<!DOCTYPE html><html class="translated-ltr" style=""><head>
<meta name="dc.identifier" content="res/131d94a011670d21b9808feeee107b006d74ae90">
<meta charset="utf-8">


<title>Coders at Work_Reflections on the Craft of Programming.Seibel2009.cn</title>
<style>div.booksection{margin-top:3em;margin-bottom:3em;margin-left:1.5em;margin-right:1.5em}.chapnum{font-family:serif;text-indent:0em;margin-left:0em;margin-right:0%;margin-top:1em;margin-bottom:2em;text-align:right}.chaptitle{font-size:270%;font-family:serif;font-style:normal;font-weight:bold;text-indent:0em;margin-left:0em;margin-right:0%;margin-top:2em;margin-bottom:1em;text-align:left;border-bottom:thin solid black}.normal{text-indent:0em;font-family:"Times New Roman",serif;font-size:100%;margin-top:0.5em;margin-bottom:0.5em;text-align:justify}.h3{font-family:"Times New Roman",serif;text-align:left;font-weight:bold;font-size:140%;margin-top:.5em;margin-bottom:.5em}.toc{font-family:"Times New Roman",serif;font-size:110%;margin-top:0.75em;margin-bottom:0.5em;padding-left:45px;text-indent:-45px;text-align:justify;font-weight:normal}.index{text-indent:0em;margin-left:0em;margin-top:0em;margin-bottom:+0em}.hangingindent{font-family:"Times New Roman",serif;font-size:100%;margin-top:0.25em;margin-bottom:0.25em;padding-left:22px;text-indent:-22px;text-align:justify}a{text-decoration:none;word-wrap:break-word}.center{font-family:"Times New Roman",serif;font-size:100%;margin-top:0.5em;margin-bottom:0.5em;text-align:center}.sidebar{margin-left:0em;margin-right:0em;font-size:95%;border-bottom:thin solid black}</style>
<style></style>
<link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>
<body>
<div id="book-container"><div id="OEBPS/Coverpage.html"><div style="margin-top:0px;margin-left:0px;margin-right:0px;margin-bottom:0px;text-align:center">

<div class="cen">
<img src="data:image/jpg;base64,/9j/4AAQSkZJRgABAgEASABIAAD/7RCgUGhvdG9zaG9wIDMuMAA4QklNA+0KUmVzb2x1dGlvbgAAAAAQAEgAAAABAAEASAAAAAEAAThCSU0EDRhGWCBHbG9iYWwgTGlnaHRpbmcgQW5nbGUAAAAABAAAAHg4QklNBBkSRlggR2xvYmFsIEFsdGl0dWRlAAAAAAQAAAAeOEJJTQPzC1ByaW50IEZsYWdzAAAACQAAAAAAAAAAAQA4QklNBAoOQ29weXJpZ2h0IEZsYWcAAAAAAQAAOEJJTScQFEphcGFuZXNlIFByaW50IEZsYWdzAAAAAAoAAQAAAAAAAAACOEJJTQP1F0NvbG9yIEhhbGZ0b25lIFNldHRpbmdzAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+BdDb2xvciBUcmFuc2ZlciBTZXR0aW5ncwAAAHAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAOEJJTQQAC0xheWVyIFN0YXRlAAAAAgABOEJJTQQCDExheWVyIEdyb3VwcwAAAAAEAAAAADhCSU0ECAZHdWlkZXMAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4NVVJMIG92ZXJyaWRlcwAAAAQAAAAAOEJJTQQaBlNsaWNlcwAAAAB1AAAABgAAAAAAAAAAAAADnQAAAlgAAAAKAFUAbgB0AGkAdABsAGUAZAAtADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAlgAAAOdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhCSU0EERFJQ0MgVW50YWdnZWQgRmxhZwAAAAEBADhCSU0EFBdMYXllciBJRCBHZW5lcmF0b3IgQmFzZQAAAAQAAAACOEJJTQQMFU5ldyBXaW5kb3dzIFRodW1ibmFpbAAADMMAAAABAAAASQAAAHAAAADcAABgQAAADKcAGAAB/9j/4AAQSkZJRgABAgEASABI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AAAAAQACAwQFBgcICQoLEAACAQMDAgQCBgcDBAIGAnMBAgMRBAAFIRIxQVEGE2EicYEUMpGhBxWxQiPBUtHhMxZi8CRygvElQzRTkqKyY3PCNUQnk6OzNhdUZHTD0uIIJoMJChgZhJRFRqS0VtNVKBry4/PE1OT0ZXWFlaW1xdXl9WZ2hpamtsbW5vY3R1dnd4eXp7fH1+f3OEhYaHiImKi4yNjo+Ck5SVlpeYmZqbnJ2en5KjpKWmp6ipqqusra6voRAAICAQIDBQUEBQYECAMDbQEAAhEDBCESMUEFURNhIgZxgZEyobHwFMHR4SNCFVJicvEzJDRDghaSUyWiY7LCB3PSNeJEgxdUkwgJChgZJjZFGidkdFU38qOzwygp0+PzhJSktMTU5PRldYWVpbXF1eX1RlZmdoaWprbG1ub2R1dnd4eXp7fH1+f3OEhYaHiImKi4yNjo+DlJWWl5iZmpucnZ6fkqOkpaanqKmqq6ytrq+v/aAAwDAQACEQMRAD8AFzTzetL++f7bftHx+eb564BT9eb/AH8//BHCtO9eb/fz/wDBHFad683+/n/4I4rTvXm/38//AARxWnevN/v5/wDgjitO9eb/AH8//BHFad683+/n/wCCOK0715v9/P8A8EcVp3rzf7+f/gjitO9eb/fz/wDBHFad683+/n/4I4rTvXm/38//AARxWnevN/v5/wDgjitO9eb/AH8//BHFad683+/n/wCCOK0715v9/P8A8EcVp3rzf7+f/gjitO9eb/fz/wDBHFad683+/n/4I4rTvXm/38//AARxWnevN/v5/wDgjitO9eb/AH8//BHFad683+/n/wCCOK0715v9/P8A8EcVp3rzf7+f/gjitO9eb/fz/wDBHFad683+/n/4I4rTvXm/38//AARxWnevN/v5/wDgjitO9eb/AH8//BHFad683+/n/wCCOK0715v9/P8A8EcVp3rzf7+f/gjitO9eb/fz/wDBHFad683+/n/4I4rTvXm/38//AARxWnevN/v5/wDgjitO9eb/AH8//BHFad683+/n/wCCOK0715v9/P8A8EcVp3rzf7+f/gjitO9eb/fz/wDBHFad683+/n/4I4rTvXm/38//AARxWnevN/v5/wDgjitO9eb/AH8//BHFad683+/n/wCCOK0715v9/P8A8EcVp3rzf7+f/gji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4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9/wCXM8u/9J0f9cf+Tf8AtF/ygZ/9IV/M4+8O/wCV3fk9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4kcsYoXFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FURaf712n/GeP/iYyUeY97PH9Q9776bqfnnavppawIdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdiqItf96rb/jKn/EhiVPJ/9f4K33+9t5/xnk/4kcsYoXFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FURaf712n/GeP/iYyUeY97PH9Q9776bqfnnavppawIdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdiqItf96rb/jKn/EhiVPJ/9D4K33+9t5/xnk/4kcsYoXFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FURaf712n/GeP/iYyUeY97PH9Q9776bqfnnavppawIdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdiqItf96rb/jKn/EhiVPJ/9H4K33+9t5/xnk/4kcsYoXFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FURaf712n/GeP/iYyUeY97PH9Q9776bqfnnavppawIdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdiqItf96rb/jKn/EhiVPJ/9L4K33+9t5/xnk/4kcsYoXFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FURaf712n/GeP/iYyUeY97PH9Q9776bqfnnavppawIdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdiqItf96rb/jKn/EhiVPJ/9P4K33+9t5/xnk/4kcsYoXFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FURaf712n/GeP/iYyUeY97PH9Q9776bqfnnavppawIdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdiqItf96rb/jKn/EhiVPJ/9T4K33+9t5/xnk/4kcsYoXFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FURaf712n/GeP/iYyUeY97PH9Q9776bqfnnavppawIdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdiqItf96rb/jKn/EhiVPJ/9X4K33+9t5/xnk/4kcsYoXFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FURaf712n/GeP/iYyUeY97PH9Q9776bqfnnavppawIdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdiqItf96rb/jKn/EhiVPJ/9b4K33+9t5/xnk/4kcsYoXFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FURaf712n/GeP/iYyUeY97PH9Q9776bqfnnavppawIdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdiqItf96rb/jKn/EhiVPJ/9f4K33+9t5/xnk/4kcsYoXFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FURaf712n/GeP/iYyUeY97PH9Q9776bqfnnavppawIdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdiqItf96rb/jKn/EhiVPJ/9D4K33+9t5/xnk/4kcsYoXFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FURaf712n/GeP/iYyUeY97PH9Q9776bqfnnavppawIdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdiqItf96rb/jKn/EhiVPJ/9H4K33+9t5/xnk/4kcsYoXFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FURaf712n/GeP/iYyUeY97PH9Q9776bqfnnavppawIdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdiqItf96rb/jKn/EhiVPJ/9L4K33+9t5/xnk/4kcsYoXFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FURaf712n/GeP/iYyUeY97PH9Q9776bqfnnavppawIdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdiqItf96rb/jKn/EhiVPJ/9P4K33+9t5/xnk/4kcsYoXFXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FURaf712n/GeP/iYyUeY97PH9Q9776bqfnnavppawIdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdiqItf96rb/jKn/EhiVPJ/9T4K33+9t5/xnk/4kcsYoXFXYq7FXYq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fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVd6kn87fecVW8m/mP34odyb+Y/firuTfzH78Vdyb+Y/firuTfzH78Vdyb+Y/firuTfzH78Vdyb+Y/firuTfzH78Vdyb+Y/firuTfzH78Vdyb+Y/firuTfzH78Vdyb+Y/firuTfzH78Vdyb+Y/firuTfzH78Vdyb+Y/firuTfzH78Vdyb+Y/firuTfzH78Vdyb+Y/firuTfzH78Vdyb+Y/firuTfzH78Vdyb+Y/firuTfzH78Vdyb+Y/firuTfzH78Vdyb+Y/firuTfzH78Vdyb+Y/firuTfzH78Vdyb+Y/firuTfzH78Vdyb+Y/firuTfzH78VVYGb1ofiP217++BS//9Jef++m/wBdv15v3rgpYpdirsVdirsVdirsVdirsVdirsVdiqFvb6y020nv9RvINPsbVedze3MixRRrWnJ3chVFT3OAmkEgCygtK8waBryNJoeu6drSJu7WF1FcUHSp9JmpiJA8iiM4y5EFN8LJ2Ku64qxC4/MHyDaTzWt3548v2tzbu0dxby6lapJG6GjKytICCCKEHIeJHvDUc2Mc5D5sntLu1v7aC9sbmK9srpBLa3cDrJFKjdGR1JDA9iDkgbbAQRYRGFLuuKsQn/MHyDazzWtz558v291bu0VxbS6lapJG6GjIymQEEEUIOQ8SPeGo5sY/iHzVrDzz5J1W8g07S/OOh6lqF0SttY2uoW000hALEJGkhZiACdhhE4nkUxzQkaEgT72U5JsdiqDv9Q0/SrSbUNUvrfTbC3ANxfXUqwwxgkKOUjkKKkgbnASBzQZACzskNl578j6ndwWGm+c9C1C/um4WtlbajbSzSN/KiJIWY+wGATieoYDNAmhIE+9lWSbHYq7rsOuKsfsfNvlTVLp7HTPN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" height="100%" alt="覆盖">
</div>
</div></div>
<div id="OEBPS/Titlepage.html"><div style="margin-top:0px;margin-left:0px;margin-right:0px;margin-bottom:0px;text-align:center">

<div class="cen">
<img src="data:image/jpg;base64,/9j/4AAQSkZJRgABAgEASABIAAD/7QlkUGhvdG9zaG9wIDMuMAA4QklNA+0KUmVzb2x1dGlvbgAAAAAQAEgAAAABAAEASAAAAAEAAThCSU0EDRhGWCBHbG9iYWwgTGlnaHRpbmcgQW5nbGUAAAAABAAAAHg4QklNBBkSRlggR2xvYmFsIEFsdGl0dWRlAAAAAAQAAAAeOEJJTQPzC1ByaW50IEZsYWdzAAAACQAAAAAAAAAAAQA4QklNBAoOQ29weXJpZ2h0IEZsYWcAAAAAAQAAOEJJTScQFEphcGFuZXNlIFByaW50IEZsYWdzAAAAAAoAAQAAAAAAAAACOEJJTQP1F0NvbG9yIEhhbGZ0b25lIFNldHRpbmdzAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+BdDb2xvciBUcmFuc2ZlciBTZXR0aW5ncwAAAHAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAOEJJTQQAC0xheWVyIFN0YXRlAAAAAgABOEJJTQQCDExheWVyIEdyb3VwcwAAAAAEAAAAADhCSU0ECAZHdWlkZXMAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4NVVJMIG92ZXJyaWRlcwAAAAQAAAAAOEJJTQQaBlNsaWNlcwAAAAB1AAAABgAAAAAAAAAAAAACvAAAAfUAAAAKAFUAbgB0AGkAdABsAGUAZAAtADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAfUAAAK8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhCSU0EERFJQ0MgVW50YWdnZWQgRmxhZwAAAAEBADhCSU0EFBdMYXllciBJRCBHZW5lcmF0b3IgQmFzZQAAAAQAAAACOEJJTQQMFU5ldyBXaW5kb3dzIFRodW1ibmFpbAAABYcAAAABAAAAUAAAAHAAAADwAABpAAAABWsAGAAB/9j/4AAQSkZJRgABAgEASABI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irsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdir//W+/mKuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv/9f7+Yq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq//0Pv5irsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdir//R+/mKuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv/9L7+Yq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq//0/v5irsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdir//U+/mKuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv/9X7+Yq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq//1vv5irsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdir//X+/mKuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv/9D7+Yq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq//0fv5irsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdir//S+/mKuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv/9P7+Yq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq//1Pv5irsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdir//V+/mKuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv/9b7+Yq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq//1/v5irsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdir//Q+/mKuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv/9H7+Yq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq//0vv5irsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdir//T+/mKuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv/9T7+Yq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq//1fv5irsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdir//W+/mKuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv/9f7+Yq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq//0Pv5irsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdir//R+/mKuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv/9L7+Yq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq//0/v5irsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdir//U+/mKuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv/9X7+Yq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq//1vv5irsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdir//X+/mKuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv/9D7+Yq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq//0fv5irsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdir//S+/mKuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv/9P7+Yq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq//1Pv5irsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdir//V+/mKuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv/9b7+Yq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq//1/v5irsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdir//Q+/mKuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv/9H7+Yq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq//0vv5irsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdir//T+/mKuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv/9T7+Yq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq//1fv5irsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdir//W+/mKuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv/9f7+Yq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq//0Pv5irsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsV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" height="100%" alt="标题">
</div>
</div></div>
<div id="OEBPS/Copyright.html"><div>

<div class="booksection">
<p></p>
<p class="normal"><b><i>编码员在工作</i></b></p><p class="normal"><b><i>Coders at Work</i></b></p>
<p class="normal">版权所有 © 2009 Peter Seibel</p><p class="normal">Copyright © 2009 by Peter Seibel</p>
<p class="normal">版权所有。未经版权所有者和出版商事先书面许可，不得以任何形式或通过任何电子或机械方式（包括影印、录音）或通过任何信息存储或检索系统复制或传播本作品的任何部分。</p><p class="normal">All rights reserved. No part of this work may be reproduced or transmitted in any form or by any means, electronic or mechanical, including photocopying, recording, or by any information storage or retrieval system, without the prior written permission of the copyright owner and the publisher.</p>
<p class="normal">ISBN-13 (pbk): 978-1-4302-1948-4 <br><br>ISBN-13 (electronic): 978-1-4302-1949-1</p><p class="normal">ISBN-13 (pbk): 978-1-4302-1948-4<br><br>ISBN-13 (electronic): 978-1-4302-1949-1</p>
<p class="normal">在美利坚合众国 (POD) 印刷和装订</p><p class="normal">Printed and bound in the United States of America (POD)</p>
<p class="normal">本书中可能会出现商标名称、徽标和图像。我们不是在每次出现商标名称、徽标或图像时都使用商标符号，而是仅以编辑方式使用名称、徽标和图像，并为了商标所有者的利益，无意侵犯商标。</p><p class="normal">Trademarked names, logos, and images may appear in this book. Rather than use a trademark symbol with every occurrence of a trademarked name, logo, or image we use the names, logos, and images only in an editorial fashion and to the benefit of the trademark owner, with no intention of infringement of the trademark.</p>
<p class="normal">本出版物中使用的商号、商标、服务标记和类似术语，即使它们未被标识为此类术语，也不应被视为对它们是否受专有权利约束的意见表达。</p><p class="normal">The use in this publication of trade names, trademarks, service marks, and similar terms, even if they are not identified as such, is not to be taken as an expression of opinion as to whether or not they are subject to proprietary rights.</p>
<p class="normal">总裁兼出版商：Paul Manning<br><br>主编：Jeffrey Pepper<br><br>技术审稿人：John Vacca<br><br>编辑委员会：Steve Anglin、Mark Beckner、Ewan Buckingham、Gary Cornell、Jonathan <br><br>&nbsp;&nbsp;&nbsp;&nbsp;Gennick、Jonathan Hassell、Michelle Lowman、Matthew Moodie、Jeffrey Pepper、<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Ben Renow-Clarke , Dominic Shakeshaft, Matt Wade, Tom Welsh<br><br>统筹编辑：Anita Castro<br><br>文案编辑：Candace English<br><br>封面设计师：Anna Ishschenko</p><p class="normal">President and Publisher: Paul Manning<br><br>Lead Editor: Jeffrey Pepper<br><br>Technical Reviewer: John Vacca<br><br>Editorial Board: Steve Anglin, Mark Beckner, Ewan Buckingham, Gary Cornell, Jonathan<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Gennick, Jonathan Hassell, Michelle Lowman, Matthew Moodie, Jeffrey Pepper,<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Ben Renow-Clarke, Dominic Shakeshaft, Matt Wade, Tom Welsh<br><br>Coordinating Editor: Anita Castro<br><br>Copy Editor: Candace English<br><br>Cover Designer: Anna Ishschenko</p>
<p class="normal">由 Springer Science+Business Media, LLC., 233 Spring Street, 6th Floor, New York, NY 10013 分发给全球图书贸易。电话 1-800-SPRINGER，传真 201-348-4505，电子邮件<code><a href="#OEBPS/mailto:orders-ny@springer-sbm.com">orders-ny@springer-sbm.com</a></code>，或访问<code><a href="http://www.springeronline.com/">www.springeronline.com</a></code>。</p><p class="normal">Distributed to the book trade worldwide by Springer Science+Business Media, LLC., 233 Spring Street, 6th Floor, New York, NY 10013. Phone 1-800-SPRINGER, fax 201-348-4505, e-mail <code><a href="#OEBPS/mailto:orders-ny@springer-sbm.com">orders-ny@springer-sbm.com</a></code>, or visit <code><a href="http://www.springeronline.com">www.springeronline.com</a></code>.</p>
<p class="normal">有关翻译的信息，请发送电子邮件至 联系我们<code><a href="#OEBPS/mailto:info@apress.com">info@apress.com</a></code>，或访问<code><a href="http://www.apress.com/">www.apress.com</a></code>。</p><p class="normal">For information on translations, please contact us by e-mail at <code><a href="#OEBPS/mailto:info@apress.com">info@apress.com</a></code>, or visit <code><a href="http://www.apress.com">www.apress.com</a></code>.</p>
<p class="normal">Apress 和 ED 书籍的朋友可以批量购买用于学术、企业或促销用途。电子书版本和许可证也适用于大多数图书。有关详细信息，请参阅我们的特别批量销售 - 电子书许可网页，网址为<code><a href="http://www.apress.com/info/bulksales">www.apress.com/info/bulksales</a></code>。</p><p class="normal">Apress and friends of ED books may be purchased in bulk for academic, corporate, or promotional use. eBook versions and licenses are also available for most titles. For more information, reference our Special Bulk Sales–eBook Licensing web page at <code><a href="http://www.apress.com/info/bulksales">www.apress.com/info/bulksales</a></code>.</p>
<p class="normal">本书中的信息按“原样”发布，不提供任何保证。尽管在准备本作品时已采取一切预防措施，但作者和 Apress 均不对任何个人或实体因所含信息直接或间接造成或据称造成的任何损失或损害承担任何责任在这项工作中。</p><p class="normal">The information in this book is distributed on an “as is” basis, without warranty. Although every precaution has been taken in the preparation of this work, neither the author(s) nor Apress shall have any liability to any person or entity with respect to any loss or damage caused or alleged to be caused directly or indirectly by the information contained in this work.</p>
</div>
</div></div>
<div id="OEBPS/Dedication.html"><div>

<div class="booksection">
<p></p>
<p class="center"><i>为了阿米莉亚</i></p><p class="center"><i>For Amelia</i></p>
</div>
</div></div>
<div id="OEBPS/Contents.html"><div>

<div class="booksection">
<p></p>
<h2 class="chaptitle"><a id="OEBPS/Contents.html.contents"></a>内容</h2><h2 class="chaptitle"><a></a>Contents</h2>
<p class="toc"><a href="#OEBPS/Abouttheauthor.html"><b>关于作者</b></a></p><p class="toc"><a href="#OEBPS/Abouttheauthor.html"><b>About the Author</b></a></p>
<p class="toc"><a href="#OEBPS/Acknowledgments.html"><b>致谢</b></a></p><p class="toc"><a href="#OEBPS/Acknowledgments.html"><b>Acknowledgments</b></a></p>
<p class="toc"><a href="#OEBPS/Introduction.html"><b>介绍</b></a></p><p class="toc"><a href="#OEBPS/Introduction.html"><b>Introduction</b></a></p>
<p class="toc"><a href="#OEBPS/Chapter01.html"><b>第 1 章：</b>杰米·扎温斯基</a></p><p class="toc"><a href="#OEBPS/Chapter01.html"><b>Chapter 1:</b> Jamie Zawinski</a></p>
<p class="toc"><a href="#OEBPS/Chapter02.html"><b>第 2 章：</b>布拉德·菲茨帕特里克</a></p><p class="toc"><a href="#OEBPS/Chapter02.html"><b>Chapter 2:</b> Brad Fitzpatrick</a></p>
<p class="toc"><a href="#OEBPS/Chapter03.html"><b>第 3 章：</b>道格拉斯·克罗克福德</a></p><p class="toc"><a href="#OEBPS/Chapter03.html"><b>Chapter 3:</b> Douglas Crockford</a></p>
<p class="toc"><a href="#OEBPS/Chapter04.html"><b>第 4 章：</b>布伦丹·艾奇</a></p><p class="toc"><a href="#OEBPS/Chapter04.html"><b>Chapter 4:</b> Brendan Eich</a></p>
<p class="toc"><a href="#OEBPS/Chapter05.html"><b>第 5 章：</b>约书亚布洛赫</a></p><p class="toc"><a href="#OEBPS/Chapter05.html"><b>Chapter 5:</b> Joshua Bloch</a></p>
<p class="toc"><a href="#OEBPS/Chapter06.html"><b>第 6 章：</b>乔·阿姆斯特朗</a></p><p class="toc"><a href="#OEBPS/Chapter06.html"><b>Chapter 6:</b> Joe Armstrong</a></p>
<p class="toc"><a href="#OEBPS/Chapter07.html"><b>第 7 章：</b>西蒙·佩顿·琼斯</a></p><p class="toc"><a href="#OEBPS/Chapter07.html"><b>Chapter 7:</b> Simon Peyton Jones</a></p>
<p class="toc"><a href="#OEBPS/Chapter08.html"><b>第8章：</b>彼得·诺维格</a></p><p class="toc"><a href="#OEBPS/Chapter08.html"><b>Chapter 8:</b> Peter Norvig</a></p>
<p class="toc"><a href="#OEBPS/Chapter09.html"><b>第9章：</b>盖伊·Steele</a></p><p class="toc"><a href="#OEBPS/Chapter09.html"><b>Chapter 9:</b> Guy Steele</a></p>
<p class="toc"><a href="#OEBPS/Chapter10.html"><b>第 10 章：</b>丹·英格尔斯</a></p><p class="toc"><a href="#OEBPS/Chapter10.html"><b>Chapter 10:</b> Dan Ingalls</a></p>
<p class="toc"><a href="#OEBPS/Chapter11.html"><b>第 11 章：</b> L Peter Deutsch</a></p><p class="toc"><a href="#OEBPS/Chapter11.html"><b>Chapter 11:</b> L Peter Deutsch</a></p>
<p class="toc"><a href="#OEBPS/Chapter12.html"><b>第12章：</b>肯·汤普森</a></p><p class="toc"><a href="#OEBPS/Chapter12.html"><b>Chapter 12:</b> Ken Thompson</a></p>
<p class="toc"><a href="#OEBPS/Chapter13.html"><b>第13章：</b>弗兰·艾伦</a></p><p class="toc"><a href="#OEBPS/Chapter13.html"><b>Chapter 13:</b> Fran Allen</a></p>
<p class="toc"><a href="#OEBPS/Chapter14.html"><b>第 14 章：</b>伯尼·科塞尔</a></p><p class="toc"><a href="#OEBPS/Chapter14.html"><b>Chapter 14:</b> Bernie Cosell</a></p>
<p class="toc"><a href="#OEBPS/Chapter15.html"><b>第 15 章：</b>唐纳德·高德纳 ( Donald Knuth)</a></p><p class="toc"><a href="#OEBPS/Chapter15.html"><b>Chapter 15:</b> Donald Knuth</a></p>
<p class="toc"><a href="#OEBPS/Appendix.html"><b>附录 A：</b>参考书目</a></p><p class="toc"><a href="#OEBPS/Appendix.html"><b>Appendix A:</b> Bibliography</a></p>
<p class="toc"><a href="#OEBPS/Index.html"><b>指数</b></a></p><p class="toc"><a href="#OEBPS/Index.html"><b>Index</b></a></p>
</div>
</div></div>
<div id="OEBPS/Abouttheauthor.html"><div>

<div class="booksection">
<p></p>
<h2 class="chaptitle"><a id="OEBPS/Abouttheauthor.html.abouttheauthor"></a>关于作者</h2><h2 class="chaptitle"><a></a>About the Author</h2>
<p class="normal">Peter Seibel 要么是作家转为程序员，要么是程序员转为作家。在获得英语本科学位并短暂担任记者后，他被网络所吸引。<i>在 20 世纪 90 年代初期，他为Mother Jones Magazine</i>和 Organic Online开发了 Perl 。他作为 WebLogic 的早期员工参与了 Java 革命，后来在 UC Berkeley Extension 教授 Java 编程。2003 年，他辞去了基于 Java 的事务性消息传递系统架构师的工作，计划用一年时间破解 Lisp。相反，他最终花了两年时间编写了获得 Jolt 生产力奖的<i>Practical Common Lisp</i>. 从那以后，他一直在 Gigamonkeys Consulting 担任首席猴子，学习训练小鸡、打太极拳和当爸爸。他与妻子 Lily、女儿 Amelia 和狗 Mahlanie 住在加利福尼亚州的伯克利。</p><p class="normal">Peter Seibel is either a writer turned programmer or programmer turned writer. After picking up an undergraduate degree in English and working briefly as a journalist, he was seduced by the web. In the early '90s he hacked Perl for <i>Mother Jones Magazine</i> and Organic Online. He participated in the Java revolution as an early employee at WebLogic and later taught Java programming at UC Berkeley Extension. In 2003 he quit his job as the architect of a Java-based transactional messaging system, planning to hack Lisp for a year. Instead he ended up spending two years writing the Jolt Productivity Award–winning <i>Practical Common Lisp</i>. Since then he's been working as chief monkey at Gigamonkeys Consulting, learning to train chickens, practicing Tai Chi, and being a dad. He lives in Berkeley, California, with his wife Lily, daughter Amelia, and dog Mahlanie.</p>
</div>
</div></div>
<div id="OEBPS/Acknowledgments.html"><div>

<div class="booksection">
<p></p>
<h2 class="chaptitle"><a id="OEBPS/Acknowledgments.html.acknowledgments"></a>致谢</h2><h2 class="chaptitle"><a></a>Acknowledgments</h2>
<p class="normal">首先，我要感谢我的研究对象，他们慷慨地付出了他们的时间，没有他们，这本书将只是一本没有答案的小册子。还要感谢 Joe Armstrong 和 Bernie Cosell 以及他们的家人，感谢他们为我提供了在斯德哥尔摩和弗吉尼亚的住宿地点。还要特别感谢 Peter Norvig 和 Jamie Zawinski，他们除了轮流对着我的录音机讲话外，还帮助我与其他成为我主题的人取得联系。</p><p class="normal">First of all I want to thank my subjects who gave generously of their time and without whom this book would be nothing but a small pamphlet of unanswered questions. Additional thanks go to Joe Armstrong and Bernie Cosell, and their families, for giving me a place to stay in Stockholm and Virginia. Extra thanks also go to Peter Norvig and Jamie Zawinski who, in addition to taking their own turns speaking into my recorders, helped me get in touch with other folks who became my subjects.</p>
<p class="normal">当我环游世界进行采访时，其他几个家庭也欢迎我到他们的家中：感谢他们的盛情款待去波士顿的 Dan Weinreb 和 Cheryl Moreau，感谢英国剑桥的 Gareth 和 Emma McCaughan，以及我自己的父母，他们提供了纽约市的大型运营基地。克里斯托夫·罗兹 (Christophe Rhodes) 帮我打发了一些面试间隙的空闲时间，让我参观了剑桥大学，他和戴夫·福克斯 (Dave Fox) 用晚餐和参观坎塔布里吉安酒吧结束了这个晚上。</p><p class="normal">As I traveled around the world conducting interviews several other families also welcomed me into their homes: thanks for their hospitality go to Dan Weinreb and Cheryl Moreau in Boston, to Gareth and Emma McCaughan in Cambridge, England, and to my own parents who provided a great base of operations in New York city. Christophe Rhodes helped me fill some free time between interviews with a tour of Cambridge University and he and Dave Fox rounded out the evening with dinner and a tour of Cantabrigian pubs.</p>
<p class="normal">丹·温瑞布 (Dan Weinreb) 除了是我在波士顿的主持人之外，自从我还在收集潜在主题的名字以来，他就是我对本书各个方面最勤奋的审阅者。Zach Beane、Luke Gorrie、Dave Walden 和我妈妈也都阅读了章节并提供了适时的鼓励。另外，扎克——就像现在我的书的传统做法一样——在封面上提供了一些文字；这次是书的副标题。Alan Kay 提出了很好的建议，包括 Dan Ingalls 和 L Peter Deutsch。Scott Fahlman 给了我一些关于 Jamie Zawinski 早期职业生涯的有用背景，Dave Walden 寄来了关于 Bolt Beranek 和 Newman 的历史材料，帮助我准备采访 Bernie Cosell。对于我忘记的任何人，您仍然要感谢和道歉。</p><p class="normal">Dan Weinreb, in addition to being my Boston host, has been my most diligent reviewer of all aspects of the the book since the days when I was still gathering names of potential subjects. Zach Beane, Luke Gorrie, Dave Walden and my mom also all read chapters and provided well-timed encouragement. Zach additionally—as is now traditional with my books—provided some words to go on the cover; this time the book's subtitle. Alan Kay made the excellent suggestion to include Dan Ingalls and L Peter Deutsch. Scott Fahlman gave me some useful background on Jamie Zawinski's early career and Dave Walden sent historical materials on Bolt Beranek and Newman to help me prepare for my interview with Bernie Cosell. To anyone I have forgotten, you still have my thanks and also my apologies.</p>
<p class="normal">感谢 Apress 的同事，特别是首先建议我写这本书的 Gary Cornell，感谢 John Vacca 和 Michael Banks 的建议，以及我的文字编辑 Candace English，他们修正了无数错误。</p><p class="normal">Thanks to the folks at Apress, especially Gary Cornell who first suggested I do this book, John Vacca and Michael Banks for their suggestions, and my copy editor Candace English who fixed innumerable errors.</p>
<p class="normal">最后，最深切地感谢我的家庭，大家庭和核心家庭。我的亲生妈妈和姻亲妈妈都来看望孩子，让我完成一些额外的工作；我的父母给了我的妻子和孩子一个星期的避难所，这样我就可以再次努力。最重要的是，感谢我的妻子和孩子：Lily 和 Amelia，虽然我可能偶尔需要一些时间来完成这项工作，但如果我的生活中没有你们，那将是不值得做的。我爱你。</p><p class="normal">Finally, deepest thanks to my family, extended and nuclear. Both of my moms, biological and in-law, came on visits to watch the the kid and let me get some extra work done; my parents gave my wife and kid a place to escape for a week so I could make another big push. And most of all, thanks to the wife and kid themselves: Lily and Amelia, while I may occasionally need some time to myself to do the work, without you guys in my life, it wouldn't be worth doing. I love you.</p>
</div>
</div></div>
<div id="OEBPS/Introduction.html"><div>

<div class="booksection">
<p></p>
<h2 class="chaptitle"><a id="OEBPS/Introduction.html.introduction"></a>介绍</h2><h2 class="chaptitle"><a></a>Introduction</h2>
<p class="normal">撇开 Ada Lovelace 的工作不谈——这位 19 世纪的伯爵夫人为 Charles Babbage 从未完成的分析引擎设计了算法——计算机编程作为一项人类努力存在的时间还不到一个人的一生：距 Konrad Zuse 公布他的计算机编程仅 68 年1941 年的 Z3 机电计算机，第一台工作通用计算机。自六名女性——凯·安东内利、让·巴蒂克、贝蒂·霍尔伯顿、马林·梅尔策、弗朗西斯·斯宾塞和露丝·泰特鲍姆——被从美国陆军“计算机军团”中撤出仅仅 64 年，这些女性计算弹道表另一方面，成为第一台通用电子计算机 ENIAC 的第一批程序员。今天有很多人活着——婴儿潮一代的前沿人物和所有婴儿潮一代的人</p><p class="normal">Leaving aside the work of Ada Lovelace—the 19th century countess who devised algorithms for Charles Babbage's never-completed Analytical Engine—computer programming has existed as a human endeavor for less than one human lifetime: it has been only 68 years since Konrad Zuse unveiled his Z3 electro-mechanical computer in 1941, the first working general-purpose computer. And it's been only 64 years since six women—Kay Antonelli, Jean Bartik, Betty Holberton, Marlyn Meltzer, Frances Spence, and Ruth Teitelbaum—were pulled from the ranks of the U.S. Army's “computer corps”, the women who computed ballistics tables by hand, to become the first programmers of ENIAC, the first general-purpose electronic computer. There are many people alive today—the leading edge of the Baby Boom generation and all of the Boomers' parents—who were born into a world without computer programmers.</p>
<p class="normal">当然没有了。现在世界上到处都是程序员。根据美国劳工统计局的数据，2008 年美国大约每 106 名工人中就有一名（超过 125 万人）是计算机程序员或软件工程师。这还不包括美国以外的专业程序员，也不包括许多学生和业余程序员，以及他们的正式工作是其他工作但花费一些甚至大量时间试图让计算机屈服于他们的意志的人。然而，尽管有数百万人编写了代码，并且自该领域开始以来编写了数十亿甚至数万亿行代码，但我们仍然经常感觉我们仍在编造代码。人们仍在争论什么是编程：数学还是工程学？手工艺、艺术、还是科学？我们当然会争论——通常非常激烈——关于最好的方法：互联网上充斥着关于这种或那种编写代码方式的博客文章和论坛帖子。书店里堆满了关于新编程语言、新方法论和思考编程任务的新方法的书籍。</p><p class="normal">No more, of course. Now the world is awash in programmers. According to the Bureau of Labor Statistics, in the United States in 2008 approximately one in every 106 workers—over 1.25 million people—was a computer programmer or software engineer. And that doesn't count professional programmers outside the U.S. nor the many student and hobbyist programmers and people whose official job is something else but who spend some or even a lot of their time trying to bend a computer to their will. Yet despite the millions of people who have written code, and the billions, if not trillions of lines of code written since the field began, it still often feels like we're still making it up as we go along. People still argue about what programming is: mathematics or engineering? Craft, art, or science? We certainly argue—often with great vehemence—about the best way to do it: the Internet overflows with blog articles and forum postings about this or that way of writing code. And bookstores are chock-a-block with books about new programming languages, new methodologies, new ways of thinking about the task of programming.</p>
<p class="normal">这本书采用不同的方法来理解什么是编程，遵循文学杂志<i>《巴黎评论》</i>派出两位教授采访小说家 EM Forster 的传统，这是一系列问答访谈中的第一个，后来收录在<i>Writers at工作</i>。</p><p class="normal">This book takes a different approach to getting at what programming is, following in the tradition established when the literary journal <i>The Paris Review</i> sent two professors to interview the novelist E.M. Forster, the first in a series of Q&amp;A interviews later collected in the book <i>Writers at Work</i>.</p>
<p class="normal">我与 15 名在该领域拥有广泛经验的非常有成就的程序员坐了下来，他们是系统黑客，例如 Unix 的发明者 Ken Thompson 和 ARPANET 的最初实现者之一 Bernie Cosell；将强大的学历与黑客信誉相结合的程序员，例如 Donald Knuth、Guy Steele 和 Simon Peyton Jones；IBM 的 Fran Allen、爱立信的 Joe Armstrong 和谷歌的 Peter Norvig 等工业研究人员；施乐 PARC 校友 Dan Ingalls 和 L Peter Deutsch；Netscape 的早期实现者 Jamie Zawinski 和 Brendan Eich；参与当今网络语言设计和实施的人员，Eich 以及 Douglas Crockford 和 Joshua Bloch；和 Live Journal 的发明者 Brad Fitzpatrick，</p><p class="normal">I sat down with fifteen highly accomplished programmers with a wide range of experiences in the field—heads down systems hackers such as Ken Thompson, inventor of Unix, and Bernie Cosell, one of the original implementers of the ARPANET; programmers who combine strong academic credentials with hacker cred such as Donald Knuth, Guy Steele, and Simon Peyton Jones; industrial researchers such as Fran Allen of IBM, Joe Armstrong of Ericsson, and Peter Norvig at Google; Xerox PARC alumni Dan Ingalls and L Peter Deutsch; early Netscape implementers Jamie Zawinski and Brendan Eich; folks involved in the design and implementation of the languages the present-day web, Eich again as well as Douglas Crockford and Joshua Bloch; and Brad Fitzpatrick, inventor of Live Journal, and an able representative of the generation of programmers who came of age with the Web.</p>
<p class="normal">我向这些人询问了有关编程的问题：他们是如何学会编程的，他们一路上发现了什么，以及他们对编程的未来有何看法。更具体地说，我试图让他们谈论程序员一直在努力解决的问题：我们应该如何设计软件？编程语言在帮助我们提高工作效率或避免错误方面扮演什么角色？有没有什么方法可以让我们更轻松地追踪难以发现的错误？</p><p class="normal">I asked these folks about programming: how they learned to do it, what they've discovered along the way, and what they think about its future. More particularly, I tried to get them to talk about the issues that programmers wrestle with all the time: How should we design software? What role do programming languages play in helping us be productive or avoid errors? Are there ways we can make it easier to track down hard-to-find bugs?</p>
<p class="normal">由于这些问题远未解决，因此我的研究对象有时会有截然不同的意见，这也许不足为奇。Jamie Zawinski 和 Dan Ingalls 强调了立即启动和运行代码的重要性，而 Joshua Bloch 描述了他如何设计 API 并测试它们是否可以支持他在执行任何实现之前针对它们编写的代码，Donald Knuth 描述了他如何编写在他开始输入任何代码之前，他用铅笔用铅笔完成了他的排版软件 TeX 的完整版本。尽管 Fran Allen 将近几十年来人们对计算机科学的兴趣下降归咎于 C，Bernie Cosell 称这是“现代计算机面临的最大安全问题”，但 Ken Thompson 认为安全问题是由程序员, 不是他们的编程语言，Donald Knuth 将 C 对指针的使用描述为他所见过的“最惊人的符号改进”之一。我的一些研究对象嘲笑形式证明可能有助于提高软件质量的观点，但 Guy Steele 很好地说明了它们的力量和局限性。</p><p class="normal">As these are far from settled questions, it's perhaps unsurprising that my subjects sometimes had quite varied opinions. Jamie Zawinski and Dan Ingalls emphasized the importance of getting code up and running right away while Joshua Bloch described how he designs APIs and tests whether they can support the code he wants to write against them before he does any implementation and Donald Knuth described how he wrote a complete version of his typesetting software TeX in pencil before he started typing in any code. And while Fran Allen lay much of the blame for the decline in interest in computer science in recent decades at the feet of C and Bernie Cosell called it the “biggest security problem to befall modern computers”, Ken Thompson argued that security problems are caused by programmers, not their programming languages and Donald Knuth described C's use of pointers as one of the “most amazing improvements in notation” he's seen. Some of my subjects scoffed at the notion that formal proofs could be useful in improving the quality of software, but Guy Steele gave a very nice illustration of both their power and their limitations.</p>
<p class="normal">然而，有一些共同的主题：几乎每个人都强调编写可读代码的重要性；我的大多数受试者都发现最难追踪的错误出现在并发代码中；似乎没有人认为编程是一个已解决的问题：大多数人仍在寻找一种更好的软件编写方法，无论是通过寻找自动分析代码的方法，为程序员提供更好的协作方式，还是寻找（或设计）更好的方法编程语言。几乎每个人似乎都认为无处不在的多核 CPU 将迫使软件编写方式发生一些重大变化。</p><p class="normal">There were, however, some common themes: almost everybody emphasized the importance of writing readable code; most of my subjects have found that the hardest bugs to track down are in concurrent code; and nobody seemed to think programming is a solved problem: most are still looking for a better way to write software, whether by finding ways to automatically analyze code, coming up with better ways for programmers to work together, or finding (or designing) better programming languages. And almost everyone seemed to think that ubiquitous multi-core CPUs are going to force some serious changes in the way software is written.</p>
<p class="normal">这些对话发生在我们这个领域历史上的一个特定时刻，所以毫无疑问，本书中讨论的一些主题将从当今紧迫的问题变成历史奇闻。但即使在像编程这样年轻的领域，历史也可以为我们提供教训。除此之外，我怀疑我的主题已经分享了一些关于什么是编程以及我们如何做得更好的见解，这将对今天的程序员<i>和</i>几代人以后的程序员都有用。</p><p class="normal">These conversations took place at a particular moment in our field's history, so no doubt some of the topics discussed in this book will fade from urgent present-day issues to historical curiosities. But even in a field as young as programming, history can hold lessons for us. Beyond that, I suspect that my subjects have shared some insights into what programming is and how we could do it better that will be useful to programmers today <i>and</i> to programmers several generations from now.</p>
<p class="normal">最后，关于标题的注释：我们选择<i>Coders at Work</i>是因为它与前面提到<i>的 Paris Review 的</i> <i>Writers at Work</i>系列以及 Apress 的书<i>Founders at Work</i>产生共鸣，这本书对于创办一家技术公司的作用与这本书试图为计算机所做的一样编程。我意识到“编码”只能指代更大的编程活动中的一个相当狭窄的部分。就我个人而言，我从不相信有可能成为一名优秀的编码员而不是一名优秀的程序员，或者成为一名优秀的程序员而不是一名优秀的设计师、沟通者和思考者。当然，我所有的主题都是这些，而且更多，我相信你将要阅读的对话反映了这一点。享受！</p><p class="normal">Finally, a note on the title: we chose <i>Coders at Work</i> for its resonance with the previously mentioned <i>Paris Review's</i> <i>Writers at Work</i> series as well as Apress's book <i>Founders at Work</i>, which does for starting a technology company what this book tries to do for computer programming. I realize that “coding” could be taken to refer to only one rather narrow part of the larger activity of programming. Personally I have never believed that it is possible to be a good coder without being a good programmer nor a good programmer without being a good designer, communicator, and thinker. Certainly all of my subjects are all of those and much more and I believe the conversations you are about to read reflect that. Enjoy!</p>
</div>
</div></div>
<div id="OEBPS/Chapter01.html"><div>

<div class="booksection">
<p></p>
<h2 class="chapnum"><a id="OEBPS/Chapter01.html.ch1"></a><a id="OEBPS/Chapter01.html.page_1"></a><img src="data:image/jpg;base64,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" alt="图片"></h2><h2 class="chapnum"><a></a><a></a></h2>
<h2 class="chaptitle">杰米扎文斯基</h2><h2 class="chaptitle">Jamie Zawinski</h2>
<div class="sidebar">
<p class="normal"><i>Lisp 黑客、早期 Netscape 开发人员和夜总会老板 Jamie Zawinski（又名 jwz）是精选黑客群体中的一员，这些黑客以其三个字母的首字母和全名而为人所知。</i></p><p class="normal"><i>Lisp hacker, early Netscape developer, and nightclub owner Jamie Zawinski, a.k.a. jwz, is a member of the select group of hackers who are as well known by their three-letter initials as by their full names.</i></p>
<p class="normal"><i>Zawinski 十几岁时就开始从事程序员工作，当时他受雇于卡内基梅隆大学人工智能实验室破解 Lisp。上大学的时间刚好足以让他发现自己讨厌它后，他在 Lisp 和 AI 世界工作了将近十年，当其他同龄的程序员都是在微型计算机的陪伴下成长时，他奇怪地沉浸在日渐式微的黑客亚文化中。</i></p><p class="normal"><i>Zawinski started working as a programmer as a teenager when he was hired to hack Lisp at a Carnegie Mellon artificial intelligence lab. After attending college just long enough to discover that he hated it, he worked in the Lisp and AI world for nearly a decade, getting a strange immersion in a fading hacker subculture when other programmers his age were growing up with microcomputers.</i></p>
<p class="normal"><i>他曾在加州大学伯克利分校为 Peter Norvig 工作，Peter Norvig 称他为“我雇用过的最好的程序员之一”，后来在 Lisp 公司 Lucid 工作，在那里他最终领导了 Lucid Emacs 的开发，后来更名为 XEmacs ，最终导致了 Emacs 的大分裂，这是最著名的开源分支之一。</i></p><p class="normal"><i>He worked at UC Berkeley for Peter Norvig, who has described him as “one of the of the best programmers I ever hired,” and later at Lucid, the Lisp company, where he ended up leading the development of Lucid Emacs, later renamed XEmacs, which eventually led to the great Emacs schism, one of the most famous open source forks.</i></p>
<p class="normal"><a id="OEBPS/Chapter01.html.page_2"></a><i>1994 年，他终于离开了 Lucid 和 Lisp 世界，加入了 Netscape，这是一家刚刚起步的初创公司，他是 Unix 版 Netscape 浏览器和后来的 Netscape 邮件阅读器的最初开发者之一。</i></p><p class="normal"><a></a><i>In 1994 he finally left Lucid and the Lisp world to join Netscape, then a fledgling start-up, where he was one of the original developers of the Unix version of the Netscape browser and later of the Netscape mail reader.</i></p>
<p class="normal"><i>1998 年，Zawinski 与 Brendan Eich 一起成为 mozilla.org 的主要推动者之一，该组织将 Netscape 浏览器开源。一年后，由于发行缺乏进展而灰心丧气，他退出了这个项目并买下了旧金山的一家名为 DNA Lounge 的夜总会，现在由他经营。他目前正致力于与加州酒精饮料控制部门抗争，试图将俱乐部转变为适合所有年龄段的现场音乐表演场所。</i></p><p class="normal"><i>In 1998 Zawinski was one of the prime movers, along with Brendan Eich, behind mozilla.org, the organization that took the Netscape browser open source. A year later, discouraged by the lack of progress toward a release, he quit the project and bought a San Francisco nightclub, the DNA Lounge, which he now runs. He is currently devoting his energies to battling the California Department of Alcoholic Beverage Control in an attempt to convert the club to an all-ages venue for live music.</i></p>
<p class="normal"><i>在这次采访中，我们谈到了为什么 C++ 令人厌恶、让数百万人使用您的软件的乐趣，以及对新手程序员进行修补的重要性。</i></p><p class="normal"><i>In this interview we talked about, among other things, why C++ is an abomination, the joy of having millions of people use your software, and the importance of tinkering for budding programmers.</i></p>
</div>
<p class="normal"><b>Seibel：</b>你是如何学习编程的？</p><p class="normal"><b>Seibel:</b> How did you learn to program?</p>
<p class="normal"><b>Zawinski：</b>哇，那是很久以前的事了，我几乎记不起来了。我想我第一次真正在编程环境中使用计算机可能是在八年级。我们有一些 TRS-80 并且我们开始玩弄 BASIC。我什至不确定有没有上课——我认为这就像放学后的事情。我记得没有办法保存程序，所以你只能从杂志之类的东西中输入它们。然后我想我读了一堆书。我记得读过有关我无法运行的语言的书籍，并在纸上为我只读过的语言编写程序。</p><p class="normal"><b>Zawinski:</b> Wow, it was so long ago I can barely remember it. The first time I really used a computer in a programming context was probably like eighth grade, I think. We had some TRS-80s and we got to goof around with BASIC a little bit. I'm not sure there was even a class—I think it was just like an after-school thing. I remember there was no way to save programs so you'd just type them in from magazines and stuff like that. Then I guess I read a bunch of books. I remember reading books about languages that I had no way to run and writing programs on paper for languages that I'd only read about.</p>
<p class="normal"><b>Seibel：</b>那会是什么语言？</p><p class="normal"><b>Seibel:</b> What languages would that have been?</p>
<p class="normal"><b>Zawinski：</b>我记得 APL 是其中之一。我读了一篇关于它的文章，认为它真的很整洁。</p><p class="normal"><b>Zawinski:</b> APL, I remember, was one of them. I read an article about it and thought it was really neat.</p>
<p class="normal"><b>Seibel：</b>嗯，这样就不用花哨的键盘了。你在高中的时候上过计算机课吗？</p><p class="normal"><b>Seibel:</b> Well, it saves having to have the fancy keyboard. When you were in high school did you have any classes on computers?</p>
<p class="normal"><b>Zawinski：</b>在高中时我学习了 Fortran。就是这样。</p><p class="normal"><b>Zawinski:</b> In high school I learned Fortran. That's about it.</p>
<p class="normal"><a id="OEBPS/Chapter01.html.page_3"></a><b>Seibel：</b>不知何故，你接触到了 Lisp。</p><p class="normal"><a></a><b>Seibel:</b> And somehow you got exposed to Lisp.</p>
<p class="normal"><b>扎温斯基：</b>我读了很多科幻小说。我认为 AI 真的很棒；计算机将接管世界。所以我对此有所了解。我在高中时有一个朋友 Dan Zigmond，我们在交换书籍，所以我们都学了 Lisp。有一天，他去卡内基梅隆大学参加 Apple 用户组会议——这实际上只是一次软件交易——因为他想得到免费的东西。他正在和那里的一些大学生交谈，“哦，这是一个知道 Lisp 的 15 岁孩子；那很新颖；你应该去找 Scott Fahlman 找份工作。” 所以丹做到了。法尔曼给了他一个。然后丹说，“哦，你也应该雇用我的朋友，”那就是我。所以 Fahlman 雇用了我们。我认为他的动机必须是这样的，哇，这里有两个高中生对这个东西很感兴趣；让他们在实验室闲逛对我并没有太大的伤害。” 所以我们有基本的繁重工作——这组东西需要重新编译，因为有一个新版本的编译器；去弄清楚如何做到这一点。这真是太棒了。所以我们两个人——这两个小孩——被所有这些从事语言和人工智能研究的研究生包围着。</p><p class="normal"><b>Zawinski:</b> I read a lot of science fiction. I thought AI was really neat; the computers are going to take over the world. So I learned a little bit about that. I had a friend in high school, Dan Zigmond, and we were trading books, so we both learned Lisp. One day he went to the Apple Users Group meeting at Carnegie Mellon—which was really just a software-trading situation—because he wanted to get free stuff. And he's talking to some college student there who's like, “Oh, here's this 15-year-old who knows Lisp; that's novel; you should go ask Scott Fahlman for a job.” So Dan did. And Fahlman gave him one. And then Dan said, “Oh, you should hire my friend too,” and that was me. So Fahlman hired us. I think his motivation had to be something along the lines of, Wow, here are two high school kids who are actually interested in this stuff; it doesn't really do me much harm to let them hang out in the lab.” So we had basic grunt work—this set of stuff needs to be recompiled because there's a new version of the compiler; go figure out how to do that. Which was pretty awesome. So there are the two of us—these two little kids—surrounded by all these grad students doing language and AI research.</p>
<p class="normal"><b>Seibel：</b>那是你在 CMU 真正运行 Lisp 的第一次机会吗？</p><p class="normal"><b>Seibel:</b> Was that the first chance you actually had to run Lisp, there at CMU.</p>
<p class="normal"><b>扎温斯基：</b>我认同。我知道我们曾经在 Macintosh 上运行的 XLISP 上闲逛过。但我认为那是后来的事情。我在那里学习了如何使用这些 PERQ 工作站进行真正的编程，这些工作站是 Spice 项目的一部分，使用后来成为 CMU Common Lisp 的 Spice Lisp。这是一个如此奇怪的环境。我们会参加每周一次的会议，通过倾听了解软件开发是如何工作的。但是那个小组中有一些非常有趣的角色。就像我们的经理一样——那个一直关注我们的人——罗伯·麦克拉克伦，沃利，是一个金发巨人，长相野蛮。非常吓人的样子。而他话不多。我记得有很多次我会坐在那儿——这是一个开放式的小隔间——工作，做点什么，写一些 Lisp 程序。和他' 我光着脚，端着他的陶瓷啤酒杯拖着脚走进来，就站在我身后。我会打个招呼。他会咕哝或什么都不说。他只是站在那里看着我打字。在一些<a id="OEBPS/Chapter01.html.page_4"></a>我会做点什么，他会说，“呸，错了！” 然后他会走开。所以这有点被扔进了深渊。这就像禅宗的方法——师父用棍子打我，现在我必须打坐。</p><p class="normal"><b>Zawinski:</b> I think so. I know at one point we were goofing around with XLISP, which ran on Macintoshes. But I think that was later. I learned how to program for real there using these PERQ workstations which were part of the Spice project, using Spice Lisp which became CMU Common Lisp. It was such an odd environment. We'd go to weekly meetings, learning how software development works just by listening in. But there were some really entertaining characters in that group. Like the guy who was sort of our manager—the one keeping an eye on us—Rob MacLachlan, Wholey, was this giant blond-haired, barbarian-looking guy. Very intimidating-looking. And he didn't talk much. I remember a lot of times I'd be sitting there—it was kind of an open-plan cubicle kind of thing—working, doing something, writing some Lisp program. And he'd come shuffling in with his ceramic mug of beer, bare feet, and he'd just stand behind me. I'd say hi. And he'd grunt or say nothing. He'd just stand there watching me type. At some <a></a>point I'd do something and he'd go, “Ptthh, wrong!” and he'd walk away. So that was kind of getting thrown in the deep end. It was like the Zen approach—the master hit me with a stick, now I must meditate.</p>
<p class="normal"><b>Seibel：</b>我给 Fahlman 发了邮件，他说你很有天赋，学得很快。但他也提到你有点散漫。正如他所说，“我们试图温和地教他如何与他人一起在团队中工作，以及如何编写你或其他人一个月后就能理解的代码。” 你还记得这些教训吗？</p><p class="normal"><b>Seibel:</b> I emailed Fahlman and he said that you were talented and learned very fast. But he also mentioned that you were kind of undisciplined. As he put it, “We tried gently to teach him about working in a group with others and about writing code that you, or someone else, could understand a month from now.” Do you remember any of those lessons?</p>
<p class="normal"><b>Zawinski：</b>我猜不是学习他们。当然，最重要的事情之一就是编写您可以稍后再回来查看的代码。但我快 39 岁了，当时我才 15 岁，所以一切都有些模糊。</p><p class="normal"><b>Zawinski:</b> Not the learning of them, I guess. Certainly one of the most important things is writing code you can come back to later. But I'm about to be 39 and I was 15 at the time, so it's all a little fuzzy.</p>
<p class="normal"><b>Seibel：</b>那是从哪一年开始的？</p><p class="normal"><b>Seibel:</b> What year did that start?</p>
<p class="normal"><b>Zawinski：</b>那一定是 84 年或 85 年。我想我是从 10 年级到 11 年级的夏天开始的。高中毕业后，我会在 4:00 左右前往那里，一直待到八九点。我不认为我每天都这样做，但我在那里的次数相当多。</p><p class="normal"><b>Zawinski:</b> That must have been '84 or '85. I think I started in the summer between 10th and 11th grade. After high school, at 4:00 or so I'd head over there and stay until eight or nine. I don't think I did that every day but I was there a fair amount.</p>
<p class="normal"><b>Seibel：</b>高中毕业后，你曾短暂地去了 CMU。</p><p class="normal"><b>Seibel:</b> And you very briefly went to CMU after you finished high school.</p>
<p class="normal"><b>扎文斯基：</b>是的。发生的事情是，我讨厌高中。那是我一生中最糟糕的时光。当我即将毕业时，我问 Fahlman 是否愿意全职雇用我，他说，“不，但我有这些创业的朋友；去和他们谈谈。” 这就是专家技术——ETI。我猜他是他们的董事会成员。他们正在制作这个专家系统来自动对黄页进行分页。他们正在使用 Lisp，我认识几个已经加入 Fahlman 小组的人。他们雇用了我，一切都很顺利，然后大约一年后我惊慌失措：天哪，我完全幸运地找到了这两份工作；这永远不会再发生了。一旦我不再在这里工作，如果我没有大学学位，我就会去煎汉堡，所以我应该做的就是去拿一个。</p><p class="normal"><b>Zawinski:</b> Yeah. What happened was, I hated high school. It was the worst time of my life. And when I was about to graduate I asked Fahlman if he'd hire me full-time and he said, “No, but I've got these friends who've got a startup; go talk to them.” Which was Expert Technologies—ETI. I guess he was on their board. They were making this expert system to automatically paginate the yellow pages. They were using Lisp and I knew a couple of the people already who had been in Fahlman's group. They hired me and that was all going fine, and then about a year later I panicked: Oh my god, I completely lucked into both of these jobs; this is never going to happen again. Once I no longer work here I'm going to be flipping burgers if I don't have a college degree, so what I ought to do is go get one of those.</p>
<p class="normal"><a id="OEBPS/Chapter01.html.page_5"></a>计划是我在 ETI 兼职工作，然后兼职上学。这变成了全职工作和全职上学，我认为持续了六个星期。也许是九周。我知道它持续了足够长的时间，以至于我错过了加/减期，所以我没有拿回任何钱。但是时间不够长，我实际上没有任何成绩。所以我是否真的去了值得怀疑。</p><p class="normal"><a></a>The plan was that I'd be working part-time at ETI and then I'd be going to school part time. That turned into working full-time and going to school full-time and that lasted, I think, six weeks. Maybe it was nine weeks. I know it lasted long enough that I'd missed the add/drop period, so I didn't get any of my money back. But not long enough that I actually got any grades. So it's questionable whether I actually went.</p>
<p class="normal">这太糟糕了。当你在高中时，每个人都会告诉你，“有很多重复的废话和标准化考试；一旦你上了大学，一切都会好起来的。” 然后你到了大学的第一年，他们就像，“哦，不——当你读研究生的时候会更好。” 所以这只是同样的狗屎，不同的日子——我无法接受。早上八点起床，背东西。他们不让我选择退出这门名为“设施简介”的课程，他们会教你如何使用鼠标。我当时想，“我已经在这所大学工作了一年半——我知道如何使用鼠标。” 没办法——“这是政策。” 诸如此类的各种事情。我受不了了。所以我退学了。我很高兴我做到了。</p><p class="normal">It was just awful. When you're in high school, everyone tells you, “There's a lot of repetitive bullshit and standardized tests; it'll all be better once you're in college.” And then you get to your first year of college and they're like, “Oh, no—it gets better when you're in grad school.” So it's just same shit, different day—I couldn't take it. Getting up at eight in the morning, memorizing things. They wouldn't let me opt out of this class called Introduction to Facilities where they teach you how to use a mouse. I was like, “I've been working at this university for a year and a half—I know how to use a mouse.” No way out of it—“It's policy.” All kinds of stuff like that. I couldn't take it. So I dropped out. And I'm glad I did.</p>
<p class="normal">然后我在 ETI 工作了四年左右，直到公司开始蒸发。我们在 ETI 使用 TI Explorer Lisp 机器，所以我花了很多时间，除了实际在专家系统上工作之外，只是摆弄用户界面的东西，并从下到上学习这些机器是如何工作的。我喜欢它们——我喜欢在操作系统中四处挖掘，只是想弄清楚它们是如何组合在一起的。</p><p class="normal">Then I worked at ETI for four years or so until the company started evaporating. We were using TI Explorer Lisp machines at ETI so I spent a lot of my time, besides actually working on the expert system, just sort of messing around with user-interface stuff and learning how those machines worked from the bottom up. I loved them—I loved digging around in the operating system and just figuring out how it all fit together.</p>
<p class="normal">我写了一堆代码，我在某个新闻组发帖说我正在找工作，哦，顺便说一句，这是一堆代码。Peter Norvig 看到了它并安排了采访。我当时的女朋友已经搬到这里去加州大学伯克利分校，所以我跟着她出去了。</p><p class="normal">I'd written a bunch of code and there was some newsgroup where I posted that I was looking for a job and, oh, by the way, here's a bunch of code. Peter Norvig saw it and scheduled an interview. My girlfriend at the time had moved out here to go to UC Berkeley, so I followed her out.</p>
<p class="normal"><b>Seibel：</b> Norvig 当时在伯克利？</p><p class="normal"><b>Seibel:</b> Norvig was at Berkeley then?</p>
<p class="normal"><b>扎文斯基：</b>是的。那是一份非常奇怪的工作。他们有一大批研究生一直在研究自然语言理解；他们基本上是做一些编程的语言学家。所以他们希望有人拿走这些零碎的东西<a id="OEBPS/Chapter01.html.page_6"></a>他们留下的代码，并将它们集成到一个实际工作的东西中。</p><p class="normal"><b>Zawinski:</b> Yeah. That was a very strange job. They had a whole bunch of grad students who'd been doing research on natural language understanding; they were basically linguists who did some programming. So they wanted someone to take these bits and pieces <a></a>of code they'd left behind and integrate them into one thing that actually worked.</p>
<p class="normal">这非常困难，因为我没有了解他们到底在做什么的背景。所以这会经常发生：我会看一些东西；我会完全卡住。我不知道这意味着什么，我从这里去哪里，我必须阅读什么才能理解这一点。所以我会问彼得。他会对此很好——他会说，“你还不明白这一点是完全有道理的。星期二我会坐下来向你解释。” 所以现在我无事可做。所以我花了很多时间研究 Windows 系统的东西，并四处寻找屏幕保护程序和我以前一直为了好玩而做的那种 UI 东西。</p><p class="normal">That was incredibly difficult because I didn't have the background to understand what in the world they were doing. So this would happen a lot: I'd be looking at something; I'd be completely stuck. I have no idea what this means, where do I go from here, what do I have to read to understand this. So I'd ask Peter. He'd be nice about it—he'd say, “It totally makes sense that you don't understand that yet. I'll sit down and explain it to you Tuesday.” So now I've got nothing to do. So I spent a lot of time working on windows system stuff and poking around with screen savers and just the kind of UI stuff that I'd been doing for fun before.</p>
<p class="normal">六八个月后，我感觉，哇，我真的只是在浪费时间。我没有为他们做任何事情，我只是觉得我在度假。有几次我真的工作了很多，当我回头看的时候，我想，“你为什么辞掉假期工作？你怎么了？他们付钱让你写屏幕保护程序！”</p><p class="normal">After six or eight months of that it just felt like, wow, I'm really just wasting my time. I'm not doing anything for them, and I just felt like I was on vacation. There have been times when I was working really a lot when I'd look back at that and I'm like, “Why did you quit the vacation job? What is wrong with you? They were paying you to write screen savers!”</p>
<p class="normal">所以我最终去了 Lucid 工作，它是剩下的两个 Lisp 环境开发人员之一。真正让我决定离开的是这种我一事无成的感觉。我周围都是不是程序员的人。我和他们中的一些人仍然是朋友；他们是好人，但他们是语言学家。与解决问题相比，他们对抽象事物更感兴趣。我想做一些我可以指着说，“看，我做了这个漂亮的东西。”</p><p class="normal">So I ended up going to work for Lucid, which was one of the two remaining Lisp-environment developers. The thing that really made me decide to leave was just this feeling that I wasn't accomplishing anything. And I was surrounded by people who weren't programmers. I'm still friends with some of them; they're good folks, but they were linguists. They were much more interested in abstract things than solving problems. I wanted to be doing something that I could point to and say, “Look, I made this neat thing.”</p>
<p class="normal"><b>Seibel：</b>你在 Lucid 的工作最终催生了 XEmacs，但当你去那里的时候，你最初是在研究 Lisp 的东西吗？</p><p class="normal"><b>Seibel:</b> Your work at Lucid eventually gave rise to XEmacs, but when you went there originally were you working on Lisp stuff?</p>
<p class="normal"><b>Zawinski：</b>是的，我从事的第一个项目是——我什至不记得那台机器是什么，但它是这台 16 处理器并行计算机，我们有这种 Lucid Common Lisp 的变体，带有一些控制结构，可以让你将事情分叉给不同的处理器。</p><p class="normal"><b>Zawinski:</b> Yeah, one of the first projects I worked on was—I can't even remember what the machine was, but it was this 16-processor parallel computer and we had this variant of Lucid Common Lisp with some control structures that would let you fork things out to different processors.</p>
<p class="normal"><a id="OEBPS/Chapter01.html.page_7"></a>我在后端做了一些工作，以降低生成线程的开销，这样您就可以执行类似 Fibonacci 的并行实现之类的操作，而不仅仅是完全被为每个线程创建新堆栈组的开销所淹没. 我真的很喜欢。这是我第一次使用这样一台相当奇怪的机器。</p><p class="normal"><a></a>I worked a little bit on the back end of that to make the overhead of spawning a thread lower so you could do something like a parallel implementation of Fibonacci that wasn't just completely swamped by the overhead of creating a new stack group for each thread. I really enjoyed that. It was the first time I'd gotten to use a fairly bizarre machine like that.</p>
<p class="normal">在那之前，我在新机器上使用 Lisp。这意味着基本上有人已经为新架构编写了编译器后端，然后他们编译了引导程序代码。所以我得到了这个文件，里面全是二进制文件，据推测是这台机器的可执行代码，现在我必须破译它们的加载器格式，这样我就可以编写一个小的 C 程序来加载它，使页面可执行，并且跳到它。然后，希望你能得到一个 Lisp 提示符，然后你就可以开始手动加载东西了。</p><p class="normal">Before that I was bringing up Lisp on new machines. Which means basically someone's already written the compiler back end for the new architecture and then they've compiled the bootstrap piece of code. So I've got this file full of binary, supposedly executable code for this other machine and now I've got to decipher their loader format so that I can write a little C program that will load that in, make the page executable, and jump to it. Then, hopefully, you get a Lisp prompt and at that point you can start loading things in by hand.</p>
<p class="normal">对于每个架构来说，这都是奇怪的，因为它从来没有被正确记录过。所以这是编译 C 程序然后逐字节查看它的问题——在 Emacs 中逐字节编辑它。让我们看看如果我将其更改为零会发生什么；它停止运行了吗？</p><p class="normal">Which for every architecture was bizarre, because it's never documented right. So it's a matter of compiling a C program and then looking at it byte by byte—byte-editing it in Emacs. Let's see what happens if I change this to a zero; does it stop running?</p>
<p class="normal"><b>Seibel：</b>当你说没有正确记录时，是没有正确记录，还是根本没有记录？</p><p class="normal"><b>Seibel:</b> When you say it wasn't documented right, was it that it wasn't documented correctly, or it wasn't documented at all?</p>
<p class="normal"><b>Zawinski：</b>它通常被记录在案，但通常是错误的。或者可能只是落后了三个修订——谁知道呢？但是在某个时候你稍微调整了一下，然后它就不再相信这是一个可执行文件，你必须弄清楚那里发生了什么。</p><p class="normal"><b>Zawinski:</b> It was usually documented and it was usually wrong. Or maybe it was just three revisions behind—who knows? But at some point you tweak a bit and then it would no longer believe this was an executable file and you had to figure out what was going on there.</p>
<p class="normal"><b>Seibel：</b>所以这是一直出现的问题，从最低级别的系统编程到高级 API，事情并不像您期望的那样工作或按照记录的方式工作。你怎么处理那件事呢？</p><p class="normal"><b>Seibel:</b> So that's something that comes up all the time, from the lowest-level systems programming to high-level APIs, where things just don't work the way you expect or the way they are documented. How do you deal with that?</p>
<p class="normal"><b>Zawinski：</b>好吧，你只是来期待它。你越早意识到你的地图是错误的，你就能越早找出哪里出了问题。就我而言，我正在尝试生成一个可执行文件。好吧，我知道 C 编译器会生成一个。拿好的那个<a id="OEBPS/Chapter01.html.page_8"></a>开始将其转换为坏的，直到它停止工作。这是逆向工程的主要工具。</p><p class="normal"><b>Zawinski:</b> Well, you just come to expect it. The sooner you realize that your map is wrong, the sooner you'll be able to figure out where it went wrong. In my case, I'm trying to produce an executable file. Well, I know the C compiler will produce one. Take the good one and <a></a>start converting it into the bad one until it stops working. That's primary tool of reverse engineering.</p>
<p class="normal">我认为，我修复过的最难修复的错误可能是在 Lucid 的那个时期。我已经到了它正在运行可执行文件并尝试引导 Lisp 的地步，它收到 500 条指令并崩溃。所以我靠在 S 键上，逐步尝试找出它崩溃的地方。而且它似乎每次都在不同的地方崩溃。这没有任何意义。我正在阅读这个我几乎不了解的架构的汇编输出。最后我意识到，“哦，天哪，当我走的时候它正在做一些不同的事情；也许这是基于时间的。” 最终我弄清楚这是怎么回事，这是早期进行推测执行的机器之一。它将执行分支的两侧。如果您单步执行分支指令，GDB 将始终采用分支。GDB 中有一个错误！</p><p class="normal">The hardest bug I've ever fixed, I think, was probably during that period at Lucid. I'd gotten to the point where it's running the executable and it's trying to bootstrap Lisp and it gets 500 instructions in and crashes. So there I am leaning on the S key, stepping through trying to figure out where it crashes. And it seems to be crashing at a different place each time. And it doesn't make any sense. I'm reading the assembly output of this architecture I only barely understand. Finally I realize, “Oh my god, it's doing something different when I step; maybe it's timing-based.” Eventually I figure out that what's going on is this is one of the early machines that did speculative execution. It would execute both sides of the branch. And GDB would always take the branch if you single-stepped past a branch instruction. There was a bug in GDB!</p>
<p class="normal"><b>塞贝尔：</b>不错。</p><p class="normal"><b>Seibel:</b> Nice.</p>
<p class="normal"><b>扎文斯基：</b>对。所以那让我陷入，“哦，我的上帝; 现在我正在尝试调试 GDB，这是我以前从未见过的。” 解决这个问题的方法是，当你到达一个分支指令时，你在分支之前停下来，在两边设置一个断点，然后继续。这就是我如何证明确实发生了什么。花了一周的时间试图修复 GDB；想不通。我假设寄存器在某个地方被踩踏了，所以它总是认为分支检查或类似的东西有一个积极的价值。</p><p class="normal"><b>Zawinski:</b> Right. So then that takes me down into, “Oh my god; now I'm trying to debug GDB, which I've never looked at before.” The way to get around that is you're coming up to a branch instruction and you stop before the branch, set a break point on both sides, and continue. So that was how I proved that really was what was going on. Spent like a week trying to fix GDB; couldn't figure it out. I assume a register was getting stomped somewhere, so it always thought there was a positive value in the branch check or something like that.</p>
<p class="normal">所以我更改了逐步指令命令，以识别它何时出现在分支指令上，然后就说，“不，不要那样做。” 然后我可以靠在 S 键上，它最终会停止，我会手动设置断点并继续。当您正在调试某些东西，然后您发现不仅是地图错误，而且工具也坏了——那是个好时机。</p><p class="normal">So I changed the step-by-instruction command to recognize when it was coming up on a branch instruction and just say, “No, don't do that.” Then I can just lean on the S key and it would eventually stop and I'd set the break point by hand and continue. When you're debugging something and then you figure out that not only is the map wrong but the tools are broken—that's a good time.</p>
<p class="normal">在 Lisp 系统上工作尤其奇怪，因为 GDB 在 Lisp 代码上完全不起作用，因为它没有任何调试信息——它是由 GDB 从未听说过的编译器编写的。我认为在某些平台上它以 GDB 没有的方式布置堆栈帧<a id="OEBPS/Chapter01.html.page_9"></a>理解。所以 GDB 在那时几乎是一个汇编步进器。所以你想尽快离开 GDB 世界。</p><p class="normal">Working on Lisp systems was especially weird because GDB was completely nonfunctional on Lisp code because it doesn't have any debug info—it's written by a compiler GDB has never heard of. I think on some platforms it laid out the stack frames in a way GDB didn't <a></a>understand. So GDB was pretty much an assembly stepper at that point. So you wanted to get out of the GDB world just as quickly as you could.</p>
<p class="normal"><b>Seibel：</b>然后你就会有一个 Lisp 调试器，一切就绪。</p><p class="normal"><b>Seibel:</b> And then you'd have a Lisp debugger and you'd be all set.</p>
<p class="normal"><b>Zawinski：</b>对，是的。</p><p class="normal"><b>Zawinski:</b> Right, yeah.</p>
<p class="normal"><b>Seibel：</b>所以 Lucid 在某个地方改变了方向并说，“我们要制作一个 C++ IDE”。</p><p class="normal"><b>Seibel:</b> So somewhere in there Lucid switched directions and said, “We're going to make a C++ IDE”.</p>
<p class="normal"><b>Zawinski：</b>那是在我开始在那里工作之前就开始的——它正在进行中。人们开始从 Lisp 端转移到 Energize 端，这就是所谓的开发环境。这是一个非常好的产品，但它早了两三年。至少在 Unix 方面，还没有人知道他们想要它。现在每个人都在使用它们，但我们不得不花很多时间向人们解释为什么它比 vi 和 GCC 更好。不管怎样，我已经做了一些 Emacs 的事情。我想那时我已经重写了 Emacs 字节编译器，因为——我为什么要那样做？是的，我写了这个 Rolodex 电话/地址簿的东西。</p><p class="normal"><b>Zawinski:</b> That had been begun before I started working there—it was in progress. And people started shifting over from the Lisp side to the Energize side, which is what the development environment was called. It was a really good product but it was two or three years too early. Nobody, at least on the Unix side, had any idea they wanted it yet. Everyone uses them now but we had to spend a lot of time explaining to people why this was better than vi and GCC. Anyway, I'd done a bit of Emacs stuff. I guess by that point I'd already rewritten the Emacs byte compiler because—why did I do that? Right, I'd written this Rolodex phone/address-book thing.</p>
<p class="normal"><b>Seibel：</b>老大哥数据库？</p><p class="normal"><b>Seibel:</b> Big Brother Database?</p>
<p class="normal"><b>扎文斯基：</b>是的。而且它很慢，所以我开始研究为什么它很慢，然后我意识到，哦，它很慢是因为编译器很烂。所以我重写了编译器，这是我第一次遇到 Stallman 的顽固态度。所以我对 Emacs 了解很多。</p><p class="normal"><b>Zawinski:</b> Yeah. And it was slow so I started digging into why it was slow and I realized, oh, it's slow because the compiler sucks. So I rewrote the compiler, which was my first run-in with the intransigence of Stallman. So I knew a lot about Emacs.</p>
<p class="normal"><b>Seibel：</b>那么对字节编译器的改变，是改变了字节码格式还是仅仅改变了编译器？</p><p class="normal"><b>Seibel:</b> So the change to the byte compiler, did it change the byte-code format or did it just change the compiler?</p>
<p class="normal"><b>Zawinski：</b>它实际上有几个选项——我在 C 层（字节码解释器）做了一些更改，添加了一些新指令来加快速度。但是编译器可以配置为发出旧式字节码或利用新代码的字节码。</p><p class="normal"><b>Zawinski:</b> It actually had a few options—I made some changes at the C layer, the byte-code interpreter, added a few new instructions that sped things up. But the compiler could be configured to emit either old-style byte-code or ones that took advantage of the new codes.</p>
<p class="normal">所以我写了一个新的编译器，Stallman 的回答是，“我认为没有必要进行这种改变。” 我就像，“你在说什么？它生成更快的代码。” 然后他的下一个回答是，“好吧，呃，<a id="OEBPS/Chapter01.html.page_10"></a>给我发送一个差异并解释你更改的每一行。” “好吧，我没有那样做——我重写了它，因为旧的很垃圾。” 那不行。它被折叠起来的唯一原因是因为我发布了它，成千上万的人开始使用它，他们喜欢它，他们唠叨了他两年，最后他把它放进去，因为他厌倦了被唠叨。</p><p class="normal">So I write a new compiler and Stallman's response is, “I see no need for this change.” And I'm like, “What are you talking about? It generates way faster code.” Then his next response is, “Okay, uh, <a></a>send me a diff and explain each line you changed.” “Well, I didn't do that—I rewrote it because the old one was crap.” That was not OK. The only reason it ever got folded in was because I released it and thousands of people started using it and they loved it and they nagged him for two years and finally he put it in because he was tired of being nagged about it.</p>
<p class="normal"><b>Seibel：</b>你签署了将版权转让给自由软件基金会的文件吗？</p><p class="normal"><b>Seibel:</b> Did you sign the papers assigning the copyright to the Free Software Foundation?</p>
<p class="normal"><b>Zawinski：</b>哦，是的，我马上就做了。我认为这可能是电子邮件中的第一件事。就像，给我发送每一行的差异并签名。所以我签了字说，“剩下的我不能做；无法向您发送差异；这是荒谬的。它有据可查；去看看。我认为他从来没有这样做过。</p><p class="normal"><b>Zawinski:</b> Oh yeah, I did that right away. I think that was probably the first thing in the email. It was like, send me a diff for each line and sign this. So I signed and said, “I can't do the rest; can't send you a diff; that's ridiculous. It's well documented; go take a look.” I don't think he ever did.</p>
<p class="normal">有这样一种说法，即 Lucid 和 FSF 之间存在一些法律问题，这绝对不是真的——我们为我们对他们所做的一切分配了版权。他们在某些时候假装我们没有这样做很方便。就像，我们实际上多次提交了文书工作，因为他们会说，“哦，哦，我们似乎把它弄丢了。” 我认为在很久以后，关于作业和 XEmacs 出现了某种骚动，但那是在我的时间之后。</p><p class="normal">There's this myth that there was some legal issue between Lucid and FSF and that's absolutely not true—we assigned copyrights for everything we did to them. It was convenient for them to pretend we hadn't at certain times. Like, we actually submitted the paperwork multiple times because they'd be like, “Oh, oh, we seem to have lost it.” I think there was some kind of brouhaha with assignments and XEmacs much later, but that was way after my time.</p>
<p class="normal"><b>Seibel：</b>所以你是从 Lisp 开始的。但你显然没有在整个职业生涯中坚持下去。接下来发生了什么？</p><p class="normal"><b>Seibel:</b> So you started with Lisp. But you obviously didn't stick with it for your whole career. What came next?</p>
<p class="normal"><b>Zawinski：</b>嗯，在 Lisp 之后，我进行任何正式编程的下一种语言是 C，这有点像回到我在 Apple II 上编写的程序集。是 PDP-11 汇编程序认为它是一种语言。你知道，这是不愉快的。我试图尽可能长时间地避免它。而 C++ 只是一个可憎的东西。它在各个方面都是错误的。所以我真的尽量避免使用它，并在 Netscape 做所有的 C 语言。这很容易，因为我们的目标是非常小的机器，它们不能很好地运行 C++ 程序，因为一旦你开始使用任何库，C++ 就会像疯了似的膨胀。此外，C++ 编译器也在不断变化——存在许多不兼容问题。所以我们从一开始就选择了 ANSI C，这对我们很有帮助。<a id="OEBPS/Chapter01.html.page_11"></a>Java 有点想回到 Lisp，因为有一些概念表明该语言并没有竭尽全力试图让你避免——这又让人感到舒服了。</p><p class="normal"><b>Zawinski:</b> Well, the next language I did any serious programming in after Lisp was C, which was kind of like going back to the assembly I programmed on an Apple II. It's the PDP-11 assembler that thinks it's a language. Which was, you know, unpleasant. I'd tried to avoid it for as long as possible. And C++ is just an abomination. Everything is wrong with it in every way. So I really tried to avoid using that as much as I could and do everything in C at Netscape. Which was pretty easy because we were targeting pretty small machines that didn't run C++ programs well because C++ tends to bloat like crazy as soon as you start using any libraries. Plus the C++ compilers were all in flux—there were lots of incompatibility problems. So we just settled on ANSI C from the beginning and that served us pretty well. After that <a></a>Java felt like going back to Lisp a bit in that there were concepts that the language wasn't bending over backwards trying to make you avoid—that were comfortable again.</p>
<p class="normal"><b>Seibel：</b>比如什么？</p><p class="normal"><b>Seibel:</b> Like what?</p>
<p class="normal"><b>Zawinski：</b>内存管理。该函数感觉更像是函数而不是子例程。它有更多的强制模块化。在 C 代码中加入 goto 总是很诱人，因为它很简单。</p><p class="normal"><b>Zawinski:</b> Memory management. That functions felt more like functions than subroutines. There was much more enforced modularity to it. It's always tempting to throw in a goto in C code just because it's easy.</p>
<p class="normal"><b>Seibel：</b>所以最近您似乎主要在使用 C 和 Perl。</p><p class="normal"><b>Seibel:</b> So these days it seems like you're mostly doing C and Perl.</p>
<p class="normal"><b>Zawinski：</b>嗯，我真的不怎么编程了。大多数情况下，我编写愚蠢的小 Perl 脚本来保持我的服务器运行。我最终写了很多愚蠢的东西来为我拥有的 MP3 制作专辑封面——诸如此类。只是微小的暴力破解程序。</p><p class="normal"><b>Zawinski:</b> Well, I don't really program very much anymore. Mostly I write stupid little Perl scripts to keep my servers running. I end up writing a lot of goofy things for getting album art for MP3s I have—that kind of thing. Just tiny brute-force throw-away programs.</p>
<p class="normal"><b>Seibel：</b>你喜欢 Perl 还是只是方便？</p><p class="normal"><b>Seibel:</b> Do you like Perl or is it just handy?</p>
<p class="normal"><b>Zawinski：</b>哦，我鄙视它。这是一种可怕的语言。但它绝对无处不在。您坐在任何一台计算机上，您永远不必通过安装 Perl 来与他人交谈来运行您的脚本。Perl 已经存在了。这真的是唯一推荐它的东西。</p><p class="normal"><b>Zawinski:</b> Oh, I despise it. It's a horrible language. But it is installed absolutely everywhere. Any computer you sit down on, you're never going to have to talk someone through installing Perl to run your script. Perl is there already. That's really the one and only thing that recommends it.</p>
<p class="normal">它有一个不错的库集合。通常有一个图书馆可以做你想做的事。而且通常效果不是很好，但至少有一些东西。用 Java 编写一些东西然后试图找出答案的经历——我自己在我的计算机上安装 Java 时遇到了麻烦——这太可怕了。我认为 Perl 是一种卑鄙的语言。如果你用得足够少，你可以让它看起来有点像 C — 或者我猜更像 JavaScript 而不是 C。如果你使用它，它的语法很疯狂。它的数据结构一团糟。没有太多好处。</p><p class="normal">It has an OK collection of libraries. There's often a library for doing the thing you want. And often it doesn't work very well, but at least there's something. The experience of writing something in Java and then trying to figure out—I myself have trouble installing Java on my computer—it's horrible. I think Perl is a despicable language. If you use little enough of it, you can make it kind of look like C—or I guess more like JavaScript than like C. Its syntax is crazy, if you use it. Its data structures are a mess. There's not a lot good about it.</p>
<p class="normal"><b>Seibel：</b>但不像 C++ 那样糟糕。</p><p class="normal"><b>Seibel:</b> But not as bad as C++.</p>
<p class="normal"><b>Zawinski：</b>不，绝对不是。这是为了不同的事情。有些东西用 Perl 或任何类似 Perl 的语言比用 C 写起来容易得多，因为它们是面向文本的——所有这些所谓的<a id="OEBPS/Chapter01.html.page_12"></a>“脚本语言”。这是一个我不太买账的区别——“编程”与“脚本”。我认为这是无稽之谈。但是，如果您正在做的是从根本上操纵文本或启动程序，例如运行 wget 并提取一些 HTML 并对其进行模式匹配，那么在 Perl 中比 Emacs Lisp 更容易做到这一点。</p><p class="normal"><b>Zawinski:</b> No, absolutely not. It's for different things. There's stuff that would be so much easier to write in Perl or any language like Perl than in C just because they're text-oriented—all these so-called <a></a>“scripting languages”. Which is a distinction I don't really buy—“programming” versus “scripting”. I think that's nonsense. But if what you're doing is fundamentally manipulating text or launching programs, like running wget and pulling some HTML out and pattern-matching it, it's going to be easier to do that in Perl than even Emacs Lisp.</p>
<p class="normal"><b>Seibel：</b>不用说，Emacs Lisp 不会非常适合命令行实用程序。</p><p class="normal"><b>Seibel:</b> To say nothing of, Emacs Lisp is not going to be very suitable for command-line utilities.</p>
<p class="normal"><b>Zawinski：</b>是的，尽管我过去一直在 Emacs 中编写随机的小实用程序。实际上，在早期的 Netscape 中，我们的构建过程的一部分涉及运行“emacs -batch”来操作一些文件。没有人真正欣赏这一点。</p><p class="normal"><b>Zawinski:</b> Yeah, though I used to write just random little utilities in Emacs all the time. There was actually a point, early on in Netscape, where part of our build process involved running “emacs -batch” to manipulate some file. No one really appreciated that.</p>
<p class="normal"><b>Seibel：</b>不。我想他们不会。XScreenSaver 怎么样——你还在研究它吗？</p><p class="normal"><b>Seibel:</b> No. I imagine they wouldn't. What about XScreenSaver—do you still work on that?</p>
<p class="normal"><b>Zawinski：</b>我仍然不时地编写新的屏幕保护程序只是为了好玩，这就是 C。</p><p class="normal"><b>Zawinski:</b> I still write new screen savers every now and then just for kicks, and that's all C.</p>
<p class="normal"><b>Seibel：</b>你为此使用某种 IDE 吗？</p><p class="normal"><b>Seibel:</b> Do you use some kind of IDE for that?</p>
<p class="normal"><b>Zawinski：</b>我主要使用 Emacs。尽管最近，我将 XScreenSaver 移植到 OS X。我这样做的方式是根据 Cocoa（Mac 图形基板）重新实现 Xlib，这样我就不必更改所有屏幕保护程序的源代码。他们仍在进行 X 调用，但我为每个调用都实现了后端。那是在 Objective C 中，它实际上是一种非常好的语言。我喜欢这样做。它在好的方面确实感觉像 Java，但也感觉像 C。因为它本质上是 C，所以您仍然可以直接与 C 代码链接并调用函数而不必向后弯腰。</p><p class="normal"><b>Zawinski:</b> I just use Emacs, mostly. Though recently, I ported XScreenSaver to OS X. The way I did that was I reimplemented Xlib in terms of Cocoa, the Mac graphics substrate, so I wouldn't have to change the source code of all the screen savers. They're still making X calls but I implemented the back end for each of those. And that was in Objective C, which actually is a pretty nice language. I enjoyed doing that. It definitely feels Java-like in the good ways but it also feels like C. Because it's essentially C, you can still link directly with C code and just call the functions and not have to bend over backwards.</p>
<p class="normal"><b>Seibel：</b>在 Lucid，撇开 Emacs 开发的政治因素不谈，你学到了哪些技术知识？</p><p class="normal"><b>Seibel:</b> At Lucid, leaving aside the politics of Emacs development, what technical stuff did you learn?</p>
<p class="normal"><b>Zawinski：</b>当我在那里的时候，我确实成为了一个更好的程序员。很大程度上是因为那真的是我见过的最聪明的一群人。在那里工作的每个人都很棒。在那种环境中真是太好了，当有人说，“那是<a id="OEBPS/Chapter01.html.page_13"></a>胡说八道”或“我们应该这样做”，你可以相信他们的话，相信他们知道他们在说什么。那真是太好了。并不是说我以前没有接触过聪明人。但那里始终都是一群高素质的人。</p><p class="normal"><b>Zawinski:</b> I definitely became a better programmer while I was there. Largely because that was really the smartest group of people I've been around. Everyone who worked there was brilliant. And it was just nice to be in that kind of environment where when someone says, “That's <a></a>nonsense,” or “We should do it this way,” you can just take their word for it, believe that they know what they were talking about. That was really nice. Not that I hadn't been around smart people before. But it was just such a high-quality group of people there, consistently.</p>
<p class="normal"><b>Seibel：</b>开发团队有多大？</p><p class="normal"><b>Seibel:</b> And how big was the development team?</p>
<p class="normal"><b>Zawinski：</b>我认为公司大概有 70 人；我不知道，开发团队有 40 人左右。Energize 团队可能有 25 人，20 人。它被分成了非常不同的区域。有人在编译器方面和后端数据库方面工作。不是 Emacs 的 GUI 东西。然后有一段时间，我和其他两三个人致力于将 Emacs 与环境集成。这最终变成了我主要从事 Emacs 的工作，试图让我们的 Emacs 19 可用，成为一个不会一直崩溃的编辑器，并且实际上运行你期望它运行的所有 Emacs 包。</p><p class="normal"><b>Zawinski:</b> I think there were like 70 people at the company so probably; I don't know, 40 or so on the development team. The Energize team was maybe 25 people, 20. It was divided up into pretty distinct areas. There were the folks working on the compiler side of things and the back-end database side of things. The GUI stuff that wasn't Emacs. And then there was, at one point, me and two or three other people working on integrating Emacs with the environment. That eventually turned into mostly me working on mostly Emacs stuff, trying to make our Emacs 19 be usable, be an editor that doesn't crash all the time, and actually runs all the Emacs packages that you expect it to run.</p>
<p class="normal"><b>Seibel：</b>所以你希望你的产品中包含的 Emacs 是一个功能齐全的 Emacs 版本。</p><p class="normal"><b>Seibel:</b> So you wanted the Emacs included in your product to be a fully capable version of Emacs.</p>
<p class="normal"><b>Zawinski：</b>最初的计划是我们不会将 Emacs 包含在我们的产品中。你的机器上已经安装了 Emacs，你也安装了我们的产品，它们可以协同工作。你的机器上已经安装了 GCC 和我们的产品，它们可以一起工作。我认为我们产品的早期代号之一类似于 Hitchhiker，因为它的想法是它会利用你已经拥有的所有工具并将它们集成在一起——通过在它们之间提供这个通信层让它们相互交谈。</p><p class="normal"><b>Zawinski:</b> The original plan was that we wouldn't include Emacs with our product. You have Emacs on your machine already and you have our product and they work together. And you had GCC on your machine already and our product, and they work together. I think one of the early code names for our product was something like Hitchhiker because the idea was that it would take all the tools that you already have and integrate them—make them talk to each other by providing this communication layer between them.</p>
<p class="normal">那根本行不通。我们最终发布了我们的 GCC 和 GDB 版本，因为我们无法足够快地获取上游的更改，或者在某些情况下根本无法获取。Emacs 也是如此。所以我们最终运送了整个东西。我们最终走上了这样的道路，“好吧，我们正在取代 Emacs。拉屎。我想我们必须这样做，这样我们才能更好地让它发挥作用。” 我花了很多时间做的一件事是让 vi 仿真模式工作。</p><p class="normal">That didn't work out at all. We ended up shipping our version of GCC and GDB because we couldn't get the changes upstream fast enough, or at all in some cases. And same thing with Emacs. So we ended up shipping the whole thing. We ended up going down the path of, “Well, we're replacing Emacs. Shit. I guess we have to do that so we better make it work.” One thing I spent a bunch of time on was making the vi emulation mode work.</p>
<p class="normal"><a id="OEBPS/Chapter01.html.page_14"></a><b>Seibel：</b>那是你生命中的几个星期，你永远不会回来。</p><p class="normal"><a></a><b>Seibel:</b> And that's several weeks of your life you're never going to get back.</p>
<p class="normal"><b>Zawinski：</b>是的，是的。这很有挑战性。我认为它最终工作正常。真正的问题不是模拟 vi 错误，而是 vi 用户总是退出并重新启动 vi。就我而言，再多的编码也无法让他们摆脱这种心态。所以他们就像，“我预计这将在半秒内启动，但它需要 14 秒。这是荒谬的。我不能用这个。”</p><p class="normal"><b>Zawinski:</b> That's true, yeah. It was challenging. I think it ended up working OK. The real problem with that wasn't so much that it was emulating vi wrong as that vi users quit and restart vi all the time. And no amount of coding on my part is going to get them out of that mindset. So they're like, “I expected this to launch in half a second and it's taking 14 seconds. That's ridiculous. I can't use this.”</p>
<p class="normal"><b>Seibel：</b>你为什么离开 Lucid？</p><p class="normal"><b>Seibel:</b> Why did you leave Lucid?</p>
<p class="normal"><b>Zawinski：</b> Lucid 已经完成了。有很多裁员。我给一群我认识的人发了邮件说，“嘿，看来我很快需要一份新工作了”，其中一个人是马克·安德森，他说，“哦，有趣的是你应该提一下，因为我们上周刚成立了一家公司。” 就是这样。</p><p class="normal"><b>Zawinski:</b> Lucid was done. There'd been a bunch of layoffs. I sent mail to a bunch of people I know saying, “Hey, looks like I'm going to need a new job soon” and one of those people was Marc Andreessen and he said, “Oh, funny you should mention that, because we just started a company last week.” And that was that.</p>
<p class="normal"><b>Seibel：</b>所以你去了 Netscape。你在那里做什么工作？</p><p class="normal"><b>Seibel:</b> So you went to Netscape. What did you work on there?</p>
<p class="normal"><b>Zawinski：</b>我几乎马上就开始做浏览器的 Unix 端。到目前为止，可能已经在上面编写了几天的代码。更多的 Windows 和 Mac 方面已经开始。该模型是一大堆后端代码，然后是三个平台中每一个的尽可能小的前端代码。</p><p class="normal"><b>Zawinski:</b> I pretty much started right away doing the Unix side of the browser. There had been maybe a few days' worth of code written on it so far. A little bit more of the Windows and Mac sides had been started. The model was a big pile of back-end code and then as small as possible a piece of front-end code for each of the three platforms.</p>
<p class="normal"><b>Seibel：</b>这是全新的代码吗？</p><p class="normal"><b>Seibel:</b> And was this all new code?</p>
<p class="normal"><b>Zawinski：</b>都是新代码。大多数 Netscape 创始人都是 NCSA/Mosaic 开发人员，因此他们编写了各种版本的 NCSA/Mosaic，实际上是三个不同的程序。这六个人都在 Netscape。他们没有重用任何代码，但他们以前写过这个程序。</p><p class="normal"><b>Zawinski:</b> It was all new code. Most of the Netscape founders had been NCSA/Mosaic developers so they had written the various versions of NCSA/Mosaic, which was actually three different programs. And all six of those people were at Netscape. They weren't reusing any code but they had written this program before.</p>
<p class="normal"><b>Seibel：</b>所以他们从一张空磁盘开始打字？</p><p class="normal"><b>Seibel:</b> So they started with an empty disk and started typing?</p>
<p class="normal"><b>扎文斯基：</b>没错。我从没看过马赛克代码；还是没有。实际上，我们曾一度因此被起诉；该大学声称我们正在重用他们的代码，我想这是以一种方式解决的<a id="OEBPS/Chapter01.html.page_15"></a>或另一个。一直有谣言说我们是这样开始的，但我们没有。</p><p class="normal"><b>Zawinski:</b> Exactly. I never looked at the Mosaic code; still haven't. We actually were sued over that at one point; the university claimed that we were reusing their code and I guess that was settled one way <a></a>or the other. There's always been that rumor that we started that way, but we didn't.</p>
<p class="normal">真的，我们为什么要这么做？每个人都想写第二版，对吧？你在写它的时候就想出来了，现在你有机会把它扔掉并重新开始——当然你会重新开始。这次会好一些。确实如此。按照其他人的设计，基本上没有办法并行加载图像，诸如此类。这真的很重要。所以我们对后端进行了更好的设计。</p><p class="normal">And really, why would we? Everyone wants to write version two, right? You were figuring it out while you wrote it and now you've got a chance to throw that away and start over—of course you're going to start over. It's going to be better this time. And it was. With the design that the other ones had, there was basically no way to load images in parallel, things like that. And that was really important. So we had a better design for the back end.</p>
<p class="normal"><b>Seibel：</b>然而，这也是陷入第二系统综合症的典型机会。</p><p class="normal"><b>Seibel:</b> Yet that's also a classic opportunity to fall into the second-system syndrome.</p>
<p class="normal"><b>Zawinski：</b>是的，是的。</p><p class="normal"><b>Zawinski:</b> It is, it is.</p>
<p class="normal"><b>Seibel：</b>你们是如何避免这种情况的？</p><p class="normal"><b>Seibel:</b> How did you guys avoid that?</p>
<p class="normal"><b>Zawinski：</b>我们非常关注最后期限，就像宗教一样。我们要在六个月内交付成品，否则我们将死于尝试。</p><p class="normal"><b>Zawinski:</b> We were so focused on deadline it was like religion. We were shipping a finished product in six months or we were going to die trying.</p>
<p class="normal"><b>Seibel：</b>你是怎么想出最后期限的？</p><p class="normal"><b>Seibel:</b> How did you come up with that deadline?</p>
<p class="normal"><b>Zawinski：</b>嗯，我们环顾了世界其他地方并决定，如果我们在六个月内没有完成，有人会抢在我们前面，所以我们将在六个月内完成。</p><p class="normal"><b>Zawinski:</b> Well, we looked around at the rest of the world and decided, if we're not done in six months, someone's going to beat us to it so we're going to be done in six months.</p>
<p class="normal"><b>Seibel：</b>鉴于你首先选择了日期，你必须控制范围或质量。那是如何工作的？</p><p class="normal"><b>Seibel:</b> Given that you picked the date first, you had to rein in scope or quality. How did that work?</p>
<p class="normal"><b>Zawinski：</b>我们花了很长时间讨论功能。好吧，时间不长，但似乎很长一段时间，因为我们每天都过着一周的生活。毫无疑问，我们剥离了功能。我们有一块白板；我们潦草地写下想法；我们把它们划掉了。这是一群大概有六七个人。我不记得确切的数字。一群聪明、自负的人坐在一个房间里互相大喊大叫了一个星期左右。</p><p class="normal"><b>Zawinski:</b> We spent a long time talking about features. Well, not a long time, but it seemed like a long time because we were living a week every day. We stripped features, definitely. We had a whiteboard; we scribbled ideas; we crossed them out. This was a group of like six or seven people. I don't remember exactly the number. A bunch of smart, egotistical people sitting in a room yelling at each other for a week or so.</p>
<p class="normal"><a id="OEBPS/Chapter01.html.page_16"></a><b>Seibel：</b>六七个人是整个 Netscape 开发团队还是 Unix 开发团队？</p><p class="normal"><a></a><b>Seibel:</b> Six or seven being the whole Netscape development team or the Unix development team?</p>
<p class="normal">Zawinski：那是整个客户团队。基本上，还有一些服务器人员正在实施他们的 Apache 分支。我们没有和他们多说话，因为我们很忙。我们和他们共进午餐，仅此而已。所以我们弄清楚了我们想在这件事上做什么，然后我们把工作分了，这样，我猜，在项目的任何部分工作的人不超过两个人。我负责 Unix 方面的工作，Lou Montulli 负责大部分后端网络方面的工作。Eric Bina 负责布局，Jon Mittelhauser 和 Chris Houck 负责 Windows 前端，Aleks Totić 和 Mark Lanett 负责为 pre-version 1.0 团队负责 Mac 前端。在那之后，这些团队成长了一点。但我们会开会，然后回到我们的小隔间，埋头苦干 16 个小时，努力让事情顺利进行。</p><p class="normal">Zawinski: That was the whole client team. There were also the server folks who were implementing their fork of Apache, basically. We didn't talk to them much because we were busy. We had lunch with them, but that was it. So we figured out what we wanted to be in the thing and we divided up the work so that there were, I guess, no more than two people working on any part of the project. I was doing the Unix side and Lou Montulli did most of back-end network stuff. And Eric Bina was doing layout and Jon Mittelhauser and Chris Houck were doing the Windows front end and Aleks Totić and Mark Lanett were doing the Mac front end for the pre—version 1.0 team. Those teams grew a little bit after that. But we'd have our meetings and then go back to our cubicles and be heads-down for 16 hours trying to make something work.</p>
<p class="normal">这真是一个很棒的环境。我真的很喜欢它。因为每个人都非常确定自己是对的，所以我们一直在争吵，但这让我们能够快速沟通。有人会靠在你的隔间上说，“你他妈的登记了什么？这完全是胡说八道——你不能那样做。你是一个白痴。” 然后你会说，“滚开！” 然后去看看它，修理它并检查它。我们非常粗鲁，但我们沟通很快，因为你不必去吹阳光给别人的屁股并向他们解释你认为错误的地方 - 你可以说，“嘿，真是一派胡言！我不能用那个。” 你会很快把它弄清楚。压力很大，但我们很快就完成了。</p><p class="normal">It was really a great environment. I really enjoyed it. Because everyone was so sure they were right, we fought constantly but it allowed us to communicate fast. Someone would lean over your cubicle and say, “What the fuck did you check in; that's complete bullshit—you can't do it that way. You're an idiot.” And you'd say, “Fuck off!” and go look at it and fix it and check it in. We were very abrasive but we communicated fast because you didn't have to go blow sunshine up someone's ass and explain to them what you thought was wrong—you could say, “Hey, that's a load of shit! I can't use that.” And you'd hash it out very quickly. It was stressful but we got it done pretty quickly.</p>
<p class="normal"><b>Seibel：</b>快速生产软件需要长时间和强度吗？</p><p class="normal"><b>Seibel:</b> Are the long hours and the intensity required to produce software quickly?</p>
<p class="normal"><b>Zawinski：</b>这当然不健康。我知道我们是那样做的，而且奏效了。所以回答这个问题的方法是，是否还有另一个例子表明有人在他们实际在家吃晚饭并在晚上睡觉的情况下快速交付质量合理的大型软件？那有没有发生过？我其实不知道。也许它有。</p><p class="normal"><b>Zawinski:</b> It's certainly not healthy. I know we did it that way and it worked. So the way to answer that question is, is there another example of someone delivering a big piece of software that fast that's of reasonable quality where they actually had dinner at home and slept during the night? Has that ever happened? I don't actually know. Maybe it has.</p>
<p class="normal"><a id="OEBPS/Chapter01.html.page_17"></a>但这并不总是关于尽快完成它。两年后不要精疲力尽，并且能够继续工作十年也很好。如果你每周工作 80 多个小时，这就不会发生。</p><p class="normal"><a></a>But it's not always about getting it done as quickly as possible. It also would be nice to not burn out after two years and be able to continue doing your job for ten. Which is not going to happen if you're working 80-plus hours a week.</p>
<p class="normal"><b>Seibel：</b>您所做的最引以为豪的事情是什么？</p><p class="normal"><b>Seibel:</b> What is the thing that you worked on that you were most proud of.</p>
<p class="normal"><b>Zawinski：</b>真的只是我们发货的事实。整个东西。我非常专注于我的部分，即 Unix 前端的用户界面。但实际上只是我们交付了东西并且人们喜欢它。人们立即从 NCSA Mosaic 转变为“哇，这是有史以来最伟大的事情”。我们在工具栏中有 What's Cool 页面的按钮，并向世界展示了人们已经建立的这些疯狂的网站。我的意思是，可能有将近 200 个！与其说是我为代码感到自豪，不如说是我为代码感到自豪；只是它已经完成了。在很多方面，代码不是很好，因为它完成得非常快。但它完成了工作。我们发货了——这是底线。</p><p class="normal"><b>Zawinski:</b> Really just the fact that we shipped it. The whole thing. I was very focused on my part, which was the user interface of the Unix front end. But really just that we shipped the thing at all and that people liked it. People converted immediately from NCSA Mosaic and were like, “Wow, this is the greatest thing ever.” We had the button for the What's Cool page up in the toolbar and got to show the world these crazy web sites people had put up already. I mean, there were probably almost 200 of them! It's not so much that I was proud of the code; just that it was done. In a lot of ways the code wasn't very good because it was done very fast. But it got the job done. We shipped—that was the bottom line.</p>
<p class="normal">在我们发布 .96 测试版的第一个晚上，我们都围坐在房间里观看下载，并连接了声音触发器——这太棒了。一个月后，两百万人在运行我编写的软件。真是难以置信。这绝对让这一切变得值得——我们对人们的生活产生了影响；由于我们所做的工作，他们的一天变得更有趣、更愉快或更轻松。</p><p class="normal">That first night when we put up the .96 beta, we were all sitting around the room watching the downloads with sound triggers hooked up to it—that was amazing. A month later two million people were running software I'd written. It was unbelievable. That definitely made it all worthwhile—that we'd had an impact on people's lives; that their day was more fun or more pleasant or easier because of the work we'd done.</p>
<p class="normal"><b>Seibel：</b>在这种无情的步伐之后，在代码质量方面，在某个时候必须开始赶上你。你们是怎么处理的？</p><p class="normal"><b>Seibel:</b> After this relentless pace, at some point that has to start to catch up with you in terms of the quality of the code. How did you guys deal with that?</p>
<p class="normal"><b>Zawinski：</b>嗯，我们处理这个问题的方式很糟糕。从来没有时间重新开始并重写它。重新开始并重写它从来都不是一个好主意。</p><p class="normal"><b>Zawinski:</b> Well, the way we dealt with that was badly. There's never a time to start over and rewrite it. And it's never a good idea to start over and rewrite it.</p>
<p class="normal"><b>Seibel：</b>在某些时候你也从事邮件阅读器的工作，对吧？</p><p class="normal"><b>Seibel:</b> At some point you also worked on the mail reader, right?</p>
<p class="normal"><a id="OEBPS/Chapter01.html.page_18"></a><b>Zawinski：</b>在 2.0 中，Marc 走进我的隔间说，“我们需要一个邮件阅读器。” 我想，“好吧，这听起来很酷。我以前从事过邮件阅读器的工作。” 我当时住在伯克利，基本上有几个星期没来办公室。我一直坐在咖啡馆里胡思乱想，试图找出我想要的邮件阅读器。列出清单，划掉它，试图决定我需要多长时间。用户界面应该是什么样的？</p><p class="normal"><a></a><b>Zawinski:</b> In 2.0 Marc comes into my cubicle and says, “We need a mail reader.” And I'm like, “OK, that sounds cool. I've worked on mail readers before.” I was living in Berkeley and basically I didn't come into the office for a couple weeks. I was spending the whole time sitting in cafes doodling, trying to figure out what I wanted in a mail reader. Making lists, crossing it off, trying to decide how long it would take me. What should the UI look like?</p>
<p class="normal">然后我回来开始编码。然后马克又进来说，“哦，所以我们雇了另一个以前做过邮件工作的人。你们应该一起努力。” 就是这个家伙 Terry Weissman，他太棒了——我们一起工作得很好。与早期浏览器团队的其他成员相比，这是一种完全不同的动态。</p><p class="normal">Then I came back and started coding. And then Marc comes in again and says, “Oh, so we hired this other guy who's done mail stuff before. You guys should work together.” It's this guy Terry Weissman, who was just fantastic—we worked together so well. And it was a completely different dynamic than it had been in the early days with the rest of the browser team.</p>
<p class="normal">我们根本没有互相吼叫。以及我们分工的方式，我无法想象它可能对任何人都有效，或者对任何人都有效。我完成了基本设计，然后开始编写一些代码，每天或每隔几天我们都会查看功能列表，然后我会说，“呃，也许我会继续努力，”然后他会说，“好吧，我会努力的，”然后我们就走了。</p><p class="normal">We didn't yell at each other at all. And the way we divided up labor, I can't imagine how it possibly worked or could ever work for anyone. I had the basic design done and I'd started doing a little coding and every day or every couple of days we'd look at the list of features and I'd go, “Uhhh, maybe I'll work on that,” and he'd go, “OK, I'll work on that,” and then we'd go away.</p>
<p class="normal">签到会发生，然后我们回来，他会说，“好吧，我已经完成了，你在做什么？” “呃，我正在研究这个。” “好吧，那我就开始吧。” 我们只是将这些部分分开了。结果非常好。</p><p class="normal">Check-ins would happen and then we'd come back and he'd say, “Alright, I'm done with that, what are you doing?” “Uh, I'm working on this.” “OK, well, I'll start on that then.” And we just sort of divided up the pieces. It worked out really well.</p>
<p class="normal">我们有分歧——我认为我们必须将过滤功能放入文件夹中，因为我们没有时间把它做好。他说，“不，不，我真的认为我们应该那样做。” 我当时想，“我们没有时间！” 所以他那天晚上就写了。</p><p class="normal">We had disagreements—I thought we had to toss filtering into folders because we just didn't have time to do it right. And he was like, “No, no, I really think we ought to do that.” And I was like, “We don't have time!” So he wrote it that night.</p>
<p class="normal">另一件事是，特里和我很少见面，因为他住在圣克鲁斯，而我住在伯克利。我们在相反的方向与工作地点的距离大致相同，因为我们两个人是唯一需要交流的人，我们就像，“如果你不让我进来，我不会让你进来” “交易！”</p><p class="normal">The other thing was, Terry and I rarely saw each other because he lived in Santa Cruz and I lived in Berkeley. We were about the same distance from work in opposite directions and because the two of us were the only two who ever needed to communicate, we were just like, “I won't make you come in if you don't make me come in.” “Deal!”</p>
<p class="normal"><a id="OEBPS/Chapter01.html.page_19"></a><b>Seibel：</b>你们经常发邮件吗？</p><p class="normal"><a></a><b>Seibel:</b> Did you guys email a lot?</p>
<p class="normal"><b>Zawinski：</b>是的，不断的电子邮件。这是在没有即时消息之前——现在可能都是 IM，因为我们不断地发送单行电子邮件。我们通过电话交谈。</p><p class="normal"><b>Zawinski:</b> Yeah, constant email. This was before instant messaging—these days it probably all would have been IM because we were sending one-liner emails constantly. And we talked on the phone.</p>
<p class="normal">所以我们发布了带有邮件阅读器的 2.0，并且很受欢迎。然后我们正在开发 2.1，这是我开始考虑完成的邮件阅读器版本——这是一个包含我们第一次无法发布的所有内容的版本。特里和我进行到一半时，马克进来说：“所以我们要收购这家公司。他们做了一个邮件阅读器，有点像你们所做的。” 我想，“哦。好的。好吧，我们有其中之一。” 他说，“嗯，是的，但我们发展得非常快，很难雇到优秀人才，有时你雇用优秀人才的方式就是收购另一家公司，因为他们已经通过审查适合你了。” “好的。这些人要做什么工作？” “他们将致力于您的项目。” “好的，</p><p class="normal">So we shipped 2.0 with the mail reader and it was well-received. Then we're working on 2.1, which is the version of the mail reader that I'm starting to consider done—this is the one with all the stuff that we couldn't ship the first time around. Terry and I are halfway through doing that and Marc comes in and says, “So we're buying this company. And they make a mail-reader thing that's kind of like what you guys did.” I'm like, “Oh. OK. Well, we have one of those.” And he says, “Well, yeah, but we're growing really fast and it's really hard to hire good people and sometimes the way you hire good people is you just acquire another company because then they've already been vetted for you.” “OK. What are these people going to be working on?” “They're going to be working on your project.” “OK, that kind of sucks—I'm going to go work on something else.”</p>
<p class="normal">所以基本上他们收购了这家公司，Collabra，并聘请了我和特里之上的整个管理结构。Collabra 有一款他们推出的产品在很多方面与我们所做的相似，只是它仅适用于 Windows，而且在市场上完全失败了。</p><p class="normal">So basically they acquired this company, Collabra, and hired this whole management structure above me and Terry. Collabra has a product that they had shipped that was similar to what we had done in a lot of ways except it was Windows-only and it had utterly failed in the marketplace.</p>
<p class="normal">然后他们中了创业彩票，被 Netscape 收购了。而且，基本上，Netscape 将公司的控制权交给了这家公司。因此，他们最终没有接管邮件阅读器，而是接管了整个客户部门。当 Collabra 被收购并开始重写时，Terry 和我一直在开发 Netscape 2.1。然后很明显，他们的 Netscape 3.0 将非常晚，我们的 2.1 变成了 3.0，因为是时候发布一些东西了，我们需要它成为一个主要版本。</p><p class="normal">Then they won the start-up lottery and they got acquired by Netscape. And, basically, Netscape turned over the reins of the company to this company. So rather than just taking over the mail reader they ended up taking over the entire client division. Terry and I had been working on Netscape 2.1 when the Collabra acquisition happened and then the rewrite started. Then clearly their Netscape 3.0 was going to be extremely late and our 2.1 turned into 3.0 because it was time to ship something and we needed it to be a major version.</p>
<p class="normal">所以他们开始研究的 3.0 变成了 4.0，正如你所知，这是有史以来最大的软件灾难之一。它基本上杀死了公司。它花了很长时间才死去，但仅此而已：由我们收购的这家公司掌舵的重写，谁从来没有<a id="OEBPS/Chapter01.html.page_20"></a>无所不能，无视我们所有的工作和所有的成功，直接进入第二系统综合症并使我们失望。</p><p class="normal">So the 3.0 that they had begun working on became 4.0 which, as you know, is one of the biggest software disasters there has ever been. It basically killed the company. It took a long time to die, but that was it: the rewrite helmed by this company we'd acquired, who'd never <a></a>accomplished much of anything, who disregarded all of our work and all of our success, went straight into second-system syndrome and brought us down.</p>
<p class="normal">他们认为只要来到这里，他们就一定会以自己的方式为荣耀而战。但是，当他们在公司按照自己的方式行事时，他们失败了。所以当那些成功的人对他们说，“看，真的，不要使用 C++；不要使用线程，”他们说，“你在说什么？你什么都不知道。”</p><p class="normal">They thought just by virtue of being here, they were bound for glory doing it their way. But when they were doing it their way, at their company, they failed. So when the people who had been successful said to them, “Look, really, don't use C++; don't use threads,” they said, “What are you talking about? You don't know anything.”</p>
<p class="normal">好吧，正是像不使用 C++ 和不使用线程这样的决定让我们按时交付了产品。另一件大事是我们总是同时发布所有平台；这是他们认为愚蠢的另一件事。“哦，90% 的人都在使用 Windows，所以我们将专注于 Windows 方面的事情，然后再移植它。” 这是许多其他失败的公司所做的。如果您正在尝试发布跨平台产品，那么历史确实表明您不能这样做。如果你想让它真正跨平台，你必须同时做。移植的事情导致第二个平台上的产品很糟糕。</p><p class="normal">Well, it was decisions like not using C++ and not using threads that made us ship the product on time. The other big thing was we always shipped all platforms simultaneously; that was another thing they thought was just stupid. “Oh, 90 percent of people are using Windows, so we'll focus on the Windows side of things and then we'll port it later.” Which is what many other failed companies have done. If you're trying to ship a cross-platform product, history really shows that's how you don't do it. If you want it to really be cross-platform, you have to do them simultaneously. The porting thing results in a crappy product on the second platform.</p>
<p class="normal"><b>Seibel：</b> 4.0 是从头重写的吗？</p><p class="normal"><b>Seibel:</b> Was the 4.0 rewrite from scratch?</p>
<p class="normal"><b>Zawinski：</b>他们并没有从一张空白磁盘开始，但他们最终替换了每一行代码。他们从一开始就使用 C++。我如此努力地与之抗争，该死的，我是对的。它使一切肿胀；它引入了所有这些兼容性问题，因为当您对 C++ 进行编程时，没有人会同意语言中哪 10% 是可以安全使用的。会有一个人决定，“我必须使用模板。” 然后你发现没有两个编译器以相同的方式实现模板。</p><p class="normal"><b>Zawinski:</b> They didn't start from scratch with a blank disk but they eventually replaced every line of code. And they used C++ from the beginning. Which I fought against so hard and, dammit, I was right. It bloated everything; it introduced all these compatibility problems because when you're programming C++ no one can ever agree on which ten percent of the language is safe to use. There's going to be one guy who decides, “I have to used templates.” And then you discover that there are no two compilers that implement templates the same way.</p>
<p class="normal">当你的背景，你的整个背景，都在编写代码，其中多平台意味着 Windows 3.1 和 Windows 95，你不知道这有多大。所以它让 Unix 方面的事情——谢天谢地不再是我的问题——变成了一场灾难。它使 Mac 方面的事情成为一场灾难。这意味着不再可能在像 Win16 这样的低端 Windows 机器上发布。我们不得不<a id="OEBPS/Chapter01.html.page_21"></a>开始削减平台。也许是时候这样做了，但这是一个糟糕的理由。这是不必要的。</p><p class="normal">And when your background, your entire background, is writing code where multiplatform means both Windows 3.1 and Windows 95, you have no concept how big a deal that is. So it made the Unix side of things—which thankfully was no longer my problem—a disaster. It made the Mac side of things a disaster. It meant it was no longer possible to ship on low-end Windows boxes like Win16. We had to <a></a>start cutting platforms out. Maybe it was time to do that, but it was a bad reason. It was unnecessary.</p>
<p class="normal">它真的感觉——这是我痛苦、自私的看待它的方式——就像特里和我建造了这个伟大的东西，却因为我们的成功而受到惩罚，把它交给了白痴。那是我在 Netscape 的一段非常不愉快的时光。那开始了我只是在那里等待归属的时期。</p><p class="normal">It really felt—this is my bitter, selfish way of looking at it—like Terry and I built this great thing and were punished for our success by having it handed over to idiots. That was a very unhappy time for me at Netscape. That began the period where I was only there waiting to vest.</p>
<p class="normal"><b>Seibel：</b>所以你在那里待了五年？</p><p class="normal"><b>Seibel:</b> So you lasted there five years?</p>
<p class="normal"><b>扎文斯基：</b>是的。授予期过去一年，因为就在授予日之前，mozilla.org 盯着看，这又一次非常有趣，所以我坚持了下来。</p><p class="normal"><b>Zawinski:</b> Yeah. A year past vesting, because just before vesting day mozilla.org stared and that was really interesting again, so I stuck around for that.</p>
<p class="normal"><b>Seibel：</b>您最终是否被迫使用 C++？</p><p class="normal"><b>Seibel:</b> Did you ultimately get dragged into using C++?</p>
<p class="normal"><b>Zawinski：</b>嗯，有 Java 的东西。有一次，我们打算用 Java 重写浏览器。我们就像，“是的！我们要放弃那个会毁了我们公司的 4.0 代码库，这真的会奏效，因为，就像，我们知道我们在做什么！”</p><p class="normal"><b>Zawinski:</b> Well, there was the Java thing. At one point, we were going to rewrite the browser in Java. We were like, “Yes! We're going to get to ditch that 4.0 code base which is going to destroy our company and this is gonna actually work because, like, we know what we're doing!”</p>
<p class="normal">它没有用。</p><p class="normal">And it didn't work.</p>
<p class="normal"><b>Seibel：</b>它不能工作是因为 Java 还没有准备好吗？</p><p class="normal"><b>Seibel:</b> Did it just not work because Java wasn't ready?</p>
<p class="normal"><b>Zawinski：</b>没有。我们又被分成了相当明确的小组。我们三个人在开发邮件阅读器。我们完成了。我们有一个非常好的邮件阅读器，速度很快，有很多非常好的功能，而且在保存数据方面做得更好——在写入大文件时从来没有任何停顿。我们很好地利用了 Java 中的多线程，这没有我预期的那么痛苦。工作真的很愉快。从我们设计的 API 中，我们看到了它可以发展的所有这些方向。</p><p class="normal"><b>Zawinski:</b> No. We were all broken up into fairly well-defined groups again. There were three of us working on the mail reader. And we were done. We had a really nice mail reader that was fast and had a lot of really nice features and was better about saving your data—there were never any stalls where it was writing some big file. We took really good advantage of multithreading in Java, which was less painful than I had expected it to be. It was just really pleasant to work on. From the API we had designed we saw all these directions it could grow.</p>
<p class="normal">除了它不能做的一件事是显示消息。因为它所做的是，它生成 HTML 并显示 HTML，您需要一个 HTML 显示层，而这并没有完成，也从未完成。这<a id="OEBPS/Chapter01.html.page_22"></a>布局组完全陷入困境，他们是该项目被取消的原因。</p><p class="normal">Except the one thing that it couldn't do was display messages. Because what it did was, it generated HTML and to display HTML you need an HTML display layer, which wasn't done and was never finished. The <a></a>layout group just completely went down a rat hole and they were the reason that that project got canceled.</p>
<p class="normal"><b>Seibel：</b>所以他们可能正在与当时不成熟的 Java GUI 技术作斗争。</p><p class="normal"><b>Seibel:</b> So they were presumably wrestling with the—at that time—immature Java GUI technology.</p>
<p class="normal"><b>扎文斯基：</b>我不这么认为。因为所有的铬都有效。窗口中间只有一个大的空白矩形，我们只能在其中显示纯文本。他们对他们的项目非常学术。他们试图从事物的 DOM/DTD 方面来处理它。“哦，好吧，我们需要做的是在这里添加另一个抽象层，并为这个委托有一个委托。最终一个角色会出现在屏幕上。”</p><p class="normal"><b>Zawinski:</b> I don't think so. Because all the chrome worked. There was just this big blank rectangle in the middle of the window where we could only display plain text. They were being extremely academic about their project. They were trying to approach it from the DOM/DTD side of things. “Oh, well, what we need to do is add another abstraction layer here and have a delegate for this delegate for this delegate. And eventually a character will show up on the screen.”</p>
<p class="normal"><b>Seibel：</b>过度设计似乎是你的一个小毛病。</p><p class="normal"><b>Seibel:</b> Overengineering seems to be a pet peeve of yours.</p>
<p class="normal"><b>扎文斯基：</b>是的。在一天结束的时候，运送他妈的东西！重写您的代码并使其更清晰是很棒的，到第三次时它实际上会很漂亮。但这不是重点——你不是来写代码的；你是来写代码的。你是来运送产品的。</p><p class="normal"><b>Zawinski:</b> Yeah. At the end of the day, ship the fucking thing! It's great to rewrite your code and make it cleaner and by the third time it'll actually be pretty. But that's not the point—you're not here to write code; you're here to ship products.</p>
<p class="normal"><b>Seibel：</b>从事过度工程的人通常会说，“好吧，一旦我有了这个框架，之后一切都会很容易。所以我这样做实际上会节省时间。”</p><p class="normal"><b>Seibel:</b> Folks engaged in overengineering usually say, “Well, once I've got this framework in place everything will be easy after that. So I'll actually save time by doing this.”</p>
<p class="normal"><b>Zawinski：</b>理论总是这样。</p><p class="normal"><b>Zawinski:</b> That is always the theory.</p>
<p class="normal"><b>Seibel：</b>有时这个理论是正确的，当某人有良好的判断力并且框架不太复杂时，它确实节省了时间。有什么方法可以告诉你你在哪一边？</p><p class="normal"><b>Seibel:</b> And there are times when that theory is true, when someone has good sense and the framework isn't too elaborate, and it does save time. Is there any way you can tell which side of the line you're on?</p>
<p class="normal"><b>Zawinski：</b>我知道这有点陈词滥调，但它又回到了更糟的是更好。如果你花时间构建一个完美的框架，它将做你想做的事，它将带你从 1.0 版到 5.0 版，一切都会变得很棒；你猜怎么着：1.0 版要花你三年的时间才能发布，而你的竞争对手将在六个月内发布他们的 1.0，现在你出局了<a id="OEBPS/Chapter01.html.page_23"></a>游戏的。你从来没有因为别人吃了你的午餐而发布了你的 1.0。</p><p class="normal"><b>Zawinski:</b> I know it's kind of a cliché but it comes back to worse is better. If you spend the time to build the perfect framework that's going to do what you want and that's going to carry you from release 1.0 through release 5.0 and everything's going to be great; well guess what: release 1.0 is going to take you three years to ship and your competitor is going to ship their 1.0 in six months and now you're out <a></a>of the game. You never shipped your 1.0 because someone else ate your lunch.</p>
<p class="normal">你的竞争对手的 6 个月 1.0 有垃圾代码，他们将不得不在两年内重写它，但是，你猜怎么着：他们可以重写它，因为你不再有工作了。</p><p class="normal">Your competitor's six-month 1.0 has crap code and they're going to have to rewrite it in two years but, guess what: they can rewrite it because you don't have a job anymore.</p>
<p class="normal"><b>Seibel：</b>一定有过这样的情况，也许是在更短的时间范围内，您已经删除了一大块代码，因为您认为重新开始会更快。</p><p class="normal"><b>Seibel:</b> There must have been times, perhaps on a shorter time frame, where you've ripped out a big chunk of code because you thought it would be faster to start over.</p>
<p class="normal"><b>Zawinski：</b>是的，确实有一些时候你必须止损。这对我来说总是感觉不对，但是当您从其他人那里继承代码时，有时自己编写代码比重用他们的代码更快。因为要花一定的时间来理解他们的代码并学习如何使用它并充分理解它以便能够对其进行调试。如果您从头开始，那将花费更少的时间。它可能只能完成您需要的 80%，但也许这就是您实际需要的 80%。</p><p class="normal"><b>Zawinski:</b> Yes, there are definitely times when you have to cut your losses. And this always feels wrong to me, but when you inherit code from someone else, sometimes it's faster to write your own than to reuse theirs. Because it's going to take a certain amount of time to understand their code and learn how to use it and understand it well enough to be able to debug it. Where if you started from scratch it would take less time. And it might only do 80 percent of what you need, but maybe that's the 80 percent you actually need.</p>
<p class="normal"><b>Seibel：</b>这不正是这个东西吗？有人过来说，“我无法理解这些东西。我会重写它”——这会导致您在开源开发中抱怨无休止的重写？</p><p class="normal"><b>Seibel:</b> Isn't it exactly this thing—someone comes along and says, “I can't understand this stuff. I'll just rewrite it”—that leads to the endless rewriting you bemoan in open-source development?</p>
<p class="normal"><b>扎文斯基：</b>是的。但还有另一个方面，即抛开效率不谈，编写自己的代码比弄清楚别人的代码更有趣。所以很容易理解为什么会这样。但是整个 Linux/GNOME 方面的事情都跨越了某人的爱好和产品之间的这条线。这是一个研究项目，我们在其中决定桌面应该是什么样子并进行试验吗？或者我们正在与 Macintosh 竞争？是哪个？很难做到两全其美。</p><p class="normal"><b>Zawinski:</b> Yeah. But there's also another aspect of that which is, efficiency aside, it's just more fun to write your own code than to figure out someone else's. So it's easy to understand why that happens. But the whole Linux/GNOME side of things is straddling this line between someone's hobby and a product. Is this a research project where we're deciding what desktops should look like and we're experimenting? Or are we competing with Macintosh? Which is it? Hard to do both.</p>
<p class="normal">但即使这样措辞也会让人听起来好像有人真正负责做出该决定，这根本不是真的。所有这些事情都会发生。发生的事情之一是所有内容都在不断被重写，而且什么都没有完成。如果您是这些开发人员中的一员，那很好，因为如果您的爱好是捣乱，总有一些东西可以玩<a id="OEBPS/Chapter01.html.page_24"></a>您的计算机而不是达到目的的手段——成为您用来完成您真正感兴趣的事情的工具。</p><p class="normal">But even phrasing it that way makes it sounds like there's someone who's actually in charge making that decision, which isn't true at all. All of this stuff just sort of happens. And one of the things that happens is everything gets rewritten all the time and nothing's ever finished. If you're one of those developers, that's fine because there's always something to play around with if your hobby is messing around with <a></a>your computer rather than it being a means to an end—being a tool you use to get whatever you're actually interested in done.</p>
<p class="normal"><b>Seibel：</b>说到为了自己而摆弄电脑，你还喜欢编程吗？</p><p class="normal"><b>Seibel:</b> Speaking of messing around with a computer for its own sake, do you still enjoy programming?</p>
<p class="normal"><b>扎文斯基：</b>有时候。我最终做了所有系统管理员的废话，这是我无法忍受的——我从来都不喜欢它。我喜欢在 XScreenSaver 上工作，因为在某些方面，屏幕保护程序——实际显示模式而不是 XScreenSaver 框架——是完美的程序，因为它们几乎总是从头开始，它们做的事情很漂亮，而且从来没有 2.0 版。屏幕保护程序中很少有错误。它崩溃了——哦，有一个被零除的问题，你解决了这个问题。</p><p class="normal"><b>Zawinski:</b> Sometimes. I end up doing all the sysadmin crap, which I can't stand—I've never liked it. I enjoy working on XScreenSaver because in some ways screen savers—the actual display modes rather than the XScreenSaver framework—are the perfect program because they almost always start from scratch and they do something pretty and there's never a version 2.0. There's very rarely a bug in a screen saver. It crashes—oh, there's a divide-by-zero and you fix that.</p>
<p class="normal">但是没有人会要求屏幕保护程序中的新功能。“我希望它更黄一些。” 您不会收到这样的错误报告。就是这样。所以这就是为什么我总是为了好玩而写那些。他们做出了这个整洁的结果，你不必考虑太多。他们不会缠着你。</p><p class="normal">But no one is ever going to ask for a new feature in a screen saver. “I wish it was more yellow.” You're not going to get a bug report like that. It is what it is. So that's why I've always written those for fun. They make this neat result and you don't have to think about them too much. They don't haunt you.</p>
<p class="normal"><b>Seibel：</b>你喜欢做一些数学和弄清楚几何图形的难题吗？</p><p class="normal"><b>Seibel:</b> And do you enjoy the puzzle of doing some math and figuring out geometry and graphics?</p>
<p class="normal"><b>扎文斯基：</b>是的。如果我这样显示这个抽象的小方程会是什么样子？或者，我怎样才能使这些斑点四处移动，看起来更有机、更不僵硬，就像计算机通常移动东西一样？像这样的东西。我要如何处理这些正弦波才能使其看起来更像是在弹跳？</p><p class="normal"><b>Zawinski:</b> Yeah. What's this abstract little equation going to look like if I display it this way? Or, how can I make these blobs move around that looks more organic and less rigid, like a computer normally moves things? Stuff like that. What do I do to these sine waves to make it look more like something bouncing?</p>
<p class="normal">然后我最终写了所有这些愚蠢的小 shell 脚本——自卫的东西。我知道我可以通过单击 30,000 个网页并手动完成来做到这一点，但为什么我不写这个脚本——节省时间的小东西。这对我来说几乎不像编程。我知道对于不是程序员的人来说，这似乎是一种魔法。</p><p class="normal">And then I end up writing all these stupid little shell scripts—self-defense stuff. I know I could do this by clicking on 30,000 web pages and doing it by hand, but why don't I write this script—little time-saver things. Which barely feels like programming to me. I know to people who aren't programmers, that seems like a black art.</p>
<p class="normal">我真的很喜欢做 XScreenSaver 框架的 Mac 端口。这实际上是在编写大量需要考虑 API 和事物结构的新代码。</p><p class="normal">I really enjoyed doing the Mac port of the XScreenSaver framework. That was actually writing a lot of new code that required thinking about APIs and the structure of the thing.</p>
<p class="normal"><a id="OEBPS/Chapter01.html.page_25"></a><b>Seibel：</b>那是你们的 API——你们是如何构建代码的？</p><p class="normal"><a></a><b>Seibel:</b> Was that your APIs—how you were structuring your code?</p>
<p class="normal"><b>扎文斯基：</b>两者都有。既找出现有的 API，又找出在 X11 世界和 Mac 世界之间构建层的最佳方法。我应该如何构建它？哪个 Mac API 最合适？这是很长一段时间以来我第一次做这样的事情，就像，“哇，这很有趣。我想我可能有点擅长这个。”</p><p class="normal"><b>Zawinski:</b> Both. Both figuring out the existing APIs and figuring out the best way to build a layer between the X11 world and the Mac world. How should I structure that? Which of the Mac APIs is most appropriate? It was the first time in a long time that I'd done something like that and it was just like, “Wow, this is kind of fun. I think I might be kind of good at this.”</p>
<p class="normal"><i>这是永远的，因为我对软件行业</i>完全厌倦了。我无法再忍受其中的那一部分——企业界和自由软件界的政治。我只是吃得太多了。我想做一些不涉及在线争论琐事的事情。或者我的产品被我没有参与的官僚决定摧毁。</p><p class="normal">It had been forever because I got completely burned out on the software <i>industry</i>. That part of it I just couldn't take anymore—the politics of it both in the corporate world and in the free-software world. I'd just had too much. I wanted to do something that didn't involve arguing online about trivia. Or having my product destroyed by bureaucratic decisions that I had no input in.</p>
<p class="normal"><b>Seibel：</b>你有没有想过回去破解 Mozilla？</p><p class="normal"><b>Seibel:</b> Are you ever tempted to go back and hack on Mozilla?</p>
<p class="normal"><b>扎文斯基：</b>不。我只是不想再在 Bugzilla 中与人争论和争吵。那不好玩。那种东西是构建大产品所必需的。如果它需要不止一个人来处理，显然 Mozilla 就是这样做的，那么你就必须这样做。但我不再期待那种战斗了。多年来，我已经失去了这一点。作为程序员，另一种选择是为别人工作。我不必那样做，所以我不能。我的第一个糟糕的一天我就离开了。如果我要创办自己的公司，我就不能成为一名程序员——我必须经营公司。</p><p class="normal"><b>Zawinski:</b> Nah. I just don't want to be arguing with people and having pissing matches in Bugzilla anymore. That's not fun. That kind of thing is necessary to build big products. If it's something that requires more than one person working on it, which obviously Mozilla does, that's the way you have to do it. But I don't look forward to that kind of fight anymore. That's been beaten out of me by too many years of it. And the other alternative, as a programmer, is go work for someone else. And I don't have to do that, so I can't. My first bad day I'd just leave. And were I to start my own company I couldn't be a programmer—I'd have to run the company.</p>
<p class="normal"><b>Seibel：</b>除了让 200 万人使用您的软件之外，您还喜欢编程吗？</p><p class="normal"><b>Seibel:</b> Other than having two million people using your software, what about programming do you enjoy?</p>
<p class="normal"><b>Zawinski：</b>这是一个很难回答的问题。我猜是它解决问题的方面。这不像是拼图游戏——我玩的拼图类游戏不多。只是弄清楚如何从 A 点到达 B 点——如何让机器做你想做的事。这是编程满意度的基本要素。</p><p class="normal"><b>Zawinski:</b> It's a hard question. The problem-solving aspect of it, I guess. It's not quite like it's a puzzle—I don't really play many puzzle-type games. Just figuring out how to get from point A to point B—how to make the machine do what you want. That's the basic element that the satisfaction of programming comes from.</p>
<p class="normal"><a id="OEBPS/Chapter01.html.page_26"></a><b>Seibel：</b>你觉得代码漂亮吗？是否存在可维护性之外的审美？</p><p class="normal"><a></a><b>Seibel:</b> Do you find code beautiful? Is there an aesthetic beyond maintainability?</p>
<p class="normal"><b>Zawinski：</b>是的，当然。任何表达得恰到好处的东西，无论是非常简洁还是只是捕捉它——就像任何东西，一个非常好的组合句子或一个小涂鸦，一个看起来像一个人但只用了四行的漫画，那种东西——它是同样的事情。</p><p class="normal"><b>Zawinski:</b> Yeah, definitely. Anything expressed just right, whether it's being really concise or just capturing it—like anything, a really well-put-together sentence or a little doodle, a caricature that looks just like someone but only used four lines, that kind of thing—it's the same sort of thing.</p>
<p class="normal"><b>Seibel：</b>你觉得编程和写作是相似的智力练习吗？</p><p class="normal"><b>Seibel:</b> Do you find that programming and writing are similar intellectual exercises?</p>
<p class="normal"><b>Zawinski：</b>在某些方面，是的。编程显然要严格得多。但就表达思想的整体能力而言，它们非常相似。不要漫无边际，在你的脑海中对你想说的话有一个想法，然后简明扼要。我认为那种思维是编程和写散文之间的重叠。</p><p class="normal"><b>Zawinski:</b> In some ways, yeah. Programming is obviously much more rigid. But as far as the overall ability to express a thought, they're very similar. Not rambling, having an idea in your head of what you're trying to say, and then being concise about it. I think that kind of thinking is the overlap between programming and writing prose.</p>
<p class="normal">感觉他们使用了我大脑的相似部分，但很难准确表达它是什么。很多时候我会读到一些看起来很糟糕的代码。像大多数合同一样。他们使用的真正死板的风格——太重复了。我看着那个，我想，你为什么不能把它分解成一个子程序——我们称之为段落。他们通常以定义开头的方式，比如，某某，被称为 blah blah blah。</p><p class="normal">It feels like they use similar parts of my brain, but it's hard to express exactly what it is. A lot of times I'll read things that just look like bad code. Like most contracts. The really rigid style they use—it's so repetitive. I look at that and I'm like, why can't you break this out into a subroutine—which we call paragraphs. And the way they usually begin with definitions, like, so and so, referred to as blah blah blah.</p>
<p class="normal"><b>Seibel：</b>让我们谈谈编程的本质。你如何设计你的代码？你如何构建代码？也许以您最近在 OS X XScreenSaver 上的工作为例。</p><p class="normal"><b>Seibel:</b> Lets talk a little bit about the nitty-gritty of programming. How do you design your code? How do you structure code? Maybe take your recent work on the OS X XScreenSaver as an example.</p>
<p class="normal"><b>Zawinski：</b>好吧，首先我搞砸了，制作了一些小的演示程序，但这些程序再也没有被使用过。只是想弄清楚这里是如何在屏幕上放置一个窗口，等等。因为我正在实施 X11，所以要做的第一件事就是选择一个屏幕保护程序并列出它发出的所有 X11 调用。</p><p class="normal"><b>Zawinski:</b> Well, first I messed around and made little demo programs that never ended up being used again. Just to figure out here's how you put a window on the screen, and so on. Since I'm implementing X11, the first thing to do is pick one of the screen savers and make the list of all the X11 calls it makes.</p>
<p class="normal">然后我为每一个创建存根，然后我慢慢地开始填充它们，弄清楚我将如何实现这个，我将如何实现这个。</p><p class="normal">Then I create stubs for each of those and then I slowly start filling them in, figuring out how am I going to implement this one, how am I going to implement this one.</p>
<p class="normal"><a id="OEBPS/Chapter01.html.page_27"></a>在另一个层面上，在 Mac 方面，有启动代码。窗口是如何出现在屏幕上的？在某些时候，它会调出 X 代码。其中一个比较棘手的部分是真正弄清楚如何设置构建系统以使其以任何一种理智的方式工作。所以一堆实验。搬东西。在某些时候，也许我已经将这段代码置于顶部，并且这段代码被它调用。然后也许需要将这些内容翻出来。所以有很多剪切和粘贴，直到我把我的头缠绕在一个看起来合理的控制流上。然后我进去把东西清理干净，把东西放在更合适的文件里，这样这段代码就和这段代码在一起了。</p><p class="normal"><a></a>At another level, on the Mac side of things, there's the start-up code. How is the window getting on the screen? And at some point that's going to call out to the X code. One of the trickier parts of that was really figuring out how to set up the build system to make that work in any kind of sane way. So a bunch of experimentation. Moving things around. At some point, maybe I'd had this piece of code on top and this piece of code being called by it. And then maybe those need to be turned inside out. So there's a lot of cut-and-pasting until I kind of wrapped my head around a flow of control that seemed sensible. Then I went in and cleaned things up and put things in more appropriate files so this piece of code is together with this piece of code.</p>
<p class="normal">这是一种广泛的笔触，建立基础设施。之后，只需转到下一个屏幕保护程序即可；这个使用了前一个没有使用过的这三个函数，所以我必须实现它们。这些任务中的每一项都相当简单。有些最终变得非常棘手，因为 X11 API 有大量选项可用于在屏幕上放置文本和四处移动矩形。所以我一直不得不让那段代码越来越毛茸茸。但他们中的大多数人都相当直截了当。</p><p class="normal">That was sort of the broad strokes, building the infrastructure. After that it was just a matter of moving on to the next screen saver; this one uses these three functions that the previous one hadn't used before, so I've got to implement those. And each of those tasks was fairly straightforward. There were some that ended up being really tricky because the X11 API has a ton of options for putting text on the screen and moving rectangles around. So I kept having to make that piece of code hairier and hairier. But most of them were fairly straightforward.</p>
<p class="normal"><b>Seibel：</b>所以对于这些 X11 调用中的每一个，您都在编写一个实现。你有没有发现你正在积累很多非常相似的代码？</p><p class="normal"><b>Seibel:</b> So for each of these X11 calls you're writing an implementation. Did you ever find that you were accumulating lots of bits of very similar code?</p>
<p class="normal"><b>Zawinski：</b>哦，是的，当然。通常在你第二次或第三次剪切和粘贴那段代码时，好吧，是时候停止剪切和粘贴并将其放入子例程中了。</p><p class="normal"><b>Zawinski:</b> Oh, yeah, definitely. Usually by the second or third time you've cut and pasted that piece of code it's like, alright, time to stop cutting and pasting and put it in a subroutine.</p>
<p class="normal"><b>Seibel：</b>如果您正在再次编写邮件阅读器的规模，您提到从几段文本和一个功能列表开始。这是您在开始编写代码之前所能达到的最佳粒度吗？</p><p class="normal"><b>Seibel:</b> If you were doing something on the scale of writing a mail reader again, you mentioned starting with a few paragraphs of text and a list of features. Is that the finest granularity that you would get to before you would just start writing code?</p>
<p class="normal"><b>扎文斯基：</b>是的。也许会对库和前端之间的划分有一个模糊的描述。但可能不是。如果我一个人工作，我不会为此烦恼，因为那部分对我来说是显而易见的。然后我要做的第一件事就是<a id="OEBPS/Chapter01.html.page_28"></a>即从顶部或底部开始。所以从任何一个开始，在屏幕上放一个窗口，上面有一些按钮，然后向下挖掘并开始构建这些按钮所做的事情。或者你可以从另一边开始，开始编写解析邮箱和保存邮箱的东西。无论哪种方式。或两者都在中间相遇。</p><p class="normal"><b>Zawinski:</b> Yeah. Maybe there'd be a vague description of the division between library and front end. But probably not. If I was working alone I wouldn't bother with that because that part is just kind of obvious to me. And then the first thing I would do with something like <a></a>that is either start at the top or at the bottom. So start with either, put a window on the screen that has some buttons on it, and then dig down and start building the stuff that those buttons do. Or you can start at the other side and start writing the thing that parses mailboxes and that saves mailboxes. Either way. or both and meet in the middle.</p>
<p class="normal">我发现尽快在屏幕上显示一些内容确实有助于我集中精力解决问题。它帮助我决定下一步要做什么。因为如果你只是看着那个大的待办事项清单，就像，嗯，我不知道我应该做哪一个——我做哪一个重要吗？但是，如果您确实可以查看某些内容，即使它只是您的邮箱解析器的调试输出，它就像是，好吧！那是什么；这需要进入的下一个方向是什么？好的，而不是仅仅显示树结构，现在也许我应该发出 HTML 或类似的东西。或者以更详细的方式解析标头。您只需从那里寻找下一件事。</p><p class="normal">I find that getting something on the screen as soon as possible really helps focus the problem for me. It helps me decide what to work on next. Because if you're just looking at that big to-do list it's like, eh, I don't know which one I should do—does it matter which one I do? But if there's something you can actually look at, even if it's just the debug output of your mailbox parser, it's like, OK, there! That's something; what's the next direction this needs to go in? OK, instead of just displaying a tree structure, now maybe I should be emitting HTML or something along those lines. Or parsing the headers in a more detailed way. You just look for the next thing to build on from there.</p>
<p class="normal"><b>Seibel：</b>你会重构以保持代码的内部结构连贯吗？还是您一开始就非常清楚这一切将如何组合在一起？</p><p class="normal"><b>Seibel:</b> Do you refactor to keep the internal structure of the code coherent? Or do you just have a very good sense at the beginning how it's all going to fit together?</p>
<p class="normal"><b>Zawinski：</b>我通常对此有很好的感觉。我不记得有多少次我想，“哦，我把这整件事彻底搞砸了。我将不得不移动所有东西。” 有时确实会发生这种情况。</p><p class="normal"><b>Zawinski:</b> I usually have a pretty good sense of that. I don't remember too many occasions where I thought, “Oh, I did this whole thing inside out. I'm going to have to move everything around.” That does happen sometimes.</p>
<p class="normal">当我刚刚编写程序的第一个版本时，我倾向于将所有内容放在一个文件中。然后我开始看到该文件中的结构。就像这块非常相似的东西。现在已经是一千行了，为什么我不把它移到另一个文件中呢。API 以这种方式有机地构建起来。设计过程绝对是一个持续的事情；在程序完成之前，您永远不知道设计是什么。所以我宁愿尽早弄湿我的脚；在屏幕上放一些东西，这样我就可以从侧面看。</p><p class="normal">When I'm just writing the first version of the program, I tend to put everything in one file. And then I start seeing structure in that file. Like there's this block of things that are pretty similar. That's a thousand lines now, so why don't I move that into another file. And the API sort of builds up organically that way. The design process is definitely an ongoing thing; you never know what the design is until the program is done. So I prefer to get my feet wet as early as possible; get something on the screen so I can look at it sideways.</p>
<p class="normal">此外，一旦开始编写代码，您就会意识到，“不，那是个愚蠢的想法。为什么我认为这个模块会非常简单，而实际上它比我想象的要复杂得多？”<a id="OEBPS/Chapter01.html.page_29"></a>在您真正开始编写代码并且感觉它离您越来越远之前，您不会了解这些内容。</p><p class="normal">Also, once you start writing the code, you're gonna realize, “No, that was a dumb idea. Why did I think that this module was going to be really easy when actually it's way more complicated than I thought?” <a></a>Which is something you're not going to clue into until you actually start writing code and you feel it getting away from you.</p>
<p class="normal"><b>Seibel：</b>有什么迹象表明某些东西正在远离你？</p><p class="normal"><b>Seibel:</b> What are the signs that something is getting away from you?</p>
<p class="normal"><b>Zawinski：</b>当你开始做某事时，你的脑子里想，“哦，这要花我半天时间，而且它会是这么大的一大块代码，”然后你开始做，你就会有那种沉没的感觉就像，“哦，对了，我也需要这件作品；好吧，我最好去做那件事。哦，那是个大问题。”</p><p class="normal"><b>Zawinski:</b> When you go into something and you have in your head, “Oh, this is going to take me half a day and it's gonna be a chunk of code this size,” and then you start doing it and you get that sinking feeling like, “Oh, right, I need this other piece too; well, I'd better go off and do that. Oh, and that's kind of a big problem.”</p>
<p class="normal"><b>Seibel：</b>我注意到区分好程序员和坏程序员的一件事是，好程序员更容易在抽象层之间跳转——他们可以在进行更改时保持各层的区别，并选择正确的层进行更改。</p><p class="normal"><b>Seibel:</b> I've noticed that one thing that separates good programmers from bad programmers is that good programmers are more facile at jumping between layers of abstraction—they can keep the layers distinct while making changes and choose the right layer to make changes in.</p>
<p class="normal"><b>Zawinski：</b>在你决定放置东西的地方肯定要有某种风格——这在未来可能会很重要。能够只是在靠近用户的某个地方破解它，而不是进行可能会在底部产生影响的更大的更改——这两种方法中的任何一种都可能是正确的答案，而且很难知道哪个是哪个。我需要做的这个改变，真的是一个小特例还是最终会有 12 个这样的？</p><p class="normal"><b>Zawinski:</b> There's definitely got to be some style in where you decide to put things—it can matter a lot down the line. Being able to just hack it out somewhere up near the user versus making a maybe larger change that may have repercussions down at the bottom—either of those can be the right answer and it is tricky to know which is which. This change I need to make, is it really one little special case or are there eventually going to be 12 of these?</p>
<p class="normal">我认为最重要的事情之一，无论如何对我来说，当从头开始构建这样的东西时，尽可能快地让程序达到你，程序员可以使用它的状态。哪怕是一点点。因为这会以一种发自内心的方式告诉你下一步该去哪里。一旦东西出现在屏幕上并且你已经连接了一个按钮来做一件事，现在你有点知道下一个是哪个按钮了。显然，这是对我所说内容的以 GUI 为中心的描述。</p><p class="normal">I think one of the most important things, for me anyway, when building something from the ground up like that is, as quickly as possible, getting the program to a state that you, the programmer, can use it. Even a little bit. Because that tells you where to go next in a really visceral way. Once the thing's on the screen and you've got the one button hooked up that does one thing, now you kind of know, which button is next. Obviously that's a GUI-centric description of what I'm talking about.</p>
<p class="normal"><b>Seibel：</b>我们谈到了一些非常可怕的错误，你必须像使用 GDB 那样追踪这些错误。但是让我们多谈谈调试。对于初学者，您首选的调试工具是什么？打印报表？符号调试器？正确性的正式证明？</p><p class="normal"><b>Seibel:</b> We talked a bit about some of the really hideous bugs you had to track down like that thing with GDB. But let's talk a little bit more about debugging. For starters, what's your preferred debugging tool? Print statements? Symbolic debuggers? Formal proofs of correctness?</p>
<p class="normal"><a id="OEBPS/Chapter01.html.page_30"></a><b>Zawinski：</b>这些年来情况发生了很大变化。当我使用 Lisp 机器时，一切都是关于运行程序和停止它以及探索数据——有一个检查器工具可以让你浏览内存，我改变了它所以基本上 Lisp 监听器变成了一个检查器。因此，无论何时打印出一个对象，上面都有一个上下文菜单，因此您可以在此处单击该对象并返回该值。只是为了更容易跟踪对象链之类的东西。很早以前我就是这么想的。深入研究代码并四处追逐和试验。</p><p class="normal"><a></a><b>Zawinski:</b> That's changed over the years a lot. When I was using the Lisp machines it was all about running the program and stopping it and exploring the data—there was an inspector tool that let you browse through memory and I changed it so basically the Lisp listener became an inspector. So anytime time it printed out an object there was a context menu on it so you could click on this thing here and have that value returned. Just to make it easier to follow around chains of objects and that sort of thing. So early on that was how I thought about things. Getting down in the middle of the code and chasing it around and experimenting.</p>
<p class="normal">然后，当我开始编写 C 语言并在 Emacs 中使用 GDB 时，我试图保持同样的做事方式。这就是我们围绕 Energize 构建的模型。而且这似乎从来没有奏效过。随着时间的流逝，我逐渐停止尝试使用这样的工具，只是坚持打印语句并再次运行它。重复直到完成。特别是当你接触到越来越多的原始环境，如 JavaScript 和 Perl 之类的东西时，这是你唯一的选择——没有任何调试器。</p><p class="normal">Then when I started writing C and using GDB inside of Emacs I kind of tried to keep up that same way of doing things. That was the model we built Energize around. And that just never seemed like it worked very well. And as time went by I gradually stopped even trying to use tools like that and just stick in print statements and run the thing again. Repeat until done. Especially when you get to more and more primitive environments like JavaScript and Perl and stuff like that, it's the only choice you have—there aren't any debuggers.</p>
<p class="normal">如今，人们似乎对调试器的概念感到困惑。“哦，你为什么需要那个？它有什么作用——为您输入打印语句？我不明白。你用的这些奇怪的词是什么？现在主要是打印报表。</p><p class="normal">People these days seem confused about the notion of what a debugger is. “Oh, why would you need that? What does it do—put print statements in for you? I don't understand. What are these strange words you use?” Mostly these days it's print statements.</p>
<p class="normal"><b>Seibel：</b>其中有多少是由于 Lisp 和 C 之间的差异，而不是工具——一个区别是在 Lisp 中你可以测试小部件——你可以调用一个你不确定是否正常工作的小函数，然后在中间休息一下，然后检查发生了什么。而 C 就像是，在其所有复杂的荣耀中运行整个程序并在某处放置一个断点。</p><p class="normal"><b>Seibel:</b> How much of that was due to the differences between Lisp and C, as opposed to the tools—one difference is that in Lisp you can test small parts—you can call a small function you're not sure is working right and then put a break in the middle of it and then inspect what's going on. Whereas C it's like, run the whole program in all of its complex glory and put a break point somewhere.</p>
<p class="normal"><b>Zawinski：</b>类 Lisp 的语言比 C 更适合于此。Perl 和 Python 以及类似的语言在这方面具有更多的 Lisp 特性，但我仍然看不到人们这样做的频率很高。</p><p class="normal"><b>Zawinski:</b> Lisp-like languages lend themselves more to that than C. Perl and Python and languages like that have a little more of the Lisp nature in that way but I still don't see people doing it that way very much.</p>
<p class="normal"><b>Seibel：</b>但是 GDB 确实给了你检查东西的能力。它对你不可用怎么办？</p><p class="normal"><b>Seibel:</b> But GDB does give you the ability to inspect stuff. What about it makes it not usable for you?</p>
<p class="normal"><a id="OEBPS/Chapter01.html.page_31"></a><b>Zawinski：</b>我一直觉得这很不愉快。它的一部分只是作为 C 的固有特性。在一个数组中四处寻找，现在我正在查看一堆数字，现在我必须进入其中并将其转换为它真正的样子。它从来没有像更好的语言那样正确地做到这一点。</p><p class="normal"><a></a><b>Zawinski:</b> I always found it unpleasant. Part of it is just intrinsic to being C. Poking around in an array and now I'm looking at a bunch of numbers and now I have to go in there and cast the thing to whatever it really is. It just never managed that right, the way a better language would.</p>
<p class="normal"><b>Seibel：</b>而在 Lisp 中，如果你正在查看一个 Lisp 数组，它们只会被打印成那些东西，因为它知道它们是什么。</p><p class="normal"><b>Seibel:</b> Whereas in Lisp, if you're looking at a Lisp array, they'll just be printed as those things because it knows what they are.</p>
<p class="normal"><b>扎文斯基：</b>没错。在 GDB 中似乎总是上下跳动，堆栈的东西会变得一团糟。你在堆栈中往上走，然后你下面的东西发生了变化，这通常是因为 GDB 在某种程度上出现了故障。或者，哦，好吧，它期望这个寄存器在这里，而你在不同的堆栈框架中，所以这不再重要了。</p><p class="normal"><b>Zawinski:</b> Exactly. It always just seemed in GDB like bouncing up and down, the stack things would just get messed up. You'd go up the stack and things have changed out from under you and often that's because GDB is malfunctioning in some way. Or, oh well, it was expecting this register to be here and you're in a different stack frame, so that doesn't count anymore.</p>
<p class="normal">总觉得我无法真正相信调试器实际告诉我的内容。它会打印一些东西，看，有一个数字。这是真的还是假的？我不知道。很多时候你最终得不到调试信息。所以你在一个堆栈框架中，看起来它没有参数，然后我会花十分钟试图记住参数零所在的寄存器。然后放弃，重新链接并放入打印语句。</p><p class="normal">It just always felt like I couldn't really trust what the debugger was actually telling me. It would print something and, look, there's a number. Is that true or not? I don't know. And a lot of times you'd end up with no debug info. So you're in a stack frame and it looks like it has no arguments and then I'd spend ten minutes trying to remember the register that argument zero goes in is. Then give up, relink and put in a print statement.</p>
<p class="normal">似乎随着时间的推移，调试设施变得越来越差。但另一方面，现在人们终于意识到手动分配内存不是可行的方法；它不再那么重要了，因为那些你必须深入挖掘数据结构的非常复杂的错误并不经常发生，因为那些通常在 C 中是内存损坏问题.</p><p class="normal">It seemed like as time went by the debugging facilities just kept getting worse and worse. But on the other hand now people are finally realizing that manual memory allocation is not the way to go; it kind of doesn't matter as much any more because the sorts of really complicated bugs where you'd have to dig deep into data structures don't really happen as often because those, often, in C anyway, were memory-corruption issues.</p>
<p class="normal"><b>Seibel：</b>您是否使用断言或其他或多或少正式的方式来记录或实际检查不变量？</p><p class="normal"><b>Seibel:</b> Do you use assertions or other more or less formal ways of documenting or actually checking invariants?</p>
<p class="normal"><b>Zawinski：</b>我们反复讨论了如何处理 Netscape 代码库中的断言。显然，出于文档目的，放入断言语句始终是调试的好主意，就像您所说的那样。它表达了意图。我们做了很多。<a id="OEBPS/Chapter01.html.page_32"></a>但是接下来的问题是，当断言失败并且您在生产代码中时会发生什么？你做什么工作？我们有点决定你所做的就是返回零并希望它继续下去。因为让浏览器宕机真的很糟糕——这比返回到空闲循环并且可能泄漏了一堆内存或其他东西更糟糕。与其他选择相比，这会让人们感到不安。</p><p class="normal"><b>Zawinski:</b> We went back and forth about what to do about assertions in the Netscape code base. Obviously putting in assert statements is always a good idea for debugging and like you said, for documentation purposes. It expressed the intent. We did that a lot. <a></a>But then the question is, well, what happens when the assertion fails and you're in production code; what do you do? And we sort of decided that what you do is return zero and hope it keeps going. Because having the browser go down is really bad—it's worse than returning to the idle loop and maybe having leaked a bunch of memory or something. That's going to upset people less than the alternative.</p>
<p class="normal">许多程序员都有这样的直觉，“你必须显示错误信息！” 不，你不知道。没有人关心这个。这类东西在 Java 这样实际上有异常系统的语言中管理起来要容易得多。在空闲状态的顶部循环中，您只需捕获所有内容即可完成。无需打扰用户告诉他们某些值为零。</p><p class="normal">A lot of programmers have the instinct of, “You've got to present the error message!” No you don't. No one cares about that. That sort of stuff is a lot easier to manage in languages like Java that actually have an exception system. Where, at the top loop of your idle state, you just catch everything and you're done. No need to bother the user with telling them that some value was zero.</p>
<p class="normal"><b>Seibel：</b>您是否曾经单步调试过一个程序——要么是为了调试它，要么像某些人建议的那样，在编写程序后单步调试它作为检查程序的一种方式？</p><p class="normal"><b>Seibel:</b> Did you ever just step through a program—either to debug it or, as some people recommend, to just step through it once you've written it as a way of checking it?</p>
<p class="normal"><b>Zawinski：</b>不，不是真的。我只有在调试某些东西时才真正执行单步执行。我想有时是为了确保我写对了。但不是那么频繁。</p><p class="normal"><b>Zawinski:</b> No, not really. I only really do stepping when I'm debugging something. I guess sometimes to make sure I wrote it right. But not that often.</p>
<p class="normal"><b>Seibel：</b>那么你是如何进行调试的呢？</p><p class="normal"><b>Seibel:</b> So how do you go about debugging?</p>
<p class="normal"><b>Zawinski：</b>我只是先看一下代码。通读它直到我认为，好吧，这不可能发生，因为它就在那里发生。然后我加入一些东西来尝试解决这个矛盾。或者，如果我阅读它并且它看起来不错，那么我会停在中间或其他地方，看看它在哪里。这取决于。很难对此一概而论。</p><p class="normal"><b>Zawinski:</b> I just eyeball the code first. Read through it until I think, well, this can't happen because that's going on right there. And then I put in something to try and resolve that contradiction. Or if I read it and it looks fine then I'll stop in the middle or something and see where it is. It depends. It's hard to generalize about that.</p>
<p class="normal"><b>Seibel：</b>就断言而言——你认为有多正式？有些人只是使用特别的断言——我认为这里有一些东西应该是真的。有些人认为非常正式——函数有前置条件和后置条件，并且有全局不变量。你在那个规模上在哪里？</p><p class="normal"><b>Seibel:</b> As far as the assertions—how formally do you think? Some people just use ad hoc assertions—here's something that I think should be true here. And some people think very formally—functions have preconditions and postconditions and there are global invariants. Where are you on that scale?</p>
<p class="normal"><b>Zawinski：</b>我绝对不会以数学上可证明的方式来考虑事情。我肯定比那更特别。你知道，当你有一个函数的输入至少有一个<a id="OEBPS/Chapter01.html.page_33"></a>在你的脑海中想法他们的界限是什么。这可以是一个空字符串吗？之类的东西。</p><p class="normal"><b>Zawinski:</b> I definitely don't think about things in a mathematically provable way. I'm definitely more ad hoc than that. You know, it's always helpful when you've got inputs to a function to at least have an <a></a>idea in your head what their bounds are. Can this be an empty string? That sort of thing.</p>
<p class="normal"><b>Seibel：</b>与调试相关的是测试。在 Netscape，你们有单独的 QA 小组还是你们自己测试所有东西？</p><p class="normal"><b>Seibel:</b> Related to debugging, there's testing. At Netscape, did you guys have a separate QA group or did you guys test everything yourselves?</p>
<p class="normal"><b>Zawinski：</b>我们都做了。我们一直都在运行它，这始终是您最好的一线 QA。然后我们有一个 QA 小组，他们进行了正式测试。每次有新版本发布时，他们都会在列表中尝试这个东西。转到此页面，单击此按钮。你应该看到这个。或者你不应该看到这个。</p><p class="normal"><b>Zawinski:</b> We did both. We were all running it all the time, which is always your best front-line QA. Then we had a QA group and they had formal tests they went through. And every time there was a new release they'd go down the list and try this thing. Go to this page, click on this. You should see this. Or you shouldn't see this.</p>
<p class="normal"><b>Seibel：</b>开发人员级别的测试（如单元测试）怎么样？</p><p class="normal"><b>Seibel:</b> What about developer-level tests like unit tests?</p>
<p class="normal"><b>扎文斯基：</b>不。我们从来没有这样做过。我偶尔会做一些事情。邮件标题的日期解析器有一组巨大的测试用例。至少在那时，没有人真正对标准给予太多关注。所以你在标题中得到了各种各样的废话。无论您向我们扔什么，如果他们的邮件分类错误，人们都会很生气。所以我在网上收集了一大堆例子，然后编造了一大堆日期格式很糟糕的列表，还有我认为应该变成的数字。每次我更改代码时，我都会运行测试，其中一些会翻转。那么，我同意还是不同意？</p><p class="normal"><b>Zawinski:</b> Nah. We never did any of that. I did occasionally for some things. The date parser for mail headers had a gigantic set of test cases. Back then, at least, no one really paid a whole lot of attention to the standards. So you got all kinds of crap in the headers. And whatever you're throwing at us, people are going to be annoyed if their mail sorts wrong. So I collected a whole bunch of examples online and just made stuff up and had this giant list of crappily formatted dates and the number I thought that should turn into. And every time I'd change the code I'd run through the tests and some of them would flip. Well, do I agree with that or not?</p>
<p class="normal"><b>Seibel：</b>这种事情有没有融入任何类型的自动化测试中？</p><p class="normal"><b>Seibel:</b> Did that kind of thing get folded into any kind of automated testing?</p>
<p class="normal"><b>Zawinski：</b>不，当我为我的代码编写这样的单元测试时，它们基本上只会在我运行它们时运行。后来我们用 Grendel 做了一点，Java 重写，因为当你写一个新类时写单元测试要容易得多。</p><p class="normal"><b>Zawinski:</b> No, when I was writing unit tests like that for my code they would basically only run when I ran them. We did a little bit of that later with Grendel, the Java rewrite, because it was just so much easier to write a unit test when you write a new class.</p>
<p class="normal"><b>Seibel：</b>回想起来，你认为你因此而受苦吗？如果你们在测试方面更加自律，开发会更容易或更快吗？</p><p class="normal"><b>Seibel:</b> In retrospect, do you think you suffered at all because of that? Would development have been easier or faster if you guys had been more disciplined about testing?</p>
<p class="normal"><a id="OEBPS/Chapter01.html.page_34"></a><b>扎文斯基：</b>我不这么认为。我认为这只会减慢我们的速度。第一次就把它做好有很多话要说。在早期，我们非常关注速度。即使它不完美，我们也必须发货。我们可以稍后发货，质量会更高，但到那时其他人可能已经吃掉了我们的午餐。</p><p class="normal"><a></a><b>Zawinski:</b> I don't think so. I think it would have just slowed us down. There's a lot to be said for just getting it right the first time. In the early days we were so focused on speed. We had to ship the thing even if it wasn't perfect. We can ship it later and it would be higher quality but someone else might have eaten our lunch by then.</p>
<p class="normal">如果我们有单元测试或更小的模块或其他任何东西，肯定会有一些东西会更快。原则上这一切听起来都很棒。鉴于从容不迫的发展步伐，这当然是要走的路。但是当你看到“我们必须在六周内从零开始完成”时，好吧，除非我删掉一些东西，否则我无法做到这一点。我要删掉的是那些不是绝对关键的东西。单元测试并不重要。如果没有单元测试，客户就不会抱怨。这是一个上游问题。</p><p class="normal">There's bound to be stuff where this would have gone faster if we'd had unit tests or smaller modules or whatever. That all sounds great in principle. Given a leisurely development pace, that's certainly the way to go. But when you're looking at, “We've got to go from zero to done in six weeks,” well, I can't do that unless I cut something out. And what I'm going to cut out is the stuff that's not absolutely critical. And unit tests are not critical. If there's no unit test the customer isn't going to complain about that. That's an upstream issue.</p>
<p class="normal">我希望我听起来不像是在说：“测试是为笨蛋准备的。” 不是。这是一个优先事项。你是想写出好的软件还是想在下周之前完成？你不能两者都做。我们在 Netscape 经常开的一个玩笑是：“我们绝对 100% 致力于质量。我们将在 3 月 31 日运送我们所能提供的最高质量的产品。”</p><p class="normal">I hope I don't sound like I'm saying, “Testing is for chumps.” It's not. It's a matter of priorities. Are you trying to write good software or are you trying to be done by next week? You can't do both. One of the jokes we made at Netscape a lot was, “We're absolutely 100 percent committed to quality. We're going to ship the highest-quality product we can on March 31st.”</p>
<p class="normal"><b>Seibel：</b>这引出了另一个话题，即维护软件。您如何理解一段不是您编写的代码？</p><p class="normal"><b>Seibel:</b> That leads to another topic, maintaining software. How do you tackle understanding a piece of code that you didn't write?</p>
<p class="normal"><b>Zawinski：</b>我只是潜入并开始阅读代码。</p><p class="normal"><b>Zawinski:</b> I just dive in and start reading the code.</p>
<p class="normal"><b>Seibel：</b>那么你从哪里开始呢？您是否从第一页开始线性阅读？</p><p class="normal"><b>Seibel:</b> So where do you start? Do you start at page one and read linearly?</p>
<p class="normal"><b>扎文斯基：</b>有时候。更常见的事情是学习如何使用一些新的库或工具包。如果幸运的话，还有一些文档。有一个 API。所以你找出你可能有兴趣使用的部分。或者弄清楚它是如何实施的。穿过你的方式。或者像 Emacs 这样的东西，也许从底部开始。cons细胞是由什么组成的？那个样子怎么样？然后从那里跳过。有时从构建系统开始可以让您了解事物如何组合在一起。我总觉得这很好<a id="OEBPS/Chapter01.html.page_35"></a>让自己沉浸在一段代码中的方法是选择一个你想要完成的任务，然后尝试去做。</p><p class="normal"><b>Zawinski:</b> Sometimes. The more common thing is learning how to use some new library or toolkit. If you're lucky there's some documentation. There's an API. So you figure out the piece of it you might be interested in using. Or work out how that was implemented. Thread your way through. Or with something like Emacs, maybe start at the bottom. What are cons cells made of? How's that look? And then skip around from there. Sometimes starting with the build system can give you an idea how things fit together. I always find that a good <a></a>way to sort of immerse yourself in a piece of code is pick a task you want to accomplish and then try and do it.</p>
<p class="normal">使用像 Emacs 这样的东西，你可以通过获取一个现有的模块并将其分解来做到这一点。好的，现在我得到了这段代码。撕掉实际做任何事情的部分，现在我得到了样板。好的，现在我知道这个系统的一个组件是什么样子了，我可以开始把我的东西放回去了。有点像把它剥离到框架上。</p><p class="normal">With something like Emacs you might do that by taking an existing module and gutting it. OK, now I've got this piece of code. Rip out the part that actually does anything and now I've got the boilerplate. OK, now I know what a component of this system looks like and I can start putting my stuff back in. Sort of stripping it down to the frame.</p>
<p class="normal"><b>Seibel：</b>在 Emacs 中，您最终重写了字节码编译器和字节码 VM 的位。我们已经讨论过重写东西比修复它更有趣，但这并不总是一个好主意。我想知道你是怎么画那条线的？您是否认为您选择重写整个编译器是因为它真的比在本地修复它更容易？或者只是，“嘿！编写编译器会很有趣。”</p><p class="normal"><b>Seibel:</b> In Emacs you ended up rewriting the byte-code compiler and bits of the byte-code VM. And we've talked about how it's more fun to rewrite stuff than to fix it, but it's not always a good idea. I wonder how do you draw that line? Do you think that you chose to rewrite the whole compiler because it was really easier than fixing it more locally? Or was it just, “Hey! It'd be fun to write a compiler.”</p>
<p class="normal"><b>Zawinski：</b>它有点变成了重写。它从我开始只是修复它并尝试向它添加优化。然后最终没有任何原始的留下。我最终使用了相同的 API，直到它们消失了。我认为字节码编译器运行良好。部分原因是那是一个孤立的模块。只有一个入口点：编译和保存。</p><p class="normal"><b>Zawinski:</b> It sort of just turned into a rewrite. It started with me just fixing it and trying to add optimizations to it. And then eventually there wasn't any of the original left. I ended up using the same APIs until then they were gone. I think the byte-code compiler worked out fine. Partly because that was such an isolated module. There's only one entry point: compile and save.</p>
<p class="normal">我在 Lucid Emacs 中放入了很多比这更无偿的东西。真的，我做的很多事情都是因为希望它更像 Lisp 机器。希望它更像我熟悉的 Emacs。这确实是我熟悉的 Lisp 环境。所以我投入了很多东西，试图在很多方面让 Emacs 成为一个不那么半途而废的 Lisp：应该有事件对象，而不是一个包含数字的列表。让一个事件对象成为一个列表，其中包含一个数字——这太鸡肋了。这很恶心。回想起来，这些变化是一些最大的问题。这些变化导致了与第三方库的兼容性问题。</p><p class="normal">There was definitely a lot of stuff that I put into Lucid Emacs that was more gratuitous than that. Really, a lot of the stuff I did was motivated by wanting it to be more like Lisp machines. Wanting it to be more like the Emacs I was familiar with. Which really was the Lisp environment I was familiar with. So I put in a lot of stuff to try to make Emacs be a less half-assed Lisp in a lot of ways: there should be event objects instead of a list with a number in it. Having an event object be a list with a number in it—that's just tasteless. It's icky. And in retrospect, those changes were some of the biggest problems. Those kind of changes caused compatibility problems with third-party libraries.</p>
<p class="normal"><b>Seibel：</b>当然，你当时并不知道会有两个 Emacs。</p><p class="normal"><b>Seibel:</b> Of course you didn't know there were going to be two Emacs at that point.</p>
<p class="normal"><a id="OEBPS/Chapter01.html.page_36"></a><b>扎文斯基：</b>当然。但即使没有它，即使只有一个 Emacs，仍然有两个 Emacs——Emacs 18 和 Emacs 19。仍然会存在兼容性问题。事后看来，如果我意识到这些变化会产生多大的影响，我可能会采取不同的做法。或者花更多的时间让旧方法也能正常工作。那种事。</p><p class="normal"><a></a><b>Zawinski:</b> Sure. But even without that, even if there had only been one Emacs, there were still two Emacs—there was Emacs 18 and Emacs 19. There was still going to be a compatibility problem. In hindsight those were changes that if I'd realized what an impact it was going to make, I probably would have done that differently. Or spent a lot more time on making the old way work as well. That kind of thing.</p>
<p class="normal"><b>Seibel：</b>之前您说过要编写代码以使其更易于阅读，这与维护有关。使代码更易于阅读的特征是什么？</p><p class="normal"><b>Seibel:</b> Earlier you said something about writing code in order to make it easier to read, which ties into maintenance. What are the characteristics that make code easier to read?</p>
<p class="normal"><b>Zawinski：</b>嗯，显然是评论。写下假设是什么以及它做了什么。如果它正在建立一个数据结构，描述它的布局。很多时候我发现这很有帮助。尤其是在编写 Perl 代码时，它就像是一个哈希表，而值是对列表的一堆引用，因为 Perl 中的数据结构简直是疯了。我需要一个右箭头才能到达这里吗？我发现这样的例子很有帮助。</p><p class="normal"><b>Zawinski:</b> Well, comments obviously. Writing down what the assumptions are and what this does. If it's building up a data structure, describing the layout of it. A lot of times I find that pretty helpful. Especially in writing Perl code when it's like, uh, well, it's a hash table and values are bunch of references to lists, because the data structures in Perl are just nuts. Do I need a right arrow here to get to this? I find examples like that to be helpful.</p>
<p class="normal">我一直希望人们能发表更多评论，尽管让我感到畏缩的是当评论是改写的函数名称时。函数称为 push_stack，注释说：“这将压入堆栈。” 谢谢你。</p><p class="normal">I always wish people would comment more, though the thing that makes me cringe is when the comment is the name of the function rephrased. Function's called push_stack and the comment says, “This pushes to the stack.” Thank you.</p>
<p class="normal">你必须在评论中说一些不存在的东西。这是为了什么？更高级别或更低级别的描述，具体取决于最重要的内容。有时最重要的是，这是为了什么？我为什么要用它？有时最重要的是，它期望的输入范围是多少？</p><p class="normal">You've got to say in the comment something that's not there already. What's it for? Either a higher-level or a lower-level description, depending on what's most important. Sometimes the most important thing is, what is this for? Why would I use it? And sometimes the most important thing is, what's the range of inputs that this expects?</p>
<p class="normal">长变量名。我不喜欢匈牙利符号，但我认为使用实际的英语单词来描述事物，除了循环迭代器，这是显而易见的。我想尽可能多的冗长。</p><p class="normal">Long variable names. I'm not a fan of Hungarian notation, but I think using actual English words to describe things, except for loop iterators, where it's obvious. Just as much verbosity as possible, I guess.</p>
<p class="normal"><b>Seibel：</b>关于组织——最终会有一些线性组织，但程序并不是真正的线性。您是自上而下还是自下而上组织代码？</p><p class="normal"><b>Seibel:</b> What about organization—ultimately there's some linear organization but programs are not really linear. Do you organize your code top-down or bottom-up?</p>
<p class="normal"><a id="OEBPS/Chapter01.html.page_37"></a><b>Zawinski：</b>我通常最终将叶节点放在文件的顶部——尽量保持它的基本结构。然后通常在顶部，记录 API。这个文件、这个模块等等的顶级入口点是什么？使用对象语言，这是由语言为您完成的。对于 C，您必须更明确一点。在 CI 中，确实倾向于尝试为每个具有所有 externs 的 .c 文件创建一个 .h 文件。.h 文件中未导出的任何内容都是静态的。然后我会回去说，“等等，我需要打电话给那个，”然后我改变它。但是你是在明确地而不是偶然地这样做。</p><p class="normal"><a></a><b>Zawinski:</b> I usually end up putting the leaf nodes up at the top of the file—try to keep it basically structured that way. And then usually up at the top, document the API. What are the top-level entry points of this file, this module, whatever? With an object-y language, that's done by the language for you. With C you've got to be a little more explicit about that. In C I do tend to try to have a .h file for every .c file that has all the externs for it. And anything that's not exported in the .h file is static. And then I'll go back and say, “Wait, I need to call that,” and I change it. But you're doing that explicitly rather than just by accident.</p>
<p class="normal"><b>Seibel：</b>你把叶子放在文件的第一位，但你是这样写的吗？你是用树叶建造的吗？</p><p class="normal"><b>Seibel:</b> You put the leaves first in the file, but is that how you write? Do you build up from leaves?</p>
<p class="normal"><b>扎文斯基：</b>不总是这样。有时我从顶部开始，有时我从底部开始。这取决于。一种方法是，我知道我将需要这些构建块，我会先将它们放在一起。或者另一种思考方式是，您已经在脑海中勾勒出它的轮廓，然后深入挖掘。我两种方式都这样做。</p><p class="normal"><b>Zawinski:</b> Not always. Sometimes I start at the top and sometimes I start at the bottom. It depends. One way is, I know I'm going to need these building blocks and I'll put those together first. Or another way of thinking about it is, you've sort of got an outline of it in your head and you dig down. I do it both ways.</p>
<p class="normal"><b>Seibel：</b>因此，为了争论起见，假设您将退休并建立一个开发团队。你会如何组织它？</p><p class="normal"><b>Seibel:</b> So suppose for the sake of argument that you were going to come out of retirement and build a development team. How would you organize it?</p>
<p class="normal"><b>Zawinski：</b>嗯，我认为你希望安排不超过三四个人在日常工作中紧密合作。然后可以扩大很多。假设您有一个项目，您可以将其划分为 25 个完全不同的模块。好吧，你可以有 25 个小团队——也许这有点多了。说十。只要他们可以相互协调，我认为你可以扩展到多大就没有太多限制。最终它开始看起来像多个项目，而不是一个项目。</p><p class="normal"><b>Zawinski:</b> Well, I think you want to arrange for there to be no more than three or four people working really closely together on a day-to-day basis. Then that can scale up a lot. Say you've got a project where you can divide it up into twenty-five really distinct modules. Well, you can have twenty-five tiny teams—maybe that's a little much. Say ten. And as long as they can coordinate with each other, I don't think there's a whole lot of limit to how big you can scale that. Eventually it just starts looking like multiple projects instead of like one project.</p>
<p class="normal"><b>Seibel：</b>所以你有多个最多四人的团队。你如何协调团队？您是否有一位首席架构师负责管理这些团队之间的依赖关系并进行调解？</p><p class="normal"><b>Seibel:</b> So you've got multiple teams of up to four people. How do you coordinate the teams? Do you have one grand architect who's managing the dependencies and mediating between those teams?</p>
<p class="normal"><b>Zawinski：</b>嗯，必须就模块之间的接口达成一致。为了让这种非常模块化的方法发挥作用，模块之间的接口必须清晰简单。哪个，<a id="OEBPS/Chapter01.html.page_38"></a>希望这意味着不需要太多尖叫就可以让每个人都同意它，并且遵循模块合同也不会太困难。我想我的意思是让模块之间的交互变得简单的最好方法就是让它变得非常简单。减少出错的方法。</p><p class="normal"><b>Zawinski:</b> Well, there's got to be agreement about what the interface between modules is. For that very modular approach to work at all, the interface between modules has to be clear and simple. Which, <a></a>hopefully, means it won't take too much screaming for everyone to agree on it and it won't be too difficult to follow the module contract. I guess what I'm getting at is the best way to make interaction between modules be easy is to just make it be really simple. Make there be fewer ways for that to go wrong.</p>
<p class="normal">你分什么线完全取决于一个项目。对于某种网络应用程序，您可能已经拥有了 UI 和数据库，以及在服务器上运行的部分和在服务器后面的机器上运行的部分。如果它是一个桌面应用程序，那就是类似的分工。有文件格式和 GUI 以及基本的命令结构。</p><p class="normal">And what lines you divide on depends entirely on a project. With some kind of web app you've probably got the UI and you've got your database and the part that runs on the server and the part that runs on the machine behind the server. And if it's a desktop application it's similar division of labor. There's file formats and GUI and basic command structure.</p>
<p class="normal"><b>Seibel：</b>您如何识别人才？</p><p class="normal"><b>Seibel:</b> How do you recognize talent?</p>
<p class="normal"><b>Zawinski：</b>我不知道。我从来都不是真正需要雇人的人。当我参与采访时，我总是觉得自己一无所知。我可以从面试中看出我是否会和这个人相处，但我不能仅仅通过与他们交谈来判断他们是否好。我总是觉得这很难。</p><p class="normal"><b>Zawinski:</b> That I don't know. I've never really been the person who had to hire people. And when I've been involved in interviews I've always just felt like I had no idea. I can tell from the interview whether I'd get along with this person, but I can't tell whether they're any good or not just by talking to them. I always found that difficult.</p>
<p class="normal"><b>Seibel：</b>如果它们不好怎么办？那有可靠的线索吗？</p><p class="normal"><b>Seibel:</b> How about if they're bad? Are there reliable clues then?</p>
<p class="normal"><b>扎文斯基：</b>有时候。通常我会认为那些是 C++ 模板的忠实粉丝的人——让我远离那个人。但这可能只是我的仓促判断。也许在他们使用它们的上下文中，它们实际上工作得很好。当然，对于与我共事过的人来说，争论他们观点的能力很重要，因为我们最终都成为了一个非常好争论的群体。在那种环境下，这帮了很多忙。那肯定和编程能力没有任何关系。那只是人际关系动力学的东西。</p><p class="normal"><b>Zawinski:</b> Sometimes. Normally I would think that someone who is a big fan of C++ templates—keep me away from that guy. But that might just be a snap judgment on my part. Maybe in the context they've used them, they actually work fine. Certainly with the folks I've worked with, ability to argue their point was important because we all ended up being a pretty argumentative bunch. With that environment, that helped a lot. That certainly doesn't have anything to do with programming ability. That's just interpersonal-dynamics stuff.</p>
<p class="normal"><b>Seibel：</b>在不同的团队中，这实际上是有害的。</p><p class="normal"><b>Seibel:</b> And on a different team, that would actually be detrimental.</p>
<p class="normal"><b>Zawinski：</b>是的，当然。</p><p class="normal"><b>Zawinski:</b> Yeah, absolutely.</p>
<p class="normal"><b>Seibel：</b>听起来在 Netscape，你们把东西分开了，所以人们拥有软件的不同部分。有人认为<a id="OEBPS/Chapter01.html.page_39"></a>这真的很重要。其他人说，团队共同拥有所有代码会更好。你对此有何看法？</p><p class="normal"><b>Seibel:</b> It sounds like at Netscape you guys divided things up so people owned different parts of the software. Some people think <a></a>that's really important. Other folks say it's better for a team to collectively own all the code. Do you have an opinion on that?</p>
<p class="normal"><b>扎温斯基：</b>我两种方式都做过。他们都有自己的优点。每个人都应该拥有所有代码的想法，我认为并不实际，因为这样的代码太多了。人们将不得不专业化；有时你需要专家。它总是会以这种方式解决。总会有您熟悉的代码，因为您碰巧编写了比其他人更多的模块。或者只是会有一些部分更能引起你的共鸣。如果只是因为您不会永远自己维护它，那么让其他人参与其中当然是件好事。由于某种原因，它必须移交给其他人。传播这些知识是件好事。但有人责备也很好。</p><p class="normal"><b>Zawinski:</b> I've done it both ways. They both have their merits. The idea that everyone should own all the code, I don't think is really practical because there's going to be too much of it. People are going to have to specialize; you need an expert sometimes. It's just always going to work out that way. There's always going to be the code you're familiar with because you happened to write more of that module than some other guy did. Or there's just going to be parts that resonate with you more. It's certainly good for other people to have their hands in it, if only because you're not going to be maintaining it yourself forever. It's going to have to be handed off to someone else for one reason or another. And for that knowledge to be spread around is good. But it's also good to have someone to blame. If everybody is responsible for it then there's no one to put their foot down.</p>
<p class="normal"><b>Seibel：</b>你当过经理吗？</p><p class="normal"><b>Seibel:</b> Have you ever been a manager?</p>
<p class="normal"><b>扎文斯基：</b>不尽然。当我在 Lucid 做 Emacs 的时候，Lucid Emacs 中包含很多其他人编写的模块。那些人并没有真正为我工作，但它有点像管理。很多人肯定经验不足，而成功的方式是他们做自己喜欢的事情，我基本上是在给他们反馈：“好吧，我想包括这个，但首先我需要这个，这个，还有这个从中。”</p><p class="normal"><b>Zawinski:</b> Not really. When I was doing the Emacs stuff at Lucid, there would be a lot of modules that were included in Lucid Emacs that were written by other people. Those people didn't really work for me but it was a little bit like management. And a lot of those people were definitely less experienced and the way that worked out well was they were doing their favorite thing and I was basically giving them feedback: “Well, I want to include this but first I need this, this, and this from it.”</p>
<p class="normal"><b>Seibel：</b>你给了他们自由发挥的空间吗？你告诉他们你想要 X、Y 和 Z，然后他们就会弄清楚该怎么做？</p><p class="normal"><b>Seibel:</b> And did you give them a free rein? You tell them you want X, Y, and Z and then they get to figure out how to do it?</p>
<p class="normal"><b>扎文斯基：</b>是的。如果我试图决定是否将这个模块包含在我要发布的东西中，我会对它提出要求。这该死的东西有用吗真的是那里的底线。所以我会给他们建议，“我认为如果你尝试这种方式而不是这种方式，你会有更好的运气。” 但我希望它能发挥作用，而且我不想成为编写它的人。如果他们想以某种疯狂的方式去做但它奏效了，那没关系<a id="OEBPS/Chapter01.html.page_40"></a>因为那给了我第二点：我不必写它。但我给他们的反馈大多只是，它是否有效，是否有意义。</p><p class="normal"><b>Zawinski:</b> Yeah. If I'm trying to decide whether to include this module in the thing that I'm going to ship, I'm going to have requirements about it. Does the damn thing work is really the bottom line there. So I would give them advice on, “I think you're going to have better luck if you try it this rather than this way.” But I wanted it to work and I wanted to not have to be the one to write it. If they wanted to go do it in some crazy way but it worked, that was OK <a></a>because that gave me point two: I didn't have to write it. But mostly the feedback I was giving them was just, does it work and does it make sense.</p>
<p class="normal"><b>Seibel：</b>另一方面，当你是经验不足的程序员时，你的导师做了哪些对你有帮助的事情？</p><p class="normal"><b>Seibel:</b> On the flip side, when you were the less-experienced programmer, what did your mentors do that was helpful?</p>
<p class="normal"><b>Zawinski：</b>我想最重要的是他们会意识到什么时候该升级了。当我去 Fahlman 工作时，我得到了一些愚蠢的小忙工作。并最终得到了一些更重要的任务——并不是说它们真的很重要。</p><p class="normal"><b>Zawinski:</b> I guess the most important thing is they'd recognize when it was time to level up. When I went to work for Fahlman I was given some silly little busy work. And eventually got given tasks that were a little more significant—not that they were significant at all really.</p>
<p class="normal"><b>Seibel：</b>我想你谈到了 Skef，他只是徘徊着说，“错了！” 也许，这是由其他更有教养的人来平衡的？</p><p class="normal"><b>Seibel:</b> I think you talked about Skef, who just hovered and said, “Wrong!” Was that balanced, perhaps, by someone else who was a little more nurturing?</p>
<p class="normal"><b>Zawinski：</b>嗯，他不完全是穴居人。他实际上也会告诉我一些事情。我知道我最终阅读了大量代码并提出了问题。我认为真正重要的一件事是不要害怕你的无知。如果您不了解某些东西是如何工作的，请询问了解的人。很多人对此感到不安。这对任何人都没有帮助。不知道某事并不意味着你很笨——它只是意味着你还不知道。</p><p class="normal"><b>Zawinski:</b> Well, he wasn't completely a cave man. He would actually tell me things, too. I know I ended up doing a lot of reading of code and asking questions. I think one thing that's really important is to not be afraid of your ignorance. If you don't understand how something works, ask someone who does. A lot of people are skittish about that. And that doesn't help anybody. Not knowing something doesn't mean you're dumb—it just means you don't know it yet.</p>
<p class="normal"><b>Seibel：</b>你阅读代码主要是因为它是你正在做的事情，还是只是你想知道它是如何工作的？</p><p class="normal"><b>Seibel:</b> Did you read code mostly because it was something you were working on, or was it just something you wanted to know how it worked?</p>
<p class="normal"><b>扎文斯基：</b>是的。只是四处闲逛——“我想知道它是如何工作的。” 拆解事物的冲动是促使人们从事这一行工作的重要原因。</p><p class="normal"><b>Zawinski:</b> Yeah. Just poking around—“I wonder how that works.” The impulse to take things apart is a big part of what gets people into this line of work.</p>
<p class="normal"><b>Seibel：</b>你真的是那些拆开烤面包机的孩子之一吗？</p><p class="normal"><b>Seibel:</b> Were you actually one of those kids who took toasters apart?</p>
<p class="normal"><b>扎文斯基：</b>是的。我做了一部电话，并学会了如何用我用锡罐做的电报分接器拨号。当我小的时候，我有这些旧书，是在旧货拍卖会上买的，比如30 年代<i>的 Boy's Own Science Book</i>，我记得从中得到了很大的乐趣。那确实是 20 年代和 30 年代的黑客文化<a id="OEBPS/Chapter01.html.page_41"></a>他们正在展示如何在您的房间和谷仓之间连接电报以及如何制作莱顿罐。</p><p class="normal"><b>Zawinski:</b> Yeah. I made a telephone and learned how to dial with a telegraph tapper that I made out of a tin can. When I was little I had these old books I got at a garage sale or something, like <i>Boy's Own Science Book</i> from the '30s, and I remember getting a really big kick out of those. That was really hacker culture in the '20s and '30s where <a></a>they're showing how to wire up a telegraph between your room and the barn and how to make Leyden jars.</p>
<p class="normal"><b>Seibel：</b>这让我想到了另一个标准问题：作为程序员，你认为自己是科学家、工程师、艺术家、工匠还是其他什么？</p><p class="normal"><b>Seibel:</b> That brings me to another of my standard questions: do you, as a programmer, think of yourself as a scientist or an engineer or an artist or a craftsman or something else?</p>
<p class="normal"><b>Zawinski：</b>嗯，绝对不是科学家或工程师，因为它们具有非常正式的含义。我不做很多数学；我不画蓝图；我不证明事情。我想介于工匠和艺术家之间，这取决于项目是什么。我写了很多屏幕保护程序——那不是工匠；拍出漂亮的照片。在那个地区的某个地方。</p><p class="normal"><b>Zawinski:</b> Well, definitely not a scientist or engineer because those have very formal connotations. I don't do a lot of math; I don't draw blueprints; I don't prove things. I guess somewhere between craftsman and artist, depending on what the project is. I write a lot of screen savers—that's not craftsman; that's making pretty pictures. Somewhere in that area.</p>
<p class="normal"><b>Seibel：</b>你觉得自己是自学计算机科学还是刚学编程？</p><p class="normal"><b>Seibel:</b> Do you feel like you taught yourself computer science or did you just learn to program?</p>
<p class="normal"><b>Zawinski：</b>好吧，这些年来我当然学到了很多计算机科学知识。但学习编程是目标。让机器做某事是目标，而计算机科学方面是达到目的的手段。</p><p class="normal"><b>Zawinski:</b> Well, I certainly picked up a bunch of computer science over the years. But learning to program was the goal. Making the machine do something was the goal and the computer-science side of it was a means to an end.</p>
<p class="normal"><b>Seibel：</b>你有没有觉得这是一种匮乏——你有没有希望自己以更系统的方式接触事物？</p><p class="normal"><b>Seibel:</b> Did you ever feel that as a lack—did you ever wish you had been exposed to things in a more systematic way?</p>
<p class="normal"><b>Zawinski：</b>肯定有很多时候，尤其是在 Lucid，很明显，这些人正在谈论的整个大黑洞，我完全错过了，因为我从来不需要知道它。然后我会学习术语，对他们在说什么有一个基本的了解，如果我需要知道的话，我可能会读一读。所以肯定有很多时候，尤其是在早期，我觉得，“天哪，我什么都不知道。” 这只会让人尴尬——但那只是缺乏安全感。作为所有这些拥有博士学位的人身边的小孩——“啊啊，我什么都不知道！我是个白痴！我是怎么混进来的？”</p><p class="normal"><b>Zawinski:</b> There were definitely times, especially at Lucid, where it'd be obvious that there's this whole big black hole that these guys are talking about that I just completely missed because I never needed to know it. And I'd then I'd pick up the terminology and have a basic idea what they're talking about and maybe do a little bit of reading on it if it was something I needed to know. So there were definitely times, especially early on, where I felt like, “Oh my god, I don't know anything.” It would just be embarrassing—but that was just being insecure. Being the young kid around all these people with PhDs—“Aaah, I don't know anything! I'm an idiot! How did I bluff my way into this?”</p>
<p class="normal"><a id="OEBPS/Chapter01.html.page_42"></a>如果我在学校呆的时间更长，我的生活肯定会大不相同——那是我做我做过的事情的时刻。</p><p class="normal"><a></a>Though my life certainly would have turned out very differently if I had spent a lot more time in school—it was a moment in time when I got to do the things I did.</p>
<p class="normal"><b>Seibel：</b>你有没有过相反的感觉，你觉得你周围的计算机科学家并不像你那样了解实际的编程？</p><p class="normal"><b>Seibel:</b> Did you ever feel the opposite, where you felt like the computer scientists around you just didn't understand actual programming as well as you did?</p>
<p class="normal"><b>Zawinski：</b>我经常有这种感觉，但实际上这并不是想，“哇，你们找错人了。” 就像，“哇，我们只是对同样的事情不感兴趣。” 我不想成为一名数学家，但我不会批评一个数学家。</p><p class="normal"><b>Zawinski:</b> I felt like that a lot, but really that's not so much about thinking, “Wow, you guys have been barking up the wrong tree.” as, “Wow, we're just not interested in the same things.” I don't want to be a mathematician but I'm not going to criticize someone who is a mathematician.</p>
<p class="normal">人们经常混淆这两种追求，这很奇怪。人们认为从事非常理论化的计算机科学的人与交付桌面应用程序的人是一样的。他们之间并没有太多关系。</p><p class="normal">It's weird that people often confuse those two pursuits. People who are into very theoretical computer science are thought of in this same way as people who are shipping desktop applications. And they don't really have a lot to do with each other.</p>
<p class="normal"><b>Seibel：</b>你基本上是自学成才的。您对自学成才的程序员有什么建议吗？</p><p class="normal"><b>Seibel:</b> You're largely self-taught. Do you have any advice for self-taught programmers?</p>
<p class="normal"><b>Zawinski：</b>这是一个很难回答的问题，因为现在的世界已经大不相同了。谈论“这就是我所做的”时，我总是觉得很奇怪。我不知道这样做是否正确。但人们总是听到它是“像我一样”。</p><p class="normal"><b>Zawinski:</b> That's a really hard question because the world's so different now. I always feel weird talking about, “Here's what I did.” I don't know if that was the right way to do it. But people always hear it as, “Be like me.”</p>
<p class="normal">我偶然发现了这一点——这一切就这么发生了。我做了一些决定，它们导致了其他决定，我们就在这里。</p><p class="normal">I stumbled into this—it all just sort of happened. I made some decisions and they led to others and here we are.</p>
<p class="normal">我时不时地收到一封来自某人的电子邮件，基本上是，“我想成为一名程序员；我想成为一名程序员；我该怎么办？” 或者，“我应该上大学吗？” 我该怎么回答呢？如果你在 1986 年问我，我对此会有非常强烈的看法。但今天有人不能走我走的同样的路，因为那条路已经不存在了。</p><p class="normal">Every now and then I get an email from someone that's basically, “I want to be a programmer; what do I do?” Or, “Should I go to college or not?” How can I answer that? I would have had very strong opinions about this if you asked me in 1986. But someone today couldn't take the same path that I took because that path doesn't even exist anymore.</p>
<p class="normal">十年前我会说绝对是你必须做的第一件事就是学习汇编语言。你必须学习机器<a id="OEBPS/Chapter01.html.page_43"></a>确实有效。这还有关系吗？我什至不知道。也许是这样。但可能不会。如果十年后软件的方式是所有网络应用程序或某个租用的计算集群中的一段分布式代码，这些代码在十几个不同的谷歌服务器之间移动并产生自身的其他副本，然后在获得后合并回一起结果，还有人需要了解汇编语言吗？是不是抽象到无所谓了？我不知道。</p><p class="normal">Ten years ago I would have said absolutely the first thing you have to do is learn assembly language. You have to learn how the machine <a></a>actually works. Does that matter any more? I don't even know. Maybe it does. But possibly not. If the way software is going to be ten years from now is all web applications or a piece of distributed code in some rented computing cluster that's moving around between a dozen different Google servers and spawning other copies of itself and then merging back together once it's got results, does anyone need to know assembly language any more? Is that so abstracted away that it doesn't matter? I don't know.</p>
<p class="normal">当我意识到有些人以 CS 学位毕业但从未写过 C 语言时，我有点吓坏了。他们从 Java 开始，然后一直呆在那里。这看起来很奇怪而且是错误的。但我不知道。也许并没有错。也许这就是穴居人的想法：“在我那个时代，我们用一块九伏电池和一只稳定的手来编程！”</p><p class="normal">I was kind of freaked out when I realized that there are people graduating with CS degrees who'd never written C. They started in Java and they stayed there. That just seemed bizarre and wrong. But I don't know. Maybe it's not wrong. Maybe that's the caveman thoughts: “Back in my day, we programmed with a nine-volt battery and a steady hand!”</p>
<p class="normal"><b>Seibel：</b>书呢？是否有每个人都应该阅读的特定计算机科学或编程书籍？</p><p class="normal"><b>Seibel:</b> What about books? Are there particular computer-science or programming books that everyone should read?</p>
<p class="normal"><b>Zawinski：</b>我实际上并没有读过很多。我一直推荐的是<i>Structure and Interpretation of Computer Programs</i>，很多人都害怕它，因为它是 Lispy，但我认为在不教授语言的情况下教授编程确实做得很好。我认为很多入门级的东西都侧重于语法，我在高中的课程和卡内基梅隆大学的入门课程中确实看到了这一点。</p><p class="normal"><b>Zawinski:</b> I actually haven't read very many of those. The one I always recommend is <i>Structure and Interpretation of Computer Programs</i>, which a lot of people are afraid of because it's Lispy, but I think does a really good job of teaching programming without teaching a language. I think a lot of introductory-level stuff focuses on syntax and I definitely saw that in the classes I had in high school and in the intro classes at Carnegie-Mellon during my brief time there.</p>
<p class="normal">这不是教人们编程；这是在教人们分号在哪里。这似乎是一种最能吓跑人们的东西，因为那不是有趣的部分。甚至对知道自己在做什么的人也不行。</p><p class="normal">This is not teaching people to program; this is teaching people where the semicolon goes. That seems like the kind of thing that's going to scare people away from it more than anything, because that's not the interesting part. Not even to someone who knows what they're doing.</p>
<p class="normal">还有另一本书——它叫什么名字？——是关于调试的，是 Microsoft 的某个人写的。它是关于如何有效地使用断言的。我记得我认为那是一本非常好的书，不是因为我从中学到了什么，而是因为这是一本你希望你的白痴同事读过的书。</p><p class="normal">There was another book—what was it called?—about debugging, written by someone from Microsoft. It was about how to use asserts effectively. I remember thinking that was a really good book, not because I learned anything from it, but because it was the book you wish your idiot coworker had read.</p>
<p class="normal"><a id="OEBPS/Chapter01.html.page_44"></a>然后是另一本书，每个人都认为是同一时期有史以来最伟大的东西——<i>设计模式</i>——我只是认为它是垃圾。就像通过剪切和粘贴进行编程一样。你没有仔细考虑你的任务，而是翻阅了食谱书，发现了一些可能，有点，有点喜欢的东西，然后只是模仿它。那不是编程；那是一本填色书。但似乎有很多人喜欢它。然后在会议上，他们会反复讨论他们从那本书中得到的所有术语。比如，反向、反向、双后空翻模式——随便什么。哦，你是说循环？好的。</p><p class="normal"><a></a>Then there was another book that everybody thought was the greatest thing ever in that same period—<i>Design Patterns</i>—which I just thought was crap. It was just like, programming via cut and paste. Rather than thinking through your task you looked through the recipe book and found something that maybe, kinda, sorta felt like it, and then just aped it. That's not programming; that's a coloring book. But a lot of people seemed to love it. Then in meetings they'd be tossing around all this terminology they got out of that book. Like, the inverse, reverse, double-back-flip pattern—whatever. Oh, you mean a loop? OK.</p>
<p class="normal"><b>Seibel：</b>程序员有没有必须具备的关键技能？</p><p class="normal"><b>Seibel:</b> Is there a key skill programmers must have?</p>
<p class="normal"><b>Zawinski：</b>好吧，好奇心——拆解事物。想知道引擎盖下发生了什么。我认为这确实是它的基础。没有它，我认为你走不了多远。这是您获取知识的主要方式。拆开某物并对其进行观察，这就是您学习构建自己的东西的方式。至少对我来说。我读的关于计算机的书很少。我的经验是挖掘源代码或参考手册。我有一个目标，好吧，要做到这一点，我需要知道这个东西做了什么，以及它做了什么。我将随机浏览它，直到找到我要去的地方。</p><p class="normal"><b>Zawinski:</b> Well, curiosity—taking things apart. Wanting to know what's going on under the hood. I think that's really the basis of it. Without that I don't think you get very far. That's your primary way of acquiring knowledge. Taking something apart and looking at it is how you learn to build your own. At least for me. I've read very few books about computers. My experience has been digging through source code or reference manuals. I've got a goal and, alright, to do this I need to know what this thing does and what this thing does. And I'll just sort of random-walk through that until I find where I'm going.</p>
<p class="normal"><b>Seibel：</b>你读过 Knuth 的<i>《计算机编程艺术》</i>吗？</p><p class="normal"><b>Seibel:</b> Have you read Knuth's, <i>The Art of Computer Programming</i>?</p>
<p class="normal"><b>扎文斯基：</b>我没有。这就是我真正应该拥有的东西之一。但我从来没有这样做过。</p><p class="normal"><b>Zawinski:</b> I haven't. And that's one of those things where, I really probably should have. But I never did.</p>
<p class="normal"><b>Seibel：</b>这很难——你需要大量的数学知识才能真正理解它。</p><p class="normal"><b>Seibel:</b> It's tough going—you need a lot of math to really grok it.</p>
<p class="normal"><b>Zawinski：</b>而且我根本不是数学家。</p><p class="normal"><b>Zawinski:</b> And I'm not a math person at all.</p>
<p class="normal"><b>Seibel：</b>这很有趣。很多程序员都是数学出身，很多计算机科学理论都非常数学化。所以你是一个存在证明，它不是绝对必要的。成为一名优秀的程序员需要多少数学或数学思维？</p><p class="normal"><b>Seibel:</b> That's interesting. Lots of programmers come out of mathematics and lots of computer-science theory is very mathematical. So you're an existence proof that it's not absolutely necessary. How much math or mathy kind of thinking is necessary to be a good programmer?</p>
<p class="normal"><a id="OEBPS/Chapter01.html.page_45"></a><b>Zawinski：</b>嗯，这取决于你在什么地方划清界限，什么是数学，什么不是。擅长模式匹配数学吗？从直觉上理解数量级和组合学很重要。但我敢肯定，如果我必须对这类东西进行基本的介绍测验，我会完全不及格。我已经很久没有做过那样正式的事情了。</p><p class="normal"><a></a><b>Zawinski:</b> Well, it depends on where you draw the line as to what's mathy and what's not. Is being good at pattern matching mathy? Having an understanding of orders of magnitude and combinatorics is important at a gut level. But I'm sure I would completely flunk if I had to take a basic intro quiz on that kind of stuff. It's been so long since I've had to do anything formal like that.</p>
<p class="normal">实际上，我唯一的数学课是在高中。我有代数。一点微积分。我不是很擅长。我挺过来了，但这对我来说并不是很自然。我在高中上过物理课，我们在那里学习力学和做实验室，在砂纸上拖动积木之类的东西。我在那堂课上表现得很糟糕，感觉自己像个白痴，因为我真的很喜欢这堂课。我做的实验室真的很好——程序很准确——然后我就是做不了数学。</p><p class="normal">Really the only math classes I had were in high school. I had algebra. A little bit of calculus. I wasn't terribly good at it. I got through it but it didn't really come naturally to me. I had a physics class in high school where we were doing mechanics and doing labs dragging blocks across sandpaper and stuff like that. I did terribly in that class and felt like an idiot because I actually enjoyed the class. I did the labs really well—the procedure was spot on—and then I just couldn't do the math.</p>
<p class="normal">我会得到一个我知道是三个数量级的答案。我会展示我的作品——我不知道我做错了什么。由于正确收集了数据并且之后我进行了清理，因此我得到了一半的分数。所以数学从来都不是我的强项。</p><p class="normal">I'd get an answer that I knew was three orders of magnitude off. I'd show my work—I don't know what I did wrong. I'd get half credit since the data was collected properly and I cleaned up afterwards. So math was never really my forte.</p>
<p class="normal">但我不会说你不需要它来成为一名程序员。显然有不同类型的编程。没有像我这样的人，这一切都不会存在。但我一直认为写作散文比数学有更多共同点。感觉就像你在写一个故事，你正试图向一个词汇量有限的非常愚蠢的人——计算机——表达一个概念。您已经有了想要表达的概念和表达它的有限工具。你使用什么词，你的介绍和总结陈述是什么样的？之类的东西。</p><p class="normal">But I wouldn't go so far as to say you don't need that to be a programmer. There's obviously different kinds of programming. Without people who are not like me none of this would exist. But I've always seen much more in common with writing prose than math. It feels like you're writing a story and you're trying to express a concept to a very dumb person—the computer—who has a limited vocabulary. You've got this concept you want to express and limited tools to express it with. What words do you use and what does your introductory and summary statement look like? That sort of thing.</p>
<p class="normal">品味问题确实适合那里。你可以用一段文字来描述正确描述它的东西，或者它可以很好地描述它，有一些天赋。程序也是如此。它可以完成工作，也可以很有意义，可以很好地组合在一起。</p><p class="normal">The issue of taste really fits in there. You can have a piece of text describing something that describes it correctly or it can describe it well, with some flair. And the same thing's true of programs. It can get the job done or it can also make sense, be put together well.</p>
<p class="normal"><b>Seibel：</b>为什么这很重要？这仅仅是为了满足它还是有品位的代码在某些实用方面也更好？</p><p class="normal"><b>Seibel:</b> And why does that matter? Is that just for the satisfaction of it or is tasteful code also better in some practical way?</p>
<p class="normal"><a id="OEBPS/Chapter01.html.page_46"></a><b>Zawinski：</b>在很大程度上，品味和可维护性是相似的。或者关系非常密切。使一篇文章有​​品位的其中一个因素是它的结构是否易于理解。事实是堆在前面还是散落在各处？如果你在回顾——如果你正在翻阅一本书，你能找出你记得的东西在书中的什么地方吗？“这是靠近中间的某个地方，因为那是他谈论这件事的地方。” 或者它只是散落在各处。这与编程中经常发生的事情是一样的。</p><p class="normal"><a></a><b>Zawinski:</b> To a large degree, tasteful and maintainable are similar. Or very closely related. One of the things that makes a piece of writing tasteful is if it's structured in a way that's easy to grasp. Are the facts loaded up at the front or are they scattered around? If you're referring back—if you're flipping through a book, can you figure out where in the book is the thing you kind of remember? “This was somewhere near the middle because that's where he talked about this thing.” Or is it just scattered all through. And that's the same sort of thing that goes on with programming a lot.</p>
<p class="normal"><b>Seibel：</b>你认为能够在编程方面取得成功的人已经发生了变化吗？</p><p class="normal"><b>Seibel:</b> Do you think the kind of people who can be successful at programming has changed?</p>
<p class="normal"><b>Zawinski：</b>当然，现在不可能只从头开始编写一个没有任何依赖关系的程序。工具包、库和框架的爆炸式增长以及诸如此类的事情——如今即使是最基本的软件也需要这些。简直炸了 如今，一切都必须是网络应用程序。这只是一种完全不同的方式。</p><p class="normal"><b>Zawinski:</b> Certainly these days it's impossible to just write a program from scratch that doesn't have any dependencies. The explosion of toolkits and libraries and frameworks and that sort of thing—even the most basic piece of software needs those these days. It's just exploded. These days, everything's got to be a web app. And that's just a whole different way of going about it.</p>
<p class="normal">因此，如果有的话，这使得能够深入研究其他人的代码并弄清楚如何利用它的技能组合变得更加重要。“我不明白这个，所以我要自己写”在过去效果更好。不管这是个好主意还是坏主意，您都可以做到。现在要摆脱它要困难得多。</p><p class="normal">So, if anything, that makes the part of the skill set that is being able to dive into someone else's code and figure out how to make use of it even more important. “I don't understand this, so I'm going to write my own” worked better in the past. Whether it was ever a good idea or not, you could do it. It's much harder to get away with that now.</p>
<p class="normal"><b>Seibel：</b>我想知道这些天是否也需要稍微缓和一下拆开事物并理解一切的倾向。如果你试图拆开你使用的每一段代码，它永远不会结束——现在你必须有一点能力说，“我有点理解它是如何工作的，我打算让它继续这样做，直到我更好地理解它变得紧迫为止。”</p><p class="normal"><b>Seibel:</b> I wonder if the inclination to take things apart and understand everything also needs to be a little more tempered these days. If you try to take apart every piece of code you work with, it'll never end—these days you've got to have a little capacity for saying, “I sort of understand how this works and I'm going to let it go at that until it becomes urgent that I understand it better.”</p>
<p class="normal"><b>扎文斯基：</b>是的。我的第一直觉是，因为事情就是这样运作的，所以你正在培养一代程序员，他们对效率或实际分配的内容一无所知。当他们意识到“哦，我的程序越来越庞大”时，他们会怎么做？他们不知道从哪里开始。这是我的第一直觉<a id="OEBPS/Chapter01.html.page_47"></a>因为我是穴居人。真的，这可能根本不重要，因为你只要给它更多的内存就可以了。</p><p class="normal"><b>Zawinski:</b> Yeah. My first instinct, because things work that way, is you're breeding a generation of programmers who don't understand anything about efficiency or what's actually being allocated. When they realize, “Oh, my program's getting gigantic,” what are they going to do? They're not going to know where to start. That's my first instinct <a></a>because I'm a caveman. Really that probably doesn't even matter because you'll just throw more memory at it and it'll be fine.</p>
<p class="normal"><b>Seibel：</b>或者，也许人们实际上会对所有这些事情的含义有更复杂的了解。就像，也许我们在这里分配了六个字节还是四个字节并不重要——重要的是我们是否调整了这个东西的大小，使其适合集群的一个节点，而不是必须溢出到第二个节点。</p><p class="normal"><b>Seibel:</b> Or perhaps people will actually learn a more sophisticated view of what all those things mean. Like, maybe it doesn't really matter whether we allocated six bytes or four bytes here—what matters is whether we've sized this thing so it fits in one node of the cluster versus having to spill over onto a second node.</p>
<p class="normal"><b>Zawinski：</b>对，没错。我认为从这个意义上说，编程肯定发生了变化。你以前必须关注的事情是不同的。在你专注于计算字节之前，“我的对象有多大？也许我应该在这里做些不同的事情，因为数组标题真的会加起来。” 像这样的东西。再也没有人会关心那些东西了。将你的前向和后向指针异或成同一个词这样的技巧是巫术——为什么有人会这样做；这很疯狂。但是现在有一套完全不同的技能，它们一直存在，但更多地出现在前面。我认为，能够深入研究 API 并找出您需要哪些部分和不需要哪些部分的人是现在最重要的事情之一。</p><p class="normal"><b>Zawinski:</b> Right, exactly. I think programming has definitely changed in that sense. The things you had to focus on before were different. Before you would focus on counting bytes, and “How big are my objects? Maybe I should do something different here because that array header is really going to add up.” Things like that. No one is ever going to care about that stuff again. Tricks like XORing your forward and back pointers into the same word are voodoo—why would anyone do that; it's crazy. But there's this whole different set of skills now that were always around but come more to the front. People who can dig into an API and figure out which parts you need and which parts you don't, is, I think, one of those important things now.</p>
<p class="normal"><b>Seibel：</b>如果你今天是 13 岁，你会被今天的编程方式所吸引吗？</p><p class="normal"><b>Seibel:</b> If you were 13 today, would you be drawn to programming the way programming is today?</p>
<p class="normal"><b>Zawinski：</b>很难说。我不认识任何13岁的孩子。我不知道这个世界是什么样的。现在事情更难分开了。不会有某个 10 岁的孩子像我小时候用手机那样突然打开他的手机并弄清楚扬声器的工作原理。不再有用户可维修的部件。</p><p class="normal"><b>Zawinski:</b> So hard to say. I don't know any 13-year-olds. I don't know what the world looks like. Things are harder to take apart now. There's not going to be some 10-year-old who pops open his cell phone and figures out how the speaker works like I did with a phone when I was a little kid. There are no user-serviceable parts anymore.</p>
<p class="normal">我喜欢那种修修补补，把磁带机的背面拆下来，看看齿轮是如何组合在一起的，这种探索对我来说是导致这个的原因。除了像 LEGO Mindstorms 这样的东西，我认为现在人们没有太多机会走这条路。但也许我错了——就像我说的，我不认识任何 13 岁的孩子。不知道玩具怎么样 有很多电子游戏；遥控器有很多东西。我还没有看到任何真正好的建筑玩具。这看起来很可悲。</p><p class="normal">I feel like that kind of tinkering, taking the back of the tape deck off and seeing how the gears fit together, that sort of exploration is what led to this for me. Aside from things like LEGO Mindstorms, I don't think there's a lot of opportunity for people to follow that path these days. But maybe I'm wrong—like I said, I don't know any 13-year-olds. I don't know what the toys are like. There's a lot of video games; there's a lot of things with remote controls. I haven't seen any really good construction kinds of toys. Which seems sad.</p>
<p class="normal"><a id="OEBPS/Chapter01.html.page_48"></a><b>Seibel：</b>另一方面，编程本身更容易获得。您不必立即掌握所有错综复杂的汇编编程，就可以让计算机做一些整洁的事情。</p><p class="normal"><a></a><b>Seibel:</b> On the flip side, programming itself is much more accessible. You don't have to master all the intricacies of assembly programming right off the bat just to make a computer do something neat.</p>
<p class="normal"><b>扎文斯基：</b>是的。我想象今天开始编程的孩子们开始构建一些网络应用程序或编写 Facebook 插件或其他东西。LiveJournal 的作者 Brad Fitzpatrick 是我的朋友。当他编写 LiveJournal 时，他四处闲逛并编写了这个 Perl 脚本，他和他的朋友可以在其中说：“我要去吃午饭了。” 他开始的方式是编写一个小的 Perl 脚本并将其放在 Web 服务器上。事情可能会朝着那个方向发展。</p><p class="normal"><b>Zawinski:</b> Yeah. I imagine that today's kids who are getting into programming start off building some web app or writing a Facebook plugin or something. Brad Fitzpatrick, who wrote LiveJournal, is a friend of mine. When he wrote LiveJournal he was goofing around and wrote this Perl script where he and his friends could say, “I'm going to get lunch.” The way he started out was he wrote a little Perl script and put it on a web server. Probably things will go more in that direction.</p>
</div>
</div></div>
<div id="OEBPS/Chapter02.html"><div>

<div class="booksection">
<p></p>
<h2 class="chapnum"><a id="OEBPS/Chapter02.html.ch2"></a><a id="OEBPS/Chapter02.html.page_49"></a><img src="data:image/jpg;base64,/9j/4AAQSkZJRgABAgEASABIAAD/7Qy2UGhvdG9zaG9wIDMuMAA4QklNA+0KUmVzb2x1dGlvbgAAAAAQAEgAAAABAAEASAAAAAEAAThCSU0EDRhGWCBHbG9iYWwgTGlnaHRpbmcgQW5nbGUAAAAABAAAAHg4QklNBBkSRlggR2xvYmFsIEFsdGl0dWRlAAAAAAQAAAAeOEJJTQPzC1ByaW50IEZsYWdzAAAACQAAAAAAAAAAAQA4QklNBAoOQ29weXJpZ2h0IEZsYWcAAAAAAQAAOEJJTScQFEphcGFuZXNlIFByaW50IEZsYWdzAAAAAAoAAQAAAAAAAAACOEJJTQP1F0NvbG9yIEhhbGZ0b25lIFNldHRpbmdzAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+BdDb2xvciBUcmFuc2ZlciBTZXR0aW5ncwAAAHAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAOEJJTQQAC0xheWVyIFN0YXRlAAAAAgABOEJJTQQCDExheWVyIEdyb3VwcwAAAAAEAAAAADhCSU0ECAZHdWlkZXMAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4NVVJMIG92ZXJyaWRlcwAAAAQAAAAAOEJJTQQaBlNsaWNlcwAAAAB1AAAABgAAAAAAAAAAAAAArwAAAPkAAAAKAFUAbgB0AGkAdABsAGUAZAAtADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAPkAAACvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhCSU0EERFJQ0MgVW50YWdnZWQgRmxhZwAAAAEBADhCSU0EFBdMYXllciBJRCBHZW5lcmF0b3IgQmFzZQAAAAQAAAACOEJJTQQMFU5ldyBXaW5kb3dzIFRodW1ibmFpbAAACNoAAAABAAAAcAAAAE8AAAFQAABnsAAACL4AGAAB/9j/4AAQSkZJRgABAgEASABI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" alt="图片"></h2><h2 class="chapnum"><a></a><a></a></h2>
<h2 class="chaptitle">布拉德·菲茨帕特里克</h2><h2 class="chaptitle">Brad Fitzpatrick</h2>
<div class="sidebar">
<p class="normal"><i>布拉德·菲茨帕特里克 (Brad Fitzpatrick) 是我采访过的最年轻的人，也是唯一一个从未在没有互联网或个人电脑的世界里生活过的人。他出生于 1980 年，很早就开始成为一名程序员，五岁时就在自制的 Apple II 克隆机上学习编程。在他十几岁的时候，互联网革命如火如荼，他深入其中，还在高中时就建立了他的第一个商业网站，并在他上大学前的那个夏天开始在流行的社区网站 LiveJournal 上工作。</i></p><p class="normal"><i>Brad Fitzpatrick is the youngest person I interviewed and the only one who has never lived in a world without the Internet or personal computers. Born in 1980, he got an early start as a programmer, learning to program at age five on a home-built Apple II clone. By his teenage years the Internet revolution was in full swing and he was deep into it, building his first commercial web site while still in high school and starting work on the popular community site LiveJournal the summer before he went to college.</i></p>
<p class="normal"><i>为了跟上 LiveJournal 日益流行的趋势，Fitzpatrick 不得不学习构建可扩展网站的艰辛方法，并且在此过程中，他和他创立的公司 Danga Interactive 的程序员最终构建了多个开源软件，包括 memcached， Perlbal 和 MogileFS，现在在世界上许多最繁忙的网站的服务器上使用。</i></p><p class="normal"><i>Keeping up with LiveJournal's ever-growing popularity forced Fitzpatrick to learn the hard way about building scalable web sites and along the way he and the programmers at the company he founded, Danga Interactive, ended up building several pieces of open source software, including memcached, Perlbal, and MogileFS, which are now used on the servers of many of the world's busiest web sites.</i></p>
<p class="normal"><i>Fitzpatrick 是世纪之交的典型——如果说成就非凡的话——Web 程序员：他的主要编程语言是 Perl 和 C，尽管他也根据需要使用 Java、C++、Python、JavaScript 和 C#。他所做的几乎所有编程都与网络有关，无论是<a id="OEBPS/Chapter02.html.page_50"></a>为网站构建更好的后端基础设施，设计协议和软件以改进博客阅读软件了解博客何时更新的方式，或者对他的手机进行编程，以便在他骑摩托车时自动打开车库门。</i></p><p class="normal"><i>Fitzpatrick is a prototypical—if exceptionally accomplished—turn-of-the-century web programmer: his primary programming languages have been Perl and C, though he also works in Java, C++, Python, JavaScript, and C# as needed. And almost all the programming he does is somehow network-related, whether it's <a></a>building better back-end infrastructure for web sites, designing protocols and software to improve the way blog-reading software knows when blogs have been updated, or programming his cell phone to automatically open his garage door when he rides up on his motorcycle.</i></p>
<p class="normal"><i></i>我们谈到了在他阅读大红狗克利福德的<i>同龄学习编程，</i><i>为什么他很高兴在运行 LiveJournal 的同时留在大学，以及他如何学会不害怕阅读别人的代码。</i></p><p class="normal"><i>We talked about learning to program at the same age as he was reading</i> Clifford the Big Red Dog, <i>why he was glad he stayed in college while running LiveJournal, and how he learned not to be afraid of reading other people's code.</i></p>
</div>
<p class="normal"><b>Seibel：</b>你是如何成为一名程序员的？</p><p class="normal"><b>Seibel:</b> How did you become a programmer?</p>
<p class="normal"><b>Fitzpatrick：</b>我父亲在 Mostek 工作。他们创造了记忆，而他迷上了电脑。他几乎用零配件组装了一台 Apple II。他和我妈妈会围坐在电视机旁，将它们焊接在一起。他们花了几个月的时间，只是焊接它。然后他能够从他们不会出售的工作中获得 ROM，因为它们有一个或多个位，卡在高位或卡在低位。他们以某种方式获得了 Apple II ROM，并一直将其烧录到这些死芯片上，直到他们得到一个可以工作的芯片，其中卡住的位恰好是正确的。最终，他和他的一群同事设法自制了 Apple II。我从两岁左右开始玩那个，看着他编程。</p><p class="normal"><b>Fitzpatrick:</b> My dad was working at Mostek. They made memory and he was into computers. He built an Apple II from spare parts, pretty much. He and my mom would sit around the TV soldering it all together. It took them months, just soldering it. Then he was able to get ROMs from work that they weren't going to sell because they had a bit, or multiple bits, stuck high or stuck low. Somehow they got the Apple II ROM and they just kept burning it onto these dead chips until they got one that worked, where the stuck bits just happened to be right. Eventually he and a bunch of his coworkers managed to make homemade Apple IIs. I was playing on that from age two or so and watching him program.</p>
<p class="normal"><b>Seibel：</b>他是程序员还是硬件专家？</p><p class="normal"><b>Seibel:</b> Was he a programmer or a hardware guy?</p>
<p class="normal"><b>菲茨帕特里克：</b>他是一名电气工程师；他涉足编程。他在我五岁时教我编程，并开玩笑说我在六七岁时就超过了他。我妈妈说我和<i>大红狗克利福德</i>同时在图书馆阅读 Apple II 程序员手册。我会说“有价值的东西”而不是“变量”。我最初的一些记忆是和我爸爸一起编程。就像他把我拉进厨房，然后在纸上写下一个程序。他问：“你认为它有什么作用？” 我记得它就像是“10 PRINT HELLO，20 GOTO 10”。</p><p class="normal"><b>Fitzpatrick:</b> He was an electrical engineer; he dabbled in programming. He taught me to program when I was five and jokes that I passed him up around six or seven. My mom says I was reading the Apple II programmers' manual from the library at the same time as <i>Clifford the Big Red Dog</i>. Instead of “variables,” I would say, “valuables.” Some of my first memories are programming with my dad. Like he pulled me into the kitchen and he was writing down a program on paper. He asked, “What do you think it does?” I remember it was like, “10 PRINT HELLO, 20 GOTO 10.”</p>
<p class="normal"><b>Seibel：</b>所以你是从 BASIC 开始的？</p><p class="normal"><b>Seibel:</b> So you started with BASIC?</p>
<p class="normal"><b>Fitzpatrick：</b>是的，那是 BASIC。我不能用鼠标做事，也不能用更高的图形模式和颜色做事，直到我们家的一个朋友<a id="OEBPS/Chapter02.html.page_51"></a>向我介绍了 C 并给了我 Turbo C。那可能是在我八岁或十岁的时候。我爸爸在 84 年搬到了英特尔，我们搬到了波特兰。他帮助设计了 386 和 486。他仍在英特尔工作。我们总是有新的、有趣的电脑。</p><p class="normal"><b>Fitzpatrick:</b> Yeah, that was BASIC. I couldn't do stuff with the mouse, or stuff with higher graphics modes and colors, until a friend of our family <a></a>introduced me to C and gave me Turbo C. This was maybe when I was eight or ten. My dad moved to Intel in '84 and we moved to Portland. He helped design the 386 and 486. He's still at Intel. We always had new, fun computers.</p>
<p class="normal"><b>Seibel：</b>你有接触过汇编编程吗？</p><p class="normal"><b>Seibel:</b> Did you get into assembly programming at all?</p>
<p class="normal"><b>Fitzpatrick：</b>我在计算器上做了一些组装。就像 TI 计算器上的 Z80，但仅此而已。</p><p class="normal"><b>Fitzpatrick:</b> I did assembly a little on calculators. Like Z80 on the TI calculators, but that was about it.</p>
<p class="normal"><b>Seibel：</b>你还记得是什么吸引了你去编程吗？</p><p class="normal"><b>Seibel:</b> Do you remember what it was that drew you to programming?</p>
<p class="normal"><b>菲茨帕特里克：</b>我不知道。它总是很有趣。我妈妈不得不打断我，给我电脑优惠券，让我出去和朋友们玩。我的朋友们会过来：“Brad 又在用电脑了。他太无聊了。” 我妈妈说，“出去玩吧。”</p><p class="normal"><b>Fitzpatrick:</b> I don't know. It was just always fun. My mom had to cut me off and give me computer coupons to make me go outside and play with friends. My friends would come over: “Brad's on the computer again. He's so boring.” My mom's like, “Go outside and play.”</p>
<p class="normal"><b>Seibel：</b>您还记得您编写的第一个有趣的程序吗？</p><p class="normal"><b>Seibel:</b> Do you remember the first interesting program that you wrote?</p>
<p class="normal"><b>Fitzpatrick：</b>我们有一台 Epson 打印机，它附带又大又厚的手册，最后是程序员参考。所以我写了一些东西——这是在 Apple 上——我可以在高级图形模式下画一些东西，然后，一旦我的程序完成绘制它正在绘制的任何东西——线条或图案或其他东西——我会点击控制 C 并在后台输入，在未显示的帧缓冲区中，然后加载我的其他程序，该程序会关闭屏幕并打印出来。</p><p class="normal"><b>Fitzpatrick:</b> We had this Epson printer and it came with big, thick manuals with a programmers' reference at the end. So I wrote something—this was back on an Apple—where I could draw something in the high graphics mode, and then, once my program finished drawing whatever it was drawing—lines or patterns or something—I'd hit control C and be typing in the background, in a frame buffer that's not showing, and load my other program, which read the screen off and printed it.</p>
<p class="normal">在那之前，我记得我写了一些东西，每当我按下一个键时，它就会移动头部，并且我将退格键连接起来向后移动，所以当我打字时感觉就像一台打字机。</p><p class="normal">Before that I remember writing something that every time I hit a key, it moved the head and I had wired backspace up to go backwards so as I typed it felt like a typewriter.</p>
<p class="normal">这是我的第一个程序——类似于 K 等于抓取下一个字符。然后我说如果K等于“a”，打印“a”；如果 K 是“b”，则打印“b”。我几乎完成了每个字母、数字和一些标点符号。然后有一次我想，“等等，我可以说，'打印变量！'”然后我用一行代码替换了 40 行代码。我当时想，“天啊，太棒了！” 对于一个六岁的孩子来说，这是一些主要的抽象概念。</p><p class="normal">This was one of my first programs—it was something like K equals grab the next char. Then I said if K equals “a”, print “a”; if K is “b”, print “b”. I pretty much did every letter, number, and some punctuation. Then at one point I was like, “Wait, I could just say, 'Print the variable!'” and I replaced 40 lines of code with one. I was like, “Holy shit, that was awesome!” That was some major abstraction for a six-year-old.</p>
<p class="normal">这些是值得注意的早期的。然后在中学时我会制作游戏，我会为我的游戏制作图形编辑器和关卡编辑器<a id="OEBPS/Chapter02.html.page_52"></a>朋友，我的朋友会把图形做成关卡，然后我们会卖给同学。我记得必须制作检测 EGA 与 VGA 的游戏。如果其中一个在 VGA 上失败，它会返回 EGA 并使用适合屏幕的一组不同的图块，因此我们必须为所有内容准备两组图形。学校里的人会花五块钱买它，他们会去安装它，但它不起作用，他们的父母会打电话给我的父母并大喊，“你的儿子从我孩子那里偷了五美元，因为这个垃圾不工作。” 当我进去调试并修复它时，我妈妈会开车送我去那里，坐在死胡同里。</p><p class="normal">Those are the notable early ones. Then in middle school I would make games and I would make the graphics editors and the level editors for my <a></a>friends, and my friends would make the graphics into levels, and then we would sell it to our classmates. I remember having to make games that detected EGA versus VGA. If one of 'em failed on VGA, it would fault back to EGA and use a different set of tiles that fit on the screen, so we'd have to have two sets of graphics for everything. People from school would buy it for like five bucks and they would go to install it and it wouldn't work, and their parents would call my parents and yell, “Your son stole five dollars from my kid for this crap that doesn't work.” My mom would drive me over there and sit in the cul-de-sac while I went in and debugged it and fixed it.</p>
<p class="normal"><b>Seibel：</b>那段时间你上过编程课吗？</p><p class="normal"><b>Seibel:</b> During that time did you take any classes on programming?</p>
<p class="normal"><b>菲茨帕特里克：</b>不是真的。都是从图书馆借来的一两本书，然后随便玩玩。没有真正的论坛或互联网。有一次我上了一个 BBS，但是 BBS 上什么都没有。它没有连接到网络，所以人们在玩棋盘游戏。</p><p class="normal"><b>Fitzpatrick:</b> Not really. It was all one or two books from the library, and then just playing around. There weren't really forums or the Internet. At one point I got on a BBS, but the BBS didn't really have anything on it. It wasn't connected to the Net, so it was people playing board games.</p>
<p class="normal"><b>Seibel：</b>你的学校有 AP 计算机科学或其他课程吗？</p><p class="normal"><b>Seibel:</b> Did your school have AP computer science or anything?</p>
<p class="normal"><b>Fitzpatrick：</b>嗯，我们没有 AP CS，但我们有计算机编程课程。有一个人在教它，但后来我会在后面教一些高级课程。他们仍然使用图形编辑器和我编写的图形库——他们的最终项目是制作游戏。我仍然偶尔会遇到那个 CS 老师——他是我家人的朋友，我会在我兄弟的足球比赛中见到他——他会说，“是的，我们仍然在使用你的图书馆。”</p><p class="normal"><b>Fitzpatrick:</b> Well, we didn't have AP C.S., but we had a computer-programming class. There was a guy teaching it but then I would teach sort of an advanced class in the back. They still use the graphics editor and the graphics library I wrote—their final project is to make a game. I still occasionally run into that C.S. teacher—he's a friend of my family's and I'll see him at my brother's soccer games—he'll be like, “Yep, we still use your libraries.”</p>
<p class="normal">我确实参加了 AP CS 考试。那是他们转向 C 之前使用 Pascal 的最后一年，那是他们转向 Java 或类似语言的前一年。我不了解 Pascal，所以我去了邻近的一所有 AP CS 的高中，我去了一些夜校，比如三四个。然后我找到一本书并学习了这门语言，我大部分时间都在用 Pascal 构建小行星，因为我刚刚学习了三角函数。我当时想，“哦，罪和余弦；这些很有趣。我可以获得推力之类的东西。”</p><p class="normal">I did take the AP C.S. test. It was the last year it was in Pascal before they switched to C, which was one year before they switched to Java or something like that. I didn't know Pascal so I went to a neighboring high school that had AP C.S. and I went to some night classes, like three or four of them. Then I found a book and learned the language, and I spent most of my time building asteroids in Pascal because I had just learned trig. I was like, “Oooh, sin and cosin; these are fun. I can get thrust and stuff like that.”</p>
<p class="normal"><b>Seibel：</b>你好吗？</p><p class="normal"><b>Seibel:</b> How'd you do?</p>
<p class="normal"><b>菲茨帕特里克：</b>哦，我得了五分。我不得不编写 bigint 类。这是我给人们的面试问题之一。“写个类来做随心所欲，<a id="OEBPS/Chapter02.html.page_53"></a>通过乘法和除法进行 bigint 操作。” 如果我在高中的 AP 考试中做到了，他们应该可以在这里做到。</p><p class="normal"><b>Fitzpatrick:</b> Oh, I got a five. I had to write bigint classes. Now that's one of the interview questions I give people. “Write a class to do arbitrary, <a></a>bigint manipulation with multiplication and division.” If I did it in high school on an AP test, they should be able to do it here.</p>
<p class="normal"><b>Seibel：</b>你在大学一年级的暑假期间在英特尔工作。你在高中时也做过程序员吗？</p><p class="normal"><b>Seibel:</b> Your freshman year in college you worked at Intel during the summer. Did you also work as a programmer during high school?</p>
<p class="normal"><b>Fitzpatrick：</b>是的，我在 Tektronix 工作过一段时间。在我有任何正式工作之前，我有一些托管帐户。我因为编写机器人程序、淹没他们的聊天室以及烦人而被 AOL 开除。我正在从另一个 Windows 程序编写 AOL 客户端脚本。我还写了一个机器人来充斥他们的在线表格，以向您发送一张 CD。我使用了我名字的每一个变体，因为我不希望他们的重复抑制只给我发送一张 CD，因为他们有 100 个免费小时，或 5,000 个免费小时。我提交了这张表格几千次，邮递员会在一周左右的时间里带着一捆捆 CD 来。</p><p class="normal"><b>Fitzpatrick:</b> Yeah, I worked at Tektronix for a while. Before I had any official job, I got some hosting account. I got kicked off of AOL for writing bots, flooding their chat rooms, and just being annoying. I was scripting the AOL client from another Windows program. I also wrote a bot to flood their online form to send you a CD. I used every variation of my name, because I didn't want their duplicate suppression to only send me one CD, because they had those 100 free hours, or 5,000 free hours. I submitted this form a couple thousand times and for a week or so the postman would be coming with bundles of CDs wrapped up.</p>
<p class="normal">我妈妈说，“该死的，布拉德，你会惹上麻烦的。” 我当时想，“呃——他们他妈的错，对吧？” 然后有一天我接到一个电话，我真的接了电话，这是我通常不会接的电话，是 AOL 的人打来的。他们只是冲着我尖叫。“停止向我们发送所有这些表单提交！” 我通常不会这么敏捷和聪明，但我只是大喊：“你为什么要给我发送这些废话？邮递员每天都来！他要丢掉所有这些 CD！” 他们就像，“我们很抱歉，先生。不会再发生了。” 然后我用了所有这些，并用它们装饰了我大学的宿舍。实际上，我仍然把它们放在车库的一个盒子里。我无法摆脱它们，因为我只记得它们曾经是一件很好的装饰品。</p><p class="normal">My mom was like, “Damn it, Brad, you're going to get in trouble.” I was like, “Eh—their fucking fault, right?” Then one day I get a phone call and I actually picked up the phone, which I normally didn't, and it was someone from AOL. They were just screaming at me. “Stop sending us all these form submissions!” I'm not normally this quick and clever, but I just yelled back, “Why are you sending me all this crap? Every day the postman comes! He's dropping off all these CDs!” They're like, “We're so sorry, sir. It won't happen again.” Then I used all those and I decorated my dorm room in college with them. I actually still have them in a box in the garage. I can't get rid of them because I just remember them being such a good decoration at one point.</p>
<p class="normal">在我离开 AOL 之后，我在某个本地 ISP 上获得了一个 shell 帐户。这基本上就是我学习 Unix 的地方。我不能运行 CGI 脚本，但我可以 FTP，所以我会在家里的桌面上运行 Perl 的东西来生成我的整个网站，然后上传它。然后我在 Tektronix 找到了一份工作，就像暑期实习生一样。我非常了解 Perl，也非常了解 Web 的东西，但是我从来没有做过动态 Web 的东西。这可能是 95 年、94 年的事——网络非常新。</p><p class="normal">After I got kicked off of AOL, I got a shell account on some local ISP. That's basically where I learned Unix. I couldn't run CGI scripts, but I could FTP up, so I would run Perl stuff on my desktop at home to generate my whole website and then upload it. Then I got a job at Tektronix, like a summer intern job. I knew Perl really well and I knew web stuff really well, but I had never done dynamic web stuff. This was probably '95, '94—the web was pretty damn new.</p>
<p class="normal">然后我去 Tektronix 工作，第一天他们就给我介绍东西，他们说，“这是你的电脑。” 它是这个大型 SPARCstation 或运行 X 和 Motif 的东西。并且，“这是您的浏览器。” 它是<a id="OEBPS/Chapter02.html.page_54"></a>Netscape 2 或其他东西——我不记得了。并且，“如果你有一些 CGI，它们会进入这个目录。” 我记得我有一个基本的 hello-world CGI，就像那天晚上的三行代码一样，我当时想，“天哪，这太有趣了。” 第二天早上 6 点，我还在上班，我对 CGI 的东西发了疯。</p><p class="normal">Then I go to work at Tektronix and on my first day they're introducing me to stuff, and they're like, “Here's your computer.” It's this big SPARCstation or something running X and Motif. And, “Here's your browser.” It's <a></a>Netscape 2 or something—I don't remember. And, “If you have some CGIs, they go in this directory.” I remember I got a basic hello-world CGI, like three lines working that night and I was like, “Holy shit, this is so fun.” I was at work the next day at six in the morning and just going crazy with CGI stuff.</p>
<p class="normal">然后我开始自己做动态网络编程。也许那时我已经找到了支持 CGI 的 Windows 网络服务器。我终于说服了我的 ISP——我和他们交了足够多的朋友，或者发送了足够多他们信任我的智能东西——所以他们说，“好的，我们会运行你的 CGI，但我们会先对它们进行审计。” 他们会浏览它们并将它们扔到他们的目录中。所以我开始运行这个 Voting Booth 脚本，你在其中创建了一个主题，比如“你最喜欢的电影是什么？” 您可以向其中添加内容并对其进行投票。那变得越来越流行。这在幕后发生了几年。</p><p class="normal">Then I started doing dynamic web-programming stuff on my own. Maybe at that point I had found a web server for Windows that supported CGI. I finally convinced my ISP—I'd made friends with them enough, or sent enough intelligent things that they trusted me—so they said, “OK, we'll run your CGIs but we're going to audit them all first.” They'd skim them and toss them in their directory. So I started running this Voting Booth script where you created a topic like, “What's your favorite movie?” and you could add things to it and vote them up. That got more and more popular. That was going on in the background for a couple of years.</p>
<p class="normal"><b>Seibel：</b>那是 FreeVote？</p><p class="normal"><b>Seibel:</b> That was FreeVote?</p>
<p class="normal"><b>Fitzpatrick：</b>是的，在它淹没我的主机后变成了 FreeVote。横幅广告当时非常流行，或者说它们刚刚变得非常流行，我不断从中获得越来越多的钱，更好的合同，更高的每次点击成本。在最高峰时，我每次点击横幅广告可获得 27 美分，即使按照今天的标准，我认为这也是相当荒谬的。所以在高峰期，我每月靠点击横幅广告赚 25、27 美元。</p><p class="normal"><b>Fitzpatrick:</b> Yeah, that turned into FreeVote after it flooded my host. Banner ads were really popular then, or they were just getting really popular, and I kept getting more and more money from that, better contracts, more cost per click. At the height I was getting 27 cents per click of banner ads, which I think is pretty ridiculous even by today's standards. So at the height, I was making like $25, $27 grand per month on fucking clicks on banner ads.</p>
<p class="normal">这一切都贯穿了整个高中——我在整个高中的背景下都这样做了。我在英特尔工作了两个夏天，然后在去年夏天开始做 LiveJournal，就在上大学之前。所以在我大学的第一年，我只是在卖 FreeVote，我基本上是免费卖给一个朋友的，大约 11 美元，只是因为我想摆脱它并摆脱对它的法律责任。</p><p class="normal">This was all through high school—I did this in the background all of high school. And I worked at Intel two summers, and then started doing LiveJournal my last summer, right before college. So then my first year of college, I was just selling FreeVote, which I basically sold for nothing to a friend, for like $11 grand just because I wanted to get rid of it and get rid of legal responsibility for it.</p>
<p class="normal"><b>Seibel：</b>当您进入 ISP 并开始使用 Unix 时，这对您的编程有很大的改变吗？</p><p class="normal"><b>Seibel:</b> When you got on your ISP and got to use Unix, did that change your programming much?</p>
<p class="normal"><b>菲茨帕特里克：</b>是的。它并没有让我发疯。我无法理解 Windows 发生了什么。您可能已经看过 Windows API——每个函数大约有 20 个参数，它们都是标志和一半<a id="OEBPS/Chapter02.html.page_55"></a>他们是零。不知道发生了什么。当某些东西神奇地不起作用时，你不能去偷看幕后情况。</p><p class="normal"><b>Fitzpatrick:</b> Yeah. It didn't drive me crazy. I couldn't understand what was going on with Windows. You've probably seen the Windows API—there are like twenty parameters to every function and they're all flags and half of <a></a>them are zero. No clue what's going on. And you can't go peek underneath the covers when something's magically not working.</p>
<p class="normal"><b>Seibel：</b>在您早期的编程方法或编程风格与您现在对编程的思考方式之间，您是否可以识别出很大的差异？</p><p class="normal"><b>Seibel:</b> Are there big differences you can identify between your early approach to programming or programming style to the way you think about programming now?</p>
<p class="normal"><b>Fitzpatrick：</b>我经历了很多风格，面向对象的东西，然后是函数式的东西，然后是面向对象和函数式编程的这种奇怪的混合体。这就是我真正喜欢 Perl 的原因。尽管语法很丑陋，而且有很多历史包袱和瑕疵，但它从不跟我混，告诉我用什么风格写。你想要的任何风格都可以。您可以使您的代码美观且一致，但没有特定于语言的样式。只是自从我在谷歌工作后，我才不再写太多 Perl。</p><p class="normal"><b>Fitzpatrick:</b> I went through lots of styles, object-oriented stuff, and then functional stuff, and then this weird, hybrid mix of object-oriented and functional programming. This is why I really love Perl. As ugly as the syntax is and as much historical baggage and warts as it has, it never fucks with me and tells me what style to write in. Any style you want is fine. You can make your code pretty and consistent, but there's no language-specified style. It's only since I've been at Google that I've stopped writing much Perl.</p>
<p class="normal">自从 LiveJournal 以来，我也做了很多测试。一旦我开始与其他人一起工作，特别是。一旦我意识到我写的代码他妈的永远不会消失，我将成为终身维护者。我收到关于将近 10 年的博客文章的评论。“嘿，我找到了这段代码。我发现了一个错误，”然后我突然开始维护代码。</p><p class="normal">I've also done a lot of testing since LiveJournal. Once I started working with other people especially. And once I realized that code I write never fucking goes away and I'm going to be a maintainer for life. I get comments about blog posts that are almost 10 years old. “Hey, I found this code. I found a bug,” and I'm suddenly maintaining code.</p>
<p class="normal">我现在维护了这么多代码，还有其他人在使用它，如果有什么半途而废的话，我只是假设其他人不会理解我的一些不变量。所以基本上每当我做一些聪明的事情时，我都会确保我在那里有一个测试来大声打破并告诉他们他们搞砸了。我不得不强迫很多人编写测试，其中大部分是为我工作的人。我会编写测试来防止我自己的代码被破坏，然后一旦他们编写了代码，我就会说，“你确定这有效吗？写一个测试。证明给我看。” 在某个时刻，人们意识到，“天哪，它确实有回报”，尤其是后期的维护成本。</p><p class="normal">I now maintain so much code, and there's other people working with it, if there's anything halfway clever at all, I just assume that somebody else is going to not understand some invariants I have. So basically anytime I do something clever, I make sure I have a test in there to break really loudly and to tell them that they messed up. I had to force a lot of people to write tests, mostly people who were working for me. I would write tests to guard against my own code breaking, and then once they wrote code, I was like, “Are you even sure that works? Write a test. Prove it to me.” At a certain point, people realize, “Holy crap, it does pay off,” especially maintenance costs later.</p>
<p class="normal"><b>Seibel：</b>你什么时候开始和其他人一起工作的？</p><p class="normal"><b>Seibel:</b> When did you start working with other people?</p>
<p class="normal"><b>菲茨帕特里克：</b>当我开始雇用其他人时，大学快结束了，尤其是当我大学毕业后搬回波特兰时。</p><p class="normal"><b>Fitzpatrick:</b> It was pretty much towards the end of college when I started hiring other people, and especially once I moved back to Portland after college.</p>
<p class="normal"><a id="OEBPS/Chapter02.html.page_56"></a>然后早期的员工都是客户支持，所以他们没有写任何代码。然后慢慢地我开始招聘程序员。我雇用的第一个人是我的一个网上朋友。他的名字叫 Brad Whitaker，我们都有一个名为 BradleyLand 或 BradleyWorld 的网站，所以我们找到了彼此的网站。我在网络编程方面领先他几年，或者可能一年，他问我，“嘿，你是怎么做到的，”无论是 HTML、框架、CGI 还是 Perl 的东西。于是我开始接一堆合同项目，我会把我不想要的交给他。然后我们有一个项目对我们两个人来说都太大了，所以我们告诉那个人，“这个项目需要两个人来完成。” 他让我们飞到宾夕法尼亚。匹兹堡？我根本不了解东海岸；我是西海岸人。费城？奶酪牛排的地方。</p><p class="normal"><a></a>Then the early employees were customer support, so they didn't write any code. Then slowly I started hiring programmers. The first person I hired was a friend of mine from online. His name is Brad Whitaker and we both had websites called BradleyLand or BradleyWorld, so we found each other's websites. I was a couple of years ahead of him web programming-wise, or maybe a year, and he was asking me, “Hey, how do you do that,” whether it was HTML, or frames, or CGI, or Perl stuff. So then I started getting a bunch of contract projects and I would give the ones I didn't want to him. And then we had a project that was too big for either of us so we told the guy, “It's going to take two people to do this project.” And he flew us out to Pennsylvania. Pittsburgh? I don't know the East Coast at all; I'm a West-coast guy. Philadelphia? The cheesesteak place.</p>
<p class="normal"><b>塞贝尔：</b>费城。</p><p class="normal"><b>Seibel:</b> Philadelphia.</p>
<p class="normal"><b>菲茨帕特里克：</b>是的，我们第一次见面是在一家便宜的旅馆里，感觉我已经认识他了。他就像，“嘿，怎么了？” 当我站在那里时，他进来并在我酒店的浴室里小便，甚至没有关上门。我想，“好吧。你舒服。” 就好像我们认识四五年了，虽然我们素未谋面。我们开始一起研究这些东西。</p><p class="normal"><b>Fitzpatrick:</b> Yeah, and we met for the first time at some cheapo hotel and it felt like I knew him already. He was like, “Hey, what up?” He came in and took a piss in my hotel bathroom without even closing the door as I'm standing right there. I'm like, “Alright. You're comfortable.” It was like we knew each other for four or five years, even though we had never met. We started working on this stuff together.</p>
<p class="normal">他搬进了我的备用卧室，我们基本上把所有东西都搬出了我的厨房，摆了一堆桌子，然后在电脑上工作。我们会在 10 点或 11 点左右醒来，一直工作到中午，然后看电视——穿着我们的平角内裤坐在一起看电视，然后胡思乱想，然后一直工作到凌晨 3 点或 4 点，不停地工作。然后我的另一个朋友暑假从威斯康星大学搬了下来。那是在我大学一年级之后，然后我们三个人在那里工作。第三个朋友住在市中心。他会在早上乘轻轨过来，滑着滑板到我家。他会坐在外面用 Wi-Fi 上网，直到我们醒来，打开门，让他进来。</p><p class="normal">He moved up into my spare bedroom and we basically moved all the stuff out of my kitchen, set up a bunch of tables, and worked on computers. We would wake up around 10 or 11 and work until noon, and watch some TV—sit around in our boxers and watch TV, and hack, and stay up until 3 or 4 in the morning just working nonstop. Then another friend of mine moved down for the summer from UW. This was after my freshman year in college and then there were three of us working there. The third friend was living downtown. He would come on the light rail in the morning and skateboard over to my house. He would sit outside on Wi-Fi, just hacking until we woke up, opened the door, and let him in.</p>
<p class="normal">一旦我们三个人，我家就有点拥挤，所以我说，“哦，好吧，让我们找间办公室吧。” 所以我们有了一间办公室，我们就像，“哦，我们有这么多空间！让我们雇用更多的人。” 在接下来的几年里，我们慢慢地增加到 12 个，LiveJournal 变得越来越流行，然后压力也越来越大，因为我在处理 HR。</p><p class="normal">Once there were three of us, it was a little crowded in my house, so I was like, “Oh, OK, let's get an office.” So we got an office and we were like, “Oh, we have all this space! Let's hire more people.” We slowly got up to 12 over the next couple of years, and LiveJournal got more and more popular, and then more stressful too, because I was dealing with HR.</p>
<p class="normal"><a id="OEBPS/Chapter02.html.page_57"></a>或者我妈妈正在处理人力资源，而我妈妈因为为我工作而与我争吵。我必须为我妈妈制定规则，比如，“如果你打电话给我，必须是私人的或公事；无论你以什么开始，这就是你结束它的方式。你不能从工作转到个人，也不能从个人转到工作。” 如果她换了，我就开始挂断她。然后她会回电话，我说，“不，你输了。” 所以那真的很有压力。当我卖掉它时，她真的很高兴，她可以不再为我工作，我们也可以停止争吵。</p><p class="normal"><a></a>Or my mom was dealing with HR and my mom was fighting with me because she worked for me. I had to make rules for my mom, like, “If you call me, it has to be personal or business; whatever one you start with, that's how you end it. You can't switch from work to personal or personal to work.” I just started hanging up on her if she switched. Then she'd call back and I'm like, “Nope, you lost.” So that was really stressful. She was really happy when I sold it, and she could stop working for me and we could stop fighting.</p>
<p class="normal"><b>Seibel：</b>你的公司当时还在做合同工作还是全是 LiveJournal？</p><p class="normal"><b>Seibel:</b> Was your company still doing contract work or was it all LiveJournal at that point?</p>
<p class="normal"><b>菲茨帕特里克：</b>几乎都是 LiveJournal。我们还尝试启动照片托管服务，Flickr 打败了我们。我们的可能设计过度了：精美抽象并融入一切。但是我们为 LiveJournal 所做的每一件新的基础设施事情，我们都想，“这将如何在 FotoBilder 上发挥作用？” 所以我们开始构建抽象的一切。Memcached 是抽象的，因为没有理由将它绑定到 LiveJournal 中。然后我们构建了一个像 GFS 这样的文件系统，我们构建了一个作业队列。因此，我们一直在构建所有这些基础架构组件以进行扩展，以适用于我们的任何一种产品，而且还因为意大利面条依赖性越少，维护起来就越容易。即使工作多了一点，如果你能减少一些依赖性，那就太好了，</p><p class="normal"><b>Fitzpatrick:</b> It was pretty much all LiveJournal. We were also trying to start a photo hosting-service, which Flickr beat us to. Ours was probably overdesigned: beautifully abstract and plugged into everything. But each new infrastructure thing we did for LiveJournal, we were like, “How is this going to work on FotoBilder?” so we started building everything abstract. Memcached was abstract because there was no reason to tie it into LiveJournal. Then we built a file system like GFS, and we built a job queue. So we kept building all these infrastructure components for scaling that would work for either of our products, but also because the less intertwined spaghetti dependency-wise, the easier it is to maintain something. Even if it's a little bit more work, if you can cut some dependencies, it was great, so we started building all that generic infrastructure.</p>
<p class="normal"><b>Seibel：</b>我很好奇你扩展 LiveJournal 的过程，从你开始的地方以及你如何学到你需要学习的课程。</p><p class="normal"><b>Seibel:</b> I'm curious about the process that you went through of scaling LiveJournal, in terms of where you started and how you learned the lessons you needed to learn along the way.</p>
<p class="normal"><b>Fitzpatrick：</b>所以它从一个与其他客户共享的 Unix 机器开始，然后几乎把它扼杀了。</p><p class="normal"><b>Fitzpatrick:</b> So it started on one shared Unix box with other customers and pretty much killed that.</p>
<p class="normal"><b>Seibel：</b>作为 CGI 运行？</p><p class="normal"><b>Seibel:</b> Running as CGIs?</p>
<p class="normal"><b>菲茨帕特里克：</b>是的。是的。我认为这可能是字面上的 CGI，分叉整个世界然后死去。这个 ISP 有一个人指派给我。我的服务器一直在死机。我想，“我付了我的钱<a id="OEBPS/Chapter02.html.page_58"></a>每月 10.00 美元。为什么它不起作用？” 所以他会说，“哦，做这个吧。” 很快我就开始学习 Unix 并了解实际发生的事情。</p><p class="normal"><b>Fitzpatrick:</b> Yes. Yeah. I think it was probably a literal CGI, fork up the whole world and die. There was a guy assigned to me at this ISP. I was having problems with my server dying all the time. I'm like, “I paid my <a></a>$10.00 a month. Why isn't it working?” So he would say, “Oh, do this.” Pretty soon I was learning Unix and learning what was actually going on.</p>
<p class="normal">然后我转换为 FastGCI。然后我调整了 Apache 并关闭了反向 DNS 查找。你经历的所有这些步骤。最后，我受 I/O 或 CPU 限制。然后我有了自己的专用服务器，但它仍然只有一个，而且快要死了，我的容量也用完了。我最初是为我的朋友打开它的，但我只是让注册页面保持活动状态。然后他们邀请了他们的朋友，而他们的朋友又邀请了他们的朋友——这从来就不是一个真正的公共网站。它只是意外地打开了一个注册页面。所以我在 LiveJournal 新闻页面上发布了一些东西，然后我说，“帮助。我们需要购买服务器。”</p><p class="normal">Then I converted to FastGCI. Then I tuned Apache and turned off reverse DNS lookups. All these steps you go through. Finally, I was I/O-bound or CPU-bound. Then I got my own dedicated server, but it was still just one and it was dying and I was out of capacity. I had originally opened it up for my friends and I just left the signup page alive. Then they invited their friends who invited their friends—it was never really supposed to be a public site. It just had an open signup page on accident. So then I put something up on the LiveJournal news page and I said, “Help. We need to buy servers.”</p>
<p class="normal">我认为可能筹集了六七千美元或其他东西来购买这两台大戴尔并将它们放在西雅图市中心的 Speakeasy。有人推荐一些服务器，戴尔，这些巨大的 6U 东西，每个 90 磅。逻辑拆分是数据库服务器和 Web 服务器。那是我唯一知道的部门，因为我正在运行一个 MySQL 进程和一个 Apache 进程。</p><p class="normal">I think that raised maybe six or seven thousand dollars or something to buy these two big Dells and put them in Speakeasy in downtown Seattle. Somebody recommend some servers, Dells, these huge 6U things, like ninety pounds each. The logical split was the database server and the web server. That was the only division I knew because I was running a MySQL process and an Apache process.</p>
<p class="normal">有一段时间效果很好。网络服务器直接与世界对话，有两个网卡和一条连接数据库服务器的交叉电缆。然后网络服务器超载了，但这仍然很容易。此时我得到了 1U 服务器。然后我们有三台 Web 服务器和一台数据库服务器。那时，我开始使用三四个 HTTP 负载平衡器——mod_backhand、mod_proxy 和 Squid，并且讨厌它们。这开始了我对 HTTP 负载平衡器的厌恶。</p><p class="normal">That worked well for a while. The web servers spoke directly to the world and had two network cards and had a little crossover cable to the database server. Then the web server got overloaded, but that was still fairly easy. At this point I got 1U servers. Then we had three web servers and one database server. At that point, I started playing with three or four HTTP load balancers—mod_backhand and mod_proxy and Squid and hated them all. That started my hate for HTTP load balancers.</p>
<p class="normal">接下来要倒下的是数据库，那时我就像是，“哦，该死。” Web 服务器的横向扩展非常好。他们都是无国籍的。您只需扔更多它们并分散负载即可。所以那是一段压力很大的时间。“好吧，我可以优化查询一段时间，”但这只会给你一个星期的时间，直到它再次加载。所以在某个时候，我开始思考个人请求需要什么。</p><p class="normal">The next thing to fall over was the database, and that's when I was like, “Oh, shit.” The web servers scale out so nicely. They're all stateless. You just throw more of them and spread load. So that was a long stressful time. “Well, I can optimize queries for a while,” but that only gives you another week until it's loaded again. So at some point, I started thinking about what does an individual request need.</p>
<p class="normal">就在那时——我以为我是世界上第一个想到这个的人——我当时想，我们会把它切开——把它分开。所以我用图片写了设计文档，说明我们的代码将如何工作。“我们将拥有我们的主数据库，仅用于存储有关全球低流量事物的元数据以及所有每个博客的元数据<a id="OEBPS/Chapter02.html.page_59"></a>每个评论的内容将被分区到每个用户的数据库集群中。这些用户 ID 位于此数据库分区上。” 回想起来很明显——每个人都这样做。然后，在服务仍在运行的情况下，我们付出了巨大的努力来移植代码。</p><p class="normal">That's when—I thought I was the first person in the world to think of this—I was like, we'll shard it out—partition it. So I wrote up design doc with pictures saying how our code would work. “We'll have our master database just for metadata about global things that are low traffic and all the per-blog <a></a>and per-comment stuff will be partitioned onto a per-user database cluster. These user IDs are on this database partition.” Obvious in retrospect—it's what everyone does. Then there was a big effort to port the code while the service was still running.</p>
<p class="normal"><b>Seibel：</b>有没有一个危险的日子，你把一切都翻了个底朝天？</p><p class="normal"><b>Seibel:</b> Was there a red-flag day where you just flipped everything over?</p>
<p class="normal"><b>Fitzpatrick：</b>没有。每个用户都有一个标志，基本上说明他们所在的集群号。如果为零，则它们在 master 上；如果它不为零，则将它们分开。然后有一个“您的帐户被锁定”的版本号。因此它会锁定并尝试迁移数据，如果您在此期间进行了一些修改，然后重试——基本上，等到我们完成迁移，而您没有在主服务器上进行任何写入，然后进行数据透视然后说，“好的，现在你在那边。”</p><p class="normal"><b>Fitzpatrick:</b> No. Every user had a flag basically saying what cluster number they were on. If it was zero, they were on the master; if it was nonzero, they were partitioned out. Then there was a “Your Account Is Locked” version number. So it would lock and try to migrate the data and then retry if you'd done some mutation in the meantime—basically, wait 'til we've done a migration where you hadn't done any write on the master, and then pivot and say, “OK, now you're over there.”</p>
<p class="normal">此迁移需要几个月的时间才能在后台运行。我们计算过，如果我们只是直接进行数据转储并编写一些东西来拆分 SQL 文件并重新加载它，那将需要一周左右的时间。我们可能会有一周的停机时间或两个月的缓慢迁移。当我们迁移 10% 的用户时，该站点对其他用户来说又变得可以忍受了，这样我们就可以提高负载集群的迁移率。</p><p class="normal">This migration took months to run in the background. We calculated that if we just did a straight data dump and wrote something to split out the SQL files and reload it, it would have taken a week or something. We could have a week of downtime or two months of slow migration. And as we migrated, say, 10 percent of the users, the site became bearable again for the other ones, so then we could turn up the rate of migration off the loaded cluster.</p>
<p class="normal"><b>Seibel：</b>那都是 pre-memcached 和 pre-Perlbal。</p><p class="normal"><b>Seibel:</b> That was all pre-memcached and pre-Perlbal.</p>
<p class="normal"><b>Fitzpatrick：</b>是的，当然是在 Perlbal 之前。Memcached 可能会在那之后出现。我不认为我是在大学刚毕业，搬出去的时候才使用 memcached 的。我记得想出了这个主意。有一天我在洗澡。该站点正在崩溃，我正在淋浴，然后我意识到我们到处都有所有这些免费内存。那天晚上我做了一个原型，用 Perl 写了服务器，用 Perl 写了客户端，然后服务器就崩溃了，因为 Perl 服务器的 CPU 太多了。所以我们开始用 C 重写它。</p><p class="normal"><b>Fitzpatrick:</b> Yeah, pre-Perlbal for sure. Memcached might have come after that. I don't think I did memcached until like right after college, right when I moved out. I remember coming up with the idea. I was in my shower one day. The site was melting down and I was showering and then I realized we had all this free memory all over the place. I whipped up a prototype that night, wrote the server in Perl and the client in Perl, and the server just fell over because it was just way too much CPU for a Perl server. So we started rewriting it in C.</p>
<p class="normal"><b>Seibel：</b>这样一来，您就不必购买更多的数据库服务器了。</p><p class="normal"><b>Seibel:</b> So that saved you from having to buy more database servers.</p>
<p class="normal"><b>Fitzpatrick：</b>是的，因为它们价格昂贵且迁移速度慢。Web 服务器很便宜，我们可以添加它们，它们会立即生效。你买了一个新的数据库，这就像一个星期的设置和验证：测试它的磁盘，然后设置它并调整它。</p><p class="normal"><b>Fitzpatrick:</b> Yeah, because they were expensive and slow to migrate. Web servers were cheap and we could add them and they would take effect immediately. You buy a new database and it's like a week of setup and validation: test its disks, and set it all up and tune it.</p>
<p class="normal"><a id="OEBPS/Chapter02.html.page_60"></a><b>Seibel：</b>所以您构建的所有基础设施，如 memcached 和 Perlbal，都是为了响应 LiveJournal 的实际扩展需求而编写的？</p><p class="normal"><a></a><b>Seibel:</b> So all the pieces of infrastructure you built, like memcached and Perlbal, were written in response to the actual scaling needs of LiveJournal?</p>
<p class="normal"><b>菲茨帕特里克：</b>哦，是的。我们建造的一切都是因为网站正在倒塌，我们整晚都在努力建造一个新的基础设施。我们曾经购买过一台 NetApp。我们问：“多少钱？” 他们就像，“告诉我们你的商业模式。” “我们已经支付了账户。” “你有多少客户？你收什么钱？” 你只是看到它们成倍增加。“代价是：你拥有的所有可支配收入都不会破产。” 我们就像，“操你妈的。” 但我们需要它，所以我们买了一个。我们对它的 I/O 印象不深，它太贵了，而且仍然存在单点故障。他们试图向我们推销一种具有高可用性的配置，而我们就像是，“去他的。我们不会再购买这些东西了。”</p><p class="normal"><b>Fitzpatrick:</b> Oh, yeah. Everything we built was because the site was falling over and we were working all night to build a new infrastructure thing. We bought one NetApp ever. We asked, “How much does it cost?” and they're like, “Tell us about your business model.” “We have paid accounts.” “How many customers do you have? What do you charge?” You just see them multiplying. “The price is: all the disposable income you have without going broke.” We're like, “Fuck you.” But we needed it, so we bought one. We weren't too impressed with the I/O on it and it was way too expensive and there was still a single point of failure. They were trying to sell us a configuration that would be high availability and we were like, “Fuck it. We're not buying any more of these things.”</p>
<p class="normal">所以我们才开始研究文件系统。我什至不确定此时 GFS 论文是否已经发表——我想我是从某人那里听说过的。在这一点上，我总是通过对密钥进行哈希处理并选择分片来遍历所有内存。为什么我们不能对文件执行此操作？嗯，文件是永久的。因此，我们应该实际记录它的位置，因为随着我们添加更多存储节点，配置会随着时间而改变。I/O 不多，只是跟踪东西在哪里，但我们如何实现高可用性？所以我们弄清楚了那部分，然后我想出了一个方案：“这是我们将执行的所有读取和写入操作，以查找内容所在的位置。” 我首先为 master 和文件所在的跟踪器编写了 MySQL 模式。然后我就像，“天哪！那么这部分可能只是 HTTP。这不是</p><p class="normal">So then we just started working on a file system. I'm not even sure the GFS paper had published at this point—I think I'd heard about it from somebody. At this point I was always spraying memory all over just by taking a hash of the key and picking the shard. Why can't we do this with files? Well, files are permanent. So, we should record actually where it is because configuration will change over time as we add more storage nodes. That's not much I/O, just keeping track of where stuff is, but how do we make that high availability? So we figured that part out, and I came up with a scheme: “Here's all the reads and writes we'll do to find where stuff is.” And I wrote the MySQL schema first for the master and the tracker for where the files are. Then I was like, “Holy shit! Then this part could just be HTTP. This isn't hard at all!”</p>
<p class="normal">我记得我整晚都在想这个问题后才开始工作。我们在共享办公楼的楼下有一个会议室——一个非常肮脏、恶心的会议室。“好了，大家停下来。我们要下楼了。我们在画画。” 每次我们进行设计时，这几乎就是我所说的——我们会去找白板来画画。</p><p class="normal">I remember coming into work after I'd been up all night thinking about this. We had a conference room downstairs in the shared office building—a really dingy, gross conference room. “All right, everyone, stop. We're going downstairs. We're drawing.” Which is pretty much what I said every time we had a design—we'd go find the whiteboards to draw.</p>
<p class="normal">我解释了模式和谁与谁交谈，以及谁对请求做了什么。然后我们上楼，我想我首先订购了所有硬件，因为它需要两周左右的时间才能拿到。然后我们开始编写代码，希望我们能在机器到达时完成代码。<a id="OEBPS/Chapter02.html.page_61"></a>一切都在火中。总有东西坏掉，所以我们总是在编写新的基础设施组件。</p><p class="normal">I explained the schema and who talks to who, and who does what with the request. Then we went upstairs and I think I first ordered all the hardware because it takes two weeks or something to get it. Then we started writing the code, hoping we'd have the code done by the time the machines arrived. <a></a>Everything was always under fire. Something was always breaking so we were always writing new infrastructure components.</p>
<p class="normal"><b>Seibel：</b>如果有人在一开始就让你坐下来告诉你，“你需要了解 X、Y 和 Z”，你的生活会不会轻松很多？</p><p class="normal"><b>Seibel:</b> Are there things that if someone had just sat you down at the very beginning and told you, “You need to know X, Y, and Z,” that your life would have been much easier?</p>
<p class="normal"><b>Fitzpatrick：</b>第一次就把事情做对总是比使用实时服务进行迁移更容易。那是有史以来最大的痛苦。我所描述的一切，你都可以在一台机器上完成。像这样开始设计。您不再假设能够将此用户数据与此用户数据或类似的东西结合起来。假设您想要加载这 20 个资产——您的实现可以是从同一个表中加载它们，但是您的更高级别的代码只是说“我想要这 20 个对象”可以有一个分散的实现-聚集在一大堆机器上。如果我从一开始就这样做，我就会避免很多迁移的痛苦。</p><p class="normal"><b>Fitzpatrick:</b> It's always easier to do something right the first time than to do a migration with a live service. That's the biggest pain in the ass ever. Everything I've described, you could do on a single machine. Design it like this to begin with. You no longer make assumptions about being able to join this user data with this user data or something like that. Assume that you're going to want to load these 20 assets—your implementation can be to load them all from the same table but your higher-level code that just says, “I want these 20 objects” can have an implementation that scatter-gathers over a whole bunch of machines. If I would have done that from the beginning, I'd have saved a lot of migration pain.</p>
<p class="normal"><b>Seibel：</b>所以基本上教训是，“你必须为你的数据不能全部放入一个数据库的那一天做好计划。”</p><p class="normal"><b>Seibel:</b> So basically the lesson is, “You have to plan for the day when your data doesn't all fit into one database.”</p>
<p class="normal"><b>Fitzpatrick：</b>我认为这是当今网络社区的常识。人们可能会过度假设他们的网站将变得庞大。但在当时，常识是，Apache 是你所需要的，MySQL 是你所需要的。</p><p class="normal"><b>Fitzpatrick:</b> Which I think is common knowledge nowadays in the web community. And people can go overkill on assuming that their site is going to be huge. But at the time, the common knowledge was, Apache is all you need and MySQL is all you need.</p>
<p class="normal"><b>Seibel：</b>看起来确实是当你因为需要而写所有这些东西时，你也喜欢这样做。</p><p class="normal"><b>Seibel:</b> It does seem that while you were writing all this stuff because you needed it, you also enjoyed doing it.</p>
<p class="normal"><b>菲茨帕特里克：</b>哦，是的。我肯定会找借口使用任何东西，学习它。因为除非你必须在其中写下一些东西，直到你必须生活和呼吸它，否则你永远不会学到任何东西。为乐趣而学习一门语言是一回事，但除非你用它编写了一些大型、复杂的系统，否则你不会真正学习它。</p><p class="normal"><b>Fitzpatrick:</b> Oh, yeah. I definitely try to find an excuse to use anything, to learn it. Because you never learn something until you have to write something in it, until you have to live and breathe it. It's one thing to go learn a language for fun, but until you write some big, complex system in it, you don't really learn it.</p>
<p class="normal"><b>Seibel：</b>那么你会说哪些语言是你真正生活和呼吸过的，足以声称是你自己的语言？</p><p class="normal"><b>Seibel:</b> So what languages would you say you've really lived and breathed with enough to claim as your own?</p>
<p class="normal"><a id="OEBPS/Chapter02.html.page_62"></a><b>菲茨帕特里克：</b> Perl。C. 回到过去，BASIC，但我什至不确定 BASIC 是否重要。我也写了很多Logo。在我们小学的 Logo 课上，人们正在做起笔、落笔，而我不会处于图形模式——有一些键可以退出图形模式——编写函数。我的老师会走过来说，“你在做什么？你做错了事。你应该在画房子。” “不，我在写 Logo。看，”“不，你不是。” 然后在课程结束时我会做一些事情——我有一个库可以绘制字母表中的每个字母，但可以任意缩放和旋转。所以我可以将整个信息打印在波浪形的横幅上，然后延伸到远处等等，每个人都说，“他妈的是什么？” 我也不知道那个算不算。</p><p class="normal"><a></a><b>Fitzpatrick:</b> Perl. C. Back in the day, BASIC, but I'm not even sure BASIC counts. I wrote a lot of Logo too. In our Logo class in elementary school, people were doing pen up, pen down and I would be not in graphics mode—there's some key to get out of graphics mode—writing functions. My teacher would come over and say, “What are you doing? You're doing the wrong thing. You're supposed to be drawing houses.” “No, I'm writing Logo. Look,” “No, you're not.” Then at the end of the class I'd do something—I had a library that drew every letter of the alphabet, but at arbitrary scales and rotations. So I could print entire messages on wavy banners going into the distance and stuff, and everyone was like, “What the fuck?” I don't know if that one counts either.</p>
<p class="normal">但是很多 Perl 和 C，然后在大学里为了工作和 Windows 而学习了很多 C++。然后我忘记了C++，或者它萎缩了，现在在谷歌，在去年，很多C++、Python和Java。Java 刚出来的时候我也写了很多，但后来我厌倦了它。现在我又在写很多 Java，我有点厌烦了。</p><p class="normal">But a lot of Perl and C, and then a lot of C++ in college for work and for Windows stuff. Then I forgot C++, or it atrophied, and now at Google, in the last year, it's a lot of C++, Python, and Java. I also wrote a lot of Java back in the day when it first came out, but then I got sick of it. Now I'm writing a lot of Java again, and I'm kinda sick of it.</p>
<p class="normal"><b>Seibel：</b>你使用什么语言对你来说很重要吗？</p><p class="normal"><b>Seibel:</b> Does it matter much to you what language you use?</p>
<p class="normal"><b>Fitzpatrick：</b>我对他们中的任何一个都不满意。我不知道到底什么能让我完全开心。我讨厌对于一个给定的项目，你必须一直跳来跳去。我想要一些让我拥有静态类型并在编译时检查所有这些东西的东西，当我想要的时候。Perl 让我非常接近，因为它让我可以用我想要的任何风格来写作。它不允许我在编译时做足够的静态检查，但我可以在运行时让它爆炸。但这还不够好。</p><p class="normal"><b>Fitzpatrick:</b> I'm still not happy with any of them. I don't know what exactly would make me totally happy. I hate that for a given project you have to jump around all the time. I want something that lets me have static types and checks all that stuff at compile time, when I want. Perl gets me pretty close in that it lets me write in any style I want. It doesn't let me do enough static checking at compile time but I can make it blow up pretty hard when I want to at runtime. But it's still not good enough.</p>
<p class="normal">我想要可选的静态类型。在 Perlbal 中，没有理由让一半的东西具有性能，除了核心，复制字节。我想在代码的某些部分给出运行时提示并声明类型。但如果我想偷懒并嘲笑一些东西，我想用那种风格来写。</p><p class="normal">I want optional static typing. In Perlbal, there's no reason for half the things to be performant except for the core, copying bytes around. I would like to give the runtime hints in certain parts of the code and declare types. But if I want to be lazy and mock something out, I want to write in that style.</p>
<p class="normal"><b>Seibel：</b>所以你主要需要类型，以便编译器可以更好地优化？</p><p class="normal"><b>Seibel:</b> So you want types mostly so the compiler can optimize better?</p>
<p class="normal"><b>Fitzpatrick：</b>不。我还希望它在编译时爆炸，告诉我，“你在做一些愚蠢的事情。” 然后有时我不在乎，我希望它在运行时为我强制并做任何事情。我不想太<a id="OEBPS/Chapter02.html.page_63"></a>看好 Perl 6，但他们宣扬了很多我想看到的东西。但我不认为它会出来。</p><p class="normal"><b>Fitzpatrick:</b> No. I also want it to blow up at compile time to tell me like, “You're doing something stupid.” Then sometimes I don't care and I want it to coerce for me at runtime and do whatever. I don't want to be too <a></a>optimistic about Perl 6, but they're preaching a lot of things I want to see. But I don't think it'll ever come out.</p>
<p class="normal"><b>Seibel：</b>你喜欢 C++ 吗？</p><p class="normal"><b>Seibel:</b> Do you like C++?</p>
<p class="normal"><b>菲茨帕特里克：</b>我不介意。语法很糟糕，完全不一致，而且错误消息，至少来自 GCC，是荒谬的。你可能会因为忘记了一些分号而得到 40 页的错误。但是——就像其他任何事情一样——你很快就能记住所有的模式。你连字都不读；你只是看到结构并想，“哦，是的，我可能忘记关闭头文件中的名称空间。” 我认为新的 C++ 规范，尽管它增加了如此多的复杂性，但有很多东西可以减少打字的痛苦——就击键次数而言。自动变量和 for 循环。它更像是 Python 风格。还有 lambda。这足以让我自欺欺人地认为我是用 Python 编写的，即使它是 C++。</p><p class="normal"><b>Fitzpatrick:</b> I don't mind it. The syntax is terrible and totally inconsistent and the error messages, at least from GCC, are ridiculous. You can get 40 pages of error spew because you forgot some semicolon. But—like anything else—you quickly memorize all the patterns. You don't even read the words; you just see the structure and think, “Oh, yeah, I probably forgot to close the namespace in a header file.” I think the new C++ spec, even though it adds so much complexity, has a lot of stuff that'll make it less painful to type—as far as number of keystrokes. The auto variables and the for loops. It's more like Python style. And the lambdas. It's enough that I could delude myself into thinking I'm writing in Python, even though it's C++.</p>
<p class="normal"><b>Seibel：</b>你使用 C++ 来提高效率。</p><p class="normal"><b>Seibel:</b> And you use C++ for efficiency.</p>
<p class="normal"><b>菲茨帕特里克：</b>是的，差不多。我主要在谷歌使用它。任何半途性能的东西都在 C++ 中。我还在谷歌写了大量的 Java。</p><p class="normal"><b>Fitzpatrick:</b> Yeah, pretty much. I mostly use it at Google. Anything that's halfway performant is in C++ there. I also write a ton of Java at Google.</p>
<p class="normal"><b>Seibel：据</b>我所知，谷歌有一种以 C++ 为中心的文化，因为这是他们最初使用的，并且他们围绕它构建了一大堆软件基础设施。虽然您无法撤消所有这些历史记录，但可能有很多代码是在 Google 用 C++ 编写的，对于性能而言并不是真正必要的。</p><p class="normal"><b>Seibel:</b> From what I understand, Google has a C++-centric culture because that's what they used originally and they've built a whole bunch of software infrastructure around it. While you can't undo all that history, there's probably a lot of code written at Google in C++ where it's not really necessary for performance.</p>
<p class="normal"><b>Fitzpatrick：</b>尤其是因为随着时间的推移，Java 变得更快，而 JVM 也变得更加智能。关于 Java 让我恼火的一点是每个人都对 JNI 的东西有如此强烈的反感。有时库是用 C++ 编写的。Python 人员——在外部社区和 Google 内部——并不关心。他们就像，“哦，我们会痛饮它。” 他们上路了，他们很高兴。如果是 C++ 语言，Python 会立即获得支持，因为他们对源语言是什么并不虔诚。</p><p class="normal"><b>Fitzpatrick:</b> Especially because, over time, Java has gotten faster and the JVM has gotten a lot smarter. The thing that annoys me about Java is that everyone has such a strong aversion to JNI stuff. Sometimes a library is in C++. The Python people—in the outside community and inside Google—don't care. They're like, “Oh, we'll SWIG-wrap it.” They get on their way and they're happy. Python gets support for something right away if it's in C++ because they're not religious about what the source language is.</p>
<p class="normal">Java 人就像，“必须是纯 Java。我们不能使用 JNI，因为如果 JVM 崩溃，我们不知道原因。” 这样做的问题是你最终把所有的东西都写了两次，一次是为 C++ 和 Python 写的，其他的都是<a id="OEBPS/Chapter02.html.page_64"></a>语言，然后是 Java。因此，如果他们能想出一个好的嵌入故事或克服对 JNI 的恐惧，那么我不会介意。</p><p class="normal">Java people are like, “Must be pure Java. We cannot use JNI because then if the JVM crashes, we don't know why.” The problem with that is you end up writing everything twice, once for C++ and Python and all the other <a></a>languages, and then once for Java. So if they could come up with a good embedding story or get over this fear of JNI, then I wouldn't mind it.</p>
<p class="normal"><b>Seibel：</b>显式内存管理与垃圾回收相比如何？人们仍然对此争论不休。您对某种方式有强烈的意见吗？</p><p class="normal"><b>Seibel:</b> What about explicit memory management versus garbage collection? People still argue about that. Do you have a strong opinion one way or the other?</p>
<p class="normal"><b>菲茨帕特里克：</b>不，不是真的。我很高兴看到其他人的强烈意见，而他们通常没有任何支持。我个人并不觉得管理内存有那么烦人，至少在 C++ 中使用类似范围的指针是这样。我可以用 C++ 写好几天，却从不说“新建”或“删除”。这似乎只是所有类型的工作。</p><p class="normal"><b>Fitzpatrick:</b> No, not really. I'm amused to watch other people's strong opinions when generally they're not backed up by anything. I personally don't find it that annoying to manage memory, at least in C++ with like scoped pointers. I can write in C++ for days and never actually say “new” or “delete”. It seems to just all kind of work.</p>
<p class="normal">我在 Google 内部重写了 memcached 以与 Google 基础架构一起工作并将其添加到 App Engine。这一切都是用 C++ 编写的，因为我需要对内存进行非常排他性的控制以减少碎片。所以我真的很感激把它放在那里。</p><p class="normal">I rewrote memcached inside Google to work with Google infrastructure and to add it to App Engine. That was all written in C++ because I needed a very exclusive control of memory to reduce fragmentation. So I really appreciated having it there.</p>
<p class="normal"><b>Seibel：</b>原来的 memcached 是用 C 写的。你是用 C++ 重做的，因为 C++ 在谷歌内部更受欢迎，还是有其他优势？</p><p class="normal"><b>Seibel:</b> The original memcached was in C. Did you redo it in C++ because C++ is more accepted within Google, or were there other advantages?</p>
<p class="normal"><b>Fitzpatrick：</b>我开始采用现有的并移植它，但结果证明需要做更多的工作。Memcached 没有那么多代码开始，所以用 C++ 重写要快得多。它就像一半的代码，用 C++ 重写。</p><p class="normal"><b>Fitzpatrick:</b> I started to take the existing one and port it but it turned out to be more work. Memcached isn't that much code to begin with, so it was a lot quicker to just rewrite in C++. It was like half as much code, rewriting it in C++.</p>
<p class="normal"><b>Seibel：</b>你认为那是因为 C++ 还是仅仅因为你这次更聪明了？</p><p class="normal"><b>Seibel:</b> Do you think that was because of C++ or just because you were smarter this time around?</p>
<p class="normal"><b>菲茨帕特里克：</b>有可能。有一次，当我 11 岁或 12 岁时，我们正在美国旅行，我在 TI-85 计算器上编写了那个游戏 Mastermind。我正在这个小屏幕上写这个程序——几百行——试图记住我在哪里。我最终删除了该死的东西两次。所以我把这件事写了三遍。但后来它变得如此容易。这是一个很好的观点——第二次就容易多了。</p><p class="normal"><b>Fitzpatrick:</b> It could be. Once, when I was 11 or 12, we were on a trip around the US and I wrote that game Mastermind on a TI-85 calculator. I'm writing this program—a couple hundred lines—on this tiny little screen trying to remember where I am. I ended up deleting the damn thing twice. So I wrote the thing three times. But then it got so easy. That's a good point—the second time around it was a lot easier.</p>
<p class="normal"><b>Seibel：</b>您已经用 Perl 完成了很多工作，Perl 是一种相当高级的语言。您认为程序员需要走多低——程序员还需要了解汇编和芯片的工作原理吗？</p><p class="normal"><b>Seibel:</b> You've done a lot of your work in Perl, which is a pretty high-level language. How low do you think programmers need to go—do programmers still need to know assembly and how chips work?</p>
<p class="normal"><a id="OEBPS/Chapter02.html.page_65"></a><b>菲茨帕特里克：</b>我不知道。我看到一些人非常聪明——我会说他们是优秀的程序员——但说他们只懂 Java。他们思考解决问题的方式总是在他们所知道的空间之内。他们不认为端到端那么多。我认为了解整个堆栈非常重要，即使您不在整个堆栈中操作也是如此。</p><p class="normal"><a></a><b>Fitzpatrick:</b> I don't know. I see people that are really smart—I would say they're good programmers—but say they only know Java. The way they think about solving things is always within the space they know. They don't think end-to-end as much. I think it's really important to know the whole stack even if you don't operate within the whole stack.</p>
<p class="normal">当我在 LiveJournal 上做事时，我在考虑从 JavaScript 到事物如何在内核中交互的事情。我正在阅读有关 epoll 的 Linux 内核代码，我当时想，“好吧，如果我们有所有这些长 TCP 连接，并且 JavaScript 正在轮询这些打开的 TCP 连接，这些连接将转到这个负载均衡器？” 我想在这里每个结构中有多少内存。这仍然有些高层次，但后来我们在考虑类似的事情，我们在以太网卡上收到如此多的中断——我们是否在内核中切换到这个 NAPI，而不是 NIC 在每个传入数据包上发送中断它将它们合并到相当于 100 兆位速度的边界，即使它是一个千兆位 NIC。</p><p class="normal">When I was doing stuff on LiveJournal, I was thinking about things from JavaScript to how things were interacting in the kernel. I was reading Linux kernel code about epoll and I was like, “Well, what if we have all these long TCP connections and JavaScript is polling with these open TCP connections that are going to this load balancer?” I was trying to think of how much memory is in each structure here. That's still somewhat high-level, but then we were thinking about things like, we're getting so many interrupts on the Ethernet card—do we switch to this NAPI thing in the kernel where rather than the NIC sending an interrupt on every incoming packet it coalesces them to boundaries that were equivalent to 100 megabits speed even though it was a gigabit NIC. We were collecting numbers to see at what point this made sense and freed up the processor.</p>
<p class="normal">我们在真正低级的东西上获得了很多胜利。最近有人告诉我一件事：“Java 负责这件事；我们不必处理那个。” 我当时想，“不，Java 无法解决这个问题，因为我知道您使用的内核版本并且内核不支持它。你的虚拟机可能对你隐藏了这一点，并给你一些抽象，使它看起来很高效，但只有当你在这个内核上运行它时它才是高效的。” 如果人们至少不了解整个堆栈的表面，我会感到沮丧。</p><p class="normal">We were getting a lot of wins for really low-level stuff. I had somebody recently tell me about something: “Java takes care of that; we don't have to deal with that.” I was like, “No, Java can't take care of this because I know what kernel version you're using and the kernel doesn't support it. Your virtual machine may be hiding that from you and giving you some abstraction that makes it look like that's efficient, but it's only efficient when you're running it on this kernel.” I get frustrated if people don't understand at least the surface of the whole stack.</p>
<p class="normal">实际上，没有任何作用。所有这些美丽的抽象都是由狗屎支持的。看起来很漂亮的库的实现很糟糕。因此，如果您是负责购买服务器成本或可靠性的人——如果您随叫随到——这有助于真正了解幕后发生的事情，而不是相信其他人的库、代码和接口。</p><p class="normal">In practice, nothing works. There are all these beautiful abstractions that are backed by shit. The implementation of libraries that look like they could be beautiful are shit. And so if you're the one responsible for the cost of buying servers, or reliability—if you're on call for pages—it helps to actually know what's going on under the covers and not trust everyone else's libraries, and code, and interfaces.</p>
<p class="normal">如果我刚开始，我几乎不认为我今天会成为一名程序员。简直太丑了。这就是为什么我对 App Engine 之类的东西如此兴奋。有人将 Google 的 App Engine 描述为这一代的 BASIC。因为这一代人，一切都联网了。当我是<a id="OEBPS/Chapter02.html.page_66"></a>编程，它是一种语言，在我自己的机器上，部署是 up enter，或者 RUN enter。今天的孩子们不想在他们自己的机器上写一些愚蠢的东西，比如“弹跳球”应用程序。他们想要一个可以与之交互的网站。</p><p class="normal">I almost don't think I would be a programmer today if I was starting off. It's just too ugly. This is why I'm so excited about things like App Engine. Someone described Google's App Engine as this generation's BASIC. Because this generation, everything is networked. When I was <a></a>programming, it was one language, and it was on my own machine, and the deploy was up enter, or RUN enter. Kids today don't want to write something stupid like a “bounce a ball” app on their own machine. They want a web site to interact with.</p>
<p class="normal">仍然有人给我发邮件，他们说，“嘿，我有这个想法——我想让维基百科与 YouTube 相遇，相遇——”每个人都想做一个网站，而他们最喜欢的四个网站不太合适，他们想要做一个看起来像那样的东西。</p><p class="normal">I still have people mailing me who are like, “Hey, I have this idea—I want to make Wikipedia meets YouTube, meets—” Everyone wants to do a web site where their favorite four web sites aren't quite right and they want to make one that looks kind of like that.</p>
<p class="normal">App Engine 为您提供了一个按钮，“将其放到 Web 上”，并且您可以使用一种语言编写，可以说是一种非常容易学习的语言，Python，这一事实是完美的。这是一个很好的编程入门——有很多层层的废话，它摆脱了。</p><p class="normal">The fact that App Engine gives you one button, “Put this on the Web,” and you write in one language, arguably a pretty easy-to-learn one, Python, is perfect. It's a great intro to programming—there are so many layers and layers of bullshit that it gets rid of.</p>
<p class="normal"><b>Seibel：</b>这与您对 Java 人员告诉您“哦，Java 会为您解决这些问题”的沮丧情绪有何关联。这不一样吗？“好吧，App Engine 会为您解决这个问题。”</p><p class="normal"><b>Seibel:</b> How does that fit with your dismay at the Java guys who tell you, “Oh, Java takes care of that for you.” Isn't that the same? “Well, App Engine will take care of that for you.”</p>
<p class="normal"><b>菲茨帕特里克：</b>我不知道。也许是因为我知道发生了什么。实际上，JVM 并没有那么糟糕。我想这是当人们盲目相信他们的抽象概念而不了解正在发生的事情时。</p><p class="normal"><b>Fitzpatrick:</b> I don't know. Maybe it's because I know what's going on. Actually the JVM isn't that bad. I guess it's when people have blind faith in their abstractions without understanding what's going on.</p>
<p class="normal"><b>Seibel：</b>当你上大学学习计算机科学时，你已经有了很多编程经验。结果如何？</p><p class="normal"><b>Seibel:</b> You had a lot of programming experience by the time you got to college and studied computer science. How did that work out?</p>
<p class="normal"><b>Fitzpatrick：</b>我跳过了很多早期的 CS 课程，因为它们真的很无聊。我会去参加考试。然后到了最后，一旦您进入 300 级和 400 级课程，他们就会变得很有趣。但是就在它变得有趣的时候，我毕业了。而且他们不让我参加有趣的研究生课程，因为我不是研究生。</p><p class="normal"><b>Fitzpatrick:</b> I skipped a lot of my early C.S. classes, because they were just really boring. I would go and take the tests. Then towards the end they got kind of fun, once you get to the 300- and 400-level classes. But right when it got interesting, I graduated. And they wouldn't let me take the fun grad-level classes, because I wasn't a grad student.</p>
<p class="normal">我记得在编译器类中，最终项目是我们必须采用我们一直在使用的这种现有语言并添加一大堆功能，包括我们自己选择的一个功能作为项目的奖励部分。所以我选择实现运行时数组边界检查。不管怎样，教授拿走了我们编译好的二进制文件并针对它运行了他的测试套件，但它没有通过他的几次测试。他说，“对不起，你得了 C，因为你没有通过我的单元测试，”当我去看它时，我说，“你已经——<a id="OEBPS/Chapter02.html.page_67"></a>那些在你的测试套件中。” 所以他给了我成绩，我得到了 A，但我从来没有因为为语言添加功能而获得加分。那时我对学校很生气。</p><p class="normal">I remember in the compiler class, the final project was we had to take this existing language that we had been playing with and add a whole bunch of features, including one feature of our own choosing as the bonus part of the project. So I chose to implement run-time array bounds checking. Anyway, the professor took our compiled binary and ran his test suite against it, and it failed a couple of his tests. He was like, “Sorry, you get a C because you failed my unit test,” When I went to look at it, I was like, “You have off-by-<a></a>ones in your test suite.” So he gave me the grade back and I got an A, but I never got the bonus points for adding a feature to the language. I was angry at school at that point.</p>
<p class="normal">我记得我们的数据库课程是由一个似乎没有数据库实际经验的人教授的。在这一点上，我使用过 Oracle、Microsoft Server 和大量的 MySQL。所以我问了所有这些我真正想要答案的现实问题——现在正在融化的东西——他们只会给我一些教科书般的答案。我想，“不，不。那是行不通的。”</p><p class="normal">And I remember our database class was taught by someone who, it seemed, had no real-world experience with databases. At this point I'd worked with Oracle, Microsoft Server, and tons of MySQL. So I was asking all these real-world questions I actually wanted answers to—things that were melting right now—they would just give me some textbook answer. I'm like, “No, no. That doesn't work.”</p>
<p class="normal"><b>Seibel：</b>你是 2002 年毕业的。你现在对他们试图教给你的东西有没有更多的欣赏？</p><p class="normal"><b>Seibel:</b> You graduated in 2002. Do you have any greater appreciation now of what they were trying to teach you?</p>
<p class="normal"><b>Fitzpatrick：</b>一半的课程我都非常喜欢，要么我学到了一些我当时不会学的全新东西，要么我学到了正确的背景材料和正确的术语。在此之前，我非常了解编程，但我没有词汇来描述我在做什么。或者我会为它编造自己的术语，人们会认为我不知道我在说什么。正规的 CS 教育帮助我能够谈论它。</p><p class="normal"><b>Fitzpatrick:</b> Half the classes I totally loved, and either I learned something totally new that I wouldn't have learned at the time, or I learned the proper background material and the proper terminology. Prior to that, I knew programming pretty well but I didn't have the vocabulary to describe what it was I was doing. Or I would make up my own terminology for it and people would think I didn't know what I was talking about. Formal C.S. education helped me be able to talk about it.</p>
<p class="normal"><b>Seibel：</b>您对将企业与学校结合起来有什么遗憾吗？你宁愿只做一个还是另一个？</p><p class="normal"><b>Seibel:</b> Do you have any regrets about combining running a business with school? Would you rather have just done one or the other?</p>
<p class="normal"><b>Fitzpatrick：</b>不，我认为那是最好的方式。我有朋友上过大学，只是上过大学，但我已经知道了很多，我会觉得无聊的。我有一个朋友也知道很多，但他属于这种思想流派，他在大学学习，而不是为了成绩，所以他一边学习阿拉伯语、汉语和日语。以及所有疯狂的编程语言。每周就像，“我有一种新的最喜欢的语言。这周我只会用 OCaml 编写。” 所以他就这样让自己忙起来。我让自己忙起来，不厌倦其他方式。</p><p class="normal"><b>Fitzpatrick:</b> No, I think that was the best way. I had friends who went to college and just did college, but I knew so much of it already, I would've been bored. I had one friend who also knew a whole bunch of it but he was of this school of thought that he's at college to learn, not for grades, so he was, on the side, studying Arabic and Chinese and Japanese. And all the crazy programming languages. Every week it was like, “I have a new favorite language. This week I'm only going to write in OCaml.” So he kept himself busy that way. I kept myself busy and not bored other ways.</p>
<p class="normal">然后我有一些朋友在大一毕业后就退学了，只是为了做网络方面的事情。一对夫妇正在做一个色情网站之类的。他们就像，“哦，我们赚了这么多钱。” 但是他们只是工作了一大堆；他们总是在地下室工作。大学很棒<a id="OEBPS/Chapter02.html.page_68"></a>用于与人会面和聚会。如果我<i>只做</i>LiveJournal，我会在压力下自杀。</p><p class="normal">Then I had friends who dropped out after their freshman year just to do web stuff. A couple were doing a porn web site or something. They were like, “Oh, we're making all this money.” But they just worked a whole bunch; they were always in their basement working. College was awesome <a></a>for meeting people and partying. If I <i>just</i> did LiveJournal, I would've killed myself stresswise.</p>
<p class="normal"><b>Seibel：</b>你很高兴你学习了计算机科学吗？</p><p class="normal"><b>Seibel:</b> Are you glad you studied computer science?</p>
<p class="normal"><b>Fitzpatrick：</b>没有它我可能也能做到。我做了很多我平时不会做的事情，所以我想这很好。我希望也许我也想做些别的事情，也许再呆一年并攻读完全不相关的双学位。多学语言学。我有点难过我离开了大学，我觉得我只学了一半，因为我已经知道了很多。我几乎没有参加过我早期的 CS 课程，直到快结束时，事情才开始变得有趣，就像“好吧，你完成了。”</p><p class="normal"><b>Fitzpatrick:</b> I probably could have done without it. I did a lot of things I wouldn't have done normally, so I guess it was good. I wish maybe I would have like done something else as well, maybe stayed another year and double-majored in something totally unrelated. Did linguistics more. I'm kind of sad I left college and I felt I only did half studying because so much of it I already knew. My early C.S. classes I barely attended and it was only towards the end where things just started to get interesting when it was like, “OK, you're done.”</p>
<p class="normal"><b>Seibel：</b>你有没有想过读研究生？</p><p class="normal"><b>Seibel:</b> Did you ever think about going to grad school?</p>
<p class="normal"><b>菲茨帕特里克：</b>是的。这本来会很有趣，但我很忙。</p><p class="normal"><b>Fitzpatrick:</b> Yeah. It would have been fun, but I was busy.</p>
<p class="normal"><b>Seibel：</b>你会努力跟上 CS 文献吗？</p><p class="normal"><b>Seibel:</b> Do you try to keep up with the C.S. literature?</p>
<p class="normal"><b>Fitzpatrick：</b>我和我的朋友们仍然互相转发论文，整洁的论文。前几天我读到一些关于在运行时调整 Bloom 过滤器大小的新技术。太棒了。来自存储会议的论文，一些来自行业，一些来自学术界，关于不同的酷系统——我试着阅读那些。Google 有不同的阅读小组——系统阅读小组或存储阅读小组。我会在 Reddit 上看到一些东西，或者朋友会转发一篇论文或类似的东西，或者在博客上链接它。</p><p class="normal"><b>Fitzpatrick:</b> Me and my friends still forward each other papers around, neat papers. I read something the other day about some new technique for resizing Bloom filters at runtime. It was pretty awesome. The papers that come out of the storage conferences, some out of industry and some from academics, about different cool systems—I try to read those. There are different reading groups at Google—systems reading groups or storage reading groups. I'll see something on Reddit or a friend will forward a paper or something like that or link it on a blog.</p>
<p class="normal"><b>Seibel：</b>您刚才提到了学术界和工业界的论文。你有没有感觉这两个人最近是否在正确的地方相遇？</p><p class="normal"><b>Seibel:</b> You just mentioned papers from the academy and from industry. Do you have any sense of whether those two meet in the right place these days?</p>
<p class="normal"><b>菲茨帕特里克：</b>他们对我来说感觉差不多。但很多时候更有趣的是阅读行业的，因为你知道他们这样做是为了解决问题并且他们的解决方案有效，而不是，“如果——我们会认为这会很酷——”有很多更疯狂的来自学术界的东西实际上并没有用，所以这只是一个疯狂的想法。也许他们以后会把它变成商业的东西。</p><p class="normal"><b>Fitzpatrick:</b> They kind of feel about the same to me. But it's more interesting, a lot of times, to read the industry ones because you know they did it to solve a problem and their solution works as opposed to, “We'd think it would be cool if—” There's a lot of crazier stuff that comes out of academia and it doesn't actually work, so it's just a crazy idea. Maybe they turn it into commercial things later.</p>
<p class="normal"><a id="OEBPS/Chapter02.html.page_69"></a><b>Seibel：</b>您如何设计软件？</p><p class="normal"><a></a><b>Seibel:</b> How do you design software?</p>
<p class="normal"><b>Fitzpatrick：</b>我从事物之间的接口开始。什么是常用方法，或常用 RPC，或常用查询。如果是存储，我试着想，常见的查询是什么？我们需要什么指标？数据将如何布置在磁盘上？然后我为不同的部分编写虚拟模拟并随着时间的推移充实它。</p><p class="normal"><b>Fitzpatrick:</b> I start with interfaces between things. What are the common methods, or the common RPCs, or the common queries. If it's storage, I try to think, what are the common queries? What indexes do we need? How are the data going to be laid out on disk? Then I write dummy mocks for different parts and flesh it out over time.</p>
<p class="normal"><b>Seibel：</b>您是否以测试先行的方式编写模拟，以便您可以边做边测试？</p><p class="normal"><b>Seibel:</b> Do you write mocks in the test-first sense so you can test it as you go?</p>
<p class="normal"><b>菲茨帕特里克：</b>越来越多。我总是这样设计软件，甚至在测试之前也是如此。我会先设计接口和存储，然后再进行实际实现。</p><p class="normal"><b>Fitzpatrick:</b> More and more. I always designed software this way, even before testing. I would just design interfaces and storage first, and then work up to an actual implementation later.</p>
<p class="normal"><b>Seibel：</b>设计会采用什么形式？伪代码？实际代码？白板涂鸦？</p><p class="normal"><b>Seibel:</b> What form would the design take? Pseudocode? Actual code? Whiteboard scribbles?</p>
<p class="normal"><b>Fitzpatrick：</b>通常我会调出一个编辑器，然后只用伪代码为模式写注释。一切顺利之后，我会构建一个真实的模式，然后将其复制粘贴进去，以确保“创建表”有效。一旦我完成了这一切，我就会真正去实施它。我总是先从 spec.txt 开始。</p><p class="normal"><b>Fitzpatrick:</b> Generally I would bring up an editor and just write notes with pseudocode for the schema. After it got good, I would make up a real schema and then I would copy-paste it in just to make sure that “create table” works. Once I got that all going, I'd actually go implement it. I always start with a spec.txt first.</p>
<p class="normal"><b>Seibel：</b>在你写了一堆代码之后，你有没有发现你真的需要重新考虑你原来的计划？</p><p class="normal"><b>Seibel:</b> After you write a bunch of code do you ever discover that you really need to reconsider your original plan?</p>
<p class="normal"><b>菲茨帕特里克：</b>有时。但我从困难的部分或我不确定的部分开始，并尝试首先实现这些部分。我尽量不把任何困难或令人惊讶的事情拖到最后；我喜欢先做困难的事情。我从未完成的项目——我的朋友告诉我这是一大堆——因为我做了最困难的部分，我学到了我想学的东西，而且我从来没有抽出时间去做那些无聊的事情。</p><p class="normal"><b>Fitzpatrick:</b> Sometimes. But I've started with the hard bits or the parts I was unsure of, and tried to implement those parts first. I try not to put off anything hard or surprising to the end; I enjoy doing the hard things first. The projects that I never finish—my friends give me shit that it's a whole bunch—it's because I did the hard part and I learned what I wanted to learn and I never got around to doing the boring stuff.</p>
<p class="normal"><b>Seibel：</b>您对自学成才的程序员有什么建议吗？</p><p class="normal"><b>Seibel:</b> Do you have any advice for self-taught programmers?</p>
<p class="normal"><b>菲茨帕特里克：</b>总是尝试做一些更难的事情，那是你力所能及的。阅读代码。我听了很多，但直到后来才真正理解。有很多年，我写了很多代码，却从未读过别人的代码。然后我上网，发现所有这些都是开源的<a id="OEBPS/Chapter02.html.page_70"></a>我可以贡献代码，但我只是害怕如果不是我的代码并且整个设计不在我的脑海中，我就无法深入理解它。</p><p class="normal"><b>Fitzpatrick:</b> Always try to do something a little harder, that's outside your reach. Read code. I heard this a lot, but it didn't really sink in until later. There were a number of years when I wrote a lot of code and never read anyone else's. Then I get on the Internet and there's all this open source <a></a>code I could contribute to but I was just scared shitless that if it wasn't my code and the whole design wasn't in my head, that I couldn't dive in and understand it.</p>
<p class="normal">然后我将补丁发送到 Gaim，即 GTK 即时通讯工具，我正在研究该代码，我只看到了整个设计。只是看到它的一部分，我明白了。看了别人的代码我才明白，并不是我把自己的代码全都背下来了，而是自己背了。我开始看到模式。我会看到他们的代码，然后我想，“哦，好吧。我了解他们要采用的结构。”</p><p class="normal">Then I was sending in patches to Gaim, the GTK instant-messenger thing, and I was digging around that code and I just saw the whole design. Just seeing parts of it, I understood. I realized, after looking at other people's code, that it wasn't that I memorized all my own code; I was starting to see patterns. I would see their code and I was like, “Oh, OK. I understand the structure that they're going with.”</p>
<p class="normal">然后我真的很喜欢阅读代码，因为每当我不理解某些模式时，我就会想，“等等，他们他妈的为什么要这样做？” 我会更多地环顾四周，我会说，“哇，这真是一个聪明的方法。我知道这是如何得到回报的。” 我本来会早点这样做，但我不敢这样做，因为我在想如果不是我的代码，我就不会理解它。</p><p class="normal">Then I really enjoyed reading code, because whenever I didn't understand some pattern, I was like, “Wait, why the fuck did they do it like this?” and I would look around more, and I'd be like, “Wow, that is a really clever way to do this. I see how that pays off.” I would've done that earlier but I was afraid to do it because I was thinking that if it wasn't my code, I wouldn't understand it.</p>
<p class="normal"><b>Seibel：</b>你是如何解决阅读他人代码的问题的？对于初学者，您阅读代码只是为了了解它的整体工作原理，还是总是想做一些更改？</p><p class="normal"><b>Seibel:</b> And how do you tackle reading other people's code? For starters, do you read code just to see how it works overall, or do you always go in with some change you want to make?</p>
<p class="normal"><b>Fitzpatrick：</b>一般来说，我想改变一些东西。或者，如果您真的很尊重某个程序员，请去阅读他们的一些代码。也许这会让你意识到他们是凡人，而不是你真正应该崇拜的人。或者你了解了他们的代码。</p><p class="normal"><b>Fitzpatrick:</b> Generally I wanted to change something. Or if you really respect some programmer, go read some of their code. Maybe that'll make you realize that they're mortal and they're not really someone you should be idolizing. Or you learn something about their code.</p>
<p class="normal"><b>Seibel：</b>假设你有一个想要做出的改变；你是怎么解决的？</p><p class="normal"><b>Seibel:</b> So say you've got a change you want to make; how do you tackle it?</p>
<p class="normal"><b>Fitzpatrick：</b>第一步，获取原始 tarball 或从 svn 中查看，并尝试构建该死的东西。克服那个障碍。对于大多数人来说，这往往是最大的障碍——构建系统中的依赖关系，或者他们假设这个库已经安装。我几乎希望这些大型项目只是带有一个作为构建环境的虚拟机。</p><p class="normal"><b>Fitzpatrick:</b> First step, take a virgin tarball or check out from svn, and try to get the damn thing to build. Get over that hurdle. That tends to be the hugest hurdle for most people—dependencies in the build system or they're assuming this library is installed. I almost wish that these large projects just came with a virtual machine that was the build environment.</p>
<p class="normal"><b>Seibel：</b>你的意思是像 VMware 虚拟机？</p><p class="normal"><b>Seibel:</b> You mean like a VMware virtual machine?</p>
<p class="normal"><a id="OEBPS/Chapter02.html.page_71"></a><b>Fitzpatrick：</b>是的，所以如果你只是想很快开始破解它，这里是所有依赖项。人们的联系变得足够快。这是完全可行的。</p><p class="normal"><a></a><b>Fitzpatrick:</b> Yeah, so if you just want to get into hacking on it really quickly, here's all the dependencies. People's connections are getting quick enough. That's totally viable.</p>
<p class="normal">无论如何，一旦你有了一个干净、有效的构建，就杀掉它，然后做一个该死的改变。将标题栏更改为“Brad says, 'Hello world.'”。更改一些内容。即使一切都很丑陋，也要开始做出改变。</p><p class="normal">Anyway, once you have one clean, working build, kill it, and just make one damn change. Change the title bar to say, “Brad says, 'Hello world.'” Change something. Even if everything's ugly, just start making changes.</p>
<p class="normal">然后沿途发送补丁。我发现这是开始对话的最佳方式。如果你进入一个邮件列表并且你说，“嘿，我想添加一个功能 X”，维护者可能会说，“哦操，我太忙了。走开。我讨厌功能 X。” 但是如果你来找他们，你会说，“我想添加功能 X。我在想像附加补丁那样的东西，”这是完全错误的，但你说，“但我认为这是完全错误的。我在想正确的方法可能是做 X，”这是一些更复杂的方法，通常他们会说，“天哪，他们试过了，然后看，他们完全用错了方法。”</p><p class="normal">Then send out patches along the way. I find that's the best way to start a conversation. If you get on a mailing list and you're like, “Hey, I want to add a feature X,” the maintainer is probably going to be like, “Oh fuck, I'm so busy. Go away. I hate feature X.” But if you come to them and you're like, “I want to add feature X. I was thinking something like the attached patch,” which is totally wrong but you say, “But I think it's totally wrong. I'm thinking the right way might be to do X,” which is some more complex way, generally they'll be like, “Holy crap, they tried, and look, they totally did it the wrong way.”</p>
<p class="normal">也许这让维护者很痛苦。他们就像，“哦，伙计，我不敢相信他们为了做到这一点付出了所有努力。以正确的方式做到这一点非常容易。” 或者，“哦，哇，他们在错误的方向上做了所有这些工作。我希望他们不要再朝那个方向发展了。” 然后他们回复。</p><p class="normal">Maybe that pains the maintainer. They're like, “Oh man, I can't believe they went through all that effort to do it. It's so easy to do it the right way.” Or, “Oh, wow, they did all this work in the wrong direction. I hope they don't go in that direction any more.” And then they reply.</p>
<p class="normal">这始终是开始对话的最佳方式。即使在谷歌，这也是我与一个我不认识的团队开始很多对话的方式。当我修复他们产品中的错误时，我做的第一件事就是通过邮件向他们发送补丁，然后说，“你们觉得这个怎么样？” 或者在内部代码审查工具上，我会说，“这是审查。你觉得怎么样？” 他们只能说，“他妈的不，这完全是错误的解决方法。”</p><p class="normal">That's always the best way to start a conversation. Even at Google, that's the way I start a lot of conversations to a team I don't know. When I fix a bug in their product the first thing I do is send them a patch in the mail and just say, “What do you guys think of this?” Or on the internal code-review tool I'd be like, “Here is a review. What do you think?” They could just say, “Fuck no, that's totally the wrong fix.”</p>
<p class="normal"><b>Seibel：</b>您是否仍然为了乐趣而阅读代码，而不是因为需要使用代码而阅读代码？</p><p class="normal"><b>Seibel:</b> Do you still read code for fun, as opposed to reading it because you need to work with it?</p>
<p class="normal"><b>菲茨帕特里克：</b>有时。我无缘无故地检查了 Android 源代码。与 Chrome 相同；当它开源时，我镜像了回购并环顾四周。我对 Firefox 和 Open Office 做了同样的事情。一些你一直在使用的程序，突然之间你可以访问，你不妨看看。</p><p class="normal"><b>Fitzpatrick:</b> Sometimes. I checked out Android source code for no real reason. The same with Chrome; when it went open source, I mirrored the repo and just looked around. I did the same thing with Firefox and Open Office. Some program you've been using and all of a sudden you have access and you might as well look.</p>
<p class="normal"><a id="OEBPS/Chapter02.html.page_72"></a><b>Seibel：</b>像这样的程序，代码库非常庞大。当你为了好玩而看这样的东西时，你对它的了解有多深？</p><p class="normal"><a></a><b>Seibel:</b> Programs like that, the code base is pretty huge. When you look at something like that for fun, how deeply do you get into it?</p>
<p class="normal"><b>Fitzpatrick：</b>一般来说，我会通过管道找到 less 并尝试了解目录结构。然后要么有东西抓住了我的眼睛，要么我不明白什么是东西。所以我选择了一个随机文件并感受一下。然后我蹦蹦跳跳，漫无目的地闲逛，直到我感到无聊，然后随机选择一个新的地点跳进去。</p><p class="normal"><b>Fitzpatrick:</b> Generally, I'll just pipe find into less and try to understand the directory structure. Then either something grabs my eye or I don't understand what something is. So I pick a random file and get a feel for it. Then I bounce around and wander aimlessly until I'm bored and then pick a new random spot to jump in.</p>
<p class="normal">很多时候，我会在阅读它的同时构建它，因为它们是非常可并行化的任务，尤其是在难以构建的情况下。当它最终建成时，如果我愿意，我可以开始调整它。</p><p class="normal">A lot of times, I'll work on building it in parallel with reading it because they're very parallelizable tasks, especially if it's hard to build. By the time it's finally built, then I can start tweaking it if I want to.</p>
<p class="normal"><b>Seibel：</b>因此，当您阅读好的代码时，它要么适合您已经理解的模式，要么您会发现新的模式。但并非所有代码都是好的。错误代码的第一个警告信号是什么？</p><p class="normal"><b>Seibel:</b> So when you read good code it either fits into patterns that you already understand, or you'd discover new patterns. But not all code is good. What are the first warning signs of bad code?</p>
<p class="normal"><b>Fitzpatrick：</b>嗯，我现在特别傲慢，因为在 Google 工作时所有语言都有非常严格的风格指南。在我们的前六七种语言中，有一个非常严格的风格指南说，“这就是我们如何布局我们的代码。这就是我们命名变量的方式。这就是我们处理间距和缩进的方式，以及您使用的这些模式和约定，这就是您声明静态字段的方式。”</p><p class="normal"><b>Fitzpatrick:</b> Well, I'm particularly snooty now, having worked at Google with really strict style guidelines in all languages. On our top six or seven languages, there's a really strict style guide that says, “This is how we lay out our code. This is how we name variables. This is how we do spacing and indentation, and these patterns and conventions you use, and this is how you declare a static field.”</p>
<p class="normal">我们也开始将这些放在网上，作为外部贡献者为我们的项目做出贡献的参考。我们希望有一个记录在案的政策，这样我们就不会只是说，“我们不喜欢你的风格。”</p><p class="normal">We've started putting these online too, just as a reference for external contributors contributing to our projects. We wanted to have a documented policy so we don't just say, “We don't like your style.”</p>
<p class="normal">现在，当我在 C 语言项目上工作时，我做的第一件事就是添加一个风格指南。一旦一个项目成熟并且有很多人参与其中，他们就会有一个风格指南。它甚至不总是被编写，但程序员只是尊重已经编写的代码风格。也许他们不喜欢大括号样式，但他妈的，在一个文件中，在一个项目中保持一致比按照你喜欢的方式来做更重要。</p><p class="normal">Now when I work on projects in C, the first thing I do is add a style guide. Once a project is mature and has a lot of people hacking on it, they'll have a style guide. It's not even always written, but the programmers just respect the style of code written already. Maybe they don't like the brace style, but fuck it, it's more important to have it consistent within a file, within a project, than to do it your favorite way.</p>
<p class="normal"><b>Seibel：</b>你做过结对编程吗？</p><p class="normal"><b>Seibel:</b> Do you ever do any pair programming?</p>
<p class="normal"><a id="OEBPS/Chapter02.html.page_73"></a><b>菲茨帕特里克：</b>我觉得这很有趣。这对很多事情都有好处。有时您只需要思考并想一个人呆着。我不是一直订阅它，但它绝对很有趣。</p><p class="normal"><a></a><b>Fitzpatrick:</b> I think it's pretty fun. It's good for lots of things. Sometimes you just need to think and want to be left alone. I don't subscribe to it all the time, but it's definitely fun.</p>
<p class="normal">我开始了太多的项目。我完成它们是因为如果我没有完成它们我会感到内疚，但我绝对经常切换上下文并且我分散得太少了。这就是为什么我真的需要结对编程——它迫使我坐下来整整三个小时，甚至整整两小时或整整一个小时，并与其他人一起做一件事，他们迫使我不要感到无聊。如果我打了一个无聊的补丁，他们就像，“来吧。我们必须这样做，”然后我们就完成了。</p><p class="normal">I start too many projects. I finish them because I have guilt if I don't finish them, but I definitely context-switch way too often and I'm spread too thin. This is why I really need pair programming—it forces me to sit down for three solid hours, or even two or one solid hour, and work on one thing with somebody else, and they force me to not be bored. If I hit a bored patch, they're like, “Come on. We've got to do it,” and we finish.</p>
<p class="normal">我喜欢一个人工作，但当我这样做时，我会到处蹦蹦跳跳。在飞机上，我会带上额外的笔记本电脑电池，并且我有一个带有本地网络服务器的完整开发环境，我会在网络浏览器中测试东西。但我仍然会点击新标签，并输入“reddit”或“lwn”——我阅读的网站。自动完成并按 Enter，然后——错误信息。我会在一分钟内多次执行此操作。他妈的！我在工作中这样做吗？我是否经常阅读网站，以至于我什至都没有想过它？好吓人。我有一个朋友，他有一些 iptables 规则，在一天中的某些时间连接到某些 IP 地址时，会重定向到“你应该工作”的页面。我还没有抽出时间去做那件事，但我可能需要做类似的事情。</p><p class="normal">I like working alone but I just bounce all over the place when I do. On a plane I'll bring extra laptop batteries and I have a whole development environment with local web servers and I'll be in a web browser, testing stuff. But I'll still be hitting new tabs, and typing “reddit” or “lwn”—sites I read. Autocomplete and hit Enter, and then—error message. I'll do this multiple times within a minute. Holy fuck! Do I do this at work? Am I reading web sites this often that I don't even think about it? It's scary. I had a friend, who had some iptables rule, that on connection to certain IP addresses between certain hours of the day would redirect to a “You should be working,” page. I haven't got around to doing that, but I need to do something like it, probably.</p>
<p class="normal"><b>Seibel：</b>关于代码所有权呢？人们单独拥有代码重要还是团队共享所有权更好？</p><p class="normal"><b>Seibel:</b> What about code ownership? Is it important for people to own code individually or is it better for a team to share ownership?</p>
<p class="normal"><b>Fitzpatrick：</b>我认为不应该拥有代码。我认为没有人真的这么认为。它在谷歌内部的工作方式是，它是一棵巨大的源代码树，一个根，一个统一的构建系统。所以任何人都可以去改变任何东西。但是有代码审查，目录有所有者，总是至少有两个人，以防万一有人辞职或休假。</p><p class="normal"><b>Fitzpatrick:</b> I don't think code should be owned. I don't think anyone really thinks that. The way it works within Google is that it's one massive source tree, one root, and one unified build system across all of it. And so anyone can go and change anything. But there are code reviews, and directories have owners, always at least two people, just in case someone quits or is on vacation.</p>
<p class="normal">要签到，您需要满足三个条件：您需要有人对其进行审查并说它看起来不错。您需要通过该语言的认证——基本上您已经证明您了解这种语言的风格——称为“可读性”。然后您还需要该目录中所有者文件中的某人的上述批准。因此，如果您已经是该目录的所有者并且您具有该语言的可读性，那么您只需要有人<a id="OEBPS/Chapter02.html.page_74"></a>说，“是的，它看起来不错。” 这是一个非常好的系统，因为通常至少有两个，最多二十个，三十个所有者。一旦您在代码库上工作了一段时间，就会有人将您添加到所有者中。我认为这是一个很棒的系统。</p><p class="normal">To check in you need three conditions met: You need someone to review it and say it looks good. You need to be certified in the language—basically you've proven you know the style of this language—called “readability.” And then you also need the approval above from somebody in the owner's file in that directory. So in the case that you already are an owner of that directory and you have readability in that language, you just need someone <a></a>to say, “Yeah, it looks good.” And it's a pretty good system, because there tends to be a minimum of two, up to twenty, thirty owners. Once you work on a code base for a while, someone just adds you to owners. I think it's a great system.</p>
<p class="normal"><b>Seibel：</b>那么让我们回到过去——LiveJournal 是如何开始的？</p><p class="normal"><b>Seibel:</b> So let's go back in time a bit—how did LiveJournal start?</p>
<p class="normal"><b>菲茨帕特里克：</b>就是和我的朋友们一起玩——我想要的和我们认为会很有趣的东西。在 LiveJournal 上发表评论是一个恶作剧。在我上课之前，我正在查看我的 LiveJournal。我们刚刚推出了朋友页面，我看到我朋友写的东西，真的很愚蠢，我想取笑他。“哦，但我不能回答。” 所以我去上课，整个课堂上我都在想，“我怎样才能添加回复系统？” 我在考虑现有的模式以及我们如何呈现它。我在课间有两个小时的休息时间，所以我添加了评论，然后回复了一些自作聪明和讽刺的话，然后去了我的另一堂课。当我从第二节课回来时，他说，“他妈的什么？我们现在可以评论了吗？”</p><p class="normal"><b>Fitzpatrick:</b> It was just fucking around with my friends—what I wanted and what we thought would be funny. Commenting on LiveJournal was a practical joke. I was checking my LiveJournal right before I ran into class. We had just introduced friend pages and I saw something my friend wrote and it was really stupid and I wanted to make fun of him. “Oh, but I can't reply.” So I went to class and all throughout class I was thinking, “How can I add a reply system?” I was thinking of the existing schema and how we could render it. I had a two-hour break between classes, so I add commenting and I reply something smartass and sarcastic and go to my other class. When I came back from my second class, he's like, “What the fuck? We can comment now?”</p>
<p class="normal">LiveJournal 上的一切几乎都是个笑话。整个安全问题，比如仅限朋友的帖子和私人帖子，是因为一位朋友写道他去参加一个聚会，第二天在沟里喝醉了。他的父母读了之后说：“什么？你在喝酒吗？他就像，“布拉德，我们需要一种方法来锁定这狗屎！” 我当时想，“在上面！” 我们已经有朋友了，所以我们只是做了一些帖子只是朋友，然后是你的父母——只是不要和他们成为朋友。</p><p class="normal">Everything on LiveJournal was pretty much a joke. The whole security thing, like friends-only posts and private posts, was because a friend wrote that he went to a party and woke up drunk in a ditch the next day. His parents read it and were like, “What? You're drinking?” He was like, “Brad, we need a way to lock this shit down!” I was like, “On it!” We already had friends, so we just made it so some posts are friends only and then your parents—just don't be friends with them.</p>
<p class="normal"><b>Seibel：</b>在 LiveJournal 的早期，你的生活似乎就是一连串没完没了的熬夜、晚睡和长时间工作。其中有多少是编程的必要部分？</p><p class="normal"><b>Seibel:</b> In the early days of LiveJournal it seems your life was an endless series of late nights, sleeping late, and overall working long hours. How much of that is a necessary part of programming?</p>
<p class="normal"><b>Fitzpatrick：</b>我只是觉得那是压力最小的时候。白天，总会有事情发生，比如另一顿饭要来了，或者要上课，或者你可能会接到一个电话。总有一些中断。我不能放松。如果我在开会前两个小时开始工作，那两个小时的效率比我那天没有开会或者开会是早上的第一件事要低。知道我没有什么事可以打扰我，我轻松多了。</p><p class="normal"><b>Fitzpatrick:</b> I just thought it was the least stressful time. During the day, there's always something coming up, like another meal is coming up, or a class, or maybe you get a phone call. There's always some interruption. I can't relax. If I go into work two hours before some meeting, that two hours is less productive than if I didn't have that meeting that day or if the meeting was the first thing in the morning. Knowing that I have nothing coming up to bug me, I'm so much more relaxed.</p>
<p class="normal"><a id="OEBPS/Chapter02.html.page_75"></a>晚上，我觉得这是我的时间，这次我在偷东西，因为其他人都在睡觉。没有噪音，没有打扰，我可以做任何事。我有时仍然熬夜。我这个周末做了；我在不同的事情上工作了很多。但这让我好几天都睡不着觉。我在大学时主要是这样做的，因为我有一些项目，而且我也在做 LiveJournal。唯一的时间是在晚上，而且我们所有的服务器维护都必须在晚上进行。然后在夏天，为什么不呢？没有理由一大早就起床去上课或做任何事情，所以不妨在晚上工作。</p><p class="normal"><a></a>At night I feel like this is my time and I'm stealing this time because everyone else is sleeping. There's no noise and no interruptions, and I can do whatever. I still stay up late sometimes. I did it this weekend; I was up quite a bit working on different things. But that screws me up for days sleepwise. I did that mostly when I had to in college, because I had some project, and I was also doing LiveJournal on the side. The only time to do it was at night and also all our server maintenance had to be at night. And then in the summer, just because why not? There's no reason to wake up early in the morning to go to a class or anything, so might as well work at night.</p>
<p class="normal"><b>Seibel：</b>长度和强度如何？我确定您已经完成了 80、100、120 小时的工作周。那有必要吗？在什么情况下这才是真正必要的，什么时候这只是我们做的一件有男子气概的事情？</p><p class="normal"><b>Seibel:</b> What about the length and intensity? I'm sure you've done the 80-, 100-, 120-hour weeks. Is that necessary? Under what circumstances is that really necessary and when is it just a macho thing that we do?</p>
<p class="normal"><b>Fitzpatrick：</b>就我而言，我不确定这是必要的还是男子气概的事情。我很开心，这就是我想做的事情。有时事情会发生故障，但即使它们没有发生故障，我仍然这样做只是因为我正在开发一个我真正希望看到的新功能。</p><p class="normal"><b>Fitzpatrick:</b> In my case, I'm not sure it was either necessary or a macho thing. I was having fun and it was what I wanted to be doing. Sometimes things were breaking, but even when they weren't breaking, I was still doing it just because I was working on a new feature that I really wanted to see happen.</p>
<p class="normal"><b>Seibel：</b>你有没有遇到过你真的需要估计事情需要多长时间的情况？</p><p class="normal"><b>Seibel:</b> Have you ever been in a situation where you really had to estimate how long things were going to take?</p>
<p class="normal"><b>菲茨帕特里克：</b>有一次我到了六人组。我想那是我三年半前的第一次经历。我们已经开始进行迁移——我们有一个客户，他们会说，“你能移动这些数据吗？” 这需要添加对此代码和测试的支持，并将其推出。我做得很糟糕。我可能在这方面仍然很糟糕，因为我总是忘记一个因素，比如不得不处理中断的废话乘数，以及我永远不会摆脱维护一打项目的事实。</p><p class="normal"><b>Fitzpatrick:</b> Once I got to Six Apart. I guess that was my first experience, three and a half years ago. We had started doing migration—we'd have a customer and they'd say, “Can you move this data?” That requires adding this support for this code and testing, and pushing it out. I was terrible at it. I probably still am terrible at it, because I always forget a factor, like the bullshit multiplier of having to deal with interruptions and the fact that I'm never going to get away from maintaining a dozen projects on the side.</p>
<p class="normal">我认为我正在好转，但幸运的是他们并没有经常这样要求。现在，当我确实为某件事设定了最后期限时，我会说，“耶！限期！” 我非常兴奋，肾上腺素开始分泌，我开始工作，完成了这该死的事情。谷歌没有什么是真正的最后期限。谷歌就像是，“你觉得推出这个怎么样？感觉如何？” 很少有真正的截止日期。他们中的大多数，我们认为这会很好</p><p class="normal">I think I'm getting better, but fortunately they don't ask for that too often. And now when I actually do get a deadline for something, I'm like, “Yay! A deadline!” and I get so excited that the adrenaline kicks in, and I work, and I finish the damn thing. Nothing with Google is really a deadline. With Google it's like, “What do you think about launching this? How does that feel?” It's rare that there's some real deadline. Most of them, we think it'd be nice to</p>
<p class="normal"><a id="OEBPS/Chapter02.html.page_76"></a>在这个日期发布，所以每个人都非常努力。但是，如果您没有完成某些事情，您只会让其他希望在那天看到它发布的人失望。我所做的大部分事情都是“当它完成时，它就完成了”。</p><p class="normal"><a></a>launch on this date and so everyone tries really hard. But you're only letting down other people that want to see it launch by that day if you don't finish something. And most of the things I work on are very “When it's done, it's done.”</p>
<p class="normal"><b>Seibel：</b>当你在 LiveJournal 招聘程序员时，你管理他们吗？</p><p class="normal"><b>Seibel:</b> When you were hiring programmers at LiveJournal, did you manage them?</p>
<p class="normal"><b>Fitzpatrick：</b>嗯，我假设他们都不需要管理；他们都会像我一样自我驱动。这是人力资源方面的一次学习经历，有些人只是按照他们的指示去做，并没有真正追求卓越的热情。他们就像，“完成了。下一个作业，”或者他们不告诉你，只是浏览网页。所以我有一些痛苦的经历。但我认为在一两年后，我了解到人是不同的。</p><p class="normal"><b>Fitzpatrick:</b> Well, I kind of assumed that none of them would need managing; that they would just all be self-driven like me. That was a learning experience in HR, that some people just do what they're told and don't really have a passion for excellence. They're just like, “Done. Next assignment,” Or they don't tell you and just browse the Web. So I had a couple of painful experiences. But I think after a year or two of that, I learned that people are different.</p>
<p class="normal">有些是纯粹主义者。他们只会在抽象上抽象。他们会走得非常慢，并且对自己的风格非常虔诚。他们就像，“我是一个工匠程序员。” 我当时想，“你的代码没有运行。它效率不高，而且看起来不像您正在与之交互的任何其他代码。”</p><p class="normal">Some are purists. They would just do abstraction on abstraction on abstractions. They would go really slowly and are very religious about their style. They're like, “I'm an artisan programmer.” And I was like, “Your code doesn't run. It's not efficient and it doesn't look like any of the other code that you're interacting with.”</p>
<p class="normal"><b>Seibel：</b>你想出如何善用这样的人了吗？</p><p class="normal"><b>Seibel:</b> Did you figure out how to make good use of people like that?</p>
<p class="normal"><b>Fitzpatrick：</b>一个人，我尝试了几十种不同的东西。我想他可能比我大十岁。我不知道多少，因为我从来没有问过——我害怕法律招聘问题。但我觉得他不想为一些年轻的朋克工作。我大概 22 岁。那个最终没有成功。那是我唯一放手的人。</p><p class="normal"><b>Fitzpatrick:</b> One person, I tried dozens of different things. I think he might've been ten years older than me. I don't know how much, because I never ask that—I was afraid of legal hiring questions. But I got the feeling that he didn't want to work for some young punk. I was like 22. That one eventually didn't work out. That was the only person I let go.</p>
<p class="normal">其他人我最终弄清楚是什么激励了他们。一个人真的很擅长修补和让原型工作。他编写了 sysadmin Perl。他可以将东西组合在一起，编写 shell 脚本，并编写非常糟糕的 Perl 和非常糟糕的 C，但有点让它工作。然后我们会说，“天哪，你研究了所有这些东西，你让所有这些组件相互通信？”</p><p class="normal">Other people I eventually figured out what motivated them. One guy was really good at tinkering and getting a prototype working. He wrote sysadmin Perl. He could wire stuff together, write shell scripts, and write really bad Perl and really bad C, but kind of get it working. Then we would be like, “Holy crap, you researched all this stuff, you got all these components talking to each other?”</p>
<p class="normal">我们正在建立一个到 LiveJournal 的语音桥，这样你就可以录制一些东西并将其发布到 LiveJournal。涉及的活动部件太多了。我<a id="OEBPS/Chapter02.html.page_77"></a>以为那是地狱般的痛苦。他喜欢它。他把这一切都弄清楚了，并让它发挥作用。然后我们就全部重写了。我们发现这就是它与他合作的方式。他弄清楚了界面，我们会把它全部修好。一旦我弄清楚那是他的角色，我们就相处得很好。</p><p class="normal">We were setting up a voice bridge to LiveJournal so you record something and post it to LiveJournal. There were just so many moving parts involved. I <a></a>thought it was painful as hell. He loved it. He figured it all out and got it working. Then we just rewrote it all. And we figured out that was the way it worked with him. He figured out the interface and we would fix it all up. Once I figured out that was his role, we got along great.</p>
<p class="normal"><b>Seibel：</b>所以你为自己的公司招聘过人才，我想你也参与过 Google 的招聘工作。你如何识别一个伟大的程序员？</p><p class="normal"><b>Seibel:</b> So you've hired for your own company, and I assume you've been involved in hiring at Google. How do you recognize a great programmer?</p>
<p class="normal"><b>Fitzpatrick：</b>我经常寻找那些自己完成了很多没有要求他们做的事情的人。不仅仅是他们的学校项目，也不仅仅是他们以前的雇主让他们做的事情。对某事充满热情并有一些副业的人。他们是如何维护它的，他们对它的重视程度如何？还是他们做了很多快速的黑客攻击然后放弃了？</p><p class="normal"><b>Fitzpatrick:</b> I often look for people that have done, like, a lot of stuff on their own that wasn't asked of them. Not just their school project or just what their previous employer had them do. Somebody who was passionate about something and had some side project. How did they maintain it and how serious did they get with it? Or do they do a lot of quick hacks and abandon them?</p>
<p class="normal"><b>Seibel：</b>你有最喜欢的面试问题吗？</p><p class="normal"><b>Seibel:</b> Do you have favorite interview questions?</p>
<p class="normal"><b>Fitzpatrick：</b>其中一个我已经给出过几次，因为它是在我的 AP 编程测试中，它给出了两个十进制数作为任意长度的字符串，将它们相乘。他们有很多不同的方法可以做到这一点。如果他们真的很擅长数学——就像我不擅长——他们可以找到一些聪明的方法来真正有效地做到这一点。最坏的情况是，他们可以创建一个重复只做加法的类。</p><p class="normal"><b>Fitzpatrick:</b> One of the ones I've given a few times because it was on my AP programming test is given two decimal numbers as strings of arbitrary length, multiply them. There are a lot of different ways that they could do it. If they're really good at math—like I'm not—they can find some clever ways to do it really efficiently. Worst case, they can make a class that does just addition repeatedly.</p>
<p class="normal">我从一开始就告诉他们，“不要紧张。您不必高效地执行此操作。只是以某种方式完成它。有些人压力很大，不知道从哪里开始。这是一个不好的迹象。最坏的情况是，您只需实施您在小学时使用的算法。</p><p class="normal">I tell them from the beginning, “Don't stress out. You don't have to do it efficiently. Just get it done somehow.” Some people stress out and have no clue where to begin. That's kind of a bad sign. The worst case, you just implement the algorithm you do in grade school.</p>
<p class="normal">我实际上在小学写了一个程序来做我的长除法和乘法并展示工作。包括所有步骤和划掉的地方。然后我们会遇到这些问题，比如每页十个之类的，我会把它输入电脑，然后在涂鸦中重现这些问题。我在化学中做了同样的事情来找到电子的轨道。但我发现，通过编写程序来作弊，你会学到东西，因为你必须真正深入地学习才能编写该程序。</p><p class="normal">I actually wrote a program in grade school to do my long division and multiplication and show the work. Including all the steps and where to cross out. So then we would get these problems, like ten per page or something, and I would type it into the computer and then just reproduce the problems in scribbles. I did the same thing in chemistry to find the orbitals of electrons. But the thing I find is by writing a program to cheat, you learn because you have to learn it really in depth to write that program.</p>
<p class="normal"><b>Seibel：</b>你认为这对任何人都有效吗？与其教孩子长除法，我们应该教他们如何编程，然后说，“好吧，<a id="OEBPS/Chapter02.html.page_78"></a>现在你的任务是编写一个程序来执行这个长除法程序”？到他们真正编写该程序时，他们就会理解除法。还是只有当你有某种自然倾向时才有效？</p><p class="normal"><b>Seibel:</b> Do you think that would work for anyone? Instead of teaching kids long division, should we teach them how to program and then say, “OK, <a></a>now your task is to write a program to do this long-division procedure”? By the time they've actually written that program, they'll understand division. Or does that only work if you have some natural inclination that way?</p>
<p class="normal"><b>菲茨帕特里克：</b>它对我有用。很多时候，有人可以教你一些东西，你会说，“是的，是的，当然。我明白。” 你自欺欺人，但一旦你真的不得不下定决心，在真正的水平上去做，并理解所有的极端情况，它就会迫使你真正去学习这件事。但我不知道这是否适用于所有人。</p><p class="normal"><b>Fitzpatrick:</b> It worked for me. A lot of times, someone could teach you something and you're like, “Yeah, yeah, sure. I understand.” You delude yourself but once you actually have to get down and do it at a real level and understand all the corner cases, it forces you to actually learn the thing. But I don't know if that would work for everyone.</p>
<p class="normal"><b>Seibel：</b>谷歌在面试官使用拼图问题方面享有盛誉，微软也是如此。</p><p class="normal"><b>Seibel:</b> Google has a bit of a reputation, as Microsoft also does, of interviewers using puzzle questions.</p>
<p class="normal"><b>Fitzpatrick：</b>我认为这些是被禁止的。或者强烈劝阻。也许有些人仍然这样做，但我认为，总的来说，他们是气馁的。</p><p class="normal"><b>Fitzpatrick:</b> I think those are kind of banned. Or strongly discouraged. Maybe some people still do them, but I think, in general, they're discouraged.</p>
<p class="normal"><b>Seibel：</b>他们在采访中问了你什么？</p><p class="normal"><b>Seibel:</b> What did they ask you in your interview?</p>
<p class="normal"><b>Fitzpatrick：</b>一个问题是，想象一下你有一堆计算机在一个开关上，它们打开了整个机架；想出一个算法，这样机架上的每台机器都知道所有其他机器的状态，比如它们是开着还是关着。所以基本上是存在的东西。这几乎是限制条件。基本上，他们描述了以太网：你可以向所有人发送广播，或者你可以将它发送到特定的 MAC 地址。因此，我只是介绍了所有不同的策略，以最小化带宽并最大程度地减少在某些东西死机时发现的延迟。那很有趣。</p><p class="normal"><b>Fitzpatrick:</b> One question was, imagine you have a bunch of computers on a switch and they turn on the whole rack; come up with an algorithm so every machine on the rack knows the status of all the other ones about whether they're on or off. So basically a presence thing. That was pretty much the constraint. Basically, they described Ethernet: you could send a broadcast to everyone, or you could send it to a specific MAC address. So I just kind of walked through all the different strategies to minimize bandwidth and to minimize latency discovering when something's dead. That was a fun one.</p>
<p class="normal"><b>Seibel：</b>您曾经不得不追踪的最严重的错误是什么？</p><p class="normal"><b>Seibel:</b> What's the worst bug you ever had to track down?</p>
<p class="normal"><b>Fitzpatrick：</b>我尽量不去记住他们。我讨厌它是你的假设太远的地方。前几天——这绝对不是有史以来最糟糕的例子——我花了 90 分钟调试一些东西，因为我正在写入一个输出文件并读取另一个名称相同但缺少一个路径组件的文件。我不断地重新运行这个巨大的 MapReduce 并查看输出并将其放入 GDB 并逐步执行它。“什么鬼？没有变化！” 最后我看了看路径<a id="OEBPS/Chapter02.html.page_79"></a>我当时想，“天哪。” 我不知道为什么我花了 90 分钟在上面；我看得入迷，没有回头看看，我的命令行是不是正确的？</p><p class="normal"><b>Fitzpatrick:</b> I try not to remember them. I hate it when it's something where your assumptions are so far off. The other day—this is definitely not an example of the worst one ever—I spent 90 minutes debugging something because I was writing to one output file and reading another file named the same thing but with one path component missing. I kept rerunning this huge MapReduce and seeing the output and putting it in GDB and stepping through it. “What the fuck? It's not changing!” Finally I looked at the paths <a></a>and I was like, “Holy crap.” I don't know why I spent 90 minutes on it; I was so obsessed that I didn't step back and check, is my command line correct?</p>
<p class="normal">有很多这样的。我们总是有一些 Perl 的好东西，比如 $_ 没有词法作用域。因此，如果你在某种程度上操弄 $_，你可能会惹恼远处的其他人。所以我们遇到了这个让我们永远无法忍受的错误，并且我们进行了大量的腐败工作。我们终于明白了。然后我审核了我们所有的代码，我们有一个新政策“永远不要这样做”。</p><p class="normal">There's a lot of that. We always had some good stuff with Perl like the $_ isn't lexically scoped. So if you fuck with $_ in a sort, you can mess with somebody else's far away. So we had this bug that took us forever and we had a bunch of corruption going on. We finally figured that out. Then I audited all our code we had a new policy of “never do this.”</p>
<p class="normal"><b>Seibel：</b>你们的调试工具是什么？调试器？印刷品？还有别的吗？</p><p class="normal"><b>Seibel:</b> What are your debugging tools? Debuggers? Printlns? Something else?</p>
<p class="normal"><b>Fitzpatrick：</b>如果我处于可以执行此操作的环境中，则 Println。调试器，如果我处于具有良好调试器的环境中。GDB 在谷歌得到了很好的维护，当你需要它时它是不可替代的。我尽量不经常需要它。我不是很擅长，但我可以环顾四周，大致弄清楚事情的来龙去脉。如果我必须进去，我一般都能找到出路。我爱斯特拉斯。Strace，我觉得没有它我活不下去。如果我不知道某个程序在做什么，或者我的程序在做什么，我会在 strace 下运行它，看看到底发生了什么。如果我只能拥有一个工具，那可能就是那个。所有 Valgrind 工具、Callgrind 等等都很好。</p><p class="normal"><b>Fitzpatrick:</b> Println if I'm in an environment where I can do that. Debugger, if I'm in an environment that has good debuggers. GDB is really well maintained at Google and is kind of irreplaceable when you need it. I try not to need it too often. I'm not that great at it, but I can look around and kind of figure things out generally. If I have to go in there, I generally can find my way out. I love strace. Strace, I don't think I could live without. If I don't know what some program is doing, or what my program is doing, I run it under strace and see exactly what's happening. If I could only have one tool, it would probably be that. All the Valgrind tools, Callgrind and all that, those are good.</p>
<p class="normal">但最近很多次，如果发生了一些奇怪的事情，我会想，“好吧，那个函数太大了；让我们把它分解成更小的部分，并分别对每个部分进行单元测试，以找出我的假设错误的地方，而不是仅仅停留在随机的 printlns 中。”</p><p class="normal">But a lot of times lately, if there's something weird going on, I'm like, “OK, that function is too big; let's break that up into smaller parts and unit-test each one of them separately to figure out where my assumptions are wrong, rather than just sticking in random printlns.”</p>
<p class="normal">然后可能在重构的过程中，我要多思考代码，然后就变得很明显了。在那一点上，我可以回到那个大的、丑陋的状态，在那里它是一个大功能并修复它，但我已经完成了一半；我不妨继续为下一个维护者简化它。</p><p class="normal">Then maybe in the process of refactoring, I have to think about the code more, and then it becomes obvious. I could, at that point, go back to the big, ugly state where it was one big function and fix it but I'm already halfway there; I might as well continue making it simpler for the next maintainer.</p>
<p class="normal"><b>Seibel：</b>您如何在代码中使用不变量？有些人加入了特别的断言，有些人在每一步都加入了不变量，这样他们就可以证明他们程序的形式属性，中间有很大的范围。</p><p class="normal"><b>Seibel:</b> How do you use invariants in your code? Some people throw in ad hoc asserts and some people put in invariants at every step so they can prove formal properties of their programs, and there's a big range in the middle.</p>
<p class="normal"><a id="OEBPS/Chapter02.html.page_80"></a><b>菲茨帕特里克：</b>我不会一直到正式场合。我的基本规则是，如果它可能来自最终用户，则它不是运行时崩溃。但如果这是我的代码对我的代码，我会尽可能地崩溃——尽可能早地失败。</p><p class="normal"><a></a><b>Fitzpatrick:</b> I don't go all the way to formal. My basic rule is, if it could possibly come from the end user, it's not a run-time crash. But if it is my code to my code, I crash it as hard as possible—fail as early as possible.</p>
<p class="normal">我试着主要考虑先决条件，并检查构造函数中的内容和函数的开头。调试检查，如果可能的话，它会被编译掉。可能有很多思想流派，我可能没有受过关于正确的方法是什么的教育。在某些语言中，所有这些东西实际上都是语言的正式部分。几乎所有我使用的语言，都由你决定。</p><p class="normal">I try to think mostly in terms of preconditions, and checking things in the constructor and the beginning of a function. Debug checks, if possible, so it compiles away. There are probably a lot of schools of thought and I'm probably not educated about what the proper way to do it is. There are languages where all this stuff is actually a formal part of the language. Pretty much all the languages I write in, it's up to you.</p>
<p class="normal"><b>Seibel：</b>您曾经写道，优化是您最喜欢的编程部分。现在还是这样吗？</p><p class="normal"><b>Seibel:</b> You wrote once that optimization is your favorite part of programming. Is that still true?</p>
<p class="normal"><b>Fitzpatrick：</b>优化很有趣，因为它不是必需的。如果你这样做，你的事情就成功了，没有什么比这更重要了，你要么在省钱，要么这样做，因为它就像一场 Perl 高尔夫比赛——我能打多短或多快。我们会在 LiveJournal 中识别热点，然后我会发送一些比赛。“这是一些代码。这是基准。快一点。” 我发送了负载均衡器的标头解析。我们都在编写疯狂的正则表达式，这些正则表达式不会回溯，并试图用最有效的捕获组来捕获事物。我们都在竞争，变得越来越快。然后第二天来了一个人。他用 XS 用 C++ 编写了这一切，所以他说，“我赢了。”</p><p class="normal"><b>Fitzpatrick:</b> Optimization is fun because it's not necessary. If you're doing that, you've got your thing working and nothing else is more important and you're either saving money or doing it because it's like a Perl golf contest—how short can I make this or how much faster. We would identify hotspots in LiveJournal, and I would send out some contests. “Here's some code. Here's the benchmark. Make it fast.” I sent our load balancer's header parsing. We were all writing crazy regexps that didn't backtrack and tried to capture things with the most efficient capture groups. And we were all competing, getting faster and faster and faster. Then one guy comes over the next day. He had written it all in C++ with XS, and so he was like, “I win.”</p>
<p class="normal"><b>Seibel：</b>最近的另一面是……</p><p class="normal"><b>Seibel:</b> The flip side of that these days is …</p>
<p class="normal"><b>Fitzpatrick：</b>程序员的时间更有价值，还有那些废话？这可能是真的。这适用于少数机器。一旦你接触到很多机器，突然之间，程序员的时间就比要部署的机器数量更有价值了，所以现在用 C 语言编写它并对其进行概要分析，并修复编译器，并花钱请人在 GCC 上工作，以加快编译速度。</p><p class="normal"><b>Fitzpatrick:</b> Programmers' time is worth more and all that crap? Which can be true. This is true for a small number of machines. Once you get to a lot of machines, all of a sudden the programmers' time is worth less than the number of machines that this will be deployed against, so now write it in C and profile the hell out of it, and fix the compiler, and pay people to work on GCC to make this compile faster.</p>
<p class="normal"><b>Seibel：</b>但即使是 Google 也使用 C++ 而不是汇编，所以在某些时候试图挤压最大性能是不值得的。或者是一个好的 C++ 编译器生成的代码比除了最罕见的汇编编码器之外的所有代码更好的理论？</p><p class="normal"><b>Seibel:</b> But even Google uses C++ rather than assembly, so there's some point at which trying to squeeze the maximum performance isn't worth it. Or is the theory that a good C++ compiler generates better code than all but the most freakishly rare assembly coders?</p>
<p class="normal"><a id="OEBPS/Chapter02.html.page_81"></a><b>Fitzpatrick：</b>我们还有一些东西在组装，但是非常少。我们对很多东西进行了分析，并且必须真正证明将其从 Perl 重写为 C，然后从 C 重写为汇编。即使都是 x86，x86 也有各种不同的变体。您真的要为 x86 的每个变体编写汇编吗？这个使用 SSE 2，那个使用 SSE 3.1。让编译器处理它。</p><p class="normal"><a></a><b>Fitzpatrick:</b> We still have some stuff in assembly, but it's very rare. We have profiling for lots and lots of stuff and it has to really be justified to rewrite it even from Perl to C, and then from C to assembly. Even if it's all x86, there are all different variations of x86. Do you really want to write assembly for every variation of x86? This one uses SSE 2 and that one uses SSE 3.1. Let the compiler deal with it.</p>
<p class="normal"><b>Seibel：</b>您小时候根据编程手册学习编程。有没有你现在强烈推荐给新程序员或者认为每个人都应该阅读的书籍？</p><p class="normal"><b>Seibel:</b> You learned to program from programming manuals when you were a little kid. Are there any books that you strongly recommend to new programmers now or think that everyone should read?</p>
<p class="normal"><b>Fitzpatrick：</b>回到我在做 Perl 的时候——即使对于非常了解 Perl 的人——我会推荐 MJD 的<i>Higher-Order Perl</i>。这本书真的很有趣，因为它开始有点简单，你会说，“是的，是的，我知道闭包是什么。” 然后它就继续操你的脑袋。到书的结尾，您简直被震撼了。尽管我知道所有这些东西，理论上，只是看着它发挥到极致真的改变了我的想法。我把它推荐给了我的一群朋友，这让他们大吃一惊。总的来说，任何能给人们带来不同思考方式的书。这是我能想到的最近的例子。</p><p class="normal"><b>Fitzpatrick:</b> Back when I was doing Perl—even for people that knew Perl really well—I would recommend MJD's <i>Higher-Order Perl</i>. The book is really fun in that it starts somewhat simple and you're like, “Yeah, yeah, I know what a closure is.” And then it just continues to fuck with your head. By the end of the book, you're just blown away. Even though I knew all that stuff, in theory, just watching it taken to the extreme really changed how I thought. I recommended that to a bunch of my friends and it blew their minds. In general, any book that gives people a different style to think in. That's the most recent example I can think of.</p>
<p class="normal"><b>Seibel：</b>我看到你那里有<i>计算机编程的艺术</i>；它看起来不太破旧。你读了多少？</p><p class="normal"><b>Seibel:</b> I see you've got <i>The Art of Computer Programming</i> up there; it doesn't look too worn. How much of it have you read?</p>
<p class="normal"><b>Fitzpatrick：</b>哦，直到不到五年前我才明白，也许是五年前。我跳来跳去并阅读其中的部分内容以获取乐趣。但是在我得到它的时候，我已经通过 CS 学到了很多东西，所以它可能在早期更有价值，但在互联网之前我并不真正了解它。</p><p class="normal"><b>Fitzpatrick:</b> Oh, I didn't get it until less than five years ago, maybe five years ago. I bounce around and read parts of it for fun. But at the time I got it, I had already learned a lot of it through C.S. So it probably would have been more valuable early on, but I didn't really know about it prior to the Internet.</p>
<p class="normal"><b>Seibel：</b>你认为成为一名程序员需要多少数学知识？要阅读 Knuth 并真正理解它，您必须精通数学，但您真的需要这样才能成为一名程序员吗？</p><p class="normal"><b>Seibel:</b> How much math do you think is necessary to be a programmer? To read Knuth and really understand it, you've got to be pretty mathematically sophisticated, but do you actually need that to be a programmer?</p>
<p class="normal"><b>Fitzpatrick：</b>你不需要那么多数学。对于大多数程序员来说，日复一日，统计数据要重要得多。如果您正在做图形方面的工作，那么数学要重要得多，但大多数人在做 Java 企业级工作或 Web 方面的工作时，事实并非如此。逻辑很有帮助，统计数据也出现了很多。</p><p class="normal"><b>Fitzpatrick:</b> You don't need that much math. For most programmers, day to day, statistics is a lot more important. If you're doing graphics stuff, math is a lot more important but most people doing Java enterprise stuff or web stuff, it's not. Logic helps and statistics comes up a lot.</p>
<p class="normal"><a id="OEBPS/Chapter02.html.page_82"></a><b>Seibel：</b>你显然仍然喜欢编程。但是读你上大学时的一些 LiveJournal 条目，似乎有时你压力很大并且讨厌电脑。</p><p class="normal"><a></a><b>Seibel:</b> You obviously still enjoy programming. But reading some of your LiveJournal entries from when you were in college, it seems like there were times when you were pretty stressed out and hating computers.</p>
<p class="normal"><b>Fitzpatrick：</b>哦，好吧，我一直讨厌电脑。我认为我们在很长一段时间内都没有真正取得任何进展。计算机似乎比以往任何时候都更慢、更崩溃、更容易出错。但我是如此乐观，我一直认为他们会好起来的。十年前我的计算体验似乎比今天更快乐。好像十年前我的电脑更快；就像十年前我的电脑运行得更好一样。事情变得更快了，但与此同时，软件变得更慢且错误更多。</p><p class="normal"><b>Fitzpatrick:</b> Oh, well, I always hate computers. I don't think we've really made any progress in quite a long time. Computers seem slower, and crashier, and buggier than ever. But I'm such an optimist, I keep thinking that they'll get better. It seems like my computing experience was happier ten years ago than it is today. It seems like my computer was faster ten years ago; like my computer worked better ten years ago. Things have gotten faster but the software has gotten slower and buggier in the meantime.</p>
<p class="normal"><b>Seibel：</b>你认为这是为什么？</p><p class="normal"><b>Seibel:</b> Why do you think that is?</p>
<p class="normal"><b>菲茨帕特里克：</b>我不知道。门槛降低了吗？还是计算机速度更快，所以您不需要高效或不需要知道自己在做什么？我没有线索。以上所有的某种组合，或者可能有太多的抽象层，以至于人们不知道下面到底发生了什么，因为计算机太快了，它隐藏了你的愚蠢。</p><p class="normal"><b>Fitzpatrick:</b> I don't know. Has the bar been lowered? Or are computers faster so you don't need to be efficient or you don't need to know what you're doing? I have no clue. Some combination of all of the above, or maybe there are so many layers of abstraction that people don't know what the hell is going on underneath because the computers are so damn fast that it hides your stupidity.</p>
<p class="normal"><b>Seibel：</b>所以也许事情并没有像计算机的速度那样快。但十年前，作为用户，今天的用户无法通过 Google 做到这一点。</p><p class="normal"><b>Seibel:</b> So maybe things are not as fast as they ought to be given the speed of computers. But ten years ago there was no way to do what people, as users, can do today with Google.</p>
<p class="normal"><b>菲茨帕特里克：</b>是的。所以有些人正在编写高效的代码并加以利用。我不玩任何游戏，但偶尔我会看到有人在玩东西，我想，“天哪，这可能吗？” 这让我很震惊。显然，有些人做得对。</p><p class="normal"><b>Fitzpatrick:</b> Yeah. So some people are writing efficient code and making use of it. I don't play any games, but occasionally I'll see someone playing something and I'm like, “Holy shit, that's possible?” It just blows me away. Obviously, some people are doing it right.</p>
<p class="normal">我想我主要是对桌面的状态不满意。后端似乎发生了很多有趣的事情。但是当我使用我的电脑时，我对它越来越感到沮丧。看来我的 Mac 不应该让沙滩球一直在旋转。</p><p class="normal">I guess I'm mostly dissatisfied with the state of my desktop. It seems like there is a lot of good interesting stuff going on in the back end. But as I'm using my computer I'm more and more frustrated with it. It seems like my Mac shouldn't have a beach ball spinning all the time.</p>
<p class="normal"><b>Seibel：</b>您有兴趣编写更好的桌面软件吗？</p><p class="normal"><b>Seibel:</b> Do you have any interest in writing better desktop software?</p>
<p class="normal"><a id="OEBPS/Chapter02.html.page_83"></a><b>Fitzpatrick：</b>问题是，没有人使用它。您想编写人们使用的东西，这归结为网络应用程序。前几天我丢了笔记本电脑，人们说，“哦，天哪，你丢东西了吗？” 我那里没有文件。这是一个互联网终端。而且它是一个加密磁盘，所以我不担心我的密码或 cookie 或类似的东西。人们不会下载程序，我不认为。</p><p class="normal"><a></a><b>Fitzpatrick:</b> The problem is, no one uses it. You want to write stuff people use, which comes down to web apps. I lost my laptop the other day and people were like, “Oh, my God, did you lose stuff?” I had no files on there. It was an Internet terminal. And it was an encrypted disk so I'm not worried about my password or cookies or anything like that. People won't download programs, I don't think.</p>
<p class="normal"><b>Seibel：</b>您是因为拥有用户还是仅仅因为编程的乐趣而更有动力？</p><p class="normal"><b>Seibel:</b> Are you more motivated by having users or just by the fun of programming?</p>
<p class="normal"><b>Fitzpatrick：</b>肯定有一些东西是我为我自己写的，我明确地为我作为唯一的用户写的，如果我得到补丁和东西，我就不在乎了。但很多时候我想和其他人一起工作。拥有用户是获得贡献者的关键。更多的用户会发现更多的错误并发现更多的用例。与其他人一起工作会更有趣，尤其是在开源项目上。</p><p class="normal"><b>Fitzpatrick:</b> There's definitely some stuff I write for me and I write it explicitly for me as the only user and I could care less if I get patches and stuff. But a lot of times I want to work with other people. Having users is a key to getting contributors. More users find more bugs and find more use cases. It's more fun to work with other people, especially on open source stuff.</p>
<p class="normal">当有人写信告诉您“嘿，我们现在正在为<i>x</i>使用您的软件”时，您总是感觉很好。这很酷。当我看到使用 memcached 或负载均衡器或其他东西的网站数量时，我会说，“啊，太酷了。” 我记得所有这些色情网站都开始告诉我他们正在使用我的文件系统。好吧，这说明了一些事情。我正在帮忙提供色情内容。在 Craigslist 上，每个请求都通过一个 Web 服务器，该服务器基本上是 memcached 的前端。好的。这很酷。</p><p class="normal">It always feels good when someone writes in to tell you, “Hey, we're now using your software for <i>x</i>.” That's pretty cool. When I see the number of web sites that use memcached or the load balancer or something, I'm like, “Ah, that's cool.” I remember all these porn sites started telling me they're using my file system. Well, that says something. I'm helping serve up porn. On Craigslist, every request goes through a web server that is basically a front end to memcached. OK. That's cool.</p>
<p class="normal"><b>Seibel：</b>你认为程序员会过度迷恋新事物吗？新语言，新工具，新的什么？</p><p class="normal"><b>Seibel:</b> Do you think programmers are overenamored of new things? New languages, new tools, new whatever?</p>
<p class="normal"><b>菲茨帕特里克：</b>他们可能是。我不知道这是否是希望新事物不会糟透的绝望，就像新的编程语言可以满足我们所有人的需求一样。但是用户也是一样的。用户总是喜欢获得版本号更高的版本，即使它更糟糕。</p><p class="normal"><b>Fitzpatrick:</b> They might be. I don't know if that's desperation in hoping the new thing doesn't suck, like the new programming language does what we all want. But users are the same way. Users always like to get the one with the higher version number even if it sucks more.</p>
<p class="normal">我不知道程序员在统计上是否与一般人不同。新的一定更好。情况并非总是如此，但人们希望如此。他们希望如此。</p><p class="normal">I don't know if programmers are statistically different than humans in general. New must be better. Which is not always the case, but people hope it is. They want it to be.</p>
<p class="normal"><a id="OEBPS/Chapter02.html.page_84"></a>我记得前阵子和我的牙医聊天，她不停地谈论过去五年牙科的进步，她真的很兴奋。</p><p class="normal"><a></a>I remember talking to my dentist a while back and she was going on and on about, like, the advances in dentistry over the last, like, five years, and she was really excited about them.</p>
<p class="normal"><b>Seibel：</b>作为一名现代程序员，很多事情都需要找到你需要使用的正确部分，并充分理解它们以使用它们。你怎么处理那件事呢？</p><p class="normal"><b>Seibel:</b> A lot of being a modern programmer requires finding the right pieces that you need to use and understanding them just well enough to use them. How do you deal with that?</p>
<p class="normal"><b>Fitzpatrick：</b> CPAN 拥有一切。有 14 个 ID3 解析器。选一个。</p><p class="normal"><b>Fitzpatrick:</b> CPAN has everything. There are 14 ID3 parsers. Pick one.</p>
<p class="normal"><b>Seibel：</b>所以，在某种程度上，这就是现代程序员面临的问题——他们有 14 个。你怎么选？</p><p class="normal"><b>Seibel:</b> So that, in a way, is the problem facing the modern programmer—there are 14 of them. How do you pick?</p>
<p class="normal"><b>Fitzpatrick：</b>谷歌搜索——哪个最高？人们倾向于喜欢哪一个？又识人。一旦我开始参加所有这些会议，我就会更多地参与到开源社区中，因为那时我会遇到一些人，看看谁受到尊重，谁很酷。</p><p class="normal"><b>Fitzpatrick:</b> Google search—which one's highest? Which one do people tend to like? And knowing people. I got so much more involved in the open source community once I started going to all these conferences because then I would meet people and see who was respected, and who was cool.</p>
<p class="normal">然后我会看到他们的代码：我记得那个人。他很棒。他风趣、友好、细心，而且他真的很关心他的代码。当人们抱怨时，他真的很热情。我将使用那个，因为如果我发现任何错误，我知道他会疯狂地修复它们。与脾气暴躁的人相反，他可能会写出很棒的代码，但如果您有问题或错误，他脾气暴躁并且与他互动并不有趣。所以你选择你信任或尊重的维护者。</p><p class="normal">Then I would see their code: I remember that guy. He was awesome. He was fun, friendly, and attentive, and he really cared about his code. He was really passionate when people complained about it. I'm going to use that one because if I find any bugs, I know he'll be crazy about fixing them. As opposed to the grumpy guy who maybe writes great code, but he's grumpy and not fun to interact with if you have a question or a bug. So you pick maintainers you trust or respect.</p>
<p class="normal"><b>Seibel：</b>那么有没有什么技巧可以快速确定某样东西是否适合您的需求？</p><p class="normal"><b>Seibel:</b> Then is there any trick to quickly figuring out whether something's going to suit your needs?</p>
<p class="normal"><b>菲茨帕特里克：</b>我刚开始。我不会将它直接插入我的代码中——首先我编写一个测试程序，使用我知道我将需要的几个函数，确保它们工作。或者仅针对我计划使用的数据为该库编写单元测试。许多图书馆甚至没有自己的测试。即使它确实如此，也许您阅读了文档并且您并不真正相信它会按照它所说的那样做，或者文档并不清楚它的行为方式。所以我为我关心的狗屎写了我自己的测试。我想既然无论如何我都必须写一些东西来学习图书馆，我的第一个 Hello, World 程序也可能是针对它的单元测试。</p><p class="normal"><b>Fitzpatrick:</b> I just start. I don't plug it right into my code—first I write a test program that uses the couple functions I know I'm going to need, make sure they work. Or write a unit test for just that library on just the data I plan to use with it. A lot of libraries out there don't even have their own tests. Even if it does, maybe you read the doc and you don't really trust that it does what it says it does, or the doc wasn't clear about how it behaves. So I write my own tests for the shit I care about. I figure since I'm going to have to write something to learn the library anyway, my first Hello, World program might as well be a unit test against it.</p>
<p class="normal"><a id="OEBPS/Chapter02.html.page_85"></a><b>Seibel：</b>那您实际使用的工具呢？您仍然是 Emacs 用户，对吗？</p><p class="normal"><a></a><b>Seibel:</b> What about the actual tools you use—you're still an Emacs user, right?</p>
<p class="normal"><b>Fitzpatrick：</b>我仍然是 Emacs 用户。我希望我在 Emacs 方面做得更好。但我知道所有的击键，但我并没有真正定制太多。我偷了别人的定制，我可以阅读它。但我发现自己对某件事感到恼火，并说，“我应该去写一些 Elisp 来将它绑定到一个键上。” 然后我没有。</p><p class="normal"><b>Fitzpatrick:</b> I'm still an Emacs user. I wish I were better at Emacs. But I know all the keystrokes but I don't really customize it much. I steal other people's customizations and I can kind of read it. But I find myself getting annoyed by something and saying, “I should go write some Elisp to bind it to a key.” And then I don't.</p>
<p class="normal">Steve Yegge 正在从事一个项目，基本上用 JavaScript 替换所有 Elisp。所以我一直说，我会等他这样做，这样我就不必学习另一种语言。我只会用 JavaScript 编写它。我不介意 JavaScript 作为一种语言。糟糕的是浏览器。在谷歌，我用 JavaScript 写了很多东西，然后嵌入到 Java 和 C++ 中。我认为 JavaScript 是一种很好的嵌入语言。</p><p class="normal">Steve Yegge is working on a project to basically replace all of Elisp with JavaScript. So I keep saying, I'll wait for him to do that so I don't have to learn another language. I'll just write it in JavaScript. I don't mind JavaScript as a language. It's browsers that suck. At Google I write a lot of stuff in JavaScript that I then embed in Java and C++. I figure JavaScript is a good embedding language.</p>
<p class="normal"><b>Seibel：</b>有没有什么工具是你被迫经常使用的，而你只是讨厌这些工具？除了你的整个桌面？</p><p class="normal"><b>Seibel:</b> Are there any tools that you are forced to use regularly that you just hate? Other than your whole desktop?</p>
<p class="normal"><b>Fitzpatrick：</b>是的，整个桌面。我的桌面上有很多东西。所有这些浏览器总是挂起、崩溃并使用大量内存。我的整个操作系统挂了。我的同事试图告诉我——如果他们看到我在 Emacs 中做某事——Eclipse 或 IntelliJ 会自动为他们做这件事。所以每六个月我都会尝试其中之一，Eclipse 或 IntelliJ。那该死的东西就一直在那里旋转，消耗内存，可能会在我打字的过程中崩溃，或者跟不上我的打字速度。来吧——在后台语法高亮或在不同的线程中编译。你为什么要阻止我打字来做到这一点？好的，我会在六个月后再试一次，伙计们。所以我很高兴我没有被迫使用它。不过，我真的应该在 Emacs 上做得更好。</p><p class="normal"><b>Fitzpatrick:</b> Yeah, the whole desktop. There are a whole lot of things on my desktop. All these browsers are always hanging and crashing and using tons of memory. My whole operating system hanging. My coworkers try to tell me—if they see me doing something in Emacs—that Eclipse or IntelliJ does it for them automatically. So every six months I try out one of them, Eclipse or IntelliJ. And the damn thing just sits there spinning forever, consuming memory and maybe crashes in the middle of me typing or can't keep up with me typing. Come on—syntax-highlight in the background or compile in a different thread. Why are you blocking my typing to do this? OK, I'll try it again in six months, guys. So I'm glad I'm not forced to use that. I should really get better at Emacs, though.</p>
<p class="normal">我的学习曲线是，我很快就学会了一些东西，直到我达到了我非常有效率和足够好的地步。然后我会在大约 90% 或 80% 的状态下稳定下来，在那里我很有效率，我不需要查找东西，我很开心。然后慢慢就好了。只有在我对我喜欢的东西感到超级舒服之后，“我才会去挖掘这种语言的文档——手册页——并学习每一个角落。”</p><p class="normal">My learning curve is, I learn something pretty rapidly until I get to this point where I'm pretty productive and good enough. Then I kind of plateau at like maybe 90 percent or 80 percent, where I'm productive and I don't have to look things up and I'm happy. And then it slowly gets better after that. It's only after I'm super comfortable with something that I'm like, “I'm going to go dig around the docs for this language—the man pages—and learn every nook and cranny.”</p>
<p class="normal"><a id="OEBPS/Chapter02.html.page_86"></a><b>Seibel：</b>现在这可能是明智的吗？你可以学到很多东西。你可能永远只学习如何使用你的编辑器，然后你会写多少软件？</p><p class="normal"><a></a><b>Seibel:</b> Is that maybe wise these days? There are so many things you could learn. You could spend forever just learning how to use your editor, and how much software would you write then?</p>
<p class="normal"><b>Fitzpatrick：</b>是的，但我一直发现——至少对你的编辑来说——它总是有回报的。每当我学到一些东西时，它就会在一两周内得到回报，我不知道。每当我在我的 bin 目录中编写一个愚蠢的小 shell 脚本，或者一个小的 Perl 脚本，或者一些让我的生活自动化的东西时，它总是有回报的。</p><p class="normal"><b>Fitzpatrick:</b> Yeah, but I've always found—at least for your editor—it always pays off. Whenever I learn something, it pays off within, I don't know, a week or two. Whenever I write a stupid little shell script in my bin directory, or a little Perl script, or something to automate my life, it always pays off.</p>
<p class="normal"><b>Seibel：</b>所以你从来没有被困在无休止的工具制造坑里？</p><p class="normal"><b>Seibel:</b> So you've never gotten trapped in the pit of endless toolsmithing?</p>
<p class="normal"><b>菲茨帕特里克：</b>不。我倾向于这样做是有目的的。我肯定知道有些人总是在使用他们的个人工具，但从来没有完成任何事情。不过，我可以朝那个方向多走一点并且安全。</p><p class="normal"><b>Fitzpatrick:</b> Nah. I tend to do it for a purpose. I definitely know people who are just always working on their personal tools and never get anything done. I can go a little bit more in that direction and be safe, though.</p>
<p class="normal"><b>Seibel：</b>您认为程序员最重要的技能是什么？</p><p class="normal"><b>Seibel:</b> What do you think is the most important skill for a programmer to have?</p>
<p class="normal"><b>Fitzpatrick：</b>像科学家一样思考；一次改变一件事。耐心并试图了解事情的根本原因。尤其是当你正在调试或设计一些不太可行的东西时。我见过年轻的程序员说，“哦，该死，这行不通”，然后全部重写。停止。试着弄清楚发生了什么。了解如何逐步编写内容，以便在每个阶段都可以验证它。</p><p class="normal"><b>Fitzpatrick:</b> Thinking like a scientist; changing one thing at a time. Patience and trying to understand the root cause of things. Especially when you're debugging something or designing something that's not quite working. I've seen young programmers say, “Oh, shit, it doesn't work,” and then rewrite it all. Stop. Try to figure out what's going on. Learn how to write things incrementally so that at each stage you could verify it.</p>
<p class="normal"><b>Seibel：</b>作为一名程序员，你有没有专门做过什么来提高你的技能？</p><p class="normal"><b>Seibel:</b> Is there anything that you did specifically to improve your skill as a programmer?</p>
<p class="normal"><b>Fitzpatrick：</b>有时我会特意用一种我不想用的语言写东西——我知道用那种语言写会花更长的时间——因为我知道我会做得更好结束。就像我刚到谷歌时，有很多次我在写一次性的东西，然后我会用 Perl 来写。然后我会想，“啊，不，我应该用 Python 写这个。” 现在我写了大量的 Python 而这并不困扰我——我几乎不需要查找东西。Perlbal 最初是用 C# 编写的，只是为了学习它。</p><p class="normal"><b>Fitzpatrick:</b> Sometimes I'll go out of my way to write something in a language that I would rather not write it in—and I know it'll take me longer to write in that language—because I know I'll be better in the end. Like when I got to Google, there were a lot of times where I was writing one-off things and I'd go to write it in Perl. Then I'd be like, “Ah, no, I should write this in Python.” Now I write tons of Python and it doesn't bother me—I barely have to look things up. Perlbal was originally written in C# just to learn that.</p>
<p class="normal"><a id="OEBPS/Chapter02.html.page_87"></a><b>Seibel：</b>除了编程本身，您认为未来的程序员还应该培养哪些技能？</p><p class="normal"><a></a><b>Seibel:</b> And are there skills apart from programming itself that you think would-be programmers should develop?</p>
<p class="normal"><b>Fitzpatrick：</b>有交流，但我不确定那是你真正可以练习的东西。经常与邮件列表中的人打交道。书面沟通方式大有帮助。但这是生活中的普遍现象，对吧？有一些关于谁在高中毕业后取得成功的研究。是聪明的孩子还是社交的孩子？事实证明，最终赚钱的是社会孩子，而不是成绩好的人。我觉得这很有趣。</p><p class="normal"><b>Fitzpatrick:</b> There's communication, but I'm not sure that's something you can really practice. Deal with people on mailing lists a lot. Written communication style goes a long way. But that's a general life thing, right? There was some study about who was successful after high school. Was it the smart kids or the social kids? It turned out that it was the social kids who ended up making all the money in life, not the people with the good grades. I thought that was interesting.</p>
<p class="normal"><b>Seibel：</b>这似乎与过去有所不同。曾经是程序员可能是躲在办公室里的侏儒。这些天都是邮件列表和协作。</p><p class="normal"><b>Seibel:</b> That seems to be a bit of a change from the past. It used to be programmers could be gnomes hiding in an office. These days it's all mailing lists and collaboration.</p>
<p class="normal"><b>Fitzpatrick：</b>嗯，在我工作过的地方，无论是开源还是公司，每个人都相互依赖。激励因素是，“我要编写这段代码，因为我知道你将在两周内需要它，或者我将在两周内需要你的代码。” 总有一个人的水平。</p><p class="normal"><b>Fitzpatrick:</b> Well, at the places I've worked, either on open source or at companies, everyone depends on each other. The motivating factor is, “I'm going to write this code because I know you're going to be needing it in two weeks or I'm going to be needing yours in two weeks.” There's always a human level.</p>
<p class="normal"><b>Seibel：</b>人们声称，最好和最差的程序员之间的生产力存在数量级的差异。那是你的经历吗？</p><p class="normal"><b>Seibel:</b> People have claimed that there are orders of magnitude differences in productivity between the best and worst programmers. Has that been your experience?</p>
<p class="normal"><b>Fitzpatrick：</b>是的，但它可能在每个领域都是如此。就是你有多少经验。我认识的两个人从事相同类型的编程，并且用相同的时间进行编程，但相差十倍的情况并不常见。看起来如果你没有一直变得更好，你可能会感到沮丧然后退出。</p><p class="normal"><b>Fitzpatrick:</b> Yeah, but it's probably like that in every field. It's how much experience you have. It's not often the case where I know of two people who do the same sort of programming and have been doing it the same amount of time, but differ by a factor of ten times. It seems like if you're not getting better all the time, you're probably getting frustrated and you drop out.</p>
<p class="normal">我想有些人只是为了工作而做，但并不真正喜欢它。没关系。但是将这些人与硬核程序员进行比较有点奇怪。当一个人工作十倍的时间并且不停地思考它而另一个人只是在他的工作中做时，什么是十倍的生产力？</p><p class="normal">I guess there are the people who just do it for a job but don't really enjoy it. Which is OK. But it's kind of weird to compare those people with people who are hardcore programmers. What's ten times more productive when one person works ten times the hours and thinks about it nonstop and the other person just does it at his job?</p>
<p class="normal"><a id="OEBPS/Chapter02.html.page_88"></a><b>Seibel：</b>您刚才提到采用科学家的方法进行调试。你认为自己是科学家、工程师、艺术家还是工匠？</p><p class="normal"><a></a><b>Seibel:</b> You just mentioned taking a scientist's approach to debugging. Do you consider yourself a scientist, an engineer, an artist, or a craftsman?</p>
<p class="normal"><b>Fitzpatrick：</b>要么是科学家，要么是工程师。可能更多的是工程师。我会说科学家是第二位的，但只是在一次改变一件事的科学方法以及你如何诊断问题的意义上。事物设计方面的工程师。我肯定有自称为艺术家或工匠的朋友。我从来没有这样想过自己。</p><p class="normal"><b>Fitzpatrick:</b> Either scientist or engineer. Probably more engineer. I would say scientist was second, but only in the sense of the scientific method of changing one thing at a time and how you diagnose problems. Engineer for the design aspect of things. I definitely have friends who call themselves artists or craftsmen. I've never thought of myself as that.</p>
<p class="normal"><b>Seibel：</b>另一方面，软件中有很多工程师羡慕的对象。你听过这样的笑话：“如果人们按照我们开发软件的方式建造摩天大楼，第一只啄木鸟就会毁灭文明。” 您认为构建软件是一门易于理解的工程学科吗？</p><p class="normal"><b>Seibel:</b> On the other hand, there's a lot of engineering envy in software. You hear the jokes about, “If people built skyscrapers the way we build software, the first woodpecker would destroy civilization.” Do you think building software is a well-understood engineering discipline?</p>
<p class="normal"><b>Fitzpatrick：</b>不。我认为它还没有。编写代码不需要许可证，对吧。并不是说我想要大量的监管，但很高兴知道其中一些具有这些 XSS 漏洞的 PHP 程序员与编写空中交通管制系统的人不同。我希望这些人之间有一些正式的联系。</p><p class="normal"><b>Fitzpatrick:</b> No. I don't think it's there yet. You don't need a license, right, to write code. Not that I want tons of regulation, but it would be nice to know that some of these PHP programmers with these XSS exploits aren't the same people writing the air-traffic-control system. I'd like there to be some official line between those people.</p>
<p class="normal">我有一个结构工程师朋友，他一直在上学，并获得了所有这些工程认证。知道为我建造桥梁的人永远研究这些狗屎并进行大量测试并一直熬夜学习，这让我感到很欣慰。</p><p class="normal">I have a friend who's a structural engineer and he went to school forever and took all this engineering certification stuff. It's kind of comforting to know that the people who build the bridges I'm on studied this shit forever and took tons of tests and stayed up all the time studying.</p>
<p class="normal"><b>Seibel：</b>但是你可以给程序员什么样的测试来让你相信他们可以编写出可以运行的软件？</p><p class="normal"><b>Seibel:</b> But what test could you give a programmer that would give you confidence that they can write software that will work?</p>
<p class="normal"><b>菲茨帕特里克：</b>我不知道。这有点可怕。</p><p class="normal"><b>Fitzpatrick:</b> I don't know. It's kind of scary.</p>
<p class="normal"><b>Seibel：</b>即使没有执照，你认为程序员对社会有任何特殊的道德责任吗？我们可以说是一种职业，职业有行为准则。</p><p class="normal"><b>Seibel:</b> Even without licensing, do you think programmers have any sort of special ethical responsibilities to society? We're arguably a profession, and professions have codes of conduct.</p>
<p class="normal"><b>Fitzpatrick：</b>你不应该杀任何人。就像飞行控制软件一样。但这是一种罕见的情况。我想请大家在他们的信用卡表格上保持一致，让我在他妈的空格或连字符中输入。计算机擅长清除这些垃圾。不要告诉我如何格式化我的数字。但那里没有道德。只是愚蠢。</p><p class="normal"><b>Fitzpatrick:</b> You shouldn't kill anyone. Like with flight-control software. But that's kind of a rare case. I would like to ask that everyone is consistent on their credit-card forms to like let me put in fucking spaces or hyphens. Computers are good at removing that shit. Don't tell me how to format my numbers. But there's no ethics there. Just stupidity.</p>
<p class="normal"><a id="OEBPS/Chapter02.html.page_89"></a><b>Seibel：</b>你现在 28 岁了。您是否担心编程是一种年轻人的游戏，随着年龄的增长您会失去一步？</p><p class="normal"><a></a><b>Seibel:</b> You're 28 now. Do you have any worries that programming is sort of a young person's game, that you're going to lose a step as you get older?</p>
<p class="normal"><b>Fitzpatrick：</b>不。最坏的情况是，我总是可以停下来自己做一些有趣的事情。我不觉得我现在在和任何人竞争，我真的不在乎其他人是否更好，因为我觉得已经有很多人更好了。我想无论如何我们总是在中间，所以我很高兴留在中间。</p><p class="normal"><b>Fitzpatrick:</b> No. The worst case, I could always just stop and work on fun things on my own. I don't feel like I'm competing with anyone right now and I don't really care if other people are better because I feel like there are tons of people who are better already. I figure we are always in the middle anyway, so I'm happy to stay in the middle.</p>
<p class="normal"><b>Seibel：</b>所以编程是你为了乐趣而做的事情，即使你辞职了？</p><p class="normal"><b>Seibel:</b> So programming is what you'd do for fun, even if you quit working?</p>
<p class="normal"><b>菲茨帕特里克：</b>哦耶。我还是会做傻事。我的手机上有这个愚蠢的棋盘游戏。我有点累了——我无法处理任何严肃的事情，所以我为那个游戏写了一个求解器。尝试做一些动态规划，做了不同的电路板尺寸，做了一堆随机的电路板，并制作了一个直方图，说明解决不同电路板尺寸的电路板需要多少步。我把它发给了作者，因为游戏对标准杆的估计非常糟糕。基本上，要在游戏中取得进步，您必须做得比标准杆更好。邮件列表中的每个人都注意到，随着你的继续，游戏变得更容易，因为他对标准杆的估计有点凭空而来。所以我把每个棋盘大小的直方图发给他。我认为他在新版本的游戏中调整了标准杆。那是一次有趣的黑客攻击，就在回家的班车上。</p><p class="normal"><b>Fitzpatrick:</b> Oh, yeah. I'd still do stupid shit. I have this silly board game on my phone. I was kind of tired—I couldn't work on anything serious, so I wrote a solver for that game. Tried to do some dynamic programming and did different board sizes and did a bunch of random boards and made a histogram of how many moves it takes to solve the board for different board sizes. I sent it to the author because the game has a really bad estimate of par. Basically, to advance in the game you have to do better than par. And everyone on the mailing list was noticing that the game got easier as you went on because his estimate of par he kind of pulled out of nowhere. So I sent him the histograms at every board size. I think in the new version of the game he adjusted par. That was a fun hack, just on the shuttle home. I could retire and just do dumb shit like that all day.</p>
</div>
</div></div>
<div id="OEBPS/Chapter03.html"><div>

<div class="booksection">
<p></p>
<h2 class="chapnum"><a id="OEBPS/Chapter03.html.ch3"></a><a id="OEBPS/Chapter03.html.page_91"></a><img src="data:image/jpg;base64,/9j/4AAQSkZJRgABAgEASABIAAD/7Q0OUGhvdG9zaG9wIDMuMAA4QklNA+0KUmVzb2x1dGlvbgAAAAAQAEgAAAABAAEASAAAAAEAAThCSU0EDRhGWCBHbG9iYWwgTGlnaHRpbmcgQW5nbGUAAAAABAAAAHg4QklNBBkSRlggR2xvYmFsIEFsdGl0dWRlAAAAAAQAAAAeOEJJTQPzC1ByaW50IEZsYWdzAAAACQAAAAAAAAAAAQA4QklNBAoOQ29weXJpZ2h0IEZsYWcAAAAAAQAAOEJJTScQFEphcGFuZXNlIFByaW50IEZsYWdzAAAAAAoAAQAAAAAAAAACOEJJTQP1F0NvbG9yIEhhbGZ0b25lIFNldHRpbmdzAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+BdDb2xvciBUcmFuc2ZlciBTZXR0aW5ncwAAAHAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAOEJJTQQAC0xheWVyIFN0YXRlAAAAAgABOEJJTQQCDExheWVyIEdyb3VwcwAAAAAEAAAAADhCSU0ECAZHdWlkZXMAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4NVVJMIG92ZXJyaWRlcwAAAAQAAAAAOEJJTQQaBlNsaWNlcwAAAAB1AAAABgAAAAAAAAAAAAAArwAAAPkAAAAKAFUAbgB0AGkAdABsAGUAZAAtADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAPkAAACvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhCSU0EERFJQ0MgVW50YWdnZWQgRmxhZwAAAAEBADhCSU0EFBdMYXllciBJRCBHZW5lcmF0b3IgQmFzZQAAAAQAAAACOEJJTQQMFU5ldyBXaW5kb3dzIFRodW1ibmFpbAAACTEAAAABAAAAcAAAAE8AAAFQAABnsAAACRUAGAAB/9j/4AAQSkZJRgABAgEASABI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" alt="图片"></h2><h2 class="chapnum"><a></a><a></a></h2>
<h2 class="chaptitle">道格拉斯克罗克福德</h2><h2 class="chaptitle">Douglas Crockford</h2>
<div class="sidebar">
<p class="normal"><i>作为 Yahoo! 的高级 JavaScript 架构师，Douglas Crockford 自 70 年代初以来一直是一名程序员，当时他在大学学习了 Fortran 课程，因为他的电视广播专业无法获得工作室时间。在他的职业生涯中，他在 Atari、Lucasfilm、Electric Communities 和现在的 Yahoo! 等地方以各种方式将计算机与媒体结合起来。</i></p><p class="normal"><i>A senior JavaScript Architect at Yahoo!, Douglas Crockford has been a programmer since the early '70s when he took a Fortran course in college after being unable to get studio time for his major in television broadcasting. Over the course of his career, he has combined computers with media in various ways at places like Atari, Lucasfilm, Electric Communities, and now Yahoo!</i></p>
<p class="normal"><i>Crockford 本质上是一个简化者和整理者。他发明了 JSON，这是一种在 Ajax 应用程序中广泛使用的数据交换格式，因为他发现 XML 太复杂了。他最近出版的书 JavaScript: The Good Parts 认为，如果避免某些功能，JavaScript 实际上是一种非常好的语言。当我与他交谈时，他强调了子集作为管理复杂性的一种方式的重要性，并描述了他使用的代码阅读过程，该过程从简单地整理代码开始。</i></p><p class="normal"><i>Crockford is, by nature, a simplifier and a tidier. He invented JSON, the data interchange format widely used in Ajax applications, because he found XML too complicated. His recently published book, JavaScript: The Good Parts, argues that JavaScript is actually quite a nice language if one avoids certain features. When I talked to him he stressed the importance of subsetting as a way of managing complexity and described a code-reading process he uses that starts with simply tidying up the code.</i></p>
<p class="normal"><i>在我们接受采访时，Crockford 以其对 ECMAScript (JavaScript) 语言标准的拟议 ECMAScript 4 (ES4) 修订版的直言不讳而闻名，理由是它过于复杂。他赞成一个更温和的标为 ES3.1 的提案，从那时起他和另一个 ES3.1<a id="OEBPS/Chapter03.html.page_92"></a>拥护者基本上占了上风——ES3.1 已更名为 ES5，而 ES4 的努力已被正式放弃。</i></p><p class="normal"><i>At the time of our interview, Crockford had become well known as an outspoken critic of the proposed ECMAScript 4 (ES4) revision to the ECMAScript (JavaScript) language standard, on the grounds that it was too complex. He was in favor of a more modest proposal labeled ES3.1, and since then he and the other ES3.1 <a></a>advocates have largely prevailed—ES3.1 has been renamed ES5, and the ES4 effort has been officially abandoned.</i></p>
<p class="normal"><i>Crockford 和我讨论了他不喜欢 ES4 提案的地方、代码阅读作为团队活动的重要性，以及如何在现有系统遗留的情况下推动 Web 向前发展。</i></p><p class="normal"><i>Crockford and I talked about what he disliked about the ES4 proposal, the importance of code reading as a team activity, and how to move the Web forward despite the legacy of existing systems.</i></p>
</div>
<p class="normal"><b>Seibel：</b>你是如何开始编程的？</p><p class="normal"><b>Seibel:</b> How did you start programming?</p>
<p class="normal"><b>克罗克福德：</b>我去了旧金山州立大学。我去那里是因为他们有一个非常好的电视节目。第一年我无法进入工作室，所以我寻找其他可以学习的东西，并且有点侥幸，我在数学系上了一门 Fortran 课。结果证明我真的很擅长，所以我参加了第二学期的课程。</p><p class="normal"><b>Crockford:</b> I went to San Francisco State University. I went there because they had a really good television program. My first year I couldn't get into the studio so I looked for other things to take and sort of as a fluke I took a Fortran class in the math department. And it turned out I was really good at it so I took the second-semester class.</p>
<p class="normal">那是 71 年、72 年。那是图书馆地下室的打孔卡。分时刚到学校。在旧金山州立大学，我们没有拥有所有计算机的强大工程部门。相反，他们分布在整个学校。自然科学有一个实验室；商学院有一个实验室；教育学院有一个实验室；人文学科有一个实验室。这真的很有趣，因为所有这些学科都在玩电脑。</p><p class="normal">That was '71, '72. It was punch cards in the basement of the library. Timesharing had just come to the school. At San Francisco State we didn't have a strong engineering department that owned all the computers. Instead they got distributed all over the school. Natural sciences had a lab; school of business had a lab; school of education had a lab; and humanities had a lab. Which was really interesting in that you had all these disciplines all playing with computers.</p>
<p class="normal">我先去科学实验室工作，然后去人文实验室工作。所以我邀请了经济学家、心理学家或地理学家——他们是最有趣的人。我会了解他们正在解决的问题，并且我很早就对普通人在玩这些可怕的机器时的担忧产生了很大的敏感性，并开始研究我们如何才能让这些东西对他们更好。</p><p class="normal">I went to work first in the science lab and then in the humanities lab. So I'd have people coming in who were economists or psychologists or geographers—they were the most interesting people. I'd learn about the problems that they were working on and I developed a lot of sensitivity really early on to the concerns of normal people as they play with these terrible machines and started looking at how we can make this stuff better for them.</p>
<p class="normal">最终我进入了工作室，做了所有的电视工作，这很有趣，但最后我决定走电脑之路。但一直以来，我花了很多时间来思考这两件事。我预料到很多东西会成为多媒体和现在的数字媒体，在我职业生涯的不同时期，我已经回去完成了媒体部分，然后又回到了编程部分。</p><p class="normal">Eventually I got into the studios and did all the TV stuff and that was fun but in the end I decided to go the computer way. But all along I spent a lot of time thinking about the two things together. I anticipated a lot of what would become multimedia and now digital media, and at various times in my career I've gone back and done the media part and then returned to the programming part.</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_93"></a><b>Seibel：</b>所以你从 Fortran 开始，并发现你擅长它。除了“哦，我似乎很擅长这个”之外，还有什么吸引你编程的吗？</p><p class="normal"><a></a><b>Seibel:</b> So you started with Fortran and discovered that you were good at it. Was there anything that drew you to programming other than, “Oh, I seem to be good at this'?'”</p>
<p class="normal"><b>克罗克福德：</b>就是这样。那是我的第一个学期，我不得不上一门数学课，我随机选了其中一门，碰巧里面有 Fortran。所以我没有打算学习如何编程。这就是发生的事情。</p><p class="normal"><b>Crockford:</b> That's all it was. It was my first semester, and I had to take a math class and I had picked one of those at random and it happened to have Fortran in it. So I didn't go into it intending to learn how to program. It was just what happened.</p>
<p class="normal"><b>Seibel：</b>你记得写的第一个有趣的程序是什么？</p><p class="normal"><b>Seibel:</b> What was the first interesting program you remember writing?</p>
<p class="normal"><b>克罗克福德：</b>那要追溯到很久以前了。我想这是我写的一个程序，用于在我使用的分时系统上反汇编 Fortran 系统的运行时。通过这样做，我能够了解该系统是如何工作的，并自学了很多基于该模型的编程知识，这些东西通常不会被发表。</p><p class="normal"><b>Crockford:</b> That's going way back. I think it was a program I wrote to disassemble the runtime of the Fortran system on the timesharing system I was using. By doing that, I was able to read how that system worked and taught myself a lot about programming based on that model, something which would not ordinarily have been published.</p>
<p class="normal"><b>Seibel：</b>你认为与那时相比，你对编程的看法最大的变化是什么？</p><p class="normal"><b>Seibel:</b> What do you think is the biggest change in the way you think about programming compared to back then?</p>
<p class="normal"><b>克罗克福德：</b>在大约十年的时间里，效率真的非常重要。我想那是在早期的微处理器时代，当时内存仍然很小，CPU 仍然很慢。我们会深入研究汇编语言，以便做游戏和音乐之类的事情，使其适合并使其快速。最终我们克服了这个问题，所以今天我们用 JavaScript 编写在浏览器中运行的大型应用程序。与我们过去所做的事情相比，这是一个非常低效的环境，但摩尔定律让一切都变得很好。</p><p class="normal"><b>Crockford:</b> There was a period of maybe a decade where efficiency was really, really important. I guess it was in the early microprocessor era when memory was still really small and the CPUs were still really slow. We'd get down into assembly language in order to do things like games and music to make it fit and to make it fast. Eventually we got over that, so today we're writing big applications in JavaScript that run in a browser. It's such a profoundly inefficient environment compared to the stuff that we used to do, but Moore's Law sort of made it all OK.</p>
<p class="normal"><b>Seibel：</b>对于你学习编程的道路，有什么让你后悔的吗？</p><p class="normal"><b>Seibel:</b> And is there anything that you regret about the path that you took learning to program?</p>
<p class="normal"><b>Crockford：</b>有一些我知道但从未有机会使用的语言。我读过很多关于 APL 的文章，我明白它为什么会失败，但它真的很简洁，我从来没有花时间在它上面，这很不幸。还有其他类似的语言，在我知道它们的地方，我已经阅读了关于它们的所有内容，但我从来没有机会真正思考它们。</p><p class="normal"><b>Crockford:</b> There are some languages that I was aware of that I never got a chance to use. I've read a lot about APL and I understand why it lost, but it was really neat and I never spent any time with it and that was unfortunate. There are other languages like that, where I'm aware of them, I've read what I can about them, but I never got a chance to actually think in them.</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_94"></a><b>Seibel：</b>所以你实际上最终获得了广播学位；在那之后你做了什么？</p><p class="normal"><a></a><b>Seibel:</b> So you actually ended up doing your degree in broadcasting; after that what did you do?</p>
<p class="normal"><b>Crockford：</b>我开始攻读教育技术硕士课程。但是我觉得我远远领先于程序所在的位置，我只是在浪费时间。大约一年后，我离开了那家公司，前往门洛帕克的 SRI 工作，担任研究员。然后我去了一家名为 Basic Four 的公司，该公司生产小型商用小型计算机，并在那里工作了很多年。我为他们开发了一个文字处理系统，并开始研究便携式机器和个人电脑。我试图将那家公司推向 PC；我买了公司的第一台个人电脑，把它放在我的桌子上，这样工程师们就可以来看看它，看看 IBM 做了什么，但最终我无法改变那里的文化——他们很固执己见正在做。</p><p class="normal"><b>Crockford:</b> I started a master's program in educational technology. But I felt like I was so far ahead of where the program was that I was just wasting time. I left that after about a year and went to work at SRI in Menlo Park, as a researcher. Then I went to a company called Basic Four, which was making small business minicomputers and spent a lot of years there. I developed a word-processing system for them and started doing some research into portable machines and PCs. I tried to push that company into PCs; I bought the first PC in the company and left it open on my desk so that the engineers could come look at it and see what IBM had done, but ultimately I couldn't change the culture there—they were pretty set in what they were doing.</p>
<p class="normal">然后一个圣诞节，也许是 81 年的圣诞节，我买了一台 Atari 800。我去了电脑商店，那里有一台 Apple II 和一台 800，而 800 看起来更时髦，所以我买了那台。我想我会在上面写一个文字处理器或为它编写一种编程语言。但是 6502 就是无能为力。所以我花了两千美元买了这东西——它能做什么？好吧，显然它可以做游戏。所以我开始编写电脑游戏并将其中一个卖给了 Atari，然后得到了在他们位于桑尼维尔的研究实验室工作的邀请。那是 Alan Kay 创办的研究实验室，这是他自 PARC 以来的第一件事。所以我去了那里，那里很棒。我在那里待了两年，眼睁睁地看着公司倒闭。但我设法在那里做了一些有趣的工作。和一些非常优秀的人一起工作。</p><p class="normal">Then one Christmas, maybe it was Christmas of '81, I bought an Atari 800. I went to the computer store and there was an Apple II and an 800 and the 800 looked to be snazzier so I got that one. I thought that I'd write a word processor on it or a programming language for it. But the 6502 was just not up to doing anything. So I'd spent two thousand dollars for the thing—what can it do? Well, obviously it can do games. So I started writing computer games and I sold one to Atari and then got an offer to work in their research laboratory in Sunnyvale. That was the research lab that Alan Kay had started, his first thing since PARC. So I went there and it was great. I was there for two years and watched the company melt down. But I managed to do some interesting work there. Worked with some really good people.</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_95"></a><b>Seibel：</b>在那之前你是游戏迷吗？</p><p class="normal"><a></a><b>Seibel:</b> Had you ever been a game aficionado before that?</p>
<p class="normal"><b>Crockford：</b>我在 Space Invaders 和 Pac-Man 上投了一些硬币。我喜欢这些游戏；我不是铁杆。对我来说，游戏的有趣之处在于它是电视与电脑互动的另一个地方。这是公众参与互动的第一个地方。我觉得那真的很有趣。</p><p class="normal"><b>Crockford:</b> I'd thrown some quarters at Space Invaders and Pac-Man. I liked the games; I wasn't hard-core. The interesting thing about games for me was it was another place where television interacted with computers. It was the first place where the public got to participate in that interaction. I thought that was really interesting.</p>
<p class="normal"><b>Seibel：</b>在 Atari 崩溃之后，接下来会发生什么？</p><p class="normal"><b>Seibel:</b> After Atari melted down, what next?</p>
<p class="normal"><b>克罗克福德：</b>然后我去了卢卡斯影业，在那里待了八年。</p><p class="normal"><b>Crockford:</b> Then I went to Lucasfilm and was there for eight years.</p>
<p class="normal"><b>Seibel：</b>当你在那里的时候，Habitat 就开始了。</p><p class="normal"><b>Seibel:</b> And Habitat started while you were there.</p>
<p class="normal"><b>克罗克福德：</b>确实如此。我的一个朋友 Chip Morningstar 开始了那个项目。他发明了化身；他发明了图形虚拟世界。他先做了所有这些事情。它在 Commodore 64s 和非高峰期 X.25 网络上运行。对那个东西的设计真是惊人的先见之明——他做对了这么多，真是太神奇了。我有点像个旁观者。我看到他们这样做并鼓励他们。但我不能相信他们所做的一切。</p><p class="normal"><b>Crockford:</b> It sure did. A friend of mine, Chip Morningstar, started that project. He invented the avatar; he invented the graphical virtual world. He did all that stuff first. It ran on Commodore 64s and off-peak X.25 networks. Just amazing foresight in the design of that thing—he got so much right, it was amazing. I was sort of a spectator. I saw them doing it and encouraged them. But I can't take any credit for what they did.</p>
<p class="normal"><b>Seibel：</b>然后你和他们一起建立了基于这些想法的 Electric Communities？</p><p class="normal"><b>Seibel:</b> And then you went with them to found Electric Communities, which built upon those ideas?</p>
<p class="normal"><b>克罗克福德：</b>对。Morningstar 和 Randy Farmer 离开了 Lucasfilm，创办了一家名为 American Information Exchange 的公司，该公司将他们的社交服务器理念应用于在线市场。绝妙的想法，但超前于他们的时代。如果他们晚一点，他们可能是 eBay。</p><p class="normal"><b>Crockford:</b> Right. Morningstar and Randy Farmer left Lucasfilm to start a company called the American Information Exchange, which took their idea of a social server and applied it to the idea of online markets. Brilliant idea, but ahead of their time. Had they been a little bit later, they could have been eBay.</p>
<p class="normal">然后我们有了想法，好吧，让我们再做一次，想出一个通用平台，可以处理娱乐、社交、商业和商业等所有事情，我们将为全世界做这个平台。我们对如何使它完全分布有一些想法，这样就没有单一的服务器——它全部分布在网络上。我们会提出安全模型，使其能够完全去中心化。这是一个非常强大的想法，这就是 Electric Communities 背后的想法。</p><p class="normal">Then we got the idea of well, let's do that again and come up with a common platform which does the entertainment thing and the social thing and the business thing and the commercial thing and everything and we'll do the platform for the whole world. And we had some ideas about how to make it fully distributed so that there is no single server—that it all spreads over the Net. And we would come up with security models that would allow it to be fully decentralized. It was a really powerful idea and that was the idea behind Electric Communities.</p>
<p class="normal"><b>Seibel：</b>这就是 E 的第一个版本的来源。</p><p class="normal"><b>Seibel:</b> And that's where the first versions of E came from.</p>
<p class="normal"><b>克罗克福德：</b>对。我们需要一种安全的编程语言来开发平台和应用程序。我们的第一个尝试是名为 Joule 的东西，它正在另一家名为 Agorics 的公司开发。Joule 是一种演员语言，它做事的方式很奇怪——它很聪明但不落俗套。</p><p class="normal"><b>Crockford:</b> Right. We needed a secure programming language to develop the platform and the applications in. And our first attempt at that was something called Joule which was being developed at another company called Agorics. Joule was an actor language and was pretty odd in the way that it did things—it was brilliant but unconventional.</p>
<p class="normal">我们担心焦耳。我们是否能够让人们使用这种语言？是不是太变态了？然后我们提出了 E 的想法，即从 Joule 中提取核心参与者概念并在 Java 之上重新实现它们。</p><p class="normal">We had concerns about Joule. Were we going to be able to get people to use this language; is it too freaky? Then we came up with the idea of E, which was taking the core actor concepts out of Joule and reimplementing them on top of Java.</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_96"></a><b>Seibel：</b>除了它的发明者之外，E 有没有被其他人采用过？</p><p class="normal"><a></a><b>Seibel:</b> Did E ever have any adoption by anyone other than its inventors?</p>
<p class="normal"><b>Crockford：</b>不是原始语言。旧的 E 是 Java 方言。我们在这方面与 Sun 有各种各样的问题。然后我们提出了一种更轻量但具有相似属性的 E 脚本语言。这就是现在称为 E 的语言。</p><p class="normal"><b>Crockford:</b> Not the original language. The old E was a Java dialect. We had all sorts of problems with Sun about that. We then came up with an E scripting language that was lighter but had similar properties. And that is the language which is now called E.</p>
<p class="normal">我们在 Electric Communities 开发了这种语言，但我认为我们从未使用过它。但有一次我们决定不使用它，但它是个好东西，所以我们将它拆分出来，我真的很高兴看到它幸存下来。</p><p class="normal">We developed that language at Electric Communities but I don't think we ever made use of it. But at one point we decided that we weren't using it, but it was good stuff so we spun it out and I'm really happy to see that it survived.</p>
<p class="normal">在 Electric Communities 工作对我有好处的一件事是它教会了我从闭包的角度思考问题。所以当我开始做 web 的东西时，我看着 JavaScript 说，“这有一些熟悉的东西。” 因为很多 JavaScript 的遗产都来自于 Scheme，但是你查看文档并没有任何内容告诉你语言中有闭包。所以我有点偶然发现了它然后去了，“哇！这很棒。” 我一直在宣传这样的想法，即您实际上可以用这种愚蠢的小语言进行严肃的编程。</p><p class="normal">One of the things that was good for me in being at Electric Communities is it taught me to think in terms of closures. So when I started doing web stuff I looked at JavaScript and said, “There's something familiar about this.” Because a lot of JavaScript's heritage comes from Scheme but you look at the documentation and there's nothing there that tells you that there are closures in the language. So I kind of discovered it by accident and went, “Whoa! This is great.” And I've been promoting that idea that you can actually do serious programming in this silly little language.</p>
<p class="normal"><b>Seibel：</b>这让我们想到了最近关于 ECMAScript 4 的争论。我猜你喜欢 ES3 版本的 JavaScript 的简单性。</p><p class="normal"><b>Seibel:</b> So that sort of brings us to the recent controversy about ECMAScript 4. I gather that you like the simplicity of the ES3 version of JavaScript.</p>
<p class="normal"><b>克罗克福德：</b>嗯，归根结底，你对语言所做的改变的重要性与语言的成功有关。语言越成功，改变它的成本就越大。你有更大的再教育成本，你有潜在的破坏成本，随着你变得更大，这些成本变得不可接受。当你真正成功时，你需要对你所做的任何改变都非常谨慎。而如果你还没有成功，你有更多的自由来改变它。</p><p class="normal"><b>Crockford:</b> Well, ultimately, the significance of the changes you can make to a language is related to the success of the language. The more successful the language is, the greater the cost of changing it. You have greater re-education costs and you have the potential costs of disruption which, as you become bigger, become unacceptable. When you're really successful, you need to be extremely cautious in any changes that you make. Whereas if you haven't made it yet, you have a lot more freedom in changing it around.</p>
<p class="normal">纯属偶然的 JavaScript 成为了世界上最流行的编程语言。到目前为止，世界上的 JavaScript 处理器比任何其他语言都多。尽管它的安全模型存在所有问题，但 JavaScript 是唯一一种您可以编写代码并在任何机器上运行的语言。</p><p class="normal">JavaScript, purely by accident, has become the most popular programming language in the world. There are more JavaScript processors in the world than any other language by far. And for all of its problems with its security model, JavaScript is the only language where you can write code and run it on any machine.</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_97"></a>如果这还不够，它现在正被嵌入到许多应用程序中。大多数 Adob​​e 应用程序中都包含 JavaScript，因此您可以在本地编写脚本。以及其他应用程序。所以它变得非常流行。</p><p class="normal"><a></a>And if that weren't enough, it's now being embedded in a lot of applications. Most of the Adobe applications have JavaScript in them so you can script them locally. And other applications as well. So it's become hugely popular.</p>
<p class="normal">该语言的问题在于它被推向市场的速度太快，标准化的速度也太快了。所以它的大部分缺陷不在当前的实现中——它们在规范中。标准说<i>这样做不正确</i>。这太可怕了。但这就是它的状态。它在 1999 年被冻结，然后应该被忽视并死亡。但是，意外地，Ajax 出现了，它突然成为世界上最重要的编程语言。</p><p class="normal">The problem with the language is that it was rushed to market way too fast and standardized way too fast. So most of its defects are not in the current implementations—they are in the specification. The standard says <i>do this incorrectly</i>. Which is appalling. But that's the state of it. It got frozen in 1999 and then should have gone into neglect and died. But instead, by accident, Ajax happened and suddenly it's the world's most important programming language.</p>
<p class="normal">所以现在我们认为我们需要修复它。但是修好的时间应该是2000年的时候。但是那个时候没有修，当时大家都不重视。现在它很大。</p><p class="normal">So now we're thinking that we need to fix it. But the time to have fixed it should have been in 2000. But it didn't get fixed then, back when everyone was paying no attention to it. Now it's huge.</p>
<p class="normal">Web 上下文中的 JavaScript 还有另一件奇怪的事情：如果您正在开发服务器应用程序、桌面应用程序或嵌入式应用程序，您不仅要选择语言，还要选择要使用的特定编译器、特定的编译器。您将要使用的运行时。在 JavaScript 中你没有这样的选择。你必须运行那里的一切。</p><p class="normal">There's another thing that's odd about JavaScript in the web context: If you're doing a server application or a desktop application or an embedded application, you get to choose not only the language but which specific compiler you're going to use, which specific runtime you're going to use. You don't get that choice in JavaScript. You have to run on everything that's out there.</p>
<p class="normal">因为我们必须运行所有东西，所以错误不会得到修复。如果浏览器制造商发布了一个错误并说，“糟糕，我们搞砸了”，而下个月他们发布了另一个错误，我们不能指望他们的所有用户都进行升级。主流，一旦他们在他们的机器上安装了 IE，就是这样；他们不升级。这些错误会在那里停留多年。</p><p class="normal">Because we have to run on everything, bugs don't get fixed. If a browser maker ships a bug and goes, “Oops, we screwed up,” and the next month they ship another one, we cannot depend on all of their users doing the upgrade. The mainstream, once they get IE installed on their machine, that's it; they don't upgrade. Those bugs stay there for years.</p>
<p class="normal"><b>Seibel：</b>这就是目前的情况。然而，您希望 Web 成为开发应用程序的更好平台。如果我们不能解决我们遇到的问题，除非所有的浏览器都修复它，即使那样也无济于事，我们就会陷入困境。前进的方向是什么？</p><p class="normal"><b>Seibel:</b> So that's the current situation. Yet you want the Web to be a better platform for developing applications. If we can't fix the problems we have unless all the browsers fix it and even that doesn't help, we're just stuck. What's the way forward?</p>
<p class="normal"><b>克罗克福德：</b>这就是我挣扎的地方。我能看到理想。我知道它需要什么。我知道我们在哪里，我可以看到路上的所有障碍。所以我想弄清楚我们如何推进这一点。从某种意义上说，我们陷入了一个陷阱，因为我们已经开发了这些庞大的系统——我更关心经济系统和社会系统，但是<a id="OEBPS/Chapter03.html.page_98"></a>还有技术系统——依赖于这个没有经过深思熟虑的系统。</p><p class="normal"><b>Crockford:</b> That's the thing I struggle with. I can see the ideal. I know what it needs to be. And I know where we are and I can see all the obstructions in the way. And so I'm trying to figure out how do we take this forward. We're in a trap, in a sense, in that we have developed these huge systems—I'm more concerned with the economic systems and the social systems, but <a></a>also the technological systems—that are dependent on this system which was not thought through very well.</p>
<p class="normal">毫无疑问，JavaScript 最糟糕的特性是它对全局对象的依赖。它没有链接器，它没有任何类型的信息隐藏在编译单元之间。所有这些都被一起转储到一个通用的全局对象中。所以所有组件都能看到其他一切；所有组件对 DOM 都有平等的访问权限；他们都可以平等地访问网络。如果任何脚本进入您的页面，它可以转到服务器并将其自身表示为您的脚本，服务器绝对无法分辨出差异。</p><p class="normal">The worst feature of JavaScript, without question, is its dependence on a global object. It doesn't have linkers, it doesn't have any kind of information hiding between compilation units. It all gets dumped together into a common global object. So all the components see everything else; all the components have equal access to the DOM; they all have equal access to the network. If any script gets onto your page it can go to the server and represent itself as your script and there's absolutely no way the server can tell the difference.</p>
<p class="normal">它可以访问屏幕；它可以交给用户并将自己表示为您的脚本，而用户无法区分。如果页面来自您的服务器并且所有脚本无论来自何处都具有相同的权限，那么他们在 chrome 中放置的所有新的反网络钓鱼功能都不起作用。</p><p class="normal">It has access to the screen; it can go to the user and represent itself as your script and the user can't tell the difference. All of the new antiphishing things that they're putting in the chrome don't work if the page came from your server and all scripts come with the same authority no matter where they came from.</p>
<p class="normal">但它甚至比这更糟糕，因为脚本可以通过其他方式进入您的页面。Web 的体系结构中包含多种语言——HTTP、HTML、URL 是一种语言、CSS 和脚本语言。它们都在那里，它们都可以相互嵌入，它们都有不同的引用、转义和注释约定。而且它们并没有在所有浏览器中一致地实现。其中一些没有在任何地方指定。因此，作恶者真的很容易获取一些脚本并将其放入 URL，将其放入一种样式并将其放入某些 HTML 并将其放入另一个脚本，等等。</p><p class="normal">But it's even worse than that because there are other ways that script can get onto your page. The architecture of the Web has several languages in it—there's HTTP, there's HTML, URLs are a language, there's CSS, and there's the scripting language. They're all in there and they can all be embedded in each other and they all have different quoting and escaping and commenting conventions. And they are not consistently implemented in all of the browsers. Some of them are not specified anywhere. So it's really easy for an evildoer to take some script and put it in a URL, put it in a piece of style and put that in some HTML and put that in another script, and so on.</p>
<p class="normal"><b>Seibel：</b>那些是典型的跨站点脚本攻击，利用了浏览器中的错误。</p><p class="normal"><b>Seibel:</b> Those are the classic cross-site scripting attacks, taking advantage of bugs in the browser.</p>
<p class="normal"><b>克罗克福德：</b>对。那太糟了; 我们必须解决这个问题——我们无法忍受继续这样下去。</p><p class="normal"><b>Crockford:</b> Right. That's horrible; we have to fix that—it's intolerable that we keep going this way.</p>
<p class="normal">除此之外，我们还发现了混搭。混搭实现了我们 20 年来一直在软件中尝试做的事情：拥有有趣的可重用组件，我们可以像乐高积木一样拼凑在一起，并立即从中制作出新的应用程序。我们正在混搭中做这些事情，它是<a id="OEBPS/Chapter03.html.page_99"></a>太棒了，你可以从 Yahoo! 谷歌的东西，你的东西，别人的东西，把它们放在一起做一个应用程序，这很棒。而这一切都发生在浏览器上，就在您眼前。除了这些组件中的每一个都可以访问相同的东西。所以现在我们有意创建 XSS 漏洞。并且浏览器的安全模型没有预料到任何这种好处，也没有提供任何允许相互怀疑合作的方式。整个网络都是建立在一个又一个错误之上的。我们有一大堆事故。</p><p class="normal">On top of that we've discovered mash-ups. And mash-ups realize something that we've been trying to do in software for 20 years: to have interesting reusable components that we can snap together like LEGO and make new applications out of, instantly. And we're doing that stuff in mash-ups and it's <a></a>brilliant, where you can take something from Yahoo! and something from Google and something of yours and something of someone else's and put them all together and make an application, and it's great. And it all happens on the browser, right in front of your eyes. Except that each of those components has access to the same stuff. So now we are intentionally creating XSS exploits. And the browser's security model did not anticipate any of this goodness and does not provide any way of allowing for cooperation with mutual suspicion. The whole Web is built on one mistake after another. We have this big pile of accidents.</p>
<p class="normal"><b>Seibel：</b>那么考虑到所有这些，ES4 努力的成本是否只是机会成本，每个人都会花时间思考这个问题而不是用某种方法来解决这些问题？</p><p class="normal"><b>Seibel:</b> So given all that, is the cost of the ES4 effort just the opportunity cost, that everyone is going to spend time thinking about that instead of some way to fix these problems?</p>
<p class="normal"><b>克罗克福德：</b>对。它解决了错误的问题。它解决了人们讨厌 JavaScript 的问题。我很欣赏布伦丹·艾希 (Brendan Eich) 的职位，因为他做了一些出色的工作，但他仓促行事，而且管理不善，导致糟糕的事情泄露出去。在过去的十几年里，他一直被诅咒和诋毁，说他有多愚蠢，语言有多愚蠢，但这些都不是真的。实际上那里有才华，他是一个才华横溢的人。所以他现在正试图证明自己并证明，我真的是一个聪明人，我将用这种语言来展示它，它具有我所见过的每一个好的特性，我们将把它们放在一起，它会起作用的。</p><p class="normal"><b>Crockford:</b> Right. It's solving the wrong problem. It's solving the problem that people hate JavaScript. And I can appreciate Brendan Eich's position there because he did some brilliant work but he rushed it and he was mismanaged and so bad stuff got out. And he's been cursed and vilified for the last dozen years about how stupid he is and how stupid the language is and none of that's true. There's actually brilliance there and he's a brilliant guy. So he's now trying to vindicate himself and prove, I'm really a smart guy and I'm going to show it off with this language that has every good feature I've ever seen and we're going to put them all together and it's going to work.</p>
<p class="normal">我认为这不是我们现在需要解决的问题。我认为我们需要解决的问题是：网络坏了，我们需要修复它。因此，我们需要找出前进的方法。我对 Brendan 试图做的事情的最大反对意见是它会分散注意力。</p><p class="normal">I don't think that's the problem we need to be solving right now. I think the problem we need to be solving is: The Web is broken and we need to fix it. So we need to figure out a way to go forward. And my biggest objection with what Brendan is trying to do is it's a distraction.</p>
<p class="normal">我正在逐步研究这些东西。如果我们能得到一个模块；如果我们可以选择编程语言，我们就已经向前迈进了一步。我们还没有完成，但我们的状态比现在好得多。还有像 Caja 和 ADsafe 这样的东西正在尝试使用当今的技术来做到这一点。我们等不及了。</p><p class="normal">I'm looking at this stuff incrementally. If we can get a module; if we can get a choice of programming language, we've gone way forward. We're still not done yet, but we're in much better shape than we are now. Then there are things like Caja and ADsafe which are trying to do that using today's technology. We can't wait.</p>
<p class="normal">ADsafe 所做的是创建 JavaScript 的安全子集。所以它不允许访问任何全局的和任何危险的东西。事实证明，该子集中仍有一种有用的语言。因为所有的 lambda<a id="OEBPS/Chapter03.html.page_100"></a>力量在那里。lambda 可以做很多事情。所以它是一种非常规的语言，因为它不允许您以我们迄今为止的方式使用原型。但它是一种完整的 lambda 语言，非常强大。</p><p class="normal">What ADsafe does is it creates a safe subset of JavaScript. So it disallows access to anything that's global and anything that's dangerous. And it turns out there's still a useful language in that subset. Because all the lambda <a></a>power is there. And lambdas can do a lot. So it's an unconventional language because it doesn't let you use prototypes in the way we have up until now. But it's a full lambda language, so hugely powerful.</p>
<p class="normal"><b>Seibel：</b>撇开它可能解决了错误的问题不谈，仅从语言的角度来看，您是否喜欢 ES4 的任何部分？</p><p class="normal"><b>Seibel:</b> Leaving aside that it may be solving the wrong problem, are there any bits of ES4 that you like, just from a language point of view?</p>
<p class="normal"><b>Crockford：</b>我认为我们应该有一些很好的错误修复。但是语言中有太多东西没有被尝试过。我们对 ES3 的经验是，一旦规范中出现错误，就不可能将其删除。而且我们没有使用这种语言的经验。没有人用它编写过大型应用程序。</p><p class="normal"><b>Crockford:</b> There are some bug fixes that are good that I think we should have. But there's too much stuff in the language that hasn't been tried. And our experience with ES3 is that once an error gets into the spec, it's impossible to take it out. And we have no experience with this language. No one has ever written a big application with it.</p>
<p class="normal">在我们知道它有效之前，它将被标准化和部署。所以我认为我们这样做太快了。如果我们有多个参考实现，并且人们用它做有用的应用程序，然后说，好吧，这门语言似乎可以工作，我会舒服得多；现在让我们对其进行标准化，现在让我们在全球范围内部署它。我认为我们正在倒退。</p><p class="normal">It will be standardized and deployed before we know that it works. So I think we're doing this way too fast. I'd be much more comfortable if we had multiple reference implementations and people doing useful applications with it and then go, OK, the language seems to work; now let's standardize it, now let's deploy it worldwide. I think we're doing it all backwards.</p>
<p class="normal"><b>Seibel：</b>所以 Google 的 GWT 将 Java 编译成 JavaScript。其他人也尝试过将其他语言编译为 JavaScript。这是前进的道路吗？</p><p class="normal"><b>Seibel:</b> So Google's GWT compiles Java into JavaScript. And other folks have played around with compiling other languages to JavaScript. Is that a path forward?</p>
<p class="normal"><b>Crockford：</b>看到 JavaScript 变成通用运行时有点有趣。这不是我们所期望的角色。</p><p class="normal"><b>Crockford:</b> It's sort of interesting to see JavaScript turning into the universal runtime. That's not a role we ever expected for it.</p>
<p class="normal"><b>Seibel：</b>但是，正如您所说，它无处不在；它<i>是</i>通用运行时。</p><p class="normal"><b>Seibel:</b> But, as you said, it's everywhere; it <i>is</i> the universal runtime.</p>
<p class="normal"><b>Crockford：</b>我认为这给让 JavaScript 快速运行带来了更大的压力。特别是当我们现在进入移动领域时。摩尔定律不适用于电池。因此，我们在解释内容上浪费了多少时间真的很重要。循环计数。所以我认为这会给提高运行时质量带来更多压力。</p><p class="normal"><b>Crockford:</b> Which I think puts even more pressure on getting JavaScript to go fast. Particularly as we're now going into mobile. Moore's law doesn't apply to batteries. So how much time we're wasting in interpreting stuff really matters there. The cycles count. So I think that's going to put more pressure on improving the quality of the runtime.</p>
<p class="normal">就 GWT 和其他变革性事物而言，我非常务实。这种环境很难工作——如果你能找到有用的东西，那就太好了。我害怕自己使用它，因为我担心抽象泄漏。如果您的 Java 代码或 GWT 或它在另一端生成的内容有问题，您可能有也可能没有地方<a id="OEBPS/Chapter03.html.page_101"></a>站起来处理那个。特别是如果你采用了完全不了解 JavaScript 的方法，因为这门语言对你是隐藏的。如果出现任何问题，您将陷入受伤的世界。我没有听说过任何人发生过这种情况，所以，到目前为止，他们似乎做对了。但存在这种风险。</p><p class="normal">As far as GWT goes, and other transforming things, I'm really pragmatic. This environment is so hard to work in—if you can find something that works, then great. I'm fearful of using it myself because I worry about the abstraction leakage. If there's a problem in your Java code or in GWT or in what it produces on the other side, you may or may not have a place to <a></a>stand to deal with that. Particularly if you took the approach that you can afford to be completely ignorant about JavaScript because the language is hidden from you. Then you're going to be in a world of hurt if anything goes wrong. I hadn't heard of that happening to anybody, so, so far they appear to be doing it right. But there is that risk.</p>
<p class="normal"><b>Seibel：</b>您希望 JavaScript 发生什么？</p><p class="normal"><b>Seibel:</b> What would you like to see happen with JavaScript?</p>
<p class="normal"><b>Crockford：</b>我认为让 JavaScript 变得更好的最好方法是让它变得更小。如果我们能把它归结为它真正擅长的地方，并删除那些增加很少或没有价值的特性，它实际上是一种更好的语言。我认为我们可以将这种方法用于 HTML；我认为我们可以将这种方法用于 HTTP 和 CSS。我认为我们正在使用的所有标准，我们需要弄清楚它们在哪些方面做对了，哪些方面做得不好，并重新调整它们的重点，而不是仅仅在上面堆砌新功能。</p><p class="normal"><b>Crockford:</b> I think the best way to make JavaScript better would be to make it smaller. If we could just get it down to what it does really well and remove the features that add little or no value, it's actually a better language. And I think we can take that approach to HTML; I think we can take that approach to HTTP and to CSS. I think all of the standards that we're working with, we need to figure out what do they do right and what is it missing and refocus them, rather than just piling new features on top.</p>
<p class="normal"><b>Seibel：</b>然而，小巧、优雅的珠宝与庞大、实用的泥球之间往往存在着紧张关系。一个小而完美的珠宝很容易理解，它没有瑕疵，但你必须在它上面建造更多的东西才能做任何事情。所以每个人都一遍又一遍地重新实现相同的东西，这导致了一种不同的膨胀和丑陋。</p><p class="normal"><b>Seibel:</b> Yet there's often a tension between small, elegant jewels and sprawling, practical balls of mud. A small, perfect jewel is easy to understand and it doesn't have warts but then you have to build more stuff on top of it to do anything. So everybody reimplements the same things over and over and that leads to a different kind of bloat and ugliness.</p>
<p class="normal"><b>克罗克福德：</b>但事实并非如此。我们有许多 Ajax 库开发人员正在这样做，其中一些人在使用该语言方面变得非常成熟。然后那里的社区在它之上构建草率的东西并且这是有效的。因此，并非每个应用程序程序员都必须了解如何充分利用 lambda 才能利用该语言的 lambda 特性。所以我们已经在这样做了。我们不需要为了解决这个问题而放弃该语言——这不是它坏掉的地方。</p><p class="normal"><b>Crockford:</b> But that's not what's happening. We have a number of Ajax library developers who are doing that and some of them are getting very sophisticated in their use of the language. And then the communities out there are building sloppy stuff on top of it and that's working. So it's not necessary for every application programmer to understand how to fully exploit lambda in order to take advantage of the lambda nature of the language. So we're already doing that. We don't need to abandon the language in order to fix that—that's not where it's broken.</p>
<p class="normal">我们确实遇到的问题是 Ajax 库太多。这是因为 JavaScript 如此强大，需求如此深远，而且它们很容易制作。所以有一段时间每个人都在制作它们。我一直期待我们会进行一次重组，但它还没有发生。所以我们仍然有很多图书馆。所以我们现在有另一个问题——因为有太多的库可供选择，开发人员不知道该使用哪个。我认为最终会有一次洗牌。</p><p class="normal">Where we do have a problem is that there are too many Ajax libraries. That was a consequence of the fact that JavaScript is so powerful and the need is so profound and that they're easy to make. So for a while everybody was making them. I've been expecting that we're going to have a shake-out but it hasn't happened yet. So we still have a whole lot of libraries. So we have an alternative problem now—because there are so many libraries to choose from, developers don't know which one to use. I think there will be a shake-out eventually.</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_102"></a>我们现在看到的一件事是 Ajax 库正在融合。jQuery 想出了一个符号，使用 CSS 选择器从 DOM 中获取对象列表，然后提供对对象进行整体操作的方法。事实证明这是一个非常好的主意，而且 JavaScript 非常有效地做到了这一点。那里的效率低下，因为 DOM 的接口很糟糕，但它们隐藏了所有内容。他们确实简化了编程模型——非常棒。</p><p class="normal"><a></a>One thing that we're seeing now is that the Ajax libraries are converging. jQuery came up with a notation for using CSS selectors for getting a list of objects from the DOM and then providing methods for manipulating the objects en masse. And that turns out to be a really good idea and it's something that JavaScript does very effectively. There's an inefficiency there in that the interface to the DOM is horrible but they hide it all. They've really simplified the programming model—it's brilliant.</p>
<p class="normal">所以现在每个人都在这样做——我们看到了功能融合。这让用户社区的问题变得更加困难，因为这使得决定使用哪个库变得更加困难，因为它们都变得越来越相似。但最终他们会合并成一对，也许是一个。我一直在预测，赢家之一将是拥有 Atlas 框架的 Microsoft，因为 Microsoft 始终是赢家之一。但他们似乎并没有受到关注。开放框架似乎做得更好。所以我预计一两个开放框架最终会获胜。</p><p class="normal">So everybody's doing that now—we're seeing feature convergence. Which makes the problem even harder for the user community because it makes it harder to decide which library to use because they're all becoming more similar. But eventually they're going to coalesce down to a couple, maybe one. I had been predicting that one of the winners was going to be Microsoft with their Atlas framework, just because Microsoft is always one of the winners. But they don't appear to be getting traction. The open frameworks seem to be doing much better. So I'm expecting one or two of the open frameworks will ultimately win.</p>
<p class="normal"><b>Seibel：</b>现在你是 Yahoo! 的 JavaScript 架构师和布道者，所以你的部分工作大概就是告诉 Yahoo! JavaScript 程序员，“这是你应该怎么做。” 您的工作是否还包括一般良好设计实践和良好编码实践？</p><p class="normal"><b>Seibel:</b> These days you're a JavaScript architect and evangelist here at Yahoo!, so part of your job, presumably, is to tell Yahoo! JavaScript programmers, “Here's how you should do it.” Does your job also cover general good design practice and good coding practice?</p>
<p class="normal"><b>Crockford：</b>我一直在推动的事情之一是代码阅读。我认为这是程序员社区可以为彼此做的最有用的事情——定期花时间阅读彼此的代码。项目管理中有一种趋势，就是让程序员独立工作，然后我们进行大合并，如果它构建了，我们就会发布它，我们完成了，我们就忘记了它。</p><p class="normal"><b>Crockford:</b> One of the things I've been pushing is code reading. I think that is the most useful thing that a community of programmers can do for each other—spend time on a regular basis reading each other's code. There's a tendency in project management just to let the programmers go off independently and then we have the big merge and if it builds then we ship it and we're done and we forget about it.</p>
<p class="normal">这样做的后果之一是，如果您有软弱或困惑的程序员，您直到为时已晚才意识到他们的实际情况。因此，项目的风险，你将不得不用不好的东西来构建，以及由此导致的延误，这是不可接受的。另一件事是，您的项目中可能有出色的程序员，但他们没有充分指导团队中的其他人。代码阅读解决了这两个问题。</p><p class="normal">One of the consequences of that is that if you have weak or confused programmers you're not aware of their actual situation until much too late. And so the risks to the project, that you're going to have to build with stuff that's bad and the delays that that causes, that's unacceptable. The other thing is that you may have brilliant programmers on the project who are not adequately mentoring the other people on the team. Code reading solves both of those problems.</p>
<p class="normal"><b>Seibel：</b>您能谈谈您是如何进行代码阅读的吗？</p><p class="normal"><b>Seibel:</b> Can you talk a bit about how you conduct a code reading?</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_103"></a><b>Crockford：</b>在每次会议上，有人负责阅读他们的代码，他们会引导我们完成所有事情，而我们其他人会观察。对于团队的其他成员来说，这是一个很好的机会来了解他们的东西将如何与那些东西相适应。</p><p class="normal"><a></a><b>Crockford:</b> At each meeting, someone's responsible for reading their code, and they'll walk us through everything, and the rest of us will observe. It's a really good chance for the rest of the team to understand how their stuff is going to have to fit with that stuff.</p>
<p class="normal">我们让每个人都围坐在桌子旁；每个人都得到一叠纸。我们也在屏幕上放大它。我们一起通读了它。我们都在对代码进行评论。人们会说，“我不明白这个注释”，或者“这个注释似乎没有描述代码”。这类东西之所以如此有价值，是因为作为一名程序员，您不再阅读自己的评论，而且您没有意识到自己在误导读者。让与你一起工作的人帮助你保持代码清洁是一项巨大的服务——你会发现你自己永远不会发现的缺陷。</p><p class="normal">We get everybody around the table; everybody gets a stack of paper. We also blow it up on the screen. And we all read through it together. And we're all commenting on the code as we go along. People say, “I don't understand this comment,” or, “This comment doesn't seem to describe the code.” That kind of stuff can be so valuable because as a programmer you stop reading your own comments and you're not aware that you're misdirecting the reader. Having the people you work with helping to keep your code clean is a huge service—you find defects that you never would've found on your own.</p>
<p class="normal">我认为一个小时的代码阅读值得两周的质量检查。这只是消除错误的一种真正有效的方法。如果你有一个阅读能力很强的人，那么他们周围的新手将会学到很多他们不会学到的东西，如果你有一个阅读新手，他会得到很多非常好的建议。</p><p class="normal">I think an hour of code reading is worth two weeks of QA. It's just a really effective way of removing errors. If you have someone who is strong reading, then the novices around them are going to learn a lot that they wouldn't be learning otherwise, and if you have a novice reading, he's going to get a lot of really good advice.</p>
<p class="normal">它不应该是我们为了最后而保存的东西。在过去，我们会在完成一个项目时安排一次代码阅读，而且通常会因为我们迟到而取消。我现在认为代码阅读应该贯穿项目的整个生命周期。这是我花了一段时间才弄清楚的事情，但它有很多好处。</p><p class="normal">And it shouldn't be something that we save for the end. Back in the old days, we would schedule a code reading just as we were finishing a project and usually it would be canceled because we were late. I now believe that code reading should be happening all the time throughout the life of the project. That's something that took me a while to figure out but there are so many benefits that come from that.</p>
<p class="normal">一方面，它可以更轻松地跟踪项目，因为我们实际上可以看到人们取得的进展。我们可以更快地看到他们是否会偏离轨道。</p><p class="normal">For one thing it makes it easier to track the project, because we can actually see what progress people are making. And we can see much sooner if they're going off the rails or not.</p>
<p class="normal">我曾管理过一些项目，在截止日期前我们有人说，“是的，我快完成了，”然后你得到了代码，但那里什么也没有，或者是废话，或者其他什么，他们离完成还差得很远。在管理中，这些是你最讨厌的经历，我认为阅读代码是避免陷入困境的最好方法。</p><p class="normal">I've managed projects where we're up against a deadline and we had people saying, “Yeah, I'm almost done,” and then you get the code, and there's nothing there, or it's crap, or whatever, and they're nowhere close to done. In management, those are the experiences you hate the most and I think code reading is the best way of not getting trapped like that.</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_104"></a><b>Seibel：</b>假设我们正在对我的一些代码进行代码阅读。我带来了打印输出，我们把它放在屏幕上。然后呢？我真的大声朗读了吗？</p><p class="normal"><a></a><b>Seibel:</b> So say we're doing a code reading of some of my code. I bring printouts and we put it up on the screen. Then what? Do I literally read it out loud?</p>
<p class="normal"><b>克罗克福德：</b>是的，逐行检查它，然后您将对其进行评论。这就是这里应该发生的事情。如果我们有时间，我们会逐行进行。</p><p class="normal"><b>Crockford:</b> Yeah, go through it line by line, and you'll be doing commentary on it. This is what's supposed to be happening here. If we have time, we'll go line by line.</p>
<p class="normal"><b>Seibel：</b>你觉得你必须教人们如何阅读代码吗？我可以想象，在不让代码的作者感到受到人身攻击的情况下，很难找到足够关键的正确平衡点。</p><p class="normal"><b>Seibel:</b> Do you find that you have to teach people how to do code readings? I can imagine it'd be hard to find the right balance of being critical enough to be worthwhile without making the code's author feel personally attacked.</p>
<p class="normal"><b>克罗克福德：</b>是的，这需要团队成员之间的高度信任，因此必须有明确的规则来规定什么在界限内，什么在界限外。如果你有一个功能失调的团队，你不想这样做，因为他们会把自己撕成碎片。如果你有一个功能失调的团队并且你没有意识到这一点，这将很快揭示它。您可以学到很多东西，这个过程揭示了很多东西。一开始感觉很不自然，但一旦你进入它的节奏，就会感觉非常自然。</p><p class="normal"><b>Crockford:</b> Yeah, it requires a lot of trust on the part of the team members so there have to be clear rules as to what's in bounds and what's not. If you had a dysfunctional team, you don't want to be doing this, because they'll tear themselves apart. And if you have a dysfunctional team and you're not aware of it, this will reveal it pretty quickly. There's a lot that you can learn, a lot that's revealed by this process. It feels unnatural at first, although once you get into the rhythm of it, it feels extremely natural.</p>
<p class="normal">另一个方面是编写您的代码，使其可以被阅读。整洁很重要，事实证明，风格很重要。所有这些都将提高代码库的质量，并提高编程社区的能力。</p><p class="normal">Another aspect is writing your code such that it can be read. Neatness counts, as it turns out, and style is important. And all of those things will increase the quality of the code base going forward and increase the competence of the programming community.</p>
<p class="normal"><b>Seibel：</b>是什么让代码对您来说可读？</p><p class="normal"><b>Seibel:</b> What makes code readable for you?</p>
<p class="normal"><b>Crockford：</b>它发生在多个层面。最简单的就是在演示文稿中保持一致，因此您始终正确地缩进所有内容；你在所有正确的地方都有空白。我仍然有一个习惯，这是我在 Fortran 时代学到的，我倾向于使用太多的单字母变量名，我认为这是一件坏事。我真的很努力地想打破它，但这很困难——这仍然是我挣扎的事情。</p><p class="normal"><b>Crockford:</b> It happens at a number of levels. The simplest is just being consistent in the presentation so you always indent everything properly; you have white space in all the right places. One habit that I still struggle with, something I learned back in the Fortran days, is I tend to use too many one-letter variable names, which I believe is a bad thing. And I'm trying really hard to break it, but it's difficult—it's still something I struggle with.</p>
<p class="normal"><b>Seibel：</b>有多难？您是否编写了代码，然后回过头来说，“哦，看看所有这些单字符变量名”？</p><p class="normal"><b>Seibel:</b> How hard is it? Do you write the code and then you come back later and say, “Oh, look at all these one-character variable names”?</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_105"></a><b>克罗克福德：</b>我认为是一封信。同样在 JavaScript 中，有一个站不住脚的效率论点，即您实际上是在为这些额外字符的下载成本付费，因此您可以通过使变量名更小来使程序更小。</p><p class="normal"><a></a><b>Crockford:</b> I think in terms of one letter. Also in JavaScript, there's an indefensible efficiency argument that you're actually paying for the download cost of those extra characters, and so you can make programs smaller by making your variable names smaller.</p>
<p class="normal"><b>Seibel：</b>有一些工具，对吧？</p><p class="normal"><b>Seibel:</b> There are tools for that, right?</p>
<p class="normal"><b>Crockford：</b>好吧，你可以 gzip 它，几乎把它全部取出来，所以我没有防御。当我回顾我的旧代码时，我发现名称太短，如果我有时间，我会更改它们。有些东西，比如我的循环计数器，可能永远都是<code>i</code>. 我不认为我会解决这个问题，但还有很多其他问题是不可原谅的。</p><p class="normal"><b>Crockford:</b> Well, you can gzip it and that pretty much takes it all out, so I have no defense. When I'm going back through my old code and I see the names are too short, if I have time, I'll change them. Some things, like my loop counters, will probably always be <code>i</code>. I don't think I'll ever fix that, but there are a lot of others that are just inexcusable.</p>
<p class="normal">这是第一层，语法方面的东西。这类似于用英语或任何语言写作，正确使用标点符号，正确使用大写字母，将逗号放在正确的位置。然后你开始看更高层次的东西，比如你如何组织句子以及你在哪里打破段落。在编程语言中，它采取的形式是如何将问题分解为一组函数或一组类？</p><p class="normal">That's the first level, the grammatical stuff. It's similar to writing in English or any language, getting the punctuation right, getting the capitalization right, putting the commas in the right place. Then you start looking at higher-level things like how you structure the sentences and where you break the paragraphs. In a programming language, it takes the form of how do you decompose the problem into a set of functions or a set of classes?</p>
<p class="normal"><b>Seibel：</b>为了使代码可读，程序员应该关注哪些具体的事情？</p><p class="normal"><b>Seibel:</b> What are the concrete things that programmers should focus on to make their code readable?</p>
<p class="normal"><b>Crockford：</b>子集的想法非常重要，尤其是对于 JavaScript，因为它包含了很多不好的特性。但它适用于所有语言。当我还是一名熟练工时，我会阅读语言手册，并且会理解每个功能。我会弄清楚如何使用它们。我会一直使用它们。事实证明，其中很多都没有经过深思熟虑。</p><p class="normal"><b>Crockford:</b> The subset idea is really important, especially for JavaScript because it contains so many bad features. But it's true for all languages. When I was a journeyman, I would read the language manual and I would understand every feature. And I would figure out how to use them all. And I'd use them all all the time. It turns out a lot of them were not well thought through.</p>
<p class="normal">我现在回想起 Fortran，但所有语言都是如此。有时语言设计者会弄错。从我现在的角度来看，C 有一大堆错误。</p><p class="normal">I'm thinking back to Fortran now, but it was true in all languages. Sometimes language designers get it wrong. C has a whole bunch of errors in it, from my perspective now.</p>
<p class="normal"><b>Seibel：</b>比如说？</p><p class="normal"><b>Seibel:</b> For instance?</p>
<p class="normal"><b>Crockford：</b>就像将 fall-through 作为默认值的 switch 语句是错误的——他们不应该那样做。<code>++</code>有巨大的安全问题——它鼓励你太狡猾，试图在<a id="OEBPS/Chapter03.html.page_106"></a>一条线。在一行中完成它的冲动中，您编写的代码很难理解并且可能导致诸如缓冲区溢出错误之类的事情。因此，过去几年我们在操作系统中看到的大多数安全问题都是<code>++</code>.</p><p class="normal"><b>Crockford:</b> Like the switch statement having fall-through be the default was wrong—they shouldn't have done that. <code>++</code> has huge security problems—it encourages you to be way too tricky, to try to do too much in <a></a>one line. In that compulsion to do it in one line, you make code which is hard to understand and which is likely to lead to things like buffer overrun errors. So most of the security problems that we've seen in operating systems over the last few years are a consequence of <code>++</code>.</p>
<p class="normal">在我的编程风格中，我现在<code>++</code>不再<i>使用</i>. 我可以证明在这里使用它是好的，在那里使用它是不好的，但我很难在我的代码中找到好的部分和坏的部分。</p><p class="normal">In my programming style now I don't use <code>++</code> anymore, <i>ever</i>. I can make the case that it's good to use it here and it's bad to use it there but it's hard for me to find the good pieces and the bad pieces in my code.</p>
<p class="normal"><b>Seibel：</b>难道不能说安全问题真的与未经检查的数组边界或原始指针<code>++</code>无关吗？<code>++</code>这在 Java 中不是安全风险，因为如果你<code>++</code>离开数组的末尾，你只会得到一个异常。</p><p class="normal"><b>Seibel:</b> Couldn't one argue that the security problem with <code>++</code> really has nothing to do with <code>++</code> but with unchecked array bounds or raw pointers? It isn't a security risk in Java because if you <code>++</code> off the end of the array you just get an exception.</p>
<p class="normal"><b>Crockford：</b>是的，在 Java 中肯定没有那么危险。而这种危险在 JavaScript 中根本不存在，因为它没有数组。但即便如此，我发现当我停止这样做时，我的代码质量变得更好，只是因为它邀请我写单行代码，而这通常是一个坏主意。</p><p class="normal"><b>Crockford:</b> Yeah, it's certainly less dangerous in Java. And that danger doesn't exist at all in JavaScript because it doesn't have arrays. But even so, I found that the quality of my code got better when I stopped doing it, just because it invited me to write one-liners and that's usually a bad idea.</p>
<p class="normal">另一个例子是<code>continue</code>声明。我从未见过我无法通过采用<code>continue out</code>. 它使某些类型的复杂结构更容易编写。但我发现，如果我能找到分解结构的方法，我总能改进结构。因此，作为我个人纪律的一部分，我从不使用<code>continue</code>。如果我<code>continue</code>在我的代码中看到 a，那么我假设我没有仔细考虑过它。</p><p class="normal">Another example of that is the <code>continue</code> statement. I have never seen a piece of code that I could not improve by taking the <code>continue out</code>. It makes certain kinds of complicated structures easier to write. But I found that I can always improve the structure if I can find a way to factor it out. So as part of my personal discipline, I don't use <code>continue</code> ever. If I see a <code>continue</code> in my code, then I assume I haven't thought it through carefully.</p>
<p class="normal"><b>Seibel：</b>你如何阅读不是你写的代码？</p><p class="normal"><b>Seibel:</b> How do you read code you didn't write?</p>
<p class="normal"><b>Crockford：</b>通过清洁它。我会将其放入文本编辑器中，然后开始修复它。我要做的第一件事就是使标点符号一致；正确缩进；做所有这些事情。我有可以为我做这件事的程序，但我发现从长远来看，我自己做这件事更有效率，因为它让我更熟悉代码。晨星教我这样做。他在重构其他人的代码方面非常出色，这就是他采用的方法，我发现它很有效。</p><p class="normal"><b>Crockford:</b> By cleaning it. I'll throw it in a text editor and I'll start fixing it. First thing I'll do is make the punctuation conform; get the indentation right; do all that stuff. I have programs that can do that for me, but I find doing that myself is more efficient in the long run because it gets me more acquainted with the code. Morningstar taught me to do this. He's brilliant at refactoring other people's code and that's the approach he takes and I find it works.</p>
<p class="normal"><b>Seibel：</b>你有没有发现那个级别的代码是一团糟，然后你清理它并发现它实际上是好的代码？</p><p class="normal"><b>Seibel:</b> Have you ever found that code that was, at that level, a mess, then you cleaned it all up and discovered it was actually good code underneath?</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_107"></a><b>克罗克福德：</b>我从来没有真正看到过。我觉得草草写出好的代码真的很难。好的代码，我的意思是它是可读的。在某种程度上，如果我无法弄清楚它对机器做了什么，它对机器做了什么并不重要，所以它可能会证明代码在效率、紧凑性或其他一些指标方面是惊人的我不在乎。</p><p class="normal"><a></a><b>Crockford:</b> I've never actually seen that. I think it's really difficult to write good code in a sloppy manner. By good code, I mean it's going to be readable. At one level, it doesn't matter what it does to a machine if I can't figure out what it does, so it might turn out that the code is amazing in terms of its efficiency, or its compactness, or some other metric which I don't care about.</p>
<p class="normal">代码的可读性现在是我的首要任务。它比快速更重要，几乎与正确一样重要，但我认为可读性实际上是使其正确的最可能方式。所以我认为这可能不是好的代码，如果代码最终处于不易阅读的状态，他们可能会做出错误的权衡。</p><p class="normal">Readability of code is now my first priority. It's more important than being fast, almost as important as being correct, but I think being readable is actually the most likely way of making it correct. So I think it's probably not good code and they probably made the wrong trade-offs if the code turned out to be in the state that it's not easily readable.</p>
<p class="normal"><b>Seibel：</b>在内部循环的内部循环中它必须非常快怎么办？是否所有代码都是可读的，或者有时您必须牺牲可读性来提高效率？</p><p class="normal"><b>Seibel:</b> What about in the inner loop of the inner loop where it's just got to be blazing-fast? Can all code be readable or are there times when you must sacrifice readability to gain efficiency?</p>
<p class="normal"><b>克罗克福德：</b>我想，但我会在这两个方面写一本小说，并解释这就是为什么我们正在做我们正在做的事情。通常这会被排除在外。我还看到很多人在绝对不需要快速进行的情况下努力尝试使事情变得快速。他们不知道自己的程序是如何花费时间的，所以他们正在优化不需要优化的东西，而且这些东西永远不会大到足以通过这条路产生任何影响，所以没有回报，没有好处所有，因为已经完成了优化。所做的所有优化都是引入了 cruft。我看到了很多。</p><p class="normal"><b>Crockford:</b> I suppose, but I would write a novel on both ends of that and explain this is why we're doing what we're doing. Usually that gets left out. I also see a lot of folks struggling to try to make stuff fast in situations where it absolutely doesn't need to go fast. They're unaware of how their own program is spending its time and so they're optimizing things which don't require optimization and which will never be big enough going through that path to ever make any difference so there's no reward, no benefit at all, for having done that optimization. All the optimization did was introduce cruft. I see a lot of that.</p>
<p class="normal"><b>Seibel：</b>在大括号语言中，关于什么是放置大括号的正确位置存在无休止的宗教战争，人们争辩说一种风格或另一种风格更容易阅读。当您“清理”代码时，您所做的部分工作是否只是将其置于您易于吸收的形式中？</p><p class="normal"><b>Seibel:</b> In curly-brace languages, there are endless religious wars about what's the proper place to put the braces, and people argue that one style or the other makes it easier to read. Is part of what you're doing when you “clean up” code just putting it in the form that's easy for you to absorb?</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_108"></a><b>克罗克福德：</b>是的，当然，因为我相信我使用的是唯一正确的风格，而其他人都错了！我认为 Thompson 和 Ritchie 没有为 C 定义漂亮的打印演示文稿，这对世界造成了伤害。它可能会一直保持下去。</p><p class="normal"><a></a><b>Crockford:</b> Yeah, definitely, because I believe I'm using the only correct style and everybody else got it wrong! I think Thompson and Ritchie did the world a disservice by not defining the pretty-print presentation for C. Saying, “This is how we do it, but you can do it some other way,” has had a huge toll on humanity, and it will probably continue to always have one.</p>
<p class="normal"><b>Seibel：</b>所以你喜欢的风格是 K&amp;R？</p><p class="normal"><b>Seibel:</b> So your preferred style is K&amp;R?</p>
<p class="normal"><b>克罗克福德：</b>是的，我认为他们做对了。他们最初的风格是对的。特别是在 JavaScript 中。JavaScript 会插入分号，因此如果将大括号放在左边而不是右边，在某些地方程序的含义会发生非常糟糕的变化。事实证明，K&amp;R 风格不受此问题的影响，但齐平风格会。</p><p class="normal"><b>Crockford:</b> Yeah, I think they got it right. Their initial style is right. Particularly in JavaScript. JavaScript does semicolon insertion, and so there are places where the meaning of a program will change in a drastically bad way if you put the braces on the left instead of on the right. It turns out the K&amp;R style is not subject to that problem, but the flush style is.</p>
<p class="normal">所以我可以争论在 JavaScript 的情况下，绝对有放置大括号的正确方法。在其他 C 风格的语言中，我不能做同样的事情。有些人喜欢把他们的牙套齐平，我看到人们争论了几个小时关于哪种方式是正确的，而且任何一方的解释都没有任何意义，因为他们真正争论的是，我在学校使用的是什么，或者我在第一份工作中使用的东西，或者给我留下深刻印象的人使用的风格，现在对我来说是正确的，而其他一切看起来都是错误的。</p><p class="normal">So I can argue in the case of JavaScript, there absolutely is a correct way of placing the braces. In other C-flavored languages I can't make that same case. Some people like to have their braces flush and I've seen people argue for hours about which way is right, and none of the explanations make any sense on either side, because what they're really arguing is, what I used in school, or what I used at my first job, or the style that's used by someone who impressed me, now looks right to me and everything else looks wrong.</p>
<p class="normal">我想这类似于关于我们应该在街道左侧还是右侧行驶的争论。最终，以这种或另一种方式做这件事并不是一个好的案例。如果你住在一个岛上，你可能会以错误的方式行事，但这并不重要，但如果我们都能弄清楚如何在同一侧驾驶，最终社区会受益。</p><p class="normal">It's similar, I suppose, to an argument about, should we be driving on the left side of the street or the right. Ultimately there's not a good case for doing it one way or another. If you live on an island, you can do it the wrong way and it doesn't matter, but ultimately the community benefits if we can all figure out how to drive on the same side.</p>
<p class="normal"><b>Seibel：</b>所以，如果你换了工作，去了一个地方，那里的 C 或 Java 编程风格与你喜欢的风格不同，你会说，“好吧，我会换，我知道过一会儿，我会很乐意看到这种风格”？或者你干脆不接受这份工作？</p><p class="normal"><b>Seibel:</b> So if you changed jobs and went somewhere where they programmed C or Java in a different style than you prefer, would you say, “Well, I'll switch and I know that after a little bit, I'll be happy to see this style”? Or would you just not take the job?</p>
<p class="normal"><b>Crockford：</b>也许这是人们应该关注的东西——这里的时尚之家是什么？我们是在左边还是右边？也许不要去一个让他们站在错误一边的地方工作。它确实具有苏斯博士的品质，您会为自己的肚子上是否有星星而感到非常沮丧。最终你必须接受房子风格，你希望把房子风格放在一起的人知道他们在做什么。他们可能没有；也许没关系。更重要的是每个人都在同一页面上。</p><p class="normal"><b>Crockford:</b> Maybe that's something that people should look at—what is the house of style here? Are we on the left or the right? And maybe not go work at a place that gets them on the wrong side. It does take on a Dr. Seuss quality where you get really upset about whether you've got a star on your belly or not. Ultimately you have to embrace the house style and you hope that the people who put the house style together knew what they were doing. They probably didn't; maybe it doesn't matter. It's more important that everybody be on the same page.</p>
<p class="normal"><b>Seibel：</b>因此，当您阅读代码时，您会从排版清理开始，您重构事物的深度或戏剧性如何？</p><p class="normal"><b>Seibel:</b> So when you're reading code you start with a typographical cleanup, how deeply or dramatically do you refactor things?</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_109"></a><b>Crockford：</b>我将重新安排代码，以便在调用之前声明和设置所有内容。有些语言为您提供了很大的灵活性，因此您不必这样做。我不想要那种灵活性。</p><p class="normal"><a></a><b>Crockford:</b> I'll rearrange code so that everything is declared and set up before it's called. Some languages give you a lot of flexibility around that so you don't have to. I don't want that flexibility.</p>
<p class="normal"><b>Seibel：</b>所以你不需要前向引用？</p><p class="normal"><b>Seibel:</b> So you want no forward references?</p>
<p class="normal"><b>克罗克福德：</b>是的，或者如果有前向参考，我希望它是明确的。我不希望代码以任何随机顺序出现，除非我正在做一种有文化的编程，在这种编程中我明确地按照表示顺序而不是语言想要的顺序来破坏代码，我喜欢这样很多。但是除非你真的在使用识字工具，否则你不应该这样做。</p><p class="normal"><b>Crockford:</b> Right, or if there is a forward reference, I want it to be explicit. I don't want code to come in any random order unless I'm doing a literate programming thing in which I'm explicitly breaking the code in terms of a presentational order rather than the order that the language wants, and I like that a lot. But unless you're actually using literate tools, you shouldn't be doing that.</p>
<p class="normal"><b>Seibel：</b>在你的一次演讲中，你引用了出埃及记 23 章 10 节和 11 节：“六年你要耕种地，收出地里的土产，第七年要让地歇息”，并建议说每七个冲刺都应该花在清理代码上。什么是正确的时间框架？</p><p class="normal"><b>Seibel:</b> In one of your talks you quoted Exodus 23:10 and 11: “And six years thou shalt sow thy land, and shalt gather in the fruits thereof: But the seventh year thou shalt let it rest and lie still” and suggested that every seventh sprint should be spent cleaning up code. What is the right time frame for that?</p>
<p class="normal"><b>克罗克福德：</b>六个周期——无论你运送什么东西之间的周期是什么。如果您处于每月交付周期，那么我认为每半年您应该跳过一个周期，只花时间清理代码。</p><p class="normal"><b>Crockford:</b> Six cycles—whatever the cycle is between when you ship something. If you're on a monthly delivery cycle then I think every half year you should skip a cycle and just spend time cleaning the code up.</p>
<p class="normal"><b>Seibel：</b>所以如果你不清理每七个周期，你可能会面临是否进行大的重写的选择。你怎么知道什么时候（如果有的话）是时候进行大的重写了？</p><p class="normal"><b>Seibel:</b> So if you don't clean up every seventh cycle you may be faced with the choice of whether or not to do a big rewrite. How do you know when, if ever, it's time for a big rewrite?</p>
<p class="normal"><b>Crockford：</b>通常团队知道什么时候到了。管理层后来发现了很多。团队经常被打败，犯了太多错误；代码太大，速度太慢；我们落后了。他们知道为什么。这不是因为他们变得更愚蠢或更懒惰。这是因为代码库不再服务于它需要的目的。</p><p class="normal"><b>Crockford:</b> Generally the team knows when it's time. Management finds out a lot later. The team is getting beat up pretty regularly, making too many bugs; the code's too big, it's too slow; we're falling behind. They know why. It's not because they became stupider or lazier. It's because the code base is no longer serving the purpose that it needs to.</p>
<p class="normal">这对于管理层来说真的是一件很难看到的事情，尤其是那些不是程序员的管理者。但即使是编程经理也会遇到这个问题，因为你已经看到你已经投入了很多时间来达到这一点。重新开始意味着我们必须一路回到那里并提出来。与此同时，我们不会继续前进<a id="OEBPS/Chapter03.html.page_110"></a>在任何其他事情上，这是不可能的。不，我们继续前进。</p><p class="normal">It's a really difficult thing for management to see, particularly managers who are not programmers. But even programming managers have trouble with this because you've seen that you've invested so much time to get to this point. And starting over means we've got to go all the way back to there and bring it up. And in the meantime we're not going to be going forward <a></a>on anything else and it's just impossible. No, we go forward with what we have.</p>
<p class="normal">谬论是它会再次花费那么多时间，尽管有反例。你遇到了第二个系统的问题，那些取得了一些成功的人得到了一张白纸，并被允许做他们想做的事。一般来说，他们会失败，因为他们太雄心勃勃，他们不了解限制。你什么也得不到。你必须有严格的纪律才能说，“这不是一张白纸；它正在重新实现我们在这里拥有的东西；它正在做我们所知道的事情。”</p><p class="normal">The fallacy is that it's going to take that amount of time again, though there are counterexamples. You've got the second-system problem where people who've had some success are given a blank slate and allowed to do whatever they want. Generally, they will fail because they'll be too ambitious, they won't understand the limits. And you get nothing out of that. You have to have extreme discipline to say, “It's not a blank slate; it's reimplementing what we had here; it's doing what we knew.”</p>
<p class="normal">使编程变得困难的部分原因是我们大部分时间都在做以前从未做过的事情。如果这是在我们重用其他东西之前已经完成的事情。对于我们所做的大部分事情，我们正在做一些我们以前没有做过的事情。做你以前没有做过的事情是很难的。这很有趣，但也很困难。特别是如果您使用经典方法，则必须对您不完全理解的系统进行分类。而且您将分类错误的可能性很高。</p><p class="normal">Part of what makes programming difficult is most of the time we're doing stuff we've never done before. If it was stuff that had been done before we'd be reusing something else. For most of what we do, we're doing something that we haven't done before. And doing things that you haven't done before is hard. It's a lot of fun but it's difficult. Particularly if you're using a classical methodology you're having to do classification on systems that you don't fully understand. And the likelihood that you're going to get the classification wrong is high.</p>
<p class="normal"><b>Seibel：</b> “经典”是指使用类。</p><p class="normal"><b>Seibel:</b> By “classical” you mean using classes.</p>
<p class="normal"><b>克罗克福德：</b>对。我发现它在原型世界中不是什么大问题，因为您专注于实例。如果您能找到一个典型的问题实例，那么您就完成了。通常你不必重构那些。但在经典系统中你不能那样做——你总是从抽象回到实例。然后从中建立层次结构真的很难做到正确。所以最终当你更好地理解问题时，你必须返回并重构它。但通常这会对代码产生巨大影响，特别是如果自从您弄清楚代码后代码变得很大。所以你没有。所以你一直在它上面捆绑这些新东西，试图修补原始层次结构中的问题，它变得越来越糟糕。</p><p class="normal"><b>Crockford:</b> Right. I've found it's less of a problem in the prototypal world because you focus on the instances. If you can find one instance which is sort of typical of what the problem is, you're done. And generally you don't have to refactor those. But in a classical system you can't do that—you're always working from the abstract back to the instance. And then making hierarchy out of that is really difficult to get right. So ultimately when you understand the problem better you have to go back and refactor it. But often that can have a huge impact on the code, particularly if the code's gotten big since you figured it out. So you don't. So you keep bundling these new things on top of it to try to patch the problems that were in the original hierarchy and it gets cruftier and worse.</p>
<p class="normal"><b>Seibel：</b>但是你认为重构可以工作，如果你每隔 7 次进行一次重构？您不必最终需要大量重写<i>？</i></p><p class="normal"><b>Seibel:</b> But you do think that refactoring can work, if you take every seventh interval to do it? You don't <i>have</i> to end up needing a big rewrite?</p>
<p class="normal"><b>克罗克福德：</b>我认为它可以工作。只有在您没有这样做或做得不好或<a id="OEBPS/Chapter03.html.page_111"></a>出了点问题，您的代码库变得无法运行。并且你可以做出合理的判断，更换它会比修复它更快。</p><p class="normal"><b>Crockford:</b> I think it can work. Throw it out and start over should only be considered in the cases where you didn't do that or you did it badly or <a></a>something went wrong and you've got a code base that has become unworkable. And you can make a reasonable judgment that it will be faster to replace it than to fix it.</p>
<p class="normal"><b>Seibel：</b>如果你不完全理解你想要重写的代码实际上做了什么，那风险呢？因为任何一段代码都包含一些嵌入式知识——一些你在说“哦，我们可以重写它”时不会想到的来之不易的功能。</p><p class="normal"><b>Seibel:</b> What about the risk that you don't fully understand what the code you want to rewrite actually does. Because any piece of code contains bits of embedded knowledge—little bits of cruft that are hard-won functionality that you don't think of when you say, “Oh, we can just rewrite this.”</p>
<p class="normal"><b>克罗克福德：</b>这是一个真正的问题。我们陷入困境的原因之一是 Web 的规范太差。规范不完整并且在很大程度上被误解了，其中许多误解已成为经典的一部分。因此，由于这些历史原因，这些系统比应有的复杂得多。在那个级别工作，是的，我对此深表同情，因为代码库中反映了很多未记录的知识。</p><p class="normal"><b>Crockford:</b> That is a real problem. One of the reasons that we're in the mess that we're in is that the Web is so poorly specified. The specifications were incomplete and were largely misinterpreted and many of those misinterpretations have become part of the canon. So these systems are way more complicated than they should be due to those historical reasons. Working at that level, yeah, I have huge sympathy for that, that there is a lot of undocumented knowledge that is reflected in the code base.</p>
<p class="normal">微软在他们的操作系统上也有类似的问题，因为他们运送了太多年的垃圾，然后他们不得不与所有基于他们所做的坏事的坏事保持兼容。因此，对他们下一个系统的设计施加的限制是可怕的。所以这真的很难推进。最终他们可能会发现他们也无法再前进了。</p><p class="normal">Microsoft has a similar problem with their operating systems, in that they shipped crap for too many years and then they had to remain compatible with all the bad stuff that was based on the bad stuff that they had done. And so the constraints that puts on the design of their next system are just horrendous. So it's really hard going forward with that. Ultimately they may find that they can't go forward anymore either.</p>
<p class="normal">这类规格错误真的非常非常难。我们在 Ajax 世界中拥有它们。我们在 Ajax 世界中的大多数问题都是由于浏览器级别的差异造成的。做跨浏览器的事情比它应该做的要难得多，因为 Web 没有很好地指定并且因为实现是如此多变。</p><p class="normal">Those sort of specification errors are really, really hard. And we have them in the Ajax world. Most of our problems in the Ajax world are due to the differences at the browser level. Doing the cross-browser stuff is much harder than it should be because the Web is not specified well and because the implementations are so variable.</p>
<p class="normal">在过去的几年里，我们在这方面做得更好，特别是随着 Ajax 库的出现。他们中的大多数人做得很好——还不是一个完整的工作——但在提高你的编程水平方面做得很好。所以我们不必直接处理浏览器的内容；我们有一种可以在其上工作的虚拟化应用程序层，它具有相当的弹性和可移植性。我们在 Yahoo! 有一个小组 它主要负责处理浏览器造成的痛苦。当他们正确地完成工作时，这里的所有其他开发人员都会更轻松。所以这很好。</p><p class="normal">We've gotten a lot better at that over the last few years, particularly with the advent of the Ajax libraries. Most of them do a very good job—not a complete job yet—but a pretty good job of boosting the level of programming that you do. So we're not having to deal directly with the browser guts; we have a sort of virtualized application layer that we can work on that is fairly resilient and pretty portable. We have one group here at Yahoo! which is primarily responsible for dealing with the pain that the browser causes. And when they do their job right, it makes it easier for all the other developers here. So that's good.</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_112"></a><b>Seibel：</b>另一方面，重写并不总是奏效。你刚刚提到了第二系统效应，在你的一次演讲中，你将看到它的实际效果描述为“令人心碎”。那是什么时候？</p><p class="normal"><a></a><b>Seibel:</b> On the other hand, rewrites don't always work out. You just mentioned the second-system effect and in one of your talks, you described seeing it in action as “heartbreaking.” When was that?</p>
<p class="normal"><b>Crockford：</b>那是在 Electric Communities。我们召集了我在任何地方见过的最聪明的程序员团队。我们有足够的钱，我们打算重新实现 Chip 和 Randy 已经做过的东西，并且知道如何去做。除了它更宏伟。</p><p class="normal"><b>Crockford:</b> It was at Electric Communities. We got together the smartest team of programmers I've ever seen assembled anywhere. And we had enough money and we were going to reimplement the stuff that Chip and Randy had already done and knew exactly how to do it. Except it was grander.</p>
<p class="normal"><b>Seibel：</b>所以这基本上是人居，重做。</p><p class="normal"><b>Seibel:</b> So that was basically Habitat, redone.</p>
<p class="normal"><b>Crockford：</b>是的，我们本来打算重做 Habitat，只是它现在要在全球发行。事实证明这真的很难。我们实际上建造了它，但它很痛苦。这不是我想再做的事。</p><p class="normal"><b>Crockford:</b> Yeah, we were going to redo Habitat except it was now going to be globally distributed. And it turned out to be really hard. We actually got it built but it was painful. Not something I'd like to do again.</p>
<p class="normal"><b>Seibel：</b>你之前给出的建议——严格遵守仅重新实现你已经了解的内容——是否足以阻止灾难发生？</p><p class="normal"><b>Seibel:</b> Would the advice you gave before—to be very disciplined about only reimplementing what you already understand—would that have been sufficient to head off the disaster?</p>
<p class="normal"><b>克罗克福德：</b>我认为这可能有所帮助。我们没有适当地分阶段考虑。我们没有增量方法。如果我们采取渐进的方法，我会从两个平行的工作开始。第一，制定一个安全的分布式平台，该平台什么都不做，但具有进行消息传递和对象管理的基础设施。第二，让我们重建栖息地。知道我们所知道的，用现代语言，让我们重建它。</p><p class="normal"><b>Crockford:</b> I think it could have helped. We didn't think about it in stages properly. We didn't have an incremental approach. Had we taken an incremental approach, I would have started with two parallel efforts. One, work out a secure distributed platform which doesn't do anything but has the infrastructure for doing the messaging and the object management. Two, let's rebuild Habitat. Knowing what we know, with modern languages, let's just rebuild it.</p>
<p class="normal">然后第二阶段是，好的，让我们将它们合并在一起。我们可以将这个提升到那个之上并且仍然有一个工作系统吗？好的，现在分发它。</p><p class="normal">Then the second phase would be, OK let's merge them together. Can we hoist this one on top of that one and still have a working system? OK, now distribute it.</p>
<p class="normal">如果我们采用这种渐进式方法，我认为我们会非常成功。但是我们试图一步完成所有这些，但这太难了。</p><p class="normal">Had we taken that kind of incremental approach, I think we would have been very successful with it. But we tried to do all of those in one step and that was too hard.</p>
<p class="normal"><b>Seibel：</b>你认为你被引导尝试一步完成，因为你知道其中的大部分内容。</p><p class="normal"><b>Seibel:</b> And you think you were led into trying to do it in one step because you knew big chunks of it.</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_113"></a><b>Crockford：</b>因为我们很聪明，而且我们有很多经验。我们有线。不能错过。程序员是乐观的。我们必须如此，因为如果我们不是乐观主义者，我们就无法完成这项工作。这就是为什么我们成为第二个系统之类的东西的牺牲品，为什么我们不能安排我们的项目，为什么这件事如此困难。</p><p class="normal"><a></a><b>Crockford:</b> Because we were so smart and we had so much experience. We had it wired. Couldn't miss. Programmers are optimistic. And we have to be because if we weren't optimists we couldn't do this work. Which is why we fall prey to things like second systems, why we can't schedule our projects, why this stuff is so hard.</p>
<p class="normal"><b>Seibel：</b>编程变得更容易了吗？将来会有更多人能够做一些我们认为是编程的事情吗？</p><p class="normal"><b>Seibel:</b> Is programming getting easier? In the future will more people be able to do something that we would recognize as programming?</p>
<p class="normal"><b>Crockford：</b>我对编程的兴趣是帮助其他人进行编程，专门设计一种语言或编程工具，以便更多人更容易使用它——这让 Smalltalk 开始了。Smalltalk 走向了不同的方向，但最初的方向对我来说真的很有吸引力。我们如何专门为儿童构建一种语言，或者我们如何专门为那些不认为自己是程序员的人构建一种语言？</p><p class="normal"><b>Crockford:</b> My interest in programming is helping other people to do programming, designing a language or a programming tool specifically so that it's more accessible to more people—the thing that got Smalltalk started. Smalltalk went in a different direction, but the initial direction was really attractive to me. How do we build a language specifically for children or how do we build a language specifically for people who don't think of themselves as programmers?</p>
<p class="normal"><b>Seibel：</b>那是因为你认为每个人都应该学习编程，至少学一点？</p><p class="normal"><b>Seibel:</b> Is that because you think everybody should learn to program, at least a little bit?</p>
<p class="normal"><b>克罗克福德：</b>我认为你必须这样做。现在世界几乎已经被计算机接管了，为了保护自己，或者成为一个完整的公民，你必须对这些东西的工作原理有一些了解。</p><p class="normal"><b>Crockford:</b> I think you have to. The world has been pretty much taken over by computers now and in order to defend yourself, or to be a full citizen, you have to have some understanding of how these things work.</p>
<p class="normal"><b>Seibel：</b>有些人还会争辩说，学习编程会教授一种重要的思维方式，就像阅读和数学是不同的思维方式一样，两者都很重要。</p><p class="normal"><b>Seibel:</b> Some folks would also argue that learning to program teaches a way of thinking that's important, like reading and math are different ways of thinking, and both important.</p>
<p class="normal"><b>克罗克福德：</b>我曾经这么认为。当我开始编程时，我有了这些惊人的见解：一切都变得井然有序，我看到了以前从未见过的结构和事物。我想，“哇，这太棒了。每个人都应该学习如何做到这一点，”因为突然间我感觉自己聪明了很多。除了很快我发现，与其他程序员交谈，不知何故他们没有得到它。程序员能够以与其他人完全相同的方式完全误解世界。弄清楚这一点我真的很难过。</p><p class="normal"><b>Crockford:</b> I used to think so. I had these amazing insights when I started programming: everything became orderly, and I saw structures and things I had never seen before. I thought, “Wow, this is amazing. Everybody should learn how to do this,” because suddenly I was feeling a lot smarter. Except pretty quickly I'd find, talking to other programmers, that somehow they didn't get it. Programmers are capable of completely misunderstanding the world in exactly the same way everybody else does. I was really sad to figure that out.</p>
<p class="normal"><b>Seibel：</b>你还像以前一样喜欢编程吗？</p><p class="normal"><b>Seibel:</b> Do you still enjoy programming as much as you always did?</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_114"></a><b>克罗克福德：</b>哦，是的。</p><p class="normal"><a></a><b>Crockford:</b> Oh, yeah.</p>
<p class="normal"><b>Seibel：</b>你认为编程完全偏向于年轻吗？</p><p class="normal"><b>Seibel:</b> Do you think that programming is at all biased toward being young?</p>
<p class="normal"><b>克罗克福德：</b>我曾经这么认为。几年前我患有睡眠呼吸暂停症，但我并不知道。我以为我只是变得又累又老，我已经到了难以集中注意力的地步，以至于我无法再编程了，因为我的脑子里装不下足够的东西。很多编程都是你把东西记在脑子里，直到你把它写下来并正确地组织起来。而我就是做不到。</p><p class="normal"><b>Crockford:</b> I used to think so. A few years ago I had sleep apnea, but I didn't know it. I thought I was just getting tired and old, and I got to the point where it was so difficult to concentrate that I couldn't program anymore because I just couldn't keep enough stuff in my head. A lot of programming is you keep stuff in your head until you can get it written down and structured properly. And I just couldn't do it.</p>
<p class="normal">我失去了那种能力，我认为这只是因为我变老了。幸运的是，我好转了，它又回来了，所以我又开始编程了。我做得很好，现在可能更好一点，因为我学会了如何不那么依赖我的记忆。我现在比以前更擅长记录我的代码，因为我不太确定下周我会记得我为什么这样做。事实上，有时我会回顾我的东西，我对我写的东西感到惊讶：我不记得曾经做过它，它要么真的很糟糕，要么很棒。我不知道我有能力做到这一点。</p><p class="normal">I had lost that ability and I thought it was just because I was getting older. Fortunately, I got better and it came back and so I'm programming again. I'm doing it well and maybe a little bit better now because I've learned how not to depend so much on my memory. I'm better at documenting my code now than I used to be because I'm less confident that I'll remember next week why I did this. In fact, sometimes I'll be going through my stuff and I'm amazed at stuff that I had written: I don't remember having done it and it's either really either awful or brilliant. I had no idea I was capable of that.</p>
<p class="normal"><b>Seibel：</b>我在某个地方读到过，您说文学编程，就像 Donald Knuth 那样，是一个绝妙的主意。你使用识字工具吗？</p><p class="normal"><b>Seibel:</b> I read somewhere where you said that literate programming, a la Donald Knuth, is a brilliant idea. Do you use literate tools?</p>
<p class="normal"><b>Crockford：</b>没有。我一直在考虑这个问题，我一直在为我正在使用的一些语言设计识字工具，但我目前没有进行任何文字编程。</p><p class="normal"><b>Crockford:</b> No. I've been thinking about it and I've been designing literate tools for some of the languages that I'm using but I'm currently not doing any literate programming.</p>
<p class="normal"><b>Seibel：</b>这只是一个工具链问题吗？如果存在这些工具，您认为您会编写文学程序吗？</p><p class="normal"><b>Seibel:</b> Is that just a tool-chain problem? If the tools existed you think you would write literate programs?</p>
<p class="normal"><b>克罗克福德：</b>我愿意。例如，我认为如果我以文学风格编写 JSLint，它对我来说会更容易维护。我喜欢识字风格的一点是，你专门为阅读设计程序，我认为这为程序提供了巨大的价值。</p><p class="normal"><b>Crockford:</b> I would. I think JSLint, for example, would be easier for me to maintain if I had written it in a literate style. The thing I like about the literate style is that you're designing the program specifically for reading and I think that provides tremendous value to the program.</p>
<p class="normal"><b>Seibel：</b>如您所见，精通编程工具的主要特征是什么？</p><p class="normal"><b>Seibel:</b> What are the key features of a literate programming tool, as you see it?</p>
<p class="normal"><b>Crockford：</b> Knuth 发现或提供的主要东西是乱序书写的能力。所以如果我关心某件事<a id="OEBPS/Chapter03.html.page_115"></a>在很多地方涉及代码，我可以将所有代码收集在一起并一起描述，然后该工具会将细节分发到需要去的地方。</p><p class="normal"><b>Crockford:</b> The principal thing that Knuth found or provided was the ability to write out of order. So if I'm concerned with a particular thing <a></a>which touches code in a lot of places, I can collect all that code together and describe it together, and then the tool will distribute the details out to where it needs to go.</p>
<p class="normal">他让你摆脱的另一件事是函数的大小。理想情况下，您希望功能不超过屏幕的大小，以便您可以一次阅读所有内容。如果它不合适，那么你就会创建更多的函数，如果这些函数实际上对程序的结构没有任何贡献，那么它们只是引入了噪音。</p><p class="normal">Another of the things he frees you from is the size of a function. Ideally, you want a function to be no bigger than a screen's worth so that you can read it all at once. And if it doesn't fit, then you're making a lot more functions, and if the functions aren't actually contributing anything to the structure of the program, they're just introducing noise.</p>
<p class="normal">Knuth 允许您获取该功能的每个方面，这些方面可能密切相关——它可能具有良好的连贯性，但它只是很大；有时东西很大——他允许你用一个极具描述性的标签来表示这些东西的集合，然后说，“这个功能是：”然后列出这些标签。你可以用函数来做到这一点，但它并不完全相同，然后你必须处理各个部分之间的通信，等等。所以它引入了更多与问题不完全匹配的结构。</p><p class="normal">Knuth allows you to take each of the aspects of that function, which may be closely related—it might have good coherence but it's just big; sometimes stuff is big—and he allows you to represent each of those collections of stuff with an extremely descriptive label and then say, “This function is:” and then list those labels. You could do that with functions, but it's not quite the same and then you have to deal with communication between the pieces, and so on. So it's introducing more structure which doesn't exactly match the problem.</p>
<p class="normal">最终，我希望看到专门为识字语言设计的新语言。Knuth 非常擅长将这个想法应用到 Pascal 和 C 中，但我真的很想看到一种新的语言，从底层开始，设计用于这种方式。</p><p class="normal">Ultimately I would like to see new languages designed specifically to be literate languages. Knuth has been very good at applying the idea to Pascal and C, but I'd really like to see a new language which is, from the bottom, designed to be used in that fashion.</p>
<p class="normal"><b>Seibel：</b>你读过 Knuth 的文学程序吗？</p><p class="normal"><b>Seibel:</b> Have you read Knuth's literate programs?</p>
<p class="normal"><b>克罗克福德：</b>当然。</p><p class="normal"><b>Crockford:</b> Sure.</p>
<p class="normal"><b>Seibel：</b>你如何阅读它们？像小说？</p><p class="normal"><b>Seibel:</b> How do you read them? Like a novel?</p>
<p class="normal"><b>克罗克福德：</b>是的，我读它就像读小说一样。我倾向于阅读他的散文而不是他的程序，但我真的很喜欢他的排版方式，而且他写得非常好，偶尔他会在其中开个玩笑。我喜欢读他的东西。</p><p class="normal"><b>Crockford:</b> Yeah, I read it like a novel. I tend to be reading his prose rather than his program, but I really like the way he lays it out and he writes really well, and occasionally he'll slip a little joke in there. I enjoy reading his stuff.</p>
<p class="normal"><b>Seibel：</b>你从中得到了什么？所以您已经阅读了<i>TeX: The Program</i>，并且您已经读完了。现在您准备好将功能添加到 TeX 中了吗？或者您只是总体感觉哇，Knuth 是个聪明人？</p><p class="normal"><b>Seibel:</b> And what do you get out of it? So you've read <i>TeX: The Program</i>, and you get to the end. Now are you ready to go add features into TeX or do you just have an overall sense of wow, Knuth's a brilliant guy?</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_116"></a><b>克罗克福德：</b>这是一个非常好的问题。我读过 TeX，但我读它的目的不是要修改 TeX。我只是读它看看他做了什么。我对他如何进行换行特别感兴趣，所以我特别感兴趣地阅读了那部分，更多的是为了了解他的算法而不是了解代码的工作原理以便我可以修改或重用它。如果我在阅读它时期望我会弄乱程序，我相信我会以不同的方式阅读它。</p><p class="normal"><a></a><b>Crockford:</b> That's a really good question. I've read TeX, but I didn't read it with an intention that I wanted to modify TeX. I was just reading it to see what he had done. I had a particular interest in how he was doing line-breaking, so I read that part with particular interest, more to understand his algorithm than to understand how the code works so that I can modify it or reuse it. If I were reading it with the expectation that I was going to mess with the program, I'm sure I would've read it differently.</p>
<p class="normal"><b>Seibel：</b>你是否经常为了乐趣而阅读代码，无论是识字的还是其他的？</p><p class="normal"><b>Seibel:</b> Do you often read code, literate or otherwise, for fun?</p>
<p class="normal"><b>克罗克福德：</b>是的。没有多少代码足够好，您可以阅读它以获得乐趣。Knuth 写了一些。Fraser 和 Hanson 有一个识字的 C 编译器；这很好。但是目前还没有很多这样的例子。真可惜。这可能表明文学编程可能失败了，因为这样的例子并不多。</p><p class="normal"><b>Crockford:</b> Yeah. There's not much code out there that's good enough that you could read it for fun. Knuth wrote some. Fraser and Hanson have a C compiler that is literate; it's very good. But there are not a lot of examples of that yet. That's kind of a shame. That could indicate that maybe literate programming has failed, because there aren't very many examples of it.</p>
<p class="normal"><b>Seibel：</b> Knuth 的巨著<i>《计算机编程艺术》</i>怎么样？您是那种会从头到尾阅读、深入研究以供参考，还是将其搁置一旁却从不看的人？</p><p class="normal"><b>Seibel:</b> What about Knuth's magnum opus, <i>The Art of Computer Programming</i>? Are you the kind of person who read it cover to cover, who dips into it for reference, or who put it on the shelf and never looked at it?</p>
<p class="normal"><b>Crockford：</b>除了最后一个。当我上大学的时候，有几个月我没有付房租来买他的书。我读了它们，发现了其中的笑话，就像第一卷索引中的一个 TUG 笑话。我无法理解所有这些。有些地方他讲的比我深得多，但我很喜欢这些书，我也把它们当作参考书。</p><p class="normal"><b>Crockford:</b> All except the last one. When I was in college, there were a couple of months where I didn't pay rent in order to buy copies of his books. And I read them and found jokes in them, like there's a TUG joke in the index of Volume I. I have not been able to make sense out of all of it. There are places where he goes really a lot deeper than I can go, but I enjoy the books a lot, and I've also used them as reference books.</p>
<p class="normal"><b>Seibel：</b>你真的从头到尾读过它们，略过你无法理解的数学吗？</p><p class="normal"><b>Seibel:</b> Did you literally read them cover to cover, skimming over the math that you couldn't understand?</p>
<p class="normal"><b>Crockford：</b>是的，星星太多的部分，我会很快读完。我试图将熟悉 Knuth 作为招聘标准，但我很失望找不到足够多的人读过他的书。在我看来，任何自称专业程序员的人都应该读过 Knuth 的书，或者至少应该有他的书的副本。</p><p class="normal"><b>Crockford:</b> Yeah, the part when there are too many stars, I would read it very quickly. I tried to make familiarity with Knuth a hiring criteria, and I was disappointed that I couldn't find enough people that had read him. In my view, anybody who calls himself a professional programmer should have read Knuth's books or at least should have copies of his books.</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_117"></a><b>Seibel：</b>在我看来，要阅读 Knuth，你必须能够阅读数学并理解它。您认为在多大程度上需要接受这种数学训练才能成为一名程序员？</p><p class="normal"><a></a><b>Seibel:</b> To read Knuth, it seems to me, you have to be able to read the math and understand it. To what extent do you think having that kind of mathematical training is necessary to be a programmer?</p>
<p class="normal"><b>克罗克福德：</b>显然不是，因为他们中的大多数人都没有。在我正在处理的各种应用程序中，我们没有看到 Knuth 为我们提供的特定工具有太多应用。如果我们正在编写操作系统或编写运行时，它会更加关键。但是我们正在做表单验证和用户界面。一般来说，性能在我们所做的事情中并不那么重要。我们大部分时间都花在等待用户或等待网络上。</p><p class="normal"><b>Crockford:</b> Obviously it's not, because most of them don't have it. In the sorts of applications that I'm working on, we don't see that much application of the particular tools that Knuth gives us. If we were writing operating systems or writing runtimes, it'd be much more critical. But we're doing form validations and UIs. Generally performance is not that important in the things that we do. We spend most of our time waiting for the user or waiting for the network.</p>
<p class="normal">我想坚持认为人们绝对有必要了解这些东西，但事实并非如此。也许这就是为什么网络编程已经起飞，为什么它如此易于访问以及为什么 JavaScript 有效。这东西真的没有那么难。大多数让它变得困难的事情都是不必要的困难。如果我们稍微清理一下平台，这项工作就会变得容易得多。</p><p class="normal">I would like to insist that it's absolutely necessary for people to understand this stuff, but it's not. And maybe that's why web programming has taken off and why it's so accessible and why JavaScript works. This stuff really isn't that hard. And most of the things that make it hard are unnecessarily hard. If we just cleaned up the platform a little bit, this work gets a lot easier.</p>
<p class="normal"><b>Seibel：</b>所以 Knuth 会教你如何做一些基本的事情，然后是大局。即使您清理平台，构建大型系统并以易于理解的方式设计它们仍然很困难。你如何设计你的代码？</p><p class="normal"><b>Seibel:</b> So there's the nitty-gritty stuff that Knuth will teach you how to do and then there's the big picture. Even if you clean up the platform, building big systems and designing them in a way that's comprehensible will still be hard. How do you design your code?</p>
<p class="normal"><b>Crockford：</b>与其说是编写程序，不如说是对程序的生存进行迭代。一般来说，我们做软件的原因是因为我们知道我们将不得不改变它，而改变任何东西都是困难的，因为有可能在改变它的过程中，你会破坏它。</p><p class="normal"><b>Crockford:</b> It's not so much about writing the program as making iterations on the program's survival. Generally the reason we're doing software is because we know we're going to have to change it and changing anything is hard because there's a likelihood that, in changing it, you're going to break it.</p>
<p class="normal">您无法预料将要用它完成的所有事情，但您会尝试构建足够的灵活性，以便它可能适应您将要做的任何事情。这就是我的想法。我怎样才能不把自己逼得太紧？我如何让自己灵活地根据需要进行调整？</p><p class="normal">You can't anticipate everything that's going to be done with it but you try to build in enough flexibility that it's likely to adapt to whatever you're going to do. So that's what I'm thinking. How do I not write myself into a corner too much? How do I give myself the flexibility to adapt as I need to?</p>
<p class="normal">这是我发现我真正喜欢 JavaScript 的地方之一。我发现用 JavaScript 重构真的很容易。而重构深类层次结构可能真的非常痛苦。</p><p class="normal">That's one of the things that I discovered I really like about JavaScript. Refactoring in JavaScript, I find, is really easy. Whereas refactoring a deep class hierarchy can be really, really painful.</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_118"></a>例如，自从我在 2000 年、2001 年开始编写 JSLint 以来，它已经发生了很大变化。它的目标也发生了显着变化——它现在正在做很多我从未想过它会做的事情。这在很大程度上是因为 JavaScript 非常灵活。我可以摆弄它，让程序在不马虎的情况下成长。</p><p class="normal"><a></a>For example, JSLint has transformed quite a lot since I started writing it in 2000, 2001. And its goals have changed significantly—it's doing a lot of stuff now that I never thought it would do. And a lot of that's because JavaScript is so flexible. I can fiddle with it and allow the program to grow without becoming sloppy.</p>
<p class="normal"><b>Seibel：</b>是什么让它变得如此简单？</p><p class="normal"><b>Seibel:</b> What makes it so much easier?</p>
<p class="normal"><b>克罗克福德：</b>我已经成为柔软物品的忠实粉丝。在 JavaScript 中，任何对象都是你所说的。这对于那些从经典角度来看它的人来说是令人震惊的，因为没有类，那么你有什么？事实证明，您正好拥有所需的东西，这真的很有用。调整你的对象。. . 您想要的对象要简单得多。</p><p class="normal"><b>Crockford:</b> I've become a really big fan of soft objects. In JavaScript, any object is whatever you say it is. That's alarming to people who come at it from a classical perspective because without a class, then what have you got? It turns out you just have what you need, and that's really useful. Adapting your objects . . . the objects that you want is much more straightforward.</p>
<p class="normal"><b>Seibel：</b>使用基于类的语言，问题大概在于它太静态了——你有一个很大的类层次结构，如果你想改变这个结构，你必须把它拆开再放回去。在 JavaScript 中，危险似乎在于它可能过于动态——你会在任何地方卡住小块，你的程序的实际结构是由运行时发生的许多事情决定的；没有静态的东西你可以看着然后说，“好的，这就是程序及其结构。”</p><p class="normal"><b>Seibel:</b> Presumably the problem, working with a class-based language, is that it's too static—you've got a big class hierarchy and if you want to change that structure you've got to take it apart and put it back together. In JavaScript it seems the danger is that it can be too dynamic—you've stuck little kludges everywhere and the actual structure of your program is determined by lots of things that happen at runtime; there's no static thing you can look at and say, “OK, this is the program and how it's structured.”</p>
<p class="normal"><b>Crockford：</b>这是它可怕的部分，害怕是件好事，因为它很可怕而且是真实的。它需要纪律。在大多数古典语言中，语言是施加纪律的东西。在 JavaScript 中，您必须遵守自己的纪律。</p><p class="normal"><b>Crockford:</b> That is the scary part of it and it's good to be scared because it is scary and it is real. It requires discipline. In most of the classical languages, the language is the thing imposing the discipline. In JavaScript you have to bring your own discipline.</p>
<p class="normal">为了防止我的代码崩溃，我所做的部分工作是在我如何将它们组合在一起时非常严格，因为我知道这种语言并没有为我提供那种严谨性。所以今天我不会考虑在没有 JSLint 的情况下进行像 JSLint 这样复杂的事情。JavaScript 本身并不能很好地扩展，但有了这个工具，我变得更加自信，我将能够保持它的工作。</p><p class="normal">Part of what I do to keep my code from falling apart is to be really rigorous myself in how I put it together because I know the language is not providing that rigor for me. So today I would not consider undertaking something as complicated as JSLint without JSLint. JavaScript does not scale very well on its own, but with that tool I become a lot more confident that I'm going to be able to keep it working.</p>
<p class="normal"><b>Seibel：</b>所以 JavaScript 对象的软性可能很危险。但是，如果您从未利用过扩充对象的能力，那么您还不如只用 Java 编写类。你有什么办法想<a id="OEBPS/Chapter03.html.page_119"></a>构建您的 JavaScript 程序以充分利用该语言为您提供的灵活性？</p><p class="normal"><b>Seibel:</b> So the softness of JavaScript objects can be dangerous. But if you never availed yourself of the ability to augment objects, then you might as well just be writing classes in Java. Is there some way you think about <a></a>structuring your JavaScript programs to take good advantage of the flexibility the language gives you?</p>
<p class="normal"><b>克罗克福德：</b>对我来说，这是多年的反复试验。当我开始使用 JavaScript 时，我没有阅读任何相关内容。我刚开始。我找到了一个糟糕的示例程序，然后开始摆弄它，直到它更像我认为的那样工作。因此，我开始使用该语言进行编程，但不了解该语言是什么，它是如何工作的，或者您如何需要它来思考它。</p><p class="normal"><b>Crockford:</b> For me it was years of trial and error. When I started working with JavaScript, I didn't read anything about it. I just started. I found a sample program, which was awful, and started fiddling with it until it worked more like the way I thought it should. So I began programming in the language, having no understanding about what the language was, or how it worked, or how you needed it to think about it.</p>
<p class="normal">我理解为什么人们对这种语言感到沮丧。如果您尝试将 JavaScript 当作 Java 来编写，它会一直困扰您。我这样做了。我用这门语言做的第一件事就是弄清楚如何模拟一些看起来有点像 Java 类的东西，但在边缘它并没有像它那样工作。而且我总是最终会被推到那些边缘并受伤。</p><p class="normal">I understand why people are frustrated with the language. If you try to write in JavaScript as though it is Java, it'll keep biting you. I did this. One of the first things I did in the language was to figure out how to simulate something that looked sort of like a Java class, but at the edges it didn't work anything like it. And I would always eventually get pushed up against those edges and get hurt.</p>
<p class="normal">最终我发现我根本不需要这些课程，然后这门语言开始为我工作。我没有与之抗争，而是发现自己被它赋予了力量。</p><p class="normal">Eventually I figured out I just don't need these classes at all and then the language started working for me. Instead of fighting it, I found I was being empowered by it.</p>
<p class="normal"><b>Seibel：</b>当你设计软件时，你更喜欢自上而下、自下而上还是中间出？</p><p class="normal"><b>Seibel:</b> When you're designing software, do you prefer to think top-down or bottom-up or middle-out?</p>
<p class="normal"><b>克罗克福德：</b>一下子。这就是将系统牢记在心的问题。最终你需要分而治之，把它分解成你可以管理的东西。我发现我正在处理问题的所有部分并同时使用所有这些技术。我一直在努力解决它，直到我弄清楚结构是什么。一旦弄清楚结构是什么，其余部分就会消失。</p><p class="normal"><b>Crockford:</b> All at once. That's the thing about keeping the system in your head. Ultimately you need to divide and conquer and get it down into something you can manage. I find I'm on all parts of the problem and using all those techniques simultaneously. And I keep struggling with it until I become clear on what the structure is. Once you figure out what the structure is, then the rest of it falls out.</p>
<p class="normal"><b>Seibel：</b>设计和编码对你来说有什么关系？您是立即开始编码然后反复完善它，还是做一些与编写代码分开的事情？</p><p class="normal"><b>Seibel:</b> How do design and coding relate for you? Do you start coding immediately and then iteratively refine it, or do you do something that's separate from writing code?</p>
<p class="normal"><b>克罗克福德：</b>他们曾经是分开的。他们现在变得越来越相似了。我曾经使用设计语言或元语言工作——半英语的东西，有点结构化，更能描述你要做什么<a id="OEBPS/Chapter03.html.page_120"></a>写。但如果我用 JavaScript 编写，那门语言就变成了 JavaScript。</p><p class="normal"><b>Crockford:</b> They used to be separate. They're becoming more similar now. I used to work in a design language or a meta language—something semi-English, a little structured, which is more descriptive of what you're going to <a></a>write. But if I'm writing in JavaScript, that language has turned into JavaScript.</p>
<p class="normal"><b>Seibel：</b>您实际上使用什么工具来编写代码？</p><p class="normal"><b>Seibel:</b> What tools do you actually use for writing code?</p>
<p class="normal"><b>Crockford：</b>我使用一个小的免费文本编辑器。它没有做任何棘手的事情。这就是我所需要的。不像其他语言那样需要正式工具。浏览器只需要一个源文件，所以你向它发送一个源文件，编译器内置在浏览器中，所以真的没有什么可做的。你没有链接器。你没有编译器。你没有任何这些东西。它只是全部在浏览器上运行。</p><p class="normal"><b>Crockford:</b> I use a little freeware text editor. It doesn't do anything tricky. That's about all I need. There is much less need of formal tools like you have in other languages. The browser just wants a source file, and so you send it a source file, and the compiler is built into the browser, so there's really nothing to do. You don't have a linker. You don't have a compiler. You don't have any of that stuff. It just all runs on the browser.</p>
<p class="normal"><b>Seibel：</b>你大概使用了 JSLint。</p><p class="normal"><b>Seibel:</b> You use JSLint, presumably.</p>
<p class="normal"><b>Crockford：</b>我确实使用 JSLint。我经常使用它。每次运行程序之前，我都会尝试使用它，所以如果我已经完成并进行了一些编辑，我会在运行它之前先通过 JSLint 运行它。</p><p class="normal"><b>Crockford:</b> I do use JSLint. I use it a lot. I try to use it every time before I run a program, so if I've gone through and I've done some edits, I'll run it through JSLint first before I run it.</p>
<p class="normal"><b>Seibel：</b>所以你在文本编辑器中编辑，在程序上运行 JSLint，然后在浏览器中运行它。调试怎么样？</p><p class="normal"><b>Seibel:</b> So you edit in your text editor, run JSLint on the program, and then run it in a browser. How about debugging?</p>
<p class="normal"><b>Crockford：</b>这取决于浏览器。如果是 Firefox，则使用 Firebug。如果是 IE，则使用 Visual Studio 调试器。他们俩其实都很好。我们在浏览器中有非常好的调试器。</p><p class="normal"><b>Crockford:</b> It depends on the browser. If it's Firefox, then you use Firebug. If it's IE, then you use the Visual Studio debugger. They're both actually very good. We have surprisingly good debuggers in the browser.</p>
<p class="normal">我使用过这样的框架，其中有由 DOM 元素构建的检查器，然后可以进入对象，打开它们，并通过那组框架进行检查。但是我发现我真的不需要那个。只需一个调试器就足够了。</p><p class="normal">I've used frameworks in which there were inspectors built out of DOM elements that could then go into objects, and open them up, and inspect through that set of frames. But I found I really don't need that. Just a debugger is enough.</p>
<p class="normal"><b>Seibel：</b>当您没有跟踪特定错误时，您是否曾将代码单步执行作为检查代码的一种方式？</p><p class="normal"><b>Seibel:</b> Do you ever step through code just as a way of checking it when you're not tracking down a specific bug?</p>
<p class="normal"><b>克罗克福德：</b>除非我有一些非常复杂的东西。作为我测试的一部分，我逐步完成它，但通常我只会在我知道我会遇到问题时才逐步进行。</p><p class="normal"><b>Crockford:</b> Only if I have something that's really intricate. I'll step through it as part of my testing, but generally I only step if I know I have problems.</p>
<p class="normal"><b>Seibel：</b>其他调试技术怎么样，比如断言或证明。你用这些吗？你认为不变量？</p><p class="normal"><b>Seibel:</b> How about other debugging techniques, like assertions, or proofs. Do you use any of those? Do you think in terms of invariants?</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_121"></a><b>克罗克福德：</b>我喜欢他们。令我失望的是，Eiffel 未能在面向对象语言竞赛中获胜；C++ 取而代之。我认为 Eiffel 是一种更有趣的语言，我喜欢它所做的前置条件/​​后置条件契约。我希望看到它内置到我的语言中，无论我使用什么语言，但这是另一个尚未真正流行的想法。</p><p class="normal"><a></a><b>Crockford:</b> I like them. I was disappointed that Eiffel was not the winner in the object-oriented-language contest; that C++ won instead. I thought Eiffel was a much more interesting language and I liked the precondition/postcondition contract stuff that it did. I would like to see that built into my language, whatever language I'm using, but that's another one of those ideas that hasn't really caught on.</p>
<p class="normal"><b>Seibel：</b>您曾经不得不追踪的最严重的错误是什么？</p><p class="normal"><b>Seibel:</b> What's the worst bug you ever had to track down?</p>
<p class="normal"><b>Crockford：</b>这可能是一个实时错误。它可能出现在视频游戏中。我们到处都是中断，根本没有内存管理，程序突然消失了，你不知道为什么。那种东西真的很难。而且通常也不会有调试器。</p><p class="normal"><b>Crockford:</b> It would've been a real-time bug. It might've been in a video game. We've got interrupts popping all over the place, and no memory management at all, and the program suddenly goes away and you don't know why. That kind of stuff is really hard. And generally there wouldn't be a debugger around either.</p>
<p class="normal">在 Basic Four，我们开发了一个文字处理终端。这是一个基于 Z80 的终端，具有全页显示和 64K，对于那么大的显示器来说，这几乎不够内存。它有一个本地网络连接到我们的服务器，它会在那里发送页面。</p><p class="normal">At Basic Four we had developed a word-processing terminal. It was a Z80-based terminal with a full-page display and 64K, which wasn't nearly enough memory for a display that big. And it had a local network connection to our server where it would send up the pages.</p>
<p class="normal">我们遇到了这个问题，每隔一段时间屏幕就会变黑。我们有这样的架构，其中我们有一行文本，然后它会有一个停止代码，然后是下一行的地址，以及一个跟随这些链接的小 DMA 处理器。在某个时候，一个链接会消失——有一些比赛正在发生。</p><p class="normal">And we had this problem where every once in a while the screen would go blank. We had this architecture in which we had a line of text and then it would have a stop code, and then the address of the next line, and a little DMA processor that would follow those links. And at some point a link would go away—there was some race that was happening.</p>
<p class="normal">从我们的角度来看，从逻辑上看，所有链接都很好，但我们没有考虑与 DMA 处理器的实时交互，它可能不会与我们同时查看内存。我只是想不通。我记得那天我在家工作，正在和我的团队通电话，突然灯泡亮了；我知道问题出在哪里，我能够告诉他们如何解决它，我们再也没有遇到过那个问题。</p><p class="normal">From our perspective, looking at it logically, all of the links were good, but we hadn't considered the real-time interaction with the DMA processor, which might not be looking at memory at the same time that we were. I just puzzled it out. I remember I was working at home that day and I was on the phone with my team and suddenly the lightbulb went on; I knew what the problem was and I was able to tell them how to fix it and we never had that problem again.</p>
<p class="normal">根据我的经验，最严重的错误是实时错误，它与多线程交互有关。我对付这些错误的方法是避免制造它们。所以我不喜欢线程。我认为线程是一种糟糕的编程模型。它们有时必然是邪恶的，但对于我们使用线程的大多数事情来说，它们并不是必需的。</p><p class="normal">In my experience, the worst bugs are the real-time bugs, which have to do with interactions with multiple threads. My approach to those bugs is to avoid making them. So I don't like threads. I think threads are an atrocious programming model. They're an occasionally necessarily evil, but they're not necessary for most of the things we use threads for.</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_122"></a>我喜欢浏览器模型的一件事是我们只有一个线程。有些人对此抱怨 — 如果您锁定该线程，则浏览器也被锁定。所以你只是不这样做。一直有人呼吁将线程放入 JavaScript，但到目前为止我们一直拒绝这样做。我真的很高兴我们有。</p><p class="normal"><a></a>One of the things I like about the browser model is that we only get one thread. Some people complain about that—if you lock up that thread, then the browser's locked up. So you just don't do that. There are constantly calls for putting threads into JavaScript and so far we've resisted that. I'm really glad we have.</p>
<p class="normal">我们在浏览器中使用的基于事件的模型非常有效。它唯一失败的地方是你的某些过程花费的时间太长。我真的很喜欢 Google 在 Gears 中采用的方法来解决这个问题，他们有一个完全隔离的单独进程，您可以将程序发送到该进程并在那里运行。完成后，它会告诉您结果，并且结果会作为事件返回。那是一个很棒的模型。</p><p class="normal">The event-based model, which is what we're using in the browser, works really well. The only place where it breaks down is if you have some process that takes too long. I really like the approach that Google has taken in Gears to solving that, where they have a separate process which is completely isolated that you can send a program to and it'll run there. When it's finished, it'll tell you the result and the result comes back as an event. That's a brilliant model.</p>
<p class="normal"><b>Seibel：</b>你曾经对形式证明感兴趣吗？</p><p class="normal"><b>Seibel:</b> Have you ever been interested in formal proofs?</p>
<p class="normal"><b>Crockford：</b>我在 70 年代密切关注它，看看他们是否会想出什么办法。我没有看到它得到回报。软件是如此复杂，并且在很多方面都可能出错。</p><p class="normal"><b>Crockford:</b> I watched it closely during the '70s, looking to see if they were going to come up with anything. And I didn't see it paying off. Software is so complicated and can go wrong in so many ways.</p>
<p class="normal">基本上，软件是软件应该如何工作的规范。任何低于完整规范的东西都不会真正告诉你它最终会如何表现。这只会让软件变得非常非常难。</p><p class="normal">Basically, software is the specification for how the software is supposed to work. And anything less than the complete specification doesn't really tell you anything about how it's ultimately going to behave. And that just makes software really, really hard.</p>
<p class="normal"><b>Seibel：</b>你如何测试代码？正如他们最近所说的那样，您是否被测试感染了？</p><p class="normal"><b>Seibel:</b> How do you test code? Are you, as they say these days, test-infected?</p>
<p class="normal"><b>克罗克福德：</b>我倾向于更临时。这是我考虑改变风格的另一个地方，但我还没有完成。</p><p class="normal"><b>Crockford:</b> I tend to be more ad hoc. That's another place where I'm considering changing my style, but I haven't accomplished that yet.</p>
<p class="normal"><b>Seibel：</b>有一个 JsUnit，对吧？</p><p class="normal"><b>Seibel:</b> There is a JsUnit, right?</p>
<p class="normal"><b>Crockford：</b>有一个 JsUnit。UI 代码的测试真的很困难，因为它确实依赖于很多东西，所以将它分解成单元往往效率较低。另外，我发现因为我正在写的风格<a id="OEBPS/Chapter03.html.page_123"></a>在 JavaScript 中，它不会像类那样以有序的方式分解为多个单元，因此您可以考虑单独测试一个类。</p><p class="normal"><b>Crockford:</b> There is a JsUnit. Testing of UI code is really difficult because it's really dependent on a whole lot of stuff, so breaking it down into units tends to be less effective. Also, I found because of the style that I'm writing <a></a>in JavaScript, it doesn't break in an orderly way into units the way classes do, so you can think about testing a class in isolation.</p>
<p class="normal">在 JavaScript 中，孤立地测试一个函数可能没有多大意义，因为它需要状态才能变得有趣。我还没有找到一种足够有用的方法来测试 JavaScript 单元。</p><p class="normal">In JavaScript, testing a function in isolation maybe doesn't make much sense because there's the state that it needs in order to be interesting. I haven't figured out a sufficiently useful way of testing units of JavaScript yet.</p>
<p class="normal"><b>Seibel：</b>在有独立 QA 组的地方，开发人员和 QA 组应该如何协同工作？</p><p class="normal"><b>Seibel:</b> In places that have separate QA groups, how should developers and QA groups work together?</p>
<p class="normal"><b>Crockford：</b>我曾经有过开发团队和测试团队之间存在对立的公司，我认为这是非常不健康的。有这样一种理论，你将两者分开，基本上，一个会淘汰另一个。我只是认为这是一个可怕的模型。</p><p class="normal"><b>Crockford:</b> I've had companies where there was an antagonism between the development teams and the testing teams, which I thought was extremely unhealthy. There was this theory that you keep the two separate and one would rat out the other, basically. And I just think it's a horrible model.</p>
<p class="normal">当我们将两个团队放在一起并让测试人员负责帮助开发人员改进他们的程序而不是出卖开发人员时，它的效果要好得多。它改变了他们报告的方式并且更加有效。此外，将开发人员循环到测试中，这样你就不会完全成为其中之一。</p><p class="normal">It worked much better when we put the two teams together and made the testers responsible for helping the developers to make their programs better, rather than ratting out the developers. It changed the way they reported and was much more effective. Also, cycling the developers into testing, so you weren't exclusively one or the other.</p>
<p class="normal">我发现最有效的地方是将测试进行到极致：去拜访客户。我在我职业生涯的早期就做过一些这样的事情，那是一次很棒的经历，我不得不与客户一起生活一周，帮助他们安装新系统，并帮助他们解决使用它时遇到的问题。</p><p class="normal">The place where I found that to be most effective was taking testing, sort of, to the ultimate: going to visit customers. I did some of that early in my career and that was a great experience, having to go live with a customer for a week, helping them to install a new system, and helping them to work out the problems with using it.</p>
<p class="normal">它让我深入了解实际使用我们的东西是什么感觉，以及我想做什么来造福那些将要使用我的东西的人。事后回过头来看，没有那种经历的开发人员在我看来都显得非常傲慢，这是完全不可原谅的。他们对使用我们产品的人缺乏尊重令人震惊，这基本上是他们从未见过这些人的结果。</p><p class="normal">It gave me a huge amount of insight into what it's like to actually use our stuff and what I want to be doing for the benefit of the people who are going to be using my stuff. Going back afterwards, developers who had not had that experience all seemed arrogant to me in a way which was completely inexcusable. The lack of respect they had for the people who used our stuff was appalling and it was basically a consequence of their having never met those people.</p>
<p class="normal"><b>Seibel：</b>你认为自己是科学家、工程师、艺术家、工匠还是其他什么？</p><p class="normal"><b>Seibel:</b> Do you consider yourself a scientist, an engineer, an artist, a craftsman, or something else?</p>
<p class="normal"><b>克罗克福德：</b>我认为自己是一名作家。有时我用英语写作，有时我用 JavaScript 写作。</p><p class="normal"><b>Crockford:</b> I think of myself as a writer. Sometimes I write in English and sometimes I write in JavaScript.</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_124"></a>这一切都归结为沟通以及您为促进沟通而使用的结构。人类语言和计算机语言在许多方面的工作方式非常不同，但最终我判断一个好的计算机程序是根据它与阅读该程序的人进行交流的能力。所以在那个层面上，他们并没有什么不同。</p><p class="normal"><a></a>It all comes down to communication and the structures that you use in order to facilitate that communication. Human language and computer languages work very differently in many ways, but ultimately I judge a good computer program by its ability to communicate with a human who reads that program. So at that level, they're not that different.</p>
<p class="normal"><b>Seibel：</b>如果它能很好地与人交流，你觉得与计算机交流的部分会失败吗？</p><p class="normal"><b>Seibel:</b> And if it can communicate well to a human, you feel like the communicating-with-the-computer part will fall out?</p>
<p class="normal"><b>克罗克福德：</b>你希望如此。计算机是任意的，不是很聪明，所以你必须付出特别的努力来确保他们得到它。因为那太难了，所以很容易忽略另一部分，但我认为它至少同样重要。</p><p class="normal"><b>Crockford:</b> You hope so. Computers are arbitrary and not very smart, so you have to make special efforts to make sure that they get it. Because that's so hard, it's easy to overlook the other part, but I think it is at least as important.</p>
<p class="normal"><b>Seibel：</b>所以 Dijkstra 有一篇著名的论文，“关于真正教授计算科学的残酷性”，基本上说计算机编程是应用数学的一个分支。你同意？</p><p class="normal"><b>Seibel:</b> So Dijkstra had a famous paper, “On the cruelty of really teaching computing science,” that basically said computer programming is a branch of applied math. Do you agree?</p>
<p class="normal"><b>Crockford：</b>数学在编程中很重要，但它只是众多重要事物中的一种。我认为，如果你过分强调数学，那么你就会低估可能更重要的东西，比如识字能力。</p><p class="normal"><b>Crockford:</b> Mathematics is important in programming, but it's just one of a lot of things that are important. I think if you overemphasize the math then you underemphasize stuff which might be even more important, such as literacy.</p>
<p class="normal">我提到我想有他们必须读过 Knuth 的招聘要求，但我不能那样做，因为我找不到足够多的人读过。我想要的另一件事是，无论他们用什么语言写给其他人，他们都能真正识字。我想要会写作的人，因为我们花了很多时间给彼此写信。我们正在写电子邮件或文档。我们正在写计划。我们正在编写规范。我想知道我团队中的人是否有能力做到这一点，事实证明这是一项非常困难的技能。所以我实际上更愿意看到人们从英语专业开始，而不是从数学专业开始进入编程。</p><p class="normal">I mentioned I wanted to have the hiring requirement that they had to have read Knuth and I couldn't do that because I couldn't find enough people who had. The other thing I wanted was that they be really literate in whatever language they write to other humans. I want people who can write, because we spend a lot of time writing to each other. We're writing email or documentation. We're writing plans. We're writing specifications. I want to know that the people on my team are capable of doing that, and that turns out to be a really difficult skill. So I would actually rather see people start as English majors than as math majors to get into programming.</p>
<p class="normal"><b>Seibel：</b>我认为 Dijkstra 对此有另一句话，“如果你不能用你的母语写作，就放弃吧。”</p><p class="normal"><b>Seibel:</b> I think Dijkstra had another quote about that along the lines of, “If you can't write in your native language, give it up.”</p>
<p class="normal"><b>克罗克福德：</b>我同意这一点。</p><p class="normal"><b>Crockford:</b> I agree with that one.</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_125"></a><b>Seibel：</b>你似乎一直遇到的编程方面是，当我们不受物理约束的束缚时，我们会被历史事故所束缚。您关于子集 JavaScript 和您的 HTML5 版本的许多建议似乎都是为了修复这些历史事故。</p><p class="normal"><a></a><b>Seibel:</b> An aspect of programming that you seem to keep running up against is that while we are unbound by physical constraints we get tied down by accidents of history. A lot of your proposals for subsetting JavaScript and your version of HTML5 seem to be attempts to fix these kinds of historical accidents.</p>
<p class="normal"><b>克罗克福德：</b>是的，其中一些是不切实际的。我知道很多我希望完成的事情是无法实现的。我对此很清楚。但每隔一段时间就会有一些效果。就像当 XML 被提议作为一种数据交换格式时，我的第一印象是，“天哪，这太复杂了。我们不需要所有这些东西来回移动数据。” 所以我提出了另一种方法，它成功了。JSON 现在是在 Ajax 应用程序中进行数据传输的首选方式，并且在很多其他应用程序中也很受欢迎。这真的很简单。所以这恢复了我对人性的信心，也许我们最终可以把其中的一些事情做对。</p><p class="normal"><b>Crockford:</b> Yeah, and some of it is quixotic. I know that a lot of the things that I'm hoping to accomplish are not achievable. I'm aware of that. But every once in a while something works. Like when XML was proposed as a data-interchange format, my first impression of that was, “My god, this is way, way, way too complicated. We don't need all of this stuff just to move data back and forth.” And so I proposed another way to do it, and it won. JSON is now the preferred way of doing data transfer in Ajax applications and it's winning in a whole lot of other applications. And it's just really simple. So that restores my faith in humanity, that maybe we can finally get some of these things right.</p>
<p class="normal">但你不能让每个人都离开，编造自己的东西。那是行不通的。那对任何人都没有好处。但是一个人必须编造一件事，而其他人必须弄清楚如何就我们将支持其中的哪一个达成一致。JSON 是另一种历史事故。</p><p class="normal">But you can't have everybody going off, making up their own thing. That doesn't work. That doesn't do anybody any good. But one person has to make up a thing and everyone else has to figure out how to agree which one of those we're all going to get behind. JSON was a different kind of accident of history.</p>
<p class="normal"><b>Seibel：</b>总的来说，您认为软件行业是一个出色的创新引擎还是一个可怕的烂摊子？</p><p class="normal"><b>Seibel:</b> Overall, do you think that the software industry is a brilliant engine of innovation or a horrible mess?</p>
<p class="normal"><b>克罗克福德：</b>我正在想一个很好的方式来表达“一团糟”。我认为总体上软件已经变得更好了。与摩尔让硬件变得更好的步伐不同。我们跟踪的方式比他慢得多，所以我们需要 20 年才能将软件开发效率提高一倍。但我们已经看到了改进。我们的大部分改进都是因为我们不必再让它合身了。我们不必再让它变快了。所以这应该让我们解放出来，让它变得更好。但我认为我们没有花足够的时间这样做。</p><p class="normal"><b>Crockford:</b> I'm trying to think of a nice way to say, “Horrible mess.” I'd think generally software has gotten better. Not at the same pace that Moore lets the hardware got better. We track way, way slow compared to him, so it takes us 20 years to double our efficiency in software development. But we have seen improvement. Most of our improvement is due to the fact that we don't have to make it fit anymore. We don't have to make it fast anymore. So that should have liberated us to just making it good. But we don't spend enough time doing that, I think.</p>
<p class="normal"><b>Seibel：</b>所以如果我们是，不管你怎么说，一团糟，我们该怎么做才能不那么乱？</p><p class="normal"><b>Seibel:</b> So if we are, however nicely you put it, a horrible mess, what could we do to not be such a mess?</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_126"></a><b>克罗克福德：</b>这就是我想弄清楚的。我认为其中很大一部分与我们创建标准的方式有关。事情之所以能像现在这样运作，是因为网络有效；随之而来的所有好处都来自于能够将所有东西联系在一起并且非常可靠地发生。</p><p class="normal"><a></a><b>Crockford:</b> That's what I'm trying to figure out. A lot of it I think has to do with the way that we create standards. The reason why things are working as well as they are now is because the Net works; all the benefits that came, came from being able to tie everything together and have that happen pretty reliably.</p>
<p class="normal">但是您不必深入研究就可以找到我们做错的地方，或者我们可以做得更好的地方。难题是，我们如何解决这些问题？任何时候我们更改软件标准，都是一种暴力行为。这是破坏性的。它会导致东西失败。它会给人们带来成本和伤害。所以我们在修改标准时需要非常小心，因为这是有代价的。我们必须确保我们增加了如此多的价值来抵消该成本。从我目前对标准的操纵方式来看，这并没有发生。标准变更的动机是“我们想做”或“因为它会很整洁”或其他一些与为世界创造大量价值不一定密切相关的动机。所以我正在努力解决这个问题。我们如何在这方面做得更好？</p><p class="normal">But you don't have to scratch it very deep to find places where we got that wrong, where we could've got it better. The dilemma is, how do we fix this stuff in place? Anytime we change a software standard, it's an act of violence. It is disruptive. It will cause stuff to fail. It will cause cost and harm to people. So we need to be really careful when we revise the standards because there is that cost. We have to make sure that we're adding so much value to offset that cost. From what I see of the way that standards are being manipulated right now, that's not occurring. Standard changes are being motivated by “we want to do it” or “because it'd be neat” or some other motivation which is not necessarily closely related to creating a lot of value for the world. So I'm struggling with that. How do we get better at that?</p>
<p class="normal"><b>Seibel：</b>你似乎倾向于减少指定。显然，这是一种避免过度指定事物和标准化事物的方法，而您以后会后悔。但是，如果标准中指定的内容较少，那么人们就必须编造更多的东西，当人们试图确定完成工作的好方法时，你将拥有一大堆事实上的标准。如果复杂性突然出现在其他地方，让标准更简单真的能解决问题吗？</p><p class="normal"><b>Seibel:</b> You seem to lean toward specifying less. That, obviously, is a way to avoid over specifying things and standardizing things that you're going to regret later. But if less is specified in standards, then people have to make more stuff up and you're going to have a big pile of de facto standards as people try to settle on OK ways of getting stuff done. Is making standards simpler really going to fix the problem, if the complexity just pops up elsewhere?</p>
<p class="normal"><b>克罗克福德：</b>我们真正需要做的是更好地预测我们未来真正需要什么。也许我们必须等待时间旅行才能最终开始正确处理这些事情。与此同时，我认为可能方法的实验和扩散是一件积极的事情，因为也许采用标准化的正确方法是弄清楚哪些是经过深思熟虑的，哪些是最可维护的，哪些是最容易成长，然后选择那个。我们不是标准委员会试图猜测最好的方法，而是从市场上的例子中挑选出实际上可以证明是最好的方法。</p><p class="normal"><b>Crockford:</b> What we really need to be doing is getting better at predicting what we're really going to need in the future. Maybe we have to wait for time travel before we finally start getting this stuff right. In the meantime, I look on that experimentation and proliferation of possible approaches as a positive thing in that maybe the right approach to take to standardization is to figure out which of those are the best thought out, which are the most maintainable, which are the most growable, and pick that. Rather than a standards committee trying to guess the best way to do it, we pick from examples in the marketplace what is actually demonstrably the best way to do it.</p>
<p class="normal"><b>Seibel：</b>但你觉得总体上我们正在取得一些进展？</p><p class="normal"><b>Seibel:</b> But you feel like overall we're making some progress?</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_127"></a><b>克罗克福德：</b>进步并不总是向前的。有时我们向前跳跃，有时我们向后跳跃。当我们转向 PC 时，我们丢失了很多东西。在分时时代，我们有在线社交系统。分时系统是一个市场。这是一个社区，属于该系统的每个人都可以交换电子邮件、交换文件、聊天、玩游戏。他们正在做所有这些事情，而当我们转向 PC 时，所有这些都丢失了。又花了 20 年左右的时间才把它找回来。</p><p class="normal"><a></a><b>Crockford:</b> Progress isn't always forward. Sometimes we're leaping forward and sometimes we're leaping backwards. When we leaped to the PC, we lost a whole lot of stuff. In the timesharing era, we had social systems online. A timesharing system was a marketplace. It was a community and everybody who was a part of that system could exchange email, they could exchange files, they could chat, they could play games. They were doing all this stuff and all that got lost when we went to PCs. It took another 20 years or so to get that back.</p>
<p class="normal">我们在安全方面也倒退了一大步。分时系统开始了解如何保护系统和系统用户免受彼此的侵害。当我们使用 PC 时，你拥有你的机器，那台机器上运行的所有东西都有相同的特权，有相同的权利做任何它必须做的事情，结果证明并不是你机器上运行的所有软件都符合你的利益. 我们仍在为此苦苦挣扎。我们已经看到 PC 操作系统有了很多改进，但我们还没有回到一些更具前瞻性的分时系统的地步。</p><p class="normal">We also took a huge step backwards in terms of security. Timesharing systems were starting to understand how to defend the system and the users of the system from each other. When we went to PCs, you owned your machine and everything running in that machine had the same privileges, the same rights to do whatever it had to do, and it turned out that not all the software running in your machine is acting in your interest. We're still struggling with that. We've seen lots of improvements going into the PC operating systems, but we're still not at the point where some of the more forward-looking timesharing systems were way, way back.</p>
<p class="normal"><b>Seibel：</b>你想到了哪些？</p><p class="normal"><b>Seibel:</b> Which ones are you thinking of?</p>
<p class="normal"><b>Crockford：</b> MULTICS 在协作过程中做了一些非常有趣的事情，并且有多个地址空间可以相互通信但不能进入彼此的东西。这是开始进行协作计算所需的基本基准。我们现在正试图弄清楚如何将其放入浏览器中。从 MULTICS 到这里已经过了很长时间。我们现在开始追赶当时正在采取行动的见解。</p><p class="normal"><b>Crockford:</b> MULTICS was doing some really interesting stuff in cooperative processes, and having multiple address spaces which were able to communicate with each other but couldn't get into each other's stuff. That's the basic baseline you need in order to start doing cooperative computing. And we're now trying to figure out how to get that into the browser. It's a long time between MULTICS and here. We're starting now to catch up to insights that were being acted on way back then.</p>
<p class="normal"><b>Seibel：</b>我注意到语言也有类似的事情——PC 是用汇编编程的，因为即使 C 也太高级了，直到现在我们才回到具有 PC 出现时存在的 Smalltalk 和 Lisp 等语言的一些强大功能的语言出去。我想知道程序员是否尽可能了解我们领域相对较短的历史，或者我们是否一直在重新发明轮子？</p><p class="normal"><b>Seibel:</b> I've noticed a similar thing with languages—PCs were programmed in assembly because even C was too high-level and only now are we getting back to languages with some of the power of languages like Smalltalk and Lisp that existed when PCs came out. I wonder if programmers are as aware of the relatively short history of our field as they could be, or do we keep reinventing the wheel?</p>
<p class="normal"><b>克罗克福德：</b>我认为我们很遗憾地没有意识到我们的历史，而且我经常很失望地看到现在正在练习这门手艺的人对这些东西的来源没有求知欲，而只是<a id="OEBPS/Chapter03.html.page_128"></a>假设某个委员会做对了，并向他们提供了一套工具或语言，他们所要做的就是正确使用它。</p><p class="normal"><b>Crockford:</b> I think we're tragically unaware of our history, and I'm often really disappointed to see that people who are now practicing this craft having no intellectual curiosity about where this stuff came from and just <a></a>assume that some committee got it right and presented them with a set of tools or languages, and all they have to do is use it properly.</p>
<p class="normal">关于这些东西从何而来，是什么影响了什么，谁做了什么，现在被认为是错误的，以及<i>应该</i>被认为是错误的，但还没有发生的事情，有很多惊人的故事。有时我认为自己是软件技术的考古学家，多年来我积累了这些未被充分认识的技术，我认为这些技术真的非常好，远远领先于我们的艺术水平。现在正在做。我一直希望我们能以某种方式重新发现这些东西并学会欣赏它并从中受益，但这是一个非常缓慢的过程。我看到人们对现在的工作方式确实根深蒂固，而且真的很难改变。</p><p class="normal">There are amazing stories about where this stuff came from, and what influenced what, and who did what, and what is now considered a mistake, and what <i>should</i> be considered a mistake, but hasn't yet. I think of myself sometimes as an archaeologist of software technology and over the years I've accumulated this collection of underappreciated technology, things that I think were really, really good, which are significantly in advance of the state of the art of what we're doing now. I keep hoping that we will somehow rediscover this stuff and learn to appreciate it and benefit from having done it, but it's a really slow process. I see folks are really entrenched in the way that things are working right now and it's really difficult to move.</p>
<p class="normal"><b>Seibel：</b>这些技术有哪些？</p><p class="normal"><b>Seibel:</b> What are some of those technologies?</p>
<p class="normal"><b>Crockford：</b> Lisp 和 Smalltalk，你刚才提到了。那是很棒的东西，我们现在终于看到这些想法被纳入现代语言中，所以我们现在正在 JavaScript 中做很多工作并试图使其现代化。事实证明，JavaScript 已经预料到了这些东西；它具有词法作用域和一流的功能，这非常棒。现在我们正试图弄清楚如何在不破坏它的情况下将 Smalltalk 和 Scheme 的更多优点融入到这种语言中。你可能会争辩说，如果我们放弃我们现在正在做的所有事情并回到 Smalltalk 和 Scheme，我们会过得更好，而且我们可能会过得比现在更好，但这似乎并没有成为一种选择。</p><p class="normal"><b>Crockford:</b> Lisp and Smalltalk, you've just mentioned. That's brilliant stuff, and we're now finally seeing those ideas being factored into modern languages, so we're doing a lot of work now in JavaScript and trying to modernize that. It turns out JavaScript already anticipated a bunch of that stuff; it's got functions which are lexically scoped and first-class, which was brilliant. Now we're trying to figure out how to get more of the goodness of Smalltalk and Scheme into this language without breaking it. You could argue that we'd be better off if we just threw out everything we're working on now and go back to Smalltalk and Scheme, and we probably would be better off than we are right now, but that doesn't appear to be an option.</p>
<p class="normal">随着我们越来越多地使用混搭，我们希望拥有来自各地的代码——我们永远、永远不会测试的东西——实际上在现场用完了。这是一种新的编程方式。我们以前从未这样做过。我认为这是编程的未来，我们首先在 JavaScript 中实现它，它在这里工作是因为这种语言，尽管它犯了所有错误，但其他的东西都是正确的。</p><p class="normal">As we're getting more and more into mash-ups, we want to have code from all over the place—stuff that we'll never, ever test with—actually run out in the field. Which is a new kind of programming. We've never done that before. I think that's the future of programming and we're getting to it in JavaScript first and it's working here because the language, in spite of all the stuff it got wrong, got this other stuff right.</p>
<p class="normal">看看我们在编程时间轴上所处的位置，我们从机器代码开始，然后我们飞跃到符号汇编语言，然后我们飞跃到高级语言，然后我们飞跃到结构化编程，然后我们迈出了面向对象编程的一步。每一次飞跃都需要一代人的时间。</p><p class="normal">Looking at where we've come on the timeline of programming, we started with machine codes and then we took a leap to symbolic assembly language and then we took a leap to high-level languages and then we took a leap to structured programming and then we took a leap to object-oriented programming. And each of these leaps takes about a human generation.</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_129"></a>我们迟到了下一个。我们已经有一段时间了。你可以说它是 Smalltalk-80。你可以早一点回去，但我们已经对这些想法坐了很长时间了。</p><p class="normal"><a></a>We're overdue on the next one. We've been at object for a while. You could argue it was Smalltalk-80. You could go back a little bit earlier, but we've been sitting on these ideas for a long time.</p>
<p class="normal">我认为下一个飞跃，我们还不知道它的名字是什么，但我认为它与混搭有关，我们可以随意地把一些程序放在一起，然后立即制作新程序。几十年来，我们一直在谈论一种编程模型，在这种模型中，我们像乐高积木一样将程序拼凑在一起并制作东西。那还没有发生。但我认为它现在开始发生了，它发生的地方是在 JavaScript 中，这是最不可能发生的地方。</p><p class="normal">I think the next leap, we don't know what the name of it is yet, but I think it's something related to mash-ups where we can casually take bits of program and put them together and immediately make new programs. We've been talking for decades about a model of programming in which we snapped programs together like LEGO and make stuff. That hasn't happened yet. But I think it is starting to happen now and the place it's happening is in JavaScript, which is the least likely place.</p>
<p class="normal"><b>Seibel：</b>当你招聘程序员时，你如何识别优秀的程序员？</p><p class="normal"><b>Seibel:</b> When you're hiring programmers, how do you recognize the good ones?</p>
<p class="normal"><b>Crockford：</b>我现在采用的方法是进行代码阅读。我邀请候选人带来一段他真正引以为豪的代码，并引导我们完成它。</p><p class="normal"><b>Crockford:</b> The approach I've taken now is to do a code reading. I invite the candidate to bring in a piece of code he's really proud of and walk us through it.</p>
<p class="normal"><b>Seibel：</b>你在找什么？</p><p class="normal"><b>Seibel:</b> And what are you looking for?</p>
<p class="normal"><b>Crockford：</b>我正在寻找演示的质量。我想看看他认为什么是他引以为豪的事情。我想看到证据，证明他实际上是他所捍卫的东西的作者。我发现这比让他们解决难题或琐事问题要有效得多。我认为所有这些东西都是无用的。但他们的沟通效率如何，这是我招聘的一项技能。</p><p class="normal"><b>Crockford:</b> I'm looking for quality of presentation. I want to see what he thinks is something he's proud of. I want to see evidence that in fact he is the author of the thing that he's defending. I find that is much more effective than asking them to solve puzzles or trivia questions. I see all that kind of stuff as useless. But how effectively they can communicate, that's a skill that I'm hiring for.</p>
<p class="normal"><b>Seibel：</b>您对自学成才的程序员有什么建议吗？</p><p class="normal"><b>Seibel:</b> Do you have any advice for self-taught programmers?</p>
<p class="normal"><b>Crockford：</b>是的，多读书。那里有好书。找到好的并阅读那些。如果您正在进行 Web 开发，请找到最好的网站并查看他们的代码。虽然我有点不愿意给出那个建议。大多数 Web 开发人员通过“查看源代码”来学习进行 Web 开发，直到最近，大多数源代码都非常糟糕。所以你有一代程序员是在非常糟糕的例子中长大的，他们认为糟糕的代码是编写的方式。</p><p class="normal"><b>Crockford:</b> Yeah, read a lot. There are good books out there. Find the good ones and read those. And if you're doing web development, find the best sites and look at their code. Although I'm a little reluctant to give that advice yet. Most web developers learned to do web development by doing “view source,” and until fairly recently, most of the source that was out there was very bad. So you had a generation of programmers who were raised on really bad examples, thinking bad code was the way to write.</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_130"></a>现在情况有所好转，但仍然有很多不好的东西，我还不愿意给出那个建议。</p><p class="normal"><a></a>That's getting better now, but there's still so much bad stuff out there that I'm reluctant to give that advice yet.</p>
<p class="normal"><b>Seibel：</b>对于真正获得 CS 学位并想从事程序员工作的人有什么建议吗？</p><p class="normal"><b>Seibel:</b> What about advice for someone who's actually getting a C.S. degree who wants to work as a programmer?</p>
<p class="normal"><b>克罗克福德：</b>我会专注于沟通方面。学习写作；学着阅读。</p><p class="normal"><b>Crockford:</b> I would focus on the communication aspect. Learn to write; learn to read.</p>
<p class="normal">我对每个人的建议几乎都是一样的，阅读和写作。我通常不会雇用特定技能的人。直到最近，您还无法聘请优秀的 JavaScript 程序员。它们极为罕见。现在有很多非常好的东西，但那是最近才发生的事情。所以在那之前，我只会聘请质量。您是优秀的 Java 程序员、优秀的 C 程序员还是其他什么？我不在乎。我只想知道您知道如何将算法放在一起，了解数据结构，并且知道如何记录它。如果你能做到这一点，你应该能够理解 JavaScript。</p><p class="normal">My advice to everybody is pretty much the same, to read and write. I generally don't hire for specific skills. Until very recently, you couldn't hire good JavaScript programmers. They were extremely rare. There are a lot of really good ones out there now, but that's a fairly recent thing. So until that happened, I would just hire for quality. Are you a good Java programmer, a good C programmer, or whatever? I don't care. I just want to know that you know how to put an algorithm together, you understand data structures, and you know how to document it. If you can do that, you should be able to figure out JavaScript.</p>
<p class="normal"><b>Seibel：</b>你遇到过这样的问题吗？在一种语言上取得成功的人有时很难放弃他们的旧方法，即使是在使用一种他们并没有真正意义的新语言时也是如此。</p><p class="normal"><b>Seibel:</b> Have you ever had problems with that? People who've been successful in one language sometimes have a hard time giving up their old ways, even when working in a new language where they don't really make sense.</p>
<p class="normal"><b>克罗克福德：</b>我有，比如说，Windows 程序员。Windows 有许多非常复杂的 API，您可能需要花费数年时间才能了解这些 API 的工作原理。这几乎就是您所做的一切，您是否知道一个 API。您可以编写一个窗口句柄，但您无能为力。除非我有一个非常具体的利基市场，否则我不会去寻找那种过度专业化的东西。一般来说，我更喜欢通才。我想要能够学习任何这些 API 但不一定精通任何一种 API 的人。</p><p class="normal"><b>Crockford:</b> I have with, say, Windows programmers. Windows has a number of very complicated APIs and you can spend years just understanding how those APIs work. And that's pretty much all you do, is you know that one API. You can write a window handle but there's not much else you can do. I tend not to look for that kind of overspecialization unless I have a really specific niche. Generally, I prefer generalists. I want someone who's capable of learning any of those APIs but isn't necessarily skilled in any one.</p>
<p class="normal"><b>Seibel：</b>你之前说过你接触计算机是因为你认为它们会让世界变得更美好。</p><p class="normal"><b>Seibel:</b> You said earlier that you got into computers because you thought they would make the world a better place.</p>
<p class="normal"><b>克罗克福德：</b>那是我的意图。</p><p class="normal"><b>Crockford:</b> That's my intention.</p>
<p class="normal"><b>Seibel：</b>结果如何？</p><p class="normal"><b>Seibel:</b> How's that working out?</p>
<p class="normal"><a id="OEBPS/Chapter03.html.page_131"></a><b>克罗克福德：</b>在大多数情况下，我们做得很好。我认为世界是一个更好的地方，尽管它并不总是向前发展。比如说，看看过去十年的国际政治，大媒体的整合及其腐败影响并没有被开放网络所弥补。这是一个很大的失望。</p><p class="normal"><a></a><b>Crockford:</b> For the most part, we've done pretty good. I think the world is a better place, although it's not always moving forward. Looking at, say, international politics over the last ten years, the consolidation of big media and the corrupting effects of that have not been compensated for by the open network. That's a big disappointment.</p>
<p class="normal">数十万人因此直接死亡。真是令人难过。我希望网络做得更好，这样类似的事情就不会再发生了。目前尚不清楚为了实现这一目标必须对网络进行哪些转换。也许它自己会好起来的，但我更悲观。我认为我们需要找出下一个飞跃，以克服现在不起作用的任何问题。</p><p class="normal">Hundreds of thousands of people have died as a direct consequence of that. That's really sad. I would like for the network to be doing a better job so that kind of stuff doesn't happen again. It's not clear yet what transformations to the network have to occur in order to accomplish that. And maybe it'll be fine on its own, but I'm more pessimistic. I think we need to figure out the next leap in order to overcome whatever is not working now.</p>
<p class="normal"><b>Seibel：</b>那里的数以百万计的博主不会说，“嘿，我们在这里写关于一切的博客，而主流媒体正在考虑它。”</p><p class="normal"><b>Seibel:</b> Wouldn't the gazillion bloggers out there say, “Hey, we're out here blogging about everything and the mainstream media is taking it in the pants.”</p>
<p class="normal"><b>克罗克福德：</b>是的，那太好了。我们还是弄错了。我们有一个很棒的东西，我们可以连接在一起，我们可以互相传递信息，但它不起作用。在这一点上只是很多噪音。</p><p class="normal"><b>Crockford:</b> Yeah, that's great. We still got it wrong. We've got this great thing where we can all get wired together and we can all get the message out to each other, but it's not working. It's just a lot of noise at this point.</p>
<p class="normal"><b>Seibel：</b>您认为该问题的部分解决方案是技术性的吗？程序员或系统设计人员可以做些什么来调整架构以提供帮助吗？还是社会问题？</p><p class="normal"><b>Seibel:</b> And do you think that part of the solution of that problem will be technical? Is there something programmers or system designers can do to tweak the architecture that will help? Or is it a social problem?</p>
<p class="normal"><b>Crockford：</b>可能新的社会系统必须在这个新的网络基础设施之上发展，而它在这一点上还不成熟，这就是它不起作用的原因。也许它只是自己解决。我希望是这样。但我认为可能会有更多的参与。现在，网络在身份识别和安全方面做得非常差，我认为这些是构建强大社会系统的必要组成部分。因此，Web 的这一方面仍然存在缺陷，也许这就是它仍然如此嘈杂的原因。</p><p class="normal"><b>Crockford:</b> It may be that new social systems have to evolve on top of this new network infrastructure and it's just immature at this point and that's why it's not working. Maybe it just solves itself. I'm hoping that's the case. But I think there may be more involved. Right now, the network does an extremely poor job of identity, does an extremely poor job of security, and those are a necessary component, I think, of building robust social systems. So that aspect of the Web is still deficient and maybe that's why it's so noisy still.</p>
</div>
</div></div>
<div id="OEBPS/Chapter04.html"><div>

<div class="booksection">
<p></p>
<h2 class="chapnum"><a id="OEBPS/Chapter04.html.ch3"></a><a id="OEBPS/Chapter04.html.page_133"></a><img src="data:image/jpg;base64,/9j/4AAQSkZJRgABAgEASABIAAD/7Q0OUGhvdG9zaG9wIDMuMAA4QklNA+0KUmVzb2x1dGlvbgAAAAAQAEgAAAABAAEASAAAAAEAAThCSU0EDRhGWCBHbG9iYWwgTGlnaHRpbmcgQW5nbGUAAAAABAAAAHg4QklNBBkSRlggR2xvYmFsIEFsdGl0dWRlAAAAAAQAAAAeOEJJTQPzC1ByaW50IEZsYWdzAAAACQAAAAAAAAAAAQA4QklNBAoOQ29weXJpZ2h0IEZsYWcAAAAAAQAAOEJJTScQFEphcGFuZXNlIFByaW50IEZsYWdzAAAAAAoAAQAAAAAAAAACOEJJTQP1F0NvbG9yIEhhbGZ0b25lIFNldHRpbmdzAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+BdDb2xvciBUcmFuc2ZlciBTZXR0aW5ncwAAAHAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAOEJJTQQAC0xheWVyIFN0YXRlAAAAAgABOEJJTQQCDExheWVyIEdyb3VwcwAAAAAEAAAAADhCSU0ECAZHdWlkZXMAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4NVVJMIG92ZXJyaWRlcwAAAAQAAAAAOEJJTQQaBlNsaWNlcwAAAAB1AAAABgAAAAAAAAAAAAAArwAAAPkAAAAKAFUAbgB0AGkAdABsAGUAZAAtADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAPkAAACvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhCSU0EERFJQ0MgVW50YWdnZWQgRmxhZwAAAAEBADhCSU0EFBdMYXllciBJRCBHZW5lcmF0b3IgQmFzZQAAAAQAAAACOEJJTQQMFU5ldyBXaW5kb3dzIFRodW1ibmFpbAAACTEAAAABAAAAcAAAAE8AAAFQAABnsAAACRUAGAAB/9j/4AAQSkZJRgABAgEASABI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" alt="图片"></h2><h2 class="chapnum"><a></a><a></a></h2>
<h2 class="chaptitle">布伦丹·艾奇</h2><h2 class="chaptitle">Brendan Eich</h2>
<div class="sidebar">
<p class="normal"><i>JavaScript 的创建者，也许是现代 Web 上使用最广泛和最受诟病的编程语言，Brendan Eich 现在是 Mozilla Corporation 的首席技术官，Mozilla Foundation 的子公司负责 Firefox 浏览器的持续开发。</i></p><p class="normal"><i>Creator of JavaScript, perhaps the most widely used and most reviled programming language on the modern Web, Brendan Eich is now CTO of the Mozilla Corporation, the subsidiary of the Mozilla Foundation responsible for continuing development of the Firefox browser.</i></p>
<p class="normal"><i>凭借对优雅理论和良好实用工程的欣赏，Eich 在 Silicon Graphics 和 MicroUnity 度过了他职业生涯的早期黑客网络和内核代码。在 MicroUnity 之后，他转到 Netscape，在那里他从事 Netscape 浏览器的工作，并在巨大的时间压力下发明了 JavaScript。</i></p><p class="normal"><i>With an appreciation of both elegant theory and good pragmatic engineering, Eich spent the early days of his career hacking network and kernel code at Silicon Graphics and MicroUnity. After MicroUnity, he moved to Netscape, where he worked on the Netscape browser and, under intense time pressure, invented JavaScript.</i></p>
<p class="normal"><i>1998 年，他与杰米·扎温斯基 (Jamie Zawinski) 一起成为说服 Netscape 开源其浏览器的领导者之一，促成了 mozilla.org 的成立，他是该公司的首席架构师。</i></p><p class="normal"><i>In 1998, along with Jamie Zawinski, he was one of the leaders of the effort to convince Netscape to open-source its browser, leading to the formation of mozilla.org, where he was chief architect.</i></p>
<p class="normal"><i>近年来，Eich 参与了 Mozilla 平台的高级方向设置以及对名为 TraceMonkey 的新 JITing JavaScript 虚拟机的低级黑客攻击。而且，正如他在这次采访中解释的那样，他还一直在努力为 Mozilla 项目寻找“推动研究针”的方法，将具有实践头脑的学者带入 Mozilla 阵营，以弥合学术理论与工业实践之间的差距.</i></p><p class="normal"><i>In recent years Eich has been involved in both high-level direction setting for the Mozilla platform and in low-level hacking on a new JITing JavaScript virtual machine called TraceMonkey. And, as he explains in this interview, he has also been trying to find ways for the Mozilla project to “move the research needle,” bringing practical-minded academics into the Mozilla fold in order to bridge the gap between academic theory and industrial practice.</i></p>
<p class="normal"><a id="OEBPS/Chapter04.html.page_134"></a><i>我们谈到的其他主题包括为什么 JavaScript 必须看起来有点像 Java 但又不太像，为什么尽管 ECMAScript 4 项目失败了，但 JavaScript 仍然需要作为一种语言发展，以及需要更多种类的静态代码分析。</i></p><p class="normal"><a></a><i>Other topics we touched on include why JavaScript had to look somewhat like Java but not too much, why JavaScript does still need to grow as a language despite the failure of the ECMAScript 4 project, and the need for more kinds of static code analysis.</i></p>
</div>
<p class="normal"><b>Seibel：</b>你什么时候学会编程的？</p><p class="normal"><b>Seibel:</b> When did you learn to program?</p>
<p class="normal"><b>Eich：</b> 70 年代末 80 年代初，我在 Santa Clara 读物理专业。我们过去常常去斯坦福大学并侵入 LOTS-A 和 LOTS-B，这是两个主要的分时 DEC TOPS-20 系统，Santa Clara 有一个 TOPS-20 系统：来自 DEC 的一个不错的 36 位处理器，很棒的操作系统，精彩的宏汇编器。C 是“可移植的汇编程序”，但宏处理很糟糕，而那时候你有真正的汇编宏，如果你对此有纪律，你可以做很多相当结构化的编程。没有类型系统，但 C 没有太多可谈的。以及一组丰富的系统调用、系统服务、内存映射 I/O，所有最初没有进入 Unix 的东西。</p><p class="normal"><b>Eich:</b> I was a physics major as an undergraduate at Santa Clara in the late '70s, early '80s. We used to go over to Stanford and hack into LOTS-A and LOTS-B, which were the two big timesharing DEC TOPS-20 systems and Santa Clara had a TOPS-20 system: a nice 36-bit processor from DEC, great OS, wonderful macro assembler. C is “portable assembler” but the macro processing is terrible, whereas back then you had real macros for assembly and you could do a lot of fairly structured programming if you were disciplined about it. No type system, but C doesn't have much of one to speak of. And a rich set of system calls, system services, memory-mapped I/O, all the stuff that didn't make it into Unix originally.</p>
<p class="normal"><b>Eich：</b>我学的是物理，但我开始更多地编程，而且我喜欢我正在上的数学和计算机科学课程，涉及自动机理论和形式语言。那时有一场研发最好的自底向上解析器生成器的研究竞赛，yacc 正在做的事情和其他人会做的事情。很容易看出形式上的纯度转化为相当干净的代码，编译器构造的前端几乎总是如此。当时的后端是一团乱七八糟的知识和启发式方法，但我真的很喜欢形式语言理论和正则语言理论等等。</p><p class="normal"><b>Eich:</b> I was doing physics but I was starting to program more and I was liking the math and computer-science classes I was taking, dealing with automata theory and formal languages. At that point there was a research race to develop the best bottom-up parser generator, what yacc was doing and others would do. It was easy to see the formal purity translate into fairly clean code, which has almost always been the case with the front end of compiler construction. The back end back then was a mess of lore and heuristics, but I really liked the formal language theory and the theory of regular languages and so on.</p>
<p class="normal"><b>Seibel：</b>你在什么语言和环境下编程——大概是在物理学中，你在用 Fortran 语言？</p><p class="normal"><b>Seibel:</b> And what languages and environments were you programming in—presumably in physics you were doing Fortran?</p>
<p class="normal"><b>艾希：</b>这很有趣。我是纯粹的物理学家，我没有参加那些让我搬运甲板并冒着溢出它和使用整理器的风险的工程课程。我实际上绕过了 Fortran。Pascal 那时很厉害，我们开始学习 C 语言和汇编语言。所以我在做低级编码，编写汇编哈希表和类似的东西。这很好。您会更好地了解不同的权衡取舍。你可以告诉<a id="OEBPS/Chapter04.html.page_135"></a>实际上已经下降到 bit-banging 级别的程序员与那些一生都被屏蔽的程序员。</p><p class="normal"><b>Eich:</b> That's the funny thing. I was so pure physics, I wasn't taking the engineering classes that would've had me carrying the deck and risking spilling it and using the collator. I actually bypassed Fortran. Pascal was big then and we were getting into C. And assembly. So I was doing low-level coding, writing assembly hash tables and stuff like that. Which was good. You get better appreciation for different trade-offs. You can tell the <a></a>programmers who've actually been down to bit-banging level versus the ones who've been shielded all their lives.</p>
<p class="normal">我也对 C 和 Unix 很感兴趣，但我们只是用这个旧的 DEC 机器才开始接触它。我们有基于 yacc 的可移植 C 编译器一团糟，我们才刚刚开始生成代码并尝试 Unix 实用程序移植。由于物理学并没有让我找到暑期工作，而且我做了很多黑客工作并担任实验室助理，所以我最终在高年级转向数学/计算机科学，这就是我获得本科学位的方向。</p><p class="normal">I also was interested in C and Unix but we were only just getting into it with this old DEC iron. We had the Portable C Compiler yacc-based mess and we were just starting to generate code and play around with Unix utility porting. Since physics wasn't getting me summer jobs and I was doing a lot of hacking and being a lab assistant I ended up switching in my senior year to math/computer science, and that's what I got my undergraduate degree in.</p>
<p class="normal"><b>Seibel：</b>您记得编写的第一个有趣的程序是什么？</p><p class="normal"><b>Seibel:</b> What was the first interesting program that you remember writing?</p>
<p class="normal"><b>Eich：</b>这会很尴尬。DEC 制造了一个糟糕的图形终端；它就像 VT100 的演变，因为它理解转义序列，但它也有一些可怜的颜色深度和某种 80 年代早期的分辨率。所以我开始为它编写游戏仿制品：吃豆人、大金刚。我用 Pascal 编写了那些游戏，它们发出了转义序列。但这是一种越来越大的爱好编程。我认为这是我做的第一个重要的编程，我必须考虑模块化和保护自己。</p><p class="normal"><b>Eich:</b> This is going to be embarrassing. There was a terrible graphics terminal DEC made; it was like an evolution of VT100 because it understood the escape sequences, but it also had some pathetic color depth and some sort of early '80s resolution. So I started writing game knockoffs for it: Pac-Man, Donkey Kong. I wrote those games in Pascal and they emitted escape sequences. But it was kind of hobby programming that grew and grew. I think that was the first nontrivial programming I did where I had to think about modularity and protecting myself.</p>
<p class="normal">那是我主修物理的时候，大概是三年级。第四年，我成为了数学/计算机科学，我开始学习形式语言和编写解析器生成器。所以这些就是我编写的程序类型：游戏或严肃的书呆子解析器生成器类型程序。然后我开始考虑编译器并编写宏处理器仿制品，例如 m4 仿制品或 CPP 仿制品。我记得当我们获得了某个版本的 Unix 源代码并阅读了一些非常笨拙的 C 代码时。John Reiser C 预处理器——可能是原始的——简直是一团糟。效率很高；它正在使用一个全局缓冲区，并且是一个巨大的指针炖，它会尽量避免复制。我想，“必须有更好的方法来做到这一点。”</p><p class="normal">This was while I was a physics major, probably third year. Fourth year I became math/computer science and I was starting to study formal languages and write parser generators. So those were the kinds of programs I wrote: either games or serious nerd parser generator type programs. Then I started thinking about compilers and writing macro processor knock offs, like m4 knockoffs or CPP knockoffs. I remember when we got some version of the Unix source and reading some of the really crufty C code. The John Reiser C preprocessor—probably the original—was just an amazing mess. It was very efficient; it was using a global buffer and it was a huge pointer stew, and it would try to avoid copying. I thought, “There has to be a better way to do this.”</p>
<p class="normal">这就是我最终离开物理学并进入计算机科学和编程的原因。在那之前我并没有真正编程；都是数学和科学。我父母不让我买 Apple II。我试过一次。我没有乞求，而是说，“我可以用它来学习一门外语”，这完全是烟幕弹。“不。你可能会浪费时间玩游戏。” 他们是对的。所以他们把我从那种命运中救了出来。</p><p class="normal">So that's how I ended up getting out of physics and into computer science and programming. I wasn't really programming before that; it was all math and science. My parents didn't let me get an Apple II. I tried once. I didn't beg but I was saying, “I could learn a foreign language with this,” which was a complete smoke screen. “No. You'll probably waste time playing games.” And they were right. So they saved me from that fate.</p>
<p class="normal"><a id="OEBPS/Chapter04.html.page_136"></a><b>Seibel：</b>除了提供比物理学更多的暑期工作外，编程还有什么吸引你的？</p><p class="normal"><a></a><b>Seibel:</b> Other than providing more summer employment than physics, what about programming drew you in?</p>
<p class="normal"><b>Eich：</b>理论与实践之间的联系，尤其是在编译器构建过程的前端，对我很有吸引力。数值方法我没有涉及太多。它们不那么有吸引力，因为你最终要处理各种疯狂的权衡，将实数表示为有限精度浮点数，这简直是地狱。它仍然困扰着 JavaScript 用户，因为我们从 80 年代就选择了这个硬件标准，而且它并不总是按照人们期望的方式运行。</p><p class="normal"><b>Eich:</b> The connection between theory and practice, especially at the front end of the compiler construction process, was attractive to me. Numerical methods I didn't get into too much. They're less attractive because you end up dealing with all sorts of crazy trade-offs in representing real numbers as finite precision floating-point numbers and that's just hellish. It still bites JavaScript users because we chose this hardware standard from the '80s and it's not always operating the way people expect.</p>
<p class="normal"><b>Seibel：</b>因为，就像西班牙宗教裁判所一样，没有人真正期待浮点数。</p><p class="normal"><b>Seibel:</b> Because, like the Spanish Inquisition, no one really expects floating point.</p>
<p class="normal"><b>Eich：</b>没有人预料到您会出现舍入误差——5 的幂不能很好地表示。他们在二垒打得不好。所以美元和美分，总和和差，会让你在 JavaScript 中得到奇怪的长零，最后是 9。有一篇关于此的博客指责 Safari 和 Mac 做错了数学并且它是 IEEE 双重 - 它存在于一切，Java 和 C 中。</p><p class="normal"><b>Eich:</b> No one expects the rounding errors you get—powers of five aren't representable well. They round badly in base-two. So dollars and cents, sums and differences, will get you strange long zeros with a nine at the end in JavaScript. There was a blog about this that blamed Safari and Mac for doing math wrong and it's IEEE double—it's in everything, Java and C.</p>
<p class="normal">物理学对我来说也不那么令人满意，因为它有点停滞不前。当你拥有这些大的归纳理论时，有些东西不太正确，人们正在完善角落并发明暗能量之类的东西，这基本上是不可证伪的。我被吸引到一些更实用但仍然具有基于数学和逻辑的理论强度的东西。</p><p class="normal">Physics was also less satisfying to me because it has kind of stalled. There's something not quite right when you have these big inductive theories where people are polishing corners and inventing stuff like dark energy, which is basically unfalsifiable. I was gravitating toward something that was more practical but still had some theoretical strength based in mathematics and logic.</p>
<p class="normal">然后我去了伊利诺伊大学香槟分校，至少获得了硕士学位。我一直想一路走下去，但我被困在一个基本上由 IBM 包办的项目中。他们从康涅狄格州丹伯里的一家公司购得一台奇怪的 68020 机器，并将 Xenix 移植到这台机器上。他们选择了我们的研究项目，让我们变得像一个 QA 小组，这太麻烦了。每个星期一，我们都会让蓝色西装出来给我们打气。我的教授对此有点冷漠。我可能应该找个新人，但我也听到 Jim Clark 在校园里演讲，我几乎决定去 Silicon Graphics 工作。</p><p class="normal">Then I went to University of Illinois Champaign-Urbana to get a master's degree, at least. I was thinking of going all the way but I got stuck in a project that was basically shanghaied by IBM. They had a strange 68020 machine they had acquired from a company in Danbury, Connecticut, and they ported Xenix to it. It was so buggy they co-opted our research project and had us become like a QA group. Every Monday we'd have the blue suit come out and give us a pep talk. My professors were kind of supine about it. I should've probably found somebody new, but I also heard Jim Clark speak on campus and I pretty much decided I wanted to go work at Silicon Graphics.</p>
<p class="normal"><b>Seibel：</b>你在 SGI 从事什么工作？</p><p class="normal"><b>Seibel:</b> What were you working on at SGI?</p>
<p class="normal"><a id="OEBPS/Chapter04.html.page_137"></a><b>Eich：</b>主要是内核和网络代码。我在那里使用的语言背景的数量随着时间的推移而增加，因为我们最终编写了自己的网络管理和数据包嗅探层，我编写了用于匹配字段和数据包的表达式语言，我编写了可以减少和优化它的翻译器到数据包前 36 个字节的少量掩码和匹配过滤器。</p><p class="normal"><a></a><b>Eich:</b> Kernel and networking code mostly. The amount of language background that I used there grew over time because we ended up writing our own network-management and packet-sniffing layer and I wrote the expression language for matching fields and packets, and I wrote the translator that would reduce and optimize that to a short number of mask-and-match filters over the front 36 bytes of the packet.</p>
<p class="normal">我最终编写了另一种语言实现，一个可以根据协议描述生成 C 代码的编译器。有人希望我们在这个数据包嗅探器中支持 AppleTalk。这是一个巨大而复杂的协议语法包，用于各种大小的序列和字段以及 . . . 主要是数组之类的东西。写作很有趣也很有挑战性。我最终使用了一些旧的 Dragon 书籍——Aho 和 Ullman——编译器技巧。但仅此而已。我想我做了一个 unifdef 克隆。Dave Yost 做过一个，它没有处理<code>#if</code>表达式，也没有根据某些术语被定义或未定义来进行表达式最小化，所以我这样做了。那仍然在那里。我认为它可能已经进入了 Linux。</p><p class="normal">And I ended up writing another language implementation, a compiler that would generate C code given a protocol description. Somebody wanted us to support AppleTalk in this packet sniffer. It was a huge, complex grab bag of protocol syntax for sequences and fields of various sizes and dependent types of . . . mostly arrays, things like that. It was fun and challenging to write. I ended up using some of the old Dragon book—Aho and Ullman—compiler skills. But that was it. I think I did a unifdef clone. Dave Yost had done one and it didn't handle <code>#if</code> expressions and it didn't do expression minimization based on some of the terms being pound-defined or undefined, so I did that. And that's still out there. I think it may have made its way into Linux.</p>
<p class="normal">我从 85 年到 92 年都在 SGI。92 年，我在 SGI 认识的一个人去了 MicroUnity，我厌倦了 SGI 的膨胀和收购公司，以及被政客淹没。所以我跳到 MicroUnity，乔治·吉尔德 (George Gilder) 在上世纪 90 年代在<i>福布斯 ASAP</i>上写道，好像它将成为下一件大事。然后沿着记忆洞走下去；它变成了北桑尼维尔价值 2 亿美元的火山口。这是一次非常好的学习经历。我在那里做了一些关于 GCC 的工作，所以我得到了一些编译器语言的黑客攻击。我为 MPEG2 视频做了一个小的编辑器语言，你可以在其中编写这种笨拙的伪规范语言，如 ISO 规范或 IEC 规范，并实际生成具有所有正确语法的测试比特流。</p><p class="normal">I was at SGI from '85 to '92. In '92 somebody I knew at SGI had gone to MicroUnity and I was tired of SGI bloating up and acquiring companies and being overrun with politicians. So I jumped and it was to MicroUnity, which George Gilder wrote about in the '90s in <i>Forbes ASAP</i> as if it was going to be the next big thing. Then down the memory hole; it turned into a $200 million crater in North Sunnyvale. It was a very good learning experience. I did some work on GCC there, so I got some compiler-language hacking. I did a little editor language for MPEG2 video where you could write this crufty pseudospec language like the ISO spec or the IEC spec, and actually generate test bit streams that have all the right syntax.</p>
<p class="normal"><b>Seibel：</b>然后在 MicroUnity 之后你去了 Netscape，剩下的就是历史了。回顾过去，在学习编程方面，有什么是您希望自己做的有所不同的吗？</p><p class="normal"><b>Seibel:</b> And then after MicroUnity you ended up at Netscape and the rest is history. Looking back, is there anything you wish you had done differently as far as learning to program?</p>
<p class="normal"><b>Eich：</b>在我转向数学和计算机科学之前，我一直在研究物理。我做了足够多的数学，我正在学习一些编程，但我已经自学了一些东西，所以当我在课堂上时，我已经坐在后面，有点向前走，或者感到无聊或做<a id="OEBPS/Chapter04.html.page_138"></a>别的东西。这对个人自律不利，我可能错过了一些我本可以学习的东西。</p><p class="normal"><b>Eich:</b> I was doing a lot of physics until I switched to math and computer science. I was doing enough math that I was getting some programming but I had already studied some things on my own, so when I was in the classes I was already sitting in the back kind of moving ahead or being bored or doing <a></a>something else. That was not good for personal self-discipline and I probably missed some things that I could've studied.</p>
<p class="normal">我和读过博士课程的人谈过，他们显然对某些领域的研究比我更深入。我觉得那是我当时的机会。现在真的不能回去做。您可以在 Internet 上学习任何东西，但您是否真的有时间与合适的教授和正确的课程一起学习，您是否有合适的机会真正学习它？但我对此并没有太多的遗憾。</p><p class="normal">I've talked to people who've gone through a PhD curriculum and they obviously have studied certain areas to a greater depth than I have. I feel like that was the chance that I had then. Can't really go back and do it now. You can study anything on the Internet but do you really get the time with the right professor and the right coursework, do you get the right opportunities to really learn it? But I've not had too many regrets about that.</p>
<p class="normal">就编程而言，就像我说的那样，我在做低级编码。我不是一个面向对象的设计模式专家。我从来没有买过伽玛书。Netscape 的一些人这样做了，Jamie Zawinski 和我的一些死对头来自另一次收购，他们像圣经一样挥舞着它，他们有点难以忍受，因为他们不是最好的程序员。</p><p class="normal">As far as programming goes, I was doing, like I said, low-level coding. I'm not an object-oriented, design-patterns guy. I never bought the Gamma book. Some people at Netscape did, some of Jamie Zawinski's and my nemeses from another acquisition, they waved it around like the Bible and they were kind of insufferable because they weren't the best programmers.</p>
<p class="normal">我一直比我应该的更低级。我认为我从 Mozilla 和 Firefox 中学到的更多是测试驱动开发，我认为这是很有价值的。以及我们经常做的模糊测试等其他事情。我们有许多源语言和大型深层渲染管道以及其他类型的评估管道，这些管道有很多内存安全漏洞的机会。所以我们发现模糊测试比几乎任何其他类型的测试都更有效率。</p><p class="normal">I've been more low-level than I should've been. I think what I've learned with Mozilla and Firefox has been about more test-driven development, which I think is valuable. And other things like fuzz testing, which we do a lot of. We have many source languages and big deep rendering pipelines and other kinds of evaluation pipelines that have lots of opportunity for memory safety bugs. So we have found fuzz testing to be more productive than almost any other kind of testing.</p>
<p class="normal">我还推动我们投资于静态分析，这已经盈利，尽管它相当深奥。我们雇佣了一些足够强大的人来使用它。</p><p class="normal">I've also pushed us to invest in static analysis and that's been profitable, though it's fairly esoteric. We have some people we hired who are strong enough to use it.</p>
<p class="normal"><b>Seibel：</b>什么样的静态分析？</p><p class="normal"><b>Seibel:</b> What kind of static analysis?</p>
<p class="normal"><b>Eich：</b> C++的静态分析，很难。通常在静态分析中，您正在进行某种整体程序分析，并且您喜欢做一些事情，例如证明有关内存的事实。所以你必须消除内存歧义才能找到所有的别名，这是一个指数级的问题，这在任何重要的程序中通常都是不可行的。但最大的突破是你真的不需要担心内存问题。如果您可以构建一个完整的控制流图并将所有虚拟方法连接到它们可能的实现，则可以对代码进行部分评估<a id="OEBPS/Chapter04.html.page_139"></a>没有实际运行它。你可以找到死代码，你可以找到冗余测试，你可以找到缺失的空测试。</p><p class="normal"><b>Eich:</b> Static analysis of C++, which is difficult. Normally in static analysis you're doing some kind of whole-program analysis and you like to do things like prove facts about memory. So you have to disambiguate memory to find all the aliases, which is an exponential problem, which is generally infeasible in any significant program. But the big breakthrough has been that you don't really need to worry about memory. If you can build a complete control-flow graph and connect all the virtual methods to their possible implementation, you can do a process of partial evaluation over the code <a></a>without actually running it. You can find dead code and you can find redundant tests and you can find missing null tests.</p>
<p class="normal">如果你进入我们共同运作的更高层次的讨论，你实际上可以做更多的事情，在我们头脑中有一个关于我们正在编写的程序的证明系统。但是我们没有通用语言的类型系统来表达证明的条款。这是一个真正的问题。Curry-Howard 对应关系表示逻辑系统和类型系统之间存在对应关系，类型是术语，程序是证明，你应该能够写下你试图强制执行的这些更高级别的模型。就像，这个数组应该对其长度有一些限制，至少在这个早期阶段，然后它可能有不同的限制或没有限制。部分诀窍是你要经历这些苗圃阶段或其他有不同规则的阶段。或者你在你自己的抽象中 s 防火墙并且您为了效率而违反了自己的不变量，但您知道自己在做什么并且从外面看它仍然是安全的。这很难以完全类型检查的方式实现。</p><p class="normal">And you can actually do more if you go to higher levels of discourse where we all operate, where there's a proof system in our head about the program we're writing. But we don't have a type system in the common languages to express the terms of the proof. That's a real problem. The Curry-Howard correspondence says there's a correspondence between logic systems and type systems, and types are terms and programs are proofs, and you should be able to write down these higher-level models that you're trying to enforce. Like, this array should have some constraint on its length, at least in this early phase, and then after that it maybe has a different or no constraint. Part of the trick is you go through these nursery phases or other phases where you have different rules. Or you're inside your own abstraction's firewall and you violate your own invariants for efficiency but you know what you're doing and from the outside it's still safe. That's very hard to implement in a fully type-checked fashion.</p>
<p class="normal">当你编写 Haskell 程序时，你不得不在知道你在做什么之前决定你的证明系统。动态语言之所以流行，是因为人们实际上可以快速制作原型并将这种潜在类型系统牢记在心。然后也许以后，如果他们有可以支持它的语言，或者如果他们用静态语言重新编码，他们可以写下类型。这就是为什么在 JavaScript 中我们对可选类型感兴趣并且我们仍然感兴趣的原因之一，尽管它在委员会中存在争议。我们仍然很有可能在 JavaScript 的未来版本中加入某种混合类型系统。</p><p class="normal">When you write Haskell programs you're forced to decide your proof system in advance of knowing what it is you're doing. Dynamic languages became popular because people can actually rapidly prototype and keep this latent type system in their head. Then maybe later on, if they have a language that can support it, or if they're recoding in a static language, they can write down the types. That was one of the reasons why in JavaScript we were interested in optional typing and we still are, though it's controversial in the committee. There's still a strong chance we'll get some kind of hybrid type system into a future version of JavaScript.</p>
<p class="normal">所以我们想用保守静态分析可以查看的注释来注释我们的 C++。而且它将是保守的，因此它不会陷入停止问题的黑洞并永远尝试呈指数增长。这将帮助我们证明有关垃圾收集器安全性或控制可以从脚本流入的函数的分区，控制可以从中流回脚本的函数，以及当您必须重新实现解释器堆栈时要做的事情以便做出安全判断。它会给我们一些我们可以证明的安全属性。其中很多是更高级别的属性。它们不仅仅是内存安全。所以我们将不得不继续打这场仗。</p><p class="normal">So we would like to annotate our C++ with annotations that conservative static analysis could look at. And it would be conservative so it wouldn't fall into the halting-problem black hole and take forever trying to go exponential. It would help us to prove things about garbage-collector safety or partitioning of functions into which control can flow from a script, functions from which control can flow back out to the script, and things to do with when you have to rematerialize your interpreter stack in order to make security judgments. It would give us some safety properties we can prove. A lot of them are higher-level properties. They aren't just memory safety. So we're going to have to keep fighting that battle.</p>
<p class="normal"><a id="OEBPS/Chapter04.html.page_140"></a><b>Seibel：</b>所以这是一个非常高级的编程视图。您认为今天的程序员需要能够接近金属多远？如果有人打算用 JavaScript 编写他们的大部分应用程序，那么他们理解汇编还重要吗？</p><p class="normal"><a></a><b>Seibel:</b> So that's a very high-level view of programming. How close to the metal do you think programmers today need to be able to go? If someone is going to be writing most of their applications in JavaScript, is it still important that they grok assembly?</p>
<p class="normal"><b>Eich：</b>我认识很多 JavaScript 程序员，他们都是聪明的程序员，其中最优秀的程序员对经济学有着很好的把握。他们进行基准测试并在进行过程中进行测试，并编写紧凑的 JavaScript。他们不必知道它如何映射到机器指令。</p><p class="normal"><b>Eich:</b> I know a lot of JavaScript programmers who are clever programmers, and the best ones have a good grasp of the economics. They benchmark and they test as they go and they write tight JavaScript. They don't have to know about how it maps to machine instructions.</p>
<p class="normal">当他们听说我们正在构建的这些 JITing、跟踪 VM 时，他们中的很多人对此很感兴趣。我们越来越多的人在推动像素。如果你给人们足够的编程语言性能和足够的像素推动能力，我认为 JavaScript 程序员将开始在较低级别使用 JavaScript。机器经济学或虚拟机经济学——真正重要的是什么？也许这是虚拟机经济学。</p><p class="normal">A lot of them are interested in that when they hear about these JITing, tracing VMs that we're building. And we're getting more and more people who are pushing pixels. If you give people enough programming-language performance and enough pixel-pushing power I think JavaScript programmers will start using JavaScript at a lower level. And machine economics or the virtual-machine economics—what really matters? Maybe it's the virtual-machine economics.</p>
<p class="normal">抽象是强大的。在 90 年代，我真正过敏并且反应不好的是所有 CORBA、COM、DCOM、面向对象的废话。当天的每家初创公司都有一些疯狂的事情，需要 200,000 次方法调用才能启动并打印“hello, world”。那是一种讽刺；您不想成为与这类事情相关的程序员。在 SGI，内核当然是真正的胸毛程序员去的地方，你不能在那里胡闹。内核<code>malloc</code>是一个新事物；我们仍然使用固定大小的桌子，当我们把它们填满时我们会感到恐慌。</p><p class="normal">Abstraction is powerful. What I'm really allergic to, and what I had a bad reaction to in the '90s, was all the CORBA, COM, DCOM, object-oriented nonsense. Every startup of the day had some crazy thing that would take 200,000 method calls to start up and print “hello, world.” That's a travesty; you don't want to be a programmer associated with that sort of thing. At SGI, the kernel, of course, was where the real programmers with chest hair went, and there you couldn't screw around. Kernel <code>malloc</code> was a new thing; we still used fixed-sized tables, and we panicked when we filled them up.</p>
<p class="normal">接近金属是我保持诚实和避免废话的方式，但是现在，你知道，随着时间和更好、更快的硬件以及好的抽象与坏的抽象的进化筛选过程，我认为人们可以在那个水平之上操作而不是了解汇编并且仍然是优秀的程序员并编写紧凑的代码。</p><p class="normal">Staying close to the metal was my way of keeping honest and avoiding the bullshit, but now, you know, with time and better, faster hardware and an evolutionary winnowing process of good abstractions versus bad, I think people can operate above that level and not know assembly and still be good programmers and write tight code.</p>
<p class="normal"><b>Seibel：</b>相反，您是否认为那些在过去可以编写复杂的、拼图式汇编代码的人，在当今世界从事高级编程时，会和优秀的程序员一样出色吗？还是那种编程需要不同的技能？</p><p class="normal"><b>Seibel:</b> Do you think, conversely, that the people who, back in the day, could write intricate, puzzle-box assembly code, would be just as great programmers in today's world doing high-level programming? Or does that kind of programming require different skills?</p>
<p class="normal"><a id="OEBPS/Chapter04.html.page_141"></a><b>Eich：</b>我想说，对于编程的某些方面，两者之间存在对应关系。原始指针和这个快乐、有趣的 JavaScript 世界是有区别的。那种仍然将胸毛（与性别无关）的程序员与那些不太有胸毛的程序员区分开来。</p><p class="normal"><a></a><b>Eich:</b> I would say for certain aspects of programming there is a correspondence between the two. There's a difference between raw pointers and this happy, fun JavaScript world. That kind of still separates the chest hair—gender-independent—programmers from those who don't quite have it.</p>
<p class="normal">将这一切牢记在心很重要。显然，人们的脑袋大小不一。脑袋大的人可以在内存安全架构中跟踪更高级别的不变量，而不必担心指针。但是，如果随着时间的推移我们失去了写入金属的能力，那么仍然有一些事情困扰着我。有人在做；编译器正在生成代码。随着时间的推移，编译器编写者必须做得更好。</p><p class="normal">Keeping it all in your head is important. Obviously people have different-sized heads. Somebody with a big head could keep track of higher-level invariants in a memory-safe architecture and not have to worry about pointers. But there's something still that bothers me if over time we lose the ability to write to the metal. Somebody's doing it; the compiler is generating the code. The compiler writers have to be doing a better job over time.</p>
<p class="normal"><b>Seibel：</b>所以这种编程总是会有一席之地的。但是现在有没有人可以成为成功的程序员，而当所有的编程都是低级黑客时就不能呢？还是有固定的一群人拥有适合编程的大脑，现在他们分裂为一些人做低级的事情，一些人做高级的事情？</p><p class="normal"><b>Seibel:</b> So there will always be a place for that kind of programming. But are there people who can be successful programmers now who just couldn't when all programming was low-level hacking? Or is there one fixed population of people who have the right kind of brain for programming and now they're split with some people doing low-level stuff and some people doing high-level stuff?</p>
<p class="normal"><b>Eich：</b>我已经很长时间没有破解内核代码了，所以我必须去尝试一下，因为它具有一定的迁移能力。还有更多的代码要写。合理的抽象让您可以解决以前无法解决的问题。</p><p class="normal"><b>Eich:</b> I haven't hacked kernel code in a long time, so I would have to go for there's some ability to migrate. There's more code to write. And sound abstractions give you leverage over problems you couldn't address before.</p>
<p class="normal"><b>Seibel：</b>让我们回到你实现原始 JavaScript 的那十天。我知道在某个时候有人让你喜欢上了 Abelson 和 Sussman，而你最初的想法是将 Scheme 放在浏览器中。</p><p class="normal"><b>Seibel:</b> Let's go back to those ten days when you implemented the original JavaScript. I know that at some point someone had turned you on to Abelson and Sussman and your original idea was to put Scheme in the browser.</p>
<p class="normal"><b>Eich：</b> Netscape 最关心的是它必须看起来像 Java。人们已经为 Lisp 完成了类似 Algol 的语法，但我没有时间学习 Scheme 核心，所以我最终直接完成了这一切，这意味着我可能会犯与其他人相同的错误。</p><p class="normal"><b>Eich:</b> The immediate concern at Netscape was it must look like Java. People have done Algol-like syntaxes for Lisp but I didn't have time to take a Scheme core so I ended up doing it all directly and that meant I could make the same mistakes that others made.</p>
<p class="normal">我没有完整的动态范围，就像 Stallman 坚持的那样对 Emacs 和 Elisp 很重要。JavaScript 主要是词法作用域，但有些奇怪——有一些漏洞几乎是动态的：全局对象、<code>with</code>语句、eval。但它不像<a id="OEBPS/Chapter04.html.page_142"></a>Perl 中的美元变量在<code>my</code>or之前<code>upvar</code>，<code>uplevel</code>在 Tcl 中。20 世纪 90 年代充满了这种感觉——很时髦。</p><p class="normal">I didn't have total dynamic scope, like Stallman insisted was somehow important for Emacs and infested Elisp with. JavaScript has mostly lexical scope with some oddness to it—there are a few loopholes that are pretty much dynamic: the global object, the <code>with</code> statement, eval. But it's not like <a></a>dollar variables in Perl before <code>my</code> or <code>upvar</code>, <code>uplevel</code> in Tcl. The '90s was full of that—it was trendy.</p>
<p class="normal">但是我没有坚持Scheme，也是因为赶时间。我没有足够的时间来真正思考我所做事情的一些后果。我节省了必须在浏览器中实现的对象数量。所以我把全局对象设为window对象，这是一个未知的新名称绑定来源，无法对自由变量进行静态判断。所以很遗憾。Doug Crockford 和其他对象功能拥护者对您​​通过全局对象获得的不需要的权限来源感到不安。这是说同一件事的不同方式。JavaScript 有内存安全的引用，所以我们接近我们想要的地方，但是有这些大错误，这些漏洞。</p><p class="normal">But I didn't stick to Scheme and it was because of the rushing. I had too little time to actually think through some of the consequences of things I was doing. I was economizing on the number of objects that I was going to have to implement in the browser. So I made the global object be the window object, which is a source of unknown new name bindings and makes it impossible to make static judgments about free variables. So that was regrettable. Doug Crockford and other object-capabilities devotees are upset about the unwanted source of authority you get through the global object. That's a different way of saying the same thing. JavaScript has memory-safe references so we're close to where we want to be but there are these big blunders, these loopholes.</p>
<p class="normal">让顶层的那些变量实际上成为一个对象的可变属性，你可以在某人的背后给它起别名和乱搞——这不好。它应该是词汇绑定。因为如果你从那里深入到函数和嵌套函数，那么它更像 Scheme。你没有丰富的结合形式，流动性或其他什么；你有更多的喜欢设置爆炸。但是您使用局部变量创建的初始绑定是词法变量。</p><p class="normal">Making those variables in the top level actually become mutable properties of an object that you can alias and mess around with behind the back of somebody—that's no good. It should've been lexical bindings. Because if you go down from there into the functions and nested functions, then it is much more Scheme-like. You don't quite have the rich binding forms, the fluid lets or whatever; you have more like set-bang. But the initial binding you create with a local variable is a lexical variable.</p>
<p class="normal"><b>Seibel：</b>所以基本上现在人们会创建一个顶级函数来获取命名空间。</p><p class="normal"><b>Seibel:</b> So basically now people make a top-level function to get a namespace.</p>
<p class="normal"><b>艾奇：</b>是的。你看到人们有一个功能，他们马上就调用它。它为他们提供了一个安全的环境来绑定私有变量。道格是这方面的大力支持者。Schemers 和 Lispers 并不是完全不知道它，但是很多 JavaScript 人不得不学习它，Doug 和其他人通过教他们做出了有价值的贡献。不幸的是，这并不是说你要让每个人都成为高质量的 Scheme 程序员，但在某种程度上他们已经成功了，所以人们现在确实在某种模式层面上理解了更多的函数习语，而不一定是在深层次上。</p><p class="normal"><b>Eich:</b> Yeah. You see people have a function and they call it right away. It gives them a safe environment to bind in, private variables. Doug's a big champion of this. It was not totally unknown to the Schemers and Lispers but a lot of JavaScript people had to learn it and Doug and others have done a valuable service by teaching them. It's not like you're getting everybody to be high-quality Scheme programmers, unfortunately, but to some extent they've succeeded, so people now do understand more functional idioms at some patterny level, not necessarily at a deep level.</p>
<p class="normal"><b>Seibel：</b>这就是已经存在了十多年的 JavaScript。现在，由于 Ajax，出现了这种巨大的复兴。所以人们说，“好吧，我们真的需要再看看这个。” 您最近经历了 ECMAScript 4 提案和与之竞争的 ECMAScript 3.1 提案的戏剧性事件<a id="OEBPS/Chapter04.html.page_143"></a>现在事情似乎已经尘埃落定，统一两者的“和谐”计划。ES4 提案是否是您向世界展示“看，我是一个非常聪明的人，而 JavaScript 是一种非常好的语言”的机会？</p><p class="normal"><b>Seibel:</b> So that's the JavaScript that's been out there for over a decade. And now there's this big renaissance due to Ajax. So folks say, “OK, we really need to take another look at this.” You recently went through the drama of the ECMAScript 4 proposal and the competing ECMAScript 3.1 proposal <a></a>and now things seem to have settled down with the “Harmony” plan for unifying the two. Was the ES4 proposal your chance to show the world that, “Look, I'm a really smart guy and JavaScript is a really a good language”?</p>
<p class="normal"><b>艾希：</b>不，我不这么认为。我知道道格可能会这么想。我认为 Doug 不太了解我，但事实是，我并不是真的在寻求尊重，尤其是来自 Java 领导者或落后者的尊重。</p><p class="normal"><b>Eich:</b> No, I don't think so. I know Doug may think that. I don't think Doug knows me that well, but the thing is, I'm not really looking for respect, especially from the Java-heads or the trailing edge.</p>
<p class="normal"><b>Seibel：</b> ES4 是你的创意吗？这是你的想法吗，知道你现在所知道的一切，你想要 JavaScript 成为什么？</p><p class="normal"><b>Seibel:</b> Was ES4 your brainchild? Was it your take on, knowing all that you know now, what you want JavaScript to be?</p>
<p class="normal"><b>Eich：</b>不。这绝对是一种协作努力，并且在某些方面是一种妥协，因为我们正在与 Adob​​e 合作，Adobe 开发了一种名为 ActionScript 的衍生语言。他们的第三版是影响第四版提案的版本。那是基于 Waldemar Horwat 在 90 年代后期对原始 JavaScript 2/ECMAScript 第四版提案所做的工作，该提案在 2003 年被封存，当时 Netscape 大部分被解雇，Mozilla 基金会成立。</p><p class="normal"><b>Eich:</b> No. It was definitely a collaborative effort and in some ways a compromise because we were working with Adobe, who had done a derivative language called ActionScript. Their version three was the one that was influencing the fourth-edition proposals. And that was based on Waldemar Horwat's work on the original JavaScript 2/ECMAScript fourth-edition proposals in the late '90s, which got mothballed in 2003 when Netscape mostly got laid off and the Mozilla foundation was set up.</p>
<p class="normal">Waldemar 做得很好——我在 97 年末和 Jamie 一起去创建 mozilla.org 时给了他通往王国的钥匙。Waldemar 是一个巨大的大脑——我认为他在 87 年赢得了 Putnam。麻省理工学院博士。他确实尝试保持语言的动态风格，但他努力向其中添加某些大型编程设施，如名称空间。</p><p class="normal">Waldemar did a good job—I gave him the keys to the kingdom in late '97 when I went off to found mozilla.org with Jamie. Waldemar is a huge brain—I think he won the Putnam in '87. MIT PhD. He did try and keep the dynamic flavor of the language, but he struggled to add certain programming-in-the-large facilities to it, like namespaces.</p>
<p class="normal">有一个相反的学派更迂腐：“我们应该只拥有一些可以对规范进行脱糖的原语；我们可以用 lambda 编码一切。反正人们应该这样写，因为我就是这么想的”或者，“这是最好的思考方式。” 这是非常简化的，并不适合所有人。显然，建立自己的心理证明系统的一种方法是将事物减少到子集语言。子集是强大的。但是要说每个人都必须在这种极小的子集中编程，那是没有用的。</p><p class="normal">There's a contrary school which is more pedantic: “We should have just a few primitives we can de-sugar our spec to; we can lambda code everything. That's how people should write anyway because that's how I think of things” or, “That's the best way to think of things.” It's very reductionistic and it's not for everybody. Obviously one way to do your own mental proof system is to reduce things, to subset languages. Subsetting is powerful. But to say everyone has to program in this sort of minuscule subset, that's not usable.</p>
<p class="normal"><b>Seibel：</b>在一些关于 ES4 的讨论中，您引用了 Guy Steele 的论文“Growing a Language”。作为一个 Lisper，对我来说，从那篇论文中得到的收获是，第一步，用你的语言建立一个宏系统。然后所有这些特殊的糖都消失了。</p><p class="normal"><b>Seibel:</b> In some of the discussion about ES4, you cited Guy Steele's paper, “Growing a Language.” Speaking as a Lisper, to me the take-away from that paper was, step one, put a macro system in your language. Then all of this special sugar goes away.</p>
<p class="normal"><a id="OEBPS/Chapter04.html.page_144"></a><b>Eich：</b>显然有两个大问题。C 语法意味着你比使用 s 表达式要困难得多，所以你必须定义你的 AST，我们将不得不标准化它们，这将是一件痛苦的事情。然后还有另一个问题，卫生问题还不是很清楚。和我们一起工作的戴夫·赫尔曼正在写他的论文——或者我最后一次检查过——关于一种证明卫生稳健性的逻辑，我希望这是有益的。因为我们会接触到宏。</p><p class="normal"><a></a><b>Eich:</b> There are two big problems, obviously. C syntax means that you have a much harder time than with s-expression, so you have to define your ASTs and we're going to have to standardize them and that's going to be a pain. Then there's the other problem, which is hygiene is still not quite understood. Dave Herman, who's working with us is doing his thesis—or was last I checked—on a kind of logic for proving soundness for hygiene, which is, I hope, beneficial. Because we will get to macros.</p>
<p class="normal">几年前，当道格·克罗克福德 (Doug Crockford) 让我在雅虎 (Yahoo!) 演讲时，我对他说过这句话。我开始谈论我热衷的糖。他说，“哎呀，也许我们应该先做一个宏观系统，”我说，“不，因为那样我们需要九年时间。” 当时在政治上确实存在微软不打算合作的风险。他们在睡着和滑行后回到了 ECMA。来自海得拉巴的新人非常热情地说：“是的，我们将把 CLR 放入 IE8，JScript.net 将成为我们新的 web JavaScript 实现。” 但我认为他的热情上了楼，然后他被告知，“不，那不是我们正在做的。” 所以它导致了巨大的反抗和分裂委员会。</p><p class="normal">I said this to Doug Crockford a couple years ago when he had me speak at Yahoo! I started talking about the sugar that I was enthusiastic about. He said, “Gee, maybe we should do a macro system first,” and I said, “No, because then we'll take nine years.” At the time there was a real risk politically that Microsoft was just not going to cooperate. They came back into ECMA after being asleep and coasting. The new guy, who was from Hyderabad, was very enthusiastic and said, “Yes, we will put the CLR into IE8 and JScript.net will be our new implementation of web JavaScript.” But I think his enthusiasm went upstairs and then he got told, “No, that's not what we're doing.” So it led to the great revolt and splitting the committee.</p>
<p class="normal">所以我们担心，如果我们去做宏，我们就是在做研究，如果我们做研究，我们就不会让微软参与进来，我们也不会给他们施加竞争压力。所以宏不得不等待。只要我们进行正确的自动语法检查并且我们确实确保我们可以在拥有宏时将所有糖重铸为宏，我就可以接受。但与此同时，没有理由让用户饿死糖。它不会腐蚀他们的牙齿，并且可以帮助他们避免错误。</p><p class="normal">So we were concerned that if we went off to do macros we were doing research, and if we were doing research we were not going to have Microsoft engaged and we were not going to be putting competitive pressure on them. So macros have had to wait. I'm fine with that so long as we do the right automated grammar checks and we do make sure we can recast all of the sugar as macros when we have macros. But in the meantime there's no reason to starve the users for sugar. It doesn't rot their teeth and it helps them avoid mistakes.</p>
<p class="normal"><b>Seibel：</b>早在 1995 年，还有哪些其他语言影响了您最初的 JavaScript 设计？</p><p class="normal"><b>Seibel:</b> Back in 1995, what other languages influenced your original design of JavaScript?</p>
<p class="normal"><b>Eich：</b> Self 很大，主要是因为 Dave Ungar 刚刚写的论文。我从未玩过任何 Self 代码，但我只是受到它们的启发。我喜欢 Smalltalk，这里有人将一个想法应用于 Smalltalk，这是基于原型的委托——与 JavaScript 不同的是多个原型——并且尽可能地用它来运行。这对我很有启发，因为既有好的编译器、VM 级工程，也有好的语言设计。</p><p class="normal"><b>Eich:</b> Self was big, mainly because of the papers that Dave Ungar had just written. I never played with any Self code, but I was just inspired by them. I like Smalltalk and here was somebody taking one idea applied to Smalltalk, which was prototype-based delegation—multiple prototypes unlike JavaScript—and just running with it as hard as they could. That was inspiring to me because there was both good compiler, VM-level engineering and, I thought, good language design.</p>
<p class="normal"><a id="OEBPS/Chapter04.html.page_145"></a>因为，就像 Crock 和其他人一样，我认为你确实想要简化，我也喜欢那些采用更少原语并看看它们能走多远的语言设计者。我认为 JavaScript 有一种斯德哥尔摩综合症：“哦，它只是做了它能做的，因为微软停止让它改进，所以我们为什么要更好的语法；对所有内容进行 lambda 编码实际上是一种美德。” 但是抛开斯德哥尔摩综合症，以及微软让 Web 停滞不前，语言设计可以很好地采纳一两个核心思想并努力推动它们。</p><p class="normal"><a></a>Because, like Crock and others, I think you do want to simplify and I do like the languages designers who take fewer primitives and see how far they can go. I think there's been kind of a Stockholm syndrome with JavaScript: “Oh, it only does what it does because Microsoft stopped letting it improve, so why should we want better syntax; it's actually a virtue to go lambda-code everything.” But that Stockholm syndrome aside, and Microsoft stagnating the Web aside, language design can do well to take a kernel idea or two and push them hard.</p>
<p class="normal"><b>Seibel：</b>你知道 NewtonScript 吗？</p><p class="normal"><b>Seibel:</b> Were you aware of NewtonScript at all?</p>
<p class="normal"><b>Eich：</b>只有在有人向我指出这一事实之后，我才意识到，“嘿，他们在他们的父链接和我们的单一原型中有类似我们范围链的东西。” 我认为这是基于自我的趋同进化。而 DOM 事件处理程序——HyperTalk 和阿特金森的 HyperCard 的部分影响。所以我不仅关注 Self 和 Scheme，而且在 HyperTalk 中也有这些 onFoo 事件处理程序，这就是我为 DOM onClick 等所做的。</p><p class="normal"><b>Eich:</b> Only after the fact did someone point it out to me and I realized, “Hey, they've got something like our scope chain in their parent link and our single prototype.” I think it was convergent evolution based on Self. And the DOM event handlers—part of the influence there was HyperTalk and Atkinson's HyperCard. So I was looking not only at Self and Scheme, but there were these onFoo event handlers in HyperTalk, and that is what I did for the DOM onClick and so on.</p>
<p class="normal">另一个积极的影响是 awk，这有点令人尴尬。我的意思是，我是一个老 Unix 黑客，Perl 已经过时了，但我仍在使用 awk 来处理各种琐事。我可以给这些一等函数起任何名字，但我称它们为“函数”主要是因为 awk。八个字母的关键字——有点重，但确实如此。</p><p class="normal">One more positive influence, and this is kind of embarrassing, was awk. I mean, I was an old Unix hacker and Perl was out, but I was still using awk for various chores. And I could've called these first-class functions anything, but I called them “function” mainly because of awk. An eight-letter keyword—it's kind of heavy, but there it is.</p>
<p class="normal"><b>Seibel：</b>至少它不是“lambda”——JavaScript 从一开始就注定要失败。在“我不想那样做”的意义上，是否有任何语言对 JavaScript 产生了负面影响？</p><p class="normal"><b>Seibel:</b> At least it wasn't “lambda”—JavaScript would've been doomed from the start. Were there any languages that negatively influenced JavaScript, in the sense of, “I don't want to do that”?</p>
<p class="normal"><b>Eich：</b>这是一项非常匆忙的工作，我并不担心，“哦，我不能把它变成 Ada 或 Common Lisp。” Java 在某些方面产生了负面影响。我既要让它看起来像 Java，又不能让那些疯狂的东西进来，比如区分原始类型和对象。另外，我不想有任何优雅的东西。所以我偏离了它，这让我开始关注 Self 并制作原型。</p><p class="normal"><b>Eich:</b> It was such a rush job that I wasn't, like, worried about, “Oh, I can't make it into Ada or Common Lisp.” Java was in some ways a negative influence. I both had to make it look like Java and not let in those crazy things like having a distinction between primitive types and objects. Also, I didn't want to have anything classy. So I swerved from that and it caused me to look at Self and do prototypes.</p>
<p class="normal"><b>Seibel：</b>你有没有考虑过开发一种与 Java 关系更密切的语言——使用 Java 并创建某种简单的子集；摆脱原始类型和其他不必要的复杂性？</p><p class="normal"><b>Seibel:</b> Did you ever consider making a language more closely related to Java—take Java and make some kind of simple subset; get rid of the primitive types and other needless complexities?</p>
<p class="normal"><a id="OEBPS/Chapter04.html.page_146"></a><b>Eich：</b>管理层施加了一些压力，要求让语法看起来像 Java。还有一些压力让它不要太大，因为毕竟，如果人们在做任何真正的编程，就应该使用 Java；这只是 Java 的笨弟弟。</p><p class="normal"><a></a><b>Eich:</b> There was some pressure from management to make the syntax look like Java. There was also some pressure to make it not too big, because after all, people should use Java if they're doing any real programming; this is just Java's dumb little brother.</p>
<p class="normal"><b>Seibel：</b>所以你想像 Java，但不要太多。</p><p class="normal"><b>Seibel:</b> So you wanted to be like Java, but not too much.</p>
<p class="normal"><b>艾奇：</b>不过分。如果我上课，我会遇到大麻烦。并不是说我真的有时间，但那将是一个禁忌。</p><p class="normal"><b>Eich:</b> Not too much. If I put classes in, I'd be in big trouble. Not that I really had time to, but that would've been a no-no.</p>
<p class="normal"><b>Seibel：</b>回到现在，ES4 已经被正式放弃，现在每个人都在朝着 ES-Harmony 努力，它将 ES3.1 与 ES4 的想法结合起来？你认为这最终是一个好的决定吗？</p><p class="normal"><b>Seibel:</b> Coming back to the present, ES4 has been officially abandoned and everyone is now working toward ES-Harmony, which will somehow combine ES3.1 with ideas from ES4? Do you think that's ultimately a good decision?</p>
<p class="normal"><b>Eich：</b>道格在第一篇博文中有点得意洋洋：“我们赢了。魔鬼已经被打败了。” 一年前我在伦敦放了一张笑话幻灯片，说道格是桥上的甘道夫，在 Khazad-dûm 面对 ES4rog。他非常喜欢这样。这是我第一次取笑他，因为他谈到这个话题时有时会有点严肃，而且他很喜欢。他可以成为英雄；ES4 并不完全是怪物。</p><p class="normal"><b>Eich:</b> Doug was a little triumphalist in first blog post: “We've won. The devil has been vanquished.” I had a joke slide I gave in London a year ago about Doug being Gandalf on the bridge, at Khazad-dûm facing down the ES4rog. He liked that a lot. It was the first time I poked fun at him because he's a little serious sometimes when he gets on this topic and he liked it a lot. He can be the hero; ES4 wasn't quite the monster.</p>
<p class="normal">回想起来，ES4 看起来太大了。但我们需要对标准采取务实的态度。我们不能只说你所需要的只是 lambda——Alonzo Church 已经证明了这一点，所以我们不会再向该语言添加任何内容。这是一种试图让每个人都成为专家的贫乏方法，它对那些在这些 Java 学校中受过错误训练的大量程序员不起作用。JavaScript总有一天<i>会</i>衰落，但如果我们不为了纯度而试图阻止糖分，我们可以继续发展它并在理论和实践意义上保持竞争力。</p><p class="normal">ES4 looks, in retrospect, too big. But we need to be practical about standards. We can't just say all you need are lambdas—Alonzo Church proved it, so we're not going to add any more to the language. That's the sort of impoverished approach that tries to make everybody into an expert and it will not work on the large number of programmers out there who have been mistrained in these Java schools. JavaScript <i>will</i> fall someday but we can keep evolving it and keep it competitive in both the theoretical and the practical sense if we don't try to hold back the sugar for purity's sake.</p>
<p class="normal">它需要发展以解决程序员面临的问题。程序员可以通过编写自己的库抽象来解决其中的一些问题。但是，如果没有扩展，用该语言编写抽象的能力将受到限制——您无法编写 getter 和 setter。你不能让对象看起来是原生的，不能让属性变成代码；像这样的东西。而且您无法以隐式或自动方式解决其中一些安全问题。</p><p class="normal">It needs to evolve to solve the problems that programmers face. Programmers can solve some of them by writing their own library abstractions. But the ability to write abstractions in the language is limited without the extensions—you can't write getters and setters. You can't make objects look native, have properties turn into code; things like that. And you can't solve some of these security problems in an implicit or automated way.</p>
<p class="normal"><a id="OEBPS/Chapter04.html.page_147"></a><b>Seibel：</b>总的来说，你觉得语言会随着时间的推移变得更好吗？</p><p class="normal"><a></a><b>Seibel:</b> In general do you feel like languages are getting better over time?</p>
<p class="normal"><b>艾希：</b>我想是的，是的。也许我们正在进入第二个黄金时代；对语言的兴趣越来越大，语言的创造也越来越多。我们谈论编程：我们需要不断练习这门手艺——就像写作或音乐一样。但是你使用的语言——声调系统——也很重要。语言很重要。所以我们应该发展编程语言；我们不应该坐以待毙。因为 Web 需要兼容性，JavaScript 可能不得不坐以待毙。但我们不应该受困于此；我们应该要么制作更好的 JavaScript，即使它不能取代 Web 上的 JavaScript，要么我们应该超越它。</p><p class="normal"><b>Eich:</b> I think so, yeah. Maybe we're entering the second golden age; there's more interest in languages and more language creation. We talk about programming: we need to keep practicing the craft—it's like writing or music. But the language that you use—the tonal system—matters too. Language matters. So we should be evolving programming languages; we shouldn't be sitting still. Because the Web demands compatibility, JavaScript may have to sit still too much. But we shouldn't get stuck by that; we should either make a better JavaScript, even if it doesn't replace the one on the Web, or we should move beyond that.</p>
<p class="normal">你会看到像 Ruby 这样的东西，它受到了 Ada 和 Smalltalk 的影响。那太棒了。我不介意折衷主义。尽管 Ruby 似乎有点被夸大了。这没什么不好的，只是有时粉丝们会说它像是第二次降临，它会解决你所有的问题，但事实并非如此。我们应该有新的语言，但它们不应该被夸大。就像 C++ 的炒作一样，整个“设计模式将拯救我们”。尽管也许他们是在对 80 年代 Unix C 世界的保守主义做出反应。</p><p class="normal">You see stuff like Ruby, which took influences from Ada and Smalltalk. That's great. I don't mind eclecticism. Though Ruby does seem kind of overhyped. Nothing bad about it, just sometimes the fan boys make it sound like the second coming and it's going to solve all your problems, and that's not the case. We should have new languages but they should not be overhyped. Like the C++ hype, the whole “design patterns will save us.” Though maybe they were reacting to the conservatism of the Unix C world of the '80s.</p>
<p class="normal">但在某些时候，我们必须拥有更好的语言。原因是要有证明助手或证明系统，对您在代码中所做的某些声明进行某种自动验证。你不会得到所有的，对吧？Valgrind 及其竞争检测器等动态工具也很棒。正如布鲁克斯所说，没有灵丹妙药，但有更好的语言，我们应该尽可能地迁移到它们。</p><p class="normal">But at some point we have to have better languages. And the reason is to have proof assistants or proof systems, to have some kind of automatic verification of some claims you're making in your code. You won't get all of them, right? And the dynamic tools like Valgrind and its race detectors, that's great too. There's no silver bullet, as Brooks said, but there are better languages and we should migrate to them as we can.</p>
<p class="normal"><b>Seibel：</b>编程语言的设计应该在多大程度上防止程序员犯错误？</p><p class="normal"><b>Seibel:</b> To what extent should programming languages be designed to prevent programmers from making mistakes?</p>
<p class="normal"><b>Eich：</b>所以像 Java 这样的蓝领语言不应该有一个疯狂的泛型系统，因为蓝领人无法弄清楚协变、逆变类型约束的语法到底意味着什么。当然，由于 C 和 C++ 的脚枪，我经历了一些脚趾损失。编程的一部分是工程；工程的一部分是制定各种安全属性，这很重要。做一个浏览器他们很重要。如果你在做 Therac-25，它们就更重要了。尽管我记得那更像是一个线程调度问题。但即便如此，你还是说得更好<a id="OEBPS/Chapter04.html.page_148"></a>用于编写并发程序或利用硬件并行性的语言。我们不应该都使用同步块——我们当然不应该使用互斥锁或自旋锁。因此，您可以通过语言获得的影响力可能涉及权衡，您会说，“为了安全，我要牺牲一些表达能力。”</p><p class="normal"><b>Eich:</b> So a blue-collar language like Java shouldn't have a crazy generic system because blue-collar people can't figure out what the hell the syntax means with covariant, contravariant type constraints. Certainly I've experienced some toe loss due to C and C++'s foot guns. Part of programming is engineering; part of engineering is working out various safety properties, which matter. Doing a browser they matter. They matter more if you're doing the Therac-25. Though that was more a thread-scheduling problem, as I recall. But even then, you talk about better <a></a>languages for writing concurrent programs or exploiting hardware parallelism. We shouldn't all be using synchronized blocks—we certainly shouldn't be using mutexes or spin locks. So the kind of leverage you can get through languages may involve trade-offs where you say, “I'm going, for safety, to sacrifice some expressiveness.”</p>
<p class="normal">对于 JavaScript，我认为我们坚持这一点，以对抗那些想要将 JavaScript 用作一种 lambda x86 语言的狂野、毛茸茸的法国超级黑客。我们不会添加 call/cc；没有理由这样做。除了实施者的负担——假设这不是问题——人们肯定会误入歧途。不一定是大多数人，但有足够多的人想成为超级黑客。有一种编程金字塔——正确的东西，你知道的。人们正在向山顶攀登，尽管有些山顶有时会掉下来或失去一个脚趾。</p><p class="normal">With JavaScript I think we held to this, against the wild, woolly Frenchmen superhackers who want to use JavaScript as a sort of a lambda x86 language. We're not going to add call/cc; there's no reason to. Besides the burden on implementers—let's say that wasn't a problem—people would definitely go astray with it. Not necessarily the majority, but enough people who wanted to be like the superhackers. There's sort of a programming ziggurat—the Right Stuff, you know. People are climbing towards the top, even though some of the tops sometimes fall off or lose a toe.</p>
<p class="normal">在 JavaScript 中，你只能借用这么多不同的方式来解决问题。有一流的功能。有原型，人们仍然有点困惑，因为它们不是标准的经典 OOP。</p><p class="normal">You can only borrow trouble so many different ways in JavaScript. There are first-class functions. There are prototypes, which are a little confusing to people still because they're not the standard classical OOP.</p>
<p class="normal">这差不多够了。我不是一个极简主义者，他会说，“就是这样；我们应该冻结语言。” 这对微软来说是一个方便的掩护，这让我有点生气，因为我看到人们浪费了很多时间，但仍然有错误。您知道，使用 lambda 编码仍然会有很多难以发现的错误。</p><p class="normal">That's almost enough. I'm not a minimalist who says, “That's it; we should freeze the language.” That's convenient cover for Microsoft, and it kind of outrages me, because I see people wasting a lot of time and still having bugs. You know, you can still have lots of hard-to-find bugs with lambda coding.</p>
<p class="normal">Doug 教过人们不同的模式，但我同意 Peter Norvig 的观点：这些模式显示了语言中的某种缺陷。这些模式不是免费的。天下没有免费的午餐。所以我们应该寻找添加正确位的语言的进化。添加可选类型可能会发生。它们甚至可能更像是 PLT 合同。</p><p class="normal">Doug has taught people different patterns, but I do agree with Peter Norvig: those patterns show some kind of defect in the language. These patterns are not free. There's no free lunch. So we should be looking for evolution in the language that adds the right bits. Adding optional types probably will happen. They might even be more like PLT contracts.</p>
<p class="normal"><b>Seibel：</b>你正在处理的很多事情，从 C++ 的静态分析到跟踪 JIT 和 JavaScript 的新特性，似乎你正在努力跟上一些非常前沿的计算机科学研究。</p><p class="normal"><b>Seibel:</b> A lot of the stuff you're dealing with, from static analysis of your C++ to the tracing JITs and new features for JavaScript, seems like you're trying to keep up with some pretty cutting-edge computer-science research.</p>
<p class="normal"><b>Eich：</b>所以我们正在打一场美好的仗，但我们正努力聪明地对待它。我们还试图改变研究方向，因为——这对我来说是显而易见的，甚至在我上学的时候，我认为这仍然是一个问题——学术研究存在很多问题。它与工业广泛分离。</p><p class="normal"><b>Eich:</b> So we're fighting the good fight but we're trying to be smart about it. We're also trying to move the research needle because—this is something else that was obvious to me, even back when I was in school, and I think it's still a problem—there are a lot of problems with academic research. It's widely separated from industry.</p>
<p class="normal"><a id="OEBPS/Chapter04.html.page_149"></a>所以我们想修复一些错误。我们一直在与有实际头脑的学者合作。那太好了。我们没有太多钱，所以我们将不得不使用杠杆——部分原因是让人们一起交谈和建立网络。</p><p class="normal"><a></a>So there's something wrong that we'd like to fix. We've been working with academics who are practically minded. That's been great. We don't have much money so we're going to have to use leverage—partly it's just getting people to talk and network together.</p>
<p class="normal">当学术界每年都在追逐 NSF 资助时，你会失去一些东西。另一件事是，你看到了动态语言的兴起。你会看到关于动态语言将如何完全取代 Java 和静态语言的疯狂、愚蠢的说法，这是无稽之谈。但学者们坚信静态类型系统是最终目的，他们正在研究特定类型的静态类型系统，如 ML、Hindley-Milner 类型推断，并且它完全脱离了工业。</p><p class="normal">You lose something when the academics are all off chasing NSF grants every year. The other thing is, you see the rise in dynamic languages. You see crazy, idiotic statements about how dynamic language are going to totally unseat Java and static languages, which is nonsense. But the academics are out there convinced static type systems are the ultimate end and they're researching particular kinds of static type systems like the ML, Hindley-Milner type inferences and it's completely divorced from industry.</p>
<p class="normal"><b>Seibel：</b>这是为什么？因为它没有解决任何实际问题，还是因为它只是部分解决方案？</p><p class="normal"><b>Seibel:</b> Why is that? Because it's not solving any real problems or because it's only a partial solution?</p>
<p class="normal"><b>Eich：</b>我们与 SML New Jersey 进行了一些合作，以自行托管 JavaScript 第四版的参考实现，该版本现已失效。我们试图做一个定义解释器。我们甚至没有使用 Hindley-Milner。我们会对类型和参数进行注释，以避免在它无法统一类型​​并选择一些随机源代码时收到这些疯狂的、臭名昭著的错误消息，而这通常是错误的。所以这里存在实施质量问题。也许那里也存在类型论问题，因为当统一失败时，很难进行有用的指责。</p><p class="normal"><b>Eich:</b> We did some work with SML New Jersey to self-host the reference implementation of JavaScript, fourth edition, which is now defunct. We were trying to make a definitional interpreter. We weren't even using Hindley-Milner. We would annotate types and arguments to avoid these crazy, notorious error messages you get when it can't unify types and picks some random source code to blame and it's usually the wrong one. So there's a quality-of-implementation issue there. Maybe there's a type-theoretic problem there too because it is difficult, when unification fails, to have useful blame.</p>
<p class="normal">现在你可以做更多的研究，并尝试开发一些更高层次的程序员犯的认知错误模型，并获得更好的责备坐标。也许我只是在这里挑一个小问题，但它看起来确实是一个大问题。</p><p class="normal">Now you could do more research and try to develop some higher-level model of cognitive errors that programmers make and get better blame coordinates. Maybe I'm just picking on one minor issue here, but it does seem like that's a big one.</p>
<p class="normal">学术界并没有帮助引导人们走向更好的模式。我认为学术界有点被遗弃了。也许这不是他们的错。他们赖以生存的经济状况并不好。但我们都知道我们正朝着这个大规模平行的未来前进。没有人解决过它。现在他们都对事务内存很感兴趣。这不会解决它。您不会让嵌套事务在大量处理器之间回滚和争用。这不会有效率。在某些情况下，它实际上不会正常工作。你无法映射你所有的<a id="OEBPS/Chapter04.html.page_150"></a>并发或并行编程算法。你不应该尝试。</p><p class="normal">Academia has not been helpful in leading people toward a better model. I think academia has been kind of derelict. Maybe it's not their fault. The economics that they subsist on aren't good. But we all knew we were headed toward this massively parallel future. Nobody has solved it. Now they're all big about transactional memory. That's not going to solve it. You're not going to have nested transactions rolling back and contending across a large number of processors. It's not going to be efficient. It's not going to actually work correctly in some cases. You can't map all your <a></a>concurrent or parallel programming algorithms on to it. And you shouldn't try.</p>
<p class="normal">像 Joe Armstrong 这样的人在无共享方法方面做得非常好。您在浏览器实现的自定义系统中看到了很多。Chrome 很重要。我们在 JavaScript 实现中以自己的方式进行。我认为，什么都不分享对学者来说甚至都不有趣。事务性内存更有趣，尤其是对于那种计算机架构类型，因为它们可以找到为它提供良好指令和硬件支持的方法。但这并不能解决我们面临的所有问题。</p><p class="normal">People like Joe Armstrong have done really good work with the shared-nothing approach. You see that a lot in custom systems in browser implementations. Chrome is big on it. We do it our own way in our JavaScript implementation. And shared nothing is not even interesting to academics, I think. Transactional memory is more interesting, especially with the sort of computer-architecture types because they can figure out ways to make good instructions and hardware support for it. But it's not going to solve all the problems we face.</p>
<p class="normal">我觉得会有进步，应该涉及到编程语言。这就是为什么我确实认为关于第二个黄金时代的说法没有错。只是我们还没有将语言的用户与潜在的开发人员以及可能研究真正突破性语言的学者联系起来。</p><p class="normal">I think there will be progress and it should involve programming languages. That's why I do think the talk about the second golden age isn't wrong. It's just that we haven't connected the users of the languages with the would-be developers with the academics who might research a really breakthrough language.</p>
<p class="normal"><b>Seibel：</b>你获得了硕士学位，但没有博士学位。您一般会建议想成为程序员的人去攻读计算机科学博士学位吗？还是应该只有某些类型的人这样做？</p><p class="normal"><b>Seibel:</b> You got a Masters but not a PhD. Would you generally recommend that people who want to be programmers should go get a PhD in computer science? Or should only certain kinds of people do that?</p>
<p class="normal"><b>Eich：</b>我认为只有某些人。攻读博士学位需要一定的技能，有时你想知道它是否最终被授予只是因为你忍受了。但是如果你愿意的话，你可以把三个字母放在你的名字后面。这可以帮助您打开某些门。但我在硅谷经历了大约 20 年的通货膨胀繁荣——尽管这种繁荣可能即将结束——这肯定不是一个好的经济权衡。所以我对此并不后悔。</p><p class="normal"><b>Eich:</b> I think only certain kind of people. It takes certain skills to do a PhD, and sometimes you wonder if it's ultimately given just because you endured. But then you get the three letters to put after your name if you want to. And that helps you open certain doors. But my experience in the Valley in this inflationist boom of 20 years or so that we've been living through—though that may be coming to an end—was certainly it wasn't a good economic trade-off. So I don't have regrets about that.</p>
<p class="normal">以系统的、甚至是悠闲的方式去学习某些东西的能力是很有吸引力的。进入市场、遵守摩尔定律、竞争和应对快速的产品周期，有时甚至是一次性软件——如果每个人都这样做，这似乎是一种耻辱。因此，想要获得博士学位且具备相关技能的人可以发挥作用。还有一些有趣的研究要做。我们在 Mozilla 推动的其中一件事是介于学术研究界所推崇的和业界已经实践的之间。那是编译器和 VM 的东西，甚至是调试器——比如 Valgrind——分析工具。投资不足且不性感<a id="OEBPS/Chapter04.html.page_151"></a>研究人员，也许不够新颖，工程化太多，但有突破的空间。我们正在与 Andreas Gal 合作，他让这些论文被拒绝，因为它们太实用了。</p><p class="normal">The ability to go study something in a systematic, and maybe even leisurely, way is attractive. The go-to-market, ride Moore's law, and compete and deal with fast product cycles and sometimes throwaway software—seems like a shame if that's all everybody does. So there's a role for people who want to get PhDs, who have the skills for it. And there is interesting research to do. One of the things that we're pushing at Mozilla is in between what's respected in academic research circles and what's already practice in the industry. That's compilers and VM stuff, debuggers even—things like Valgrind—profiling tools. Underinvested-in and not sexy for <a></a>researchers, maybe not novel enough, too much engineering, but there's room for breakthroughs. We're working with Andreas Gal and he gets these papers rejected because they're too practical.</p>
<p class="normal">当然，我们需要有这种倾向的研究人员，但我们也需要做研究的程序员。我们需要让编程纪律不仅仅是这种与象牙塔中的人隔绝的蓝领事物。</p><p class="normal">Of course, we need researchers who are inclined that way, but we also need programmers who do research. We need to have the programming discipline not be just this sort of blue-collar thing that's cut off from the people in the ivory towers.</p>
<p class="normal"><b>Seibel：</b>你如何看待证据？</p><p class="normal"><b>Seibel:</b> How do you feel about proofs?</p>
<p class="normal"><b>艾希：</b>证明很难。大多数人都很懒惰。拉里沃尔是对的。懒惰应该是一种美德。所以这就是为什么我更喜欢自动化。证明是学者们喜欢而大多数程序员讨厌的东西。编写断言可能很有用。尽管应该警告的错误断言，随着时间的推移，我们在 Mozilla 中有了更多好的断言。从那以后，我们对您想在某些梦想类型系统中表达的不变量是什么有了一些启发。</p><p class="normal"><b>Eich:</b> Proofs are hard. Most people are lazy. Larry Wall is right. Laziness should be a virtue. So that's why I prefer automation. Proofs are something that academics love and most programmers hate. Writing assertions can be useful. In spite of bad assertions that should've been warnings, we've had more good assertions over time in Mozilla. From that we've had some illumination on what the invariants are that you'd like to express in some dream type system.</p>
<p class="normal">我认为将断言视为证据点会有所帮助。但不需要任何假装是完整证明的东西——有足够的证据发表在充满漏洞的学术论文中。</p><p class="normal">I think thinking about assertions as proof points helps. But not requiring anything that pretends to be a complete proof—there are enough proofs that are published in academic papers that are full of holes.</p>
<p class="normal"><b>Seibel：</b>关于一个完全不同的话题，您曾经不得不追踪的最严重的错误是什么？</p><p class="normal"><b>Seibel:</b> On a completely different topic, what's the worst bug you ever had to track down?</p>
<p class="normal"><b>艾奇：</b>哦，伙计。最严重的错误是多线程错误。我在 Silicon Graphics 所做的工作涉及 Unix 内核。内核最初像当时的所有 Unix 内核一样，作为一个整体监视器开始运行，一旦您通过系统调用进入内核，它就会运行完成。除了中断，你可以确定你可以运行到完成，所以没有<a id="OEBPS/Chapter04.html.page_152"></a>锁定您自己的数据结构。那太酷了。非常简单。</p><p class="normal"><b>Eich:</b> Oh, man. The worst bugs are the multithreaded ones. The work I did at Silicon Graphics involved the Unix kernel. The kernel originally started out, like all Unix kernels of the day, as a monolithic monitor that ran to completion once you entered the kernel through a system call. Except for interrupts, you could be sure you could run to completion, so no <a></a>locks for your own data structure. That was cool. Pretty straightforward.</p>
<p class="normal">但是在 SGI，来自 HP 的聪明的年轻人进来了。他们把对称多处理卖给了 SGI。他们真的震撼了旧内核组。他们和他们的一些新人一起进来，他们做到了。他们挺身而出，不断挥杆，直到把球踢出很远的地方。但是他们没有用比 C 和信号量和自旋锁以及可能的监视器、条件变量更好的东西来做到这一点。全部手工编码。所以有很多错误。那真是一场噩梦。</p><p class="normal">But at SGI the bright young things from HP came in. They sold symmetric multiprocessing to SGI. And they really rocked the old kernel group. They came in with some of their new guys and they did it. They stepped right up and they kept swinging until they knocked the ball pretty far out of the field. But they didn't do it with anything better than C and semaphores and spin locks and maybe monitors, condition variables. All hand-coded. So there were tons of bugs. It was a real nightmare.</p>
<p class="normal">我在博客上提到了去澳大利亚和新西兰的免费旅行。我们实际上在现场修复了这个错误，但找到并修复它是地狱般的，因为它是这些错误之一，我们采用了一些单线程内核代码并将其放入这个对称多处理多线程内核中，我们并不担心特定的竞争条件。所以首先我们必须制作一个测试用例来找到它，这已经够难的了。然后在时间压力下，因为当我们在现场时客户想要修复，我们不得不真正想出一个修复。</p><p class="normal">I got a free trip to Australia and New Zealand that I blogged about. We actually fixed the bug in the field but it was hellish to find and fix because it was one of these bugs where we'd taken some single-threaded kernel code and put it in this symmetric multiprocessing multithreaded kernel and we hadn't worried about a particular race condition. So first of all we had to produce a test case to find it, and that was hard enough. Then under time pressure, because the customer wanted the fix while we were in the field, we had to actually come up with a fix.</p>
<p class="normal">诊断它很困难，因为它对时间很敏感。这与这些机器被终端集中器滥用有关。人们将一堆 PTY 连接到真实的终端。澳大利亚布里斯班的实验室学生或采矿软件公司的一群人，在这种 70 年代的立方体海洋中，尽头有一堵玻璃墙，后面是一堆机器，包括 SGI 双处理器机器。这很难，我很高兴我们找到了它。</p><p class="normal">Diagnosing it was hard because it was timing-sensitive. It had to do with these machines being abused by terminal concentrators. People were hooking up a bunch of PTYs to real terminals. Students in a lab or a bunch of people in a mining software company in Brisbane, Australia in this sort of '70s sea of cubes with a glass wall at the end, behind which was a bunch of machines including the SGI two-processor machine. That was hard and I'm glad we found it.</p>
<p class="normal">这些错误通常不会存在多年，但确实很难找到。你必须暂停你的生活，一直想着他们，梦想着他们等等。不过，您最终会做非常基本的事情。就像许多其他错误一样。你最终一分为二——你知道“狼篱”。您尝试通过监视执行和内存状态来弄清楚，并尝试限制错误的范围以及可以解决的控制流和数据。如果它是一个野外指针存储，那么您有点搞砸了，您必须真正开始寻找更难使用的工具，这些工具最近才出现，这要归功于那些千兆赫处理器，如 Valgrind 和 Purify。</p><p class="normal">These bugs generally don't linger for years but they are really hard to find. And you have to sort of suspend your life and think about them all the time and dream about them and so on. You end up doing very basic stuff, though. It's like a lot of other bugs. You end up bisecting—you know “wolf fence.” You try to figure out by monitoring execution and the state of memory and try to bound the extent of the bug and control flow and data that can be addressed. If it's a wild pointer store then you're kinda screwed and you have to really start looking at harder-to-use tools, which have only come to the fore recently, thanks to those gigahertz processors, like Valgrind and Purify.</p>
<p class="normal">对整个内存层次结构进行检测和检查模型很重要。Robert O'Callahan，我们在新西兰的大脑袋，基于 Valgrind 框架开发了自己的调试器，该框架有效地记录了每条指令，因此他可以随时重新创建整个程序状态。它不仅仅是一个时间旅行的调试器。这是一个完整的数据库，因此您会看到一个数据结构，并且有一个字段具有 scrogged 值，您可以说，“谁写了最后一个？” 你得到了完整的堆栈。你可以从效果中推理<a id="OEBPS/Chapter04.html.page_153"></a>回到原因。这是整个游戏在调试中。所以它很慢。这比实时慢了一百倍，但还是有希望的。</p><p class="normal">Instrumenting and having a checked model of the entire memory hierarchy is big. Robert O'Callahan, our big brain in New Zealand, did his own debugger based on the Valgrind framework, which efficiently logs every instruction so he can re-create the entire program state at any point. It's not just a time-traveling debugger. It's a full database so you see a data structure and there's a field with a scrogged value and you can say, “Who wrote to that last?” and you get the full stack. You can reason from effects <a></a>back to causes. Which is the whole game in debugging. So it's very slow. It's like a hundred times slower than real time, but there's hope.</p>
<p class="normal">或者您可以使用这些更快的记录 VM 之一——它们仅在系统调用和 I/O 边界处检查点。他们可以在任何边界重新创建损坏的程序状态，但要进入这些边界之间就更难了。但是，如果你使用它，你可能可以近乎实时地快速关闭，然后一旦你到达那个阶段，你可以将它转移到 Rob 的 Chronomancer 中，并以更慢的速度运行它并获取所有程序状态并找到错误。</p><p class="normal">Or you can use one of these faster recording VMs—they checkpoint only at system call and I/O boundaries. They can re-create corrupt program states at any boundary but to go in between those is harder. But if you use that you can probably close in quickly at near real time and then once you get to that stage you can transfer it into Rob's Chronomancer and run it much slower and get all the program states and find the bug.</p>
<p class="normal">令人遗憾的是，调试技术研究不足。这是工业界和学术界之间存在巨大鸿沟的另一个例子：由于 POPLmark 挑战和类似的事情，学者们正在做证明，有时是手工的，越来越机械化。但在现实世界中，我们都在使用调试器，它们都是 70 年代的垃圾，比如 GDB。</p><p class="normal">Debugging technology has been sadly underresearched. That's another example where there's a big gulf between industry and academia: the academics are doing proofs, sometimes by hand, more and more mechanized thanks to the POPLmark challenge and things like that. But in the real world we're all in debuggers and they're pieces of shit from the '70s like GDB.</p>
<p class="normal"><b>Seibel：</b>在现实世界中，使用符号调试器的人和使用打印语句的人之间存在很大的分歧。</p><p class="normal"><b>Seibel:</b> In the real world one big split is between people who use symbolic debuggers and people who use print statements.</p>
<p class="normal"><b>艾奇：</b>是的。所以我使用 GDB，我很高兴 GDB，至少在 Mac 上，有一个大部分工作的观察点工具。所以我可以观察一个地址，我可以捕捉到它从好位到坏位的变化。这很有帮助。否则我用<code>printf</code>s 来平分。一旦我足够接近，通常我可以在 GDB 中尝试一些东西或使用一些命令脚本。但它非常虚弱。脚本语言本身很弱。我认为 Van Jacobson 添加了循环，我什至不知道这些循环是否通过 FSF 大厅监视器进入了真正的 GDB。</p><p class="normal"><b>Eich:</b> Yeah. So I use GDB, and I'm glad GDB, at least on the Mac, has a watch-point facility that mostly works. So I can watch an address and I can catch it changing from good bits to bad bits. That's pretty helpful. Otherwise I'm using <code>printf</code>s to bisect. Once I get close enough usually I can just try things inside GDB or use some amount of command scripting. But it's incredibly weak. The scripting language itself is weak. I think Van Jacobson added loops and I don't even know if those made it into the real GDB, past the FSF hall monitors.</p>
<p class="normal">但是还有更多的调试可以为您做，这些尝试，比如 Chronomancer 和 Replay，都很好。他们最近确实为我改变了比赛。但是我不知道多线程。有 Helgrind，还有我们正在使用的其他类型的动态竞争检测器。这些产生了一些我们必须清除的误报，试图训练工具或修复我们的代码以不触发它们。陪审团仍在讨论这些问题。</p><p class="normal">But there's so much more debugging can do for you and these attempts, like Chronomancer and Replay, are good. They certainly changed the game for me recently. But I don't know about multithreading. There's Helgrind and there are other sort of dynamic race detectors that we're using. Those are producing some false positives we have to weed through, trying to train the tools or to fix our code not to trigger them. The jury is still out on those.</p>
<p class="normal">坦率地说，多线程的东西让我害怕，因为在我结婚生子之前，它占据了我生命中的很多时间。并不是每个人都准备好考虑并发性和所有可能的订单组合<a id="OEBPS/Chapter04.html.page_154"></a>即使是小场景也有。一旦将代码与其他人的代码组合在一起，它就会失去控制。你不可能在头脑中模拟状态空间。大多数人都做不到。我可能会像 Slashdot 上那些吹牛的人中的一员——当我写关于“Threads suck”的博客时，有人说，“哦，他什么都不知道。他不是一个真正的男人。” 来吧，你这个白痴。我去了新西兰和澳大利亚。我得到了一些津贴。但这绝对是痛苦的，而且需要很长时间。正如奥斯卡王尔德所说的社会主义，“它需要太多的夜晚。”</p><p class="normal">The multithreaded stuff, frankly, scares me because before I was married and had kids it took a lot of my life. And not everybody was ready to think about concurrency and all the possible combinations of orders that are out <a></a>there for even small scenarios. Once you combine code with other people's code it just gets out of control. You can't possibly model the state space in your head. Most people aren't up to it. I could be like one of these chest-thumpers on Slashdot—when I blogged about “Threads suck” someone was saying, “Oh he doesn't know anything. He's not a real man.” Come on, you idiot. I got a trip to New Zealand and Australia. I got some perks. But it was definitely painful and it takes too long. As Oscar Wilde said of socialism, “It takes too many evenings.”</p>
<p class="normal"><b>Seibel：</b>你如何设计代码？</p><p class="normal"><b>Seibel:</b> How do you design code?</p>
<p class="normal"><b>Eich：</b>很多原型设计。我曾经做过一些高级伪代码，然后我开始自下而上地填充。我很少做高级伪代码，因为我通常可以把它放在脑子里，然后自下而上直到它加入。我经常使用现有的代码片段添加一些新的子系统或其他东西，我几乎可以自下而上地完成它。当我在中间遇到麻烦时，我仍然会编写伪代码，然后自下而上地工作，直到我完成它。我尽量不要让它花太长时间，因为你必须能够测试它；您必须能够看到它运行并单步执行它并确保它正在做它应该做的事情。</p><p class="normal"><b>Eich:</b> A lot of prototyping. I used to do sort of high-level pseudocode, and then I'd start filling in bottom up. I do less of the high-level pseudocode because I can usually hold it in my head and just do bottom-up until it joins. Often I'm working with existing pieces of code adding some new subsystem or something on the side and I can almost do it bottom-up. When I get in trouble in the middle I do still write pseudo-code and just start working bottom up until I can complete it. I try not to let that take too long because you've got to be able to test it; you've got to be able to see it run and step through it and make sure it's doing what it's supposed to be doing.</p>
<p class="normal">在该级别的设计之前，可能存在一些实体关系或粗略的模块化。可能有一个或三个我们正在考虑的算法，你在哪里推理它的复杂性——它是线性的吗？它是恒定的吗？每次我编写某种将进行二次复合的线性搜索，并将其发布到 Web 上时，Web 开发人员都发现这是一个问题。他们已经写了足够多的东西来强调它。所以我们倾向于做很多时间常数的数据结构。即便如此，constant 也可以不是一个——它可以大到你关心的程度。</p><p class="normal">Before that level of design, there may be some entity relationships or gross modularization. There's probably an algorithm or three that we're thinking of where you're reasoning about the complexity of it—is it linear? Is it constant? Every time I've written some kind of linear search that's going to compound quadratically, and unleashed it on the Web, web developers have found that to be a problem. They've written enough stuff it stresses it. So we tend to do a lot of data structures that are constant time. And even then, constant can be not one—it can be big enough that you care.</p>
<p class="normal">所以我们做了很多原型设计，我们做了很多自下而上和自上而下的工作，它们在中间相遇。我认为实际上我们，在 Mozilla，没有做足够的重写。我们非常保守。我们是开源的，所以我们有社区，我们试图建立社区并将新人带入。我们当然有用户从中受益的价值，我们不想中断三年重写，如果我们尝试太多就会发生这种情况。</p><p class="normal">So we do lots of prototyping, we do lots of bottom-up and top-down and they meet in the middle. And I think actually we, at Mozilla, don't do enough rewriting. We're very conservative. We are open source, so we have community we try to build and bring new people into. We certainly have value that users benefit from, and we don't want to take a three-year break rewriting, which is what would happen if we tried too much.</p>
<p class="normal">但是，如果您真的在尝试移动针头并且您不确切知道自己在做什么，请重写。需要多次尝试才能知道<a id="OEBPS/Chapter04.html.page_155"></a>你在干什么 然后当你有一个更坚定的设计时，你会坚持下去，你会开始更多地修补它，然后你就会达到这种成熟的状态，我们会用补丁吱吱作响。这是代码进化的死胡同。你知道，也许这是一个很好的沉没成本，你可以坚持多年。也许正是这个东西急需更换。也许在开源世界中出现了一些更好的标准库。</p><p class="normal">But if you really are trying to move a needle and you don't know exactly what you're doing, rewrite. It's going to take several tries to know what the <a></a>hell you're doing. And then when you have a design more firm you'll stick with it and you'll start patching it more, and you'll get to this mature state where we creak with patches. It's kind of an evolutionary dead-end for code. You know, maybe it's a good sunk cost and you can stand on it for years. Maybe it's this thing that's crying out for replacement. Maybe in the open-source world some better standard library has emerged.</p>
<p class="normal">我认为这又回到了编程技巧上。您不只是根据某些旧设计编写代码。您想继续练习，而练习涉及思考设计并将您在编码方面的经验反馈到设计过程中。</p><p class="normal">And that gets back to the craft of programming, I think. You don't just write code based on some old design. You want to keep practicing, and the practicing involves thinking about design and feeding back your experience in coding to the design process.</p>
<p class="normal">我对象牙塔设计和设计模式非常反感。Peter Norvig，当他在 Harlequin 时，他写了这篇关于设计模式实际上只是编程语言中的缺陷的论文。获得更好的编程语言。他是绝对正确的。崇拜模式并思考，“哦，我会使用 X 模式。”</p><p class="normal">I have this big allergy to ivory-tower design and design patterns. Peter Norvig, when he was at Harlequin, he did this paper about how design patterns are really just flaws in your programming language. Get a better programming language. He's absolutely right. Worshipping patterns and thinking about, “Oh, I'll use the X pattern.”</p>
<p class="normal"><b>Seibel：</b>所以更新的体验可以告诉你更好的前进方式。但是，当编写代码显示出现有设计中的重大缺陷时怎么办？</p><p class="normal"><b>Seibel:</b> So newer experiences can show you better ways going forward. But what about when writing the code shows you big flaws in your existing design?</p>
<p class="normal"><b>艾希：</b>那确实发生了。它经常发生。有时很难扔掉并回到原点。你已经做出了承诺，你就陷入了这个陷阱。我用 JavaScript 做到了这一点。我非常匆忙地写了一个字节码解释器。即使在那个时候我就知道我会后悔我所做的一些事情。但这是一个其他人可以理解的设计，我希望得到其他人的帮助。所以我一直质疑设计。我只是意识到我们并不总是能够重新审视我们最深层次的设计决策。这就是我们随后尝试进行大规模重写的地方，因为你真的很难通过增量重写来改变深层设计决策。</p><p class="normal"><b>Eich:</b> That does happen. It happens a lot. Sometimes it's difficult to throw out and go back to square one. You've already made commitments, and you get into this trap. I did this with JavaScript. In a great big hurry, I wrote a byte-code interpreter. Even at the time I knew I was going to regret some of the things I'd done. But it was a design that was understandable to other people and I could hope to get other people helping me work on. So I question design all the time. I just realize that we don't always get the luxury of revisiting our deepest design decisions. And that is where we then attempt to do a big rewrite, because you really would have a hard time incrementally rewriting to change deep design decisions.</p>
<p class="normal"><b>Seibel：</b>您如何决定何时进行大的重写是正确的？感谢 Joel Spolsky，Netscape 在某些方面是大改写危险的典型代表。</p><p class="normal"><b>Seibel:</b> How do you decide when it's right to do a big rewrite? Thanks to Joel Spolsky, Netscape is in some ways the poster child for the dangers of the big rewrite.</p>
<p class="normal"><b>Eich：</b><i>Netscape</i>迫切希望通过使用<a id="OEBPS/Chapter04.html.page_156"></a>他们的新渲染引擎，就像我的第一个面向对象的渲染引擎。从高层次上看，这听起来不错；它使用 C++ 和设计模式。但它有很多问题。</p><p class="normal"><b>Eich:</b> There was an imperative from Netscape to make the acquisition that waved the <i>Design Patterns</i> book around feel like they were winners by using <a></a>their new rendering engine, which was like My First Object-Oriented Rendering Engine. From a high level it sounded good; it used C++ and design patterns. But it had a lot of problems.</p>
<p class="normal">但我们进行重大重写的第二个原因是——我在 mozilla.org，我真的对 Netscape 有点生气，就像 Jamie 一样，他正准备退出。我想，你知道，我们需要为新的贡献者开放家园空间。我们不能用这个 1994 年的学生代码的老毛团来做。或者我的 Unix 内核风格的解释器代码。</p><p class="normal">But the second reason we did the big rewrite—I was in mozilla.org and I really was kind of pissed at Netscape, like Jamie, who was getting ready to quit. I thought, you know, we need to open up homesteading space to new contributors. We can't do it with this old hairball of student code from 1994. Or my fine Unix kernel-style interpreter code.</p>
<p class="normal">我们需要做一个相当大的重置。是的，我们将在运输后四年。那时我认为我们没有告诉高层管理人员，因为他们不想听，所以我们正在针对他们进行优化。这让一些管理层付出了代价。尽管他们在选项上都做出了惊人的选择——比我做的要好得多。但对于 Mozilla 来说，这是正确的交易。</p><p class="normal">We needed to do a fairly big reset. Yeah, we were going to be four years from shipping. At that point I don't think we were telling upper management that because they didn't want to hear it, so we were optimizing to them. And that cost some of the management their heads. Though they all made out fabulously on the options—much better than I did. But for Mozilla that was the right trade.</p>
<p class="normal">事后看来，我们是幸运的，因为我们本可以让 Web 发展得更快。微软——有些人声称这是由于反托拉斯案而不是他们的本性——倾向于坐在网络上并使其停滞不前。所以这让我们有时间挥舞标准旗帜——这是两刃的，半废话——然后去重写。像 Joel 一样，我对重写持怀疑态度。我认为很难找到这种利益一致并获得足够的资金来度过难关而不错过市场。例外情况非常罕见。</p><p class="normal">We were lucky in hindsight, because we could have had a more rapid evolution of the Web. Microsoft was—some people claim this was due to the antitrust case more than their nature—inclined to sit on the Web and stagnate it. So that gave us time to wave the standards flag—which is two-edged and half bullshit—and go rewrite. Like Joel, I'm skeptical of rewrites. I think it's rare to find that kind of an alignment of interests and get enough funding to live through it and not miss the market. The exceptions are very rare.</p>
<p class="normal">不过，我之前提到的重写是在您制作原型时。这很关键，而且规模较小。它可能是对一大堆代码的横切更改，所以它的行数很少，但它的范围很大，而且你必须满足所有不变量。或者它可能是一个新的 JIT 或其他什么，你可以摆脱它。</p><p class="normal">The rewrites I was speaking of earlier, though, were when you're prototyping. That's critical and smaller-scale. It may be a cross-cutting change to a big pile of code so it's small in lines, but it's big in reach and all the invariants you have to satisfy. Or maybe it's a new JIT or whatever, and that you can get away with.</p>
<p class="normal"><b>Seibel：</b>你做过任何文学编程吗，la Knuth？</p><p class="normal"><b>Seibel:</b> Have you ever done any literate programming, a la Knuth?</p>
<p class="normal"><b>Eich：</b>我遵循了原始的东西。非常整洁。我喜欢它。这是单词检索。他有某种 hash-trie 数据结构，而且都是经过文字编程的。然后 Doug McIlroy 出现并用管道完成了这一切。</p><p class="normal"><b>Eich:</b> I followed the original stuff. It was very neat. I liked it. It was word retrieval. He had some kind of a hash-trie data structure and it was all literately programmed. Then Doug McIlroy came along and did it all with a pipeline.</p>
<p class="normal"><a id="OEBPS/Chapter04.html.page_157"></a>我们的程序被大量评论，但我们没有任何方法可以提取散文并以某种方式让人类（如果不是自动）根据代码对其进行检查。Python 人员在那里做了一些更有趣的工作。除了发表大量评论外，我什么也没做。我确实回去并保持评论——这真的很痛苦，有时我不这样做，然后我后悔了，因为有人得到了一个流浪汉。</p><p class="normal"><a></a>Our programs are heavily commented but we don't have any way of extracting the prose and somehow making it be checked by humans, if not automatically, against the code. Python people have done some more interesting work there. I have not done anything more than heavily comment. I do go back and maintain comments—it's a real pain and sometimes I don't do it and then I regret it because somebody gets a bum steer.</p>
<p class="normal">我其实很喜欢麦克罗伊的反驳。这不是对文学编程的反驳——但它有点。你不想写太多的文字、散文或代码。在某些方面，代码应该在小层面上说明一切。在更大的层面上，大怪物功能或模块边界，你需要文档。所以文档注释或类似的东西——文档字符串。在评论中嵌入测试。我想这就是 Python 最重要的地方。那挺好的。</p><p class="normal">I actually like McIlroy's rejoinder. It wasn't a rebuttal of literate programming—but it was kind of. You don't want to write too many words, prose or code. In some ways the code should speak for itself at the small level. It's at the bigger level, the big monster function or the module boundary, that you need docs. So doc comments or things like them—doc strings. Embedding the test in the comment. I guess that's the big Python thing. That's good.</p>
<p class="normal">有一些东西需要文字编程，尤其是这些集成测试和文档字符串。我希望看到更多语言支持的内容。我们尝试使用一流的元数据挂钩或反射挂钩向 ES4 添加某种文档注释，但不可能让所有人都同意。</p><p class="normal">There is something to literate programming, especially these integrated tests and doc strings. I'd like to see more of that supported by languages. We tried to add doc comments of some sort to ES4 with first-class metadata hooks or reflection hooks and it was just impossible to get everybody to agree.</p>
<p class="normal"><b>Seibel：</b>你会阅读你不在处理的代码吗？</p><p class="normal"><b>Seibel:</b> Do you read code you're not working on?</p>
<p class="normal"><b>Eich：</b>我这样做是我工作的一部分。代码审查是一个强制性的预签入步骤，主要是为了弥补 Netscape 的糟糕招聘，但我们保留了它并且仍然将它用于集成审查。我们有一个单独的“超级评论”，用于当您接触大量模块并且您不知道不再在 Mozilla 工作的 Joe Schmoe 头脑中知道的所有隐藏不变量时。其他人可能已经弄明白了，所以您有经验的人可以看大局。有时，如果您知道自己在做什么并且您在那种绝地委员会中，您可以绕过它，但我们并不想在它上面作弊太多。</p><p class="normal"><b>Eich:</b> I do it as part of my job. Code review is a mandatory pre-check-in step, mostly to compensate for Netscape's bad hiring, but we kept it and still use it for integration review. We have a separate “super review” for when you're touching a lot of modules and you don't know all the hidden invariants that Joe Schmoe, who no longer works on Mozilla, knew in his head. Somebody else may have figured them out so you have somebody experienced to look at the big picture. Sometimes you can bypass it if you know what you're doing and you're in the sort of Jedi council, but we're not trying to cheat on it too much.</p>
<p class="normal">我们没有设计评审，所以有时这会导致设计评审延迟。他们说，“哦，回到绘图板。你写的代码太多了。你应该以其他方式设计它。” 那是个例外。我们不会强加任何类型的瀑布，设计然后实现。这是我进入这个行业时的一件大事<a id="OEBPS/Chapter04.html.page_158"></a>在 80 年代初期，坦率地说，那是一场噩梦。你把所有的时间都花在写文档上，然后你去写代码，你常常意识到这真的很愚蠢，你完全改变了代码，把文档记在了记忆洞里。</p><p class="normal">We don't have design reviews, so sometimes this causes a delayed design review to happen. They say, “Oh, back to the drawing board. You wrote too much code. You should have designed it this other way.” That's the exception. We aren't going to impose any kind of waterfall, design then implementation. That was the big thing when I was getting into the industry <a></a>in the early '80s and it was a nightmare, frankly. You spend all this time writing documents and then you go to write the code and often you realize that it's really stupid and you totally change the code and put the documents down the memory hole.</p>
<p class="normal"><b>Seibel：</b>这就是进入 Mozilla 的代码；你有没有阅读过 Mozilla 之外的其他人的代码，只是为了启发？</p><p class="normal"><b>Seibel:</b> So that's code that is going into Mozilla; do you ever read other people's code, outside Mozilla, just for edification?</p>
<p class="normal"><b>Eich：</b>开源很棒。我喜欢查看世界其他地方的其他人的代码。我没有花足够的时间在这上面，但我确实研究了服务器框架，或者我研究了 Python 和 Ruby 之类的东西。</p><p class="normal"><b>Eich:</b> Open source is great. I love looking at other people's code that's in some other part of the world. I don't spend enough time on it but I do look at server frameworks or I look at things like Python and Ruby.</p>
<p class="normal"><b>Seibel：</b>那些东西的实现？</p><p class="normal"><b>Seibel:</b> The implementations of those things?</p>
<p class="normal"><b>Eich：</b>实现和库代码。我查看了 Ajax 库 — 看到人们可以变得多么聪明以及这一小部分工具（闭包、原型和对象）如何用于创建合理、方便、有时非常方便的抽象，这令人振奋。它们并不总是坚固或安全，但它们非常方便。</p><p class="normal"><b>Eich:</b> Implementations and also library code. I look at the Ajax libraries—and it's heartening to see how clever people can be and how this small set of tools—closures, prototypes, and objects—can be used to create reasonable, convenient, sometimes very convenient abstractions. They're not always hardened or safe but they're awfully convenient.</p>
<p class="normal"><b>Seibel：</b>当你阅读一大段代码时，你是如何进入其中的？</p><p class="normal"><b>Seibel:</b> When you read a big piece of code, how do you get into it?</p>
<p class="normal"><b>Eich：</b>我以前是自上而下开始的。如果它足够大，您将获得函数指针并且控制流变得不透明。我有时会在调试器中驱动它并以这种方式玩弄它。此外，我寻找我认识的自下而上的模式。如果它是一个语言处理器，或者如果它有一些我理解的系统调用，我可以开始研究如何使用这些原语。系统中的更高级别如何使用它？这有助于我四处走动。但真正理解它的是这个格式塔过程，它涉及从不同的角度观察顶部和底部以及不同的视图，在调试器中播放，在调试器中单步执行——尽管这可能非常乏味。</p><p class="normal"><b>Eich:</b> I used to start top-down. If it's big enough you get function pointers and control flow gets opaque. I sometimes drive it in the debugger and play around with it that way. Also, I look for bottom-up patterns that I recognize. If it's a language processor or if it's got something that makes system calls that I understand, I can start looking at how those primitives are used. How does that get used by higher levels in the system? And that helps me get around. But really understanding it is this gestalt process that involves looking at different angles of top and bottom and different views of it, playing in the debugger, stepping through in the debugger—incredibly tedious though that can be.</p>
<p class="normal">如果你能稍微了解堆中发生的事情——追踪指针，遍历cons cells，等等——尽管这很乏味，但还是值得的。对我来说，这与阅读资源一样重要。可以获取长途阅读资源；您也可能会陷入困境并感到无聊，并说服自己您了解一些您不了解的事情。</p><p class="normal">If you can understand what's going on a little bit in the heap—chase pointers, walk through cons cells, whatever—that can be worth the trouble though it gets tedious. That, to me, is as important as reading source. You can get a long way reading source; you can also get stuck and get bored and convince yourself you understand something that you don't.</p>
<p class="normal"><a id="OEBPS/Chapter04.html.page_159"></a>当我处理 JavaScript 的正则表达式时，我正在查看 Perl 4。我确实在调试器中单步执行它，并阅读了代码。这给了我想法；我所做的实施是相似的。在这种情况下，它们的递归回溯性质有点新奇，所以我不得不绞尽脑汁。它确实有助于调试简单的正则表达式，只是为了跟踪执行。我知道其他程序员也这么说：你应该单步执行代码，你应该了解程序的动态状态在各种快速鸟瞰图或健全性检查中是什么样的，我同意这一点。</p><p class="normal"><a></a>When I did JavaScript's regular expressions I was looking at Perl 4. I did step through it in the debugger, as well as read the code. And that gave me ideas; the implementation I did was similar. In this case the recursive backtracking nature of them was a little novel, so that I had to wrap my head around. It did help to just debug simple regular expressions, just to trace the execution. I know other programmers talk about this: you should step through code, you should understand what the dynamic state of the program looks like in various quick bird's-eye views or sanity checks, and I agree with that.</p>
<p class="normal"><b>Seibel：</b>你会用自己的代码来做这件事吗，即使你没有追踪错误？</p><p class="normal"><b>Seibel:</b> Do you do that with your own code, even when you're not tracking down a bug?</p>
<p class="normal"><b>Eich：</b>当然——只是健全性检查。我有很多断言，所以如果这些断言失败，那么我肯定会在调试器中。但有时你编写代码并且你有一些聪明的簿记方案或其他。然后你测试它，它似乎可以工作，直到你在调试器中单步执行它。尤其是当星星和月亮对齐时才发挥一点聪明才智。然后你想使用一个条件断点，甚至一个观察点，一个数据断点，然后你可以实际捕捉到它并检查，是的，行星都按照它们应该的方式对齐并且可能测试它你不是生活在乐观的小马​​国。您实际上可以在调试器中查看，而在源代码中您仍然处于小马之地。所以这似乎很重要；我仍然这样做。</p><p class="normal"><b>Eich:</b> Absolutely—just sanity checks. I have plenty of assertions, so if those botch then I'll be in the debugger for sure. But sometimes you write code and you've got some clever bookkeeping scheme or other. And you test it and it seems to work until you step through it in the debugger. Particularly if there's a bit of cleverness that only kicks in when the stars and the moon align. Then you want to use a conditional break point or even a watch point, a data break point, and then you can actually catch it in the act and check that, yes, the planets are all aligned the way they should be and maybe test that you weren't living in optimistic pony land. You can actually look in the debugger, whereas in the source you're still in pony land. So that seems important; I still do it.</p>
<p class="normal"><b>Seibel：</b>你发现问题的方式是否是通过你的思维模型逐步查看源头，然后你发现它没有发生？</p><p class="normal"><b>Seibel:</b> Is the way you discover a problem that you're stepping through looking at the source with your mental model of what's about to happen, and then you see it not happen?</p>
<p class="normal"><b>Eich：</b>你看它不会发生，或者——这是我的问题——我在小马国。我越来越老，越来越怀疑，我做得越来越好，但我仍然对某些事情感到乐观。在我的脑海深处，这只 Jiminy Cricket 正在窃窃私语，“你可能有一个错误，因为你忘记了什么。” 这种问题仍然发生在我身上。</p><p class="normal"><b>Eich:</b> You see it not happen, or—and this is my problem—I was in pony land. I'm getting older and more skeptical and I'm doing better, but there's still something that I was optimistic about. In the back of my mind this Jiminy Cricket is whispering, “You probably have a bug because you forgot about something.” That kind of problem happens to me still.</p>
<p class="normal">有时我知道这一点，我发誓——在某个地方我知道我错了。我的后脑有这种痒——好吧，我的后脑没有；我不知道它在哪里；微管。不管怎样，我觉得有些事情我应该<a id="OEBPS/Chapter04.html.page_160"></a>注意，在调试器中帮助我注意它，它帮助我强制解决问题或看到测试向量，虽然它在某种意义上涵盖了代码，但并未涵盖所有组合，因为它是一个巨大的，巨大的超空间。如果你只是改变这个值，那么你就会陷入困境。</p><p class="normal">And sometimes I know about it, I swear—somewhere in there I know I'm wrong. I have this sort of itch in my hind-brain—well, not in my hind-brain; I don't know where it is; the microtubules. Anyway, I kind of feel like there's something that I should <a></a>watch out for, and being in debugger helps me watch out for it and it helps me force the issue or see that the test vector, though it covered the code in some sense, didn't cover all the combinations, because it's a huge, huge hyperspace. And if you just change this one value then you'd go into a bad place.</p>
<p class="normal"><b>Seibel：</b>除了阅读代码，很多程序员还阅读有关编程的书籍——您有什么推荐的书籍吗？</p><p class="normal"><b>Seibel:</b> In addition to reading code, lots of programmers read books about programming—are there any books that you would recommend?</p>
<p class="normal"><b>艾希：</b>我应该是一个更好的文学学生。但我认为这有点像音乐，因为你必须练习它。而且你可以通过阅读别人的代码学到很多东西。我确实喜欢 Brian Kernighan 的书；我认为它们很整洁，因为它们会构建少量代码，然后开始重复使用它，并进行模块化。以及高德纳 (Knuth) 的<i>《计算机编程艺术》</i>，第 1-3 卷，尤其是半数值方面的内容。双重哈希——我喜欢这些部分。关于黄金比例的引理和证明留作练习。</p><p class="normal"><b>Eich:</b> I should be a better student of the literature. But I think it's sort of like music in that you have to practice it. And you can learn a lot reading other people's code. I did like Brian Kernighan's books; I thought they were neat, because they would build up a small amount of code, and start reusing it as you go, and modularizing. And Knuth's <i>Art of Computer Programming</i>, Volumes 1–3, especially the seminumerical stuff. Double-hashing—I love those parts. The lemma about the golden ratio with the proof left as an exercise.</p>
<p class="normal">但我对通过书本学习编程持怀疑态度。编程部分是工程；天气好的时候可能会有一些数学。还有很多实用的东西甚至没有上升到土木工程和机械工程意义上的工程水平。也许它会随着时间的推移更加正式化。</p><p class="normal">But I'm a little skeptical of book learning for programming. Programming is partly engineering; there's maybe some math on a good day. And then there's a lot of practical stuff that doesn't even rise to the level of engineering in the sense of civil engineering and mechanical engineering. Maybe it'll be formalized more over time.</p>
<p class="normal">肯定有一个很好的知识库。计算机科学是一门科学。我记得 20 年前有人在 Usenet 上说过，“精简科学，三分之一的严谨。” 随着时间的推移，仍然有很多东西看起来并不像它真的经得起考验——这些 10 页、10 点字体的论文往往有漏洞，要么发表，要么灭亡。期刊出版物更好，因为您可以与审稿人互动；这不仅仅是真心话大冒险。他们会得到更仔细的审查。机械化打样领域令人印象深刻。但它仍然没有到达程序员。因此，在我看来，计算机科学中缺少一些东西，这让我对书本学习持怀疑态度。我可能不应该在这条 Luddite 赛道上走得太远。但它就在那里。</p><p class="normal">There's definitely a good corpus of knowledge. Computer science is a science. I remember somebody on Usenet 20 years ago said, “Science lite, one-third the rigor.” There's still a lot of stuff that doesn't look like it really holds up over time—there are these publish-or-perish ten-page, ten-point-font papers that often have holes in them. The journal publications are better because you get to interact with the referee; it's not just a truth or dare. And they get reviewed more carefully. The areas of mechanized proofs, that's getting impressive. But it's still not reaching programmers. So there's something a little bit missing in computer science in my view that makes me skeptical of book learning. I should probably not go so far on this Luddite track. But there it is.</p>
<p class="normal">那里有科学，有重要的东西要学。你也可以花很多时间研究它们。我认识很多从事 JavaScript 语言开发工作的理论方面的人，他们中的很多人也是黑客，这很好。其中一些不会编程。<a id="OEBPS/Chapter04.html.page_161"></a>他们不是真正务实的人。他们有惊人的洞察力，有时会非常有成效，但是当你必须实际编写程序并将它们交付给用户并让它们可用并让它们赢得某种市场竞争时，你就离理论很远了。但我对理论很感兴趣，它确实有助于改善我们的生活。</p><p class="normal">There is science there, and there are important things to learn. You could spend a lot of time studying them, too. I know a lot of people on the theoretical side of it from work on JavaScript language development, and a lot of them are hackers, too, which is good. Some of them don't program. <a></a>They're not really practical people. They have amazing insights, which can sometimes be very productive, but when you have to actually write programs and ship them to users and have them be usable and have them win some sort of market contest, you're far removed from theory. But I am interested in theory, and it does help improve our lives.</p>
<p class="normal"><b>Seibel：</b>还有其他种类的书。有些书可以向您介绍编程技巧，但没有太多理论。</p><p class="normal"><b>Seibel:</b> There are other kinds of books too. There are books that introduce you to the craft of programming, without a lot of theory.</p>
<p class="normal"><b>Eich：</b>这就是我喜欢的那种书。我们讨论了高德纳 (Knuth) 的文字编程论文。我喜欢整个编程领域。我喜欢 Smalltalk 书籍。现在回想起来，那些影响还是挺大的。阿黛尔戈德堡的书。在此之前，<i>字节</i>问题。</p><p class="normal"><b>Eich:</b> And that's the kind of book I like. We talked about Knuth's literate programming paper. And there was a whole area of programming as craft that I like. I like the Smalltalk books. Now that I think about it, those were pretty influential. The Adele Goldberg book. And before that, the <i>Byte</i> issue.</p>
<p class="normal"><b>Seibel：</b>封面上的热气球？</p><p class="normal"><b>Seibel:</b> With the hot-air balloon on the cover?</p>
<p class="normal"><b>艾希：</b>是的。这极大地改变了我。那是很大的。那就像 80 年代左右。所以我当时并没有真正做很多编程。我在想它，我在读它，我在本科大学里玩这个老铁。Smalltalk 环境的纯粹性，它是如此高度自举的事实——所有这些都以一种让我想参与编程语言和虚拟机的方式真正打动了我。进入 Unix 是物理机器和操作系统，这就是行动所在。但即使在那个时候，我也在阅读 — 有一本 Springer-Verlag 的书，里面有一堆论文，当时的人们一直在幻想通用对象文件格式和 Java 字节码，基本上是在它的时代之前。但是，是的，Smalltalk 非常庞大。我没有'</p><p class="normal"><b>Eich:</b> Yeah. That turned me around in a big way. That was big. That was like '80 or so. So I wasn't really doing a lot of programming then. I was thinking about it and I was reading about it and I was playing around on this old iron at undergraduate university. The purity of the Smalltalk environment, the fact that it was so highly bootstrapped—all that really hit me in a way that made me want to be involved in programming—languages and virtual machines. Going into Unix was physical machines and operating systems, and that was where the action was. But even then I was reading—there was a Springer-Verlag book that had a bunch of papers, and people back then were fantasizing about universal object file formats and Java byte-code, essentially, before its time. But yes, Smalltalk was huge. I didn't actually get to use it until years later at U of I, when they finally released something that ran on the Suns of the time and it was slow.</p>
<p class="normal"><b>Seibel：</b>换个话题，您如何识别编程人才？</p><p class="normal"><b>Seibel:</b> On another topic, how do you recognize programming talent?</p>
<p class="normal"><b>Eich：</b>我们刚才雇了一个人；他是我们雇用的超级大脑之一的朋友。但我认为这是一个本科生或学士学位的人；我不确定他是否完成了。他遇到了一个为我们工作的人，他们都是 OCaml 黑客，他在一边做他自己的 OCaml 黑客。他正在考虑我们在静态分析中看到的问题。当我们采访他时，我知道他很年轻，但你看不出来。有些人认为，“哦，是的，他没有<a id="OEBPS/Chapter04.html.page_162"></a>做了很多。你知道，我们应该只雇用摇滚明星；我们跟他谈什么？”</p><p class="normal"><b>Eich:</b> We hired somebody a while ago; he was a friend of one of the superbrains we'd hired. But this was a guy who was, I think, just undergrad or a bachelor's degree; I'm not sure if he even finished. He met a guy who was working for us and they're both OCaml hackers, and he was doing his own OCaml hacking on the side. And he was thinking about problems that we were seeing in my static analysis. When we interviewed him, I knew he was young but you couldn't tell. Some people thought, “Oh, yeah, he hasn't <a></a>done much. You know, we should only hire rock stars; what are we talking to him for?”</p>
<p class="normal">我说，“不，你们看错了。这就像我们聪明的实习生之一。在他们年轻的时候得到他们。他自己做了很多，他已经进入了 OCaml；他不仅知道源语言，还知道运行时，他破解了本地方法，他正在编写一个 OCaml 操作系统，玩具操作系统。不过这人不错。” 并不是我给了他任何特定的编程测试。只是我听过他谈论他做了什么以及他为什么这样做。他不只是在重复关于 C++ 模式的废话。不幸的是，我们有这样的孩子。好人和​​足够的程序员，对于他们所做的，Java Enterprise 的东西。但是我们需要一个不同的人，而这个人是不同的。</p><p class="normal">I said, “No, you guys are looking at this wrong. This is like one of our bright interns. Get them while they're young. He's done a bunch by himself, he's gotten into OCaml; he knows not just the source language, but the runtime, and he's hacked native methods and he was writing an OCaml operating system, toy operating system. But this guy is good.” And it wasn't that I gave him any particular programming test; it was just that I'd listened to him talk about what he'd done and why he'd done it. He wasn't just repeating pabulum about C++ patterns. We have kids like that, unfortunately. Nice people and adequate programmers, for what they were doing, Java Enterprise stuff. But we needed somebody different, and this guy was different.</p>
<p class="normal">所以在采访中，主要的问题是克服人们对他年龄的误读，或者认为他的成就不够。但我们雇用了他，他只是一个超级巨星。他做了很多静态分析工具，最初是在这个开源 Berkeley Oink 框架上，然后作为插件在 GCC 上，与 GCC 人员一起工作。现在他正在将我们的移动工作推向高速档，只是做穷人的分析和<code>printf</code>时间戳，找出成本在哪里并降低成本。</p><p class="normal">So in the interview the main problem was overcoming people misreading his age or thinking he wasn't accomplished enough. But we hired him and he's just been a superstar. He's done a bunch of static analysis tooling, originally on this open-source Berkeley Oink framework, and then on GCC as plug-ins, working with the GCC guys. Now he's kicking our mobile effort into high gear, just doing poor man's profiling and <code>printf</code> of timestamps and finding out where the costs are and whacking them.</p>
<p class="normal">所以当我采访他时，我知道他很有才华。他是由聪明人推荐的，这很好，因为你知道聪明人彼此喜欢并且可以互相评判——通常不会出现功能失调，“雇用我的朋友，他真的不聪明。” 他们想和聪明的人一起工作。也许这听起来像是我在作弊，但这是我识别人才的一种方式。我认为这就是我们聘请超级黑客的原因。我认为我们正在雇用所有 Valgrind 黑客。其中一些人可以做任何事情；他们不乱搞。</p><p class="normal">So when I interviewed him I knew there was talent. That he came recommended from somebody bright was good, because you know bright people like each other and can judge each other—generally there's not a dysfunctional, “Hire my friend, who's really not bright.” They want to work with bright people. Maybe this sounds like I'm cheating, but that's one way I recognize talent. And I think that's why we're hiring superhackers. I think we're hiring up all the Valgrind hackers. Some of those guys can do anything; they don't fuck around.</p>
<p class="normal"><b>Seibel：</b>那是不是你在采访中经常做的事情：让他们谈论他们自己的项目？</p><p class="normal"><b>Seibel:</b> So is that something you often do in interviews: get them to talk about their own projects?</p>
<p class="normal"><b>艾奇：</b>我愿意。我不会给人们难题来解决。我们这里有人这样做。就我们必须这样做的程度而言，我们正在使用它来过滤申请人，我担心。</p><p class="normal"><b>Eich:</b> I do. I don't give people puzzles to solve. We have people who do that here. To the extent that we have to do that and we're using that to filter applicants, I worry.</p>
<p class="normal"><a id="OEBPS/Chapter04.html.page_163"></a><b>Seibel：</b>这甚至是一个很好的首通过滤器吗？</p><p class="normal"><a></a><b>Seibel:</b> Is that even a good first-pass filter?</p>
<p class="normal"><b>艾希：</b>我持怀疑态度。谷歌确实做到了这一点，他们聘请了一群非常聪明的解谜者。但他们中的一些人，他们的街头智慧并不一定存在，成熟的判断力。所以我对此持怀疑态度。我认为我们必须在某种程度上这样做，因为你最终可能会找到一个能说会道但实际上在编程方面效率不高的人，所以你想看到他们站起来思考，你想看看他们是否已经之前解决了一个问题。所以我们给他们相当实际的问题。不是深奥的谜题或数学题，而是更像是编程问题。</p><p class="normal"><b>Eich:</b> I'm skeptical. Google does that in spades, and they hire a bunch of very bright puzzle-solvers. But some of them, their street smarts are not necessarily there, and mature judgment. So I'm skeptical of it. I think we have to do it to some extent because you can end up getting someone who talks well, but actually isn't effective at programming, and so you want to see them think on their feet, you want to see if they've solved a problem before. So we give them fairly practical problems. Not esoteric puzzles or math-y things, but more like programming problems.</p>
<p class="normal">检查他们的 C++ 知识，因为 C++ 是毛茸茸的。所以这是一种理智检查，不足以说“让我们雇用他吧。” 但如果他们通过了，那很好；如果他们不这样做，我们会担心。要说“让我们雇用他们”，我们必须看到其他东西，那就是涉及细节的火花，比如他们做了什么、他们的方法以及他们使用了什么语言。</p><p class="normal">Check their C++ knowledge, because C++ is hairy. So it's sort of a sanity check, not enough to say, “Let's hire him.” But if they pass it, that's good; if they don't, we worry. To say, “Let's hire them,” we have to see something else, and that's the spark that involves particulars, like what they've done and their approach and what languages they've used.</p>
<p class="normal">也许我也同情奇鸭。我不介意有点不同的人。我不想雇用难以共事的人，但我们需要人才。我们需要有不同想法的人。</p><p class="normal">Maybe I'm also sympathetic to the odd duck. I don't mind people who are a little different. I don't want to hire somebody who's hard to work with, but we need talent. We need people who think differently.</p>
<p class="normal">当我还是一名本科生时，我真的受到了 Pirsig 的<i>Zen and the Art of Motorcycle Maintenance 的</i>影响。我一直在研究柏拉图和早期哲学家。那时，我更倾向于某种哲学意义上的唯心主义。我认为 little-endian 字节顺序优于 big-endian，因为毕竟最低有效位在最低地址中——其中存在某种和谐或几何关系。但是尝试阅读十六进制转储。实际的事情很重要；细节很重要。著名的雅典学派画作亚里士多德朝下，柏拉图朝上——我现在更偏向于朝下。随着年龄的增长，我越来越怀疑，对什么有效也越来越感兴趣。</p><p class="normal">When I was an undergrad I was really affected by Pirsig's <i>Zen and the Art of Motorcycle Maintenance</i>. And I had been going through Plato and the early philosophers. I was, at that point, inclined more towards idealism in some philosophical sense. I thought little-endian byte order was superior to big-endian, because after all, the least significant digits are in the lowest address—there was some kind of harmony or geometry in that. But try reading a hex dump. Practical things matter; particulars matter. The famous School of Athens painting with Aristotle pointing down and Plato pointing up—I'm more on the pointing-down side now. As I get older I get more and more skeptical and more and more interested in what works.</p>
<p class="normal">当我面试人时，当我寻找人才时，我很难不坚持细节和实用性。好的，所以这个人知道 OCaml——这意味着他很聪明，但我们应该雇用他吗？嗯，不，但他也自己做事，当我和他谈话时他在思考，他已经在考虑编译或分析问题，我们打算雇用他来解决这些问题。但也许最重要的是<a id="OEBPS/Chapter04.html.page_164"></a>真实的故事，是我们正在经历的网络，我们雇用的那个人，他是他的朋友。</p><p class="normal">When I'm interviewing people, when I'm looking for talent, it's very hard for me to not stick with particulars and practicalities. OK, so this guy knew OCaml—it meant he was smart, but should we hire him? Well no, but he also did things on his own and he thought on his feet when I talked to him, and he was already thinking about compilation or analysis problems that we were going to hire him to work on. But maybe the important thing there, the <a></a>real story, was the network we were going through, the guy we hired, he was his friend.</p>
<p class="normal"><b>Seibel：</b>你还喜欢编程吗？</p><p class="normal"><b>Seibel:</b> Do you still enjoy programming?</p>
<p class="normal"><b>艾奇：</b>是的。这有点像上瘾；这有点问题。这不仅仅是让代码运行的编程部分；对我来说，现在越来越多地找到正确的想法，它具有 90/10 权衡的新泽西哲学——一个甜美、健全的理论核心，它不会解决你<i>所有</i>的问题，但当你落在 10% 时输了，你不下地狱。您实际上可以通过这种方式获胜，并且代码保持足够小和足够简单，并且理论和实现之间存在一些差异。我喜欢。这仍然吸引我；它仍然很有趣；当我应该睡觉时，它让我夜不能寐。</p><p class="normal"><b>Eich:</b> Yeah. It's a bit like an addiction; it's a little problematic. It's not just the programming part of getting the code to run; to me now it's more and more finding the right idea that has the New Jersey philosophy of a 90/10 trade-off—a sweet, sound theoretical core that isn't going to solve <i>all</i> your problems but when you fall on the 10 percent that loses, you don't go to hell. You can actually win this way and the code stays small enough and simple enough and there's some dance between theory and implementation. I like that. That still appeals to me; it still is fun; it keeps me up at night thinking about it when I should be sleeping.</p>
<p class="normal"><b>Seibel：</b>有没有你不再喜欢的部分？</p><p class="normal"><b>Seibel:</b> Are there parts of it that you don't enjoy as much anymore?</p>
<p class="normal"><b>艾奇：</b>我不知道。C++。我们能够使用它的大部分功能——它们太多了。它可能有一个比 Java 更好的类型系统。但我们仍在使用 70 年代的调试器和链接器，这很愚蠢。我不知道我们为什么要忍受它。</p><p class="normal"><b>Eich:</b> I don't know. C++. We're able to use most of its features—there are too many of them. It's probably got a better type system than Java. But we're still screwing around with '70s debuggers and linkers, and it's stupid. I don't know why we put up with it.</p>
<p class="normal">对原始工具的不耐烦和仇恨驱使我努力成为一名更好的程序员。我们的代码现在充满了断言，它们是致命的。这对我们很重要。但这是对我有帮助的事情，尤其是当我在代码上执行其中一项据称合理的 90/10 甜蜜权衡移动时，它并不能完全满足所有不变量。我忘记了什么；一个断言会搞砸然后就像，bing，我知道要解决什么。</p><p class="normal">Impatience and hatred of primitive tools drives me to try to be a better programmer. Our code is riddled with assertions now and they are fatal. That's important to us. But this is something that has helped me, especially when I'm doing one of these allegedly sound, 90/10, sweet trade-off moves on the code that doesn't quite satisfy all the invariants. I forget something; an assertion will botch and then it's like, bing, I know what to fix.</p>
<p class="normal">此外，我什至现在还在了解自己的弱点，我会在这些方面优化太多。我会在脑海中创造出某种快乐的小马之地，在那里我忘记了一些重要的问题。这始终是一个挑战，因为程序员必须是乐观主义者。我们应该是偏执狂、神经质、伍迪·艾伦 (Woody Allen) 类型的人，他们总是担心事情，但实际上，如果您真的偏执狂，您就不会在编程中取得任何进展。</p><p class="normal">Also I'm even now learning about my own weaknesses, where I'll optimize something too much. I'll have made some kind of happy pony land in my head, where I forgot some important problem. That's always a challenge because programmers have to be optimists. We're supposed to be paranoid, neurotic, Woody Allen types who are always worried about things, but really you wouldn't get anywhere in programming if you were truly paranoid.</p>
<p class="normal"><b>Seibel：</b>你觉得编程是年轻人的游戏吗？</p><p class="normal"><b>Seibel:</b> Do you feel at all that programming is a young person's game?</p>
<p class="normal"><a id="OEBPS/Chapter04.html.page_165"></a><b>Eich：</b>我认为年轻人有巨大的优势，只是与大脑有关的生理优势。他们没有的是智慧！你变得更粗鲁，也许你变得更慢，但你确实吸取了一些痛苦的教训，并试图将这些教训传给下一代。我看到他们无视我并以艰难的方式学习他们，我挥舞着拳头！</p><p class="normal"><a></a><b>Eich:</b> I think young people have enormous advantages, just physiological advantages to do with the brain. What they don't have is the wisdom! You get crustier and maybe you get slower but you do learn some painful lessons that you try to pass on to the next generation. I see them ignoring me and learning them the hard way, and I shake my fist!</p>
<p class="normal">但是，除此之外，如果你保持阅读并坚持下去，你的输出不一定是大量的。虽然编写大量代码仍然很重要，但让我感兴趣的是——这是我们在 Netscape 谈论他们的首席工程师跟踪时所谈到的——是那些不是管理层但仍然具有足够领导力或影响力的人导致其他程序员像他们一样编写代码而无需他们这样做，因为您一天或手指没有足够的时间。</p><p class="normal">But, apart from that, if you stay well-read and keep at it, your output doesn't necessarily have to be voluminous. While producing a lot of code is still important, what has interested me—and this is something that we talked about at Netscape when we talked about their track for principal engineer—is somebody who isn't management but still has enough leadership or influence to cause other programmers to write code like they would write without them having to do it, because you don't have enough hours in the day or fingers.</p>
<p class="normal">有能力传播你的方法和你学到的任何编程知识，并通过某种社区产生一个比你能做的更大的代码库，这对我来说就像坚持下去一样令人满意整晚写太多代码。</p><p class="normal">Having that ability to spread your approach and whatever you've learned about programming, and have that go through some kind of community and produce a corpus of code that's bigger than you could do, that's as satisfying to me as being the one that stays up all night writing too much code.</p>
<p class="normal">我仍然工作太多，而且我还有小孩。我的妻子是一个很好的运动，但我认为她不太喜欢我旅行。但我也在做一些这样的事情。那不是编程，但不知何故它变得重要了。就 JavaScript 而言，我们必须弄清楚如何推动语言向前发展，这不仅需要传福音，还需要让人们思考如果语言确实发生变化会发生什么，你希望它如何发展，它应该去哪里。然后处理响应的杂音。</p><p class="normal">I'm still working too much, plus I've got small children. My wife is a good sport but I don't think she likes me traveling so much. But I'm doing some of that too. That's not programming, yet it somehow has become important. In the case of JavaScript we have to figure out how to move the language forward, and that requires some amount of not just evangelism, but getting people to think about what would happen if the language did move, how would you like it to move, where should it go. And then dealing with the cacophony of responses.</p>
<p class="normal">并不是所有的程序员都会这么说，他们中的很多人都是孤独的，在角落里，但我在 Netscape 意识到的一件事是我喜欢与实际使用我的代码的人互动。如果我回到角落里，我会错过的。我想对此有所了解。我有足够的安全感，认为我可以去做一些对我自己来说就像一座漂亮的天空城堡的事情，但我很现实，知道这只适合我自己，可能对其他人来说并不好。这有什么意义呢？“如果我只为我自己”，你知道，老希勒尔，“我是什么？”</p><p class="normal">Not all programmers will say this, a lot of them are solitary, in the corner, but one of the things I realized at Netscape was that I liked interacting with people who actually use my code. And I would miss that if I went back into a corner. I want to be grounded about this. I'm secure enough to think I could go do something that was a fine sky castle for myself, but I'm realist enough to know that it would be only for myself and probably not fine for other people. And what's the point? “If I'm only for myself”, you know, Hillel the elder, “what am I?”</p>
<p class="normal"><a id="OEBPS/Chapter04.html.page_166"></a>我不是 JavaScript。在早期，这是一个非常匆忙的工作，而且有很多错误，然后 Jamie Zawinski 转发了一些 Usenet 帖子给我。他说：“他们说你的孩子丑。” 我现在有了真正的孩子；我不必为此担心。</p><p class="normal"><a></a>I am not JavaScript. In the early days, it was such a rush job and it was buggy and then there was some Usenet post Jamie Zawinski forwarded me. He said, “They're calling your baby ugly.” I have real kids now; I don't have to worry about that.</p>
</div>
</div></div>
<div id="OEBPS/Chapter05.html"><div>

<div class="booksection">
<p></p>
<h2 class="chapnum"><a id="OEBPS/Chapter05.html.ch5"></a><a id="OEBPS/Chapter05.html.page_167"></a><img src="data:image/jpg;base64,/9j/4AAQSkZJRgABAgEASABIAAD/7QxkUGhvdG9zaG9wIDMuMAA4QklNA+0KUmVzb2x1dGlvbgAAAAAQAEgAAAABAAEASAAAAAEAAThCSU0EDRhGWCBHbG9iYWwgTGlnaHRpbmcgQW5nbGUAAAAABAAAAHg4QklNBBkSRlggR2xvYmFsIEFsdGl0dWRlAAAAAAQAAAAeOEJJTQPzC1ByaW50IEZsYWdzAAAACQAAAAAAAAAAAQA4QklNBAoOQ29weXJpZ2h0IEZsYWcAAAAAAQAAOEJJTScQFEphcGFuZXNlIFByaW50IEZsYWdzAAAAAAoAAQAAAAAAAAACOEJJTQP1F0NvbG9yIEhhbGZ0b25lIFNldHRpbmdzAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+BdDb2xvciBUcmFuc2ZlciBTZXR0aW5ncwAAAHAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAOEJJTQQAC0xheWVyIFN0YXRlAAAAAgABOEJJTQQCDExheWVyIEdyb3VwcwAAAAAEAAAAADhCSU0ECAZHdWlkZXMAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4NVVJMIG92ZXJyaWRlcwAAAAQAAAAAOEJJTQQaBlNsaWNlcwAAAAB1AAAABgAAAAAAAAAAAAAArwAAAPoAAAAKAFUAbgB0AGkAdABsAGUAZAAtADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAPoAAACvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhCSU0EERFJQ0MgVW50YWdnZWQgRmxhZwAAAAEBADhCSU0EFBdMYXllciBJRCBHZW5lcmF0b3IgQmFzZQAAAAQAAAACOEJJTQQMFU5ldyBXaW5kb3dzIFRodW1ibmFpbAAACIcAAAABAAAAcAAAAE4AAAFQAABmYAAACGsAGAAB/9j/4AAQSkZJRgABAgEASABIAAD/7gAOQWRvYmUAZIAAAAAB/9sAhAAMCAgICQgMCQkMEQsKCxEVDwwMDxUYExMVExMYEQwMDAwMDBEMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQ0LCw0ODRAODhAUDg4OFBQODg4OFBEMDAwMDBERDAwMDAwMEQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAz/wAARCABOAHADASIAAhEBAxEB/90ABAAH/8QBPwAAAQUBAQEBAQEAAAAAAAAAAwABAgQFBgcICQoLAQABBQEBAQEBAQAAAAAAAAABAAIDBAUGBwgJCgsQAAEEAQMCBAIFBwYIBQMMMwEAAhEDBCESMQVBUWETInGBMgYUkaGxQiMkFVLBYjM0coLRQwclklPw4fFjczUWorKDJkSTVGRFwqN0NhfSVeJl8rOEw9N14/NGJ5SkhbSVxNTk9KW1xdXl9VZmdoaWprbG1ub2N0dXZ3eHl6e3x9fn9xEAAgIBAgQEAwQFBgcHBgU1AQACEQMhMRIEQVFhcSITBTKBkRShsUIjwVLR8DMkYuFygpJDUxVjczTxJQYWorKDByY1wtJEk1SjF2RFVTZ0ZeLys4TD03Xj80aUpIW0lcTU5PSltcXV5fVWZnaGlqa2xtbm9ic3R1dnd4eXp7fH/9oADAMBAAIRAxEAPwDo/rGLusfXHC+rV+Zbg9N+xuzXNoean5Vgs9L7J6gP0Kq2faNjP+E/4O2rc6H0DC6Jbk14eTkWV3hjhi33OubVt9Qb6G27rK/W3fpPd7/RVDrOb/i+65Synquf07JZWd1ZOVW17D39O6q6u2vdt92x6j0bK/xe9DZazpfUOn4/rkOud9rY97y2dm+2++y12zc7Z70lOVjdU6zjfXr6yMwcC3qrQMMek2+uptQ9Frp25T2N/TT/AIL9xaH1BycrJd16zLY+m39qWzRY8WGr2VONO9jn1+x3+j9itY3VfqLi9Ry+p0dTwGZmeGDKt+2MO/0h6dXsdc6tmxn+jYpYPV/qP09+S/D6pgVOzbnZOSftdbt1r432fpLn7Po/Qr9iSnkfr31o3/WPIxR1P9mfsDE+04zQ/ab81/p5NNOz6FtfotrZ7/8A0au9+r/WaOudGxeq0Da3JZucyZ2PB2XVTDd3p2texZ/T+rfUbprsl2H1TArdmXOyclxy63l9r43v3W3Pc36P8239GxR6V1L6hdHqup6b1Lp+PVkWuvsY3LrLfUfAe5rbLn+n9Bv6Ov8ARpKeA+ruB9Y+qVPu6S3J+10dUeD1V2YW01VM2Ofi24NlrnZHtfv9lHv9X0/f7616p1XovT+rsrZnNsc2lxcz07radSNursWylzv7SyekdR+oXRaLcfpnU8Ciq+119jftjHzY8Na9+66+x30a2K//AM7Pqt/5c4H/ALE0/wDpRJTzv+LnpOJbgN6ta6+zNpycmpj35Fzm7A59DWuofaaH7a/3q0319GRb9YPq/jU41ue25ubuwqcg4pt2soc2chtlO30f536a1+mdW+o3ScY4vT+qYFNBe6ws+2Mf7nnfY7dbc93ucq/Wrv8AF3119D+qdRwb3Yu8UubnCot9Tb6n9HyKt2702fSSU6n1axXYvSa634VnTnuc9z8W3IOW5pLjr9qc+3f6jR6n0/YvM+k2ZjbejXNZl4t2T1Z1P7WflPfj2Mba+cF+I19u19zB6FbLK6PX/wBL6XqLv+k9U+ovRsT7H07qmDTj7i/Yc1lnud9I7777X/8ASVZzv8W7uku6M7PwD091nrGr7a2RYX+v6jLvtHrsd6v7lqSnq0lkj61/VUAAdZwYGmuVUfy2J/8AnZ9Vv/LnA/8AYmn/ANKJKf/Q8+geASgeATpJJWgeASgeATpJKWgeASgeATqL3bGOdzAlJS8DwCUDwC9QH+JrDgT1W+Y1iquJT/8AjN4X/lrf/wBtVpKfLoHgEoHgF0f11+q+F9WcrFw6MyzLvvY621tjWtDGT6dTh6f+ke23/ttc6kpaB4BKB4BOkkpaB4BKB4BOkkp//9Hz9JJJJKkkkklKU6KvWyKaTqLLa2EeTnsb/FQVrpRYOrYBscGVjKoL3uIDQ0W17nPc72tY1qSnq/8AG9eL/rLjYxO5mNiNO3kB9tlu7/wOqpcP6NJ4Y1eifWvrv1PxvrFl5bsIfWLPfsrcLXBuJjitvp+jX7LW5N3qN9S79FZs3+l6tX6RG+rfWvqN9YsodK6h9XsPp2TfLcd1dbCywxJr9eqrHtou2/zf7/8ApfV/RpIfN2ta0Q0ADyTrqvr59Sz9W8pmTiONnSst5bSHGX02QbPs73H+dqcxr349v85/grv9NdyqSVJJJJKUkkkkp//S8/SSSSSpJJJJSkxIAJcQB3J4TrovqBndHwfrNTd1gN9FzDXj22NDmVZDn1Gi58/zXtbZX6/+B3/4P+cSU842IG2NvaOESm+3HvpyKSRdRZXbURzvY9r2bf5W5q7v/GN9Ss6vqj+sdJxH5GJljflV47dzq7ho+30Kx6jq8lv6V72Ns/Tes+7+cWV9TPqZ1Xq3V8a/KxbMfpmNYy++29jmCwMPqV49DLQx13qvZtte39HVV/wnppKe7/xr10v+qT3WfTqyaHU/1y70nf8AgNlq8bXoH+NP604PUDT0PAs9YYtxuzLW/QFjGuqrxmu/wr2eo+y7b7Kv0f8Ahf5rz9JCkkkkkqSSSSU//9Pz9JJJJKkkkklKS5EHUHlJJJTp9P8ArN9YumVCjA6lfRQ0Q2ncHsaPCuu9trav+tqWd9a/rN1Co05nVMiypwIdW1wqa4HQts+zNp3t/kvWUkkpQAAgaAcBJJJJSkkkklKSSSSU/wD/2QA4QklNBCEaVmVyc2lvbiBjb21wYXRpYmlsaXR5IGluZm8AAAAAVQAAAAEBAAAADwBBAGQAbwBiAGUAIABQAGgAbwB0AG8AcwBoAG8AcAAAABMAQQBkAG8AYgBlACAAUABoAG8AdABvAHMAaABvAHAAIAA2AC4AMAAAAAEAOEJJTQQGDEpQRUcgUXVhbGl0eQAAAAAHAAYAAAABAQD/7gAOQWRvYmUAZEAAAAAB/9sAhAACAgICAgICAgICAwICAgMEAwICAwQFBAQEBAQFBgUFBQUFBQYGBwcIBwcGCQkKCgkJDAwMDAwMDAwMDAwMDAwMAQMDAwUEBQkGBgkNCgkKDQ8ODg4ODw8MDAwMDA8PDAwMDAwMDwwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAz/wAARCACvAPoDAREAAhEBAxEB/90ABAAg/8QBogAAAAcBAQEBAQAAAAAAAAAABAUDAgYBAAcICQoLAQACAgMBAQEBAQAAAAAAAAABAAIDBAUGBwgJCgsQAAIBAwMCBAIGBwMEAgYCcwECAxEEAAUhEjFBUQYTYSJxgRQykaEHFbFCI8FS0eEzFmLwJHKC8SVDNFOSorJjc8I1RCeTo7M2F1RkdMPS4ggmgwkKGBmElEVGpLRW01UoGvLj88TU5PRldYWVpbXF1eX1ZnaGlqa2xtbm9jdHV2d3h5ent8fX5/c4SFhoeIiYqLjI2Oj4KTlJWWl5iZmpucnZ6fkqOkpaanqKmqq6ytrq+hEAAgIBAgMFBQQFBgQIAwNtAQACEQMEIRIxQQVRE2EiBnGBkTKhsfAUwdHhI0IVUmJy8TMkNEOCFpJTJaJjssIHc9I14kSDF1STCAkKGBkmNkUaJ2R0VTfyo7PDKCnT4/OElKS0xNTk9GV1hZWltcXV5fVGVmZ2hpamtsbW5vZHV2d3h5ent8fX5/c4SFhoeIiYqLjI2Oj4OUlZaXmJmam5ydnp+So6SlpqeoqaqrrK2ur6/9oADAMBAAIRAxEAPwD7mfmB568ufll5K8zef/Nt59Q8ueU7CXUdVuAOT+nENkjUbs7tREUdWIHfFX4C3n57/wDOZX/Oef5ja15V/JjUr7yL5J0+kz6Rpd+dKtNPsmdxDLqupQ8Z5pJaU4KSpI+CLZjizoB6fcf84A/852eUrW213yh/zkRFqOvxs95fadZ+Z9ctHNyApX0ZZ4VjmL0oTL6Y6VqCaKLD9Xv+cX7j83bn8jPIzfnxHcxfmvD+krbzWt2lvHMTb6ndw2rOLUCFuVqkTB02cHlU1rigvXPN0skPlTzPNDI0M0Ok3rxSoSrKywOQykbgg9Dih+K//PqX8yPzE87/AJl/mlaedPPvmPzfaWPlm2msrbW9Uu9Qjhka8RS8aXMsgViNiRvTFlJ+x/5oXNxZ/lp+Yl3aTyWt3a+WdXmtrmFikkciWcrI6OpBVlIqCNwcWL8cP+fUv5kfmJ53/Mv80rTzp598x+b7Sx8s201lba3ql3qEcMjXiKXjS5lkCsRsSN6YspP3JxYvLfzt/M/S/wAmPyo89/mdq5ja38o6VNd2ttI4QXN41IrO2BJG807pGP8AWxV/LpY/nn/zlNptvpf5zn8zfOl7oUPmz6ul5caxfNpcur2oi1FrOa1SdIuDo4PpBQpSqgADFsoP6n/ys/MLRvzY/LnyZ+Y/l9q6V5x0q31GCKvIwvIv76ByP2oZA0bf5SnFrZ9ir8Tv+fsP5ifmB5H81/k1D5K89eYfJ8Oo6Tq76hFomp3enrO0c9sEaUW0sYcqGNCelcWUXkev/wDON/8Azlxon/OPOkf85GaL/wA5V+ZdU06XyfY+eNQ8uPr2t2d3bWdzZRXzLDMLqVJZIlkPXhXjtuQMU2Lfc/8Az7f/AOco/Of/ADkF5I84+WvzHuTq/nH8tZrGvmcxpG2oWGpCf0PWEdFM0TWzqzBV5KUO7cziiQp96/mJ5e1Xzd+X/nnypoWuS+Wdb8z+XtT0nRvMkJdZdPur20kggu0MTI4aF3DgqwNRsQcWL8Zvzb/5w2/5yg/Kj8s/O/5k3X/OZXmnWbbyVpFxq0+lRX+twvcLbryMayNqLBSfEg4srD53/wCcRvy6/wCckP8AnLL/AJWD+if+cpfOPkz/AAB+ifrH1vV9YvPrP6V+ucePp3sfHh9TNa1ry9sUmg/aL/nFT8iPzM/IrRvN+m/mV+cN/wDnBda/e21zpeo6hLeyvZxwxujxL9cuLggMWDfCQPbFiS+sMUP5nvJCfn5+f/8AzlV5+/KHy/8A85CecPJMba95nmsbttZ1WW2t4NPupmWFLeK7jAHEBVAIAGLPkH23/wBE9f8AnKj/ANjd8y/9JWuf95LFFjufsNixfll/z9Y86ecfJH5Uflpf+TPNms+Ub6782PBd3mi39xYSyxfUZ29N3tnjZl5AGhNK4sovknyf/wA4x/8AOWnnn/nH7TPz28s/85V+ZppdS0KfXrfydc63rMEpjtjKXiW7+uMnMiI8aoFrsSOuKbD6Z/59l/8AOVP5j/nIPOf5Yfmdqs/mzUvKGnwat5f82XfxXj2hlFvLbXcgUeqysyMkjkuatyLUFFEhT9asWLsVdirsVdir/9D6G/8APyiw1S//AOcQfzHGmRSzraXei3WpxQgk/VYtTti7Mq1JVG4s3gByOwxTHm+dv+fQWv8AlqT8pPzN8rQ3NuvnG083nVdRtKqLhtMuLC0gtXpXkyLNDOK0oCf8rFMn68YsVquj8uDq/Bir8SDRh1Bp3xVjvnP/AJQ/zX/2x77/AKh3xV/Ln/zhl5A/5yM/MDzb5wsv+ccfP1v5A1+w0iKfzDfXF9NYrPZtOqpGGht7gsRJQ0IHzxbDT7s84f8AOO3/AD8wsfKXmi98w/8AOQ+nX2gWekX0+uWK69eO01nHA7TxhTpqglowRQkfPFjYYN/z59/8mn+bn/gKWv8A1HJimT9/cWD8W/8An7l+c5stF8h/kTpF4BNrUh80ecYo3+IW1uzQ6fDIoBqskvqyUqKGJDQ1xZRDxZ/zF/5w3l/5wHt/yBP5pQJ+Z0VgPNS8tD1uq+bCxumgNyumGKnEmx9SvH09+X7WKd7e0/8APpL88RfaN5y/IHWrsfWdEdvM3khXYVa1nZY9Qt0HEf3cpSUfESfUfYBcUSD9pMWL8Hf+fxX/ACmH5Hf9sfWv+oi1xZxSTy7/AM4zf8/Bvzh/JLyH5dj/ADY0eP8AJ7zL5X0abQPLtzqr2sa6M9nDLYW9ytpYGVlSHgCjM4qN60rith+ov/OH3/OKmjf84reQdR0JNUj8x+cPNVzFe+cfMkcPopK0CFLe2hUkt6MHNyvI1LO7UHKgWJNvrjFD5r/5zF/9Za/Pn/wDdS/5NHFI5vzW/wCfNf8A68d/4KH/AHe8WUn7e4sHYq/lW8i/l7+bH5n/APOXn5j+U/yW88f8q8893HmLzXcWnmX9J3+k+nbwXk7Tx/WtOjlnHNdqBaHvi2dH6I+S/wDnDf8A5+F6N5x8p6x5i/5yq/S3l/SdZsLzXdL/AMc+bJ/rNnBcJJcQ+lNZLG/ONSvFyFNaHbFjYfsxixfkZ/z9/wD/ACTv5Wf+Bk//AHT7jFlHm+CNW8tf85u+X/8AnEPy75vsvP1zd/8AOO2p6Ysb+XdCuwl1YaZNO8ZF6iW8M3oPISrhZXWjfH8FcU7W/QP/AJ9PaJ+Tkf5Z+btf8n3V5d/mpcXNvZ/mVDqDpztYVDvZJaRJsLaQ+owc/EzhgxoiqqiT9Z8WLsVdirsVdir/AP/R+82vaFo/mfRNW8ueYdNg1jQtdtJrDWNKukEkNxbXCGOWKRT1VlJBxV+FX5jf8+4v+chvyX89z+f/APnFDzdPqdlbSerotnBqi6Tr9rG7qXtZJJmhtrqIU35SD1FHFo2P2lnxd6Lh8kf8/c/PkcnlnWPMOq+WNKvYzDeaxcaloGm+mhFP96NLJvATTrGCfHFGz9Xf+cXPyh8w/kZ+Svlf8uvNfmKHzV5l06fUb/XNcg9UpNdanezXstHn/eScWmILsAXPxECtMUF7R5ms7jUPLfmCws4/Wu77Tbu3tYqheUksLoi1YgCpI3Jpih+Tn/Pt7/nFz89vyD8//mLrf5s+Rv8ACmma75fgsdKuf0npl/6s6XSyMnCwu7hloorVgB74spG36nfmFpd/rnkDzxomlwfWtT1jy/qdjp1tyVPUnuLWSOJOblVXkzAVYgDucWL8sf8An29/zi5+e35B+f8A8xdb/NnyN/hTTNd8vwWOlXP6T0y/9WdLpZGThYXdwy0UVqwA98WUjb9fsWL8Odd/5w3/AOchPz+/5zOuPzM/Or8um0P8nbzzF69yZ9b0u7B0LSk42NiLe0vJ5l+tLCiyBUFDJI1VO+LK6D9F/wDoRn/nEv8A8sd5f++5/wCq+KLL84NS/wCcMf8AnIL8iP8AnL+0/Nf/AJx2/Lf/ABB+V2ma1Dqmn2drrGl2ZTTr5OGp6WIb/ULWQ8VeVI+Xw04GpocU3YfuapJUEqVJFSppUexpUYsX5L/8/J/+cZfzv/P7zJ+VV/8AlJ5J/wAWWnlvTdTt9al/SWm2HoyXE0DxLS/urctyCNuoIHfFlE0/RX8i/LeteTvyS/J3yh5ksv0d5i8q+R/L2j69p/qRzehe2Om29vcRepCzxvwkRl5IxU9QSN8WJeqYq7FXiH/OSnlDzF5//IP82/JXlHTv0t5m8z+Wr7T9D0z1oYPXuZo+KJ6tw8cSVPd2A98VD4g/59of844fnP8A84/f8rq/5W75N/wl/i3/AA3/AIe/3I6df/WPqH6U+s/7wXNzw4fWY/t8a8vhrQ0WUjb9TsWLsVfzvp/zih/zn3+XP57eefzZ/JzyF+htT1HXtdm0PX/0r5VuOdjqV1K1fq+oXkqj1I2H24+Q9jizsU9j/wDjzf8An/yrvFdn7Z2P1n6lafXP97PQj+t9P73iOf2dutem2LB+ef8Az8f/ACI/Nb8+/wAtvIOgflP5V/xXq+ieZX1DU7T69Y2PpWxs5og/O/uLdG+NwKKSfamKYmnu/wDzjx+UmoaL/wA4reR/yb/Nby+ltejyxc6F5y8uSy290oS6edZYjLA80L1jk6qxGKl+dX/OH3/OL3/OU/8AzjB/zklqF4/kN9X/ACc1ya88v675jh1nRws+miVmsNU+pm9E/KNkRynpcwjSKFqaYpJsP20xYuxV2KuxV2Kv/9L7+Yq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FX//T+eH/AEM1/wA5I/8AsQf5lf8AhWax/wBlWLZQd/0M1/zkj/7EH+ZX/hWax/2VYrQd/wBDNf8AOSP/ALEH+ZX/AIVmsf8AZVitB3/QzX/OSP8A7EH+ZX/hWax/2VYrQd/0M1/zkj/7EH+ZX/hWax/2VYrQd/0M1/zkj/7EH+ZX/hWax/2VYrQd/wBDNf8AOSP/ALEH+ZX/AIVmsf8AZVitB3/QzX/OSP8A7EH+ZX/hWax/2VYrQd/0M1/zkj/7EH+ZX/hWax/2VYrQd/0M1/zkj/7EH+ZX/hWax/2VYrQd/wBDNf8AOSP/ALEH+ZX/AIVmsf8AZVitB3/QzX/OSP8A7EH+ZX/hWax/2VYrQd/0M1/zkj/7EH+ZX/hWax/2VYrQd/0M1/zkj/7EH+ZX/hWax/2VYrQd/wBDNf8AOSP/ALEH+ZX/AIVmsf8AZVitB3/QzX/OSP8A7EH+ZX/hWax/2VYrQd/0M1/zkj/7EH+ZX/hWax/2VYrQd/0M1/zkj/7EH+ZX/hWax/2VYrQd/wBDNf8AOSP/ALEH+ZX/AIVmsf8AZVitB3/QzX/OSP8A7EH+ZX/hWax/2VYrQd/0M1/zkj/7EH+ZX/hWax/2VYrQd/0M1/zkj/7EH+ZX/hWax/2VYrQd/wBDNf8AOSP/ALEH+ZX/AIVmsf8AZVitB3/QzX/OSP8A7EH+ZX/hWax/2VYrQd/0M1/zkj/7EH+ZX/hWax/2VYrQd/0M1/zkj/7EH+ZX/hWax/2VYrQd/wBDNf8AOSP/ALEH+ZX/AIVmsf8AZVitB3/QzX/OSP8A7EH+ZX/hWax/2VYrQd/0M1/zkj/7EH+ZX/hWax/2VYrQd/0M1/zkj/7EH+ZX/hWax/2VYrQd/wBDNf8AOSP/ALEH+ZX/AIVmsf8AZVitB3/QzX/OSP8A7EH+ZX/hWax/2VYrQf/U+QGLa7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FX/1fkBi2uxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV/9b5AYtrsVdirsVdirsVdirsVdirsVdirsVdir6u/wCcdf8AnDf83/8AnJzS/Met/l7JoVhpHlm6isb2+1y9ktlluZUMhjhSCC4clE4liyqPiFCTWigmn0d/0SY/5yb/AOr75B/7it//AN43FHEHf9EmP+cm/wDq++Qf+4rf/wDeNxXiDv8Aokx/zk3/ANX3yD/3Fb//ALxuK8Qd/wBEmP8AnJv/AKvvkH/uK3//AHjcV4gk3mT/AJ9a/wDOSHlfy7r3mbUNb8iSWHl3TrrU75I9WuldobSFppArTWMUYJVDQu6r4sBvivE/NzFk7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq//1/kBi2uxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv6IP+fQ1rw/5x/8AzBvaJ/pH5g3UHIfb/c6Vpjb7dP3u2/jiwk/Rrzf+bX5V/l9dWth5+/Mzyp5Ivr2My2Vnr+s2OmSzRqQC8aXU0bMASKkDFixH/oZr/nG7/wBiD/LX/wAKzR/+yrFNF3/QzX/ON3/sQf5a/wDhWaP/ANlWK0Xf9DNf843f+xB/lr/4Vmj/APZVitF8Vf8AOfv/ADld+V0X/ON/mryt+WX5p+V/OPmj8wpoPLz2vlzWLHU57fT5yZb6WZLWaQpG8EbQksKVkAxSBu/nIxZuxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv8A/9D5AYtrsVdirsVdirsVdirsVdirsVdirsVdir+lz/n1fpiWH/OKlpdLBHE2tea9ZvZJEADSlDDa85KdWAgC79gMWEub8Wf+c7PMv+Kf+ctPzsv1uvrcVhra6PEQ/NY/0VbQ2LxrRmA4yQsCK7GtQDUYshyfJOKXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FX/9H5AYtrsVdirsVdirsVdirsVdirsVdirsVdir+ov/n2pafVv+cOvyym9MJ+kLvX7jkOr8dZvIeR/wCRdPoxa5c382/5ua/F5r/Nf8zvNMEy3MHmTzZrWqw3CMHWRLy+mnVwwZwQQ9ahjXxOLYHnmKuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv/0vkBi2uxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv6m/+cSpbb8v/wDnBHyBrHp/o+30XyTq3mGZjIfh9WS81KSXmX25Fy/2hStNgNlrPN+Bf5Ff84afn5/zkJFFqfkjyoun+VJXaP8Axvr0psNLLJs3pvwkmnodiYInodjTFmTT9KPJ/wDz540mOD1fP/51Xd1cyItLHy/pUdukT0PL/SLqaYyAmlP3SdPfZY8TKNS/589/lpLZzJo/5w+ZrHUGVhb3V5Y2d3CrUPEvDH9XZgDQkCQVG1R1xXifHn5v/wDPrL8/Py+s7rWPIl9pn5u6RaRmSW00xWsdYovIuVsJ2ZJAABRYp3kYmgTxUiT819Q0+/0m+u9M1WxuNM1KwlaC+0+7ieGeGVDRo5I3AZWU7EEVGLJB4q7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq/wD/0/kBi2uxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv60v+cfrDypbf84bflNZ+eBZW/ku7/LHSm81Lqsix2TWF7pqPci5aRgvpSJIeQY0Kmh2xazzfmn/AM5B/wDP1G9sLqfyV/zjFoVhpfl7SkFnb+ftTtAxdYwUX9G6awWKGNKDg0ytUbekmLIRfAV5/wA5vf8AOWN9dPeT/nn5kSVzUpbyQ20XWu0UMSRj5BcU0H1h/wA4+f8AP0v81/J+s2Gj/nkU/MjyZczLHd69Fbw2utWEbED1ENusUVyqdSjoHPaTtigxf0BeVPNfl3zz5b0bzf5S1e313y35htUvNH1a1blFNDINiOhBBqCpAKkEEAgjFg+Bf+c9f+cMtE/PXyZqv5heRtGhtPzm8r2rXVvLbJwbXrW3Us9jOAQGl41MLkV5ARk8WqqkGn8z2LY7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq//U+QGLa7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq9e1X8+/zj1z8sdP8Ayb1j8w9X1L8tNLngnsPK1xKrxx/VVK28PqlfWMEVQUhLmJSFKoCqkK08hxV2KuxV+4n/AD6K/OS9uR+YP5E6revPb6fbjzZ5Pt35EQxmZLbUo1YigUyTQOFr1LsB9rFhIP23xYv5Tv8AnPn8rLb8p/8AnKH8wtL0y1js9B81SQ+atCt4yeKx6qpkuFCnZQt2s6qo2CgUp0C2R5PjXFLsVdirsVdirsVdirsVdirsVdirsVf/1fkBi2uxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv0C/59ja82kf8AOXfkzTwZAPNOj67pbhApUiPT5dQ+Ou4FbPtvWnauKJcn9POLW/nt/wCfvelWsH52/lrrUZcXepeSVtLlPh4cLPUbt42AAryP1hgSSdgtKU3WcX5LYsnYq7FXYq7FXYq7FXYq7FXYq7FXYq//1vkBi2uxV2KuxV2KuxV2KuxV2KuxV2KuxVlnkjyL5w/MnzLpvk7yJ5evfNHmbV34WGkWMfORqfadiaKiKN2dyFUbsQMVfSP5z/8AODn/ADkF+RHkeP8AMPz35f08+WUlgg1a50u+jvH06S5YJELtUAChpGEfJCy8iBy+JaqAbfIWKXYq7FX6I/8APrvy+us/85Z6BqLQ+qfKfl7W9VR6sPTMlv8Ao7lRSAdr0rRtt/GmLGXJ/TViwfzcf8/XvNMGuf8AOTdhodte+uvkvydpmnX1mrllgu7ma61BqpUhXeG5hJ2qV4+2LOPJ+ZeLJ2KuxV2KuxV2KuxV2KuxV2KuxV2Kv//X+QGLa7FXYq7FXYq7FXYq7FXYq7FXYq7FX7Rf8+dLPQpPMf5731zDA3mW107y/Do87Cs6WU0t+b1Yz2VpI7fl7hcWMn7RfmT5E0f8z/IHnD8vNfUnSPOOk3WlXjr9qMXEZVZU3HxRtR19wMWD+PT8y/y98yflR5981fl15utPqfmHylfyWOoRivB+NGimjJpWOaNlkQ91YHFtYNirsVfvh/z6U/JLU/L3lXzv+eGvWRtT549LQ/JYlTjI+nWchkvLlWqSY57gIiig3hJ3BU4sJF+s3nLzf5e8geVPMHnXzXqMeleXPLFjNqOsX8nSOGBSzUHVmalFUbsxCjc4sX8ev5y/mVqX5w/mn57/ADN1VDDdectXnv47RiGNvbk8LW35ClfRhVI69+OLaHmeKuxV2KuxV2KuxV2KuxV2KuxV2KuxV//Q+QGLa7FXYq7FXYq7FXYq7FXYq7FXYq7FXsn5C/nf5w/5x6/MrRfzK8mNHLe6eHttV0m4JFvqFhMV9e0m47hX4ggjdWVW3pTFBFv6ff8AnHr/AJyz/J3/AJyP0e3n8meYIrDzWkIfWfIGousOqWjhQX4RtT6xEtf72LkvjxaqhYEUwP8A5y3/AOcJ/If/ADlHYWurNef4N/MzRoBb6N50ghEyzW6sWFpfwck9WIFiUYMHQmoJXkjKg0/GPzR/z7C/5y10HUhZaP5U0bzrZs7KNX0jW7GCFVBFGdNTkspRUHoEPQ+1VnxB9IfkR/z6Z813GuWWs/8AOQHmPT9N8t2cqSy+TfL1w9xe3oUhjDcXnBI4I26MYi7kV4tGaNigyfsp5o85/lT+QfkW0uvM+taN+XPkby3aR2Ok20hS3hjht4wsVtZ26DnIyoAFjiVmPYYsH88//Obv/Odeq/8AOSFz/gLyNBd+XPye0m7Wf0p29O8124h/u7i8RTRIUO8UNW3pI/x8VjWYFPzqxZOxV2KuxV2KuxV2KuxV2KuxV2KuxV2Kv//R+QGLa7FXYq7FXYq7FXYq7FXYq7FXYq7FXYqiLW6urG6tr2yuZbO9s5UntLuB2jliljYMjo6kMrKwBBBqDir658j/APOev/OWHkG3tLHTPzd1DWdNs1KJY+YILXWOS0ICtcXkUtxRe1JRSlOm2KKD2lf+frP/ADlKqSKY/Jrs9OMh0iWqUNfhpdgb9NwcUcIYN5r/AOfk/wDzlx5njMFv5/s/Kds4YSw6FpNlCzAhQP31xFcTLShIKOvU+1FPCHxt5u87+cvP2rSa95481at5v1qUENqmsXk17OFJLcFeZmKqCdlGw7DFLF8VdirsVdirsVdirsVdirsVdirsVdirsVdir//S+QGLa7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FXYq7FX/0/kBi2uxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV2KuxV/9T5AYtrsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVdirsVf/Z" alt="图片"></h2><h2 class="chapnum"><a></a><a></a></h2>
<h2 class="chaptitle">约书亚·布洛赫</h2><h2 class="chaptitle">Joshua Bloch</h2>
<div class="sidebar">
<p class="normal"><i>现在是 Google 的首席 Java 架构师，Bloch 之前是 Sun Microsystems 的杰出工程师，在那里他领导了 Java 2 中引入的 Java Collections Framework 的设计和实现，并参与了 Java 5 版本中的几种语言添加的设计。他拥有哥伦比亚大学的学士学位和卡内基梅隆大学的博士学位，在那里他从事 Camelot 分布式事务处理系统的工作，该系统后来成为 Transarc 的产品 Encina，他在那里担任高级系统设计师。他撰写了 2001 年 Jolt 奖获奖书籍 Effective Java，并合着了 Java Puzzlers 和 Java Concurrency in Practice。</i></p><p class="normal"><i>Now Chief Java Architect at Google, Bloch previously was a Distinguished Engineer at Sun Microsystems, where he led the design and implementation of the Java Collections Framework introduced in Java 2 and was involved in the design of several language additions in the Java 5 release. He has a BS from Columbia University and a PhD from Carnegie-Mellon University, where he worked on the Camelot distributed transaction processing system, which later became Encina, a product of Transarc, where he was a Senior Systems Designer. He wrote the 2001 Jolt Award–winning book Effective Java and coauthored Java Puzzlers and Java Concurrency in Practice.</i></p>
<p class="normal"><i>正如您对在 Google 的工作是鼓励使用 Java 的人所期望的那样，Bloch 是该语言的坚定拥护者。尽管最近人们对软件事务内存或 Erlang 的消息传递等并发方法产生了浓厚的兴趣，但 Bloch 认为 Java 拥有“所有语言中最好的并发方法”，并预测随着越来越多的程序员对 Java 的兴趣会重新兴起。被迫处理多核 CPU 机器的编程。</i></p><p class="normal"><i>As you might expect from someone whose job is to encourage the use of Java at Google, Bloch is a strong advocate of the language. Despite the recent flurry of interest in approaches to concurrency such as Software Transactional Memory or Erlang's message passing, Bloch thinks Java has “the best approach of any language out there” to concurrency and predicts a resurgence of interest in Java as more and more programmers are forced to deal with programming for machines with multicore CPUs.</i></p>
<p class="normal"><a id="OEBPS/Chapter05.html.page_168"></a><i>Bloch 还大力提倡将编程视为 API 设计，我们讨论了这对他自己的设计过程有何影响，以及 Java 是否变得过于复杂以及为什么选择一种编程语言就像选择一个酒吧。</i></p><p class="normal"><a></a><i>Bloch is also a strong advocate of treating programming as API design, and we talked about how that affects his own design process, as well as whether Java has gotten too complex and why picking a programming language is like picking a bar.</i></p>
</div>
<p class="normal"><b>Seibel：</b>你是怎么开始编程的？</p><p class="normal"><b>Seibel:</b> How did you get into programming?</p>
<p class="normal"><b>布洛赫：</b>我很想说它存在于血液之中。我父亲是布鲁克海文国家实验室的化学家。我上四年级时，他参加了编程课程。那时候，当然，机器是玻璃窗后面的大型机，您将一副纸牌交给操作员。这不是亲身实践，但我只是对这些可以为你做事的电子计算机器的想法感到兴奋。所以我在他上那门课的时候从他那里学了一点 Fortran。</p><p class="normal"><b>Bloch:</b> I'm tempted to say it's in the blood. My dad was a chemist at Brookhaven National Lab. When I was in fourth grade, he took a programming course. Back then, of course, machines were mainframes behind glass windows and you handed your deck of cards to the operator. It wasn't hands-on, but I was just thrilled by the idea of these electronic computing machines that would do stuff for you. So I learned a little bit of Fortran from him while he was taking that course.</p>
<p class="normal"><b>Seibel：</b>那应该是哪一年？</p><p class="normal"><b>Seibel:</b> This would have been what year?</p>
<p class="normal"><b>Bloch：</b>我想那是在 1971 年。直到几年后，这个错误才真正咬到我。当然，它的作用是分时。长岛有一个 DECsystem-10，由萨福克县的所有学校共享。拿骚县还有另一个。令人惊讶的是，有多少知名人士是从这两个 DECsystem-10 中的一个开始的。</p><p class="normal"><b>Bloch:</b> I think it was 1971. The bug didn't really bite me until a couple years later. And what did it, of course, was timesharing. Long Island had a DECsystem-10, which was shared among all of the schools in Suffolk County. There was another one for Nassau County. It's amazing how many well-known people got their start on one of those two DECsystem-10s.</p>
<p class="normal">一旦你有了交互性，bug 就会咬你。大约从 1973 年到 1976 年，我和当时的其他人一样用 BASIC 编程。那是我开始认真研究它的时候。令人惊奇的是，我仍然保留着当时在电传纸上的程序——那是幸存下来的媒介——我看着它们，我可以看出我的风格的点点滴滴从那时起就没有改变。</p><p class="normal">Once you have interactivity, the bug bites you. I was programming in BASIC, like everybody else back then, from about 1973 through 1976. That's when I got seriously into it. The amazing thing is, I still have programs from back then on Teletype paper—that's the medium that survived—and I look at them and I can sort of see that bits and pieces of my style haven't changed since then.</p>
<p class="normal"><b>Seibel：</b>那么您记得编写的第一个有趣的程序是什么？</p><p class="normal"><b>Seibel:</b> So what was the first interesting program that you remember writing?</p>
<p class="normal"><b>布洛赫：</b>嗯，我记得在 1977 年 7 月 4 日写了一个名为“动物”的经典二十问游戏版本。该程序有一个二叉树，内部节点有是或否问题，叶子有动物。当它第一次遇到一种新动物时，它会通过询问用户一个是或否的问题来“学习”该动物，以区分新动物和其他动物<a id="OEBPS/Chapter05.html.page_169"></a>它猜错了。二叉树存储在磁盘上，因此程序会随着时间的推移变得越来越“聪明”。</p><p class="normal"><b>Bloch:</b> Well, I remember on July 4th, 1977 writing a version of the classic Twenty Questions game called “animals.” The program had a binary tree with yes-or-no questions at the interior nodes and animals at the leaves. When it first encountered a new animal, it “learned” the animal by asking the user for a yes-or-no question to distinguish the new animal from the <a></a>one it had incorrectly guessed. The binary tree was stored on disk so the program kept getting “smarter” over time.</p>
<p class="normal">我记得当时在想，“我的天哪，这太酷了：程序真的在学习。” 那是一种<i>啊哈！</i>我的时刻。我记得的另一件事是在高中——我想是 10 年级——在那个 DECsystem-10 上。我们不允许编写现在称为即时消息程序的程序——它们被认为对系统资源的消耗太大。</p><p class="normal">I remember thinking, “My gosh, this is cool: the program actually learns.” That was one sort of <i>aha!</i> moment for me. Another thing I remember was in high school—10th grade, I think—on that DECsystem-10. We weren't allowed to write what would now be called instant-messaging programs—they were thought to be too big a drain on system resources.</p>
<p class="normal"><b>Seibel：</b>事实上，现在就是这样。</p><p class="normal"><b>Seibel:</b> As they are, in fact, now.</p>
<p class="normal"><b>布洛赫：</b>不要让我开始。IM 毁了我的生活。不，电子邮件毁了我的生活——即时通讯只是一种消遣。不管怎样，作为一个顽皮的孩子，我参加了长岛数学博览会的一个项目，我称之为“工作间交流项目”。我实际上因此获得了奖品。</p><p class="normal"><b>Bloch:</b> Don't get me started. IM ruins my life. No, email ruins my life—IM is just a distraction. Anyway, being the bratty kid that I was, I entered a project into the Long Island Math Fair on what I called “inter-job communication programs.” I actually won a prize for it.</p>
<p class="normal"><b>Seibel：</b>你真的写了程序？</p><p class="normal"><b>Seibel:</b> And you actually wrote the programs?</p>
<p class="normal"><b>布洛赫：</b>是的。我编写了程序，除了一个由一位名叫 Thomas De Bellis 的朋友贡献的程序。Tom 程序的独特之处在于它完全是用 BASIC 编写的。它是面向线路的，使用文件进行通信。它既不快速也不高效，但它起作用了！我写了两个，一个面向行，一个面向字符。我用 MACRO-10（PDP-10 汇编语言）编写它们。他们使用一种称为“高段”的共享内存进行通信。</p><p class="normal"><b>Bloch:</b> Yes. I wrote the programs, except for one that was contributed by a friend named Thomas De Bellis. The unique thing about Tom's program was that it was written entirely in BASIC. It was line-oriented, and used files to communicate. It wasn't fast or efficient, but it worked! I wrote two, one line-oriented and one character-oriented. I wrote them in MACRO-10, the PDP-10 assembly language. They used a kind of shared memory called the “high segment” for the communication.</p>
<p class="normal">那时我对并发编程一无所知。我记得我并没有真正理解互斥体。但是存在通信缓冲区，以及试图同时相互通信的独立代理。所以存在竞争条件，偶尔程序会丢失一两个字符。作为一名高中生，我无法弄清楚自己。</p><p class="normal">I didn't know anything about concurrent programming back then. I remember not really understanding mutexes. But there were communication buffers, and independent agents trying to communicate with each other concurrently. So there were race conditions, and occasionally the program lost a character or two. I wasn't able to figure that out myself as a high-school student.</p>
<p class="normal"><b>Seibel：</b>你说你在最早的节目中看到了你当前风格的各个方面。哪些部分保持不变？</p><p class="normal"><b>Seibel:</b> You say that you saw aspects of your current style in your earliest programs. What are the bits that have stayed the same?</p>
<p class="normal"><b>Bloch：</b>我试图让我的程序可读。正如 Knuth 所说，程序本质上是文学作品。无论出于何种原因，我什至在那时就意识到程序必须是可读的。这并没有改变。</p><p class="normal"><b>Bloch:</b> My attempts to make my programs readable. As Knuth would say, a program is essentially a work of literature. For whatever reason, I realized even back then that a program has to be readable. And that hasn't changed.</p>
<p class="normal"><a id="OEBPS/Chapter05.html.page_170"></a><b>Seibel：</b>什么发生了变化？</p><p class="normal"><a></a><b>Seibel:</b> And what has changed?</p>
<p class="normal"><b>Bloch：</b>好吧，当您受限于单字符变量名时，很难使您的程序可读。所以我现在更担心变量命名。显然，当您使用具有新功能的语言时，很多事情都会发生变化。多年来你模糊理解的事情真的被猛烈抨击回家了。</p><p class="normal"><b>Bloch:</b> Well, it's hard to make your programs readable when you're restricted to single-character variable names. So I worry more about variable naming now. Obviously, as you use languages with new features, many things change. And things that you vaguely understood over the years really get slammed home.</p>
<p class="normal">例如，不要重复自己。那时我比现在更自由地进行复制和粘贴。现在我真的尽量不这样做。这有点夸大其词，但只是一点点。一般来说，如果我发现自己在复制和粘贴，我会想，“这个设计有什么问题？我该如何解决它？所以这需要一些时间才能做好。这些年来，基本上我对自己越来越严格了——这就是编写好的程序所需要的。你真的不能接受自己的坏习惯。</p><p class="normal">For example, don't repeat yourself. I was freer with the copy-and-paste back then than I am now. Now I really try not to do it at all. That's a little bit of an overstatement, but only a little bit. Generally speaking, if I find myself copying and pasting, I think, ”What's wrong with this design? How can I fix it?” So that's something that took a little while to get right. Basically I've become harder on myself over the years—that's what it takes to write good programs. You really can't accept bad habits from yourself.</p>
<p class="normal"><b>Seibel：</b>如果你要回到过去，重新做一遍，有没有什么是你真的希望自己做得不一样的？BASIC 没有对你造成脑损伤之类的吗？</p><p class="normal"><b>Seibel:</b> If you were going to go back in time and do it all over again, is there anything you wish you had really done differently? The BASIC didn't brain-damage you or anything?</p>
<p class="normal"><b>Bloch：</b>不，实际上这是一件有趣的事情。我认为 Dijkstra，上帝保佑他的灵魂，在这一点上是完全错误的。我认识很多非常优秀的程序员，他们都是从 BASIC 开始编程的，因为这对他们来说是可用的。</p><p class="normal"><b>Bloch:</b> No, actually that's a funny thing. I think Dijkstra, God rest his soul, was entirely wrong about that. I know so many really good programmers who got their start programming BASIC because that's what was available to them.</p>
<p class="normal">不过，我确实认为使用多种语言是件好事。到我上大学的时候，我正在编写一大堆程序。您将使用不同的语言进行每门课程。在数字课程或科学课程中，您会使用 Fortran。如果你当时正在上编程课程，那就是 Pascal 或 SAIL 或 Simula 或类似的东西。在 AI 课程中，它是 Lisp。</p><p class="normal">I do think it's good to use lots of languages, though. By the time I was in college, I was programming a whole bunch of them. Each course you would do in a different language. In a numerics course or a science course, you'd use Fortran. If you were taking a programming course back then, it was Pascal or SAIL or Simula or something like that. In an AI course, it was Lisp.</p>
<p class="normal">但也许我应该学更多的语言。很有趣——直到游戏后期我才真正接触到面向对象的东西。Java 是我第一个认真使用的面向对象语言，部分原因是我不能完全让自己使用 C++。</p><p class="normal">But maybe I should have learned more languages. It's funny—I didn't really get into the object-oriented thing until late in the game. Java was the first object-oriented language I used with any seriousness, in part because I couldn't exactly bring myself to use C++.</p>
<p class="normal"><b>Seibel：</b>那是什么时候？</p><p class="normal"><b>Seibel:</b> When was that?</p>
<p class="normal"><a id="OEBPS/Chapter05.html.page_171"></a><b>Bloch：</b>从 96 年我加入 Sun 开始。我认为如果比我早一点学习这些概念会很好。也就是说，我不认为所有这些概念都是好的。OO 是一件有趣的事情。这意味着两件事。这意味着模块化。模块化很棒。但我不认为面向对象的人可以要求这样做的权利。您可以查看较早的文献——例如 Parnas 的信息隐藏——并发现类作为抽象的概念早于面向对象编程。另一件事是继承，我认为继承是喜忧参半，就像现在很多人所做的那样。</p><p class="normal"><a></a><b>Bloch:</b> Starting in '96 when I joined Sun. I think it would have been good to learn those concepts a little earlier than I did. That said, I don't think all those concepts are good. OO is a funny thing. It means two things. It means modularity. And modularity is great. But I don't think the OO people can claim the right to that. You can look at older literature—for example Parnas's information hiding—and see that the notion of a kind of class as an abstraction predates object-oriented programming. And the other thing is inheritance and I consider inheritance a mixed blessing, as many people do by now.</p>
<p class="normal">此外，我应该让自己接触更多领域，包括计算机科学内外。你学的东西越多，越年轻，你就越好。我从来没有真正做过太多的一件事是 GUI 编程，我应该在某个时候强迫自己去做。但无论出于何种原因，这些年来图书馆对我的吸引力最大，它编写了供其他人使用的构建块。所以几十年来我一直在做数据结构和算法等等。</p><p class="normal">Also I should have exposed myself to more areas, inside and outside of computer science. The more things you learn and the younger you learn them, the better off you are. One thing I've never really done much of is GUI programming and I should have forced myself to do that at some point. But for whatever reason, libraries have appealed the most to me over the years, writing the building blocks for other people to use. So I've been doing data structures and algorithms and so forth for decades.</p>
<p class="normal"><b>Seibel：</b>有没有什么书是每个程序员都应该读的？</p><p class="normal"><b>Seibel:</b> Are there any books that every programmer should read?</p>
<p class="normal"><b>Bloch：</b>一个明显的，我对此有一些复杂的感觉，但我仍然认为每个人都应该阅读，是<i>设计模式</i>。它给了我们一个共同的词汇。里面有很多好点子。另一方面，有一种风格和语言的大杂烩，它开始显示出它的时代。但我认为它绝对值得一读。</p><p class="normal"><b>Bloch:</b> An obvious one, which I have slightly mixed feelings about but I still think everyone should read, is <i>Design Patterns</i>. It gives us a common vocabulary. There are a lot of good ideas in there. On the other hand, there's sort of a mish-mash of styles and languages, and it's beginning to show its age. But I think it's absolutely worth reading.</p>
<p class="normal">另一个是<i>Elements of Style</i>，它甚至不是一本编程书籍。您应该阅读它有两个原因：首先，每个软件工程师的大部分工作都是写散文。如果您不能编写精确、连贯、可读的规范，那么没有人能够使用您的东西。所以任何能改善你的散文风格的东西都是好的。第二个原因是那本书中的大部分思想也适用于程序。</p><p class="normal">Another is <i>Elements of Style</i>, which isn't even a programming book. You should read it for two reasons: The first is that a large part of every software engineer's job is writing prose. If you can't write precise, coherent, readable specs, nobody is going to be able to use your stuff. So anything that improves your prose style is good. The second reason is that most of the ideas in that book are also applicable to programs.</p>
<p class="normal">我的荒岛名单有点奇怪。例如，对我来说非常重要的一本书是Hank Warren 的<i>Hacker's Delight</i>。</p><p class="normal">My desert-island list is a little bit odd. For example, a book that's terribly important to me is <i>Hacker's Delight</i>, by Hank Warren.</p>
<p class="normal"><b>Seibel：</b>那是一本有点乱七八糟的书？</p><p class="normal"><b>Seibel:</b> That's the bit-twiddling book?</p>
<p class="normal"><a id="OEBPS/Chapter05.html.page_172"></a><b>布洛赫：</b>是的。我喜欢玩点心，这与我所做的有关。如果您编写库、编译器、低级图形或密码，这本书是必不可少的。沃伦采用了过去的口头传统，将其全部放在一个地方，并给予它应有的严格数学处理。那本书出版时我很激动。</p><p class="normal"><a></a><b>Bloch:</b> Yes. I love bit twiddling and it's relevant to what I do. If you write libraries, compilers, low-level graphics, or crypto, this book is indispensable. Warren has taken what used to be an oral tradition, put it all in one place, and given it the rigorous mathematical treatment that it deserves. I was thrilled when that book was published.</p>
<p class="normal">当然还有 Knuth 的<i>The Art of Computer Programming</i>。事实上，我还没有读过整个系列或任何接近它的东西。不过，当我在研究一种特定的算法时，我会去那里看看他对此有何看法。通常这正是我所需要的——都在里面。</p><p class="normal">Of course there's Knuth's <i>The Art of Computer Programming</i>. In truth, I haven't read the whole series or anything close to it. When I'm working on a particular algorithm, though, I go there to see what he has to say about it. And often it's exactly what I need—it's all in there.</p>
<p class="normal">但我根本没有阅读所有内容的能力和速度，所以如果我告诉你我有，那我就是在撒谎。我认为很棒的一本旧书是<i>The Elements of Programming Style</i>，作者是 Kernighan 和 Plauger。所有的例子都在 Fortran IV 和 PL/I 中，所以它有点过时了。但令人惊奇的是，考虑到这本书的年代，这些想法仍然是最新的。</p><p class="normal">But I simply don't have the capacity and speed to read through all of it, so I'd be lying if I told you I had. An old book that I think is great is <i>The Elements of Programming Style</i>, by Kernighan and Plauger. All the examples are in Fortran IV and PL/I, so it's a bit out-of-date. But it's amazing, given the age of the book, the ideas are all still current.</p>
<p class="normal">另一本旧书是 Frederick Brooks 的<i>The Mythical Man Month</i>。它已有 40 年的历史，今天仍然和它写成时一样真实。阅读只是一种乐趣。每个人都应该读那个。这本书的主要信息是“将人员添加到已延迟的软件项目中会使它变得更晚”，这仍然是正确的。但是里面还有很多其他重要的东西。一些细节已经开始老化，但无论如何每个人都应该阅读它。</p><p class="normal">Another old one is Frederick Brooks's <i>The Mythical Man Month</i>. It's 40 years old and still as true today as when it was written. And it's just a joy to read. Everyone should read that. The main message of the book is “adding people to a late software project makes it later,” and it's still true. But there are a lot of other important things in it. Some of the details are beginning to age, but everyone should read it anyway.</p>
<p class="normal">如今，每个人都必须学习并发。因此，<i>Java Concurrency in Practice</i>是另一个不错的选择。尽管它的标题中有<i>Java</i>，但很多材料都超越了任何特定的编程语言。</p><p class="normal">These days, everybody has to learn about concurrency. So <i>Java Concurrency in Practice</i> is another good bet. Although it has <i>Java</i> in the title, a lot of the material transcends any particular programming language.</p>
<p class="normal"><b>Seibel：</b>那是你和 Brian Goetz 合作的那个？</p><p class="normal"><b>Seibel:</b> That's the one you worked on with Brian Goetz?</p>
<p class="normal"><b>Bloch：</b>我的名字在封面上，但我可以随意提及它的原因是它并不是我的书。第一作者是 Brian，第二作者是 Tim Peierls，其余作者是 JSR-166 的所有人，Java 并发专家。但这些几乎都是出于礼貌——我们为本书贡献了材料，而不是散文。</p><p class="normal"><b>Bloch:</b> My name is on the cover but the reason I felt free to mention it is that it's not really my book. The lead author is Brian and then the secondary author was Tim Peierls and the remaining ones are everyone who was on JSR-166, the Java concurrency people. But those are almost there for courtesy—we contributed material but not prose to the book.</p>
<p class="normal">哦，还有一本书：<i>Merriam-Webster's Collegiate Dictionary，第 11 版</i>。没有它，永远不要去任何地方。这不是你实际<i>阅读</i>的东西，但正如我所说，当你编写程序时，你需要能够命名你的<a id="OEBPS/Chapter05.html.page_173"></a>标识符很好。你的散文必须很好。没有一本好字典，我会感到迷茫。</p><p class="normal">Oh, one more book: <i>Merriam-Webster's Collegiate Dictionary, 11th Edition</i>. Never go anywhere without it. It's not something you actually <i>read</i>, but as I said, when you're writing programs you need to be able to name your <a></a>identifiers well. And your prose has to be good. I'd feel lost without a good dictionary.</p>
<p class="normal"><b>Seibel：</b>除了更好地命名变量，减少剪切和粘贴之外，随着经验的积累，您的编程方式还有什么变化吗？</p><p class="normal"><b>Seibel:</b> Other than naming your variables better, and cutting and pasting less, is there anything else about how you approach programming that has changed as you gained experience?</p>
<p class="normal"><b>Bloch：</b>我年纪越大，就越意识到这不仅仅是让它发挥作用；它是关于生成可读、可维护和高效的工件。一般来说，我发现，与流行的看法相反，程序越干净、越好，它运行的速度就越快。如果没有，将很容易让它变快。正如他们所说，优化正确的代码比更正优化的代码更容易。</p><p class="normal"><b>Bloch:</b> The older I get, the more I realize it isn't just about making it work; it's about producing an artifact that is readable, maintainable, and efficient. Generally speaking, I find that, contrary to popular belief, the cleaner and nicer the program, the faster it's going to run. And if it doesn't, it'll be easy to make it fast. As they say, it's easier to optimize correct code than to correct optimized code.</p>
<p class="normal">我的方法中的一些变化是特定于语言的。每种语言都为您提供了一个工具包。您想为工作使用正确的工具，而在一种语言中是正确的工具在另一种语言中可能不是正确的工具。一个简单的例子：如果你用 Java 5 编写，使用<code>enums</code>而不是<code>int</code>常量或布尔值可以大大简化你的程序并使其更安全、更健壮。</p><p class="normal">Some of the changes in my approach are specific to languages. Every language presents you with a toolkit. You want to use the right tool for the job, and what would be the right tool in one language may not be the right one in another. A trivial example: if you're writing in Java 5, using <code>enums</code> instead of <code>int</code> constants or booleans can greatly simplify your program and make it safer and more robust.</p>
<p class="normal"><b>Seibel：</b>鉴于此，您能谈谈如何加快流利使用一门新语言的过程吗？</p><p class="normal"><b>Seibel:</b> Given that, can you say anything about how to speed up the process of getting to fluency in a new language?</p>
<p class="normal"><b>布洛赫：</b>我认为这很像口头语言。一种方法是了解多种语言——如果您已经了解意大利语和西班牙语并且想学习葡萄牙语，那么您将不会很难做到。你知道的越多，你就越需要借鉴。</p><p class="normal"><b>Bloch:</b> I think it's a lot like spoken languages. One way is by knowing a lot of languages—if you already know Italian and Spanish and you want to learn Portuguese, you're not going to have a very hard time doing it. The more you know, the more you have to draw on.</p>
<p class="normal">当你学习一门新语言时，带着你所学的一切进来，但要保持开放的心态。我知道有些人已经决定，“这就是所有程序的编写方式。” 我不会提到任何语言，但是某些语言，无论出于何种原因，都会使人们如此。每当他们使用一种新语言时，他们都会批评它不像上帝真正的语言，不管它是什么。当他们使用新语言时，他们会尽可能地使用上帝的真实语言来编写程序，就像您可以使用新语言一样。如果这样做，您通常会错过使语言与众不同的原因。</p><p class="normal">When you're learning a new language, come in with all that you've learned, but remain open-minded. I know people who have sort of decided, “This is the way that all programs should be written.” I won't mention any languages, but some languages, for whatever reason, cause people to get this way. Whenever they go to a new language, they criticize it to the extent it isn't like God's true language, whatever that happens to be. And when they use the new language, they try to program in God's true language to the extent that you can in the new language. Often you're missing what makes a language special if you do that.</p>
<p class="normal"><a id="OEBPS/Chapter05.html.page_174"></a>这就像如果你唯一的工具是一把锤子，而有人给你一把螺丝刀，你说，“嗯，这不是一把很好的锤子，但我想我可以握住刀刃并用手柄敲打。 ” 你有一把蹩脚的锤子，而实际上你可以把它当作一把好螺丝刀。因此，思想开放和愿意应用您已经知道的一切的结合。当然，代码，代码，代码！您使用该语言的次数越多，您就会学得越快。</p><p class="normal"><a></a>It's like if the only tool you have is a hammer and someone gives you a screwdriver, and you say, “Well, this isn't a very good hammer but I guess I can hold the blade in my hand and whack with the handle.” You have a crappy hammer when in fact you could have used it as a fine screwdriver. So, a combination of open-mindedness and a willingness to apply everything you already do know. And of course, code, code, code! The more you use the language, the faster you'll learn it.</p>
<p class="normal"><b>Seibel：</b>为什么人们对他们的计算机语言如此虔诚？</p><p class="normal"><b>Seibel:</b> Why do people get so religious about their computer languages?</p>
<p class="normal"><b>布洛赫：</b>我不知道。但是，当您选择一种语言时，您选择的不仅仅是一组技术权衡——您是在选择一个社区。这就像选择一个酒吧。是的，您想去一家供应好酒的酒吧，但这不是最重要的。这是谁在那里闲逛以及他们谈论什么。这就是您选择计算机语言的方式。随着时间的推移，社区围绕该语言建立起来——不仅是人，还有软件工件：工具、库等等。这就是有时表面上比其他语言更好的语言没有获胜的原因之一——因为它们只是没有在自己周围建立合适的社区。</p><p class="normal"><b>Bloch:</b> I don't know. But when you choose a language, you're choosing more than a set of technical trade-offs—you're choosing a community. It's like choosing a bar. Yes, you want to go to a bar that serves good drinks, but that's not the most important thing. It's who hangs out there and what they talk about. And that's the way you choose computer languages. Over time the community builds up around the language—not only the people, but the software artifacts: tools, libraries, and so forth. That's one of the reasons that sometimes languages that are, on paper, better than other languages don't win—because they just haven't built the right communities around themselves.</p>
<p class="normal"><b>Seibel：</b> Java 在这方面让我觉得很有趣，因为它有两个社区。有实施者和系统程序员——在 Javasoft 或 Weblogic 或类似地方工作的人。然后是所有使用 Java 和应用程序服务器以及预构建框架来构建业务应用程序的人。这些是非常不同的酒吧。</p><p class="normal"><b>Seibel:</b> Java strikes me as interesting in that regard because it has two communities. There's the implementers and systems programmers—people who worked at Javasoft or Weblogic or places like that. Then there's all the people who use Java and app servers and prebuilt frameworks to build business applications. Those are very different bars.</p>
<p class="normal"><b>Bloch：</b>有多个社区与 Java 和其他编程语言相关联。如果没有，通常表明该语言是小众语言或不成熟的语言。随着语言的发展和繁荣，它自然会吸引更加多样化的社区。此外，随着对一种语言的投资量增加，它的价值也会增加。</p><p class="normal"><b>Bloch:</b> There are multiple communities associated with Java and with other programming languages too. When there aren't, it's usually a sign that the language is either a niche language or an immature language. As a language grows and prospers, it naturally appeals to a more diverse community. And furthermore, as the amount of investment in a language grows, the value of it grows.</p>
<p class="normal">这就像梅特卡夫定律：网络的价值与用户数量的平方成正比。语言也是如此——你让所有这些人都使用一种语言，突然间你有了 Eclipse，你有了 FindBugs，你有了 Guice。即使 Java 不是您的完美语言，使用它也有所有这些附带的好处，因此您可以形成自己的语言<a id="OEBPS/Chapter05.html.page_175"></a>弄清楚如何在 Java 中进行数字编程或您想进行的任何类型的编程的社区。</p><p class="normal">It's like Metcalfe's law: the value of a network is proportional to the square of the number of users. The same is true of languages—you get all these people using a language and all of a sudden you've got Eclipse, you've got FindBugs, you've got Guice. Even if Java isn't the perfect language for you, there are all these incidental benefits to using it, so you form your own <a></a>community that figures out how to do numeric programming in Java, or whatever kind of programming you want to do.</p>
<p class="normal"><b>Seibel：</b>你和小时候一样喜欢编程吗？</p><p class="normal"><b>Seibel:</b> Do you enjoy programming as much as you did when you were a kid?</p>
<p class="normal"><b>布洛赫：</b>我有，虽然不一定以同样的方式。我认为，像许多孩子一样，编程在某种程度上是我逃避生活中无法处理的方面的避难所。另一件事是，当你年轻的时候，你拥有无限的能量，你可以连续几个小时地进行黑客攻击。</p><p class="normal"><b>Bloch:</b> I do, although not necessarily in the same way. Like many kids, I think, to some degree programming was a refuge from aspects of life that I couldn't handle. And the other thing is, when you're young you have boundless energy and you can hack for hours and hours on end.</p>
<p class="normal">随着年龄的增长，有了家庭和孩子等等，你就有了其他的责任，生活中其他重要的事情。然而，仍然有这种不可否认的高潮来自编写程序，看着各个部分落到位并提出几行可读、快速并做你想做的漂亮代码。</p><p class="normal">As you get older and have a family and kids and all that, you have other responsibilities, other important things in your life. And yet, there's still this undeniable high that comes from writing a program, watching the pieces fall into place and coming up with several beautiful lines of code that are readable, fast, and do what you want.</p>
<p class="normal"><b>Seibel：</b>你有没有发现，因为你更清楚地意识到仅仅让它发挥作用是不够的，还有所有这些其他问题，它几乎更令人生畏？</p><p class="normal"><b>Seibel:</b> Do you ever find that because of your greater awareness that it's not just enough to get it to work, that there are all these other issues, that it's almost more daunting?</p>
<p class="normal"><b>布洛赫：</b>当然。顺便说一下，书也是。开始做事时，我肯定会采取回避行为。开始是最难的部分，无论是程序、书籍还是其他任何东西。另一方面，有时你会提醒自己，“来吧乔希；你已经做了三十年了，你和大多数人一样知道如何去做，所以就去做吧。” 你只是提醒自己，“看，几乎每一次你都尝试这样做，结果都很好，所以这次他们可能也会很好。”</p><p class="normal"><b>Bloch:</b> Absolutely. Books too, by the way. I definitely go into avoidance behaviors when starting things. Starting is the hardest part, whether it's a program or a book or anything else. On the other hand, sometimes you remind yourself, “Come on Josh; you've been doing this for three decades now, you know how to do it as well as most other people, so just go for it.” And you just sort of remind yourself that, “Look, pretty much every other time you've tried to do this the results have been good, so they're probably going to be good this time too.”</p>
<p class="normal"><b>Seibel：</b>所以你刚刚谈到了随着你的生活经验的拓宽，它可能会让人分心，但是你觉得有没有什么东西，编程之外的经验让你成为了更好的程序员？</p><p class="normal"><b>Seibel:</b> So you just talked about how as your life experience broadens, it can be a distraction, but are there any things, experiences outside of programming, that you feel have made you a better programmer?</p>
<p class="normal"><b>布洛赫：</b>哦，当然。我认为几乎所有你做的事，只要你做得好。想法从各地转移。我想到的一个例子是，当我写论文时，我分析了一种分布式数据结构，即复制的稀疏内存。使我能够进行分析的基本想法来自我上过的化学课程。这是一个概念<a id="OEBPS/Chapter05.html.page_176"></a>速率平衡方程：当系统处于动态平衡状态时，您可以写出这样的方程式：“事物进入某种状态的速度与它们离开某种状态的速度相同。” 我在三个变量中得到三个联立方程，求解它们，得出的结果与观察到的这种复杂分布式数据结构的行为精确匹配。这是我直接从化学中窃取并重新定位到计算机科学的想法。</p><p class="normal"><b>Bloch:</b> Oh, absolutely. I think almost everything you do, if you do it well. Ideas transfer from all over the place. One example that comes to mind is, when I wrote my thesis, I did an analysis of a distributed data structure, the replicated sparse memory. And the basic idea that enabled me to do the analysis came from a chemistry course I had taken. It was the notion of a <a></a>rate-balance equation: when you have a dynamic equilibrium in a system, you can write equations that say, “Things are entering a certain state at the same rate that they're leaving it.” I got three simultaneous equations in three variables, solved them, and came up with results that precisely matched the observed behavior of this complicated distributed data structure. This was an idea I stole straight from chemistry and retargeted at computer science.</p>
<p class="normal">您在生活中看到的许多事物，无论是在建筑中——建筑物的建造方式，还是在语言中——交流发生的方式，其中许多想法都可以重新定位。当然，还有数学。数学和编程非常相似。因此，睁大眼睛并愿意重用想法是一件好事。</p><p class="normal">Many things that you see in life, whether in architecture—the way buildings are constructed, in language—the way that communication occurs, many of these ideas can be retargeted. And, of course, there's math. Math and programming are pretty darn similar. So keeping your eyes open and being willing to reuse ideas is a good thing.</p>
<p class="normal"><b>Seibel：</b>你认识一些程序员，他们是伟大的程序员但不懂数学或没有受过良好的数学教育？为了成为一名程序员，学习微积分和离散数学以及所有这些东西真的很重要吗？或者只是一种即使你没有接受过那种训练你也会有的想法？</p><p class="normal"><b>Seibel:</b> Do you know programmers who are great programmers but who aren't mathematical or well-educated in math? Is it actually important to have learned calculus and discrete math and all this stuff in order to be a programmer? Or is just more a kind of thinking that you could have even if you hadn't had that training?</p>
<p class="normal"><b>布洛赫：</b>我认为这是一种如果你没有接受过那种训练就会有的想法。但这确实有帮助。我和一个名叫 Mike McCloskey 的人一起工作。他非常喜欢数学，但没有学过数论。他重写了BigInteger。它曾经是 C 包上的单板，他用 Java 重写了它，并执行命令以使其运行速度与基于 C 的版本一样快。他实际上成功了。为此，他必须学习大量的数论知识。如果他没有数学倾向，他不可能做到，但如果他已经知道了，他就不必学习了。</p><p class="normal"><b>Bloch:</b> I think it's a kind of thinking that you could have if you hadn't had that training. But it sure helps. I worked with a guy by the name of madbot, Mike McCloskey. He's very mathematically inclined but hadn't taken number theory. He rewrote BigInteger. It used to be a veneer over a C package, and he rewrote it in Java with marching orders to make it run as fast as the C-based version. He actually pulled it off. In doing so he had to learn a heck of a lot of number theory. He couldn't have done it if he weren't mathematically inclined, but he wouldn't have had to learn it if he already knew it.</p>
<p class="normal"><b>Seibel：</b>但这本质上是一个数学问题。</p><p class="normal"><b>Seibel:</b> But that was an inherently mathematical problem.</p>
<p class="normal"><b>布洛赫：</b>你是对的；这是一个可怕的例子。但我相信，即使对于本质上不是数学的问题，你在数学中学到的那种思维方式对于编程来说也是必不可少的。例如，归纳证明与递归编程密切相关，如果不了解另一个就无法真正理解其中一个。您可能不知道<i>基本情况</i>和<i>归纳假设</i>这两个术语，但是如果您要编写正确的递归程序，就必须理解这些概念。所以即使域是<a id="OEBPS/Chapter05.html.page_177"></a>与数学无关，不熟悉这些概念的程序员将会遇到困难。</p><p class="normal"><b>Bloch:</b> You're right; it's a terrible example. But I believe that even for problems that aren't inherently mathematical, the kind of thinking that you learn in math is essential to programming. For instance, inductive proofs are so tied to recursive programming that you can't really understand one without understanding the other. You may not know the terms <i>base case</i> and <i>induction hypothesis</i>, but you have to understand these concepts if you're going to write correct recursive programs. So even if the domain is <a></a>unrelated to math, a programmer who isn't comfortable with these concepts is going to have a harder time.</p>
<p class="normal">你提到了微积分——我认为它不那么重要。这些年来发生了一件有趣的事情。过去人们只是假设，如果你是一个受过教育并且上过大学的人，你就必须了解微积分。那里有很多美妙的想法——能够以这种方式让你的思想围绕无穷大真是太好了。</p><p class="normal">You mentioned calculus—I think it's less important. A funny thing has happened over the years. It used to be just assumed that if you were an educated person who had gone to college you had to know calculus. And there are a lot of beautiful ideas there—it's nice to be able to get your mind around infinity in that way.</p>
<p class="normal">但是有一种离散且连续的方式可以使您的思想围绕无穷大。我认为对于一个程序员来说，掌握离散的方式更为重要。比如刚才提到的归纳证明。您可以证明所有整数都为真。这有点神奇。你证明了一个整数，你证明了一个暗示下一个，然后你已经证明了所有的整数。我认为对于程序员来说，这比理解限制的概念更重要。</p><p class="normal">But there's a discrete and a continuous way to get your mind around infinity. I think that for a programmer it's more important to have mastered the discrete way. For example, I just mentioned induction proofs. You can prove something true for all integers. It's kind of magical. You prove it for one integer and you prove that one implies the next and then you've proved it for all of them. And I think that is more important for a programmer than, let's say, understanding the notion of limits.</p>
<p class="normal">幸运的是，我们不必做出选择。我认为这两个课程都有足够的空间。所以即使你不会像使用离散数学那样频繁地使用微积分，我认为它仍然应该被教授。但我认为离散的东西比连续的东西更重要。</p><p class="normal">Luckily we don't have to make a choice. I think that there's plenty of room in the curriculum for both. So even if you're not going to use the calculus as much as you use the discrete mathematics, I think it should still get taught. But I think that the importance of the discrete stuff is greater than that of the continuous.</p>
<p class="normal"><b>Seibel：</b>您之前谈到过散文写作与编程有很多相似的特点。虽然数学一直与计算机和编程密切相关，但我想知道一旦您谈论开发诸如 Web 框架或基于框架的 Web 应用程序之类的东西，它是否需要与写作更相关的技能。</p><p class="normal"><b>Seibel:</b> You talked before about how writing prose has many similar characteristics to programming. While mathematics has always been closely associated with computers and programming, I wonder if once you're talking about developing things like web frameworks or a web application on top of a framework, if it requires skills more related to writing.</p>
<p class="normal"><b>Bloch：</b>是的——之前您提到有两个截然不同的 Java 程序员社区。在编写库、编译器和框架的社区中，对数学的需求要大得多。如果您在框架之上编写 Web 应用程序，则必须了解口头和视觉通信。当网站驱使我做错事时，我会很生气。很明显，只是有人没有想过接近这东西的人会如何处理。所以，是的，事情的真相是编程是一大堆学科的交汇点。根据你擅长的领域，你会更擅长编写不同的应用程序。但即使是库、编译器和<a id="OEBPS/Chapter05.html.page_178"></a>框架必须是可读和可维护的。我认为，如果你不是一个称职的作家，你将很难实现这个目标。</p><p class="normal"><b>Bloch:</b> Yes—earlier you mentioned that there were two distinct communities of Java programmers. The need for math is much greater in the community that writes libraries, compilers, and frameworks. If you write web applications on top of frameworks, you have to understand communication, both verbal and visual. I get infuriated at web sites when they drive me to do the wrong thing. It's clear that someone just hasn't thought about how someone approaching this thing will deal with it. So yes, the truth of the matter is that programming is at the confluence of a whole bunch of disciplines. And depending on which ones you excel at, you will be better at writing different applications. But even libraries, compilers, and <a></a>frameworks have to be readable and maintainable. I contend that you'll have a hard time achieving that goal if you aren't a competent writer.</p>
<p class="normal"><b>Seibel：</b>您设计软件的过程是怎样的？您会启动 Emacs 并开始编写代码，然后四处移动直到它看起来正确吗？或者你会拿着一张纸坐在沙发上吗？</p><p class="normal"><b>Seibel:</b> What is your process for designing software? Do you fire up Emacs and start writing code and then move it around until it looks right? Or do you sit down on your couch with a pad of paper?</p>
<p class="normal"><b>Bloch：</b>几年前，我在 OOPSLA 上做了一个名为“如何设计好的 API 及其重要性”的演讲，并且它的多个版本在 Web 上流传。它很好地解释了我是如何去做的。</p><p class="normal"><b>Bloch:</b> I gave a talk called “How to Design a Good API and Why It Matters” at OOPSLA a couple years ago, and several versions of it are floating around the Web. It does a pretty good job explaining how I go about it.</p>
<p class="normal">最重要的是知道您要构建什么：您要解决什么问题。需求分析的重要性怎么强调都不为过。有些人认为，“哦，是的，需求分析；你去找你的客户，你说，'你需要什么？他告诉你，你就完了。”</p><p class="normal">The most important thing is to know what you're trying to build: what problem you're trying to solve. The importance of requirements analysis can't be overstated. There are people who think, “Oh, yeah, requirements analysis; you go to your customer, you say, 'What do you need?' He tells you, and you're done.”</p>
<p class="normal">没有东西会离事实很远。这不仅是一个谈判，而且是一个理解的过程。许多客户不会告诉您问题；他们会告诉你一个解决方案。例如，客户可能会说，“我需要你为这个系统添加对以下 17 个属性的支持。然后你必须问，'为什么？你打算用这个系统做什么？你希望它如何发展？'”等等。你来回反复，直到你弄清楚所有客户真正需要软件做什么。这些是用例。</p><p class="normal">Nothing could be further from the truth. Not only is it a negotiation but it's a process of understanding. Many customers won't tell you a problem; they'll tell you a solution. A customer might say, for instance, “I need you to add support for the following 17 attributes to this system. Then you have to ask, 'Why? What are you going to do with the system? How do you expect it to evolve?'” And so on. You go back and forth until you figure out what all the customer really needs the software to do. These are the use cases.</p>
<p class="normal">提出一组好的用例是您在此阶段可以做的最重要的事情。一旦你有了它，你就有了一个基准，你可以根据它来衡量任何可能的解决方案。如果你花很多时间让它合理地接近正确也没关系，因为如果你做错了，你就已经死了。该过程的其余部分将是徒劳的。</p><p class="normal">Coming up with a good set of use cases is the most important thing you can do at this stage. Once you have that, you have a benchmark against which you can measure any possible solution. It's OK if you spend a lot of time getting it reasonably close to right, because if you get it wrong, you're already dead. The rest of the process will be an exercise in futility.</p>
<p class="normal">你能做的最糟糕的事情——我已经看到这种情况发生了——你让一群聪明人到一个房间里工作六个月，在他们真正理解他们是什么之前写了一份 247 页的系统规范试图建立。因为六个月后，他们将拥有一个非常精确指定的系统，但很可能毫无用处。他们经常说，“我们在规范上投入了太多，我们必须构建它。” 所以他们构建了无用的系统，但它永远不会被使用。那太可怕了。如果你没有<a id="OEBPS/Chapter05.html.page_179"></a>用例，你构建了东西，然后你尝试做一些非常简单的事情，你意识到，“哦，我的天哪，做一些非常简单的事情，比如获取 XML 文档并打印它需要一页又一页的样板代码。” 这是一件可怕的事情。</p><p class="normal">The worst thing that you can do—and I've seen this happen—is you get a bunch of smart guys into a room to work for six months and write a 247-page system specification before they really understand what it is they're trying to build. Because after six months, they'll have a very precisely specified system that may well be useless. And often they say, “We've invested so much in the spec that we have to build it.” So they build the useless system and it never gets used. And that's horrible. If you don't have <a></a>use cases, you build the thing and then you try to do something very simple and you realize that, “Oh my gosh, doing something very simple like taking an XML document and printing it requires pages upon pages of boilerplate code.” And that's a horrible thing.</p>
<p class="normal">因此，获取这些用例，然后编写框架 API。它应该非常非常短。整个事情通常应该适合一页。它不必非常精确。您需要包、类和方法的声明，如果不清楚它们应该做什么，那么可能需要对每个声明进行一句话描述。但这不是您最终将分发的质量文档。</p><p class="normal">So get those use cases and then write a skeletal API. It should be really, really short. The whole thing should, usually, fit on a page. It doesn't have to be terribly precise. You want declarations for the packages, classes, and methods and, if it's not clear what they should do, then maybe a one-sentence description for each. But this is not documentation of the quality that you will end up distributing.</p>
<p class="normal">整个想法是在这个阶段保持敏捷，充实 API，使您可以获取用例并使用这个新生的 API 对它们进行编码，看看它是否能胜任这项任务。真是太神奇了，事后看来有很多事情是显而易见的，但是当你设计 API 时，即使考虑到用例，你也会弄错。然后，当您尝试编写用例代码时，您会说，“哦，是的，这从根本上是错误的；我这里的课太多了；这些应该结合起来，这些需要打破，”不管它是什么。幸运的是，您的 API 文档只有一页纸，因此很容易修复它。</p><p class="normal">The whole idea is to stay agile at this stage, to flesh the API out just enough that you can take the use cases and code them up with this nascent API to see if it it's up to the task. It's just amazing, there are so many things that are obvious in hindsight but when you're designing the API, even with the use cases in mind, you get them wrong. Then when you try to code up the use cases you say, “Oh, yeah, this is fundamentally wrong; I have too many classes here; these should be combined, these need to be broken out,” whatever it is. Luckily, your API doc is only a page long, so it's easy to fix it.</p>
<p class="normal">随着您对 API 的信心增强，您<i>就会</i>充实它。但基本规则是，先编写使用 API 的代码，然后再编写实现它的代码。因为否则您可能会浪费时间编写不会被使用的实现代码。事实上，在充实规范之前编写使用 API 的代码，否则您可能会浪费时间为一些根本不完善的内容编写详细规范。这就是我设计东西的方式。</p><p class="normal">As your confidence in the API increases, <i>then</i> you flesh it out. But the fundamental rule is, write the code that uses the API before you write the code that implements it. Because otherwise you may be wasting your time writing implementation code that won't get used. In fact, write the code that uses the API before you even flesh out the spec, because otherwise you may be wasting your time writing detailed specs for something that's fundamentally broken. That's how I go about designing stuff.</p>
<p class="normal"><b>Seibel：</b>这对于设计像 Java 集合这样的东西有多具体，它们是一种特殊的独立 API？</p><p class="normal"><b>Seibel:</b> And how specific is this to designing things like the Java collections, which are a particular kind of self-contained API?</p>
<p class="normal"><b>Bloch：</b>我声称它没有你想象的那么具体。任何复杂的编程都需要 API 设计，因为大型程序必须是模块化的，并且您必须设计模块化接口。</p><p class="normal"><b>Bloch:</b> I claim it's less specific than you might think. Programming of any complexity requires API design because big programs have to be modular, and you have to design the intermodular interfaces.</p>
<p class="normal">出于几个原因，优秀的程序员会根据单独有意义的片段来思考。一是您可能不经意地最终生成了有用的、可重用的模块。如果您编写一个整体系统，并且，<a id="OEBPS/Chapter05.html.page_180"></a>当它变得太大时，你把它撕成碎片，可能没有明确的界限，你最终会得到无法维护的污水。所以我声称这只是最好的编程方式，无论您是否认为自己是 API 设计者。</p><p class="normal">Good programmers think in terms of pieces that make sense in isolation, for several reasons. One is that you, perhaps inadvertently, end up producing useful, reusable modules. If you write a monolithic system and, <a></a>when it gets too big, you tear it into pieces, there will likely be no clear boundaries, and you'll end up with unmaintainable sewage. So I claim that it's simply the best way to program, whether you consider yourself an API designer or not.</p>
<p class="normal">也就是说，编程的世界非常广阔。如果您的编程是编写 HTML，那么这可能不是最好的编程方式。但我认为对于许多类型的编程来说，它是。</p><p class="normal">That said, the world of programming is very large. If programming for you is writing HTML, it's probably not the best way to program. But I think that for many kinds of programming, it is.</p>
<p class="normal"><b>Seibel：</b>所以你想要一个由内聚和松散耦合的模块组成的系统。如今，对于如何达到这一点，至少有两种观点。一种是坐下来提前设计这些模块间 API，即您所说的过程。另一种是这种“可能可行的最简单的事情，毫不留情地重构”的方法。</p><p class="normal"><b>Seibel:</b> So you want a system that's made up of modules that are cohesive and loosely coupled. These days there's at least two views on how you can get to that point. One is to sit down and design these intermodule APIs in advance, the process that you're talking about. And the other is this “simplest thing that could possibly work, refactor mercilessly” approach.</p>
<p class="normal"><b>布洛赫：</b>我不认为这两者是相互排斥的。从某种意义上说，我所说的是应用于 API 的测试优先编程和重构。您如何测试 API？你在实现它之前就给它写了用例。虽然我不能运行它们，但我正在做测试先行的编程：我正在测试 API 的质量，当我编写用例代码以查看 API 是否能胜任任务时。</p><p class="normal"><b>Bloch:</b> I don't think the two are mutually exclusive. In a sense, what I'm talking about is test-first programming and refactoring applied to APIs. How do you test an API? You write use cases to it before you've implemented it. Although I can't run them, I am doing test-first programming: I'm testing the quality of the API, when I code up the use cases to see whether the API is up to the task.</p>
<p class="normal"><b>Seibel：</b>所以你编写客户端代码来使用 API，然后查看它并问，“我想写这段代码吗？”</p><p class="normal"><b>Seibel:</b> So you write the client code to use the API and then look at it and ask, “Is this code I would want to write?”</p>
<p class="normal"><b>布洛赫：</b>当然。有时您甚至没有到达可以查看客户端代码的阶段。你试着写它，然后你说，“我根本不能这样做，因为我忘记了 API 中的这个功能，”或者，“我可以这样做，但它会很乏味，所以这不是正确的方法”</p><p class="normal"><b>Bloch:</b> Absolutely. Sometimes you don't even get to the stage where you can look at the client code. You try to write it and you say either, “I cannot do this at all because I forgot this piece of functionality in the API,” or, “I can do this but it's going to be so tedious that this was not the right approach.”</p>
<p class="normal">不管你有多好；在您尝试编写代码之前，您无法获得正确的 API。你设计一些东西；尝试使用它；然后说，“哦，这太不对了。” 如果你在浪费时间编写它下面的所有层之前就这样做了，那就是一个巨大的胜利。所以我说的是测试先行编程和重构API，而不是重构API下面的实现代码。</p><p class="normal">It doesn't matter how good you are; you can't get an API right until you've tried to code to it. You design something; try to use it; and say, ”Oh, this is so wrong.” And if you do this before you've wasted time writing all of the layers underneath it, that's a huge win. So what I'm talking about is test-first programming and refactoring the APIs, rather than refactoring the implementation code underneath the APIs.</p>
<p class="normal"><a id="OEBPS/Chapter05.html.page_181"></a>至于做最简单的事情，我完全赞成。API 设计的基本定理是，<i>当有疑问时，将其排除在外</i>。它应该是最简单的东西，大到足以处理您关心的所有用例。这并不意味着“只是将一些草率的代码放在一起”。有很多关于这种效果的格言。我最喜欢的是一个通常被错误归因于 Thelonious Monk 的词：“简单并不容易。”</p><p class="normal"><a></a>As far as doing the simplest thing that will work, I'm all for it. The fundamental theorem of API design is, <i>when in doubt, leave it out</i>. It should be the simplest thing that is big enough to handle all the use cases that you care about. That doesn't mean “Just throw some sloppy code together.” There are oodles of aphorisms to this effect. My favorite is one that's commonly misattributed to Thelonious Monk: “Simple ain't easy.”</p>
<p class="normal">没有人喜欢草率的软件。那些说“写最简单的东西并毫不留情地重构”的人并不是在说“写草率的代码”，也不是在说“不要做前期设计工作”。我已经和 Martin Fowler 谈过这个问题。他坚信要思考你将要做什么，这样你的系统才有合理的形状和结构。他的意思是，“在写一行代码之前不要写 247 页的规范，”我同意。</p><p class="normal">Nobody likes sloppy software. People who say, “Write the simplest thing that could possibly work and refactor mercilessly” aren't saying, “Write sloppy code,” and they aren't saying, “Don't do upfront design work.” I've talked to Martin Fowler about this. He's a huge believer in thinking about what you're going to do so your system has a reasonable shape and a reasonable structure. What he's saying is, “Don't write 247-page specs before writing a line of code,” and I agree.</p>
<p class="normal">有一点我确实不同意 Martin 的观点：我认为测试甚至不能作为文档的可接受替代品。一旦您尝试编写其他人可以编码的东西，您就需要精确的规范，并且测试应该测试代码是否符合这些规范。</p><p class="normal">I do disagree with Martin on one point: I don't think tests are even remotely an acceptable substitute for documentation. Once you're trying to write something that other people can code to, you need precise specs, and the tests should test that the code conforms to those specs.</p>
<p class="normal">所以两个阵营之间存在一些分歧点，但我认为鸿沟并不像某些人认为的那么大。</p><p class="normal">So there are some points of disagreement between the two camps, but I don't think the gulf is as wide as some people do.</p>
<p class="normal"><b>Seibel：</b>既然你提到了 Fowler，他写了几本关于 UML 的书，你有没有使用 UML 作为设计工具？</p><p class="normal"><b>Seibel:</b> Since you mentioned Fowler, who's written a couple of books on UML, do you ever use UML as a design tool?</p>
<p class="normal"><b>Bloch：</b>不。我认为能够制作其他人可以理解的图表很好。但老实说，我什至不记得哪些组件应该是圆形或方形的。</p><p class="normal"><b>Bloch:</b> No. I think it's nice to be able to make diagrams that other people can understand. But honestly I can't even remember which components are supposed to be round or square.</p>
<p class="normal"><b>Seibel：</b>您是否曾经像 Knuth 那样进行过全面的文学编程？</p><p class="normal"><b>Seibel:</b> Have you ever done full-on literate programming a la Knuth?</p>
<p class="normal"><b>Bloch：</b>不，原则上我不反对。我只是没有机会这样做。另一件事是——我怎么能委婉地说——我倾向于不相信宗教，任何宗教，全盘托付。无论是面向对象编程、函数式编程、基督教还是犹太教——我都从中挖掘出好点子，但我并没有全部付诸实践。文学编程中有很多很棒的想法，但这不是正确的标准：没有<a id="OEBPS/Chapter05.html.page_182"></a>足够多的其他程序员在那里闲逛。我可以看到也许做一次实验。</p><p class="normal"><b>Bloch:</b> No. I'm not against it in principle. I just haven't had occasion to do it. The other thing is—how can I put this delicately—I tend not to buy into religions, any religions, whole hog. Whether it's object-oriented programming or functional programming or Christianity or Judaism—I mine them for good ideas but I don't practice them in toto. There are a lot of great ideas in literate programming, but it's not the right bar: there aren't <a></a>enough other programmers hanging out there. I could see maybe doing it once as an experiment.</p>
<p class="normal">相反，我会高高兴兴地花几个小时在标识符名称上：变量名称、方法名称等等，以使我的代码可读。如果您使用这些标识符读取一些表达式并且它读起来像一个英语句子，那么您的程序很可能是正确的，并且更容易维护。我认为那些说“哦，这不值得花时间；它只是一个变量的名称，”只是不明白它。以这种态度，您不会生成可维护的程序。</p><p class="normal">What I do instead is I will cheerfully spend literally hours on identifier names: variable names, method names, and so forth, to make my code readable. If you read some expression using these identifiers and it reads like an English sentence, your program is much more likely to be correct, and much easier to maintain. I think that people who say, “Oh, it's not worth the time; it's just the name of a variable,” just don't get it. You're not going to produce a maintainable program with that attitude.</p>
<p class="normal"><b>Seibel：</b>程序与大多数文献（无论如何都是非实验性文献）不同的一个方面是，阅读程序没有固定的顺序。你如何阅读一个不是你写的大程序？</p><p class="normal"><b>Seibel:</b> One way that programs differ from most literature—non-experimental literature anyway—is that there is no one order in which to read a program. How do you read a big program that you didn't write?</p>
<p class="normal"><b>布洛赫：</b>好问题。事实上，我真的希望程序写得很好。我认识一些人，他们有能力接受一个任意大的、写得不好的系统，并将自己包裹在代码中，直到他们在脑海中对架构有一个完整的了解。这是一个非常有用的技能，但我从来没有做到过。</p><p class="normal"><b>Bloch:</b> Good question. The truth is I really want programs to be well-written. I know a few people with the ability to take an arbitrarily large and poorly written system and wrap themselves in the code till they get a total mental picture of the architecture. It's a really useful skill, but I've never been able to do it.</p>
<p class="normal">我希望能够单独使用小模块、阅读它们并理解它们。如果我试图阅读一个紧密耦合的系统，那么我必须阅读整个内容才能理解其中的一部分，那将是一场噩梦。我什至要打起精神来<i>尝试</i>阅读它，而且我必须同时访问所有代码。我通常把所有东西都打印出来，然后坐在被打印件包围的地板上，在上面写笔记。</p><p class="normal">I want to be able to take small modules, read them, and understand them in isolation. If I'm trying to read a system that's tightly coupled so I have to read the whole thing in order to understand one part, it's a nightmare. I have to psych myself up even to <i>attempt</i> to read it, and I have to have access to all the code at the same time. I usually print everything out and sit on the floor surrounded by the printout, writing notes on it.</p>
<p class="normal">如果我正在阅读一段写得很好的代码，我会尝试从 10,000 英尺的高度寻找一个视图：通常有人在某个地方写下了整个系统形状的描述。如果我能找到它，我就知道重要的模块是什么，我会先阅读它们，偶尔会深入到较低级别的模块以帮助我理解。</p><p class="normal">If I'm reading a well-written piece of code, I try to find a view from 10,000 feet: usually someone, somewhere has written a description of the shape of the entire system. If I can find it, I know what the important modules are, and I read them first, occasionally diving down into lower-level modules to aid my understanding.</p>
<p class="normal">此外，尽管代码是按页面线性排列的，但执行过程完全不是线性的。如果我有幸拥有一段可以从上到下阅读的代码，那太好了。如果没有，重要的是我可以访问让我快速找到正在调用的方法的工具，正在调用的类<a id="OEBPS/Chapter05.html.page_183"></a>正在扩展，等等。这让我了解代码中的关键执行路径。</p><p class="normal">Also, although code is written linearly down the page, the execution is not at all linear. If I'm lucky enough to have a piece of code that can be read from top to bottom, great. If not, it's important that I have access to tools that let me quickly locate methods that are being invoked, classes that are <a></a>being extended, and so on. This lets me understand key execution paths through the code.</p>
<p class="normal"><b>Seibel：</b>您是否曾将单步执行代码作为理解代码的一种方式？</p><p class="normal"><b>Seibel:</b> Do you ever step through code as a way of understanding it?</p>
<p class="normal"><b>布洛赫：</b>当然！那仍然是我选择的调试方法。特别是对于并发代码——事物可能处于的状态太多，我无法一一列举。我只是盯着代码看；在心理上逐步完成；想想什么不变量必须在什么时候保持。对于我们可以使用的所有花哨的调试工具，没有什么能比得上在调试器中单步调试程序或阅读程序并在脑海中执行代码的强大功能。我以这种方式发现了很多错误，并将其用作写作过程的一部分。</p><p class="normal"><b>Bloch:</b> Absolutely! That is still my chosen method of debugging. Especially for concurrent code—there are too many states that the thing can be in for me to possibly enumerate all of them. I just stare at the code; step through it mentally; think of what invariants must hold at what time. For all of the fancy debugging tools at our disposal, there's nothing that can match the power of simply stepping through a program, in a debugger or by reading it and mentally executing the code. I've found many bugs that way and I use it as part of the writing process.</p>
<p class="normal">当我编写程序时，我对自己说，这里必须是真的是什么？将这些断言放入代码中非常重要，以便为子孙后代保留它们。如果您的语言允许您使用断言结构来完成它，请使用它；如果不是，请在评论中提出断言。无论哪种方式，信息都太宝贵了，不能丢失。这是您在六个月后了解该计划所需要的，也是您的同事随时了解该计划所需要的。</p><p class="normal">As I write the program, I say to myself, what it is that must be true here? And it's very important to put those assertions into the code, to preserve them for posterity. If your language lets you do it with an assert construct, use it; if not, put assertions in comments. Either way, the information is too valuable to lose. It's what you need to understand the program six months down the road, and what your colleague needs to understand the program any time at all.</p>
<p class="normal"><b>Seibel：</b>你觉得人们是否理解不变量以及如何使用断言？</p><p class="normal"><b>Seibel:</b> Do you feel like people understand invariants and how to use assertions as well as they ought?</p>
<p class="normal"><b>Bloch：</b>不。您可能知道断言是我添加到 Java 编程语言中的第一个结构，而且我很清楚它们从未真正成为文化的一部分。只有一小部分 Java 程序员使用它们。我不完全知道为什么会这样。谈到数学——不变量在很大程度上是一个数学概念。</p><p class="normal"><b>Bloch:</b> No. You probably know that assertions were the first construct that I added to the Java programming language and I'm well aware that they never really became part of the culture. Only a small fraction of Java programmers use them. I don't exactly know why that is. Talking of mathematics—invariants are very much a mathematical idea.</p>
<p class="normal"><b>Seibel：</b>但是你不需要有很多数学知识就能理解它。</p><p class="normal"><b>Seibel:</b> But you don't have to have a lot of math to be able to understand it.</p>
<p class="normal"><b>布洛赫：</b>你没有。但让我只是唱反调。做数学有一定的思维精确性。我曾为四年级和五年级学生执教过数学奥林匹克队。这正是一些孩子在某种程度上开始理解证明概念的年龄——<a id="OEBPS/Chapter05.html.page_184"></a>一个命题可以被证明是绝对正确的，而不仅仅是“我认为它是正确的，因为这里有一些它似乎有效的例子。”</p><p class="normal"><b>Bloch:</b> You don't. But let me just play the devil's advocate. There's a certain precision of thinking that comes with doing math. I coached a Math Olympiad team for fourth and fifth graders. This is just the age at which some kids are starting to understand, at some level, the notion of a proof—that <a></a>a proposition can be demonstrably, unequivocally true rather than just, “I think it's true because here are a few examples where it seems to work.”</p>
<p class="normal">为了理解不变量的概念，您必须理解证明的概念。不幸的是，有很多成年人不这样做。这是一种通常在数学课上教授的思维方式。</p><p class="normal">In order to understand the notion of an invariant, you have to understand the notion of a proof. Unfortunately, there are plenty of adults who don't. And it's a style of thinking that is typically taught in mathematics classes.</p>
<p class="normal"><b>Seibel：</b>你几乎想知道是否编程是教授这种思维的更好论坛。如果您只是将编程讲授为不变量——</p><p class="normal"><b>Seibel:</b> You'd almost wonder if maybe the better forum to teach that kind of thinking would be in programming. If you just taught programming as being about invariants—</p>
<p class="normal"><b>布洛赫：</b>在某种程度上我同意，但你可以在那个方向上走得太远。然后我们回到 Dijkstra。我相信您已经读过“论真正教授计算机科学的残酷性”，我认为这可能是错误的。Dijkstra 说你不应该让学生接触计算机，直到他们在一个学期内操纵了符号，剥夺了它们的真正含义。太疯狂了！告诉计算机做某事并看着它做是一种乐趣。我不会剥夺学生的那种快乐。而且，我不认为我可以——计算机无处不在。十岁的孩子正在编程。</p><p class="normal"><b>Bloch:</b> To a certain extent I agree, but you can go too far in that direction. Then we're back to Dijkstra. I'm sure you've read “On the Cruelty of Really Teaching Computing Science”, which I think is as wrong as it could possibly be. Dijkstra says that you shouldn't let students even touch a computer until they've manipulated symbols, stripped of their true meaning, for a semester. That's crazy! There's a joy in telling the computer to do something, and watching it do it. I would not deprive students of that joy. And furthermore, I wouldn't assume that I could—computers are everywhere. Ten-year-olds are programming.</p>
<p class="normal"><b>Seibel：</b>作为 Google 的 Java 人员，您认为它可以被更多地使用吗？撇开历史的力量和历史的选择不谈，如果你能以某种方式挥舞魔杖，用 Java 替换所有的 C++，那行得通吗？</p><p class="normal"><b>Seibel:</b> As a Java guy at Google, do you think it could be used more? Leaving aside the force of history and historical choices, if somehow you could wave a magic wand and replace all of the C++ with Java, could that work?</p>
<p class="normal"><b>布洛赫：</b>在一定程度上。系统的大部分都可以这样写，随着时间的推移，事情正朝着那个方向发展。但对于系统的绝对核心——例如索引服务器的内部循环——性能上非常小的提升却价值巨大。当你有那么多机器运行同一段代码时，如果你能让它快几个百分点，那么你就做了一些在经济和环境方面都有实际好处的事情。所以有一些代码你想用汇编语言写，而 C 不是美化的汇编语言是什么？</p><p class="normal"><b>Bloch:</b> Up to a point. Large parts of the system could be written that way, and over time, things are moving in that direction. But for the absolute core of the system—the inner loops of the index servers, for instance—very small gains in performance are worth an awful lot. When you have that many machines running the same piece of code, if you can make it even a few percent faster, then you've done something that has real benefits, financially and environmentally. So there is some code that you want to write in assembly language, and what is C but glorified assembly language?</p>
<p class="normal">我不信教。如果有效，那就太好了。我写了 20 年的 C 代码。但就程序员的时间而言，使用提供更好安全性、便利性和表现力的更现代的语言要高效得多。在大多数情况下，程序员的时间比计算机时间更有价值。<a id="OEBPS/Chapter05.html.page_185"></a>但如果您在许多、数千台机器上运行相同的程序，则不一定如此。因此，我们编写的一些程序可能使用不太安全的语言来提取每一盎司的性能是值得的。我认为对于现在的大多数程序来说，所有现代语言的性能都是一种洗礼，如果有人告诉你他们的语言效率高十倍，他们可能是在骗你。</p><p class="normal">I'm not religious. If it works, great. I wrote C code for 20 years. But it's much more efficient, in terms of programmers' time, to use a more modern language that provides better safety, convenience, and expressiveness. In most cases, programmer time is much more valuable than computer time. <a></a>But that isn't necessarily so if you're running the same program on many, many thousands of machines. So there are some programs that we write where probably using less-safe languages to extract every ounce of performance is worth it. I think for most programs these days the performance of all modern languages is a wash and if anyone tells you that their language is ten times more efficient, they're probably lying to you.</p>
<p class="normal">但就效率而言，就工程师的时间利用而言，还差得远呢。首先，更现代的语言不会出现大量错误。其次，他们拥有令人惊叹的工具集，可以提高工程师的效率。在某种程度上，这是文化；这是人们在学校学习的语言。但在某种程度上，我认为这实际上是基础工程在起作用。例如，如果一种语言有一个宏处理器，那么就很难为它编写好的工具。解析 C++ 比解析 Java 复杂得多。</p><p class="normal">But in terms of efficiency, in terms of use of engineers' time, it's far from a wash. More modern languages, first of all, are exempt from large classes of errors. Second of all, they have marvelous sets of tools which make engineers more efficient. To some degree it's cultural; it's what languages people learned in schools. But to some degree I think it's actually fundamental engineering at work. For example, if a language has a macro processor it's much harder to write good tools for it. Parsing C++ is a much trickier business than parsing Java.</p>
<p class="normal">与过去相比，Google 现在用 Java 编写的代码要多得多。我不知道数字是多少，但如果线还没有越过，他们很快就会。因此，我们在每种语言中有多少行代码与在每种语言中执行了多少个周期之间存在很大差异。而且我认为尝试获取用 Java 编写的索引服务器的内部循环将是徒劳的，也不是特别有价值。如果你今天要创办一家公司来做这类事情，你可能主要用 Java 或其他一些现代、安全的语言编写东西，然后在需要时转义它。但是我们有这个工程基础设施。图书馆和监控设施以及所有使之运转的东西。最后 Java，如果不是这方面的平等合作伙伴，它' 在这些系统中可以合理使用，这很好。当我到达时，情况还不是这样。</p><p class="normal">Google is writing a lot more of its code in Java now than it used to. I don't know what the numbers are, but if the lines haven't already crossed, they will soon. So there's a big difference between how many lines of code do we have in each language versus how many cycles are getting executed in each language. And I think it would be a fool's errand and not particularly meritorious, either, to try and get the inner loops of the indexing servers written in Java. If you were starting a company to do this sort of thing today, you might write things largely in Java or in some other modern, safe language, and then escape it when you needed to. But we have this engineering infrastructure. Libraries and monitoring facilities and all of that stuff that makes it go. And finally Java is, if not an equal partner in this, it's reasonably usable within these systems, which is good. When I arrived that wasn't the case yet.</p>
<p class="normal">公司很早就建立了自己的 DNA。它可以使他们取得巨大成功，但也可能使他们在早期对他们有利的东西不再对他们有利时难以逃脱。我记得 1982 年左右在 Yorktown Heights 的 IBM Research 实习，看到这种文化仍然以批处理为主。甚至在做分时的时候，他们都是用虚拟读卡器和虚拟打卡器来说话。一切仍然是 80 列记录。对于 DEC，他们从未摆脱过分时心态。和我<a id="OEBPS/Chapter05.html.page_186"></a>假设对于微软来说，他们是否能够超越桌面 PC 的心态是一个悬而未决的问题。</p><p class="normal">Companies establish their DNA very early on. It can make them tremendously successful, but it can also make it hard for them to escape when what served them well in the early days doesn't serve them so well any more. I remember being an intern at IBM Research in Yorktown Heights around 1982, seeing the culture still dominated by batch processing. Even when they were doing timesharing, they talked in terms of virtual card readers and virtual card punches. Everything was still 80-column records. With DEC, it was the timesharing mentality that they never escaped. And I <a></a>suppose with Microsoft it's an open question whether they'll be able to move beyond the desktop-PC mentality.</p>
<p class="normal"><b>Seibel：</b>从现在起 20 年后，人们将谈论 Google 如何无法摆脱在互联网上销售广告的困境。</p><p class="normal"><b>Seibel:</b> And 20 years from now people will be talking about how Google can't get past how to sell ads on the Internet.</p>
<p class="normal"><b>布洛赫：</b>当然。无论如何，在谷歌有这样一种文化模因，即 Java 缓慢且不可靠。它的来源很明显：Linux 上的 Blackdown Java，大约在 1999 年，速度慢且不可靠。旧观念很难消亡。尽管事实是，谷歌将 Java 用于多种业务关键功能，顺便说一句，包括广告。</p><p class="normal"><b>Bloch:</b> Absolutely. Anyway, there was this sort of cultural meme at Google that Java is slow and unreliable. And it's obvious where it came from: Blackdown Java on Linux, around 1999, was slow and unreliable. And old ideas die very hard. Although the truth is, Google uses Java for many sorts of business-critical functions, including, by the way, ads.</p>
<p class="normal">所以在某种程度上，他们明白它既不慢也不不可靠。但实际的搜索管道，在机器周期方面是最密集的，这些东西基本上都是 C++，并且有一个明显的原因与公司的起源有关。我认为这将在相当长的一段时间内继续影响我们。</p><p class="normal">So at some level they understand that it's neither slow nor unreliable. But the actual search pipeline, which is the most intense in terms of machine cycles, that stuff is all basically C++ and there's an obvious reason having to do with the genesis of the company. And I think that will continue to affect us for quite some time.</p>
<p class="normal"><b>Seibel：</b>您实际使用的编程工具是什么？</p><p class="normal"><b>Seibel:</b> What are the tools you actually use to program?</p>
<p class="normal"><b>Bloch：</b>我知道这会发生；我是个老屁，我并不以此为荣。Emacs 击键已连接到我的大脑中。我倾向于编写较小的程序、库等。所以我在没有现代工具的情况下做了太多编码。但我知道现代工具可以让你更有效率。</p><p class="normal"><b>Bloch:</b> I knew this was coming; I'm an old fart and I'm not proud of it. The Emacs keystrokes are wired into my brain. And I tend to write smaller programs, libraries and so forth. So I do too much of my coding without modern tools. But I know that modern tools make you a lot more efficient.</p>
<p class="normal">我确实将 IntelliJ 用于更大的东西，因为我小组的其他人都在使用它，但我并不是很精通。令人印象深刻：我喜欢这些工具为您做的静态分析。我让来自这些工具（IntelliJ、Eclipse、NetBeans 和 FindBugs）的人担任<i>Java Puzzlers</i>的章节审阅者，这些工具会自动检测到那本书中的许多陷阱。我认为这太棒了。</p><p class="normal">I do use IntelliJ for larger stuff, because the rest of my group uses it, but I'm not terribly proficient. It is impressive: I love the static analysis that these tools do for you. I had people from those tools—IntelliJ, Eclipse, NetBeans, and FindBugs—as chapter reviewers on <i>Java Puzzlers</i>, so many of the traps and pitfalls in that book are detected automatically by these tools. I think it's just great.</p>
<p class="normal"><b>Seibel：</b>您是否相信如果您花一个月的时间真正彻底地学习 IntelliJ，您的工作效率真的会更高吗？</p><p class="normal"><b>Seibel:</b> Do you believe you would really be more productive if you took a month to really learn IntelliJ inside out?</p>
<p class="normal"><b>布洛赫：</b>我愿意。现代 IDE 非常适合大规模重构。Brian Goetz 指出，人们现在编写的代码更加简洁，因为他们进行了他们根本不会尝试的重构<a id="OEBPS/Chapter05.html.page_187"></a>前。他们几乎可以指望这些工具在不改变代码行为的情况下传播变化。</p><p class="normal"><b>Bloch:</b> I do. Modern IDEs are great for large-scale refactorings. Something that Brian Goetz pointed out is that people write much cleaner code now because they do refactorings that they simply wouldn't have attempted <a></a>before. They can pretty much count on these tools to propagate changes without changing the behavior of the code.</p>
<p class="normal"><b>Seibel：</b>其他工具呢？</p><p class="normal"><b>Seibel:</b> What about other tools?</p>
<p class="normal"><b>Bloch：</b>我不擅长编程工具。我希望我是。构建和源代码控制工具的变化超出了我的预期，我很难跟上。因此，每次设置新环境时，我都会打扰我更精通工具的同事。我说，“这些天你是怎么做到的？” 他们翻白眼帮助我，我使用环境直到它不再工作。</p><p class="normal"><b>Bloch:</b> I'm not good with programming tools. I wish I were. The build and source-control tools change more than I would like, and it's hard for me to keep up. So I bother my more tool-savvy colleagues each time I set up a new environment. I say, “How do you do it these days?” They roll their eyes and help me and I use the environment until it doesn't work anymore.</p>
<p class="normal">我并不为此感到骄傲。工程师有他们擅长的事情，也有他们不擅长的事情。有些人想假装事实并非如此，工程师可以互换，每个人都可以而且应该成为全才。但这忽略了这样一个事实，即有些人在某些事情上非常擅长，但在其他事情上不一定那么擅长。如果你强迫他们做每件事，你可能会做出平庸的产品。</p><p class="normal">I'm not proud of this. Engineers have things that they're good at and things they're not so good at. There are people who would like to pretend that this isn't so, that engineers are interchangeable, and that everyone can and should be a total generalist. But this ignores the fact that there are people who are stunningly good at certain things and not necessarily so good at other things. If you force them all to do everything, you'll probably make mediocre products.</p>
<p class="normal">特别是有些人，用 Kevin Bourrillion 的话来说，“缺乏同理心基因”。如果你不能设身处地为普通程序员尝试使用你的 API 或语言来完成某件事，你就不会成为一名优秀的 API 设计者或语言设计者。不过，有些人是优秀的 API 和语言设计者。然后有些人非常擅长语言设计的技术方面，他们可以说，“哦，这将使事情不是 LALR(1)，你需要以这种方式调整它。” 这是一个非常有用的技能。但它无法替代拥有同理心基因并知道您拥有这种无法使用的糟糕语言。</p><p class="normal">In particular there are some people who, in Kevin Bourrillion's words, “lack the empathy gene.” You aren't going to be a good API designer or language designer if you can't put yourself in the shoes of an ordinary programmer trying to use your API or language to get something done. Some people are good API and language designers, though. Then there are people who are stunningly good at the technical aspects of language design where they can say, “Oh, this will make the thing not LALR(1) and you need to tweak it in just such a way.” That's an incredibly useful skill. But it's no substitute for having the empathy gene and knowing you have this awful language that's unusable.</p>
<p class="normal">我认识其他人，他们非常擅长提取最后一部分的性能。你想让他们处于他们正在做的位置。他们会很高兴，并且会为您的公司做好事。我认为你必须弄清楚你的工程师擅长什么，并为此使用他们。所以这就是我为什么不喜欢工具的道歉。蹩脚的，我知道。</p><p class="normal">I know other people who are stunningly good at extracting that last percentage of performance. You want to put them in a position where that's what they're doing. They'll be happy and they'll do good stuff for your company. I think you've got to figure out what your engineers are good at and use them for that. So that's my apologia for why I suck at tools. Lame, I know.</p>
<p class="normal"><b>Seibel：</b>我们来谈谈调试吧。您必须追踪的最严重的错误是什么？</p><p class="normal"><b>Seibel:</b> Let's talk about debugging. What's the worst bug you ever had to track down?</p>
<p class="normal"><a id="OEBPS/Chapter05.html.page_188"></a><b>布洛赫：</b> 90 年代初，当我在匹兹堡一家名为 Transarc 的公司工作时，我想到了一件既可怕又有趣的事情。我承诺在非常紧迫的时间表内执行事务性共享内存实现。我按时完成了设计和实现，甚至在这个过程中产生了一些可重用的组件。但是我匆忙写了很多新代码，这让我很紧张。</p><p class="normal"><a></a><b>Bloch:</b> One that comes to mind, which was both horrible and amusing, happened when I worked at a company called Transarc, in Pittsburgh, in the early '90s. I committed to do a transactional shared-memory implementation on a very tight schedule. I finished the design and implementation on schedule, and even produced a few reusable components in the process. But I had written a lot of new code in a hurry, which made me nervous.</p>
<p class="normal">为了测试代码，我写了一个可怕的“basher”。它运行大量事务，每个事务都包含嵌套事务，递归到某个最大嵌套深度。每个嵌套事务都会按升序锁定和读取共享数组的几个元素，并向每个元素添加一些内容，从而保留数组中所有元素的总和为零的不变性。每个子事务要么提交，要么中止——90% 的提交，10% 的中止，或其他。多个线程同时运行这些事务并在阵列上运行很长时间。由于我正在测试的是共享内存工具，因此我同时运行了多个多线程 basher，每个都在自己的进程中。</p><p class="normal">To test the code, I wrote a monstrous “basher.” It ran lots of transactions, each of which contained nested transactions, recursively up to some maximum nesting depth. Each of the nested transactions would lock and read several elements of a shared array in ascending order and add something to each element, preserving the invariant that the sum of all the elements in the array was zero. Each subtransaction was either committed or aborted—90 percent commits, 10 percent aborts, or whatever. Multiple threads ran these transactions concurrently and beat on the array for a prolonged period. Since it was a shared-memory facility that I was testing, I ran multiple multithreaded bashers concurrently, each in its own process.</p>
<p class="normal">在合理的并发水平下，basher 以优异的成绩通过了测试。但是当我真正提高并发性时，我发现 basher 偶尔会失败其一致性检查。我不知道发生了什么。当然，我认为这是我的错，因为我已经编写了所有这些新代码。</p><p class="normal">At reasonable concurrency levels, the basher passed with flying colors. But when I really cranked up the concurrency, I found that occasionally, just occasionally, the basher would fail its consistency check. I had no idea what was going on. Of course I assumed it was my fault because I had written all of this new code.</p>
<p class="normal">我花了一周左右的时间为每个组件编写了痛苦而彻底的单元测试，并且所有测试都通过了。然后我为每个内部数据结构编写了详细的一致性检查，这样我就可以在每次突变后调用一致性检查，直到测试失败。最后我发现了一个低级别的一致性检查失败——不是重复的，但以一种允许我分析发生了什么的方式。我得出了一个不可避免的结论，我的锁坏了。我有并发的读取-修改-写入序列，其中两个事务锁定、读取和写入相同的值，最后一个写入破坏了第一个。</p><p class="normal">I spent a week or so writing painfully thorough unit tests of each component, and all the tests passed. Then I wrote detailed consistency checks for each internal data structure, so I could call the consistency checks after every mutation until a test failed. Finally I caught a low-level consistency check failing—not repeatably, but in a way that allowed me to analyze what was going on. And I came to the inescapable conclusion that my locks weren't working. I had concurrent read-modify-write sequences taking place in which two transactions locked, read, and wrote the same value and the last write was clobbering the first.</p>
<p class="normal">我已经编写了自己的锁管理器，所以我当然怀疑它。但是锁管理器以优异的成绩通过了单元测试。最后，我确定损坏的不是锁管理器，而是底层的互斥锁实现！这是在运营之前的日子<a id="OEBPS/Chapter05.html.page_189"></a>系统支持线程，因此我们必须编写自己的线程包。事实证明，负责互斥锁代码的工程师不小心在我们的 Solaris 线程实现的汇编代码中交换了 lock 和 try-lock 例程的标签。所以每次你以为你在调用 lock，你实际上是在调用 try-lock，反之亦然。这意味着当存在实际争用时（当时很少见），第二个线程就进入了临界区，就好像第一个线程没有锁一样。有趣的是，这意味着整个公司已经在没有互斥量的情况下运行了几个星期，而且没有人注意到。</p><p class="normal">I had written my own lock manager, so of course I suspected it. But the lock manager was passing its unit tests with flying colors. In the end, I determined that what was broken wasn't the lock manager, but the underlying mutex implementation! This was before the days when operating <a></a>systems supported threads, so we had to write our own threading package. It turned out that the engineer responsible for the mutex code had accidentally exchanged the labels on the lock and try-lock routines in the assembly code for our Solaris threading implementation. So every time you thought you were calling lock, you were actually calling try-lock, and vice versa. Which means that when there was actual contention—rare in those days—the second thread just sailed into the critical section as if the first thread didn't have the lock. The funny thing was that that this meant the whole company had been running without mutexes for a couple weeks, and nobody noticed.</p>
<p class="normal">Bentley 和 McIlroy 在他们名为“Engineering a Sort Function”的精彩论文中引用了关于测试的 Knuth 名言，关于让自己处于最卑鄙和最恶劣的情绪中。对于这组测试，我肯定是这样做的。但这满足了所有让 bug 难以发现的问题。首先，它与并发有关，而且它是完全不可重现的。其次，你有一些核心假设被证明是错误的。他们说“是的，好吧，语言坏了”或“系统坏了”是新手的标志。但在这种情况下，是的，我所站的基石——互斥体——实际上已经坏了。</p><p class="normal">There's a wonderful Knuth quote about testing, quoted by Bentley and McIlroy in their wonderful paper called “Engineering a Sort Function,” about getting yourself in the meanest and nastiest mood that you can. I most certainly did that for this set of tests. But this tickled all of the things that make a bug hard to find. First of all, it had to do with concurrency and it was utterly unreproducible. Second of all, you had some core assumption that turned out to be false. It's the hallmark of the tyro that they say, ”Yeah, well, the language is broken” or, “The system is broken.” But in this case, yes, the bedrock on which I was standing—the mutex—was, in fact, broken.</p>
<p class="normal"><b>Seibel：</b>所以错误不在你的代码中，但与此同时你已经为你的代码编写了如此彻底的单元测试，以至于你别无选择，只能看看你的代码之外。您是否认为互斥锁代码的作者可以或应该编写一些测试来发现此错误并为您节省一周半的调试时间？</p><p class="normal"><b>Seibel:</b> So the bug wasn't in your code but in the meantime you had written such thorough unit tests for your code that you had no choice but to look outside your code. Do you think there were tests that the author of the mutex code could have, or should have, written that would have found this bug and saved you a week and a half of debugging?</p>
<p class="normal"><b>Bloch：</b>我认为对互斥设施进行良好的自动化单元测试可以使我免于这种特殊的痛苦，但请记住，那是在 90 年代初期。我从来没有想过要责怪所涉及的工程师没有编写足够好的单元测试。即使在今天，为并发实用程序编写单元测试也是一种艺术形式。</p><p class="normal"><b>Bloch:</b> I think a good automated unit test of the mutex facility could have saved me from this particular agony, but keep in mind that this was in the early '90s. It never even occurred to me to blame the engineer involved for not writing good enough unit tests. Even today, writing unit tests for concurrency utilities is an art form.</p>
<p class="normal"><b>Seibel：</b>我们之前谈到了单步执行代码，但是您实际使用的调试工具是什么？</p><p class="normal"><b>Seibel:</b> We talked a bit before about stepping through code, but what are the actual tools you use for debugging?</p>
<p class="normal"><b>布洛赫：</b>我听起来有点像尼安德特人，但对我来说最重要的工具仍然是我的眼睛和大脑。我打印出所有涉及的代码并非常仔细地阅读它。</p><p class="normal"><b>Bloch:</b> I'm going to come out sounding a bit Neanderthal, but the most important tools for me are still my eyes and my brain. I print out all the code involved and read it very carefully.</p>
<p class="normal"><a id="OEBPS/Chapter05.html.page_190"></a>调试器很好，有时我会使用<code>print</code>语句，但使用断点。所以是的，我偶尔会使用调试器，但没有它们我也不会感到迷茫。只要我能<code>print</code>在代码中加入语句，并且能够彻底阅读它，我通常就能找到错误。</p><p class="normal"><a></a>Debuggers are nice and there are times when I would have used a <code>print</code> statement, but instead use a breakpoint. So yes, I use debuggers occasionally, but I don't feel lost without them, either. So long as I can put <code>print</code> statements in the code, and can read it thoroughly, I can usually find the bugs.</p>
<p class="normal">正如我所说，我使用断言来确保维护复杂的不变量。如果不变量被破坏，我想知道它发生的那一刻；我想知道是哪一组操作导致了腐败的发生。</p><p class="normal">As I said, I use assertions to make sure that complicated invariants are maintained. If invariants are corrupted, I want to know the instant it happens; I want to know what set of actions caused the corruption to take place.</p>
<p class="normal">这让我想起了另一个非常难以发现的错误。我对这个的记忆有点模糊；它要么发生在 Transarc，要么发生在我在 CMU 读研究生时，正在研究 Camelot 分布式事务系统。我不是发现这个的人，但它确实给我留下了深刻的印象。</p><p class="normal">That reminds me of another very difficult-to-find bug. My memory of this one is a bit hazy; either it happened at Transarc or when I was a grad student at CMU, working on the Camelot distributed transaction system. I wasn't the one who found this one, but it sure made an impression on me.</p>
<p class="normal">我们有一个允许代码发出调试信息的跟踪包。每个跟踪事件都标有发出它的线程的 ID。有时我们在日志中得到不正确的线程 ID，我们不知道为什么。我们只是决定我们可以忍受这个错误一段时间。这似乎是无害的。</p><p class="normal">We had a trace package that allowed code to emit debugging information. Each trace event was tagged with the ID of the thread that emitted it. Occasionally we were getting incorrect thread IDs in the logs, and we had no idea why. We just decided that we could live with the bug for a while. It seemed innocuous enough.</p>
<p class="normal">事实证明，这个错误根本不在 trace 包中：它要严重得多。为了找到线程 ID，trace 包调用了 threading 包。为了获得线程 ID，threading 包使用了一个当时相当普遍的技巧：它查看堆栈变量地址的一些高位。换句话说，它获取一个指向堆栈变量的指针，将其向右移动固定距离，这就是线程 ID。这个技巧取决于每个线程都有一个固定大小的堆栈，其大小是众所周知的 2 的幂。</p><p class="normal">It turned out that the bug wasn't in the trace package at all: it was much more serious. To find the thread ID, the trace package called into the threading package. To get the thread ID, the threading package used a trick that was fairly common at the time: it looked at some high-order bits of the address of a stack variable. In other words, it took a pointer to a stack variable, shifted it to the right by a fixed distance, and that was the thread ID. This trick depends on the fact that each thread has a fixed-size stack whose size is a well-known power of two.</p>
<p class="normal">看起来是一个合理的方法，对吧？除了那些一无所知的人在堆栈上创建对象，按照当时的标准，这些对象非常大。也许是 100 个元素的数组，每个元素的大小为 4k——所以你的线程堆栈上有 400k 的东西。您直接跳过堆栈的红色区域并进入下一个线程的堆栈。现在 thread-ID 方法错误地识别了线程。更糟糕的是，当线程访问线程局部变量时，它会获取下一个线程的值，因为线程 ID 被用作线程局部变量的键。</p><p class="normal">Seems like a reasonable approach, right? Except that people who didn't know any better were creating objects on the stack that were, by the standards of the day, very big. Perhaps arrays of 100 elements, each 4k in size—so you've got 400k slammed onto your thread stack. You jump right over the stack's red zone and into the next thread's stack. Now the thread-ID method misidentifies the thread. Worse, when the thread accesses thread-local variables, it gets the next thread's values, because the thread ID was used as the key to the thread-local variables.</p>
<p class="normal"><a id="OEBPS/Chapter05.html.page_191"></a>所以我们认为是跟踪系统中的一个小缺陷实际上是一个非常严重的错误的证据。当一个事件被归因于线程 43 而不是线程 42 时，这是因为线程 42 现在无意中冒充了线程 43，这可能会带来灾难性的后果。</p><p class="normal"><a></a>So what we took to be a minor flaw in the tracing system was actually evidence of a really serious bug. When an event was attributed to thread-43 instead of thread-42, it was because thread-42 was now unintentionally impersonating thread-43, with potentially disastrous consequences.</p>
<p class="normal">这是为什么需要安全语言的示例。这不是任何人都应该应对的事情。我最近在一所大学与某人交谈，他问我对他的大学想要先教授 C 和 C++ 然后再教授 Java 这一事实有何看法，因为他们认为程序员应该“一直深入”地了解系统。</p><p class="normal">This is an example of why you need safe languages. This is just not something that anyone should ever have to cope with. I was talking to someone recently at a university who asked me what I thought about the fact that his university wanted to teach C and C++ first and then Java, because they thought that programmers should understand the system “all the way down.”</p>
<p class="normal">我觉得前提是对的，结论是错的。是的，学生应该学习低级语言。事实上，他们应该学习汇编语言，甚至芯片架构。尽管芯片已经变成了这些令人难以置信的复杂野兽，但由于它们是如此复杂的状态机，甚至芯片也不再具有良好的性能模型。但是，如果他们了解系统较低层中正在发生的事情，他们将成为更好的高级语言程序员。</p><p class="normal">I think the premise is right but the conclusion is wrong. Yes, students should learn low-level languages. In fact, they should learn assembly language, and even chip architecture. Though chips have turned into to these unbelievable complicated beasts where even the chips don't have good performance models anymore because of the fact that they are such complicated state machines. But they'll be much better high-level language programmers if they understand what's going on in the lower layers of the system.</p>
<p class="normal">所以是的，我认为学习所有这些东西很重要。但是我认为你应该从像 C 这样的低级语言开始吗？不！学生在第一次接触编程时不必处理缓冲区溢出、手动内存分配等问题。</p><p class="normal">So yes, I think it's important that you learn all this stuff. But do I think you should start with a low-level language like C? No! Students should not have to deal with buffer overruns, manual memory allocation, and the like in their first exposure to programming.</p>
<p class="normal">James Gosling 在谈到 Java 的诞生时曾对我说，“偶尔你会按下重启按钮。这是可能发生的最奇妙的事情之一。” 通常，您必须保持与已有数十年历史的东西的兼容性；很少，你不会，当这种情况发生时它很棒。但不幸的是，正如您在 Java 中看到的那样，您只需要十年时间就可以解决问题。</p><p class="normal">James Gosling once said to me, discussing the birth of Java, “Occasionally you get to hit the reset button. That's one of the most marvelous things that can happen.” Usually, you have to maintain compatibility with stuff that's decades old; rarely, you don't, and it's great when that happens. But unfortunately, as you can see with Java, it only takes you a decade until you're the problem.</p>
<p class="normal"><b>Seibel：</b>既然你这么说，Java 是不是有点落伍了？它变得更复杂的速度是否比变得更好的速度更快？</p><p class="normal"><b>Seibel:</b> Since you say that, is Java off in the weeds a little bit? Is it getting more complex faster than it's getting better?</p>
<p class="normal"><b>布洛赫：</b>这是一个非常困难的问题。特别是，Java 5 的变化增加了比我们预期的更多的复杂性。我不了解泛型的复杂性，尤其是通配符<a id="OEBPS/Chapter05.html.page_192"></a>将添加到语言中。我必须在应得的荣誉上给予荣誉——格雷厄姆·汉密尔顿当时确实明白这一点，而我却不明白。</p><p class="normal"><b>Bloch:</b> That's a very difficult question. In particular, the Java 5 changes added far more complexity than we ever intended. I had no understanding of just how much complexity generics and, in particular, wildcards were <a></a>going to add to the language. I have to give credit where credit is due—Graham Hamilton did understand this at the time and I didn't.</p>
<p class="normal">有趣的是，他多年来一直反对它，试图将泛型排除在语言之外。但是，在成功地将泛型排除在 Java 之外的那些年里，变体的概念——通配符背后的想法——开始流行起来。如果他们早点进来，没有差异，我们今天可能会有一种更简单、更易处理的语言。</p><p class="normal">The funny thing is, he fought against it for years, trying to keep generics out of the language. But the notion of variance—the idea behind wildcards—came into fashion during the years when generics were successfully being kept out of Java. If they had gone in earlier, without variance, we might have had a simpler, more tractable language today.</p>
<p class="normal">也就是说，通配符有真正的好处。子类型化和泛型之间存在基本的阻抗不匹配，而通配符在纠正不匹配方面大有帮助。但是在复杂性方面付出了巨大的代价。有些人认为声明站点而不是使用站点变体是更好的解决方案，但我不太确定。</p><p class="normal">That said, there are real benefits to wildcards. There's a fundamental impedance mismatch between subtyping and generics, and wildcards go a long way towards rectifying the mismatch. But at a significant cost in terms of complexity. There are some people who believe that declaration-site, as opposed to use-site, variance is a better solution, but I'm not so sure.</p>
<p class="normal">陪审团基本上对任何未经大量程序员在现实条件下测试过的东西都没有意见。通常语言只在某些小众市场取得成功，人们会说，“哦，它们很棒，很遗憾它们没有成为世界上成功的语言。” 但通常有他们没有这样做的原因。希望一些确实使用声明站点变体的语言，如 Scala 或 C# 4.0，将一劳永逸地回答这个问题。</p><p class="normal">The jury is basically still out on anything that hasn't been tested by a huge quantity of programmers under real-world conditions. Often languages only succeed in some niche and people say, “Oh, they're great and it's such a pity they didn't become the successful language in the world.” But often there are reasons they didn't. Hopefully some language that does use declaration-site variance, like Scala or C# 4.0, will answer this question once and for all.</p>
<p class="normal"><b>Seibel：</b>那么添加仿制药的动力是什么？</p><p class="normal"><b>Seibel:</b> So what was the impetus for adding generics?</p>
<p class="normal"><b>布洛赫：</b>对于事实证明不如看上去那么美妙的想法，情况总是如此，那就是相信我们自己的新闻稿。我的心智模型是，“嘿，集合几乎都是同类的——一个字符串列表，一个从字符串到整数的映射，或者其他什么。然而，默认情况下它们是异构的：它们都是对象的集合，你必须在出路时进行转换，这是无稽之谈。” 如果我可以告诉系统这是一个从字符串到整数的映射并且它会为我进行转换并且当我试图做错事情时它会在编译时捕获它，那不是更好吗？它可以捕捉到更多的错误——它会有更高级别的信息，这听起来是件好事。</p><p class="normal"><b>Bloch:</b> As is always the case for ideas that prove less wonderful than they seemed, it was believing our own press sheets. My mental model was, “Hey, collections are almost all homogeneous—a list of strings, a map from string to integer, or whatever. Yet by default they are heterogeneous: they're all collections of objects and you have to cast on the way out and that's nonsense.” Wouldn't it be much better if I could tell the system that this is a map from strings to integers and it would do the casting for me and it would catch it at compile time when I tried to do something wrong? It could catch more errors—it would have higher-level-type information and that sounds like a good thing.</p>
<p class="normal">我想到泛型的方式与我想到我们在 Java 5 中添加的许多其他语言特性的方式相同——我们只是让语言为我们做我们以前必须手动做的事情。在某些情况下，我完全明白：<code>for-each</code>循环很棒。它所做的只是隐藏了<a id="OEBPS/Chapter05.html.page_193"></a>迭代器或您的索引变量。代码更短，概念表面积也没有变大。从某种意义上说，它甚至更小，因为我们在数组和其他集合之间创建了这种假多态性，因此您可以遍历 ArrayList 或数组，而不知道或不关心您在遍历哪个。</p><p class="normal">I thought of generics in the same way I thought about many of the other language features we added in Java 5—we were simply getting the language to do for us what we had to do manually before. In some cases I was dead on: the <code>for-each</code> loop is just great. All it does is hide the complexity of the <a></a>iterators or the index variables from you. The code is shorter and the conceptual surface area is no larger. In a sense, it's even smaller because we've created this false polymorphism between arrays and other collections so you can iterate over an ArrayList or an array and not know or care which you're iterating over.</p>
<p class="normal">这种想法不适用于泛型的主要原因是它们代表了对已经很复杂的类型系统的主要补充。类型系统很微妙，修改它们会对整个语言产生深远且不可预测的影响。</p><p class="normal">The main reason this thinking didn't apply to generics is that they represent a major addition to an already complex type system. Type systems are delicate, and modifying them can have far-reaching and unpredictable effects throughout the language.</p>
<p class="normal">我认为这里的教训是，当你正在发展一种成熟的语言时，你必须比以往任何时候都更加意识到功率与复杂性之间的权衡。问题是，复杂性至少是语言特征数量的二次方。当您向旧语言添加功能时，您通常会添加很多复杂性。当一种语言已经达到或接近程序员理解它的能力时，你就不能在不破坏它的情况下再增加它的复杂性。</p><p class="normal">I think the lesson here is, when you are evolving a mature language you have to be even more conscious than ever of the power-versus-complexity trade-off. And the thing is, the complexity is at least quadratic in the number of features in a language. When you add a feature to an old language you're often adding a hell of a lot of complexity. When a language is already at or approaching programmers' ability to understand it, you simply can't add any more complexity to it without breaking it.</p>
<p class="normal">如果你真的给它增加了复杂性，这种语言会消失吗？不，不会的。我认为 C++ 已经远远超出了它的复杂性门槛，但仍有很多人在为它编程。但是你所做的是强迫人们对其进行子集化。所以几乎我所知道的每家使用 C++ 的商店都说，“是的，我们正在使用 C++，但我们没有进行多重实现继承，我们也没有使用运算符重载。” 只有一堆功能您不会使用，因为生成的代码的复杂性太高了。当你必须开始这样做时，我认为这不是一件好事。你失去了程序员的可移植性，每个人都可以阅读其他人的代码，我认为这是一件好事。</p><p class="normal">And if you do add complexity to it, will the language simply disappear? No, it won't. I think C++ was pushed well beyond its complexity threshold and yet there are a lot of people programming it. But what you do is you force people to subset it. So almost every shop that I know of that uses C++ says, “Yes, we're using C++ but we're not doing multiple-implementation inheritance and we're not using operator overloading.” There are just a bunch of features that you're not going to use because the complexity of the resulting code is too high. And I don't think it's good when you have to start doing that. You lose this programmer portability where everyone can read everyone else's code, which I think is such a good thing.</p>
<p class="normal"><b>Seibel：</b>如果您不考虑泛型，您觉得 Java 今天会更好吗？</p><p class="normal"><b>Seibel:</b> Do you feel like Java would be better off today if you had just left generics out?</p>
<p class="normal"><b>布洛赫：</b>我不知道。我还是喜欢泛型。泛型帮我在我的代码中找到错误。泛型让我把以前在注释中的东西放入编译器可以强制执行的代码中。另一方面，当我查看那些与参数化类型相关的疯狂错误消息时，当我查看泛型类型声明时，例如我为 Enum 编写的类声明<a id="OEBPS/Chapter05.html.page_194"></a><code>Enum&lt;E extends Enum&lt;E&gt;&gt;</code>—我认为很明显，仿制药设计还不够成熟，无法进入。</p><p class="normal"><b>Bloch:</b> I don't know. I still like generics. Generics find bugs in my code for me. Generics let me take things that used to be in comments and put them into the code where the compiler can enforce them. On the other hand, when I look at those crazy parameterized-type-related error messages, and when I look at generic type declarations like the one I wrote for Enum—class <a></a><code>Enum&lt;E extends Enum&lt;E&gt;&gt;</code>—I think it's clear that the generics design wasn't quite mature enough to go in.</p>
<p class="normal">在我们的职业中我们都是乐观主义者，否则我们将被迫自杀。所以我们说，“哦，是的，我们当然可以做到这一点。我们从 CLU 就知道了泛型。这是 25 年前的技术。” 这些天你听到同样的论点适用于关闭，除了它是 50 年的技术。“哦，这很容易；它根本不会给语言增加任何复杂性。”</p><p class="normal">We're all optimists in our profession or we'd be forced to shoot ourselves. So we say, “Oh, yeah, of course we can do this. We've known about generics since CLU. This is 25-year-old technology.” These days you hear the same argument applied to closures except it's 50-year-old technology. “Oh, it's easy; it doesn't add any complexity to the language at all.”</p>
<p class="normal">是的，确实如此。但我认为我们中的许多人都从我们使用仿制药的经验中吸取了教训。在您真正理解语言将对概念表面区域做什么之前，您不应该向语言添加任何东西——直到您可以提出令人信服的论据，证明工作的程序员将能够有效地使用新功能，并且它将使他们的生活得更好。</p><p class="normal">Hell yes, it does. But I think many of us have learned from our experience with generics. You shouldn't add something to a language until you really understand what it's going to do to the conceptual surface area—until you can make a convincing argument that working programmers will be able to use the new feature effectively, and that it will make their lives better.</p>
<p class="normal">如果你看看街上的人对仿制药的反应，我们当然应该做一些不同于我们所做的事情。这是否意味着我们根本不应该使用泛型？不，我不这么认为。我认为泛型实际上是好的。大多数集合是同质的，而不是异质的，因此处理同质集合应该很容易，这一基本论点是正确的。此外，铸造通常是一件坏事。强制转换可能会失败，而且强制转换不会让您的程序变得漂亮。所以我认为你应该能够说出它是什么类型的集合，然后它应该会自动为你强制执行。但这是否意味着您必须忍受我们今天所拥有的所有这些复杂性？不，我认为我们只是没有采取正确的措施。</p><p class="normal">If you look at how the man on the street has been reacting to generics, we certainly should have done something other than what we did. Does that mean we shouldn't have done generics at all? No, I don't think so. I think that generics are actually good. The fundamental argument that most collections are homogeneous, not heterogeneous, so it should be easy to deal with homogeneous collections is true. Furthermore casting is generally a bad thing. Casts can fail and casts don't make your program beautiful. So I think you should be able to say what kind of collection it is and then it should just automatically be enforced for you. But does that mean you have to suffer with all this complexity that we have today? No. I think we just didn't take the right cut at it.</p>
<p class="normal"><b>Seibel：</b>仿制药是否存在真正的用户压力？人们是否抱怨缺乏泛型阻碍了他们编写软件？</p><p class="normal"><b>Seibel:</b> Was there real user pressure for generics? Were people complaining that the lack of generics was stopping them from writing software?</p>
<p class="normal"><b>Bloch：</b>真正的工程师会抱怨缺乏泛型吗？我认为这个问题的不幸答案是，不，他们不是。我认为我放了一些东西是有罪的，因为它很整洁。而且因为感觉这是正确的事情。</p><p class="normal"><b>Bloch:</b> Were real engineers bitching about the lack of generics? I think the unfortunate answer to that question is, no, they weren't. I think I was guilty of putting in something because it was neat. And because it felt like the right thing to do.</p>
<p class="normal">也就是说，很多工程都是来自直觉。人们一直在告诉我投入<code>foreach</code>吗？不，他们也没有告诉我这样做。但我只知道这是正确的做法。我是对的——每个人都喜欢它。<a id="OEBPS/Chapter05.html.page_195"></a>但我认为在我们这个领域，在工程领域，一个很大的罪过就是做一些事情只是因为它很整洁，因为它是好的工程，无论如何。如果您不是在为真实用户（在本例中为 Java 程序员）解决实际问题，那么您不应该添加该功能。</p><p class="normal">That said, a lot of engineering is from the gut. Had people been telling me to put in <code>foreach</code>? No. They hadn't been telling me to do that either. But I just knew that it was the right thing to do. And I was right—everybody likes it. <a></a>But I think a big sin in our area, in engineering, is doing stuff just because it's neat, because it's good engineering, whatever. If you're not solving real problems for real users—in this case, Java programmers—then you shouldn't add the feature.</p>
<p class="normal">詹姆斯·高斯林 (James Gosling) 发表了一场精彩的演讲，名为“Java 的感觉”，他在演讲中说，在你放入任何东西之前，你需要三个真正的用途。你不会仅仅因为它很整洁就把它放进去。</p><p class="normal">There's this marvelous talk that James Gosling gave called “The Feel of Java,” in which he said you need three real uses before you put anything in. You don't put anything in just because it's neat.</p>
<p class="normal">但人们只是想把东西放进去。工程师是做什么的？他们写代码。如果他们正在写一个图书馆或写一门语言，他们想把他们的东西放进去。你需要一些存在，一些指导性的声音，给你一些可以很好地协同工作的东西，并在你的东西之间做出正确的权衡。 do 和 don't put in。因为对于任何给定的语言，你可以输入的东西比你应该输入的要多。这是否意味着任何这些东西都是坏的？不，它没有。这只是意味着你做出了选择，某些东西不应该混在一起。</p><p class="normal">But people just want to put stuff in. What do engineers do? They write code. And if they are writing a library or writing a language, they want to put their stuff in. You need some presence, some guiding voice, to give you something that works well together and has made the right set of trade-offs between what you do and don't put in. Because there's simply more stuff that you could put in than you should put in to any given language. Does that mean that any of this stuff is bad? No, it doesn't. It just means that you make your choices and certain things shouldn't be mixed.</p>
<p class="normal"><b>Seibel：</b>我正在阅读<i>Java Puzzlers</i>和<i>Effective Java</i>，令我震惊的是，对于一开始如此简单的语言来说，有很多奇怪的小角落。</p><p class="normal"><b>Seibel:</b> I was reading <i>Java Puzzlers</i> and <i>Effective Java</i> and it struck me that there are a lot of little weird corners for a language that started out so simple.</p>
<p class="normal"><b>Bloch：</b>确实有一些奇怪的角落，但这只是生活中的一个事实；所有语言都有。您还没有看过一本名为<i>C++ Puzzlers</i>的书。为什么不？</p><p class="normal"><b>Bloch:</b> There are weird corners, yes, but that's just a fact of life; all languages have them. You haven't seen a book called <i>C++ Puzzlers</i>. Why not?</p>
<p class="normal"><b>Seibel：</b>因为<i>都是</i>益智游戏。</p><p class="normal"><b>Seibel:</b> Because it's <i>all</i> puzzlers.</p>
<p class="normal"><b>布洛赫：</b>是的。它会占用一个架子。在 Java 中，益智游戏值得收藏，正是因为您将其视为一种简单的语言。每种语言都有其极端情况，而 Java 的极端情况很少，因此它们在大多数情况下都很有趣。</p><p class="normal"><b>Bloch:</b> Yep. It would take up a shelf. In Java, the puzzlers are worth collecting precisely because you think of it as a simple language. Every language has its corner cases and Java has few enough that they're for the most part fun and interesting.</p>
<p class="normal"><b>Seibel：</b>您是否从从事 Java 工作和思考其设计的过程中学到了关于编程的任何东西？</p><p class="normal"><b>Seibel:</b> Is there anything that you've learned about programming specifically from working on Java and thinking about its design?</p>
<p class="normal"><b>布洛赫：</b>我学到了很多东西。我了解到的一件事——我在“几乎所有的二进制搜索和合并排序都被破坏”博客文章中写到这一点——就是即使正确地编写小程序也非常困难。如果我们认为我们的程序是，通过和<a id="OEBPS/Chapter05.html.page_196"></a>大，没有虫子。他们不是。在大多数情况下，我们编写的程序没有足够的错误来近似完成我们希望它们完成的工作。</p><p class="normal"><b>Bloch:</b> I've learned an awful lot of things. One thing I've learned—I wrote about this in the “Nearly All Binary Searches and Mergesorts Are Broken” blog entry—is that even writing small programs correctly is incredibly difficult. We're just fooling ourselves if we think our programs are, by and <a></a>large, free of bugs. They're not. For the most part, we've written programs that are free enough of bugs to approximate the jobs that we want them to do.</p>
<p class="normal">我了解到，鉴于编写正确的程序有多么困难，我们需要我们能得到的所有帮助。因此，任何能够从我们的盘子中去除潜在错误的东西都是好的。这就是为什么我非常相信静态类型和静态分析 — 任何可以从我们的盘子中消除某类错误的可能性的东西都是非常好的东西。任何能让我们作为程序员的工作变得更轻松的事情都是好事。</p><p class="normal">I learned that, given how hard it is to write correct programs, we need all the help we can get. So anything that removes potential bugs from our plate is good. That's why I'm very much a believer in static typing and in static analysis—anything that can remove the possibility of a certain class of bugs from our plate is a very good thing. Anything that can make our jobs as programmers easier is a good thing.</p>
<p class="normal">我更加坚信良好的 API 文档的重要性。Javadoc 是该平台成功的一个鲜为人知的原因。良好的 API 文档一直是 Java 文化的一部分，我相信这是因为 Javadoc 从一开始就存在。</p><p class="normal">My belief in the importance of good API documentation has been reinforced. Javadoc is one of the lesser-appreciated reasons for the success of the platform. Good API documentation has always been a part of Java's culture, and I believe it's because Javadoc has been there from day one.</p>
<p class="normal">我自然而然地相信简单就是好的倾向得到了加强。我一次又一次地看到更复杂的添加物证明它们在长期或短期内都是有害的。当我设计东西时，我会密切关注我的“复杂度计”：当它开始进入红色区域时，就该重新设计东西了。</p><p class="normal">My natural tendency to believe that simple is good has been reinforced. Over and over I see additions that are more complex proving themselves to be detrimental in the long—or short—run. When I'm designing stuff, I pay close attention to my “complexity meter:” when it starts bumping into the red zone, it's time to redesign stuff.</p>
<p class="normal">我偶尔会遇到一些根本不相信的人，他们只是说，“好吧，你很蠢，乔希，你就是不明白；这是正确的做法，如果你不明白，我很抱歉。” 我只是不买那个。我认为，如果事情开始变得复杂，则可能是它们出了问题，可能是时候开始寻找一种更简单的方法来做到这一点了。</p><p class="normal">I've occasionally run into people who just don't believe that, who just say, “Well, you're stupid, Josh, you just don't get it; this is the right way to do it and I'm sorry if you don't understand it.” I just don't buy that. I think that if things start getting complicated, there's probably something wrong with them and it's probably time to start looking for an easier way to do it.</p>
<p class="normal">托尼·霍尔 (Tony Hoare) 在他的图灵奖演讲中有一段精彩的引述，关于如何设计系统有两种方法：“一种方法是让它变得如此简单，以至于<i>显然</i>没有缺陷，另一种方法是让它变得如此复杂，以至于有没有<i>明显</i>的缺陷。”</p><p class="normal">There's a brilliant quote by Tony Hoare in his Turing Award speech about how there are two ways to design a system: “One way is to make it so simple that there are <i>obviously</i> no deficiencies and the other way is to make it so complicated that there are no <i>obvious</i> deficiencies.”</p>
<p class="normal">接下来的段落同样精彩，尽管它并不那么广为人知：“第一种方法要困难得多。它需要与发现复杂自然现象背后的简单物理定律相同的技能、奉献精神、洞察力，甚至灵感。它还需要愿意接受受物理、逻辑和技术限制的目标，并在发生冲突时接受妥协<a id="OEBPS/Chapter05.html.page_197"></a>无法实现目标。除非为时已晚，否则任何委员会都不会这样做。”</p><p class="normal">The paragraph that follows is equally brilliant, though it isn't as well-known: “The first method is far more difficult. It demands the same skill, devotion, insight, and even inspiration as the discovery of the simple physical laws which underlie the complex phenomena of nature. It also requires a willingness to accept objectives which are limited by physical, logical, and technological constraints, and to accept a compromise when conflicting <a></a>objectives cannot be met. No committee will ever do this until it is too late.”</p>
<p class="normal"><b>Seibel：</b>您认为您会在职业生涯中再次改变您的主要语言，还是您认为您会一直使用 Java 直到退休？</p><p class="normal"><b>Seibel:</b> Do you expect that you will change your primary language again in your career or do you think you'll be doing Java until you retire?</p>
<p class="normal"><b>布洛赫：</b>我不知道。我有点从 C 转向 Java。从我离开研究生院到 1996 年，我几乎完全使用 C 编程，然后直到现在一直使用 Java。我当然可以看到在某些情况下我会更改为另一种编程语言。但我不知道那种语言会是什么。我认为它可能还不存在。我认为世界对于一种新的编程语言来说已经成熟，但我也认为现在平台的惯性比过去高得多。现代平台不仅仅是一种语言和几个库；它有大量的工具，一个虚拟机——这是一个巨大的东西。创建一个全新平台的前景比以往任何时候都更加令人生畏。</p><p class="normal"><b>Bloch:</b> I don't know. I sort of turned on a dime from C to Java. I programmed in C pretty much exclusively from the time I left grad school until 1996, and then Java exclusively until now. I could certainly see some circumstance under which I would change to another programming language. But I don't know what that language would be. I think it may not exist yet. I think the world is ripe for a new programming language but I also think that the inertia of a platform is so much higher now than it used to be. A modern platform isn't just a language and a few libraries; it's got loads of tools, a virtual machine—it's an enormous thing. The prospect of creating an entire new platform is much more daunting than it ever was before.</p>
<p class="normal">我不知道接下来会发生什么。但我想，如果改变我的主要语言是正确的做法，我仍然可以做到。我想对这种可能性保持开放的心态。我想更多地使用其他语言。我最近没有时间这样做，但我想花时间。</p><p class="normal">I don't know what's coming next. But I'd like to think that if changing my primary language was the correct thing to do, I could still do it. I want to keep my mind open to the possibility. I want to play around more with other languages. I haven't had the time to do that recently, but I want to take the time.</p>
<p class="normal"><b>Seibel：</b>你最想和谁一起玩的短名单是什么？</p><p class="normal"><b>Seibel:</b> What's your short list of ones you want to play with more?</p>
<p class="normal"><b>Bloch：</b>我想试试 Scala，尽管我对它是否会成为下一件大事有些怀疑。我非常尊重 Martin Odersky。我认为这门语言中有很多巧妙的想法。但我也认为它可能太复杂，太面向学术界，无法在整个世界取得成功。不过，我没有权利这么说，因为我还没有学会。</p><p class="normal"><b>Bloch:</b> I want to try Scala, though I have some doubts as to whether it will be the next big thing. I have great respect for Martin Odersky. I think there are a bunch of neat ideas in the language. But I also think it may be too complex and too oriented towards academics to succeed in the world at large. I have no right to say that, though, because I haven't learned it yet.</p>
<p class="normal">我也应该玩 Python。我想玩的一个真正的老东西是 Scheme。我认为花几个月的时间和我儿子一起学习<i>计算机程序的结构和解释会很有趣。</i>每个人都说这是一本很棒的书。我买了它——这是第一步。但这需要一段时间才能完成。我想这就是我目前的候选名单。</p><p class="normal">I should also play with Python. A real old one I want to play with is Scheme. I think that it would be fun to just take a couple of months and work my way through <i>Structure and Interpretation of Computer Programs</i> with my son. Everybody says it's such a great book. I bought it—that's the first step. But it'll take a while to do. I guess that's my current short list.</p>
<p class="normal"><b>Seibel：</b>现在很多人都在担心我们将如何编写充分利用即将到来的多核 CPU 的软件。<a id="OEBPS/Chapter05.html.page_198"></a>Java 是第一个为多线程提供内置机制的主流语言。您觉得 Java 的方法在多核世界中可行吗？</p><p class="normal"><b>Seibel:</b> These days lots of people are worrying about how we're going to write software that takes good advantage of the coming multicore CPUs. <a></a>Java is notable as the first mainstream language to provide built-in mechanisms for multithreading; do you feel like Java's approach is viable in a multicore world?</p>
<p class="normal"><b>布洛赫：</b>我要更进一步。我认为这是所有语言中最好的方法。这很有趣，因为现在谈论 Java 已死似乎很流行。基本上，我认为这是装腔作势。但我认为目前最好的现有多线程构建块是在 Java 中。我认为 Java 准备好复兴了。我并不是说这是我们未来 20 年的发展方向；这是处理这些多核的最佳方式。但我想到今天可用的东西，它在竞争中遥遥领先。</p><p class="normal"><b>Bloch:</b> I'm going to go one step further. I think it is the best approach of any language out there. It's funny because it seems very popular to talk about Java being dead now. I see it as histrionics, basically. But I think that right now the best existing multithreaded building blocks are in Java. I think Java is poised for a little resurgence. I'm not saying it is where we'll be headed for the next 20 years; that it is the best way to take care of these multicores. But I think of what's available today, it's head and shoulders above the competition.</p>
<p class="normal"><b>Seibel：</b>您认为与 Java 的竞争是什么？</p><p class="normal"><b>Seibel:</b> What do you see as the competition to Java?</p>
<p class="normal"><b>Bloch：</b>嗯，我在考虑 C++ 和 C#。</p><p class="normal"><b>Bloch:</b> Well, I'm thinking C++ and C#.</p>
<p class="normal"><b>Seibel：</b>像 Erlang 或软件事务内存这样的东西呢？</p><p class="normal"><b>Seibel:</b> What about things like Erlang or Software Transactional Memory?</p>
<p class="normal"><b>Bloch：</b>据我所知，STM 还没有以实用的形式存在于任何主流语言中。如果 STM 被证明物有所值，我怀疑它会在出现在其他地方的同时出现在 Java 中。</p><p class="normal"><b>Bloch:</b> So far as I know, STM doesn't yet exist in a practical form in any mainstream language. If STM proves to be worth its salt, I suspect it will appear in Java at about the same time it appears elsewhere.</p>
<p class="normal">Erlang 实现并发的方法是 actor，如果他们被证明是一个大赢家，他们也可以用多种语言来实现。如您所知，Odersky 和公司已经在 Scala 中实现了它们。我不相信 actor 最适合多核并行，但如果是的话，我怀疑有人会很快用 Java 实现它们。</p><p class="normal">Erlang's approach to concurrency is actors, and if they prove to be a big win, they can also be implemented in many languages. As you know, Odersky and company have already implemented them in Scala. I'm not convinced that actors are the best fit for multicore parallelism, but if they are, I suspect that someone will implement them in Java soon enough.</p>
<p class="normal"><b>Seibel：</b>因此，正如您所说，Java 提供了构建块，让您可以对操作系统提供的线程进行可移植访问，然后使用<code>java.util.concurrent</code>API 进行一些更高级别的构造。但与 Erlang 或 STM 之类的东西相比，它们仍然是相当低级的结构，不是吗？</p><p class="normal"><b>Seibel:</b> So Java provides, as you say, building blocks that let you get portable access to threads provided by the OS and then some higher-level constructs with the <code>java.util.concurrent</code> API. But they're still pretty low-level constructs compared to something like Erlang or STM, aren't they?</p>
<p class="normal"><b>布洛赫：</b>我不太确定。Java 的一些构建块是低级的，例如 AtomicInteger；有些是中级的，比如 CyclicBarrier；有些是高级的，比如 ConcurrentHashMap 和 ThreadPoolExecutor。我相信 STM 和 Actor 都能在 Java 的“并发性”中找到舒适的归宿<a id="OEBPS/Chapter05.html.page_199"></a>当人们相信他们会尽力而为时，“积木”方法。</p><p class="normal"><b>Bloch:</b> I'm not so sure. Some of Java's building blocks are low-level, like AtomicInteger; some are midlevel, like CyclicBarrier; and some are high-level, like ConcurrentHashMap and ThreadPoolExecutor. I believe that STM and actors could both find comfortable homes in Java's “concurrency <a></a>building blocks” approach when and if people are convinced that they pull their weight.</p>
<p class="normal">某种形式的事务内存在未来可能会变得很重要，可能会作为并发库设计者使用的构建块。但我不认为 STM 作为一种工具会成功，它可以让应用程序程序员不再担心锁并生活在一个线程不会相互干扰的美丽世界中。这是不会发生的。</p><p class="normal">Some form of transactional memory may become important in the future, perhaps as a building block for use by concurrency library designers. But I don't think STM will succeed as a tool that lets the application programmer stop worrying about locks and live in a beautiful world where threads don't interfere with one another. It's just not going to happen.</p>
<p class="normal">这有很多原因。这是我在交易系统中工作时学到的。当您尝试仅基于字节级别的读写进行自动锁定或乐观并发控制时，您最终会遇到线程之间的“错误争用”：您有与逻辑冲突不对应的物理冲突。如果您被迫考虑要获取哪些锁，您可以尽最大努力确保您不会获取超出强制逻辑冲突所需的任何锁。</p><p class="normal">There are a bunch of reasons for this. Here's one I learned when I worked in transaction systems. When you try to do automatic locking or optimistic concurrency control based merely on reading and writing at the byte level, you end up with “false contention” between threads: you have physical conflicts that don't correspond to logical conflicts. If you're forced to think about what locks to acquire, you can do your best to ensure that you don't acquire any locks beyond what is required to enforce logical conflicts.</p>
<p class="normal">因此，例如，如果您有两个线程，它们都在递增计数器，则应该允许它们并发进行。它们可能正在访问同一块内存，但从逻辑角度来看它们并不相互冲突。如果您有一个正在读取计数器的线程和一个正在递增它的线程，那么它们就会发生冲突。但是你可以让任意多个读者或任意多个增量器同时进行。这是迄今为止我所见过的任何系统都无法自行解决的事情。反例可能是人为的，但物理争用比逻辑争用更具限制性的情况并不少见。</p><p class="normal">So, for example, if you have two threads, both of which are incrementing a counter, they should be allowed to proceed concurrently. They may be accessing the same piece of memory but they're not conflicting with each other from a logical perspective. If you have one thread that's reading a counter and one that's incrementing it, they're in conflict. But you can have arbitrarily many readers or arbitrarily many incrementers proceeding concurrently. This is the sort of thing that no system that I've seen to date can figure out of its own accord. The counter example may be artificial, but it's not uncommon that physical contention is far more restrictive than logical contention.</p>
<p class="normal">STM 的另一个问题是在事务中不能进行各种操作。I/O 就是典型的例子。第三个问题是一些 STM 方案允许“注定的事务”查看处于不一致状态的内存，这可能会带来灾难性的后果。同样，这些是我们在构建通用分布式事务系统时努力解决的问题。他们有解决方案，但我所知道的所有解决方案都会增加复杂性或降低性能。</p><p class="normal">Another problem with STM is that there are all manner of operations that can't occur inside a transaction. I/O is the classic example. A third problem is that some STM schemes allow “doomed transactions” to view memory in inconsistent states, with potentially disastrous results. Again, these are problems that we struggled with back when we were building general-purpose distributed transaction systems. They have solutions, but all the solutions I know of add complexity or reduce performance.</p>
<p class="normal">无论如何，据我所知，STM 仍处于研究阶段。我认为人们正在进行这项研究很棒。但我根本不相信并发的灵丹妙药，至少在可预见的未来是这样。</p><p class="normal">Anyway, to the best of my knowledge, STM is still research. I think it's great that people are doing this research. But I simply don't believe in a silver bullet for concurrency, at least for the foreseeable future.</p>
<p class="normal"><a id="OEBPS/Chapter05.html.page_200"></a><b>Seibel：</b>好的，换个话题：你更喜欢如何与其他程序员一起工作？</p><p class="normal"><a></a><b>Seibel:</b> OK, different topic: how do you prefer to work with other programmers?</p>
<p class="normal"><b>布洛赫：</b>我其实很灵活。我喜欢“伙伴编程”，您可以在其中与其他人一起工作，但不是在同一个键盘上。您正在编写系统的不同部分——您来回交换代码。你们甚至不必在同一个半球。Doug Lea 和我多年来一直以这种方式广泛工作。我们中的一个人会写一个界面，另一个人会说，“这很好，但是这部分很糟糕，我改成这样了。”</p><p class="normal"><b>Bloch:</b> I'm actually quite flexible. I love “buddy programming” where you're working with someone else but not at the same keyboard. You're writing different parts of the system—you trade the code back and forth. You don't even have to be in the same hemisphere. Doug Lea and I have worked that way extensively over the years. One of us will write an interface and the other one will say, “Well this is great but this part sucks and I changed it this way.”</p>
<p class="normal">最终我们到达了一些我们喜欢的接口，我将实现非并发版本，他将实现并发版本，当我们这样做时，我们将找出我们做错的所有事情并再次破解接口. 我们会阅读彼此的代码，他会说，“好吧，你可以通过这种方式使它变得更快，”我会说，“你是对的，Doug，你可以。” 他非常擅长让事情进展得更快——他有点与 VM 交流。所以这是我非常喜欢的一种风格。这有助于远程协作。</p><p class="normal">Eventually we arrive at some interface that we like and I'll implement the nonconcurrent version and he'll implement the concurrent version and as we do that, we'll find out all the things that we did wrong and take another crack at the interface. And we'll read each other's code and he'll say, “Well, you can make this much faster this way,” and I'll say, “You're right, Doug, you can.” He's very good at making things go fast—he kind of communes with the VM. So that's one style that I like a lot. And that lends itself to remote collaborations.</p>
<p class="normal">我确实喜欢与某人坐在同一个终端上并编写代码，但我并没有以这种方式从头开始编写很多程序。通常是在代码审查的背景下，我会得到一些代码进行审查，并且会有很多更改，我会说，“我们为什么不一起坐在一台机器前，把它敲成形状？这有很多原因。我认为这是一种很好的教学方式，可以将知识从一代黑客传给下一代。</p><p class="normal">I do like sitting at the same terminal with someone and working on code, but I haven't written many programs that way from the ground up. Typically it's in the context of a code review where I'll get some code to review and there'll be a lot of changes and I'll say, “Why don't we just sit together at a machine and bash it into shape?” That's good for a whole bunch of reasons. I think it's a great way to teach, to pass knowledge down from one generation of hacker to the next.</p>
<p class="normal">我不喜欢完全孤立地工作。当我在写一个程序时，我做出了一个棘手的设计决定，我只需要向别人求助。在我工作过的每个地方，我都有一个或多个同事可以向我征求意见。这对我来说至关重要；我需要那个反馈。</p><p class="normal">I don't like working in total isolation. When I'm writing a program and I come to a tricky design decision, I just have to bounce it off someone else. At every place I've worked, I've had one or more colleagues I could bounce ideas off of. That's critically important for me; I need that feedback.</p>
<p class="normal"><b>Seibel：</b>那是为了获得反馈还是只是为了有机会讨论它？</p><p class="normal"><b>Seibel:</b> Is that for the feedback you get or just for the chance to talk it through?</p>
<p class="normal"><b>布洛赫：</b>两者都有。我们所做的事情有太多的技巧——通常情况下没有一个正确的解决方案，或者如果有，直到你已经<a id="OEBPS/Chapter05.html.page_201"></a>用过它。你必须从直觉出发，与持不同观点的人交谈会非常有帮助。</p><p class="normal"><b>Bloch:</b> Both. There's so much craft in what we do—it's often the case that there's no one right solution, or if there is, it's not apparent until you've <a></a>used it. You have to go from the gut and talking to someone with a different perspective can be very helpful.</p>
<p class="normal">我认识一些不这么认为的人——他们愿意在真空中编程。我认为这伤害了他们。你会更早地发现你的错误——你真的想在设计到达代码点之前很久就发现它的问题。因此，当你在与不同的方法或什至不同的功能较量时——我应该支持这个还是这个或者只是那个——你只需要从其他人那里反弹它。另一方面，你不能把每个人说的都当作福音，因为你会得到相互矛盾的意见，最终，你要对自己的工作负责。</p><p class="normal">I've known people who don't feel this way—who are willing to program in a vacuum. I think it hurts them. You will discover your bugs earlier—you really want to discover problems with a design long before it hits the point of code. So when you're wrestling with different approaches or even different features—should I support this and this or simply that—you just have to bounce it off other people. On the other hand, you can't take what each person says as gospel because you'll get conflicting opinions, and ultimately, you are responsible for your own work.</p>
<p class="normal"><b>Seibel：</b>这引发了另一个古老的问题——我认为 Weinberg 在70 年代<i>的计算机编程心理学中写过这个，而</i>今天的 XPers 也在谈论这个问题：代码应该由一个人“拥有”，而这个人是唯一一个曾经拥有的人接触它还是项目中的每个人都应该共同拥有所有代码以便任何人都可以摆弄任何东西？</p><p class="normal"><b>Seibel:</b> That raises another age-old question—I think Weinberg wrote about this in <i>The Psychology of Computer Programming</i> in the '70s and the XPers talk about it today: should code be “owned” by one person who is the only person who ever touches it or should everyone on a project collectively own all the code so anyone can fiddle with anything?</p>
<p class="normal"><b>Bloch：</b>我相信代码所有权是不可否认的。在某种程度上，这就像母性——你编写的代码诞生了，特别是如果它是大的、复杂的或原创的，它<i>就是</i>你的。如果您发现自己正在使用其他人的代码，请在修改他们的代码之前与他们交谈。特别是如果你认为它确实有问题，因为你可能错了。如果你破坏了别人的代码，那就不好了。</p><p class="normal"><b>Bloch:</b> I believe that code ownership can't be denied. In a way, it's like motherhood—you give birth to the code that you write, and especially if it's large, complex, or original, it <i>is</i> yours. If you find yourself working in someone else's code, talk to them before mucking with their code. Especially if you think there's something really wrong with it, because you might be wrong. If you break someone else's code, that's not nice.</p>
<p class="normal">当然，如果一段代码完全属于一个人，这对一个组织来说是不利的，因为如果那个人离开了组织，他们就会变得又高又干。因此，多人了解每段代码并能够对其进行处理非常重要。但我认为期望每个人都拥有所有代码是不现实的。</p><p class="normal">Of course, it's bad for an organization if a piece of code belongs to exactly one person because if that person leaves the organization, they're high and dry. So it's really important that multiple people learn about each piece of code and are able to work on it. But I think it's unrealistic to expect everyone to own all the code.</p>
<p class="normal">这也涉及到我们之前讨论的专业领域。真正能够编写位操作代码的人并不多，因此如果您发现自己正处于一些位操作代码的核心，您应该与公司中少数能够实际处理这些代码的人交谈，如果你不是其中之一。做这件事的人喜欢它，并且愿意花一整天的时间通过一条指令减少指令序列，或者证明一些可以加速计算的身份。但是很容易破坏一些东西。而且很容易写<a id="OEBPS/Chapter05.html.page_202"></a>比方说，对于 2 32 种可能的输入中的 2 <sup>32</sup>减<sup>1</sup>种效果很好。单元测试可能会也可能不会测试新解决方案不起作用的那个值。如果它没有，你打破了它，你就是山羊。<sup></sup></p><p class="normal">This also touches on what we were discussing earlier in terms of areas of expertise. There aren't that many people who can really write bit-twiddling code, so if you find yourself in the bowels of some code that's doing bit twiddling, you should talk to one of the few people at your company who can actually handle that stuff, if you're not one of them. People who do this stuff love it and are willing to spend whole days reducing an instruction sequence by one instruction or proving some identity that speeds up a computation. But it's so easy to break something. And it's so easy to write <a></a>something that, let's say, works well for 2<sup>32</sup> minus 1 of the 2<sup>32</sup> possible inputs. A unit test may or may not test that one value where your new solution doesn't work. And if it doesn't and you broke it, you're the goat.</p>
<p class="normal"><b>Seibel：</b>说到编写复杂的代码，我注意到那些太聪明的人，无论如何在某个维度上，都会写出最糟糕的代码。因为他们实际上可以把所有的东西都装进他们的脑子里，所以他们可以写出大量的意大利面条式代码。</p><p class="normal"><b>Seibel:</b> Speaking of writing intricate code, I've noticed that people who are too smart, in a certain dimension anyway, make the worst code. Because they can actually fit the whole thing in their head they can write these great reams of spaghetti code.</p>
<p class="normal"><b>布洛赫：</b>我同意你的看法，那些既足够聪明可以应对巨大复杂性又缺乏对我们其他人的同理心的人可能会成为这种情况的牺牲品。他们认为，“我能理解它，我能使用它，所以它一定是好的。”</p><p class="normal"><b>Bloch:</b> I agree with you that people who are both smart enough to cope with enormous complexity and lack empathy with the rest of us may fall prey to that. They think, “I can understand this and I can use it, so it has to be good.”</p>
<p class="normal"><b>Seibel：</b>编程中是否有某种内在的东西总是会吸引具有这种心态的人？</p><p class="normal"><b>Seibel:</b> Is there something intrinsic in programming that's always going to draw people with that kind of mentality?</p>
<p class="normal"><b>布洛赫：</b>当然。我们喜欢脑筋急转弯。但我们必须用我们正在为真实的人解决实际问题的知识来缓和这种爱。如果我们不这样做，我们基本上就是在打发时间。我认为我参与的第一家公司失败的部分原因是我们不明白我们所做的不是纯粹的工程。</p><p class="normal"><b>Bloch:</b> Absolutely. We love brainteasers. But we have to temper this love with the knowledge that we're solving real problems for real people. And if we don't do that we are, essentially, whacking off. I think that part of the failure of the first company that I was involved in was due to the fact that we didn't understand that what we were doing wasn't pure engineering.</p>
<p class="normal">我们并没有真正认为我们能做的最重要的事情就是为真正的客户解决真正的问题。一旦你看不到这一点以及你的客户是谁，你就死定了。但我确实认为它倾向于与那些被编程吸引的人发生冲突，他们是那些喜欢脑筋急转弯的人。但我认为你可以吃蛋糕也可以吃。在设计 API 时保持同理心基因，但随后，为了让它们运行得非常快，您可以自由地进入拼图宫殿。</p><p class="normal">We weren't really thinking that the most important thing we could do was solve real problems for real customers. The moment you lose sight of that and who your customers are, you're dead meat. But I do think that it tends to conflict with the sort of people who are attracted to programming, who are the people who love brainteasers. But I think you can have your cake and eat it too. Keep that empathy gene on when you're designing your APIs, but then, in order to make them run bloody fast, you can freely descend into the puzzle palace.</p>
<p class="normal">在设计和优化算法和数据结构（尤其是并发算法和数据结构）时，您将有很多机会解决脑筋急转弯。你必须能够以数学的精确度来思考非常复杂的东西，你必须能够想出创造性的方法来组合基元以达到预期的效果。</p><p class="normal">You'll have plenty of opportunity to solve brainteasers when designing and optimizing algorithms and data structures, especially concurrent ones. You have to be able to think with mathematical precision about stuff that is quite complex, and you have to be able to come up with creative ways of combining primitives to achieve the desired effect.</p>
<p class="normal"><a id="OEBPS/Chapter05.html.page_203"></a>但是你必须知道你可以并且应该在什么地方应用这种思维，以及它在什么地方只会产生一个无法维护或无法使用的系统。</p><p class="normal"><a></a>But you have to know where you can and should apply that kind of thinking and where it will just produce a system that is unmaintainable or unusable.</p>
<p class="normal"><b>Seibel：</b>进行这种编程的机会会消失吗？许多这种低级别的东西是在您正在使用的 VM 或您正在使用的并发库中实现的。所以对于很多人来说，编程就是将东西粘合在一起。</p><p class="normal"><b>Seibel:</b> Are the opportunities for doing that kind of programming going away? A lot of this low-level stuff is implemented in the VM that you're using or the concurrency libraries that you're using. So for a lot of people, anymore, programming is about gluing stuff together.</p>
<p class="normal"><b>布洛赫：</b>我完全同意。好吧，相对而言，它正在减少。必须这样做的程序员的百分比比以前少了很多。当你买了一台机器时，它甚至没有操作系统，更不用说编程语言或任何现成的应用程序了，是的，每个人都必须这样做。</p><p class="normal"><b>Bloch:</b> I totally agree. Well, in relative terms it's diminishing. The percentage of programmers who have to do this is way smaller than it used to be. Back when you bought a machine and it didn't even have an operating system on it, nevermind a programming language or any ready-written applications, yeah, everybody had to do that.</p>
<p class="normal">大多数程序员必须这样做的世界正在消失或消失。但从绝对意义上讲，对这类人的需求可能与以往一样多。我们既想吃蛋糕也想吃——我们想拥有安全语言的优势以及手动调整汇编代码的速度，所以我们需要人们编写这些虚拟机和这些垃圾收集器并设计这些芯片，这些芯片是它们本身基本上是软件作品，尽管是在硬件中实现的。</p><p class="normal">The world in which most programmers have to do this is vanishing or vanished. But in absolute terms there's probably as much need as there ever was for that sort of people. We want to have our cake and eat it too—we want to have the advantages of safe languages coupled with the speed of hand-tuned assembly code, so we need people to write these virtual machines and these garbage collectors and design these chips which are themselves basically works of software, albeit realized in hardware.</p>
<p class="normal">我认为喜欢做这些事情的人有很多工作机会，但我们必须谨慎地瞄准他们。我认为，如果你有纯粹的解谜者，你必须将他们与管理层结合起来，管理层可以确保他们将自己的技能用于组织的最大利益。</p><p class="normal">I think there's plenty of employment for people who like doing this stuff, but we have to carefully target them. I think if you have people who are pure puzzle solvers you have to couple them with management who can make sure that they are using their skills in the organization's best interests.</p>
<p class="normal">有一个问题，那就是，编程在很大程度上是一种知识精英统治，而这些人往往是组织中最聪明的人；因此，他们认为应该允许他们做出所有决定。但仅仅他们是组织中最聪明的人这一事实并不意味着他们应该做出所有决定，因为智力不是标量；它是一个矢量。如果你缺乏同理心或情商，那么你就不应该设计 API、GUI 或语言。</p><p class="normal">There's this problem, which is, programming is so much of an intellectual meritocracy and often these people are the smartest people in the organization; therefore they figure they should be allowed to make all the decisions. But merely the fact that they're the smartest people in the organization doesn't mean they should be making all the decisions, because intelligence is not a scalar quantity; it's a vector quantity. And if you lack empathy or emotional intelligence, then you shouldn't be designing APIs or GUIs or languages.</p>
<p class="normal">我们所做的是一种审美追求。它涉及工艺和数学，涉及人际交往能力和散文技巧——所有这些我们不一定认为是工程，但没有这些我不认为<a id="OEBPS/Chapter05.html.page_204"></a>认为你会成为一个非常好的工程师。所以我认为这只是我们必须提醒自己的事情。但我认为这是这个星球上最有趣的工作之一。我认为我们真的很幸运能够在这些技能带来这些工作的时候成长起来。我不知道我们几代人以前会做什么。</p><p class="normal">What we're doing is an aesthetic pursuit. It involves craftsmanship as well as mathematics and it involves people skills and prose skills—all of these things that we don't necessarily think of as engineering but without which I don't <a></a>think you'll ever be a really good engineer. So I think it's just something that we have to remind ourselves of. But I think it's one of the most fun jobs on the planet. I think we're really lucky to have grown up at the time that we did when these skills led to these jobs. I don't know what we would have been doing a few generations back.</p>
</div>
</div></div>
<div id="OEBPS/Chapter06.html"><div>

<div class="booksection">
<p></p>
<h2 class="chapnum"><a id="OEBPS/Chapter06.html.ch6"></a><a id="OEBPS/Chapter06.html.page_205"></a><img src="data:image/jpg;base64,/9j/4AAQSkZJRgABAgEASABIAAD/7QzmUGhvdG9zaG9wIDMuMAA4QklNA+0KUmVzb2x1dGlvbgAAAAAQAEgAAAABAAEASAAAAAEAAThCSU0EDRhGWCBHbG9iYWwgTGlnaHRpbmcgQW5nbGUAAAAABAAAAHg4QklNBBkSRlggR2xvYmFsIEFsdGl0dWRlAAAAAAQAAAAeOEJJTQPzC1ByaW50IEZsYWdzAAAACQAAAAAAAAAAAQA4QklNBAoOQ29weXJpZ2h0IEZsYWcAAAAAAQAAOEJJTScQFEphcGFuZXNlIFByaW50IEZsYWdzAAAAAAoAAQAAAAAAAAACOEJJTQP1F0NvbG9yIEhhbGZ0b25lIFNldHRpbmdzAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+BdDb2xvciBUcmFuc2ZlciBTZXR0aW5ncwAAAHAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAOEJJTQQAC0xheWVyIFN0YXRlAAAAAgABOEJJTQQCDExheWVyIEdyb3VwcwAAAAAEAAAAADhCSU0ECAZHdWlkZXMAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4NVVJMIG92ZXJyaWRlcwAAAAQAAAAAOEJJTQQaBlNsaWNlcwAAAAB1AAAABgAAAAAAAAAAAAAArwAAAPgAAAAKAFUAbgB0AGkAdABsAGUAZAAtADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAPgAAACvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhCSU0EERFJQ0MgVW50YWdnZWQgRmxhZwAAAAEBADhCSU0EFBdMYXllciBJRCBHZW5lcmF0b3IgQmFzZQAAAAQAAAACOEJJTQQMFU5ldyBXaW5kb3dzIFRodW1ibmFpbAAACQoAAAABAAAAcAAAAE8AAAFQAABnsAAACO4AGAAB/9j/4AAQSkZJRgABAgEASABI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" alt="图片"></h2><h2 class="chapnum"><a></a><a></a></h2>
<h2 class="chaptitle">乔·阿姆斯特朗</h2><h2 class="chaptitle">Joe Armstrong</h2>
<div class="sidebar">
<p class="normal"><i>Joe Armstrong 最出名的身份是编程语言 Erlang 和开放电信平台 (OTP) 的创建者，OTP 是一个用于构建 Erlang 应用程序的框架。</i></p><p class="normal"><i>Joe Armstrong is best known as the creator of the programming language Erlang and the Open Telecom Platform (OTP), a framework for building Erlang applications.</i></p>
<p class="normal"><i>在现代语言领域，Erlang 有点奇怪。它比许多流行语言既古老又年轻：Armstrong 于 1986 年开始研究它——比 Perl 出现早一年——但它仅作为商业产品提供，主要在爱立信内部使用，直到 1998 年作为开源软件发布，三个在 Java 和 Ruby 出现多年之后。它的根源在于逻辑编程语言 Prolog 而不是 Algol 家族的某个成员。它是为一种相当特殊的软件设计的：高度可用、高度可靠的系统，如电话交换机。</i></p><p class="normal"><i>In the modern language landscape, Erlang is a bit of an odd duck. It is both older and younger than many popular languages: Armstrong started work on it in 1986—a year before Perl appeared—but it was available only as a commercial product and used primarily within Ericsson until it was released as open source in 1998, three years after Java and Ruby appeared. Its roots are in the logic programming language Prolog rather than some member of the Algol family. And it was designed for a fairly specific kind of software: highly available, highly reliable systems like telephone switches.</i></p>
<p class="normal"><i>但是，使它有利于构建电话交换机的特性也——而且几乎是无意中——使它非常适合编写并发软件，当程序员开始与多核未来的后果作斗争时，这一点引起了人们的注意。</i></p><p class="normal"><i>But the characteristics that made it good for building telephone switches also—and almost inadvertently—made it quite well suited to writing concurrent software, something which has drawn notice as programmers have started wrestling with the consequences of the multicore future.</i></p>
<p class="normal"><i>阿姆斯特朗也有点古怪。他最初是一名物理学家，后来在攻读物理学博士学位期间花光了钱，并在英国人工智能领域的创始人之一唐纳德·米奇 (Donald Michie) 找到了一份研究员的工作，转而从事计算机科学。在米奇的实验室，阿姆斯特朗被曝光<a id="OEBPS/Chapter06.html.page_206"></a>接触到各种 AI 产品，成为英国机器人协会的创始成员，并撰写有关机器人视觉的论文。</i></p><p class="normal"><i>Armstrong, too, is a bit of an odd duck. Originally a physicist, he switched to computer science when he ran out of money in the middle of his physics PhD and landed a job as a researcher working for Donald Michie—one of the founders of the field of artificial intelligence in Britain. At Michie's lab, Armstrong was exposed <a></a>to the full range of AI goodies, becoming a founding member of the British Robotics Association and writing papers about robotic vision.</i></p>
<p class="normal"><i>当 AI 的资金因著名的 Lighthill 报告而枯竭时，它又回到了物理相关的编程领域超过五年，首先是在 EISCAT 科学协会，后来是瑞典航天公司，最后加入爱立信计算机科学实验室，他发明了 Erlang。</i></p><p class="normal"><i>When funding for AI dried up as a result of the famous Lighthill report, it was back to physics-related programming for more than half a decade, first at the EISCAT scientific association and later the Swedish Space Corporation, before finally joining the Ericsson Computer Science Lab, where he invented Erlang.</i></p>
<p class="normal"><i>在斯德哥尔摩，我们在他厨房的桌子上进行了几天的交谈，其中，我们谈到了 Erlang 的并发方法、更好更简单的程序连接方式的需求，以及打开黑匣子的重要性。</i></p><p class="normal"><i>In our several days of conversation over his kitchen table in Stockholm, we talked about, among other things, the Erlang approach to concurrency, the need for better and simpler ways of connecting programs, and the importance of opening up black boxes.</i></p>
</div>
<p class="normal"><b>Seibel：</b>你是如何学习编程的？这一切是什么时候开始的？</p><p class="normal"><b>Seibel:</b> How did you learn to program? When did it all start?</p>
<p class="normal"><b>阿姆斯特朗：</b>在我上学的时候。我出生于 1950 年，所以那时没有多少计算机。学校的最后一年，我想我一定是 17 岁，地方议会有一台大型计算机——可能是 IBM。我们可以在上面写 Fortran。这是很平常的事情——你在编码表上写下你的程序，然后把它们发送出去。一周后，编码表和穿孔卡片回来了，你必须批准它们。但是制作穿孔卡片的人会犯错误。所以它可能会前后移动一两次。然后它最终会进入计算机中心。</p><p class="normal"><b>Armstrong:</b> When I was at school. I was born in 1950 so there weren't many computers around then. The final year of school, I suppose I must have been 17, the local council had a mainframe computer—probably an IBM. We could write Fortran on it. It was the usual thing—you wrote your programs on coding sheets and you sent them off. A week later the coding sheets and the punch cards came back and you had to approve them. But the people who made the punch cards would make mistakes. So it might go backwards and forwards one or two times. And then it would finally go to the computer center.</p>
<p class="normal">然后它去了计算机中心并返回，Fortran 编译器在程序中的第一个语法错误处停止。它甚至没有处理程序的其余部分。运行你的第一个程序大约需要三个月。然后我了解到，不是发送一个程序，而是必须并行开发每个子程序并发送批次。我想我写了一个小程序来显示棋盘——它会在打印机上绘制棋盘。但我不得不将所有子程序编写为并行任务，因为周转时间非常糟糕。</p><p class="normal">Then it went to the computer center and came back and the Fortran compiler had stopped at the first syntactic error in the program. It didn't even process the remainder of the program. It was something like three months to run your first program. I learned then, instead of sending one program you had to develop every single subroutine in parallel and send the lot. I think I wrote a little program to display a chess board—it would plot a chess board on the printer. But I had to write all the subroutines as parallel tasks because the turnaround time was so appallingly bad.</p>
<p class="normal"><b>Seibel：</b>所以你会写一个子程序，基本上是一个单元测试，这样你就会看到它实际上已经运行了？</p><p class="normal"><b>Seibel:</b> So you would write a subroutine with, basically, a unit test so you would see that it had, in fact, run?</p>
<p class="normal"><a id="OEBPS/Chapter06.html.page_207"></a><b>阿姆斯特朗：</b>是的。然后你会把它们放在一起。我不知道这是否算作学习编程。当我上大学时，我在伦敦大学学院的物理系。我想我们可能从第一年就开始编程了。然后你有三个小时左右的周转时间。但同样最好同时运行大约四到五个程序，这样你就可以很快地恢复它们。</p><p class="normal"><a></a><b>Armstrong:</b> Yes. And then you'd put it all together. I don't know if that counts as learning programming. When I went to university I was in the physics department at University College of London. I think we probably had programming from the first year. Then you had this turnaround of three hours or something. But again it was best to run about four or five programs at the same time so you got them back fairly quickly.</p>
<p class="normal"><b>Seibel：</b>在高中时，这是一门真正的学校课程吗？</p><p class="normal"><b>Seibel:</b> In high school, was it an actual school course?</p>
<p class="normal"><b>阿姆斯特朗：</b>那是一个课后课程——计算机俱乐部之类的。我们去看了电脑，我记得。许多穿着白大褂、口袋里插着钢笔的严肃老男人四处游荡，就像一座教堂。那是一台非常昂贵的电脑。</p><p class="normal"><b>Armstrong:</b> It was an after-hours course—computer club or something. We went to see the computer, I remember. Lots of serious-looking older men wearing white coats with pens stuck in their pockets wandering around, like, a church. It was a very expensive computer.</p>
<p class="normal"><b>Seibel：</b>你在学物理；你什么时候转向编程的？</p><p class="normal"><b>Seibel:</b> You were studying physics; when did you shift to programming?</p>
<p class="normal"><b>阿姆斯特朗：</b>嗯，作为一名本科生，一些课程涉及编写程序，我真的很喜欢。而且我必须非常擅长调试。如果一切都失败了，我会调试人们的程序。标准调试是一瓶啤酒。然后它会上升——两杯啤酒的问题或三杯啤酒的问题或类似的问题。</p><p class="normal"><b>Armstrong:</b> Well, as an undergraduate some of the courses involved writing programs and I really enjoyed that. And I got to be very good at debugging. If all else failed, I would debug people's programs. The standard debugging was one beer. Then it would go up—a two-beer problem or a three-beer problem or something like that.</p>
<p class="normal"><b>Seibel：那是指</b>当你调试他们的程序时，他们必须给你买多少啤酒？</p><p class="normal"><b>Seibel:</b> That was in terms of how many beers they had to buy you when you debugged their program?</p>
<p class="normal"><b>阿姆斯特朗：</b>是的，当我修复他们的程序时。我曾经阅读程序并思考，“他们为什么要这样写？这非常复杂，”我只是重写它们以简化它们。人们编写复杂的程序曾经让我觉得很奇怪。我可以在几行内看到如何做事，而他们已经写了几十行，我有点奇怪为什么他们看不到简单的方法。我很擅长那个。</p><p class="normal"><b>Armstrong:</b> Yeah, when I fixed their program. I used to read programs and think, “Why are they writing it this way; this is very complicated,” and I'd just rewrite them to simplify them. It used to strike me as strange that people wrote complicated programs. I could see how to do things in a few lines and they'd written tens of lines and I'd sort of wonder why they didn't see the simple way. I got quite good at that.</p>
<p class="normal">当我真正开始编程是在我完成了我的第一个学位之后，我决定要攻读博士学位。所以我开始攻读高能物理学博士学位，并加入了那里的气泡室小组，他们有一台电脑。DDP-516，霍尼韦尔 DDP-516。我可以自己使用它。它是穿孔卡片，但我可以在那里运行程序——我可以把它们放进去，然后按下一个按钮，<i>砰</i>的一声，出来了<a id="OEBPS/Chapter06.html.page_208"></a>立即回答。我玩得很开心。我为它写了一个小国际象棋程序。</p><p class="normal">When I really got to programming was after I finished my first degree and I decided I wanted to do a PhD. So I started to do a PhD in high-energy physics and joined the bubble chamber group there and they had a computer. A DDP-516, a Honeywell DDP-516. And I could use it all by myself. It was punched cards, but I could run the programs there—I could put them into the thing and press a button and <i>whoomp</i>, out came the <a></a>answer immediately. I had great fun with that. I wrote a little chess program for it.</p>
<p class="normal">这是真正的核心记忆由小老太太编织的时候，你可以看到核心——你可以看到这些小磁铁和电线进出。贵得吓人——它有一个 10MB 的磁盘驱动器，有 20 个盘片，重 15 公斤左右。它有一个图文电视界面——你可以在上面输入你的程序。</p><p class="normal">This was when real core memory was knitted by little old ladies and you could see the cores—you could see these little magnets and the wires went in and out. Frightfully expensive—it had something like a 10MB disk drive that had 20 platters and weighed 15 kilos or something. It had a teletext interface—you could type your programs in on that.</p>
<p class="normal">然后出现了这个“玻璃 TTY”，它是最早的视觉显示单元之一，你可以输入你的程序并进行编辑。我觉得这太棒了。没有更多的穿孔卡片。我记得与计算机管理员交谈时说，“你知道，总有一天每个人都会拥有这些。” 他说，“你疯了，乔。彻底疯了！” “为什么不？” “嗯，它们太贵了。”</p><p class="normal">And then came this “glass TTY” which was one of the first visual display units and you could type your programs in and edit them. I thought this was fantastic. No more punched cards. I remember talking to the computer manager and saying, “You know, one day everybody will have these.” And he said, “You're mad, Joe. Completely mad!” “Why not?” “Well, they're far too expensive.”</p>
<p class="normal">那真的是我学习编程的时候。我当时的导师，他说，“你不应该攻读物理学博士学位。你应该停下来做电脑，因为你喜欢电脑。” 我说，“不，不，不。我必须完成我正在做的这些事情。” 但实际上他是对的。</p><p class="normal">That was really when I learned to program. And my supervisor at the time, he said, “You shouldn't be doing a PhD in physics. You should stop and do computers because you love computers.” And I said, “No, no, no. I've to finish this stuff that I was doing.” But he was right, actually.</p>
<p class="normal"><b>Seibel：</b>你博士毕业了吗？</p><p class="normal"><b>Seibel:</b> Did you finish your PhD?</p>
<p class="normal"><b>阿姆斯特朗：</b>不，我没有，因为我没钱了。然后我去了爱丁堡。当我读物理的时候，我们经常去物理图书馆学习。而在物理图书馆的角落里，有这部分计算机科学书籍。还有这些棕色背景的书叫做<i>机器智能，</i>第 1、2、3 和 4 卷来自爱丁堡，来自那里的机器智能系。我本来应该学习物理的，但我急切地阅读这些东西并想，“哦，那真是太有趣了。” 于是我写信给爱丁堡机器智能系主任唐纳德米奇，说我对这种东西很感兴趣，他有没有工作。我收到一封回信说，好吧，他们目前没有，但他无论如何都想见我，看看我是什么样的人。</p><p class="normal"><b>Armstrong:</b> No, I didn't because I ran out of money. Then I went to Edinburgh. When I was reading physics we used to go and study in the physics library. And in the corner of the physics library there was this section of computer science books. And there were these brown-backed volumes called <i>Machine Intelligence,</i> Volumes 1, 2, 3, and 4, which came from Edinburgh, from the Department of Machine Intelligence there. I was supposed to be studying physics but I was eagerly reading these things and thought, “Oh, that's jolly good fun.” So I wrote to Donald Michie, who was the director of the Department of Machine Intelligence at Edinburgh, and said I was very interested in this kind of stuff and did he have any jobs. And I got back a letter that said, well, they didn't at the moment but he would like to meet me anyway, see what sort of person I was.</p>
<p class="normal">几个月后，我接到米奇的电话或信件，说：“下周二我会在伦敦；我们能碰面吗？我要坐火车去爱丁堡；你能来车站吗？” 我去了车站，遇到了 Michie，他说，<a id="OEBPS/Chapter06.html.page_209"></a>“嗯！好吧，我们不能在这里接受采访——好吧，我们会找一家酒吧。” 所以我们去了一家酒吧，我和 Michie 聊了聊，过了一会儿我收到了他的另一封信，他说，“爱丁堡有一份研究工作，你为什么不申请呢。” 所以我成为唐纳德·米奇的研究助理，去了爱丁堡。那是我在物理学和计算机科学之间的过渡。</p><p class="normal">Months later I got a phone call, or letter, from Michie, saying, “I'll be in London next Tuesday; can we meet? I'm getting the train to Edinburgh; can you come to the station?” I went to the station, met Michie, and he said, <a></a>“Hmmm! Well, we can't have an interview here—well, we'll find a pub.” So we went to a pub and I chatted to Michie and then a bit later I got another letter from him, he says, “There's a research job at Edinburgh, why don't you apply for it.” So I became Donald Michie's research assistant and went to Edinburgh. That was my transition between physics and computer science.</p>
<p class="normal">第二次世界大战期间，米奇曾在布莱切利公园与图灵一起工作，并获得了图灵的所有论文。我在图灵的图书馆里有一张桌子，所以我周围都是图灵的论文。所以我在爱丁堡待了一年。在那之后，爱丁堡有点崩溃，因为政府聘请了数学家詹姆斯·莱特希尔 (James Lighthill) 去爱丁堡研究人工智能。他回来说，“这个地方永远不会产生任何具有商业价值的东西。”</p><p class="normal">Michie had worked with Turing at Bletchley Park during the second World War and got all of Turing's papers. I had a desk in Turing's library, so all around me were Turing's papers. So I was a year at Edinburgh. After that Edinburgh kind of collapsed because James Lighthill, a mathematician, was hired by the government to go and investigate artificial intelligence at Edinburgh. And he came back and said, “Nothing of commercial value will ever come out of this place.”</p>
<p class="normal">这就像一个巨大的围栏之类的地方。我是英国机器人协会的创始成员，我们都认为这真的会产生巨大的影响。但是资助机构——机器人！这是什么东西？我们不会资助这个！所以我猜在 72 年左右有一段时间，所有的资金都枯竭了，每个人都说，“好吧，我们在这里玩得很开心；最好去做点别的事情。”</p><p class="normal">It was like one gigantic playpen kind of place. I was a founding member of the British Robotics Association and we all thought this was really going to have enormous relevance. But the funding agencies—Robotics! What's this stuff? We're not going to fund this! And so there was a period around '72, I guess, when all the funding dried up and everybody said, “Well, we had fun while we were here; better go and do something else.”</p>
<p class="normal">然后它又回到了物理学家。我来到瑞典，在 EISCAT 科学协会找到了一份物理学程序员的工作。我的老板来自 IBM，他比我年长，他想要一个规范，他会去实施它。我们曾经为此争论不休。他说，“这项工作的缺点是我们没有工作描述，也没有详细的规范。” 我说，“好吧，没有职位描述的工作是一份非常好的工作。因为那样你就可以随心所欲地塑造它。” 不管怎样，大约一年后他离开了，我得到了老板的工作，首席设计师。</p><p class="normal">Then it's back to being a physicist. I came to Sweden and I got a job as a physicist programmer for the EISCAT scientific association. My boss had come from IBM and he was older than me and he wanted a specification and he would go and implement it. We used to argue over this. He said, “What's bad about the job is we don't have a job description and we don't have a detailed specification.” And I said, “Well, a job with no job description is a really good job. Because then you can form it how you like.” Anyway, he left after about a year and I got the boss's job, the chief designer.</p>
<p class="normal">我为他们设计了一个系统，我想这就是您所说的应用程序操作系统——它是在常规操作系统之上运行的东西。到现在为止，计算机已经变得相当合理了。我们有挪威的 NORD-10 计算机——我认为它们是为了进入 PDP-11 市场。</p><p class="normal">I designed a system for them and that was what I suppose you'd call an application operating system—it's something that runs on top of the regular operating system. By now computers were becoming quite reasonable. We had NORD-10 computers which were Norwegian—I think they were an attempt to get into the PDP-11 market.</p>
<p class="normal"><a id="OEBPS/Chapter06.html.page_210"></a>我在那里工作了将近四年。然后我在瑞典航天公司找到了一份工作，并构建了另一个应用程序操作系统来控制瑞典的第一颗卫星，这颗卫星被称为<i>Viking</i>。那是一个有趣的项目——我忘记了计算机的名称，但它是 Amdahl 计算机的克隆。它仍然只有行编辑。它没有全屏编辑器。你所有的程序都必须在一个目录中。十个字母作为文件名，三个字母作为扩展名。还有一个 Fortran 编译器或汇编器，仅此而已。</p><p class="normal"><a></a>I worked there for almost four years. Then I got a job for the Swedish Space Corporation and built yet another application operating system to control Sweden's first satellite, which was called <i>Viking</i>. That was a fun project—I've forgotten the name of the computer but it was a clone of the Amdahl computer. It still only had line editors. It didn't have full-screen editors. And all your programs had to be in one directory. Ten letters for the file name and three letters for the extension. And a Fortran compiler or assembler and that's it.</p>
<p class="normal">有趣的是，回想起来，我认为所有这些现代小发明实际上并没有让你更有效率。分层文件系统——它们如何提高您的工作效率？无论如何，大多数软件开发都在您的脑海中进行。我认为使用那个更简单的系统会强加一种有纪律的思维方式。如果您没有目录系统并且必须将所有文件放在一个目录中，那么您必须相当有纪律。如果您没有修订控制系统，则必须严格遵守纪律。鉴于您将这一纪律应用于您正在做的事情，在我看来，拥有分层文件系统和修订控制似乎并没有什么更好的。他们没有解决解决您问题的根本问题。它们可能使一群人更容易一起工作。</p><p class="normal">The funny thing is, thinking back, I don't think all these modern gizmos actually make you any more productive. Hierarchical file systems—how do they make you more productive? Most of software development goes on in your head anyway. I think having worked with that simpler system imposes a kind of disciplined way of thinking. If you haven't got a directory system and you have to put all the files in one directory, you have to be fairly disciplined. If you haven't got a revision control system, you have to be fairly disciplined. Given that you apply that discipline to what you're doing it doesn't seem to me to be any better to have hierarchical file systems and revision control. They don't solve the fundamental problem of solving your problem. They probably make it easier for groups of people to work together. For individuals I don't see any difference.</p>
<p class="normal">另外，我认为今天我们的选择有点不堪重负。我的意思是，我刚学过 Fortran。我认为我们甚至没有 shell 脚本。我们只有批处理文件，所以你可以运行东西、编译器和 Fortran。如果你真的需要它，可能还有汇编器。所以没有这种选择的痛苦。今天作为一名年轻的程序员一定很糟糕——你可以选择 20 种不同的编程语言、几十种框架和操作系统，但你却被选择所困。那时没有选择的麻痹。你只是开始做，因为关于哪种语言和事情的决定刚刚做出——没有考虑你应该做什么，你只是去做。</p><p class="normal">Also, I think today we're kind of overburdened by choice. I mean, I just had Fortran. I don't think we even had shell scripts. We just had batch files so you could run things, a compiler, and Fortran. And assembler possibly, if you really needed it. So there wasn't this agony of choice. Being a young programmer today must be awful—you can choose 20 different programming languages, dozens of framework and operating systems and you're paralyzed by choice. There was no paralysis of choice then. You just start doing it because the decision as to which language and things is just made—there's no thinking about what you should do, you just go and do it.</p>
<p class="normal"><b>Seibel：如今</b>的另一个不同之处在于，您无法再从上到下理解整个系统。因此，您不仅有很多选择要做，而且都是关于您想使用哪些黑匣子的，而不必完全了解它们的工作原理。</p><p class="normal"><b>Seibel:</b> Another difference these days is that you can no longer understand the whole system from top to bottom. So not only do you have lots of choices to make, they're all about which black boxes you want to use without necessarily fully understanding how they work.</p>
<p class="normal"><b>阿姆斯特朗：</b>是的——如果这些大黑匣子不能正常工作，你必须修改它们，我认为从头开始更容易<a id="OEBPS/Chapter06.html.page_211"></a>自己写一切。真正没有用的是软件重用。这太糟糕了。</p><p class="normal"><b>Armstrong:</b> Yeah—if these big black boxes don't work properly, and you have to modify them, I reckon it's easier just to start from scratch and just <a></a>write everything yourself. The thing that really hasn't worked is software reuse. It's appallingly bad.</p>
<p class="normal"><b>Seibel：</b>然而，您不仅是 Erlang 的架构师，还是应用程序框架（开放电信平台）的架构师。它可以重复使用吗？</p><p class="normal"><b>Seibel:</b> Yet you're the architect not only of Erlang but of an application framework, the Open Telecom Platform. Is it reusable?</p>
<p class="normal"><b>阿姆斯特朗：</b>在某种程度上它是可重复使用的。但是会出现同样的问题。如果那个框架确实解决了你的问题——如果一些对 OTP 设计标准一无所知的程序员在几年后看到它说，“哦，那太好了；” 这正是我想要做的，”然后就可以了，你就得到了这种可重用性的衡量标准。如果<i>不是</i>，那么你就有问题了。</p><p class="normal"><b>Armstrong:</b> To an extent it's reusable. But the same problem will occur. If that framework exactly solves your problem—if some programmer who doesn't know anything about the design criteria for OTP looks at it in a few years' time and says, “Oh, that's great; that's exactly what I want to do,” then it's fine and you get this measure of reusability. If it's <i>not</i>, then you have a problem.</p>
<p class="normal">最近我看到有人说，“这真的有点人为，我们正在扭曲代码以适应这个 OTP 框架。” 所以我说，“好吧，重写 OTP 框架。” 他们认为自己无法更改框架。但框架只是另一个程序。这真的很容易。我进入它然后它做他们想要的。他们看着它说，“是的，好吧，这很容易。” 他们承认这很容易。但他们说，“嗯，我们的项目管理人员不希望我们乱搞框架。” 好吧，那就给它起个不同的名字吧。</p><p class="normal">Fairly recently I've seen people say, “This is really kind of artificial, we're twisting the code to fit into this OTP framework.” So I say, “Well, rewrite the OTP framework.” They don't feel they can change the framework. But the framework's just another program. It's really rather easy. And I go into it and then it does what they want. They look at it and they say, “Yeah, well, that's easy.” They accept that it's easy. But they say, “Well, our project management doesn't want us messing around with the framework.” Well, give it a different name then or something.</p>
<p class="normal"><b>Seibel：</b>但是你认为真正打开所有这些黑匣子，看看里面，看看它们是如何工作的，然后决定如何根据自己的需要调整它们真的可行吗？</p><p class="normal"><b>Seibel:</b> But do you think it's really feasible to really open up all those black boxes, look inside, see how they work, and decide how to tweak them to one's own needs?</p>
<p class="normal"><b>阿姆斯特朗：</b>多年来，我犯了一个普遍性错误，普遍性错误就是没有打开黑匣子。心里想，这个黑匣子太难破了，太难了，我不打开它。我已经打开了一两个黑盒子：我想做一个窗口系统，一个 Erlang 的图形系统，我想，“好吧，让我们在 X Windows 上运行它吧。” 什么是 X 视窗？它是一个套接字，上面有一个协议。因此，您只需打开套接字并将这些消息喷射到其中即可。为什么需要图书馆？Erlang 是基于消息的。整个想法是你向事物发送信息，然后它们做事。好吧，这就是 X Windows 中的理念——你有一个窗口，向它发送一条消息，它就会做一些事情。如果您在窗口中执行某些操作，它会向您发回一条消息。所以这很像 Erlang。<i></i>然而，X Windows 是通过回调库——发生这种情况并调用它。这不是 Erlang 的思维方式。二郎之道<a id="OEBPS/Chapter06.html.page_212"></a>思考的方式是，向某事发送消息并做某事。所以，等一下，让我们去掉中间的所有这些库——让我们直接与套接字对话。</p><p class="normal"><b>Armstrong:</b> Over the years I've kind of made a generic mistake and the generic mistake is to not open the black box. To mentally think, this black box is so impenetrable and so difficult that I won't open it. I've opened up one or two black boxes: I wanted to do a windowing system, a graphics system for Erlang, and I thought, “Well, let's run this on X Windows.” What is X Windows? It's a socket with a protocol on top of it. So you just open the socket and squirt these messages down it. Why do you need libraries? Erlang is message based. The whole idea is you send messages to things and they do things. Well, that's the idea in X Windows—you've got a window, send it a message, it does something. If you do something in the window it sends you a message back. So that's very much like Erlang. The way of <i>programming</i> X Windows, however, is through callback libraries—this happens and call this. That's not the Erlang way of thinking. The Erlang way <a></a>of thinking is, send a message to something and do something. So, hang on, let's get rid of all these libraries in between—let's talk directly to the socket.</p>
<p class="normal">你猜怎么着？这真的很容易。X 协议有，我不知道，100 条消息，80 条消息等等。结果你只需要大约 20 个就可以做任何有用的事情。你只需将这 20 条消息映射到 Erlang 术语上，并施展一些魔法，然后你就可以开始直接向窗口发送消息，它们会做一些事情。而且它也很有效。它不是很漂亮，因为我没有在图形和艺术标准上投入太多精力——那里有很多工作可以让它看起来很漂亮。但实际上并不难。</p><p class="normal">And guess what? It's really easy. The X protocol's got, I don't know, 100 messages, 80 messages or something. Turns out you only need about 20 of them to do anything useful. And these 20 messages you just map onto Erlang terms and do a little bit of magic and then you can start sending messages to windows directly and they do things. And it's efficient as well. It's not very pretty because I haven't put much effort into graphics and artistic criteria—there's a lot of work there to make it look beautiful. But it's not actually difficult.</p>
<p class="normal">另一个是我做的这个排版系统，我开辟的抽象边界是Postscript。当你到达那个边界时，你会想，“我不想穿过边界”，因为在你想象的下面是非常复杂的。但同样，事实证明这很容易。它是一种编程语言。这是一种很好的编程语言。抽象边界很容易通过，一旦你通过了，就会有很多好处。</p><p class="normal">Another one is this typesetting system I did where the abstraction boundary I opened up is Postscript. As you get to that boundary you think, “I don't want to go through the boundary,” because what's underneath is—you imagine—enormously complicated. But again, it turns out to be very easy. It's a programming language. It's a good programming language. The abstraction boundary is easy to go through and once you've gone through, there's a lot of benefit.</p>
<p class="normal">对于我的 Erlang 书，我的出版商说：“我们有制作图表的工具。” 但我不喜欢图表工具的一点是，很难让箭头准确相交。你的手受伤了。我想，“编写一个吐出 Postscript 的程序，然后说，'我想要一个圆圈，箭头恰好在那里，'并使程序正确，所花的时间并不长。” 这需要几个小时。用程序制作图表所花费的时间与在所见即所得的东西中制作图表所花费的时间大致相同。只有两个好处。最后你的手不会受伤，甚至当你把这个东西放大到 10,000 倍时，箭头指向也完全正确。</p><p class="normal">For my Erlang book, my publisher said, “We've got tools to make diagrams.” But the thing I don't like about diagramming tools is it's really difficult to get an arrow to meet exactly. And your hand hurts. I thought, “The amount of time to write a program that spits out Postscript and then say, 'I want a circle there and the arrow goes exactly there,' and get the program right, isn't long.” It takes a few hours. Doing diagrams with programs takes about the same time as doing them in a WYSIWYG thing. Only there are two benefits. Your hand doesn't hurt at the end and even when you blow the thing up to a magnification of 10,000, the arrow points exactly right.</p>
<p class="normal">我不能说初学者程序员应该打开所有这些抽象。但我的意思是你当然应该考虑打开它们的可能性。没有完全拒绝这个想法。值得一看的是直接路由是否比打包路由更快。总的来说，我认为如果你购买软件，或者如果你使用其他人的软件，你必须考虑非常长的时间来定制它——它并没有完全按照你的要求做，它做了一些微妙的不同。而这种差异可能需要很长时间才能解决。</p><p class="normal">I can't say beginner programmers should open up all these abstractions. But what I am saying is you should certainly consider the possibility of opening them. Not completely reject the idea. It's worthwhile seeing if the direct route is quicker than the packaged route. In general I think if you buy software, or if you use other people's software, you have to reckon with an extremely long time to tailor it—it doesn't do exactly what you want, it does something subtly different. And that difference can take a very long time to solve.</p>
<p class="normal"><a id="OEBPS/Chapter06.html.page_213"></a><b>Seibel：</b>所以你一开始就说软件重用“非常糟糕”，但是打开每个黑盒子并摆弄它似乎并不像是朝着重用软件的方向发展。</p><p class="normal"><a></a><b>Seibel:</b> So you started out saying software reuse is “appallingly bad,” but opening up every black box and fiddling with it all hardly seems like movement toward reusing software.</p>
<p class="normal"><b>Armstrong：</b>我认为缺乏可重用性的是面向对象的语言，而不是函数式语言。因为面向对象语言的问题在于它们拥有随身携带的所有这些隐式环境。你想要一根香蕉，但你得到的是一只拿着香蕉和整个丛林的大猩猩。</p><p class="normal"><b>Armstrong:</b> I think the lack of reusability comes in object-oriented languages, not in functional languages. Because the problem with object-oriented languages is they've got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.</p>
<p class="normal">如果你有引用透明的代码，如果你有纯函数——所有的数据都在它的输入参数中，所有的东西都出来了，没有留下任何状态——它是难以置信的可重用性。您可以在这里、那里和任何地方重复使用它。当你想在不同的项目中使用它时，你只需将这段代码剪切并粘贴到你的新项目中。</p><p class="normal">If you have referentially transparent code, if you have pure functions—all the data comes in its input arguments and everything goes out and leaves no state behind—it's incredibly reusable. You can just reuse it here, there, and everywhere. When you want to use it in a different project, you just cut and paste this code into your new project.</p>
<p class="normal">程序员被骗去使用所有这些不同的编程语言，他们被骗到不使用简单的方法将程序连接在一起。Unix 管道机制——A 管道 B 管道 C——很容易将事物连接在一起。这就是程序员将事物连接在一起的方式吗？不。他们使用 API 并将它们链接到相同的内存空间，这非常困难并且不是跨语言的。如果语言属于同一个家族，那没关系——如果它们是命令式语言，那很好。但是假设一个是 Prolog，另一个是 C。他们对世界的看法完全不同，你如何处理内存。所以你不能像那样将它们链接在一起。你不能重复使用东西。一定有很大的商业利益，对他们来说，东西不能一起工作是非常可取的。它为顾问创造了数千个工作岗位。以及数以千计的工具来解决不应该存在的问题。几年前解决的问题。</p><p class="normal">Programmers have been conned into using all these different programming languages and they've been conned into not using easy ways to connect programs together. The Unix pipe mechanism—A pipe B pipe C—is trivially easy to connect things together. Is that how programmers connect things together? No. They use APIs and they link them into the same memory space, which is appallingly difficult and isn't cross-language. If the language is in the same family it's OK—if they're imperative languages, that's fine. But suppose one is Prolog and the other is C. They have a completely different view of the world, how you handle memory. So you can't just link them together like that. You can't reuse things. There must be big commercial interests for whom it is very desirable that stuff won't work together. It creates thousands of jobs for consultants. And thousands of tools to solve problems that shouldn't exist. Problems that were solved years ago.</p>
<p class="normal">我认为我们只有很少的编程语言来描述事物之间的交互，这真的很奇怪。我不断回到将事物粘合在一起的方式和描述协议的方式。我们没有办法在事物之间描述此协议：如果我向您发送其中一个，那么您向我发送其中一个。我们有描述数据包及其类型的方法，但我们有非常有限的描述协议的方法。</p><p class="normal">I think it's really weird that we have very few programming languages that describe the interaction between things. I keep coming back to ways of gluing things together and ways of describing protocols. We don't have ways of describing this protocol in between things: if I send you one of them then you send me one of these. We have ways of describing packets and their types but we have very restricted ways of describing the protocols.</p>
<p class="normal">编程与我们在现实世界中构建事物的方式有着根本的不同。假设您是一家汽车制造商。你买元件<a id="OEBPS/Chapter06.html.page_214"></a>来自分包商。你从 Lucas 那里买了一块电池，然后从某个地方买了一台发电机。你把东西栓在一起——你通过把东西并排放置来构造东西。您可以通过将砖块彼此堆叠并在其中安上门来盖<i>房子</i>。这就是我们制造芯片的方式。你得到一块基本上只提供这种连接的印刷电路板。但是你可以考虑在购买所有这些芯片时制造电子产品，然后用电线将其中一些的腿连接到其他的腿上。这就是你制造硬件的方式。但我们不做那样的软件。我们应该制作那样的软件，但我们没有。</p><p class="normal">Programming is fundamentally different to the way we construct things in the real world. Imagine you're a car manufacturer. You buy components <a></a>from subcontractors. You buy a battery from Lucas and you buy a generator from somewhere. And you bolt things together—you construct things by placing things next to each other. You build a house by putting the bricks on top of each other and putting the door <i>there</i>. That's how we make chips. You get a printed circuit board that basically just provides this connection. But you can think of making electronic things as you buy all these chips and you connect the legs of some to others with wires. And that's how you make hardware. But we don't make software like that. We should make software like that and we don't.</p>
<p class="normal">我们不这样做的原因与并发性有关。你看，这些芯片，当你把它们并排放置时，它们都是并行执行的。他们发送消息。它们基于这种消息传递编程范例，这是我所相信的。而这不是我们一起编写软件的方式。所以我认为 Erlang 可能采取的一个方向，或者我希望它采取的方向是组件方向。我还没有这样做，但我想制作一些图形前端来制作组件，我想通过将它们连接在一起来制作软件。数据流编程非常声明。没有顺序状态的概念。没有程序计数器翻过这个东西。就是这样。这是一个声明式模型，非常容易理解。我想念大多数编程语言中的这一点。</p><p class="normal">The reason we don't, has to do with concurrency. You see, the chips, when you put them next to each other, they all execute in parallel. And they send messages. They are based on this message-passing paradigm of programming, which is what I believe in. And that's not how we write software together. So I think one direction Erlang might take, or I would like it to take, is this component direction. I haven't done it yet, but I'd like to make some graphic front ends that make components and I'd like to make software by just connecting them together. Dataflow programming is very declarative. There's no notion of sequential state. There's no program counter flipping through this thing. It just is. It's a declarative model and it's very easy to understand. And I miss that in most programming languages.</p>
<p class="normal">这并不是说单个黑匣子里面的东西不是很复杂。以 grep 为例。从外面看——想象一个小正方形。输入是一个数据流，一个文件。你说<code>cat foo | grep</code>grep 有一些参数，它有一个必须匹配的正则表达式。好的。从 grep 出来的是所有匹配该正则表达式的行。现在，在感性层面上，了解 grep 的作用非常简单。它有一个输入，它是一个文件。它有一个输入，它是一个正则表达式。它的输出是一组与正则表达式匹配的行或行流。但这并不是说黑匣子里的算法很简单——它可能非常复杂。</p><p class="normal">That's not to say that what's inside an individual black box isn't very complicated. Take grep, for example. Seen from the outside—imagine a little square. The input is a stream of data, a file. You say <code>cat foo | grep</code> and grep has got some arguments, it's got a regular expression it's got to match. OK. And out of grep come all the lines that match that regular expression. Now, at a perceptual level, understanding what grep does is extremely simple. It has an input which is a file. It has an input which is a regular expression. It has an output which is a set of lines or a stream of lines that match the regular expression. But that is not to say that the algorithm inside the black box is simple—it could be exceedingly complicated.</p>
<p class="normal">黑匣子内部发生的事情可能非常复杂。但是将这些复杂的组件粘合在一起本身并不复杂。grep的使用一点也不复杂。我在系统架构中看不到的是这种明显的区别<a id="OEBPS/Chapter06.html.page_215"></a>在把东西粘在一起和盒子里东西的复杂性之间。</p><p class="normal">What's going on inside the black boxes can be exceedingly complicated. But gluing things together from these complicated components does not itself have to be complicated. The use of grep is not complicated in the slightest. And what I don't see in system architectures is this clear distinction <a></a>between the gluing things together and the complexity of the things inside the boxes.</p>
<p class="normal">当我们通过编程语言 API 将事物连接在一起时，我们并没有得到这种黑盒抽象。我们将它们放在同一个内存空间中。如果 grep 是一个在其 API 中公开例程的模块，并且您给它一个<code>char*</code>指向 this 的指针并且您必须 malloc 那个并且您是否深复制了这个字符串——我可以创建一个并行进程来执行此操作吗？然后它变得难以理解。我不明白为什么人们会以如此复杂的方式将事物联系在一起。他们应该以简单的方式将事物联系在一起。</p><p class="normal">When we connect things together through programming language APIs we're not getting this black box abstraction. We're putting them in the same memory space. If grep is a module that exposes routines in its API and you give it a <code>char*</code> pointer to this and you've got to malloc that and did you deep copy this string—can I create a parallel process that's doing this? Then it becomes appallingly complicated to understand. I don't understand why people connect things together in such complicated ways. They should connect things together in simple ways.</p>
<p class="normal"><b>Seibel：</b>将您现在对编程的看法与刚开始时的看法进行比较，您的想法最大的变化是什么？</p><p class="normal"><b>Seibel:</b> Comparing how you think about programming now with how you thought when you were starting out, what's the biggest change in your thinking?</p>
<p class="normal"><b>Armstrong：</b>我对编程的看法发生的重大变化与硬件无关。显然，它更快、更强大，但您的大脑比最好的软件工具强大一百万倍。我可以编写程序，然后在几天后突然说，“那个程序中有一个错误——如果发生这种情况，发生那种情况，发生这种情况，然后发生这种情况，那么它就会崩溃。” 然后我去查看代码——是的，我是对的。从来没有任何症状。现在你告诉我一个可以做那种事情的开发系统。所以作为程序员发生的变化，是我内心的变化。</p><p class="normal"><b>Armstrong:</b> The big changes in how I think about programming have nothing to do with the hardware. Obviously it's a lot faster and lot more powerful but your brain is a million times more powerful than the best software tools. I can write programs and then suddenly, days later, say, “There's a mistake in that program—if this happens and that happens and that happens and this happens, then it will crash.” And then I go and look in the code—yup, I was right. There has never been a symptom. Now you tell me a development system that can do that kind of stuff. So the changes that have happened as a programmer, they're mental changes within me.</p>
<p class="normal">有两个变化，我认为它们与你编程的年数有关。一是，当我年轻的时候，我经常会写一个程序并努力直到它完成。当它完成时，我会停止工作。完成了，结束了。然后我会有一个洞察力——“啊！错误的！笨蛋！” 我会重写它。再次：“是的，这是错误的”——重写它。</p><p class="normal">There are two changes and I think they're to do with the number of years you program. One is, when I was younger quite often I would write a program and work at it until it's finished. When it was finished I would stop working on it. It was done, finished. Then I'd get an insight—“Ah! Wrong! Idiot!” I'd rewrite it. Again: “Yeah, it's wrong”—rewrite it.</p>
<p class="normal">我记得自己在想，“如果我能思考所有这些东西而不是写出来，那不是很好吗？” 如果我不用写就可以得到这个见解，那不是很好吗？我想我现在可以做到。所以我会把那段用了 20 年的时间描述为学习如何编程。现在我知道如何编程了。我正在做实验来学习如何编程。我想我现在知道如何编程，因此我不必再做实验了。</p><p class="normal">I remember thinking to myself, “Wouldn't it be nice if I could think all of this stuff instead of writing it?” Wouldn't it be nice if I could get this insight without writing it. I think I can do that now. So I would characterize that period, which took 20 years, as learning how to program. Now I know how to program. I was doing experiments to learn how to program. I think I know how to program now and therefore I don't have to do the experiments anymore.</p>
<p class="normal"><a id="OEBPS/Chapter06.html.page_216"></a>有时我不得不做非常小的实验——编写非常小的程序只是为了回答一些问题。然后我仔细考虑事情，当我对它们进行编程时，它们或多或少会像我期望的那样工作，因为我已经仔细考虑过它们。这也意味着需要很长时间。一个你编写的程序，你获得洞察力，你重写——你可能需要一年的时间来编写。所以我可能会考虑一年。我只是没有做所有这些打字。</p><p class="normal"><a></a>Occasionally I have to do very small experiments—write extremely small programs just to answer some question. And then I think through things and they more or less work as I expect when I program them because I've thought through them. That also means it takes a long time. A program that you write, you get the insight, you rewrite—it might take you a year to write. So I might think about it for a year instead. I'm just not doing all this typing.</p>
<p class="normal">这是第一件事。发生的第二件事是直觉。当我年轻的时候，我会通宵破解，编程到凌晨四点，你会感到非常疲倦，而且这是大男子主义的编程——你会一小时又一小时地破解代码。它进展不顺利，你坚持不懈，你让它发挥作用。当直觉不存在时，我会编程。</p><p class="normal">That's the first thing. The second thing that's happened is intuition. When I was younger, I would do the all-night hacks, programming to four in the morning and you get really tired and it's macho programming—you hack the code in hour after hour. And it's not going well and you persevere and you get it working. And I would program when the intuition wasn't there.</p>
<p class="normal">我学到的是，当你累了的时候编程，你写了垃圾，第二天你就把它扔掉了。20 年前我会编程，尽管我强烈地感觉到这是不对的——这段代码有问题。多年来我注意到，我真正写出的好代码是在我全神贯注的时候——完全没有意识到时间：甚至没有真正思考程序，只是放松地坐在那里，只是输入这些东西，然后看着当我输入它时，它会出现在屏幕上。该代码将没问题。那些你无法集中注意力的东西，有人在说，“不，不，不，这是错误的，错误的，错误的”——我多年前就忽略了这一点。我会把它全部扔掉。现在，如果它说“不”，我就不能再编程了。我只是从经验中知道，停止——不要 不要写代码。停止这个问题。做点别的。</p><p class="normal">And what I've learned is, programming when you're tired, you write crap and you throw it all away the next day. And 20 years ago I would program although I was getting a strong feeling that this isn't right—there's something wrong with this code. I have noticed over the years, the really good code I would write was when I'm in complete flow—just totally unaware of time: not even really thinking about the program, just sitting there in a relaxed state just typing this stuff and watching it come out on the screen as I type it in. That code's going to be OK. The stuff where you can't concentrate and something's saying, “No, no, no, this is wrong, wrong, wrong”—I was ignoring that years ago. And I'd throw it all away. Now I can't program anymore if it says, “No.” I just know from experience, stop—don't write code. Stop with the problem. Do something else.</p>
<p class="normal">因为我在学校擅长数学之类的东西，所以我想，“哦，我是一个有逻辑的人。” 但我参加了这些心理学测试，并在直觉上获得了高分。而且逻辑思维得分很低。不低——我会做数学之类的；我很擅长他们。但是因为我擅长数学，所以我认为科学是关于逻辑和数学的。但我现在不会这么说。我会说这是非常多的直觉，只是知道什么是对的。</p><p class="normal">Because I was good at math and that sort of stuff at school, I thought, “Oh, I'm a logical person.” But I took these psychology tests and got way high scores on intuition. And quite low scores on logical thinking. Not low—I can do math and stuff; I'm quite good at them. But because I was good at math I thought science was about logic and math. But I wouldn't say that now. I'd say it's an awful lot of intuition, just knowing what's right.</p>
<p class="normal"><b>Seibel：</b>所以现在你在编码之前花了更多的时间思考，你在那个阶段实际上在做什么？</p><p class="normal"><b>Seibel:</b> So now that you spend more time thinking before you code, what are you actually doing in that stage?</p>
<p class="normal"><b>阿姆斯特朗：</b>哦，我在写笔记——我不<i>只是在</i>思考。在纸上涂鸦。我可能不会对代码投入太多。如果你要监控<a id="OEBPS/Chapter06.html.page_217"></a>我的活动主要是思考，有点涂鸦。另一件事，对于解决问题非常重要，就是问我的同事，“你会如何解决这个问题？” 这种情况发生了很多次，以至于你去找他们说，“我一直在想我是应该这样做还是那样做。我必须在 A 和 B 之间做出选择，”然后你向他们描述 A 和 B，然后你说到一半，“是的，B。谢谢你，非常感谢。”</p><p class="normal"><b>Armstrong:</b> Oh, I'm writing notes—I'm not <i>just</i> thinking. Doodling on paper. I'm probably not committing much to code. If you were to monitor <a></a>my activity it'd be mostly thinking, a bit of doodling. And another thing, very important for problem solving, is asking my colleagues, “How would you solve this?” It happens so many times that you go to them and you say, “I've been wondering about whether I should do it this way or that way. I've got to choose between A and B,” and you describe A and B to them and then halfway through that you go, “Yeah, B. Thank you, thank you very much.”</p>
<p class="normal">你需要这个智能白板——如果你只是在白板上自己做，就没有反馈。但是作为一个人，你在白板上向他们解释替代解决方案，他们会加入对话并提出奇怪的建议。然后突然间你看到了答案。对我来说，这不会扩展到编写代码。但是与处于同一问题空间的同事进行对话非常有价值。</p><p class="normal">You need this intelligent white board—if you just did it yourself on a white board there's no feedback. But a human being, you're explaining to them on the white board the alternative solutions and they join in the conversation and suggest the odd thing. And then suddenly you see the answer. To me that doesn't extend to writing code. But the dialog with your colleagues who are in the same problem space is very valuable.</p>
<p class="normal"><b>Seibel：</b>你认为是那些小的反馈或问题吗？或者仅仅是解释它的事实？</p><p class="normal"><b>Seibel:</b> Do you think it's those little bits of feedback or questions? Or is it just the fact of explaining it?</p>
<p class="normal"><b>阿姆斯特朗：</b>我认为这是因为你强迫它把它从你大脑中解决它的部分转移到你大脑中表达它的部分，它们是大脑的不同部分。我认为这是因为你强迫它发生。我从来没有做过只对着空荡荡的房间大声说话的实验。</p><p class="normal"><b>Armstrong:</b> I think it is because you are forcing it to move it from the part of your brain that has solved it to the part of your brain that has verbalized it and they are different parts of the brain. I think it's because you're forcing that to happen. I've never done the experiment of just speaking out loud to an empty room.</p>
<p class="normal"><b>Seibel：</b>我听说一个计算机科学系在导师的办公室里有一个毛绒玩具，规则是你必须先向毛绒玩具解释你的问题，然后才能打扰导师。“好的，熊先生，这是我正在做的事情，这是我的方法——啊哈！就在那里。</p><p class="normal"><b>Seibel:</b> I heard about a computer science department where in the tutor's office they had a stuffed animal and the rule was you had to explain your problem to the stuffed animal before you could bother the tutor. “OK, Mr. Bear, here's the thing I'm working on and here's my approach—aha! There it is.”</p>
<p class="normal"><b>阿姆斯特朗：</b>真的吗？我必须试试看。</p><p class="normal"><b>Armstrong:</b> Really? I must try that.</p>
<p class="normal"><b>Seibel：</b>和你的猫说话。</p><p class="normal"><b>Seibel:</b> Talk to your cats.</p>
<p class="normal"><b>阿姆斯特朗：</b>猫——当然！我和一个比我大一点而且非常聪明的人一起工作。每次我去他的办公室问他一个问题，每一个问题，他都会说，“程序是一个黑盒子。它有输入，也有输出。输入和输出之间存在函数关系。你的问题的输入是什么？你的问题的输出是什么？什么是函数关系<a id="OEBPS/Chapter06.html.page_218"></a>两者之间？” 然后在这个对话的某个地方，你会说，“你是个天才！” 你跑出房间，他会惊奇地摇头——“我想知道问题出在哪里，他从来没有说过。” 所以他是你的熊，你可以向他解释问题。</p><p class="normal"><b>Armstrong:</b> The cats—absolutely! I worked with this guy who was slightly older than me and very clever. And every time I'd go into his office and ask him a question, every single question, he would say, “A program is a black box. It has inputs and it has outputs. And there is a functional relationship between the inputs and the outputs. What are the inputs to your problem? What are the outputs to your problem? What is the functional relationship <a></a>between the two?” And then somewhere in this dialog, you would say, “You're a genius!” And you'd run out of the room and he would shake his head in amazement—“I wonder what the problem was, he never said.” So he's your bear which you explain the problem to.</p>
<p class="normal"><b>Seibel：</b>涂鸦——是写一小段代码还是字面上的图形涂鸦？</p><p class="normal"><b>Seibel:</b> The doodling—is that writing little snippets of code or is it literally graphical doodles?</p>
<p class="normal"><b>阿姆斯特朗：</b>更多的是带箭头的气泡。你知道当你在白板上向人们解释事情时——你会画气泡、箭头、方程式和符号。不是代码。代码片段——有时是零散的代码片段，因为这是一种表达某些东西的紧凑方式。这是在思考期。非常偶尔的代码实验，因为我不知道做某事需要多长时间。所以我会写十行代码和时间。</p><p class="normal"><b>Armstrong:</b> It's more bubbles with arrows. You know when you explain things to people on a white board—you draw bubbles and arrows and equations and notations. Not code. Code fragments—piddly bits of code sometimes because that's a compact way to express something. This is in the thinking period. Very occasional code experiments because I don't know how long it takes to do something. So I'll write ten lines of code and time something.</p>
<p class="normal"><b>Seibel：</b>你的意思是计算机需要多长时间才能完成？</p><p class="normal"><b>Seibel:</b> You mean how long it takes for the computer to do it?</p>
<p class="normal"><b>阿姆斯特朗：</b>是的。这需要一毫秒还是一微秒——我不知道。我能猜到，但我想证实这个猜测。所以我只关注我并不真正了解的部分。但我有丰富的 Erlang 编程经验，所以我非常清楚要做什么。问题解决与几年前相同。它是，确定困难的部分，编写小原型，确定不确定的区域，编写非常小的代码。基本上我现在做同样的事情，但我没有理由做这些小实验。如果是二郎。如果我正在做 Ruby 或 Java，那么我必须回去做很多实验，因为我不知道会发生什么。</p><p class="normal"><b>Armstrong:</b> Yeah. Does that take a millisecond or a microsecond—I don't know. I can guess but I want to confirm that guess. And so I'm only looking at the bits I don't really know. But I have a great stock of experience programming Erlang so I know pretty much what things are going to do. Problem solving was the same years ago. It was, identify the difficult bits, write the small prototypes, identify the areas of uncertainty, writing very small bits of code. Essentially I do the same thing now but I have less reason to do these small experiments. If it's Erlang. If I'm doing Ruby or Java then I have to go back and do a lot of experiments because I don't know what's going to happen.</p>
<p class="normal"><b>Seibel：</b>那么在这个思考过程中的某个地方，您会到达知道如何编写代码的地步吗？</p><p class="normal"><b>Seibel:</b> Then somewhere in this thinking process you get to the point where you know how to write the code?</p>
<p class="normal"><b>阿姆斯特朗：</b>是的，然后所有的部分都组合在一起。但也许我无法向任何人解释。我只是有一种非常强烈的感觉，如果我现在开始编写程序，它就会成功。我真的不知道解决方案是什么。它就像一个鸡蛋。鸡准备下蛋了。现在我准备下蛋了。</p><p class="normal"><b>Armstrong:</b> Yeah, then all the bits fit together. But maybe I can't explain it to anybody. I just get a very strong feeling that if I start writing the program now it'll work. I don't really know what the solution is. It's like an egg. The chicken's ready to lay the egg. Now I'm ready to lay the egg.</p>
<p class="normal"><b>Seibel：</b>这就是你需要进入心流而不是被打扰的时刻。</p><p class="normal"><b>Seibel:</b> And that's the point at which you need to go into flow and not be interrupted.</p>
<p class="normal"><a id="OEBPS/Chapter06.html.page_219"></a><b>阿姆斯特朗：</b>是的，是的。</p><p class="normal"><a></a><b>Armstrong:</b> Yes, yes.</p>
<p class="normal"><b>Seibel：</b>所以想必在代码层面还有很多细节需要整理，需要大家集中精力。</p><p class="normal"><b>Seibel:</b> So there are still presumably a lot of details to be sorted out at the code level which requires your concentration.</p>
<p class="normal"><b>阿姆斯特朗：</b>哦，是的。但是这些东西有两种类型。真正需要集中注意力的事情是那些不会自动发生的事情——你必须考虑一下。你遇到了这个非常棘手的垃圾收集——确切地说什么需要标记以及确切的位置——你必须认真考虑一下。你知道你会找到一个解决方案，因为你已经把它限制在里面了。你知道它在正确的小黑盒子里。</p><p class="normal"><b>Armstrong:</b> Oh yes. But then there are two types of those things. The stuff that really needs the concentration is the stuff that is not automatic—you've got to think about it. You've got this really tricky garbage collection—exactly what needs to be marked and exactly where—you've got to think hard about that. You know you'll find a solution because you've kind of bounded it in. And you know it's in the right little black box.</p>
<p class="normal">米开朗基罗正在做西斯廷教堂的屋顶之类的，他有一整个画家团队在帮助他。所以他会先勾勒出大局。这些巨大的区域必须用蓝色和绿色来完成。所以这更像是编写程序。第一张草图是一张粗略的草图，其中一切都在正确的位置。其中一些地方将用统一的颜色填充，并且可以相当快速地填充——你不必思考。</p><p class="normal">Michelangelo is doing the roof of the Sistine Chapel or something and he's got a whole team of painters helping him. So he would sketch the big picture first. These huge areas have got to be done in blue and green. So that's rather like writing a program. The first sketch is this broad sketch where everything's in the right place. Some of these places are going to be filled with uniform color and just can be filled in fairly rapidly—you don't have to think.</p>
<p class="normal">然后你会得到眼睛的细节——这是很棘手的事情。你知道你能做到。而且眼睛在正确的位置，因为图片还可以。所以你去做眼睛和细节。这并不是说这很容易——实际上，那是困难的一点。在做眼睛时，你必须真正集中注意力。在做前额或脸颊时，您不必真正集中注意力，因为它们相当均匀。这里有一点胡茬，所以你可以集中注意力。</p><p class="normal">And then you get to the details of the eyes—that's tricky stuff. You know you can do it. And the eye is in the right place because the picture is OK. So you go and do the eye and the detail. That's not to say that's easy—that's the difficult bit, actually. You've got to really concentrate while you're doing the eye. You don't have to really concentrate while you're doing the forehead or the cheeks because they're fairly uniform. A bit of stubble here so you pay a sort of half concentration.</p>
<p class="normal">然后将其全部输入并排除语法错误并运行一些小测试以确保其正常工作。这一切都相当放松。在那里看到一个小的编译器错误，然后修复它。一旦您熟悉了一种语言，您甚至都懒得去阅读诊断书。它只是显示行号——您不会阅读它的内容。那条线——哦，是的。打错了，你重新输入。</p><p class="normal">Then type it all in and get the syntax errors out and run a few little tests to make sure it works. And that's all rather relaxing. See a little compiler error there and you fix it. Once you're experienced at a language you don't even bother to read the diagnostic. It just says the line number—you don't read what it says. That line—oh, yeah. That's wrong, you retype it.</p>
<p class="normal">我在芝加哥开设了 Erlang 课程。我在班级里四处走动，然后我发现有些不对劲。哦，那里少了一个逗号，否则它会在此之前崩溃并且您没有链接。我的妻子非常擅长校对，她说错误会从页面中跳出来。一个漏掉的逗号或一个拼写错误——它们从字面上跳出了她的页面。</p><p class="normal">I gave a course in Erlang in Chicago. I was wandering around the class and I'd notice, there's something wrong. Oh, there's a comma missing there or that'll crash before that happens and you're not linked. My wife's very good at proofreading and she says errors spring out of the page at you. A missing comma or a spelling mistake—they literally spring out of the page at her.</p>
<p class="normal"><a id="OEBPS/Chapter06.html.page_220"></a>如果我四处查看其他人的代码，编程错误就会从页面中跳出来。感觉不涉及有意识的思考——它是整体的。您会在屏幕上看到所有内容，但出现错误，<code>bumpf</code>. 所以这只是纠正这些表面错误的问题。</p><p class="normal"><a></a>And programming errors just spring out of the page if I look at other people's code, wandering around. It doesn't feel like conscious thought is involved—it's holistic. You see everything on the screen and there's the error, <code>bumpf</code>. So it's just a matter of correcting those surface errors.</p>
<p class="normal">一个棘手的问题是变量名中的轻微拼写错误。所以我故意选择非常不同的变量名，这样就不会发生错误。如果你有一个很长的变量，比如最后<code>personName</code>有<code>personNames</code>一个“s”，那就是一个人名列表，我的眼睛会倾向于阅读我认为它应该是的东西。所以我会<code>personName</code>然后<code>listOfPeople</code>。我是故意这样做的，因为我知道我的眼睛会看到我认为我写的东西。但是标点符号，我确实看到了——我确实认为逗号和括号是错误的。当然，Emacs 会为所有内容着色并自动缩进，并且括号是不同的颜色。所以这真的很容易。</p><p class="normal">One that's tricky is slight spelling errors in variable names. So I choose variable names that are very dissimilar, deliberately, so that error won't occur. If you've got a long variable like <code>personName</code> and you've got <code>personNames</code> with an “s” on the end, that's a list of person names, that will be something that my eye will tend to read what I thought it should have been. And so I'd have <code>personName</code> and then <code>listOfPeople</code>. And I do that deliberately because I know that my eye will see what I thought I'd written. But punctuation, I do see that—I do see the commas and the brackets as being wrong. And of course Emacs colors everything and auto-indents and the brackets are different colors. So this is really easy.</p>
<p class="normal"><b>Seibel：</b>在您开始输入代码时，您是自上而下、自下而上还是从中间向外编写代码？</p><p class="normal"><b>Seibel:</b> At the point that you start typing code, do you code top-down or bottom-up or middle-out?</p>
<p class="normal"><b>阿姆斯特朗：</b>自下而上。我写一点然后测试，写一点然后测试。现在，我已经开始编写测试用例了。单元测试。只需编写测试用例，然后编写代码。我相当有信心它有效。</p><p class="normal"><b>Armstrong:</b> Bottom up. I write a little bit and test it, write a little bit and test it. I've gone over to this writing test cases first, now. Unit testing. Just write the test cases and then write the code. I feel fairly confident that it works.</p>
<p class="normal"><b>Seibel：</b>回顾一下你的历史，是在瑞典航天公司之后你去了爱立信的研究实验室？</p><p class="normal"><b>Seibel:</b> Back to a bit of your history, it was after the Swedish Space Corporation that you went to Ericsson's research lab?</p>
<p class="normal"><b>阿姆斯特朗：</b>是的。那是一个非常非常幸运的时刻，一定是 84 年。我想我是在它开始两年后才来到实验室的。所以我们非常乐观。我们对世界的看法是，是的，我们将解决问题，然后将它们推进项目，我们将提高爱立信的生产力。这种世界观还没有受到任何与现实接触的影响。所以我们认为发现新的和有用的东西很容易，我们认为一旦我们发现了新的和有用的东西，世界就会张开双臂欢迎我们。我们后来了解到，发现新事物并不那么容易。让人们使用新的更好的东西是<i>非常困难的。</i></p><p class="normal"><b>Armstrong:</b> Yes. And it was a very, very fortunate time to come, it must have been '84. I think I had come to the lab something like two years after it had started. So we were very optimistic. Our view of the world was, yes we'll solve problems and then we'll push them into projects and we will improve Ericsson's productivity. This view of the world wasn't yet tinged by any contact with reality. So we thought it would be easy to discover new and useful stuff and we thought that once we had discovered new and useful stuff then the world would welcome us with open arms. What we learned later was, it wasn't all that easy to discover new stuff. And it's <i>incredibly</i> difficult to get people to use new and better stuff.</p>
<p class="normal"><a id="OEBPS/Chapter06.html.page_221"></a><b>Seibel：</b>而 Erlang 是您希望他们使用的那些新的有用的东西之一吗？</p><p class="normal"><a></a><b>Seibel:</b> And Erlang was one of those new and useful things you expected them to use?</p>
<p class="normal"><b>阿姆斯特朗：</b>是的。绝对地。所以发生的事情是，首先它只是 Prolog。我有点创造了一种语言，人们开始使用它。然后罗伯特维尔丁走过来说，“嘿，这看起来很有趣。” 他一直在读我的 Prolog，他说，“我可以稍微修改一下吗？” 这是非常危险的，因为 Robert 这么说，你最终会在程序顶部看到一条评论，“Joe 想到了这些东西，我改变了一点，”然后它就完全改变了。所以罗伯特和我只是来回重写这些东西，我们有很大的争论——“啊哈，我看不懂你的代码，所有逗号后面都是空白。”</p><p class="normal"><b>Armstrong:</b> Yes. Absolutely. So what happened was, first of all it was just Prolog. I sort of made a little language and people started using it. And then Robert Virding came along and said, “Hey, this looks like fun.” And he'd been reading my Prolog and he said, “Can I modify it a bit?” That's pretty dangerous because Robert says that and you end up with one comment at the top of the program that says, “Joe thought of this stuff and I've changed a bit,” and then it's completely changed. So Robert and I just rewrote this stuff back and forth and we had great arguments—“Ahhh, I can't read your code, it's got blanks after all the commas.”</p>
<p class="normal">然后我们在爱立信内部发现有人想要一种新的编程语言或者想要一种更好的电话编程方式。我们每周与他们见面一次，我记不清了，六个月，九个月。一般的想法是我们会教他们如何编程，他们会教我们有关电话的知识——问题是什么。我记得那既令人沮丧又非常刺激。这改变了语言，因为我们有真实的人在使用它，这导致了一项研究，他们认为，“是的，这没问题，但它太慢了”——他们测量了它的性能并说，“它必须是 70 倍快点。” 然后我们说，“这个阶段现在结束了。我们将使它的运行速度提高 70 倍，他们将继续对其进行编程，我们必须在两年或更长时间内完成。”</p><p class="normal">Then we found somebody inside Ericsson who wanted a new programming language or wanted a better way of programming telephony. We met up with them once a week for about, I can't remember, six months, nine months. And the general idea was we would teach them how to program and they would teach us about telephony—what the problem was. I remember it was both frustrating and very stimulating. That changed the language because we had real people using it and that resulted in a study where they thought, “Yeah, this would be OK but it's far too slow”—they measure the performance of it and said, “It's gotta be 70 times faster.” So then we said, “This phase is now over. We'll make it go 70 times faster and they'll carry on programming it and we have to do this in two years or something.”</p>
<p class="normal">我们有几次错误的开始。我们有几个非常尴尬的时刻。大错：在你实施<i>之前</i>，不要告诉人们某件事的速度有多快。但最终我们想出了如何去做。我用 Prolog 写了一个编译器。Rob 负责图书馆之类的工作。我们现在差不多两年了。然后我想我可以用 C 实现这个抽象机，所以我开始写我的第一个 C。Mike Williams 过来看着我的 C 说，“这是最糟糕的 C我一生中从未见过。这太糟糕了。” 我不认为是<i>那样</i>不好，但迈克不喜欢它。然后迈克用 C 语言做了虚拟机，我用 Prolog 做了编译器。然后编译器自己编译并生成字节码，然后将其放入机器中，然后我们更改语法和句法并自行编译编译器并得出一个<a id="OEBPS/Chapter06.html.page_222"></a>图像会引导然后我们就飞了。我们失去了 Prolog 的根源，我们现在是一种语言。</p><p class="normal">We had several false starts. And we had several really embarrassing moments. Big mistake: don't tell people how fast something is going to be <i>before</i> you've implemented it. But ultimately we figured out how to do it. I wrote a compiler in Prolog. And Rob was doing the libraries and things. We're now kind of two years in. Then I thought I could implement this abstract machine in C so I started writing my first-ever C. And Mike Williams came along and looked at my C and said, “This is the worst C I've ever seen in my entire life. This is appallingly bad.” I didn't think it was <i>that</i> bad but Mike didn't like it. So then Mike did the virtual machine in C and I did the compiler in Prolog. Then the compiler compiled itself and produced byte-code and you put it in the machine and then we changed the grammar and the syntax and compiled the compiler in itself and came out with an <a></a>image that would bootstrap and then we're flying. We've lost our Prolog roots and we're now a language.</p>
<p class="normal"><b>Seibel：</b>您是否发现有什么难以融入 Erlang 模型的？</p><p class="normal"><b>Seibel:</b> Has there ever been anything that you've found difficult to work into the Erlang model?</p>
<p class="normal"><b>阿姆斯特朗：</b>是的。我们完全从记忆中抽象出来。如果您要将 JPEG 图像转换为位图数据，这在非常精确的意义上取决于数据的位置，则效果不佳。依赖于破坏性升级状态的算法——它们运行不佳。</p><p class="normal"><b>Armstrong:</b> Yeah. We abstract away from memory, completely. If you were turning a JPEG image into a bitmap data, which depends on the placement of the data in a very exact sense, that doesn't work very well. Algorithms that depend on destructively upgrading state—they don't work well.</p>
<p class="normal"><b>Seibel：</b>所以如果你正在编写一个大型图像处理工作流系统，那么你会用其他语言编写实际的图像转换吗？</p><p class="normal"><b>Seibel:</b> So if you were writing a big image processing work-flow system, then would you write the actual image transformations in some other language?</p>
<p class="normal"><b>Armstrong：</b>我会用 C 语言或汇编语言之类的语言编写它们。或者我可能实际上用 Erlang 的一种方言编写它们，然后将 Erlang 交叉编译为 C。制作一种方言——这种特定领域语言的想法。或者我可能会编写生成 C 程序的 Erlang 程序，而不是手动编写 C 程序。但目标语言将是 C 或汇编程序或其他语言。是我手写还是生成它们将是一个有趣的问题。我倾向于自动生成 C 而不是手动编写它，因为它更容易。</p><p class="normal"><b>Armstrong:</b> I'd write them in C or assembler or something. Or I might actually write them in a dialect of Erlang and then cross-compile the Erlang to C. Make a dialect—this kind of domain-specific language kind of idea. Or I might write Erlang programs which generate C programs rather than writing the C programs by hand. But the target language would be C or assembler or something. Whether I wrote them by hand or generated them would be the interesting question. I'm tending toward automatically generating C rather than writing it by hand because it's just easier.</p>
<p class="normal">但我会使用 Erlang 结构。我有一些东西可以做我的家庭形象和事情。所以我将 ImageMagik 与一些 shell 脚本一起使用。但我从 Erlang 控制这一切。所以我只是围绕它编写包装器，<code>os:command</code>然后调用 ImageMagik 命令。所以把东西包起来真是太好了。不想在 Erlang 中进行实际的图像处理。用 Erlang 编写它是愚蠢的。C只会好很多。</p><p class="normal">But I'd use an Erlang structure. I've got some stuff that does my family images and things. So I use ImageMagik with some shell scripts. But I control it all from Erlang. So I just write wrappers around it and call <code>os:command</code> and then the ImageMagik command. So it's quite nice to wrap up things in. Wouldn't want to do the actual image processing in Erlang. It'd be foolish to write that in Erlang. C's just going to be a lot better.</p>
<p class="normal"><b>Seibel：</b>另外，ImageMagik 已经编写好了。</p><p class="normal"><b>Seibel:</b> Plus, ImageMagik is already written.</p>
<p class="normal"><b>阿姆斯特朗：</b>我一点也不担心。我想如果我在 OCaml 中做这件事，那么我会继续下去，因为 OCaml 可以做到那种效率。但 Erlang 不能。所以如果我是一名 OCaml 程序员：“好吧，我必须做什么？重新实现 ImageMagik？对了，我们走了。”</p><p class="normal"><b>Armstrong:</b> That doesn't worry me in the slightest. I think if I was doing it in OCaml then I would go down and do it because OCaml can do that kind of efficiency. But Erlang can't. So if I was an OCaml programmer: “OK, what do I have to do? Reimplement ImageMagik? Right, off we go.”</p>
<p class="normal"><a id="OEBPS/Chapter06.html.page_223"></a><b>Seibel：</b>只是因为好玩？</p><p class="normal"><a></a><b>Seibel:</b> Just because it's fun?</p>
<p class="normal"><b>阿姆斯特朗：</b>我喜欢编程。为什么不？你知道，我一直在说 Erlang 不适合图像处理——我从未真正尝试过。我觉得这会很糟糕，但这可能是错误的。我应该试试 嗯，有趣。你不应该引诱我。</p><p class="normal"><b>Armstrong:</b> I like programming. Why not? You know, I've always been saying that Erlang is bad for image processing—I've never actually tried. I feel it would be bad but that might be false. I should try. Hmmm, interesting. You shouldn't tempt me.</p>
<p class="normal">真正优秀的程序员会花很多时间编程。我还没有见过不花很多时间编程的非常优秀的程序员。如果我两三天不编程，我就需要去做。而且你会做得更好——你会做得更快。写所有这些其他东西的副作用是，当你开始做普通问题时，你可以很快地完成它们。</p><p class="normal">The really good programmers spend a lot of time programming. I haven't seen very good programmers who don't spend a lot of time programming. If I don't program for two or three days, I need to do it. And you get better at it—you get quicker at it. The side effect of writing all this other stuff is that when you get to doing ordinary problems, you can do them very quickly.</p>
<p class="normal"><b>Seibel：</b>作为一名程序员，您有没有专门做过什么来提高您的技能？</p><p class="normal"><b>Seibel:</b> Is there anything that you have done specifically to improve your skill as a programmer?</p>
<p class="normal"><b>阿姆斯特朗：</b>不，我不这么认为。我学习了新的编程语言，但并不是为了成为更好的程序员。也许是为了成为更好的语言设计师。</p><p class="normal"><b>Armstrong:</b> No, I don't think so. I learned new programming languages but not with the goal of becoming a better programmer. With the goal of being a better language designer, maybe.</p>
<p class="normal">我喜欢弄清楚事情是如何运作的。一个很好的测试是自己实施。对我来说，编程并不是将代码输入机器。编程是关于理解的。我喜欢理解事物。那么为什么我要像我们之前讨论的那样实现 JPEG 呢？这是因为我想了解小波变换。所以编程是理解小波变换的工具。或者为什么我要尝试做一个 X Windows 的接口？因为我想了解 X 协议是如何工作的。</p><p class="normal">I like to figure out how things work. And a good test of that is to implement it yourself. To me programming isn't about typing code into a machine. Programming is about understanding. I like understanding things. So why would I implement a JPEG thing like we talked about earlier? It's because I'd like to understand wavelet transforms. So the programming is a vehicle to understand wavelet transformations. Or why do I try to do an interface to X Windows? Because I wanted to understand how the X protocol worked.</p>
<p class="normal">这是实施某事的动力；我真的推荐它。如果你想了解 C，写一个 C 编译器。如果您想了解 Lisp，请编写 Lisp 编译器或 Lisp 解释器。有人说，“哦，哇，编写编译器真的很难。” 不是。这很容易。有很多小东西要学，没有一个是难的。你必须了解数据结构。你需要了解哈希表，你需要了解解析。您需要了解代码生成。您需要了解口译技巧。其中每一项都不是特别困难。我想如果你是初学者，你会认为它又大又复杂，所以你不会去做。不做的事很困难，做过的事很容易。所以你甚至不尝试。</p><p class="normal">It's a motivating force to implement something; I really recommend it. If you want to understand C, write a C compiler. If you want to understand Lisp, write a Lisp compiler or a Lisp interpreter. I've had people say, “Oh, wow, it's really difficult writing a compiler.” It's not. It's quite easy. There are a lot of little things you have to learn about, none of which is difficult. You have to know about data structures. You need to know about hash tables, you need to know about parsing. You need to know about code generation. You need to know about interpretation techniques. Each one of these is not particularly difficult. I think if you're a beginner you think it's big and complicated so you don't do it. Things you don't do are difficult and things you've done are easy. So you don't even try. And I think that's a mistake.</p>
<p class="normal"><a id="OEBPS/Chapter06.html.page_224"></a><b>Seibel：</b>与我交谈过的一些人建议学习不同的编程语言，因为它能让你从不同的角度看待如何解决问题。</p><p class="normal"><a></a><b>Seibel:</b> Several of the folks I've talked to have recommended learning different programming languages because it gives you different perspectives on how to solve problems.</p>
<p class="normal"><b>Armstrong：</b>做不同事情的语言。学习很多做同样事情的语言是没有意义的。当然，我已经编写了相当多的 JavaScript、相当多的 Tcl、相当多的 C 和相当多的 Prolog——好吧，大量的 Prolog、大量的 Fortran 和大量的 Erlang。还有一点红宝石。一点哈斯克尔。我有点阅读所有语言，但我并不擅长对它们进行编程。当然，我可以使用多种语言进行编程。</p><p class="normal"><b>Armstrong:</b> Languages that do different things. There's no point learning lots of languages that all do the same thing. Certainly I've written quite a lot of JavaScript and quite a lot of Tcl and quite a lot of C and quite a lot of Prolog—well, an enormous amount of Prolog and an enormous amount of Fortran and an enormous amount of Erlang. And a bit of Ruby. A bit of Haskell. I sort of read all languages and I'm not fluent at programming them all. Certainly I can program in quite a lot of languages.</p>
<p class="normal"><b>Seibel：</b>没有 C++？</p><p class="normal"><b>Seibel:</b> No C++?</p>
<p class="normal"><b>Armstrong：</b>不，C++，我几乎不会读或写它。我不喜欢 C++；感觉不对。这很复杂。我喜欢小而简单的语言。它不觉得小而简单。</p><p class="normal"><b>Armstrong:</b> No, C++, I can hardly read or write it. I don't like C++; it doesn't feel right. It's just complicated. I like small simple languages. It didn't feel small and simple.</p>
<p class="normal"><b>Seibel：</b>哪些语言影响了 Erlang 的设计？</p><p class="normal"><b>Seibel:</b> What languages influenced the design of Erlang?</p>
<p class="normal"><b>阿姆斯特朗：</b>序言。好吧，很明显，它是从 Prolog 发展而来的。</p><p class="normal"><b>Armstrong:</b> Prolog. Well, it grew out of Prolog, obviously.</p>
<p class="normal"><b>Seibel：</b>今天在其中看不出太多 Prolog。</p><p class="normal"><b>Seibel:</b> There's not a lot of Prolog discernible in it today.</p>
<p class="normal"><b>Armstrong：</b>嗯，统一——模式匹配，直接来自 Prolog。还有那种数据结构。元组和列表在 Prolog 中的语法略有不同，但它们确实存在。然后是 Tony Hoare 的 CSP，Communicating Sequential Processes。我还阅读了有关 Dijkstra 的受保护命令的内容——这就是为什么我要求某些模式应始终匹配，不应该有默认情况——您应该明确要求某些分支始终匹配。我认为这些是主要的影响。</p><p class="normal"><b>Armstrong:</b> Well, unification—pattern matching, that comes directly from Prolog. And the kind of data structures. Tuples and lists have slightly different syntax in Prolog but they're there. Then there was Tony Hoare's CSP, Communicating Sequential Processes. Also I'd read about Dijkstra's guarded commands—that's why I require that some pattern should always match, there shouldn't be a default case—you should explicitly require that some branch always match. I think those are the main influences.</p>
<p class="normal"><b>Seibel：</b>您从哪里获得功能方面的信息？</p><p class="normal"><b>Seibel:</b> And where did you get the functional aspect?</p>
<p class="normal"><b>Armstrong：</b>一旦你将并发添加到 Prolog，你真的只需要确保它在你完成某些事情后不会回溯。在 Prolog 中，您可以调用一些东西，然后回溯解决方案以基本上撤消调用它的效果。<i>所以你必须意识到，如果这句</i>话说，“发射导弹” ，然后他们离开了，你不能回溯它并扭转它。纯 Prolog 程序是可逆的。但是当你与<a id="OEBPS/Chapter06.html.page_225"></a>现实世界中，你所做的所有事情都是一种方式。话虽如此，发射导弹，导弹发射。说过，“将交通灯从红色变为绿色”，它们从红色变为绿色，你不能说，“哦，那是个糟糕的决定；” 撤消它。</p><p class="normal"><b>Armstrong:</b> Once you've added concurrency to Prolog you really just had to make sure it didn't backtrack after you'd done something. In Prolog you could call something and then backtrack over the solution to basically undo the effect of calling it. So you had to realize if this statement says, “Fire the missiles,” and <i>whoom</i>, off they go, you can't backtrack over it and reverse that. Pure Prolog programs are reversible. But when you're interacting with <a></a>the real world, all the things you do are one way. Having said, fire the missiles, the missiles fire. Having said, “Change the traffic lights from red to green,” they change from red to green and you can't say, “Oh, that was a bad decision; undo it.”</p>
<p class="normal">现在我们有了并发语言和并行进程，在这些进程中我们正在使用回溯和所有类似的东西做完整的 Prolog。所以 Prolog 变得非常确定，到处都有削减以阻止它回溯。</p><p class="normal">Now we've got a concurrent language and parallel processes and inside these processes we're doing full Prolog with backtracking and all that kind of stuff. So the Prolog became very deterministic with cuts everywhere to stop it from backtracking.</p>
<p class="normal"><b>Seibel：</b>不可逆转的事情会在哪里向其他进程发送消息？</p><p class="normal"><b>Seibel:</b> Where the irreversible things would be sending messages to other processes?</p>
<p class="normal"><b>阿姆斯特朗：</b>是的。但这只是一个函数调用，也许不是发射火箭的函数，而是一个调用其他东西的函数调用其他东西调用它，所以试图将这两个世界分开只是一种痛苦。因此，您在流程中编写的代码变得越来越实用，有点像 Prolog 的一种方言，它是一个功能子集。因此，如果它是一个功能子集，不妨让它完全发挥作用。</p><p class="normal"><b>Armstrong:</b> Yes. But it's just a function call and maybe not of the function that fires the rockets but one that calls something else that calls something else that calls it so it's just a pain kind of trying to keep these two worlds separate. So the code you wrote inside a process became more and more functional, sort of a dialect of Prolog which was a functional subset. And so if it's a functional subset, might as well make it completely functional.</p>
<p class="normal"><b>Seibel：</b>然而，Erlang 在动态类型方面与当今大多数函数式语言有很大不同。您觉得自己是函数式语言社区的一员吗？</p><p class="normal"><b>Seibel:</b> Yet Erlang is pretty different from most functional languages these days in being dynamically typed. Do you feel like part of the functional language community?</p>
<p class="normal"><b>阿姆斯特朗：</b>哦，是的。当我们去参加函数式编程会议时，我想我们会争论我们的分歧。我们争论热切求值和懒惰求值。我们争论动态类型系统和静态类型系统。但是尽管如此，函数式编程的核心是不可变状态的思想——x<i>不是</i>内存中某个位置的名称；这是一个价值。所以无法改变。我们说<i>x</i>等于 3，此后不能更改。所有这些不同的社区都表示，这对于理解您的程序、并行化您的程序和调试您的程序有巨大的好处。然后是带有动态类型系统的函数式语言，如 Erlang 和带有静态类型系统的函数式语言，它们各有优缺点。</p><p class="normal"><b>Armstrong:</b> Oh yes. When we go to functional programming conferences, I suppose we argue about our differences. We argue about eager evaluation and lazy evaluation. We argue about dynamic type systems and static type systems. But despite everything the central core of functional programming is the idea of nonmutable state—that <i>x</i> isn't the name of a location in memory; it's a value. So it can't change. We say <i>x</i> equals three and you can't change it thereafter. All these different communities say that has enormous benefits for understanding your program and for parallelizing your program and for debugging your program. Then there are functional languages with dynamic type systems like Erlang and functional languages with static type systems and they've both got their good and bad points.</p>
<p class="normal">如果能在 Erlang 中享受静态类型系统的好处，那就太好了。也许在某些地方我们可以注释程序来制作类型<a id="OEBPS/Chapter06.html.page_226"></a>更明确，以便编译器可以派生类型并生成更好的代码。</p><p class="normal">It'd be really nice to have the benefits of a static type system in Erlang. Maybe in certain places we could annotate programs to make the types <a></a>more explicit so the compiler can derive the types and generate much better code.</p>
<p class="normal">然后静态类型的人说，“嗯，当我们编组数据结构时，我们真的很喜欢动态类型的好处。” 我们不能通过线路发送任意程序并在另一端重建它，因为我们需要知道类型。我们有——Cardelli 称之为一个永久不一致的系统。我们的系统一直在增长和变化，其中的部分可能暂时不一致。当我更改系统中的代码时，它不是原子的。有些节点会改变，有些则不会。他们互相交谈——在某些时候他们是一致的。在其他时候——当我们越过通信边界时——我们是否相信边界是正确的？他们可能会撒谎。所以我们需要检查某些东西。</p><p class="normal">Then the static type people say, “Well, we really rather like the benefits of dynamic types when we're marshaling data structures.” We can't send an arbitrary program down a wire and reconstruct it at the other end because we need to know the type. And we have—Cardelli called it a system that's permanently inconsistent. We have systems that are growing and changing all the time, where the parts may be temporarily inconsistent. And as I change the code in a system, it's not atomic. Some of the nodes change, others don't. They talk to each other—at certain times they're consistent. At other times—when we go over a communication boundary—do we trust that the boundary is correct? They might fib. So we need to check certain stuff.</p>
<p class="normal"><b>Seibel：</b>很早就通过调试其他人的程序来赚取啤酒。为什么你认为你是一个如此优秀的调试者？</p><p class="normal"><b>Seibel:</b> So early on you earned your beer by debugging other people's programs. Why do you think you were such a good debugger?</p>
<p class="normal"><b>阿姆斯特朗：</b>嗯，我喜欢调试。在程序的这一点上，您打印出一些变量和东西以查看发生了什么，它们都符合您的预期。在程序的这一点上它是正确的。后来在某个地方是错误的。所以你看中间的一半——它是对的还是错的，你只是把这个间隔减半。前提是您可以重现错误。不可重现的错误，很难调试。但他们没有给我那个。他们给了我可重现的错误。因此，继续减半直到找到它。你必须最终找到它。</p><p class="normal"><b>Armstrong:</b> Well, I enjoyed debugging. At this point in the program you print out a few variables and things to see what's going on and they're all according to what you expect. And at this point in the program it's right. And somewhere later it's wrong. So you look halfway in between—it's either right or wrong and you just do this interval halving. Provided you can reproduce an error. Errors that are nonreproducible, that's pretty difficult to debug. But they weren't giving me that. They were giving me reproducible errors. So just carry on halving until you find it. You must ultimately find it.</p>
<p class="normal"><b>Seibel：</b>所以你认为你只是有一个更系统的观点？</p><p class="normal"><b>Seibel:</b> So do you think you just had a more systematic view?</p>
<p class="normal"><b>阿姆斯特朗：</b>是的，他们放弃了。我不知道为什么——我无法真正理解为什么他们不能调试程序。我的意思是，你认为调试难吗？我不。你只要停下来让它慢下来。我的意思是，我只是在谈论批处理 Fortran。</p><p class="normal"><b>Armstrong:</b> Yeah, they gave up. I don't know why—I couldn't really understand why they couldn't debug programs. I mean, do you think debugging is difficult? I don't. You just stop it and slow it down. I mean, I'm just talking about batch Fortran.</p>
<p class="normal">好的，调试实时系统或垃圾收集器——我记得有一次 Erlang 崩溃了——那是早期——我刚启动它就崩溃了。我只是在打字。它在 shell 中内置了某种 Emacsy 命令。然后我输入<code>erl</code>启动它，你就进入了一个读取-评估-打印循环。和<a id="OEBPS/Chapter06.html.page_227"></a>我输入了大约四五个字符并犯了一个拼写错误。然后我多次支持游标并更正它，它因垃圾收集错误而崩溃。我知道那是一个很深很深的错误。我想，“我能准确地记得我输入了什么吗？” 因为它只有 12 个字符左右。我重新启动并输入并没有崩溃。我在那里坐了大约一个半小时，尝试了大概一百种不同的东西。然后又崩溃了！然后我写下来了。然后我可以调试它。</p><p class="normal">OK, debugging real-time systems or garbage collectors—I remember once Erlang crashed—it was early days—and it crashed just after I'd started it. I was just typing something. It had built in sort of Emacsy commands into the shell. And I typed <code>erl</code> to start it and you get into a read-eval-print loop. And <a></a>I'd typed about four or five characters and made a spelling mistake. And then I backed the cursor a couple of times and corrected it and it crashed with a garbage collection error. And I knew that's a deep, deep, error. And I thought, “Can I remember exactly what did I type in?” Because it was only about 12 characters or something. I restarted and typed and it didn't crash. And I sat there for like an hour and a half trying probably a hundred different things. Then it crashed again! Then I wrote it down. Then I could debug it.</p>
<p class="normal"><b>Seibel：</b>你在那里使用了哪些技术？打印报表？</p><p class="normal"><b>Seibel:</b> What are the techniques that you use there? Print statements?</p>
<p class="normal"><b>阿姆斯特朗：</b>打印报表。编程大神们说过，“你应该<code>printf</code>在你认为程序出错的地方加上语句，重新编译并运行它。”</p><p class="normal"><b>Armstrong:</b> Print statements. The great gods of programming said, “Thou shalt put <code>printf</code> statements in your program at the point where you think it's gone wrong, recompile, and run it.”</p>
<p class="normal">然后是——我不知道是我在什么地方读到的还是我自己发明的——Joe 的调试法则，即所有错误都将是你上次更改程序的位置的正负三个语句。当我在瑞典航天公司工作时，我的老板是一名硬件专家。我们到达了北部的火箭发射场和卫星跟踪站 Esrange。有一次他苦苦思索，调试硬件中的一些错误，插入示波器，然后改变一些东西。我说，“哦，我能帮忙吗？” 他说，“不，乔，你帮不上忙——这是硬件。” 我说，“是的，但它必须像软件一样——这个错误将非常接近你对硬件所做的最后一次更改。” 他说，“我换了一个电容器。你真是个天才！他' d 用一个更大的电容器更换了一个电容器，然后他将其拆焊并放回原来的电容器，它就可以工作了。到处都一样。你修好了你的车，但它出了问题——这是你做的最后一件事。你改变了一些东西——你只需要记住它是什么。一切都是如此。</p><p class="normal">Then there's—I don't know if I read it somewhere or if I invented it myself—Joe's Law of Debugging, which is that all errors will be plus/minus three statements of the place you last changed the program. When I worked at the Swedish Space Corporation my boss was a hardware guy. We were up at Esrange, the rocket-launching site and satellite-tracking station in the north. And one time he was banging his head, debugging some bug in the hardware, plugging in oscilloscopes, and changing things. And I said, “Oh, can I help?” And he said, “No Joe, you can't help here—this is hardware.” And I said, “Yeah, but it must be like software—the bug will be pretty near to the last change you made to the hardware.” And he went, “I changed a capacitor. You're a genius!” He'd replaced one capacitor with a bigger capacitor and he unsoldered it and put the original one back and it worked. It's the same everywhere. You fix your car and it goes wrong—it's the last thing you did. You changed something—you just have to remember what it was. It's true with everything.</p>
<p class="normal"><b>Seibel：</b>那么你有没有证明过你的程序是正确的？那种形式主义对你有吸引力吗？</p><p class="normal"><b>Seibel:</b> So have you ever proved any of your programs correct? Has that kind of formalism ever appealed to you?</p>
<p class="normal"><b>阿姆斯特朗：</b>是的，也不是。我用代数方式操纵程序只是为了证明它们是等价的。还没有真正进入定理证明。我上了一门指称语义学之类的课程。我记得放弃了。给出的练习是：<code>let × = 3 in let y = 4 in × plus y</code>表明方程式 foo 给出的热切评估方案<a id="OEBPS/Chapter06.html.page_228"></a>和方程式 bar 给出的懒惰评估方案，都评估为 7。</p><p class="normal"><b>Armstrong:</b> Yes and no. I've manipulated programs algebraically to just show that they were equivalent. Haven't really gone into theorem proving as such. I did a course in denotational semantics and things like that. I remember giving up. The exercise was given: <code>let × = 3 in let y = 4 in × plus y</code> show that the eager evaluation scheme given by the equations foo <a></a>and the lazy evaluation scheme given by the equations bar, both evaluate to seven.</p>
<p class="normal">十四页的引理和事后我想，“等一下——x 是三，y 是四，× 加上 y；是的七。当时我正在编写 Erlang 编译器。如果需要很多页来证明三加四等于七，那么证明我的编译器在任何意义上都是正确的将是成千上万页。</p><p class="normal">Fourteen pages of lemmas and things later I thought, “Hang on—x is three, y is four, × plus y; yeah seven.” At the time I was writing the Erlang compiler. If it took lots of pages to prove that three plus four is seven then the proof that my compiler was in any sense correct would have been thousands and thousands of pages.</p>
<p class="normal"><b>Seibel：</b>你更喜欢独自工作还是团队合作？</p><p class="normal"><b>Seibel:</b> Do you prefer to work alone or on a team?</p>
<p class="normal"><b>阿姆斯特朗：</b>如果你明白我的意思，我喜欢团队合作的工作场所。我不是反社会的。但我就是喜欢自己编程。当然，从与人讨论问题的意义上讲，我喜欢与人合作。我一直认为，当你开始工作时喝咖啡的休息时间会产生你在上班途中的所有想法，这些想法非常有价值。那时你会得到很多见解。很高兴在人群面前讨论你的想法。你处于解释你的想法的位置，对我来说，将它们从我大脑的一个部分转移到另一个部分。通常当你解释事物时，你会更好地理解它们。</p><p class="normal"><b>Armstrong:</b> I like a workplace of teams, if you see what I mean. I'm not antisocial. But I just like programming by myself. Certainly I like collaborating with people in the sense of discussing problems with them. I always thought the coffee break that you have when you got to work and out came all the ideas that you'd had on your walk to work was very valuable. You get a lot of insights then. Good to thrash your ideas out in front of the crowd. You're put in a position of explaining your ideas which, for me, moves them from one part of my brain to another part. Often when you explain things then you understand them better.</p>
<p class="normal"><b>Seibel：</b>你有没有结对编程——坐在电脑前和另一个人一起编写代码？</p><p class="normal"><b>Seibel:</b> Have you ever pair programmed—sat down at a computer and produced code with another person?</p>
<p class="normal"><b>阿姆斯特朗：</b>是的。与罗伯特，罗伯特维丁。当我们俩都在黑暗中挣扎时，我们往往会这样做。我们真的不知道我们在做什么。因此，如果您不知道自己在做什么，那么我认为这对那些也不知道自己在做什么的人非常有帮助。如果你有一个程序员比另一个好，那么较弱的程序员或经验不足的程序员观察另一个程序员可能会有好处。他们将从中学到一些东西。但如果差距太大，那么他们就不会学习，他们只会坐在那里觉得自己很愚蠢。当我和能力和我差不多但我们都不知道自己在做什么的程序员结对编程时，这很有趣。</p><p class="normal"><b>Armstrong:</b> Yeah. With Robert, Robert Virding. We would tend to do that when both of us were kind of struggling in the dark. We didn't really know what we were doing. So if you don't know what you're doing then I think it can be very helpful with someone who also doesn't know what they're doing. If you have one programmer who's better than the other one, then there's probably benefit for the weaker programmer or the less-experienced programmer to observe the other one. They're going to learn something from that. But if the gap's too great then they won't learn, they'll just sit there feeling stupid. When I have done pair programming with programmers about the same ability as me but neither of us knew what we were doing, then it's been quite fun.</p>
<p class="normal">然后是我可能称之为特殊问题的问题。如果我感冒了或身体状况不佳，我不会尝试它们。我知道这需要三天的时间来写，我会计划一天而不是阅读电子邮件并开始，它是<a id="OEBPS/Chapter06.html.page_229"></a>会整整四个小时。我会在家里做，所以我知道我不会被打扰。我只想做它，进入我能做到的完全专注的状态。我不认为结对编程会有帮助。这将是非常具有破坏性的。</p><p class="normal">Then there are what I might call special problems. I wouldn't attempt them if I've got a cold or I'm not on good physical form. I know it's going to take three days to write and I'll plan a day and not read email and start and it's <a></a>gonna be four hours solid. I'll do it at home so I know I won't be interrupted. I just want to do it and get into this complete concentrated state where I can do it. I don't think pair programming would help there. It would be very disruptive.</p>
<p class="normal"><b>Seibel：</b>这种问题的例子是什么？</p><p class="normal"><b>Seibel:</b> What's an example of that kind of problem?</p>
<p class="normal"><b>Armstrong：</b>弄清楚垃圾收集器的位——这是命令式编码——你必须记住在其中标记所有这些寄存器。或者在编译器中做一些 lambda 提升，这非常困难——你重新标记所有变量，然后你有四到五层抽象数据类型，所有这些都乱七八糟，框架中有不同的东西，你想，“我”我必须真正理解这一点，真正深入地思考它。” 你想专心。</p><p class="normal"><b>Armstrong:</b> Figuring out bits of a garbage collector—it's the imperative coding—where you've got to remember to mark all those registers. Or doing some lambda lifting in the compiler, which is pretty tough—you relabel all the variables and then you've got four or five layers of abstract data types all messing around and frames with different stuff in them and you think, “I've got to really understand this, really think deeply about it.” You want to concentrate.</p>
<p class="normal">我根据心情改变我做的任务。有时我很没有精神，所以我想，“啊，我现在去打扰谁。” 或者我会阅读一些电子邮件。其他时候我觉得，现在我要做一些硬编码，因为我有心情去做。你必须有点权利来进行编码。那么两个人一起工作会怎样呢？其中一个只是注意力不集中，想阅读他的电子邮件和其他东西。</p><p class="normal">I vary the tasks I do according to mood. Sometimes I'm very uninspired so I think to myself, “Ah, who shall I go and disturb now.” Or I'll read some emails. Other times I feel, right now I'm going to do some hard coding because I'm in the mood for it. You've got to be sort of right to do the coding. So how's that going to work with two people? One of them is just not in a concentrating mode and wants to read his emails and things.</p>
<p class="normal"><b>Seibel：</b>你确实与 Robert Virding 进行了一种串行结对编程，当你来回传递代码时，每次都重写它。</p><p class="normal"><b>Seibel:</b> You did do a kind of serial pair programming with Robert Virding, when you passed the code back and forth rewriting it each time.</p>
<p class="normal"><b>阿姆斯特朗：</b>是的。一次一个。我会在程序上工作，通常是两到三个星期，然后我会说，“好吧，我受够了，给你，罗伯特。” 他会接受的。每次我们这样做时，它都会变得面目全非。他会做大量的改变，然后反馈给我，我会做大量的改变。</p><p class="normal"><b>Armstrong:</b> Yeah. One at a time. I would work on the program, typically two or three weeks, and then I'd say, “Well, I've had enough, here you are, Robert.” And he'd take it. Every time we did this, it would come back sort of unrecognizable. He would make a large number of changes and it'd come back to me and I'd make a large number of changes.</p>
<p class="normal"><b>Seibel：</b>它们是富有成效的改变吗？</p><p class="normal"><b>Seibel:</b> And they were productive changes?</p>
<p class="normal"><b>阿姆斯特朗：</b>哦，当然。如果他找到更好的做事方式，我会很高兴。我们都相处得很好。他曾经概括。我记得有一次我找到了一个变量——我跟着它转了一圈又一圈，完成了大约 45 个例程，然后，它出现了，最后，甚至从未使用过。他只是将这个变量传入和传出 45 个不同的函数。我说：“这是干嘛的？<a id="OEBPS/Chapter06.html.page_230"></a>你不用它。” 他说：“我知道。为将来的扩展保留。” 所以我删除了它。</p><p class="normal"><b>Armstrong:</b> Oh, absolutely. I was delighted if he found better ways of doing things. We both got on very well. He used to generalize. I remember once I found a variable—I followed it round and round through about 45 routines and then, out it came, at the end, never even used. He just passed this variable in and out of 45 different functions. I said, “What's that for? <a></a>You don't use it.” He said, “I know. Reserved for future expansion.” So I removed that.</p>
<p class="normal">我会编写一个特定的算法，删除该程序不需要的所有内容。每当我得到程序时，它变得更短，因为它变得更具体。每当罗伯特参加我的课程时，它就会变得更长，增加了通用性。我相信这个 Unix 哲学——一个程序应该做它应该做的事<i>，而不是别的</i>。罗伯特的理念是它应该是一个通用程序，然后程序本身应该是通用程序的一个特定案例。所以他会增加通用性，然后专门化它。</p><p class="normal">I would write a specific algorithm removing all things that were not necessary for this program. Whenever I got the program, it became shorter as it became more specific. And whenever Robert took my program it became longer, adding generality. I believe this Unix philosophy—a program should do what it's supposed to do <i>and nothing else</i>. And Robert's philosophy is it should be a general program and then the program itself should be a specific case of the general program. So he would add generality and then specialize it.</p>
<p class="normal"><b>Seibel：</b>这似乎是一个相当深的哲学鸿沟。让项目经历这两个极端有什么好处吗？</p><p class="normal"><b>Seibel:</b> That seems like a pretty deep philosophical divide. Was there any benefit to having the program go through those two extremes?</p>
<p class="normal"><b>阿姆斯特朗：</b>哦，是的。每个周期它都会改进。因此，我认为情况要好得多。并且可能比我们中的任何一个人都做得更好。</p><p class="normal"><b>Armstrong:</b> Oh yes. Every cycle it improved. I think it was a lot better because of that. And probably better than either of us could have done on our own.</p>
<p class="normal"><b>Seibel：</b>您能谈谈您是如何设计软件的吗？也许以 OTP 为例。</p><p class="normal"><b>Seibel:</b> Can you talk about how you design software? Maybe take example of something like OTP.</p>
<p class="normal"><b>阿姆斯特朗：</b>OTP 是由我和 Martin Björklund 以及 Magnus Fröberg 设计的。只有我们三个人做了最初的设计。我们每天早上在喝咖啡的时候见面，并进行长时间的交谈——大约一到两个小时——然后我们在白板上写满了东西。我会做很多笔记——我立即写下所有的文档，他们写下所有的代码。有时我也会写一些代码。当我编写我发现的文档时，我无法描述这一点，我们必须对其进行更改。或者他们会碰到我说，“不，它不起作用；我们今天早上的这个想法，因为这个，这个，这个，这个，它行不通。” 在一天结束的时候，我们要么得到了所有文档和所有代码，要么得到了足够的代码和足够的文档，我们知道它会起作用。</p><p class="normal"><b>Armstrong:</b> OTP was designed by me and Martin Björklund and Magnus Fröberg. There were just the three of us did the original design. We met every morning at coffee and had a long conversation—about an hour to two hours—and we covered the white board in stuff. I'd take loads of notes—I wrote all the documentation immediately and they wrote all the code. Sometimes I'd write a bit of code as well. And when I was writing the documentation I'd discover, I can't describe this, we have to change it. Or they would run into me and say, “Nah, it doesn't work; this idea we had this morning, because of this, this, this, and this it doesn't work.” At the end of the day we either got to the point where we got all the documentation and all the code or enough of the code and enough of the documentation that we knew it was going to work. And then we called it a day.</p>
<p class="normal">有些日子它不起作用，所以我们说，“好吧，我们明天再做一次。” 没有足够的时间在一天内完成第二遍。但是一天大约一次通过就可以了。因为它给了我们大约两个小时的时间来在早上讨论它，大约两个小时来编写文档或编写代码。而如果<a id="OEBPS/Chapter06.html.page_231"></a>你真的花了四个小时认真思考，这是一天的工作。所以这非常非常有效。我不知道我们这样工作了多久。十周，十二周之类的。然后我们得到了基本框架，然后我们有了更多的人。我们已经指定了架构——现在我们可以开始发展它了。我们会再招三四个程序员。</p><p class="normal">Some days it didn't work so we said, “OK, we'll do it again tomorrow.” There wasn't enough time to do a second pass in a day. But about one pass in a day worked fine. Because it gives us about two hours to discuss it in the morning, about two hours to write the documentation or code it up. And if <a></a>you spent four hours really thinking hard, that's a good day's work. So that worked very, very well. I don't know how long we worked like that for. Ten weeks, twelve weeks, something like that. And then we got the basic framework and then we had more people. We'd specified the architecture—now we could start growing it. We'd get three or four more programmers in.</p>
<p class="normal"><b>Seibel：</b>然后你是如何为这些新人分配工作的？</p><p class="normal"><b>Seibel:</b> And then how did you divvy up the work for those new folks?</p>
<p class="normal"><b>阿姆斯特朗：</b>好吧，我们知道什么是原型，什么是最终版本。我一直认为系统设计，你先解决困难的问题。找出困难的问题，然后解决它们。然后是简单的问题，你知道它们很快就会暴露出来。所以在将它们分为简单和困难方面有一些经验。我知道 IP 故障转移或类似的东西会相当困难。但我知道解析配置文件会很容易。在原型中，您可能只有一个您阅读的配置文件。你没有语法检查它——你没有语法。在生产版本中，您可以使用 XML 来完成它并拥有完整的语法并对其进行验证。但你知道这是一个机械步骤。一个称职的程序员需要几个星期，或者任何需要的时间。但它是可行的，它是可以及时预测的，并且在途中不应该有任何令人讨厌的意外。但是让通信协议正确，并在出现故障时让它们正常工作，我会在一个小组中做。</p><p class="normal"><b>Armstrong:</b> Well, we knew what were prototypes and what were final versions. I've always taken the view of system design, you solve the hard problems first. Identify the hard problems and then solve them. And then the easy problems, you know they'll just come out in the wash. So there's a bit of experience there in classifying them as easy and hard. I know IP fail-over or something like that is going to be fairly hard. But I know that parsing a configuration file is going to be easy. In the prototype you might just have a configuration file that you read. You don't syntax check it—you don't have a grammar. In the production version you might do it in XML and have a complete grammar and validate it. But you know that that's a mechanical step to do that. It will take a competent programmer several weeks, or whatever time it takes. But it's doable, it's predictable in time, and there shouldn't be any nasty surprises on the way. But getting the communication protocols right, and getting them working properly when things fail, that I would do in a small group.</p>
<p class="normal"><b>Seibel：</b>所以在这种情况下，您在编写代码之前或至少在编写代码时编写了文档。你通常是这样做的吗？</p><p class="normal"><b>Seibel:</b> So in this case you wrote the documentation before, or at least while, the code was being written. Is that how you usually do it?</p>
<p class="normal"><b>阿姆斯特朗：</b>这取决于问题的难度。我认为对于非常困难的问题，我通常会从编写文档开始。越难，我越有可能先记录下来。</p><p class="normal"><b>Armstrong:</b> It depends on the difficulty of the problem. I think with very difficult problems I quite often start right by writing the documentation. The more difficult it is, the more likely I am to document it first.</p>
<p class="normal">我喜欢文档。在您编写了一些合理的文档之前，我不认为程序已经完成。我非常喜欢一个规范。我认为那些说“它有什么作用？阅读代码。” 代码向我展示了它<i>的作用</i>。它没有告诉我它应该做什么。我认为代码是问题的答案。如果您没有规范或没有任何文档，则必须猜测问题出在哪里<a id="OEBPS/Chapter06.html.page_232"></a>来自答案。你可能猜错了。我想知道问题出在哪里。</p><p class="normal">I like documentation. I don't think a program is finished until you've written some reasonable documentation. And I quite like a specification. I think it's unprofessional these people who say, “What does it do? Read the code.” The code shows me what it <i>does</i>. It doesn't show me what it's supposed to do. I think the code is the answer to a problem. If you don't have the spec or you don't have any documentation, you have to guess what the problem <a></a>is from the answer. You might guess wrong. I want to be told what the problem is.</p>
<p class="normal"><b>Seibel：</b>您在这个阶段编写的文档是其他程序员会阅读的内部文档还是用户文档？</p><p class="normal"><b>Seibel:</b> Is the documentation you write at this stage internal documentation that another programmer would read or documentation for the user?</p>
<p class="normal"><b>阿姆斯特朗：</b>这是给用户指南的。它让我进入了一种不同的思维模式。我刚开始，为了做到这一点，创建一个名为 that 的目录，将这个文件放在那里，将其重命名为 that 并引导结构。我有点想过这个问题。我敢打赌 Knuth 会说，“嗯，所有的程序都是文字程序。” 您不会编写代码然后编写文档。您同时编写两者，因此这是一个文字程序。我不在那里。我不这么认为。我不知道他的观点是不是因为他发表了他的节目。</p><p class="normal"><b>Armstrong:</b> It's for user guides. It sort of switches me into a different mode of thinking. I just start, in order to do this, create a directory called that, put this file in there, rename this as that and that is guiding the structure. I've sort of pondered the question. I bet Knuth would say, “Well, all programs are literate programs.” You don't write the code and then write the documentation. You write both at the same time, so it's a literate program. I'm not there. I don't think that. I don't know if his view is because he publishes his programs.</p>
<p class="normal">我不知道这是左脑/右脑转变，还是什么，但是当您编写文档时，您对程序的看法与编写代码时不同。所以我想编写读写程序的力量会随着您的编写而发生变化。这可能非常有成效。我确实做了一些识字的 Erlang，尽管我已经很长时间没有真正使用过它了。所以这是一个有趣的想法——也许我应该再次唤醒它并使用有文化的 Erlang 编写一些东西。我不反对这个想法，但我有点不耐烦，想写代码而不是文档。但如果你真的想理解它，那么我认为编写文档是必不可少的一步。</p><p class="normal">I don't know if it's a left-brain/right-brain shift, or what it is, but when you write the documentation you think about the program differently to when you write the code. So I guess writing literate programs forces that shift as you're doing it. Which might be very productive. I did do some literate Erlang though I haven't actually used it for a very long time. So that's an interesting idea—perhaps I should wake it up again and write some stuff using literate Erlang. I'm not against the idea but I'm sort of impatient and wanted to write the code and not the documentation. But if you really want to understand it then I think writing the documentation is an essential step.</p>
<p class="normal">如果我在为 Haskell 编程，我将被迫很早地考虑类型并记录它们并写下来。如果您正在使用 Lisp 或 Erlang 进行编程，那么您可以开始编写代码并且您还没有真正考虑过类型。在某种程度上，编写文档就是在某种程度上考虑类型。我想你从“是一个”开始。你说，“旋律是一系列音符。” 正确的。好的。旋律是一系列和弦，其中每个和弦都是相同时长的音符的平行组合。只需在文档中定义术语（某物就是某物），您就在进行某种类型分析，并且您正在以声明方式思考数据结构是什么。</p><p class="normal">If I were programming Haskell, I would be forced to think about the types pretty early and document them and write them down. If you're programming in Lisp or Erlang you can start writing the code and you haven't really thought about the types. And in a way, writing the documentation is thinking about the types in a way. I suppose you start off with “is a”. You say, “A melody is a sequence of notes.” Right. OK. A melody is a sequence of chords where each chord is a parallel composition of notes of the same duration. Just by defining terms in your documentation—a something is a something—you're doing a sort of type analysis and you're thinking declaratively about what the data structures are.</p>
<p class="normal"><b>Seibel：</b>你认为整体编程语言正在变得更好吗？我们是否正处于从过去吸取足够教训并提出足够新想法的轨道上？</p><p class="normal"><b>Seibel:</b> Do you think overall programming languages are getting better? Are we on a trajectory where we learn enough lessons from the past and come up with enough new ideas?</p>
<p class="normal"><a id="OEBPS/Chapter06.html.page_233"></a><b>阿姆斯特朗：</b>是的。新语言很好。Haskell 之类的东西。二郎。然后是一些真正应该使用的有趣的语言。Prolog 是一种美丽的语言，但并未被广泛使用。它有点达到顶峰；Kowalski 称其为寻找问题的解决方案。</p><p class="normal"><a></a><b>Armstrong:</b> Yes. The new languages are good. Haskell and things like that. Erlang. Then there are some funny languages that should really be used. Prolog is a beautiful language but not widely used. It sort of peaked; Kowalski called it a solution looking for a problem.</p>
<p class="normal"><b>Seibel：</b> Dan Ingalls 以 Prolog 为例来说明我们应该真正重新审视的想法，因为我们已经有了几十年的摩尔定律。</p><p class="normal"><b>Seibel:</b> Dan Ingalls mentioned Prolog as an example of the kind of idea that we should really revisit now that we've had a couple decades of Moore's Law.</p>
<p class="normal"><b>Armstrong：</b> Prolog 与所有其他编程语言截然不同。这就是这种惊人的思维方式。它并不适用于所有问题。但它适用于非常大的一组问题。它没有被广泛使用。这是一个很大的耻辱，因为程序非常短。我想我在编写我的第一个 Prolog 程序时感到震惊。这是一种震撼的体验。你随便走走，程序呢——我还没写程序呢。你只是告诉它一些关于系统和你的问题的事实。在这里，它正在弄清楚该怎么做。太棒了。我应该回到 Prolog——放弃 Erlang。</p><p class="normal"><b>Armstrong:</b> Prolog is so different to all the other programming languages. It's just this amazing way of thinking. And it's not appropriate to all problems. But it is appropriate to an extremely large set of problems. It's not widely used. And it's a great shame because programs are incredibly short. I think I went into shock when I wrote my first Prolog program. It's a kind of shocking experience. You just walk around going, where's the program—I haven't written a program. You just told it a few facts about the system, about your problem. Here it is figuring out what to do. It's wonderful. I should go back to Prolog—drop Erlang.</p>
<p class="normal"><b>Seibel：</b>是否有其他与编程没有直接关系的技能，但您认为这些技能提高了您的编程水平，或者对程序员来说很有价值？</p><p class="normal"><b>Seibel:</b> Are there other skills that are not directly related to programming that you feel have improved your programming or that are valuable to have as a programmer?</p>
<p class="normal"><b>阿姆斯特朗：</b>写作是。有一些计算机科学家说，“哦，如果你不擅长英语，你永远不会成为一个很好的程序员。”</p><p class="normal"><b>Armstrong:</b> Writing is. There's some computer scientist that said, “Oh, if you're no good at English you'll never be a very good programmer.”</p>
<p class="normal"><b>Seibel：</b>我认为 Dijkstra 对此有所了解。</p><p class="normal"><b>Seibel:</b> I think Dijkstra had something about that.</p>
<p class="normal"><b>阿姆斯特朗：</b>我偶尔会被要求就计算机科学课程的教学大纲科目的选择向大学的人提出建议，就像我在工业界工作一样——工业界想要什么？我说，“好吧，让他们变得能够有说服力地写作和辩论。” 大多数出来的毕业生，他们都有计算机科学学位，写作不是他们的强项。</p><p class="normal"><b>Armstrong:</b> I've occasionally been asked to advise people at universities on choice of syllabus subjects for computer science courses, being as how I work for industry—what does industry want? And I say, “Well, turn 'em out being able to write and argue cogently.” Most graduates who come out, and they've got degrees in computer science, writing's not their strong point.</p>
<p class="normal">我认为这实际上很难教，因为它非常个人化。必须有人拿着你的文字和红笔向你解释你做错了什么。这非常耗时。你读过海明对年轻研究人员的建议吗？</p><p class="normal">I think it's actually very difficult to teach because it's very individual. Somebody's got to take your text and a red pen and explain to you what you did wrong. And that's very time consuming. Have you ever read Hamming's advice to young researchers?</p>
<p class="normal"><a id="OEBPS/Chapter06.html.page_234"></a><b>Seibel：</b> “你和你的研究”？</p><p class="normal"><a></a><b>Seibel:</b> “You and Your Research”?</p>
<p class="normal"><b>阿姆斯特朗：</b>他会说“做好事”之类的话。他说，“如果你不做好事，在好的领域，你做什么都没用。” 汉明说，“我总是每周花一天时间学习新东西。这意味着我花在学习新东西上的时间比我的同事多 20%。现在 20% 的复利意味着四年半后我知道的会是他们的两倍。由于复利，这 20% 的额外费用，每周一天，五年后我会知道三倍，”或者不管数字是什么。我认为这是真的。因为我做研究，所以我不会花 20% 的时间思考新事物，我会花 40% 的时间思考新事物。我已经做了 30 年了。所以我注意到我知道很多东西。当我作为故障排除者被拉进来时，砰的一声，那样做，那样做。您之前问过应该怎么做才能成为更好的程序员？花 20% 的时间学习东西——因为它是复合的。阅读汉明的论文。很好。非常好。</p><p class="normal"><b>Armstrong:</b> He says things like, “Do good stuff.” He says, “If you don't do good stuff, in good areas, it doesn't matter what you do.” And Hamming said, “I always spend a day a week learning new stuff. That means I spend 20 percent more of my time than my colleagues learning new stuff. Now 20 percent at compound interest means that after four and a half years I will know twice as much as them. And because of compound interest, this 20 percent extra, one day a week, after five years I will know three times as much,” or whatever the figures are. And I think that's very true. Because I do research I don't spend 20 percent of my time thinking about new stuff, I spend 40 percent of my time thinking about new stuff. And I've done it for 30 years. So I've noticed that I know a lot of stuff. When I get pulled in as a troubleshooter, boom, do it that way, do it that way. You were asking earlier what should one do to become a better programmer? Spend 20 percent of your time learning stuff—because it's compounded. Read Hamming's paper. It's good. Very good.</p>
<p class="normal"><b>Seibel：</b>你觉得有些代码漂亮吗？</p><p class="normal"><b>Seibel:</b> Do you find some code beautiful?</p>
<p class="normal"><b>阿姆斯特朗：</b>是的。这是为什么我不知道。有趣的是，如果你给两个程序员同样的问题——这取决于问题，但更数学性质的问题，他们通常最终会写出相同的代码。仅受格式问题和重新标记变量和函数名称的影响，它是同构的——它是完全相同的算法。我们是在创造这些东西，还是只是在扯掉蜘蛛网？它就像一座雕像在那里，我们正在拉掉蜘蛛网并揭示一直存在的算法。那么我们是在发明一种新算法还是在发明一种已经存在的结构？有些算法就是这样。我认为更多的是数学算法。当我实施电话协议或其他东西时，我没有那种感觉。那'</p><p class="normal"><b>Armstrong:</b> Yes. Why this is I don't know. The funny thing is, if you give two programmers the same problem—it depends on the problem, but problems of a more mathematical nature, they can often end up writing the same code. Subject to just formatting issues and relabeling the variables and the function names, it's isomorphic—it's exactly the same algorithms. Are we creating these things or are we just pulling the cobwebs off? It's like a statue that's there and we're pulling the cobwebs off and revealing the algorithm that's always been there. So are we inventing a new algorithm or are we inventing a structure that already exists? Some algorithms feel like that. I think it's more the mathematical algorithms. I don't get that feeling when I'm implementing a telephony protocol or something. That's not a statue that I'm pulling the cobwebs off.</p>
<p class="normal"><b>Seibel：</b>所以这类似于数学之美，因为它是自然的一部分。然后还有其他级别的代码在某种程度上具有美感。</p><p class="normal"><b>Seibel:</b> So that's similar to the beauty of math, because it's part of nature. Then there are other levels at which code sort of has an aesthetic.</p>
<p class="normal"><b>阿姆斯特朗：</b>是的。这有点像风水。我喜欢简约的代码，非常漂亮、结构化的代码。如果你开始删除东西，如果你到了这样的地步，如果你要删除更多的东西，那将不起作用<a id="OEBPS/Chapter06.html.page_235"></a>不再——此时它是美丽的。你可以想象做出的每一个改变都会使它成为一个更糟糕的算法，到那时它就会变得漂亮。</p><p class="normal"><b>Armstrong:</b> Yeah. It's kind of feng shui. I like minimalistic code, very beautifully poised, structured code. If you start removing things, if you get to the point where if you were to remove anything more it would not work <a></a>any more—at this point it is beautiful. Where every change that you could conceivably make, makes it a worse algorithm, at that point it becomes beautiful.</p>
<p class="normal"><b>Seibel：</b>你提到当你和 Robert Virding 来回传递代码时，你们每个人如何更改格式化的低级细节，这是程序员无休止争论的问题。</p><p class="normal"><b>Seibel:</b> You mentioned that when you and Robert Virding were passing the code back and forth how each of you changed the low-level details of formatting, stuff that programmers argue endlessly about.</p>
<p class="normal"><b>阿姆斯特朗：</b>这不会影响算法的美感。</p><p class="normal"><b>Armstrong:</b> That's not affecting the beauty of the algorithm.</p>
<p class="normal"><b>Seibel：</b>但这是审美的一部分。这是人的口味。</p><p class="normal"><b>Seibel:</b> But it's part of the aesthetic. It's people's taste.</p>
<p class="normal"><b>阿姆斯特朗：</b>是的。但我不会说，“这是丑陋的代码，因为逗号后面有一个空格。” 丑陋的是当它通过线性搜索完成时，它可以通过二进制间隔减半来完成。或者它可以以对数方式完成并且以线性方式完成。出于错误的原因。如果我们知道我们正在搜索包含 10 个元素的列表，当然可以线性搜索，谁在乎呢？但如果它是一个大数据结构，那么它应该用二进制搜索来完成。因此，以线性形式执行它真的不是很漂亮。数学算法——就像柏拉图式的美。这更像是建筑。你欣赏一座精美的建筑——它不是一个数学对象。不是固体、球体或棱镜——它是一座摩天大楼。看起来很好。</p><p class="normal"><b>Armstrong:</b> Yeah. But I wouldn't say, “This is ugly code because there's a blank after the comma.” Ugly is when it's done with a linear search and it could have been done with a binary interval halving. Or it could have done logarithmically and it's done linearly. For the wrong reasons. Sure do it linearly if we know we're searching through a list of ten elements, who cares? But if it's a big data structure then it should have been done with a binary search. And so it's really not very pretty to do it in a linear form. The mathematical algorithms—that's like Platonic beauty. This is more like architecture. You admire a fine building—it's not a mathematical object. Not a solid or a sphere or a prism—it's a skyscraper. It looks nice.</p>
<p class="normal"><b>Seibel：</b>是什么造就了一个好的程序员？如果你正在招聘程序员——你在寻找什么？</p><p class="normal"><b>Seibel:</b> What makes a good programmer? If you are hiring programmers—what do you look for?</p>
<p class="normal"><b>阿姆斯特朗：</b>我认为是问题的选择。你是被问题驱动还是被解决方案驱动？我倾向于喜欢那些说“我遇到了这个非常有趣的问题”的人。然后你问，“你写过的最有趣的项目是什么？给我看这个东西的代码。你会如何解决这个问题？” 我不太在意他们对 X 语言或 Y 语言的了解程度。从我所见的程序员来看，他们要么精通所有语言，要么一门都不精通。优秀的 C 程序员会擅长 Erlang——这是一个非常好的预测器。我见过例外情况，但擅长一种语言所必需的心理技能似乎可以转化为其他语言。</p><p class="normal"><b>Armstrong:</b> Choice of problem, I think. Are you driven by the problems or by the solutions? I tend to favor the people who say, “I've got this really interesting problem.” Then you ask, “What was the most fun project you ever wrote; show me the code for this stuff. How would you solve this problem?” I'm not so hung up on what they know about language X or Y. From what I've seen of programmers, they're either good at all languages or good at none. The guy who's a good C programmer will be good at Erlang—it's an incredibly good predictor. I have seen exceptions to that but the mental skills necessary to be good at one language seem to convert to other languages.</p>
<p class="normal"><b>Seibel：</b>一些公司以在面试中使用逻辑谜题而闻名。你在采访中问过人们这样的问题吗？</p><p class="normal"><b>Seibel:</b> Some companies are famous for using logic puzzles during interviews. Do you ask people that kind of question in interviews?</p>
<p class="normal"><a id="OEBPS/Chapter06.html.page_236"></a><b>阿姆斯特朗：</b>不，一些非常优秀的程序员在这类事情上有点慢。从事 Erlang 工作的人之一，他获得了数学博士学位，我对他唯一的类比，就像金刚石钻头在花岗岩上钻孔。我记得他得了流感，所以他把 Erlang 列表带回家了。然后他进来了，他在 Erlang 程序中写了一个原子，他说，“这将使模拟器进入无限循环。” 他发现这个原子的初始散列值恰好为零，我们取了一些东西来获得下一个值，结果也为零。因此，他针对一个病态案例对哈希算法进行了逆向工程。他甚至没有执行这些程序来查看它们是否会起作用；他阅读程序。但他并没有很快做到。他读得很慢。我不</p><p class="normal"><a></a><b>Armstrong:</b> No. Some very good programmers are kind of slow at that kind of stuff. One of the guys who worked on Erlang, he got a PhD in math, and the only analogy I have of him, it's like a diamond drill drilling a hole through granite. I remember he had the flu so he took the Erlang listings home. And then he came in and he wrote an atom in an Erlang program and he said, “This will put the emulator into an infinite loop.” He found the initial hash value of this atom was exactly zero and we took something mod something to get the next value which also turned out to be zero. So he reverse engineered the hash algorithm for a pathological case. He didn't even execute the programs to see if they were going to work; he read the programs. But he didn't do it quickly. He read them rather slowly. I don't know how good he would have been at these quick mental things.</p>
<p class="normal"><b>Seibel：</b>好的程序员还有其他特征吗？</p><p class="normal"><b>Seibel:</b> Are there any other characteristics of good programmers?</p>
<p class="normal"><b>阿姆斯特朗：</b>我在某处读到，要成为一名合理的程序员，你必须拥有良好的记忆力。我相信这是真的。</p><p class="normal"><b>Armstrong:</b> I read somewhere, that you have to have a good memory to be a reasonable programmer. I believe that to be true.</p>
<p class="normal"><b>Seibel：</b> Bill Gates 曾经声称，他仍然可以走到黑板前，将他为 Altair 编写的 BASIC 代码写成大块，这比他最初编写的代码晚了大约十年。你认为你可以那样记住你的旧代码吗？</p><p class="normal"><b>Seibel:</b> Bill Gates once claimed that he could still go to a blackboard and write out big chunks of the code to the BASIC that he had written for the Altair, a decade or so after he had originally written it. Do you think you can remember your old code that way?</p>
<p class="normal"><b>阿姆斯特朗：</b>是的。好吧，我可以重建一些东西。有时我只是完全丢失了一些旧代码，而我一点也不担心。我没有清单或任何东西；只需再次输入即可。这在逻辑上是等价的。一些变量名称会改变，文件中函数的顺序会改变，函数的名称也会改变。但它几乎是同构的。或者我输入的是一个改进版本，因为我的大脑已经在工作了。</p><p class="normal"><b>Armstrong:</b> Yeah. Well, I could reconstruct something. Sometimes I've just completely lost some old code and it doesn't worry me in the slightest. I haven't got a listing or anything; just type it in again. It would be logically equivalent. Some of the variable names would change and the ordering of the functions in the file would change and the names of the functions would change. But it would be almost isomorphic. Or what I would type in would be an improved version because my brain had worked at it.</p>
<p class="normal">以我十年前编写的编译器中的模式匹配为例。我可以坐下来输入它。它会与原始版本不同，但如果我凭记忆输入，它会是一个改进版本。因为它会在你什么都不做的时候自我提升。但它可能有一个非常相似的结构。</p><p class="normal">Take the pattern matching in the compiler which I wrote ten years ago. I could sit down and type that in. It would be different to the original version but it'd be an improved version if I did it from memory. Because it sort of improves itself while you're not doing anything. But it'd probably have a pretty similar structure.</p>
<p class="normal">我不担心丢失代码或类似的东西。你记住的是你头脑中的这些模式。好吧，我什至不能说你记得他们。<a id="OEBPS/Chapter06.html.page_237"></a>你可以再做一次。没有那么多回忆。当我说你可以准确地记住一个程序时，我不认为它真的在记住。但你可以再做一次。如果比尔能记住实际的文字，我就做不到。但是我当然可以很长一段时间记住这个结构。</p><p class="normal">I'm not worried about losing code or anything like that. It's these patterns in your head that you remember. Well, I can't even say you remember them. <a></a>You can do it again. It's not so much remembering. When I say you can remember a program exactly, I don't think that it's actually remembering. But you can do it again. If Bill could remember the actual text, I can't do that. But I can certainly remember the structure for quite a long time.</p>
<p class="normal"><b>Seibel：</b> Erlang 风格的消息是否传递了解决并发编程问题的灵丹妙药？</p><p class="normal"><b>Seibel:</b> Is Erlang-style message passing a silver bullet for slaying the problem of concurrent programming?</p>
<p class="normal"><b>阿姆斯特朗：</b>哦，不是。这是一个进步。它比共享内存编程好很多。我认为这是 Erlang 所做的一件事——它实际上已经证明了这一点。当我们第一次使用 Erlang 时，我们去参加会议并说，“你应该复制你所有的数据。” 而且我认为他们接受了关于容错的争论——复制所有数据的原因是为了使系统容错。他们说，“如果你这样做，效率会非常低，”我们说，“是的，它会，但它会容错。”</p><p class="normal"><b>Armstrong:</b> Oh, it's not. It's an improvement. It's a lot better than shared memory programming. I think that's the one thing Erlang has done—it has actually demonstrated that. When we first did Erlang and we went to conferences and said, “You should copy all your data.” And I think they accepted the arguments over fault tolerance—the reason you copy all your data is to make the system fault tolerant. They said, “It'll be terribly inefficient if you do that,” and we said, “Yeah, it will but it'll be fault tolerant.”</p>
<p class="normal">令人惊讶的是它在某些情况下效率更高。我们出于容错原因所做的事情，在许多情况下，结果证明与共享一样有效，甚至<i>更有效。</i></p><p class="normal">The thing that is surprising is that it's more efficient in certain circumstances. What we did for the reasons of fault tolerance, turned out to be, in many circumstances, just as efficient or even <i>more</i> efficient than sharing.</p>
<p class="normal">然后我们问了一个问题，“为什么会这样？” 因为它增加了并发。当您共享时，您必须在访问数据时锁定数据。而且您已经忘记了锁的成本。也许您正在复制的数据量并不大。如果您正在复制的数据量非常小，并且如果您正在进行大量更新和访问以及大量锁定，那么突然复制所有内容并不是那么糟糕。然后在多核上，如果你有旧的共享模型，锁可以停止所有的核。你有一个千核 CPU，一个程序进行全局锁定——所有千核都必须停止。</p><p class="normal">Then we asked the question, “Why is that?” Because it increased the concurrency. When you're sharing, you've got to lock your data when you access it. And you've forgotten about the cost of the locks. And maybe the amount of data you're copying isn't that big. If the amount of data you're copying is pretty small and if you're doing lots of updates and accesses and lots of locks, suddenly it's not so bad to copy everything. And then on the multicores, if you've got the old sharing model, the locks can stop all the cores. You've got a thousand-core CPU and one program does a global lock—all the thousand cores have got to stop.</p>
<p class="normal">我也非常怀疑隐式并行性。您的编程语言可以具有并行结构，但如果它没有映射到并行的硬件，如果它只是被您的编程系统模拟，那么它就没有好处。因此，存在三种类型的硬件并行性。</p><p class="normal">I'm also very skeptical about implicit parallelism. Your programming language can have parallel constructs but if it doesn't map into hardware that's parallel, if it's just being emulated by your programming system, it's not a benefit. So there are three types of hardware parallelism.</p>
<p class="normal">存在流水线并行性——因此您可以在芯片中制作更深的流水线，这样您就可以并行处理事情。好吧，当你设计时，那是一劳永逸的<a id="OEBPS/Chapter06.html.page_238"></a>芯片。普通程序员对指令级并行性无能为力。</p><p class="normal">There's pipeline parallelism—so you make a deeper pipeline in the chip so you can do things in parallel. Well, that's once and for all when you design <a></a>the chip. A normal programmer can't do anything about the instruction-level parallelism.</p>
<p class="normal">有数据并行性，这不是真正的并行性，但它与缓存行为有关。如果你想让一个C程序高效运行，如果<code>*p</code>是在16字节的边界上，如果你访问<code>*p</code>，那么访问<code>*(p + 1)</code>是免费的，基本上，因为缓存行把它拉进来了。然后你需要担心多宽高速缓存行是——在一次高速缓存传输中你拉入了多少字节？这就是数据并行性，程序员可以通过非常小心地了解它们的结构并准确了解它在内存中的布局来使用它。乱七八糟的东西——你真的不想那样做。</p><p class="normal">There's data parallelism, which is not really parallelism but it has to do with cache behavior. If you want to make a C program go efficiently, if <code>*p</code> is on a 16-byte boundary, if you access <code>*p</code>, then the access to <code>*(p + 1)</code> is free, basically, because the cache line pulls it in. Then you need to worry about how wide the cache lines are—how many bytes do you pull in in one cache transfer? That's data parallelism, which the programmer can use by being very careful about their structures and knowing exactly how it's laid out in memory. Messy stuff—you don't really want to do that.</p>
<p class="normal">芯片中真正并发的另一个来源是多核。到本世纪末将有 32 个内核，到 2019 年或其他时间将有 100 万个内核。所以你必须在你的程序中获取并发的颗粒并将它们映射到计算机的核心。当然这是一个相当重量级的操作。在不同的核心上开始计算并得到答案本身就是一件需要时间的事情。因此，如果您只是将两个数字加在一起，那是不值得的——与在原地进行相比，您将花费更多的精力将其移至另一个核心并进行计算并获得答案。</p><p class="normal">The other source of real concurrency in the chip are multicores. There'll be 32 cores by the end of the decade and a million cores by 2019 or whatever. So you have to take the granules of concurrency in your program and map them onto the cores of the computer. Of course that's quite a heavyweight operation. Starting a computation on a different core and getting the answer back is itself something that takes time. So if you're just adding two numbers together, it's just not worth the effort—you're spending more effort in moving it to another core and doing it and getting the answer back than you are in doing it in place.</p>
<p class="normal">Erlang 非常适合那里，因为程序员说过，“我想要一个进程，我想要另一个进程，我想要另一个进程。” 然后我们把它们放在核心上。也许我们应该考虑实际将它们放在核心上。可能产生另一个进程的进程与该进程对话。所以如果我们把它放在物理上靠近的核心上，那是放置它的好地方，而不是放在很远的地方。也许如果我们知道它<i>不是</i>经常和它交谈也许我们可以把它放在很远的地方。也许执行 I/O 的进程应该靠近芯片的边缘——那些与 I/O 进程对话的进程。随着芯片变得越来越大，我们将不得不考虑如何将数据传输到芯片中间比传输到芯片边缘成本更高。也许你有两个或三个服务器和一个数据库，也许你要把它映射到核心上，所以我们会把数据库放在芯片的中间，这些与客户端通信，所以我们会把它们放在靠近芯片的边缘。我不知道——这是研究。</p><p class="normal">Erlang's quite well suited there because the programmer has said, “I want a process, I want another process, I want another process.” Then we just put them on the cores. And maybe we should be thinking about actually physically placing them on cores. Probably a process that spawns another process talks to that process. So if we put it on a core that's physically near, that's a good place to put it, not on one that's a long way away. And maybe if we know it's <i>not</i> going to talk to it a lot maybe we can put it a long way away. And maybe processes that do I/O should be near the edge of the chip—the ones that talk to the I/O processes. As the chips get bigger we're going to have to think about how getting data to the middle of the chip is going to cost more than getting it to the edge of the chip. Maybe you've got two or three servers and a database and maybe you're going to map this onto the cores so we'll put the database in the middle of the chip and these ones talk to the client so we'll put them near the edge of the chip. I don't know—this is research.</p>
<p class="normal"><a id="OEBPS/Chapter06.html.page_239"></a><b>Seibel：</b>您非常关心 Erlang 的并发方式。你更关心那个想法——消息传递的无共享并发——还是 Erlang 语言？</p><p class="normal"><a></a><b>Seibel:</b> You care a lot about the idea of Erlang's way of doing concurrency. Do you care more about that idea—the message-passing shared-nothing concurrency—or Erlang the language?</p>
<p class="normal"><b>阿姆斯特朗：</b>这个想法——当然。人们一直在问我，“Erlang 会怎样？它会成为一种流行的语言吗？” 我不知道。我认为它已经产生了影响。它最终可能会像 Smalltalk 一样。我认为 Smalltalk 非常非常有影响力，并受到一群热情的人的喜爱，但从未真正被广泛采用。我认为 Erlang 可能就是这样。它可能需要微软采纳它的一些想法，在这里和那里加上一些花括号，然后将它推到公共语言运行时中，以打入大众市场。</p><p class="normal"><b>Armstrong:</b> The idea—absolutely. People keep on asking me, “What will happen to Erlang? Will it be a popular language?” I don't know. I think it's already been influential. It might end up like Smalltalk. I think Smalltalk's very, very influential and loved by an enthusiastic band of people but never really very widely adopted. And I think Erlang might be like that. It might need Microsoft to take some of its ideas and put some curly braces here and there and shove it out in the Common Language Runtime to hit a mass market.</p>
</div>
</div></div>
<div id="OEBPS/Chapter07.html"><div>

<div class="booksection">
<p></p>
<h2 class="chapnum"><a id="OEBPS/Chapter07.html.ch7"></a><a id="OEBPS/Chapter07.html.page_241"></a><img src="data:image/jpg;base64,/9j/4AAQSkZJRgABAgEASABIAAD/7Qu2UGhvdG9zaG9wIDMuMAA4QklNA+0KUmVzb2x1dGlvbgAAAAAQAEgAAAABAAEASAAAAAEAAThCSU0EDRhGWCBHbG9iYWwgTGlnaHRpbmcgQW5nbGUAAAAABAAAAHg4QklNBBkSRlggR2xvYmFsIEFsdGl0dWRlAAAAAAQAAAAeOEJJTQPzC1ByaW50IEZsYWdzAAAACQAAAAAAAAAAAQA4QklNBAoOQ29weXJpZ2h0IEZsYWcAAAAAAQAAOEJJTScQFEphcGFuZXNlIFByaW50IEZsYWdzAAAAAAoAAQAAAAAAAAACOEJJTQP1F0NvbG9yIEhhbGZ0b25lIFNldHRpbmdzAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+BdDb2xvciBUcmFuc2ZlciBTZXR0aW5ncwAAAHAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAOEJJTQQAC0xheWVyIFN0YXRlAAAAAgABOEJJTQQCDExheWVyIEdyb3VwcwAAAAAEAAAAADhCSU0ECAZHdWlkZXMAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4NVVJMIG92ZXJyaWRlcwAAAAQAAAAAOEJJTQQaBlNsaWNlcwAAAAB1AAAABgAAAAAAAAAAAAAAmwAAAOEAAAAKAFUAbgB0AGkAdABsAGUAZAAtADIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAOEAAACbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhCSU0EERFJQ0MgVW50YWdnZWQgRmxhZwAAAAEBADhCSU0EFBdMYXllciBJRCBHZW5lcmF0b3IgQmFzZQAAAAQAAAACOEJJTQQMFU5ldyBXaW5kb3dzIFRodW1ibmFpbAAAB9oAAAABAAAAcAAAAE0AAAFQAABlEAAAB74AGAAB/9j/4AAQSkZJRgABAgEASABI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" alt="图片"></h2><h2 class="chapnum"><a></a><a></a></h2>
<h2 class="chaptitle">西蒙·佩顿·琼斯</h2><h2 class="chaptitle">Simon Peyton Jones</h2>
<div class="sidebar">
<p class="normal"><i>Simon Peyton Jones 是 1987 年导致编程语言 Haskell 定义的项目的发起人之一，他是位于英国剑桥的 Microsoft Research 实验室的首席研究员。他编辑了</i>Haskell 98 修订报告<i>，该语言的当前稳定定义；他是格拉斯哥 Haskell 编译器 (GHC) 的架构师和首席开发人员，根据 haskell.org，这是“事实上的标准编译器”；他给了 Haskell 一个被广泛引用的非官方格言：“不惜一切代价避免成功。”</i></p><p class="normal"><i>One of the instigators, back in 1987, of the project that led to the definition of the programming language Haskell, Simon Peyton Jones is a Principal Researcher at Microsoft Research's lab in Cambridge, England. He edited the</i> Haskell 98 Revised Report<i>, the current stable definition of the language; he is the architect and lead developer of the Glasgow Haskell Compiler (GHC), the “de facto standard compiler” according to haskell.org; and he gave Haskell its widely cited unofficial motto: “Avoid success at all costs.”</i></p>
<p class="normal"><i>佩顿·琼斯 (Peyton Jones) 是一位才华横溢的研究员和从未获得博士学位的前教授，他既重视实用又重视理论上的美感。他学会了在一台没有永久存储器且只有 100 个内存位置的机器上编程，在大学期间，他致力于为学校的大型设备编写高级编译器，并用学生预算中他能负担得起的部件构建自己的原始计算机. 但他被一位教授演示了如何在不使用变异的情况下构建双向链表以及惰性求值的思想之美而被函数式编程所吸引。Peyton Jones 认为函数式编程的思想“是对整个程序编写企业的激进而优雅的攻击”：一种“建造一堵全新的墙”的方式，而不是“只是在墙上多放一块砖”。<a id="OEBPS/Chapter07.html.page_242"></a>Machinery 选他为院士，表彰他“对函数式编程语言的贡献”。</i></p><p class="normal"><i>A high-powered researcher and former professor who never got a PhD, Peyton Jones values both the practical and the theoretically beautiful. He learned to program on a machine with no permanent storage and only 100 memory locations, and in college he worked on both writing high-level compilers for the school's big iron and building his own primitive computers out of parts he could afford on a student's budget. But he was drawn to functional programming by a professor's demonstration of how to build doubly linked lists without using mutation and the beauty of the idea of lazy evaluation. Peyton Jones saw the ideas of functional programming “as a radical and elegant attack on the whole enterprise of writing programs”: a way, rather than “just putting one more brick in the wall,” to “build a whole new wall.” In 2004 the Association for Computing <a></a>Machinery elected him a Fellow, citing his “contributions to functional programming languages.”</i></p>
<p class="normal"><i>我们在这次采访中讨论的主题包括为什么他认为函数式编程显示出改变软件编写方式的希望越来越大，为什么软件事务内存是一种比锁和条件变量更好的编写并发软件的方法，以及为什么它如此困难，甚至在像 Microsoft Research 这样的地方，对不同的编程语言是否会提高或降低程序员的工作效率进行真正的研究。</i></p><p class="normal"><i>Among the topics we covered in this interview are why he thinks functional programming shows increasing promise of changing the way software is written, why Software Transactional Memory is a much better way of writing concurrent software than locks and condition variables, and why it is so difficult, even at a place like Microsoft Research, to do real studies of whether different programming languages make programmers more or less productive.</i></p>
</div>
<p class="normal"><b>Seibel：</b>你什么时候学会编程的？</p><p class="normal"><b>Seibel:</b> When did you learn to program?</p>
<p class="normal"><b>佩顿琼斯：</b>当我在学校的时候。英特尔刚刚生产出 4004——世界上第一个微处理器。我们没有 4004 或类似的东西——它确实是业余爱好者在那个阶段几乎无法获得的芯片。他们唯一可用的电脑是一台 IBM 学校的电脑，这是一台用大型机的备件组装而成的奇怪机器。它没有任何永久存储空间，因此每次运行时都必须输入程序。</p><p class="normal"><b>Peyton Jones:</b> When I was at school. Intel had just about produced the 4004—the world's first microprocessor. We didn't have a 4004 or anything like it—it was really a chip that hobbyists could barely get at that stage. The only computer they had available was an IBM schools computer, which was a strange machine built out of spare parts from mainframes. It had no permanent storage whatsoever so you had to type in your program every time you ran it.</p>
<p class="normal">它总共有 100 个存储位置，我认为每个存储位置可以存储八位十进制数。这同时存储了您的程序和数据。所以编程游戏的名称就是将程序放入 100 个存储位置。我不太记得我是如何编写我的第一个程序的。我想我和学校的另一位爱好者在学校的电脑上花了很多时间。那应该是我 15 岁的时候，1974 年，73 年——那个时代。</p><p class="normal">It had 100 storage locations, total, which would each store, I think, eight-digit decimal numbers. And this stored both your program and your data. So the name of the game of programming that was simply to fit the program into 100 storage locations. I can't quite remember how I got to write my first program. I think I and one other enthusiast at the school spent a lot of time on the schools computer. This would have been when I was about 15, 1974, '73—that kind of era.</p>
<p class="normal">然后，在我们对这台机器进行了一些编程之后，我们发现斯温顿的技术学院有一台计算机。所以我们每周的一个下午在一辆非常慢的公共汽车上呆一个小时，然后去斯温顿，那里有一台巨大的机器——一台 Elliot 803——它住在一个房间里的六个白色冰箱大小的大柜子里一个穿白大衣的操作员</p><p class="normal">Then after we'd been programming this machine for a little bit we discovered there was a computer at the technical college in Swindon. So we spent an hour on a very slow bus one afternoon a week and went to Swindon where there was this enormous machine—an Elliot 803—which lived in half a dozen large, white, fridge-sized cabinets in a room all its own with a white-coated operator.</p>
<p class="normal">过了一会儿，穿白大衣的操作员得知我们可以弄清楚如何使用这台机器，所以在我们玩这个巨大的引擎时她就走了。<a id="OEBPS/Chapter07.html.page_243"></a>它适用于纸带和电传打字机，因此您可以在纸带上编写程序。我们用 Algol 编写，所以那是我的第一种高级语言。你在磁带上编写程序，在磁带上编辑。你想改变它，你必须让磁带穿过电传打字机，让它打印出新的磁带，在正确的地方停下来，输入新的位——这是一种非常费力的编辑程序的方法。一种物理介质的行编辑器。所以那是我第一次编程。这非常鼓舞人心。</p><p class="normal">After a bit the white-coated operator learned that we could figure out how to use the machine so she went away while we played with this vast engine. <a></a>It worked with paper tape and teletype so you had your program on a paper tape. We wrote in Algol, so that was my first high-level language. You wrote your program on the tape, you edited on the tape. You wanted to change it, you had to run the tape through the teletype, make it print out a new tape, stop it at the right place, type the new bit—an extremely laborious way to edit your program. A kind of line editor with physical medium. So that was my first experience of programming. It was very motivating.</p>
<p class="normal"><b>Seibel：</b>虽然那不是学校的课程。</p><p class="normal"><b>Seibel:</b> That wasn't a course at school though.</p>
<p class="normal"><b>佩顿琼斯：</b>哦，不！零，绝对没有在学校教授有关计算机的知识。</p><p class="normal"><b>Peyton Jones:</b> Oh, no! Zero, absolutely no teaching about computers at school.</p>
<p class="normal"><b>Seibel：</b>所以它只是——“嘿，孩子们，这是一台电脑，让你自己兴奋起来。”</p><p class="normal"><b>Seibel:</b> So it was just—“Hey kids, here's a computer, knock yourself out.”</p>
<p class="normal"><b>佩顿·琼斯：</b>当然。它在一个锁着的大橱柜里，你可以借用钥匙，它有一个屏幕，它只显示寄存器中内容的固定显示以及内存位置中内容的这些十进制数字。您可以设置程序并按 Go。你可以单步执行它。确实如此。所以它甚至不是汇编语言编程，因为根本没有 ASCII 字符。它实际上是机器代码，以十进制显示，甚至不是十六进制。</p><p class="normal"><b>Peyton Jones:</b> Absolutely. It was there in a large locked cupboard and you could borrow the key and there it was with a screen and it just displayed a fixed display of what was in the registers and these decimal numbers of what was in memory locations. You could set the program and press Go. You could single-step it. That was really it. So it wasn't even assembly language programming because there was no ASCII characters at all. It was literally the machine code, displayed in decimal, not even in hexadecimal.</p>
<p class="normal"><b>Seibel：</b>但它有屏幕？</p><p class="normal"><b>Seibel:</b> But it had a screen?</p>
<p class="normal"><b>佩顿琼斯：</b>它确实有一个电视屏幕。那是它唯一的输出媒介。</p><p class="normal"><b>Peyton Jones:</b> It did have a television screen. That was its sole output medium.</p>
<p class="normal"><b>Seibel：</b>输入是什么？</p><p class="normal"><b>Seibel:</b> And what was the input?</p>
<p class="normal"><b>Peyton Jones：</b>这是一种触摸键盘。你触摸这些按钮，它们会感觉到你的手指触摸了。所以这相当复杂——没有机械钥匙。它是某种电容式的东西——你触摸一下键，它就在那里。总共有大约 20 个按钮。</p><p class="normal"><b>Peyton Jones:</b> It was a kind of touch keyboard. You touched these buttons and they sensed that your finger touched. So that was rather sophisticated—no mechanical keys. It was some kind of capacitive thing—you touched the key and there it was. There were a total of about 20 buttons.</p>
<p class="normal"><b>Seibel：</b>所以这些按钮只是用于数字？</p><p class="normal"><b>Seibel:</b> So these buttons were just for numbers?</p>
<p class="normal"><a id="OEBPS/Chapter07.html.page_244"></a><b>佩顿·琼斯（Peyton Jones）：</b>数字和前进。并“告诉我这个记忆位置。” 实在是太原始了。更令人兴奋的是。</p><p class="normal"><a></a><b>Peyton Jones:</b> Numbers and Go and Step. And “show me this memory location.” It was really extremely primitive. And all the more exciting for that.</p>
<p class="normal"><b>Seibel：</b>我假设你必须计划好你的程序，在你走到这台机器前并开始输入内容之前，可能需要非常详细的计划。</p><p class="normal"><b>Seibel:</b> I assume you had to plan your program, probably in excruciating detail, before you get up to this machine and start keying stuff in.</p>
<p class="normal"><b>Peyton Jones：</b>首先你画一个流程图。然后你会把它分解成指令。然后你将指令编码成这种奇怪的数字格式。然后你输入数字。您输入一个 800 位数字，这就是您的程序。然后你按开始。如果幸运的话，您没有输错这 800 个数字中的任何一个，那么您的状态就很好。所以我们花了很多时间来低头看东西，一个人看着屏幕检查，另一个人说，“去下一个地方。”</p><p class="normal"><b>Peyton Jones:</b> First of all you draw a flow diagram. Then you'd break it down into instructions. Then you'd encode the instructions into this strange digital format. And then you type in the numbers. You type in essentially an 800-digit number, which is your program. And then you press Go. If you were lucky you hadn't mistyped one of those 800 digits and you were in good shape. So we spent a lot of time just looking down the thing with one guy looking at the screen and checking and the other guy saying, “Go to the next location.”</p>
<p class="normal">然后当我去剑桥上大学时，微处理器才刚刚开始起飞。所以有一个大学计算机俱乐部。有一个大型大学计算大型机，称为 Phoenix，具有极其复杂的会计系统。</p><p class="normal">Then when I went to university at Cambridge, microprocessors were just beginning to take off. So there was a university computing club. There was a big university computing mainframe kind of machine, called Phoenix, with an extremely elaborate accounting system.</p>
<p class="normal">您使用它的时间非常重要。您获得了一定数量的机器货币单位，您的程序占用的内存越多，您消耗的单位就越多；你的程序花费的时间越长，你消耗的单位就越多。但是负载越低，程序消耗的单元就越少。因此，结果是，我们没有得到很大分配的本科生只是在那里过夜，因为从晚上 9:00 左右开始，运行您的程序变得相当便宜。</p><p class="normal">The time at which you used it was very significant. You were given a certain amount of units of the machine's currency and the more memory your program took, the more units you consumed; the longer your program took, the more units you consumed. But the lower the load was, the fewer units your program consumed. So as a result, us undergraduates, who didn't get a very large allocation, simply spent our nights there because from about 9:00 at night it became rather cheap to run your program.</p>
<p class="normal">所以我们会在上午 9:00 到 3:00 在那里编写我们的程序。我们主要写了什么？BCPL，我想。所以这又完全是业余爱好者的东西。当时我正在攻读数学学位。因此，计算机科学的正规教学为零。</p><p class="normal">So we would be there 9:00 to 3:00 a.m., writing our programs. And what did we write in mainly? BCPL, I think. So this again was completely hobbyist stuff. I was doing a maths degree at the time. So zero formal teaching in computer science.</p>
<p class="normal">当时也没有完整的本科学位。那是 1976 年到 79 年。有一个最后一年的课程，所以你可以毕业于计算机科学。但是你不能学三年的计算机科学——你必须事先学其他的东西，比如数学或自然科学。事实上，我学了数学，并完成了一年的电气科学。主要是<a id="OEBPS/Chapter07.html.page_245"></a>因为我认为计算是我的爱好——把它作为你的学位也有点像作弊；学位应该很难。</p><p class="normal">There wasn't a whole undergraduate degree at that time either. That was 1976 to '79. There was a final year course so you could graduate in computer science. But you couldn't do three years of computer science—you had to do something else like maths or natural sciences beforehand. In fact I did maths and finished up with a year of electrical sciences. Mainly <a></a>because I thought computing was my hobby—it'd be a bit like cheating to do it as your degree as well; degrees should be hard.</p>
<p class="normal">但事实证明数学有点太难了，因为剑桥到处都是非常聪明的数学家，所以我转向了电气科学。</p><p class="normal">But maths turned out to be a bit too hard because Cambridge is stuffed with extremely brainy mathematicians so I switched to electrical sciences.</p>
<p class="normal"><b>Seibel：</b>还有电气科学——这就是我们在美国所说的电气工程？</p><p class="normal"><b>Seibel:</b> And electrical sciences—that's what we'd call electrical engineering in the U.S.?</p>
<p class="normal"><b>佩顿·琼斯：</b>没错。在那个阶段，我在学校的同一个朋友 Thomas Clarke 也在剑桥。所以托马斯和我建造了各种电脑。您会为自己购买一个微处理器和大量 7400 系列 TTL 并将其连接起来。我记得，我们最大的问题是打印机。打印机和屏幕。那些是困难的部分。</p><p class="normal"><b>Peyton Jones:</b> That's right. At that stage my same friend that I was at school with, Thomas Clarke, was also here at Cambridge. So Thomas and I built various computers. You would buy yourself a microprocessor and lots of 7400 series TTL and wire it up. Our biggest problem, I remember, was printers. Printers and screens. Those were the hard bits.</p>
<p class="normal"><b>Seibel：</b>因为它们很贵。</p><p class="normal"><b>Seibel:</b> Because they're expensive.</p>
<p class="normal"><b>Peyton Jones：</b>它们太贵了——是的。你可以用学生买得起的钱买到电气部件，但打印机通常是冰箱大小的大型行式打印机。他们有很多机制，使他们完全超出了我们的价格范围。那和存储设备——任何一种永久性存储设备往往都很棘手。所以我们倾向于让电脑只有键盘、屏幕，除此之外别无其他。以及某种原始的磁带机制。</p><p class="normal"><b>Peyton Jones:</b> They're so expensive—yes. You could get the electrical parts for the kind of money students could afford but printers were typically big, fridge-sized line printer things. They had a lot of mechanics in them that made them completely out of our price bracket. That and storage devices—any kind of permanent storage device tended to be tricky. So we tended to have computers with a keyboard, a screen, and not much else. And some kind of primitive tape mechanism.</p>
<p class="normal"><b>Seibel：</b>你们在 76 年到 79 年期间从头开始构建这些计算机。Altair 不是在同一时间问世吗？</p><p class="normal"><b>Seibel:</b> You guys were building these computers from scratch in '76 to '79. Isn't that about the same time the Altair was coming out?</p>
<p class="normal"><b>佩顿·琼斯：</b>没错。爱好者电脑肯定开始问世了。但我们认为那些是在作弊。</p><p class="normal"><b>Peyton Jones:</b> That's right. Hobbyist computers were definitely starting to come out. But we considered those to be rather cheating.</p>
<p class="normal">关于我们自己制造的这台机器，问题在于软件。我认为我为这台机器设计的最先进的程序是康威的生命游戏。效果很好。但是编写任何一种严肃的程序，比如编程语言，都是太多的工作，因为它的永久存储介质非常有限。而且都是输入十六进制的东西——没有汇编程序。</p><p class="normal">The thing about this machine that we built ourselves was that software was the problem. I think my most advanced program for this machine was Conway's Game of Life. That worked very nicely. But writing any kind of serious program, like a programming language, was just too much work because it had very limited permanent storage medium. And it was all typing in hexadecimal stuff—no assembler.</p>
<p class="normal"><b>Seibel：</b>所以更多的原始机器代码。</p><p class="normal"><b>Seibel:</b> So more raw machine code.</p>
<p class="normal"><a id="OEBPS/Chapter07.html.page_246"></a><b>Peyton Jones：</b>剑桥大型机当然理解 BCPL，所以我们编写了很多 BCPL 程序。当时我们实际上是在为我们发明的编程语言编写编译器。我们从未完成这个编译器——它非常复杂。有这两个完全分离的世界。用高级语言为大型机编写编译器，而在另一端摆弄硬件。</p><p class="normal"><a></a><b>Peyton Jones:</b> Of course the Cambridge mainframe understood BCPL so we were writing lots of BCPL programs. We were actually writing a compiler then for a programming language that we'd invented. We never completed this compiler—it was very elaborate. There were these two completely divorced worlds. Writing compilers in a high-level language for a mainframe and diddling with hardware on the other end.</p>
<p class="normal"><b>Seibel：</b>你记得写的第一个有趣的程序是什么？</p><p class="normal"><b>Seibel:</b> What was the first interesting program you remember writing?</p>
<p class="normal"><b>Peyton Jones：</b>在这所学校的计算机上提取 24 位平方根并将其放入 99 个内存位置的程序。</p><p class="normal"><b>Peyton Jones:</b> A program to extract 24-digit square roots on this schools computer and fit it into 99 memory locations.</p>
<p class="normal"><b>Seibel：</b>所以你有一个备用的！</p><p class="normal"><b>Seibel:</b> So you had one spare!</p>
<p class="normal"><b>佩顿·琼斯：</b>没错。这是求平方根的某种牛顿-拉夫森近似。我为此感到非常自豪。那之后呢？我想下一个扩展一定是我们从未完成的编译器。它是用 BCPL 编写的，非常详尽。我们对此非常有野心。没有类型系统，所以我们只有大量的打印输出，其中包含图片、结构图和它们之间的箭头。</p><p class="normal"><b>Peyton Jones:</b> That's right. It was some kind of Newton-Raphson approximation to do square roots. I was terribly proud of it. What after that? I suppose the next scale up must have been this compiler that we never completed. It was written in BCPL and it was extremely elaborate. We were extremely ambitious with it. There was no type system so we just had enormous sheets of printout with pictures, diagrams of structures and arrows between them.</p>
<p class="normal"><b>Seibel：</b>你的意思是在 BCPL 中没有类型系统。</p><p class="normal"><b>Seibel:</b> You mean in BCPL there was no type system.</p>
<p class="normal"><b>佩顿琼斯：</b>是的，没错。所以基本上我们通过在大纸上用箭头画出我们的类型来写出来。那就是我们的类型系统。那是一个相当大的计划——事实上它过于雄心勃勃；我们从未完成它。</p><p class="normal"><b>Peyton Jones:</b> Yeah, that's right. So essentially we wrote out our types by drawing them on large sheets of papers with arrows. That was our type system. That was a pretty large program—in fact it was over ambitious; we never completed it.</p>
<p class="normal"><b>Seibel：</b>你认为你从那次失败中吸取了教训吗？</p><p class="normal"><b>Seibel:</b> Do you think you learned any lessons from that failure?</p>
<p class="normal"><b>Peyton Jones：</b>可能是那时候我第一次意识到编写一个非常大的程序最终可能会遇到规模问题——你无法同时在脑海中保留足够多的内容。以前我写的所有东西，你可以毫不费力地把整个东西记在脑子里。所以这可能是我第一次对长期存在的文档进行认真的尝试。</p><p class="normal"><b>Peyton Jones:</b> That was probably when I first became aware that writing a really big program you could end up with problems of scale—you couldn't keep enough of it in your head at the same time. Previously all the things I had written, you could keep the whole thing in your head without any trouble. So it was probably the first time I'd done any serious attempt at long-standing documentation.</p>
<p class="normal"><b>Seibel：</b>但在这种情况下，即使这样还不够吗？</p><p class="normal"><b>Seibel:</b> But even that wasn't enough, in this case?</p>
<p class="normal"><a id="OEBPS/Chapter07.html.page_247"></a><b>佩顿琼斯：</b>嗯，我们还有很多其他事情要做，比如获得学位。这一切都发生在晚上 9:00 到凌晨 3:00 之间</p><p class="normal"><a></a><b>Peyton Jones:</b> Well, we had a lot of other things to do, like get degrees. This was all between 9:00 p.m. and 3:00 a.m.</p>
<p class="normal"><b>Seibel：</b>在学习编程方面，有什么是你希望自己做的不同的吗？</p><p class="normal"><b>Seibel:</b> And is there anything you wish you had done differently about learning to program?</p>
<p class="normal"><b>Peyton Jones：</b>嗯，从来没有人教过我编程。我不确定我是否真的错过了。今天我觉得我的主要编程空白点似乎是我对面向对象编程没有深刻的、发自内心的感觉。我当然知道如何编写面向对象的程序等等。但是当你大规模地做某事时，会发生一些不同的事情。当您构建持续很长时间的大型程序并以复杂的方式使用类层次结构并构建框架时，这就是我所说的深刻的、发自内心的理解。不是那种你可以立即从书本上学到的东西。</p><p class="normal"><b>Peyton Jones:</b> Well, nobody ever taught me to program. I'm not sure I ever really missed that. Today I feel as if my main programming blank spot is that I don't have a deep, visceral feel for object-oriented programming. Of course I know how to write object-oriented programs and all that. But something different happens when you do something at scale. When you build big programs that last for a long time and you use class hierarchies in a complex way and you build frameworks—that's what I mean by a deep, visceral understanding. Not the kind of stuff that you'd learn immediately from a book.</p>
<p class="normal">我觉得这是一种不足，因为我觉得我不能真正权威地说明面向对象编程可以做什么和不能做什么。我说话总是非常小心，尤其是不要对命令式编程持否定态度，因为它是一种非常复杂和丰富的编程范例。但不知何故，由于我的生活发展方式，我从未真正花几年时间编写大型 C++ 程序。这就是你如何获得某种深刻的、发自内心的感觉，而我从未有过。</p><p class="normal">I feel that as a lack because I don't feel I can really be authoritative about what you can and can't do with object-oriented programming. I'm always very careful in what I say, particularly not to be negative about imperative programming because it's an incredibly sophisticated and rich programming paradigm. But somehow because of the way my life developed, I never really spent several years writing big C++ programs. That's how you get some kind of deep, visceral feel and I never have.</p>
<p class="normal"><b>Seibel：</b>我认为那种感觉通常是厌恶。</p><p class="normal"><b>Seibel:</b> I think that feeling is usually revulsion.</p>
<p class="normal"><b>Peyton Jones：</b>没错——但这是一种知情的反感，而不是表面上的“哦，那太糟糕了”的反感。</p><p class="normal"><b>Peyton Jones:</b> That's right—but it's a well-informed revulsion rather than a superficial, “Oh, that sucks” kind of revulsion.</p>
<p class="normal"><b>Seibel：</b>所以你在剑桥完成了三年，然后呢？</p><p class="normal"><b>Seibel:</b> So you finished your three years at Cambridge, then what?</p>
<p class="normal"><b>Peyton Jones：</b>然后我想，“好吧，最好在计算方面做一点工作。” 所以我花了一年的时间攻读计算机科学的研究生文凭——这是我唯一的计算机科学正规教育。</p><p class="normal"><b>Peyton Jones:</b> Then I thought, “Alright, better do a little bit of work on computing.” So I spent one year doing a postgraduate diploma in computer science—my sole formal education in computer science.</p>
<p class="normal"><b>Seibel：</b>这有点像硕士学位吗？</p><p class="normal"><b>Seibel:</b> Is that kind of like a master's degree?</p>
<p class="normal"><b>Peyton Jones：</b>有点像硕士学位。我度过了美好的一年。我怀疑它与本科学位计算机科学 tripos 非常相似。<a id="OEBPS/Chapter07.html.page_248"></a>但它是为没有学过任何其他计算机科学的学生准备的。</p><p class="normal"><b>Peyton Jones:</b> Kind of like a master's degree. I had a great year. I suspect it was very similar to the computer science tripos, the undergraduate degree. <a></a>But it was intended for students who hadn't done any other computer science.</p>
<p class="normal"><b>Seibel：</b>然后你在工业界工作了几年，然后才回到研究领域。你当时在做什么？</p><p class="normal"><b>Seibel:</b> Then you spent a couple years in industry before getting back into research. What were you doing then?</p>
<p class="normal"><b>Peyton Jones：</b>那是一家非常小的过程控制和监控公司。我们构建了位于基于微处理器的计算机中的硬件和软件，这些计算机实际上位于传送带的称重控制器中。我建造的一件事是观察运煤传送带上的称重传感器；它控制皮带的速度并听取称重传感器的声音并调整速度以使流量达到应有的水平。这是一个小型实时操作系统，我用一种叫做 PL/Z 的语言编写的。它有点像 Algol。我在 Z80 机器上编写它，该机器运行一种名为 Chromix 的精简版 Unix。</p><p class="normal"><b>Peyton Jones:</b> That was a very small process control and monitoring company. We built hardware and software that sat in microprocessor-based computers that were physically sitting in weigh scale controllers for conveyor belts. One thing I built watched a load cell on a conveyor belt that carried coal; it controlled the speed of the belt and listened to what the load cell was saying and adjusted the speed to make the flow rate what it should be. It was a little real-time operating system, which I wrote in a language called PL/Z. It was a little bit like Algol. I wrote it on a Z80 machine that ran a sort of cut-down Unix called Chromix.</p>
<p class="normal">那是一家非常小的公司——大约只有六个人。有时变化多达 15 个。但是因为它很小，所以一切都很不稳定。有时我们有很多钱，有时我们一文不值。两年后，我决定创业生活不适合我。这是我对小公司的主要见解：要成为一名企业家，您需要从涉及金钱的压力情况中<i>获取</i>能量，而我的能量却被涉及金钱的压力情况所消耗。我的老板是这家公司的总经理。事情越糟糕，他就会越有活力。他来来往往，他会有新的软件技术想法。他高兴得像只蜜蜂。我意识到，这就是你所需要的，因为如果它耗尽了你的精力，你就会把整个时间都花在低迷中。</p><p class="normal">It was a very small company—it was like half a dozen people. Varied up to 15 at times. But because it was small everything was quite volatile. Sometimes we had plenty of money, other times we had none. After two years I'd decided that the entrepreneurial life was not for me. This was my main insight about small companies: to be an entrepreneur you need to <i>get</i> energy from stressful situations involving money, whereas my energy is sapped by stressful situations involving money. My boss was the managing director of this company. The worse things got, the more energetic he would be. He'd come bouncing around and he'd have new technical ideas for software. He was just as happy as a bee. And I realized, that's what you need, because if it saps your energy, you spend your whole time in a slump.</p>
<p class="normal">所以我觉得这太辛苦了，于是四处寻找工作，最终在伦敦大学学院找到了一份讲师的工作。当我在那里时，我没有博士学位，也没有接受过研究培训。所以我的系主任给我放假做研究。给我减轻了教学负担，这样我就可以开始我的研究工作了。但我一点也不知道该怎么做。所以我会坐在我的办公室里，拿着一张白纸和一支削尖的铅笔，等待好主意。当我盯着房间四周等待好主意的出现时，就会出现这种沉默。什么都不会发生。</p><p class="normal">So I decided that was all much too hard work and looked around for a job and ended up getting a job as a lecturer at University College London. And when I was there I had no PhD, I had no research training. So my head of department gave me time off to do research. Gave me a light teaching load so I could get my research gig started. But I hadn't the faintest idea what to do. So I would sit in my office with a blank sheet of paper and a sharpened pencil and wait for great ideas. And there was this sort of silence while I would sort of stare around the room waiting for great ideas to come. And nothing much would happen.</p>
<p class="normal"><a id="OEBPS/Chapter07.html.page_249"></a>John Washbrook 本人是该系的高级学者，他把我置于他的羽翼之下，他告诉了我一些非常重要的事情。他说，“开始吧，不管多么卑微。” 这不是关于编程，而是关于研究。但无论它看起来多么卑微、缺乏原创性和不重要，都要开始做点什么并写一篇关于它的论文。所以这就是我所做的。事实证明这是一条非常重要的建议。</p><p class="normal"><a></a>John Washbrook, who was himself a senior academic in the department, took me under his wing and he told me something that was very important. He said, “Just start something, no matter how humble.” This is not really about programming, this is about research. But no matter how humble and unoriginal and unimportant it may seem, start something and write a paper about it. So that's what I did. It turned out to be a very significant piece of advice.</p>
<p class="normal">从那以后，我把这件事告诉了我所有的研究生。因为这是你开始的方式。一旦你开始磨机转动，那么计算机科学就会非常分形——几乎所有的事情都会变得很有趣，因为这个主题比你先发展。它不像一个固定的东西，你必须去发现它。它只是扩大。</p><p class="normal">I've told that to every research student I've ever had since. Because it's how you get started. Once you start the mill turning then computer science is very fractal—almost everything turns out to be interesting, because the subject grows ahead of you. It's not like a fixed thing that's there that you've got to discover. It just expands.</p>
<p class="normal"><b>Seibel：</b>所以你回到了学术界，但你从未获得过博士学位。这怎么可能？</p><p class="normal"><b>Seibel:</b> So you came back into academia but you never did get a PhD. How was that possible?</p>
<p class="normal"><b>Peyton Jones：如今</b>，没有博士学位就很难获得教职。那一定是 1982 年、1983 年。我申请 UCL 是因为我姐姐在那里学习计算机科学，她说，“哦，UCL 有几个讲师职位，你为什么不申请？” 令我惊讶的是，我被任命了。我只能假设当时肯定存在极度短缺，并且任何能够在计算意义上对自己做出合理描述的人都可以被录用。因为否则，他们如何设法雇用没有博士学位的人？</p><p class="normal"><b>Peyton Jones:</b> These days getting a faculty post without a PhD would be very hard. This must have been 1982, 1983. I applied to UCL because my sister was studying computer science there and she said, “Oh, there are a couple of lectureships at UCL, why don't you apply?” Much to my astonishment, I was appointed. I can only assume that at the time there must have been a desperate shortage and that anyone that could give a plausible account of himself, in a computing sense, could get hired. Because otherwise, how did they manage to hire somebody without a PhD?</p>
<p class="normal">在 UCL 七年后，我开始考虑也许我应该获得博士学位。但是写论文真的很麻烦。但是，事实证明，在剑桥，你可以通过特殊规定获得博士学位，这意味着你只需提交你发表的作品，幸运的话，他们会说，“你是一个应该拥有博士学位的好人。” 所以当我被任命为格拉斯哥的教授时，我正准备这样做。全职教授。所以那时我被称为“教授”，所以没有人知道我是否拥有博士学位，所以我放弃了这个想法。罗宾·米尔纳 (Robin Milner) 没有博士学位；它一定是一家杰出的公司。从那以后我就一直这样。</p><p class="normal">After seven years at UCL I began to think maybe I should get a PhD. But it was a big hassle writing a thesis, really. But, it turns out at Cambridge you can get a PhD by special regulation, which means that you just submit your published work and, with luck, they say, “You are a fine person who should have a PhD.” So I was just getting geared up to do that when I got appointed as a professor at Glasgow. Full professor. So by that time I was called “Professor” so nobody would know whether I had a PhD or not so I dropped the idea. Robin Milner doesn't have a PhD; it must be a distinguished company. I've stuck like that ever since.</p>
<p class="normal"><b>Seibel：如今</b>，获得博士学位有价值吗？有人曾经告诉我，博士学位实际上是一个职业学位——如果你想成为一名教授，你必须<a id="OEBPS/Chapter07.html.page_250"></a>得到一个，但如果你不想成为一名教授，那就没有意义了。你认为分析适用于计算机科学吗？</p><p class="normal"><b>Seibel:</b> These days, is getting a PhD valuable? Someone once told me a PhD is really a vocational degree—if you want to be a professor, you've got to <a></a>get one but if you don't want to be a professor, there's no point. Do you think that analysis applies to computer science?</p>
<p class="normal"><b>佩顿·琼斯：</b>那部分当然是真的。如果你想坚持以研究为职业——无论是在学术界还是在像微软研究院或谷歌研究实验室这样的地方——一个严肃的工业研究实验室，这是必要的但还不够。您确实需要博士学位才​​能通过起始职位。</p><p class="normal"><b>Peyton Jones:</b> That part is certainly true. It's necessary but not sufficient if you want to stick with research as a career—either academic or at somewhere like Microsoft Research or Google's research labs—a serious industrial research lab. You really need a PhD to get past the starting post.</p>
<p class="normal">如果你不想从事研究事业，那么我认为这会成为一种随心所欲的事情。如果您正在从事让您充满热情的事情，那么您的工作效率会提高五倍。所以如果你发现自己在想，“我只是喜欢这个，我只是想有一些时间来深入研究它，”博士学位是一个在英国度过三年，或者更确切地说在美国度过更长时间的绝佳机会，只是在学习一些东西。这是一种难以置信的自由，因为你有点像社会上的寄生虫。如果您知道自己不想以全职研究为职业，那么攻读博士学位的原因就是您充满热情、好奇心和兴趣。但是无论如何，博士都很奇怪。他们强迫你自己工作并写出大多数人不会读的重要论文——他们” 我会读你的论文。所以这是一种不寻常的研究模式。</p><p class="normal">If you don't want to pursue a career in research, then I think it becomes a follow-your-heart kind of thing. You're five times as productive if you're working on something that makes you enthusiastic. So if you find yourself thinking, “I just love this and I'd just like to have some time to dig into it some more,” a PhD is a fantastic opportunity to spend three years in Britain, or rather longer in the States, just studying something. It's an incredible freedom really because you're sort of a parasite on society. If you know you don't want to do full-time research as a career then the reason to do a PhD is because you're just enthusiastic and inquisitive and interested. But PhDs are rather strange anyway. They force you to work on your own and produce a substantial thesis that most people won't read—they'll read your papers. So it's an unusual research mode.</p>
<p class="normal">一旦你完成了博士学位，你就会开始与许多其他人更密切地合作，共同完成通常更小、更紧凑的工作。我认为在某些方面，博士学位是一种奇怪的准备，即使是为了研究。英国比较奇怪，因为时间紧迫。我认为在美国，您可以在一段时间内更加协作，直到您将自己的研究计划归零。</p><p class="normal">Once you've finished a PhD you start working much more collaboratively with lots of other people on typically smaller, more bite-sized pieces of work. I think in some ways a PhD is an odd preparation, even for research. Odder in Britain because of its compressed timescale. I think in the States you can be more collaborative for a while until you zero in on your own research program.</p>
<p class="normal"><b>Seibel：</b>说到研究和学术，函数式编程在研究界很受欢迎，但我认为该社区外的很多人都认为函数式编程是由想法驱动的，这些想法虽然简洁，但可能非常数学化，并且与日常工作脱节-天编程。这是一个公平的表征吗？</p><p class="normal"><b>Seibel:</b> Speaking of research and academics, functional programming is quite popular within the research community but I think a lot of people outside that community see functional programming as being driven by ideas that, while neat, can be very mathematical and divorced from day-to-day programming. Is that a fair characterization?</p>
<p class="normal"><b>Peyton Jones：</b>我认为这大约是公平的。我将函数式编程（即纯函数式编程，其中的副作用以某种方式真正归属于它们自己的世界）描述为对整个程序编写企业的激进而优雅的攻击。事情是<a id="OEBPS/Chapter07.html.page_251"></a>根据定义，激进分子不是从事物所处的状态进化而来的。</p><p class="normal"><b>Peyton Jones:</b> I think it's about half fair. I characterize functional programming—that is, purely functional programming, where side effects are somehow really relegated to a world of their own—as a radical and elegant attack on the whole enterprise of writing programs. Things that are <a></a>radical are by definition not evolutionary from the state of where things are at.</p>
<p class="normal">今天的“现状”是大公司正在向生态系统、编辑器、分析器、工具、程序员和技能以及所有类似的东西投入大量资源。根据定义，主流是非常实用的。与此同时，函数式编程的这种激进而优雅的东西却没有那么深入的基础设施支持。但与此同时，这并不一定会让人自我放纵去追求它。因为，毕竟，除非<i>有人</i>致力于激进和优雅的事情，否则你最终会陷入局部最优，逐步优化主流，但仍停留在低矮的山坡上。</p><p class="normal">Today “where things are at” is that big companies are pouring immense resources into ecosystems and editors and profilers and tools and programmers and skills and all that kind of stuff. The mainstream is, by definition, deeply practical. Meanwhile this radical and elegant stuff of functional programming has much less of that deep, infrastructural support. But at the same time that doesn't necessarily make it self-indulgent to pursue it. Because, after all, unless <i>some</i> people are working on radical and elegant things you're going to end up in a local optimum, incrementally optimizing the mainstream but stuck on a low hill.</p>
<p class="normal">因此，我认为整个学术研究业务的好处之一是，教授们可以离开并做一些疯狂的事情，而不会被问到这对底线有何好处。有些人会做一些非常重要的事情，有些则不那么重要；但你无法提前分辨出哪个是哪个！因此，对于为什么值得像我这样的人在纯函数式编程上花费大量时间的原因，我的总体理由是它显示了希望。我不想断言这就是未来每个人编写程序的方式，但它显示出希望。事实上，我会证明它显示出<i>越来越大</i>的希望。我认为，当命令式编程的石灰石被磨掉后，函数式编程的花岗岩就会出现。</p><p class="normal">So I think that one of the good things about the whole business of academic research is that professors can go off and do sort of loopy things without being asked how it's benefiting the bottom line. Some will do things that turn out to be fantastically important, and some less so; but you can't tell which is which in advance! So my big-picture justification for why it's worth some people, like me, spending a lot of time on purely functional programming, is that it shows promise. I don't want to claim that it's exactly the way that everyone will be writing programs in the future, but it shows promise. And actually I'll make the case that it shows <i>increasing</i> promise. I see it as, when the limestone of imperative programming is worn away, the granite of functional programming will be observed.</p>
<p class="normal">就是说，我认为纯函数式编程开始时相当怪异、学术和数学。实际上，过去 20 年的故事——我一直致力于此——是一个变得越来越实际的故事，不仅关注抽象的想法，而且试图一个接一个地克服妨碍实现的障碍现实生活中的程序员在实际应用程序中使用函数式编程语言。Haskell 本身的发展就是一个例子。</p><p class="normal">That said, I think purely functional programming started quite geeky and academic and mathematical. The story of the last, really, 20 years—all the time I've been working on it—has been a story of becoming increasingly practical, focusing not just on abstract ideas but trying to overcome, one by one, the obstacles that prevent real-life programmers using functional programming languages for real applications. The development of Haskell itself is an example of that.</p>
<p class="normal">很高兴这里有一群人，他们可能有点不切实际，正在走向主流，也许你在这里学到的纯功能世界的观点可以为主流提供信息和启发。你可以看到，这已经发生了。许多关于类型系统和泛型的东西最初是在函数式编程语言的背景下开发的。这是一个实验室<a id="OEBPS/Chapter07.html.page_252"></a>其中一些想法得到了发展。生成器和惰性流是另一个例子。Python 在句法级别具有列表推导式。有很多单独的东西。通常它们会被重新命名，有时，为了适应主流环境，它们会发生很大的变化。我不想宣称这是一种排他性的谱系，但我确实认为很多想法已经渗透进来。所以它很有用。</p><p class="normal">It's good that there are a bunch of people out here, maybe slightly impractical, who are heading towards the mainstream and maybe the perspectives you learn over here in the purely functional world can inform and illuminate the mainstream. That, you can see, has happened. Lots of stuff about type systems and generics were originally developed in the context of functional programming languages. It was a kind of laboratory in <a></a>which some of those ideas were developed. Generators and lazy streams are another example. Python has list comprehensions at the syntactic level. There are lots of individual things. Usually they've been rebranded and sometimes, to fit the mainstream context, they've been changed quite a bit. I don't want to claim a kind of exclusive genealogy but I do think a lot of ideas have nevertheless percolated across. So it's been useful.</p>
<p class="normal"><b>Seibel：</b>对您来说，研究与实际编程之间的关系如何？</p><p class="normal"><b>Seibel:</b> For you, what about the relation between research and actually programming?</p>
<p class="normal"><b>Peyton Jones：</b>哦，他们互动很多。我的研究领域是编程语言。到底什么是编程语言？它们是为了让编程更容易。实际上，它们是编程的用户界面。所以程序设计和程序设计语言的研究是密切相关的。我们不擅长的一件事是：布丁的证明在于吃，所以你应该看程序员吃东西。也就是说，你应该对程序员编程进行适当的、形式化的研究，看看他们做了什么。那是非常昂贵的。而且它也更“柔软”。很难得出明确的结果。</p><p class="normal"><b>Peyton Jones:</b> Oh, they interact a lot. My area of study is programming languages. What are programming languages for in the end? They're to make it easier to program. They're the user interface of programming, in effect. So programming and programming language research are deeply related. One thing we're not good about is this: the proof of the pudding is in the eating, so you should watch programmers eating. That is, you should do proper, formalized studies of programmers programming and see what they do. And that's jolly expensive. And it's also more “squishy.” It's harder to come up with unequivocal results.</p>
<p class="normal">所以编程语言社区的文化更多的是“证明你的类型系统是健全和完整的”之类的东西。我们可能会回避更重要但更难回答的问题，即它们在实践中是否会提高人们的工作效率。但这些问题确实很难给出令人信服的答案。编写函数式程序或面向对象程序来做同样的事情，您的工作效率更高吗？即使你可以花很多钱做严肃的实验，我也不确定你会得出人们真正会买的结果。</p><p class="normal">So the culture of the programming-language community is much more, “prove that your type system is sound and complete,” kind of stuff. We dodge, probably, the more important but much harder to answer questions about whether, in practice, they make people more productive. But they are questions that are really hard to give convincing answers to. Are you more productive writing a functional program or an object-oriented program to do the same thing? Even if you could spend a lot of money on doing serious experiments, I'm not sure you'd come up with results which people would actually buy.</p>
<p class="normal"><b>Seibel：</b>你们做过任何小规模的实验吗？您正在为拥有大量现金的 Microsoft 工作，那么为什么不组建一个由经验丰富的 Haskellites 团队和一个由经验丰富的 C# 人员组成的团队，并给他们同样的任务，看看会发生什么？这就是你需要的那种测试，对吧？</p><p class="normal"><b>Seibel:</b> Do you guys do any, even small-scale experiments? You're working for Microsoft, who has plenty of cash, so why not get a team of experienced Haskellites and a team of experienced C# people and give them the same task and see what happens? That's the kind of test you would need, right?</p>
<p class="normal"><b>佩顿琼斯：</b>是的，是的，没错。这在一定程度上是钱的问题。但这不仅仅是钱的问题。这也是一种时间和注意力。做那种实验你的整个方法是不同的。您还需要在文化上进行转变。而且，虽然从外部看来，Microsoft<a id="OEBPS/Chapter07.html.page_253"></a>有足够的现金，实际上这里的故事主要是一位研究人员和他的工作站。我们不能只为任何特定的事情打开金钱。如果可以的话，请多多关照。在靠近采煤面的地方，雷德蒙德有大型可用性实验室，他们在那里对原型产品进行实验。新版本的 Visual Studio 经过广泛的可用性测试。</p><p class="normal"><b>Peyton Jones:</b> Yeah, yeah, that's right. It's partly a question of money. But it's not just a question of money. It's also sort of time and attention. To do that kind of experiment your whole methodology is different. And you need to shift culturally as well. And, while Microsoft, from the outside, appears to <a></a>have plenty of cash, in fact the story here is largely one researcher and his workstation. We can't just turn on money for any particular thing. Be nice if we could. Nearer the coalface, as it were, there are big usability labs in Redmond where they do perform experiments on things that are proto products. New versions of Visual Studio are extensively usability tested.</p>
<p class="normal"><b>Seibel：</b>大概这更多是为了整个用户交互，而不是编程语言问题。</p><p class="normal"><b>Seibel:</b> Presumably that's more for the total user interaction, rather than for programming language issues.</p>
<p class="normal"><b>Peyton Jones：</b>嗯，他们还在测试 API 方面做了一些有趣的工作。史蒂文·克拉克 (Steven Clarke) 和他在雷德蒙德 (Redmond) 的同事进行了系统的尝试，以观察程序员在使用新 API 时讨论他们正在尝试做什么。他们让设计 API 的人坐在玻璃屏幕后面观看。</p><p class="normal"><b>Peyton Jones:</b> Well, they also do some interesting work on testing APIs. Steven Clarke and his colleagues at Redmond have made systematic attempts to watch programmers, given a new API, talk through what they're trying to do. And they get the people who designed the API to sit behind a glass screen and watch them.</p>
<p class="normal">坐在玻璃幕后的人说，“不，不，不要那样做！那不是正确的方法！” 但它隔音。这往往很有启发性。他们去改变他们的 API。老实说，编程语言研究在这方面很薄弱。但这在一定程度上是因为这些问题很难回答。从文化上讲，我们不太适合这样做。我认为这是一个弱点。但不是我个人认为非常适合解决的问题。</p><p class="normal">And the guys sitting there behind the glass screen say, “No, no, don't do that! That's not the right way!” But it's soundproof. That turns out often to be very instructive. They go and change their API. To be honest, programming language research is weak on that score. But it is partly because these are difficult questions to answer. And culturally we're not well adapted to do it. I regard it as a weakness. But not one that I personally feel terribly well equipped to address.</p>
<p class="normal"><b>Seibel：</b>因此，如果研究人员想出了关于如何改进编程的有趣想法，那么来自研究实验室和大学的最好的好想法是否足够快地渗透到实践中？</p><p class="normal"><b>Seibel:</b> So if researchers are coming up with interesting ideas about how to improve programming, are the best of those good ideas from research labs and universities percolating into practice fast enough?</p>
<p class="normal"><b>Peyton Jones：</b>嗯，够快了。我不知道。每当我与真正参与构建客户想要并因此准备付费的产品的人交谈时，我都非常清楚许多困扰我的事情根本不在他们的考虑范围之内。</p><p class="normal"><b>Peyton Jones:</b> Well, fast enough. I don't know. Whenever I talk to people who are actually involved in building products that customers want and are therefore prepared to pay for, I'm very conscious that many of the things that bother me just aren't on their radar at all.</p>
<p class="normal">他们本周必须做一些他们的客户会重视的事情；他们只是没有时间去考虑一些可能有用的东西，或者甚至可能在某些方面有用但总的来说还没有准备好迎接黄金时段的东西。</p><p class="normal">They have to do something this week that their customers are going to value; they just don't have time to mess about with something that might work or that might even work in some ways but in total isn't yet ready for prime time.</p>
<p class="normal">有一点脱节——这是一个先有鸡还是先有蛋的问题。有时，在研究中形成的想法需要相当多的<a id="OEBPS/Chapter07.html.page_254"></a>为了直接有用，围绕不是基础研究的边缘进行工程工作。</p><p class="normal">There's a bit of a disconnect—it's sort of a chicken-and-egg problem there. Sometimes the ideas that are developed in research need quite a bit of <a></a>engineering effort around the edges that isn't fundamental research in order to be directly useful.</p>
<p class="normal">我不想暗示当地的开发人员对此很愚蠢，只是没有采纳有益于他们生活的好主意。他们这样做是有充分理由的。有时，研究原型与您可以在现实中构建的东西之间存在一些差距。我认为微软实际上在这方面做得很好，因为微软研究院确实填补了这一空白，并且确实有相当多的机制——孵化组等等——其目的是让研究人员和开发人员彼此更紧密地联系，也许是为了帮助提供一些额外的努力来跨越边界。因此，我认为，就跨越该边界而言，MSR 已经尽善尽美了。</p><p class="normal">I wouldn't like to imply that developers on the ground are being dopey about this, just not taking up good ideas that would benefit their lives. They're doing what they're doing for quite good reasons. There is sometimes a bit of a gap between research prototypes and stuff that you can build in reality. And I think that Microsoft is actually doing quite well here because Microsoft Research does fill that gap a bit and does have quite a bit of mechanism—incubation groups and so forth—whose aim is to put researchers and developers in closer touch with each other and perhaps to help provide some extra effort to lift things across the boundary. So MSR is kind of as good as it gets, I think, as far as crossing that boundary is concerned.</p>
<p class="normal">这种洋葱有层次。对于充斥着 Java 的主流开发人员来说，函数式编程不仅是一种完全不同的编程思维方式，而且还有很多互操作性问题。你有足够的书吗？有足够的图书馆吗？因此，整个生态系统与编程、人员和技能、图书馆、框架和工具等相关。</p><p class="normal">There are layers to this kind of onion. For a mainstream developer shop that's stuffed with Java, not only is functional programming a radically different way of thinking about programming but also there are lots of interop questions. And have you got enough books and are there enough libraries? So there's this whole ecosystem that goes with programming, people and skills and libraries and frameworks and tools and so forth.</p>
<p class="normal">如果你有足够多的阻滞剂，你就会陷入困境。所以我认为编程语言中不同的研究技术存在于一个光谱的不同点上。有些比我们所在的地方更具进化性。你可以说，“它直接插入你现有的框架，它在未修改的 Java 上工作，它是一种静态分析，可以指出你代码中的错误和 yipee！” 这比“这是一种全新的编程思维方式”更容易吸收。</p><p class="normal">If you have enough of those blockers you get sort of stuck. So I think different pieces of research technology in programming language live on different points on a spectrum. Some are more evolutionary from where we are. You can say, “It just plugs right into your existing framework, it works on unmodified Java, it's a static analysis that points you to bugs in your code and yipee!” That's much easier to absorb than, “Here's a whole new way of thinking about programming.”</p>
<p class="normal">也就是说，我认为如果我们专门讨论函数式编程，那么我确实认为我们已经看到人们态度发生了质的翻天覆地的变化。听说过函数式编程的人比以往任何时候都多。突然之间，不必<i>总是</i>解释什么是 Haskell，有时人们会说，“哦，我听说过它。事实上，前几周我在 Slashdot 上读到过它，我觉得它很酷。” 这在几年前还没有发生。</p><p class="normal">That said, I think that if we're specifically discussing functional programming then I do think that we have seen a qualitative sea change in people's attitude. Many more people have heard about functional programming than ever used to. Suddenly rather than <i>always</i> having to explain what Haskell is, sometimes people say, “Oh, I've heard about that. In fact I was reading about it on Slashdot the other week and I gather it's rather cool.” That just didn't happen a few years ago.</p>
<p class="normal"><a id="OEBPS/Chapter07.html.page_255"></a>但这背后的原因是什么？这只是随机流行的事情吗？或许部分原因是更多的学生在大学里学习了函数式编程，现在担任管理或高级职位。也许。但也许这也与我们扩大软件处理不受限制的副作用的不良后果以及我们想要处理更多的验证和并行性有关，所有这些问题都变得更加紧迫。我认为这导致了更大程度的兴趣。我认为针正在逐渐跨越这种成本/收益权衡。</p><p class="normal"><a></a>But what's underlying that? Is it just a random popularity thing? Or maybe part of it is that more students have been taught about functional programming in university and are now in managerial or seniorish positions. Perhaps. But perhaps it's also to do with as we scale up software dealing with the bad consequences of unrestricted side effects and as we want to deal with more verification and parallelism, all those issues become more pressing. I think that leads to this greater level of interest. I think gradually the needle is moving across this cost/benefit tradeoff.</p>
<p class="normal"><b>Seibel：</b>您是什么时候开始接触函数式编程的？</p><p class="normal"><b>Seibel:</b> When did you get introduced to functional programming?</p>
<p class="normal"><b>Peyton Jones：</b>直到我在剑桥大学的最后一年，我才开始学习函数式编程，当时我参加了 Arthur Norman 开设的短期课程。Arthur Norman 是系里一位才华横溢但略显古怪的讲师。很棒的家伙，对符号代数很感兴趣，所以他也很喜欢 Lisp。他开设了一个关于函数式编程的短期课程，向我们展示了如何在完全不使用任何副作用的情况下构建双向链表。我清楚地记得这一点，因为这是我的第一个想法，你可以做一些奇怪的事情——你会认为如果你建立一个双向链表，你必须分配单元格，然后你必须填充它们以使它们指向每个单元格其他。看起来你只<i>需要</i>以某种方式使用副作用。</p><p class="normal"><b>Peyton Jones:</b> I didn't learn about functional programming until something like my final year at Cambridge when I went to a short course given by Arthur Norman. Arthur Norman was a brilliant and slightly eccentric lecturer in the department. Wonderful guy, interested in symbolic algebra so he was big into Lisp as well. He gave a short course on functional programming in which he showed us how to build doubly linked lists without using any side effects at all. I vividly remember this because this was my first notion that you could do something that weird—you'd think if you build a doubly-linked list you have to allocate the cells and then you have to fill them in to make them point to each other. It looks as if you just <i>have</i> to use side effects somehow.</p>
<p class="normal">但他展示了如何在纯函数式语言中实际编写它而不使用任何副作用。所以这让我大开眼界，函数式编程，在那个阶段我还知之甚少，是一种你可以真正编写非常有趣的程序的媒介，而不仅仅是小玩具。</p><p class="normal">But he showed how, in a purely functional language, you could actually write it without using any side effects. So that opened my eyes to the fact that functional programming, which at that stage I knew very little about, was a medium you could really write quite interesting programs in rather than just little toy ones.</p>
<p class="normal"><b>Seibel：</b>我认为很多人可能会在观看该演示时说，“哦，这不是很有趣吗”，然后仍然会继续破解 BCPL。为什么你认为你能够飞跃得如此之远，花费你职业生涯的大部分时间来展示人们如何真正使用这些东西？</p><p class="normal"><b>Seibel:</b> I think a lot of people might look at that demonstration and say, “Oh, isn't that interesting,” and then still go back to hacking BCPL. Why do you think you were able to take the leap so much farther, spending most of your career trying to show how folks can really use this stuff?</p>
<p class="normal"><b>Peyton Jones：</b>还有另外一个组成部分，就是 David Turner 关于 SK 组合器的论文。SK 组合子是一种转换然后执行 lambda 演算的方法。我已经了解了一些关于 lambda 演算的知识，当时可能是通过渗透。特纳的论文展示的是如何将 lambda 演算转化为三个<a id="OEBPS/Chapter07.html.page_256"></a>组合子 S、K 和 I。S、K 和 I 都是封闭的 lambda 项。所以它实际上是说，“你可以将这些任意复杂的 lambda 项翻译成这三个。” 事实上，你也可以去掉 I，因为 I 等于 SKK。</p><p class="normal"><b>Peyton Jones:</b> There was one other component, which was David Turner's papers on S-K combinators. S-K combinators are a way of translating and then executing the lambda calculus. I'd learned a little bit about the lambda calculus, probably by osmosis at the time. What Turner's papers showed was how to translate lambda calculus into the three <a></a>combinators, S, K, and I. S, K, and I are all just closed lambda terms. So in effect it says, “You can translate these arbitrary complicated lambda terms into just these three.” In fact, you can get rid of I as well because I equals SKK.</p>
<p class="normal">所以有一个奇怪的编译步骤，在这个步骤中，你将一个你可以理解的 lambda 项变成一团你根本无法理解的 S 和 K。但是当你将它应用于一个参数时，奇迹般地，它计算出与原始 lambda 东西相同的答案。这是另一个非常聪明的例子，当时对我来说难以置信。但是尽管如此，您还是可以看到它始终有效。</p><p class="normal">So there's this strange compilation step in which you take a lambda term that you can kind of understand and turn it into a complete mess of S's and K's that you can't understand at all. But when you apply it to an argument, miraculously, it computes the same answer as the original lambda stuff did. And that was another example of something that was very clever and, to me at the time, implausible. But nevertheless you could see that it would just always work.</p>
<p class="normal">我不太清楚是什么让我对这件事感兴趣。我发现它完全鼓舞人心。我想这部分是因为对硬件感兴趣，感觉这是一种可以<i>实现</i>lambda 演算的方法。因为 lambda 演算看起来根本不像是一种实现机制。这有点像数学思维方式，离机器有点远。这个 SK 的东西看起来好像你可以运行它，而且确实可以。</p><p class="normal">I don't know quite what it was that turned me on about this. I found it completely inspirational. It's partly, I suppose, because, being interested in hardware, it felt like this is a way you could <i>implement</i> the lambda calculus. Because the lambda calculus doesn't look like it's an implementation mechanism at all. It's a bit of a mathematical way of thinking, a bit remote from the machine. This S-K stuff looks as if you could just run it and indeed you can.</p>
<p class="normal"><b>Seibel：</b>所以，你有一种感觉，好吧，我将只构建一台硬连线 S 和 K 的机器，然后我所要做的就是将东西编译成一系列 S 和 K 操作。</p><p class="normal"><b>Seibel:</b> So, you had a sense that, OK, I'll just build a machine that has S and K hardwired and then all I've got to do is compile things to a series of S and K ops.</p>
<p class="normal"><b>Peyton Jones：</b>事实上，我的朋友们就是这么做的。William Stoye 和 Thomas Clarke 以及其他几个人建造了这台机器，SKIM，SKI 机器，它直接执行 S 和 K。出于某种原因，我没有直接参与那个项​​目。但当时有这种感觉在发展。John Backus 的论文“能否从冯诺依曼风格中解放出来”在当时极具影响力。那是他的图灵奖演讲，他就是这个发明了 Fortran 的人，实际上他说：“函数式编程是未来的方式。”</p><p class="normal"><b>Peyton Jones:</b> In fact that's exactly what my friends did. William Stoye and Thomas Clarke and a couple others, built this machine, SKIM, the SKI Machine, which directly executed S and K. For some reason I wasn't directly involved in that project. But at the time there was this feeling developing. John Backus's paper, called, “Can Programming Be Liberated from the von Neumann Style” was extremely influential at the time. It was his Turing Award lecture and he was this guy who had invented Fortran saying, in effect, “Functional programming is the way of the future.”</p>
<p class="normal">此外，他说，“也许我们应该开发新的计算机架构来执行这些东西。” 因此，对这个研究领域的高度认可意味着我们疯狂地引用了那篇论文。所以 SKIM 就是这样的一个例子。我们认为，也许这种执行或至少思考程序的不寻常方式会变成<a id="OEBPS/Chapter07.html.page_257"></a>完全不同的计算机体系结构。这个阶段大约从 1980 年持续到 1990 年——函数式编程的激进架构。我现在认为它有点误导，但它仍然非常令人兴奋。</p><p class="normal">Furthermore, he said, “Maybe we should develop new computer architectures to execute this stuff on.” So this very high-level endorsement of this research area meant we cited that paper like crazy. And so SKIM was an example of such a thing. We thought maybe this unusual way of going about executing, or at least thinking about, programs turns into a <a></a>completely different sort of computer architecture. That phase lasted from about 1980 to 1990—radical architectures for functional programming. I now regard it as slightly misdirected but nevertheless it was terribly exciting.</p>
<p class="normal">惰性评估是另一个巨大的激励因素。事后看来，我现在认为惰性评估非常棒，但在当时它有点关键。惰性评估是指函数不评估其参数的想法。同样，激励因素与它的美丽或优雅、不寻常和激进有关。</p><p class="normal">Lazy evaluation was another huge motivating factor. With the benefit of hindsight I now think lazy evaluation is just wonderful but at that time it was sort of pivotal. Lazy evaluation is this idea that functions don't evaluate their arguments. Again the motivating factor was something to do with it being beautiful or elegant and unusual and radical.</p>
<p class="normal">这有助于激发想象力：看起来这可能是一种以全新方式思考编程的方式。我们可以建造一堵全新的墙，而不是仅仅在墙上多放一块砖。这非常令人兴奋。我受到了强烈的激励。仅仅是因为这是一个巧妙的把戏吗？在某些方面，我认为巧妙的技巧非常重要。惰性求值非常简洁，你可以做一些你认为不可能的不同寻常的事情。</p><p class="normal">That's kind of good for catching the imagination: it looks as if this might be a way of thinking about programming in a whole new way. Rather than just putting one more brick in the wall, we can build a whole new wall. That's very exciting. I was strongly motivated by that. Was it just that it was a neat trick? In some ways I think neat tricks are very significant. Lazy evaluation was just so neat and you could do such remarkable different things that you wouldn't think were possible.</p>
<p class="normal"><b>Seibel：</b>比如什么？</p><p class="normal"><b>Seibel:</b> Like what?</p>
<p class="normal"><b>Peyton Jones：</b>我记得我的朋友 John Hughes 为我写了一个程序。对于一个项目，我正在执行 lambda 演算的两个实现并比较它们的性能，因此 John 给了我一些测试程序。其中之一是计算<i>e</i>的小数展开至任意精度的程序。这是一个惰性程序——它非常漂亮，因为它生成了<i>e的</i><i>所有</i>数字。<i></i></p><p class="normal"><b>Peyton Jones:</b> I remember my friend John Hughes wrote a program for me. For a project I was doing two implementations of the lambda calculus and comparing their performance, so John gave me some test programs. One of them was a program that computed the decimal expansion of <i>e</i> to arbitrary precision. It was a lazy program—it was rather beautiful because it produced <i>all</i> the digits of <i>e</i>.</p>
<p class="normal"><b>Seibel：</b>最终。</p><p class="normal"><b>Seibel:</b> Eventually.</p>
<p class="normal"><b>Peyton Jones：</b>最终，这是对的。但这取决于消费者。您不必事先说明要生成多少位数字。你刚刚得到了这个列表，你一直在拖拉列表的元素，它不会给你另一个数字，直到它花费了足够的周期来计算它。因此，如果您正在编写 C 程序，那么这不是一件很明显的事情。实际上，您可以足够聪明地做到这一点。但这不是 C 语言的自然编程范式。您几乎只能在看到惰性函数式程序后才能这样做。而约翰的程序只有四五行。惊人的。</p><p class="normal"><b>Peyton Jones:</b> Eventually, that's right. But it was up to the consumer. You didn't have to say how many digits to produce in advance. You just got given this list and you kept hauling on elements of the list and it wouldn't give you another digit until it had spent enough cycles computing it. So that's not something that's very obvious to do if you're writing a C program. Actually you can do it with enough cleverness. But it's not a natural programming paradigm for C. You can almost only do it once you've seen the lazy functional program. Whereas John's program was just about four or five lines. Amazing.</p>
<p class="normal"><a id="OEBPS/Chapter07.html.page_258"></a><b>Seibel：</b>其他语言已经对这种计算进行了特殊处理，例如，Python 中的生成器或可以产生值的东西。有没有什么让你说，“啊哈；有很多事情可以被富有成效地看作是无限系列的计算，我们只想从中得出答案，直到我们厌倦它为止？” 而不是说，“哦，这对某些问题来说是一种有趣的技术，但不是所有问题的基础。”</p><p class="normal"><a></a><b>Seibel:</b> Other languages have since special-cased that kind of computation with, for example, generators in Python or something where you can yield values. Was there something that made you say, “Aha; there are lots of things that could be fruitfully looked at as an infinite series of computations from which we just want to draw answers until we're tired of it?” As opposed to saying, “Oh, that's an interesting technique for certain problems but not the basis for everything.”</p>
<p class="normal"><b>Peyton Jones：</b>我认为在这个阶段我没有那么反思。我只是觉得它太酷了。和乐趣。我认为做你觉得有动力和有趣的事情并遵循它是很重要的。我只是发现它非常鼓舞人心。我不认为我真的认为这是进行编程<i>的</i>方式有深刻的原则性原因。我只是认为这是一种非常棒的编程方式。我喜欢滑雪。那么，我为什么喜欢滑雪呢？不是因为它会改变世界——只是因为它很有趣。</p><p class="normal"><b>Peyton Jones:</b> I think at this stage I wasn't as reflective as that. I just thought it was so cool. And fun. I think it's important to do what you find motivating and interesting and follow it. I just found it very inspiring. I don't think I really thought there are deep principled reasons why this is <i>the</i> way to do programming. I just thought it was a rather wonderful way to do programming. I like skiing. Well, why do I like skiing? Not because it's going to change the world—just because it's a lot of fun.</p>
<p class="normal">我现在认为懒惰的重要之处在于它让我们保持纯洁。您可能会在我的几次演讲中看到这一点。但我其实很喜欢懒惰。如果有选择，我会选择一种惰性语言。我认为它对各种编程事物真的很有帮助。我相信您已经阅读了 John Hughes 的论文“Why Functional Programming Matters”。这可能是最早以一种可爱的方式阐明为什么懒惰可能很重要的阐述。他的主要故事是它可以帮助您编写模块化程序。</p><p class="normal">I now think the important thing about laziness is that it kept us pure. You'll have seen this in several of my talks probably. But I actually really like laziness. Given a choice I'd choose a lazy language. I think it's really helpful for all kinds of programming things. I'm sure you've read John Hughes's paper, “Why Functional Programming Matters.” It's probably the earliest articulate exposition of why laziness might be important in more than a cute way. And his main story is that it helps you write modular programs.</p>
<p class="normal">惰性求值让你可以编写生成器——他的例子是在你的国际象棋游戏中生成所有可能的动作——与你的消费者分开，它走过树并进行 alpha-beta minimaxing 或其他事情。或者，如果您正在生成一个答案的所有近似值序列，那么您就会有一个消费者告诉您何时停止。事实证明，通过将生成器与消费者分开，您可以模块化地分解您的程序。然而，如果您必须将它与一个说何时停止的消费者一起生成，那会使您的程序的模块化程度大大降低。模块化的意思是在可以组合在一起的不同地方的不同思想。John 的论文提供了一些很好的示例，说明您可以彼此独立地更改消费者或更改生成器的方法，</p><p class="normal">Lazy evaluation lets you write generators—his example is generate all the possible moves in your chess game—separately from your consumer, which walks over the tree and does alpha-beta minimaxing or something. Or if you're generating all the sequence of approximations of an answer, then you have a consumer who says when to stop. It turns out that by separating generators from consumers you can modularly decompose your program. Whereas, if you're having to generate it along with a consumer that's saying when to stop, that can make your program much less modular. Modular in the sense of separate thoughts in separate places that can be composed together. John's paper gives some nice examples of ways in which you can change the consumer or change the generator, independently from each other, and that lets you plug together new programs that would have been more difficult to get by modifying one tightly interwoven one.</p>
<p class="normal"><a id="OEBPS/Chapter07.html.page_259"></a>这就是为什么懒惰是一件好事。它在您的程序的局部级别上也非常有帮助。你会发现 Haskell 程序员会写下带有一些局部定义的函数定义。所以他们会说“f of × equals blah, blah, blah <i>where</i> …”并且在<code>where</code>子句中他们写下了一堆定义和这些定义，并不是在所有情况下都需要。但是你还是把它们写下来。需要的将得到评估；那些不需要的不会。所以你不必想，“哦，天哪，所有这些子表达式都将被评估，但我无法评估它，因为它会因为除以零而崩溃，所以我必须将定义移到条件的右分支。”</p><p class="normal"><a></a>So that's all about why laziness is a good thing. It's also very helpful in a very local level in your program. You tend to find Haskell programmers will write down a function definition with some local definitions. So they'll say “f of × equals blah, blah, blah <i>where</i> …” And in the <code>where</code> clause they write down a bunch of definitions and of these definitions, not all are needed in all cases. But you just write them down anyway. The ones that are needed will get evaluated; the ones that aren't needed won't. So you don't have to think, “Oh, goodness, all of these sub expressions are going to be evaluated but I can't evaluate that because that would crash because of a divide by zero so I have to move the definition into the right branch of the conditional.”</p>
<p class="normal">没有这些。您倾向于只写下可能需要的辅助定义，然后评估需要的定义。所以这是一种编程方便的东西。这是一个非常非常方便的机制。</p><p class="normal">There's none of that. You tend to just write down auxiliary definitions that might be needed and the ones that are needed will be evaluated. So that's a kind of programming convenience thing. It's a very, very convenient mechanism.</p>
<p class="normal">但是回到大局，如果你有一个懒惰的求值器，就很难准确预测一个表达式何时被求值。所以这意味着如果你想在屏幕上打印一些东西，每一种按值调用的语言，其中评估的顺序是完全明确的，通过有一个不纯的“函数”来做到这一点——我在它周围加上引号，因为它现在根本不是一个函数——类型类似于 string to unit。您调用此函数，作为副作用，它会在屏幕上显示一些内容。这就是 Lisp 中发生的事情；它也发生在 ML 中。它基本上发生在每种按值调用语言中。</p><p class="normal">But getting back to the big picture, if you have a lazy evaluator, it's harder to predict exactly when an expression is going to be evaluated. So that means if you want to print something on the screen, every call-by-value language, where the order of evaluation is completely explicit, does that by having an impure “function”—I'm putting quotes around it because it now isn't a function at all—with type something like string to unit. You call this function and as a side effect it puts something on the screen. That's what happens in Lisp; it also happens in ML. It happens in essentially every call-by-value language.</p>
<p class="normal">现在在纯语言中，如果你有一个从字符串到单元的函数，你永远不需要调用它，因为你知道它只是给出答案单元。这就是一个函数所能做的，就是给你答案。你知道答案是什么。但是，当然，如果它有副作用，那么调用它是非常重要<i>的</i>。在惰性语言中，问题在于如果你说“<code>f</code>应用于<code>print “hello”</code>”，那么<code>f</code>函数的调用者并不明显地评估它的第一个参数。这与函数的内部结构有关。如果你给它传递两个参数<code>f</code>，<code>print “hello”</code>和<code>print “goodbye”</code>, 那么您可以按任一顺序打印其中一个或两个。所以不知何故，通过惰性评估，通过副作用进行输入/输出是不可行的。你不能那样写出合理、可靠、可预测的程序。所以，我们不得不忍受。这真的有点尴尬，因为你真的不能<a id="OEBPS/Chapter07.html.page_260"></a>做任何输入/输出可言。所以很长一段时间以来，我们基本上都有可以将字符串转换为字符串的程序。这就是整个程序所做的。输入字符串是输入，结果字符串是输出，这就是程序真正能做的。</p><p class="normal">Now in a pure language, if you have a function from string to unit you would never need to call it because you know that it just gives the answer unit. That's all a function can do, is give you the answer. And you know what the answer is. But of course if it has side effects, it's very important that you <i>do</i> call it. In a lazy language the trouble is if you say, “<code>f</code> applied to <code>print “hello”</code>,” then whether <code>f</code> evaluates its first argument is not apparent to the caller of the function. It's something to do with the innards of the function. And if you pass it two arguments, <code>f</code> of <code>print “hello”</code> and <code>print “goodbye”</code>, then you might print either or both in either order or neither. So somehow, with lazy evaluation, doing input/output by side effect just isn't feasible. You can't write sensible, reliable, predictable programs that way. So, we had to put up with that. It was a bit embarrassing really because you couldn't really <a></a>do any input/output to speak of. So for a long time we essentially had programs which could just take a string to a string. That was what the whole program did. The input string was the input and result string was the output and that's all the program could really ever do.</p>
<p class="normal">您可以通过使输出字符串编码一些由某些外部解释器解释的输出命令来变得有点聪明。所以输出字符串可能会说，“在屏幕上打印这个；把它放在磁盘上。” 口译员实际上可以做到这一点。所以你想象函数式程序是美好而纯粹的，并且有某种解释一串命令的邪恶解释器。但是，当然，如果您读取一个文件，您如何将输入返回到程序中呢？好吧，这不是问题，因为你可以输出一串由邪恶的解释器解释的命令，并使用惰性求值，它可以将结果转储回程序的输入。因此，该程序现在采用对请求流的响应流。请求的流向邪恶的解释器，它对世界做事。每个请求都会生成一个响应，然后将其反馈给输入。并且由于评估是惰性的，程序会及时发出响应，以便它绕过循环并作为输入使用。但它有点脆弱，因为如果你过于急切地消耗你的响应，那么你就会陷入某种僵局。因为你会问一个你还没有从后端吐出来的问题的答案。</p><p class="normal">You could get a bit clever by making the output string encode some output commands that were interpreted by some outer interpreter. So the output string might say, “Print this on the screen; put that on the disk.” An interpreter could actually do that. So you imagine the functional program is all nice and pure and there's sort of this evil interpreter that interprets a string of commands. But then, of course, if you read a file, how do you get the input back into the program? Well, that's not a problem, because you can output a string of commands that are interpreted by the evil interpreter and using lazy evaluation, it can dump the results back into the input of the program. So the program now takes a stream of responses to a stream of requests. The stream of requests go to the evil interpreter that does the things to the world. Each request generates a response that's then fed back to the input. And because evaluation is lazy, the program has emitted a response just in time for it to come round the loop and be consumed as an input. But it was a bit fragile because if you consumed your response a bit too eagerly, then you get some kind of deadlock. Because you'd be asking for the answer to a question you hadn't yet spat out of your back end yet.</p>
<p class="normal">关键是懒惰把我们逼到了一个角落，我们不得不想办法解决这个 I/O 问题。我认为那非常重要。懒惰最重要的一点是它驱使我们到达那里。但这不是它开始的方式。从一开始，懒惰很酷；多么棒的编程习惯。</p><p class="normal">The point of this is laziness drove us into a corner in which we had to think of ways around this I/O problem. I think that that was extremely important. The single most important thing about laziness was it drove us there. But that wasn't the way it started. Where it started was, laziness is cool; what a great programming idiom.</p>
<p class="normal"><b>Seibel：</b>自从您开始编程以来，您对编程的看法发生了什么变化？</p><p class="normal"><b>Seibel:</b> Since you started programming, what's changed about how you think about programming?</p>
<p class="normal"><b>Peyton Jones：</b>我认为我对编程的看法的重大变化可能与 monad 和类型系统有关。与 80 年代初期考虑使用相对简单类型系统的纯函数式编程相比，现在我考虑的是纯函数式、命令式和由 monad 调解的并发编程的混合体。并且类型变得更加复杂，允许您表达<a id="OEBPS/Chapter07.html.page_261"></a>在那个阶段，我设想的项目范围比我想象的要广泛得多。我想，您可以将这两者视为某种进化。</p><p class="normal"><b>Peyton Jones:</b> I think probably the big changes in how I think about programming have been to do with monads and type systems. Compared to the early 80s, thinking about purely functional programming with relatively simple type systems, now I think about a mixture of purely functional, imperative, and concurrent programming mediated by monads. And the types have become a lot more sophisticated, allowing you to express a <a></a>much wider range of programs than I think, at that stage, I'd envisaged. You can view both of those as somewhat evolutionary, I suppose.</p>
<p class="normal"><b>Seibel：</b>例如，自从您第一次尝试编写编译器失败后，您已经编写了很多编译器。您一定已经了解了一些有关如何做到这一点的知识，使您现在能够成功地做到这一点。</p><p class="normal"><b>Seibel:</b> For instance, since your first abortive attempt at writing a compiler you've written lots of compilers. You must have learned some things about how to do that that enable you to do it successfully now.</p>
<p class="normal"><b>佩顿·琼斯：</b>是的。好吧，很多事情。那当然是用命令式语言编写的命令式语言的编译器。现在我正在用函数式语言为函数式语言编写编译器。但是 GHC（我们的 Haskell 编译器）的一大特点是它使用的中间语言本身就是类型化的。</p><p class="normal"><b>Peyton Jones:</b> Yes. Well, lots of things. Of course that was a compiler for an imperative language written in an imperative language. Now I'm writing a compiler for a functional language in a functional language. But a big feature of GHC, our compiler for Haskell, is that the intermediate language it uses is itself typed.</p>
<p class="normal"><b>Seibel：</b>中间表示上的打字是否只是从原始源进行打字？</p><p class="normal"><b>Seibel:</b> And is the typing on the intermediate representation just carrying through the typing from the original source?</p>
<p class="normal"><b>Peyton Jones：</b>是的，但要明确得多。在原始源中，正在进行大量类型推断，并且源语言经过精心设计，因此可以进行类型推断。在中间语言中，类型系统更通用，更具表现力，因为它更明确：每个函数参数都用其类型修饰。没有类型<i>推断</i>，只有中间语言的类型<i>检查</i>。所以它是一种显式类型的语言，而源语言是隐式类型的。</p><p class="normal"><b>Peyton Jones:</b> It is, but it's much more explicit. In the original source, lots of type inference is going on and the source language is carefully crafted so that type inference is possible. In the intermediate language, the type system is much more general, much more expressive because it's more explicit: every function argument is decorated with its type. There's no type <i>inference</i>, there's just type <i>checking</i> for the intermediate language. So it's an explicitly typed language whereas the source language is implicitly typed.</p>
<p class="normal">类型推断基于一组精心选择的规则，这些规则确保它恰好符合类型推断引擎可以计算出的内容。如果您通过源到源的转换来转换程序，也许您现在已经超出了该边界。类型推断无法再达到它。所以这不利于优化。您不希望优化不得不担心您是否刚刚超出了类型推断的界限。</p><p class="normal">Type inference is based on a carefully chosen set of rules that make sure that it just fits within what the type inference engine can figure out. If you transform the program by a source-to-source transformation, maybe you've now moved outside that boundary. Type inference can't reach it any more. So that's bad for an optimization. You don't want optimizations to have to worry about whether you might have just gone out of the boundaries of type inference.</p>
<p class="normal"><b>Seibel：</b>所以这表明有些程序是正确的，因为你假设一个合法的源到源转换，如果你手动编写它，编译器会说，“对不起；我无法打字。”</p><p class="normal"><b>Seibel:</b> So that points out that there are programs that are correct, because you're assuming a legitimate source-to-source transformation, which, if you had written it by hand, the compiler would have said, “I'm sorry; I can't type this.”</p>
<p class="normal"><b>佩顿·琼斯：</b>对。这就是静态类型系统的本质——也是动态语言仍然有趣和重要的原因。有节目<a id="OEBPS/Chapter07.html.page_262"></a>您可以编写特定类型系统无法输入但在运行时不会“出错”的代码，这是黄金标准——不要段错误，不要向字符添加整数。他们很好。</p><p class="normal"><b>Peyton Jones:</b> Right. That's the nature of static type systems—and why dynamic languages are still interesting and important. There are programs <a></a>you can write which can't be typed by a particular type system but which nevertheless don't “go wrong” at runtime, which is the gold standard—don't segfault, don't add integers to characters. They're just fine.</p>
<p class="normal"><b>Seibel：</b>因此，当动态类型和静态类型的拥护者发生争执时，动态类型的人会说，“嗯，有很多这样的程序——静态类型妨碍了我编写我想编写的程序。” 然后静态类型的粉丝说，“不，它们存在，但实际上这不是问题。” 你对此有何看法？</p><p class="normal"><b>Seibel:</b> So when advocates of dynamic and static typing bicker the dynamic folks say, “Well, there are lots of those programs—static typing gets in the way of writing the program I want to write.” And then the fans of static typing say, “No, they exist but in reality it's not a problem.” What's your take on that?</p>
<p class="normal"><b>Peyton Jones：</b>这在一定程度上与简单的熟悉有关。这很像我说我对编写 C++ 程序没有本能的感觉。或者，您不会错过懒惰评估，因为您从未使用过它，而我会错过它，因为我会经常使用它。也许动态类型有点像那样。我的感觉——考虑到它的价值，考虑到我在文化上有偏见——大块程序可以完美地静态类型化，尤其是在这些非常丰富的类型系统中。在可能的情况下，由于经过广泛排练的原因，它非常有价值。</p><p class="normal"><b>Peyton Jones:</b> It's partly to do with simple familiarity. It's very like me saying I've not got a visceral feel for writing C++ programs. Or, you don't miss lazy evaluation because you've never had it whereas I'd miss it because I'm going to use it a lot. Maybe dynamic typing is a bit like that. My feeling—for what it's worth, given that I'm biased culturally—is that large chunks of programs can be perfectly well statically typed, particularly in these very rich type systems. And where it's possible, it's very valuable for reasons that have been extensively rehearsed.</p>
<p class="normal">但很少排练的一项是维护。当你有一段三年前写的代码，你想对其进行系统性的改变时——不仅仅是对一个过程的一点点调整，而是会产生普遍影响的东西——我发现类型系统非常有用.</p><p class="normal">But one that is less often rehearsed is maintenance. When you have a blob of code that you wrote three years ago and you want to make a systemic change to it—not just a little tweak to one procedure, but something that is going to have pervasive effects—I find type systems are incredibly helpful.</p>
<p class="normal">这发生在我们自己的编译器中。我可以对 GHC 进行更改，对遍及编译器的数据表示进行更改，并且可以确信我已经找到了所有使用它们的地方。我会非常担心用一种更动态的语言来表达这一点。我会担心我错过了一个并发布了一个编译器，其中有人输入了一些我从未有过的数据，它只是落在了一些我没有持续改变的东西上。</p><p class="normal">This happens in our own compiler. I can make a change to GHC, to data representations that pervade the compiler, and can be confident that I've found all the places where they're used. And I'd be very anxious about that in a more dynamic language. I'd be anxious that I'd missed one and shipped a compiler where somebody feeds in some data that I never had and it just fell over something that I hadn't consistently changed.</p>
<p class="normal">我想静态类型对我来说也执行了我对程序<i>功能</i>的部分解释。这是一种小语言，我可以用它来说明这个程序的作用，但不能说太多。人们经常问，“什么是函数式语言的 UML 图？” 我认为我能想到的最好的答案是类型系统。当一个面向对象的程序员可能会画一些图时，我却坐在那里写类型签名。当然，它们不是图解式的，但因为它们是一种正式语言，所以它们构成了程序文本的永久部分<a id="OEBPS/Chapter07.html.page_263"></a>并根据我编写的代码进行静态检查。所以它们也有各种好的特性。它几乎是对程序部分功能的架构描述。</p><p class="normal">I suppose static types, for me, also perform part of my explanation of what the program <i>does</i>. It's a little language in which I can say something, but not too much, about what this program does. People often ask, “What's the equivalent of UML diagrams for a functional language?” And I think the best answer I've ever been able to come up with is, it's the type system. When an object-oriented programmer might draw some pictures, I'm sitting there writing type signatures. They're not diagrammatic, to be sure, but because they are a formal language, they form a permanent part of the program text <a></a>and are statically checked against the code that I write. So they have all sorts of good properties, too. It's almost an architectural description of part of what your program does.</p>
<p class="normal"><b>Seibel：</b>那么你有没有写过一个你知道是正确的但不知何故落在类型检查器范围之外的程序？</p><p class="normal"><b>Seibel:</b> So do you ever write a program that you know is correct but somehow falls outside the bounds of the type checker?</p>
<p class="normal"><b>Peyton Jones：</b>当你在进行泛型编程时会出现这种情况，比如你想编写函数来获取任何类型的数据，然后遍历它并序列化它。所以那时候类型可能有点笨拙，而无类型语言特别简单。用无类型语言编写序列化程序再简单不过了。</p><p class="normal"><b>Peyton Jones:</b> This comes up when you're doing generic programming, where you want to write functions that will take data of any type and just walk over it and serialize it, say. So that's a time when types can be a bit awkward and an untyped language is particularly straightforward. It couldn't be easier to write a serializer in an untyped language.</p>
<p class="normal">现在有一个小型家庭手工业，人们描述了编写通用程序的巧妙类型化方法。我认为这样的事情很有趣。但它在某种程度上并不像用动态类型语言编写它那么简单。我试图说服 John Hughes 为<i>Journal of Functional Programming</i>写一篇关于为什么静态类型不好的论文。因为我认为 John 写一篇论文会很有趣，John 是主流的、强类型的、非常成熟的函数式程序员，他现在在非类型化的 Erlang 中做了大量的工作，说明为什么静态类型不好。我认为他会写一篇非常有反思性和有趣的论文。我不知道我们会在哪里结束。</p><p class="normal">Now there's a small cottage industry of people describing clever typed ways of writing generic programs. I think such things are fascinating. But it's somehow just isn't as simple as writing it in a dynamically typed language. I'm trying to persuade John Hughes to write a paper for the <i>Journal of Functional Programming</i> on why static typing is bad. Because I think it would be very interesting to have a paper from John, who's a mainstream, strongly typed, very sophisticated functional programmer, who is now doing a lot of work in untyped Erlang, saying why static types are bad. I think he would write a very reflective and interesting paper. I don't know quite where we'll end up.</p>
<p class="normal">我想我仍然会说，“在适合静态类型的地方，每次都这样做，因为它具有极好的维护好处。” 它可以帮助您考虑您的程序；它可以帮助您编写它，所有这些东西。但是，我们不断生成越来越复杂的类型系统这一事实表明，我们正在努力不断突破界限，在世界上说得更多——涵盖更多的程序。所以故事还没有讲完。</p><p class="normal">I think I would still say, “Where static typing fits, do it every time because it has just fantastic maintenance benefits.” It helps you think about your program; it helps you write it, all that kind of stuff. But the fact that we keep generating more and more sophisticated type systems is an indication that we're trying to keep pushing the boundary out to say more in the world—to cover more programs. So the story hasn't finished yet.</p>
<p class="normal">依赖类型编程的人会说，“最终类型系统应该能够表达任何东西。” 但类型是有趣的东西——类型就像一种非常紧凑的规范语言。他们说了一些关于该功能的内容，但没有太多以至于您无法一次将其放在脑海中。所以关于类型的一个重要的事情是它有点脆。如果它持续了两页，那么它就停止传达它应该传达的所有信息。</p><p class="normal">The dependently typed programming people would say, “Ultimately the type system should be able to express absolutely anything.” But types are funny things—types are like a very compact specification language. They say something about the function but not so much that you can't fit it in your head at one time. So an important thing about a type is it's kind of crisp. If it goes on for two pages, then it stops conveying all the information it should.</p>
<p class="normal"><a id="OEBPS/Chapter07.html.page_264"></a>我认为我希望看到事情发展的方向是保持清晰和紧凑的类型，这些类型有点弱，正是为了使它们能够清晰，以及不变量，也许用比可推断类型更丰富的语言来表达系统，但仍然可以进行静态检查。我在另一个项目中正在做的事情是尝试对前置条件和后置条件以及数据类型不变量进行静态验证。</p><p class="normal"><a></a>I think the direction I'd like to see things go is to have still crisp and compact types which are a little bit weak, precisely so that they can be crisp, along with invariants, perhaps stated in a rather richer language than the inferable type system, but which are still amenable to static checking. Something I'm working on in another project is to try to do static verification for pre- and post-conditions and data-type invariants.</p>
<p class="normal"><b>Seibel：</b>类似于埃菲尔铁塔的合同设计？</p><p class="normal"><b>Seibel:</b> Similar to Design by Contract in Eiffel?</p>
<p class="normal"><b>佩顿·琼斯：</b>没错。你希望能够为这样的函数编写契约，“你给我大于零的参数，我会给你一个小于零的结果。”</p><p class="normal"><b>Peyton Jones:</b> That's right. You'd like to be able to write a contract for a function like, “You give me arguments that are bigger than zero and I'll give you a result that is smaller than zero.”</p>
<p class="normal"><b>Seibel：</b>你是如何着手设计软件的？</p><p class="normal"><b>Seibel:</b> How do you go about designing software?</p>
<p class="normal"><b>Peyton Jones：</b>我想我会说，当我考虑编写程序（考虑编写一些新的 GHC）时，通常最主要的问题不是如何将想法转化为代码。但更确切地说，这是什么想法？</p><p class="normal"><b>Peyton Jones:</b> I suppose I would say that usually the dominant problem when I'm thinking about writing a program—thinking about writing some new piece of GHC—is not how to get the idea into code. But it's rather, what is the idea?</p>
<p class="normal">举个例子，目前我们正在移动 GHC 的后端，代码生成部分，以一种新的方式重构它。目前，编译器中有一个步骤基本上采用函数式语言并将其翻译成 C--，这是一种命令式语言。这是相当大的一步。它被称为 C-- 因为它就像 C 的一个子集。但它确实是一种可移植的汇编语言。而且它不是以 ASCII 打印出来的——它只是一种内部数据类型。所以在编译器中这一步就是从表示函数式程序的数据结构到表示命令式程序的数据结构的函数。你如何迈出这一步？</p><p class="normal">To take an example, at the moment we're in mid-flight for moving GHC's back end, the code generation part, to refactor it in a new way. At the moment there's a step in the compiler that takes essentially a functional language and translates it into C--, which is an imperative language. And that's a pretty big step. It's called C-- because it's like a subset of C. But it's really meant to be a portable assembly language. And it's not printed out in ASCII—it's just an internal data type. So this step in the compiler is a function from a data structure representing a functional program to a data structure representing an imperative program. How do you make that step?</p>
<p class="normal">好吧，我现在有一段相当复杂的代码可以做到这一点。但是前几天我意识到它可以分成两部分：首先把它变成C--的一种方言，它允许过程调用——在一个过程中，你可以调用一个过程。然后将其翻译<i>成</i>一种没有调用的子语言——只有尾调用。</p><p class="normal">Well, I have a pretty complicated bit of code that does that at the moment. But a couple of days ago I realized that it could be separated into two parts: first transform it into a dialect of C--, which allows procedure calls—inside a procedure, you can call a procedure. Then translate <i>that</i> into a sub-language that has no calls—only has tail calls.</p>
<p class="normal">那么问题来了，数据类型到底是什么？这个 C-- 东西，它是什么？它是代表命令式程序的数据结构。当你进行第二步时，你遍历程序，<a id="OEBPS/Chapter07.html.page_265"></a>看着每一位，一次一个。因此，您的注意力会沿着控制流向下移动，或者可能会通过控制流向上移动。一个很好的表示它的数据结构被称为“拉链”——这是一个非常有用的纯函数数据结构，可以将焦点转移到一个纯函数数据结构上。</p><p class="normal">Then the name of the game is figuring out, just what is the data type? This C-- stuff, what is it? It's a data structure representing an imperative program. And as you make the second step, you walk over the program, <a></a>looking at each bit, one at a time. So your focus of attention moves down the control flow, or perhaps back up through the control flow. A good data structure for representing that is called a “zipper”—which is a very useful purely functional data structure for moving the focus around a purely functional data structure.</p>
<p class="normal">哈佛大学的诺曼·拉姆齐 (Norman Ramsey) 找到了一种使用它来遍历表示命令式控制流图的数据结构的方法。所以他和我以及 John Dias 然后花了一段时间重新设计 GHC 的后端以基本上采用这种分解技术。这样做使它更加通用，因此我们现在可以使用相同的后端作为其他语言的后端。</p><p class="normal">Norman Ramsey at Harvard found a way to use this for walking around data structures that represent imperative control flow graphs. So he and I and John Dias then spent a while reengineering GHC's back end to adopt essentially this factored technology. And in doing so making it much more general so we can now use this same back end as a back end for other languages.</p>
<p class="normal">我们的很多讨论基本上都是在类型级别。Norman 会说，“这是 API，”——通过给出类型签名——我会说，“这看起来很复杂，为什么会这样？” 他会解释原因，我会说，“这样就不能更简单吗？” 所以我们在描述类型的层面上花了很多时间来来回回。</p><p class="normal">A lot of our discussion was essentially at the type level. Norman would say, “Here's the API,”—by giving a type signature—and I would say, “That looks way complicated, why is it like that?” And he'd explain why and I'd say, “Couldn't it be simpler this way.” So we spent a lot of time to'ing and fro'ing at the level of describing types.</p>
<p class="normal">但很多时候它并不是真正关于编程本身——它是关于，想法是什么？无论如何，我们试图用这个数据流分析做什么？您尝试以清晰的方式说明程序的这一步是为了做什么。所以我们花了很多时间来弄清楚输入和输出是什么，并研究输入和输出的数据类型。只要正确设置数据类型，您就已经对程序的功能说了很多。事实上，数量惊人。</p><p class="normal">But a lot of the time it wasn't really about programming as such—it was about, what is the idea? What are we trying to do with this dataflow analysis, anyway? You try to say in a clear way what this step of the program is meant to do. So we spent quite a lot of time just being clear on what the inputs and the outputs are and working on the data types of the inputs and the outputs. Just getting the data types right, already you've said quite a lot about what your program does. A surprisingly large amount, in fact.</p>
<p class="normal"><b>Seibel：</b>思考类型与实际坐下来编码有什么关系？勾勒出类型后，您可以坐下来编写代码吗？还是编写代码的行为会反馈到您对类型的理解中？</p><p class="normal"><b>Seibel:</b> How does thinking about the types relate to actually sitting down and coding? Once you sketch out the types can you sit down and write the code? Or does the act of writing the code feed back into your understanding of the types?</p>
<p class="normal"><b>Peyton Jones：</b>哦，更多的是后者，是的。我将立即开始将类型签名写入文件。实际上，我可能会开始编写一些代码来操纵这些类型的值。然后我会回去更改数据类型。这不是我们说“现在我已经完成了类型，我可以编写代码了”的两阶段过程。</p><p class="normal"><b>Peyton Jones:</b> Oh, more the latter, yes. I'll start writing type signatures into a file right away. Actually I'll probably start writing some code that manipulates values of those types. Then I'll go back and change the data types. It's not a two-stage process where we say, “Now I've done the types, I can write the code.”</p>
<p class="normal"><a id="OEBPS/Chapter07.html.page_266"></a>如果有的话，我对此有点缺乏纪律。这是因为没有作为大型团队的一员工作。当你在编写代码时，你可以做一些你在一个更大的团队中可能做不到的事情，一个人仍然可以理解。</p><p class="normal"><a></a>If anything I'm a bit ill-disciplined about this. This comes from not working as part of a large team. You can do things when you're working on code that one person can still get their head around that you probably couldn't in a much bigger team.</p>
<p class="normal"><b>Seibel：</b>您提到在 GHC 的最新代码剧变中，事情变得更加普遍。GHC 是一个随着时间的推移而发展的大型程序，因此您有机会从通用性中受益，也有机会为过度通用性付出代价。关于如何在泛化过度和泛化不足之间取得平衡，你学到了什么吗？</p><p class="normal"><b>Seibel:</b> You mentioned that in this latest code upheaval in GHC, things got much more general. GHC is a big program that's evolved over time so you've had the chance to benefit from generality and the chance to pay the cost of over-generality. Have you learned anything about how to strike the balance between over- and under- generalization?</p>
<p class="normal"><b>Peyton Jones：</b>我认为我的默认设置是不会一开始就写一些非常笼统的东西。所以我试着让我的程序尽可能<i>漂亮</i>，但不一定尽可能<i>通用</i>。这是有区别的。我尝试编写能够以尽可能清晰明了的方式完成手头任务的代码。只有当我发现自己多次编写本质上相同的代码时，我才会想，“哦，让我们只做一次，传递一些额外的参数以在两者之间不同的位上对其进行参数化。”</p><p class="normal"><b>Peyton Jones:</b> I think my default is not to write something very general to begin with. So I try to make my programs as <i>beautiful</i> as I can but not necessarily as <i>general</i> as I can. There's a difference. I try to write code that will do the task at hand in a way that's as clear and perspicuous as I can make it. Only when I've found myself writing essentially the same code more than once, then I'll think, “Oh, let's just do it once, passing some extra arguments to parameterize it over the bits that are different between the two.”</p>
<p class="normal"><b>Seibel：</b>您的实际编程环境是什么？你使用什么工具？</p><p class="normal"><b>Seibel:</b> What is your actual programming environment? What tools do you use?</p>
<p class="normal"><b>佩顿琼斯：</b>哦，非常原始。我只是坐在那里使用 Emacs 并使用 GHC 进行编译。仅此而已。我们的编译器附带了性能分析工具，人们经常使用这些工具来分析 Haskell 程序。我们这样做是为了分析编译器本身。GHC 转储了很多中间输出，所以我可以看到发生了什么。</p><p class="normal"><b>Peyton Jones:</b> Oh, terribly primitive. I just sit there with Emacs and compile with GHC. That's just about it. There are profiling tools that come with our compiler and people often use those for profiling Haskell programs. And we do that for profiling the compiler itself. GHC dumps a lot of intermediate output so I can see what's going on.</p>
<p class="normal">调试，对我来说，通常是编译器没有生成好的代码，所以我正在观察它的内部状态。或者，使用这个小源程序；到目前为止编译它；看那个。那是对我的调试。它很少单步执行程序——它更多地查看编译中不同部分的值。</p><p class="normal">Debugging, for me, is often, the compiler isn't generating good code so I'm eyeballing the state of its entrails. Or, take this little source program; compile it this far; look at that. That's debugging for me. It's seldom single-stepping through the program—it's more looking at values of different parts in compilation.</p>
<p class="normal">我什至没有任何非常复杂的 Emacs jiggery-pokery。有些人这样做。还有很多人习惯了 Visual Studio 和 Eclipse 类的 IDE。我认为采用函数式编程语言的文化障碍部分是因为我们没有 IDE<a id="OEBPS/Chapter07.html.page_267"></a>故事整理好了。这里有点鸡生蛋还是蛋生鸡的问题。目前这只鸡越来越忙了——一般来说，人们对函数式编程更感兴趣。我希望这会激发对鸡蛋的研究。为 Haskell 构建 IDE 需要大量工程。即使使用 Visual Studio 作为 shell 或 Eclipse 作为 shell，要制作一个真正流畅且一切正常的插件也需要做很多工作。</p><p class="normal">I don't even have any very sophisticated Emacs jiggery-pokery. Which some people do. There's also a whole world of people out there who are used to Visual Studio and Eclipse kind of IDEs. I think a cultural barrier to adoption of functional programming languages is partly that we haven't got the IDE <a></a>story sorted out. There's a bit of a chicken-and-egg problem here. At the moment the chicken is getting busier—there's more interest in functional programming generally. I'm hoping that will provoke work on the egg. It's a lot of engineering to build an IDE for Haskell. Even with Visual Studio as a shell or Eclipse as a shell, there's quite a lot of work in making a plugin that's really smooth and does everything right.</p>
<p class="normal"><b>Seibel：</b> GHC 有一个读取-评估-打印循环，GHCI。你倾向于交互式地编写 Haskell 程序吗？</p><p class="normal"><b>Seibel:</b> GHC has a read-eval-print loop, GHCI. Do you tend to program Haskell interactively?</p>
<p class="normal"><b>Peyton Jones：</b>实际上，我主要从事编辑和编译工作。但其他人一生都在 GHCI 中度过。</p><p class="normal"><b>Peyton Jones:</b> Actually, I tend to mostly edit and compile. But other people just live their whole lives in GHCI.</p>
<p class="normal"><b>Seibel：</b>说到测试，我想函数式语言的好处之一就是当你想测试程序内部的一些小函数时，你只需要弄清楚它的输入是什么形式。</p><p class="normal"><b>Seibel:</b> When it comes to testing, I suppose one of the nice things about functional languages is when you want to test some little function in the bowels of your program, you just have to figure out what form is its input going to be.</p>
<p class="normal"><b>Peyton Jones：</b>嗯，对我来说，如果输入数据足够简单，你可以做到这一点，那么我的程序可能就不会出现问题。我的程序的问题将是一些相当庞大的输入程序，GHC 试图编译它并得到错误的答案。</p><p class="normal"><b>Peyton Jones:</b> Well, for me, if the input data is simple enough that you could do that, it's probably not going to be the problem with my program. The problem with my program is going to be some fairly humongous input program that GHC is trying to compile and getting the wrong answer for it.</p>
<p class="normal">我认为，测试对于记录属性非常重要，而 QuickCheck 属性非常有用——QuickCheck 是一个 Haskell 库，用于根据函数的类型生成随机测试。但我试图思考为什么我不更多地使用 QuickCheck——这是一个非常好的工具。我认为这是因为给我带来麻烦的情况是我发现很难为其生成测试数据的情况。无论如何，有很多人在那里生成程序，以某种方式使 GHC 呕吐。这就是 GHC 的错误跟踪器的作用。</p><p class="normal">Testing is, I think, frightfully important for writing down properties and QuickCheck properties are really useful—QuickCheck is a Haskell library for generating random tests for a function based on its type. But I was trying to think why I don't use QuickCheck—which is a very nice tool—more. I think it's because the situations that cause me trouble are ones that I would find it difficult to generate test data for. In any case, there are loads of people out there generating programs that make GHC barf in one way or another. That's what GHC's bug tracker is about.</p>
<p class="normal">所以通常我已经从不正确的事情开始了。也许编译器可能会完全崩溃或者在不应该的时候拒绝一个程序。或者它可能只是生成次优代码。如果它只是生成了错误的代码，我会查看编译管道中各个阶段的代码并说：“那么它看起来不错；那看起来不错。呸，这里变坏了；怎么了？</p><p class="normal">So typically I'm starting with something that's not right, already. Maybe the compiler could just fall over altogether or reject a program when it shouldn't. Or it could just generate suboptimal code. If it's just generating bad code, I'll look at the code at various stages in the compilation pipeline and say, “It looks good then; it looks good then. Bah, it's gone bad here; what's gone wrong?”</p>
<p class="normal"><a id="OEBPS/Chapter07.html.page_268"></a><b>Seibel：</b>那么您实际上是如何看待它的呢？</p><p class="normal"><a></a><b>Seibel:</b> So how do you actually look at it?</p>
<p class="normal"><b>Peyton Jones：</b> GHC 有一些标志，可以让你以一种相当批量处理的方式说，“只是打印出各种东西。”</p><p class="normal"><b>Peyton Jones:</b> GHC has flags that let you say, in rather a batch-dumpy kind of way, “Just print out various things.”</p>
<p class="normal"><b>Seibel：</b>内置打印语句调试？</p><p class="normal"><b>Seibel:</b> Built-in print statement debugging?</p>
<p class="normal"><b>佩顿·琼斯：</b>是的。该结构与大多数编译器一样，这一事实对它有所帮助：它具有发生事件的管道的这种顶级结构。如果其中一次传球过程中出现问题，那可能会有点棘手。但我倾向于使用相当简单的调试技术。只需向我展示此遍之前和之后的程序即可。啊啊，我知道出了什么问题。或者有时我看不出出了什么问题，所以我可能会<code>printf</code>在周围散布一些 unsafe 来告诉我实际发生了什么。</p><p class="normal"><b>Peyton Jones:</b> Yes. And it's aided by the fact that the structure is like most compilers: it has this top-level structure of a pipeline of things that happen. If something's gone wrong in the middle of one of these passes, then that could be a bit trickier. But I tend to use rather unsophisticated debugging techniques. Just show me the program before and after this pass. Aaah, I see what's going wrong. Or sometimes I don't see what's going wrong so then I might scatter a few unsafe <code>printf</code>s around to show me what's actually going on.</p>
<p class="normal">Haskell 有多种调试环境——暑期学生 Pepe Iborra 在今年早些时候做了一个不错的调试环境，它现在带有 GHC，它是某种交互式调试器。我还没有使用太多。部分原因是我们这么久都没有了，因为你如何单步执行一个功能程序不太明显。</p><p class="normal">There are various debugging environments for Haskell—a summer student, Pepe Iborra, did a nice one earlier this year which now comes with GHC, which is an interactive debugger of some kind. Which I've not used very much yet. Partly because we haven't had one for so long, because it's less obvious how do you single-step a functional program.</p>
<p class="normal">一段时间以来，如何调试函数式程序一直是一个有趣的研究问题。有点尴尬的是我们不能直接勾选那个方框，但这使它成为一个有趣的研究问题。</p><p class="normal">It's been a kind of interesting research question of how you go about debugging functional programs for some time. It's a bit embarrassing that we can't tick that box in a straightforward way, but that makes it an interesting research problem.</p>
<p class="normal">这就是说我倾向于使用带有 unsafe<code>printf</code>的非常粗糙的调试技术的漫长方法。我对此并不感到自豪。但是很长一段时间我们都没有别的东西了。至少就 GHC 而言，我已经发展了一些机制，这意味着这是我完成任务的最短路径。</p><p class="normal">That was the long way around of saying that I tend to use terribly crude debugging techniques with unsafe <code>printf</code>s. And I'm not very proud of that. But for a long time we didn't have anything else. At least as far as GHC is concerned, I've evolved mechanisms that mean that's the shortest path to completion for me.</p>
<p class="normal"><b>Seibel：</b>这似乎是一个普遍的故事。如果有这么多人通过打印语句调试，这有点让你想知道编写更好的调试器的实用性。</p><p class="normal"><b>Seibel:</b> That seems to be a common story. It sort of makes you wonder about the utility of writing better debuggers if so many people get by with print statement debugging.</p>
<p class="normal"><b>Peyton Jones：</b>虽然有文化因素。在带有调试器的 .NET 平台上，人们已投入数十或数百人年<a id="OEBPS/Chapter07.html.page_269"></a>工程，我认为这是一种质的不同的体验。我认为调试器确实需要更多的工程周期才能正常工作。但是如果你把它们放进去，你确实会得到一些非常有用的东西。</p><p class="normal"><b>Peyton Jones:</b> There's a cultural thing though. On the .NET platform with debuggers that people have put tens or hundreds of man-years into <a></a>engineering, I think it's a qualitatively different experience. I think debuggers do require perhaps more engineering cycles to get to work well. But if you put them in, you do get something that is really quite remarkably more helpful.</p>
<p class="normal">也许您一直主要与之交谈的人更多地处于学术软件模式中。也可能是在少了复杂的调试环境的情况下长大的。我不想吸取任何一般教训。我当然不想贬低或淡化良好调试环境的重要性。特别是在这些相当复杂的生态系统中，那里有很多很多很多软件层。与具有 DOM 和 UML 层的完整 .NET 环境相比，GHC 是一个非常简单的系统，我不知道是什么样的 goop。现实世界变得如此黏糊糊，以至于更多的机械支持可能真的很重要。</p><p class="normal">Maybe the people that you've been mainly talking to are more in the academic software mold. And also perhaps have grown up with sophisticated debugging environments less. I wouldn't like to draw any general lessons. I certainly wouldn't wish to denigrate or downplay the importance of good debugging environments. Particularly in these rather complicated ecosystems where there are many, many, many layers of software. GHC is a very simple system compared to a full-on .NET environment with layers of DOMs and UMLs and I don't know what kind of goop. The real world gets so goopy that more mechanical support may well be really important.</p>
<p class="normal"><b>Seibel：</b>获得正确软件的另一种方法是使用形式化证明。您如何看待它有用的前景？</p><p class="normal"><b>Seibel:</b> Another approach to getting correct software is to use formal proofs. What do you think about the prospect of that being useful?</p>
<p class="normal"><b>Peyton Jones：</b>假设你声明你的目标是让所有的东西都有一个机器检查的正确性证明。这意味着什么甚至都不明显。机械地证明了什么？针对某些规范。那么你如何编写规范？现在这意味着成为程序所做的<i>一切的规范。</i>否则你就无法证明它做了它应该做的一切。所以你必须对它应该做的每件事都有一个正式的规范。那么现在——你打算如何编写该规范？您可能会用函数式语言编写它。在这种情况下，也许这就是您的程序。</p><p class="normal"><b>Peyton Jones:</b> Suppose you declare that your goal is for everything to have a machine-checked proof of correctness. It's not even obvious what that would mean. Mechanically proved against what? Against some specification. Well how do you write the specification? This is now meant to be a specification of <i>everything</i> the program does. Otherwise you wouldn't have proved that it does everything that it should do. So you must have a formal specification for everything it should do. Well now—how are you going to write that specification? You'll probably write it in a functional language. In which case, maybe that's your program.</p>
<p class="normal">我在这里说得有点快和松散，因为你可以用规范语言说一些你不能在程序中说的东西，比如，“函数的结果是<i>y</i>使得<i>y</i>的平方等于<i>x</i>。” 这是平方根函数的一个很好的规范，但它不是很可执行。尽管如此，我认为要尝试指定一个程序应该做的<i>所有</i>事情，你会得到本身非常复杂的规范，以至于你不再相信它们说的是你想要的。</p><p class="normal">I'm being a bit fast and loose here because you can say some things in specification languages that you can't say in programs like, “The result of the function is that <i>y</i> such that <i>y</i> squared equals <i>x</i>.” That's a good specification for a square-root function but it's not very executable. Nevertheless, I think to try to specify <i>all</i> that a program should do, you get specifications that are themselves so complicated that you're no longer confident that they say what you intended.</p>
<p class="normal">我认为在现实生活中更有成效的是写下您希望程序具有的一些<i>属性。</i>你想说，“这个阀门应该<a id="OEBPS/Chapter07.html.page_270"></a>切勿与该阀门同时关闭。这棵树应该总是平衡的。这个函数应该总是返回一个大于零的结果。” 这些都是小部分规范。它们不是完整的规格。它们只是您希望成真的事情。</p><p class="normal">I think much more productive for real life is to write down some <i>properties</i> that you'd like the program to have. You'd like to say, “This valve should <a></a>never be shut at the same time as that valve. This tree should always be balanced. This function should always return a result that's bigger than zero.” These are all little partial specifications. They're not complete specifications. They're just things that you would like to be true.</p>
<p class="normal">你怎么把这些写下来？嗯，函数式语言在这方面相当擅长。事实上，这正是您编写 QuickCheck 规范时发生的情况；你将属性记为 Haskell 函数。假设我们要检查它<code>reverse</code>是它自己的逆元——好吧，你可以将<code>checkreverse</code>A 的类型列表写成 bool。So <code>checkreverse</code>of <code>xs</code>is <code>reverse</code>of <code>reverse</code> <code>xs</code>equals<code>xs.</code>所以这是一个应该总是返回 true 的函数。这就是属性函数。但它只是用同一种语言编写的——所以很好。</p><p class="normal">How do you write those down? Well, functional languages are rather good at that. In fact this is exactly what happens when you write a QuickCheck specification; you write down properties as Haskell functions. Say we want to check that <code>reverse</code> is its own inverse—well, you might write <code>checkreverse</code> with type list of A to bool. So <code>checkreverse</code> of <code>xs</code> is <code>reverse</code> of <code>reverse</code> <code>xs</code> equals <code>xs.</code> So this is a function that should always return true. That's what a property function is. But it's just written in the same language—so that's nice.</p>
<p class="normal">现在您可能希望对此进行一些静态检查。这可能很难也可能很容易。但是，即使以正式的方式记录财产也是一个真正的帮助。您可以通过生成测试数据来测试它，这实际上正是 QuickCheck 所做的。</p><p class="normal">Now you might hope to do some static checking on this. It might be hard or easy. But even having the property written down in a formal way is a real help. You can test it by generating test data, which is, indeed, just what QuickCheck does.</p>
<p class="normal">因此，与其尝试写下程序的<i>所有</i>规格，我认为写下部分规格会更有成效。也许多个部分规范。然后通过测试、动态检查或静态检查来检查它们。你永远无法证明你的程序是正确的。您只是增加了对它的正确性的信心。我认为这就是任何人所做的一切。</p><p class="normal">So rather than trying to write down specifications for <i>all</i> that a program does I think it's much more productive to write down partial specifications. Perhaps multiple partial specifications. And then check them either by testing or by dynamic checks or by static checks. You never prove that your program is right. You just increase your confidence that it's right. And I think that's all that anybody ever does.</p>
<p class="normal"><b>Seibel：</b>所以你定义了很多属性，涵盖了你关心的事情。然后您可以选择确认这些属性实际上是静态的还是动态的，具体取决于实际可行的情况。因为我们可能不知道如何静态检查它们？</p><p class="normal"><b>Seibel:</b> So you define however many properties, covering the things you care about. And then you can choose to confirm that those properties actually hold either statically or dynamically, depending on what's actually feasible. Because we may not know how to statically check them all?</p>
<p class="normal"><b>佩顿·琼斯：</b>对。但在功能设置中，你有更好的机会。但是我们在证明这一点上仍然有些拖延。尽管如此，第一步是首先记下这些属性。</p><p class="normal"><b>Peyton Jones:</b> Right. But in a functional setting, you have a better chance. But we've still been dragging our feet a bit about demonstrating that. Nevertheless—step one is to write down these properties in the first place.</p>
<p class="normal">但我认为最重要的是摆脱关于规范的这种单一的、全有或全无的故事，并说你可以对部分规范进行有用的静态和动态测试。这些将增加您对程序正确性的信心，而这正是您所希望的。<a id="OEBPS/Chapter07.html.page_271"></a>即使是据称完整的规格也遗漏了——你知道，它必须在 0.1 秒内工作。或者必须适合 10KB 的内存。资源的东西往往不包括在内。或计时的事情。有无穷无尽的小东西意味着该程序实际上可能无法按预期运行，即使它符合其正式规范。所以我认为我们是在自欺欺人地说我们实际上已经证明了整件事是完全正确的。最好的办法是承认这一点，并说我们正在提高信心——这就是我们正在做的事情。这可以从小事做起——你可能只用 5% 的努力就提高了 75% 的信心。那会很好。</p><p class="normal">But I think the big thing is to get away from this monolithic, all-or-nothing story about specification and to say that you can do useful static and dynamic tests on partial specifications. These will increase your confidence in the correctness of your program and that is all you can possibly hope for. <a></a>Even the allegedly complete specifications miss out—you know, it has to work in .1 of a second. Or must fit in 10KB of memory. Resource things are often not covered. Or timing things. There's endless little stuff that means the program might actually not function as desired even though it meets its formal specification. So I think we're kidding ourselves to say we've actually proved the whole thing is completely right. Best thing to do is to acknowledge that and say we're improving our confidence—that's what we're doing. And that can start quite modestly—you might have improved your confidence by 75 percent with only 5 percent of the effort. That'd be good.</p>
<p class="normal"><b>Seibel：</b>让我们稍微谈谈并发性。Guy Steele 让我问你：“STM 会拯救世界吗？”</p><p class="normal"><b>Seibel:</b> Let's talk about concurrency a little bit. Guy Steele asked me to ask you: “Is STM going to save the world?”</p>
<p class="normal"><b>佩顿·琼斯：</b>哦，不。STM 不会靠自己拯救世界。并发和并行编程通常是一个多方面的野兽，我认为它不会被一颗子弹杀死。在并发方面，我是一个多元化主义者。</p><p class="normal"><b>Peyton Jones:</b> Oh, no. STM is not going to save the world on its own. Concurrency, and parallel programming generally, is a many-faceted beast and I don't think it will be slain by a single bullet. I'm a diversifist when it comes to concurrency.</p>
<p class="normal">人们很想说，“使用一种编程范式来编写并发程序并很好地实现它，就是这样；” 人们应该只学习如何使用该范例编写并发程序。但我就是不相信。我认为对于某些编程风格，您可能希望使用消息传递。对于其他人，您可能想使用 STM。对于其他人来说，数据并行性要好得多。程序员将需要努力解决不止一种方法。</p><p class="normal">It's tempting to say, “Use one programming paradigm for writing concurrent programs and implement it really well and that's it;” people should just learn how to write concurrent programs using that paradigm. But I just don't believe it. I think for some styles of programming you might want to use message passing. For others you might want to use STM. For others data parallelism is much better. The programmer is going to need to grapple with more than one way to do it.</p>
<p class="normal">但是如果你问我，STM 比锁和条件变量好吗？现在你在比较同类。是的。我认为它完全支配了锁和条件变量。所以忘记锁和条件变量吧。对于多程序计数器、多线程、共享内存多核上的共享内存：STM。但这是编写并发程序的唯一方法吗？绝对不。</p><p class="normal">But if you ask me, is STM better than locks and condition variables? Now you're comparing like with like. Yes. I think it completely dominates locks and condition variables. So just forget locks and condition variables. For multiple program counters, multiple threads, diddling on shared memory on a shared-memory multicore: STM. But is that the only way to write concurrent programs? Absolutely not.</p>
<p class="normal"><b>Seibel：</b>我听到的对 STM 的批评是，当它真正落到实处时，乐观并发将不会允许像您希望的那样多的并发。我认为声明是你可以很容易地进入这些你真的没有取得进步的情况。</p><p class="normal"><b>Seibel:</b> A criticism I've heard of STM was that when it really gets down to it, optimistic concurrency won't allow as much concurrency as you hope. I think the claim was you can fairly easily get in these situations where you're really not making progress.</p>
<p class="normal"><a id="OEBPS/Chapter07.html.page_272"></a><b>佩顿琼斯：</b>你确实需要担心饥饿。我最喜欢的例子是一个大事务一直无法提交，因为有一个小事务进入并首先提交。举个例子，图书管理员正在重组他们的图书馆。他们开始乐观地重组他们的图书馆。他们已经完成了三分之二，一个本科生走过来借了一本书。好吧，他成功地提交了他的事务，因为库重组还没有提交。图书管理员走到尽头，发现，啊，我看到了不一致的内存视图，因为在我重组图书馆时图书馆发生了变化，所以我只能回去重新开始。</p><p class="normal"><a></a><b>Peyton Jones:</b> You do have to worry about starvation. My favorite example here is of one big transaction that keeps failing to commit because a little transaction gets in there and commits first. So an example would be a librarian who's reorganizing their library. They start optimistically reorganizing their library. And they've got two-thirds of the way through and an undergraduate comes along and borrows a book. Well, he commits his transaction successfully because the library reorganization hasn't committed. The librarian gets to the end and discovers, ah, I saw an inconsistent view of memory because the library changed while I was reorganizing it so I just have to go back and start again.</p>
<p class="normal"><b>Seibel：</b>在锁和条件变量程序中，它可能会走另一条路——图书管理员会锁住图书馆，在图书馆完全重组之前没有人可以借出书籍。所以你可能会看到这个问题并立即说，“在我们完成之前我们不能锁定图书馆，”不允许签出，所以我们必须想出一些更复杂的锁定方案。</p><p class="normal"><b>Seibel:</b> In a locks-and-condition-variables program it would probably go the other way—the librarian would lock the library and nobody could check out books until it's completely reorganized. So you would probably look at this problem and immediately say, “We can't lock the library until we're done,” disallowing checkouts so we have to come up with some hairier locking scheme.</p>
<p class="normal"><b>佩顿·琼斯：</b>对。做一个小的子图书馆之类的——把经常借的书放在那里，这样本科生就可以借了，而你锁定主图书馆并重新组织它之类的。所以现在你必须考虑一个特定于应用程序的策略，现在你必须以某种方式表达它。好吧，在这两种情况下都会出现同样的问题——您需要一个特定于应用程序的策略，这样您就可以重新组织图书馆，尽管您不想阻止各种借阅。一旦你认真思考了你希望如何去做，现在你必须表达出来。表达它的媒介是什么？STM 是一个明显的胜利。它只是比表达并发程序的锁和条件变量要好得多。</p><p class="normal"><b>Peyton Jones:</b> Right. Make a little sub-library or something—put the commonly borrowed books out there so undergraduates can borrow them while you lock the main library and reorganize it or something. So now you've got to think of an application-specific strategy and now you've got to express it in some way. Well, the same problem arises in both cases—you need an application-specific strategy so you can reorganize the library despite not wanting to block out all sorts of borrowing. Once you've done the hard thinking about how you wish to do it, now you've got to express that. What is the medium in which to express it? STM is a clear win. It's just much better than locks and condition variables for expressing concurrent programs.</p>
<p class="normal"><b>Seibel：</b>如果我什至不想考虑有人进来寻找第 21 本书最需要的书并被阻止的可能性怎么办？在现实世界中，您可以想象，当有人借出一本书时，我们会交换该书的代理，然后图书管理员会重新组织该书，每当一本书回来时，我们都会将其放回代理现在所在的位置。但是您正在修改图书馆，在 STM 世界中，这似乎会导致图书馆员不得不重试他的整个交易。</p><p class="normal"><b>Seibel:</b> What if I don't even want to allow for the possibility that someone comes in and looks for the 21st most-requested book and gets blocked? In the physical world you can imagine that when someone checks out a book we swap in a proxy for the book that the librarian then reorganizes and whenever a book comes back we put it back wherever the proxy is now. But you are modifying the library which seems, in an STM world, like it would cause the librarian to have to retry his whole transaction.</p>
<p class="normal"><a id="OEBPS/Chapter07.html.page_273"></a><b>Peyton Jones：</b>但有些东西是不变的——书上的钥匙保证不会以某种方式改变，对吧？所以有很多方法可以做到这一点。一种是您可以说，“当您用代理替换它时，您所做的就是根本不修改库”——这没有改变。你所做的就是修改这本书本身。而且您不修改它的键字段——您只修改它当前所在的值字段。现在可以在书在其他地方时重新组织索引。这很酷——而且你可以完美自然地表达出来。</p><p class="normal"><a></a><b>Peyton Jones:</b> But there's something that stayed the same—the key on the book is guaranteed not to change somehow, right? So there's a number of ways you could do this. One is you could say, “What you do when you replace it with a proxy is you don't modify the library at all”—that's unchanged. What you do is you modify the book itself. And you don't modify its key field—you only modify its value field, where it's currently living. Now the index can be reorganized while the book is somewhere else. That's cool—and you can express that perfectly naturally.</p>
<p class="normal">使用 STM，最后图书馆员查看他已读取的所有内存位置，看看它们现在是否包含与他读取时相同的值。所以他阅读过的位置将包括这本书的关键领域，因为这决定了他把它放在哪里。但是他没有看过书的内容。所以他会说，“啊，这本书——这个关键字段是否仍然包含 73；哦，是的。</p><p class="normal">With STM, at the end the librarian looks through all the memory locations that he has read and sees if they contain now the same values that they did when he read them. So the locations that he has read will include the key field of the book because that determined where he put it. But he hasn't read the contents of the book. So he'll say, “Ah, this book—does this key field still contain 73; oh, yes it does.”</p>
<p class="normal">但我不想将饥饿问题最小化，因为它有点阴险。您需要良好的分析工具来指出未能提交的事务，因为它们不断受到影响，这样您就可以得到一些反馈，而不是程序只是默默地不做太多事情。基于锁的程序也是如此。当那些沙漏出现时，我讨厌它。</p><p class="normal">But I don't want to minimize the problem of starvation because it's a bit insidious. You need good profiling tools that point you at transactions that are failing to commit because they keep getting bumped so that, rather than the program just silently not doing very much, you get some feedback about it. The same is true of a lock-based program. I hate it when those hourglasses appear.</p>
<p class="normal"><b>Seibel：</b>我想在基于锁定的程序中，我们刚刚学会了尝试尽可能短地保持锁定，因为这将使我们的争用最少。</p><p class="normal"><b>Seibel:</b> I guess in locked-based programs we've just learned to try hold locks for as short a duration as possible since that will give us the least contention.</p>
<p class="normal"><b>佩顿·琼斯：</b>对。但是，当然，编程就更难了。更细粒度的锁定很难做到正确。我认为这是 STM 的巨大胜利之一，它为您提供了非常细粒度锁定的细粒度以及非常简单的推理原则。</p><p class="normal"><b>Peyton Jones:</b> Right. But, of course, then it's harder to program. Finer-grained locking is tricky to get right. I think this is one of the huge wins of STM, is it gives you the fine granularity of very fine-grained locking along with very simple reasoning principles.</p>
<p class="normal">这是STM给你的一个推理原则，锁绝对不会。我将建立我的顶级不变量——我有一堆银行账户，所有银行账户中的总金额加在一起是<i>N</i>。钱在银行账户之间流动——仅此而已。所以这是我的不变量。任何交易在开始时都假设不变，并在结束时恢复它。您如何推断它会起作用？我们看任何一笔交易，上面写着：“从那笔交易中取出三笔，然后将三笔放入那笔交易。” 好的，<a id="OEBPS/Chapter07.html.page_274"></a>保持不变。我的推理是如何完成的？纯顺序推理。一旦我描述了一些顶级不变量，我就可以完全按顺序分别对每个事务进行推理。</p><p class="normal">Here's a reasoning principle that STM gives you that locks absolutely do not. I'll establish my top-level invariants—I've got a bunch of bank accounts, the total sum of money in all the bank accounts added together is <i>N</i>. Money moves between bank accounts—that's all. So there's my invariant. Any transaction assumes that invariant at the beginning and restores it at the end. How do you reason that it does? We look at any one transaction that says, “Take three out of that one and put three into that one.” Good, <a></a>invariant maintained. How is my reasoning in that done? Purely sequential reasoning. Once I've described some top-level invariants, I can reason completely sequentially about each transaction separately.</p>
<p class="normal"><b>Seibel：</b>因为你有事务隔离。</p><p class="normal"><b>Seibel:</b> Because you have transaction isolation.</p>
<p class="normal"><b>佩顿琼斯：</b>因为他们被隔离了。所以这确实是一个非常强大的推理原则。因为它说尽管程序是并发的，但您可以使用关于命令式代码的顺序推理。您必须确定那些顶级不变量是什么，但这对您的灵魂也有好处。因为那样你就知道你要维护的是什么东西。如果您在事务中间抛出异常，那也很酷 — 这不会破坏不变量，因为事务被放弃而没有效果。我觉得这太棒了。那么关于性能问题的推理是不同的层次——你已经保证了某种正确性；现在您想确保没有任何性能漏洞。那些更难得到——目前我不知道</p><p class="normal"><b>Peyton Jones:</b> Because they are put in isolation. So that's really rather a powerful reasoning principle. Because it says you can use your sequential reasoning about imperative code despite the fact that the program's concurrent. You've got to establish what those top-level invariants are, but that's good for your soul, too. Because then you know what things you are trying to maintain. If you get an exception thrown in the middle of a transaction, that's cool, too—that can't destroy the invariants because the transaction is abandoned without effect. I think this is fabulous. Then reasoning about performance issues is a different level—you've guaranteed a certain sort of correctness; now you want to make sure you haven't got any performance holes. Those are harder to get at—at the moment I don't know anything better than profiling and directed feedback tools for doing that.</p>
<p class="normal"><b>Seibel：</b>令我印象深刻的是，虽然乐观并发已不时用于持久性数据库，但与基于锁的并发相比，它从未真正立足于此。</p><p class="normal"><b>Seibel:</b> It strikes me that while optimistic concurrency has been used from time to time in persistent databases, it's never really gotten a foothold there compared to lock-based concurrency.</p>
<p class="normal"><b>Peyton Jones：</b>当然，STM 可以通过各种方式实现——乐观并发只是其中之一。你可以边走边锁，这更像是一种悲观的并发模型。</p><p class="normal"><b>Peyton Jones:</b> Of course STM can be implemented in all sorts of ways—optimistic concurrency is only one of them. You can lock as you go, which is more like a pessimistic concurrency model.</p>
<p class="normal"><b>Seibel：</b>但是锁管理器是数据库中最毛茸茸的部分也是有原因的。</p><p class="normal"><b>Seibel:</b> But there's also a reason that lock managers are the hairiest part of databases.</p>
<p class="normal"><b>佩顿·琼斯：</b>对。所以关于 STM 的事情是你要确保一个人或一个团队开始实施 STM，而其他人都可以使用它。你可以付给他们很多钱，然后把他们关在一个小黑屋里一年，以确保他们做得很好。</p><p class="normal"><b>Peyton Jones:</b> Right. So the thing about STM is you want to make sure that one person, or one team, gets to implement STM and everybody else gets to use it. You can pay them a lot of money and shut them in a small dark room for a year to try to make sure they do a really good job.</p>
<p class="normal">但是，每个人都可以通过一个非常简单的界面使用该作品。这就是我认为它的好处。我想避免的是每个人的头脑中都有那种水平的专业知识。我在一次演讲中使用的例子<a id="OEBPS/Chapter07.html.page_275"></a>昨天——这来自 Maurice Herlihy——是一个双端队列：插入和删除元素。</p><p class="normal">But then that work is usable by everybody through a very simple interface. That's what I think is nice about it. What I want to avoid is having that level of expertise in everybody's head. The example that I used at a talk I gave <a></a>yesterday—this comes from Maurice Herlihy—is a double-ended queue: insert and delete elements.</p>
<p class="normal">双端队列的顺序实现是本科一年级的编程问题。对于每个节点一个锁的并发实现，这是一个研究论文问题。这一步太大了。如此困难的事情是荒谬的。对于事务性内存，这又是一个本科生问题。您只需将插入和删除操作包装成“原子”——大功告成。我认为这太棒了。这是质的区别。现在实施 STM 的人，他们必须确保他们以原子方式将一堆更改作为一个提交到内存中。这并不容易，只需比较和交换即可。这是可以做到的，但你必须小心。</p><p class="normal">A sequential implementation of a double-ended queue is a first-year undergraduate programming problem. For a concurrent implementation with a lock per node, it's a research paper problem. That is too big a step. It's absurd for something to be so hard. With transactional memory it's an undergraduate problem again. You simply wrap “atomic” around the insert and delete operations—job done. That's amazing, I think. It's a qualitative difference. Now the people who implement the STM, they'd have to make sure they atomically commit a bunch of changes to memory as one. That's not easy to do, just with compare and swaps. It can be done but you have to be careful about it.</p>
<p class="normal">然后，如果存在与饥饿有关的性能问题，那么您可能需要做一些应用程序级别的思考，以考虑如何避免这种情况。但是随后您再次使用 STM 来表达您的应用级思维的结果。我确实认为对于那种程序来说，这是一个飞跃。</p><p class="normal">And then if there are performance problems to do with starvation then you may need to do some application-level thinking about how to avoid that. But then you express the results of your application-level thinking, again using STM. I do think for that kind of program it's a leap forward.</p>
<p class="normal">我还想提一件事——这可以追溯到函数式编程。当然，STM 与函数式编程完全没有直接关系。这实际上是关于改变共享状态——这听起来不太实用。</p><p class="normal">There was one other thing I wanted to mention—this goes back to functional programming. STM, of course, has nothing directly to do with functional programming at all. It's really about mutating shared state—that doesn't sound very functional.</p>
<p class="normal">但事情是这样的，我去听了蒂姆·哈里斯 (Tim Harris) 关于 Java 中的 STM 的演讲。我以前从未听说过 STM；我刚好去听他的谈话。他描述的是一个 STM，其中他有“原子”但实际上没有其他东西。您可以实现这些原子事务。</p><p class="normal">But what happened is this, I went to a talk given by Tim Harris about STM in Java. I'd never heard about STM before; I just happened to go to his talk. He was describing an STM in which he had “atomic” but really not much else. You could implement these atomic transactions.</p>
<p class="normal">我说，“哇，这看起来真的很整洁。啊，所以你需要记录对内存的每一个副作用。每个加载和存储指令。天哪，Java 中有很多这样的东西。” 但在 Haskell 中几乎没有，因为它们出现在这种单子设置中。所以 Haskell 中的加载和存储是非常明确的——程序员认为它们是一件大事。</p><p class="normal">I said, “Wow, that seems really neat. Ah, so you need to log every side effect on memory. Every load and store instruction. Gosh, well there are a lot of those in Java.” But in Haskell there are practically none because they occur in this monadic setting. So loads and stores in Haskell are extremely explicit—programmers think of them as a big deal.</p>
<p class="normal">所以我想，“哦，我们应该尝试在 Haskell 中复制这种原子内存的东西，因为拥有它会是一个非常酷的特性。” 然后我们就开始了——我和蒂姆谈了如何做到这一点。不久，因为那种框架<a id="OEBPS/Chapter07.html.page_276"></a>我们拥有——我们拥有的这种纯粹的、更简洁的框架——我们发明了<code>retry</code>并且<code>orElse</code>…… <code>Retry</code>这种机制允许您在事务中进行阻塞，并且<code>orElse</code>是允许您在事务中进行选择的位。这些都不是他或他的同事在为 Java 开发事务内存时想到的，因为他们的上下文的其余部分相当复杂。</p><p class="normal">So I thought, “Oh, we should just try replicating this atomic memory stuff in Haskell because it would be a very cool feature to have.” And off we went—I talked to Tim about how to do this. Before long, because of the kind of framework <a></a>that we had—this kind of pure, rather sparer framework that we had—we'd invented <code>retry</code> and <code>orElse</code>. <code>Retry</code> is this mechanism that allows you to do blocking within a transaction and <code>orElse</code> is the bit that allows you to do choice within a transaction. Neither of these are things that had occurred to him or his colleagues in developing transactional memory for Java because the rest of their context was rather more complicated.</p>
<p class="normal">所以他们并没有真正考虑过阻止。或者，也许他们只是假设你进行阻塞的方式是你说，原子地，“只有当这个谓词成立时才运行这个事务。” 但这是非常不合逻辑的——假设您想从一个银行账户中取出一些东西并将其存入另一个银行账户，那么交易可以在什么条件下进行？答案：嗯，如果第一个银行账户中有足够的钱并且第二个银行账户中有足够的空间——假设它们在两端都是有限的。所以这是一个相当复杂的条件。如果涉及第三个银行账户，事情会变得更加复杂。它是非常非组合的——你必须查看方法内部并将它们的所有先决条件拉到前面。</p><p class="normal">So they hadn't really thought much about blocking. Or maybe they just assumed that the way you do blocking was you say, atomically, “Only run this transaction when this predicate holds.” But that's very noncompositional—supposing you wanted to get something out of one bank account and put it in another, well, what's the condition that the transaction can run under? Answer: well, if there's enough money in the first bank account and there's enough space in the second—let's say that they're limited at both ends. So that's a rather complicated condition to figure out. And it gets even more complicated if there's a third bank account involved. It's very noncompositional—you have to look inside the methods and pull all their preconditions out to the front.</p>
<p class="normal">这就是他所拥有的，它对小程序来说工作得很好，但显然不是很令人满意。所以在 Haskell 上下文中，我们想出了这个<code>retry</code>，<code>orElse</code>我们已经将其移植回主流命令式上下文中，他们也正在忙着<code>retry</code>做<code>orElse</code>。那太棒了。</p><p class="normal">That's what he had and it kind of worked fine for small programs but clearly wasn't very satisfactory. So in a Haskell context we came up with this <code>retry</code>, <code>orElse</code> thing which we've since transplanted back into the mainstream imperative context and they're busy doing <code>retry</code> and <code>orElse</code> as well. That's great.</p>
<p class="normal"><b>Seibel：</b>所以 Haskell 并没有什么内在的东西可以实现这个概念？就凭你能想到？</p><p class="normal"><b>Seibel:</b> So there's nothing actually inherent about Haskell that enabled that concept? It was just that you were able to think of it?</p>
<p class="normal"><b>佩顿·琼斯：</b>没错。基本上，废话少了，所以这个很酷的想法在更高的浮雕中脱颖而出。更令人厌恶的是，没有办法在不失去抽象的情况下进行阻塞。这就是导致我们<code>retry</code>和<code>orElse</code>. 我认为函数式编程的一个真正好的地方，或者它发挥的作用，是作为一种实验室来检查野兽。然后想法可以反馈。这个 STM 是一个特别明显的例子，因为在两个方向上都有一个过渡。这里有一个实际上关闭的循环，我认为这很可爱。</p><p class="normal"><b>Peyton Jones:</b> That's right. There was less crap, basically, so the cool idea stood out in higher relief. It became more disgusting that there was no way to do blocking without losing the abstraction. That's what led us to <code>retry</code> and <code>orElse</code>. I think a really good place for functional programming to be, or a role for it to play, is as a kind of laboratory in which to examine the beast. And then ideas can feed back. And this STM was a particularly clear example because there was a transition in both directions. Here there was a loop that actually got closed, which I thought was lovely.</p>
<p class="normal"><b>Seibel：</b>你的程序员书籍清单是什么？</p><p class="normal"><b>Seibel:</b> What's your desert-island list of books for programmers?</p>
<p class="normal"><a id="OEBPS/Chapter07.html.page_277"></a><b>Peyton Jones：</b>嗯，您绝对应该阅读 Jon Bentley 的<i>Programming Pearls</i>。说到珍珠，Brian Hayes 在这本书<i>Beautiful Code</i>中有一个可爱的章节，标题为“为‘The Book’编写程序”，我认为他所说的“The Book”是指一个将拥有永恒之美的程序。你有两个点和第三个点，你必须找到这个第三点在两点之间的线的哪一侧。并且有几种解决方案效果不佳。但是有一个非常简单的解决方案可以正确地做到这一点。</p><p class="normal"><a></a><b>Peyton Jones:</b> Well, you should definitely read Jon Bentley's <i>Programming Pearls</i>. Speaking of pearls, Brian Hayes has a lovely chapter in this book <i>Beautiful Code</i> entitled, “Writing Programs for ‘The Book’” where I think by “The Book” he means a program that will have eternal beauty. You've got two points and a third point and you have to find which side of the line between the two points this third point is on. And several solutions don't work very well. But then there's a very simple solution that just does it right.</p>
<p class="normal">当然是 Don Knuth 的系列<i>计算机程序设计艺术</i>。我不认为这是我直接读过的任何东西；这不是那种书。我当然在一个阶段提到了很多。Chris Okasaki 的书<i>Purely Functional Data Structures</i>。极好的。这就像 Arthur Norman 的课程只展开了一整本书。它是关于如何在没有任何副作用但具有良好的复杂性界限的情况下执行队列、查找表和堆。真的，非常好的书。每个人都应该阅读这篇文章。它也很短且易于访问。<i>计算机程序的结构和解释</i>。阿贝尔森和萨斯曼。我喜欢那个。并<i>继续编译</i>, Andrew Appel 关于如何使用连续传递样式编译函数式程序的书。也很精彩。</p><p class="normal">Of course, Don Knuth's series, <i>The Art of Computer Programming</i>. I don't think it was ever anything I read straight through; it's not that kind of book. I certainly referred to it a lot at one stage. Chris Okasaki's book <i>Purely Functional Data Structures</i>. Fantastic. It's like Arthur Norman's course only spread out to a whole book. It's about how you can do queues and lookup tables and heaps without any side effects but with good complexity bounds. Really, really nice book. Everyone should read this. It's also quite short and accessible as well. <i>Structure and Interpretation of Computer Programs</i>. Abelson and Sussman. I loved that. And <i>Compiling with Continuations</i>, Andrew Appel's book about how to compile a functional program using continuation passing style. Also wonderful.</p>
<p class="normal">对我很重要但我已经很久没有读过的书： Dijkstra<i>的 A Discipline of Programming</i>。Dijkstra 非常注重编写漂亮的程序。这些是完全必要的，但它们具有“Hoare 属性”，而不是没有明显的错误，它们显然没有错误。它给出了非常好的、优雅的推理来推理它。那本书让我第一次以一种非常无懈可击的方式对程序进行推理。当时给我留下深刻印象的另一本书是 Per Brinch Hansen 关于编写并发操作系统的书。我读了很多遍。</p><p class="normal">Books that were important to me but I haven't read for a long time: <i>A Discipline of Programming</i> by Dijkstra. Dijkstra is very careful about writing beautiful programs. These ones are completely imperative but they have the “Hoare property” of rather than having no obvious bugs they obviously have no bugs. And it gives very nice, elegant reasoning to reason about it. That's a book that introduced me for the first time to reasoning about programs in a pretty watertight way. Another book that at the time made a huge impression on me was Per Brinch Hansen's book about writing concurrent operating systems. I read it lots of times.</p>
<p class="normal"><b>Seibel：</b>你还经常编程吗？</p><p class="normal"><b>Seibel:</b> Do you still program a lot?</p>
<p class="normal"><b>佩顿琼斯：</b>哦，是的。我每天写一些代码。这实际上不是每天，但这是我的口头禅。我认为存在这种可怕的危险，即擅长任何事情的人都会得到提升或变得更重要，直到他们不再做他们擅长的事情为止。因此，我喜欢在这里工作和从事研究工作的原因之一是，我仍然可以使用我自 1990 年以来一直在研究的编译器。<a id="OEBPS/Chapter07.html.page_278"></a>这是一段很大的代码，其中有很大一部分我真的是最了解它的人。</p><p class="normal"><b>Peyton Jones:</b> Oh yes. I write some code every day. It's not actually every day, but that's my mantra. I think there's this horrible danger that people who are any good at anything get promoted or become more important until they don't get to do the thing they're any good at anymore. So one of the things I like about working here and working in research generally is that I can still work on the compiler that I've been working on since 1990. <a></a>It's a big piece of code and there are large chunks of it that I'm really the person who knows most about it.</p>
<p class="normal">我要写多少代码？有些日子我整天都在编程，实际上是盯着代码看。其他日子，没有。所以也许，平均而言，每天几个小时，当然。编程就是这么有趣。为什么你不想这样做？此外，它让您保持诚实——使用您自己的编译器并使用您提倡的语言是一个很好的现实检查。</p><p class="normal">How much code do I write? Some days I spend the whole day programming, actually staring at code. Other days, none. So maybe, on average, a couple hours a day, certainly. Programming is such fun. Why would you ever want not to do it? Furthermore it keeps you honest—it's a good reality check to use your own compiler and to use the language that you advocate as well.</p>
<p class="normal"><b>Seibel：</b>你仍然像刚开始时一样喜欢编程吗？</p><p class="normal"><b>Seibel:</b> And you still enjoy programming just as much as when you started?</p>
<p class="normal"><b>佩顿琼斯：</b>哦，是的，是的。这是最好玩的事情。我想大多数程序员都有这样一种感觉，“一定有一个好的方法来做这件事”。从事研究工作的好处之一是，不再有经理站在我旁边说，“这周必须完成——完成它，”我可以坐下来看着一些东西说，“必须有一个这样做的正确方法。”</p><p class="normal"><b>Peyton Jones:</b> Oh, yes, yes. That's the most fun thing. I think most programmers have the feeling that “there must be a good way to do this.” One of the nice things about working in research is that instead of some manager standing over me saying, “This has to be done this week—just get it done,” I can sit and look at something and say, “There must be a right way to do this.”</p>
<p class="normal">所以我花了很多时间重构和移动接口并编写新类型，甚至只是重写整个 blob 以尝试使其正确。GHC 相当大——按照工业标准它不算大；按照函数式编程标准，它很大——大约有 80,000 行 Haskell，也许更多。而且它很长寿——现在已经 15 岁了。它仍在积极开发的事实表明块已被重写。没有不可触及的位。因此，看着一些东西并思考“做这件事的正确方法是什么？”既具有挑战性又很有趣。通常我会在某件事上拖延数周，但我就是想不出一个好的方法来做这件事。但这很诱人。因为必须有一个好的方法。</p><p class="normal">So I spend a lot of time refactoring and moving interfaces around and writing new types or even just rewriting a whole blob to try to make it right. GHC is pretty large—it's not large by industrial standards; it's large by functional programming standards—it's about 80,000 lines of Haskell, maybe a bit more. And it's long-lived—it's 15 years old now. The fact that it's still actively developed is indicative that chunks have got rewritten. There are no untouchable bits. So it's both challenging and good fun to look at something and think, “What is the right way to do this?” And often I'll hold off for weeks on something but I just can't think of a nice way to do it. But that's tantalizing. Because there has to be a nice way.</p>
<p class="normal"><b>Seibel：</b>在那几个星期里，发生了什么？</p><p class="normal"><b>Seibel:</b> In those weeks, what happens?</p>
<p class="normal"><b>Peyton Jones：</b>哦，我在心里想着这件事。有时我会尝试一下——我有点跑上山坡。然后我记得为什么它如此复杂，然后通常会发生一些其他的置换活动。所以有时我跑上这座山好几次。有时我在后台思考它。有时我会想，“好吧，时间到了——现在必须做点什么了。” 也许它并不像它应该的那样美丽。</p><p class="normal"><b>Peyton Jones:</b> Oh, I'm thinking about it in the back of my mind. And sometimes I'll have a go at it—I sort of run up the hill. And then I remember why it was so complicated and then usually some other displacement activity takes place. So sometimes I run up this hill several times. Sometimes I'm thinking about it in the background. And sometimes I think, “Well, time's up—just got to do something now.” And maybe it's not quite as beautiful as it could be.</p>
<p class="normal"><a id="OEBPS/Chapter07.html.page_279"></a><b>Seibel：</b>是不是那种你早上醒来然后说，“啊，我明白了！”的事情。还是您决定再试一次，这次您到达了山顶？</p><p class="normal"><a></a><b>Seibel:</b> Is it the kind of thing that you wake up in the morning and you say, “Ah, I've got it!” Or is it that you decide to take another run at it and this time you get to the top of the hill?</p>
<p class="normal"><b>佩顿·琼斯：</b>更像是那样。我很少在早上有一种令人眼花缭乱的洞察力。作为研究人员发生的另一件事是你有机会反思你所做的事情并将其写下来。因此，如果发生了一些有趣的事情，我常常会尝试写一篇关于它的论文。所以这方面的一个例子是有一篇名为“GHC Inliner 的秘密”的论文，它实际上是一篇非常面向实现的论文，它描述了我们为 GHC 内部的特定部分开发的一些实现技术，我们认为这些技术可能可以重用其他。作为一名学者，你有机会从代码中抽象出来，第四次，你终于踢出了一个感觉良好的形状，然后写下来，这样其他人就可以重用同样的技术。</p><p class="normal"><b>Peyton Jones:</b> It's more like that. It's seldom that I just having a blinding insight in the morning. Another thing that happens as a researcher is you have the opportunity to reflect on what you've done and write it up. So quite often if something interesting has happened I try to write a paper about it. So an example of that is there's a paper called “The Secrets of the GHC Inliner,” which is really a very implementation-oriented paper that describes some implementation techniques that we developed for a particular part of GHC's innards which we thought might be reusable for others. The chance that you have as an academic is to abstract from the code that, the fourth time around, you've finally kicked into a shape that feels good, and write about it so other people can reuse that same technique.</p>
<p class="normal"><b>Seibel：</b>编程对你来说是什么？您认为自己是科学家、工程师还是工匠？或者完全是别的东西？</p><p class="normal"><b>Seibel:</b> What is programming to you? Do you think of yourself as a scientist or an engineer or a craftsman? Or something else entirely?</p>
<p class="normal"><b>Peyton Jones：</b>你读过 Fred Brooks 关于这个的论文吗，那篇叫做“作为工具匠的计算机科学家”？我最近重读了它。这是很不错的。我认为记住我们关心的是构建事物是件好事。我认为这就是编程如此有趣的原因。</p><p class="normal"><b>Peyton Jones:</b> Have you read Fred Brooks's paper about this, the one called, “The Computer Scientist as Toolsmith”? I reread it recently. It's very nice. I think it's good to remember that we're concerned with building things. I think that's why programming is so interesting.</p>
<p class="normal">与此同时，我非常热衷于尝试提取具有持久价值的<i>原则</i>。我有一篇关于如何写好论文或进行良好的研究演讲的论文，其中一个高阶位是，不要描述工件。工件是一个想法的实现。你试图将可重复使用的大脑转移到听众的脑海中，这个想法是什么？有一些对他们有用的东西。我认为，从具体的工件中抽象出可重用的想法是学术界的工作。从发现规律的意义上说，这仍然不是科学。但它是一种从现实生活的泥潭中抽象出来的可重复使用的思想材料，我认为这是非常重要的。</p><p class="normal">At the same time I'm really keen on trying to extract <i>principles</i> of enduring value. I have a paper about how to write a good paper or give a good research talk and one of the high-order bits is, don't describe an artifact. An artifact is an implementation of an idea. What is the idea, the reusable brain-thing that you're trying to transfer into the minds of your listeners? There's something that's useful to them. It's the business of academics, I think, to abstract reusable ideas from concrete artifacts. Now that's still not science in the sense of discovering laws. But it is a kind of abstraction into reusable thought-stuff out of the morass of real life that I think is very important.</p>
<p class="normal"><b>Seibel：</b>那么工程与工艺呢？我们是否应该期望像那些建造桥梁的人一样，在大多数情况下，桥梁不会倒塌？或者我们真的更像那些制作陶器的人——除了陶器是<a id="OEBPS/Chapter07.html.page_280"></a>只是难以置信的复杂——你所能做的就是让自己成为某人的学徒，并向他们学习他们是如何做的？</p><p class="normal"><b>Seibel:</b> So what about engineering vs. craft. Should we expect to be like the guys who build bridges where, for the most part, bridges don't fall down? Or are we really more like the guys making pottery—except the pottery is <a></a>just incredibly complex—where all you can do is apprentice yourself to someone and learn from them how they do it?</p>
<p class="normal"><b>Peyton Jones：</b>这是一种错误的二分法。这不是真正的非此即彼的选择。即使对于专业的软件工程师和开发人员来说，一件困难的事情是发自内心地理解我们工作的工件的大小。您正通过一个 1 平方英尺的舷窗观看帝国大厦，因此很难真正感受到您所看到的结构有多么巨大。以及它是如何相互关联的。</p><p class="normal"><b>Peyton Jones:</b> It's a bit of a false dichotomy. It's not truly an either-or choice. One thing that is hard, even for professional software engineers and developers, is to viscerally grok the size of the artifacts on which we work. You're looking at the Empire State Building through a 1-foot-square porthole, so it's difficult to have a real feel for how gigantic the structure you're looking at is. And how it's interconnected.</p>
<p class="normal">GHC 有多大？我对此没有感觉，就像我对这座建筑有多大有感觉一样。所以我认为我们离工程师建造桥梁的地方还差得很远。他们的设计模式现在已经被归结为他们几乎可以确定桥梁不会倒塌的地方。我们离软件还差得很远。但我认为这不是说我们根本不应该担心它的理由。</p><p class="normal">How big is GHC? I don't have a feel for that in the same sense I have a feel for how big this building is. So I don't think we're anywhere near where the engineers are with building bridges. Their design patterns have now been boiled down to where they can pretty much be sure that the bridge isn't going to fall down. We're nowhere near that with software. But I don't think that that's a reason for saying we just shouldn't worry about it at all.</p>
<p class="normal">事实上，我认为它是函数式编程可以提供很多东西的地方。因为我认为从根本上说，它使您能够构建更强大的结构。更容易理解、测试和推理的结构。这是我认为函数式程序员落后的地方：我们谈论函数式程序的推理，但我们做的并不<i>多</i>。我希望通过理解 Haskell 程序的工具看到更多，并对它们进行正式推理，并为您提供超出其类型的保证。我们站在更高的平台上，应该能够走得更远。</p><p class="normal">In fact I think it's somewhere where functional programming has a lot to offer. Because I think fundamentally it enables you to build more robust structures. Structures that are easier to comprehend and test and reason about. And here is something that I think functional programmers are lagging on: we talk about reasoning about functional programs but we don't <i>do</i> it very much. I'd like to see much more by way of tools that understand Haskell programs and formally reason about them and give you guarantees beyond their types. We stand on a higher platform and we should be able to go further.</p>
<p class="normal">所以这就是说材料应该变得更加坚固。您的材料越坚固，您就越不需要专注于细节而不是更大规模的结构。当然，这只会让我们更加雄心勃勃地建造更大的结构，直到我们到达它们再次分崩离析的地步。</p><p class="normal">So that's about saying the material should become more robust. The more robust your materials, the less you need to concentrate on the minutia instead of the larger-scale structures. Of course that will just make us more ambitious to build larger structures until we get to the point where they fall apart again.</p>
<p class="normal">我认为这是一种不变性。一旦你能做到，你就会伸展到你不能再做的地步。我想我真的不认为它是这个还是那个？我认为，总会有一个强大的狡猾元素，只是因为我们会扩大我们的野心。在工程结构的情况下，您可以伸展多远存在物理限制。没有人会在短期内建造一座横跨大西洋的桥梁。那真的<a id="OEBPS/Chapter07.html.page_281"></a>如果你建造它可能会倒下。但这不是人们不建造它的原因——只是因为它太贵了。而现在，有了软件，一旦你可以非常快速和廉价地在英吉利海峡上架起桥梁，那么，这就成了一笔交易，我们现在认为这非常便宜，所以我们现在将尝试大西洋。而现在它又分崩离析了。</p><p class="normal">I think that's sort of an invariant. As soon as you can do it, you stretch to the point where you can't do it anymore. I suppose I don't really see it as, is it this or is it that? There will always be a strong crafty element, I think, just because we'll stretch our ambition. In the case of engineering structures, there are physical limits on how far you can stretch. Nobody's going to build a bridge that traverses the Atlantic any time soon. And that really <a></a>might fall down if you built it. But that's not the reason people won't build it—it's just because it'd be too expensive. Whereas nowadays, with software, once you can build bridges over the Channel pretty quickly and cheaply, well then, that becomes a done deal and we now think that's pretty cheap so we'll now try the Atlantic. And now it falls apart again.</p>
<p class="normal"><b>Seibel：</b> Guy Steele 说摩尔定律如何在他的整个职业生涯中都是真实的，他怀疑这不会对他儿子的整个职业生涯都是真实的，并且正在猜测这将对编程产生什么影响。我想知道我们是否最终不得不停止说，“如果我们能在海峡上建一座桥，我们就能在大西洋上建一座桥”？</p><p class="normal"><b>Seibel:</b> Guy Steele was saying how Moore's Law has been true for his whole career and he suspects it won't be true for his son's whole career and was speculating a bit about what that's going to do to programming. I wonder will we eventually have to stop just saying, “If we can build a bridge over the Channel, we can build one over the Atlantic”?</p>
<p class="normal"><b>佩顿·琼斯：</b>不，不。我认为软件不同。因为如果您编写十倍大的软件，并不意味着您必须在十倍快的计算机上运行它。程序计数器只在一小部分代码中花费时间。它百分之九十的时间都花在了百分之十的代码上。所以性能关键的部分可能是程序中相对较小的部分。</p><p class="normal"><b>Peyton Jones:</b> No, no. Software's different I think. Because if you write software that's ten times as big that doesn't mean you have to run it on a computer that's ten times as fast. The program counter spends its time in a small portion of the code. Ninety percent of its time is spent in ten percent of the code or something. So the parts that are performance critical may be a relatively small part of the program.</p>
<p class="normal">的确，往往会发生的事情是你在抽象上打抽象，在你知道它按下屏幕上的一个按钮之前，在你最终到达一些寄存器被移动之前，大量的事情一直沿着链条发生。</p><p class="normal">It's true that what tends to happen is you slap abstraction on abstraction on abstraction and before you know it pressing a single button on the screen a great number of things happen all the way down the chain before you finally get to some registers being moved.</p>
<p class="normal">因此，我们可能不得不研究通过复杂的编译器转换来折叠这些层的方法，这样就不会发生太多事情。抽象边界可能对人有用，但机器不关心。所以我不认为仅仅因为我们可能达到计算机可以做的事情的界限，软件必然会立即停止变得更复杂。因为到那时他们无论如何都会很快。我认为对软件的主要限制不是计算机的速度，而是我们理解它应该做什么的能力。</p><p class="normal">So we may have to work on ways of collapsing out those layers by sophisticated compiler transformations so not so much happens. The abstraction boundary may be useful for people but machines don't care. So I don't think just because we may reach the boundaries of what computers can do that necessarily software will immediately halt from getting more complicated. Because by that time they'll be pretty fast anyway. I think the primary limitation on software is not the speed of computers but our ability to get our heads around what it's supposed to do.</p>
<p class="normal"><b>Seibel：</b>你喜欢编程什么？</p><p class="normal"><b>Seibel:</b> What do you enjoy about programming?</p>
<p class="normal"><b>Peyton Jones：</b>对我来说，让编程变得有趣的部分原因在于尝试编写对他们来说具有智力完整性的程序。您可以继续在程序的一侧拍打泥巴，这只是让它工作了很长时间，但并不是很令人满意。所以我认为一个好的属性<a id="OEBPS/Chapter07.html.page_282"></a>程序员，是他们试图找到一个漂亮的解决方案。不是每个人都有今天不能完成工作的奢侈，因为他们想不出一个漂亮的方法来完成它。</p><p class="normal"><b>Peyton Jones:</b> For me, part of what makes programming fun is trying to write programs that have an intellectual integrity to them. You can go on slapping mud on the side of a program and it just kind of makes it work for a long time but it's not very satisfying. So I think a good attribute of a good <a></a>programmer, is they try to find a beautiful solution. Not everybody has the luxury of being able to not get the job done today because they can't think of a beautiful way to do it.</p>
<p class="normal">但我真的认为这是一种有趣的媒介，因为它的可塑性很强。您几乎可以用它做任何事情。但这意味着你可以建造丑陋的东西，也可以建造美丽的东西，以及完全无法维护和不耐用的东西。有时我对商业世界感到有点害怕，一方面，因为客户下周需要它，所以必须完成它，另一方面，我们构建的系统的广度而不是深度。</p><p class="normal">But I really think it's a funny medium because it's so malleable. You can do virtually anything with it. But that means you can build ugly things as well as beautiful things and things that will be completely unmaintainable and un-durable. I sometimes feel a bit afraid about the commercial world with, on the one hand, the imperatives of getting it done because the customer needs it next week and, on the other hand, the sheer breadth rather than depth of the systems that we build.</p>
<p class="normal">系统充满了太多的东西——为了构建一个 ASP.NET web 服务，你需要了解这个 API 和这个工具，你需要用三种不同的语言编写，你需要了解 Silverlight 和 LINQ 以及你可以永远做首字母缩略词。他们每个人都有一本描述它的厚书。</p><p class="normal">Systems are filled with so much goop—in order to build an ASP.NET web service-y thing you need to know about this API and this tool and you need to write in three different languages and you need to know about Silverlight and LINQ and you can go on doing acronyms forever. And each of them has a fat book that describes it.</p>
<p class="normal">这是一种我不知道如何解决的紧张局势。这些都是有用的系统——它们不是偶然设计的。他们每个人的存在都是有原因的，他们每个人都有一个聪明的人，他们正在努力思考应该如何设计这个东西。但是，尽管如此，每个单独的界面都有一个广泛的界面。它可能很深也可能不很深，但它肯定很广泛。有很多东西需要放在脑子里。这就像学习一门语言——一种人类语言——词汇量很大。</p><p class="normal">This is a tension I don't know how to resolve. These are useful systems—they're not designed by accident. Each of them is there for a reason and each of them has a smart person who's thinking hard about how this thing should be architected. But nevertheless, each, individually, has a broad interface. It may or may not be deep but it's certainly broad. There's a lot of stuff you need to just have in your head. It's like learning a language—a human language—there's a large vocabulary.</p>
<p class="normal">对我来说，这没什么好玩的。我从来没有学过乘法表。每次我总是从第一原则开始解决它们，我只是开发了足够多的技巧，我可以足够快地完成它。当你做七个九时，我还得去，哦，七个九，哦，七个十加减法，所以是六十三。而其他人只是学习了它们。这是一件相对较小的事情。所以我讨厌你只需要学习这些大东西。所以我本能地远离这些大而粘稠的东西。但与此同时，我承认它们在实践中是有用且重要的。我脑海中的问题是，如果你能够花更长的时间来设计其中的一些东西，它们是否可以设计成更小、更简单、更少特别的界面？</p><p class="normal">For me, that's no fun. I never learned my multiplication tables. I always worked them out from first principles every time and I just developed enough tricks that I could do it quickly enough. When you do seven nines I still have to go, oh, seven nines, oh, seven tens and subtract, so it's sixty-three. Whereas other people just learnt them. And that's a relatively small thing. So I hate things were you just have to learn these big things. So instinctively I back away from these big goopy things. But at the same time I acknowledge that they're useful and important in practice. The question in my mind is, if you were able to take a bit longer to design some of these things, could they be designed with smaller, less complicated, and less ad hoc interfaces?</p>
<p class="normal"><a id="OEBPS/Chapter07.html.page_283"></a><b>Seibel：</b>有时似乎正是<i>因为</i>这些 blob 中的每一个都有一些聪明的人或一些人在处理它，而且每个聪明人都想在自己的小游乐场玩耍，所以事情变得如此复杂。</p><p class="normal"><a></a><b>Seibel:</b> Sometimes it seems that it's exactly <i>because</i> each of these blobs has some smart person or people working on it and each smart person wants their own little playground to play in, that things get so complicated.</p>
<p class="normal"><b>Peyton Jones：</b>我确定其中有一个因素。但是，如果您愿意，要对其进行更积极的构建，这是一个庞大而复杂的世界，还有很多事情要做。如果你有一个宏伟的奥林匹克愿景——如果你有一个非常大的大脑和巨大的吞吐量——你也许可以做一些重叠更少、整体连贯性更高的事情。</p><p class="normal"><b>Peyton Jones:</b> I'm sure there's an element of that. But to put a more positive construction on it, if you like, it's a big, complicated world and there's a lot to get done. If you had a grand Olympian vision—if you had a very large brain and enormous throughput—you might be able to do something with less overlap and more overall coherence.</p>
<p class="normal">但在实践中，我们必须将这些问题分解成小块。然后每个小块都有人照顾它，并且受制于他们以前做过的事情和他们的遗产。因此，也许他们在该空间内设计的东西可能不如它可能的那么好——他们时间紧迫。当然，当你看到所有东西的组合时，它可能比它可能的好得多。然后在您意识到这一点之前，您就陷入了一个遗留问题——这是事情没有达到预期效果的另一个原因。</p><p class="normal">But in practice we have to factor these problems into little chunks. And then the little chunks each have somebody who looks after it and who's conditioned by the things they've done before and their heritage. So maybe they design something within that space that may not be as good as it could possibly be—they're pressed for time. And certainly by the time you look at the combination of everything it's maybe quite a lot less good than it could possibly be. And then before you know it you're locked into a legacy problem—that's another reason that things are not as good as they could possibly be.</p>
<p class="normal">所以有一个巨大的遗留球和链条被拖来拖去。这是 Haskell 的优点之一。当我在 POPL 2004 或其他什么地方回顾 Haskell 时，我放了一张幻灯片，上面说我们在 Haskell 中学到的一件事是“不惜一切代价避免成功”。这显然是一种模因，因为人们记住了这句话，并把它引用给我。</p><p class="normal">So there's a tremendous legacy ball and chain that's being dragged around. It's one of the nice things about Haskell. When I gave a retrospective on Haskell at, I think it was POPL 2004 or something, I put up a slide that said one of the things we've learned to do in Haskell is to “avoid success at all costs.” This is clearly a sort of meme because people remember that phrase and they quote it back to me.</p>
<p class="normal">它有一定的道理，因为这意味着通过不太成功、过早，我们已经能够在 Haskell 的生命周期中对其进行很多改造。我现在感到有点狂躁的部分原因是因为 Haskell 变得更加成功，所以我收到了更多的错误报告，更多的功能请求。越来越多的人说，“请不要破坏我的程序。” 那过去不会发生。</p><p class="normal">It has a grain of truth in it because it means by not being too successful, too early, we've been able to morph Haskell quite a lot during its life. And part of the reason that I'm feeling a bit manic at the moment is because Haskell has become more successful and so I get more bug reports, more feature requests. And more people saying, “Don't break my program please.” That didn't use to happen.</p>
<p class="normal"><b>Seibel：</b>您曾多次提到编写漂亮的代码。漂亮的代码有什么特点？</p><p class="normal"><b>Seibel:</b> You've mentioned writing beautiful code a couple of times. What are the characteristics of beautiful code?</p>
<p class="normal"><b>Peyton Jones：</b> Tony Hoare 的措辞非常棒，他说你的代码显然应该没有错误，而不是没有明显的错误。<a id="OEBPS/Chapter07.html.page_284"></a>错误。所以对我来说，我认为漂亮的代码是明显正确的代码。它有点清澈透明。</p><p class="normal"><b>Peyton Jones:</b> Tony Hoare has this wonderful turn of phrase in which he says your code should obviously have no bugs rather than having no obvious <a></a>bugs. So for me I suppose beautiful code is code that is obviously right. It's kind of limpidly transparent.</p>
<p class="normal"><b>Seibel：</b>那些你几乎不得不弄清楚它们是如何工作的小代码呢，但一旦你做到了，它就会令人惊叹。那些也美吗？</p><p class="normal"><b>Seibel:</b> What about those little jewels of code that you almost have to puzzle out how they work but once you do, it's amazing. Are those also beautiful?</p>
<p class="normal"><b>Peyton Jones：</b>有时候说它显然是对的并不意味着你可以在没有任何心理支架的情况下看到它是对的。可能你需要被告知一个洞察力来弄清楚为什么它是正确的。如果您查看 AVL 树的代码，如果您不知道它试图实现什么，那么您真的不知道为什么会发生这些旋转。但是一旦你知道它维护的不变量，你就会看到，啊，如果我们维护那个不变量，那么我们将获得日志查找时间。然后你看着每一行代码，你说，“啊，是的，它保持不变。” 所以不变量是让你有洞察力的东西，“哦，这显然是正确的。”</p><p class="normal"><b>Peyton Jones:</b> Sometimes to say that it's obviously right doesn't mean that you can see that it's right without any mental scaffolding. It may be that you need to be told an insight to figure out why it's right. If you look at the code for an AVL tree, if you didn't know what it was trying to achieve, you really wouldn't have a clue why those rotations were taking place. But once you know the invariant that it's maintaining, you can see, ah, if we maintain that invariant then we'll get log lookup time. And then you look at each line of code and you say, “Ah, yes, it maintains the invariant.” So the invariant is the thing that gave you the insight to say, “Oh, it's obviously right.”</p>
<p class="normal">我完全同意仅查看裸代码可能还不够。我认为，漂亮代码的特征并不是您应该能够只查看裸代码并了解为什么它是正确的。您可能需要被告知原因。但是在你有了那个之后，现在有了那个观点，那个不变量，那个对正在发生的事情的理解，你可以看到，哦，是的，那是对的。</p><p class="normal">I agree completely that just looking at the bare code may not be enough. And it's not a characteristic, I think, of beautiful code, that you should be able to just look at the bare code and see why it's right. You may need to be told why. But after you have that, now with that viewpoint, that invariant, that understanding of what's going on, you can see, oh yeah, that's right.</p>
<p class="normal"><b>Seibel：</b>这是否为一个软件可以有多大并且仍然美观设定了上限？</p><p class="normal"><b>Seibel:</b> Does that put an upper bound on how big a piece of software can be and still be beautiful?</p>
<p class="normal"><b>Peyton Jones：</b>我不知道它的大小是否有限制。为了让自己确信它是正确的，或者至少是正确的，你需要的洞察力是沿着更有信心它是正确的。任何非常、非常大的软件都必然有缺点，或者确实有一些你只知道是错误的事情。但目前修复它们并不经济。GHC 确实如此，微软的软件也绝对如此。</p><p class="normal"><b>Peyton Jones:</b> I don't know if it's a bound on its size. The insights that you need in order to reassure yourself that it's right, or at least right-ish, are along the lines of being more confident that it's correct. Any really, really big piece of software is bound to have shortcomings or indeed outright things that you just know are wrong with it. But it's not economic to fix them at the moment. It's certainly true of GHC and it's definitely true of Microsoft's software.</p>
<p class="normal">但是，使大型软件易于管理的是拥有一些关于它应该做什么以及什么事情应该是真实的全局不变量或全局陈述。因此，以 GHC 为例，具有这种不变量，即每个中间程序都应该是良好类型的。<a id="OEBPS/Chapter07.html.page_285"></a>实际上，如果您愿意，可以在运行时对其进行检查。对于正在发生的事情，这是一个非常强大的不变量。所以我不确定这是否真的与尺寸有关。</p><p class="normal">But what makes big software manageable is having some global invariants or big-picture statements about what it's supposed to do and what things are supposed to be true. So, to take GHC as another example, having this invariant that each of these intermediate programs should be well typed. <a></a>That can be checked, actually, at runtime if you like. That's quite a powerful invariant about what's going on. So I'm not sure it's really necessarily to do with size.</p>
<p class="normal">当然，相互关联会使大型项目最终在自身的重量下崩溃。有时，你从研究工作中获得的奢侈品之一是，你有时可以根据你对你试图实现的目标以及你可能如何实现它的更深入的洞察力，获取一大块代码并简单地重写它。我们讨论了重构 GHC 后端的业务。如果我在更商业化的环境中工作，我可能负担不起。但我希望它能使 GHC 从长远来看更易于维护和理解。</p><p class="normal">Certainly interconnectedness makes big programs eventually crumble under their own weight. Sometimes one of the luxuries that you get from working in research is that you can sometimes take a chunk of code and simply rewrite it in the light of your improved insights into what you were trying to achieve and how you might try to achieve it. We talked about this business of refactoring GHC's back end. If I was working in a more commercial setting, I might not be able to afford to do that. But I'm hoping that it will make GHC more maintainable and understandable in the long term.</p>
<p class="normal">大小有上限吗？我不知道。我相当怀疑，只要我们能够继续构建良好的抽象，我们就可以继续建造横跨大西洋的桥梁。我们拥有运行良好的软件——虽然不完美，但考虑到它的规模，却出奇的好。</p><p class="normal">Is there an upper bound on the size? I don't know. I rather suspect that as long as we can go on building good abstractions we can keep building bridges across the Atlantic. We have software that works—not perfectly, but surprisingly well considering how big it is.</p>
<p class="normal"><b>Seibel：</b>所以问题是，你能建造一座那么大、能用、又漂亮的大厦吗？</p><p class="normal"><b>Seibel:</b> So the question is, can you build an edifice that's that large, and works, and is also beautiful.</p>
<p class="normal"><b>Peyton Jones：</b>它很难保持它的美丽。比特币在最初建造时通常很漂亮，或者至少可以接受，不丑陋。面对延长的寿命——维护——很难做到这一点。这是长寿命程序最糟糕的事情……它们逐渐变得丑陋。因此，他们不会在任何时刻变得毁容，但过了一段时间后，他们就会变得蹩脚。</p><p class="normal"><b>Peyton Jones:</b> It's hard for it to maintain its beauty. Bits are often beautiful or at least acceptably non-ugly when they're first built. In the face of protracted life—maintenance—it's quite difficult to maintain that. That's the worst thing about long-lived programs … that they gradually become ugly. So there's no moment at which they become disfigured but nevertheless after a while they just become crappy.</p>
<p class="normal"><b>Seibel：</b>唯一的出路是说“好吧，这东西活得够久了，重新开始”？</p><p class="normal"><b>Seibel:</b> And is the only way out to say, “OK, this thing has lived long enough, start over”?</p>
<p class="normal"><b>Peyton Jones：</b>我认为最终你必须重新设计其中的一部分。如果你有能力在前进的过程中进行一些再造，那么——如果你十年什么都不做，那么结果可能会令人望而生畏，以至于你会想，“我只能把它扔掉，重新开始。 ” 如果你能负担得起再造一点，就像人类细胞自我再生一样——我希望 GHC 能做到这一点。</p><p class="normal"><b>Peyton Jones:</b> I think that eventually you have to reengineer chunks of it. And if you can afford to reengineer a bit as you go along, then—if you don't do anything for ten years then the result may just be so daunting that you think, “I just have to throw it away and start again.” If you can afford to reengineer a bit as you go along, like the human cells regenerating themselves—that's what I hope is happening to GHC.</p>
<p class="normal"><a id="OEBPS/Chapter07.html.page_286"></a>我认为，作为一名程序员，生活中最令人沮丧的事情是，如果你面对的是别人写的一大块代码，或者更糟的是，你自己写的代码，但你再也不敢修改了。真令人沮丧。</p><p class="normal"><a></a>The most depressing thing about life as a programmer, I think, is if you're faced with a chunk of code that either someone else wrote or, worse still, you wrote yourself but you no longer dare to modify. That's depressing.</p>
</div>
</div></div>
<div id="OEBPS/Chapter08.html"><div>

<div class="booksection">
<p></p>
<h2 class="chapnum"><a id="OEBPS/Chapter08.html.ch8"></a><a id="OEBPS/Chapter08.html.page_287"></a><img src="data:image/jpg;base64,/9j/4AAQSkZJRgABAgEASABIAAD/7Q0OUGhvdG9zaG9wIDMuMAA4QklNA+0KUmVzb2x1dGlvbgAAAAAQAEgAAAABAAEASAAAAAEAAThCSU0EDRhGWCBHbG9iYWwgTGlnaHRpbmcgQW5nbGUAAAAABAAAAHg4QklNBBkSRlggR2xvYmFsIEFsdGl0dWRlAAAAAAQAAAAeOEJJTQPzC1ByaW50IEZsYWdzAAAACQAAAAAAAAAAAQA4QklNBAoOQ29weXJpZ2h0IEZsYWcAAAAAAQAAOEJJTScQFEphcGFuZXNlIFByaW50IEZsYWdzAAAAAAoAAQAAAAAAAAACOEJJTQP1F0NvbG9yIEhhbGZ0b25lIFNldHRpbmdzAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+BdDb2xvciBUcmFuc2ZlciBTZXR0aW5ncwAAAHAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAOEJJTQQAC0xheWVyIFN0YXRlAAAAAgABOEJJTQQCDExheWVyIEdyb3VwcwAAAAAEAAAAADhCSU0ECAZHdWlkZXMAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4NVVJMIG92ZXJyaWRlcwAAAAQAAAAAOEJJTQQaBlNsaWNlcwAAAAB1AAAABgAAAAAAAAAAAAAAmwAAANwAAAAKAFUAbgB0AGkAdABsAGUAZAAtADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAANwAAACbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhCSU0EERFJQ0MgVW50YWdnZWQgRmxhZwAAAAEBADhCSU0EFBdMYXllciBJRCBHZW5lcmF0b3IgQmFzZQAAAAQAAAACOEJJTQQMFU5ldyBXaW5kb3dzIFRodW1ibmFpbAAACTEAAAABAAAAcAAAAE8AAAFQAABnsAAACRUAGAAB/9j/4AAQSkZJRgABAgEASABI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" alt="图片"></h2><h2 class="chapnum"><a></a><a></a></h2>
<h2 class="chaptitle">彼得·诺维格</h2><h2 class="chaptitle">Peter Norvig</h2>
<div class="sidebar">
<p class="normal"><i>彼得·诺维格 (Peter Norvig) 思想开阔，骨子里是一名黑客。他曾经写过一个程序，在谷歌的搜索日志中查找同一用户的三个连续搜索系列，当这些搜索组合在一起时，就形成了俳句（最令人难忘的俳句之一：“java ECC / java 椭圆曲线 / 花花公子常见问题解答”）。</i></p><p class="normal"><i>Peter Norvig is a broad thinker and a hacker at heart. He once wrote a program to find in Google's search logs series of three consecutive searches by the same user that, when put together, made a haiku (one of the most memorable: “java ECC / java elliptical curve / playboy faq”).</i></p>
<p class="normal"><i>在他的网站上，Norvig 有指向常用内容的链接：他写的书籍和论文、他发表的演讲的幻灯片以及他的代码的各个部分。但也有指向他在 McSweeney's Quarterly Concern 上发表的项目的链接，他机智地讲述了编写一个程序来生成世界上最长的回文句子，以及他的“葛底斯堡 Powerpoint 演示文稿”，这是一份微软 PowerPoint 软件的发送，已被由 Edward Tufte 引用，如果您使用 Google“PowerPoint”，它会出现在结果的第一页。</i></p><p class="normal"><i>On his web site Norvig has links to the usual stuff: books and papers he's written, slides from talks he's given, and various bits of his code. But there are also links to items he's had published in McSweeney's Quarterly Concern, his witty recounting of writing a program to generate the world's longest palindromic sentence, and his “Gettysburg Powerpoint Presentation,” a send-up of Microsoft's PowerPoint software, which has been cited by Edward Tufte and which appears on the first page of results if you Google “PowerPoint.”</i></p>
<p class="normal"><i>在担任搜索质量总监之后，他现在是谷歌的研究总监。在此之前，他曾是美国宇航局艾姆斯研究中心计算科学部的负责人，在此之前，他是 90 年代末互联网初创公司 Junglee 的早期员工。他于 2001 年获得美国宇航局杰出成就奖，是美国人工智能协会和计算机协会的会员。</i></p><p class="normal"><i>He is now the Director of Research at Google, after having been the Director of Search Quality. Prior to that he had been the head of the Computational Sciences Division at NASA Ames Research Center and before that, an early employee at the late-'90s Internet startup Junglee. He won the NASA Exceptional Achievement Award in 2001 and is a Fellow of the American Association for Artificial Intelligence and the Association for Computing Machinery.</i></p>
<p class="normal"><i>在 Google、NASA 和 Junglee 之间，Norvig 在构建软件的“黑客”和“工程师”方法方面都有经验，并在本次采访中谈到了每种方法的优缺点。作为一名前计算机科学<a id="OEBPS/Chapter08.html.page_288"></a>教授，现在是世界上最大的工业软件商店之一的内部人员，他对学术计算机科学与工业实践之间的关系也有有趣的看法。</i></p><p class="normal"><i>Between Google, NASA, and Junglee, Norvig has experience with both the “hacker” and “engineer” approaches to building software and talks in this interview about the advantages and disadvantages of each. As a former computer-science <a></a>professor and now an insider at one of the biggest industrial software shops in the world, he also has an interesting perspective on the relation between academic computer science and industrial practice.</i></p>
<p class="normal"><i>我们谈话中的其他话题包括编程在最近几年发生了怎样的变化，为什么没有设计技术可以弥补不知道你在做什么，以及为什么 NASA 使用不太可靠但更便宜的软件可能会更好。</i></p><p class="normal"><i>Other topics in our conversation included how programming has changed in recent years, why no design technique can make up for not knowing what you're doing, and why NASA might be better off with less-reliable but cheaper software.</i></p>
</div>
<p class="normal"><b>Seibel：</b>你什么时候开始编程的？</p><p class="normal"><b>Seibel:</b> When did you start programming?</p>
<p class="normal"><b>Norvig：</b>在高中。我们有一个 PDP-8，我想是，在我的高中，我上了一门课——我们从 BASIC 编程开始，然后我从那里开始。</p><p class="normal"><b>Norvig:</b> In high school. We had a PDP-8, I think it was, at my high school, and there was a class I took—we started in BASIC programming and I went from there.</p>
<p class="normal"><b>Seibel：</b>那会是哪一年？</p><p class="normal"><b>Seibel:</b> What year would that have been?</p>
<p class="normal"><b>Norvig：</b>我 74 年高中毕业，所以那一定是 72 年或 73 年。我记得一些事情，回到那些早期的日子。我记得老师试图教洗牌。她的算法是，使用随机数生成器选择两个位置，然后交换它们并保留一个表示这些已交换的位向量，并继续进行直到它们全部交换。我记得我当时的反应是，“那太蠢了。这一定是世界上最愚蠢的事情。这可能需要很长时间，因为可能有一对你永远不会碰巧选择。” 当它本可以是 n 阶时，<i>我</i>当时还不知道说它是<i>n平方</i><i></i>. 但我知道那是错误的。然后我想出了 Knuth 算法，从 0 交换到 52，然后从 0 交换到 51 等等——一个<i>n</i>阶算法。我记得老师为她的方法辩护。这让我想到，“好吧，也许我有编程方面的天赋。” 这也帮助我说，“也许老师并不是真的无所不知。”</p><p class="normal"><b>Norvig:</b> I graduated high school in '74, so it must have been '72 or '73. I remember a couple of things, going back to those early days. I remember the teacher trying to teach shuffling of a deck of cards. Her algorithm was, use a random-number generator to pick two locations and then swap them and keep a bit vector that said, these were swapped, and keep going until they're all swapped. I remember my reaction being, “That's stupid. That's gotta be the stupidest thing in the world. It could take forever because there could be one pair that you never happen to choose.” I didn't know enough then to say it's <i>n</i> squared when it could have been order <i>n</i>. But I knew that that was just wrong. Then I was able to come up with, I think, the Knuth algorithm of swapping from 0 to 52 and then from 0 to 51 and so on—an order <i>n</i> algorithm. And I remember the teacher defending her approach. That helped me think, “Well, maybe I have an aptitude for this programming stuff.” It also helped me say, “Maybe teachers don't really know everything.”</p>
<p class="normal"><b>Seibel：</b>是不是她一描述你就说，“哇，这是错的”？或者你玩了一会儿然后说，“天哪，我们在这里做了很多工作”？</p><p class="normal"><b>Seibel:</b> Was it as soon as she described it that you just said, “Wow, this is wrong”? Or did you play with it for a while and then say, “Gosh it seems like we're doing a lot of work here”?</p>
<p class="normal"><a id="OEBPS/Chapter08.html.page_289"></a><b>Norvig：</b>我想我马上就注意到了。很难知道我当时真正在想什么，但我想我马上就注意到这可能不会终止的可能性是有限的。我不确定我对预期的运行时间了解多少。</p><p class="normal"><a></a><b>Norvig:</b> I think I noticed right away. It's hard to know what I was really thinking back then but I think right away I noticed there's a finite possibility that this might not terminate. I'm not sure I knew as much about the expected runtime.</p>
<p class="normal">我还记得在阁楼上找到我父亲的《<i>科学美国人》过刊并翻阅。</i>Christopher Strachey 有一篇关于软件工程的文章，他在文章中说人们将使用这些高阶语言。他发明了这种从来没有编译器的语言——它是一种书面语言。他说，“我要用这种语言编写跳棋程序。” 我记得读过那个——这是我读过的第一个重要的程序，因为在学校我们只是在学习如何洗牌等等。我最近又读了一遍，我注意到的第一件事是里面有一个错误。这很棒，因为你认为这是 Christopher Strachey，他应该知道他在做什么，而且这是《<i>科学美国人》</i>，他们有编辑器等等——他们可能应该解决这些错误。但是在散文中它说有一个函数<code>make-move</code>可以获取棋盘位置并返回移动，然后您查看代码就会发现<code>make-move</code>它需要一个棋盘位置和一个额外的参数。显然他们先写了散文，然后才写了实现。他们发现你无法无限深入地搜索，所以他们添加了一个额外的参数，即搜索深度，你可以递归到某个级别，然后停止。他们后来补充说，并没有回去修复文档。</p><p class="normal">I also remember finding my father's back issues of <i>Scientific American</i> in the attic and going through them. There was this article by Christopher Strachey on software engineering in which he said that people are going to use these higher-order languages. And he had invented this language that there was never a compiler for—it was a paper language. And he said, “I'm going to write a checkers program using this language.” I remember reading that—it was the first nontrivial program I had ever read because in school we were just learning how to shuffle and so on. I read it again recently and the first thing I noticed was that there's a bug in it. And it was great because you figure this is Christopher Strachey, he should know what he's doing, and it's <i>Scientific American</i>, they've got editors and so on—they should probably get those bugs out. But in the prose it says there's a function <code>make-move</code> which takes a board position and returns a move and then you look in the code and there's <code>make-move</code> and it takes a board position and an extra parameter. Apparently they wrote the prose first and then they wrote the implementation. And they found out you can't search infinitely deep so they added an extra parameter which was depth of search and you recurse down to a certain level and then you stop. They had added that in afterwards and hadn't gone back and fixed the documentation.</p>
<p class="normal"><b>Seibel：</b>那是你读到的第一个有趣的代码；你写的第一个有趣的程序是什么？</p><p class="normal"><b>Seibel:</b> So that was the first interesting code you read; what was the first interesting program you wrote?</p>
<p class="normal"><b>Norvig：</b>我想这可能是生命游戏。这实际上是班级的作业。我很快就完成了作业，当然那时我们没有漂亮的显示屏。我没有 30 英寸的显示器——我有带黄纸的电传打字机。我说，“这太浪费了，打印出一个小区域”——他们可能希望我们做一个 10×10 的区域——“然后再打印下一个和下一个。” 所以我说，“让我们连续打印五代。” 我记得 BASIC 中不能有三维数组，出于某种原因我什至不能有一堆二维数组。就像他们用完了内存或其他东西。所以我必须弄清楚如何让这些二维数组有五个或六个，这就是我发现位域的时候。</p><p class="normal"><b>Norvig:</b> I guess it was probably the Game of Life. It was actually an assignment for the class. I quickly did the assignment, and of course then we didn't have the nice display screens. I didn't have my 30-inch monitor—I had the teletype with the yellow paper. I said, “This is a waste, printing out one small field”—they probably wanted us to do a ten-by-ten field—“and then printing out the next one and the next one.” So I said, “Let's print out five generations in a row.” And I remember that you couldn't have three-dimensional arrays in BASIC, and for some reason I couldn't even have a bunch of two-dimensional arrays. It's like they ran out of memory or something. So I had to figure out how am I going to have five or six across of these two-dimensional arrays, and that's when I discovered bit fields.</p>
<p class="normal"><a id="OEBPS/Chapter08.html.page_290"></a><b>Seibel：</b>考虑到内存的限制，你为那么多的数据滚动了自己的存储空间。您是否学习过位数组并弄清楚如何应用它们，或者您是否仔细阅读了手册并发现，“哦，看，这是 PEEK 和 POKE”或其他什么？</p><p class="normal"><a></a><b>Seibel:</b> So given the constraints on memory, you rolled your own storage for that much data. Had you been taught about bit arrays and figured out how to apply them, or did you go digging through the manual and discovered, “Oh, look, here's this PEEK and POKE” or whatever it was?</p>
<p class="normal"><b>Norvig：</b>嗯，我在每个位置都存储了一个零或一个，我需要在某个地方存储更多的东西，我说，“哦，在那里存储其他数字。” 事实上，我什至不记得我是否做过位存储。我可能已经完成了数字——十进制而不是二进制——因为二进制的东西并没有以一种有趣的方式真正地暴露给我们。然后我必须添加一些东西，比如它是否重复，如果是，以什么周期重复。当你只保留上一代时，你无法做到这一点。</p><p class="normal"><b>Norvig:</b> Well, I was storing a zero or one in each of these locations, and I needed to store more stuff somewhere, and I said, “Oh, store other numbers there.” In fact, I don't even remember if I did bit store. I might've done digits—decimal rather than binary—because the binary stuff hadn't really been exposed to us in an interesting way. And then I got to add in things, like, is it repeating and if so, with what cycle. You couldn't do that when you were just keeping one previous generation.</p>
<p class="normal"><b>Seibel：</b>当你成为一名程序员时，你是专门做一些事情来提高你作为程序员的技能，还是只是编程？</p><p class="normal"><b>Seibel:</b> When you were coming up as a programmer, did you do things specifically to improve your skill as a programmer, or did you just program?</p>
<p class="normal"><b>Norvig：</b>我想我只是在编程。我当然会做一些事情，因为它们很有趣。尤其是当我还是一名研究生时，我不太受制于日程安排。我会说，“哦，这是一个有趣的问题。看看我能不能解决这个问题。” 不是因为它是我论文的进步，而是因为它很有趣。</p><p class="normal"><b>Norvig:</b> I think I just programmed. Certainly I would do things because they were fun. Especially when I was a grad student and I was less beholden to schedules. I'd say, “Oh, here's an interesting problem. Let's see if I can solve that.” Not because it's progress on my thesis, but just because it was fun.</p>
<p class="normal"><b>Seibel：</b>你在大学里学的是计算机，但没有主修计算机科学，对吧？</p><p class="normal"><b>Seibel:</b> And you studied computers in college but didn't major in computer science, right?</p>
<p class="normal"><b>Norvig：</b>当我开始学习时，计算机课程是应用数学系的一部分。到我毕业时，实际上已经有了一个计算机科学系，但我还是坚持把数学作为我的专业。感觉就像完成计算机科学专业的所有要求一样，就像在 IBM 专业一样。你得学他们的汇编语言，你得学他们的360操作系统，等等。那似乎没什么意思。有一些我喜欢的课程，我参加了这些课程，但我不想完成所有要求。</p><p class="normal"><b>Norvig:</b> When I started, the computer classes were part of the applied-math department. By the time I graduated there actually was a computer-science department, but I stuck with math as my major. It felt like doing all the requirements for a computer-science major was like majoring in IBM. You had to learn their assembly language, you had to learn their 360 operating system, and so on. That didn't seem like much fun. There were some courses that I liked and I took those, but I didn't want to go through all the requirements.</p>
<p class="normal">大学毕业后，我在剑桥的一家软件公司工作了两年。两年后我说，“我花了四年时间厌倦了学校，只花了两年时间就厌倦了工作，也许我喜欢学校的程度是原来的两倍。”</p><p class="normal">After college I worked for two years, for a software company in Cambridge. And after two years I said, “It took me four years to get sick of school and only two years to get sick of work, maybe I like school twice as much.”</p>
<p class="normal"><b>Seibel：</b>你为他们做了什么？</p><p class="normal"><b>Seibel:</b> What were you doing for them?</p>
<p class="normal"><a id="OEBPS/Chapter08.html.page_291"></a><b>Norvig：</b>他们的主要产品是软件设计工具集，他们还提供各种软件咨询服务。创始人曾在剑桥的 Draper Labs 从事<i>阿波罗</i>任务和其他类似任务；他们与空军有联系，并且是政府承包商。他们对应该如何设计软件有这样的想法。我从不相信整个想法，但它很有趣。</p><p class="normal"><a></a><b>Norvig:</b> Their main product was a software-design tool set, and they also did software consulting of various kinds. The founders had worked at Draper Labs in Cambridge on the <i>Apollo</i> mission and other things like that; they had Air Force connections and they were a government contractor. They had this idea of how software should be designed. I never believed in the whole idea, but it was fun.</p>
<p class="normal">我记得我们在这家公司的一个项目是写一个流程图抽屉。这个想法是它会解析你的程序并为它生成一个流程图。这很完美，因为人们总是这样使用流程图。你应该提前写它们，但你真的从来没有这样做——你是在事后写的。它的聪明之处在于它有一种部分语法，所以你可以使用一个甚至在语法上都不完全正确的程序，它会掩盖它无法解析的部分。它必须知道如何解析<code>IF</code>陈述，因为那些制造了不同的块等等，但其他的东西它只是说，“好吧，无论那里有什么，只要把它扔进一个块。” 我们得到这份合同来生成这个东西，他们指定他们想在 Unix 系统上运行它。所以我们在麻省理工学院借了一台机器，并使用了所有的 Unix 工具，yacc 和其他东西，用于编译器。在最后一刻他们说，“不，我们要把它安装在 VMS 系统上。” 所以突然之间，yacc 不在了。但我们说，“没关系，我们不需要它——我们只需要它来生成表格就可以了。”</p><p class="normal">I remember one of the projects we had there, at this company, was to write a flowchart drawer. The idea was that it would parse your program and generate a flowchart for it. Which was perfect because that's the way people always use flowcharts. You're supposed to write them ahead of time but you really never do—you write them after the fact. And it was clever in that it had a sort of partial grammar so you could take a program that wasn't even quite syntactically correct and it would gloss over the parts that it couldn't parse. It would have to know how to parse the <code>IF</code> statements because those made different blocks and so on but the other stuff it just said, “Well, whatever is there just throw it into a block.” We got this contract to generate this thing and they specified that they wanted to run it on a Unix system. So we borrowed a machine at MIT and used all the Unix tools, yacc and stuff, for the compiler. And at the last minute they said, “No, we're going to install it on a VMS system.” So all of the sudden, yacc wasn't there. But we said, “That's OK, we don't need it—we just needed it to generate the tables and that's done.”</p>
<p class="normal"><b>Seibel：</b>只要你的语法永远不变，你就没问题。</p><p class="normal"><b>Seibel:</b> As long as your grammar never changes, you're OK.</p>
<p class="normal"><b>Norvig：</b>是的，所以我们交付了它，他们很高兴，然后——当然——语法发生了变化。而且我们再也无法访问任何 Unix 机器。所以我最终不得不通过理解表格来修补语法，然后说，“这是跳到另一个状态的跳转——好的，我将在这里发明一个新状态，然后跳转到那个状态。”</p><p class="normal"><b>Norvig:</b> Right, and so we delivered it and they were happy and then—of course—the grammar changed. And we didn't have access to any Unix machines anymore. So I ended up having to patch the grammar by understanding the tables and saying, “Here's a jump to this other state—OK, I'll invent a new state here and jump to that one instead.”</p>
<p class="normal"><b>Seibel：</b>那真的是正确的解决方案吗——你有没有考虑过只写一个新的解析器？</p><p class="normal"><b>Seibel:</b> And was that really the right solution—did you ever consider just writing a new parser?</p>
<p class="normal"><b>Norvig：</b>我可能应该有。但是，你知道，这只是一个小小的修复。</p><p class="normal"><b>Norvig:</b> I probably should have. But, you know, it was just this one little fix.</p>
<p class="normal"><b>Seibel：</b>而且你没有陷入每三周他们对语法进行一次新更改的陷阱？</p><p class="normal"><b>Seibel:</b> And you didn't get caught in the trap of every three weeks they come around with a new change to the grammar?</p>
<p class="normal"><a id="OEBPS/Chapter08.html.page_292"></a><b>Norvig：</b>嗯，然后我去了研究生院。其他人遇到了问题，我不知道发生了什么。</p><p class="normal"><a></a><b>Norvig:</b> Well, then I went off to grad school. Somebody else had the problem and I don't know what happened.</p>
<p class="normal"><b>Seibel：</b>不再是你的问题了。所以你获得了博士学位。在学习编程的过程中，有什么是您希望自己做的有所不同的吗？</p><p class="normal"><b>Seibel:</b> Not your problem anymore. So you got your PhD. Is there anything that you wish you had done differently about how you learned to program?</p>
<p class="normal"><b>Norvig：</b>我最终进入了工业环境，所以也许我希望早点做更多这样的事情。我确实学会了这样做，但我在学校和研究生院待了很长时间。那也很有趣，所以我没有任何遗憾。</p><p class="normal"><b>Norvig:</b> I ended up in industrial settings, so maybe I would've wished to have done more of that earlier on. I did learn to do it, but I was in school and in grad school for a long time. That was a lot of fun, too, so I don't have any regrets.</p>
<p class="normal"><b>Seibel：</b>关于工业编程，你必须学习哪些东西？</p><p class="normal"><b>Seibel:</b> What were the things you had to learn about industrial programming?</p>
<p class="normal"><b>Norvig：</b>关于制定时间表，让团队成员、客户和经理开心。当你是一名研究生时，你不必这样做；只是时不时地出现在你的顾问面前。</p><p class="normal"><b>Norvig:</b> About having schedules, and keeping team members and customers and managers happy. When you're a grad student, you don't have to do that; just show up to your adviser every now and then.</p>
<p class="normal">我想最大的变化是从一个人到一个团队，并弄清楚这些互动是如何运作的。这是你在学校通常得不到的东西。我想有些学校开始更多地将其纳入课程。当我在学校的时候，团队合作被称为作弊。</p><p class="normal">I guess the biggest change was going from one person to a team and figuring out how those kinds of interactions work. That's something you don't normally get in school. I guess some of the schools are starting to bring that into the curriculum more. When I was in school, working as a team was called cheating.</p>
<p class="normal"><b>Seibel：</b>对于进入工业界的人来说，除了编写代码的能力之外，还有其他技能是人们应该培养的吗？</p><p class="normal"><b>Seibel:</b> For people who are going into industry, are there other skills, beyond just the ability to write code, that people should develop?</p>
<p class="normal"><b>Norvig：</b>与人相处是最主要的。能够了解客户很重要：了解您想要构建的是什么以及您拥有的是否正确。能够与他们互动，然后与您的队友互动。当你出去见他们时，与公司高层和你的客户互动。有各种不同的社会关系，它们需要不同的技能。</p><p class="normal"><b>Norvig:</b> Getting along with people is the main thing. Being able to understand the customer is important: to know what it is you want to build and whether what you have is right. Being able to interact with them and then interact with your teammates. And interact with people higher up in the company and your customers when you go out and see them. There are all different social relations and they require different skills.</p>
<p class="normal"><b>Seibel：</b>编程是否变得比过去更具社交性？</p><p class="normal"><b>Seibel:</b> Has programming become a more social activity than it used to be?</p>
<p class="normal"><b>诺维格：</b>我想是的。我认为计算机过去更加隔离。而在过去，它主要是批处理，所以界面简单得多。可以在您说的地方进行这种瀑布设计，<a id="OEBPS/Chapter08.html.page_293"></a>“输入将是这副牌，输出将是一份报告，其中包含此列中的数字。”</p><p class="normal"><b>Norvig:</b> I think so. I think the computer used to be more segregated. And in the old days it was mostly batch processing, so the interface was so much simpler. It was possible to do this kind of waterfall design where you said, <a></a>“The input is going to be this deck of cards, and the output is going to be a report that has this number in this column.”</p>
<p class="normal">以这种方式指定它可能不是一个好主意。可能从一开始你就应该与客户进行更多的互动。但它似乎更可分离。现在一切似乎都更加流畅和互动，所以说“与其从一开始就有完整的规范，不如让客户进入房间并开始集思广益”更有意义。</p><p class="normal">It probably wasn't a very good idea to specify it that way. Probably right from the start you should have had more interaction with the customer. But it seemed more separable. Now everything seems more fluid and interactive so it makes more sense to say, “Rather than have a complete specification from the start, just get customers in the room and start brainstorming.”</p>
<p class="normal"><b>Seibel：</b>你还记得任何特别的<i>啊哈！</i>你注意到自己做某事和团队合作的区别的时刻？</p><p class="normal"><b>Seibel:</b> And do you remember any particular <i>aha!</i> moments where you noticed the difference between working on something by yourself and working on a team?</p>
<p class="normal"><b>Norvig：</b>我不知道是不是有那么多时刻，但就是意识到你不能自己做所有事情。我认为很多编程都能够尽可能多地保留在您的脑海中，但这仅此而已，至少在我的脑海中。然后你必须依赖其他人拥有正确的抽象，这样你才能使用他们拥有的东西。我开始思考，“这怎么可能完成？” 而不是，“我知道这是怎么做的，因为我做到了。” 如果我要这样做，我会怎么做？我希望它是那样的，如果不是，弄清楚为什么不，然后弄清楚如何使用它。</p><p class="normal"><b>Norvig:</b> I don't know if it was so much moments, but just this realization that you can't do everything yourself. I think a lot of programming is being able to keep as much as you can inside your head, but that only goes so far, at least in my head. Then you have to rely on other people to have the right abstractions so that you can use what they have. I started thinking about it in terms of, “How is this likely done?” rather than, “I know how this was done because I did it.” If I were to have done this, how would I have done it? I hope that it's like that, and if it's not, figure out why not, and then figure out how to use it.</p>
<p class="normal"><b>Seibel：</b>你是否认为学习以这种方式在团队中工作也能让你真正从事更大的事情，即使你是一个跨越时间的团队？</p><p class="normal"><b>Seibel:</b> Do you think that learning to work on teams that way also enables you to actually work on bigger things even by yourself when you're sort of a team spread across time?</p>
<p class="normal"><b>Norvig：</b>我认为这是真的，而且这肯定是我在现在出现的年轻程序员身上看到的。现在和那时的另一个区别是，现在似乎更多的是组装，而不是从头开始编写所有内容。现在，对于一项学校作业，有人说，“好吧，我需要一个网站，所以我用 Ruby on Rails 做这个，我用 Drupal 做那部分，然后我有这个 Python 脚本，然后我下载了这个统计例程”，所有这些都是通过脚本将这些片段组合在一起，而不是从头开始编写所有内容。所以我认为理解接口以及它们如何组合在一起比了解这些包内部的所有细节更重要。</p><p class="normal"><b>Norvig:</b> I think that's true and that's certainly something I see in the younger programmers that are coming out now. Another difference between now and then is it seems like it's much more assembling pieces now rather than writing everything from scratch. Now, for a school assignment, someone says, “OK, I needed a website, so I used Ruby on Rails for this, and I used Drupal for that part, and then I had this Python script, and then I downloaded this statistical routine,” and it's all scripting to put together these pieces rather than writing everything from scratch. So I think understanding interfaces and how they go together is more important than all the details of the insides of these packages.</p>
<p class="normal"><a id="OEBPS/Chapter08.html.page_294"></a><b>Seibel：</b>你认为这会改变现在能够在编程方面取得成功的人吗？</p><p class="normal"><a></a><b>Seibel:</b> And do you think that changes the kind of people who can be successful at programming now?</p>
<p class="normal"><b>挪威：</b>我认为真正成功的人都是一样的——至少我在这里看到的是这样。但是，是的，更多的是“我能否快速了解我需要什么”，而不是“我需要完全理解”。我认为其中有些是虚张声势，这种愿意说，“我要继续做下去，”无所畏惧地说，“我不明白正在发生的一切，但我进入了文档并我学会了这三件事。我试过了，它奏效了，所以我要继续了。” 这会让你达到一定程度，但我认为要真正成为一名优秀的程序员，你不能只这样做。你必须多了解一点，然后说，“安全吗，我在这里做什么？或者有哪些失败案例？当然，我试过一次，它成功了，但它总是会起作用吗？我如何编写测试用例来展示它并更好地理解它，然后一旦我完成了，我是否可以提取我所做的并发布一个其他人可以使用的新工具，因为我已经把这些以某种方式拼凑在一起。”</p><p class="normal"><b>Norvig:</b> I think the people that are really successful are the same—at least that's what I see around here. But, yeah, it is a little bit more of, “Can I quickly get an understanding of what I need,” and less of, “I need complete understanding.” I think some of it is bravado, this willingness to say, “I'm just going to go ahead and do it,” the fearlessness of saying, “I don't understand everything that's going on, but I went into the documentation and I learned these three things. I tried it and it worked, so I'm just going to go ahead.” That gets you to a certain point, but I think to really be a good programmer, you can't just do that. You have to understand a little bit more, and say, “Is it safe, what I'm doing here? Or what are the failure cases? Sure, I tried it once and it worked, but is it always going to work? How do I write test cases to show that and to understand it a little better, and then once I've done that, can I extract what I've done and publish a new tool that other people can use because I've put these pieces together in a certain way.”</p>
<p class="normal"><b>Seibel：</b>当你还是一名程序员时，你喜欢在团队中工作吗？是不是最好把问题分开，让每个人都能分得清？还是您喜欢 XP 的结对编程模型，每个人都共同拥有所有代码？</p><p class="normal"><b>Seibel:</b> How did you like to work on a team when you were a programmer? Is it better to take the problem and split it up so everybody gets their piece? Or do you like the XP model of pair-program everything and everybody owns all the code collectively?</p>
<p class="normal"><b>Norvig：</b>我猜它更像是分解。Steve Yegge 有一篇“好的敏捷，坏的敏捷”文章。我认为他是对的。百分之十的时间坐在一起是一个非常好的主意，因为你想要共同的理解。我认为大多数时候你不会那么有效。</p><p class="normal"><b>Norvig:</b> I guess it's more break it up. Steve Yegge's got this “Good Agile, Bad Agile” piece. I think he's about right. Ten percent of the time it is a really good idea to sit down together because you want that shared understanding. I think most of the time you're not going to be as effective.</p>
<p class="normal">如果你有两个优秀的程序员，最好让他们独立工作，然后相互调试对方的工作，而不是说，“我们只为增加的一双眼睛承担 50% 的损失。”</p><p class="normal">If you have two good programmers, it's better for them to work independently and then debug each other's work afterwards rather than to say, “We'll take a 50 percent hit just for that added set of eyes.”</p>
<p class="normal">我认为重要的是，当你弄清楚你想做什么时，集思广益我们要解决的问题是什么，这里的功能是什么？在开始之前，您甚至不知道产品是什么。你真的很想一起做。然后你会说，“好吧，现在我们知道我们想做什么了。我们要怎么分？” 你想一起做的事。一旦你有了一个很好的主意，我认为你会过得更好<a id="OEBPS/Chapter08.html.page_295"></a>大部分时间都花在自己身上。你想要反馈，所以我认为你应该要求每段代码都由另一组眼睛审查，但在你编写代码时，它不必是实时的。</p><p class="normal">I think it is important to get together when you're figuring out what it is you want to do both in terms of brainstorming what is the problem we're trying to solve and what is the functionality going to be here? You don't even know what the product is before you start. That you really want to do together. Then you get to the point of saying, “OK, now we know what we want to do. How are we going to divide it up?” That you want to do together. Once you have a pretty good idea, I think you're better off <a></a>spending most of the time on your own. You want feedback, so I think you should require every piece of code to be reviewed by another set of eyes, but it doesn't have to be real-time, when you're writing it.</p>
<p class="normal">我记得 IBM 大师级程序员的想法，那似乎是我听过的最愚蠢的事情。为什么有人愿意让自己成为一个真正的程序员的地鼠？</p><p class="normal">I remember the IBM master-programmer idea, and that just seemed like the dumbest thing I have ever heard of. Why would anybody want to subject themselves to being a gopher for the one real programmer?</p>
<p class="normal"><b>Seibel：</b>我很惊讶你认为大师-程序员模型是一个如此愚蠢的想法。在您的“十年自学编程”文章中，您指出编程是一种技能，与许多技能一样，可能需要大约十年才能真正掌握。许多手工艺品都有大师/熟练工/学徒的等级制度。所以也许没有人<i>愿意</i>成为学徒，但说经历过长达十年学习经历的人应该从事与刚从学校毕业的人不同的工作，这也许并不疯狂。</p><p class="normal"><b>Seibel:</b> I'm surprised you think the master-programmer model is such a dumb idea. In your “Teach Yourself Programming in Ten Years” essay you make the point that programming is a skill that, like many skills, probably takes about a decade to really master. And lots of crafts had master/journeymen/apprentice kind of hierarchies. So maybe nobody <i>wants</i> to be the apprentice, but maybe it isn't crazy to say that somebody who's been through that decade-long learning experience should be doing different work than someone who's fresh out of school.</p>
<p class="normal"><b>Norvig：</b>我认为学徒方法最好的部分是你可以看到大师，我希望看到更多。所以我想这是结对编程的另一种用途。我可以看出，如果你没有经验，那么观看经验丰富的人会非常好。特别是对于那些没有教得那么多的东西，比如调试技巧。任何人都可以学习算法等等，但他们并没有真正教调试和观察某人，然后说，“哇，我从没想过要那样做，”这真的很有用。</p><p class="normal"><b>Norvig:</b> I think the best part of the apprentice approach is that you get to watch the master, and I would like to see more of that. So I guess that's another use of pair programming. I can see that it'd be really good, if you were inexperienced, to watch somebody who's much more experienced. Particularly for the types of things that aren't taught as much, like debugging skills. Anybody can learn algorithms and so on, but they don't really teach debugging and watching someone, and saying, “Wow, I never thought of doing that,” that's really useful.</p>
<p class="normal">不过我觉得你们之所以有师徒，有一部分原因是因为材料比较稀有。当你做金匠的时候，只有这么多的金子。或者当外科医生在做手术时，只有一颗心脏，所以你想要最好的人来做这件事，而你希望其他人只是帮忙。使用编码，它不是那样的。你有很多终端。你有很多键盘。你不必配给它。</p><p class="normal">But I think part of the reasons why you had master and apprentice is because the materials were rarer. When you were doing goldsmithing, there's only so much gold. Or when the surgeon's operating, there's only one heart, and so you want the best person on that and you want the other guys just helping. With coding, it's not like that. You've got plenty of terminals. You've got plenty of keyboards. You don't have to ration it.</p>
<p class="normal"><b>Seibel：</b>说到没有教得那么多的东西，你既是学术界的又是工业界的；你觉得学术计算机科学和工业编程在正确的地方相遇吗？</p><p class="normal"><b>Seibel:</b> Speaking of things that aren't taught as much, you've been both an academic and in industry; do you feel like academic computer science and industrial programming meet in the right place?</p>
<p class="normal"><b>Norvig：</b>这是个大问题。我不认为计算机科学课程中有很多浪费。我认为这主要是非常好的知识。我认为<a id="OEBPS/Chapter08.html.page_296"></a>上学是有用的，但它并不是你在行业中取得成功或构建系统所需的一切。我确实认为许多学校的课程适应缓慢。这在很多地方都发挥了作用：学校里并没有教太多关于团队合作的知识。这种能够将各个部分组合在一起的想法并没有真正被教导，但无论如何孩子们都会以某种方式接受它，所以也许这没关系。在谷歌，我们当然对这种大规模云计算、并行计算等很感兴趣。虽然我认为人们对此很感兴趣，但并没有教太多。所以我认为他们落后了一点，但我认为它仍然有用。</p><p class="normal"><b>Norvig:</b> It's a big question. I don't think there's a lot of waste in computer-science curriculum. I think that it's mostly very good stuff to know. I think <a></a>going to school is useful, but it's not everything that you need to be successful in the industry or to build systems. I do think that curriculum in many schools has been slow to adapt. There are a number of places where that comes into play: working in a team is not taught so much in school. This idea of being able to put the pieces together is not really taught there, but somehow the kids pick it up anyway, so maybe that's OK. At Google we're certainly interested in this large-scale cloud computing, parallel computing, and so forth. That's not taught so much, although I think there's a lot of interest in it. So I think they lag behind a little bit, but I think it's still useful.</p>
<p class="normal"><b>Seibel：</b>学术界是否有领先于工业界的领域？行业忽略了关于我们应该如何构建软件的好东西。</p><p class="normal"><b>Seibel:</b> And are there any areas where academics are out in front of industry? Where industry is ignoring good stuff about how we ought to build software.</p>
<p class="normal"><b>挪威：</b>我认为在某种程度上。最好的例子可能是模型检查，英特尔并没有真正关注这些地方，然后他们召回了这次大事件，他们损失了很多钱，因为他们的乘法有一个错误。然后他们开始注意，他们去找一位学者说，“你能帮我们做什么？” 所以那里确实有东西。现在它是他们所做工作不可或缺的一部分，所以这是一个很好的例子。看起来像编程语言，可能不是那么多。有很多工作正在进行，但您看不到新编程语言的重大影响。操作系统，一点点。我们与 Dave Patterson 等一起支持伯克利的 RAD 实验室。他们有一些好主意——如何制作可靠的系统。但可以肯定的是，该行业拥有更大的，更大的问题。他们可能没有所有的答案——但他们比在大学环境中对他们的打击更大。</p><p class="normal"><b>Norvig:</b> I think to some degree. Probably the best example was the model checking where Intel wasn't really paying much attention and then they had this big recall and they lost a lot of money because they had a bug in their multiply. And then they started to pay attention, and they went to an academic and said, “What can you do to help us?” So there actually was something there. And now it's an integral part of what they do, so that was a good example. It seems like programming languages, probably not so much. There's a lot of work going on but you don't see a big impact of the newer programming languages. Operating systems, a little bit. We're supporting this RAD Lab at Berkeley with Dave Patterson and so on. They have some good ideas—how to make reliable systems. But it's certainly the case that industry has the larger, bigger problems. They may not have all the answers to them—but they're hitting them harder than in the university setting.</p>
<p class="normal"><b>Seibel：</b>所以你不认为学术界有任何想法没有被工业界采纳仅仅是因为人们抵制某些类型的变化——也许一代自学成才的 PHP 程序员甚至永远不会对 Haskell 产生好感这是否是编写软件的更好方法？</p><p class="normal"><b>Seibel:</b> So you don't think there are any ideas floating around academia that haven't been picked up by industry simply because people resist certain kinds of change—maybe a generation of self-taught PHP programmers are never going to warm to Haskell even if it might be a better way to write software?</p>
<p class="normal"><b>Norvig：</b>我想我很怀疑。我认为如果有真正的优势，人们就会利用它们。我不认为这是一个完美的信息市场，一切都立即转向最优<a id="OEBPS/Chapter08.html.page_297"></a>解决方案，但我认为它近似于此。学术界可能没有看到该行业必须处理的全部问题。部分原因是教育问题，但如果你有一群程序员不了解 monad 是什么，也没有上过范畴论课程，那就有差距了。</p><p class="normal"><b>Norvig:</b> I guess I'm pretty skeptical. I think that if there were real advantages, people would be taking advantage of them. I don't think it's a perfect information market where everything instantly moves to the optimal <a></a>solution, but I think it approximates that. Academics may be not seeing the whole problem that the industry has to deal with. And part of it is an education problem, but if you have a bunch of programmers who don't understand what a monad is and haven't taken courses in category theory, there's a gap.</p>
<p class="normal">部分原因是我们拥有所有这些系统，你不能一下子把它们全部扔掉，所以有一个过渡。我敢肯定，在某些地方，行业应该更具前瞻性地说，“当然，我们今天无法实现这种转变，但我们应该有一个计划，说明十年后我们会达到什么水平？它不会是我们现在所在的位置，我们如何到达那里？”</p><p class="normal">And part of it's this legacy of we've got all these systems and you can't just throw them out all at once, so there's a transition. I'm sure there are places where industry should be more forward-looking about saying, “Sure, we can't make that transition today, but we should have a plan to say where are we going to be in ten years? It's not going to be where we are now and how do we get there?”</p>
<p class="normal">但是您希望在将产生重大影响的领域进行改进。而且我认为很多时候，编程语言所关注的水平可能太低，无法产生语言设计者认为的那样大的影响。所以如果他们说，“哦，看，在我闪亮的新语言中，这六行代码变成了两行代码。” 嗯，是的，这很好，我想这会让你更有效率，更容易调试和维护等等。但也许你编写的代码只是整个生产系统的一小部分，真正让人头疼的是每天更新你的数据，抓取网络并将这些新数据放入，并将其放入正确的格式。所以你必须记住你'</p><p class="normal">But you want improvements in areas that are going to make a big impact. And I think a lot of the times the level that programming languages are looking at is maybe too low a level to have as big an impact as language designers think it's going to. So if they say, “Oh look, in my shiny new language, these six lines of code become two lines of code.” Well yeah, that's nice, and I guess that makes you more productive and it's easier to debug and maintain and so on. But maybe the code that you write is just a small part of the whole production system, and really the big headache is updating your data every day, and scraping the Web and getting this new data in, and putting it in the right format. So you have to remember that you're solving a very small part of the overall problem and that means there has to be a big barrier to make it worthwhile to make a switch.</p>
<p class="normal"><b>Seibel：</b>所以撇开实用语言研究不谈，你会觉得自从计算机科学就像主修 IBM 以来，我们已经走了一段路。</p><p class="normal"><b>Seibel:</b> So leaving aside the utility language research, you feel like we have come a ways since computer science was like majoring in IBM.</p>
<p class="normal"><b>诺维格：</b>是的。我认为现在这是一个很好的课程，令人沮丧的是它没有被很多学生采用。报名人数下降。当然，有一类人就是非常喜欢计算机或计算机设计，以至于他们最终会走向那里。我们坚持那个小组。但是后来有一群最优秀和最聪明的人进入物理学或生物学或其他领域，因为这些是最热门的领域。然后有一群人说，“好吧，我有点喜欢电脑，但它没有前途，因为无论如何所有的工作都外包给了印度，所以我打算做法律预科或其他什么，这样我就可以得到一个工作。” 我认为这是一种耻辱。我认为他们被误导了。</p><p class="normal"><b>Norvig:</b> Yeah. I think it's a good curriculum now, and it's depressing that it's not being taken up by many students. Enrollments are down. Certainly there is a class of people who just love computers or computer design so much that that's where they end up. We're holding onto that group. But then there's a bunch of the best and the brightest who are going into physics or biology or something because those are the hottest fields. And then there's a bunch who are saying, “Well, I kind of like computers but there's no future in it because all of the jobs are outsourced to India anyway, so I'm going to do prelaw or something else so I can get a job.” And I think that's a shame. I think they've been misinformed.</p>
<p class="normal"><a id="OEBPS/Chapter08.html.page_298"></a><b>Seibel：</b>你是说这是一种耻辱，因为你认为很多人会喜欢当程序员，或者因为我们需要他们？</p><p class="normal"><a></a><b>Seibel:</b> You mean it's a shame because you think a lot of those people would enjoy being programmers, or because we need them?</p>
<p class="normal"><b>诺维格：</b>两者都有。许多人可以享受很多不同的事物，如果他们同样享受两种事物，我不想说他们必须从事计算机科学。但我认为存在不匹配。我们需要更多优秀的人才，我认为他们可以对世界产生重大影响，如果这是他们想要实现的目标，从理性上讲，我们应该比现在分配更多的顶尖人才进入计算机科学领域。</p><p class="normal"><b>Norvig:</b> Both. Many people could enjoy lots of different things and if they enjoy two equally I don't want to say that they have to do computer science. But I think there is a mismatch. We need more good people and I think that they can have a big impact on the world and if that's what they want to accomplish, rationally we should be allocating more of the top people into computer science than we are now.</p>
<p class="normal"><b>Seibel：</b> Dijkstra 在他的一篇论文中谈到计算机科学是数学的一个分支，以及计算机科学专业的学生在接受教育的前<i>n</i>年甚至不应该接触计算机，而是应该学习操纵形式符号系统。您认为要成为一名称职的程序员需要多少数学知识？</p><p class="normal"><b>Seibel:</b> In one of his papers Dijkstra talks about how computer science is a branch of mathematics and how computer-science students shouldn't even touch a computer for the first <i>n</i> years of their education and should instead learn to manipulate systems of formal symbols. How much mathematics do you think is required to be a competent programmer?</p>
<p class="normal"><b>Norvig：</b>我认为您不需要完整的 Dijkstra 级别。这是他关注的一种特殊类型的数学。它是离散的、合乎逻辑的证明。我想我来自一个不太重要的领域，它更具概率性而非逻辑性。我很少有一个程序可以证明是正确的。</p><p class="normal"><b>Norvig:</b> I don't think you need the full Dijkstra level. And it's a particular type of math that he focuses on. It's discrete, logical proofs. I guess I'm coming from an area where that's less important and it's more probabilistic rather than logical. I rarely have a program that I can prove correct.</p>
<p class="normal">谷歌是正确的吗？好吧，输入这些词，你会得到十页。如果它崩溃了，那么它就是不正确的，但是如果它返回给您的是这十个链接而不是那十个链接，则不能说一个是正确的。你可以对哪个比另一个更好有意见，但你不能超越那个。我认为这与他的想法完全不同。我认为一旦你开始解决这些类型的问题或者让机器人汽车在城市中行驶而不撞到任何人的问题，逻辑证据很快就会被抛出。</p><p class="normal">Is Google correct? Well, type in these words, you get back ten pages. If it crashes, then it's incorrect but if it gives you back these ten links rather than those ten links, there's no saying that one is right. You can have opinions on which are better than the other, but you can't go beyond that. I think that's quite different than what he had in mind. I think once you start solving these types of problems or the problem of having a robot car navigate through a city without hitting anybody, the logical proof gets thrown out pretty quickly.</p>
<p class="normal"><b>Seibel：</b>那么成为一名优秀的程序员需要具备什么基本技能吗？不同的领域显然有不同的要求，但无论领域如何，最终编写代码是否有一些共性？</p><p class="normal"><b>Seibel:</b> So is there any essential skill needed to be a good programmer? Different domains obviously have different requirements but ultimately is there some commonality to writing code regardless of the domain?</p>
<p class="normal"><b>Norvig：</b>你必须能够取得进步，然后再改进它。这就是你在生活中需要做的一切。你必须有一些想法并说，“这是前进的方向，”然后能够说，“现在我必须完善它。” 改进可以是，“我没有完全正确；有些情况我没有处理过，”或者可能是，“现在我理解得更好了，我<a id="OEBPS/Chapter08.html.page_299"></a>打算编写一个工具，使其更抽象，下次我可以更轻松地编写这样的系统。” 我想这是一种内省的程度，可以说，“我要去哪里？我是怎么到那里的？有没有更好的方法到达那里？</p><p class="normal"><b>Norvig:</b> You've got to be able to make progress and then improve on it. That's all you need to be able to do in life. You've got to have some idea and say, “Here's the direction to go,” and then be able to say, “Now I've got to refine it.” And refinement can be, “I didn't quite get it right; there are cases I didn't handle,” or it can be, “Now that I understand it better, I'm <a></a>going to write a tool so that it's more abstract and next time I can write a system like this more easily.” Which I guess is that level of introspection to say, “Where was I going? How did I get there? Is there a better way to get there?”</p>
<p class="normal"><b>Seibel：</b>所以你认为那种技能——本质上是成功的；调试它；迭代——是一种很多人都应该学习的思维方式，即使是那些最终不会成为程序员的人也是如此？如果你正在制作小学或初中或高中的课程，你想让每个人都接触到编程的想法吗？或者它是一项过于专业的技能？</p><p class="normal"><b>Seibel:</b> So do you think that that skill—essentially make it; debug it; iterate—is a kind of thinking that lots of people should learn, even people who aren't going to ultimately be programmers? If you were making a grade-school or junior-high or high-school curriculum, would you want everyone to be exposed to the idea of programming? Or is it too specialized a skill?</p>
<p class="normal"><b>Norvig：</b>我认为它很专业。我认为这是这种思维的一个例子。但如果你能举出其他例子，比如某种机械问题，我也会很高兴。“这里有一堆碎片。我怎样才能把一些水从这里移到这里，然后放到这个杯子里呢？” 它不必操纵代码行。它可以操纵多种零件并查看它们如何协同工作。</p><p class="normal"><b>Norvig:</b> I think it's specialized. I think it's one example of this type of thinking. But I'd be just as happy if you brought other examples like some type of mechanical problem. “Here's a bunch of pieces. How can I move some water from here to here and get it into this cup?” It doesn't have to be manipulating lines of code. It could be manipulating many kinds of pieces and seeing how they work together.</p>
<p class="normal"><b>Seibel：</b>程序员应该走多远？在“十年自学编程”中，您谈到了解执行指令与从磁盘读取等需要多长时间。我们还需要学习汇编吗？</p><p class="normal"><b>Seibel:</b> And how far down should programmers go? In “Teach Yourself Programming in Ten Years,” you talk about knowing how long it takes to execute an instruction vs. reading from disk and so on. Do we still need to learn assembly?</p>
<p class="normal"><b>诺维格：</b>我不知道。Knuth 说，一切都用汇编来做，因为用 C 写太低效了。我不同意。我认为您想知道的足够多，知道哪些指令效率低下，但这不再是单个指令的级别。这不仅仅是因为这是一个三指令序列而不是两个指令序列。它是，您是否有页面错误或缓存未命中？我认为我们不需要了解汇编语言。你需要架构。您应该了解什么是汇编语言，并且您应该了解存在内存层次结构，从层次结构的一个级别到下一个级别的缺失是一个很大的性能损失。但我认为你可以在抽象层面上理解这一点。</p><p class="normal"><b>Norvig:</b> I don't know. Knuth said, do everything in assembly, because it's just too inefficient to write in C. I don't agree with that. I think you want to know enough to know what instructions are inefficient, but that's no longer at the level of individual instructions. It's not just that this was a three-instruction sequence rather than a two-instruction sequence. It's, did you have a page fault or a cache miss? I don't think we need to know assembly language. You need architecture. You should understand what assembly language is, and you should understand that there's a memory hierarchy and missing from one level of the hierarchy to the next is a big performance penalty. But I think you can understand that at the abstract level.</p>
<p class="normal"><b>Seibel：</b>您认为所有程序员都应该阅读哪些书籍？</p><p class="normal"><b>Seibel:</b> Are there any books that you think all programmers should read?</p>
<p class="normal"><b>Norvig：</b>我认为有很多选择。我不认为只有一条路。你必须阅读一些算法书。你不能只选择这些<a id="OEBPS/Chapter08.html.page_300"></a>东西拿出来贴在一起。可能是 Knuth，也可能是 Cormen、Leiserson 和 Rivest。还有其他人。Sally Goldman 现在就在这里。她出版了一本关于算法的更实用的新书。我认为这很有趣。所以你需要其中之一。你需要一些关于抽象思想的东西。我喜欢阿贝尔森和萨斯曼。还有其他人。</p><p class="normal"><b>Norvig:</b> I think there are a lot of choices. I don't think there's only one path. You've got to read some algorithm book. You can't just pick these <a></a>things out and paste them together. It could be Knuth, or it could be the Cormen, Leiserson, and Rivest. And there are others. Sally Goldman's here now. She has a new book out that's a more practical take on algorithms. I think that's pretty interesting. So you need one of those. You need something on the ideas of abstraction. I like Abelson and Sussman. There are others.</p>
<p class="normal">你需要很好地了解你的语言。阅读参考。阅读有关语言机制以及调试和测试整个企业的书籍：<i>Code Complete</i>或类似的书籍。但我认为有很多不同的路径。我不想说你必须读一套书。</p><p class="normal">You need to know your language well. Read the reference. Read the books that tell you both the mechanics of language and the whole enterprise of debugging and testing: <i>Code Complete</i> or some equivalent of that. But I think there are a lot of different paths. I don't want to say you have to read one set of books.</p>
<p class="normal"><b>Seibel：</b>虽然你现在的工作不需要大量编程，但你仍然为网站上的论文编写程序。当您编写这些小程序时，您是如何处理的？</p><p class="normal"><b>Seibel:</b> Though your job now doesn't entail a lot of programming you still write programs for the essays on your web site. When you're writing these little programs, how do you approach it?</p>
<p class="normal"><b>Norvig：</b>我认为最重要的事情之一就是能够同时将所有内容记在脑海中。如果你能做到这一点，你就有更大的成功机会。这使得小程序更容易。对于更大的程序，您需要额外的工具来处理它。</p><p class="normal"><b>Norvig:</b> I think one of the most important things is being able to keep everything in your head at once. If you can do that you have a much better chance of being successful. That makes a small program easier. For a bigger program, you need extra tools to be able to handle that.</p>
<p class="normal">知道自己在做什么也很重要。当我写我的数独解算器时，一些博主对此发表了评论。他们说，“看看对比——这是 Norvig 的数独游戏，然后是另一个人，”我忘记了他的名字，他是这些测试驱动设计大师之一。他开始说，“好吧，我要做数独，我要上这门课，我要做的第一件事就是写一堆测试。” 但后来他一无所获。他有五篇不同的博客文章，在每一篇中他都写了一点点，写了很多测试，但他从来没有得到任何工作，因为他不知道如何解决问题。</p><p class="normal">It's also important to know what you're doing. When I wrote my Sudoku solver, some bloggers commented on that. They said, “Look at the contrast—here's Norvig's Sudoku thing and then there's this other guy,” whose name I've forgotten, one of these test-driven design gurus. He starts off and he says, “Well, I'm going to do Sudoku and I'm going to have this class and first thing I'm going to do is write a bunch of tests.” But then he never got anywhere. He had five different blog posts and in each one he wrote a little bit more and wrote lots of tests but he never got anything working because he didn't know how to solve the problem.</p>
<p class="normal">实际上，我从 AI 那里知道，嗯，有约束传播这个领域——我知道它是如何工作的。有一个递归搜索领域——我知道它是如何工作的。我可以看到，从一开始，你就把这两个放在一起，你就可以解决这个数独问题。他不知道这一点，所以他有点在黑暗中犯了错误，尽管他的所有代码都“有效”，因为他有所有这些测试用例。</p><p class="normal">I actually knew—from AI—that, well, there's this field of constraint propagation—I know how that works. There's this field of recursive search—I know how that works. And I could see, right from the start, you put these two together, and you could solve this Sudoku thing. He didn't know that so he was sort of blundering in the dark even though all his code “worked” because he had all these test cases.</p>
<p class="normal"><a id="OEBPS/Chapter08.html.page_301"></a>然后博客们就这意味着什么来回争论。我不认为它有什么意义——我认为测试驱动设计很棒。我这样做比以前多了很多。但是你可以测试所有你想要的，如果你不知道如何解决问题，你就不会得到解决方案。</p><p class="normal"><a></a>Then bloggers were arguing back and forth about what this means. I don't think it means much of anything—I think test-driven design is great. I do that a lot more than I used to do. But you can test all you want and if you don't know how to approach the problem, you're not going to get a solution.</p>
<p class="normal"><b>Seibel：</b>那么问题是，他怎么知道的？他应该去攻读博士学位并专攻人工智能吗？你不可能知道每一种算法。现在你有谷歌，但找到解决问题的正确方法与寻找网络框架有点不同。</p><p class="normal"><b>Seibel:</b> So then the question is, how should he have known that? Should he have gone and gotten a PhD and specialized in artificial intelligence? You can't know every algorithm. These days you have Google, but finding the right approach to a problem is a little different than finding a web framework.</p>
<p class="normal"><b>Norvig：</b>你怎么知道你不知道的？</p><p class="normal"><b>Norvig:</b> How do you know what you don't know?</p>
<p class="normal"><b>塞贝尔：</b>没错。</p><p class="normal"><b>Seibel:</b> Exactly.</p>
<p class="normal"><b>Norvig：</b>所以我想它分为两部分。一个是认识到也许有一个已知的解决方案。你可以说，“好吧，没有人可能知道如何做到这一点，所以随机探索和其他一切一样好。” 这是一种可能。另一种可能性是，“好吧，可能有人知道怎么做。我只是不知道用什么词来形容它，所以我必须去发现那些词。” 我想这在一定程度上只是直觉，并且说，“这似乎是人工智能知识体系中应该包含的那种东西。” 然后你必须弄清楚，我如何找到它？也许他可以在数独上搜索并找到它。也许他认为那是作弊。我不知道。</p><p class="normal"><b>Norvig:</b> So I guess it's two parts. One is to recognize that maybe there is a known solution to this. You could say, “Well, nobody could possibly know how to do this, so just exploring randomly is as good as everything else.” That's one possibility. The other possibility is, “Well, probably somebody does know how to do this. I just don't know what the words are for it, so I have to discover those.” I guess that's partly just intuition and saying, “It seems like the kind of thing that should be in the body of knowledge from AI.” And then you have to figure out, how do I find it? And probably he could've done a search on Sudoku and found it that way. Maybe he thought that was cheating. I don't know.</p>
<p class="normal"><b>Seibel：</b>所以我们可以说这<i>是</i>作弊——假设您是第一个尝试解决数独问题的人。您最终使用的技术仍会在那里等待应用。</p><p class="normal"><b>Seibel:</b> So let's say that <i>is</i> cheating—say you were the first person ever to try and solve Sudoku. The techniques that you ended up using would still have been out there waiting to be applied.</p>
<p class="normal"><b>Norvig：</b>假设我想解决一些生物学问题。我不知道做基因测序或其他什么的最好的算法是什么。但我很清楚有这样的算法。然后我就可以开始四处看看了。在另一个层面上，其中一些东西非常基础——如果您不知道什么是动态规划，那么您将处于严重的劣势。它会一次又一次地出现。如果您不了解搜索的一般概念——您可以做出选择并在不需要时返回。这些都是来自的想法<a id="OEBPS/Chapter08.html.page_302"></a>60 年代。人们只是在编程几年后才发现这些东西。似乎这是每个人都应该知道的事情。去年发现的一些东西，应该不是每个人都知道。</p><p class="normal"><b>Norvig:</b> Let's say I wanted to solve some problem in biology. I wouldn't know what the best algorithms were for doing gene sequencing or whatever. But I'd have a pretty good idea that there were such algorithms. Then I could start looking around. At another level, some of these things are pretty fundamental—if you don't know what dynamic programming is, then you're at a severe disadvantage. It's going to come up time and time again. If you don't know this idea of search in general—that you can make a choice and backtrack when you don't need it. These are all ideas from the <a></a>'60s. It was only a few years into programming that people discovered these things. It seems like that's the type of thing that everyone should know. Some things that were discovered last year, not everybody should know.</p>
<p class="normal"><b>Seibel：</b>那么程序员应该回去阅读所有旧论文吗？</p><p class="normal"><b>Seibel:</b> So should programmers go back and read all the old papers?</p>
<p class="normal"><b>Norvig：</b>不，因为有很多错误的开始和很多合并，两个不同的领域开发出完全不同的技术和术语，然后他们发现他们实际上在做同样的事情。我认为你宁愿从现代的角度来讲述一个故事，也不愿遵循所有的步骤。但你应该拥有它们。我不知道这方面最好的书是什么，因为我是通过艰难的方式零碎地学习的。</p><p class="normal"><b>Norvig:</b> No, because there are lots of false starts and lots of mergers where two different fields develop completely different technology and terminology, and then they discover they were really doing the same thing. I think you'd rather have a story from the modern point of view rather than have to follow all the steps. But you should have them. I don't know what the best books are for that since I picked it up the hard way, piecemeal.</p>
<p class="normal"><b>Seibel：</b>回到设计软件。如果您正在处理更大的程序，您将无法记住所有代码是如何组合在一起的，那该怎么办？那你怎么设计呢？</p><p class="normal"><b>Seibel:</b> So back to designing software. What about when you're working on bigger programs, where you're not going to be able to just remember how all the code fits together? Then how do you design it?</p>
<p class="normal"><b>挪威：</b>我认为您希望在整个系统设计级别拥有良好的文档。事情应该做什么，它将如何做？每种方法的文档通常比它需要的更乏味。大多数情况下，它只是复制您可以从函数名称和参数中读取的内容。但是，要做什么的总体设计，首先要进行布局非常重要。它必须是每个人都能理解的东西，也必须是正确的选择。拥有一个成功的项目最重要的事情之一就是拥有足够经验的人来构建正确的东西。除此之外，如果它是你以前没有构建过的东西，你不知道该怎么做，</p><p class="normal"><b>Norvig:</b> I think you want to have good documentation at the level of over-all system design. What's the thing supposed to do and how's it going to do it? Documentation for every method is usually more tedious than it needs to be. Most of the time it just duplicates what you could read from the name of the function and the parameters. But the overall design of what's going to do what, that's really important to lay out first. It's got to be something that everybody understands and it's also got to be the right choice. One of the most important things for having a successful project is having people that have enough experience that they build the right thing. And barring that, if it's something that you haven't built before, that you don't know how to do, then the next best thing you can do is to be flexible enough that if you build the wrong thing you can adjust.</p>
<p class="normal"><b>Seibel：</b>你认为你可以坐下来弄清楚一些东西应该如何工作，假设它不是你以前建造的东西？您是否需要开始编写代码才能真正了解问题所在？</p><p class="normal"><b>Seibel:</b> How much do you think you can sit down and figure out how something ought to work, assuming it's not something that you've built before? Do you need to start writing code in order to really understand what the problem is?</p>
<p class="normal"><b>Norvig：</b>一种思考方式是倒退。你想达到一个最终状态，在那里你有一些好的东西，而对于某些问题，大致只有一件事是好的。对于其他问题，大约有数百万个，你可以朝很多不同的方向前进，它们都是<a id="OEBPS/Chapter08.html.page_303"></a>大致相同。所以我认为这取决于你遇到的是哪种类型的问题。</p><p class="normal"><b>Norvig:</b> One way to think about it is going backwards. You want to get to an end state where you have something that's good and for some problems there's roughly one thing that's good. For other problems there are roughly millions and you can go in lots of different directions and they'd all be <a></a>roughly the same. So I think it's different depending on which of those types of problems you have.</p>
<p class="normal">然后你要考虑哪些是困难的选择，哪些是简单的选择。如果您做出了错误的架构选择——如果您遇到了内置限制，或者如果您只是在构建错误的东西，那么什么事情会真正地把您搞砸。在谷歌，我认为我们遇到了所有这些类型的问题。一直存在缩放问题。如果你看看我们今天的处境并说，我们将建造比这多十倍的东西，几年后你就会超过它，你必须扔掉它并重新开始。但是您至少要为您选择的操作条件做出正确的选择——您将处理十亿到一百亿个网页或其他内容。那么，就如何将其分发到多台机器而言，这意味着什么？你要来回走什么样的交通？你必须在那个层面上有一个令人信服的故事。其中一些你可以通过信封背面的计算来完成，一些你可以通过模拟来完成，还有一些你必须预测未来。</p><p class="normal">Then you want to think about what are the difficult choices vs. what are the easy ones. What's going to come back to really screw you if you make the wrong architectural choice—if you hit built-in limitations or if you're just building the wrong thing. At Google I think we run up against all these types of problems. There's constantly a scaling problem. If you look at where we are today and say, we'll build something that can handle ten times more than that, in a couple years you'll have exceeded that and you have to throw it out and start all over again. But you want to at least make the right choice for the operating conditions that you've chosen—you'll work for a billion up to ten billion web pages or something. So what does that mean in terms of how you distribute it over multiple machines? What kind of traffic are you going to have going back and forth? You have to have a convincing story at that level. Some of that you can do with calculations on the back of the envelope, some of that you can do with simulations, and some of that you have to predict the future.</p>
<p class="normal"><b>Seibel：</b>对于这类问题，与编写代码相比，通过粗略计算或模拟，您似乎更有可能正确回答。</p><p class="normal"><b>Seibel:</b> It seems for that kind of question you'll be far more likely to answer correctly with either back-of-the-envelope calculations or simulation than writing code.</p>
<p class="normal"><b>Norvig：</b>是的，我认为是的。这些是计算可能是更好方法的事情。然后有一些供应商的这些问题说他们明年将推出一个交换机，可以处理十倍的流量；你为此设计吗？你相信他们吗？或者你设计你今天拥有的东西？那里有很多权衡取舍。</p><p class="normal"><b>Norvig:</b> Yeah, I think that's right. Those are the kind of things where the calculations are probably a better approach. And then there are these issues of some vendor says they're going to have a switch coming out next year that will handle ten times as much traffic; do you design to that? Do you believe them? Or do you design to what you have today? There are a lot of trade-offs there.</p>
<p class="normal">然后是用户界面的东西，你在构建它之前是不知道的。您认为这种交互会很棒，但随后您将其展示给用户，但一半的用户就是无法理解。然后你必须回溯并想出一些新的东西。</p><p class="normal">Then there are user-interface things where you just don't know until you build it. You think this interaction will be great but then you show it to the user and half the users just can't get it. Then you have to backtrack and come up with something new.</p>
<p class="normal"><b>Seibel：</b>撇开设计用户交互不谈，原型设计什么时候有价值？而不是仅仅考虑某事将如何运作？</p><p class="normal"><b>Seibel:</b> Leaving aside designing user interactions, when is prototyping valuable? As opposed to just thinking about how something is going to work?</p>
<p class="normal"><a id="OEBPS/Chapter08.html.page_304"></a><b>Norvig：</b>我认为想象解决方案很有用，看看它是否会奏效。看看它是否舒适很有用。您需要一组工具来帮助您构建您现在必须构建的东西，并帮助您随着时间的推移改进系统。而且，如果您开始制作原型并突然感觉很笨拙，那么您可能得到了错误的原语集。尽快知道这一点会很好。</p><p class="normal"><a></a><b>Norvig:</b> I think it's useful to imagine the solution, to see if it's going to work. It's useful to see if it feels comfortable. You want a set of tools that are going to help you build what you have to build now and are going to help you evolve the system over time. And if you start out prototyping and all the sudden it feels clunky, then maybe you've got the wrong set of primitives. It'd be good to know that as soon as possible.</p>
<p class="normal"><b>Seibel：</b>使用测试来驱动设计的想法怎么样？</p><p class="normal"><b>Seibel:</b> What about the idea of using tests to drive design?</p>
<p class="normal"><b>Norvig：</b>我更多地将测试视为一种纠正错误的方式，而不是一种设计方式。这种极端的方法说，“好吧，你做的第一件事就是写一个测试，说我最后得到了正确的答案，”然后你运行它，看到它失败了，然后你说，“我该怎么办？需要下一个吗？”——这对我来说似乎不是设计东西的正确方法。</p><p class="normal"><b>Norvig:</b> I see tests more as a way of correcting errors rather than as a way of design. This extreme approach of saying, “Well, the first thing you do is write a test that says I get the right answer at the end,” and then you run it and see that it fails, and then you say, “What do I need next?”—that doesn't seem like the right way to design something to me.</p>
<p class="normal">似乎只有当解决方案如此简单以至于预定的时候才有意义。我认为你必须先考虑一下。你必须说，“这些碎片是什么？在我知道其中一些是什么之前，我怎么能为片段编写测试呢？” 然后，一旦你完成了这些，那么对这些部分中的每一个进行测试并很好地理解它们如何相互作用以及边界情况等是一个很好的纪律。那些都应该有测试。但我不认为你通过说“这个测试失败了”来推动整个设计。</p><p class="normal">It seems like only if it was so simple that the solution was preordained would that make sense. I think you have to think about it first. You have to say, “What are the pieces? How can I write tests for pieces until I know what some of them are?” And then, once you've done that, then it is good discipline to have tests for each of those pieces and to understand well how they interact with each other and the boundary cases and so on. Those should all have tests. But I don't think you drive the whole design by saying, “This test has failed.”</p>
<p class="normal">我不喜欢的另一件事是我们在谷歌遇到的很多事情都不适合这个简单的布尔测试模型。你看看这些测试套件，它们有<code>assertEqual</code>等等。这很有用，但我们也希望拥有并断言这个包含可能查询的大型数据库，我们得到的结果的分数是某某的精度值和某某某某的召回值，我们想对其进行优化。而且他们没有您要优化的这些统计或连续值，而不仅仅是布尔值“这是对还是错？”<code>assertNotEqual</code><code>assertTrue</code><code>assertAsFastAsPossible</code></p><p class="normal">The other thing I don't like is a lot of the things we run up against at Google don't fit this simple Boolean model of test. You look at these test suites and they have <code>assertEqual</code> and <code>assertNotEqual</code> and <code>assertTrue</code> and so on. And that's useful but we also want to have <code>assertAsFastAsPossible</code> and assert over this large database of possible queries we get results whose score is precision value of such and such and recall value of such and such and we'd like to optimize that. And they don't have these kinds of statistical or continuous values that you're trying to optimize, rather than just having a Boolean “Is this right or wrong?”</p>
<p class="normal"><b>Seibel：</b>但最终所有这些都可以转换为布尔值——运行一系列查询并捕获所有这些值，看看它们是否都在您想要的容差范围内。</p><p class="normal"><b>Seibel:</b> But ultimately all of those can get converted into Booleans—run a bunch of queries and capture all those values and see if they're all within the tolerances that you want.</p>
<p class="normal"><a id="OEBPS/Chapter08.html.page_305"></a><b>诺维格：</b>你可以。但是您可以从测试套件为您提供的方法中看出，他们没有设置这样做，他们没有考虑过这种可能性。我对这种方法在谷歌的接受程度感到惊讶——当我在 Junglee 时，我记得我不得不向 QA 团队传授这方面的知识。我们在做这个购物搜索时说，“我们想要测试一下，在这个查询中，我们希望得到 80% 的正确答案。” 所以他们说，“对！所以，如果答案错误，那就是错误，对吧？” 我说，“不，有一个错误的答案是可以的，只要它不是 80%。” 所以他们说，“所以错误的答案<i>不是</i>错误？” 好像那是仅有的两种可能性。没有人认为这更像是一种权衡。</p><p class="normal"><a></a><b>Norvig:</b> You could. But you can tell, just from the methods that the test suites give you, that they aren't set up to do that, they haven't thought about that as a possibility. I'm surprised at how much this type of approach is accepted at Google—when I was at Junglee I remember having to teach the QA team about it. We were doing this shopping search and saying, “We want a test where on this query we want to get 80 percent right answers.” And so they're saying, “Right! So if it's a wrong answer it's a bug, right?” And I said, “No, it's OK to have one wrong answer as long at it's not 80 percent.” So they say, “So a wrong answer's <i>not</i> a bug?” It was like those were the only two possibilities. There wasn't an idea that it's more of a trade-off.</p>
<p class="normal"><b>Seibel：</b>但你仍然相信单元测试。程序员应该如何考虑测试？</p><p class="normal"><b>Seibel:</b> But you are still a believer in unit tests. How should programmers think about testing?</p>
<p class="normal"><b>Norvig：</b>他们应该写很多测试。他们应该考虑不同的情况。而且我认为您希望进行更复杂的回归测试以及单元测试。想想故障模式——我记得我在编程方面得到的重要教训之一是当我出现在希思罗机场时，发生了电源故障，所有计算机都无法正常工作。但我的飞机准时到达。</p><p class="normal"><b>Norvig:</b> They should write lots of tests. They should think about different conditions. And I think you want to have more complex regression tests as well as the unit tests. And think about failure modes—I remember one of the great lessons I got about programming was when I showed up at the airport at Heathrow, and there was a power failure and none of the computers were working. But my plane was on time.</p>
<p class="normal">他们不知何故得到了所有航班的打印件。我不知道在哪里——一定有一些电脑不在现场。我不知道他们是在那天早上打印出来的，还是他们有一个程序，总是在前一天晚上打印出来，然后寄过去，每天有电的时候，他们就把它们扔掉。但不知何故，他们就在那里，门口的人有一个使用纸质备份而不是使用计算机系统的程序。</p><p class="normal">Somehow they had gotten print-outs of all the flights. I don't know where—there must have been some computer off-site. I don't know whether they printed them that morning or if they had a procedure of always printing them the night before and sending them over and every day when there is power they just throw them out. But somehow they were there and the people at the gates had a procedure for using the paper backup rather than using the computer system.</p>
<p class="normal">我认为这是软件设计的重要一课。我认为大多数程序员都不会考虑“在没有电源的情况下，我的程序运行得如何？”</p><p class="normal">I thought that was a great lesson in software design. I think most programmers don't think about, “How well does my program work when there's no power?”</p>
<p class="normal"><b>Seibel：</b>没有电时，Google 是如何工作的？</p><p class="normal"><b>Seibel:</b> How does Google work when there's no power?</p>
<p class="normal"><b>Norvig：</b>谷歌在没有电源的情况下不能很好地工作。但我们有备用电源和多个数据中心。我们确实会考虑，“当我的作品连接到的服务器出现故障时，它的工作情况如何？<a id="OEBPS/Chapter08.html.page_306"></a>或者当有其他类型的失败时？或者，“我在一千台机器上运行我的程序；如果他们中的一个死了怎么办？” 该计算如何在其他地方重新开始？</p><p class="normal"><b>Norvig:</b> Google does not work very well without power. But we have backup power and multiple data centers. And we do think in terms of, “How well does my piece work when the server it's connecting to is down <a></a>or when there are other sorts of failures?” Or, “I'm running my program on a thousand machines; what happens when one of them dies?” How does that computation get restarted somewhere else?</p>
<p class="normal"><b>Seibel：</b> Knuth 有一篇关于开发 TeX 的文章，他在文章中谈到转向这种纯粹的、破坏性的 QA 个性，并尽最大努力破坏他自己的代码。您认为大多数开发人员都擅长于此吗？</p><p class="normal"><b>Seibel:</b> Knuth has an essay about developing TeX where he talks about flipping over to this pure, destructive QA personality and doing his darnedest to break his own code. Do you think most developers are good at that?</p>
<p class="normal"><b>Norvig：</b>没有。我的拼写校正器中有一个这样的例子。我在代码中引入了一个错误来衡量我的表现，同时对实际代码进行了一些小改动。我运行了它，我得到了一个更好的分数，因为它的表现如何。我相信了！如果它的分数要差得多，我绝不会说：“哦，对真实函数的这个小改动一定会使它变得更糟。” 但我宁愿相信这个微小的改变会使分数变得更好，而不是持怀疑态度并说，“不，不可能有那么大的不同，一定是有其他问题。”</p><p class="normal"><b>Norvig:</b> No. And I had an example of that in my spelling corrector. I had introduced a bug in the code that measured how well I was doing and simultaneously had made some minor change in the real code. I ran it and I got back a much better score for how well it was doing. And I believed it! If it had been a much worse score I would have never said, “Oh, this minor change to the real function must have made it much worse.” But I was willing to believe this minor change made the score much better rather than being skeptical and saying, “Nah, couldn't have made that much difference, there must be something else wrong.”</p>
<p class="normal"><b>Seibel：</b>您如何避免过度概括和构建超出您需要的内容，从而避免以这种方式浪费资源？</p><p class="normal"><b>Seibel:</b> How do you avoid over-generalization and building more than you need and consequently wasting resources that way?</p>
<p class="normal"><b>Norvig：</b>这是一场战斗。围绕它有很多战斗。而且，我可能不是最好的提问者，因为我仍然喜欢优雅的解决方案而不是实用的解决方案。所以我不得不与自己作斗争并说，“在我的日常工作中，我不能那样想。” 我不得不说，“我们在这里提供最有意义的解决方案，如果有完美的解决方案，我们可能负担不起。” 我们不得不放弃并说，“我们现在要做最重要的事情。” 我必须将这一点灌输给自己和与我共事的人。德国有句谚语说完美是善的敌人；我忘记了它的确切来源——每个实际的工程师都必须吸取这一教训。</p><p class="normal"><b>Norvig:</b> It's a battle. There are lots of battles around that. And, I'm probably not the best person to ask because I still like having elegant solutions rather than practical solutions. So I have to sort of fight with myself and say, “In my day job I can't afford to think that way.” I have to say, “We're out here to provide the solution that makes the most sense and if there's a perfect solution out there, probably we can't afford to do it.” We have to give up on that and say, “We're just going to do what's the most important now.” And I have to instill that upon myself and on the people I work with. There's some saying in German about the perfect being the enemy of the good; I forget exactly where it comes from—every practical engineer has to learn that lesson.</p>
<p class="normal"><b>Seibel：</b>为什么解决一个我们实际上没有的问题如此诱人？</p><p class="normal"><b>Seibel:</b> Why is it so tempting to solve a problem we don't really have?</p>
<p class="normal"><b>Norvig：</b>你想要聪明，你想要结束；你想完成一些事情然后继续做其他事情。我认为人们生来只能处理一定数量的事情，你想说，“这是<a id="OEBPS/Chapter08.html.page_307"></a>完全完成；我可以把它从我的脑海中抹去，然后我可以继续。” 但是你必须计算，嗯，完全解决它的投资回报是多少？总是存在这种<i>S</i>形曲线，当您完成 80% 或 90% 时，您的收益开始递减。还有 100 件你可以做的事情就在曲线的底部，在那里你可以获得更好的回报。在某些时候你必须说，“够了，让我们停下来去做一些我们可以获得更好回报的事情。”</p><p class="normal"><b>Norvig:</b> You want to be clever and you want closure; you want to complete something and move on to something else. I think people are built to only handle a certain amount of stuff and you want to say, “This is <a></a>completely done; I can put it out of my mind and then I can go on.” But you have to calculate, well, what's the return on investment for solving it completely? There's always this sort of <i>S</i>-shaped curve and by the time you get up to 80 or 90 percent completion, you're starting to get diminishing returns. There are 100 other things you could be doing that are just at the bottom of the curve where you get much better returns. And at some point you have to say, “Enough is enough, let's stop and go do something where we get a better return.”</p>
<p class="normal"><b>Seibel：</b>程序员如何学会更好地识别他们在曲线上的位置？</p><p class="normal"><b>Seibel:</b> And how can programmers learn to better recognize where they are on that curve?</p>
<p class="normal"><b>Norvig：</b>我认为您设置了正确的环境，以结果为导向。我认为人们可以训练自己。你想优化，但让你自己优化你自己的舒适感，这与你真正应该优化的不同——有些人会说公司的投资回报，其他人会说你的客户满意度。你必须考虑，如果我在这个功能上的投入从 95% 增加到 100%，而不是在这 10 个其他的 0% 的功能上工作，这会给客户带来多少好处。</p><p class="normal"><b>Norvig:</b> I think you set the right environment, where it's results-oriented. And I think people can train themselves. You want to optimize, but left to yourself you optimize your own sense of comfort and that's different from what you really should be optimizing—some people would say return on investment for the company, others would say satisfaction of your customers. You have to think how much is it going to benefit the customer if I go from 95 percent to 100 percent on this feature vs. working on these ten other features that are at 0 percent.</p>
<p class="normal">在谷歌，我认为这很容易，因为我们有“尽早且经常发布”的理念。由于公司的运作方式，有多种原因：其一，我们的大部分产品不收取任何费用，所以很容易说，好吧，继续发货吧；他们能抱怨多少？另一个是我们不会在 CD 上盖章并将它们放入盒子中，因此如果今天有什么东西不完整，或者即使它有错误，也不是灾难。大多数软件都在我们的服务器上，所以我们明天就可以修复它，每个人都会立即得到更新。我们没有安装更新的噩梦。所以这让我们更容易说，“我们只是要发布一些东西，从用户那里得到一些反馈，修复需要修复的东西，不要担心其他的东西。”</p><p class="normal">At Google, I think it's easy because we have this “launch early and often” philosophy. And because of the way the company is, for a number of reasons: one, most of our products we don't charge any money for so it's easy to say, well, go ahead and ship it; how much could they complain? The other one is we're not stamping CDs and putting them in a box so if there's something that's not complete today or even if it has a bug, it's not a disaster. Most of the software is on our servers so we can fix it tomorrow and everybody gets the update instantly. We don't have this nightmare of installing updates. So it makes it easier for us to say, “We're just going to launch things and get some feedback from the users and fix the stuff that needs to be fixed and don't worry about the other stuff.”</p>
<p class="normal"><b>Seibel：</b>如果你正在设计一个大系统，你会使用什么工具——你坐下来是拿着一张方格纸还是 UML 绘图工具？</p><p class="normal"><b>Seibel:</b> If you're working on the design of a big system what are the tools you use—do you sit down with a pad of graph paper or a UML drawing tool?</p>
<p class="normal"><b>Norvig：</b>我从来都不喜欢这些 UML 类型的工具。我一直认为，“如果你不能用语言本身做到这一点，那就是语言的弱点。” 我想一个<a id="OEBPS/Chapter08.html.page_308"></a>你所做的很多事情，都是在更高层次上进行的。在谷歌，我们所做的很多事情都是弄清楚如何分解事物并将它们并行化。我们必须在多台机器上运行它，但是我们有这么多的用户，而且对于许多应用程序来说，有这么多的数据；这将如何工作？所以我们更多地在机器和机器机架的层面上思考，而不是在功能和交互的层面上。一旦理清了这一点，就可以开始深入研究各个功能和方法。</p><p class="normal"><b>Norvig:</b> I never liked any of these UML-type tools. I always thought, “If you can't do it in the language itself that's a weakness of the language.” I think a <a></a>lot of what you're doing, you're dealing at a higher level. At Google a lot of what we do is figuring out how to break things up and parallelize them. We're going to necessarily run this on multiple machines but we've got so many users and, for many applications, so much data; how's that going to work? So we're thinking more at the level of machines and racks of machines rather than at the level of functions and interactions. Once you get that straightened out, then you can start diving into individual functions and methods.</p>
<p class="normal"><b>Seibel：</b>所以那种程度的描述只是散文？</p><p class="normal"><b>Seibel:</b> And so that level of description is just prose?</p>
<p class="normal"><b>Norvig：</b>是的，主要是。有时人们会画画。他们会说，“我们将在这台服务器上为这些类型的请求提供服务，然后将其连接到该服务器，然后我们将使用这些各种工具来存储和大型分布式哈希表以及其他类型的东西。我们将选择这三个现成的工具，然后我们将讨论是否必须构建一个新工具；这些现有的哪些有效，或者我们还需要其他东西吗？”</p><p class="normal"><b>Norvig:</b> Yeah, mostly. Sometimes people draw pictures. They'll say, “We'll have this server here that will be serving these kinds of requests and then it's connected to this server and then we'll use these various tools for storage and big distributed hash tables and other types of things. We'll choose these three tools off the shelf and then we'll argue about whether we have to build a new one; which of these existing ones works or do we need something else?”</p>
<p class="normal"><b>Seibel：</b>您如何评价这种设计？</p><p class="normal"><b>Seibel:</b> And how do you evaluate that kind of design?</p>
<p class="normal"><b>Norvig：</b>你把它展示给以前做过的人看。他们说，“哦，看起来你需要一个缓存在这里——它会太慢但是应该有很多重复请求，所以如果你在这里安装一个这种大小的缓存应该会有很大帮助。” 你有一个设计审查，人们会检查它并说出他们是否认为它有意义，然后你开始构建它并测试它。</p><p class="normal"><b>Norvig:</b> You show it to the people who've done it before. They say, “Oh, it looks like you'll need a cache here—it's going to be too slow but there should be a lot of repeat requests, so if you install a cache of this size here that should help a lot.” You have a design review where people look over it and say whether they think it makes sense and then you start building it and testing it.</p>
<p class="normal"><b>Seibel：</b>你们有正式的设计评审吗？你曾在 NASA 工作，他们在那里进行了非常正式的设计审查。</p><p class="normal"><b>Seibel:</b> And you guys have formal design reviews? You worked at NASA where they had a very formal design review.</p>
<p class="normal"><b>Norvig：</b>没有像 NASA 这样正式的事情。对我们来说，赌注较低，因为正如我所说，我们很容易失败并从中恢复过来。在美国宇航局，通常第一次失败是致命的，所以他们要小心得多。我们不用担心那么多。我认为这更像是一次咨询，而不是一次审查。</p><p class="normal"><b>Norvig:</b> Nothing formal like NASA. The stakes are lower for us because, as I say, it's easy for us to have a failure and recover from that. At NASA usually the first failure is fatal so they were much more careful. We don't worry about that much. It's more of a consultation, I think, rather than a review.</p>
<p class="normal">有正式阅读设计文档并对其进行评论的人。你通过它并让你的设计获得批准。但是还是很多<a id="OEBPS/Chapter08.html.page_309"></a>比美国国家航空航天局的事情更非正式。那是在项目的鼓动下。在项目过程中有定期审查，但他们并没有真正深入研究代码。它更多的是说，“你的立场如何？你提前了吗？进度落后？你的大问题是什么？”——在那个层面上。</p><p class="normal">There are people who officially read design documents and comment on them. You go through that and get your design approved. But it's still much <a></a>more informal than the NASA thing. That's at the instigation of the project. During the course of a project there are periodic reviews, but they don't really dig into the code. It more says, “How do you stand? Are you ahead of schedule? Behind schedule? What are your big problems?”—at that level.</p>
<p class="normal">然后启动过程是所有过程中最正式的。然后，有一个清单——就安全问题而言，它是非常正式的。如果我们推出这个，是否有人能够进入并执行跨站点脚本来接管其他东西？这是相当严格的。</p><p class="normal">Then the launch process is the most formal of them all. Then, there is a checklist—it's very formal in terms of security issues. If we launch this, is someone going to be able to go in and do cross-site scripting to take over something else? That's fairly strict.</p>
<p class="normal"><b>Seibel：</b>你曾经告诉我，当 Guido van Rossum 来到这里时，他必须接受 Python 的检查，而 Ken Thompson 必须接受 C 的检查，以确保他们能够满足非常明确的编码标准。您是否有同样明确的设计标准？</p><p class="normal"><b>Seibel:</b> You told me once that when Guido van Rossum came here he had to get checked out on Python and Ken Thompson had to get checked out on C, to make sure they could meet very explicit coding standards. Do you have design standards that are equally explicit?</p>
<p class="normal"><b>Norvig：</b>不。一些编码标准涉及一些设计问题，但你在那里有更多的回旋余地。但是肯定有政策，所以你需要先获得认证，然后才能开始贡献代码。每次签到都必须由其他人审查并验证。</p><p class="normal"><b>Norvig:</b> No. Some of the coding standards go into some design issues, but you get a lot more leeway there. But there certainly are policies, so you need to be certified before you can start contributing code. Every check-in has to be reviewed by somebody else and verified.</p>
<p class="normal"><b>Seibel：</b>所以每次签入 Perforce 仓库的代码在进入之前都经过审查？</p><p class="normal"><b>Seibel:</b> So every code check-in into the Perforce depot is reviewed before it goes in?</p>
<p class="normal"><b>Norvig：</b>你可以自己做实验性的东西，并且有一个例外过程，你可以在这个过程中检查一些东西并在未来的某个日期进行审查。但你应该尽量减少这些。</p><p class="normal"><b>Norvig:</b> You can do experimental stuff on your own, and there is an exception process where you can check something in and have be reviewed at a future date. But you're supposed to minimize those.</p>
<p class="normal"><b>Seibel：</b>那么这在本质上是否等同于经典的桌面检查：“这是我的代码；其他人看着它，读了它，然后说，‘是的，这是正义的。’”</p><p class="normal"><b>Seibel:</b> So is this essentially the equivalent of the classic desk check: “Here's my code; someone else look at it and read it and say, ‘Yeah, this is righteous.’”</p>
<p class="normal"><b>诺维格：</b>是的。事实上，那是 Guido 的第一个项目。我们使用了标准的 diff 工具来做到这一点，它有点笨拙，所以 Guido 编写了这个分布式系统，具有更漂亮的显示和着色等，让您可以更好地检查签到。</p><p class="normal"><b>Norvig:</b> Yeah. In fact that was Guido's first project. We had used the standard diff tools to do that, and it was kind of clunky, so Guido wrote this distributed system with fancier display and coloring and so on that allowed you to do reviews of check-ins better.</p>
<p class="normal"><b>Seibel：</b>很多公司都说他们应该进行审查，但很少有人坚持下去。在某种程度上，你必须培训人们如何做到这一点。</p><p class="normal"><b>Seibel:</b> A lot of companies say they should do reviews but it's very rarely followed through on. You must, at some level, train people how to do that.</p>
<p class="normal"><a id="OEBPS/Chapter08.html.page_310"></a><b>挪威：</b>我认为这是一直在做的事情，所以人们接受了。好吧，我不应该这么说。有些人需要一段时间才能习惯。一个典型的失败案例是一位新员工进来了，他们不习惯做这种事情，所以他们只是开始了一个实验分支，他们把所有的代码都放在那里，你不断地告诉他们，“哎呀，你还没有任何签到。” 他们说，“是的，是的，是的，我只是在清理它——我明天会检查它。” 然后又一周过去了，又一周过去了，最终他们有了这个巨大的签到。然后这是一个问题，时间过去了太多，很难一次评估它，而且他们比较的一些东西已经从他们下面改变了。</p><p class="normal"><a></a><b>Norvig:</b> I think it was something that had always been done and so people accept it. Well, I shouldn't say that completely. Some people it takes a while to get used to it. One of the typical failure cases is a new hire comes in and they're not used to doing this kind of thing so they just start an experimental branch and they have all their code in there and you keep on telling them, “Gee, you don't have any check-ins yet.” And they say, “Yeah, yeah, yeah, I'm just cleaning it up—I'll check it in tomorrow.” And then another week goes by and another week goes by and eventually they have this one gigantic check-in. And then it's a problem that too much time has gone by, it's hard to evaluate it all at once, and some of the things they're comparing against have changed out from underneath them. Then they see what a headache it is and they learn not to do that.</p>
<p class="normal"><b>Seibel：</b>所以这是在编码方面。审稿人是否具备培养的技能？</p><p class="normal"><b>Seibel:</b> So that's on the coding side. Are there skills that the reviewers develop?</p>
<p class="normal"><b>Norvig：</b>肯定有一些人比其他人更善于审稿。在您提交评论时需要权衡取舍——您是尝试找一个会给您很多好的反馈的人，还是尝试找一个只会尽快说“好的”的人？</p><p class="normal"><b>Norvig:</b> There certainly are people who are known for being better reviewers than others. There's a trade-off of when you submit a review—do you try to get somebody who will give you a lot of good feedback or do you try to get somebody who will just say “OK” as quickly as possible?</p>
<p class="normal"><b>Seibel：</b>那么是什么让更好的审稿人变得更好呢？</p><p class="normal"><b>Seibel:</b> So what makes the better reviewers better?</p>
<p class="normal"><b>Norvig：</b>嗯，他们抓到更多的东西。有些是你缩进了错误数量的空格之类的琐碎事情，但有些是，“我认为如果你把它从这里移到那里，这个设计会更干净。” 所以有些人会做更多，而其他人则不会打扰。</p><p class="normal"><b>Norvig:</b> Well, that they catch more things. Some of it is the trivial stuff of you indented the wrong number of spaces or whatever but some of it is, “I think this design would be cleaner if you moved this from here over to there.” So some people will do more of that and others won't bother.</p>
<p class="normal"><b>Seibel：</b>有点相关，每个优秀的程序员长大后都会成为优秀的架构师吗？还是有些人是出色的编码员，但只是在一定水平上，永远不应该允许他们进行更大的设计？</p><p class="normal"><b>Seibel:</b> Sort of related to that, does every good programmer turn into a good architect when they grow up? Or are there some people who are brilliant coders but only at a certain level and they should never be allowed to do bigger designs?</p>
<p class="normal"><b>Norvig：</b>我认为不同的人有不同的技能。就代码的外观而言，我们最好的搜索人员之一绝不是我们最好的程序员。但是如果你说，“这是我们拥有的这个新因素——你知道，人们在做了这样那样的事情之后点击这个页面的次数——我们如何将其纳入我们的搜索结果？” 他会说，“哦，在第 427 行有这个变量 alpha，你应该把这个新因子提高到<a id="OEBPS/Chapter08.html.page_311"></a>二次方乘以 1.5 加到 alpha 上。” 然后你尝试了几个月尝试不同的东西，你发现他是对的，除了它应该是 1.3 而不是 1.5。</p><p class="normal"><b>Norvig:</b> I think different people have different skills. One of our best search people is by no means our best programmer, in terms of how the code looks. But if you say, “Here's this new factor that we have—you know, how many times people click on this page after they've done such and such—how do we fold that into our search results?” He'll say, “Oh, on line 427 there's this variable alpha and you should take this new factor and raise it to <a></a>the second power and multiply it by 1.5 and add it to alpha.” Then you experiment for a couple months trying different things and you find out he was right except it should have been 1.3 instead of 1.5.</p>
<p class="normal"><b>Seibel：</b>所以这表明他对软件的工作原理有着非常好的心智模型。</p><p class="normal"><b>Seibel:</b> So that suggests he just has this very good mental model of how the software works.</p>
<p class="normal"><b>Norvig：</b>他完全理解代码。其他人可以写出更好的代码，但他了解所有的含义。</p><p class="normal"><b>Norvig:</b> He understands the code perfectly. Other people can write code better but he understands all the implications of what goes where.</p>
<p class="normal"><b>Seibel：</b>你认为它们有关联吗？通常看来，写出最糟糕的意大利面条代码的人往往是头脑最清醒的人——这是他们可能写出那样的代码的唯一途径。</p><p class="normal"><b>Seibel:</b> Do you think those are related? It often seems that people who write the worst spaghetti code are the ones who can hold the most in their head—that's the only way they could possibly write code like that.</p>
<p class="normal"><b>Norvig：</b>是的，我想可能是这样。</p><p class="normal"><b>Norvig:</b> Yeah, I think that may be.</p>
<p class="normal"><b>Seibel：</b>所以这里的审查不像 NASA 那样正式。从这两个词的最佳含义来看，“工程”和“黑客”精神之间的其他区别是什么？</p><p class="normal"><b>Seibel:</b> So the reviews here are less formal here than at NASA. What are the other differences between the “engineering” and “hacker” ethos, in the best sense of both those words?</p>
<p class="normal"><b>Norvig：</b>一个很大的区别是组织结构和软件被接受的方式。谷歌是作为一家软件公司成立的，他们聘请了一位拥有伯克利计算机科学博士学位的首席执行官，聘请了一位具有计算机工程背景的销售副总裁——这贯穿了整个公司。在 NASA，他们是火箭科学家！他们不是软件专家。他们说，“软件是必不可少的恶。直线代码，我能理解；如果它有一个循环，那就有点不确定了。<i>然后，如果循环中</i>有一个分支语句，哦哦，那就偏离了我可以用控制理论中的微分方程来解决的问题。” 所以他们不信任。</p><p class="normal"><b>Norvig:</b> One big difference is organizational structure and how software is accepted. Google was founded as a software company, and they went out and hired a CEO who has a PhD in computer science from Berkeley, hired a VP of Sales who has a computer engineering background—it's throughout the whole company. At NASA they're rocket scientists! They aren't software guys. They say, “Software is this necessary evil. Straight line code, I can sort of understand; if it's got a loop in it, that's kind of iffy. Then if there's a branch statement <i>inside</i> the loop, ooooh, that's getting away from what I can solve with a differential equation in control theory.” So they're distrustful.</p>
<p class="normal"><b>Seibel：</b>他们也应该如此！</p><p class="normal"><b>Seibel:</b> As well they should be!</p>
<p class="normal"><b>Norvig：</b>他们也应该是，是的。他们不信任创新。所以你可以说，“看看我的这个很棒的新原型，”他们会说，“太棒了；我很乐意在我的任务中驾驶它——一旦它在其他两个任务中得到证实。” 你去找其他人，他们都说同样的话。</p><p class="normal"><b>Norvig:</b> As well they should be, yeah. And they're distrustful of innovation. So you can say, “Look at this great new prototype I have,” and they'll say, “That's fantastic; I'd love to fly that on my mission—as soon as it's been proven on two other missions.” And you go to everybody else and they all say the same thing.</p>
<p class="normal"><a id="OEBPS/Chapter08.html.page_312"></a>唐·戈尔丁 (Don Goldin) 以美国宇航局局长的身份上任，他说：“我们必须做得更好、更快、成本更低。这些太空任务花费太多。执行更多任务会更好，其中一些会失败，但总的来说，我们仍然可以用同样多的钱完成更多的工作。” 不可否认，这是真的。不幸的是，这在政治上并不正确。失去飞船可不行。因为大众非常了解，NASA丢了一艘飞船。他们真的不知道价值 1 亿美元的航天器和价值 10 亿美元的航天器之间有什么区别。这不像你会损失 1 亿美元中的 10 个而不是 10 亿美元。所以这从来都不是真的。</p><p class="normal"><a></a>Don Goldin came in as NASA administrator and he said, “We've got to do this better, faster, cheaper. These space missions cost too much. It'd be better to run more missions and some of them would fail but overall we'd still get more done for the same amount of money.” And that was undeniably true. Unfortunately it was not politically true. It's not OK to lose a spacecraft. Because the public understands very well, NASA lost a spacecraft. They don't really know that there's any difference between a $100 million spacecraft and a billion dollar spacecraft. It's not like you get to lose ten of the $100 millions instead of one billion. So it was never quite true.</p>
<p class="normal"><b>Seibel：</b>您不得不追踪的最严重的错误是什么？</p><p class="normal"><b>Seibel:</b> What is the worst bug you've ever had to track down?</p>
<p class="normal"><b>Norvig：</b>嗯，我想我遇到的最严重的错误不是我的，而是我必须在之后清理的错误：98 年的火星计划失败。一个是英尺磅与牛顿。另一个是，我们认为，虽然我们不是 100% 确定，但由于软件问题而过早关闭引擎。</p><p class="normal"><b>Norvig:</b> Well, I guess the most consequential bugs I was involved with were not mine, but the ones I had to clean up after: the Mars program failures in '98. One was foot-pounds vs. newtons. And the other was, we think, though we're not 100 percent sure, prematurely shutting off the engines due to a software problem.</p>
<p class="normal"><b>Seibel：</b>我读过一份关于火星气候轨道器的报告——那份报告是关于英尺磅与牛顿的问题——你是那个小组中唯一的计算机科学家。您是否参与了与软件人员的交谈以找出问题所在？</p><p class="normal"><b>Seibel:</b> I read one of the reports on the Mars Climate Orbiter—that was the one that was the foot-pounds vs. newtons problem—and you were the only computer scientist on that panel. Were you involved in talking to the software guys to figure out what the problem was?</p>
<p class="normal"><b>Norvig：</b>这很容易，事后，因为他们知道故障模式。从那以后，他们能够将其撤消，并且很快就弄清楚了。然后是为什么会发生这种事后分析？我认为这是多种因素的结合。一是外包。这是帕萨迪纳的 JPL 和科罗拉多州的洛克希德马丁公司的共同努力。两个不同的团队有两个人，他们只是没有坐下来一起吃午饭。我相信，如果他们有，他们就会解决这个问题。但是，相反，一个人发了一封电子邮件说，你知道，“这些测量结果有些不对劲，我们似乎偏离了一点点。不是很多，可能还可以，但是——”</p><p class="normal"><b>Norvig:</b> That was pretty easy, post hoc, because they knew the failure mode. From that they were able to back it out and it didn't take long to figure that one out. Then there was this postmortem of why did it happen? And I think it was a combination of things. One was outsourcing. It was a joint effort between JPL in Pasadena and Lockheed-Martin in Colorado. There were two people on two different teams and they just weren't sitting down and having lunch together. I'm convinced that if they had, they would have solved this problem. But instead, one guy sent an email saying, you know, “Something not quite right with these measurements, seems like we're off by a little bit. It's not very much, it's probably OK, but—”</p>
<p class="normal"><b>Seibel：</b>那都是在飞行期间？</p><p class="normal"><b>Seibel:</b> That was all during the flight?</p>
<p class="normal"><b>诺维格：</b>对。在飞行过程中，他们有机会抓住它。他们知道出了什么问题，他们发送了这封电子邮件，但他们没有<a id="OEBPS/Chapter08.html.page_313"></a>将其放入错误跟踪系统。如果他们有，NASA 对错误跟踪有很好的控制，并且在飞行的后期点必须有人来确定它。相反，这只是一封从未得到回复的非正式电子邮件，JPL 说：“哦，我想 Lockheed-Martin 一定已经解决了这个问题。” 洛克希德说：“哦，JPL 不再问了——他们不必担心。”</p><p class="normal"><b>Norvig:</b> Right. During the flight they had chance and chance to catch it. They knew something was wrong and they sent this email but they did not <a></a>put it into the bug-tracking system. If they had, NASA has very good controls for bug tracking and at later points in the flight somebody would have had to OK it. Instead it was just an informal email that never got an answer back, and JPL said, “Oh, I guess Lockheed-Martin must have solved this problem.” And Lockheed says, “Oh, JPL's not asking anymore—they must not be concerned.”</p>
<p class="normal">所以这是这个沟通问题。这也是一个软件重用问题。他们对关键任务的东西进行了非常好的检查，而在之前的任务中，以英尺磅记录的东西是非任务关键的——它只是一个不用于导航的日志。所以它被归类为非关键任务。在新任务中，他们重用了大部分内容，但他们更改了导航，因此以前的日志文件现在变成了导航的输入。</p><p class="normal">So it was this communications problem. It was also a software reuse problem. They have extremely good checks for the stuff that's mission-critical, and on the previous mission the stuff that was recorded in foot-pounds was non–mission-critical—it was just a log that wasn't used for navigation. So it had been classified as non–mission-critical. In the new mission they reused most of the stuff but they changed the navigation so that what was formerly a log file now became an input to the navigation.</p>
<p class="normal"><b>Seibel：</b>所以实际的问题是一方生成了一个以英尺磅为单位的数据文件，然后将该数据文件输入到一个软件中，该软件正在计算实际导航的输入并期望牛顿？</p><p class="normal"><b>Seibel:</b> So the actual problem was that one side generated a data file in foot-pounds and that data file was fed into a piece of software that was calculating inputs to the actual navigation and was expecting newtons?</p>
<p class="normal"><b>诺维格：</b>对。所以本质上，另一个根本原因是来自太阳的粒子太多。航天器是不对称的，它有这些太阳能电池板。粒子会稍微扭曲航天器，因此您必须发射火箭才能将其扭转回来。所以洛克希德公司的这个新员工去了火箭制造商，他们有所有以英尺磅为单位的规格，所以他只是说，“我会接受的，”然后他就这样记录了他们，不知道美国宇航局需要他们在公制。</p><p class="normal"><b>Norvig:</b> Right. So essentially the other root cause was too many particles from the sun. The spacecraft is asymmetrical and it's got these solar panels. Particles twist the spacecraft a little bit so you've got to fire the rockets to twist it back. So this new hire at Lockheed went to the rocket manufacturer, and they had all their specifications in foot-pounds, so he just said, “I'll go with that,” and he recorded them that way, not knowing that NASA wanted them in metric.</p>
<p class="normal"><b>Seibel：</b>读到那份报告，我对 NASA 的态度感到震惊，“好吧，问题是由于这个软件错误，但我们有很多其他机会注意到飞船不在我们预期的位置，我们应该. 我们无论如何都应该修复它，即使我们处理的数字由于一些愚蠢的软件故障而完全是假的。” 我认为这是令人钦佩的。</p><p class="normal"><b>Seibel:</b> I was struck, reading that report, by the NASA attitude of, “Well, the problem was due to this software bug but we had so many other chances to notice that the ship wasn't where we expected, and we should have. We should have fixed it anyway even though the numbers we were dealing with were totally bogus because of some stupid software glitch.” I thought that was admirable.</p>
<p class="normal"><b>Norvig：</b>是的，他们正在研究这个过程。</p><p class="normal"><b>Norvig:</b> Yeah, they were looking at the process.</p>
<p class="normal"><b>Seibel：</b>如此严重的软件错误是否真的很常见，我们从未听说过，因为所有其他进程都保持在线状态？</p><p class="normal"><b>Seibel:</b> Is it actually common for there to be software bugs of that magnitude, which we never hear about because all the other processes keep everything online?</p>
<p class="normal"><a id="OEBPS/Chapter08.html.page_314"></a><b>Norvig：</b>是的，我想是的。查看计算机上的所有软件错误。他们有数百万。但大多数时候它不会崩溃。</p><p class="normal"><a></a><b>Norvig:</b> Yeah, I think so. Look at all the software bugs on your computer. There are millions of them. But most of the time it doesn't crash.</p>
<p class="normal"><b>Seibel：</b>然而你听说过穿梭飞行软件每行要花费 1,500 美元或什么的，因为他们编写它时非常谨慎，而且据称没有错误。那只是一个谎言吗？</p><p class="normal"><b>Seibel:</b> Yet you hear about how the shuttle flight software costs $1,500 a line or something because of the care with which they write it and which is allegedly bug-free. Is that just a lie?</p>
<p class="normal"><b>Norvig：</b>不，这可能是真的。但我不知道它是否是最佳的。我认为他们使用有缺陷的软件可能会更好。</p><p class="normal"><b>Norvig:</b> No, that's probably true. But I don't know if it's optimal. I think they might be better off with buggy software.</p>
<p class="normal"><b>Seibel：</b>用更便宜的软件和更好的操作？</p><p class="normal"><b>Seibel:</b> With cheaper software and better operations?</p>
<p class="normal"><b>挪威：</b>是的，因为他们必须对这些宇航员进行大量培训，才能处理软件无法处理的事情。他们把这些宇航员放在模拟器里，给他们所有这些情况，当事情变糟时，你会看到这个屏幕，东西在上面滚动，你不能暂停屏幕，你不能回去，你不能得到什么是重要的事情的总结。宇航员只需要接受培训就可以知道，“当我看到这种情况时，这就是真正发生的事情。” 有一百条连续的消息说，“这个电器有故障”，你训练他们说，“好吧，那一定是因为这个原来的故障，然后下游有一个级联，所有其他的都被报告了” 为什么可以' 你不是用软件来做这件事而不是训练宇航员吗？他们不尝试，因为他们不想搞砸它。</p><p class="normal"><b>Norvig:</b> Yeah, because of the amount of training they have to give to these astronauts to be able to deal with the things the software just can't do. They put these astronauts in simulators and give them all these situations and when things go bad you've got this screen and stuff is scrolling through it and you can't pause the screen, you can't go back, you can't get a summary of what the important things are. The astronauts just have to be trained to know, “When I see this happening, here's what's really going on.” There are a hundred messages in a row saying, “This electrical thing has faulted,” and you train them to say, “OK, that must be because this original one faulted and then there was a cascade downstream and all the other ones are reported.” Why can't you do that in software rather than train the astronaut? They don't try because they don't want to mess with it.</p>
<p class="normal"><b>Seibel：</b>关于另一个话题，您最喜欢的调试技术和工具是什么？打印报表？正式证明？符号调试器？</p><p class="normal"><b>Seibel:</b> On a different topic, what are your preferred debugging techniques and tools? Print statements? Formal proofs? Symbolic debuggers?</p>
<p class="normal"><b>Norvig：</b>我认为这是一个混合体，这取决于我在哪里。有时我使用具有良好跟踪功能的 IDE，有时我只使用 Emacs 而没有这些。当然是跟踪和打印。和思考。编写较小的测试用例并观察它们的运行情况，然后分解功能以查看测试用例失败的地方。而且我必须承认，我经常以重写告终。有时我这样做却没有发现错误。我到了我能感觉到它就在这一部分的地步。我只是对这部分不太满意。一团糟。真的不应该那样。与其一次调整一点点，不如扔掉几百行代码，从头开始重写，通常这样 bug 就消失了。</p><p class="normal"><b>Norvig:</b> I think it's a mix and it depends on where I am. Sometimes I'm using an IDE that has good tracing capability and sometimes I'm just using Emacs and don't have all that. Certainly tracing and printing. And thinking. Writing smaller test cases and watching them go, and breaking the functionality down to see where the test case failed. And I've got to admit, I often end up rewriting. Sometimes I do that without ever finding the bug. I get to the point where I can just feel that it's in this part here. I'm just not very comfortable about this part. It's a mess. It really shouldn't be that way. Rather than tweak it a little bit at a time, I'll just throw away a couple hundred lines of code, rewrite it from scratch, and often then the bug is gone.</p>
<p class="normal"><a id="OEBPS/Chapter08.html.page_315"></a>有时我为此感到内疚。这是我的失败吗？我不明白这个错误是什么。我没有找到错误。我刚刚在房子上扔了一颗炸弹，炸掉了所有的虫子，盖了一座新房子。从某种意义上说，这个错误让我望而却步。但如果它成为正确的解决方案，也许就可以了。你比找到它更快地完成了它。</p><p class="normal"><a></a>Sometimes I feel guilty about that. Is that a failure on my part? I didn't understand what the bug was. I didn't find the bug. I just dropped a bomb on the house and blew up all the bugs and built a new house. In some sense, the bug eluded me. But if it becomes the right solution, maybe it's OK. You've done it faster than you would have by finding it.</p>
<p class="normal"><b>Seibel：</b>断言或不变量之类的东西呢？在编码时，您是如何正式考虑这些事情的？</p><p class="normal"><b>Seibel:</b> What about things like assertions or invariants? How formally do you think about those kinds of things when you're coding?</p>
<p class="normal"><b>挪威：</b>我想我更偏向于非正式的一面。除了类型声明之外，我还没有使用过作为正式机制重要组成部分的语言。就像循环不变量一样：我一直认为这比它的价值更麻烦。我偶尔会遇到此循环不终止的问题，但大多数情况下你不会终止，我只是觉得它会减慢你执行正式部分的速度。如果您确实遇到问题，调试器会告诉您卡在哪个循环中。我想如果你正在编写嵌入在某些东西中的高可靠性软件，它不会失败真的很重要，那么你真的想证明一切。但就让程序的第一个版本运行或调试而言，我</p><p class="normal"><b>Norvig:</b> I guess I'm more on the informal side. I haven't used languages where that's a big part of the formal mechanism, other than just type declarations. Like loop invariants: I've always thought that was more trouble than it was worth. I occasionally have a problem where this loop doesn't terminate, but mostly you don't, and I just feel like it slows you down to do the formal part. And if you do have a problem, the debugger will tell you what loop you're stuck inside. I guess if you're writing high-dependability software that's embedded in something that it's really important that it doesn't fail, then you really want to prove everything. But just in terms of getting the first version of the program running or debugging it, I'd rather move fast towards that than worry about the degree of formal specification you need later.</p>
<p class="normal"><b>Seibel：</b>您是否做过任何明确的尝试并从您创建的错误中学习？</p><p class="normal"><b>Seibel:</b> Have you ever done anything explicit to try and learn from the bugs that you've created?</p>
<p class="normal"><b>Norvig：</b>是的，我认为这很有趣，我希望我能用它做更多。实际上，我现在正在讨论，看看我是否可以在公司范围内做一个实验，然后可能在整个世界范围内进行实验，以更多地了解其中的一些问题。您如何对错误进行分类，以及在生产力方面有哪些因素？你怎么知道的？有特定类型的人吗？那个人的哪些因素使他们更有效率？而且我认为让某人做得更好的可控因素更有趣。如果给他们一个更大的显示器可以将工作效率提高多少个百分点，那么您应该这样做。</p><p class="normal"><b>Norvig:</b> Yeah, I think that's pretty interesting and I wish I could do more with that. I'm actually in a discussion now to see if I can do an experiment, company-wide and then maybe for the world at large, to understand more some of these issues. How do you classify bugs, but also what are some factors in terms of productivity? How do you know? Is there a certain type of person? What are the factors of that person that makes them more productive? And I think it's more interesting what the controllable factors are that make somebody do better. If giving them a bigger monitor increases productivity by such and such a percent, then you should probably do it.</p>
<p class="normal"><b>Seibel：</b>当你发现实际上非常小的显示器可以提高人们的工作效率时，人们会讨厌你。</p><p class="normal"><b>Seibel:</b> People are going to hate you when you discover that actually, really tiny monitors make people more productive.</p>
<p class="normal"><a id="OEBPS/Chapter08.html.page_316"></a><b>诺维格：</b>对。如果提供安静很重要，那么您可能应该这样做，但另一方面，如果在团队成员之间提供沟通很重要，那么您应该这样做，您如何平衡这两者？</p><p class="normal"><a></a><b>Norvig:</b> Right. And if providing quiet is important, then you should probably do that, but on the other hand, if providing communication between team members is important, then you should do that, and how do you balance those two?</p>
<p class="normal">我刚刚开始思考什么是正确的方法。你如何设置一个实验？你跟踪什么？我们是否已经有了可以通过添加某种问卷来使用的数字？我们必须进行实验吗？</p><p class="normal">I just started thinking about what's the right way to do that. How do you set up an experiment? What do you track? Do we have numbers already that we could make use of just by adding in some kind of questionnaire? Do we have to set up an experiment?</p>
<p class="normal"><b>Seibel：</b>人们经常声称程序员之间的生产力存在数量级的差异。然而我在某处读到一些对这些说法的批评，说研究发现是很久以前完成的，从那以后编程发生了很多变化，这可能是造成差异的原因——比如研究中的一些人是当其他人使用分时编程环境时，我仍在使用批处理技术。</p><p class="normal"><b>Seibel:</b> It's often claimed that there are orders of magnitude differences in productivity between programmers. Yet I read somewhere some criticism of those claims, saying the studies that found that were done quite some time ago, and a lot of things have changed about programming since then that could have accounted for the differences—such as some people in the study were still using batch processing techniques while other people were using timesharing programming environments.</p>
<p class="normal"><b>Norvig：</b>我不认为这就是全部，因为我认为在使用更多相同工具的同一组织内存在一些差异。我还记得有人批评一些只寻找相关性但不知道因果关系的研究。如果你发现大角落办公室里的程序员更有效率，那是因为你用办公室奖励优秀的程序员，还是因为办公室让他们变得更好？你真的无法得出结论。</p><p class="normal"><b>Norvig:</b> I don't think that's all of it, because I think there were some differences within the same organization using more of the same tools. I also remember there were criticisms of some of the studies of finding correlation, but not knowing cause and effect. If you found that the programmers in the big corner offices were more productive, is that because you reward the good programmers with the offices, or is it because the offices makes them better? You can't really come to a conclusion.</p>
<p class="normal"><b>Seibel：</b>你还像刚开始时那样喜欢编程吗？</p><p class="normal"><b>Seibel:</b> Do you still enjoy programming as much as when you were starting out?</p>
<p class="normal"><b>Norvig：</b>是的，但不知道所有事情是令人沮丧的。我做的不多，所以我忘记了一点。还有所有这些新事物。我真的应该重新设计我的网站，它应该在客户端有 JavaScript。它应该有 PHP 或类似的东西，但我只是没有动力去学习所有这些东西并能够做到这一点。</p><p class="normal"><b>Norvig:</b> Yeah, but it's frustrating to not know everything. I'm not doing it as much, so I forget a little bit. And there are all these new things. I really should redesign my web site and it should have JavaScript on the client side. It should have PHP or something like that, and I just haven't gotten up the momentum to learn all that stuff and be able to do it.</p>
<p class="normal"><b>Seibel：</b>你认为编程是年轻人的游戏吗？</p><p class="normal"><b>Seibel:</b> Do you think programming is a young person's game?</p>
<p class="normal"><b>Norvig：</b>我认为它在某些方面有所帮助。我们这里当然有很多人，他们在各个级别和各个年龄段都非常出色。我觉得<a id="OEBPS/Chapter08.html.page_317"></a>年轻的优势是在头脑中把握整个计划、整个问题——能够集中注意力。而且我认为当你年轻的时候这会更容易，因为你的大脑更擅长于此，或者可能只是因为你分心的事情更少了。如果你有孩子、家庭等等，你就不能像没有的时候那样连续投入那么多时间。这就是其中的一部分。但另一方面，你拥有这一系列的经验，所以你可以通过做更多事情来在某些方面弥补这一点，因为你知道如何去做。</p><p class="normal"><b>Norvig:</b> I think it helps in some ways. We certainly have a range of people here that are exceptionally good at all levels and all ages. I think the <a></a>advantage of being young is it's important to grasp the whole program, the whole problem, in your head—being able to concentrate. And I think that's easier when you're younger, because your brain is better at it, or maybe it's just that you have less distractions. If you have kids, and family, and so on, you just can't devote as many consecutive hours as when you don't. So that's part of it. But on the other hand, you've got this range of experience, so you can make up for that in some ways by being able to do more because you know how to do it.</p>
<p class="normal"><b>Seibel：</b>正如您所说，现代编程风格的一个方面是程序员必须快速吸收东西。您如何解决理解一大堆代码的问题，而您以前从未见过这些代码？</p><p class="normal"><b>Seibel:</b> One of the aspects of the modern style of programming, as you were saying, is that programmers have to absorb things quickly. How do you tackle the problem of understanding a big pile of code, none of which you've ever seen before?</p>
<p class="normal"><b>Norvig：</b>我认为你混合了静态和动态。你开始阅读代码并试图理解它，然后你会得到一些线索，知道什么调用什么，大部分时间花在哪里，以及它的流程是什么。然后尝试做某事。说，“我要做这个微不足道的小改变。” 或者去问题数据库说，“我要这个。” 为了做到这一点，我必须学习它的一小部分。只有一小块，但你完成了那块，然后继续下一块。</p><p class="normal"><b>Norvig:</b> I think you do a mix of statically and dynamically. You start reading the code and trying to make sense of it and then you get some traces of what calls what, and where most of time is spent, and what's the flow through it. Then try to do something. Say, “I'm going to make this trivial little change.” Or go to the issues database and say, “I'll take this one.” In order to do that, I have to learn a little piece of it. There's only a little piece, but you get that done and you move on to the next one.</p>
<p class="normal"><b>Seibel：</b>你有没有像 Knuth 那样做过文字编程？</p><p class="normal"><b>Seibel:</b> Have you ever done literate programming a la Knuth?</p>
<p class="normal"><b>Norvig：</b>我从来没有使用过他的工具本身。我当然写过宏等等。我使用过 Java 文档和类似的东西。在许多方面，Lisp 编程鼓励你边做边做你自己的系统，所以它最终以这种方式被识字。您会为自己的特定于应用程序的编程找到自己的宏，其中一部分是文档，一部分是数据，一部分是代码，所以我确实做到了。最近，无论我使用什么语言，无论是 Java、Python 还是其他语言，我都非常小心地编写测试用例，并围绕它编写文档。</p><p class="normal"><b>Norvig:</b> I never used his tools per se. I've certainly written macros and so on. And I've used the Java docs and things like that. In many ways, Lisp programming encourages you to make your own system as you go, and so it ends up being literate in that way. You find your own macros for your own application-specific programming, and part of that is the documentation, part of it's the data, and part of it's the code, so I've certainly done that. Then more recently, in whatever language I'm using, whether it's Java, or Python, or whatever, I've certainly been careful to write test cases, and document around that.</p>
<p class="normal">你看看高德纳 (Knuth) 的原始<i>文学编程</i>，他真的想说，“写书的最佳顺序是什么”，假设有人要阅读整本书，并且他希望它按逻辑顺序排列。人们不再这样做了。他们不想读书。他们想要一个索引，这样他们就可以说，“这本书我拥有的最少数量是多少？<a id="OEBPS/Chapter08.html.page_318"></a>阅读？我只想找到我需要的三个段落。给我看，然后我会继续前进。” 我认为这是一个真正的改变。</p><p class="normal">You look at Knuth's original <i>Literate Programming</i>, and he was really trying to say, “What's the best order for writing a book,” assuming that someone's going to read the whole book and he wants it to be in a logical order. People don't do that anymore. They don't want to read a book. They want an index so they can say, “What's the least amount of this book that I have <a></a>to read? I just want to find the three paragraphs that I need. Show me that and then I'll move on.” I think that's a real change.</p>
<p class="normal"><b>Seibel：</b>我想知道是否有一种方法可以编写现代风格的文学编程。当然，Knuth 的工具会为您提供索引和漂亮的交叉引用。我想知道现代的文学编程方法是否会以不同的方式组织这本书——既作为一个完整的程序，又作为一堆你可以一点点理解的片段？</p><p class="normal"><b>Seibel:</b> I wonder if there isn't a way to write modern-style literate programming. Certainly Knuth's tools give you an index and beautiful cross-referencing. I wonder if perhaps a modern approach to literate programming just would organize the book differently—both as a whole program and as a bunch of pieces that you can understand in bits?</p>
<p class="normal"><b>诺维格：</b>我不知道。我认为他正在解决一个在很大程度上不再存在的问题。部分原因是他想按线性顺序排列，而不是像网络一样或可搜索的顺序。我认为部分原因是限制。我认为他最初使用的是 Pascal。就必须首先声明的内容而言，它非常严格，而且不一定按照您想要的顺序。现代语言在这个顺序上更加自由，所以我认为现在这不是一个问题。</p><p class="normal"><b>Norvig:</b> I don't know. I think he was solving a problem that doesn't exist anymore to a large degree. Part of it was because he wanted to put it in a linear order rather than in a web-like or a searchable order. I think part of it was the limitations. I think he was using Pascal originally. And there it's pretty strict in terms of what had to be declared first and not necessarily in the order you want. Modern languages are more free in that order, so I think it's less of an issue now.</p>
<p class="normal"><b>Seibel：</b>您提到在《<i>科学美国人</i>》中阅读过 Strachey 的西洋跳棋代码。在你的“十年自学编程”文章中，你谈到了阅读代码的重要性。你读到了什么代码？</p><p class="normal"><b>Seibel:</b> You mentioned reading Strachey's checkers code in <i>Scientific American</i>. And in your “Teach Yourself Programming in Ten Years” essay, you talk about the importance of reading code. What code did you read coming up?</p>
<p class="normal"><b>Norvig：</b>我读了很多 Symbolics 的代码，因为我在伯克利的时候就已经可以使用了。</p><p class="normal"><b>Norvig:</b> I read a lot of the Symbolics's code, because that was available when I was at Berkeley.</p>
<p class="normal"><b>Seibel：</b>那仅仅是因为它可用且有趣吗？或者你读它是为了试图理解你观察到的一些行为？</p><p class="normal"><b>Seibel:</b> Was that just because it was available and was interesting? Or were you reading it to try to understand some behaviors you were observing?</p>
<p class="normal"><b>诺维格：</b>两者都有。有时我只是想弄清楚事情是如何运作的，有时我需要它来解决问题。</p><p class="normal"><b>Norvig:</b> Both. I sometimes just tried to figure out how things work and sometimes I needed it to solve a problem.</p>
<p class="normal"><b>Seibel：</b>所以当你只是为了一般性的启发而阅读时，你是如何处理的？</p><p class="normal"><b>Seibel:</b> So when you're reading just for general edification, how do you approach that?</p>
<p class="normal"><b>Norvig：</b>我认为这可能是利益驱动的。“哎呀，这个文件系统允许你使用你在本地机器上使用的相同协议通过网络读取文件——我想知道它是怎么做到的？” 所以你会说，“也许它在 open 函数中。” 你看着那里，然后说，“哦，这叫另一个<a id="OEBPS/Chapter08.html.page_319"></a>事物。” 然后你看着那里，最后你说，“哦，它就是这样做的。”</p><p class="normal"><b>Norvig:</b> I think it's probably interest-driven. “Gee, this file system allows you to read files across the net using the same protocol that you use locally on your machine—I wonder how it does that?” And so you'll say, “Maybe it's in the open function.” You look there, and say, “Oh, that calls this other <a></a>thing.” And you look there, and eventually you say, “Oh, this is how it does it.”</p>
<p class="normal"><b>Seibel：</b>你读过 Knuth 的任何文学程序吗？</p><p class="normal"><b>Seibel:</b> Have you read any of Knuth's literate programs in book form?</p>
<p class="normal"><b>Norvig：</b>我确实拿起了书并翻阅了它们。我可以说我看过它们，但我没有研究过它们。</p><p class="normal"><b>Norvig:</b> I've certainly picked up the books and flipped through them. I could say I glanced at them, but I haven't studied them.</p>
<p class="normal"><b>Seibel： 《</b><i>计算机编程艺术》</i>怎么样？就此与我交谈过的一些人完全从头到尾阅读了它。有些人把它放在架子上，作为参考。有些人只是把它放在架子上。</p><p class="normal"><b>Seibel:</b> What about <i>The Art of Computer Programming</i>? Some of the people I've talked to on this have absolutely read it from cover to cover. Some people have it on the shelf and use it as a reference. And some people just have it on the shelf.</p>
<p class="normal"><b>Norvig：</b>有一次我把它当作我的显示器支架，因为它是我拥有的最大的一套书之一，而且它的高度恰到好处。那很好，因为它一直在那里，我想我更倾向于将它用作参考，因为它就在我面前。</p><p class="normal"><b>Norvig:</b> At one point I had it as my monitor stand because it was one of the biggest set of books I had, and it was just the right height. That was nice because it was always there, and I guess then I was more prone to use it as a reference because it was just right in front of me.</p>
<p class="normal"><b>Seibel：</b>但是你每次想看的时候都得把显示器举起来？</p><p class="normal"><b>Seibel:</b> But you had to lift up the monitor every time you wanted to look at it?</p>
<p class="normal"><b>Norvig：</b>不，我有套装。你必须用力拉，但你可以拉一个盒子。现在我不太可能使用任何书籍作为参考——我只是可能会进行搜索。</p><p class="normal"><b>Norvig:</b> No, I had the box set. You had to pull hard, but you could pull one of the box. Now I'm less likely to use any book for reference—I'm just likely to do a search.</p>
<p class="normal"><b>Seibel：</b>只是因为它更方便？</p><p class="normal"><b>Seibel:</b> Just because it's more convenient?</p>
<p class="normal"><b>Norvig：</b>很方便。我认为这也是我可能更以目标为导向。如果你说“我想知道关于这个主题的一切”，高德纳很好。但通常我会说，“我想知道 A 是否比 B 好”，或者，“我想知道它的渐近复杂性，一旦我知道了，我就不需要所有的细节了我们是怎么到那里的。”</p><p class="normal"><b>Norvig:</b> It's convenient. I think it's also that I'm probably more goal-oriented. Knuth is good if you say, “I want to know everything about this subject.” But usually I'm saying, “I want to know if A is better than B,” or, “I want to know the asymptotic complexity of this, and once I've got that, I don't need all the details of how we got there.”</p>
<p class="normal"><b>Seibel：</b>作为一名程序员，你认为自己是科学家、工程师、艺术家还是工匠？</p><p class="normal"><b>Seibel:</b> As a programmer, do you consider yourself a scientist, an engineer, an artist, or a craftsman?</p>
<p class="normal"><b>Norvig：</b>嗯，我知道当你比较各种书名时，我一直认为“工艺”是正确的答案。所以我认为艺术有点自命不凡，因为艺术的目的是为了美丽或产生情感联系或情感影响，我不觉得那有什么<a id="OEBPS/Chapter08.html.page_320"></a>我尝试做的。当然，我希望程序在某些方面很漂亮，但有时我觉得我在这方面花了太多时间。我一直处于这样一种境地，我可以奢侈地说：“哎呀，我有时间回去把它美化一下。” 在我能够为出版物写作的地方，你花更多的时间去做这件事，而不是仅仅为了你自己的职业发展。</p><p class="normal"><b>Norvig:</b> Well, I know when you compare the various titles of books and so on, I always thought the “craft” was the right answer. So I thought art was a little pretentious because the purpose of art is to be beautiful or to have an emotional contact or emotional impact, and I don't feel like that's anything <a></a>that I try to do. Certainly I want programs to be pretty in some ways, and sometimes I feel like I spend too much time doing that. I've been in a position where I've had the luxury to say, “Gee, I have time to go back and pretty this up a little bit.” And places where I've been able to write for a publication, you spend more time doing that than you would if it was just for your own professional growth.</p>
<p class="normal">但我不认为那是艺术。我认为<i>工艺</i>真的是正确的词。你可以做一把椅子，它很漂亮，但它主要是实用的——它是一把椅子。</p><p class="normal">But I don't think of that as art. I think <i>craft</i> is really the right word for it. You can make a chair, and it's good looking, but it's mostly functional—it's a chair.</p>
<p class="normal"><b>Seibel：</b>您如何识别优秀的程序员，尤其是在招聘时？你们雇佣了很多程序员，而且你们显然试图雇佣非常优秀的程序员。你怎么做呢？</p><p class="normal"><b>Seibel:</b> How do you recognize a great programmer, particularly when you're hiring? You guys have hired a lot of programmers and you obviously try to hire really good programmers. How do you do it?</p>
<p class="normal"><b>Norvig：</b>我们还不知道。</p><p class="normal"><b>Norvig:</b> We still don't know.</p>
<p class="normal"><b>Seibel：</b>谷歌以在面试中提出难题而闻名。你认为这是一个好方法吗？</p><p class="normal"><b>Seibel:</b> Google is somewhat famous for asking puzzle questions in interviews. Do you think that's a good approach?</p>
<p class="normal"><b>挪威：</b>我认为人们是否可以解决难题并不重要。我不喜欢诡计难题。我认为重要的是让他们处于技术环境中，而不仅仅是闲聊并感受他们是否是个好人。尽管有一个可以相处的人很重要。但你真的必须看看，他们能否在技术上做到他们所说的。有很多不同的方法可以证明这一点。而且很多时候从简历上就能看出来。我认为我们最好的信号是，如果有人以前与我们的一名员工共事过，并且该员工可以为他们提供担保。但是我们还是尽量在采访的时候现场画出来。更多的是你想感受一下这个人是怎么想的，他们是如何一起工作的，所以他们知道基本的想法吗？他们可以说，“好吧，为了解决这个问题，我需要知道 A、B 和 C，”然后他们开始将它们放在一起。而且我认为您可以证明这一点，同时仍然无法解决难题。你可以说，“好吧，这就是我解决这个难题的方法。嗯，我首先想到的是这个。然后我这样做。然后我就这么做了，但是天哪，这部分我不太明白。” 对于某些人来说，那一小部分会发出咔哒声，而对于某些人来说则不会。只要您展示了基本的能力和流畅的思考方式，即使它没有点击，您也可以做得很好。然后你真的想让人们在板上写代码，如果你是 然后我这样做。然后我就这么做了，但是天哪，这部分我不太明白。” 对于某些人来说，那一小部分会发出咔哒声，而对于某些人来说则不会。只要您展示了基本的能力和流畅的思考方式，即使它没有点击，您也可以做得很好。然后你真的想让人们在板上写代码，如果你是 然后我这样做。然后我就这么做了，但是天哪，这部分我不太明白。” 对于某些人来说，那一小部分会发出咔哒声，而对于某些人来说则不会。只要您展示了基本的能力和流畅的思考方式，即使它没有点击，您也可以做得很好。然后你真的想让人们在板上写代码，如果你是<a id="OEBPS/Chapter08.html.page_321"></a>面试他们的编码工作。因为有些人已经忘记或不太了解，您可以很快看到这一点。</p><p class="normal"><b>Norvig:</b> I don't think it's important whether people can solve the puzzles or not. I don't like the trick puzzle questions. I think it's important to put them in a technical situation and not just chitchat and get a feeling if they're a nice guy. Though it is important to have someone that you can get along with. But you really have to see, can they technically do what they said they can do. And there are a lot of different ways to demonstrate that. And many times you can see it from the résumé. I think our best signal is if somebody has worked with one of our employees before and the employee can vouch for them. But we still try to draw it out on-site during the interview. It's more you want to get a feeling for how this person thinks and how they work together, so do they know the basic ideas? Can they say, “Well, in order to solve this, I need to know A, B, and C,” and they start putting it together. And I think you can demonstrate that while still failing on a puzzle. You can say, “Well, here's how I attack this puzzle. Well, I first think about this. Then I do that. Then I do that, but geez, here's this part I don't quite understand.” For some people that little part clicks and for some it doesn't. And you can do fine if it doesn't click as long as you've demonstrated the basic competency and fluency in how you think about it. And then you really want to have people write code on the board if you're <a></a>interviewing them for a coding job. Because some people have forgotten or didn't quite know and you could see that pretty quickly.</p>
<p class="normal"><b>Seibel：</b>那么这只是一个负面指标吗？如果他们不能编写合理的代码，那是一个不好的迹象。但是，如果他们不克服这个障碍，就很难判断他们是否真的会在更大的环境中编写出真正好的代码。</p><p class="normal"><b>Seibel:</b> So is that just a negative indicator? If they can't write reasonable code, that's a bad sign. But if they don't stumble over that hurdle, it's hard to tell whether they're actually going to write really good code in a larger context.</p>
<p class="normal"><b>诺维格：</b>对。你可以在一定程度上说出来，但在其他层面上你不能。我们已经非常仔细地研究了这一点，因为我们已经收到了很多申请，并且我们从两个层面来看待它。第一，我们说，从我们得到的所有简历来看，我们是否在面试合适的人？然后，从我们得到的面试中，我们是否雇用了合适的人选？</p><p class="normal"><b>Norvig:</b> Right. You could tell to a certain degree but at other levels you can't. And we've studied this pretty carefully because we've gotten a lot of applications and we look at it at two levels. One, we say, from all the résumés we get, are we interviewing the right set of people? And then, from the interviews we get, are we hiring the right set of people?</p>
<p class="normal"><b>Seibel：</b>那么你如何衡量呢？你不知道你没有谈过或没有雇用的人。</p><p class="normal"><b>Seibel:</b> So how do you measure that? You don't know about the one you didn't talk to or didn't hire.</p>
<p class="normal"><b>Norvig：</b>是的，所以这很难。在这两个级别上，你只有一半的样本，所以这是一个有偏见的问题，但我想基本上我们正在做的是说，“在我们面试过并且表现出色的人中，他们的简历是什么样的，”并尝试找到更多。这么多年的经验重要吗？从事开源编程项目重要吗？这与赢得编程竞赛相比如何？</p><p class="normal"><b>Norvig:</b> Yeah, so that's hard. At both levels, you've only got half your sample, so it's this biased problem, but I guess basically what we're doing is saying, “Of the people that we interviewed and did well, what did their résumé look like,” and try to find more of those. Is having so many years of experience important? Is working on an open-source programming project important? How does that compare to winning a programming contest?</p>
<p class="normal"><b>Seibel：</b>你真的把所有这些东西都塞进数据库了吗？</p><p class="normal"><b>Seibel:</b> Do you really take all these things and shove them into a database?</p>
<p class="normal"><b>Norvig：</b>是的，我们这样做了，当我们进行招聘时，我们会得到这些分数，这些分数表明，“简历预测者说了这般，面试预测者说了如此这般。” 我们不把它们当作福音，但它们只是我们收到的所有其他反馈的另一条输入。</p><p class="normal"><b>Norvig:</b> Yes, we do, and when we're doing the hiring, we have these scores that come up that say, “The résumé predictor says such and such, and the interview predictor says such and such.” We don't take them as gospel, but they're just another piece of input along with all the other feedback we have.</p>
<p class="normal"><b>Seibel：</b>做采访的人事先有这些数字吗？</p><p class="normal"><b>Seibel:</b> Do the people who are doing the interviews have those numbers beforehand?</p>
<p class="normal"><b>Norvig：</b>不，我们只有在他们进入招聘委员会时才会看到，一旦我们收集了所有反馈。我们发现的一个有趣的事情是，当我们试图预测我们雇用的人在一两年后评估他们时的表现时，最好的指标之一是<a id="OEBPS/Chapter08.html.page_322"></a>公司内部的成功是在你的一次面试中获得最差的分数。我们从一到四对人进行排名，如果您在一次面试中获得一分，那是一个非常好的成功指标。</p><p class="normal"><b>Norvig:</b> No, we only see that when they're in the hiring committee, once we've gathered all the feedback. One of the interesting things we found, when trying to predict how well somebody we've hired is going to perform when we evaluate them a year or two later, is one of the best indicators of <a></a>success within the company was getting the worst possible score on one of your interviews. We rank people from one to four, and if you got a one on one of your interviews, that was a really good indicator of success.</p>
<p class="normal"><b>Seibel：</b>但是你必须在其他事情上做得足够好，你才能真正被录用？</p><p class="normal"><b>Seibel:</b> But you had to do well enough on something else that you actually got hired?</p>
<p class="normal"><b>Norvig：</b>是的，就是这样。百分之九十九的人在我们没有雇用的面试中获得了一个。但是其他人，为了让我们雇用他们，必须要有其他人非常热情，以至于他们拍着桌子说，“我必须雇用这个人，因为我在他身上看到了一些非常棒的东西，而这个人认为他不好是错误的，我必须为他挺身而出，赌上我的名誉。”</p><p class="normal"><b>Norvig:</b> Right, so that's the thing. Ninety-nine percent of the people who got a one in one of their interviews we didn't hire. But the rest of them, in order for us to hire them somebody else had to be so passionate that they pounded on the table and said, “I have to hire this person because I see something in him that's so great, and this guy who thought he was no good is wrong, and I've got to stand up for him and put my reputation on the line.”</p>
<p class="normal"><b>Seibel：</b>所以你在谷歌周围都是一流的程序员。鉴于计算机和软件在我们社会中的普及程度，您是否认为每个人都需要了解一点编程知识才能融入或了解他们生活的世界？</p><p class="normal"><b>Seibel:</b> So you're surrounded by top-notch programmers here at Google. Given how pervasive computers and software are in our society, do you think everybody needs to understand a bit about programming just to get along in or understand the world they live in?</p>
<p class="normal"><b>Norvig：</b>你可能希望受过教育的人了解软件是如何制造的，就像他们了解汽车是如何制造的一样。另一个有趣的事情是，一个有见识的公民必须<i>成为</i>一名程序员多少钱？当然，普通人现在可以进行文字处理，其中许多人可以进行电子表格，所以如果您对电子表格有一点经验，那么您就开始成为一名程序员了。</p><p class="normal"><b>Norvig:</b> You probably want an educated person to understand how software is made to the same degree they understand how a car is made. The other interesting thing is, how much does an informed citizen have to <i>be</i> a programmer? Certainly the average person now can do word processing and many of them can do spreadsheets, and so if you're a little bit experienced with spreadsheets, you're starting to be a programmer.</p>
<p class="normal">终端用户编程和为每个人编程的许多尝试都不是很成功。我不知道这有多容易。有没有一种方式认为人们有我们已经得到了所有很容易教的人，而其他人真的很难，或者只是我们错过了模型并且有一些简单的模型如果我们创建它，代替许多可能影响编程的人？</p><p class="normal">Lots of attempts at end-user programming, and programming for everyone, haven't been very successful. I don't know how easy it is. Is there a way of thinking that people have that we've gotten all the people that it's easy to teach, and the other ones are going to be really hard, or is it just that we've missed the model and there's some simple model in place of many people that could influence programming if we created it?</p>
<p class="normal"><b>Seibel：</b>我为这本书和其他地方采访过的很多人之所以接触计算机，既是因为他们喜欢它，也是因为他们觉得它会改变世界。我为本书采访过的一些人过去曾这样做过，现在他们感到沮丧，因为他们觉得世界因此发生的变化如此之小。你对这件事有什么感想？</p><p class="normal"><b>Seibel:</b> A lot of people that I have talked to for this book, and elsewhere, got into computers both because they just enjoyed it and because they felt like it would change the world. Some of the folks I talked to for this book did that in the past and now are depressed by how little they feel the world has changed as a result. How do you feel about that?</p>
<p class="normal"><a id="OEBPS/Chapter08.html.page_323"></a><b>Norvig：</b>好吧，我来对地方了。我们有数亿用户，我们可以为他们带来改变，我们可以为他们快速推出新服务。我认为那很好。我无法想象我还能做些什么来产生那种程度的影响。</p><p class="normal"><a></a><b>Norvig:</b> Well, I'm in the right place. We have hundreds of millions of users and we can make a difference for them, and we can launch new services for them quickly. I think that's great. I can't imagine anything else I could be doing to have that level of impact.</p>
</div>
</div></div>
<div id="OEBPS/Chapter09.html"><div>

<div class="booksection">
<p></p>
<h2 class="chapnum"><a id="OEBPS/Chapter09.html.ch9"></a><a id="OEBPS/Chapter09.html.page_325"></a><img src="data:image/jpg;base64,/9j/4AAQSkZJRgABAgEASABIAAD/7Q0KUGhvdG9zaG9wIDMuMAA4QklNA+0KUmVzb2x1dGlvbgAAAAAQAEgAAAABAAEASAAAAAEAAThCSU0EDRhGWCBHbG9iYWwgTGlnaHRpbmcgQW5nbGUAAAAABAAAAHg4QklNBBkSRlggR2xvYmFsIEFsdGl0dWRlAAAAAAQAAAAeOEJJTQPzC1ByaW50IEZsYWdzAAAACQAAAAAAAAAAAQA4QklNBAoOQ29weXJpZ2h0IEZsYWcAAAAAAQAAOEJJTScQFEphcGFuZXNlIFByaW50IEZsYWdzAAAAAAoAAQAAAAAAAAACOEJJTQP1F0NvbG9yIEhhbGZ0b25lIFNldHRpbmdzAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+BdDb2xvciBUcmFuc2ZlciBTZXR0aW5ncwAAAHAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAOEJJTQQAC0xheWVyIFN0YXRlAAAAAgABOEJJTQQCDExheWVyIEdyb3VwcwAAAAAEAAAAADhCSU0ECAZHdWlkZXMAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4NVVJMIG92ZXJyaWRlcwAAAAQAAAAAOEJJTQQaBlNsaWNlcwAAAAB1AAAABgAAAAAAAAAAAAAAmwAAANkAAAAKAFUAbgB0AGkAdABsAGUAZAAtADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAANkAAACbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhCSU0EERFJQ0MgVW50YWdnZWQgRmxhZwAAAAEBADhCSU0EFBdMYXllciBJRCBHZW5lcmF0b3IgQmFzZQAAAAQAAAACOEJJTQQMFU5ldyBXaW5kb3dzIFRodW1ibmFpbAAACS0AAAABAAAAcAAAAFAAAAFQAABpAAAACREAGAAB/9j/4AAQSkZJRgABAgEASABI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" alt="图片"></h2><h2 class="chapnum"><a></a><a></a></h2>
<h2 class="chaptitle">盖·Steele</h2><h2 class="chaptitle">Guy Steele</h2>
<div class="sidebar">
<p class="normal"><i>Guy Steele 是一个真正的编程通晓者。当我问他认真使用过哪些语言时，他列出了这个列表：COBOL、Fortran、IBM 1130 汇编语言、PDP-10 机器语言、APL、C、C++、Bliss、GNAL、Common Lisp、Scheme、Maclisp、S- 1 Lisp、*Lisp、C*、Java、JavaScript、Tcl、Haskell、FOCAL、BASIC、TECO 和 TeX。“我猜这些将是主要的，”他补充道。</i></p><p class="normal"><i>Guy Steele is a true programming polyglot. When I asked him what languages he has used seriously he came up with this list: COBOL, Fortran, IBM 1130 assembly, PDP-10 machine language, APL, C, C++, Bliss, GNAL, Common Lisp, Scheme, Maclisp, S-1 Lisp, *Lisp, C*, Java, JavaScript, Tcl, Haskell, FOCAL, BASIC, TECO, and TeX. “Those would be the main ones, I guess,” he added.</i></p>
<p class="normal"><i>他参与了两个主要的现存通用 Lisp 方言的创建：Common Lisp 和 Scheme。他曾在定义 Common Lisp、Fortran、C、ECMAScript 和 Scheme 的标准机构任职，并被 Bill Joy 招募来帮助编写 Java 的官方语言规范。他现在正在设计 Fortress，一种用于高性能科学计算的新语言。</i></p><p class="normal"><i>He had a hand in the creation of both of the major surviving general-purpose Lisp dialects: Common Lisp and Scheme. He served on the standards bodies that defined Common Lisp, Fortran, C, ECMAScript, and Scheme and was recruited by Bill Joy to help write the official language specification for Java. He is now at work designing Fortress, a new language for high-performance scientific computing.</i></p>
<p class="normal"><i>Steele 的学术生涯包括哈佛大学的文学学士学位和麻省理工学院的 SM 和博士学位。在麻省理工学院期间，他与 Gerald Sussman 合作撰写了一系列论文，这些论文现在被称为“Lambda 论文”，其中包括 Scheme 编程语言的原始定义。作为 Jargon File 的原始编译者之一和书籍版本 The Hacker's Dictionary（随后由 Eric S. Raymond 更新和扩展为 The New Hacker's Dictionary）的编辑，他还是黑客文化的编年史者。并且他在 Emacs 的诞生中扮演了重要的角色，并且是最早移植 Donald Knuth 的程序 TeX 的程序员之一。</i></p><p class="normal"><i>Steele's academic career included an AB from Harvard and an SM and PhD from MIT. While at MIT he collaborated with Gerald Sussman on a series of papers now known as “The Lambda Papers,” which included the original definition of the Scheme programming language. He has also been a chronicler of hacker culture as one of the original compilers of the Jargon File and editor of the book version, The Hacker's Dictionary (subsequently updated and expanded by Eric S. Raymond as The New Hacker's Dictionary). And he played an important role in the birth of Emacs and was one of the first programmers to port Donald Knuth's program TeX.</i></p>
<p class="normal"><a id="OEBPS/Chapter09.html.page_326"></a><i>Steele 是计算机协会和美国艺术与科学院的院士，也是美国国家工程院的成员。他于 1988 年获得了 ACM 的 Grace Murray Hopper 奖，并于 2005 年获得了 Dr. Dobb 的卓越编程奖。</i></p><p class="normal"><a></a><i>Steele is a Fellow of the Association for Computing Machinery and the American Academy of Arts and Sciences and a member of the U.S. National Academy of Engineering. He won the ACM's Grace Murray Hopper Award in 1988 and Dr. Dobb's Excellence in Programming Award in 2005.</i></p>
<p class="normal"><i>在这次采访中，他谈到了软件设计以及写作和编程之间的关系，他给出了我所听过的关于正确性形式证明的价值和局限性的最好解释之一。</i></p><p class="normal"><i>In this interview he talks about designing software and the relation between writing and programming, and he gives one of the best explanations I've ever heard of the value—and limitations—of formal proofs of correctness.</i></p>
</div>
<p class="normal"><b>Seibel：</b>您是如何参与编程的？</p><p class="normal"><b>Seibel:</b> How did you get involved in programming?</p>
<p class="normal"><b>Steele：</b>好吧，我记得上小学时我对科学和数学很着迷，我读过欧文·阿德勒的《数字之家》等书；这是我的最爱之一。我喜欢儿童科幻小说，比如 Danny Dunn 系列之类的。所以我对科学和数学产生了普遍的兴趣。在尽我所能阅读有关科学和数学的所有内容时，我也阅读了一些有关这些即将出现的新型计算机的信息。</p><p class="normal"><b>Steele:</b> Well, when I was in elementary school I remember being fascinated by science and math and I read books such as Irving Adler's House of Numbers; it was one of my favorites. And I liked kiddie science fiction like, say, the Danny Dunn series and that kind of thing. So I had this general interest in science and math. In reading everything I could about science and math, I read a little bit about these newfangled computers that were coming up as well.</p>
<p class="normal"><b>Seibel：</b>那会是什么时候？</p><p class="normal"><b>Seibel:</b> And when would that have been?</p>
<p class="normal"><b>Steele：</b>我从 1960 年到 66 年都在上小学。但我认为真正的转折点是在我进入波士顿拉丁学校时——相当于九年级。一位朋友问我，“你听说过地下室的新电脑吗？” 我以为这是继四楼游泳池的最新故事，而学校只有三层楼。但他说，“不，真的，它存在。”</p><p class="normal"><b>Steele:</b> I was in elementary school from 1960 through '66. But I think the real turning point was when I got to Boston Latin School—it would have been in the equivalent of the ninth grade. A friend asked me, “Have you heard about the new computer in the basement?” I thought this was the newest story after the one about the fourth-floor swimming pool and the school only has three stories. But he said, “No really, it exists.”</p>
<p class="normal">事实证明，T. Vincent Learson 在波士顿拉丁学校的地下室里安排了一台 IBM 1130 小型计算机。他是一位校友，显然是一位非常慷慨的人。我的朋友继续向我展示一个大约五行的 Fortran 程序，我立刻被迷住了。</p><p class="normal">It turns out that T. Vincent Learson had arranged for an IBM 1130 minicomputer to be in the basement of the Boston Latin School. He was an alum and a very generous one apparently. My friend proceeded to show me a Fortran program of about five lines and I was immediately fascinated.</p>
<p class="normal">然后我去找我们的一位数学老师，问我能不能给我一些书来学习。他给了我一些书，以为它们能让我忙上一个月，但实际上它们只持续了一个周末。我在 1968 年的感恩节周末自学了 Fortran——所以那是一个漫长的周末。之后我就完全迷上了。</p><p class="normal">Then I went to one of our math teachers and asked if I could have some books to study. He gave me some books and thought they'd keep me busy for a month but they actually lasted a weekend. I taught myself Fortran over Thanksgiving weekend—so it was a long weekend—of 1968. After that I was completely hooked.</p>
<p class="normal"><a id="OEBPS/Chapter09.html.page_327"></a>由于 IBM 1130，我和我的拉丁学校朋友对 IBM 产生了浓厚的兴趣，我们每隔几个月就会去市中心的 IBM 办公室，与那里的人交谈，偶尔用我们仅有的一点钱订购出版物。</p><p class="normal"><a></a>My Latin School friends and I had a fascination with IBM because of the IBM 1130 and we took to visiting the IBM office downtown every couple of months and talking with the people there and occasionally ordering publications with what little money we had.</p>
<p class="normal">市中心还有一家书店，出售关于 PL/I 等外来语言的书籍，我们偶尔会在那里买书。因此，通过 Latin School，我们了解了 IBM 设备。我们只有 1130，但我们对 System 360 垂涎欲滴。我们阅读了它，但实际上并没有访问它。</p><p class="normal">There was also a bookstore downtown that had books about exotic languages like PL/I, and we'd occasionally buy books there. So, through Latin School we got to know IBM equipment. We just had the 1130 but we drooled over System 360. We read about it and didn't really have access to one.</p>
<p class="normal">1969 年春天，我开始参与麻省理工学院的高中学习项目。这太棒了——周六早上去，让大学生教你所有这些很酷的东西。我参加了群论和计算机编程课程，其他的我都忘了。我变得相当投入，因此开始在麻省理工学院非常熟悉的地盘上感受。通过高中学习计划，我们可以使用 IBM 1130s 和 DEC PDP-10s。这就是我们了解数字设备系列的方式。</p><p class="normal">Then I became involved at MIT in the spring of 1969 in the High School Studies Program. This was great—go on Saturday mornings and have college students teach you all this cool stuff. I took courses in group theory and computer programming and I forget what all else. I became rather heavily involved and therefore got to feel on very familiar turf at MIT. Through the High School Studies Program, we had access to both IBM 1130s and DEC PDP-10s. So that's how we got to know the Digital Equipment line.</p>
<p class="normal">作为高中生，我们开始意识到中央广场的 DEC 办公室倾向于迎合麻省理工学院的学生。当高中生走进来索要参考手册时，他们没有眨眼。太好了。当我在拉丁学校读大三或大四时，我和我的一个朋友向 DEC 提交了一份为 PDP-8 实施 APL 的提案。他们认真对待了这个提议。他们看了一个星期，然后说：“好吧，我们认为这不是个好主意，但谢谢你的提议。”</p><p class="normal">As high-school students we became aware of the DEC office in Central Square that tended to cater to the MIT students. They didn't blink when high-school students walked in and asked for reference manuals. It was great. When I was a junior or senior at Latin School, a friend of mine and I typed up a proposal to DEC to implement an APL for the PDP-8. And they took the proposal seriously. They looked at it for a week and then they said, “Well, we don't think this is a good idea, but thanks for the offer.”</p>
<p class="normal"><b>Seibel：</b>您编写的第一个有趣的程序是什么？</p><p class="normal"><b>Seibel:</b> What was the first interesting program you wrote?</p>
<p class="normal"><b>Steele：</b>嗯，我先学了 Fortran，所以当我开始学习 IBM 1130 汇编语言时，我觉得事情真的很有趣。我想我能记得的最早的有趣程序是生成上下文关键字索引的程序。IBM 为他们的手册提供了这些所谓的快速索引，给定一个关键字，你可以在索引中查找它，它是根据关键字按字母顺序排列的，但在关键字的两边你会看到围绕该词的上下文的其他几个词.</p><p class="normal"><b>Steele:</b> Well, I learned Fortran first so I think things really got interesting when I started to learn IBM 1130 assembly language. And I guess the earliest interesting program I can remember was something that would generate keyword-in-context indexes. IBM provided these so-called quick indexes for their manuals that, given a keyword, you could look it up in the index and it was alphabetized according to keyword but on either side of the keyword you would see several other words of context surrounding that word.</p>
<p class="normal"><b>Seibel：</b>这个词出现的上下文？</p><p class="normal"><b>Seibel:</b> Context from where the word appeared?</p>
<p class="normal"><a id="OEBPS/Chapter09.html.page_328"></a><b>Steele：</b>这个词出现在原始出版物中的地方。所以在中间一栏下面是按字母顺序排列的单词，两边突出的都是上下文。所以我想我会解决这个问题，在 1130 上做。考虑到 1130 只有 4,000 字的内存，很明显我必须将记录保存在磁盘上。所以我借此机会学习了高效的核外排序技术。这个程序的有趣之处与其说是 KWIC 索引的生成，不如说是实现多路核外合并排序。它相当有效。不幸的是，我的核心排序是冒泡排序，因为我不是那么老练。我也应该在核心中进行合并排序，但当时我还没有完全弄明白。</p><p class="normal"><a></a><b>Steele:</b> Where the word had appeared in the original publication. So down the middle column were the words that had been alphabetized and sticking out on either side would be chunks of context. So I thought I'd tackle that problem, doing it on the 1130. And considering that the 1130 had only 4,000 words of memory, it was clear that I was going to have to keep the records on disk. So I took this opportunity to learn about efficient out-of-core sorting techniques. What was interesting about this program was not so much the generation of the KWIC index but implementing a multiway out-of-core merge sort. And it was reasonably effective. Unfortunately my in-core sort was bubble sort because I wasn't that sophisticated. I should have also done a merge sort in core but I hadn't quite figured that out at the time.</p>
<p class="normal"><b>Seibel：</b>您认为从您第一次意识到地下室确实有一台计算机到您编写此程序需要多长时间？几个月了？几周？</p><p class="normal"><b>Seibel:</b> How long do you think it was from when you first realized there really was a computer in the basement to when you were writing this program? Was it months? Weeks?</p>
<p class="normal"><b>Steele：</b>应该是在头两年内。不记得是不是第一年了。我在 68 年秋天学习了 Fortran。我记得 APL 是我的第三语言，所以我一定是在圣诞节前后的某个地方或之后不久学习了汇编语言。我知道我是在 69 年春天学习 APL 的，因为那是春季联合计算机会议来到波士顿的时候。</p><p class="normal"><b>Steele:</b> It would have been within the first two years. I don't remember whether it was in the first year. I learned Fortran in the fall of '68. And I remember that APL was my third language so I must have learned the assembly language somewhere around Christmastime or shortly after. I know I learned APL in the spring of '69 because that's when the Spring Joint Computer Conference came to Boston.</p>
<p class="normal">IBM 在展厅里有一个展品，宣传各种 IBM 产品，但特别是 APL 360，我在那个展位附近闲逛。在贸易展结束时，他们正准备扔掉用于 Selectric 终端演示的那叠纸。恰逢其时，我走上前问道：“你打算把它扔掉吗？” 这位女士疑惑地看着我，说：“给你，这是你的，”就好像她要送给我这件大圣诞礼物一样。她是。</p><p class="normal">IBM had an exhibit on the show floor touting all manner of IBM products but the APL 360 in particular, and I hung around that booth. At the end of the trade show they were about to throw the stack of paper away that had been used for demos on the Selectric terminal. At just the right moment I walked up and asked, “Are you going to throw that away?” And the lady looked at me, puzzled, and said, “Here, it's yours,” as if she was giving me this big Christmas present. Which she was.</p>
<p class="normal"><b>Seibel：那张</b>纸上写的是什么？</p><p class="normal"><b>Seibel:</b> What was on that paper?</p>
<p class="normal"><b>Steele：</b>这是来自 Selectric 终端的折叠纸，过去两天他们一直在该终端上演示 APL。只是一些他们碰巧输入的小程序示例。根据他们在贸易展厅的小册子，我自学了 APL。</p><p class="normal"><b>Steele:</b> It was fan-fold paper from a Selectric terminal on which they had been demonstrating APL for the past two days. Just little programming examples of whatever they had happened to type in. And from that and the brochure they had on the trade-show floor, I taught myself APL.</p>
<p class="normal"><a id="OEBPS/Chapter09.html.page_329"></a><b>Seibel：</b>所以你在麻省理工学院过得很舒服，但你最终去了哈佛大学并在麻省理工学院工作。发生了什么？</p><p class="normal"><a></a><b>Seibel:</b> So you were very comfortable at MIT but you ended up going to Harvard and working at MIT. What happened?</p>
<p class="normal"><b>Steele：</b>当我申请大学时，我申请了麻省理工学院、哈佛大学和普林斯顿大学，并且真的很想去麻省理工学院。我三个都被录取了。波士顿拉丁学校的校长是威尔弗雷德·L·奥利里 (Wilfred L. O'Leary)，他是一位守旧的古典主义者，一位了不起的绅士。他打电话给我的父母说：“你有没有意识到你儿子在哈佛被录取后实际上正在考虑去理工学院？！” 所以他扭了他们的胳膊，他们扭了我的胳膊，最后我决定去哈佛。</p><p class="normal"><b>Steele:</b> By the time I was applying to colleges I applied to MIT, Harvard, and Princeton and really wanted to go to MIT. I got accepted at all three. The headmaster of Boston Latin School was Wilfred L. O'Leary, an old-school classicist, a wonderful gentleman. He called up my parents and said, “Do you realize that your son is actually considering going to Tech when he has an acceptance at Harvard?!” So he twisted their arms and they twisted my arm and I decided to go to Harvard after all.</p>
<p class="normal">然后我的父母帮我找一份暑期工作，而不是仅仅坐在家里——你知道，典型的综合症。我知道我对计算很感兴趣，不想做汉堡包。所以我面试了打孔工作，认为这是我有资格做的事情。但是没有人愿意雇用我，部分原因是我还不到 18 岁。直到后来我才明白这一点。他们只是听了我的故事然后说，“别打电话给我们，我们会打电话给你。”</p><p class="normal">Then my parents were on my case to get a summer job and not just sit around the house—you know, the classic syndrome. I knew I was interested in computing and didn't want to flip burgers. So I interviewed for keypunching jobs, figuring that was something I'd be reasonably qualified to do. But nobody wanted to hire me, in part because I wasn't 18 yet. I didn't figure that out until later. They just listened to my story and said, “Don't call us, we'll call you.”</p>
<p class="normal">然后大约在 7 月初，我听说麻省理工学院的 Bill Martin 在寻找 Lisp 程序员。我想，“啊哈，我知道 Lisp。” 我经常在麻省理工学院闲逛，并从人工智能实验室获得了 Lisp 文档的副本，我会偷偷溜进实验室玩电脑。那时候门是开着的——越南抗议还没有发生，这就是他们锁门的原因。我在大四的时候为 IBM 1130 实现了我自己的 Lisp。</p><p class="normal">Then around the beginning of July I heard that Bill Martin at MIT was looking for Lisp programmers. I thought, “Aha, I know Lisp.” I'd hung around MIT so much and had obtained copies of Lisp documentation from the Artificial Intelligence Lab and I would sneak into the labs and play with the computers. The doors were open in those days—the Vietnam protests had not yet happened, which is what caused them to put locks on the doors. And I had spent my senior year implementing my own Lisp for the IBM 1130.</p>
<p class="normal">所以我出现在 Bill Martin 的办公室，这个不知从哪里冒出来的瘦小子，探出头来说，“我听说你在找 Lisp 程序员。” 他没有嘲笑我。他只是看着我说，“好吧，你必须参加我的 Lisp 测验。” “好的。现在怎么样？” 所以我坐下来花了两个小时来列出问题和谜题。完成后，我把文件交给他，他花了十分钟看了一遍，然后说：“你被录用了。”</p><p class="normal">So I showed up at Bill Martin's office, this skinny kid out of nowhere, and poked my head in and said, “I hear you're looking for Lisp programmers.” And he didn't laugh at me. He just looked at me and said, “Well, you have to take my Lisp quiz.” “OK. How about now?” So I sat down and spent two hours working on a list of questions and puzzles. When I was done I gave him the papers and he spent ten minutes looking them over and said, “You're hired.”</p>
<p class="normal"><b>Seibel：</b> Lisp 是你在这个高中研究项目中实际学习的东西之一吗？</p><p class="normal"><b>Seibel:</b> Was Lisp one of the things you had actually studied in this High School Studies Program?</p>
<p class="normal"><a id="OEBPS/Chapter09.html.page_330"></a><b>Steele：</b>有一点，不过更多的是 Fortran 和其他一些东西。</p><p class="normal"><a></a><b>Steele:</b> A little bit, though it was more Fortran and some other things.</p>
<p class="normal"><b>Seibel：</b>你刚开始的时候有什么重要的导师吗？</p><p class="normal"><b>Seibel:</b> Did you have any important mentors when you were starting out?</p>
<p class="normal"><b>Steele：</b>在拉丁学校，我主要得感谢数学老师对我的鼓励。在九年级时，拉尔夫·威林斯 (Ralph Wellings) 在感恩节周末把那些书借给我，他与我达成了一项协议。他说：“我注意到你在所有数学测验中都获得了 100% 的分数。” 他说：“如果你在第五天参加测验并获得 100%，我会让你每周在机房上四节数学课。” 如果你得到的少于 100%，那么交易就结束了。” 这就是激励。在今年余下的时间里，我的测验成绩都很好——我特别努力地学习数学，这让我可以使用电脑。更好的是，第二年我的数学老师不会提供同样的优惠，这很合适，因为我不知道那一年的数学。所以他们认为这是正确的。</p><p class="normal"><b>Steele:</b> At Latin School I'd primarily have to credit the math teachers with encouraging me just the right amount. In the ninth grade Ralph Wellings, who lent me those books over the Thanksgiving weekend, struck a deal with me. He said, “I notice you've been getting 100 percent on all your math quizzes.” He said, “I'll let you spend four math classes a week in the computer room if on the fifth day you take the quiz and get 100 percent. If you ever get less than 100 percent then the deal is over.” So that was incentive. I proceeded to ace quizzes for the rest of the year—I studied math especially hard and that gave me access to the computer. Even better, the next year my math teacher would not offer the same deal, which was appropriate because I did not know the math for that year. So they judged it about right. So I had good teachers that gave me what I needed to learn all kinds of things.</p>
<p class="normal"><b>Seibel：</b>然后，随着您越来越多地接触计算机，是否有特别的人在整个过程中帮助过您？</p><p class="normal"><b>Seibel:</b> And then, as you got more involved in computers, were there particular folks who helped you along the way?</p>
<p class="normal"><b>Steele：</b>嗯，当然是 Bill Martin，他雇用了我。还有 Joel Moses，他负责 Macsyma 项目，我在麻省理工学院受雇于该项目。</p><p class="normal"><b>Steele:</b> Well, certainly Bill Martin, who hired me. And Joel Moses, who was in charge of the Macsyma project into which I was hired at MIT.</p>
<p class="normal"><b>Seibel：</b>最后你整个大学都在做那个项目？</p><p class="normal"><b>Seibel:</b> And you ended up working on that project throughout college?</p>
<p class="normal"><b>Steele：</b>是的，我在哈佛的时候一直是麻省理工学院的员工。这是暑假的全职工作，在学年期间变成了下午的工作。我会尽我最大的努力把我的课程安排在哈佛的早上，然后我可以把 T 带到麻省理工学院，在回家之前进行两三个小时的编程。</p><p class="normal"><b>Steele:</b> Yes, I was an employee of MIT all the time I was at Harvard. It was a full-time job in the summers and it became a afternoon job during the school year. I'd do my best to arrange my classes to be in the mornings at Harvard, then I could take the T down to MIT and get in two or three hours of programming before heading home.</p>
<p class="normal"><b>Seibel：</b>这就是 Macsyma 在 Lisp 中的全部工作？</p><p class="normal"><b>Seibel:</b> And that was all working on Macsyma in Lisp?</p>
<p class="normal"><b>Steele：</b>是的。我的具体工作是维护 Maclisp 解释器。JonL White 负责解释器和编译器，他几乎成了编译器大师，我负责解释器，这是一个很好的拆分。所以 JonL White 是我的导师。Macsyma 项目的所有人都把我置于他们的领导之下<a id="OEBPS/Chapter09.html.page_331"></a>翅膀。我还认识了人工智能实验室的一些人。所以当我申请麻省理工学院研究生院时，很容易被录取，因为他们已经了解我和我在做什么。</p><p class="normal"><b>Steele:</b> Yeah. My specific job was to be the maintainer of the Maclisp interpreter. JonL White had been in charge of both the interpreter and the compiler and he became pretty much the compiler guru, and I took care of the interpreter, and it was a pretty good split. So JonL White was a mentor of mine. All the people on the Macsyma project kind of took me under their <a></a>wing. I also got to know some of the people in the AI Lab. So by the time I applied to MIT for graduate school it was pretty easy to get accepted because they already knew me and what I was doing.</p>
<p class="normal"><b>Seibel：</b>你获得了计算机科学的本科学位吗？</p><p class="normal"><b>Seibel:</b> Did you get your undergrad degree in computer science?</p>
<p class="normal"><b>Steele：</b>是的。我打算成为一名纯数学专业的学生，​​并适当地安排了我的课程，然后发现我对无限维 Banach 空间没有任何直觉。这就是我参与的原因。幸运的是，出于兴趣，我已经参加了足够多的计算机课程，因此我有能力转专业。准确的说，我转的是应用数学专业。计算机科学是应用数学的一部分，应用数学是哈佛工程系的一部分。</p><p class="normal"><b>Steele:</b> Yeah. I set out to be a pure math major and arranged my courses appropriately and then discovered that I had no intuition whatsoever for infinite dimensional Banach spaces. That's what did me in. Fortunately, just out of interest, I had taken enough computer courses on the side that I was well-positioned to make the switch in major. To be precise, what I switched to was an applied math major. Computer science was part of applied math, and applied math was part of the engineering department at Harvard.</p>
<p class="normal"><b>Seibel：</b>在哈佛，你用的是什么机器？</p><p class="normal"><b>Seibel:</b> At Harvard what kinds of machines were you dealing with?</p>
<p class="normal"><b>Steele：</b> DEC PDP-10s。校园里有一台 PDP-10，但我认为它主要用于研究生工作。本科生可以使用电传终端访问哈佛租用或租赁的商业系统。</p><p class="normal"><b>Steele:</b> DEC PDP-10s. There was a PDP-10 on campus, but I think that was mostly used for the graduate work. Undergraduates had access to teletype terminals to a commercial system that Harvard was renting or leasing or something.</p>
<p class="normal"><b>Seibel：</b>对于学习编程的方式，您有什么不同的做法吗？有什么你希望你早点做的吗？</p><p class="normal"><b>Seibel:</b> Is there anything you would do differently about how you went about learning to program? Is there anything you wish you had done earlier?</p>
<p class="normal"><b>Steele：</b>这并不是说我是带着一个特定的目标出发的。我对我所走的特定道路并不后悔。回想起来，我认为我是许多有趣的巧合或祝福的幸运受益者。</p><p class="normal"><b>Steele:</b> It's not as if I set out with a particular goal in mind. I have no regrets about the particular path I took. Looking back I think I was the fortunate beneficiary of a number of interesting coincidences or blessings.</p>
<p class="normal">实际上，我现在意识到同时在麻省理工学院和哈佛大学的这种经历是一种非常不寻常的经历。我可以跑来跑去说：“河对岸的教授说的。” 而这个人会说，“哦，他充满了它；这是你应该考虑的方式。这给了我非常广泛的教育，很快。</p><p class="normal">This experience of being, in effect, both at MIT and Harvard at the same time I now realize was a very unusual experience. I could run back and forth and say, “The professor at the other end of the river says this.” And this one will say, “Oh, he's full of it; here's the way you should think about it.” That gave me a very broad education, very quickly.</p>
<p class="normal">作为一名高中生进入麻省理工学院是另一件相对不寻常的事情。并在我 15 岁时被允许玩价值百万美元的电脑，那时候一百万美元是真钱。所以不，我当然没有任何抱怨或遗憾或希望我做任何不同的事情。我也倾向于成为一个悠闲的人，并且接受事物。</p><p class="normal">Having access to MIT as a high schooler was another relatively unusual thing. And to be allowed to play with million-dollar computers when I was 15, back when a million dollars was real money. So no, I certainly don't have any complaints or regrets or wishes that I had done anything differently. I also tend to be a laid-back kind of guy and to take things as they come.</p>
<p class="normal"><a id="OEBPS/Chapter09.html.page_332"></a><b>Seibel：</b>与那时相比，您现在对编程的看法发生了最大的变化？除了了解冒泡排序不是最好的排序技术。</p><p class="normal"><a></a><b>Seibel:</b> What has changed the most in the way you think about programming now, vs. then? Other than learning that bubble sort is not the greatest sorting technique.</p>
<p class="normal"><b>Steele：</b>我想对我来说最大的变化是现在你不可能知道电脑里发生的一切。有些事情是您完全无法控制的，因为不可能了解所有软件的一切。回到 70 年代，一台计算机只有 4,000 个字的内存。可以进行核心转储并检查每个词以查看它是否符合您的预期。阅读操作系统的源代码清单并了解其工作原理是合理的。我做到了——我研究了磁盘例程和读卡器例程，并编写了我自己的变体。我觉得我好像理解了整个 IBM 1130 是如何工作的。或者至少和我想知道的一样多。你不能再那样做了。</p><p class="normal"><b>Steele:</b> I guess to me the biggest change is that nowadays you can't possibly know everything that's going on in the computer. There are things that are absolutely out of your control because it's impossible to know everything about all the software. Back in the '70s a computer had only 4,000 words of memory. It was possible to do a core dump and inspect every word to see if it was what you expected. It was reasonable to read the source listings of the operating system and see how that worked. And I did that—I studied the disk routines and the card-reader routines and wrote variants of my own. I felt as if I understood how the entire IBM 1130 worked. Or at least as much as I cared to know. You just can't do that anymore.</p>
<p class="normal"><b>Seibel：</b>在您学习编程时，有没有对您很重要的书籍？</p><p class="normal"><b>Seibel:</b> Were there books that were important to you when you were learning to program?</p>
<p class="normal"><b>Steele：</b>在 70 年代，绝对是：Knuth，<i>计算机编程的艺术</i>。</p><p class="normal"><b>Steele:</b> In the '70s, absolutely: Knuth, <i>The Art of Computer Programming</i>.</p>
<p class="normal"><b>Seibel：</b>你从头到尾看完了吗？</p><p class="normal"><b>Seibel:</b> Did you read those cover-to-cover?</p>
<p class="normal"><b>Steele：</b>非常接近封面到封面，是的。我做了尽可能多的练习，因为我觉得我有能力解决。有些人要求高等数学或其他我不明白的东西，我会略过或跳过这些。但是前两卷和第三卷的大部分内容我都读得很仔细。Aho、Hopcroft 和 Ullman 算法书——我认为那是我学习如何真正进行排序的地方。我必须走到我的图书馆才能记住其他的。我是个背包客——我保存了所有这些书。但那些是我会从头顶引用的那些。还有关于 Lisp 的书籍。由 Berkeley 和 Bobrow 编辑的 Triple-I Lisp 书：有点散乱的论文集，但我从中学到了很多有趣的东西。然后我开始阅读<i>SIGPLAN 通知</i>和<i>ACM 的通讯</i>。在那个年代， <i>CACM</i>具有真正的技术含量，非常值得一读。</p><p class="normal"><b>Steele:</b> Pretty close to cover-to-cover, yes. I worked as many exercises as I felt I was capable of tackling. Some called for higher math or other things I didn't understand, and I'd sort of gloss or skip over those. But the first two volumes and much of the third I read pretty carefully. The Aho, Hopcroft, and Ullman algorithms book—that's where I learned how to do sorting for real, I think. I'd have to step across to my library to try to remember other ones. I'm a pack rat—I've saved all these books. But those are the ones that I would cite off the top of my head. And books about Lisp. The Triple-I Lisp book edited by Berkeley and Bobrow: kind of a scatter-shot collection of papers, but I learned a lot of interesting stuff from that. And then I started reading <i>SIGPLAN Notices</i> and <i>Communications of the ACM</i>. Back in those days <i>CACM</i> had real technical content and was well worth reading.</p>
<p class="normal">我应该提两件事。首先，我在拉丁学校时参加过科学展览会，并且特别关注计算机科学项目。有一年，一位评委说：“你有没有考虑过成为一名学生？<a id="OEBPS/Chapter09.html.page_333"></a>ACM会员？” 我不知道他的名字。但从那以后我一直很感激。这对我来说是件好事。</p><p class="normal">I should mention two things. First, I did science fairs when I was at Latin School and I made a point of doing projects about computer science. One of the judges one year said, “Have you considered becoming a student <a></a>member of ACM?” I don't know his name. But I have been very thankful ever since. That was a good thing for me.</p>
<p class="normal">当我到了哈佛，如果我早上有空闲时间可以消磨，我会去拉蒙特图书馆，我会做两件事之一：我会通过《<i>科学美国人</i>》向后阅读，我会向前阅读，从一开始，在<i>ACM 的通讯中</i>。因此，我特别尝试阅读 Martin Gardner 关于数学游戏的所有专栏。我只是从<i>CACM</i>中阅读任何我感兴趣的内容。在 1972 年，该期刊只有大约 15 年的历史，因此很快就可以将它们全部翻完。</p><p class="normal">And when I got to Harvard, if I had a spare hour to kill in the morning I would go over to Lamont Library and I would do one of two things: I would read my way backwards through <i>Scientific American</i> and I would read my way forward, from the beginning, in <i>Communications of the ACM</i>. So I was, in particular, trying to pick up all of Martin Gardner's columns on mathematical games. And I just read whatever interested me out of <i>CACM</i>. In 1972 there was only about 15 years of that journal, so it didn't take that long to plow through them all.</p>
<p class="normal"><b>Seibel：</b>从某种意义上说，那时肯定比今天更容易，因为你可以用同样的方式理解整个系统，一个人也可以希望理解整个领域。</p><p class="normal"><b>Seibel:</b> It also must have been easier then than it would today in the sense that the same way you could understand whole systems, one person could hope to understand the whole field.</p>
<p class="normal"><b>Steele：</b>是的，你可能希望了解整个领域。有很多单页文章。你知道：“这是一种聪明的新哈希技术。” 我读了很多。</p><p class="normal"><b>Steele:</b> Yeah, you could hope to understand the whole field. There were lots of one-page articles. You know: “Here's a clever new hashing technique.” I read a lot.</p>
<p class="normal"><b>Seibel：</b>我经常发现较旧的论文很难进入，因为它们与旧硬件或语言的细节有关。</p><p class="normal"><b>Seibel:</b> I often find older papers are hard to get into since they're tied to the particulars of old hardware or languages.</p>
<p class="normal"><b>Steele：</b>嗯，需要是发明之母——一个想法的产生是因为它在特定的环境中是需要的。然后过了一会儿，人们认识到那个想法很重要。然后你需要去掉上下文，这样想法才能被看到，这需要几年时间。“这是一种颠倒单词位的巧妙技术，”他们用 7090 汇编语言给出了一些东西。那里有一个有趣的数学思想，但他们还没有完全抽象出来。</p><p class="normal"><b>Steele:</b> Well, necessity is the mother of invention—an idea arises because it's needed in a particular context. Then a little later it's recognized that that idea is the important thing. And then you need to strip away the context so the idea can be seen and that takes some years. “Here's a clever technique for reversing the bits of a word,” and they give something in 7090 assembly language. And there's an interesting mathematical idea there but they haven't quite abstracted yet.</p>
<p class="normal"><b>Seibel：</b>我猜这是 Knuth 的工作，对吧？</p><p class="normal"><b>Seibel:</b> I guess that's Knuth's job, right?</p>
<p class="normal"><b>Steele：</b> Knuth 和喜欢他的人，绝对如此。</p><p class="normal"><b>Steele:</b> Knuth and people like him, absolutely.</p>
<p class="normal"><b>Seibel：</b>想必在学校学习计算机科学的人会在指导下学习所有这些东西。但也有很多程序员没有经过正规培训就进入了它，在工作中学习。你对如何解决这个问题有什么建议吗？你从哪里开始，你如何<a id="OEBPS/Chapter09.html.page_334"></a>到了你可以真正阅读这些技术论文并理解它们的地步？您是否应该从 ACM 的开头开始，并尝试一直到现在？</p><p class="normal"><b>Seibel:</b> Presumably people who study computer science in school get guided through all that stuff. But there are also a lot of programmers who came into it without formal training, learning on the job. Do you have any advice for how to tackle that problem? Where do you start and how do you <a></a>get to the point where you can actually read these technical papers and understand them? Should you start at the beginning of the ACM and try to get up to the present?</p>
<p class="normal"><b>Steele：</b>嗯，首先，让我说，从一开始就阅读<i>CACM</i>的练习并不是我通过阅读文献中的所有内容成为一名伟大的计算机科学家的计划。我读它是因为我对某些东西很感兴趣，并且有内在的动力去处理那组特定的材料。所以我想有两件事：一是有内在动机想要阅读这些东西，因为你感兴趣或者因为你认为它会提高你的技能。</p><p class="normal"><b>Steele:</b> Well, first of all, let me say that that exercise of reading through <i>CACM</i> from early on wasn't my plan to become a great computer scientist by reading everything there was in the literature. I read it because I was interested in stuff and felt internally motivated to tackle that particular set of material. So I guess there are two things: one is having the internal motivation to want to read this stuff because you're interested or because you think it will improve your skills.</p>
<p class="normal">然后就是如何找到好东西的问题？当然，对于什么是好东西的看法会随着十年的变化而变化。今年被认为是真正好东西的东西可能在十年后就过时了。但我想你会去找一位经历过的导师说，你认为好的东西是什么？对我来说，好东西是 Knuth；阿霍、霍普克罗夫特和乌尔曼。杰拉尔德·温伯格 (Gerald Weinberg)<i>的《计算机编程心理学》</i>，我认为这本书在今天仍然具有很强的可读性。Fred Brooks 的<i>Mythical Man-Month</i>给了我一些见解。</p><p class="normal">Then there is the problem of how do you find the good stuff? And of course the view of what is the good stuff changes from decade to decade. Stuff that was considered the really good stuff this year may be kind of dated in ten years. But I guess you go to a mentor who's been through it and say, what do you think was the good stuff? For me the good stuff was Knuth; Aho, Hopcroft, and Ullman. Gerald Weinberg on <i>The Psychology of Computer Programming</i>, which I think is still very readable today. Fred Brooks's <i>Mythical Man-Month</i> gave me some insights.</p>
<p class="normal">在那些日子里，我经常光顾麻省理工学院书店的计算机科学书籍区，并且每月特意去那里浏览一次书架。当然现在你走进一家书店，那里有一个十倍大的计算机专区，但大部分都是关于今年如何做 C 或 Java 的。但是会有一小部分关于理论背景、算法之类的书籍。</p><p class="normal">In those days I haunted the computer-science book section of the MIT bookstore and just made a point of going through there once a month and browsing through the bookshelves. Of course now you walk into a bookstore and there's a computer section that's ten times as big, but most of it is about how to do C or Java this year. But there will be a smaller section of books about the theoretical background, algorithms, that kind of thing.</p>
<p class="normal"><b>Seibel：</b>还有另一种阅读方式，我知道你认为它很重要——阅读代码。你如何阅读一大堆你没有写的代码？</p><p class="normal"><b>Seibel:</b> There's another kind of reading, which I know you think is important—reading code. How do you find your way into a big pile of code you didn't write?</p>
<p class="normal"><b>Steele：</b>如果这是一个我知道如何使用但不知道内部如何工作的软件，我通常会选择一个特定的命令或交互并对其进行跟踪。</p><p class="normal"><b>Steele:</b> If it's a piece of software that I know how to use and just don't know how the insides work, I will often pick a particular command or interaction and trace it through.</p>
<p class="normal"><b>Seibel：</b>执行路径？</p><p class="normal"><b>Seibel:</b> The execution path?</p>
<p class="normal"><a id="OEBPS/Chapter09.html.page_335"></a><b>Steele：</b>是的。因此，如果我走到 Emacs 面前，我会说，“好吧，让我们看一下‘转发一个字符’的代码。” 我不会完全理解它，但至少它会向我介绍它使用的一些数据结构以及缓冲区的表示方式。如果我幸运的话，我可以找到一个地方加一个。一旦我理解了这一点，我就会尝试“倒转一个角色”。“杀一行。” 逐步完成越来越复杂的使用和交互，直到我觉得我已经找到了代码中一些更重要的部分。</p><p class="normal"><a></a><b>Steele:</b> Yes. So if I were walking up to Emacs, I'd say, “OK, let's take a look at the code that does ‘forward a character’.” And I won't completely understand it but at least it'll introduce me to some data structures it uses and how the buffer is represented. And if I'm lucky I can find a place where it adds one. And then once I've understood that, then I'll try “backwards a character.” “Kill a line.” And work my way up through more and more complicated uses and interactions until I feel that I've traced my way through some of the more important parts of the code.</p>
<p class="normal"><b>Seibel：</b> “跟踪”是指查看源代码的文本并在脑海中执行它，还是在调试器中启动它并逐步执行它？</p><p class="normal"><b>Seibel:</b> And would “tracing” mean looking at the text of the source code and mentally executing it, or would you fire it up in a debugger and step through it?</p>
<p class="normal"><b>Steele：</b>两种方法我都做过——在 70 年代或 80 年代，我主要在较小的代码上使用步进调试器来完成。现在的问题是从一个程序第一次启动到它开始做任何有趣的事情可能已经是一个漫长的初始化过程。因此，也许最好尝试找到主命令循环或中央控制例程，然后从那里进行追踪。</p><p class="normal"><b>Steele:</b> I've done it both ways—I've done it with a stepping debugger mostly on smaller codes back in the '70s or '80s. The problem nowadays is from the time a program first fires up until it begins to do anything interesting can already be a long initialization process. So perhaps one is better off trying to find the main command loop or the central control routine and then tracing from there.</p>
<p class="normal"><b>Seibel：</b>一旦你发现了这一点，你会设置一个断点然后从那里开始，还是只是通过心理执行来完成？</p><p class="normal"><b>Seibel:</b> And once you find that, would you set a break point and then step from there or just do it by mental execution?</p>
<p class="normal"><b>Steele：</b>我倾向于通过案头检查来做到这一点——通过实际阅读代码并思考它的作用。如果我真的需要理解整个代码，那么在某个时候我可能会坐下来尝试通读一遍。但是，在您脑海中形成某种关于事物组织方式的框架之前，您不能一开始就这样做。现在，如果你幸运的话，程序员实际上留下了一些文档，或者把东西命名得很好，或者在文件中以正确的顺序留下了东西，所以你实际上可以通读它。</p><p class="normal"><b>Steele:</b> I'd be inclined to do it by desk-checking—by actually reading the code and thinking about what it does. If I really need to understand the whole code then at some point I might sit down and try to read my way all the way through it. But you can't do that at first until you've got some kind of framework in your head about how the thing is organized. Now, if you're lucky, the programmer actually left some documentation behind or named things well or left things in the right order in the file so you actually can sort of read it through.</p>
<p class="normal"><b>Seibel：</b>那么文件中的正确顺序是什么？</p><p class="normal"><b>Seibel:</b> So what is the right order in the file?</p>
<p class="normal"><b>Steele：</b>这是一个很好的问题。令我印象深刻的是，像 Pascal 这样的编程语言的一个问题是，因为它是为一次性编译器设计的，所以文件中例程的顺序往往是自下而上的，因为您必须在使用之前定义例程他们。因此，阅读 Pascal 程序的最佳方式实际上是倒着读<a id="OEBPS/Chapter09.html.page_336"></a>因为那会给你程序的自上而下的视图。现在事情的形式更加自由，除了程序员尝试以可能对您有帮助的方式布置事情的良好品味之外，您真的不能指望任何其他事情。第三，既然我们有很好的 IDE 可以帮助您进行交叉引用，也许程序的线性顺序并不那么重要。</p><p class="normal"><b>Steele:</b> That's a very good question. It strikes me that one of the problems of a programming language like Pascal was that because it was designed for a one-pass compiler, the order of the routines in the file tended to be bottom-up because you had to define routines before you use them. As a result, the best way to read a Pascal program was actually backwards <a></a>because that would give you the top-down view of the program. Now that things are more free-form, you really can't count on anything other than the programmer's good taste in trying to lay things out in a way that might be helpful to you. On the third hand, now that we've got good IDEs that can help you with cross-referencing, maybe the linear order of the program doesn't matter so much.</p>
<p class="normal">第四，我不太喜欢 IDE 的一个原因是它们会让你很难知道什么时候真正看到了一切。在图表中走来走去，很难知道您已经触及了所有部分。而如果你有一些线性顺序，它保证会带你完成所有事情。</p><p class="normal">On the fourth hand, one reason I don't like IDEs quite so much is that they can make it hard to know when you've actually seen everything. Walking around in a graph, it's hard to know you've touched all the parts. Whereas if you've got some linear order, it's guaranteed to take you through everything.</p>
<p class="normal"><b>Seibel：</b>那么，当您现在编写代码时，您会在高级功能所依赖的低级功能之前展示更多自上而下的组织吗？</p><p class="normal"><b>Seibel:</b> So when you write code these days would you present more of a top-down organization with the high-level functions before the lower-level functions on which they depend?</p>
<p class="normal"><b>Steele：</b>我会尝试提出高层次的想法。展示这一点的最佳方式可能是展示一个中央命令和控制例程，以及它向其下派遣的事物。或者，可能重要的是首先显示数据结构，或者更重要的数据结构。重点是按顺序呈现想法，以便它们讲述一个故事，而不仅仅是一堆代码。</p><p class="normal"><b>Steele:</b> I'd try to present the high-level ideas. The best way to present that might be to show a central command-and-control routine with the things it dispatches to beneath it. Or, it might be that the important thing is to show the data structures first, or the more important data structures. The point is to present the ideas in an order such that they tell a story rather than just being a pile of code thrown together.</p>
<p class="normal">在麻省理工学院工作的一件美妙的事情是，有很多代码没有被锁起来，是由非常聪明的黑客编写的。所以我看了ITS操作系统。我阅读了 TECO 和 Lisp 的实现。还有第一个漂亮的 Lisp 打印机，由 Bill Gosper 编写。事实上，我还是一名高中生时就读过它们，然后在我的 1130 实施中复制了其中的一些内容。</p><p class="normal">One of the wonderful things about working at MIT was that there was a lot of code sitting around that was not kept under lock and key, written by pretty smart hackers. So I read the ITS operating system. I read the implementations of TECO and of Lisp. And the first pretty printer for Lisp, written by Bill Gosper. In fact I read them as a high-school student and then proceeded to replicate some of that in my 1130 implementation.</p>
<p class="normal">如果没有访问另一台计算机上现有的 Lisp 实现，我将无法为 1130 实现 Lisp。我不知道该怎么办。那是我教育的重要组成部分。我们现在面临的部分问题是，既然软件已经变得有价值并且大多数软件都是商业软件，那么我们没有很多好的代码示例可供阅读。开源运动在某种程度上帮助纠正了这一点。如果你愿意，你可以进去阅读 Linux 的源代码。阅读 TeX 的源代码是一个<a id="OEBPS/Chapter09.html.page_337"></a>有价值的练习只是因为它是大量经过深思熟虑、调试良好的代码。</p><p class="normal">I would not have been able to implement Lisp for an 1130 without having had access to existing implementations of Lisp on another computer. I wouldn't have known what to do. That was an important part of my education. Part of the problem that we face nowadays, now that software has become valuable and most software of any size is commercial, is that we don't have a lot of examples of good code to read. The open source movement has helped to rectify that to some extent. You can go in and read the source to Linux, if you want to. Reading the source to TeX was a <a></a>valuable exercise just because it was a large body of well-thought-out, well-debugged code.</p>
<p class="normal"><b>Seibel：</b>当我非常具体地需要了解某些东西是如何工作的时候，我阅读代码的运气通常最好；阅读像 TeX 这样的程序时，您的心态是什么？</p><p class="normal"><b>Seibel:</b> I usually have the best luck reading code when I have a very specific need to know how something works; what is your mindset reading a program like TeX?</p>
<p class="normal"><b>Steele：</b>有时我有一个特定的目标，因为我正在努力解决一个问题。有两次，我想，我无法通过阅读<i>The TeXbook</i>来修复我的 TeX 宏中的错误，并且有必要继续阅读<i>TeX：The Program</i>以准确了解功能的工作原理。在每种情况下，我都能在 15 分钟内找到答案，因为<i>TeX: The Program</i>有很好的文档记录和交叉引用。这本身就让人大开眼界——事实上，一个程序可以如此有组织、如此有文档、如此索引，以至于你可以快速找到一些东西。</p><p class="normal"><b>Steele:</b> Sometimes I've got a specific goal because I'm trying to solve a problem. There have been exactly two times, I think, that I was not able to fix a bug in my TeX macros by reading <i>The TeXbook</i> and it was necessary to go ahead and read <i>TeX: The Program</i> to find out exactly how a feature worked. In each case I was able to find my answer in 15 minutes because <i>TeX: The Program</i> is so well documented and cross-referenced. That, in itself, is an eye-opener—the fact that a program can be so organized and so documented, so indexed, that you can find something quickly.</p>
<p class="normal">我从中学到的另一件事是高级程序员如何组织数据结构，他如何组织代码以使其更易于阅读。Knuth 精心编排了<i>TeX: The Program</i>这样你几乎可以把它当作小说之类的来读。你可以在线性通道中阅读它。当你遇到各种各样的事情时，你可能想要来回跳跃。当然，这对他来说是一项巨大的工作，这就是为什么很少有项目是这样完成的。</p><p class="normal">The other thing I learned from it is how a master programmer organizes data structures, how he organizes the code so as to make it easier to read. Knuth carefully laid out <i>TeX: The Program</i> so you could almost read it as a novel or something. You could read it in a linear pass. You'd probably want to do some jumping back and forth as you encountered various things. Of course, it was an enormous amount of work on his part, which is why very few programs have been done that way.</p>
<p class="normal"><b>Seibel：</b>当你走到尽头时，你会带走什么？</p><p class="normal"><b>Seibel:</b> And when you get to the end, what are you going to take away?</p>
<p class="normal"><b>Steele：</b>我会对它的组织方式有一个很好的了解，并且我可能已经想到了一些关于如何更好地组织我自己的代码的想法。我认为我永远无法以 Knuth 的风格写作，就像我无法以 Faulkner 或 Hemingway 的风格写作一样。不过，读过这些作家的小说，多少会影响我对英式风格的思考。也许出于某种原因我会做出有意识的决定，<i>不要像海明威那样写作。</i>这是一次宝贵的经历。更不用说阅读一本写得很好的小说或一段写得很好的代码的乐趣了。</p><p class="normal"><b>Steele:</b> I'll have a pretty good idea of how it's organized and I may have come away with some ideas about how to organize my own code better. I don't think I'll ever be able to write in the style of Knuth any more than I could write in the style of Faulkner or Hemingway. Nevertheless, having read novels by those writers will influence my own thinking about English style a little bit. Maybe I'll make a conscious decision <i>not</i> to write like Hemingway for some reason or another. It's a valuable experience. Not to mention just the enjoyment of going through a well-written novel or a well-written piece of code.</p>
<p class="normal"><b>Seibel：</b>你写过文字程序吗？</p><p class="normal"><b>Seibel:</b> Have you ever written literate programs?</p>
<p class="normal"><a id="OEBPS/Chapter09.html.page_338"></a><b>Steele：</b>几乎不像 Knuth 那样有纪律。它影响了我思考这些问题的风格——我通常会在开始编写子程序之前写一段散文。但我并没有以几乎同样有纪律的风格来做这件事。有时我想知道他是否也这样做，当他在准备出版之前进行探索性编程时。我不知道他在那里的过程是什么样的。</p><p class="normal"><a></a><b>Steele:</b> Not in nearly the disciplined way that Knuth has. It has influenced my style in that I think about those issues—I will often actually write a paragraph of prose before beginning to write a subroutine. But I don't do it in nearly as disciplined a style. And sometimes I wonder whether he does, either, when he's doing exploratory programming before he readies it up for publication. I don't know what his process looks like there.</p>
<p class="normal"><b>Seibel：</b>所以你已经尝试过了，但它并没有让你觉得它能让编程变得更有效率或更有趣？</p><p class="normal"><b>Seibel:</b> So you've tried it but it didn't strike you as something that made programming much more productive or enjoyable?</p>
<p class="normal"><b>Steele：</b>部分原因是我不想为自己构建大量工具。他构建的工具是围绕 Pascal 组织的，然后是 C。我可以看到 Pascal，但我非常清楚 C 中的缺陷，我不确定使用有文化的编程工具是否足以克服它们。如果他为 Common Lisp 构建了文学编程工具，我可能会更快地跳到它们那里。</p><p class="normal"><b>Steele:</b> In part I didn't feel like doing a lot of tool building for myself. The tools he had built were organized around Pascal and then C. Pascal I could see but I was quite aware of the flaws in C and I wasn't sure that using literate programming tools would suffice to overcome them. If he had built literate programming tools for Common Lisp I might have jumped over to them much more quickly.</p>
<p class="normal"><b>Seibel：</b>抛开文字程序，回到阅读代码，你是否发现你可以从头到尾阅读通常写得很好的程序？还是它总是一个超文本，您必须找到自己的出路？</p><p class="normal"><b>Seibel:</b> Leaving aside literate programs and back to reading code, do you find that you can read usually well-written programs from beginning to end? Or is it always a hypertext that you have to find your way through?</p>
<p class="normal"><b>Steele：</b>我不一定反对超文本。但我认为如果一个程序写得很好，它的结构就会引导我按照某种有意义的顺序访问它的各个部分。你知道，这不仅仅是程序的作用——还有一个故事。有一个关于程序如何组织的故事，有一个关于程序预期运行的环境的故事。人们会希望这个程序会有一些东西，无论是在每个例程开始时的块注释还是单独提供的概述文档，或者只是选择变量名来以某种方式向您传达这些故事。人们希望一个优秀的程序员，一个真正优秀的程序员，<i></i>该程序确实如此。</p><p class="normal"><b>Steele:</b> I don't necessarily object to hypertext. But I think if a program is well written, there will be something about its structure that will guide me to various parts of it in an order that will make some kind of sense. You know, it's not just what the program does—there's a story. There's a story about how the program is organized, there's a story about the context in which the program is expected to operate. And one would hope that there will be something about the program, whether it's block comments at the start of each routine or an overview document that comes separately or just choices of variable names that will somehow convey those stories to you. And one would hope that a good programmer, a really good programmer, will have given thought to conveying those stories in addition to the story of <i>what</i> the program actually does.</p>
<p class="normal"><b>Seibel：</b>您最近读了哪些代码只是为了好玩？</p><p class="normal"><b>Seibel:</b> What code have you read most recently just for fun?</p>
<p class="normal"><b>Steele：</b>很难找到值得一读的好代码。我们还没有开发出一套公认的文献来说明：“这是很棒的代码；每个人都应该阅读这篇文章。” 所以它往往是一页的片段，通常在<a id="OEBPS/Chapter09.html.page_339"></a>论文，而不是现有内容中的代码块。可能我最近阅读的代码是我自己的团队作为 Fortress 实施的一部分一直在生产的东西。以及部分 Java 库。</p><p class="normal"><b>Steele:</b> It's hard to find good code that's worth reading. We haven't developed a body of accepted literature that says, “This is great code; everybody should read this.” So it tends to be one-page snippets, often in <a></a>papers, rather than chunks of code out of existing stuff. Probably the code I've read most recently is the stuff that my own team has been producing as part of the Fortress implementation. And parts of the Java libraries.</p>
<p class="normal">我阅读的最后一段代码可能只是为了好玩，它是由 George Hart 编写的。他是一位数学家，多面体方面的专家。他有一段非常有趣的代码，可以在浏览器中使用 VRML 生成和显示复杂的多面体。所以他得到了构建 VRML 代码然后将其提供给 VRML 显示器的大量 JavaScript 代码。</p><p class="normal">Probably the last substantial body of code I read just for fun was written by George Hart. He's a mathematician, a specialist in polyhedra. And he has a very interesting piece of code that will generate and display complex polyhedra using VRML within a browser. And so he's got this enormous body of JavaScript code that constructs VRML code and then feeds that to the VRML displayer.</p>
<p class="normal">我决定尝试以各种方式增强它，所以我深入阅读了他的代码。然后继续尝试对其进行各种改进并了解发生了什么：尝试制作一些更有趣的多面体等等。我还设法犯了几个严重的错误——有一个松弛算法试图展开多面体的顶点以使其更漂亮和更容易显示，偶尔我会引入数学不稳定性，这会导致奇怪的事情发生。非常有趣，我这样做纯粹是为了我自己的启迪。那大概是六七年前的事了。</p><p class="normal">I decided to try to enhance it in various ways so I went in and read his code thoroughly. And then proceeded to try to make various enhancements to it and understand what was going on: try to make some somewhat funkier polyhedra and so forth. I also managed to make several bad errors—there was a relaxation algorithm that tries to spread out the vertexes of the polyhedra to make it prettier and easier to display, and occasionally I'd introduce mathematical instabilities which would cause grotesque things to happen. Tremendous fun, and I was doing this purely for my own edification. That was probably six or seven years ago.</p>
<p class="normal"><b>Seibel：</b>阅读和修改交织在一起的程度如何？你能坐在一张有打印输出的桌子旁阅读，或者在不执行它的情况下坐在电脑前看，看看如果你在那儿摆弄一点点会发生什么吗？</p><p class="normal"><b>Seibel:</b> How much did the reading and the modification intertwine? Can you read sitting at a table with a printout or at a computer without executing it to see what happens if you twiddle that little bit there?</p>
<p class="normal"><b>Steele：</b>嗯，事实上，我确实在纸上打印了代码。我会坐在办公桌前阅读。并且经常标记它并做注释并问自己问题和类似的事情。然后我会回到电脑前开始输入内容，看看它的表现如何。并追踪它。</p><p class="normal"><b>Steele:</b> Well I did, in fact, print out the code on paper. I would sit at a desk and read it. And very often mark it up and make annotations and ask myself questions and things like that. And then I'd go back to the computer and start typing in things and see how it behaved. And tracing it.</p>
<p class="normal"><b>Seibel：</b>在这种情况下，你想修改它，所以你就这么做了。但是你能从阅读代码中得到一些好处或乐趣吗？打印出来，阅读，也许在上面涂写一些问题，然后记下来？</p><p class="normal"><b>Seibel:</b> In this case you wanted to modify it, so that's what you did. But could you get some benefit or enjoyment out of just reading the code? Print it out, read it, maybe scribble some questions on it, and then put it down?</p>
<p class="normal"><b>Steele：</b>是的。如果我在那一点上停下来，那将是一个值得的练习，只是阅读了代码。它教会了我一些关于 VRML 的知识；它教会了我一些关于 JavaScript 的东西，那就是它没有我想要的那么多抽象。动态类型对我来说有点太自由了——在一种面向对象的语言中。</p><p class="normal"><b>Steele:</b> Yes. If I had stopped at that point, it would have been a worthwhile exercise, just having read the code. It taught me something about VRML; it taught me something about JavaScript, which is that it doesn't have as many abstractions as I would like. The dynamic typing was a little bit too free-form for my taste—in an object-oriented language.</p>
<p class="normal"><a id="OEBPS/Chapter09.html.page_340"></a><b>Seibel：</b>那么让我们谈谈软件设计。这些天您编写的代码不像以前那么多了，但是您是如何着手设计新软件的呢？你是坐在电脑前开始编码，还是拿着一叠方格纸坐下，还是​​什么？</p><p class="normal"><a></a><b>Seibel:</b> So let's talk a little bit about designing software. You're not coding as much these days as you used to, but how did you go about designing a new piece of software? Do you sit down at a computer and start coding or do you sit with a pad of graph paper, or what?</p>
<p class="normal"><b>Steele：</b>我在这里非常谨慎，因为很容易有修正主义的记忆，然后说，“哦，好吧，回到 70 年代，这就是我应该做的，所以我一定是这样做的” 我试图记住我做过的真实事情。</p><p class="normal"><b>Steele:</b> I'm being very cautious here because it's all too easy to have a revisionist memory and say, “Oh, well, back in the '70s this is the way I should have done it so that must be the way I did it.” I'm trying to remember actual things I did.</p>
<p class="normal">有时我会画流程图——我有一个 IBM 流程图模板和这样的纸本。而且我在结构化编程时代之前就学会了编程，所以我的一些设计是结构化的，而另一些则不是。当我意识到结构化编程时，我认识到其中的一些好想法，我认为在 70 年代，我的汇编语言编程在本质上变得更加结构化，我明确地考虑制作 if/then/else 路径和循环以及类似的东西然后我更多地考虑了我的汇编语言代码的结构。</p><p class="normal">Sometimes I would draw flowcharts—I did have an IBM flowcharting template and pads of such paper. And I learned to program before the structured programming era, so some of my designs were structured and some of them weren't. As I became aware of structured programming I recognized some of the good ideas in that and I think during the '70s my assembly language programming became more structured in nature and I was thinking explicitly of making if/then/else paths and loops and things like that and I thought more about the structure of my assembly-language code.</p>
<p class="normal">我经常会列出清单，描述我希望能够提供给程序的输入类型，然后写下我想要的输出类型的描述。或者我有时会编一些简短的例子。我最近发现了一个我写过的最早的 APL 程序的例子。当时我大概 15 或 16 岁。我拥有的是一段 APL 代码——这是我在实际尝试之前在纸上记下的第一件事。随附的是另一张纸，这是我认为输入/输出交互的示例。它有错误并且与代码不匹配等等，但至少我正在努力尝试产生一些我认为使用这个程序会是什么样子的例子。这正是我认为终端抄本在打印终端上的样子。</p><p class="normal">I would often make lists describing the kinds of inputs I wanted to be able to give to a program and then write down a description of what kind of output I wanted. Or I would sometimes make up short examples. I recently found an example of one of the earliest APL programs that I ever wrote. I was probably 15 or 16 at the time. And what I had was a piece of APL code—this was the first thing I jotted down on paper before I'd actually tried it out. And enclosed was another piece of paper, which was an example of what I thought the input/output interaction would look like. It has bugs in it and doesn't match the code and so forth but at least I was struggling to try to produce some examples of what I thought it would be like to use this program. It was exactly what I thought the terminal transcript would look like, on a printing terminal. Here's a series of interactions that I think we can cause with this program.</p>
<p class="normal">一旦我开始从事 Maclisp 项目，它就提供了一个结构。我所做的几乎所有事情都是将一个新函数添加到已经存在的大量函数集合中。已经有很多关于函数文档应该是什么样子的例子，所以这只是添加到那堆文件中的问题。</p><p class="normal">Once I started working on the Maclisp project, that provided a structure. Nearly everything I did was a new function being added to an already existing large collection of functions. There were already plenty of examples of what documentation of functions ought to look like so it was just a matter of adding to that pile.</p>
<p class="normal"><a id="OEBPS/Chapter09.html.page_341"></a><b>Seibel：</b>你说你从 JonL 那里接手了解释器，JonL 一直在做解释器和编译器。</p><p class="normal"><a></a><b>Seibel:</b> You said you took over the interpreter from JonL, who had been doing both the interpreter and the compiler.</p>
<p class="normal"><b>Steele：</b>我们会在设计工作上进行合作。我是初级成员，所以他会说，“这是我们应该拥有的功能，它应该如何工作；你为什么不去编码呢。” 或者，更常见的是，我们会收到来自 Macsyma 实施者的请求，他们说，“我们需要一些东西来做这件事，”而 JonL 和我会集思广益，说，“好吧，我们为什么不设计一个看起来像这样，”然后我会开始编写代码。</p><p class="normal"><b>Steele:</b> We'd collaborate on the design work. I was the junior member so he'd say, “Here's a function we should have and here's how it should work; why don't you go code it.” Or, more often, we'd get requests from the Macsyma implementers saying, “We need something to do this,” and JonL and I would put our heads together and say, “Well, why don't we design an interface that looks this way,” and I then would go off and code it.</p>
<p class="normal"><b>Seibel：</b>那么这些是添加到 Maclisp 的新语言特性，必须在解释器和编译器中实现吗？</p><p class="normal"><b>Seibel:</b> So those were new language features being added to Maclisp that had to be implemented in the interpreter and the compiler?</p>
<p class="normal"><b>Steele：</b>是的，语言特征。许多面向系统的风格——他们需要能够控制资源或分配页面。我实现了一种称为“hunk”的新数据类型，这可能是我们在语言设计中遇到的最大灾难。它本质上是一个具有两个以上指针的cons cell。这是一个绝望的举动，因为我们在 PDP-10 上的地址空间已经用完了。回想一下，10 只有一个 18 位地址空间。在一个列表中，50% 的指针专门用于维护列表的结构，而对于一组线程化的大块，可能只有八分之一的指针专门用于块的线程化，所以你会变得更好内存使用情况。</p><p class="normal"><b>Steele:</b> Yeah, language features. Many of a systems-oriented flavor—they needed to be able to control resources or allocate pages. I implemented a new data type called a “hunk,” which was probably the biggest disaster in language design we ever put in. It was essentially a cons cell with more than two pointers. It was a desperation move because we were running out of address space on the PDP-10. Recall that the 10 only had an 18-bit address space. In a list, 50 percent of the pointers were dedicated to just maintaining the structure of the list, whereas with a threaded set of hunks, maybe only one-eighth of the pointers were dedicated to the threading of the chunks so you'd get better memory usage that way.</p>
<p class="normal"><b>Seibel：</b>所以你有这样的功能请求流——鉴于它是增量的，你是如何保持某种连贯性的？如果你只是不断地以最明显的方式添加一个东西，最终你会得到一大堆勉强能粘在一起的杂物。</p><p class="normal"><b>Seibel:</b> So you had this stream of requests for features—given that it was incremental, how did you maintain some kind of coherence? If you just keep adding one thing in the most obvious way, eventually you end up with a big pile of kludges that barely holds together.</p>
<p class="normal"><b>Steele：</b>有过一两次大的重组。我认为最值得注意的可能是语言中所有输入/输出操作的完全重新设计和重新实现。这就是所谓的新 I/O 设计，我想说的是，1975 年或 76 年，我在那里的某个地方从事的工作。目标是旧的 I/O 系统只允许一个输入流和一个输出流，并且能够与控制台交互。我们意识到，如果我们可以拥有代表 I/O 通道的实际 Lisp 对象，那么我们可以打开多达 15 个 I/O 通道，这将更加灵活。</p><p class="normal"><b>Steele:</b> There were one or two big reorgs. I think probably the most notable one was the complete redesign and reimplementation of all the input/output operations in the language. This was the so-called New I/O design, something I undertook in, I want to say, 1975 or '76, somewhere in there. The goal was that the old I/O system allowed for only one input stream and one output stream, plus being able to interact with the console. We realized that it would be a lot more flexible if we could have actual Lisp objects that stood for I/O channels and then we could have as many as 15 I/O channels open.</p>
<p class="normal"><a id="OEBPS/Chapter09.html.page_342"></a>推动这一切的另一件事是 Maclisp 开始被移植到其他操作系统。每个站点都有自己的 PDP-10 操作系统变体。当我们审视我们拥有的所有客户时，我们意识到我们想要支持六种不同的操作系统：TENEX、TWENEX、ITS、TOPS-10、WAITS 和 CMU 变体。</p><p class="normal"><a></a>The other thing that was pushing this was that Maclisp was beginning to be ported to other operating systems. Every site had its own variant of the PDP-10 operating system. When we looked at all the customers we had, we realized there were a half a dozen different operating systems we wanted to support: TENEX, TWENEX, ITS, TOPS-10, WAITS, and the CMU variant.</p>
<p class="normal">所以有一个夏天，我和 JonL 坐下来，我们设计了一套新的 API。我们当时不称它们为 API，而是描述可用于创建文件对象、打开和关闭它们、系统地执行“删除”和“重命名”等操作以及获取目录列表的功能.</p><p class="normal">So there was a summer when I sat down with JonL and we designed a new set of APIs. We didn't call them APIs at the time, but it was descriptions of functions that could be used to create file objects, open and close them, do things like “delete” and “rename” in a systematic way, and get directory listings.</p>
<p class="normal">然后有一段时间，我在纸上列出了所有 Maclisp 的新清单，带着六套操作系统手册和清单回到我父母的避暑别墅呆了一个星期，每天花六个小时在代码。</p><p class="normal">Then there was a point where I took a fresh listing of all of Maclisp on paper and retreated to my parents' summer home for a week with six sets of operating-systems manuals and the listing and spent six hours a day scribbling corrections and changes in the code.</p>
<p class="normal">我必须弄清楚每个功能（例如“重命名”功能）是如何完成的，因为在这六个操作系统中，您如何与操作系统交互以重命名文件的细节非常不同。但它往往分为三个集群——TOPS-20 变体、TOPS-10 变体和 ITS。</p><p class="normal">I had to figure out for each feature, such as the “rename” function, how is that done, because the details of how you interact with the operating system to rename a file were very different among those six operating systems. But it tended to fall into three clusters—the TOPS-20 variants, the TOPS-10 variants, and ITS.</p>
<p class="normal">我花了整整一周的时间来做这件事，并且注意到，在没有坐在计算机终端前的情况下进行设计和实施。这都是案头工作。一周后，我回到麻省理工学院，并在接下来的一个月里将其全部输入并调试和测试。</p><p class="normal">I spent a solid week doing that, and notice, doing design and implementation without sitting at a computer terminal. This was all desk work. And then after a week of that, I came back to MIT and spent the next month typing it all in and debugging and testing it.</p>
<p class="normal"><b>Seibel：</b>你为什么那样做？</p><p class="normal"><b>Seibel:</b> Why did you do it that way?</p>
<p class="normal"><b>Steele：</b>我这样做是因为对于我必须编写的每个功能，都必须先进行大量研究。正如我所说，我必须阅读六种操作系统的规范。而且我将不得不花一个小时这样做，然后编写 30 行代码，可能是三倍。当它不会给我买那么多东西时，坐在终端前似乎没有意义。好像我可以谷歌一些东西或访问在线文档。我大部分时间都没有打字。最好将那个办公桌空间用于我面前的纸质文件。</p><p class="normal"><b>Steele:</b> I did it that way because for every function I had to write, it would have to be preceded by an enormous amount of research. As I say, I'd have to read the specification for six operating systems. And I would have to spend an hour doing that and then write the 30 lines of code, probably times three. It didn't seem to make sense to be sitting in front of a terminal when it wasn't going to be buying me that much. It's not as if I could Google something or access online documentation. I wasn't spending most of the time typing. Better to use that desk space for the paper documents in front of me.</p>
<p class="normal"><a id="OEBPS/Chapter09.html.page_343"></a><b>Seibel：</b>在今天的某些情况下，您认为关闭计算机和清理办公桌是正确的做法吗？</p><p class="normal"><a></a><b>Seibel:</b> Are there situations today where you think turning off the computer and clearing your desk is the right approach?</p>
<p class="normal"><b>Steele：</b>是的，我仍然这样做。事实上，我发现我真的必须关闭电脑，因为如果风扇在我身后呼呼作响，就会有“检查你的电子邮件，检查你的电子邮件”的诱惑。所以我会把它关掉或者至少让它进入睡眠状态，然后走到房间另一边的这张桌子旁，摊开我的文件思考一下。或者在白板上工作什么的。</p><p class="normal"><b>Steele:</b> Yeah, I still do that. In fact, I find that I literally have to turn off the computer because if the fan is whirring behind me there's the lure of “Check your email, check your email.” So I'll turn it off or at least put it to sleep, come over to this table on the other side of the room, and spread out my papers and think. Or work at the whiteboard or something.</p>
<p class="normal"><b>Seibel：</b>我读过一些东西，你转述了 Fred Brooks 关于流程图和表格的话，说，“给我看你的界面，我就不需要你的代码，因为它会是多余的或不相关的。” 当您使用 Java 这样的语言工作时，您的设计是从接口开始的吗？</p><p class="normal"><b>Seibel:</b> I read something where you paraphrased Fred Brooks's saying about flowcharts and tables, saying, “Show me your interfaces and I won't need your code because it'll be redundant or irrelevant.” When you're working in a language like Java, do you start your designs from interfaces?</p>
<p class="normal"><b>Steele：</b>是的，我变得比以前更注重界面了。没有代码的方法的输入、操作和输出的描述。我喜欢写那些东西。我也喜欢编写实现它的代码，但现在我做的比以前少了。当然，拥有这样做的经验很重要，这样您就不会设计出不可能的规格。在设计界面时，您应该知道实现的样子。您至少应该对实施有一个想法。然后，如果有人带来更好的，那很好。</p><p class="normal"><b>Steele:</b> Yeah, I've become much more interface-oriented than I used to be. Descriptions of the inputs and actions and outputs of methods with no code. I love writing that stuff. I also enjoy writing the code that implements it, but I do less of that nowadays than I used to. And of course it's important to have had an experience doing that so you don't design impossible specifications. You should have an idea what the implementation is going to look like as you design the interface. You should at least have an idea for the implementation. Then if someone comes along with a better one, that's fine.</p>
<p class="normal"><b>Seibel：</b>除了实现它的可能性之外，您如何确定您的接口是否良好？</p><p class="normal"><b>Seibel:</b> Other than the possibility of implementing it at all, how do you decide whether your interfaces are good?</p>
<p class="normal"><b>Steele：</b>我通常会考虑通用性和正交性。符合公认的做事方式。例如，除非有充分的理由，否则您不会将除数放在被除数之前，因为在数学中我们习惯于以相反的方式进行。所以你考虑传统的做事方式。</p><p class="normal"><b>Steele:</b> I usually think about generality and orthogonality. Conformance to accepted ways of doing things. For example, you don't put the divisor before the dividend unless there's a really good reason for doing so because in mathematics we're used to doing it the other way around. So you think about conventional ways of doing things.</p>
<p class="normal">我已经做了足够多的设计，以至于我会思考我以前做过的方式，以及它们是好是坏。我也在设计一些我之前已经设计过的相关东西。因此，例如，在查看 Java 中数字函数的规范时，我已经完成了 Common Lisp 的数字函数。我还记录了 C 的数字函数。我知道这些东西的一些实现陷阱和一些规范陷阱。我花了很多时间担心边缘情况。<a id="OEBPS/Chapter09.html.page_344"></a>这是我从 Trenchard More 和他的 APL 阵列理论中学到的东西。他的论点是，如果你处理边缘情况，那么中间的事情通常会自行处理。好吧，他不是那样说的；我想这就是我从他那里得出的结论。</p><p class="normal">I've done enough designs that I think about ways I've done it before and whether they were good or bad. I'm also designing relative to some related thing that I've already designed before. So, for example, while looking at the specifications for numeric functions in Java, I'd already done numeric functions for Common Lisp. And I'd documented numeric functions for C. I knew some of the implementation pitfalls and some of the specification pitfalls for those things. I spent a lot of time worrying about edge cases. <a></a>That's something I learned from Trenchard More and his array theory for APL. His contention was that if you took care of the edge cases then the stuff in the middle usually took care of itself. Well, he didn't say it that way; I guess that's the conclusion I draw from him.</p>
<p class="normal">要扭转局面，您需要设计中间部分的规范，使其在边界上自然也是正确的，而不是将边界视为特殊情况。</p><p class="normal">To turn it around, you want to design the specification of what's in the middle in such a way that it naturally is also correct on the boundaries, rather than treating boundaries as special cases.</p>
<p class="normal"><b>Seibel：</b>在麻省理工学院期间，您以某种方式参与了 Emacs 的诞生。但 Emacs 的早期历史有点模糊。你的故事版本是什么？</p><p class="normal"><b>Seibel:</b> During your time at MIT you were somehow involved in the birth of Emacs. But the early history of Emacs is a bit hazy. What is your version of the story?</p>
<p class="normal"><b>Steele：</b>我的故事版本是我在扮演标准人。发生的事情是这种显示模式将 TECO 变成了类似于 WYSIWYG 编辑器的东西。在我们的 24×80 屏幕上，缓冲区中的 21 行内容将显示在屏幕上，底部 3 行仍然是 TECO 命令行。你会输入这些 TECO 命令，只有当你点击双 altmode 时它们才会被执行。然后是实时编辑模式，其中建议 TECO 命令将您带到另一种模式，而不是等待您键入双 altmode，TECO 会立即对单字符命令做出反应。如果您键入一个字符，它就会执行命令。你键入另一个字符，它会执行命令。大多数印刷字符都是自插入的。然后使用控制字符向前、向后、向上和向下移动。它非常非常原始——它看起来像一个非常原始的 Emacs 版本。</p><p class="normal"><b>Steele:</b> My version of the story was that I was playing standards guy. What had happened was there was this display mode that turned TECO into something like a WYSIWYG editor. On our 24×80 screens, 21 lines of what was in the buffer would be shown on the screen and the bottom 3 lines were still a TECO command line. You'd be typing in these TECO commands and only when you hit the double altmode would they then be executed. Then there was the real-time edit mode, where it was suggested that a TECO command throw you in this other mode whereby instead of waiting for you to type the double altmode, TECO would react immediately to single character commands. If you type one character, it would do the command. You type another character, it would do the command. And most printing characters were self-inserting. Then the control characters were used to move forward, back, up, and down. It was a very, very primitive—it looked like a very primitive version of Emacs.</p>
<p class="normal">然后是突破。建议是，我们有这样的想法，即获取一个字符并在表中查找它并执行 TECO 命令。为什么我们不将其应用于实时编辑模式？这样您可以键入的每个字符都用作此表中的查找字符。默认表说，打印字符是自插入的，控制字符做这些事情。但是让我们让它可编程，看看会发生什么。立即发生的是麻省理工学院周围四五个不同的聪明人对如何处理它有自己的想法。在短短几个月内，出现了五个与 TECO 完全不兼容的 GUI 界面。</p><p class="normal">Then came the breakthrough. The suggestion was, we have this idea of taking a character and looking it up in a table and executing TECO commands. Why don't we apply that to real-time edit mode? So that every character you can type is used as a lookup character in this table. And the default table says, printing characters are self-inserting and control characters do these things. But let's just make it programmable and see what happens. And what immediately happened was four or five different bright people around MIT had their own ideas about what to do with that. Within just a few months there were five completely incompatible GUI interfaces to TECO.</p>
<p class="normal"><a id="OEBPS/Chapter09.html.page_345"></a><b>Seibel：</b>所以他们只是在本质上定制键绑定？</p><p class="normal"><a></a><b>Seibel:</b> So they were just customizing, essentially, the key-bindings?</p>
<p class="normal"><b>Steele：</b>没错。他们每个人都有自己的想法，关于什么应该简洁，因为你最常这样做，什么是你可以承受得起更长的时间。因此，举个例子，一个人非常关心 Lisp 代码的输入，并开始尝试寻找平衡的括号表达式。另一个人对文本更感兴趣，所以他对可以在单词上移动并在大写和小写之间转换并将它们大写的命令感兴趣。这就是 Emacs 中的那些命令的来源。</p><p class="normal"><b>Steele:</b> That's right. And they each had their own ideas about what should be concise because you do it most often and what you can afford to be longer. So one guy, for example, was really concerned about typing in Lisp code and began to experiment with finding balanced parenthesized expressions. And another guy was more interested in text, so he was interested in commands that would move over words and convert between uppercase and lowercase and capitalize them. And that's where those commands in Emacs came from.</p>
<p class="normal">不同的人对于键绑定应该如何组织有不同的想法。作为 Lisp 的系统支持人员，我经常被叫到人们的终端并要求帮助他们。我很快就注意到我不能坐在他们的 TECO 帮助他们修改他们的程序，因为我会面对一组键绑定而且我不知道他们要做什么。</p><p class="normal">Different people had different ideas about how the key-bindings ought to be organized. As a systems-support guy for Lisp, I was often called to people's terminals and asked to help them. And I fairly quickly noticed that I couldn't sit down at their TECOs and help them modify their programs because I'd be faced with a set of key-bindings and I had no idea what they were going to do.</p>
<p class="normal"><b>Seibel：</b> Richard Stallman 是这些人中的一员吗？</p><p class="normal"><b>Seibel:</b> Was one of these guys Richard Stallman?</p>
<p class="normal"><b>Steele：</b>不，Stallman 是 TECO 的实施者和支持者。他还提供了内置的实时编辑模式功能，尽管我认为 Carl Mikkelsen 已经开发了它的早期版本。他提供了使所有这一切成为可能的键绑定功能。</p><p class="normal"><b>Steele:</b> No, Stallman was the implementer and supporter of TECO. And he provided the built-in real-time edit mode feature, although I think Carl Mikkelsen had worked on the early version of it. He provided the key-bindings feature that made all of this possible.</p>
<p class="normal">不管怎样，有四个不同的宏包，它们互不兼容，我决定扮演标准专家或社区协调专家的角色。我看到了我们社区中丢失的一些东西，那就是在我们的终端轻松地互相帮助的能力。我说，“好吧，我们已经做了一些实验；我们已经看到了很多想法。如果我们可以就一组通用的键绑定达成一致，并从其中的每一个中得出最好的想法呢？”</p><p class="normal">Anyway, there were something like four different macro packages and they were incompatible, and I decided to play standards guy, or community reconciliation guy. I saw something that had been lost in our community, which was the ability to easily help each other at our terminals. I said, “OK, we've had some experimentation; we've seen a bunch of ideas. What if we could agree on a common set of key-bindings and draw the best ideas from each of these things?”</p>
<p class="normal">我真的拿着一张纸在大楼里跑来跑去，和这些人交谈，拜访他们每个人几次，并试图达成某种共识。我试图就内容应该是什么达成共识，然后我借鉴了他们的设计并尝试组织键绑定的实际选择，以使它们更规则，更便于记忆。而且根本不是一个人为因素的人，我根本没想到<a id="OEBPS/Chapter09.html.page_346"></a>关于触摸打字员的便利性。我主要关心助记值。这就是为什么 Meta-C、Meta-L 和 Meta-U 代表大写字母、小写字母和大写字母。</p><p class="normal">I literally had a pad of paper and ran around the building, talking to these guys, visiting each of them several times, and tried to get some kind of consensus. I was trying to get consensus on what the content ought to be and then I drew on their designs and tried to organize the actual choice of key-bindings so as to make them a little more regular and a little more mnemonic. And not being a human-factors guy at all, I didn't think at all <a></a>about convenience for touch typists. I was principally concerned with mnemonic value. And so that's why Meta-C and Meta-L and Meta-U stand for capitalize and lowercase and uppercase.</p>
<p class="normal"><b>Seibel：</b>考虑到命令从大脑转移到手指的方式，这有点讽刺。我相信您一定经历过这样的现象，有人问您每天使用一千次的东西的键绑定是什么，而您却说不出来。</p><p class="normal"><b>Seibel:</b> Which is sort of ironic given the way the commands move out of your brain and into your fingers. I'm sure you have experienced the phenomenon of having someone ask you what is the key-binding for something that you use a thousand times a day, and you can't say.</p>
<p class="normal"><b>Steele：</b>其实我妻子有过这样的经历。也许我不太了解它的原因之一是我不是一个特别好的触摸打字员。但她已经离开 Emacs 20 年了，然后我在她的 Macintosh 上提供了一个。她坐下来，输入了一些东西，然后说，“我该如何保存它？我忘记了如何保存文件。” 然后她意识到她的手指已经做到了，她不知道她输入了什么。所以她又做了一次，<i>看着</i>自己的手指说：“哦，是的，Control-X Control-S。” 但她真的不记得命令是什么。</p><p class="normal"><b>Steele:</b> Actually my wife had that experience. Maybe one of the reasons I was less aware of it is that I'm not a particularly good touch typist. But she'd been away from Emacs for 20 years and then I made one available on her Macintosh. And she sat down, typed in some stuff, and then said, “How do I save this? I forget how to save a file.” And then she realized her fingers had done it and she didn't know what she'd typed. So she did it again and <i>watched</i> her fingers and said, “Oh yes, Control-X Control-S.” But she literally couldn't remember what the commands were.</p>
<p class="normal"><b>Seibel：</b>所以你制作了这套标准的键绑定。那是怎么过去的？人们对此感到满意吗？</p><p class="normal"><b>Seibel:</b> So you made this standard set of key-bindings. How did that go over? Were people happy with it?</p>
<p class="normal"><b>Steele：</b>嗯，人们经历过它。然后我坐下来开始实施它。我们同时想到了另一个想法，如果你挤出空间并删除所有评论，你可以让 TECO 宏运行得更快。TECO 解释器的工作方式是一次解释一个字符，当您遇到评论时，它不得不花时间跳过该评论。所以我们有了这个非常原始的 TECO 编译器的想法，它主要只是挤出空白和注释，并做一些其他的小事情来把它放在一个运行得更快的形式中。</p><p class="normal"><b>Steele:</b> Well, people worked through it. Then I sat down and proceeded to begin an implementation of it. And we had another idea that came into the mix at the same time and it was the idea that you could make TECO macros run a lot faster if you squeezed out the spaces and deleted all the comments. The way the TECO interpreter worked, interpreting one character at a time, when you encountered a comment it had to spend the time skipping over that comment. So we had this idea of this very primitive TECO compiler that was mostly just squeezing out the white space and the comments and doing a few other minor things to put it in a form that would run a little bit faster.</p>
<p class="normal">所以我开始以最初的方式尝试构建这个宏压缩器的一个版本，我认为这实际上是基于 Moon 早先的想法。我不认为我提出了这个想法。我开始思考如何组织初始调度并组织一些前几个例程借用其他宏包的现有实现——我试图综合它们。就在这时，斯托曼走过来说，“你在做什么？这看起来很有趣。” 他立马跳了起来<a id="OEBPS/Chapter09.html.page_347"></a>他的实施速度是我的十倍，部分原因是他对 TECO 了如指掌。</p><p class="normal">So I began in an initial way to try to construct a version of this macro compressor, which I think was actually based on an earlier idea that Moon had had. I don't think I originated that idea. I began to think about how to organize the initial dispatch and organize some of the first few routines borrowing on the existing implementations of other macro packages—I was trying to synthesize them. And about that point Stallman came along and said, “What are you doing? This looks interesting.” He immediately jumped <a></a>in and he could implement ten times as fast as I could, partly because he knew TECO inside out.</p>
<p class="normal">因此，我认真地致力于 Emacs 的实现，大概只用了大约四到六周的时间。在这一点上，很明显 Stallman 明白了这个程序是什么。我想回去做研究生的事情。所以 Stallman 完成了其余 99.999% 的工作。但我在催化它并开始实施方面发挥了作用。</p><p class="normal">So I worked seriously on the implementation of Emacs probably for only about four or six weeks. At which point it became clear that Stallman understood what the program was. I wanted to get back to doing graduate-student things. So Stallman did the other 99.999 percent of the work. But I played a role in catalyzing it and beginning the implementation.</p>
<p class="normal"><b>Seibel：</b>在另一个主题上，如今学术计算机科学非常数学化。对于工作的程序员来说，能够理解 Knuth 中的数学有多重要？而不是说，“我需要排序；我要翻阅 Knuth 并跳到他说“这是最好的算法”并实现它的地方”？</p><p class="normal"><b>Seibel:</b> On a different subject, academic computer science is very mathematical these days. How important is it for working programmers to be able to understand, say, the math in Knuth? Versus saying, “I need to sort things; I'm going to flip through Knuth and skip to where he says, ‘This is the best algorithm’ and implement that”?</p>
<p class="normal"><b>Steele：</b>我不知道。Knuth 的某些部分我不理解，因为我没有受过数学训练。特别是如果它涉及更高或连续的数学。我在这方面比较弱。我认为我的优势在于组合学和排列、群论等方面。我发现自己一遍又一遍地使用它。也许那是因为那是我手头的特殊锤子。我不认为每个程序员都需要它。但我认为数学将程序员每天确实需要处理的概念形式化。</p><p class="normal"><b>Steele:</b> I don't know. There are parts of Knuth that I don't understand because I don't have the mathematical training. Particularly if it involves higher or continuous math. I'm a little weaker on that. I think my strengths are in things like combinatorics and permutations, group theory, things like that. And I find myself using that over and over and over again. Maybe that's because that's the particular hammer I have at hand. I don't think that every programmer needs that. But I think that mathematics formalizes concepts that programmers do need to work with every day.</p>
<p class="normal">我会给你一个例子，来自我最近关于并行语言的编程语言工作，我正在进行的这个 Fortress 项目。假设你想把一堆数字加起来。好吧，您可以做的一件事是将寄存器初始化为零，然后一次添加一个数字——这是一种经典的顺序技术。</p><p class="normal">I'll give you an example from my recent programming-language work on parallel languages, this Fortress project that I've got going. Suppose you want to add up a bunch of numbers. Well, one thing you can do is you can initialize a register to zero and add in the numbers one at a time—a classic sequential technique.</p>
<p class="normal">请注意，这取决于具有标识的加法运算。你需要从零开始。琐碎的小观察，但它就在那里。</p><p class="normal">Notice that this depends on the addition operation having an identity. You needed to start with zero. Trivial little observation, but it's there.</p>
<p class="normal">现在这里有另一种策略——你可以将所有数字排成一行，然后将它们成对相加，得到一堆总和，并继续成对相加，直到你只剩下一个数字。当然，如果在任何时候你有奇数个，你只需留下那个额外的，让它进入下一阶段，依此类推。好吧，那也很好用。如果你使用浮点数，它实际上可能会给你带来更好的效果<a id="OEBPS/Chapter09.html.page_348"></a>准确性，尽管由于簿记开销有时不值得。</p><p class="normal">Now here's another strategy—you can lay out all the numbers in a row and then add them up pairwise, giving you a bunch of sums, and keep adding pairwise until you've only got one number left. And of course if at any point you've got an odd number of them you just leave that one over extra and let it go to the next stage and so forth. Well, that works fine, too. And if you're using floating-point numbers it may actually give you a little bit better <a></a>accuracy, although with the bookkeeping overhead it's sometimes not worth it.</p>
<p class="normal">请注意，这将给你相同的答案，至少如果你使用整数，就像从零开始并一次加一个一样。这取决于加法是结合的这一事实。换句话说，以何种方式对数字进行分组并不重要。</p><p class="normal">Notice thaat this will give you the same answer, at least if you're working with integers, as starting with zero and adding them one at a time. This depends on the fact that addition is associative. In other words, it doesn't matter in what way you group the numbers.</p>
<p class="normal">然后是第三种策略。假设你有一堆处理器。您可以将这些对分配给处理器并分发该工作。“从零开始，一次加一个”算法很难并行化，但是通过成对的聚类，你实际上已经做了一棵树，你可以为树的不同部分分配处理器，他们可以做他们自己的事情独立的部分，只有在最后他们才需要互动，你就得到了总和。</p><p class="normal">And then there's a third strategy. Suppose you've got a bunch of processors. You could parcel out the pairs to the processors and distribute that work. The “start with zero and add them one at a time” algorithm is hard to parallelize, but with the bunching in pairs, you've in effect made a tree and you can assign processors different parts of the tree, and they can do their parts independently, and only at the end do they need to interact and you get the sum.</p>
<p class="normal">好的，这很酷。这是另一个更像第一个的并行策略：选择一些寄存器并将其初始化为零，然后让处理器竞争获取数字并将它们添加到那个公共位置。这涉及同步问题，但你仍然会得到相同的答案。但这取决于加法同时具有结合性和交换性。也就是说，不仅如何对数字进行分组无关紧要，处理数字的顺序也无关紧要。</p><p class="normal">OK, so that's cool. Here's another parallel strategy that's more like the first one: pick some register and initialize it to zero, and then let processors compete for grabbing numbers and adding them into that common place. This involves questions of synchronization, but you will still get the same answer. But this depends on addition being both associative and commutative. That is, not only does it not matter how you group the numbers, it also doesn't matter in what order you process the numbers.</p>
<p class="normal">数学家用“恒等式”、“结合律”和“交换律”等大而可怕的词来谈论这些东西——这是他们的简写。但是程序员需要知道这样的想法，不管你按什么顺序做。他们需要了解这样的想法，如果你重新组合就可以了。因此，在某种程度上，我声称数学思想在某种程度上对程序员很重要。</p><p class="normal">Mathematicians have big, scary words like “identity” and “associativity” and “commutativity” to talk about this stuff—it's their shorthand. But programmers need to know about ideas like, it doesn't matter in what order you do it. And they need to know about ideas like, it's OK if you regroup things. So to that extent I claim that mathematical ideas are important at some level to programmers.</p>
<p class="normal"><b>Seibel：</b>显然这是一个很好的例子，因为任何懂算术的人都能理解。但是您是否发现有某种更高层次的概念以同样的方式重新回到编程中？</p><p class="normal"><b>Seibel:</b> Obviously that's a good example to give because anyone who understands arithmetic can understand it. But do you find that there are kind of higher-level concepts that come back into programming in the same way?</p>
<p class="normal"><b>Steele：</b>现在假设我正在生成一份报告。典型的事情是你做了一堆打印语句，你依赖于按顺序执行它们，然后事情就会按照你说的顺序打印出来。那么，在这个多核世界中<a id="OEBPS/Chapter09.html.page_349"></a>也许我想分解报告的生成并将其打包给处理者。那么，连接字符串怎么样？我可以使用与加法​​相同的技巧吗？事实证明它是结合性的而不是交换性的——这准确地告诉我哪些技巧对字符串有效，哪些无效。作为担心设计并行编程语言的语言设计师，我发现这些概念和它们的词汇表非常有用。</p><p class="normal"><b>Steele:</b> Now suppose I'm generating a report. The typical thing is you make a bunch of print statements and you depend on doing them in order and things get printed out in the order you said. Well, in this multicore world <a></a>maybe I would like to break up the generation of the report and parcel it out to processors. Well, how about concatenating strings? Can I use the same techniques I used for adding up numbers? Turns out it is associative but not commutative—that tells me exactly which tricks will work for the strings and which ones won't. As a language designer worrying about designing parallel programming languages, I find these concepts and a vocabulary for them very useful.</p>
<p class="normal"><b>Seibel：</b>说到作为一名语言设计师，您对语言设计的想法随着时间的推移发生了怎样的变化？</p><p class="normal"><b>Seibel:</b> Speaking of being a language designer, how have your ideas about language design changed over time?</p>
<p class="normal"><b>Steele：</b>我认为我思想上最大的变化是大约十年前，即 1998 年，我在 OOPSLA 的“Growing a Language”演讲中所设定的。回到 70 年代，人们会发明语言并进行完整的设计和实现它，你就完成了。或者你不会完成，但你有这个想法，有这个完整的东西。</p><p class="normal"><b>Steele:</b> I think that the biggest change in my thinking is what I set down in that talk “Growing a Language” at OOPSLA almost ten years ago, in 1998. Back in the '70s people would invent languages and make a complete design and implement it and you'd be done. Or you wouldn't be done, but you had this idea that there is this complete thing.</p>
<p class="normal">所以 Pascal 是一项发明。东西在里面是有原因的，东西被排除在外也是有原因的，但它是一个完整的设计。如果结果证明它不完整——如果结果证明字符串处理不是那么好，那么，太糟糕了：Wirth 设计了这种语言。PL/I 得到设计，Ada 得到设计。也许 Ada 和 C++ 接近那一代的最后一代。而 C++ 并没有那么多，因为它确实随着时间的推移而发展。</p><p class="normal">So Pascal was an invention. Things were in it for a reason and things were left out for a reason but it was a complete design. And if it turned out that it wasn't complete—if it turned out that string processing wasn't that great, well, too bad: Wirth had designed the language. And PL/I got designed and Ada got designed. And maybe Ada and C++ were close to the last of that generation. And C++ not so much, because it did sort of evolve over time.</p>
<p class="normal">我意识到，随着语言变得越来越复杂，它们真的太大了，无法一次设计所有，而且从现在开始，语言必然会经历进化，因为它们太大了，无法一次设计所有或一次实现所有。这导致我处理编程语言设计和思考它的方式发生了变化。</p><p class="normal">I realized as languages got more complicated they were really too big to design all at once and that languages would necessarily from now on undergo evolution because they were too big to design all at once or to implement all at once. And that caused a change in how I approached programming-language design and thinking about it.</p>
<p class="normal"><b>Seibel：</b>所以你认为 Java 不是那样设计的？</p><p class="normal"><b>Seibel:</b> So you think Java was not designed that way?</p>
<p class="normal"><b>Steele：</b>我认为也许 Java 不是而且应该是。Java 是通过 Java Community Process 发展起来的。这解决了比核心语言问题更多的 API。虽然在过去的 12 或 13 年里已经为该语言添加了功能，但我认为在 90 年代初期设计 Java 的团队认为他们正在为特定的独立目的设计一种完整的语言。你知道，他们的目标是机顶盒。</p><p class="normal"><b>Steele:</b> I think maybe Java was not and should have been. Java has evolved through the Java Community Process. That has addressed more API than core language issues. And while features have been added to the language over the last 12 or 13 years, I think the team that designed Java in the early '90s thought they were designing a complete language for a specific self-contained purpose. You know, they were aiming at set-top boxes.</p>
<p class="normal"><a id="OEBPS/Chapter09.html.page_350"></a><b>塞贝尔：</b>对。</p><p class="normal"><a></a><b>Seibel:</b> Right.</p>
<p class="normal"><b>Steele：</b>他们当时甚至没有想到要对万维网进行编程，或者拥有如此庞大的用户群。所以我认为他们正在设计一种相当小的、独立的内核语言，然后您可以在其上构建一堆 API 并将其用于各种用途。这就是模型，这就是它的工作方式。我对“发展一种语言”的部分想法来自于观察这个过程，Java 变得有点太小了，人们想要更多的特性来处理其他事情。</p><p class="normal"><b>Steele:</b> They hadn't even envisioned at that point programming the World Wide Web or having as huge a user base as it has turned out to have. And so I thought they were designing a fairly small, self-contained kernel language on top of which you would then build a bunch of APIs and use it for various things. And that was the model and that's the way it's worked out. And part of my thoughts about “Growing a Language” came out of observing that process, that Java turned out to be a little bit too small and people wanted more features to get to other things.</p>
<p class="normal">特别是对于<code>for</code>可以遍历枚举的那种循环存在压力。这是添加到该语言中的一项功能。来自高性能科学计算社区的压力要求添加更多功能来支持浮点和类似的东西。这几乎被 Java Community Process 拒绝了，我认为这更多是出于社会原因而不是技术原因。</p><p class="normal">In particular there was pressure for the kind of <code>for</code> loop that could iterate through an enumeration. That is a feature that got added to the language. There was pressure from the high-performance scientific computing community to put in more features to support floating point and stuff like that. That pretty much got rejected by the Java Community Process, and I think that was more for social reasons than technical reasons.</p>
<p class="normal">但是有这种添加到语言中的需求，然后有一个社会过程以各种方式控制它。所以我开始思考，也许对于一种真正成功的编程语言，你需要像设计语言的技术特性一样设计和规划社会过程，并考虑这两者将如何相互作用。Fortress 是我们的第一个实验，或者至少是我的第一个实验。而且它还处于游戏的早期——这只是一个完成了一半的实验。</p><p class="normal">But there is this demand for adding to the language and then there was a social process that gated that in various ways. And so I got to thinking that maybe for a really successful programming language, you need to design and plan for the social process as much as you design the technical features of the language and think about how those two things are going to interact. And Fortress is our first experiment with that, or at least my first experiment with that. And it's still early in the game—it's only a half-done experiment.</p>
<p class="normal"><b>Seibel：</b>你不认为你参与的 Common Lisp 在如何做到这一点上确立了立场吗？</p><p class="normal"><b>Seibel:</b> Don't you think Common Lisp, which you were involved with, stakes out a position in how one does that?</p>
<p class="normal"><b>Steele：</b>是的，这是另一个早期的例子，它与 Java 这样的东西相对立，让我开始思考这些“发展语言”的问题。我当然熟悉 Lisp 的历史，特别是它的宏设施如何使它随着时间的推移更容易发展并让人们做出贡献。</p><p class="normal"><b>Steele:</b> Yes, that was the other early example as over against something like Java that got me thinking about these “growing a language” issues. I'm certainly familiar with the history of Lisp and how its macro facilities in particular made it somewhat easier for it to evolve over time and for people to make contributions.</p>
<p class="normal"><b>Seibel：</b>似乎最近三种语言（您在某种程度上都参与其中）都经历了或正在经历痛苦的​​重新设计。Scheme刚刚通过R6RS；JavaScript—<a id="OEBPS/Chapter09.html.page_351"></a>ECMAScript——正在经历 ES4 与 ES3.1 的争论。而 Java 正在为是否以及如何添加闭包而苦苦挣扎。</p><p class="normal"><b>Seibel:</b> It seems like recently three languages, all of which you were involved with at some level, have gone through or are going through a painful redesign. Scheme just went through R6RS; JavaScript—<a></a>ECMAScript—is going through the ES4 vs. ES3.1 debate. And Java is struggling with whether or not and how to add closures.</p>
<p class="normal"><b>Steele：</b>例如，是的。</p><p class="normal"><b>Steele:</b> For example, yes.</p>
<p class="normal"><b>Seibel：</b>这些语言的例子是否没有足够的内置技术或社会资金来轻松成长，因此不得不经历这些痛苦的成长过程？或者这就是它总是如何发生的？</p><p class="normal"><b>Seibel:</b> Are these examples of languages that didn't have enough built-in technical or social wherewithal to grow easily and so had to go through these painful growth processes? Or is this how it always happens?</p>
<p class="normal"><b>Steele：</b>嗯，如果一种语言没有消亡，它就会发展壮大。总是存在进化压力，因为需求会发生变化，人们会希望修改工具以适应他们现在的情况，而不是五年前的情况。我的猜想不是关于一种语言是否<i>会</i>发展，而是关于您可以在语言的早期设计中做出的技术选择，这些选择可能会在以后以某些方式促进增长。而且我认为，由于它们之间的技术差异，某些语言比其他语言更容易发展。部分原因还在于社会背景之间的差异。</p><p class="normal"><b>Steele:</b> Well, if a language doesn't die, it is going to grow. There are always evolutionary pressures because needs change and people will want to modify the tool to suit where they are now as opposed to where they were five years ago. My conjecture isn't about whether a language <i>will</i> grow or not but rather about technical choices you can make in the early design of the language that may facilitate the growth in certain ways later on. And I think some languages have turned out to be easier to grow than others because of technical differences among them. And also in part because of differences among the social contexts.</p>
<p class="normal"><b>Seibel：</b>那么容易成长的例子有哪些？</p><p class="normal"><b>Seibel:</b> So what are the examples that have grown easily?</p>
<p class="normal"><b>Steele：</b>嗯，我认为 Lisp 是一种因其宏机制的灵活性而容易成长的语言的例子。在某种程度上，部分原因在于构建它的群体的社会态度。</p><p class="normal"><b>Steele:</b> Well, I think Lisp is an example of a language that has grown easily because of the flexibility of its macro mechanism. And to some extent in part because of the social attitudes of the group that constructed it.</p>
<p class="normal">相比之下，Scheme 的成长之路要痛苦得多。这部分是因为 Scheme 社区很早就形成了一种文化，即除非每个人都同意，否则他们不会在语言中加入任何东西。或者接近每个人。所以它更像是一种黑球文化。而对于变成 Common Lisp 的社区，大多数人足以满足每个人。人们更愿意接受他们不为之疯狂的东西，以便得到其他东西。</p><p class="normal">Scheme, by contrast, has had a much more painful growth path. And that's in part because the Scheme community developed a culture early on that they would not put anything in the language unless everyone agreed on it. Or close to everyone. So it was more of a blackball culture. Whereas with the community that turned into Common Lisp, majority was enough to satisfy everyone. And people were more willing to accept things they weren't crazy about in order to get other things.</p>
<p class="normal"><b>Seibel：</b>语言的选择到底有多重要？选择一种语言而不是另一种语言是否有充分的理由，或者这一切都归结为品味？</p><p class="normal"><b>Seibel:</b> How much does a choice of language really matter? Are there good reasons to choose one language over another or does it all just come down to taste?</p>
<p class="normal"><b>Steele：</b>为什么味道不应该是一个很好的理由？</p><p class="normal"><b>Steele:</b> Why shouldn't taste be a good reason?</p>
<p class="normal"><a id="OEBPS/Chapter09.html.page_352"></a><b>Seibel：</b>好吧，我可能喜欢香草冰淇淋而你喜欢巧克力，但我们不会<i>为此争吵</i>。但是人们为编程语言而争吵。</p><p class="normal"><a></a><b>Seibel:</b> Well, I may like vanilla ice cream and you like chocolate, but we don't <i>fight</i> about it. But people fight about programming languages.</p>
<p class="normal"><b>Steele：</b>好吧，这就是想要属于胜利一方的人类社会现象。而且，不，我认为这不值得争论，但我认为对什么是对给定任务更有效的工具有意见是合理的。</p><p class="normal"><b>Steele:</b> Well, that's the human social phenomenon of wanting to belong to the winning side. And, no, I don't think it's worth fighting over, but I think it's reasonable to have opinions about what is a more effective tool for a given task.</p>
<p class="normal">我有理由相信的一件事是，认为一种语言比任何其他语言都能更好地解决所有问题，甚至同样好，这是错误的。我真的认为有特定语言更适合的应用领域。</p><p class="normal">The one thing I am reasonably convinced of is that it's a mistake to think that one language solves all problems better than any other language, or even equally well. I really think that there are application areas for which particular languages are better suited.</p>
<p class="normal">在做算法设计时，我觉得完全可以自由地使用不同语言的大杂烩。只要我只是与自己交流，我就会去白板写 Java 和 Fortran 的片段，并混入 APL。这至少不会打扰我，只要我能整理出我之后写的东西. 对于特定的算法部分，符号给我带来了一些我认为另一种语言不会那么清晰或有用的东西。</p><p class="normal">I feel perfectly free, when doing algorithm design, to use a hodgepodge of different languages. As long as I'm just communicating with myself I will go to a whiteboard and write fragments of Java and Fortran with APL mixed in. It doesn't bother me in the least as long as I can sort out what I've written afterwards. For a particular piece of the algorithm the notation is buying me something that I think another language wouldn't be nearly as clear or useful for.</p>
<p class="normal">问题是，如果你想出了一个擅长一小部分想法的符号，你仍然想把它放在一个完整的编程语言的上下文中，你必须围绕它构建一些东西并使它完整，如果你不这样做'把每件事都做好，然后你最终会得到一种不平衡的语言，这种语言在这个想法上很棒，而在其他方面有点笨拙。</p><p class="normal">The problem is, if you come up with a notation that's good at one small set of ideas, you still want to put that in the context of a complete programming language and you have to build something around it and make it complete and if you don't do a good job of everything, then you end up with a lopsided language that's great at this one idea and kind of clunky for the other stuff.</p>
<p class="normal">另一方面，真的很难创造出一种在所有方面都很棒的语言，部分原因在于只有那么多简洁的符号可供使用。有这个霍夫曼编码问题。如果您使某些内容简洁明了，那么某些内容将因此变得更加冗长。所以在设计一门语言时，你要考虑的一件事是，“我想让哪些东西说起来容易，做起来容易？” 但要明白，为了这个目的用完了字符或符号，你会让其他事情变得更难说。</p><p class="normal">On the other hand, it's really hard to make a language that's great at everything, in part just because there are only so many concise notations to go around. There's this Huffman encoding problem. If you make something concise, something is going to have to be more verbose as a consequence. So in designing a language, one of the things you think about is, “What are the things I want to make very easy to say and very easy to get right?” But with the understanding that, having used up characters or symbols for that purpose, you're going to have made something else a little bit harder to say.</p>
<p class="normal"><b>Seibel：</b>解决这个问题的一种方法是 Lisp 的做法——让一切都统一半简洁。其中均匀性具有允许的优点<a id="OEBPS/Chapter09.html.page_353"></a>该语言的用户可以轻松添加自己的同样统一、半简洁、一流的句法扩展。然而，很多人抵制 s-expression 语法。自鸣得意的 Lisp weenie 世界观是，“有些人就是不明白；有些人就是不明白；如果他们这样做了，他们就会看到解决方案的卓越之处。” 你是不是一个自鸣得意的 Lisp weenie 认为如果人们真正理解 Lisp 他们就不会被括号推迟？</p><p class="normal"><b>Seibel:</b> One way to resolve that is the way Lisp does—make everything uniformly semiconcise. Where the uniformity has the advantage of allowing <a></a>users of the language to easily add their own equally uniform, semiconcise, first-class syntactic extensions. Yet a lot of folks resist the s-expression syntax. The smug Lisp weenie view of the world is, “Some people just don't get it; if they did they would see the brilliance of the solution.” Are you a smug enough Lisp weenie to think that if people really understood Lisp they would not be put off by the parentheses?</p>
<p class="normal"><b>Steele：</b>不。我不认为我有资格沾沾自喜。如果有的话，因为我学了这么多语言，我想我比很多人更了解不同的语言可以提供不同的东西这一事实。并且有充分的理由在它们之间做出选择，而不是举起一种语言说，“这是赢家。”</p><p class="normal"><b>Steele:</b> No. I don't think I've got the standing to be smug. If anything, because I have learned so many languages I think I understand better than a lot of people the fact that different languages can offer different things. And there are good reasons to make choices among them rather than to hold up one language and say, “This is the winner.”</p>
<p class="normal">有一些项目我不想用 Lisp 以外的任何东西来处理，因为我对它提供给我的工具集很感兴趣。例如，现成的输入/输出——如果我愿意遵守 Lisp 的语法，那么我已经构建了适合某些工作的阅读器和打印机。这反过来又允许您进行某些类型的快速原型制作。另一方面，如果将 I/O 自定义为现有的特定格式很重要，那么 Lisp 可能不是一个很好的工具。否则，我可能不得不用某种语言（Lisp 或其他语言）构建某种转换器，以将其引入 Lisp 世界。</p><p class="normal">There are certain kinds of projects that I would not want to tackle with anything other than Lisp because I'm interested in the set of tools it provides me. For instance, ready-made input/output—if I'm willing to conform to Lisp's syntax, then I've already got readers and printers built that are adequate for some kinds of jobs. This in turn allows you to do some kinds of rapid prototyping. On the other hand, if it's important that I customize the I/O to an existing specific format, then Lisp might not be such a good tool. Or else I might have to build some kind of transducer in some language, Lisp or otherwise, to get it over to the Lisp world.</p>
<p class="normal"><b>Seibel：</b>你认真使用过哪些语言？这对你来说一定是一个长长的清单。</p><p class="normal"><b>Seibel:</b> What languages have you used seriously? It must be a long list for you.</p>
<p class="normal"><b>Steele：</b>我用 COBOL 编程赚了第一笔钱。我还是一名高中生，分包给了为另一个学校系统做成绩单生成系统的人，所以那里没有任何利益冲突。我使用 Fortran、IBM 1130 汇编语言、PDP-10 机器语言、APL。我想我不能说我认真地使用过 SNOBOL。当然是 C、C++、Bliss，以及来自卡内基梅隆大学的 DECsystems 实现语言。GNAL，它是基于Red的，我已经很认真地使用过了。</p><p class="normal"><b>Steele:</b> I earned my first money programming in COBOL. I was still a high-school student and subcontracted to someone who was doing a report-card generator system for another school system, so there wasn't any conflict of interest there. I used Fortran, IBM 1130 assembly language, PDP-10 machine language, APL. I guess I can't claim to have used SNOBOL seriously. Certainly C, C++, Bliss, the DECsystems implementation language that came out of Carnegie Mellon. GNAL, which is based on Red, I've used quite seriously.</p>
<p class="normal">几种不同的 Lisp 变体，包括 Common Lisp、Scheme、Maclisp。Dick Gabriel 和我为 S-1 构建的 Lisp 版本，S-1 Lisp，它是合并为 Common Lisp 的四五个版本之一。我开发了 Connection Machine Lisp，但我不确定是否可以说我已经完成了<a id="OEBPS/Chapter09.html.page_354"></a>严肃的编码。我认为，这反过来又在 *Lisp 中实现了。*不要将 Lisp 与 Connection Machine Lisp 混淆；它们是两种截然不同的语言。</p><p class="normal">Several different varieties of Lisp, including Common Lisp, Scheme, Maclisp. The version of Lisp that Dick Gabriel and I built for the S-1, S-1 Lisp, which was one of the four or five that merged to make Common Lisp. I developed Connection Machine Lisp but I'm not sure I could be said to have done <a></a>serious coding in it. That was, I think, in turn implemented in *Lisp. *Lisp is not to be confused with Connection Machine Lisp; they are two distinct languages.</p>
<p class="normal">我用 C* 进行了一些认真的编码，这是我们为 Connection Machine 开发的另一种语言。爪哇，当然。还有一些脚本语言。我在 Tcl 中用 JavaScript 做了一些广泛的工作。</p><p class="normal">I did some serious coding in C*, which was another language we developed for the Connection Machine. Java, of course. And some scripting languages. I've done some extensive work in JavaScript, in Tcl.</p>
<p class="normal">我已经用 Haskell 进行了认真的编程，“认真”意味着我已经使用一种语言工作了一个多月，并尝试用它编写大量代码。哦，FOCAL，DEC 计算机上的一种早期交互语言，类似于……有点像 BASIC，有点像 JOSS。我已经用 BASIC 编写了大量代码，现在我想起来了。TECO，文本编辑器和校正器，当然被用来编写 Emacs 的第一个版本，我将其视为用于该目的的编程语言。我写了大量的 TECO 代码。而TeX，也算是一种编程语言。我想这些将是主要的。</p><p class="normal">I've done serious programming in Haskell, taking “serious” to mean I've worked with a language for more than a month and tried to write a substantial piece of code in it. Oh, FOCAL, an early interactive language on the DEC computers, similar to … a little bit like BASIC, a little bit like JOSS. I've done substantial coding in BASIC, now that I think about it. And TECO, the Text Editor and Corrector, of course was used to program the first version of Emacs and I regard that as a programming language for that purpose. I wrote enormous amounts of TECO code. And TeX, also regarded as a programming language. Those would be the main ones, I guess.</p>
<p class="normal"><b>Seibel：</b>根据您之前所说的内容，我猜测“您最喜欢的编程语言是什么？”这个问题的答案。必须是“mu”。</p><p class="normal"><b>Seibel:</b> I'm guessing from what you said earlier that the answer to the question of “What's your favorite programming language?” would have to be “mu.”</p>
<p class="normal"><b>Steele：</b>我有三个孩子；你不妨问我最喜欢哪个。他们都很棒——他们拥有不同的技能和不同的个性。</p><p class="normal"><b>Steele:</b> I've got three children; you might as well ask me which is my favorite. They're all great—they've got different skills and different personalities.</p>
<p class="normal"><b>Seibel：</b>有没有你不喜欢使用的编程语言？</p><p class="normal"><b>Seibel:</b> Are there any programming languages which you just don't enjoy using?</p>
<p class="normal"><b>Steele：</b>我从每种语言中获得某种乐趣。但肯定有某些语言比其他语言更令人沮丧。我当时很喜欢TECO；我不认为我想回去。它有很多困难——很难在一个月内回来阅读你写的东西。</p><p class="normal"><b>Steele:</b> I get some kind of pleasure out of each language. But there are certainly certain languages that I find more frustrating than others. I enjoyed TECO at the time; I don't think I'd want to go back. It had quite a number of difficulties—it was very difficult to come back in a month and read what you'd written.</p>
<p class="normal">我不确定我是否已经编写了足够多的 Perl 代码以作为批评者认真对待，但我并没有被这种语言所吸引。我没有被 C++ 所吸引。我写了一些C++代码。任何我认为我可能<a id="OEBPS/Chapter09.html.page_355"></a>现在想用 C++ 编写也可以在 Java 中完成，而且更容易。除非效率是首要考虑因素。</p><p class="normal">I'm not sure that I've written enough Perl code to be taken seriously as a detractor, but I have not been attracted to the language. I have not been attracted to C++. I have written some C++ code. Anything I think I might <a></a>want to write in C++ now could be done about as well and more easily in Java. Unless efficiency were the primary concern.</p>
<p class="normal">但我不想被视为 Bjarne Stroustrup 努力的诋毁者。他为自己设定了一个特定的目标，即开发一种完全向后兼容 C 的面向对象语言。这对他来说是一项艰巨的任务。考虑到这种限制，我认为他想出了一个令人钦佩的设计，而且效果很好。但是考虑到我在编程中的各种目标，我认为向后兼容 C 的决定是一个致命的缺陷。只是一系列无法​​克服的困难。C 从根本上说有一个损坏的类型系统。能帮你避开一些困难就好了，但也不是万无一失的，不能指望它。</p><p class="normal">But I don't want to be seen as a detractor of Bjarne Stroustrup's effort. He set himself up a particular goal, which was to make an object-oriented language that would be fully backwards-compatible with C. That was a difficult task to set himself. And given that constraint, I think he came up with an admirable design and it has held up well. But given the kinds of goals that I have in programming, I think the decision to be backwards-compatible with C is a fatal flaw. It's just a set of difficulties that can't be overcome. C fundamentally has a corrupt type system. It's good enough to help you avoid some difficulties but it's not airtight and you can't count on it.</p>
<p class="normal"><b>Seibel：</b>你认为语言会变得更好吗？你一直在设计它们，所以希望你认为这是值得的追求。由于我们取得的进步，现在编写软件是否更容易？</p><p class="normal"><b>Seibel:</b> Do you think languages are getting better? You keep designing them, so hopefully you think it's a worthwhile pursuit. Is it easier to write software now because of advances that we've made?</p>
<p class="normal"><b>Steele：</b>嗯，现在编写我们 30 年前尝试编写的程序种类要容易得多。但我认为我们的野心已经大大增加了。所以我认为编程可能比 30 年前更难。</p><p class="normal"><b>Steele:</b> Well, it's much easier now to write the kinds of programs we were trying to write 30 years ago. But I think our ambitions have grown tremendously. So I think programming is probably a more difficult activity than it was 30 years ago.</p>
<p class="normal"><b>Seibel：</b>是什么让它变得更加困难？</p><p class="normal"><b>Seibel:</b> And what are the things that are making it more difficult?</p>
<p class="normal"><b>Steele：</b>我认为我们现在的人和 30 年前的人一样聪明，他们正像 30 年前的人一样被逼到能力的极限——我在 30 年前就选择了任意基线，因为那是我离开学校的时候。但不同之处在于——正如我之前所说的——不可能再理解正在发生的一切。或者甚至认为你可以。所以我认为今天的程序员面对的是一个更加困难的环境 — 仍然发挥着同样多的聪明才智，但在一个更难理解的环境中。所以我们尝试制作更精细的语言来帮助他们应对那些环境的不确定性。</p><p class="normal"><b>Steele:</b> I think we've got people now who are just as smart as the people we had 30 years ago and they are being pushed to the limits of their abilities as people were 30 years ago—I've chosen 30 years ago as an arbitrary baseline because that's when I got out of school. But the difference is that—as I remarked earlier—it's not possible to understand everything that's going on anymore. Or even to think you can. So I think that the programmers of today are up against a more difficult environment—still exercising the same amounts of ingenuity but in an environment that's harder to understand. So we try to make more elaborate languages to help them deal with the uncertainty of those environments.</p>
<p class="normal"><b>Seibel：</b>你说“更复杂的语言”很有趣。有一种思想流派——你肯定知道，因为它可以称为 Scheme 思想流派——管理复杂性的唯一方法是让事情（包括我们的编程语言）非常简单。</p><p class="normal"><b>Seibel:</b> It's interesting that you say, “more elaborate languages.” There's a school of thought—one that you're certainly aware of as it could be called the Scheme school of thought—that the only way to manage complexity is to keep things, including our programming languages, very simple.</p>
<p class="normal"><a id="OEBPS/Chapter09.html.page_356"></a><b>Steele：</b>我认为语言能够捕捉到程序员想要告诉计算机的内容，并加以记录和考虑，这一点很重要。现在不同的程序员对于他们要记录的内容有不同的风格和不同的想法。随着我对应该记录什么的理解的深入，我想我们想多谈谈数据结构，我们想多谈谈它们的不变量。我们在 Javadoc 中捕获的东西就是应该告诉编译器的东西。如果值得告诉另一个程序员，那么我认为也值得告诉编译器。</p><p class="normal"><a></a><b>Steele:</b> I think it's important that a language be able to capture what the programmer wants to tell the computer, to be recorded and taken into account. Now different programmers have different styles and different ideas about what they want recorded. As I've progressed through my understanding of what ought to be recorded I think we want to say a lot more about data structures, we want to say a lot more about their invariants. The kinds of things we capture in Javadoc are the kinds of things that ought to be told to a compiler. If it's worth telling another programmer, it's worth telling the compiler, I think.</p>
<p class="normal"><b>Seibel：</b> Javadoc 中的大部分内容，除了人类可读的散文，实际上不是从代码中派生出来的吗？</p><p class="normal"><b>Seibel:</b> Isn't most of the stuff in Javadoc, other than the human-readable prose, actually derived from the code?</p>
<p class="normal"><b>Steele：</b>其中一些是。但有些不是。Java 代码不能很好地捕获参数之间的关系。例如，这是一个数组，这是一个整数，这个整数应该是数组的有效索引。这在 Java 中是不容易说的。这是一个重要的概念，在 Fortress 中你可以这样说。</p><p class="normal"><b>Steele:</b> Some of it is. But some of it isn't. Relationships between parameters are not well captured by Java code. For instance, here's an array and here's an integer and this integer ought to be a valid index into the array. That's something you can't easily say in Java. That's an important concept and in Fortress you are able to say such things.</p>
<p class="normal"><b>Seibel：</b>它们被编译成运行时断言或静态检查？</p><p class="normal"><b>Seibel:</b> And they're compiled into runtime asserts or statically checked?</p>
<p class="normal"><b>Steele：</b>任何合适的。两个都。就 Fortress 而言，我们正试图捕捉到这些类型的关系。我们之前讨论过代数关系，即某些运算是关联的。我们希望能够在 Fortress 中非常明确地讨论这一点。而且我不希望每个应用程序程序员都会停下来思考，“你知道，我刚刚发明的这个子例程是关联的。”</p><p class="normal"><b>Steele:</b> Whatever is appropriate. Both. In the case of Fortress we are trying to be able to capture those kinds of relationships. We talked about algebraic relationships earlier, the idea that some operation is associative. We want to be able to talk about that very explicitly in Fortress. And I don't expect that every applications programmer is going to stop and think, “You know, this subroutine I just invented is associative.”</p>
<p class="normal">但是库程序员真的很关心这一点。部分原因是，如果他们要使用复杂的实现算法，算法的正确性就关键取决于这些属性。因此，在它确实关键地取决于这些属性的地方，我们想要一种以编译器可以理解的方式来讨论它们的方法。我猜想这是找到我们前进方向的重要方法，可以在语言中捕捉编程的重要属性。</p><p class="normal">But library programmers really care about that a lot. Partly because if they're going to use sophisticated implementation algorithms, the correctness of the algorithm hinges crucially on these properties. And so where it does depend crucially on those properties, we want a way to talk about them in a way the compiler can understand. I conjecture that that is an important approach to finding our way forward, to capture in the language important properties of programming.</p>
<p class="normal"><b>Seibel：</b>语言在避免犯错方面的作用如何？有人说，“如果我们将这种语言锁定得足够好，就不可能编写出糟糕的代码。” 然后其他人说，“算了吧；<a id="OEBPS/Chapter09.html.page_357"></a>这是一个注定要失败的企图，所以我们还不如让一切都敞开，让程序员聪明起来。” 你如何找到这种平衡？</p><p class="normal"><b>Seibel:</b> What about the role of the language in making it impossible to make mistakes? Some people say, “If we just lock this language down enough it'll be impossible to write bad code.” Then other people say, “Forget it; <a></a>that's a doomed enterprise, so we might as well just leave everything wide open and leave it to the programmers to be smart.” How do you find that balance?</p>
<p class="normal"><b>Steele：</b>重要的是要意识到这是你做出的权衡。而且您不能希望根除所有不良代码。你可以希望通过要求“妈妈，我可以吗？”来阻止某些类型的可能错误。代码; 为了做一些困难的事情，你必须写一些更详细的东西来说，“是的，我真的是这个意思。” 或者你可以故意让说某件事变得困难或不可能，例如破坏类型系统。这有其优点和缺点——用完全类型安全的语言为裸机编写设备驱动程序真的很困难，因为与裸机对话的抽象级别是错误的。或者你可以尝试添加一些东西，让你说，“这个变量真的是绝对地址 XXXX 处的这个设备寄存器。” 这本身就是一种不安全的特性。</p><p class="normal"><b>Steele:</b> The important thing is just to realize that it is a trade-off that you make. And you can't hope to eradicate all bad code. You can hope to discourage certain kinds of likely errors by requiring “Mother, may I?” code; in order to do something difficult, you have to write something a little more elaborate to say, “Yes, I really meant this.” Or you can purposely make it difficult or impossible to say a certain thing, such as, for example, to corrupt the type system. Which has its pluses and minuses—it's really hard to write device drivers for bare metal in a completely type-safe language just because the levels of abstraction are wrong for talking to the bare metal. Or you can try to add in stuff that lets you say, “This variable really is this device register at absolute address XXXX.” That in itself is a kind of unsafe feature.</p>
<p class="normal"><b>Seibel：</b>是否有任何较新的语言提供了有趣的惊喜？</p><p class="normal"><b>Seibel:</b> Have any of the newer languages provided any interesting surprises?</p>
<p class="normal"><b>Steele：</b> Python 的组织方式很不错。我想我不同意 Guido 早期不使用垃圾收集器的决定。我想他后来放弃了那个决定——我本可以预料到他们最终可能会想要一个。他们做出了一些有趣的句法选择，包括依赖缩进的决定，以及他们在某些语句末尾使用冒号的方式有点可爱。他们支持对象和闭包的具体方式很有趣。</p><p class="normal"><b>Steele:</b> Python's kind of nice in the way that it's organized. I think I disagreed with Guido's decision not to use a garbage collector early on. I think he's since recanted that decision—I could have predicted they would probably want one eventually. They made some interesting syntactic choices including the decision to rely on indentation, and the way they use colons at the end of certain statements is kind of cute. And the specific ways in which they support objects and closures is kind of interesting.</p>
<p class="normal"><b>Seibel：</b>大多数 Lispers 会认为闭包有点不足；lambda 非常有限。</p><p class="normal"><b>Seibel:</b> Most Lispers would think of the closures as being sort of deficient; the lambda is pretty limited.</p>
<p class="normal"><b>Steele：</b>对。你知道，他正在根据可实施性和可解释性以及其他因素做出一系列妥协。这是一组有趣的选择。这不是我会做出的一系列选择，但他正在为一个特定的用户社区服务，并试图完成某些事情，我能理解他为什么以他的方式做出选择。Haskell 是一门美丽的语言。我爱哈斯克尔。我不经常使用它。</p><p class="normal"><b>Steele:</b> Right. Well you know, he was making a certain set of compromises based on implementability and explainability and other things. And it was an interesting set of choices. And it was not the set of choices I would have made, but he was serving a particular user community and trying to get certain things done and I can appreciate why he made the choices the way he did. Haskell is a beautiful language. I love Haskell. I don't use it that much.</p>
<p class="normal"><b>Seibel：</b>所以你正在设计一种语言并且你喜欢 Haskell，但 Fortress 不是一种纯函数式语言吗？</p><p class="normal"><b>Seibel:</b> So you're in the midst of designing a language and you love Haskell, but Fortress isn't a pure functional language?</p>
<p class="normal"><a id="OEBPS/Chapter09.html.page_358"></a><b>Steele：</b>另一方面，现在 Haskell 已经发现了 monad，他们已经引入了 I/O monad，现在又引入了事务内存 monad。有一种理论认为它具有功能性，也许它确实可以助您一臂之力。另一方面，它感觉越来越迫切。<i>我忍不住想起了《镜中奇遇记</i>》中的白骑士——“我在想一个把胡须染成绿色的计划，并且总是用这么大的扇子，以至于他们看不见。” 在某些方面，monad 让我印象深刻，因为你拖入 I/O 并试图再次隐藏它——副作用真的存在，还是真的没有？</p><p class="normal"><a></a><b>Steele:</b> On the other hand, now Haskell has discovered monads and they have dragged in the I/O monad and now the transactional-memory monad. There's a theory that it's functional and maybe that does give you a leg up. On the other hand it's feeling more and more imperative. And I can't resist thinking of the White Knight in <i>Through the Looking Glass</i>—“I was thinking of a plan to dye one's whiskers green, and always use so large a fan that they could not be seen.” And in some ways, monads strike me as that fan, where you're dragging in the I/O and trying to hide it again—are the side effects really there, or are they really not?</p>
<p class="normal">尽管我大约每个月都会说一次，但我感觉我希望在设计 Fortress 时我们从 Haskell 开始并尝试将其转向 Fortran 和 Java，而不是从 Fortran 和 Java 开始并尝试将其转向 Haskell。当我们遇到尝试制作高效并行数据结构的困难时，我们发现自己在设计 Fortress 库时越来越多地采用函数式方法。</p><p class="normal">Although I will say that about once a month I get the feeling that I wish that in designing Fortress we had started with Haskell and tried to move it toward Fortran and Java, rather than starting with Fortran and Java and trying to move it toward Haskell. We are finding ourselves taking more and more of a functional approach as we design the Fortress libraries as we encounter the difficulties of trying to make efficient parallel data structures.</p>
<p class="normal"><b>Seibel：</b>你显然用英语写了很多东西并且也很关心这门手艺。你觉得写散文和写代码是相似的脑力练习吗？</p><p class="normal"><b>Seibel:</b> You obviously write a lot in English and care about that craft as well. Do you find writing prose and writing code to be similar mental exercises?</p>
<p class="normal"><b>Steele：</b>嗯，他们感觉不同，因为我非常清楚英语散文的主要读者拥有与计算机截然不同的处理器。因此，例如，我不能以完全相同的方式使用递归。对于老练的读者我可以稍微用一下。但是，对于读者将如何处理文本并理解文本，人们始终保持清醒的认识。</p><p class="normal"><b>Steele:</b> Well, they feel different in that I'm very aware that the primary reader for English prose has a very different kind of processor than a computer. So I can't use recursion in quite the same way, for example. For sophisticated readers I can use it a little bit. But there's a constant awareness of how a reader is going to process the text and understand it.</p>
<p class="normal">我写作时最担心的事情是英语的歧义，但我对电脑不太担心。我一直担心读者会以何种方式误解我所写的内容。所以我实际上花了很多时间有意识地设计我的散文风格的机制，以使用不太可能被误解的结构。</p><p class="normal">Something I worry about a lot when I write, that I'm less worried about with a computer, is about the ways in which English is ambiguous. I'm constantly worrying about ways in which the reader might misinterpret what I've written. So I've actually spent a lot of time consciously crafting the mechanics of my prose style to use constructions that are less likely to be misinterpreted.</p>
<p class="normal">我最喜欢的<i>周六夜现场</i>素描，甚至比蜜蜂或狂野疯狂的家伙还要多，是埃德·阿斯纳 (Ed Asner) 的素描，他扮演一个核电站的经理，去度假两周。他走出门，说：“再见，大家，我走了。记住，<a id="OEBPS/Chapter09.html.page_359"></a>你不能给核反应堆太多的冷却剂。” 在接下来的三分钟里，他们就他的意思争论不休。</p><p class="normal">My favorite <i>Saturday Night Live</i> sketch, even more than the bees or the wild and crazy guys, was a sketch where Ed Asner was on and he played the manager of a nuclear power plant going on vacation for two weeks. He walked out the door, saying, “Goodbye, everybody, I'm going. Remember, <a></a>you can't give too much coolant to the nuclear reactor.” And they spend the next three minutes arguing over what he meant.</p>
<p class="normal"><b>Seibel：</b>所以当你写英语时，你显然是在为人类读者写作，你似乎将其与编写软件进行对比，后者是为计算机编写的。但是很多人——比如高德纳 (Knuth)——强调了一个重要的观点，即当你编写代码时，你是在为人类读者和计算机编写代码。</p><p class="normal"><b>Seibel:</b> So when you're writing English, you're obviously writing for a human reader and you seem to contrast that to writing software, which is for a computer. But lots of people—such as Knuth—make a big point that when you're writing code you're writing as much for human readers as for the computer.</p>
<p class="normal"><b>Steele：</b>哦，那是真的。</p><p class="normal"><b>Steele:</b> Oh, that's true.</p>
<p class="normal"><b>Seibel：</b>那么，为人类读者编写英语的课程对你编写代码的这方面有帮助吗？</p><p class="normal"><b>Seibel:</b> So do the lessons of writing English for a human reader help you with that aspect of code?</p>
<p class="normal"><b>Steele：</b>嗯，当然。当我写代码的时候，我脑海中最重要的事情之一就是，这会让计算机做我想做的事吗？所以这是一个问题，“它会以一种方式被理解吗？” 而不是根本没有。然后就是经常有不止一种方法来正确写东西的问题。那时我开始担心人类读者。我也担心效率。</p><p class="normal"><b>Steele:</b> Well, sure. When I'm writing code, one of the foremost things in my mind is, will this get the computer to do what I want? And so it's a matter of, “Will it be understood even one way?” Rather than not at all. Then there's the question of often there's more than one way to write something correctly. And at that point I begin worrying about the human reader. And I also worry about efficiency.</p>
<p class="normal">通常，那里需要权衡取舍。如果效率很重要，我通常会使用一些技巧。然后我意识到这会误导人类。你必须对其进行评论或做一些事情来标记它，以使其更具可读性。但是，是的，在选择变量名和代码布局方式等方面，重点更多地放在人类读者身上，您会考虑如何使用无关紧要的代码格式细节向计算机提供必要的信号给人类读者。</p><p class="normal">There's a trade-off there, typically. If efficiency is important, I'll often resort to a trick. And then I realize that will mislead a human. And you have to comment it or do something to flag that, to make it more readable. But yes, very often in things like choices of variable names and the way code is laid out and so forth, the emphasis is more on the human reader, and you think about how you can use details of the code formatting that don't matter to the computer to provide the necessary signals to the human reader.</p>
<p class="normal"><b>Seibel：</b>随着我们的语言变得更好，或者至少对程序员更友好，与穿孔卡片上的汇编语言时代相比，编写正确的程序似乎更容易——你会从为你标记错误的编译器那里得到很多帮助等等。是否有可能将对可读性的关注放在首位，如果只是稍微领先于正确性？毕竟，正如 Haskell 的人们喜欢说的那样，“如果您的 Haskell 程序类型检查，它就不会出错。”</p><p class="normal"><b>Seibel:</b> As our languages get better, or at least more programmer-friendly, compared to the days of assembly language on punch cards, it seems like it's easier to write correct programs—you get a lot of help from compilers that flag errors for you and so forth. Is it possible to allow the focus on readability to come first, if only slightly ahead, of correctness? After all, as the Haskell folks are fond of saying, “If your Haskell program type checks, it can't go wrong.”</p>
<p class="normal"><b>Steele：</b>我认为这是一个可怕的陷阱。一个可编译的程序有太多的错误方式，你真的需要担心<a id="OEBPS/Chapter09.html.page_360"></a>关于正确性的所有时间。如果它不正确，您不仅会误导计算机，还会误导您的人类读者。</p><p class="normal"><b>Steele:</b> I think that's a terrible pitfall. There are so many ways for a compilable program to have errors in it that you really do need to worry <a></a>about correctness all the time. And if it's not correct you'll mislead not only the computer but your human readers, too.</p>
<p class="normal">我坚信，编程是一项非常不自然的活动，必须认真学习。人们习惯于让听众填补空白。我想我们在某种程度上依靠编译器来做这件事——你说，“我需要一个名为‘foo’的变量，”你不必担心到底是什么寄存器等等。但我认为大多数人不习惯在沟通中非常精确和严谨。但是，当我们描述要执行的流程时，小细节确实很重要，因为小细节的变化会影响流程的总体结果。</p><p class="normal">Programming is a highly unnatural activity, I'm convinced, and it must be carefully learned. People are used to their listeners filling in the gaps. I suppose we lean on compilers to do that in a little way—you say, “I need a variable named ‘foo’,” you don't worry about exactly what register and so forth. But I think that most people are not used to being very precise and rigorous in their communications. But when we are describing processes to be carried out, little details do matter because a change in a small detail can affect the gross outcome of the process.</p>
<p class="normal">我认为人们习惯于以有限的方式使用递归——我认为 Noam Chomsky 证明了这一点。但在实践中，人们很少深入到三层——当他们这样做时，通常是以尾递归的方式。理解递归的学科实际上是一门非常难学的艺术。然而这实际上是我们最强大的编程工具之一，一旦您学会了这门学科并全神贯注于它。所以我真的认为你不能把注意力从正确性球上移开。</p><p class="normal">I think people are used to using recursion in a limited way—I think Noam Chomsky demonstrated that. But in practice people rarely go even three deep—and when they do it's usually in a tail-recursive way. The discipline of understanding recursion is actually a very difficult learned art. And yet that is actually one of our most powerful programming tools, once you've learned the discipline and wrapped your head around it. So I really think you can't afford to take your eye off the correctness ball.</p>
<p class="normal"><b>Seibel：</b>然而，很多人都试图想出允许“非程序员”编程的语言或编程系统。我认为你认为这可能是一个注定要失败的企图——关于编程的问题不是我们没有找到正确的语法，而是人们必须学习这种不自然的行为。</p><p class="normal"><b>Seibel:</b> Yet lots of people have tried to come up with languages or programming systems that will allow “nonprogrammers” to program. I take it you think that might be a doomed enterprise—the problem about programming is not that we haven't found the right syntax for it but that people have to learn this unnatural act.</p>
<p class="normal"><b>Steele：</b>是的。我认为另一个问题是人们喜欢专注于他们脑海中的主要事情，而不是担心边缘案例或螺丝案例或不太可能发生的事情。然而恰恰是在那些情况下，人们最有可能不同意正确的做法是什么。</p><p class="normal"><b>Steele:</b> Yeah. And I think that the other problem is that people like to focus on the main thing they have in mind and not worry about the edge cases or the screw cases or things that are unlikely to happen. And yet it is precisely in those cases where people are most likely to disagree what the right thing to do is.</p>
<p class="normal">有时我会问学生，“在这种情况下应该发生什么？” “好吧，显然它应该这样做。” 马上就会有人跳进来说，“不，不，它应该那样做。” 而这些正是您需要在某些流程的编程规范中确定的内容。</p><p class="normal">Sometimes I'll quiz a student, “What should happen in this case?” “Well, obviously it should do this.” And immediately someone else will jump in and say, “No, no, it should do that.” And those are exactly the things that you need to nail down in a programming specification of some process.</p>
<p class="normal">我认为我们经常使用魔术的意象来描述编程并不是偶然的。我们谈到计算奇才，我们想到<a id="OEBPS/Chapter09.html.page_361"></a>通过魔法或自动发生的事情。我认为那是因为能够让机器做你想做的事是我们在技术上最接近青少年愿望实现的东西。</p><p class="normal">I think it's not an accident that we often use the imagery of magic to describe programming. We speak of computing wizards and we think of <a></a>things happening by magic or automagically. And I think that's because being able to get a machine to do what you want is the closest thing we've got in technology to adolescent wish-fulfillment.</p>
<p class="normal">如果你看童话故事，人们希望能够在他们的脑海中思考他们想要什么，挥挥手，它就会发生。当然，童话故事中充满了警示性故事，您忘记涵盖边缘情况，然后就会发生不好的事情。</p><p class="normal">And if you look at the fairy tales, people want to be able to just think in their minds what they want, wave their hands, and it happens. And of course the fairy tales are full of cautionary tales where you forgot to cover the edge case and then something bad happens.</p>
<p class="normal"><b>Seibel：例如，</b> <i>幻想曲</i>和递归的危险。</p><p class="normal"><b>Seibel:</b> <i>Fantasia</i> and the perils of recursion, for instance.</p>
<p class="normal"><b>Steele：</b> <i>幻想曲</i>和递归，是的。或者，“我希望我是这个国家最富有的人”——好吧，这会让其他人都变得非常贫穷，而你和以前一样。童话故事中会发生这种事情，因为人们忘记了做某事的方法不止一种。如果你只考虑你的主要愿望而不考虑细节，那么很多事情就不会被束缚。</p><p class="normal"><b>Steele:</b> <i>Fantasia</i> and recursion, yes. Or, “I wish I was the richest man in the country”—well, that makes everybody else extremely poor and you're the same as you were before. That kind of thing happens in fairy tales because people forget that there's more than one way to do something. And if you just think about your main wish and don't think about the details, that leaves a lot not tied down.</p>
<p class="normal"><b>Seibel：</b>那么童话故事的教训是，世界上的甘道夫是通过艰苦的劳动、学习咒语到达那里的，没有捷径吗？</p><p class="normal"><b>Seibel:</b> So the lesson from fairy tales is that the Gandalfs of the world got there by hard labor, learning the incantations, and there's no shortcut to that?</p>
<p class="normal"><b>Steele：</b>是的。我再给你举个例子——假设我告诉我的智能计算机，“好的，我有这个地址簿，我希望地址总是按排序顺序排列，”它的响应是丢弃除第一个以外的所有内容入口。现在地址簿已经排序了。但这不是你想要的。事实证明，仅指定像“列表按排序顺序并且我没有丢失任何数据并且没有任何内容被复制”这样简单的内容实际上是一个相当难以编写的规范。</p><p class="normal"><b>Steele:</b> Yeah. I'll give you another example—suppose I were to tell my smart computer, “OK, I've got this address book and I want the addresses to always be in sorted order,” and it responds by throwing away everything but the first entry. Now the address book is sorted. But that's not what you wanted. It turns out that just specifying something as simple as “a list is in sorted order and I haven't lost any of the data and nothing has been duplicated” is actually a fairly tricky specification to write.</p>
<p class="normal"><b>Seibel：</b>那么是否有一些语言特性可以让程序员——那些掌握了这种不自然行为的人——更有效率？你现在正在设计一种语言，所以你显然对此有一些看法。</p><p class="normal"><b>Seibel:</b> So are there language features that make programmers—folks who have mastered this unnatural act—more productive? You're designing a language right now so you've obviously got some opinions about this.</p>
<p class="normal"><b>Steele：</b>我之前说过，我认为你不能忽视正确性。另一方面，我认为我们可以设计工具来更容易地实现这一目标。我们不能让它变得微不足道，但我认为我们可以让它更容易避免各种错误。一个很好的例子是算术溢出检测，或者提供大数字而不是仅仅让 32 位整数回绕。现在，<a id="OEBPS/Chapter09.html.page_362"></a>实现这些更昂贵，但我相信提供成熟的 bignums 对于某些类型的编程来说更不容易出错。</p><p class="normal"><b>Steele:</b> I said earlier that I think you can't afford to neglect correctness. On the other hand, I think we can design tools to make it easier to achieve that. We can't make it trivial, but I think we can make it easier to avoid mistakes of various kinds. A good example is overflow detection on arithmetic, or providing bignums instead of just letting 32-bit integers wrap around. Now, <a></a>implementing those is more expensive but I believe that providing full-blown bignums is a little less error-prone for some kinds of programming.</p>
<p class="normal">我发现系统程序员和操作系统算法设计者经常掉入的一个陷阱是，他们说，“好吧，我们需要在这里同步一些阶段，所以我们将使用取一个数字的策略。每次我们进入计算的新阶段时，我们都会增加一些变量，这将是新的数字，然后不同的参与者将确保在某个操作发生之前他们都在处理相同的阶段数字。” 这在实践中非常有效，但如果您使用 32 位整数，则不需要那么长时间就能数到 40 亿。如果这个数字回绕会发生什么？你还好吗？事实证明，文献中的许多此类算法都存在这种潜伏的错误。如果某些线程在第 2 次到第 32 次迭代中停止怎么办？那' 这在实践中极不可能，但有可能。人们应该要么减轻该正确性问题，要么进行计算以表明，是的，我不想担心它的可能性很小。或者，也许您愿意每天接受一个故障。但关键是你应该进行分析而不是简单地忽略这个问题。事实上，计数器可以环绕是一个潜伏的陷阱，它不会伤害大多数程序员，但对于极少数人来说，它会在他们的算法中设置陷阱。但关键是你应该进行分析而不是简单地忽略这个问题。事实上，计数器可以环绕是一个潜伏的陷阱，它不会伤害大多数程序员，但对于极少数人来说，它会在他们的算法中设置陷阱。但关键是你应该进行分析而不是简单地忽略这个问题。事实上，计数器可以环绕是一个潜伏的陷阱，它不会伤害大多数程序员，但对于极少数人来说，它会在他们的算法中设置陷阱。</p><p class="normal">A trap that I find systems programmers and designers of operating-systems algorithms constantly falling into is they say, “Well, we need to synchronize some phases here so we're going to use a take-a-number strategy. Every time we enter a new phase of the computation we'll increment some variable and that'll be the new number and then the different participants will make sure they're all working on the same phase number before a certain operation happens.” And that works pretty well in practice, but if you use a 32-bit integer it doesn't take that long to count to four billion anymore. What happens if that number wraps around? Will you still be OK or not? It turns out that a lot of such algorithms in the literature have that lurking bug. What if some thread stalls for 2 to the 32nd iterations? That's highly unlikely in practice, but it's a possibility. And one should either mitigate that correctness problem or else do the calculation to show that, yeah, it's sufficiently unlikely that I don't want to worry about it. Or maybe you're willing to accept one glitch every day. But the point is you should do the analysis rather than simply ignoring the issue. And the fact that counters can wrap around is a lurking pitfall that doesn't hurt most programmers but for a very few it lays traps in their algorithms.</p>
<p class="normal"><b>Seibel：</b>说到故障，您不得不追踪的最严重的错误是什么？</p><p class="normal"><b>Seibel:</b> Speaking of glitches, what was the worst bug you've ever had to track down?</p>
<p class="normal"><b>Steele：</b>我不确定我能找出最糟糕的一个，但我可以告诉你几个故事。当然，处理并行进程产生了最难处理的错误。</p><p class="normal"><b>Steele:</b> I'm not sure I can dig up a worst one, but I can tell you a few stories. Certainly, dealing with parallel processes has produced the most difficult-to-deal-with bugs.</p>
<p class="normal">当我十几岁的时候，在 IBM 1130 上编程是我一生中唯一一次在梦中找到错误的解决方案。或者当我醒来的时候。几天来我一直在为一个错误而困惑，无法弄清楚。然后突然在半夜坐直身体，意识到我知道问题出在哪里。这是因为我忽略了接口规范中的某些内容。</p><p class="normal">When I was a teenager programming on the IBM 1130 was the one time in my life when the solution to a bug came to me in a dream. Or as I woke up. I had been puzzling over a bug for a couple days, couldn't figure it out. And then suddenly sat bolt upright in the middle of the night and realized I knew what the problem was. And it was because I had overlooked something in an interface specification.</p>
<p class="normal">它与并发进程有关。我正在写一个反编译器，以便通过反编译来研究IBM磁盘操作系统。为此，它会在磁盘上获取二进制数据并以各种格式打印出来<a id="OEBPS/Chapter09.html.page_363"></a>包括指令、字符代码、数字等。为了转换字符，我将数据提供给各种字符转换例程，其中一个是为从读卡器读取卡代码后使用而设计的。我忽略了规范中的小脚注，“我们假设在您调用该过程之前，将读取卡数据的缓冲区已清除所有低阶位。” 或者也许让他们设置。</p><p class="normal">It had to do with concurrent processes. I was writing a decompiler so that I could study the IBM disk operating system by decompiling it. And to this end it would take binary data on the disk and print it in a variety of formats <a></a>including as instructions, as character codes, as numbers, and so on. And in order to convert the characters, I was feeding the data to various character-conversion routines, one of which was designed for use after reading card codes from a card reader. And I had overlooked the tiny footnote in the specification that said, “We assume that before you call the procedure, the buffer in which the card data will be read has all of the low order bits cleared.” Or maybe had them set.</p>
<p class="normal">无论如何，卡片代码列的 12 位进入 16 位字的高 12 位，并且他们使用低位作为一个巧妙的技巧，您可以异步调用读卡器例程，它会异步加载缓冲区和转换例程将紧随其后，使用该低位来确定是否已读入下一个卡片列。如果它已被读取，它就会转换该字符。因此，一旦卡片被读取，转换很快就会完成——他们将卡片转换的成本与读取卡片的时间重叠。我正在向它提供不遵守此约束的原始二进制数据。我刚刚忽略了这一点——我认为这是另一个卡片转换例程，但事实证明，这个例程的接口有一些特别之处——它依赖于那些通常你不会想到的低位位。它正在将缓冲区中的内容解释为“哦，数据尚未从读卡器到达。” 原则上我知道这一点，但我没有想到。然后，就像我说的，它是在我睡着的时候想到的。所以这是一个奇怪的案例。</p><p class="normal">Anyway, the 12 bits from the card-code column were going into the high 12 bits of the 16-bit word and they were using the low bit for a clever trick whereby you could call the card-reader routine asynchronously and it would asynchronously load the buffer and the conversion routine would follow behind, using that low bit to determine whether the next card column had been read in or not. And if it had been read it would then convert that character. Thereby, as soon as the card was read, very shortly thereafter the conversion would finish—they were overlapping the cost of the card conversion with the time it took to read the card. And I was feeding it raw binary data that wasn't obeying this constraint. And I had just overlooked this—I thought it was yet another card-conversion routine but it turned out this one had something special about its interface—it was relying on those low-order bits, which ordinarily you wouldn't think about. It was interpreting what was in the buffer as saying, “Oh, the data has not yet arrived from the card reader.” In principle I knew this, but it wasn't occurring to me. And then, as I say, it came to me while I was asleep. So that was an odd case.</p>
<p class="normal">我能想到的另一个非常有趣的故事是当我是 Maclisp 系统的维护者时，Maclisp 支持 bignums——任意精度的整数。它们已经存在了好几年，并且被认为经过了很好的调试和淘汰。它们在 Macsyma 中被用于各种各样的东西，Macsyma 用户一直在使用它们。然而 Bill Gosper 的一份报告说，“这两个整数的商是错误的。” 他能看出来是因为商应该非常接近圆周率的十进制倍数。</p><p class="normal">The other really interesting story I can think of was while I was the maintainer of the Maclisp system and Maclisp supported bignums—integers of arbitrary precision. They'd been around for several years and were considered pretty well debugged and shaken out. They'd been used for all kinds of stuff in Macsyma, and Macsyma users were using them all the time. And yet a report came in from Bill Gosper saying, “The quotient of these two integers is wrong.” And he could tell because the quotient was supposed to be very near a decimal multiple of pi.</p>
<p class="normal">这些都是大约一百位数的数字，用手追踪整个数字确实不可行，因为除法例程相当复杂，而且这些数字很大。所以我盯着<a id="OEBPS/Chapter09.html.page_364"></a>代码并没有看到任何明显的错误。但是引起我注意的一件事是我不太了解的条件步骤。</p><p class="normal">These were numbers about a hundred digits each and it really wasn't feasible to trace through the entire thing by hand because the division routine was fairly complicated and these were big numbers. So I stared at <a></a>the code and didn't see anything obviously wrong. But one thing that caught my eye was a conditional step that I didn't quite understand.</p>
<p class="normal">这些例程基于 Knuth 的算法，因此我从现成的 Knuth 那里获取并阅读规范，然后将 Knuth 算法的步骤映射到汇编语言代码上。引起我注意的是 Knuth 的评论，即这一步很少发生——概率大约只有二分之一的机器字次方（比如机器字长是32bits, 2^32 = 40亿左右）。所以我们预计这种情况每四十亿次左右只会发生一次。</p><p class="normal">These routines were based on algorithms from Knuth, so I got Knuth off the shelf and read the specification and proceeded to map the steps of Knuth's algorithm onto the assembly-language code. And what caught my eye in Knuth was a comment that this step happens rarely—with a probability of roughly only one in two to the size of the word. So we expected this to happen only once in every four billion times or something.</p>
<p class="normal">由此我心想，“这些例程被认为已经很好地实证了，因此这一定是一个罕见的错误；” 因此问题很可能出在很少执行的代码中。” 这足以让我将注意力集中在该代码上，并意识到数据结构没有被正确复制。结果，后来出现了一个副作用错误，某些东西被破坏了。所以我修复了它，然后输入数字并得到了正确的答案，Gosper 似乎很满意。</p><p class="normal">From that I reasoned to myself, “These routines are thought to be well shaken out, thus this must be a rare bug; therefore the problem is likely to be in the rarely executed code.” That was enough to focus my attention on that code and realize that a data structure wasn't being properly copied. As a result, later down the line there was a side-effect bug where something was getting clobbered. And so I repaired that and then fed the numbers through and got the right answer and Gosper seemed to be satisfied.</p>
<p class="normal">一周后，他带着两个稍大一些的数字回来，说：“这些也不能正确划分。” 这一次，经过适当的准备，我回到了同样的 10 条指令，并发现该代码中存在第二个同类错误。因此，我彻底检查了代码，确保以正确的方式复制了所有内容，并且此后没有报告任何错误。</p><p class="normal">A week later he came back with two somewhat larger numbers and said, “These don't divide properly either.” This time, properly prepared, I returned to that same little stretch of ten instructions and discovered there was a second bug of the same kind in that code. So then I scoured the code thoroughly, made sure everything was copied in the right ways, and no errors were ever reported after that.</p>
<p class="normal"><b>Seibel：</b>这总是诀窍——会有不止一个。</p><p class="normal"><b>Seibel:</b> That's always the trick—that there's going to be more than one.</p>
<p class="normal"><b>Steele：</b>所以我想那里有教训——我应该吸取的教训是这里可能有不止一个错误，我应该在第一次时更仔细地检查。但另一个教训是，如果错误被认为是罕见的，那么查看很少执行的路径可能会富有成效。第三件事是，拥有关于算法正在尝试做什么的良好文档，即对 Knuth 的引用，这非常棒。</p><p class="normal"><b>Steele:</b> So I guess there's lessons there—the lesson I should have drawn is there may be more than one bug here and I should have looked harder the first time. But another lesson is that if a bug is thought to be rare, then looking at rarely executed paths may be fruitful. And a third thing is, having good documentation about what the algorithm is trying to do, namely a reference back to Knuth, was just great.</p>
<p class="normal"><b>Seibel：</b>当这不仅仅是半夜醒来并意识到问题所在时，您首选的调试技术是什么？您是否使用符号调试器、打印语句、断言、形式证明，以上所有这些？</p><p class="normal"><b>Seibel:</b> When it's not just a matter of waking up in the middle of the night and realizing what the problem is, what are your preferred debugging techniques? Do you use symbolic debuggers, print statements, assertions, formal proofs, all of the above?</p>
<p class="normal"><a id="OEBPS/Chapter09.html.page_365"></a><b>Steele：</b>我承认我很懒——我会尝试的第一件事就是加入 print 语句，看看它是否对我有帮助，尽管这对于处理复杂的错误来说可能是最不有效的。但它在捕获简单错误方面做得非常好，值得一试。另一方面，我在编程思想演变过程中的一个重大启示是当我在 Haskell 中从事那个项目时。因为它是一种纯函数式语言，所以我不能只加入打印语句。</p><p class="normal"><a></a><b>Steele:</b> I admit to being lazy—the first thing I will try is dropping in print statements to see if it will help me, even though that is probably the least effective for dealing with a complicated bug. But it does such a good job of grabbing the simple bugs that it's worth a try. On the other hand, one of the great revelations in the evolution of my thinking about programming was when I was working on that one project in Haskell. Because it was a purely functional language, I couldn't just drop in print statements.</p>
<p class="normal">这迫使我 100% 地进行单元测试。因此，我着手为我的每个子过程构建全面的单元测试。结果证明这是一门很好的纪律。</p><p class="normal">This forced me to go 100 percent to a regimen of unit testing. So I proceeded to construct thorough unit tests for each of my subprocedures. And this turned out to be a very good discipline.</p>
<p class="normal">这影响了 Fortress 的设计，试图包含鼓励构建单元测试的功能。并将它们与程序文本一起记录，而不是在单独的文件中。在那个程度上，我们借鉴了一些想法，比如埃菲尔的合同设计和类似的东西，你可以在这些东西上放置前置条件和后置条件。您可以在某些地方声明测试数据和单元测试过程，然后测试工具会在您请求时负责运行这些程序。</p><p class="normal">This has influenced the design of Fortress to try to include features that would encourage the construction of unit tests. And recording them alongside the program text, rather than in separate files. To that extent we borrowed some ideas of say, Eiffel's Design by Contract and similar things where you can put preconditions and postconditions on procedures. There are places where you can declare test data and unit-test procedures, and then a test harness will take care of running those whenever you request.</p>
<p class="normal"><b>Seibel：</b>既然你刚才提到了按契约设计，那么你如何在自己的代码中使用断言？</p><p class="normal"><b>Seibel:</b> Since you just mentioned Design by Contract, how do you use assertions in your own code?</p>
<p class="normal"><b>Steele：</b>我倾向于加点断言，尤其是在程序开始时和过程中的重要时刻。当试图——也许“证明”这个词太强了——试图向自己证明某些代码的正确性时，我通常会根据不变量来思考，然后证明不变量得到维护。我认为这是一种富有成效的思考方式。</p><p class="normal"><b>Steele:</b> I have a tendency to drop in assertions, particularly at the beginnings of procedures and at important points along the way. And when trying to—maybe “prove” is too strong a word—trying to justify to myself the correctness of some code I will often think in terms of an invariant and then prove that the invariant is maintained. I think that's a fruitful way to think about it.</p>
<p class="normal"><b>Seibel：</b>如何在调试器中逐步执行代码？如果其他一切都失败了，你会这样做吗？</p><p class="normal"><b>Seibel:</b> How about stepping through code in a debugger? Is that something you'll do if all else fails?</p>
<p class="normal"><b>Steele：</b>这取决于节目的长度。当然，您可以使用工具来帮助您跳过不需要逐步完成的部分，因为您确信这些部分没问题。当然，Common Lisp 有这个非常好的<code>STEP</code>功能，非常有帮助。我已经逐步完成了很多 Common Lisp 代码。跳过您信任细节的特定子程序的能力当然会给您带来很多好处。还有<a id="OEBPS/Chapter09.html.page_366"></a>能够设置陷阱并说：“在这个特定的循环第十七次出现之前，我真的不需要看这个。” PDP-10 上有硬件工具支持它，这很好，至少在麻省理工学院是这样。当时他们倾向于修改他们的机器，以添加功能。对于以各种方式观看代码的实际执行，还有很多话要说。</p><p class="normal"><b>Steele:</b> It depends on the length of the program. And of course you can have tools that will help you to skip sections you don't need to step through because you're confident that those parts are OK. And of course Common Lisp has this very nice <code>STEP</code> function, which is very helpful. I've stepped through a lot of Common Lisp code. The ability to skip over particular subroutines whose details you trust, of course, buys you a lot. Also the <a></a>ability to set traps and say, “I really don't need to look at this until this particular loop has gone around for the seventeenth time.” And there were hardware tools to support that on the PDP-10, which was nice, at least at MIT. They tended to modify their machines in those days, to add features. And there's a lot to be said for watching the actual execution of code in various ways.</p>
<p class="normal"><b>Seibel：</b>你有没有尝试正式证明你的代码是正确的？</p><p class="normal"><b>Seibel:</b> Do you ever try to formally prove your code correct?</p>
<p class="normal"><b>Steele：</b>嗯，这取决于代码。如果我正在编写带有某种棘手的数学不变量的代码，我将寻求证明。如果写排序例程，我会构造某种不变量并证明它。</p><p class="normal"><b>Steele:</b> Well, it depends on the code. If I'm writing code with some kind of tricky mathematical invariant I will go for a proof. I wouldn't dream of writing a sorting routine without constructing some kind of invariant and proving it.</p>
<p class="normal"><b>Seibel：</b> Peter van der Linden 在他的<i>Expert C Programming</i>一书中有一个关于证明的不屑一顾的章节，他在其中展示了某事的证明，但是，哈哈，这个证明有一个错误。</p><p class="normal"><b>Seibel:</b> Peter van der Linden in his book <i>Expert C Programming</i> has a sort of dismissive chapter about proofs in which he shows a proof of something, but then, ha ha, this proof has a bug in it.</p>
<p class="normal"><b>Steele：</b>是的，确实如此。证明也可能有错误。</p><p class="normal"><b>Steele:</b> Yes, indeed. Proofs can also have bugs.</p>
<p class="normal"><b>Seibel：</b>他们是否至少比他们正在验证的代码更不可能出现错误？</p><p class="normal"><b>Seibel:</b> Are they at least less likely to have a bug than the code which they are proving?</p>
<p class="normal"><b>Steele：</b>我认为是的，因为你以不同的方式来处理它，你使用不同的工具。您使用证明的原因与您使用数据类型的原因相同，或者出于与登山者使用绳索相同的原因。如果一切顺利，你不需要它们。但是，如果出现问题，它们会增加捕获它的机会。</p><p class="normal"><b>Steele:</b> I think so, because you come at it in a different way and you use different tools. You use proofs for the same reason you use data types, or for the same reason that mountain climbers use ropes. If all is well, you don't need them. But they increase the chance of catching it if something does go wrong.</p>
<p class="normal"><b>Seibel：</b>我想真正糟糕的情况是，如果你的程序中有一个错误，然后你的证明中有一个补偿错误。希望那会很少见。</p><p class="normal"><b>Seibel:</b> I suppose the really bad case would be if you had a bug in your program and then a compensating bug in your proof. Hopefully that would be rare.</p>
<p class="normal"><b>Steele：</b>那是有可能发生的。我什至不确定它一定很少见，因为您倾向于构建证明以匹配代码的结构。或者相反，如果您在编写代码时心中有一个证明，那么它往往会指导您构建程序。所以你真的不能说代码和证明在概率意义上是完全独立的。但是您可以使用不同的工具和不同的思维方式。</p><p class="normal"><b>Steele:</b> That can happen. I'm not even sure it's necessarily rare, because you tend to construct the proof to match the structure of the code. Or conversely, if you've got a proof in mind as you're writing the code, that tends to guide your construction of the program. So you really can't say the code and the proof are totally independent, in the probabilistic sense. But you can bring different tools and different modes of thought to bear.</p>
<p class="normal"><a id="OEBPS/Chapter09.html.page_367"></a>特别是，编程的细节倾向于采取局部观点，而不变性倾向于关注全局观点。正是在证明你使这两件事相互作用的过程中。您查看程序的局部步骤如何影响您试图维护的全局不变量。</p><p class="normal"><a></a>In particular, the details of the programming tend to take a local point of view and the invariants tend to focus on the global point of view. It's in doing the proof that you cause those two things to interact. You look at how the local steps of the program affect the global invariant you're trying to maintain.</p>
<p class="normal">我职业生涯中最有趣的练习之一是有一次我被要求审阅 David Gries 为<i>CACM 撰写</i>的一篇关于证明垃圾收集器算法正确的论文，即并行垃圾收集器。Susan Owicki 是 Gries 的学生，她开发了一些工具来证明并行程序的正确性，他决定将这些技术应用到 Dijkstra 开发的一个并行垃圾收集器版本中。我认为整段代码只有半页。然后论文的其余部分就是正确性的证明。</p><p class="normal">One of the most interesting exercises in my career was the time I was asked to review a paper for <i>CACM</i> by David Gries on proving a garbage-collector algorithm correct, a parallel garbage collector. Susan Owicki was a student of Gries's and she developed some tools for proving parallel programs correct, and he decided to apply these techniques to a version of a parallel garbage collector that had been developed by Dijkstra. The whole piece of code fit on, I think, a half a page. And then the entire rest of the paper was the proof of correctness.</p>
<p class="normal">我翻阅了证明，并试图为自己验证每一步。让它变得棘手的是，实际上，程序中的每个语句都有可能违反任何不变量，因为它是一个并行程序。因此，Owicki 技术涉及在所有点上对这些进行交叉检查。我花了大约 25 个小时才完成，在这个过程中我发现有几个步骤我无法完成。所以我报告了这一点，结果证明它们确实代表了算法中的错误。</p><p class="normal">I cranked through the proof and tried to verify every step for myself. And what makes it tricky is, in effect, every statement in the program has the potential to violate any invariant because it's a parallel program. So the Owicki technique involves cross-checking these at all points. And it took me about 25 hours to go through, and in the process I found a couple of steps I couldn't push through. So I reported this and it turned out they did represent bugs in the algorithm.</p>
<p class="normal"><b>Seibel：</b>所以它们是算法中的错误，因为证明的结果是，QED 这个东西有效，所以证明遗漏了。</p><p class="normal"><b>Seibel:</b> So they were bugs in the algorithm which the proof missed since the result of the proof was, Q.E.D. this thing works.</p>
<p class="normal"><b>Steele：</b>是的，提供的证明是错误的证明。因为某些地方被忽略了。这是公式操作的一些细节——公式几乎正确但不完全正确。我认为这是纠正顺序的问题——两个陈述的顺序或其他东西。</p><p class="normal"><b>Steele:</b> Yes, the proof presented was a faulty proof. Because something had been overlooked somewhere. It was some detail of formula manipulation—the formula was almost right but not quite. And I think it was a matter of correcting the order—the sequence of two statements or something.</p>
<p class="normal"><b>Seibel：</b>所以你花了 25 个小时来分析证明。如果你有代码，你能在短短 25 小时内找到代码中的错误吗？</p><p class="normal"><b>Seibel:</b> So it took you 25 hours to analyze the proof. Could you have found the bug in the code in just 25 hours if you just had the code?</p>
<p class="normal"><b>Steele：</b>我怀疑我什至不会意识到有一个错误。该算法非常复杂，以至于我可能会盯着代码说，“是的，这对我来说很有意义”，而不会发现这种非常晦涩的交互。这是一个必要的多步骤序列——一种极不可能的相互作用。</p><p class="normal"><b>Steele:</b> I doubt I would have even realized there was a bug. The algorithm was sufficiently intricate that I would probably have stared at the code and said, “Yeah, this makes sense to me” and not have spotted this very obscure interaction. It was a multistep sequence that was necessary—a highly unlikely interaction.</p>
<p class="normal"><a id="OEBPS/Chapter09.html.page_368"></a><b>Seibel：</b>所以这种交互基本上通过制作证明的过程被抽象化，所以你不必想出如果发生这种情况然后这个然后这个然后这个然后意识到存在问题的场景。</p><p class="normal"><a></a><b>Seibel:</b> And so that kind of interaction basically gets abstracted by the process of making the proof so you don't have to come up with this scenario of what if this happens and then this and then this to realize that there's a problem.</p>
<p class="normal"><b>Steele：</b>没错。实际上，证明采用了全局观点并涵盖了所有可能性，将其总结为一个非常复杂的公式。而且您必须进行公式运算才能通过。所以作者重新提交了这篇论文，它回来重新审阅，即使我已经完成了整个练习，我又花了 25 个小时来重新验证证明。这一次似乎一切正常。</p><p class="normal"><b>Steele:</b> Exactly. In effect the proof takes the global point of view and covers all the possibilities, summarizing it in a very complicated formula. And you have to do formula crunching to push it through. So the author resubmitted the paper and it came back for rereviewing and even though I had done the entire exercise, it took me another 25 hours to reverify the proof. This time it all seemed to be sound.</p>
<p class="normal">我报告了这一点，论文发表了，从那以后就没有人发现其中的错误。它真的没有错误吗？我不知道。但我认为通过证明练习让我更有信心该算法现在是合理的。我希望我不是唯一一个真正完成了整个证明的审阅者。</p><p class="normal">I reported that and the paper was published and nobody's found a bug in it since. Is it actually bug-free? I don't know. But I think having gone through the exercise of the proof gives me a lot more confidence that the algorithm is now sound. And I'm hoping that I wasn't the only reviewer who actually did the complete cranking through of the proof.</p>
<p class="normal"><b>Seibel：</b> Dijkstra 引用了一句关于如何无法通过测试证明程序没有错误，你只能证明你未能通过测试找到任何错误。但这听起来有点像证明——你不能证明一个程序没有错误——你只能证明，就你自己的证明而言，它没有出现任何错误.</p><p class="normal"><b>Seibel:</b> There's a Dijkstra quote about how you can't prove by testing that a program is bug-free, you can only prove that you failed to find any bugs with your tests. But it sort of sounds the same way with a proof—you can't prove a program is bug-free with a proof—you can only prove that, as far as you understand your own proof, it hasn't turned up any bugs.</p>
<p class="normal"><b>Steele：</b>是的。这就是为什么该学科有一个与机械证明验证有关的子专业。希望您随后将问题简化为证明证明验证者是正确的。与验证任何相当大的程序的证明相比，如果您可以编写足够小的验证程序，这实际上是一个更容易处理的问题。</p><p class="normal"><b>Steele:</b> That's true. Which is why there is a subspecialty in the discipline having to do with mechanical proof verification. And the hope is that you then reduce the problem to proving that the proof verifier is correct. Which is—if you can write a small enough verifier—actually a much more tractable problem than verifying the proof of any rather large program.</p>
<p class="normal"><b>Seibel：</b>然后手动验证的机械验证器将完成您所做的 25 小时的工作，以验证其他代码的特定证明？</p><p class="normal"><b>Seibel:</b> And then the manually proved mechanical verifier would do the 25 hours of work you did of grinding out a verification of a specific proof of some other piece of code?</p>
<p class="normal"><b>Steele：</b>是的。确切地。</p><p class="normal"><b>Steele:</b> Yes. Exactly.</p>
<p class="normal"><b>Seibel：</b>你有什么想谈的吗？</p><p class="normal"><b>Seibel:</b> Is there anything that you would like to talk about?</p>
<p class="normal"><a id="OEBPS/Chapter09.html.page_369"></a><b>Steele：</b>好吧，我们还没有过多地谈论程序中的美感，我不想对此置若罔闻。我读过一些真正让我印象深刻的节目，它们具有一种美感。TeX 是一个例子，TeX 的源代码。METAFONT 少了一点，我不知道这是否只是因为我较少使用该程序，或者代码的组织或程序的设计有些微妙的不同，我不太喜欢。我真的不能决定。</p><p class="normal"><a></a><b>Steele:</b> Well, we haven't talked that much about the beauty in programs, and I wouldn't want that to go without remark. I have read some programs that really strike me as having a kind of beauty to them. TeX is one example, the source code for TeX. METAFONT a little less so and I don't know whether it's just because I use the program less or there's something subtly different about the organization of the code or about the design of the program that I like less. I really can't decide.</p>
<p class="normal">有一些算法让我觉得非常棒。在代码压缩很重要的日子里，我看到过一些小程序是代码压缩的奇迹——当你只有 1 兆字节的内存时，无论你使用 40 个字还是 30 个字都非常重要，人们有时会非常努力地压缩一个程序下来。Bill Gosper 写了这些四行的小奇迹，如果你将放大器连接到某个累加器的低位，而它正在摆弄位，它们会做出惊人的事情。</p><p class="normal">There are certain algorithms that strike me as just wonderful. I have seen little pieces of program that were marvels of code compression back in the days when that mattered—when you had only a megabyte of memory, whether you used 40 words or 30 really mattered, and people would really work hard sometimes to squeeze a program down. Bill Gosper wrote these little four-line wonders that would do amazing things if you then connected an amplifier to the low bits of some accumulator while it was twiddling the bits.</p>
<p class="normal">这似乎是我努力的可怕浪费，但我职业生涯中最令人满意的时刻之一是当我意识到我找到了一种方法可以从 Gosper 编写的 11 字程序中削减一个字时。这是以非常少量的执行时间为代价的，以机器周期的分数来衡量，但我实际上找到了一种将他的代码缩短一个字的方法，而且我只花了 20 年的时间就做到了。</p><p class="normal">This may seem like a terrible waste of my effort, but one of the most satisfying moments in my career was when I realized that I had found a way to shave one word off an 11-word program that Gosper had written. It was at the expense of a very small amount of execution time, measured in fractions of a machine cycle, but I actually found a way to shorten his code by 1 word and it had only taken me 20 years to do it.</p>
<p class="normal"><b>Seibel：</b>所以 20 年后你说，“嘿，比尔，你猜怎么着？”</p><p class="normal"><b>Seibel:</b> So 20 years later you said, “Hey Bill, guess what?”</p>
<p class="normal"><b>Steele：</b>并不是我花了 20 年时间做这件事，而是 20 年后我突然回来再次看它，突然有了一个以前没有的洞察力：我意识到通过改变其中一个操作码，它也是一个足够接近我想要的浮点常量，因此我可以将该指令用作指令和浮点常量。</p><p class="normal"><b>Steele:</b> It wasn't that I spent 20 years doing it, but suddenly after 20 years I came back and looked at it again and suddenly had an insight I hadn't had before: I realized that by changing one of the op codes, it would also be a floating point constant close enough to what I wanted, so I could use the instruction both as an instruction and as a floating point constant.</p>
<p class="normal"><b>Seibel：</b>这直接出自“真正的程序员 Mel 的故事”。</p><p class="normal"><b>Seibel:</b> That's straight out of “The Story of Mel, a Real Programmer.”</p>
<p class="normal"><b>Steele：</b>是的，没错。这是其中之一。而且，不，我不想在现实生活中这样做，但这是我唯一一次设法减少 Gosper 的一些代码。感觉像是一场真正的胜利。这是一段漂亮的代码。这是一个用于计算正弦和余弦的递归子程序。</p><p class="normal"><b>Steele:</b> Yeah, exactly. It was one of those things. And, no, I wouldn't want to do it in real life, but it was the only time I'd managed to reduce some of Gosper's code. It felt like a real victory. And it was a beautiful piece of code. It was a recursive subroutine for computing sines and cosines.</p>
<p class="normal"><a id="OEBPS/Chapter09.html.page_370"></a>所以这就是我们当时担心的事情。当我在 IBM 1130 上编程时，有一个引导卡的概念，它是你放在甲板前面的一张卡。您按下计算机上的开始按钮，硬件将自动读取第一张卡并将其放入内存中的前 80 个位置。然后在给定位置开始执行。那张卡片的工作就是成为一个真正的读卡器例程来读取其余的卡片，然后这就是你自己启动的方式。</p><p class="normal"><a></a>So that's the kind of thing we worried about back then. When I programmed on the IBM 1130, there was this concept of a boot card, which is a single card you put on the front of your deck. You hit a start button on the computer and the hardware would automatically read the first card and put it in the first 80 locations in memory. And then start execution at a given location. And the job of that card was then to be a real card-reader routine to read the rest of the cards, and then that's how you got yourself bootstrapped.</p>
<p class="normal">IBM 1130 的难点在于卡片只有 12 行，而且它是一个 16 位计算机字。所以这 12 位分散在 16 位指令中，这意味着有些指令无法在卡上表示。因此，任何无法在卡片上表示的指令都必须使用卡片上的其他指令来构建。所以你有这个非常复杂的权衡——“我可以使用什么指令，如果我使用这个指令；我将需要卡片上的其他几条指令来构建它”——这带来了巨大的压力，你只有 80 个字来编写你的例程，所以你确实倾向于使用诸如重用指令作为数据之类的东西，将一条数据用于不止一件事。如果你能设法把这个小子程序放在<i>那里</i>在内存中，那么它的地址也可以用作数据常量。这就是它所需要的——它是折纸和俳句以及所有这些作为一种编程风格。我花了几年时间这样做。</p><p class="normal">What made it hard on the IBM 1130 was that cards have only 12 rows and it was a 16-bit computer word. So the 12 bits were scattered throughout the 16 bits of instructions, which meant that some instructions couldn't be represented on the card. Therefore any instructions that couldn't be represented on the card had to be built by using other instructions that were on the card. So you had this very complicated trade-off—“What instructions can I use, and if I use this instruction; I'm going to need several other instructions on the card just to build it”—and this presented a tremendous amount of pressure and you only got 80 words to write your routine, and so you do tend to use things like reusing instructions as data, using a piece of data for more than one thing. If you can manage to put this little subroutine <i>there</i> in memory, then its address can also be used as a data constant. This is what it took—it was origami and haiku and all that as a style of programming. And I spent several years doing that.</p>
<p class="normal"><b>Seibel：</b>你认为在当前环境下，经历过那门学科的人是更好还是更差的程序员？</p><p class="normal"><b>Seibel:</b> Do you think that people who went through that discipline are better or worse programmers in the current environment?</p>
<p class="normal"><b>Steele：</b>他们在处理资源限制和尝试准确衡量资源限制方面积累了经验。</p><p class="normal"><b>Steele:</b> They got experience at dealing with resource constraints and trying to measure them accurately.</p>
<p class="normal"><b>Seibel：</b>嗯，学会准确地测量它们是一件好事。但它也可以双向切断你养成现在不适应的编程习惯。</p><p class="normal"><b>Seibel:</b> Well, learning to measure them accurately is a good thing. But it can also cut both ways where you develop habits of programming that are now maladaptive.</p>
<p class="normal"><b>Steele：</b>人们很容易过于执着于优化某些东西，只是因为你可以，即使这不是你需要做的。确实如此。我很高兴我的儿子在高中时就有了编写 TI 计算器的经验。因为同样，那些有适度严重的内存限制。所以他必须学会如何<a id="OEBPS/Chapter09.html.page_371"></a>以压缩形式表示数据以使其适合计算器。我不希望他以这种方式度过他的整个编程生涯，但我认为这是一次有用的经历。</p><p class="normal"><b>Steele:</b> It's easy to become too fixated on optimizing something just because you can, even though it's not what you need to work on. That's indeed true. I'm glad that my son had the experience of programming TI calculators when he was in high school. Because again, those had moderately severe memory constraints. And so he had to learn how to <a></a>represent data in compressed forms to get it to fit in the calculator. I wouldn't want him to spend his whole programming career that way, but I think it was a useful experience.</p>
<p class="normal"><b>Seibel：</b>回到代码之美——那种俳句，折纸编程之所以美丽，是因为任何复杂的小东西都是美丽的。</p><p class="normal"><b>Seibel:</b> Back to code beauty—that kind of haiku, origami programming is beautiful for the reason that any intricate little thing is beautiful.</p>
<p class="normal"><b>Steele：</b>是的。但我要强调的是，Gosper 的那段代码很漂亮，不仅因为你可以用这种方式压缩它——它开始时这么小的一个原因是因为它基于一个漂亮的数学公式，一个正弦的三角公式功能。递归可以在这个特定的体系结构上非常简洁地表达，因为该体系结构旨在以当时其他机器所不支持的方式支持递归。所以有几种不同的美学融合在一起，结合在这个例程中。</p><p class="normal"><b>Steele:</b> Yes. But I should emphasize that that piece of Gosper's code is beautiful not only because you can compress it in this way—one of the reasons it's so small to begin with is because it's based on a beautiful mathematical formula, a triple angle formula for the sine function. And that recursion can be expressed very concisely on this particular architecture because that architecture was designed to support recursion in a way that other machines of its day weren't. So there are several different aesthetics melding together, combined in this one routine.</p>
<p class="normal"><b>Seibel：</b>您还提到了 Knuth 的 TeX，它显然是一个更大的程序。是什么让这个程序如此美丽？</p><p class="normal"><b>Seibel:</b> You also mentioned Knuth's TeX, which is obviously a much larger program. What is it that makes that program beautiful?</p>
<p class="normal"><b>Steele：</b>他将一个非常非常复杂的程序与许多特殊情况结​​合起来，并将其简化为一个非常简单的范例：将盒子粘在一起并粘合在一起。这是一个非常关键的突破。事实证明，它不仅可以灵活地排版文本，还可以灵活地处理所有其他事情，以及与页面上的二维视觉布局有关的事情。我希望更多的 GUI 界面基于盒子和胶水来布置按钮和类似的东西。</p><p class="normal"><b>Steele:</b> He took a very, very complicated program with lots of special cases and reduced it to a single, very simple paradigm: sticking boxes and glue together. That was an immensely critical breakthrough. It turns out to be flexible not only for typesetting text but for all manner of other things as well that have to do with laying things out visually, two-dimensionally, on a page. I wish that more GUI interfaces were based on boxes and glue for laying out buttons and things like that.</p>
<p class="normal"><b>Seibel：</b>所以一旦你理解了盒子和胶水的含义，你就可以欣赏美，你可以说，“是的，这是一个深刻而正确的想法，我欣赏它的美，看看它如何在这个项目之外应用。” 通过阅读源代码并查看该主题如何发挥作用，您是否获得了——并且只能获得——进一步的审美品质？或者更多的是你阅读了整篇文章，然后在最后你说，“哇，这真的是基于这个简单但不简单的想法。”？</p><p class="normal"><b>Seibel:</b> So there is beauty to be appreciated once you understand what boxes and glue means, you can say, “Yeah, that's a deep and righteous idea and I appreciate the beauty of that and see how it would apply outside this one program.” Is there further aesthetic quality that you get—and can only get—by reading through the source code and seeing how that theme plays out? Or is it more that you read the whole thing and then at the end you say, “Wow, that was really all based on this one simple, but not simplistic, idea.”?</p>
<p class="normal"><b>Steele：</b>这是这些的结合。而 Knuth 真的很擅长讲一个关于代码的故事。当你通读<i>《计算机编程艺术》</i>和你通读算法时，他已经解释过了<a id="OEBPS/Chapter09.html.page_372"></a>向您展示了一些应用程序并给了您一些工作练习，您觉得自己已经踏上了一段值得的旅程。一路上你看到了有趣的景象。在 TeX 的代码中徘徊，我也有同样的感觉。我学到了一些关于编程的东西。还有一部分是平淡无奇、敷衍了事等等。还有一些你会说，“哇，我没想到要那样组织。” 每个都有一点。</p><p class="normal"><b>Steele:</b> It's a combination of those. And Knuth is really good at telling a story about code. When you read your way through <i>The Art of Computer Programming</i> and you read your way through an algorithm, he's explained it <a></a>to you and showed you some applications and given you some exercises to work, and you feel like you've been led on a worthwhile journey. And you've seen interesting sights along the way. Wandering through the code of TeX I feel much the same way. I've learned some things about programming. And some parts of them are mundane and perfunctory and so forth. And other ones you say, “Wow, I didn't think of organizing it that way.” It's a little of each.</p>
<p class="normal"><b>Seibel：</b>在代码美的另一端，软件也充满了我们无法摆脱的令人痛苦的历史缺陷，比如不同的行结束约定。</p><p class="normal"><b>Seibel:</b> At the other end of the spectrum from code beauty, software is also full of painful historical warts that we can't get rid of, like differing line-ending conventions.</p>
<p class="normal"><b>Steele：</b>是的。我们在 Common Lisp 委员会花了很多时间来讨论行尾的处理方式，以适应仅使用换行符的 Unix 和使用 CRLF 的 PDP-10 系统。正确定义换行符以使其在这两个操作系统上都能正常工作是一场噩梦。</p><p class="normal"><b>Steele:</b> Yes. We spent hours and hours in the Common Lisp committee just debating the treatment of end of line in order to accommodate both Unix, which used just newline, and the PDP-10 systems, which used CRLF. And getting the definition of newline just right so it worked on both those operating systems was a nightmare.</p>
<p class="normal"><b>Seibel：</b>那么对于那些正在阅读本书并打算编写未来软件的人来说，有什么办法可以避免这些事情吗？有什么方法可以让我们变得更聪明吗？或者这只是进化设计的本质？</p><p class="normal"><b>Seibel:</b> So for the people who are reading this book and are going to be writing some of the software of the future, is there any way to avoid that stuff? Is there any way we can be smarter? Or is it just the nature of evolutionary design?</p>
<p class="normal"><b>Steele：</b>是的。并且不知道未来。如果我能改变一件事——这听起来很愚蠢——但如果我能回到过去并改变一件事，我可能会试着让一些早期没有文字的人在数数时不使用拇指。它本可以成为标准，并且在现代时代会让很多事情变得更容易。另一方面，我们从十进制与二的幂不兼容的斗争中学到了很多东西。</p><p class="normal"><b>Steele:</b> Yeah. And not knowing the future. If I could change one thing—this is going to sound stupid—but if I could go back in time and change one thing, I might try to interest some early preliterate people in not using their thumbs when they count. It could have been the standard, and it would have made a whole lot of things easier in the modern era. On the other hand, we have learned a lot from the struggle with the incompatibility of base-ten with powers of two.</p>
</div>
</div></div>
<div id="OEBPS/Chapter10.html"><div>

<div class="booksection">
<p></p>
<h2 class="chapnum"><a id="OEBPS/Chapter10.html.ch10"></a><a id="OEBPS/Chapter10.html.page_373"></a><img src="data:image/jpg;base64,/9j/4AAQSkZJRgABAgEASABIAAD/7Q3qUGhvdG9zaG9wIDMuMAA4QklNA+0KUmVzb2x1dGlvbgAAAAAQAEgAAAABAAEASAAAAAEAAThCSU0EDRhGWCBHbG9iYWwgTGlnaHRpbmcgQW5nbGUAAAAABAAAAHg4QklNBBkSRlggR2xvYmFsIEFsdGl0dWRlAAAAAAQAAAAeOEJJTQPzC1ByaW50IEZsYWdzAAAACQAAAAAAAAAAAQA4QklNBAoOQ29weXJpZ2h0IEZsYWcAAAAAAQAAOEJJTScQFEphcGFuZXNlIFByaW50IEZsYWdzAAAAAAoAAQAAAAAAAAACOEJJTQP1F0NvbG9yIEhhbGZ0b25lIFNldHRpbmdzAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+BdDb2xvciBUcmFuc2ZlciBTZXR0aW5ncwAAAHAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAOEJJTQQAC0xheWVyIFN0YXRlAAAAAgABOEJJTQQCDExheWVyIEdyb3VwcwAAAAAEAAAAADhCSU0ECAZHdWlkZXMAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4NVVJMIG92ZXJyaWRlcwAAAAQAAAAAOEJJTQQaBlNsaWNlcwAAAAB1AAAABgAAAAAAAAAAAAAAlAAAANAAAAAKAFUAbgB0AGkAdABsAGUAZAAtADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAANAAAACUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhCSU0EERFJQ0MgVW50YWdnZWQgRmxhZwAAAAEBADhCSU0EFBdMYXllciBJRCBHZW5lcmF0b3IgQmFzZQAAAAQAAAACOEJJTQQMFU5ldyBXaW5kb3dzIFRodW1ibmFpbAAACg0AAAABAAAAcAAAAFAAAAFQAABpAAAACfEAGAAB/9j/4AAQSkZJRgABAgEASABI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" alt="图片"></h2><h2 class="chapnum"><a></a><a></a></h2>
<h2 class="chaptitle">丹·英格尔斯</h2><h2 class="chaptitle">Dan Ingalls</h2>
<div class="sidebar">
<p class="normal"><i>如果 Alan Kay 是 Smalltalk 的父亲，那么 Dan Ingalls 就是它的母亲——Smalltalk 最初可能只是 Alan Kay 眼中的一线曙光，但 Ingalls 是付出辛勤努力将其带入世界的人。从第一个用 BASIC 编写并基于 Kay 的一页笔记的 Smalltalk 实现开始，Ingalls 参与了从第一个原型到当今开源实现 Squeak 的七代 Smalltalk 的实现。</i></p><p class="normal"><i>If Alan Kay is Smalltalk's father, Dan Ingalls is its mother—Smalltalk may have started as a gleam in Alan Kay's eye, but Ingalls is the one who did the hard work of bringing it into the world. Starting with the first implementation of Smalltalk, written in BASIC and based on one page of notes from Kay, Ingalls has been involved in implementing seven generations of Smalltalk from the first prototype to the present-day open source implementation, Squeak.</i></p>
<p class="normal"><i>Ingalls 最初是一名物理学家，开始使用 Fortran 进行编程，后来开始销售他在研究生院时编写的分析器，并最终找到了通往 Xerox PARC 的路，在那里他加入了 Kay 的学习研究小组，该小组建立了 Smalltalk 并探索了计算机在孩子的教育。</i></p><p class="normal"><i>Originally a physicist, Ingalls started programming with Fortran, made a business selling a profiler he wrote while in grad school, and eventually found his way to Xerox PARC, where he joined Kay's Learning Research Group, which built Smalltalk and explored the use of computers in children's education.</i></p>
<p class="normal"><i>在 PARC 期间，Ingalls 还发明了位图图形中使用的 BitBlt 操作，并将其编码为 PARC 的 Alto 计算机的微代码，从而实现了高性能位图图形，从而实现了 UI 创新，例如我们现在都采用的弹出菜单理所当然。（在 Ingalls 的一次 Smalltalk 系统内部演示中，一个弹出式菜单让我下一章的主题 L Peter Deutsch 跳起来惊呼：“你刚刚做了我想做的事吗？ ”）</i></p><p class="normal"><i>While at PARC, Ingalls also invented the BitBlt operation used in bit-mapped graphics and coded it in microcode for PARC's Alto computer, allowing the high-performance bit-mapped graphics that enabled UI innovations such as pop-up menus that we now all take for granted. (At one of Ingalls's in-house demonstrations of the Smalltalk system, a pop-up menu caused the subject of my next chapter, L Peter Deutsch, to leap to his feet and exclaim, “Did you just do what I thought you did?”)</i></p>
<p class="normal"><i>Ingalls 现在是 Sun Microsystems 的杰出工程师，正在研究 Lively Kernel，这是一种类似 Smalltalk 的编程环境，它使用 JavaScript 和浏览器提供的图形完全在浏览器中运行。他收到了<a id="OEBPS/Chapter10.html.page_374"></a>1984 年计算机协会 Grace Murray Hopper 奖和 1987 年 ACM 软件系统奖，以表彰他在 Smalltalk 方面的工作。2002 年，他获得了 Dr. Dobb 的卓越编程奖。</i></p><p class="normal"><i>Now a Distinguished Engineer at Sun Microsystems, Ingalls is working on Lively Kernel, a Smalltalk-like programming environment that runs completely in the browser using JavaScript and browser-provided graphics. He received the <a></a>Association for Computing Machinery Grace Murray Hopper Award in 1984 and the ACM Software System Award in 1987 for his work on Smalltalk. In 2002 he won the Dr. Dobb's Excellence in Programming Award.</i></p>
<p class="normal"><i>在我们的谈话中，我们谈到了交互式编程环境的重要性，为什么幸运的是他从未学过 Lisp，以及为什么构建灵活的动态系统然后锁定它们比构建静态系统然后尝试添加更好动态特征。</i></p><p class="normal"><i>In our conversation, we talked about the importance of interactive programming environments, why it was a lucky thing he never learned Lisp, and why it's better to build flexible, dynamic systems and then lock them down rather than building static systems and then trying to add dynamic features.</i></p>
</div>
<p class="normal"><b>Seibel：</b>首先，您是如何参与编程的？</p><p class="normal"><b>Seibel:</b> To start at the start, how did you get involved in programming?</p>
<p class="normal"><b>英格尔斯：</b>让我们看看。我在地下室长大，成为一名发明家，而物理学是我最接近的，所以那是我的大学专业。我去了哈佛，那里有一门关于 Fortran 编程的课程，我选了这门课。</p><p class="normal"><b>Ingalls:</b> Let's see. I grew up being an inventor in my basement, and physics was the closest I could come to that so that was my college major. I went to Harvard and there was a course on programming in Fortran, which I took.</p>
<p class="normal"><b>Seibel：</b>那会是几年？</p><p class="normal"><b>Seibel:</b> What years would that have been?</p>
<p class="normal"><b>英格尔斯：</b>我从 62 年到 66 年都在哈佛。我的两次编程经历是关于 Fortran 的这门课程，在我参加模拟计算机课程的其中一栋楼的地下室里有一个很棒的实验室。它让你的想法完全不同——你有这个大接线板，然后只是一堆电路，它们是集成器、微分器——你可以将它们连接在一起以实时解决各种问题。但它始于 Fortran，我从一开始就喜欢它。我试着看看我能把程序写多短，诸如此类。</p><p class="normal"><b>Ingalls:</b> I was at Harvard from '62 to '66. My two programming experiences were this course on Fortran and there was a great lab in the basement of one of the buildings where I took a course on analog computers. It makes you think completely differently—you've got this big patch panel and then just a bunch of circuits that are integrators, differentiators—things that you can wire together to solve all sorts of problems in real time. But it began with Fortran and I loved it from the get-go. I tried to see how much shorter I could make programs, and stuff like that.</p>
<p class="normal">结果我决定也许我对电气工程感兴趣。所以我以双 E 的身份来到斯坦福大学，在那里学习了一些计算机科学课程，并且非常享受。我没有在 double E 上花那么多时间。我上了 Don Knuth 的课程，他有一门关于程序测量的研究生课程，我很喜欢。我实际上参与了一个可以分析其他程序的程序，然后从斯坦福大学退学并以此为生。第二年我拿到了硕士学位，然后退学了。所以我们现在是 68 年，我猜。</p><p class="normal">As a result I decided that maybe I was interested in electrical engineering. So I came out to Stanford in double E and took some computer-science courses there and really enjoyed that. I didn't spend that much time with double E. I got into Don Knuth's course and he had a graduate course on program measurement and I loved that. I actually worked on a program that would analyze other programs and dropped out of Stanford to make a business out of it. I got my master's the next year, and then dropped out. So we're in '68 now, I guess.</p>
<p class="normal"><b>Seibel：</b>所以这是你退出的博士课程？</p><p class="normal"><b>Seibel:</b> So it was a PhD program you dropped out of?</p>
<p class="normal"><a id="OEBPS/Chapter10.html.page_375"></a><b>Ingalls：</b>对，在斯坦福大学的无线电科学系，它是双 E 的一部分。</p><p class="normal"><a></a><b>Ingalls:</b> Right, in the radio science department at Stanford, which was part of double E.</p>
<p class="normal"><b>Seibel：</b>所以你做生意的程序是什么？</p><p class="normal"><b>Seibel:</b> So the program you made a business out of—what was it?</p>
<p class="normal"><b>Ingalls：</b>嗯，它是从 Knuth 开始的，作为我参加的一个研讨会的一部分。该研讨会旨在衡量程序并查看它们的动态行为。</p><p class="normal"><b>Ingalls:</b> Well, it started out with Knuth, as a part of a seminar I took. The seminar was to measure programs and look at their dynamic behavior.</p>
<p class="normal"><b>Seibel：</b>意思是，剖析？</p><p class="normal"><b>Seibel:</b> Meaning, profiling?</p>
<p class="normal"><b>英格尔斯：</b>是的。所以有一个程序会吞噬一个 Fortran 程序并在每个分支点插入计数器。我做了一个更漂亮的版本，它也有一个定时器中断过程，这样它就可以跟踪在程序的各个部分花费了多少实时时间。</p><p class="normal"><b>Ingalls:</b> Yeah. So there was a program that would gobble up a Fortran program and insert counters at every branch point. I made a fancier version of it that also had a timer-interrupt process so that it would keep track of how much real time was spent in various parts of the program.</p>
<p class="normal"><b>Seibel：</b>所以基本上是一个采样分析器？</p><p class="normal"><b>Seibel:</b> So basically a sampling profiler?</p>
<p class="normal"><b>英格尔斯：</b>对。值得注意的是，在那之前，分析通常是根据内存位置进行的，需要量子力学才能知道结果告诉你什么，而这是根据你的源代码出现的，你可以看到，“哦，它把所有的时间都花在这里了。” 这立即可供用户使用。我认出了，“哇！人们可能正在使用它。”</p><p class="normal"><b>Ingalls:</b> Right. And what was notable about these was that until that time profiling had typically been in terms of memory locations, and it took a quantum mechanic to know what the results were telling you, whereas this came out in terms of your source code and you could see, “Oh, it's spending all its time here.” This was immediately usable to the user. I recognized, “Whoa! people could be using this.”</p>
<p class="normal"><b>Seibel：</b>所以你经营你的企业有一段时间了——在你去 Xerox PARC 之前，你是不是一直在做这件事？</p><p class="normal"><b>Seibel:</b> So you ran your business for a while—is that what you were doing up until you went to Xerox PARC?</p>
<p class="normal"><b>英格尔斯：</b>差不多。事实上，这就是我最终进入 PARC 的原因。我最终在当地的服务局呆了很多时间。有一个 Control Data 和一个 IBM。我会将我的程序带到这些不同的地方，并确保它在他们特定的计算机上运行。</p><p class="normal"><b>Ingalls:</b> Pretty much. In fact, that's how I ended up at PARC. I wound up spending a bunch of time in local service bureaus. There was a Control Data one and an IBM one. And I would take my program around to these various places and make sure that it ran on their particular computer.</p>
<p class="normal"><b>Seibel：</b>这还在分析 Fortran 代码吗？</p><p class="normal"><b>Seibel:</b> And this was profiling Fortran code still?</p>
<p class="normal"><b>英格尔斯：</b>是的。但是我发现了一个有趣的事情。谁是 Fortran 的大用户？他们是大型科学计算用户。他们都在为谁工作？他们都在为政府工作。他们关心他们的程序有多高效吗？并不真地。他们真正想做的是表明计算机超载，他们需要一台新计算机<a id="OEBPS/Chapter10.html.page_376"></a>和更多的钱。我在几家公司展示了这个，他们说，“天哪，如果你有这个用于 COBOL，那就太好了。”</p><p class="normal"><b>Ingalls:</b> Yeah. But I found out an interesting thing. Who were the big Fortran users? They're big scientific computation users. And who are they all working for? They're all working for the government. Do they care how efficient their program is? Not really. What they really want to do is to show that the computer is overloaded and that they need a new computer <a></a>and more money. I showed this at a couple of companies and they said, “Jeez, if you had this for COBOL it would be great.”</p>
<p class="normal"><b>Seibel：</b>因为没有人会给他们更多的钱来为 COBOL 购买大铁。</p><p class="normal"><b>Seibel:</b> Because no one's going to give them more money to buy big iron for COBOL.</p>
<p class="normal"><b>英格尔斯：</b>没错。所以我为 COBOL 写了同样的东西。这是我对 COBOL 的沉浸。我记得我写了一个完成例程，将来自定时器中断的统计数据放在一起。完成例程希望用与您正在测量的东西相同的语言编写，以便它们可以一起加载。我可能是唯一一个用 COBOL 编写过哈希表的人。</p><p class="normal"><b>Ingalls:</b> Exactly. So I wrote the same thing for COBOL. This was my immersion into COBOL. I remember writing the completion routine that would put together the statistics from the timer interrupts. The completion routine wanted to be written in the same language as the thing you're measuring so that it could all be loaded in together. I may be the only person who's ever written a hash table in COBOL.</p>
<p class="normal">不管怎样，卖得很好。我记得有几次我出去的销售电话，作为演示，我在他们的一个程序上运行它，并在演示过程中向他们展示如何节省比程序成本更多的钱。</p><p class="normal">Anyway, that sold great. I can remember several sales calls where I'd go out and as a demo I'd run it on one of their programs and, in the course of the demo, would show them how to save more money than the program cost.</p>
<p class="normal">在四处寻找这些服务局的过程中，我在斯坦福工业园区的 CDC 服务局结束了——通常你工作到深夜，因为那时它更便宜——那里有另一个人有一个 Fortran 程序做语音识别。他有各种语音样本，他的程序分析了频谱并将音素和类似的东西分组。我开始和他说话，我说，“好吧，老天，你想在你的程序上运行我的程序吗？” 所以我们就那样做了，然后分手了。</p><p class="normal">In the process of going around to these service bureaus, I wound up at the CDC service bureau in Stanford industrial park—typically you're working late at night because that's when it was less expensive—there was another guy there who had a Fortran program to do speech recognition. He had various speech samples and his program analyzed the spectra and grouped the phonemes and stuff like that. I started talking to him and I said, “Well, jeez, you want to run my program on yours?” So we did that and parted company.</p>
<p class="normal">几周后他给我打电话说：“施乐聘请我做一个语音识别项目，但没有人帮我解决细节问题；你愿意和我一起工作吗？” 所以我开始咨询他。那就是乔治·怀特，他长期从事语音识别工作。这就是我进入 Xerox 和 Alan Kay 的方式，因为事实证明我的办公室就在 Alan 的办公室对面，而且我一直听到比语音识别更感兴趣的对话。</p><p class="normal">He called me up a couple of weeks later and said, “I've been hired by Xerox to do a speech-recognition project and I've got no one to help me with the nitty-gritty; would you like to work with me?” So I started consulting with him. That was George White, who went on for a long time to do speech recognition. That's how I got in with Xerox and also with Alan Kay, because it turned out that my office was across the hall from Alan's and I kept hearing conversations that I was more interested in than speech recognition.</p>
<p class="normal"><b>Seibel：</b>是不是语音识别领域没有那么有趣，或者它与所涉及的编程有关？</p><p class="normal"><b>Seibel:</b> Was the domain of speech recognition not that interesting or was it something about the programming involved?</p>
<p class="normal"><a id="OEBPS/Chapter10.html.page_377"></a><b>英格尔斯：</b>哦，这很有趣——令人着迷。我最终在这台 Sigma 3 小型计算机上构建了一个完整的个人计算环境。它使用卡片组，而 Fortran 是我必须使用的主要工具。由此我构建了一个交互式环境。我用 Fortran 编写了一个文本编辑器，然后我们可以开始从终端远程提交内容。它最终成为一个不错的小型计算环境，只是以这种奇怪的方式完成。</p><p class="normal"><a></a><b>Ingalls:</b> Oh, it was interesting—it was fascinating. I ended up building up a whole personal-computing environment on this Sigma 3 minicomputer. It used card decks and Fortran was the main thing I had to work with. Out of that I built an interactive environment. I wrote a text editor in Fortran and then something so we could start submitting stuff remotely from a terminal. It wound up being a nice little computing environment, just done in this sort of strange way.</p>
<p class="normal"><b>Seibel：</b>这种对交互式环境的渴望是你职业生涯中多次出现的主题。例如，您用 BASIC 编写了第一个 Smalltalk，因为那是您手头的交互式环境。您从哪里得到这样的想法，即给定一个要解决的问题，您首先需要的是一个交互式编程环境？</p><p class="normal"><b>Seibel:</b> This desire for an interactive environment is a theme that's come up a bunch of times in your career. For example, you wrote the first Smalltalk in BASIC because that was the interactive environment you had at hand. Where did you get that idea that given a problem to solve, the first thing you need is an interactive programming environment?</p>
<p class="normal"><b>英格尔斯：</b>这是个好问题。我认为任何你能立即得到满足的东西都会自生自灭。</p><p class="normal"><b>Ingalls:</b> That's a good question. I think anything where you get immediate gratification feeds on itself by definition.</p>
<p class="normal"><b>Seibel：</b>那么您最先感到满足的地方是什么？</p><p class="normal"><b>Seibel:</b> So what was that first place that you had that immediate gratification?</p>
<p class="normal"><b>英格尔斯：</b>有一些经历。我有机会使用半交互式 PL/I。我的一个朋友在 IBM 工作，那里有交互式 APL 环境。我不记得哪一个是第一个。我真的记得 APL 那个。这在很多方面影响了我，因为交互的即时性——看到你的结果返回——和表达式求值，这与 Fortran 的面向语句的编程完全不同。</p><p class="normal"><b>Ingalls:</b> There were a couple of experiences. I had a chance to work with a semi-interactive PL/I. And a friend of mine was working at an IBM where they had an interactive APL environment. I can't remember which of those was first. I really remember the APL one. That affected me in a number of ways because of both the immediacy of interaction—seeing your results come back—and the expression evaluation, which is really different from Fortran's statement-oriented programming.</p>
<p class="normal">您现在仍然看到这一点，这很惊人 — 整个 C/C++/Java 传统，尽管它朝着面向对象的方向发展，但仍然是面向语句的。但如果方便做表情，确实让体验变得不一样。对我来说，它使数学更加生动。无论如何，这是两者之一。当我到 Xerox 时，除了 Lisp 家伙的东西外，没有太多的互动。我碰巧不喜欢 Lisp。我希望，如果我是，事情会有所不同。</p><p class="normal">You still see that now, it's amazing—the whole C/C++/Java tradition, although it goes in an object-oriented direction, is still statement-oriented. But if it's convenient to make expressions, it really makes the experience different. To me it brings the mathematics to life more. Anyway, it was one of those two. When I got to Xerox there wasn't much interactive except the Lisp guys' stuff. I happened not to be into Lisp. Things would have been different if I were, I expect.</p>
<p class="normal"><b>Seibel：</b>怎么会这样？</p><p class="normal"><b>Seibel:</b> How so?</p>
<p class="normal"><a id="OEBPS/Chapter10.html.page_378"></a><b>英格尔斯：</b>我想我会完全朝那个方向走。由于没有朝那个方向前进，这让我想以不同的方式做那种事情。我认为我与 Alan 合作的作品具有同样漂亮、生动、表达的感觉，但它更自然地包含了对象和消息的概念。</p><p class="normal"><a></a><b>Ingalls:</b> I think I would have gone completely in that direction. And by not having gone in that direction, it left me wanting to do that kind of thing in a different way. I think what I worked on with Alan had that same kind of nice, lively, expression feel, but it included the notion of objects and messages more naturally.</p>
<p class="normal">我想如果我在像 Lisp 这样的系统中感到舒服，我就不会打扰了。我会尝试绕过它来获取对象，但我认为，从一开始就从对象的概念开始，然后让它变得美观、交互和方便，这是一种贡献。</p><p class="normal">I think if I had been as comfortable in a system like Lisp, I never would have bothered. I would have tried working around it to get objects, but starting with the notions of objects from the get-go and then making that nice and interactive and convenient was, I think, a contribution.</p>
<p class="normal"><b>Seibel：</b> Alan Kay 曾说过，Lisp 和 Smalltalk 都存在这样的问题，即它们太好以至于吃了自己的孩子。如果你知道 Lisp，那么 Smalltalk 将是第一个被吃掉的孩子。</p><p class="normal"><b>Seibel:</b> Alan Kay has said that both Lisp and Smalltalk have the problem that they're so good they eat their children. If you had known Lisp, then Smalltalk would have been the first eaten child.</p>
<p class="normal"><b>英格尔斯：</b>也许是这样。</p><p class="normal"><b>Ingalls:</b> Maybe so.</p>
<p class="normal"><b>Seibel：</b>所以这是无知优势的一个很好的例子；它为创造力留下了一些空间。但有时感觉无知是这个行业的通病——人们对事物一无所知，轮子不断被改造成尖角。</p><p class="normal"><b>Seibel:</b> So that's a nice example of the advantage of some ignorance; it leaves some room for creativity. But sometimes it feels like ignorance is endemic in this industry—that people are unaware of things and wheels are constantly being reinvented with pointy corners.</p>
<p class="normal"><b>英格尔斯：</b>是的。</p><p class="normal"><b>Ingalls:</b> That's true.</p>
<p class="normal"><b>Seibel：</b>我们应该尝试解决这个问题吗？这只是我们必须付出的代价，这样人们才能有创造力的空间吗？或者，如果人们更多地了解正在发生的事情，我们会过得更好吗？</p><p class="normal"><b>Seibel:</b> Should we be trying to fix that? Is it just a price that we have to pay so that people can have room for creativity? Or would we be better off if people were a little more aware of what else is going on?</p>
<p class="normal"><b>Ingalls：</b>我是一个拥抱多样性的人。我想，我们刚才举的例子是说，“不，让人们随心所欲。” 无知会造成浪费，但自然选择会解决问题。你会得到这些带你进入未来的偶然运动。</p><p class="normal"><b>Ingalls:</b> I'm an embrace-diversity guy. The example we just went through, I think, says, “No, let people go whatever way they want.” There will be waste from ignorance, but natural selection will take care of straightening things out. And you will get these occasional sports that take you into the future.</p>
<p class="normal">我能想到很多领域，在这些领域中，试图标准化，试图所有人都朝着同一个方向前进，抑制了创造力。我在一家由 Java 提供支持的公司工作，所以我不会在这方面走得太远，但当 Java 出现时就是这种情况——我衡量它的最简单方法是查看 OOPSLA 发生的事情——当 Java 出来的时候不仅工作慢<a id="OEBPS/Chapter10.html.page_379"></a>在其他面向对象的编程语言中甚至可能会停止，但即使在一般的动态编程中也是如此。我认为那是一种损失。</p><p class="normal">I can think of lots of areas where trying to standardize, trying to all go in one direction, has suppressed creativity. I work at a company that's supported by Java, so I'm not going to go very far with this, but it is the case that when Java came out—the easiest way I had of measuring it was looking at what went on at OOPSLA—when Java came out not only did work slow <a></a>down and even maybe come to a halt on other object-oriented programming languages but even in dynamic programming in general. I think that was a loss.</p>
<p class="normal">但这不是永久性的。人们终于意识到“哦，等一下，Java 拥有所有这些强大的优势，我们正在用它来做这做那，但我们正在用动态编程语言做其他好事，现在是时候回到那个了。” 但这是一个我很容易看到的例子，因为我参与其中。</p><p class="normal">But it wasn't permanent. People finally realized “Oh, wait a minute, Java has all these great strengths and we're using it for this and that but we were on to other good things with dynamic programming languages and it's time to get back to that.” But that's an example that's easy for me to see because I'm involved in it.</p>
<p class="normal">从更广泛的意义上说，我讨厌看到计算机科学系认为他们的角色是让人们为在一个行业工作做好准备，而这个行业正在朝着这个方向发展，因此我们必须以这种方式教我们的学生。这完全是错误的做法。你应该对你的学生做的是教他们进行一般性思考——跳出框框思考并规划我们应该学习的<i>其他课程。</i></p><p class="normal">In a much bigger sense I hate to see computer-science departments that feel their role is to prepare people to work in an industry and the industry is going that way and therefore we have to teach our students that way. It's exactly the wrong thing to do. What you should be doing with your students is teaching them to think generally—think outside the box and plot the <i>other</i> courses we should be pursuing.</p>
<p class="normal">这不是一个简单的问题，因为拥有完整的标准<i>具有</i>很大的价值。拥有数以千计的程序员，他们处理过数以千计的例程，而且他们非常扎实——您可以通过这种方式完成您的工作。</p><p class="normal">It's not a simple problem because there <i>is</i> great value to having that whole standard out there. Having thousands of programmers who have worked on thousands of routines and they're very solid—you can get your work done that way.</p>
<p class="normal">为生产服务的计算机科学与为推动知识内容发展服务的计算机科学之间存在一些差异。我一直在享受 Lively Kernel 的乐趣，从某种意义上说，它是微不足道的。这没有什么新鲜事——我正在使用以前的所有东西。它建立在 JavaScript 和您可以在浏览器中获得的图形之上。但它真的很有趣，因为它是另一个像 Squeak 一样的内核。因为 JavaScript 都在浏览器中，图形也都在浏览器中，所以内核的工作非常小。只是，如何使图形栩栩如生，如何构建一个小的计算环境。</p><p class="normal">It's a little bit the difference between computer science in the service of production and computer science in the service of moving the intellectual content forward. I've been having fun with the Lively Kernel, which is, in a way, trivial. There's nothing new about it—I'm using all stuff that was there before. It's built on JavaScript and the graphics you can get in a browser. But it's been really fun because it's another kernel like Squeak. Because JavaScript is all there in the browser and the graphics is all there in the browser, the work on the kernel is very tiny. It's just, how do you bring the graphics to life and how do you build up a little computing environment.</p>
<p class="normal">每当你做这样的事情时，足够小，那么任何人都能理解。如果你从等式中去掉一些东西，比如语言和图形，那么问题就是，内核是什么？我认为这是一个有趣的问题。</p><p class="normal">Whenever you do something like that, small enough, then anybody can understand it. If you take a few things out of the equation, like the language and the graphics, then the question is, what is the kernel? And I think that's an interesting question.</p>
<p class="normal">我希望这——不是特别是我的东西——但这种调查可能会重新激发计算机科学来做一些关于你如何<a id="OEBPS/Chapter10.html.page_380"></a>制作一个内核，我们还可以制作更简单、更统一的其他内核。</p><p class="normal">I'm hoping that this—not particularly my stuff—but this kind of investigation might reinspire computer science to do some studies about how do you <a></a>make a kernel, what other kernels could we build that are even simpler, even more uniform.</p>
<p class="normal">这就像数学所做的一样。通过符号化事物发现的数学可以简化很多事物。然后，正因为如此，你可以开始考虑更大的结构。那是我的希望。</p><p class="normal">It's like what math did. Math found by symbolizing things that you could simplify a lot of stuff. Then, because of that, you could start to think about bigger constructs. That's my hope.</p>
<p class="normal"><b>Seibel：</b>当您说内核时，您指的是编程内核。Lively Kernel的核心是什么？</p><p class="normal"><b>Seibel:</b> When you say a kernel, you're talking about a programming kernel. What's the core of the Lively Kernel?</p>
<p class="normal"><b>Ingalls：</b>我所说的内核通常是指将足够多的东西放在一起，从某种意义上说，它可以构建自己或构建其他有用的东西。Squeak 是一款真正可以自行构建的产品。Lively Kernel 假定存在 JavaScript 和一些图形，但它最终具有编辑图形的能力，以便您可以创建新的图形事物，并编辑程序以便您可以创建新程序。因此，构建您可能想要在浏览器中构建的所有应用程序就足够了。</p><p class="normal"><b>Ingalls:</b> What I mean by a kernel, typically, is you put together enough stuff that it can, in some sense, build itself or build other useful things. Squeak is one that really can build itself. The Lively Kernel presumes the existence of JavaScript and some graphics, but it ends up with the ability to edit the graphics so that you can make new graphical things and to edit the programs so you can make new programs. So it's enough to build all the applications that you might want to build in a browser.</p>
<p class="normal">我认为在玩这个游戏时你可以隐藏你想要的图层。问题是，你的比赛场地在哪里。在 Squeak 中，整个语言都是内核的一部分，因此它有自己的编译器和字节码解释器。它有它的整个图形系统——它有 BitBlt 和所有相关的东西。</p><p class="normal">I think in playing this game you get to hide layers that you want to. The question is, where is your playing field. In Squeak the whole language is part of the kernel so it's got its own compiler and byte-code interpreter. And it's got its whole graphics system—it's got BitBlt and all the stuff around that.</p>
<p class="normal">看起来它们是任何内核的重要组成部分，但您<i>可以</i>将它们删除。你可以说，“让我们假设我们有一个动态语言；让我们假设我们有图形。” 在我以前的想法中，我会想，“好吧，没有别的了。” 但事实并非如此。剩下的就是如何将图形组合在一起以创建有趣的用户界面环境？以及如何将程序和脚本提升到可以更改它们的级别？</p><p class="normal">It looks like those are an important part of any kernel but you <i>can</i> take them out. You can say, “Let's assume that we have a dynamic language; let's assume that we have graphics.” In my old thinking, I would have thought, “Well, there is nothing else.” But it's not true. What's left is, how do you put the graphics together to make an interesting user interface environment? And how do you bring programs and scripts up to the level that you can change them?</p>
<p class="normal">我被迫想出一些无需安装即可在浏览器中运行的东西，以获取浏览器中的内容。浏览器里有什么？好吧，我们有 JavaScript 和图形环境。这是一个从这一切中退后一步说，“嗯，是的，有语言内核，有图形内核，然后还有其他类型的自支持用户界面环境内核。”</p><p class="normal">I was forced, by trying to come up with something that would run without installation, in a browser, to take what was in the browser. What's in the browser? Well, we've got JavaScript and we've got a graphics environment. It was a chance to step back from all this and say, “Well, yes there are language kernels, there are graphics kernels, and then there's this other kind of self-supporting user-interface environment kernel.”</p>
<p class="normal"><a id="OEBPS/Chapter10.html.page_381"></a><b>Seibel：</b>在 Lively Kernel 和 Squeak 中，从我玩过的小游戏来看，内核的一部分不是语言或图形，而是始终可编程的 UI 概念——它有这些小手柄等等你可以用它来做程序化的事情。</p><p class="normal"><a></a><b>Seibel:</b> In both Lively Kernel and Squeak, from the little that I've played with them, part of that kernel that's not the language or the graphics is this notion of a UI that's always programmable—it's got these little handles and so forth that you can do programmatic things with.</p>
<p class="normal"><b>英格尔斯：</b>对。</p><p class="normal"><b>Ingalls:</b> Right.</p>
<p class="normal"><b>Seibel：</b>我发现这很令人困惑。我在编程吗？我在使用这个应用程序吗？有时我希望有更多的区别。</p><p class="normal"><b>Seibel:</b> I found that pretty confusing. Am I programming? Am I using this application? Sometimes I wished there were a bit more of a distinction.</p>
<p class="normal"><b>英格尔斯：</b>是的。这是另一把双刃剑。我不认为有一个简单的答案。从根本上说，我们制造出完全允许改变的计算机是一件了不起的事情。都是随机存取存储器；这都是可编程的。对我来说，保持活力、可塑性和多变性很重要。如果你有一个动态和可变的系统，然后划定界限并说，“你不能改变这里的东西”比从非动态和可变的东西开始然后尝试使它更容易那样。</p><p class="normal"><b>Ingalls:</b> Yup. This is another of those double-edged swords. I don't think there's a simple answer. At the very bottom, it's a wonderful thing that we've built computers that totally allow for change. It's all random-access memory; it's all programmable. To me it's important to keep that liveliness, that malleability, that changeability. If you have a system that's dynamic and changeable, it's much easier to then draw boundaries and say, “You can't change stuff inside of here” than it is to start out with something that's not dynamic and changeable and then try to make it that way.</p>
<p class="normal">如果你现在看 Web 编程，它是从这种文本标记语言开始的，然后 JavaScript 出现了，试图让它变得动态。如果从当时每个人都知道的动态图形开始，然后在需要时固定和打印东西，会容易得多。</p><p class="normal">If you look at web programming right now, it started out with this text-markup language and then JavaScript came into the picture to try and make it dynamic. It would have been so much easier to start out with something that was like the dynamic graphics everyone knew about in those days and then make stuff fixed and printable when you needed to.</p>
<p class="normal"><b>Seibel：</b>好吧，除了那些只想在 Web 上放置一些文本的人之外，每个人都更容易。</p><p class="normal"><b>Seibel:</b> Well, easier for everybody except someone who just wanted to put some text on the Web.</p>
<p class="normal"><b>英格尔斯：</b>我想那是真的。但是有人更容易在其之上放置一个层，如 HTML。我认为最好让底层系统尽可能动态。然后你可以加上语法或类型限制，或者这个，那个，以及其他使它成为固定事物的东西。当然，有些情况下人们只是在使用一个系统——你希望事情是固定的，不需要灵活。是的，如果人们认为它很灵活，他们就会感到害怕。如果您按现在的样子使用 Lively Kernel，它根本不是最终用户想要的东西。没有人愿意突然看到他们的窗户倾斜 20 度。</p><p class="normal"><b>Ingalls:</b> I suppose that's true. But it's easier for someone to put a layer, like HTML, on top of that. I think it's better to have the underlying systems be as dynamic as possible. Then you can put on syntax or type restrictions, or this, that, and the other that make it into a fixed thing. Absolutely there are situations when people are just using a system—you want things to be fixed that don't need to be flexible. And yes it does seem that if people perceive that it's flexible, it's scary to them. If you take the Lively Kernel as it is right now, it's not at all something that an end user would want. Nobody wants to suddenly see their window tilted at 20 degrees.</p>
<p class="normal"><b>Seibel：</b>或者检查他们试图按下的按钮的代码。</p><p class="normal"><b>Seibel:</b> Or to inspect the code of the button they're trying to press.</p>
<p class="normal"><a id="OEBPS/Chapter10.html.page_382"></a><b>英格尔斯：</b>对，对。这真的是一个演示，试图激励那些想要朝那个方向发展的人。它也非常简单，所以有人可以放入一个层，使其可用并且不能以各种奇怪的方式进行更改。但是，是的，在让事情变得灵活和通用与让事情被编码并能够用作食谱并始终按照您的期望进行操作之间存在真正的权衡。</p><p class="normal"><a></a><b>Ingalls:</b> Right, right. Really it's a demo to try to inspire people who want to go that direction. It's also very simple so somebody could put in a layer that would make it usable and not changeable in those various weird ways. But yeah, there's a real trade-off between having things be flexible and general and having things be codified and able to be used as a cookbook and always do what you expect.</p>
<p class="normal"><b>Seibel：</b>你真的认为当前的 Lively Kernel 或它的一些近期演化将成为人们构建应用程序的一种方式，或者这真的是 Sun Labs 向人们展示一种思维方式的思想实验吗？</p><p class="normal"><b>Seibel:</b> Do you really think the current Lively Kernel, or some near-term evolution of it, will become a way people are going to build apps, or is this really a thought experiment out of Sun Labs to show people a way of thinking?</p>
<p class="normal"><b>Ingalls：</b>嗯，这绝对是一个思想实验。它提供了一些甜蜜点，从某种意义上说，这些点实际上可能会作为真正的产品生存下来。它有能力非常快速地做一些事情，比如，如果你想做一个红色的心，在里面放一条信息，让它跳动，然后把它存储为一个网页，你可以在里面做所有的事情，从来没有安装了任何软件。所以你得到了 Lively Kernel，你用一些脚本构建了这个动态的小东西，它有 WebDAV 协议来创建和存储一个新的网页。</p><p class="normal"><b>Ingalls:</b> Well, it's definitely a thought experiment. It offers a couple of sweet spots that might actually survive as real products in some sense. It's got the ability to very quickly do something like, if you wanted to make a red heart and put a message in it and make it throb, and then store that as a web page, you can do all that from within it, never having installed any software. So you get the Lively Kernel and you build this little dynamic thing with a little bit of scripting in it and it's got the WebDAV protocol to go out and create and store a new web page.</p>
<p class="normal">这是简单而有用的东西，如果脚本同样简单，就像 eToys 中的磁贴脚本一样，我认为很多人可以从中获得乐趣。所以这是一种噱头。但是，如果你再考虑两个级别，你就会进入实际上具有教育意义的东西——你可以构建可以与之交互的简单动态模型。它很像 Flash，但它更简单并且与编程集成度更高。</p><p class="normal">That's something that's simple and useful and if the scripting were equally simple, the way the tile scripting is in eToys, I think that a lot of people could have fun playing with that. So that's sort of a gimmick. But if you take that about two levels more, you're into stuff that's actually educational—you could build simple dynamic models that you could interact with. It's a lot like Flash but it's simpler and more integrated with programming.</p>
<p class="normal">从那里开始，我只是认为它可能是一个很好的环境，可以嵌入许多动态的、有教育意义的小例子。一两年前出现了 HyperCard，许多教师能够理解它并在其中做有用的事情。整个体验并没有自然而然地进入网络，这真的很奇怪。我认为像 HyperCard 这样简单、像 Web 这样直接的工具仍然可以发挥作用。如果那样的话会很酷。</p><p class="normal">From there, I just think of it as being possibly a nice environment for embedding lots of little dynamic, educational examples. A decade or two ago there was HyperCard and lots of teachers were able to understand that and do useful things in it. It's really strange that that whole experience didn't naturally go right into the Web. I think there's still a role to be filled there with tools as simple as HyperCard and as immediate as the Web. It would be cool if it went that way.</p>
<p class="normal"><b>Seibel：</b>众所周知，您参与了五、七代或多代 Smalltalk 实现。让我们从第一个 Smalltalk 开始<a id="OEBPS/Chapter10.html.page_383"></a>你在 BASIC 中所做的。你有几页艾伦·凯的笔记，你必须把它们变成现实。你做了什么？</p><p class="normal"><b>Seibel:</b> You've famously been involved in five or seven or however many generations of Smalltalk implementations. Let's start with the first Smalltalk <a></a>that you did in BASIC. You had a couple pages of notes from Alan Kay that you had to make real. What did you do?</p>
<p class="normal"><b>Ingalls：</b>我刚开始输入代码。我认为第一件事是验证执行模型。只需要几个基本结构，相当于堆栈框架。所以我刚刚做了，它一定是一个数组，在 BASIC 中，这样做并足够组合以执行一段代码。</p><p class="normal"><b>Ingalls:</b> I just started typing in code. I think the first thing was to validate the execution model. There were just a couple of basic structures that were needed, the equivalent of a stack frame. So I just made, it must have been an array, in BASIC, to do that and put together enough that would execute a piece of code.</p>
<p class="normal">通常对于类似的东西——我想到的词是你的“面包板”——你只需做你需要做的来把一个结构放在适当的位置，这个结构就是你认为你想要解释的结构，然后尝试让它起作用。我记得我们首先要运行的是六阶乘。这是一个非常简单的示例，但它涉及动态查找和创建新堆栈帧的过程。然后一旦你开始工作，你就会明白事情将如何发展，你会发现什么是困难的。</p><p class="normal">Typically with something like that—the word that's coming to mind is you “breadboard” it—you just do what you need to do to put a structure in place that's the structure you think you're going to want to interpret and then try to make it work. I remember the first thing we got to run was six factorial. It's a really simple example but it involves the process of dynamic lookup and creating new stack frames. And then once you've got that working, you come to understand how things are going to go and you find out what's difficult.</p>
<p class="normal">最终你会弄清楚时间花在了哪里，所以你会改进所有这些事情。然后，在这种特殊情况下，一旦成功，就会出现在其上放置一个层的问题，该层本质上是一个解析器，因此您可以在其中键入文本并使其进入您试验板的结构。然后你就有了一个小环境，你开始学习东西。</p><p class="normal">Eventually you figure out where the time's going and so you improve all those things. Then, in this particular case, once that worked there was the problem of putting a layer on it which is essentially a parser so you can type text into it and get it to go into that structure that you breadboarded. Then you've got a little environment and you start learning things.</p>
<p class="normal">然后你说，“好的，我知道它是如何工作的，我要用汇编代码来写它，”或者其他什么。然后你突然意识到，“哦，是的，我们需要自动存储管理。那我们要怎么做呢？” 这是一件接一件的事情。</p><p class="normal">Then you say, “OK, I see how this works, I'm going to write it in assembly code,” or whatever else. Then you suddenly realize, “Oh, yeah, we need automatic storage management. So how are we going to do that?” It's one thing after another.</p>
<p class="normal"><b>Seibel：</b>那么，是否曾经发生过这种即时开发失败的情况，或者您知道它不会起作用而必须以某种不同的方式进行设计的情况？</p><p class="normal"><b>Seibel:</b> So have there ever been things where that sort of just-in-time development either failed to work, or you knew it would not work and you had to do a design in some different way?</p>
<p class="normal"><b>英格尔斯：</b>好吧，你总是尽你所能，当你陷入困境时，你总是转身反思。</p><p class="normal"><b>Ingalls:</b> Well, you always do what you can and when you're stuck you always turn away and reflect.</p>
<p class="normal">在实施者的范围内，我可能会犯错误，只是让事情发生。很多是因为我得到了太多的刺激<a id="OEBPS/Chapter10.html.page_384"></a>生活中的事情，一开始是错的甚至都没有关系。关键是，一旦生命出现，它就会开始告诉你它是什么。</p><p class="normal">In the spectrum of implementers, I probably err on the side of just making things happen. A lot of that is because I get so much of a thrill bringing <a></a>things to life that it doesn't even matter if it's wrong at first. The point is, that as soon as it comes to life it starts telling you what it is.</p>
<p class="normal">你会发现，是的，也许你可以完全不同地完成存储管理，但你正在学习的真正重要的东西与那无关。我做的第一个 Smalltalks 使用引用计数进行垃圾收集；可能使用其他东西会更好。有一段时间，引用计数带来了一定程度的痛苦。但这并不重要——关键是系统已经启动、活跃和运行，我们正在学习所有其他伟大的东西，比如你如何把东西和对象放在一起，以面向对象的方式做数字是什么感觉——所有那其他真正的进步。</p><p class="normal">And you find out that, yes, maybe you could have done the storage management completely differently, but the really important things you're learning have nothing to do with that. The first Smalltalks I did used reference counting for garbage collection; probably it would have been better to use something else. For a while there was a certain amount of pain associated with reference counts. But that didn't matter—the point was the system was up and alive and running and we were learning all this other great stuff about how you put together things with objects, what it's like to do numerics in an object-oriented style—all that other real progress.</p>
<p class="normal"><b>Seibel：</b>我不知道你在这个范围内有那么远，至少在我为本书采访过的人中是这样。尽管 Don Knuth 在输入一行代码之前确实用铅笔在笔记本上写了六个月的 TeX，他说他节省了时间，因为他不必费心编写脚手架来测试他正在开发的所有代码，因为他只是写整个东西。</p><p class="normal"><b>Seibel:</b> I don't know that you're that far out on the spectrum, at least among the people I've talked to for this book. Though Don Knuth did write TeX in pencil in a notebook for six months before he typed in a line of code and he said he saved time because he didn't have to bother writing scaffolding to test all the code he was developing because he just wrote the whole thing.</p>
<p class="normal"><b>英格尔斯：</b>我相信。有些人的运作方式完全不同。但对于特定的人，我认为这就是他们必须做的事情。我知道我已经以某种方式浪费了一些时间。但也有它的这一面，它是探索性编程的原型方面，如果它能让你更快地进入一个你可以从中学习的环境，你可能会发现你的一些最初的目标甚至没有事情。更重要的是那边的另一件事。这成为一个全新的焦点。</p><p class="normal"><b>Ingalls:</b> I believe that. There are people who operate completely differently. But for a given person I think that's just how they have to operate. I know I've wasted some time one way or another. But there's also this side of it, and it's sort of the archetypal aspect of exploratory programming, which is if it gets you more quickly to an environment that you can learn from, you may find out that some of your original goals don't even matter. What's much more important is that other thing over there. And that becomes a whole new focus.</p>
<p class="normal">回到反思和把事情做好的需要，我已经做过几次了。我想到的例子是 BitBlt。当我决定做成为 BitBlt 的事情时，它遇到了这样的挑战，我不得不坐下来吃一两个晚上的面条。也就是说，您将如何有效地将位边界上的所有这些位跨字边界移动？在这种情况下，世界上没有任何其他选择可供我使用。所以我想了又想，想出了一个简单的模型。这不是其他人的规范，但我已经查看了我们进行线条绘制、文本显示和滚动的所有地方，所以我心中有一个关于它需要做什么的规范。</p><p class="normal">Coming back to this need to reflect and get things right, there have been a couple of times when I've done that. The example that comes to my mind is BitBlt. When I decided to do the thing that became BitBlt, it had this challenge to it that I had to sit and noodle for a night or two. Which is, how are you going to efficiently move all these bits on bit boundaries across word boundaries? That was a case where there weren't any alternatives out in the world for me to work with. And so I thought about that and thought about that and came up with a simple model. It wasn't somebody else's spec but I had looked at all the places we were doing line drawing and text display and scrolling so I had a spec in my mind for what it needed to do.</p>
<p class="normal"><a id="OEBPS/Chapter10.html.page_385"></a><b>Seibel：</b>也许你可以解释一下 BitBlt 旨在解决的基本问题。</p><p class="normal"><a></a><b>Seibel:</b> Maybe you can explain the basic problem that BitBlt was designed to solve.</p>
<p class="normal"><b>Ingalls：</b>想把显示器想象成一个 1000×1000 像素的屏幕与记忆是逐字组织的事实之间的脱节。如果你想拿起这四位并将它们放在<i>那里</i>，它们可能在你放它们的单词的不同部分。事实上，它们可能跨越两个词。如果在屏幕上，你试图将这个东西移到那里，可能你将不得不从<i>这里</i>的两个单独的词中拾取碎片，然后把它们放在<i>那里</i>。当你放下它们时，你必须存储整个单词。所以你将不得不把它插入到之前的地方并在它周围遮住。所以这是一团糟。</p><p class="normal"><b>Ingalls:</b> The disconnect between wanting to think about the display as just a 1000×1000-pixel screen and the fact that the memory is organized word by word. If you want to pick up these four bits and put them down <i>there</i>, they may be in a different part of the word where you put them down. In fact they might straddle two words. If, on the screen, you're trying to move this thing to there, it may be that you're going to have to pick up pieces from two separate words <i>here</i> and lay them down <i>there</i>. And when you lay them down you have to store an entire word. So you're going to have to insert that into what was there before and mask around it. So it's a mess.</p>
<p class="normal">然后是屏幕光栅 - 屏幕的逐行方面，为您提供二维。BitBlt 处理源和目标每个扫描行可能具有不同数量的字的可能性。</p><p class="normal">Then there's the screen raster—the line-by-line aspect of the screen that gives you two dimensions. BitBlt handles the possibility that the source and destination may have differing numbers of words per scan line.</p>
<p class="normal">这是一个挑战，其中对需要发生的事情有一个明确的规范，这也是其中之一，你试图拥有一个非常通用的内核，因为如果你做对了，它不仅会让你把东西从一部分到另一部分，但它可以让你做重叠的卷轴。它还允许您混合像素。有所有这些概括的机会。</p><p class="normal">That was a challenge where there was a clear spec for what needed to happen, and it was also one of these things where you tried to have a very general kernel, because if you do this right, it will not only give you moving things from one part to another, but it will allow you to do overlapping scrolls. And it will also allow you to blend pixels. There's all this opportunity for generalization.</p>
<p class="normal">我测试了它并确保它首先在 Smalltalk 中运行，然后在汇编中运行，然后将它放入 Alto 的微代码中。最终完成后，我们可以基本上以内存的全速执行这些操作，而不会因为所有令人讨厌的屏蔽和移位而造成任何延迟，因为这些都可以隐藏在内存周期时间之下。</p><p class="normal">I tested it and made sure it ran first in Smalltalk, then in assembly, then put it into microcode for the Alto. When finally done, we could do these operations at essentially the full speed of the memory without any delay due to all the yucky masking and shifting because that could all be hidden under the memory-cycle time.</p>
<p class="normal">拥有微程序计算机是一个很好的动力，因为很明显，如果有一个小内核可以执行所需的操作，那么可以将其放入微代码中，整个系统就会运行得很快。所以我总是有动力去做那件事。</p><p class="normal">Having microprogrammed computers around was a wonderful motivation because it was clear that if there was a little kernel that would do what was needed, then that could be put in microcode and the whole thing would run fast. So I was always motivated to do that.</p>
<p class="normal">我为所有这些想出的东西，它实际上是作为一个图像而不是其他任何东西出现在我脑海中的，也就是说，它就像一个轮子。<i>如果你想到来源、目的地和单词边界，就好像有一个轮子在这里</i>捡起整个单词，然后把它们从<i>这里</i>扔到那里<a id="OEBPS/Chapter10.html.page_386"></a>只需要一个班次——这就是我想到的画面。然后只需将其放入代码中即可。</p><p class="normal">The thing I came up with for all of this, it actually came to me as an image rather than anything else, which is, it's like a wheel. If you think of the source and the destination and word boundaries, it's like there's a wheel picking up whole words <i>here</i> and then dropping them off <i>here</i>, and there <a></a>would only be one shift required—that was the picture that came to me. Then it was just a matter of putting that into code.</p>
<p class="normal">所以在 BitBlt 操作的中心基本上有一个长移位器，它从源中拾取单词并将它们放到目的地。这是我必须坐下来思考的事情。但是一旦你有了它，你就可以用这种方式存储常量，你可以放置文本，从字体中提取字形，并将它们放在任何像素位置。</p><p class="normal">So at the center of the BitBlt operation there's essentially one long shifter, which is picking up words from the source and dropping them in the destination. That was the thing I had to sit down and think about. But once you had that you could do storing of constants this way, you could do the laying down of text, the extraction of glyphs from a font, and putting them down at any pixel location.</p>
<p class="normal"><b>Seibel：</b>回到 Smalltalk 的 BASIC 实现：那是原始的 Smalltalk，甚至在 Smalltalk-72 之前？</p><p class="normal"><b>Seibel:</b> Back to the BASIC implementation of Smalltalk: that was sort of the primordial Smalltalk, before even Smalltalk-72?</p>
<p class="normal"><b>英格尔斯：</b>对。工作的那一刻我就开始并完成了整个汇编语言版本——因为那是我在 Nova 上的版本——相当完整。所以我们用它来调试一堆东西，然后与此同时，正在建造 Alto。一旦它可用，我们就搬过去并开始在 Alto 上跑步。那变成了 Smalltalk-72。</p><p class="normal"><b>Ingalls:</b> Right. The minute that worked I set off and did this whole assembly-language version—because that's what I had on the Nova—that was fairly complete. So we used that to debug a bunch of stuff and then, in parallel with that, the Alto was being built. As soon as it was available, we moved over and started running on the Alto. That became Smalltalk-72.</p>
<p class="normal"><b>Seibel：</b>所以 Smalltalk-72 是用汇编程序编写的——它是从哪里开始自我托管的？您经常听说 Smalltalk 的一大优点是它的大部分内容都是自己实现的。</p><p class="normal"><b>Seibel:</b> So Smalltalk-72 was written in assembler—where along the line did it become self-hosting? You often hear that one of the great things about Smalltalk was that so much of it was implemented in itself.</p>
<p class="normal"><b>英格尔斯：</b>那是很久以后的事了。Smalltalk-72 有一大堆汇编代码。Smalltalk-76 也做到了。Smalltalk-72 与 Smalltalk-76 的最大区别在于我为 Smalltalk 设计了字节码引擎，它具有关键字语法并且是可编译的。此外，对于您关于自我描述的观点，类甚至堆栈框架都是真实的对象。</p><p class="normal"><b>Ingalls:</b> That was a long time later. Smalltalk-72 had a big pile of assembly code with it. And Smalltalk-76 did, too. The big difference from Smalltalk-72 to Smalltalk-76 was that I came up with the byte-code engine for Smalltalk that had the keyword syntax and it was compilable. Also that classes and even stack frames were real objects, to your point about self-description.</p>
<p class="normal"><b>Seibel：</b>您是从哪里得到编写字节码解释器的想法的？</p><p class="normal"><b>Seibel:</b> Where did you get the idea to write a byte-code interpreter?</p>
<p class="normal"><b>英格尔斯：</b>那是一种机制。我正在努力解决的一件大事是 Smalltalk-72 动态解析，至少出于两个原因，我们需要能够编译具有这些语义但不需要动态解析所有内容的东西.</p><p class="normal"><b>Ingalls:</b> That was a mechanism. The big thing that I was grappling with was that Smalltalk-72 parsed on the fly and for two reasons, at least, we needed to be able to compile something that had those kinds of semantics but that didn't require parsing everything on the fly.</p>
<p class="normal">所以我想到了 Smalltalk-76 语法，它几乎是 Smalltalk-80 语法。那么问题是，您将其编译成什么才能以这种方式有效运行？唯一变得复杂的地方<a id="OEBPS/Chapter10.html.page_387"></a>是在做我们所谓的远程评估——你在这里声明的变量，但他们在这里得到评估。这就是 Smalltalk 中的块，就像其他系统中的闭包一样。</p><p class="normal">So I came up with the Smalltalk-76 syntax, which is pretty much the Smalltalk-80 syntax. Then the question is, what do you compile that into that will run effectively this way? The only place where it got complicated <a></a>was in doing what we called remote evaluation—variables you declare up here but they get evaluated down here. This is what ended up as blocks in Smalltalk, which are like closures in other systems.</p>
<p class="normal"><b>Seibel：</b>为什么不直接编译成机器码呢？</p><p class="normal"><b>Seibel:</b> Why not just compile to machine code?</p>
<p class="normal"><b>Ingalls：</b>我们仍然非常注重空间，与周围的任何其他东西相比，这些东西最终变得非常紧凑。它需要如此紧凑，因为我们仍在尝试在具有 96K 的 Altos 上运行它。然后他们推出了大的，128K。紧凑性很重要。</p><p class="normal"><b>Ingalls:</b> We were still very space-conscious and this stuff wound up incredibly compact compared to anything else around. And it needed to be that compact because we were still trying to run this on Altos that had 96K. Then they came out with the big one, which was 128K. The compactness was important.</p>
<p class="normal"><b>Seibel：</b>意思是生成的代码会更小，因为字节码比本地机器指令更丰富？</p><p class="normal"><b>Seibel:</b> Meaning the generated code would be smaller because the byte codes were richer than native machine instructions?</p>
<p class="normal"><b>英格尔斯：</b>是的。我也很喜欢这个想法，并受到 Peter Deutsch 在 Lisp 字节码引擎方面的工作的启发。这种协同作用进一步激发了我的灵感——它是这些内核中的另一个可以适合微代码的内核。从一开始我就设想它会进入 Alto 的微代码。</p><p class="normal"><b>Ingalls:</b> Yeah. I also just plain loved the idea and was inspired by Peter Deutsch's work on the byte-code engine for Lisp. I was further inspired by this synergy—it's another one of these kernels that could fit in microcode. From the beginning I envisioned it as going into the microcode of the Alto.</p>
<p class="normal"><b>Seibel：</b>微码是 RAM，所以你可以把 Smalltalk 内核放在那里，然后切换到 Lisp，把 Lisp 字节码解释器放在那里。</p><p class="normal"><b>Seibel:</b> And the microcode was RAM so you could put the Smalltalk kernel in there and then switch to Lisp and put the Lisp byte-code interpreter in there.</p>
<p class="normal"><b>英格尔斯：</b>是的。</p><p class="normal"><b>Ingalls:</b> Yup.</p>
<p class="normal"><b>Seibel：</b>那么下一步的发展是什么？</p><p class="normal"><b>Seibel:</b> Then what was the next evolution?</p>
<p class="normal"><b>Ingalls：</b> Smalltalk-76 继承了所有同类的图形包袱——大量用于线条绘制、文本显示等的特殊代码。但是当时我做了BitBlt，所以我重写了内核，所有的图形只用了BitBlt和Smalltalk，这样内核就小了很多。那就是 Smalltalk-78，这是我们在微处理器上运行的第一个——在 8086 上。</p><p class="normal"><b>Ingalls:</b> Smalltalk-76 inherited all the same sort of graphics baggage—a lot of special code for line drawing, text display, and so on. But at that time I had done BitBlt, so I rewrote the kernel so all the graphics just used BitBlt and Smalltalk, so that made the kernel much smaller. That was Smalltalk-78, which was the first one we ran on a microprocessor—on an 8086.</p>
<p class="normal">但这仍然不是 Smalltalk 中的 Smalltalk。Smalltalk 中的 Smalltalk 直到 Squeak 才出现。Smalltalk-80 有一个在书中发布的虚拟机规范，但所有的实现都是用 C 或汇编代码编写的。</p><p class="normal">But that still wasn't Smalltalk in Smalltalk. The Smalltalk in Smalltalk wasn't until Squeak. Smalltalk-80 had a virtual machine spec that was published in the book, but all the implementations were in C or assembly code.</p>
<p class="normal"><b>Seibel：</b>编译器呢？</p><p class="normal"><b>Seibel:</b> What about the compiler?</p>
<p class="normal"><a id="OEBPS/Chapter10.html.page_388"></a><b>Ingalls：</b>编译器是用 Smalltalk 编写的。实际上，当我们编写 Smalltalk-80 书籍时，Dave Robson 和我——这主要是他的工作——编写了字节码解释器的 Smalltalk 仿真。作为 Smalltalk-80 版本的一部分，我们希望帮助人们构建他们自己的虚拟机。我们发现，最有用的帮助之一是在您首次启动系统时准确跟踪哪些字节码以何种顺序执行。</p><p class="normal"><a></a><b>Ingalls:</b> The compiler was written in Smalltalk. Actually, when we were doing the Smalltalk-80 books, Dave Robson and I—it was mainly his work—wrote a Smalltalk emulation of the byte-code interpreter. As part of the Smalltalk-80 release we wanted to help people build their own virtual machines. We had discovered that one of the most useful aids was a trace of exactly what byte-codes get executed in what order when you first start up the system.</p>
<p class="normal">所以他在 Smalltalk 中编写了一个模拟器，因为我们的 Smalltalk 变得足够快，这是一件合理的事情，并产生了所有这些可以帮助人们调试的痕迹。</p><p class="normal">So he wrote an emulator in Smalltalk, because our Smalltalk was getting fast enough that that was a reasonable thing to do, and produced all those traces that would help people debugging.</p>
<p class="normal"><b>Seibel：</b>你想帮助人们编写 Smalltalk 虚拟机，因为 Smalltalk-80 的目的是成为一个逃生舱，这样即使 PARC 决定不对它做任何事情，Smalltalk 也可以走向世界？</p><p class="normal"><b>Seibel:</b> And you wanted to help people write Smalltalk virtual machines because the point of Smalltalk-80 was to be an escape pod so Smalltalk could go out into the world even if PARC decided not to do anything with it?</p>
<p class="normal"><b>英格尔斯：</b>没错。然后我离开了这个行业，当我回来的时候，我想为一个新项目做一个 Smalltalk。那时事情进展得如此之快以至于“等一下; 为什么我们不尝试运行它的 Smalltalk 版本，看看会发生什么？但是“啊哈！” 是，机械地将其转换为 C 应该不难，然后它就会和其他引擎一样快。如果你想改变虚拟机的某些东西，你可以在 Smalltalk 中改变它——你可以在 Smalltalk 中尝试它，然后按下一个按钮，它就会突然出现在生产解释器中。</p><p class="normal"><b>Ingalls:</b> That's right. Then I left the industry and when I came back, I wanted to do a Smalltalk for a new project. At that time things were running so fast that, “Wait a minute; why don't we just try running the Smalltalk version of it and see what that does?” But the “aha!” was, it shouldn't be hard to mechanically translate that to C and then it would be as fast as the other engines. If you wanted to change something about the virtual machine you could change that in Smalltalk—you could try it out in Smalltalk and then push a button, and it would suddenly be in the production interpreter.</p>
<p class="normal"><b>Seibel：</b>所以你把这个 Smalltalk 解释器写在它碰巧写在 Smalltalk 的任何子集中，并编写了一个知道如何将该子集编译成 C 的专用编译器？</p><p class="normal"><b>Seibel:</b> So you took this Smalltalk interpreter written in whatever subset of Smalltalk it happened to be written in and wrote a special-purpose compiler that knows how to compile that subset into C?</p>
<p class="normal"><b>Ingalls：</b> C 翻译器只是 Smalltalk 编译器的一个子集——我们只需要用 C 打印出解析树。这实际上是我们之前在 Xerox 做过的事情——Ted Kaehler 用 Smalltalk 编写了一个虚拟内存，并且然后我们使用相同的技巧将其转换为 BCPL。一样。</p><p class="normal"><b>Ingalls:</b> And the C translator was simply a subset of the Smalltalk compiler—we just had to make the parse trees print out in C. This was actually something we had done before at Xerox—Ted Kaehler had written a virtual memory in Smalltalk, and then we used the same trick to translate that to BCPL. Same thing.</p>
<p class="normal"><b>Seibel：</b>当 Smalltalk-80 面世时，世界上出现了 Smalltalk 公司；对象是一件大事；<i>Byte</i>的所有问题都与 Smalltalk 相关。<a id="OEBPS/Chapter10.html.page_389"></a>承诺是对象将成为这些可重用的组件，程序员只需去 Ye Olde Object Shoppe 购买一些对象并将它们插入到他们的程序中。那个诺言兑现了吗？</p><p class="normal"><b>Seibel:</b> When Smalltalk-80 got out in the world there were Smalltalk companies; objects were a big thing; <i>Byte</i> did its issue all about Smalltalk. <a></a>The promise was that objects were going to be these reusable components and that programmers would just go down to Ye Olde Object Shoppe and buy some objects and plug them into their program. Has that promise been kept?</p>
<p class="normal"><b>英格尔斯：</b>我认为是和否。</p><p class="normal"><b>Ingalls:</b> I think yes and no.</p>
<p class="normal"><b>Seibel：</b>那么它是以什么方式发生的呢？</p><p class="normal"><b>Seibel:</b> So in what ways has it happened?</p>
<p class="normal"><b>Ingalls：</b>看看 Java 的世界——就是这样一个世界。由于这些类型的界面，有大量的软件可以很好地协同工作。我认为这是向前迈出的真正一步。Smalltalk 中发生的一些事情或多或少确实在世界上结束了。其中之一是面向对象的设计和接口。另一个是动态语言和用户界面。它没有接管，你可以看看历史上的各个小地方，在这些地方，事情本可以以不同的方式做，而且它可能有更好的机会。但我不认为这是失去或获得的大事。世界在慢慢前进。其他事情做得更好。自然选择会处理这一切。</p><p class="normal"><b>Ingalls:</b> Look at the world of Java—it's that kind of a world. There are huge bodies of software that work well together because of those kinds of interfaces. I think that was all a real step forward. There were several things going on in Smalltalk that did end up in the world more or less. One of them is object-oriented design and interfaces. The other is dynamic languages and user interfaces. It didn't take over and you can look at various little places in history where things could have been done differently and it might have had a better chance. But I don't think that's a big thing lost or gained. The world moves forward slowly. Other things got done that were better. Natural selection takes care of it all.</p>
<p class="normal"><b>Seibel：</b>但是自然选择也可以选择一些非常奇怪的结果。</p><p class="normal"><b>Seibel:</b> But natural selection can also select some pretty grotesque outcomes.</p>
<p class="normal"><b>Ingalls：</b>哦，是的，Beta 和 VHS，这是真的。但最终，没有什么真正好的东西会真正丢失。</p><p class="normal"><b>Ingalls:</b> Oh yeah, Beta and VHS, it's true. But ultimately, nothing that's really good ever gets really lost.</p>
<p class="normal"><b>Seibel：</b> Alan Kay 近年来特别强调的 Smalltalk 的另一个方面是，它不应该是关于对象的；它应该是关于对象的；这是关于消息传递的。C++ 和 Java 的消息传递方式几乎与 Smalltalk 不同。为什么这是一个核心思想？</p><p class="normal"><b>Seibel:</b> Another aspect of Smalltalk that Alan Kay has particularly emphasized in recent years is that it wasn't supposed to be about objects; it was about message passing. C++ and Java don't have message passing in nearly the same way Smalltalk did. Why is that such a core idea?</p>
<p class="normal"><b>Ingalls：</b>因为它给了你真正的分离。艾伦的最新说法——我认为这很恰当——是它应该一直像互联网一样。我们担心我们在程序中的哪些地方有安全和各种安全机制，它们有各种各样的问题。但是互联网式的分离是一个真正的层，没有办法绕过。</p><p class="normal"><b>Ingalls:</b> Because it gives you real separation. Alan's latest phrase—which is appropriate, I think—is it should be like the Internet all the way down. We worry about where we have security and various sorts of security mechanisms in programs and there are all sorts of things wrong with them. But the Internet-style separation is a real layer that there's no way around.</p>
<p class="normal">那么为什么消息传递这么好呢？这就是原因：它将内部与外部 100% 分开。至少，做对了。和<a id="OEBPS/Chapter10.html.page_390"></a>还有其他系统在这方面走得更远，我认为我们会在那个领域看到更多。</p><p class="normal">So why is message passing such a good thing? That's the reason: it separates the inside from the outside, 100 percent. At least, done right it does. And <a></a>there are other systems that have gone farther with this and I think we'll see more in that space.</p>
<p class="normal"><b>Seibel：</b>所以没有什么好东西会真正丢失。是否有来自 Smalltalk 或其他任何地方的想法是您希望被主流采用的？</p><p class="normal"><b>Seibel:</b> So nothing good ever gets really lost. Are there ideas, from Smalltalk or anywhere else, that you wish had been adopted by the mainstream?</p>
<p class="normal"><b>Ingalls：</b>我对主流并没有真正的希望——我有我想做的事情，或者我想变得简单。在计算机科学的背景下，我对主流的一个愿望是，人们会更多地回到第一原则，了解如何在智力领域利用计算。</p><p class="normal"><b>Ingalls:</b> I don't really have wishes for the mainstream—I have things I want to do or that I would like to be easy. My one wish for the mainstream, in the context of computer science, is that people would go back to first principles a little bit more about ways to leverage computing in the intellectual space.</p>
<p class="normal">我们已经非常擅长使用我们所知道的编程系统和语言。如果我们对逻辑编程那么擅长怎么办？它整合得好吗？我认为我们会在更多以人为本的空间中做更多的事情。它确实朝着人工智能的方向发展。你必须知道，在某个时候，我们将跨越一个门槛，在这个门槛上，计算机将比我们更好地思考事物。</p><p class="normal">We've gotten incredibly good with the programming systems and the languages we know. What if we were that good with logic programming? And had it integrated well? I think we would be doing extraordinarily more stuff in much more of a human-oriented space. It does go in the direction of artificial intelligence. You have to know that at some point we're going to cross a threshold where computers will be doing a better job thinking about stuff than we do.</p>
<p class="normal">有时我想知道我们是否在无意识地拖延它。直到 1980 年，该领域取得了很大进展。现在计算机的速度和体积都快了几个数量级。在我得到的最新计算机上，如果我运行 Smalltalk 音乐合成，在 Smalltalk 中，它可以计算广播电台的无线电信号。这对于那些曾经可以看到正在计算简单算术的人来说很难。</p><p class="normal">I wonder sometimes if we're unconsciously holding that off. A lot of progress was made, up until 1980, in that area. And the computers are orders of magnitude faster and bigger now. On the latest computer I got, if I run the Smalltalk music synthesis, in Smalltalk, it can compute the radio signal for a radio station. This is hard for somebody who, at one point, could watch simple arithmetic being computed.</p>
<p class="normal">所以你把它与逻辑编程、基于规则的系统和人工智能中的各种可能性进行比较，你必须知道那里有很多进步。我想看看导致 Lively Kernel 的那种想法——除了语言和用户界面之外，内核是什么？还有哪些内核？如果您围绕逻辑编程构建一个内核，您可以用它做什么？我不认为人们在玩弄这些东西，修补这些东西还不够。因为，主啊，我们今天拥有的机器——如果你在那里有一个小小的突破，你就可以做出不可思议的事情。</p><p class="normal">So you take that and put it against all sorts of possibilities in logic programming, in rule-based systems, and artificial intelligence, and you have to know there's lots of progress to be made there. I would like to see the kind of thinking that led to the Lively Kernel—what is a kernel apart from the language and the user interface? What other kernels are there? What if you build a kernel around logic programming and what kinds of things can you do with that? I don't think that people are playing around with, tinkering with that stuff enough. Because, Lord, the machines we have today—if you have a minor breakthrough there you could do incredible stuff.</p>
<p class="normal"><a id="OEBPS/Chapter10.html.page_391"></a><b>Seibel：</b> Smalltalk 最初被设想为一个用于教育的平台，对吧？</p><p class="normal"><a></a><b>Seibel:</b> Smalltalk was originally envisioned as a platform for use in education, right?</p>
<p class="normal"><b>Ingalls：</b>它被设想为一种适合孩子——所有年龄段的孩子——使用 Alan 的原始短语的语言。我认为对整个项目有帮助的一件事是，它是一个长期项目，我们并不是要打造世界上最好的编程环境。我们的目的是构建教育软件，所以很多章程更多地是在简单和模拟现实世界的空间。</p><p class="normal"><b>Ingalls:</b> It was envisioned as a language for kids—children of all ages—to use Alan's original phrase. I think one of the things that helped that whole project, and it was a long-term project, was that it wasn't like we were out to do the world's best programming environment. We were out to build educational software, so a lot of the charter was more in the space of simplicity and modeling the real world.</p>
<p class="normal">有了这个教育目标，就可以很容易地激励低层次的东西尽可能简单。因此，我们所做的很多事情并没有像您希望的那样运行得那么快。第一个 Smalltalk-72 系统真的很慢——它的第二个修订版运行速度大约快 20、25 倍。但我们让它运行起来了，天哪，我们能够与孩子们一起使用它，甚至在尝试第二个版本之前就学到了很多东西。</p><p class="normal">Something about having this educational goal made it easy to keep inspiring the lower-level stuff to be as simple as possible. So there were lots of things we did that didn't run as fast as you might like. The first Smalltalk-72 system was really slow—the second revision on it ran about 20, 25 times faster. But we had it running, by God, and we were able to use it with kids and learned a huge amount before even trying a second version.</p>
<p class="normal">我们非常专注于让一些很酷的图形、位图图形、音乐，并用一种​​相当简单的语言将它们组合在一起。我们从中学到的东西确实造就了一种非常好的语言。所以在 Smalltalk-72 之后，我们做了 Smalltalk-76，本质上就是 Smalltalk-80。我看到这可能是一个严肃的行业编程环境。艾伦在那里有些紧张，因为他不想分散到那个方向。</p><p class="normal">We focused a lot on getting some cool graphics to work, bitmapped graphics, music, and putting it together in a fairly simple language. What we learned from that did actually make a seriously good language. So after Smalltalk-72, we did Smalltalk-76, which was essentially Smalltalk-80. And I saw that that could be a serious programming environment for the industry. There was some tension there with Alan because he wanted to not get scattered in that direction.</p>
<p class="normal">不久他就离开了施乐，因此我们走上了那些不同的道路。但那是因为我们发现了一些东西。例如，我们从一开始就在系统中进行更改的周转时间是几秒钟，很快就会达到亚秒级。它完全是活的。这就是我和其他一些人所热衷的事情。让我们建立一个像那样生活的系统。这就是 Smalltalk 的样子。所以这成为了一个新的目标，然后将 Smalltalk-80 剥离了。Squeak 是对这一点的回归，但增加了自己动手的部分。</p><p class="normal">It wasn't too much longer before he left Xerox, and so we pursued those separate paths. But that was because we had discovered some things. For instance, our turnaround time for making changes in the system from the beginning was seconds, and subsecond fairly soon. It was just totally alive. And that's something which I, and a bunch of the other people, got a passion for. Let's build a system that's living like that. That's what Smalltalk became. So that then became a new goal, which then spun Smalltalk-80 off. Squeak was a return to that, but with the doing-it-in-itself bit added.</p>
<p class="normal"><b>Seibel：</b>正如你所说，你和 Kay 走的是不同的道路。您是否对最初的 Smalltalk 愿景不再抱有幻想？</p><p class="normal"><b>Seibel:</b> So you and Kay followed, as you say, separate paths. Did you become disenchanted with the original Smalltalk vision?</p>
<p class="normal"><b>英格尔斯：</b>不，一点也不。我已经谈到了我作为物理学家的训练，我认为观察世界是我的天性——它是如何运作的，力是如何的，<a id="OEBPS/Chapter10.html.page_392"></a>行星如何运动，风如何吹，以及所有这些东西——提出有关它的问题并真正接触到这种现象。至少在物理世界中，这很容易。您可以归零并理解“是的，这就是它的工作原理”。</p><p class="normal"><b>Ingalls:</b> No, not at all. I've talked about my training as a physicist, and I think it's in my nature to look at the world—how it works, how forces are, <a></a>how the planets move, how the winds blow, and all that stuff—as asking questions about it and really being in touch with the phenomenon. In the physical world, at least, that's easy. You can zero in and come away with an understanding of, “Yes, that's how it works.”</p>
<p class="normal">在计算机中，我认为有同样的事情。在计算环境中，您应该能够将音乐、音乐合成和声音归零，并且只了解整个事物的工作原理。它应该是可访问的。图形也是一样。它的组合方式非常相似。你有原子的东西，它们是各种图形效果，然后你有结构的东西，你把它们放在一起。数值计算也是如此。</p><p class="normal">In computers I think there's the same kind of thing. You should be able, in a computing environment, to zero in on music and musical synthesis and sound and just understand how the whole thing works. It should be accessible. The same thing with graphics. It's put together very much the same way. You've got atomic things, which are the various graphical effects, and then you've got structural things you put them together with. The same thing's the case for numerical calculation.</p>
<p class="normal">当我带一个 Smalltalk 新手时，我会说，“你有什么兴趣，把文本分开？玩数字？看图形？还是玩音乐？” 然后我们从那里开始深入研究。这仍然是我热情的一部分，我相信艾伦也是如此，带领人们朝着他们有动力的方向深入探索，这样他们就会带着艾伦所说的强大的想法——“啊哈！” 这让你看到这个惊人的多样性实际上是一些小的、通用的东西在起作用。</p><p class="normal">When I take somebody new with Smalltalk, I'll say, “What interests you, taking text apart? Playing with numbers? Looking at graphics? Or playing with music?” And then we start there and do a deep dive on that. It's very much still a part of my passion, and I'm sure Alan's too, to take people through some deep dive in a direction that they're motivated about so they come away with what Alan calls powerful ideas—the “aha!” that lets you see this amazing variety is really a couple of small, general things at work.</p>
<p class="normal">你可以在音乐中看到这一点。你可以在图形中看到它。您可以在数字和文本操作中看到它。使它可用和可访问对我来说真的很令人兴奋。</p><p class="normal">You can see that in music. You can see it in graphics. You can see it in numbers and text manipulation. And it's really exciting to me to make that available and accessible.</p>
<p class="normal">Squeak 环境实际上是计算机科学家的环境。eToys 环境是孩子们的环境，但没有它应有的那么全面，而且我仍然觉得我们还没有在那里做一件事，它可以让你同样直观地潜入其中，并从物理上了解那些强大的东西想法。</p><p class="normal">The Squeak environment is really a computer scientist's environment. The eToys environment is a kids' environment, but not as comprehensive as it could be, and I still feel there's a thing we haven't done out there, which would allow you equally intuitively to dive in and get a physical understanding of those powerful ideas.</p>
<p class="normal">我仍然对它充满热情。为什么我在这里做这些东西——JavaScript 和浏览器——是因为我们已经非常接近能够将类似 Squeak 的材料放在网页上，您可以从任何浏览器浏览并以一些漂亮的自我交互-揭示方式。这是整个画面的一部分。我相信它会改变。浏览器将会改变。我们会得到除 JavaScript 之外的其他语言，我仍然与 Alan 和他的团队保持完全联系，他们正在对此进行另一种尝试<a id="OEBPS/Chapter10.html.page_393"></a>更深入地尝试更认真地解决其中一些其他问题。但它绝对仍然是相同的愿景。</p><p class="normal">I'm still as passionate about that as anything. Why I'm here doing this stuff—JavaScript and the browser—is that we're getting pretty close to being able to put Squeak-like material on a web page that you can browse from any browser and interact with in some nice, self-revealing way. That's part of this whole picture. I'm sure it's going to change. Browsers are going to change. We'll get other languages besides JavaScript, and I'm still totally in touch with Alan and his group, who are doing another take on this going <a></a>deeper down and trying to solve some of these other things more seriously. But it's absolutely still the same vision.</p>
<p class="normal"><b>Seibel：</b>你提到了四个学科：音乐、图形、数学和文本。那些与人类一样古老。显然，那里有独立于计算机的强大想法——计算机只是提供了一种探索它们的方法，如果没有计算机可能很难。计算机是否也有一套有趣的、强大的想法？编程或计算机科学是另一门深度学科——第五个领域——我们现在只有拥有计算机才能做到吗？</p><p class="normal"><b>Seibel:</b> You mention four disciplines: music, graphics, mathematics, and text. Those are about as old as humanity. Clearly there are powerful ideas there that are independent of computers—the computer just provides a way to explore them that might be hard without the computer. Is there also a set of interesting, powerful ideas inherent in the computer? Is programming or computer science another deep discipline—a fifth area—that we can only do now that we have computers?</p>
<p class="normal"><b>Ingalls：</b>是的，我想这就是我要表达的意思。我一直设想的课程是你从其中一个开始，也许出于深入其中一个领域的动机，你转向另一个不太熟悉的领域，并在那里做类似的事情。要吸取的教训是，在每种情况下，你获得生成整个场的那些更简单、更深层次结构的方式都是相似的。</p><p class="normal"><b>Ingalls:</b> Yes, I think that's what I am getting at. The curriculum I've always envisioned is one in which you start with one of these and maybe from the motivation of going deep in one of those areas, you move over to one of the other ones that's less familiar and do a similar thing there. And a lesson to be learned is that the way in which you get to those simpler, deeper structures that generate that whole field is similar in every case.</p>
<p class="normal">有一个图形代数。是原始物体，叠加平移，旋转。或者音乐。它是音符、时间序列和和弦——同样的东西。我认为这可以追溯到风如何运作以及行星如何运行。它邀请你深入了解事物的运作方式，并学习构成代数的事物——过程和原始事物。所以是的，第五个区域，正如你所说的，正是所有这些事情的共同点。</p><p class="normal">There's an algebra of graphics. It's primitive objects, superposition translation, rotation. Or music. It's notes and temporal sequences and chordals—same thing. And I think this goes back to seeing how the wind works and how the planets move. It's an invitation to go down and find out how things work and learn the things that make up the algebra—the processes and the primitive things. So yes, that fifth area, as you call it, is just what's common about all of these things.</p>
<p class="normal"><b>Seibel：</b>你认为一个玩过其中三四个领域的人最终会学习如何编程吗？或者，如果他们的兴趣恰好落入特定渠道，这只是可能发生的事情之一吗？</p><p class="normal"><b>Seibel:</b> Would you expect someone who has played with three or four of these areas to end up learning how to program? Or is that just one of the things that could happen if their interest happened to go down a particular channel?</p>
<p class="normal"><b>Ingalls：</b>我认为这只是可能发生的事情之一。希望你提高了他们的思维能力。通过向他们介绍事物并以某种方式让他们对事物感到兴奋。但是有些人会喜欢编程，有些人则不会。我有一个 12 岁的儿子，他只想在滑雪板上做 540 度的滑雪，一切都有时间和地点。</p><p class="normal"><b>Ingalls:</b> I think it's just one of the things that could happen. Hopefully you've sharpened their thinking skills. Both by introducing them to stuff and by getting them excited about stuff in some way or another. But there are people who are going to like programming and there are people who are not. I've got a 12-year-old son and all he wants to do is do 540s on skis, and there's a time and a place for everything.</p>
<p class="normal"><b>Seibel：</b>回到一些本质问题：你如何测试你的软件？</p><p class="normal"><b>Seibel:</b> Back to some nitty-gritty: how do you test your software?</p>
<p class="normal"><a id="OEBPS/Chapter10.html.page_394"></a><b>英格尔斯：</b>这取决于我在做什么。我总是为了最直接的满足而设置它。所以当尝试做一些新的事情时，我只想到什么是可以实现的第一个成功。在每种情况下都是不同的。如果我有更正常的生活，在更正常的编程团队中，我可能会完全融入当前的团队编程方式。但对我来说，它更像是自我诱导的——甚至是我注意力持续时间的问题。如果我认为我可以在周末完成这项工作，那么这就是我选择的大块，这就是我全力以赴的事情，忽略所有其他事情。我很难概括这一点，只能说，有一个地方是你想去的，你选择了其中的一块，那将是令人满意的，这将证明你</p><p class="normal"><a></a><b>Ingalls:</b> It depends what I'm doing. I always set it up for the most immediate gratification. So when trying to do something new, I just think of what would be the first piece of success that's achievable. And it's different in every case. If I had a more normal life, in more normal programming teams, I'd probably be totally into the current way of team programming. But for me, it's much more self-induced—even down to a question of my attention span. If I think I could get this working over the weekend, then that's the chunk I pick and that's the thing that I go flat out for, ignoring all the other things. It's hard for me to generalize this except to say, there's a place you want to get to, you pick a piece of it that would be gratifying and that would demonstrate that you're on the path and that you can fit into the time until you next get pulled off to do this at home or that at work.</p>
<p class="normal"><b>Seibel：</b>既然你选择了最终会产生某种令人满意的结果的东西，那就是你的第一个测试——验收测试：它会在屏幕上绘制一个窗口还是其他什么？更细粒度的测试呢？</p><p class="normal"><b>Seibel:</b> Since you've picked something that's going to have some kind of gratifying result at the end, that's your first test—an acceptance test: does it draw a window on the screen or whatever? What about finer-grained tests?</p>
<p class="normal"><b>英格尔斯：</b>如果这是您第一次能够拾起某物并将其拖过并放下，那么您需要有一个框架可以在那里工作。是否考虑了框架以便让其他人看到这些是测试？这是我通常不会做的事情。这可能只是我们这一代人的奢侈——如今没有人能逃脱惩罚。但我是个老屁，他们不会强迫我这么做的。但我认为潜在的感觉仍然是一样的。Squeak 代码过去充满了可执行的注释和要检查的内容。例如，在很多 BitBlt 测试中，有这些小东西会从屏幕上的一个地方拾取一些东西，对它做一些事情，然后放回去，如果你看到屏幕上有任何变化，它' 它工作不正常，评论也是这么说的。这是一个简单的测试。</p><p class="normal"><b>Ingalls:</b> If it's the first time you've made it possible to pick something up and drag it over and drop it down, there's a framework that you need to have working there. Is the framework factored so that someone else coming along will see that these are the tests? That's something that I have not typically done. This may just be the luxury of my generation—nobody would get away with that these days. But I'm an old fart and they're not going to make me do it. But I think the underlying feeling is still the same. The Squeak code used to be full of comments that are executable and things to check. For instance, in lots of the BitBlt tests, there are these little things that will pick something up from one place on the screen, do something to it, and put it back, and if you see anything change on the screen, it's not working right and the comment says so. That's a straightforward test.</p>
<p class="normal"><b>Seibel：</b>那么让我们谈谈与他人合作的问题。PARC 的学习研究小组听起来像是一个非常紧密的小组。您是如何在代码本身上进行协作的？</p><p class="normal"><b>Seibel:</b> So let's talk about working with others. The Learning Research Group at PARC sounded like a pretty close-knit group. How did you collaborate on the code itself?</p>
<p class="normal"><b>英格尔斯：</b>只是靠近。和偶尔的混乱。它从来都不是一个大团体，我们每个人都有自己的领域。有很多成长起来的团队编程专业知识，而我根本不了解它。现在，在 Lively Kernel 中，内核部分只有我和另一个人 Krzysztof Palacz。我们在某种程度上有自己的工作领域。我们<a id="OEBPS/Chapter10.html.page_395"></a>实际上现在确实在使用代码存储库，并且团队中还有其他人在做更多的应用程序工作和一些内核工作。我发现拥有一个可用的共享存储库是件好事——这太棒了。Lively Kernel 的下一步是将其与存储库集成——您可以更改 Lively Kernel 中的内容，但它只是那个正在运行的版本；它不会被推送到存储库并成为未来的一部分。这是我们下一步需要做的。</p><p class="normal"><b>Ingalls:</b> Just by being close. And occasional mayhem. It was never a big group and we each had our own areas. There's a lot of team programming expertise that's grown up and I'm not up on it at all. Right now, in the Lively Kernel, the kernel part has been just me and one other guy, Krzysztof Palacz. And we sort of have our separate areas that we work on. We <a></a>actually do use a code repository now, and there are other guys on the team who are doing more application stuff and a little bit in the kernel. And I see that it's nice having a shared repository that works—that's great. The next step for the Lively Kernel is to integrate it with the repository—you can change stuff in the Lively Kernel but it's only that running version; it doesn't get pushed out to the repository and become a part of the future. That's the next step we need to do.</p>
<p class="normal"><b>Seibel：</b>你做过结对编程吗？</p><p class="normal"><b>Seibel:</b> Have you ever done pair programming?</p>
<p class="normal"><b>Ingalls：</b>我正在努力想一些例子。通常我一直独自一人或在一个单独的部分工作。我与其他人合作过很多项目，还有许多紧张的结对调试会议。</p><p class="normal"><b>Ingalls:</b> I'm trying to think of examples. Usually I've been on my own or working on a separate part. There are lots of projects on which I've worked with others, and many intense pair debugging sessions.</p>
<p class="normal"><b>Seibel：</b>有没有管理这种协作的技术？当每个人都去各自做自己的工作时，总会有事情不太适合的可能性。</p><p class="normal"><b>Seibel:</b> Are there any techniques for managing that kind of collaboration? When everybody goes off to each do their own work, there's always the potential of things not quite fitting together.</p>
<p class="normal"><b>Ingalls：</b>要么你同意某个界面，要么我经常会构建一些不完整的框架，但它适用于一个示例，然后其他人很明显地知道他们的东西适合哪里。或者他们已经做到了，这对我来说很明显我的东西适合的地方。它通常以那种具体的方式，而不是任何一种规范，因为我们通常一直在研究没有人写下来的东西。一切都是为了满足当下的需要。</p><p class="normal"><b>Ingalls:</b> Either you agree on some interface, or often I'll build some framework that's incomplete but that works for one example and then it's obvious to someone else where their stuff would fit in. Or they've done that and it's obvious to me where my stuff fits in. It's usually been in that concrete way, rather than any kind of spec because we've usually been working on something that nobody wrote down. It's all kind of been following the needs of the moment.</p>
<p class="normal"><b>Seibel：</b>从 BitBlt 的位和编写微代码到 Smalltalk 中相当高级的东西，您从事过很多级别的工作。程序员需要对他们所处理的各种级别的软件和硬件了解多少？</p><p class="normal"><b>Seibel:</b> You've worked at a lot of levels from down in the bits of BitBlt and writing microcode up to fairly high-level stuff in Smalltalk. How much do programmers need to know about the various levels of software and hardware they're dealing with?</p>
<p class="normal"><b>英格尔斯：</b>这是个好问题。要跳出框框思考，您必须<i>稍微</i>跳出框框。如果有一些你在正常接触语言时看不到的东西可以利用，那么你必须有一些外在的直觉和对此的一些理解以及在控制它的系统中工作的能力.</p><p class="normal"><b>Ingalls:</b> That's a good question. To think outside the box, you've got to <i>be</i> a little outside the box. If there's something to be taken advantage of that you don't see in your normal exposure to a language, then you've got to have some intuition outside and some understanding of that and the ability to work in a system that has control over that.</p>
<p class="normal">在语言设计的背景下，也许你会想要使用现有的处理器，所以也许你不需要了解太多<a id="OEBPS/Chapter10.html.page_396"></a>关于它们，除了为了体面的性能，缓存的工作原理和诸如此类的东西。我认为你必须退后一步说，“这会跨越什么界限？”</p><p class="normal">In the context of language design, maybe you're going to want to work with the processors that are out there so maybe you don't need to know a lot <a></a>about them, other than, for decent performance, how caching works and that kind of stuff. I think you have to stand back and say, “What boundaries is this going to cross?”</p>
<p class="normal"><b>Seibel：</b>撇开你最终需要知道多少不谈，说到学习编程，有人说你应该从一门高级语言开始，学习一些通用的概念。其他人说您需要从组装开始，然后逐步提高，以便您了解发生了什么。你买那个吗？</p><p class="normal"><b>Seibel:</b> Leaving aside how much you need to know eventually, when it comes to learning to program, some people say you should start with a high-level language and learn certain universal concepts. Other people say you need to start with assembly and work your way up so you understand what's going on. Do you buy that?</p>
<p class="normal"><b>英格尔斯：</b>不，我不认为我一定会买那个。这就是我学习它的方式，我对它着迷。而且我认为总会有人对这个或那个层次着迷。但我不认为只有一种方法，就像做艺术只有一种方法一样。</p><p class="normal"><b>Ingalls:</b> No, I don't think I necessarily buy that. That's how I learned it and I was fascinated with it. And I think there will always be people who are fascinated with this level or that. But I don't think there's any one way, just like there's any one way to do art.</p>
<p class="normal">我认为还有其他同样令人兴奋且可能更适合当今的事物仍有待探索。主啊，我们在四分之一个世纪前就在考虑做人工智能。机器的速度快得无法估量，而我们在那个领域几乎什么都没做——我们做的仍然非常接近 Fortran。Prolog 已经存在很长时间了；有各种各样的事情可以用逻辑程序来完成。如果你应该学习组装并找出它是如何工作的，你应该沉浸在更跳出框框的东西中，这些东西确实是未来的一部分。</p><p class="normal">I think there are other things that are equally exciting and probably more appropriate nowadays still to be explored. Lord, we were thinking of doing artificial intelligence a quarter of a century ago. The machines are immeasurably faster and we're doing almost nothing in that space—we're still doing very close to Fortran. Prolog has been out there for a long time; there's all sorts of stuff that can be done with logic programs. If you ought to learn about assembly and find out how that works, you ought to be doing some immersion in things that are more outside the box and that are really a possible piece of the future.</p>
<p class="normal">所以我不是说“不是汇编语言”。我是说，你应该学习一些其他强大的技术，这样当你考虑如何前进时，你就可以利用它们。就起点而言，即时满足对我来说一直很管用。当我想教别人 Smalltalk 时，我通常会以一段对话开始：“你最感兴趣的是什么？您是否对如何玩文字、数字、音乐或图形感兴趣？” 从其中任何一个开始。</p><p class="normal">So I'm not saying, “not assembly language.” I'm saying, you should learn some of these other powerful techniques so when you think about how to go forward, you can take advantage of them. In terms of a place to start, immediate gratification has always worked for me. When I want to teach somebody Smalltalk, I usually start with a little dialog: “What interests you most? Are you interested in how to play with text or things you can do with numbers or things you can do with music, or things you can do with graphics?” And start with any one of those.</p>
<p class="normal">您可以将文本分开并组合在一起，做各种有趣的事情。您可以使用数字、不同的基数、浮点数和固定数来做各种有趣的事情。音乐也是如此：你可以从音符开始，然后将它们组合成旋律和和弦。以及图形：叠加和旋转。其中任何一个都是富人<a id="OEBPS/Chapter10.html.page_397"></a>探索的空间。我真的认为不同的人有不同的想法。同样，如果您要教某人编程计算机，您可能会学习表达式求值，也可能会学习逻辑编程。也许你在用户界面上做了一些事情。人们会在一个区域发光，那就是他们应该深入的地方。</p><p class="normal">There's all kinds of fun stuff you can do taking text apart and putting it together. There's all kinds of fun stuff you can do with numbers and different bases and floating-point and fixed. And the same thing with music: you can start with notes and put them together in melodies and chords. And with graphics: superpositions and rotations. Any one of those is a rich <a></a>space to explore. I really think different people think differently that way. Similarly, if you're going to teach somebody to program a computer, maybe you work with expression evaluation, maybe you work with logic programming. Maybe you do some stuff in user interface. People will light up in one area and that's where they should go deep.</p>
<p class="normal"><b>Seibel：</b>据我了解，Smalltalk 最初的目的是教授一种编程素养。这是每个人都应该拥有的东西，就像每个人都应该能够读写和做一点数学一样吗？每个人都应该有一定的计算机编程能力，仅仅因为它是一种有用的思维方式吗？</p><p class="normal"><b>Seibel:</b> As I understand it, the original purpose of Smalltalk was to teach a kind of programming literacy. Is that something everyone should have, just the way everyone is expected to be able to read and write and do a little bit of math? Should everyone have some ability to program a computer just because it's a useful way of thinking?</p>
<p class="normal"><b>Ingalls：</b>我很难说任何人都<i>应该</i>做任何事情，因为我遇到过我认为在这方面或那方面比我更好的人，他们对编程一无所知。就识字而言，下面的东西是逻辑和数学，是的，人们应该能够逻辑思考。但我从来没有说过有人应该知道如何编程，我不认为。我们在日常生活中会做一些事情，比如编程。您需要了解带有步骤的程序，诸如此类。</p><p class="normal"><b>Ingalls:</b> It's very hard for me to say that anyone <i>should</i> do anything, because I've met people that I think are better than me in this way or that way that know nothing about programming. In terms of literacy, the stuff that's under there is logic and math and yes, people should be able to think logically. But I'd never say that somebody should know how to program, I don't think. There's stuff we do in everyday life that's like programming. You need to know about procedures with steps, that kind of thing.</p>
<p class="normal">计算机融合了一些强大的想法，可以将一些强大的想法变为现实。计算机的美妙之处在于它们将数学带入了生活。所以他们可以成为一个很好的工具。现在，我对过上美好生活所必需的强大想法的感觉，不清楚这个领域有多少。</p><p class="normal">Computers incorporate some powerful ideas and can bring some powerful ideas to life. The wonderful thing about computers is they bring mathematics to life. So they can be a great tool that way. Now, my feeling about the powerful ideas that are necessary to lead a good life, it's not clear how many of them are in this space.</p>
<p class="normal"><b>Seibel：</b> Seymour Papert 在<i>Mindstorms</i>中写道，调试是智力工具包的一个重要元素——游戏的名称不是获得正确答案，而是获得<i>答案</i>然后对其进行调试。</p><p class="normal"><b>Seibel:</b> Seymour Papert wrote in <i>Mindstorms</i> about debugging as an important element of an intellectual toolkit—the idea that the name of the game is not to get the right answer but to get <i>an</i> answer and then debug it.</p>
<p class="normal"><b>英格尔斯：</b>哦，当然！人们应该学会清晰地思考和质疑。对我来说这是非常基本的。如果你在一个家庭中长大，当橱柜门没有关好时，有人打开它并查看铰链，发现一个螺丝松了，所以它就这样挂着，而不是如果他们说，“哦，门不能正常工作；打电话给某人”—那里是有区别的。对我来说，你不需要任何与计算机的接触就能体验到你所看到的是不对的，你会怎么做？查询。看。然后如果你看到问题，你如何解决它？对我来说，这是非常基本和人性化的，而且从父母那里传给了孩子。<a id="OEBPS/Chapter10.html.page_398"></a>计算机当然是这样做的媒介。但他们只是电脑。有很多东西会转移，但对我来说，它真的很大，很基础，很人性化，所以我们不会仅仅通过教他们计算机来启发世界。</p><p class="normal"><b>Ingalls:</b> Oh, absolutely! People should learn to think clearly and to question. And to me it's very basic. If you grow up in a family where when the cupboard door doesn't close right, somebody opens it up and looks at the hinge and sees that a screw is loose and therefore it's hanging this way vs. if they say, “Oh, the door doesn't work right; call somebody”—there's a difference there. To me you don't need any involvement with computers to have that experience of what you see isn't right, what do you do? Inquire. Look. And then if you see the problem, how do you fix it? To me that's so basic and human and comes so much from parent to child. <a></a>Computers are certainly a medium for doing that. But they're just computers. There's a lot of that that will transfer, but to me it's really big and basic and human, so it's not like we're going to enlighten the world just by teaching them computers.</p>
<p class="normal"><b>Seibel：</b>您还记得您编写的第一个有趣的程序吗？</p><p class="normal"><b>Seibel:</b> Do you remember the first interesting program you wrote?</p>
<p class="normal"><b>英格尔斯：</b>哦，让我们看看。在每一次编程经历中，都有一些开箱即用的东西。当我发现 VisiCalc 时，我编写了一个电子表格以在 VisiCalc 中将英语翻译成 pig Latin。对我来说，这很有趣，因为它使用电子表格隐喻作为并行编程方法。以这种方式解析文本既有趣又富有启发性。</p><p class="normal"><b>Ingalls:</b> Oh, let's see. In each programming experience, there was something that was out of the box. When I discovered VisiCalc, I wrote a spreadsheet to translate English to pig Latin in VisiCalc. That was, to me, interesting, because it used the spreadsheet metaphor as a parallel programming approach. Parsing text that way was fun and enlightening.</p>
<p class="normal"><b>Seibel：</b>所以 VisiCalc 有分解字符串的原语？</p><p class="normal"><b>Seibel:</b> So VisiCalc had primitives for taking apart strings?</p>
<p class="normal"><b>Ingalls：</b>是的，你可以拆开琴弦。也许我实际上拥有的是 Lotus 1-2-3，而不是 VisiCalc，因为我不确定 VisiCalc 是否具有字符串原语。我得到了一台小型 Poqet PC——它是第一台真正的手持式 PC。它在两个笔灯上运行，我在上面放了 1-2-3，然后我坐飞机飞越了全国，我想，“这段时间我能做什么？”</p><p class="normal"><b>Ingalls:</b> Yeah, you could take apart strings. Maybe what I actually had was Lotus 1-2-3, not VisiCalc, because I'm not sure that VisiCalc had string primitives. I got one of those little Poqet PCs—it was the first truly handheld PC. It ran on two penlights, and I put 1-2-3 on it, and I had a plane flight across the country and I thought, “What can I do in this time?”</p>
<p class="normal"><b>Seibel：</b>在你学会编程之后一定很好，因为你刚开始的时候显然没有 Poqet PC。</p><p class="normal"><b>Seibel:</b> That must've been well after you learned to program, because there obviously weren't Poqet PCs when you were starting out.</p>
<p class="normal"><b>英格尔斯：</b>那是后来的事情。我在 Fortran 中做的真正有趣的事情是我得到了 Val Schorre 关于 META II 的论文——这是一个很棒的、非常简单的编译器编译器，并用 Fortran 编写了它的实现。所以突然之间，这意味着您可以在纯 Fortran 环境中使用其他语言。那是我在 Fortran 中做的最有趣的事情，因为它使用 Fortran 来逃离 Fortran 的世界。</p><p class="normal"><b>Ingalls:</b> That was later on. The really interesting thing that I did in Fortran was I got a hold of Val Schorre's paper on META II—just a wonderful, really simple compiler compiler and wrote an implementation of that in Fortran. So all of a sudden this meant you could have other languages in a Fortran-only environment. That was the most interesting thing I did in Fortran, because it used Fortran to escape from the world of Fortran.</p>
<p class="normal"><b>Seibel：</b>这似乎是一个主题：pig-Latin 电子表格，然后是这个，以及用于您的分析器的 COBOL 哈希表——你们中是否有一部分人只是喜欢逆势而行？</p><p class="normal"><b>Seibel:</b> That seems to be a bit of a theme: the pig-Latin spreadsheet, then this, and a hash table in COBOL for your profiler—is there a part of you that just likes cutting against the grain?</p>
<p class="normal"><b>Ingalls：</b>我不觉得它有违常理，但每当我有一个计算环境可以使用时，我都喜欢在其中尝试新事物。这就是我开发 Smalltalk 系统的乐趣所在。你几乎是从头开始，你的工作是弄清楚要组装什么<a id="OEBPS/Chapter10.html.page_399"></a>并首先开始工作，这将帮助您进行下一步并从那里开始构建东西。</p><p class="normal"><b>Ingalls:</b> I don't feel like it's against the grain, but whenever I have a computing environment to play with, I like to try new things in it. That's what's been so much fun about doing the Smalltalk systems I did. You start from pretty much scratch and your job is to figure out what to assemble <a></a>and get working first that will help you to do the next step and build stuff up from there.</p>
<p class="normal">在这些情况下，这是一个跳出框框的问题。这是一种断言你已经掌握了这件事的方式——如果你能做一些你认为自己在其中做不到的事情。</p><p class="normal">In these cases, it was a matter of getting outside the box. That's a way of asserting that you've mastered the thing—if you can do some things that you wouldn't have thought you could do in it.</p>
<p class="normal"><b>Seibel：</b>你能指出你现在对编程的看法有什么重大变化吗？</p><p class="normal"><b>Seibel:</b> Can you identify any big changes in the way you think about programming now?</p>
<p class="normal"><b>英格尔斯：</b>这是个好问题。一件事是我们有很多计算机周期要花费。所以我现在很舒服，正如贬义的说法所说，惹恼周期以干净利落地完成某件事。但基本的事情对我来说根本没有改变，就是试图弄清楚我必须使用的内核是什么，以及我想要实现的目标。</p><p class="normal"><b>Ingalls:</b> That's a good question. One thing is we've got lots of computer cycles to spend. So I'm comfortable now, as the pejorative saying goes, pissing away cycles to get something done cleanly. But the basic thing hasn't changed for me at all, which is trying to get clear about what the kernel or kernels are that I have to work with and the goal that I'm trying to achieve.</p>
<p class="normal">它发生了一点变化，因为我不再是我工作的团队中的量子力学。我处于更高的水平——这只是意味着我在目标和政治上花费的时间比我多一点在代码上。它更多地与创建上下文有关。直到我生命的后期阶段，我一直很幸运能够处于一个现有的环境中，而我不必去创造它。但时不时地，我还是会静下心来认真写代码。</p><p class="normal">It's changed a little bit in that I'm no longer the quantum mechanic in the group that I work in. I'm more at a higher level—that just means that I'm spending a little bit more time on goals and politics than on code. It's got more to do with creating a context. Until this later phase of my life, I've been lucky to be in an existing context where I didn't have to create it. But every once in a while I still get down and write serious code.</p>
<p class="normal"><b>Seibel：</b>我在看你 70 年代的一篇关于 Fortran 分析器的论文。在序言中，您非常热衷于该工具如何改变您的编程，从弄清楚您将要编写的内容，编写它并调试它，到弄清楚您将要编写的内容，编写一个非常简单的版本，对其进行分析，然后优化它。你还这样工作吗？</p><p class="normal"><b>Seibel:</b> I was looking at one of your papers from the '70s about your Fortran profiler. In the preamble you were very enthusiastic about how that tool changed your programming from figuring out what you were going to write, writing it, and debugging it, to figuring out what you were going to write, writing a really simple version, profiling it, then optimizing it. Do you still work that way?</p>
<p class="normal"><b>Ingalls：</b>我肯定会首先考虑效果，屏幕上的位或其他任何东西，因为这太有动力了，而且你经常通过有机会瞥见它的发展方向来学习一些关于你想做的事情的新东西。</p><p class="normal"><b>Ingalls:</b> I definitely go for effects first, bits on the screen or whatever it is, because that's so motivating, and you often learn something new about what you had wanted to do just by getting a chance to glimpse where it's going.</p>
<p class="normal">然后，如果需要分析，则进行分析。或者结果可能是你没有做正确的事——那不是你想做的，所以你改变了目标，或者你改变了你做事的方式。但是当涉及性能问题时，我仍然以相同的方式操作。我们在 Smalltalk 中做了一个非常好的分析器，然后是 Squeak，这给了你很好的反馈。<a id="OEBPS/Chapter10.html.page_400"></a>其中一部分与性能有关，而另一部分与结构和体系结构有关。您可能会发现有些东西几乎从未使用过，也许您可​​以通过不同的方式来摆脱它们。这只是对事物的不同看法。</p><p class="normal">Then if profiling is what's needed, you profile. Or it may turn out you weren't doing the right thing—that wasn't quite what you wanted to do, so you changed the goals, or you change how you're doing it. But when it's a matter of performance, I still operate the same way. We did a really nice profiler in Smalltalk, and then Squeak, that gave you good feedback that way. <a></a>Part of that is about performance but part of it is about just structure and architecture. You may find that some things are hardly ever used and maybe you could just get rid of them by doing things differently. It's just a different perspective on the thing.</p>
<p class="normal"><b>Seibel：</b>似乎几乎每个程序员都有一本 Knuth 的<i>《计算机编程艺术》</i>。有些人拥有它，它就在他们的架子上。有些人拥有它并将其用作参考。有些人拥有它并且真的从头到尾阅读了它。您实际上在斯坦福大学与 Knuth 一起学习；你读了多少？</p><p class="normal"><b>Seibel:</b> It seems that virtually every programmer has a copy of Knuth's <i>The Art of Computer Programming</i>. Some people have it and it's just on their shelf. Some people have it and use it as a reference. And some people have it and really read it cover-to-cover. You actually studied with Knuth at Stanford; how much of it have you read?</p>
<p class="normal"><b>Ingalls：</b>我喜欢和 Don 一起工作，我也在斯坦福大学教了他一个季度的 MIX 课程，这也很有启发性。我认为我与 Don 很不一样，但我喜欢他的地方在于他拥有出色的数学头脑，但也喜欢深入细节——事物的实用部分。我也喜欢从务实的方面入手，但我不像 Don 那样严谨。</p><p class="normal"><b>Ingalls:</b> I loved working with Don and I taught his MIX course for one quarter at Stanford, too, which was also enlightening. I think I'm pretty different from Don, but what I like about him is he's got a great mathematical mind but also loves to go deep into the bits—the pragmatic parts of things. I, too, love to get into the pragmatic side of things but I'm not as rigorous as Don.</p>
<p class="normal">我接受过物理学方面的培训，对我来说，我所处理的问题，或者我如何处理这些问题，实际上更像是一种物理问题。当我谈论程序的其他观点时，我真的在想那里有一个东西，你可以触摸它并感觉到它在振动。</p><p class="normal">I was trained in physics and to me the problems I work on, or how I work on them, is really much more a physical thing. When I'm talking about other perspectives on programs, I'm really thinking that there's a thing there that you can touch and feel it vibrate.</p>
<p class="normal">如果你看看他在 TeX 上的工作方式，那是非常数学化的，而且漂亮优雅。将其与第一个 Smalltalk 引擎进行比较：它们非常特别。我只是把需要的东西放在一起。可能是在几轮之后，我开始得到它的某种数学图像，或者我们做到了，但在这方面是不同的。</p><p class="normal">If you take the way he worked on TeX, it was very mathematical and beautiful and elegant. Compare that with, say, the first Smalltalk engines: they were very ad hoc. I just put together what was needed. It may be that after a few go-rounds, I started to get some sort of mathematical picture of it, or we did, but it's different in that regard.</p>
<p class="normal">所以事实是，我读了很多他的基本数据结构的东西，但我不是一个大读者——我是一个实干家。如果我有缺陷，那就是我经常自己做 X、Y 或 Z，而不是阅读文献并了解它。我认为这通常对我有利，但谁知道呢？</p><p class="normal">So the truth is, I read a fair amount of his basic data structures stuff, but I'm not a big reader—I'm very much of a doer. If I have a flaw, it's that I will often do my own of X, Y, or Z rather than reading the literature and knowing about it. It's usually worked to my advantage I think, but who knows?</p>
<p class="normal"><b>Seibel：</b>你认为程序员需要知道多少数学知识？Dijkstra 声称计算机科学只是数学的一个分支。理解<i>计算机编程的艺术</i>需要相当多的数学知识。</p><p class="normal"><b>Seibel:</b> How much math do you think programmers need to know? Dijkstra claimed that computer science is just a branch of mathematics. And understanding <i>The Art of Computer Programming</i> requires a fair bit of math.</p>
<p class="normal"><a id="OEBPS/Chapter10.html.page_401"></a><b>Ingalls：</b>你必须有逻辑思维。但是我在弗吉尼亚州的乡村学习计算机的时间很长。我一直认为，如果我想在弗吉尼亚山区开一家电脑公司，我会去找机械师。除了某些相当深奥的部分，数学并不像逻辑和直觉那么重要。</p><p class="normal"><a></a><b>Ingalls:</b> You've got to have a logical mind. But I spent a lot of time in the country in Virginia while learning about computers. I always thought that if I wanted to start a computer company in the mountains of Virginia, I'd go find the mechanics. Except in certain fairly esoteric parts, the math isn't near as important as logic and intuition.</p>
<p class="normal">我认为其中很多都更具建筑性：图形与模型一起工作的方式；事物需要更新或缓存的方式。那不是深奥的数学。也就是说，我确实认为它是数学领域的重要组成部分。对我来说，计算机真正令人兴奋的事情是它们让数学成为一种综合性的艺术，而不仅仅是一种分析艺术。我每天做的非常有趣的事情是一种数学的事情，但它是创造性的、生成的、综合的。</p><p class="normal">I think of a lot of it as being more architectural: the way the graphics work together with the models; the way things need to be updated or cached. That's not esoteric mathematics. That said, I do view it as being very much a part of the field of mathematics. To me, the really exciting thing about computers is they allowed mathematics to become a synthetic, not just an analytic art. What I have so much fun doing day to day is a mathematical kind of thing, but it's creative, generative, synthetic.</p>
<p class="normal"><b>Seibel：</b>你说你不是一个大读者。有什么书可以推荐吗？</p><p class="normal"><b>Seibel:</b> You say you're not a big reader. Are there any books you'd recommend?</p>
<p class="normal"><b>Ingalls：</b>没有。而且我确信我属于这种方式的少数。我小时候不是一个大读者。我偶尔会通读一遍，直到读完才被打扰。肯定有一些论文，我猜还有一些书。Val Schorre 关于 META II 的论文就是其中之一。有 LISP 1.5 书。有 APL，但我觉得 Iverson 的书根本不是学习它的好方法。一个数学家可能会有。我什至不记得我读过什么来了解它。但我喜欢它。所以我认为花一点时间在那种语言上就像读一本书一样。同样，Smalltalk。</p><p class="normal"><b>Ingalls:</b> No. And I'm sure I'm in the minority this way. I was not a big reader as a kid. I would occasionally read things thoroughly and not be interrupted until I was done. There are some papers, absolutely, and I guess with them come some books. Val Schorre's paper on META II is one of them. There is the LISP 1.5 book. There's APL, but I didn't find Iverson's book to be at all a good way to learn it. A mathematician probably would have. I can't even remember what I read to learn about it from. But I loved it. So I think spending a bit of time in that language would be like a book to read. Likewise, Smalltalk.</p>
<p class="normal"><b>Seibel：</b>那么您是否仍然像刚开始时那样喜欢编程？</p><p class="normal"><b>Seibel:</b> So do you still enjoy programming as much as you used to when you started?</p>
<p class="normal"><b>Ingalls：</b>是的，编程本身。过去的几年很有趣，因为我已经离开了我已经习惯的环境——Smalltalk，然后是 Squeak——那里的工具真的很棒。我不得不退后一步，在浏览器和传统开发环境中使用 JavaScript。有时我调试东西的时间比以前要长，但我仍然非常喜欢获得想法并实现它的基本过程。</p><p class="normal"><b>Ingalls:</b> Yeah, the programming itself. The last couple of years have been interesting because I've been taken away from the environment that I got so used to—Smalltalk and then Squeak—where the tools are just really great. I've had to step back a little bit, working with JavaScript in browsers and conventional development environments. It sometimes takes me longer to debug stuff than it used to, but the basic process of getting an idea and making it happen I still really enjoy.</p>
<p class="normal"><b>Seibel：</b>你觉得编程是年轻人的游戏吗？</p><p class="normal"><b>Seibel:</b> Do you feel at all that programming is a young person's game?</p>
<p class="normal"><a id="OEBPS/Chapter10.html.page_402"></a><b>英格尔斯：</b>不完全是，不。能够审视所有正在发生的事情，以及我觉得自己不像以前那样拥有无穷无尽的能量，这让人感觉很不错。但我仍然喜欢只是解决一个问题，然后坐下来仔细研究它，直到它是正确的。这里有一个类比：我很晚才尝试学习弹钢琴。人们说：“哦，你应该趁年轻学习。你学得真快。” 虽然我没走多远，但我的结论是，并不是年轻人学得那么快；而是年轻人学得更快。只是他们有更多的时间。当我投入时间时，我取得了进步。</p><p class="normal"><a></a><b>Ingalls:</b> Not really, no. There's something about being able to survey all the stuff that's going on, and some of that endless energy that I don't feel I have the way I used to. But I still love to just take a problem and sit down and pore over it until it's right. There's an analogy here: I tried to learn to play piano fairly late in life. People said, “Oh, you should learn when you're young. You learn so much quicker.” Although I didn't go very far, my conclusion was that it isn't that young people learn that much faster; it's just they have more time. When I would put time in, I made progress.</p>
<p class="normal">我对编程的感觉有点相同。当我回顾我早年的生活时，我拥有了我想要的所有时间。我只会工作和工作。现在我的生活中发生了其他事情，我的责任不仅仅是编程。这破坏了那种强烈的关注。</p><p class="normal">I feel a bit the same thing with programming. When I look back on earlier times in my life, I had all the time I wanted. I would just work and work. Now there are other things going on in my life and I've got responsibilities that aren't just programming. That undermines a bit of that intense focus.</p>
<p class="normal"><b>Seibel：</b>撇开你花在这上面的时间不谈，编程不需要一定的强度和专注吗？人们谈论心流，以及如果你每 15 分钟就被打扰一次，你将永远无法完成任何事情，因为甚至开始整理大脑中的东西都需要那么长时间。</p><p class="normal"><b>Seibel:</b> Leaving aside the amount of time you get to spend on it, doesn't programming require a certain intensity and focus? People talk about flow and how if you get interrupted every 15 minutes, you never get anything done because it takes that long to even start getting the stuff in your brain sorted out.</p>
<p class="normal"><b>Ingalls：</b>这让我想起了我在 PARC 时对某人说过的话。除了破解 Smalltalk 之外，我开始承担一些其他职责，但我们也在使它成为一个真正高效的系统方面取得了很大进展。我开玩笑说我正在努力改进 Smalltalk 环境，这样我就可以在越来越短的时间内继续完成合理的工作。所以我在 15 分钟内到达了可以坐下来实际做一些有用的事情的地方。</p><p class="normal"><b>Ingalls:</b> That reminds me of something I said to somebody way back at PARC. I was starting to have some other responsibilities besides just hacking Smalltalk, but we were also making a lot of progress in making it a really productive system. I kidded that I was racing to improve the Smalltalk environment so that I could continue to get reasonable work done in increasingly short amounts of time. So I'd gotten to where in 15 minutes I could sit down and actually do something useful.</p>
<p class="normal">另一部分是你与其他人一起工作。我和年轻人一起工作，这很棒——也许我会花更多的时间在目标和政治层面上思考，并安排让事情发生，他们正在弥补我在深入、深入潜水方面缺乏的可用时间.</p><p class="normal">The other part of it is that you work with other people. I work with younger people and it's great—maybe I spend a bit more time thinking at the level of goals and politics and arranging to make things happen, and they're making up for what I lack in available time for that deep, deep dive.</p>
<p class="normal"><b>Seibel：</b>当你领导一个项目时，你会成为一个值得为之工作的好人。您如何领导一个使人们富有成效和快乐的团队？</p><p class="normal"><b>Seibel:</b> You have a reputation of being a great guy to work for, when you're leading a project. How do you lead a team that makes people productive and happy?</p>
<p class="normal"><b>英格尔斯：</b>我热爱我的工作。与其他人分享很有趣。这些活动可以深入或广泛，因此很容易找到适合的东西<a id="OEBPS/Chapter10.html.page_403"></a>不同的人一起工作。我一直很喜欢和别人一起做。有时效果会好些，有些时候效果不好——这种工作有非常不同的阶段。有时您会看到所有需要做的事情，而这只是让人们去做的问题。还有其他时候，您并不真正知道需要做什么，而您正试图找出答案。这些真的是不同的阶段。</p><p class="normal"><b>Ingalls:</b> I love what I do. And it's fun to share with other people. These activities can go arbitrarily deep or wide, so it's easy to find things for <a></a>various people to work on. I've just always enjoyed doing that with other people. There have been times when it's worked better or not—there are very different phases to this kind of work. There are times when you see everything that needs to be done and it's just a matter of getting people to do it. And there are other times when you don't really know what needs to be done and you're trying to find out. Those are really different phases.</p>
<p class="normal"><b>Seibel：</b>关于如何成为一名优秀的技术领导者，您有什么建议吗？</p><p class="normal"><b>Seibel:</b> Do you have any tips on how to be a good technical leader?</p>
<p class="normal"><b>Ingalls：</b>首先要清楚你想做什么。工作是获得清晰的视野。如果你去过那里，你就能真正看到你将如何实施它，这样你就可以开始了解这将如何根据不同的人可以做什么以及它们如何组合在一起来实现。</p><p class="normal"><b>Ingalls:</b> The first thing is being clear about what you're trying to do. The job is to get a clear vision. If you've been around, you can see actually how you're going to implement that, so you can start to see how that would work out in terms of what various people can do and how it would all fit together.</p>
<p class="normal">曾经有几次我一直在做一个我可以看到一切的项目。这感觉真的很强大，因为无论何时有人遇到困难，我都可以立即告诉他们下一步是什么，或者如何绕过它。如果你知道自己要去哪里，人们也会有这种感觉。他们可以立即感觉到一切都在那里——他明白了。这也赋予了团队力量。</p><p class="normal">There have been times when I've been working on a project where I could see everything. It felt really powerful because whenever anybody was stuck I could tell them immediately what the next step was, or how to get around it. And people feel that, too, if you know where you're headed. They can immediately sense it's all there—he's got it. And that's empowering for the team as well.</p>
<p class="normal"><b>Seibel：</b>对你想要的东西有太清晰的认识是否会<i>削弱</i>人们的能力——既然你脑子里什么都有，他们就没有什么有趣的事可做了？</p><p class="normal"><b>Seibel:</b> Does having too clear a picture of what you want ever <i>disempower</i> people—since you've got everything in your head, there's nothing fun for them to do?</p>
<p class="normal"><b>Ingalls：</b>好吧，你可以让它保持开放，他们如何做他们的工作，你可能只在需要的时候介入微观管理。通常事情会变得更好。我很幸运能与一群我信任的人一起工作很长时间。信任是其中的一部分，信任与您一起工作的人。另一件事就是信心。当画面清晰时，就很容易对它充满信心。我认为造成糟糕的微观管理的是你担心和没有安全感，所以你觉得你必须把所有事情都搞定。</p><p class="normal"><b>Ingalls:</b> Well, you can leave it open how they do their part of it and you maybe only step in with micromanagement where it's needed. And often things turn out better. I was lucky to work with a great crew of people for a long time whom I trusted. Trust is part of it, trust for the people that you're working with. The other thing is just confidence. When the picture's clear, it's easy to be confident about it. I think the kind of thing that makes for bad micromanagement is you're worried and you're insecure, and so you're feeling like you have to nail everything down.</p>
<p class="normal"><b>Seibel：</b>当你还是一名工蜂时，你有过真正伟大的团队领导吗？</p><p class="normal"><b>Seibel:</b> Have you ever had a really great team leader when you were a worker bee?</p>
<p class="normal"><a id="OEBPS/Chapter10.html.page_404"></a><b>英格尔斯：</b>我生命中最好的老板是艾伦·凯。我在 Xerox 在他手下工作了几年，这是一个非常有趣的组合，因为他知道自己想要什么，但他几乎从不告诉我应该如何做事。但他在技术上精通所有这些，所以他是一个很好的评论家。我和和我一起工作的人真的很有效率，所以我认为他觉得自己有足够的进步，所以他不需要太多干预。他为我，为我们制作了一把雨伞，他真的很清楚自己想做什么。</p><p class="normal"><a></a><b>Ingalls:</b> The best boss in my life has been Alan Kay. I worked under him at Xerox for some very formative years, and that was an interesting combination, because he knew what he wanted but he hardly ever said how I should do things. But he was technically savvy about all of it so he was a good critic. I and the guys who came to work with me were really productive so I think he felt enough progress that he didn't have to interfere much. He made an umbrella for me, for us, and he really had a picture of what he wanted to do.</p>
<p class="normal"><b>Seibel：</b>当人们在一个团队中工作时，编码人员每个人都拥有一个系统是不是更好？“这是我的代码，没有人碰它”与团队拥有代码，任何人都可以碰任何东西。</p><p class="normal"><b>Seibel:</b> When folks are working in a group, is it better for coders to each own a piece of a system? Where “This is my code and no one touches it” vs. the team owns the code and anybody can touch anything.</p>
<p class="normal"><b>英格尔斯：</b>我不知道。我们现在在 Lively Kernel 项目上的工作方式是不同的人有不同的工作领域，但没有任何界限。这更多的是专业知识、重点或目标的问题。我正在努力思考这些看起来非常成功的时期，以及它们是如何运作的。我从来没有在大团队工作过，所以通常人们几乎只在一段代码上工作。</p><p class="normal"><b>Ingalls:</b> I don't know. The way we work now on the Lively Kernel project is different people have different areas they work on, but there aren't any fences. It's more a matter of expertise, or focus, or goals. I'm trying to think of these periods that seemed really successful, how that worked. I've never worked in big teams, so it's generally been that people pretty much worked solely on a piece of code.</p>
<p class="normal"><b>Seibel：</b>另一个话题，调试：你不得不追踪的最严重的错误是什么？</p><p class="normal"><b>Seibel:</b> Another topic, debugging: what's the worst bug you've ever had to track down?</p>
<p class="normal"><b>Ingalls：</b>这是一个垃圾收集错误。垃圾收集是最糟糕的事情，因为问题的表现是在原因来来去去很久之后才出现的。能够追踪到这样一个不起眼的错误让我想到了破解代码。我父亲在战略服务办公室工作，他们以团队合作，他们所做的很多事情只是收集信息，只是试图掌握事情的进展。然后一个代码会和他们在报纸上看到的东西的片段一起进来，然后他们会把它们放在一起。</p><p class="normal"><b>Ingalls:</b> It was a garbage-collection bug. Garbage collection is the worst thing because the manifestation of the problem is long after the cause has come and gone. Being able to track down an obscure bug like that makes me think of breaking codes. My father was in the Office of Strategic Services, and they worked in teams, and a lot of what they did was just gathering information, just trying to be up on things. Then a code would come in with a fragment of something they had seen in a newspaper and they would put it together that way.</p>
<p class="normal">这与能够追踪到这一点是一回事。我带来的只是对在这些情况下会发生什么的所有这些直觉。这个特别的，我在里面至少呆了一天。当我终于完成它时，我很高兴，我当时四岁的儿子给我颁发了“坚定的调试者奖”。</p><p class="normal">It was the same thing with being able to track this down. What I brought to it was just having all this intuition of what can cause what to happen in these situations. This particular one, I was in it deep down for at least a day. When I finally got it done, I was elated, and my son, who was, I think, four at the time, made me a “Determined Debugger Award.”</p>
<p class="normal"><a id="OEBPS/Chapter10.html.page_405"></a><b>Seibel：</b>我想这是在 Smalltalk 中。您是否有可以使用的符号调试器，或者您正在查看内存的十六进制转储？</p><p class="normal"><a></a><b>Seibel:</b> This was in Smalltalk, I assume. Did you have a symbolic debugger that you could use, or were you looking at hex dumps of memory?</p>
<p class="normal"><b>Ingalls：</b>这比漂亮的 Smalltalk 调试器级别低。我真的不能告诉你这件事的细节，但那种事情是你在某处遇到错误，这实际上会把你带到低级调试器。所以你把内存看成一堆八进制位置。然后你会发现一个对象以不应该的方式指向另一个对象。所以你在想，“这怎么可能发生？” 你有所有这些小线索和小模式，这可能导致那个，这可能导致那个，所以你试图找出它们。</p><p class="normal"><b>Ingalls:</b> This was lower level than the nice Smalltalk debugger. I really can't tell you the details of this one, but the kind of thing is you get an error somewhere, which would actually take you to the low-level debuggers. So you're looking at memory like a bunch of octal locations. Then you find things like one object pointing into another object in the way it shouldn't. So you're trying to think of, “How could that happen?” You have all these little clues and little patterns of this can cause that, this can cause that, and so then you try to figure them out.</p>
<p class="normal"><b>Seibel：</b>所以这是一个非常低的水平。当您在良好的 Smalltalk 环境中进行开发时，我假设您使用符号调试器。你有没有求助于打印报表？</p><p class="normal"><b>Seibel:</b> So that was at a very low level. When you're developing in the nice Smalltalk environment, I assume you use symbolic debuggers. Do you ever resort to print statements?</p>
<p class="normal"><b>Ingalls：</b>我不知道有谁会这样做，如果他们可以选择使用一个好的调试器的话。因为你把<code>print</code>声明放在哪里？你把它放在<i>那里</i>。好吧，难道你不想呆在<i>那里</i>，看看所有的东西，而不是打印出来吗？现在我进行了大量的打印语句式调试，因为通常情况下我没有足够好的 JavaScript 调试器。</p><p class="normal"><b>Ingalls:</b> I don't know of anybody who does that if they have the choice of using a good debugger. Because where do you put the <code>print</code> statement? You put it <i>there</i>. Well, wouldn't you just like to <i>be</i> there, looking at everything, instead of just printing it? Now I do a fair amount of print statement–style debugging because it's often the case I don't have a good enough JavaScript debugger.</p>
<p class="normal"><b>Seibel：</b>是什么让 Smalltalk 调试器如此出色？</p><p class="normal"><b>Seibel:</b> What made the Smalltalk debugger so nice?</p>
<p class="normal"><b>Ingalls：</b>好吧，您可以在程序的任何地方停下来，您实际上可以查看所有变量的所有绑定。您可以在上下文中间执行片段、计算表达式。</p><p class="normal"><b>Ingalls:</b> Well, you could stop anywhere in the program and you could actually look at all the bindings of all the variables. You could execute fragments, evaluate expressions right in the middle of the context.</p>
<p class="normal"><b>Seibel：</b>在栈帧中的任何特定点？</p><p class="normal"><b>Seibel:</b> At any particular point in the stack frame?</p>
<p class="normal"><b>Ingalls：</b>是的，你可以做出重大改变然后继续。你可能会遇到一个错误，将它显示在屏幕上，保存系统的整个状态，将它发送给使用 Windows 机器而不是 Mac 的其他人，他们可以启动相同的图像，在你的位置是，进行修复，然后继续。因此，只需在不同的机器表示中完整保存状态即可。</p><p class="normal"><b>Ingalls:</b> Yep, and you could make significant changes and then proceed. And you could get to an error, have it on the screen, save the entire state of the system, ship it to somebody else who was on a Windows machine and not a Mac, and they could fire up that same image, be where you were, make a fix, and proceed. So just complete preservation of state across different machine representations.</p>
<p class="normal"><a id="OEBPS/Chapter10.html.page_406"></a><b>Seibel：</b>不变量是另一种调试工具。有些人非常重视正式的前提条件，以及他们所有方法和类不变量的后置条件，而有些人对他们如何思考事物更加特别。你怎么看他们？</p><p class="normal"><a></a><b>Seibel:</b> Invariants are another sort of debugging tool. Some people are very big on formal preconditions, and postconditions on all their methods and class invariants, and some people are more ad hoc about how they think about things. How do you think about them?</p>
<p class="normal"><b>Ingalls：</b>我可能会参加不太正式的阵营。主要是出于让事情尽可能绝对简单的原始感觉。我对类型有同样的感觉。类型本质上是关于程序的断言。而且我认为让事情尽可能绝对简单是有价值的，包括甚至不说类型是什么。我认为当你对一个系统越来越认真时，能够添加所有这些东西是很好的，并且有一些方法可以吃蛋糕和吃它，例如推断类型并且不必看到它们，除非你想见他们。</p><p class="normal"><b>Ingalls:</b> I'd probably go in the less formal camp. Mainly out of that original feeling of having things be as absolutely simple as possible. I feel the same kinds of things about types. Types are essentially assertions about a program. And I think it's valuable to have things be as absolutely simple as possible, including not even saying what the types are. I think as you get more serious about a system, it's nice to be able to add all that stuff, and there are ways of having your cake and eating it, too, such as inferring the types and not having to see them except when you want to see them.</p>
<p class="normal">类型只是范围中的一件事，包括单位和您可以放在其中的各种其他断言。这是我们必须用这种综合数学探索的迷人领域的一部分。我认为我们越来越多地可以利用计算领域并越来越多地使用实时文档、真正的编程文档来记录它们，所以那里有断言真的可以帮助你，你通常看不到，但如果你被卡住了，你可以开始将它们带进来并测试有关它的各种事情。</p><p class="normal">And types are only one thing in a spectrum that includes units and all sorts of other assertions you can put on there. That's part of the fascinating area we have to explore with this synthetic mathematics. I think increasingly we can take areas of computation and document them more and more with living documentation, real programming documentation, so there are assertions there that really help you that you don't usually see, but if you're stuck, you can start to bring them in and test various things about it.</p>
<p class="normal"><b>Seibel：</b>您对正式证明程序正确有任何看法吗？</p><p class="normal"><b>Seibel:</b> Do you have an opinion one way or the other on formally proving programs correct?</p>
<p class="normal"><b>Ingalls：</b>这从来都不是我的职业。我倾向于专注于使对事物做出断言更容易的架构部分。所以如果你被允许在一个程序中做各种危险的事情，那么当你坐下来做正式证明时，就会非常困难，因为在每一步你都必须说，“好吧，这可能发生，那可能发生，那可能发生。” 如果架构是干净的，那么通过阅读代码，形式证明几乎是显而易见的。你会说，“好吧，这只能来自那里。我们很安全。”</p><p class="normal"><b>Ingalls:</b> It's never been an occupation of mine. I'm inclined to focus on the architectural part that makes it easier to make assertions about things. So if you are allowed to do all sorts of dangerous things in a program, then when you sit down to do the formal proof, it's very hard because at every step you've got to say, “Well, this could happen, that could happen, that could happen.” If the architecture is clean, then the formal proof may almost be obvious just by reading the code. You'll say, “Well, this could only come from there. We're safe.”</p>
<p class="normal"><b>Seibel：</b>你用过 C++ 吗？</p><p class="normal"><b>Seibel:</b> Have you ever used C++?</p>
<p class="normal"><b>英格尔斯：</b>不。也不是 C。</p><p class="normal"><b>Ingalls:</b> No. Nor C.</p>
<p class="normal"><a id="OEBPS/Chapter10.html.page_407"></a><b>Seibel：</b>但是你做过 BCPL 和汇编，所以你并不是从未使用过低级语言。</p><p class="normal"><a></a><b>Seibel:</b> But you did BCPL and assembly, so it's not like you've never used low-level languages.</p>
<p class="normal"><b>英格尔斯：</b>对。我实际上已经做了一些 C 来调试 Squeak 生成的东西。但我记得当我们制作 Squeak 时，我的部分目的是拥有一个你真正可以掌握的系统，<i>除了</i>Squeak 什么都不需要知道。所以我的目标是永远不学那个。John Maloney 做了从 Squeak 到 C 的翻译，以便给我们一个实际的实现。事实是，我会进去查看 C 代码，但我几乎可以确定您不需要执行任何这些操作。</p><p class="normal"><b>Ingalls:</b> Right. And I actually have done some C to debug things generated by Squeak. But I remember when we did Squeak, part of my purpose was to have a system that you really could be master of without having to know anything <i>but</i> Squeak. So I made it my purpose to not ever learn that. John Maloney did the translator from Squeak to C in order to give us a practical implementation. The truth is, I would go in and look at that C code but I pretty much made sure that you didn't need to do any of that.</p>
<p class="normal"><b>Seibel：</b>当 C++ 出现时，您一定看过它，因为您是这个群体的一员——也许 Simula 的人除外——可以最好地声称已经发明了面向对象的编程。</p><p class="normal"><b>Seibel:</b> You must've looked at C++ when it came out, as you were part of the group that—other than perhaps the Simula folks—can best claim to have invented object-oriented programming.</p>
<p class="normal"><b>英格尔斯：</b>我并没有那么投入。这似乎是从 C 以各种方式向前迈出的一步，但它似乎还不是我们已经在体验的承诺。如果我被迫进行另一个自下而上的实现，而不是使用机器代码，我可能会从 C++ 开始。我认识几个精通 C++ 的人，我喜欢看他们是如何做事的，因为我认为他们不依赖它来做它并不擅长的事情，而是完全将它用作几乎一种元编程语言.</p><p class="normal"><b>Ingalls:</b> I didn't get that much into it. It seemed like a step forward in various ways from C, but it seemed to be not yet what the promise was, which we were already experiencing. If I had been forced to do another bottom-up implementation, instead of using machine code I would've maybe started with C++. And I know a couple of people who are masters of C++ and I love to see how they do things because I think they don't rely on it for the stuff that it's not really that good at but totally use it as almost a metaprogramming language.</p>
<p class="normal"><b>Seibel：</b>让我们谈谈代码阅读。你如何进入一段新的代码？</p><p class="normal"><b>Seibel:</b> Let's talk about code reading. How do you get into a new piece of code?</p>
<p class="normal"><b>Ingalls：</b>我很难抽象地回答。你开始知道它做什么或应该做什么。我想我几乎是自上而下的——我只是试图理解这些部分是什么以及它们是如何协同工作的。查看定义了哪些类和方法以及它们在做什么。然后，这取决于我们为什么要寻找。它可能只是一些新事物，我们想了解它。可能是它表现不佳，然后您对其进行分析并查看。</p><p class="normal"><b>Ingalls:</b> It's hard for me to answer in the abstract. You start out knowing what it does or is supposed to do. I guess I go at it pretty much top-down—I just try to understand what the pieces are and how they work together. See what classes and methods are defined and what they're doing. Then it depends on why we're looking. It could be it's just something new and we want to find out about it. It could be that it's performing badly and then you do a profile of it and look at that.</p>
<p class="normal"><b>Seibel：</b>我们之前谈到过 Knuth。他的另一个爱好是文学编程。您是否编写过文学代码或阅读过任何代码？</p><p class="normal"><b>Seibel:</b> We talked about Knuth before. His other passion is literate programming. Have you ever written literate code or read any?</p>
<p class="normal"><a id="OEBPS/Chapter10.html.page_408"></a><b>英格尔斯：</b>我喜欢以这种方式处理我有时间完成的事情。当我第一次写东西时，没有评论。一旦我开始工作，我会写一些评论。如果我喜欢我所做的或者看起来很难理解，我会写更多的评论。但我不相信把评论放在一切旁边。而且我觉得一种语言越好，你就越不需要评论。您使用合理的变量名称。这就是为什么我喜欢 Smalltalk 中的关键字参数。它确实使事情变得非常可读。您可以在 JavaScript 的不同地方执行这个奇妙的小 hack。它有点贵，但是 JavaScript 有这个大括号对象表示法，因此您可以使用关键字，它们实际上看起来像 Smalltalk 关键字，因为它们以冒号结尾，因此您可以将多个参数放在大括号表达式中。它实际上制作了漂亮的程序。</p><p class="normal"><a></a><b>Ingalls:</b> I like to work that way with something where I've got the time to finish it off. When I first write stuff, there are no comments. As soon as I have it working, I'll write some comments. And if I like what I've done or it seems like it would be hard to figure out, I'll write more comments. But I don't believe in putting comments beside everything. And I kind of feel like the better a language is, the less you need comments. You use reasonable variable names. That's why I liked the keyword parameters in Smalltalk. It really makes things pretty readable. There's this wonderful little hack that you can do in various places in JavaScript. It's a little bit expensive, but JavaScript has this curly bracket object notation, and so you can use keywords and they actually looks like Smalltalk keywords because they end with colons, so you can have your multiple arguments be in a curly brace expression. It actually makes nice-looking programs.</p>
<p class="normal"><b>塞贝尔：</b>嗯。这既美丽又令人作呕。</p><p class="normal"><b>Seibel:</b> Hmmm. That's kind of beautiful and disgusting at the same time.</p>
<p class="normal"><b>英格尔斯：</b>是的，没错。</p><p class="normal"><b>Ingalls:</b> Yeah, right.</p>
<p class="normal"><b>Seibel：</b>你说服过其他人采用这种风格吗？</p><p class="normal"><b>Seibel:</b> Have you convinced anyone else to adopt that style?</p>
<p class="normal"><b>Ingalls：</b>事实是，在我自己想到之前，我发现有人在这样做。</p><p class="normal"><b>Ingalls:</b> The truth is I found somebody else doing that before I thought of it myself.</p>
<p class="normal"><b>Seibel：</b>你认为自己是科学家、工程师、艺术家还是工匠？</p><p class="normal"><b>Seibel:</b> Do you consider yourself a scientist, an engineer, an artist, or a craftsman?</p>
<p class="normal"><b>英格尔斯：</b>真的，所有这些。我认为我作为物理学家的教育对我有好处。其中很多只与查看身体问题等问题有关，试图隔离身体上的力。这与您用来查看系统中正在使用的东西的所有方式以及它如何受到影响的方式相同。这是我对真正具有空间性的东西的一种非常物理的感觉——事物如何协同工作以及可能不同的事物如何相同以及如何构建更好的架构。</p><p class="normal"><b>Ingalls:</b> Really, all of those. I think my education as a physicist was good for me. A lot of that just has to do with looking at problems like physical problems, trying to isolate the forces on a body. It's the same kind of thing you use for looking at what all the ways are that something's being used in the system, how it could be affected. And it's a very physical feeling I have about stuff that's also really spatial—how things work together and how things that might be different could be the same and how that would make a better architecture.</p>
<p class="normal">我记得我不得不进行的关于 Smalltalk 的早期演讲之一；我说，“我们这个小组所做的就像科学方法，就是你进行观察，提出一个理论来解释它，然后你进行实验来验证它。” 这正是我们在<a id="OEBPS/Chapter10.html.page_409"></a>连续几代的 Smalltalk。我们有一个关于如何使某事发挥作用的理论。我们建立了一个以这种方式工作的系统。我们使用了一段时间后发现，“哦，如果我们以不同的方式来做这个、这个和这个就好了，”于是我们构建了一个新的。所以我们一直绕着那个圈子转，这就像科学研究和进步一样。</p><p class="normal">I remember one of the early talks I had to give about Smalltalk; I said, “What we do in this group is like the scientific method, which is you make an observation, you come up with a theory to explain it, and you perform an experiment to verify it.” And that's very much what we did in the <a></a>successive generations of Smalltalk. We had a theory for how to make something work. We built a system that worked that way. We used it for a while and we found out, “Oh, it'd be good if we did this and this and this differently,” and we built a new one. So we kept going around that circle, which is just like scientific research and progress.</p>
<p class="normal">当我工作时，我觉得自己像个艺术家，因为我脑子里有这个想法，我只想让它成为现实。我想象一位雕塑家有同样的感受，将一件作品赋予生命。</p><p class="normal">I feel like an artist when I'm working because I have this idea in my head and I just want to make it real. I imagine a sculptor having the same feeling, bringing a piece to life.</p>
<p class="normal">在这种情况下，我认为工程师和工匠几乎是一样的。只不过工程师是一个技术领域的工匠。有时我也有这种感觉，但它们是不同的时间——一个非常不同的时间。这是我在做一些低级的事情的时候。从我的历史来看，我从事过 BitBlt 或 Smalltalk 字节码引擎的最深入部分，这些都是非常像工匠的东西。而且我有幸重新做几次，使它们真正正确，这是一门手艺。</p><p class="normal">In this context, I view engineer and craftsman as being almost identical. It's just that an engineer is a craftsman in a technological field. There are times when I feel that way, too, but they are different times—a very different time. It's when I'm doing something low-level. From my history, I worked on the deepest parts of BitBlt or the Smalltalk byte-code engine and those are very craftsman-like things. And I had the luxury to do those over again a couple of times to get them really right and that's a craft.</p>
<p class="normal"><b>Seibel：</b>我认为工程师和工匠之间的区别在于，工程师会说：“我们应该像建造桥梁的人一样。桥梁不会倒塌。他们有一个可重复的工程过程。” 工匠们说：“这更像是木工。木材每次都是独一无二的，有经验法则，但没有方法可以保证一定的结果。”</p><p class="normal"><b>Seibel:</b> The difference I see between engineers and craftsmen is the engineers are the folks who say, “We should be like the guys who build bridges. Bridges don't fall down. They have a repeatable engineering process.” The craftsmen say, “This is more like woodworking. The wood is unique every time and there are rules of thumb but no method that can guarantee certain results.”</p>
<p class="normal"><b>Ingalls：</b>所以在这方面我可能不太像工程师。我认为我强调系统的方式是不同的。我知道有些人在做严肃的企业编程系统。那不是我的重点或热情。在你提到的四个人中，工程师可能是最少的，其次是工匠，然后是艺术家和科学家之间有趣的组合。</p><p class="normal"><b>Ingalls:</b> So in that regard I may be less of an engineer. I think that the ways in which I stress systems are different. I know there are people who do serious enterprise programming systems. That's not a focus or a passion of mine. Of the four you mentioned, the engineer is probably the least, then craftsman, and then this funny combination between artist and scientist at the top.</p>
<p class="normal"><b>Seibel：</b>你提到你离开这个行业一段时间然后又回来了。您是否厌倦了计算机，或者只是生活中的其他事情？</p><p class="normal"><b>Seibel:</b> You mentioned that you left industry for a while and then you came back. Were you tired of computers or was it just other things in life?</p>
<p class="normal"><b>英格尔斯：</b>这是我生活中的其他事情。这也是一次不错的休息，我选择了一个很好的时间，因为当我回来的时候，在我看来事情并没有发生太大的变化，只是一切都快了一百倍。</p><p class="normal"><b>Ingalls:</b> It was other things in my life. It was also a nice break, and I picked a good time for it, because when I came back, it didn't seem to me like things had changed that much, except everything was a hundred times faster.</p>
<p class="normal"><a id="OEBPS/Chapter10.html.page_410"></a><b>Seibel：</b>对于想成为程序员的人，你有什么建议吗？</p><p class="normal"><a></a><b>Seibel:</b> Do you have any recommendations for people who want to be programmers?</p>
<p class="normal"><b>Ingalls：</b>嗯，我认为计算机科学方面的一门像样的课程应该不错。我的组织方式是学习几种具有不同优势的不同语言。Smalltalk 有很多优势，但它不是万能的。有逻辑编程。有函数式编程。实际上，您可以以函数式风格来实现 Smalltalk，因此那里已经涵盖了很多内容。但是就像我说的关于 Lotus 1-2-3 和将英语翻译成猪拉丁语一样，我认为值得采用几种不同的计算环境，然后在其中选择一个问题来解决，这要么揭示语言的力量，要么鼓励你以某种方式逃避它。</p><p class="normal"><b>Ingalls:</b> Well, I think a decent course in computer science should be good. The way I would organize that is to learn several different languages that have various different strengths. Smalltalk's got a lot of strengths but it's not the answer to everything. There's logic programming. There's functional programming. Actually, you can do Smalltalk in a functional style, and so that's covered there pretty much. But like what I said about Lotus 1-2-3 and translating English to pig Latin, I think it's worth it to take several different computing environments and then pick a problem to solve in them, which either reveals the strength of the language or encourages you to somehow escape from it.</p>
<p class="normal"><b>Seibel：</b>你认为编程——以及那些能够成为成功程序员的人——已经改变了吗？如果不学习汇编或 C，甚至不学习从阅读 Knuth 中获得的算法，你能成为一个在某个高级水平上工作的优秀程序员吗，因为现在你使用的是一些高级语言，其中包含很多库中的那些算法？</p><p class="normal"><b>Seibel:</b> Do you think programming—and therefore the kind of people who can succeed as programmers—has changed? Can you be a great programmer operating at a certain high level without ever learning assembly, or C, and maybe without ever learning the algorithms you would get from reading Knuth, because these days you're using some high-level language that includes a lot of those algorithms in libraries?</p>
<p class="normal"><b>Ingalls：</b>不同的人有不同的层次，他们需要达到不同的层次才能对自己的工作感到满意。所以我认为有人可以完全自信地使用集合库，而无需自己编程。这只是意味着他们在另一个层面上运作。上帝知道，我不认为任何打算使用图形的人都必须编写 BitBlt。您不必做与非门；你可以使用汇编语言。我认为您可以在这些级别中的任何一个级别工作。如果挑战要求你这样做，你将不得不更深入，如果你的兴趣被激发，你将想要更深入。</p><p class="normal"><b>Ingalls:</b> Different people have different levels that they need to go to to feel good about what they're working with. So I think somebody can be entirely confident maybe using a collections library without having programmed it themselves. It just means they're operating at another level. Lord knows, I wouldn't expect anybody who intends to work with graphics to have had to write BitBlt. You don't have to do NAND gates; you can use assembly language. I think you can work at any of these levels. If the challenge calls on you for it, you're going to have to go deeper, and if your interest is sparked, you will want to go deeper.</p>
<p class="normal"><b>Seibel：</b>那么您认为今天大多数可能在不同环境中工作的水平相当高的程序员会学习汇编和微码吗？还是您认为人们成为成功的程序员所需要的那种才能正在发生变化？</p><p class="normal"><b>Seibel:</b> So do you think most programmers today, who may be working at a fairly high level, in a different environment would have learned assembly and microcode? Or do you think the kind of talents that people need to be successful programmers are changing?</p>
<p class="normal"><b>英格尔斯：</b>是的，也不是。在某种程度上，它在任何级别上下都是一样的，希望它会显得更加如此。但也有正确的地方<a id="OEBPS/Chapter10.html.page_411"></a>现在我认为有更多的地方根据公式和其他领域处理更原始的事情。</p><p class="normal"><b>Ingalls:</b> Yes and no. It is in a way the same up and down at any level and hopefully it will come to appear even more so. But there are areas right <a></a>now where I think there's more putting together according to formula and other areas where there's dealing with things that are much more primitive.</p>
<p class="normal">我是一名物理学家；我有数学家朋友，我觉得自己和他们的大脑完全不同。但我们都做了好事。我认为计算机也会出现这种情况。我认为，从事程序验证工作的人与从事图形系统工作的人不同。因此，人们会发现自己的优势以及他们想要工作的地方和他们不喜欢工作的地方。我认为这里有一些先天和后天的影响，而且永远都会有。</p><p class="normal">I was a physicist; I had mathematician friends and I did not feel like I was at all the same kind of brain as they were. But we both did good things. I think that's going to be the case in computers, too. The people who are working on program provers are different from the people who are working on graphics systems, I think. And so people are going to find their strengths and the place they want to work and the place that they're not comfortable working. I think there's some nature as well as nurture going on here, and there always will be.</p>
<p class="normal">可能这些系统中的某些系统具有足够的级别和部分，以至于给定的人可能主要在一种领域而不是另一种领域工作时感到舒适和高效，但我认为它们都是一样的。有逻辑思维，也有结构思维。还有人类的东西和创造力。一个特定的人从他们的天性和他们的养育中得到了特定的混合，对我来说，它并没有太大改变。人们正在尝试做可能更大、更好的事情，但在我看来，它们仍然几乎相同。</p><p class="normal">It may be that some of these systems have enough levels and parts to them that a given person may be mainly comfortable and productive working in one kind of area rather than another, but I think it's all the same stuff. There's logical thought and there's structural thought. And there's human stuff and creativity. A given person has a given mix of that from their nature and their nurture, and to me, it hasn't changed much. People are trying to do presumably bigger, better stuff, but it seems to me to still be pretty much the same.</p>
<p class="normal"><b>Seibel：</b>与此相关，随着越来越多的领域以越来越多的临时方式依赖计算，有些人想要为“非程序员”找到一种编程方式。你认为这会发生吗，或者领域专家，比如生物学家，总是需要与程序员合作来构建定制软件来解决他们的问题？</p><p class="normal"><b>Seibel:</b> Related to that, as more and more fields rely on computing in more and more ad hoc ways, there are folks who want to find a way for “nonprogrammers” to program. Do you think that'll happen, or will domain experts, say biologists, always have to team up with programmers to build custom software to solve their problems?</p>
<p class="normal"><b>Ingalls：</b>我认为会有这种合作，因为生物学家对编程不感兴趣。他有兴趣找出这个或那个。然后有人了解这些东西是如何在计算机上工作的，可以帮助他做到这一点。我认为让非程序员编程的是应用程序。</p><p class="normal"><b>Ingalls:</b> I think there will be that kind of collaboration because the biologist isn't interested in programming it. He's interested in finding out this or that. Then there's somebody who understands how this stuff is being worked on on the computers who can help him do that. I think the thing that lets a nonprogrammer program is an application.</p>
<p class="normal"><b>Seibel：</b>我参与了一个项目，该项目试图为生物学家提供一个编程环境，理论上他们需要的软件总是临时的。你无法构建一个应用程序并完成它，因为生物学家并不真正知道他们需要什么，直到他们开始研究一些生物学数据并说，“我真正想要的是什么<a id="OEBPS/Chapter10.html.page_412"></a>知道是 X，”从该数据中提取 X 的唯一方法本质上是编写程序。</p><p class="normal"><b>Seibel:</b> I worked on a project that tried to provide a programming environment for biologists on the theory that the software they would need would always be ad hoc. You couldn't build an application and be done with it because the biologists didn't really know what they needed until they got down to some piece of biological data and said, “What I really want to <a></a>know is X,” and the only way to extract X from that data was, essentially, to write a program.</p>
<p class="normal"><b>Ingalls：</b>是的，如果我们可以拥有一些计算环境，其中包含您的所有信息，那么您就可以通过其自我揭示的性质以某种方式弄清楚如何获取所有信息，那就太好了。但我认为有些人会对此感兴趣，有些人不会。</p><p class="normal"><b>Ingalls:</b> Yeah, it would be nice if we could have some computing environment with all your information in it so you could somehow figure out how to get to it all just by its self-revealing nature. But I think that there are people who are going to be interested in that and people who aren't.</p>
<p class="normal"><b>Seibel：</b>有没有什么我没有问过但你认为我可能会问的？</p><p class="normal"><b>Seibel:</b> Is there anything I haven't asked about that you thought I might?</p>
<p class="normal"><b>Ingalls：</b>通常，阅读有关名人的文章时，我感兴趣的一面是，他们如何让自己的生活发挥作用？所有不是他们热衷的事情，他们是如何处理的，他们是如何处理的，他们的家人，他们的财务状况，以及如何平衡这些。或者他们只是躲起来说，“让其他一切都见鬼去吧，”然后让它崩溃，直到他们完成他们的工作？</p><p class="normal"><b>Ingalls:</b> Often, reading about famous people, the side of it that I'm interested in is, how do they make their life work? All the things that weren't their passion, and how did they deal with that, and with their family, and with their finances, and balancing that. Or did they just hole up and say, “To hell with everything else,” and let it just come crumbling down until they had their work done?</p>
<p class="normal"><b>Seibel：</b>您是否觉得在您的生活中有时您对编程的热情失控而损害了您生活的其他部分？</p><p class="normal"><b>Seibel:</b> Do you feel like there were times in your life where your passion for programming ran amok to the detriment of other parts of your life?</p>
<p class="normal"><b>英格尔斯：</b>是的，有时候对别人来说很难，因为我很专注并且需要保持专注。对于任何对自己所做的事情充满热情的人来说，这都是一种风险。我想要么你学会稍微缓和它，要么你做的另一件事就是传达它，这样你周围的每个人都知道你正在处理这件事，你可能会在一周内完成，但在那之前爸爸有点难以接近.</p><p class="normal"><b>Ingalls:</b> Yeah, there are times when it's been hard on others because I'm focused and need to stay focused. It's a risk with anybody who's got a passion for what they're doing. I think either you learn to moderate it somewhat or the other thing you do is communicate it so that everybody around you knows that you're dealing with this thing, and you'll probably be done in a week, but until then Daddy's somewhat inaccessible.</p>
<p class="normal"><b>Seibel：</b>然后你赢得了“坚定的调试者爸爸”奖。</p><p class="normal"><b>Seibel:</b> And then you win your “Dad the Determined Debugger” award.</p>
<p class="normal"><b>英格尔斯：</b>没错；正确的。另外就是，你越能把进步带来的满足感反馈给那段时间所有和你打交道的人，至少他们有一种爸爸做的好事的感觉，到时候我们都会很高兴。完毕。</p><p class="normal"><b>Ingalls:</b> Exactly; right. The other thing is, the more you can reflect the satisfaction from progress back out to all the people who have dealt with you during that time, at least they have a sense that Daddy's doing something good, and we'll all be happy when it's done.</p>
</div>
</div></div>
<div id="OEBPS/Chapter11.html"><div>

<div class="booksection">
<p></p>
<h2 class="chapnum"><a id="OEBPS/Chapter11.html.ch11"></a><a id="OEBPS/Chapter11.html.page_413"></a><img src="data:image/jpg;base64,/9j/4AAQSkZJRgABAgEASABIAAD/7Qy2UGhvdG9zaG9wIDMuMAA4QklNA+0KUmVzb2x1dGlvbgAAAAAQAEgAAAABAAEASAAAAAEAAThCSU0EDRhGWCBHbG9iYWwgTGlnaHRpbmcgQW5nbGUAAAAABAAAAHg4QklNBBkSRlggR2xvYmFsIEFsdGl0dWRlAAAAAAQAAAAeOEJJTQPzC1ByaW50IEZsYWdzAAAACQAAAAAAAAAAAQA4QklNBAoOQ29weXJpZ2h0IEZsYWcAAAAAAQAAOEJJTScQFEphcGFuZXNlIFByaW50IEZsYWdzAAAAAAoAAQAAAAAAAAACOEJJTQP1F0NvbG9yIEhhbGZ0b25lIFNldHRpbmdzAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+BdDb2xvciBUcmFuc2ZlciBTZXR0aW5ncwAAAHAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAOEJJTQQAC0xheWVyIFN0YXRlAAAAAgABOEJJTQQCDExheWVyIEdyb3VwcwAAAAAEAAAAADhCSU0ECAZHdWlkZXMAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4NVVJMIG92ZXJyaWRlcwAAAAQAAAAAOEJJTQQaBlNsaWNlcwAAAAB1AAAABgAAAAAAAAAAAAAAlAAAANMAAAAKAFUAbgB0AGkAdABsAGUAZAAtADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAANMAAACUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhCSU0EERFJQ0MgVW50YWdnZWQgRmxhZwAAAAEBADhCSU0EFBdMYXllciBJRCBHZW5lcmF0b3IgQmFzZQAAAAQAAAACOEJJTQQMFU5ldyBXaW5kb3dzIFRodW1ibmFpbAAACNkAAAABAAAAcAAAAE8AAAFQAABnsAAACL0AGAAB/9j/4AAQSkZJRgABAgEASABI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" alt="图片"></h2><h2 class="chapnum"><a></a><a></a></h2>
<h2 class="chaptitle">彼得德意志</h2><h2 class="chaptitle">L Peter Deutsch</h2>
<div class="sidebar">
<p class="normal"><i>L Peter Deutsch 是一个神童，他在 50 年代后期开始编程，当时他 11 岁，当时他的父亲带回了一份关于哈佛大学剑桥电子加速器设计计算编程的备忘录。他很快就在麻省理工学院闲逛，在 PDP-1 上实现 Lisp，并破解和改进麻省理工学院黑客编写的代码，这些代码的年龄几乎是他的两倍。</i></p><p class="normal"><i>A prodigy, L Peter Deutsch started programming in the late '50s, at age 11, when his father brought home a memo about the programming of design calculations for the Cambridge Electron Accelerator at Harvard. He was soon hanging out at MIT, implementing Lisp on a PDP-1, and hacking on and improving code written by MIT hackers nearly twice his age.</i></p>
<p class="normal"><i>作为加州大学伯克利分校的二年级学生，他参与了 Project Genie，这是最早的基于小型计算机的分时系统之一，编写了该操作系统的大部分内核。（Ken Thompson，Unix 的发明者和<a href="#OEBPS/Chapter12.html.ch12">第 12 章</a>的主题，在伯克利读研究生时也参与了这个项目，影响了他后来在 Unix 上的工作。）在参与了 Project Genie 系统商业化的失败尝试后，Deutsch 搬到了到 Xerox PARC，在那里他从事 Interlisp 系统和 Smalltalk 虚拟机的工作，帮助发明了即时编译技术。</i></p><p class="normal"><i>As a sophomore at UC Berkeley, he got involved with Project Genie, one of the first minicomputer-based timesharing systems, writing most of the operating system's kernel. (Ken Thompson, inventor of Unix and the subject of <a href="#OEBPS/Chapter12.html.ch12">Chapter 12</a>, would also work on the project while a grad student at Berkeley, influencing his later work on Unix.) After participating in a failed attempt to commercialize the Project Genie system, Deutsch moved to Xerox PARC, where he worked on the Interlisp system and on the Smalltalk virtual machine, helping to invent the technique of just-in-time compilation.</i></p>
<p class="normal"><i>他曾在 PARC 的衍生公司 ParcPlace 担任首席科学家，并且是 Sun Microsystems 的研究员，在那里他提出了现在著名的“分布式计算的七大谬误”。他还是 Postscript 查看器 Ghostscript 的作者。1992 年，他是获得计算协会奖的小组成员之一<a id="OEBPS/Chapter11.html.page_414"></a>Machinery Software System Award, for their work on Interlisp, and in 1994 he was elected a Fellow of the ACM.</i></p><p class="normal"><i>He served as Chief Scientist at the PARC spin-off, ParcPlace, and was a Fellow at Sun Microsystems, where he put to paper the now famous “Seven Fallacies of Distributed Computing.” He is also the author of Ghostscript, the Postscript viewer. In 1992, he was part of the group that received the Association for Computing <a></a>Machinery Software System Award, for their work on Interlisp, and in 1994 he was elected a Fellow of the ACM.</i></p>
<p class="normal"><i>2002 年，Deutsch 辞去了 Ghostscript 的工作，转而学习作曲。现在他更可能是在创作新的音乐作品而不是新的程序，但仍然无法抗拒不时破解的冲动，主要是在他自己设计的乐谱编辑器上。</i></p><p class="normal"><i>In 2002 Deutsch quit work on Ghostscript in order to study musical composition. Today he is more likely to be working on a new musical composition than on a new program, but still can't resist the urge to hack every now and then, mostly on a musical score editor of his own devising.</i></p>
<p class="normal"><i>我们在谈话中涉及的主题包括他看到的任何计算机语言的深层问题，包括指针或引用的概念，为什么软件应该被视为资本资产而不是费用，以及为什么他最终从专业退休编程。</i></p><p class="normal"><i>Among the topics we covered in our conversation were the deep problems he sees with any computer language that includes the notion of a pointer or a reference, why software should be treated as a capital asset rather than an expense, and why he ultimately retired from professional programming.</i></p>
</div>
<p class="normal"><b>Seibel：</b>你是如何开始编程的？</p><p class="normal"><b>Seibel:</b> How did you start programming?</p>
<p class="normal"><b>Deutsch：</b>我 11 岁时偶然开始编程。我父亲从当时正在建造的 Cambridge Electron Accelerator 带回了一些备忘录。有一个小组进行设计计算，他们的一些备忘录无意中找到了他。我看到它躺在他的办公室周围，里面有一些计算机代码，其中有些东西引起了我的想象。</p><p class="normal"><b>Deutsch:</b> I started programming by accident when I was 11. My dad brought home some memo from the Cambridge Electron Accelerator, which was being built at the time. There was a group that did design computations and some memo of theirs accidentally found its way to him. I saw it lying around his office and it had some computer code in it and there was something about it that caught my imagination.</p>
<p class="normal">事实证明，这份备忘录实际上是另一份备忘录的附录，所以我问他是否可以拿到原始备忘录。他把它带回家，我说，“哎呀，这东西真的很有趣。” 我想我可能真的问过他我是否可以见见写备忘录的人。我们见过面。我真的不记得细节了——那是 50 年前的事了。我以某种方式为剑桥电子加速器的设计计算之一编写了一些代码。我就是这样开始的。</p><p class="normal">It turned out the memo was actually an addendum to another memo so I asked him if he could lay his hands on the original memo. He brought that home and I said, “Gee, this stuff is really interesting.” I think I might actually have asked him if I could meet the guy who had written the memos. We met. I don't really remember the details any more—this was 50 years ago. Somehow I got to write a little bit of code for one of the design calculations for the Cambridge Electron Accelerator. That's how I got started.</p>
<p class="normal"><b>Seibel：</b>那是你十一岁的时候。到 14 或 15 岁时，你在麻省理工学院玩 PDP-1，你父亲是那里的教授。</p><p class="normal"><b>Seibel:</b> So that was when you were eleven. By 14 or 15 you were playing on the PDP-1s at MIT, where your dad was a professor.</p>
<p class="normal"><b>Deutsch：</b>在我 14 岁的时候，我找到了通往 TX-0 的道路，此后不久又转向了 PDP-1。我记得拿到了一份 Lisp 1.5 程序员手册。我不记得如何。这是一个非常早期的版本——实际上是油印的——旧的紫色墨水。有东西<a id="OEBPS/Chapter11.html.page_415"></a>关于 Lisp 引起了我的想象。我一直有一种数学倾向，而 Lisp 似乎有点酷。我想有一个玩，但我无法得到 Building 26 大型机。所以我在 PDP-1 上实现了 Lisp。</p><p class="normal"><b>Deutsch:</b> When I was 14, I found my way to the TX-0 and to the PDP-1 shortly thereafter. I remember getting a hold of a copy of the Lisp 1.5 programmers' manual. I don't remember how. It was a very early version—it was actually mimeographed—the old purple ink. There was something <a></a>about Lisp that caught my imagination. I've always had a kind of mathematical bent, and Lisp just seemed sort of cool. I wanted to have one to play with and I couldn't get my hands on the Building 26 mainframe. So I did my Lisp implementation on the PDP-1.</p>
<p class="normal"><b>Seibel：</b>你还记得你是如何设计 PDP-1 Lisp 的吗？</p><p class="normal"><b>Seibel:</b> Do you remember at all how you designed your PDP-1 Lisp?</p>
<p class="normal"><b>Deutsch：</b>我笑了，因为程序太小了。你看过清单吗？它只有几百行汇编程序。</p><p class="normal"><b>Deutsch:</b> I'm smiling because the program was so small. Have you seen the listing? It's only a few hundred lines of assembler.</p>
<p class="normal"><b>Seibel：</b>我见过；我没有试图去理解它。难道只是把1.5手册里的东西音译成汇编的问题吗？</p><p class="normal"><b>Seibel:</b> I've seen it; I didn't try to understand it. Was it just a matter of transliterating the thing in the 1.5 manual into assembly?</p>
<p class="normal"><b>德语：</b>不，不，不。1.5 手册中只有解释器。我必须编写一个阅读器和分词器，我必须设计数据结构和所有这些东西。我的回忆是，我是按照我实际完成大部分编程的方式来做的，即首先做数据结构。当我还年轻的时候，我的直觉会给我指明正确的方向——我不会说绝对正确，但足够接近——那是一个非常好的方法。</p><p class="normal"><b>Deutsch:</b> No, no, no. All that was in the 1.5 manual was the interpreter. I had to write a reader and tokenizer and I had to design the data structures and all that stuff. My recollection was that I did that the way I actually have done most of my programming, which is to do the data structures first. When I was young enough that my intuition would point me in the right direction—I won't say infallibly, but close enough—that was a really good approach.</p>
<p class="normal">在过去的几年里，我注意到我变得生疏了——我的直觉不再那么灵敏了。几年来，我一直在断断续续地做一个重要的项目，以做一个好的开源乐谱编辑器。几年来我一直在断断续续地摆弄它，我发现让我的直觉引导我找到正确的数据结构，然后从那里写出所有东西已经行不通了。</p><p class="normal">In the last couple of years I've noticed that I've gotten rusty—my intuition doesn't work so well anymore. I've been doing a substantial project off and on for several years now to do a good open-source music score editor. I've been fiddling with that off and on for several years now and I find that letting my intuition steer me to the right data structures and then just writing everything out from there just doesn't work anymore.</p>
<p class="normal"><b>Seibel：</b>你认为你的直觉实际上更糟，还是你曾经有更多的耐力让它发挥作用，即使你的直觉实际上有点偏离？</p><p class="normal"><b>Seibel:</b> Do you think your intuition is actually worse or did you used to have more stamina for making it work even if your intuition was actually a bit off?</p>
<p class="normal"><b>Deutsch：</b>我认为两者都有，但我认为更多的是前者。我认为直觉实际上是一种从大量数据中综合出解决方案的无意识过程。随着我越来越远离沉浸在软件的东西中，进入该综合的数据变得越来越难以访问。</p><p class="normal"><b>Deutsch:</b> I think it's some of each but I think it's more the former. I think what intuition is, really, is an unconscious process for synthesizing a solution out of a large amount of data. And as I've gotten further and further away from being immersed in the stuff of software, the data that goes into that synthesis has become less and less accessible.</p>
<p class="normal"><a id="OEBPS/Chapter11.html.page_416"></a>我听说要成为某事的大师，您必须掌握 20,000 个具体案例，几乎完全听命于您。发生的事情是，在我 45 年的行业生涯中，从我面前经过的 20,000 个特定的软件设计案例正逐渐变得越来越难以访问，就像记忆一样。我认为这就是正在发生的事情。</p><p class="normal"><a></a>I've heard it said that to be a master at something you have to have, pretty much at your command, something like 20,000 specific cases. What's happened is the 20,000 specific cases of software design that passed in front of my face in my 45 years in the industry are just gradually becoming less and less accessible, the way memories do. I think that's pretty much what's going on.</p>
<p class="normal"><b>Seibel：</b>你还记得吸引你的是什么编程吗？</p><p class="normal"><b>Seibel:</b> Do you remember what it was about programming that drew you in?</p>
<p class="normal"><b>Deutsch：</b>凭借 50 年的后见之明，我发现我一直被指示性符号系统——语言所吸引。不仅是话语语言——人类语言——还有话语在其中产生影响的语言。编程语言当然属于这一类。</p><p class="normal"><b>Deutsch:</b> With the benefit of 50 years of hindsight, I can see that I have always been drawn to systems of denotative symbols—languages. Not only languages of discourse—human languages—but languages in which utterances have effects. Programming languages certainly fall right into that category.</p>
<p class="normal">我想这也与为什么我转行从事音乐创作有关。音乐是一种语言，或者是一个语言家族，但是你用这些语言说的话可能不仅具有外延，而且还对人们产生影响。音乐有点有趣，因为在形式上它介于自然语言和计算机语言之间。它比自然语言更正式和结构化，但几乎没有计算机语言的结构或形式。我认为，这可能与我进入音乐而不是诗歌的原因有关。我认为诗歌对我来说不够结构化。</p><p class="normal">I think that also has something to do with why the career that I've switched into is musical composition. Music is a language, or a family of languages, but what you say in those languages not only has denotation, maybe, but it also has effects on people. Music is kind of interesting because on the spectrum of formality it falls between natural languages and computer languages. It's more formal and structured than a natural language, but it doesn't have nearly the structure or formality of a computer language. That, I think, may have to do with why I went into music and not poetry. I think poetry is not structured enough for me.</p>
<p class="normal">但简短的回答确实是，我只是马上就被这些东西吸引了。</p><p class="normal">But the short answer really is, I just gravitated to this stuff right away.</p>
<p class="normal"><b>Seibel：</b>您还记得您编写的第一个有趣的程序吗？</p><p class="normal"><b>Seibel:</b> Do you remember the first interesting program you wrote?</p>
<p class="normal"><b>Deutsch：</b>我因为内容感兴趣而写的第一个程序实际上是我写的第二个程序。我编写的第一个程序是一些与剑桥电子加速器有关的计算。第二个程序是浮点输出格式化程序。</p><p class="normal"><b>Deutsch:</b> The first program that I wrote because the content interested me was actually the second program that I wrote. The first program I wrote was some piece of calculation having to do with the Cambridge Electron Accelerator. The second program was a floating-point-output-formatting program.</p>
<p class="normal"><b>Seibel：</b>这是一个棘手的问题。</p><p class="normal"><b>Seibel:</b> Which is a pretty hairy problem.</p>
<p class="normal"><a id="OEBPS/Chapter11.html.page_417"></a><b>Deutsch：</b>嗯，它在二进制机器上。在十进制机器上这不是一个毛茸茸的问题，而且我在十进制机器上工作。您只需滑动字符串并决定将小数点放在哪里。您必须决定是使用 E 格式还是 F 格式。但在那些日子里，一切都困难得多——我在批处理机器上用汇编语言编写——所以这不是一个小问题。这不是一个难题，但也不是一个微不足道的问题。那是我编写的第一个程序，因为我想这样做。</p><p class="normal"><a></a><b>Deutsch:</b> Well it is on a binary machine. It's not a hairy problem on a decimal machine, and I was working on a decimal machine. You just slide the string around and decide where to put the decimal point. You have to decide whether to use the E or F format. But in those days, everything was a lot harder—I was writing in assembly language on a batch-processing machine—so this was not a trivial problem. It wasn't a hard problem but it wasn't a trivial one. That was the first program that I wrote because I wanted to.</p>
<p class="normal"><b>Seibel：</b>所以你高中时在麻省理工学院闲逛，然后去了伯克利大学。你想逃离东海岸吗？</p><p class="normal"><b>Seibel:</b> So you were hanging out at MIT during high school and then you went to Berkeley for college. Did you want to escape the East Coast?</p>
<p class="normal"><b>德语：</b>有点。我意识到去一个远离父母的地方对我来说真的很好。我认真考虑的三个地方是，我认为是罗切斯特大学、芝加哥大学和伯克利大学。那是显而易见的——三个中只有一个天气晴朗。这就是我最终进入伯克利的原因。这是我一生中发生过的最美好的事情之一。</p><p class="normal"><b>Deutsch:</b> Sort of. I realized that it would be really good for me to go to someplace that was far away from my parents. The three places that I considered seriously were, I think it was University of Rochester, University of Chicago, and Berkeley. That was a no-brainer—only one of the three has reasonable weather. So that's how I ended up at Berkeley. And it was one of the best things that ever happened in my life.</p>
<p class="normal">我当时在伯克利，到达后很快就找到了 Project Genie，并一直参与那个项​​目，直到有了 Project Genie，然后是 Berkeley Computer Corporation，然后是 Xerox。</p><p class="normal">I was at Berkeley and I found Project Genie pretty quickly after I arrived and stayed with that project until—well there was Project Genie and then there was Berkeley Computer Corporation and then there was Xerox.</p>
<p class="normal"><b>Seibel：</b>大概在伯克利，你开始从事比 PDP-1 Lisp 实现更大的项目。</p><p class="normal"><b>Seibel:</b> Presumably at Berkeley you started working on bigger projects than your PDP-1 Lisp implementation.</p>
<p class="normal"><b>德语：</b>哦，是的。Project Genie 中相当大的项目。首先，我几乎编写了整个操作系统内核。内核可能正在推动 10,000 行。</p><p class="normal"><b>Deutsch:</b> Oh, yeah. Considerably larger projects at Project Genie. To begin with I wrote pretty much the whole operating-system kernel. The kernel was probably pushing 10,000 lines.</p>
<p class="normal"><b>Seibel：</b>这种变化——大小上的数量级差异——是如何改变你的设计过程的？</p><p class="normal"><b>Seibel:</b> How did that change—an order-of-magnitude difference in size—change your design process?</p>
<p class="normal"><b>Deutsch：</b>我试图记住内核中的内容。它仍然是一个足够小的程序，我可以将它作为一个整体来处理。显然有职能部门。我知道我对程序的哪些部分可以与哪些关键数据结构进行交互有一个清晰的心理模型。但实际上并没有太多该死的数据结构。有一个流程表；有现成的清单。有 I/O 缓冲区，还有<a id="OEBPS/Chapter11.html.page_418"></a>一些用于跟踪虚拟内存的东西。然后每个进程都有一个打开的文件表。但是，就 C 结构定义而言，所有系统数据结构的描述可能适合两页。所以我们不是在谈论一个复杂的系统。</p><p class="normal"><b>Deutsch:</b> I'm trying to remember what was in the kernel. It was still a small enough program that I could approach it as a whole. There were obviously functional divisions. I know I had a clear mental model of which sections of the program were allowed to interact with which of the key data structures. But in fact there weren't very damn many data structures. There was a process table; there were ready lists. There were I/O buffers and there was <a></a>some stuff for keeping track of virtual memory. And then there was an open file table, per process. But the descriptions of all the system data structures probably could have fit on, in terms of C struct definitions, probably could have fit on two pages. So we're not talking about a complicated system.</p>
<p class="normal"><b>Seibel：</b>在您的记忆中，您开发过的最大的系统是什么？</p><p class="normal"><b>Seibel:</b> What's the biggest system that you've worked on that you remember how it was designed?</p>
<p class="normal"><b>Deutsch：</b>我是三个大型系统的主要推动者。Ghostscript——不包括设备驱动程序，我没有编写大部分——可能大约在 50,000 到 100,000 行 C 代码之间。</p><p class="normal"><b>Deutsch:</b> I've been the primary mover on three large systems. Ghostscript—not counting the device drivers, which I didn't write most of—was probably somewhere on the order of between 50,000 and 100,000 lines of C.</p>
<p class="normal">在 ParcPlace Smalltalk 虚拟机上，我只在即时编译器上工作，这可能是它的 20%，而且可能是几千行 C 的低个位数。可能有 3,000、5,000 行——差不多.</p><p class="normal">On the ParcPlace Smalltalk virtual machine I worked only on the just-in-time compiler, which was probably 20 percent of it, and that was probably in the low single-digit thousands of lines of C. Maybe 3,000, 5,000—something like that.</p>
<p class="normal">而 Interlisp 实现，就我所关心的而言，可能是几千行微代码，也许——我现在猜测——可能是另外 5,000 行 Lisp。所以 Ghostscript 可能是我接触过的最大的单一系统。</p><p class="normal">And the Interlisp implementation, as much of it as I was concerned with, was probably a couple thousand lines of microcode, and maybe—I'm guessing now—maybe another 5,000 lines of Lisp. So Ghostscript is probably the largest single system I've ever been involved with.</p>
<p class="normal"><b>Seibel：</b>而且除了别人写的设备驱动，基本都是你自己写的。</p><p class="normal"><b>Seibel:</b> And other than the device drivers written by other people, you basically wrote that by yourself.</p>
<p class="normal"><b>Deutsch：</b>到 1999 年底，基本上每一行代码都是我写的。一开始我做了一些架构上的决定。第一个是将语言解释器与图形完全分开。</p><p class="normal"><b>Deutsch:</b> Up to the end of 1999, I basically wrote every line of code. At the beginning I made a few architectural decisions. The first one was to completely separate the language interpreter from the graphics.</p>
<p class="normal"><b>Seibel：</b>这种语言是 PostScript 吗？</p><p class="normal"><b>Seibel:</b> The language being PostScript?</p>
<p class="normal"><b>德语：</b>对。因此，语言解释器对用于绘制图形的数据结构一无所知。它与具有 API 的图形库对话。</p><p class="normal"><b>Deutsch:</b> Right. So the language interpreter knew nothing about the data structures being used to do the graphics. It talked to a graphics library that had an API.</p>
<p class="normal">我做出的第二个决定是使用驱动程序接口构建图形库。所以图形库理解像素，理解曲线渲染，理解文本渲染<a id="OEBPS/Chapter11.html.page_419"></a>但它对我如何管理特定设备的像素编码方式以及像素如何传输到特定设备的了解尽可能少。</p><p class="normal">The second decision I made was to structure the graphics library using a driver interface. So the graphics library understood about pixels and it understood about curve rendering and it understood about text rendering <a></a>but it knew as little as I could manage about how pixels were encoded for a particular device, how pixels were transmitted to a particular device.</p>
<p class="normal">第三个决定是驱动程序将实际执行基本绘图命令。一开始，基本上是<code>draw-pixmap</code>and <code>fill-rectangle</code>。</p><p class="normal">The third decision was that the drivers would actually implement the basic drawing commands. Which, at the beginning, were basically <code>draw-pixmap</code> and <code>fill-rectangle</code>.</p>
<p class="normal">所以渲染库将矩形和像素数组传递给驱动程序。如果需要，驱动程序可以将整页图像放在一起，或者为了显示，它可以将它们直接传递给 Xlib 或 GDI 或其他任何东西。所以这就是我预先做出的三个重大架构决策，它们都是很好的决策。他们几乎是母性。我想我遵循的原则是，如果您遇到在多个域中运行的东西，并且这些域之间并没有固有的耦合或交互，那么这是一个非常强大的好地方软件边界。</p><p class="normal">So the rendering library passed rectangles and pixel arrays to the driver. And the driver could either put together a full-page image if it wanted to or, for display, it could pass them through directly to Xlib or GDI or whatever. So those were the three big architectural decisions that I made up front and they were all good ones. And they were pretty much motherhood. I guess the principle that I was following was if you have a situation where you have something that's operating in multiple domains and the domains don't inherently have a lot of coupling or interaction with each other, that's a good place to put a pretty strong software boundary.</p>
<p class="normal">所以语言解释和图形本身并没有太多的相互作用。图形渲染和像素图表示交互更多，但这似乎也是放置抽象边界的好地方。</p><p class="normal">So language interpretation and graphics don't inherently interact with each other very much. Graphics rendering and pixmap representation interact more, but that seemed like a good place to put an abstraction boundary as well.</p>
<p class="normal">事实上，在编写第一行图形代码之前，我编写了一个没有图形的 Level 1 PostScript 解释器。如果您打开手册并基本上浏览所有未参考图形的运算符，我什至在开始设计图形之前就实现了所有这些。我必须设计分词器；我必须决定所有 PostScript 数据类型的表示以及 PostScript 手册中解释器必须提供的内容。当我们到达具有垃圾收集功能的 PostScript Level 2 时，我不得不回去重做很多。但这就是我开始的地方。</p><p class="normal">In fact I wrote a Level 1 PostScript interpreter with no graphics before I wrote the first line of graphics code. If you open the manual and basically go through all the operators that don't make any reference to graphics, I implemented all of those before I even started designing the graphics. I had to design the tokenizer; I had to decide on the representation of all the PostScript data types and the things that the PostScript manual says the interpreter has to provide. I had to go back and redo a lot of them when we got to PostScript Level 2, which has garbage collection. But that's where I started.</p>
<p class="normal">然后我就让我在语言解释器方面的经验带我进入解释器数据结构的设计。在我开始的时间和我能够输入<code>3 4 add equals</code>并让它返回的时间之间<code>7</code>大约有三个星期。那很容易。顺便说一下，我工作的环境——MS-DOS。带有精简版 Emacs 和某人的 C 编译器的 MS-DOS；我不记得是谁的了。</p><p class="normal">Then I just let my experience with language interpreters carry me into the design of the data structures for the interpreter. Between the time that I started and the time that I was able to type in <code>3 4 add equals</code> and have it come back with <code>7</code> was about three weeks. That was very easy. And by the way, the environment in which I was working—MS-DOS. MS-DOS with a stripped-down Emacs and somebody's C compiler; I don't remember whose.</p>
<p class="normal"><a id="OEBPS/Chapter11.html.page_420"></a><b>Seibel：</b>这是您之前做过很多次的任务，即为一种语言实现解释器。您是刚开始编写 C 代码吗？或者用数据结构图填满笔记本？</p><p class="normal"><a></a><b>Seibel:</b> This was a task that you had done many times before, namely implementing an interpreter for a language. Did you just start in writing C code? Or fill up a notebook with data-structure diagrams?</p>
<p class="normal"><b>Deutsch：</b>这个任务对我来说似乎很简单，所以我懒得写图表。我的回忆是，首先我有点沉浸在 PostScript 手册中。然后我可能在纸上做了一些笔记，但可能我只是开始编写 C 头文件。因为，正如我所说，我喜欢从数据开始设计。</p><p class="normal"><b>Deutsch:</b> The task seemed simple enough to me that I didn't bother to write out diagrams. My recollection was that first I sort of soaked myself in the PostScript manual. Then I might have made some notes on paper but probably I just started writing C header files. Because, as I say, I like to design starting with the data.</p>
<p class="normal">然后我有了一些想法，好吧，必须有一个带有主解释器循环的文件。必须进行一些初始化。必须有一个分词器。必须有一个内存管理器。必须有一些东西来管理文件的 PostScript 概念。必须实现各个 PostScript 运算符。所以我将它们按照功能分成了一堆文件。</p><p class="normal">Then I had some idea that, well, there'd have to be a file with a main interpreter loop. There'd have to be some initialization. There'd have to be a tokenizer. There'd have to be a memory manager. There'd have to be something to manage the PostScript notion of files. There'd have to be implementation of the individual PostScript operators. So I divided those up into a bunch of files sort of by functionality.</p>
<p class="normal">当我不厌其烦地注册 Ghostscript 代码的版权时，我不得不向他们发送一份最早的 Ghostscript 实现的完整列表。那时就像是 10 年后——我很感兴趣地查看原始代码、原始结构和各种事物的原始名称，并注意到可能 70% 或 80% 的结构和命名约定仍然存在, 10 年和 2 次主要的 PostScript 语言修订。</p><p class="normal">When I took the trouble of registering the copyright in the Ghostscript code I had to send them a complete listing of the earliest Ghostscript implementation. At that point it was like 10 years later—it was interesting to me to look at the original code and the original structure and the original names of various things and to note that probably 70 or 80 percent of the structure and naming conventions were still there, 10 years and 2 major PostScript language revisions later.</p>
<p class="normal">所以基本上这就是我所做的——首先是数据结构。粗略划分为模块。我的信念仍然是，如果你得到正确的数据结构和它们的不变量，大部分代码都会自行编写。</p><p class="normal">So basically that's what I did—data structures first. Rough division into modules. My belief is still, if you get the data structures and their invariants right, most of the code will just kind of write itself.</p>
<p class="normal"><b>Seibel：</b>所以当你说你写一个头文件时，是为了获得函数签名还是结构，或者两者兼而有之？</p><p class="normal"><b>Seibel:</b> So when you say you write a header file, is that to get the function signatures or the structs, or both?</p>
<p class="normal"><b>Deutsch：</b>结构。那是 1988 年，在 ANSI C 之前——还没有函数签名。一旦 ANSI C 编译器几乎成为标准，我就花了两个月的时间进行了研究，并为 Ghostscript 中的每个函数制作了函数签名。</p><p class="normal"><b>Deutsch:</b> The structs. This was 1988, before ANSI C—there weren't function signatures. Once ANSI C compilers had pretty much become the standard, I took two months and went through and I made function signatures for every function in Ghostscript.</p>
<p class="normal"><b>Seibel：</b>从早期到现在，您对编程的思考方式或编程实践有何变化？</p><p class="normal"><b>Seibel:</b> How has your way of thinking about programming or your practice of programming, changed from those earliest days to now?</p>
<p class="normal"><a id="OEBPS/Chapter11.html.page_421"></a><b>Deutsch：</b>它发生了巨大的变化，因为我觉得有趣的节目种类发生了巨大的变化。我认为可以公平地说，我最初几年编写的程序只是一小段代码。</p><p class="normal"><a></a><b>Deutsch:</b> It's changed enormously because the kinds of programs that I find interesting have changed enormously. I think it's fair to say that the programs that I wrote for the first few years were just little pieces of code.</p>
<p class="normal">随着时间的推移，我考虑了以下问题：您如何采用一个可以做更大、更有趣的事情的程序并对其进行结构化和思考，以及您如何考虑用于以设法完成的方式表达它的语言您的实用性、可靠性、效率、透明度的目标？</p><p class="normal">Over time I've considered the issues of how do you take a program that does something larger and interesting and structure it and think about it, and how do you think about the languages that you use for expressing it in a way that manages to accomplish your goals of utility, reliability, efficiency, transparency?</p>
<p class="normal">现在我知道了一套更大的软件评估标准。我在更大、更复杂的程序的背景下考虑这些标准，在这些程序中，架构或系统级问题是所有艰苦工作的所在。并不是说在单个算法中还没有艰苦的工作要做，但这对我来说似乎不再是最有趣的了——已经很长时间了。</p><p class="normal">Now I'm aware of a much larger set of criteria for evaluating software. And I think about those criteria in the context of much larger and more complex programs, programs where architectural or system-level issues is where all the hard work is. Not to say that there isn't still hard work to be done in individual algorithms, but that's not what seems most interesting to me any more—hasn't for a long time.</p>
<p class="normal"><b>Seibel：</b>所有的程序员都应该成长到那个级别的工作吗？</p><p class="normal"><b>Seibel:</b> Should all programmers grow up to work at that level?</p>
<p class="normal"><b>Deutsch：</b>没有。事实上，我刚刚读到我的一位来自 Xerox PARC 的老朋友 Leo Guibas 刚刚在该领域获得了一些相当高的奖项。从我一直以来的意义上讲，他从来都不是真正的系统专家。他一直是个算法专家——一个才华横溢的人。他找到了一种方法来思考某些类别的分析或优化算法，使它们适用于许多不同的问题，并产生了处理这些问题的新工具。所以，这是很棒的工作。程序员也应该能够成长为 Leo Guibas。</p><p class="normal"><b>Deutsch:</b> No. In fact, I was just reading that an old friend of mine from Xerox PARC, Leo Guibas, just received some fairly high award in the field. He has never really been a systems guy in the sense that I've been; he's been an algorithms guy—a brilliant one. He's found a way to think about certain classes of analysis or optimization algorithms in a way that's made them applicable to a lot of different problems, and that has yielded new tools for working with those problems. So, it's wonderful work. Programmers should be able to grow up to be Leo Guibas, too.</p>
<p class="normal">Leo 和像他这样的人用来解决这些困难的优化和分析问题的架构原则和算法设计原则之间存在相似之处。不同之处在于，处理算法问题的原则更直接地基于 5,000 或 10,000 年的数学历史。我们现在如何进行编程，我们没有任何类似的基础可以建立。这就是为什么这么多软件都是垃圾的原因之一：我们还不知道我们在做什么。</p><p class="normal">There's a parallel between architectural principles and the kinds of algorithmic design principles that Leo and people like him use to address these hard optimization and analysis problems. The difference is that the principles for dealing with algorithmic problems are based a lot more directly on 5,000 or10,000 years' worth of history in mathematics. How we go about programming now, we don't have anything like that foundation to build on. Which is one of the reasons why so much software is crap: we don't really know what we're doing yet.</p>
<p class="normal"><b>Seibel：</b>那么对于那些没有系统级思维天赋的人来说，可以从事软件的较小部分吗？你能分开吗<a id="OEBPS/Chapter11.html.page_422"></a>程序员和架构师？或者你真的希望所有从事系统类软件工作的人，因为它有点分形，能够从系统的角度思考吗？</p><p class="normal"><b>Seibel:</b> So is it OK for people who don't have a talent for systems-level thinking to work on smaller parts of software? Can you split the <a></a>programmers and the architects? Or do you really want everyone who's working on systems-style software, since it is sort of fractal, to be able to think in terms of systems?</p>
<p class="normal"><b>Deutsch：</b>我不认为软件是分形的。如果是的话可能会很好，但我不认为这是因为我认为我们没有很好的工具来处理随着系统变大而发生的事情。我认为系统变大时发生的事情与系统从小到中等规模时发生的事情在本质上是不同的。</p><p class="normal"><b>Deutsch:</b> I don't think software is fractal. It might be nice if it were but I don't think it is because I don't think we have very good tools for dealing with the things that happen as systems get large. I think the things that happen when systems get large are qualitatively different from the things that happen as systems go from being small to medium size.</p>
<p class="normal">但就谁应该做软件而言，我没有一个很好的统一答案。我确实知道，软件的管道越深入，由真正优秀的人构建它就越重要。这是精英主义的观点，我很乐意持有它。</p><p class="normal">But in terms of who should do software, I don't have a good flat answer to that. I do know that the further down in the plumbing the software is, the more important it is that it be built by really good people. That's an elitist point of view, and I'm happy to hold it.</p>
<p class="normal">今天发生的部分事情是软件和非软件之间的界限越来越模糊。如果您有人在设计网站，如果该网站在与用户交互或跟踪状态方面有任何类型的甚至是中等复杂的行为，您就拥有用于构建此类网站的工具。使用这些工具——据我所知，没有使用过它们——实现了一些与编程相同的目的，但这些方法看起来不太像编写程序。</p><p class="normal">Part of what's going on today is that the boundary between what is software and what isn't software is getting blurred. If you have someone who's designing a web site, if that web site has any kind of even moderately complex behavior in terms of interacting with the user or tracking state, you have tools for building web sites like that. And working with those tools—as I understand it, not having used them—accomplishes some of the same ends as programming, but the means don't look very much like writing programs.</p>
<p class="normal">因此，您的问题的答案之一可能是，随着时间的推移，人们过去认为需要编程的越来越多的部分将不再是“编程”，而且几乎任何人都能够做到这一点，并且做一个它的合理工作。</p><p class="normal">So one of the answers to your question might be that over time a larger and larger fraction of what people used to think of as requiring programming won't be “programming” any more and pretty much anybody will be able to do it and do a reasonable job of it.</p>
<p class="normal">你知道关于电话和电话接线员的古老故事吗？故事是，在电话采用的相当早的某个时候，很明显电话的使用正以惊人的速度增长，越来越多的人不得不被雇用作为接线员，因为我们没有拨电话。有人推断增长率并说：“我的上帝。到 20 或 30 年后，每个人都必须成为电话接线员。” 好吧，事情就是这样。我认为类似的事情也可能发生在一些大的编程领域。</p><p class="normal">You know the old story about the telephone and the telephone operators? The story is, sometime fairly early in the adoption of the telephone, when it was clear that use of the telephone was just expanding at an incredible rate, more and more people were having to be hired to work as operators because we didn't have dial telephones. Someone extrapolated the growth rate and said, “My God. By 20 or 30 years from now, every single person will have to be a telephone operator.” Well, that's what happened. I think something like that may be happening in some big areas of programming, as well.</p>
<p class="normal"><a id="OEBPS/Chapter11.html.page_423"></a><b>Seibel：</b>程序员可以那样被取代吗？</p><p class="normal"><a></a><b>Seibel:</b> Can programmers be replaced that way?</p>
<p class="normal"><b>Deutsch：</b>取决于你想编程什么。在过去五年多的时间里，我一直在思考的一件事是，“为什么编程这么难？”</p><p class="normal"><b>Deutsch:</b> Depends on what you want to program. One of the things that I've been thinking about off and on over the last five-plus years is, “Why is programming so hard?”</p>
<p class="normal">你有编程的算法方面，这与数学非常接近，你可以使用数学作为基本模型，如果你愿意的话，它会发生什么。您可以使用数学方法和数学思维方式。这并不容易，但没有人认为数学很容易。因此，您正在使用的材料与我们对该材料的理解以及我们对使用该材料所需的技能水平的理解非常匹配。</p><p class="normal">You have the algorithmic side of programming and that's close enough to mathematics that you can use mathematics as the basic model, if you will, for what goes on in it. You can use mathematical methods and mathematical ways of thinking. That doesn't make it easy, but nobody thinks mathematics is easy. So there's a pretty good match between the material you're working with and our understanding of that material and our understanding of the skill level that's required to work with it.</p>
<p class="normal">我认为另一种编程的部分问题在于，我们所拥有的基本上所有编程语言的世界与我们的感官、我们的大脑和我们的社会共同进化来应对的物理世界有着如此深刻的差异，期望人们用它做好事是愚蠢的。要成为一名真正优秀的程序员，你必须有一些小毛病。也许“你有问题”有点太强了，但是使一个人成为一个运作良好的人的品质和使一个人成为一个真正优秀的程序员的品质——它们是重叠的，但它们并没有重叠太多。我是以一个非常优秀的程序员的身份发言的。</p><p class="normal">I think part of the problem with the other kind of programming is that the world of basically all programming languages that we have is so different in such deep ways from the physical world that our senses and our brains and our society have coevolved to deal with, that it is loony to expect people to do well with it. There has to something a little wrong with you for you to be a really good programmer. Maybe “wrong with you” is a little too strong, but the qualities that make somebody a well-functioning human being and the qualities that make somebody a really good programmer—they overlap but they don't overlap a whole heck of a lot. And I'm speaking as someone who was a very good programmer.</p>
<p class="normal">冯·诺依曼计算和 Algol 家族语言的世界与物理世界有着如此不同的要求，这对我来说实际上是相当令人惊讶的是我们设法构建了所有工作的大型系统，即使它们的性能如此糟糕。</p><p class="normal">The world of von Neumann computation and Algol-family languages has such different requirements than the physical world, that to me it's actually quite surprising that we manage to build large systems at all that work even as poorly as they do.</p>
<p class="normal">也许这不应该比我们可以制造喷气式客机这一事实更令人惊讶，但喷气式客机在现实世界中发挥作用，我们有数千年的机械工程经验可以借鉴。对于软件，我们有一个奇怪的世界，有这些奇怪的、非常奇怪的基本属性。物理世界的属性植根于亚原子物理学，但你有这些层次：你有亚原子物理学，你有原子物理学，你有化学。你有大量由此产生的涌现特性，我们拥有所有这些设备，可以在那个世界中正常运作。</p><p class="normal">Perhaps it shouldn't be any more surprising than the fact that we can build jet airliners, but jet airliners are working in the physical world and we have thousands of years of mechanical engineering to draw on. For software, we have this weird world with these weird, really bizarre fundamental properties. The physical world's properties are rooted in subatomic physics, but you've got these layers: you've got subatomic physics, you've got atomic physics, you've got chemistry. You've got tons of emergent properties that come out of that and we have all of this apparatus for functioning well in that world.</p>
<p class="normal"><a id="OEBPS/Chapter11.html.page_424"></a>我不会环顾四周，看到任何看起来像地址或指针的东西。我们有对象；我们没有这些计算机科学家错误命名为“对象”的奇怪东西。</p><p class="normal"><a></a>I don't look around and see anything that looks like an address or a pointer. We have objects; we don't have these weird things that computer scientists misname “objects.”</p>
<p class="normal"><b>Seibel：</b>更不用说规模了。任何事情的二到六十四都是很多，每秒发生数十亿次的事情很快。</p><p class="normal"><b>Seibel:</b> To say nothing of the scale. Two to the 64th of anything is a lot, and things happening billions of times a second is fast.</p>
<p class="normal"><b>Deutsch：</b>但这并不影响我们在现实世界中的生活。你知道阿伏加德罗的数字，对吧？十点到二十三点？所以，我们环顾四周，看到一个拥有数量惊人的小东西的世界，它们聚集在一起并同时发生。它不会打扰我们，因为世界就是这样，你不必在亚原子水平上理解这张表。</p><p class="normal"><b>Deutsch:</b> But that doesn't bother us here in the real world. You know Avogadro's number, right? Ten to the 23rd? So, we're looking here around at a world that has incredible numbers of little things all clumped together and happening at the same time. It doesn't bother us because the world is such that you don't have to understand this table at a subatomic level.</p>
<p class="normal">物质的物理特性使您在 99.9% 的时间里都可以综合理解它。而你必须知道的关于它的一切，你都可以通过综合处理它来理解。在很大程度上，这在软件世界中并非如此。</p><p class="normal">The physical properties of matter are such that 99.9 percent of the time you can understand it in aggregate. And everything you have to know about it, you can understand from dealing with it in aggregate. To a great extent, that is not true in the world of software.</p>
<p class="normal">人们一直在尝试为软件做模块化结构。随着时间的推移，这项技术的水平一直在提高，但在我看来，它与我们环顾四周并看到具有 10 到 23 个原子的事物的轻松程度相去甚远，并且它甚至不会让我们感到不安。</p><p class="normal">People keep trying to do modularization structures for software. And the state of that art has been improving over time, but it's still, in my opinion, very far away from the ease with which we look around and see things that have, whatever it is, 10 to the 23rd atoms in them, and it doesn't even faze us.</p>
<p class="normal">软件是一门注重细节的学科，这是软件的一个深刻而可怕的基本问题。除非我们了解如何以一种我们不必考虑每个小部分如何与其他部分交互的方式来概念化和组织软件，否则事情不会变得更好。我们离那里还很远。</p><p class="normal">Software is a discipline of detail, and that is a deep, horrendous fundamental problem with software. Until we understand how to conceptualize and organize software in a way that we don't have to think about how every little piece interacts with every other piece, things are not going to get a whole lot better. And we're very far from being there.</p>
<p class="normal"><b>Seibel：</b>技术原因是可以改变的，还是只是野兽的本性？</p><p class="normal"><b>Seibel:</b> Are the technical reasons things that could be changed, or is it just the nature of the beast?</p>
<p class="normal"><b>Deutsch：</b>你必须重新开始。你必须首先抛弃所有具有指针概念的语言，因为在现实世界中没有指针这样的东西。您必须了解这样一个事实，即信息占用空间并随着时间的推移而存在，并且位于特定位置。</p><p class="normal"><b>Deutsch:</b> You'd have to start over. You'd have to throw out all languages that have the concept of a pointer to begin with because there is no such thing as a pointer in the real world. You'd have to come to grips with the fact that information takes space and exists over time and is located at a particular place.</p>
<p class="normal"><a id="OEBPS/Chapter11.html.page_425"></a><b>Seibel：</b>当你从编写小代码片段到构建大系统的过程中，你是否仍然以相同的方式编写小片段代码，只是添加了一个关于大系统的新视角，或者它是否真的改变了你做整个事情的方式事物？</p><p class="normal"><a></a><b>Seibel:</b> As you made the progression from writing small pieces of code to building big systems, did you still write small pieces of code the same way and just add a new perspective about bigger systems, or did it actually change the way you did the whole thing?</p>
<p class="normal"><b>Deutsch：</b>它改变了我做整件事的方式。我编写的第一个重要程序是哈佛 UNIVAC 上的程序。下一个小集群是我在麻省理工学院对 PDP-1 所做的工作。在我上高中的 1960 年代初期的那个时代，我确实想到了三种不同的程序或系统。</p><p class="normal"><b>Deutsch:</b> It changed the way I did the whole thing. The first significant programs I wrote would be the ones on the UNIVAC at Harvard. The next little cluster would be the work that I did on the PDP-1 at MIT. There were really three different programs or systems that I think of dating from that era, in the early-1960s timeframe, around when I was in high school.</p>
<p class="normal">我为普通 PDP-1 构建了一个 Lisp 解释器。我为 Jack Dennis 奇怪的修改版 PDP-1 做了一些操作系统方面的工作。我为丹尼斯的 PDP-1 写了一个文本编辑器。</p><p class="normal">There was a Lisp interpreter that I built for a stock PDP-1. I did some work on the operating system for Jack Dennis's weird modified PDP-1. And I wrote a text editor for Dennis's PDP-1.</p>
<p class="normal">那三个系统我还是写的，基本上是单体写的。与我在 UNIVAC 上的旧程序不同的是，我必须开始进行数据结构设计。所以这是我所做的编程类型的第一个重大转变。</p><p class="normal">Those three systems I still wrote basically monolithically. The difference from my old programs on the UNIVAC was I had to start doing data-structure design. So that was the first big shift in what kind of programming I was doing.</p>
<p class="normal">我开始意识到我所说的功能细分，但我不认为它有任何特别的意义。我知道你可以编写程序的某些部分，而不必在编写程序时考虑程序的其他部分，但是关于接口的问题，随着程序变得越来越大，接口问题变得非常重要，我不记得那些令人担忧。</p><p class="normal">I was starting to be aware of what I would call functional segmentation but I didn't think of it as having any particular significance. I was aware that you could write certain parts of the program and not have to think about other parts of the program while you were doing it, but the issues about interfaces, which really become paramount as programs get big, I don't recall those being of concern.</p>
<p class="normal">这种转变发生在我的下一个大集群工作中，这是我在伯克利所做的工作，主要是作为一名本科生，关于 Project Genie：940 分时系统和 QED 文本编辑器。我写了一个汇编语言调试器，但我对它的记忆不多。</p><p class="normal">That transition happened with my next big cluster of work, which was the work that I did at Berkeley, mostly as an undergraduate, on Project Genie: the 940 timesharing system and on the QED text editor. And I wrote an assembly-language debugger but I don't remember much of anything about it.</p>
<p class="normal">最具系统风味的部分是操作系统。说我写了整个操作系统是不公平的；我没有。但我基本上写了整个内核。这是用汇编语言完成的。我们在这里谈论的程序越来越大，可能大约有 10,000 行汇编程序。它有一个过程<a id="OEBPS/Chapter11.html.page_426"></a>调度程序。它有虚拟内存。它有一个文件系统。事实上，它有几个文件系统。</p><p class="normal">The piece that had the most system flavor to it was the operating system. It's not fair to say that I wrote the whole operating system; I didn't. But I essentially wrote the whole kernel. This was done in assembly language. We're talking about programs that are getting to be a little larger here, probably on the order of 10,000 lines of assembler. It had a process <a></a>scheduler. It had virtual memory. It had a file system. In fact, it had several file systems.</p>
<p class="normal">那里有更复杂的数据结构设计问题。我记得有一个活动进程表。还有一个问题是如何设计它以及操作系统应该如何决定一个进程何时可以运行——诸如此类的事情。有用于跟踪虚拟内存系统的结构。但是界面的一些问题开始出现。不在操作系统本身之内，因为操作系统是如此之小，以至于内核基本上被设计为一个整体，一个整体。</p><p class="normal">There, there were more complex questions of data-structure design. The one that I remember is there was an active process table. And there was a question as to how to design that and how the operating system should decide when a process was runnable or not—that kind of thing. There were structures for keeping track of the virtual memory system. But some issues of interface started to emerge. Not within the operating system itself, because the operating system was so small that the kernel was designed essentially as a single piece, as a monolith.</p>
<p class="normal">但是有两个重要领域开始出现软件界面问题。其中之一就是用户程序和内核之间的接口。系统调用应该是什么？参数应该如何布置？我知道在940 TSS的前几个版本中，读写文件的基本操作相当于Unix的<code>read</code>and <code>write</code>calls，基本上就是给一个基址和一个计数。好吧，这一切都很好，但很多时候这并不是你想要的。你基本上想要一个流接口。在那些日子里，我们没有这样的概念，你可以采用操作系统设施，然后围绕它包装用户级代码，从而为你提供一些更好的界面，<code>getc</code>并在其<code>putc</code>之上<code>read</code>构建<code>write</code>. <code>getc</code>所以我们实际上做的是在操作系统的更高版本中，我们添加了相当于和的操作系统调用<code>putc</code>。</p><p class="normal">But there were two important areas where issues of software interface started to emerge. One of them was simply the interface between user programs and the kernel. What should the system calls be? How should the parameters be laid out? I know that in the first few versions of the 940 TSS, the basic operations for reading and writing files were the equivalent of the Unix <code>read</code> and <code>write</code> calls, where you basically gave a base address and a count. Well, that was all very well and good, but a lot of the time that wasn't what you wanted. You basically wanted a stream interface. And in those days, we didn't have the concept that you could take an operating-system facility and then wrap user-level code around it to give you some nicer interface in the way <code>getc</code> and <code>putc</code> get built on top of <code>read</code> and <code>write</code>. So what we actually did was in later versions of the operating system, we added operating-system calls that were the equivalent of <code>getc</code> and <code>putc</code>.</p>
<p class="normal">接口问题开始出现的另一个地方——再次基于 MULTICS 模式——从一开始我们就在内核和我们今天所说的 shell 之间有很大的区别。这是操作系统开发的早期，我们没有意识到您实际上可以构建一个基本上没有特殊权限的 shell。shell 是一个用户模式程序，但它有很多特权。但是关于内核必须为 shell 提供哪些功能存在一些问题——shell 应该能够直接执行哪些操作以及它应该让内核调用哪些操作。</p><p class="normal">The other place where issues of interface started to show up were—again, based on the MULTICS mode—from the beginning we had a strong distinction between the kernel and what today we would call the shell. This was early enough in the development of operating systems that we didn't realize that you could, in fact, build a shell with essentially no special privileges. The shell was a user-mode program, but it had a lot of special privileges. But there were some issues about what facilities the kernel had to give the shell—what things the shell should be able to do directly and what things it should have to make kernel calls for.</p>
<p class="normal">我们看到了刚刚从任务中出现的界面设计选择。那是我职业生涯中的一个点，我开始模糊地意识到接口<a id="OEBPS/Chapter11.html.page_427"></a>实体之间确实需要单独设计，它们之间的接口也是一个重要的设计问题。</p><p class="normal">We saw interface-design choices just emerging from the task. That was the point in my career at which I dimly started to become aware that interfaces <a></a>between entities really needed to be designed separately, that the interfaces between them were also an important design issue.</p>
<p class="normal">所以回答你关于我在小系统中编程的方式是否随着我开始使用更大的系统而改变的问题，答案是，是的。当我构建越来越大的系统时，我发现当我坐下来写任何代码时，我首先会问自己的问题越来越多，“好吧，它和它周围的一切之间的接口是什么样的？传入什么？什么被淘汰了？界面的哪一侧应该有多少任务？” 这类问题开始成为我正在处理的问题中越来越大的一部分。我认为它们确实影响了我编写单个较小代码块的方式。</p><p class="normal">So responding to your question about whether the way I programmed in the small changed as I started to work with larger systems, the answer is, yes. As I built larger and larger systems, I found that when sitting down to write any piece of code, more and more the question I would ask myself first is, “OK, what's the interface between this and everything around it going to look like? What gets passed in? What gets passed out? How much of a task should be on which side of an interface?” Those kinds of questions started to become a larger and larger part of what I was dealing with. And they did affect the way that I wrote individual smaller chunks of code, I think.</p>
<p class="normal"><b>Seibel：</b>这是在更大的系统上工作的自然结果——最终系统变得足够大，你只需要找到一些方法将它们分开。</p><p class="normal"><b>Seibel:</b> And this was a natural consequence of working on bigger systems—eventually the systems get big enough that you just have to find some way to break them apart.</p>
<p class="normal"><b>德语：</b>是的。从这个意义上说，我同意软件是分形的，因为分解是一个发生在许多不同层次上的问题。我要说的是，我不认为较大颗粒的分解类型与较小颗粒发生的分解类型在性质上是相同的。我不确定。当您以较小的粒度进行分解时，您可能不会考虑资源分配等问题；当你在更大的粒度上进行分解时，你必须这样做。</p><p class="normal"><b>Deutsch:</b> That's right. In that sense I agree that software is fractal in that decomposition is an issue that happens at many different levels. I was going to say I don't think that the kinds of decomposition at bigger grains are qualitatively the same as the kinds of decomposition that happen at smaller grains. I'm not sure. When you're doing decomposition at a smaller grain you may not be thinking, for example, about resource allocation; when you're doing decomposition at a larger grain you have to.</p>
<p class="normal"><b>Seibel：</b>您是否曾与在您看来非常优秀的程序员但只能在一定规模上工作的人共事过？就像他们可以很好地解决某种规模的问题，但除此之外，他们只是没有打破系统并以这种方式思考它们的心态？</p><p class="normal"><b>Seibel:</b> Have you worked with people who, in your opinion, were very good programmers, yet who could only work at a certain scale? Like they could work well on problems up to a sort of certain size but beyond that, they just didn't have the mentality for breaking systems apart and thinking about them that way?</p>
<p class="normal"><b>Deutsch：</b>我曾与非常聪明但没有大规模编程经验的程序员一起工作。对于 Ghostscript，在将其移交给我创办的公司时，我确实与被带入团队的两名工程师存在一些非常严重的分歧。都是非常聪明和勤奋的人，都有经验。我认为他们是非常优秀的程序员，优秀的设计师。但他们不是系统思想家。他们不仅不习惯用<a id="OEBPS/Chapter11.html.page_428"></a>变化的影响或后果；他们在某种程度上什至没有意识到这是一个必不可少的问题。对我来说，区别在于了解在进行更大规模设计时必须提出的问题的人和出于某种原因也看不到这些问题的人。</p><p class="normal"><b>Deutsch:</b> I've worked with programmers who were very smart but who didn't have experience at larger-scale programming. And for Ghostscript, I did have some pretty serious disagreements with two of the engineers who were brought into the team as it was getting handed over to the company that I started. Both very smart and hardworking guys, both experienced. I thought they were very good programmers, good designers. But they were not system thinkers. Not only were they not used to thinking in terms of <a></a>the impact or ramifications of changes; they to some extent didn't even realize that that was an essential question to ask. To me the distinction is between people who understand what the questions are that you have to ask in doing larger-scale design and the people who for whatever reason don't see those questions as well.</p>
<p class="normal"><b>Seibel：</b>但是你认为那些人——当他们不想成为整个系统的架构师时——做得很好吗？</p><p class="normal"><b>Seibel:</b> But you think those people—when they're not trying to be the architect of a whole system—do good work?</p>
<p class="normal"><b>德语：</b>是的。我想到的这两位工程师都为公司做了非常出色的工作。其中一位正在研究一项规模庞大、吃力不讨好的项目，但在商业上很重要。另一个人重写了我的一些图形代码，他的代码产生了更好看的结果。所以这些都是优秀、聪明、经验丰富的人。他们只是看不到图片的那一部分——至少我是这么认为的。</p><p class="normal"><b>Deutsch:</b> Yeah. The two engineers that I'm thinking of both did really great work for the company. One of them was working on something that was large and rather thankless but important commercially. And the other one redid some substantial chunks of my graphics code and his code produces better-looking results. So these are good, smart, experienced guys. They just don't kind of see that part of the picture—at least that's my take on it.</p>
<p class="normal"><b>Seibel：</b>您觉得有什么特别的技能让您成为一名优秀的程序员吗？</p><p class="normal"><b>Seibel:</b> Are there particular skills that you feel made you a good programmer?</p>
<p class="normal"><b>Deutsch：</b>我将在这里给你一个非常新时代的答案。总的来说，我不是一个新时代的人，虽然我也经历过留长发的时期。当我处于我认为自己能力的顶峰时，我的直觉非常可靠。我会做一些事情，结果会是对的。其中一些是运气。我敢肯定，其中一些是已经内化到很深的地方，以至于我无法有意识地进入这个过程。但我想我只是有一个诀窍。我知道这不是一个非常令人满意的答案，但我真的相信，让我擅长我所做的事情的一些东西就在那里。</p><p class="normal"><b>Deutsch:</b> I'm going to give you a very new-age answer here. I'm not a new-age kind of guy generally speaking, although I went through my period of really long hair. When I was at what I would consider the peak of my abilities, I had extremely trustworthy intuition. I would do things and they would just turn out right. Some of that was luck. Some of it, I'm sure, was experience that had simply gotten internalized so far down that I didn't have conscious access to the process. But I think I just had a knack for it. I know that's not a very satisfying answer but I truly believe that some of what made me good at what I did was something that was just there.</p>
<p class="normal"><b>Seibel：</b>在你作为一个早熟的少年在麻省理工学院闲逛的时候，你是否有机会观察到，“哇，这个人真的很聪明，但他不知道怎么做我会做的事情。”？</p><p class="normal"><b>Seibel:</b> In your days as a precocious teenager hanging out at MIT, did you have a chance to observe, “Wow, this guy's really smart but he doesn't know how to do this thing that I know how to do.”?</p>
<p class="normal"><b>Deutsch：</b>不，我没有。好吧，我确实记得我开始重写 Dennis 的 PDP-1 上的文本编辑器；我一定是 15 或 16 岁。原始代码是由 Tech Model Railroad Club 小组的一两个人编写的。那些人很聪明。我查看了代码，我认为其中很多都很糟糕。</p><p class="normal"><b>Deutsch:</b> No, I didn't. Well, OK, I do remember when I started rewriting the text editor on Dennis's PDP-1; I must have been 15 or 16. The original code had been written by one or two of the guys from the Tech Model Railroad Club group. Those were smart guys. And I looked at the code and I thought a lot of it was awful.</p>
<p class="normal"><a id="OEBPS/Chapter11.html.page_429"></a>我不会说这是我和我周围工作的人之间的区别。这是我认为代码应该是的方式和我在我面前看到的代码之间的差异。我会犹豫将其概括为关​​于人民的声明。</p><p class="normal"><a></a>I would not say it was a difference between me and the people I was working around. It was a difference between the way I thought code should be and the code that I saw in front of me. I would hesitate to generalize that into a statement about the people.</p>
<p class="normal">我一直对我所谓的符号世界，符号世界感到非常自在。符号和它们的图案一直只是我午餐吃的东西。对于很多人来说情况并非如此。我什至和我的伴侣也看到了。我们都是音乐家。我们都是作曲家。我们都是声乐表演者。但我主要是从象征的角度来看音乐的。我只用一支铅笔和一张纸做很多作文。音符在里面，但我没有在钢琴上把它们挑出来。我听到他们的声音，我有一个计划。</p><p class="normal">I've always been really comfortable in what I would call the symbolic world, the world of symbols. Symbols and their patterns have always just been the stuff I eat for lunch. And for a lot of people that's not the case. I see it even with my partner. We're both musicians. We're both composers. We're both vocal performers. But I come at music primarily from a symbolic point of view. I do a lot of my composition just with a pencil and a pad of paper. The notes are in there but I'm not picking them out on the piano. I hear them and I have a plan.</p>
<p class="normal">而他的大部分作品都是用吉他创作的。他会弹奏一些东西并四处闲逛，也许会弹奏一下钢琴，然后再次弹奏一遍。而且他从不写下任何东西。他会写下和弦序列，也许，如果按下的话，我猜他会在某个时候写下这些词。但他根本不是从基于符号的思维方式来创作的。</p><p class="normal">Whereas he does most of his composition on his guitar. He plays stuff and fools around with it, maybe plunks around at the piano a little bit, runs through it again. And he never writes anything down. He'll write down the chord sequences, maybe, if pressed, and I guess at some point he writes down the words. But he doesn't come at composition kind of from the symbol-based mindset at all.</p>
<p class="normal">所以有些人走那条路，有些人不走。如果我要从中吸取教训——好吧，我又是一个精英主义者：我会说应该编程的人是那些在符号世界中感到自在的人。如果你觉得在那个世界里游来游去不是很舒服，也许编程不是你应该做的。</p><p class="normal">So some people go that way, some people don't. If I was going to draw lessons from it—well again, I'm kind of an elitist: I would say that the people who should be programming are the people who feel comfortable in the world of symbols. If you don't feel really pretty comfortable swimming around in that world, maybe programming isn't what you should be doing.</p>
<p class="normal"><b>Seibel：</b>你有什么重要的导师吗？</p><p class="normal"><b>Seibel:</b> Did you have any important mentors?</p>
<p class="normal"><b>Deutsch：</b>有两个人。其中之一是已经不在身边的人；他的名字叫卡尔文·穆尔斯。他是信息系统的早期先驱。我相信实际上是他创造了<i>信息检索</i>这个术语。他的背景最初是图书馆学。我想，我是在高中或大学时代认识他的。他已经开始设计一种他认为可以直接供人们直接使用的编程语言。但他对编程语言一无所知。那时，我这样做是因为我已经构建了这个 Lisp 系统并且我学习了其他一些编程语言。</p><p class="normal"><b>Deutsch:</b> There were two people. One of them is someone who's no longer around; his name was Calvin Mooers. He was an early pioneer in information systems. I believe he is credited with actually coining the term <i>information retrieval</i>. His background was originally in library science. I met him when I was, I think, high-school or college age. He had started to design a programming language that he thought would be usable directly by just people. But he didn't know anything about programming languages. And at that point, I did because I had built this Lisp system and I'd studied some other programming languages.</p>
<p class="normal"><a id="OEBPS/Chapter11.html.page_430"></a>所以我们聚在一起，他最终形成的语言是我认为公平地说他和我有点共同设计的语言。它被称为 TRAC。那时他对我来说只是一个真正的支持者。</p><p class="normal"><a></a>So we got together and the language that he eventually wound up making was one that I think it's fair to say he and I kind of codesigned. It was called TRAC. He was just a real supportive guy at that point for me.</p>
<p class="normal">另一个我一直认为是导师的人是 Danny Bobrow。他和我是很长一段时间的朋友。我一直认为他是我职业生涯中的导师。</p><p class="normal">The other person that I've always thought of as something of a mentor is Danny Bobrow. He and I have been friends for a very long time. And I've always thought of him as kind of a mentor in the process of my career.</p>
<p class="normal">但就实际如何编程、如何开发软件而言，麻省理工学院没有人。伯克利真的没有人。在 PARC，只有一个人真正影响了我开发软件的方式，他甚至都不是程序员。那是 Jerry Elkind，他曾担任 PARC 计算机科学实验室的经理一段时间。</p><p class="normal">But in terms of actually how to program, how to do software, there wasn't anybody at MIT. There wasn't really anybody at Berkeley. At PARC, only one person really affected the way that I did software, and he wasn't even a programmer. That was Jerry Elkind, who was the manager of the Computer Science Lab at PARC for a while.</p>
<p class="normal">他说的对我影响深远的一件事是衡量事物的重要性。有时候——可能比你想象的要多——你的信念或直觉并不正确，所以要衡量事物。甚至有时会测量您认为不需要测量的东西。这对我产生了深远的影响。</p><p class="normal">The thing that he said that made a profound effect on me was how important it is to measure things; that there'll be times—maybe more times than you think—when your beliefs or intuitions just won't be right, so measure things. Even sometimes measure things you don't think you need to measure. That had a profound effect on me.</p>
<p class="normal">当我想做一些涉及大量计算或大量数据的事情时，我现在经常做的事情之一就是测量。自从我在 PARC 开始就是这种情况，PARC 大约 35 年前就开始了。</p><p class="normal">When I want to do something that's going to involve a significant amount of computation or significant amount of data, one of the things that I always do now is measure. And that's been the case since I was at PARC, which was starting about 35 years ago.</p>
<p class="normal"><b>Seibel：</b>你是我就这本书联系过的唯一一个对书名中的<i>编码器</i>这个词有强烈反应的人。您更喜欢如何描述自己？</p><p class="normal"><b>Seibel:</b> You were the only person I contacted about this book who had a really strong reaction to the word <i>coder</i> in the title. How would you prefer to describe yourself?</p>
<p class="normal"><b>Deutsch：</b>我不得不说，在我生命的这个阶段，我什至对<i>程序员</i>这个词有轻微的负面反应。如果你看看创建实际工作的软件的过程，它会做一些有用的事情，有很多不同的角色和很多不同的过程和技能来实现这一目标。有人可以称自己为程序员，但这并不能告诉您他们实际上为该过程带来了哪些技能集。</p><p class="normal"><b>Deutsch:</b> I have to say at this point in my life I have even a mildly negative reaction to the word <i>programmer</i>. If you look at the process of creating software that actually works, that does something useful, there are a lot of different roles and a lot of different processes and skills that go into achieving that end. Someone can call themselves a programmer and that doesn't tell you very much about what set of skills they actually bring to bear to that process.</p>
<p class="normal">但至少<i>程序员</i>这个词已经相当成熟，涵盖了相当广泛的范围。“编码器”与最小的和<a id="OEBPS/Chapter11.html.page_431"></a>整个努力中最狭隘的部分。我认为<i>编码员</i>，与生产实际工作并做一些有用的软件的过程有关，在建造实际工作的建筑物的过程中可能略高于<i>瓦工。</i></p><p class="normal">But at least the word <i>programmer</i> is pretty well established as covering a pretty wide range. “Coder” is strongly associated with the smallest and <a></a>most narrowly focused part of that whole endeavor. I think of <i>coder</i>, in relation to the process of producing software that actually works and does something useful, as being maybe slightly above <i>bricklayer</i> in the process of constructing buildings that actually work.</p>
<p class="normal">成为一名编码员没有错。做瓦工也没有错。做好这件事需要很多技巧。但它代表了整个过程中这么一个小角落。</p><p class="normal">There's nothing wrong with being a coder. There's nothing wrong with being a bricklayer, either. There's a lot of skill that goes into doing it well. But it represents such a small corner of the whole process.</p>
<p class="normal"><b>Seibel：</b>什么是适合您的包罗万象的术语？软件开发人员？电脑科学家？</p><p class="normal"><b>Seibel:</b> What is an encompassing term that would work for you? Software developer? Computer scientist?</p>
<p class="normal"><b>Deutsch：我对</b><i>计算机科学</i>也有一点不满。我可以提出一个非常有力的理由，即<i>科学</i>这个词不应该应用于计算。我认为基本上所有所谓的<i>计算机科学</i>都是工程学和应用数学的某种结合。我认为它很少是科学过程方面的科学，你所做的是对观察到的现象进行更好的描述。</p><p class="normal"><b>Deutsch:</b> I have a little bit of a rant about <i>computer science</i> also. I could make a pretty strong case that the word <i>science</i> should not be applied to computing. I think essentially all of what's called <i>computer science</i> is some combination of engineering and applied mathematics. I think very little of it is science in terms of the scientific process, where what you're doing is developing better descriptions of observed phenomena.</p>
<p class="normal">我想如果我要选择一个简短的短语，我可能会说<i>软件开发人员</i>。这几乎涵盖了从架构到编码的所有内容。它不包括为了生产实际工作和有用的软件而必须发生的一些其他事情，但它几乎涵盖了我所做的所有事情。</p><p class="normal">I guess if I was to pick a short snappy phrase I would probably say <i>software developer</i>. That covers pretty much everything from architecture to coding. It doesn't cover some of the other things that have to happen in order to produce software that actually works and is useful, but it covers pretty much all of what I've done.</p>
<p class="normal"><b>Seibel：</b>它没有涵盖什么？</p><p class="normal"><b>Seibel:</b> What doesn't it cover?</p>
<p class="normal"><b>Deutsch：</b>它不包括理解问题域以及引出和理解需求的过程。它不包括从测试到软件发布后发生的事情的那种反馈循环的过程——至少不是所有过程。基本上，“软件开发人员”指的是开发软件的组织范围内的世界。它很少提及该组织与其客户或世界其他地区之间的联系，毕竟，这首先证明了软件创建的合理性。</p><p class="normal"><b>Deutsch:</b> It doesn't cover the process of understanding the problem domain and eliciting and understanding the requirements. It doesn't cover the process—at least not all of the process—of the kind of feedback loops from testing to what happens after the software has been released. Basically “software developer” refers to the world within the boundaries of the organization that's developing the software. It says very little about the connections between that organization and its customers or the rest of the world, which, after all, are what justifies the creation of software in the first place.</p>
<p class="normal"><a id="OEBPS/Chapter11.html.page_432"></a><b>Seibel：</b>你认为这种情况正在改变吗？如今，有人提倡尽早与客户或用户建立联系，并真正使这成为软件开发人员工作的一部分。</p><p class="normal"><a></a><b>Seibel:</b> Do you think that's changing? These days there are people advocating trying to connect earlier with the customer or user and really making that part of the software developer's job.</p>
<p class="normal"><b>Deutsch：</b>是的，XP 确实如此。我不是 XP 的忠实粉丝，这有两个原因。XP 提倡在开发过程中与客户紧密耦合，我猜有两个原因。一是这样可以更好地理解和满足客户的需求。这很可能是真的。我没有这方面的第一手知识，但我对此有点担心，因为客户并不总是知道客户的需求是什么。</p><p class="normal"><b>Deutsch:</b> Yes, XP certainly does that. I'm not a big fan of XP, and it's for two reasons. XP advocates very tight coupling with the customer during the development process on, I guess, two grounds. One is that this results in the customer's needs being understood and met better. That may well be true. I don't have firsthand knowledge of it but I'm a little wary of that because the customer doesn't always know what the customer's needs are.</p>
<p class="normal">我认为，XP 提倡与客户紧密耦合的另一个原因是避免过早的泛化或过度设计。我认为这是一把双刃剑。因为我已经看到这个过程在两个方向上都误入歧途：过早的泛化和过早的专业化。</p><p class="normal">The other reason that XP, I think, advocates this tight coupling with the customer is to avoid premature generalization or overdesign. I think that's a two-edged sword. Because I've seen that process go astray in both directions: both premature generalization and premature specialization.</p>
<p class="normal">所以我在这方面对 XP 有一些疑问。项目“完成”后会发生什么？它可维护吗？是否支持？它是可进化的吗？当原始开发人员离开时会发生什么？因为 XP 非常讨厌文档，所以我对此非常担心。</p><p class="normal">So I have some questions about XP in that respect. What happens after the project is “done”? Is it maintainable? Is it supportable? Is it evolvable? What happens when the original developers have left? Because XP is so documentation-phobic, I have very grave concerns about that.</p>
<p class="normal">这是我遇到过的许多人的问题，他们非常热衷于快速原型制作或任何不将其视为工程的软件开发形式。我严重质疑不是从工程角度构建的软件能持续多久。</p><p class="normal">That's an issue I've had with a number of people who are very much into rapid prototyping or any form of software development that doesn't treat it as engineering. I seriously question how well software not built from an engineering point of view lasts.</p>
<p class="normal"><b>Seibel：</b>您能否举例说明泛化或专业化出现问题的情况？</p><p class="normal"><b>Seibel:</b> Can you give an example of when you've seen generalization or specialization go awry?</p>
<p class="normal"><b>Deutsch：</b>当我处于职业生涯的巅峰时期时，我做得非常出色的一件事，我不能说我是以完全系统的方式做的，就是选择合适的概括性水平来涵盖几个多年的未来发展方向可能并不完全明显。</p><p class="normal"><b>Deutsch:</b> When I was in the peak years of my career, one of the things that I did extremely well, and I can't claim that I did it in a completely systematic way, was to pick the right level of generality to cover several years' worth of future evolution in directions that might not have been completely obvious.</p>
<p class="normal">但我认为回过头来看，过早专业化的一个例子是 Ghostscript 在体系结构级别上决定使用面向像素而不是面向平面的彩色地图表示。使用位图并要求像素表示适合机器长度。</p><p class="normal">But I think in retrospect the one example of premature specialization was the decision in Ghostscript, at an architectural level, to use pixel-oriented rather than plane-oriented representation of color maps. To use bitmaps and to require the representation of a pixel to fit in a machine long.</p>
<p class="normal"><a id="OEBPS/Chapter11.html.page_433"></a>事实上，它使用块状而不是平面表示法，这意味着处理专色会变得非常笨拙——在这种情况下，您的打印机可能针对特定作业需要非标准 CMYK 墨水的颜色。例如，必须精确匹配的银色、金色或特殊色调。</p><p class="normal"><a></a>The fact that it used a chunky rather than planar representation meant that it turned out to be very awkward to deal with spot color—where you have printers that may, for specific jobs, require colors that are not the standard CMYK inks. For example silver, gold, or special tints that have to be matched exactly.</p>
<p class="normal">如果您查看像素化的彩色图像，则在内存中或多或少有两种表示方式。您可以在内存中将其表示为像素数组，其中每个像素都包含图像上斑点的 RGB 或 CMYK 数据。例如，这通常是显示控制器的工作方式。</p><p class="normal">If you look at a pixelized color image there are more or less two ways of representing that in memory. You can represent it in memory as an array of pixels where each pixel contains RGB or CMYK data for the spot on the image. That's typically the way display controllers work, for example.</p>
<p class="normal">另一种在印刷行业更常见的方法是有一个数组，其中包含每个像素的红色数量，然后是另一个数组，其中包含每个像素的绿色数量，然后是另一个包含蓝色数量的数组，等等., 等等。如果你是在逐个像素的基础上处理事情，这就不太方便了。另一方面，它不会对有多少种不同的油墨或多少种不同的印版可以进入给定图像的生产施加任何先验限制。</p><p class="normal">The other way, which is more common in the printing industry, is to have an array that contains the amount of red for each pixel and then another that contains the amount of green for each pixel, then another that contains the amount of blue, etc., etc. If you're processing things on a pixel-by-pixel basis, this is less convenient. On the other hand, it doesn't impose any a priori constraint on how many different inks or how many different plates can go into the production of a given image.</p>
<p class="normal"><b>Seibel：</b>所以如果你有一台可以使用金色墨水的打印机，你只需添加一个平面。</p><p class="normal"><b>Seibel:</b> So if you have a printer that can use gold ink, you just add a plane.</p>
<p class="normal"><b>德语：</b>对。这在消费级打印机中当然不常见，甚至在办公室打印机中也不常见。但在胶版印刷中，具有特殊层是比较常见的。所以这是概括性不足的一个领域。</p><p class="normal"><b>Deutsch:</b> Right. This certainly is not common in consumer-grade printers or even typically in office printers. But in offset printing it is relatively common to have special layers. So that was one area of insufficient generalization.</p>
<p class="normal">所以这是一个例子，即使我有很多想法和技巧，我还是错过了船。它并没有很好地说明我的观点；从某种意义上说，它破坏了我的观点，因为在这种情况下，即使是仔细的预见也会导致泛化不足。而且我可以准确地告诉你远见不足是从哪里来的——这是因为 Ghostscript 基本上是由一个对印刷业一无所知的非常聪明的人完成的。</p><p class="normal">So that's an example where even with a great deal of thought and skill I missed the boat. It doesn't illustrate my point well; in a sense it undermines my point because, in this case, even careful foresight resulted in insufficient generalization. And I can tell you exactly where that insufficient foresight came from—it came from the fact that Ghostscript was basically done by one very smart guy who had no acquaintance with the printing industry.</p>
<p class="normal"><b>Seibel：</b>意思是你。</p><p class="normal"><b>Seibel:</b> Meaning you.</p>
<p class="normal"><b>德语：</b>对。Ghostscript 最初只是一个用于预览 PostScript 文件的屏幕预览器，因为那时还没有，而且 PDF 也不存在。如果我要从那个故事中吸取教训，那就是要求<a id="OEBPS/Chapter11.html.page_434"></a>总是在改变，他们总是会至少尝试改变你没有想到的方向。</p><p class="normal"><b>Deutsch:</b> Right. Ghostscript started out as strictly a screen previewer for previewing PostScript files because there wasn't one and PDF didn't exist yet. If I was going to draw a moral from that story, it's that requirements <a></a>always change, they always are going to at least attempt to change in directions you didn't think of.</p>
<p class="normal">关于如何为此做好准备，有两种思想流派。一种思想流派，我认为它可能与 XP 看待它的方式非常接近，它基本上是说，因为需求会一直在变化，所以你不应该期望软件能够持久。如果需求发生变化，您可以构建新的东西。我认为，这其中有一定的智慧。</p><p class="normal">There are two schools of thought as to how you prepare yourself for that. One school of thought, which I think is probably pretty close to the way XP looks at it, that basically says that because requirements are going to change all the time, you shouldn't expect software to last. If the requirements change, you build something new. There is, I think, a certain amount of wisdom in that.</p>
<p class="normal">问题出在业内的一句老话：“快、便宜、好——任选其二。” 如果你快速构建东西并且你有某种方法可以廉价地构建它们，那么它们就不太可能是好的。但是这种思想流派认为你不应该指望软件能够持久。</p><p class="normal">The problem being the old saying in the business: “fast, cheap, good—pick any two.” If you build things fast and you have some way of building them inexpensively, it's very unlikely that they're going to be good. But this school of thought says you shouldn't expect software to last.</p>
<p class="normal">我认为这背后可能是一种将软件作为支出与软件作为资本资产的心态。我非常赞同软件作为资本资产的观点。当我在 ParcPlace 工作时，Adele Goldberg 在那里宣传面向对象设计，我们谈论对象的部分方式以及我们向客户和潜在客户提倡面向对象语言和设计的部分方式是说，“你看，你应该将软件视为资本资产。”</p><p class="normal">I think behind this perhaps is a mindset of software as expense vs. software as capital asset. I'm very much in the software-as-capital-asset school. When I was working at ParcPlace and Adele Goldberg was out there evangelizing object-oriented design, part of the way we talked about objects and part of the way we advocated object-oriented languages and design to our customers and potential customers is to say, “Look, you should treat software as a capital asset.”</p>
<p class="normal">没有不需要持续维护和投资的资本资产。您应该预料到维护不断增长的可重用软件库会产生一些成本。这将使您的会计变得复杂，因为这意味着您不能仅向项目或此时激励创建该软件的客户收取构建软件的成本。你必须像看待资本资产一样来看待它。</p><p class="normal">And there is no such thing as a capital asset that doesn't require ongoing maintenance and investment. You should expect that there's going to be some cost associated with maintaining a growing library of reusable software. And that is going to complicate your accounting because it means you can't charge the cost of building a piece of software only to the project or the customer that's motivating the creation of that software at this time. You have to think of it the way you would think of a capital asset.</p>
<p class="normal"><b>Seibel：</b>就像建造新工厂一样。</p><p class="normal"><b>Seibel:</b> Like building a new factory.</p>
<p class="normal"><b>德语：</b>对。对象的很大一部分销售是因为设计良好的对象是可重复使用的，因此您在设计中投入的投资在以后的工作中会以更少的努力得到回报。</p><p class="normal"><b>Deutsch:</b> Right. A large part of the sell for objects was that well-designed objects are reusable, so the investment that you put into the design pays itself back in less effort going down the road.</p>
<p class="normal">我仍然相信这一点，但可能不像我那样坚定。这些天我看到被重复使用的东西不是很大就是很小。规模<a id="OEBPS/Chapter11.html.page_435"></a>我们在提升对象时谈论的重用是类和类组。除了在您拥有包含某种真实领域知识的类集合的情况下，我认为这种情况很少发生。</p><p class="normal">I still believe that, but probably not quite as strongly as I did. The things that I see getting reused these days are either very large or very small. The scale <a></a>of reuse that we were talking about when we were promoting objects was classes and groups of classes. Except in situations where you have a collection of classes that embody some kind of real domain knowledge, I don't see that happening much.</p>
<p class="normal">我看到被重用的要么是非常小的东西——单独的图标、单独的网页设计——要么是非常大的东西，比如整个语言或具有扩展架构的大型应用程序，如 Apache 或 Mozilla。</p><p class="normal">What I see getting reused is either very small things—individual icons, individual web page designs—or very big things like entire languages or large applications with extension architectures like Apache or Mozilla.</p>
<p class="normal"><b>Seibel：</b>所以您现在不太相信最初的对象重用宣传。是这个理论出了什么问题，还是因为历史原因没有成功？</p><p class="normal"><b>Seibel:</b> So you don't believe the original object-reuse pitch quite as strongly now. Was there something wrong with the theory, or has it just not worked out for historical reasons?</p>
<p class="normal"><b>Deutsch：</b>好吧，我不再称自己为计算机科学家的部分原因是我看到了大约 50 年的软件实践，并且在过去的 30 年里基本上没有太大的改进.</p><p class="normal"><b>Deutsch:</b> Well, part of the reason that I don't call myself a computer scientist any more is that I've seen software practice over a period of just about 50 years and it basically hasn't improved tremendously in about the last 30 years.</p>
<p class="normal">如果你看一下编程语言，我会提出一个强有力的例子，即编程语言在过去 40 年中没有在质量上得到改善。当今使用的编程语言没有一种在质量上优于 Simula-67。我知道这听起来有点好笑，但我是认真的。Java 并不比 Simula-67 好多少。</p><p class="normal">If you look at programming languages I would make a strong case that programming languages have not improved qualitatively in the last 40 years. There is no programming language in use today that is qualitatively better than Simula-67. I know that sounds kind of funny, but I really mean it. Java is not that much better than Simula-67.</p>
<p class="normal"><b>Seibel：</b> Smalltalk？</p><p class="normal"><b>Seibel:</b> Smalltalk?</p>
<p class="normal"><b>Deutsch：</b> Smalltalk 比 Simula-67 好一些。但是今天存在的 Smalltalk 本质上存在于 1976 年。我并不是说今天的语言并不比 30 年前存在的语言好。我今天使用的所有编程语言 Python，我认为比 30 年前可用的任何语言都要好得多。我比 Smalltalk 更喜欢它。</p><p class="normal"><b>Deutsch:</b> Smalltalk is somewhat better than Simula-67. But Smalltalk as it exists today essentially existed in 1976. I'm not saying that today's languages aren't better than the languages that existed 30 years ago. The language that I do all of my programming in today, Python, is, I think, a lot better than anything that was available 30 years ago. I like it better than Smalltalk.</p>
<p class="normal">我非常有意地使用<i>定性这个词。</i>今天我能想到的每一种大量使用的编程语言都有指针的概念。我不知道有什么方法可以使使用该基本概念构建的软件在质量上更好。</p><p class="normal">I use the word <i>qualitatively</i> very deliberately. Every programming language today that I can think of, that's in substantial use, has the concept of pointer. I don't know of any way to make software built using that fundamental concept qualitatively better.</p>
<p class="normal"><b>Seibel：</b>您将 Python 和 Java 风格的引用算作指针？</p><p class="normal"><b>Seibel:</b> And you're counting Python- and Java-style references as pointers?</p>
<p class="normal"><a id="OEBPS/Chapter11.html.page_436"></a><b>德语：</b>当然。是的。用 Python 和 Java 构建的程序——一旦你超过了某个相当小的规模——就会遇到所有相同的问题，除了你在 C 或 C++ 中遇到的存储损坏。</p><p class="normal"><a></a><b>Deutsch:</b> Absolutely. Yes. Programs built in Python and Java—once you get past a certain fairly small scale—have all the same problems except for storage corruption that you have in C or C++.</p>
<p class="normal">问题的本质是没有语言机制来理解或陈述或控制或推理系统中的信息共享和信息访问模式。传递指针和存储指针是本地化操作，但它们的结果是隐式创建此图。我什至不打算谈论多线程应用程序——即使在单线程应用程序中，您也有在程序的不同部分之间流动的数据。您有正在传播到程序的不同部分的引用。即使在设计最好的程序中，也有两种或三种或四种不同的复杂模式正在发生，但无法以实际限制小单元发生的方式来描述、推理或表征大单元。人们已经解决了这个问题。但我认为没有任何突破，我认为没有任何类型的被广泛接受或广泛使用的解决方案。</p><p class="normal">The essence of the problem is that there is no linguistic mechanism for understanding or stating or controlling or reasoning about patterns of information sharing and information access in the system. Passing a pointer and storing a pointer are localized operations, but their consequences are to implicitly create this graph. I'm not even going to talk about multithreaded applications—even in single-threaded applications you have data that's flowing between different parts of the program. You have references that are being propagated to different parts of the program. And even in the best-designed programs, you have these two or three or four different complex patterns of things that are going on and no way to describe or reason about or characterize large units in a way that actually constrains what happens in the small. People have taken runs at this problem. But I don't think there have been any breakthroughs and I don't think there have been any sort of widely accepted or widely used solutions.</p>
<p class="normal"><b>Seibel：</b>它们可能没有被广泛使用，但是纯函数式语言呢？</p><p class="normal"><b>Seibel:</b> They aren't, perhaps, widely used, but what about pure functional languages?</p>
<p class="normal"><b>Deutsch：</b>是的，纯函数式语言有一系列不同的问题，但它们肯定能解决这个棘手的问题。</p><p class="normal"><b>Deutsch:</b> Yes, pure functional languages have a different set of problems, but they certainly cut through that Gordian knot.</p>
<p class="normal">时不时地，我会感到设计一种编程语言的诱惑，但后来我只是躺下，直到它消失。但是，如果我屈服于这种诱惑，那么在只讨论值而没有指针概念的功能部分与讨论共享、引用和控制模式的某种不同领域之间会有一个非常基本的分歧.</p><p class="normal">Every now and then I feel a temptation to design a programming language but then I just lie down until it goes away. But if I were to give in to that temptation, it would have a pretty fundamental cleavage between a functional part that talked only about values and had no concept of pointer and a different sphere of some kind that talked about patterns of sharing and reference and control.</p>
<p class="normal">作为一个编译器和解释器的人，我可以想出很多方法来实现这样一种不涉及一直复制大数组的语言。但是职能人员在这方面远远领先于我。有很多聪明人一直在研究 Haskell 和类似的语言。</p><p class="normal">Being a compiler and interpreter guy, I can think of lots of ways of implementing a language like that that doesn't involve copying around big arrays all the time. But the functional people are way ahead of me on that. There are a lot of smart people who've been working on Haskell and similar languages.</p>
<p class="normal"><a id="OEBPS/Chapter11.html.page_437"></a><b>Seibel：</b> Haskell 的人不会回来说，“是的，那是我们的 monad，它明显区分的方式是在类型系统中？”</p><p class="normal"><a></a><b>Seibel:</b> Wouldn't the Haskell guys come back and say, “Yes, that's our monads and the way that it's clearly differentiated is in the type system?”</p>
<p class="normal"><b>Deutsch：</b>你知道，我从来没有理解过 Haskell monads。我想我在 ML 停止了跟踪函数式语言。</p><p class="normal"><b>Deutsch:</b> You know, I have never understood Haskell monads. I think I stopped tracking functional languages at ML.</p>
<p class="normal">如果您看一下 E——这不是任何人都知道要谈论的语言——它就是这种基于非常强大的能力概念的语言。它与休伊特的演员语言有关，也与基于能力的操作系统有关。它具有端口或通信通道，作为两个对象之间的基本连接，其想法是连接的任何一端都不知道连接的另一端是什么。所以这与指针非常不同，指针是单向的，持有指针的实体非常清楚指针的另一端是什么。它基于非常强的不透明度。</p><p class="normal">If you look at E—this is not a language that anyone knows about to speak of—it's this language which is based on a very strong notion of capability. It's related to Hewitt's actor languages and it's related to capability-based operating systems. It has ports, or communication channels, as the fundamental connection between two objects, the idea being that neither end of the connection knows what the other end of the connection is. So this is very different from a pointer, which is uni-directional and where the entity that holds the pointer has a pretty strong idea what's at the other end of it. It's based on very strong opacity.</p>
<p class="normal">我的那种模糊的一阶想法是，你有一种语言，你可以在其中进行功能计算，但你没有共享对象。您拥有的是某种形式的序列化端口。每当你想和你只知道参考的东西交谈时，你知道无论外面的东西是什么，它都是一种将要处理多种通信来源的东西，因此它是语言的基本性质的一部分必须期望序列化或仲裁或其他东西。没有属性访问的概念，当然也没有存储到属性中的概念。</p><p class="normal">My sort of fuzzy first-order idea is that you have a language in which you have functional computations and you do not have sharing of objects. What you have is some form of serialized ports. Whenever you want to talk to something that you only know by reference, it's part of the basic nature of the language that you are aware that whatever that thing out there is, it's something that's going to be dealing with multiple sources of communications and therefore it has to be expected to serialize or arbitrate or something. There's no concept of attribute access and certainly no concept of storing into an attribute.</p>
<p class="normal">有些语言的 API 不透明，因此实现可以保持不变性；它仍然没有告诉您有关更大的通信模式的任何信息。例如，一种常见的模式是，您有一个对象，将其交给某个第三方，您告诉该第三方对其执行某些操作，然后在某个时候您要求返回该对象。这就是分享的模式。你，调用者，可能从来没有真正放弃所有指向你传递的对象的指针。但是您同意自己不要通过该指针进行任何引用，直到第三方完成您要求他们做的任何事情。</p><p class="normal">There are languages in which you have opaque APIs so the implementations can maintain invariants; it still doesn't tell you anything about the larger patterns of communication. For example, one common pattern is, you have an object, you hand it off to some third party, you tell that third party to do certain things to it, and then at some point you ask for that object back. That's a pattern of sharing. You, the caller, may never have actually given up all pointers to the object that you handed off. But you agree with yourself not to make any references through that pointer until that third party has done whatever you asked them to.</p>
<p class="normal">这是构建程序模式的一个非常简单的示例，如果有一种方法可以用语言表达它，将帮助人们确保他们的代码符合他们的意图。</p><p class="normal">This is a very simple example of a pattern of structuring a program that, if there were a way to express it linguistically, would help people ensure that their code was conformant with their intentions.</p>
<p class="normal"><a id="OEBPS/Chapter11.html.page_438"></a>也许我没有真正着手设计语言的最大原因是我认为我没有足够的洞察力来知道如何在足够高的水平上以足够可组合的方式描述共享模式和通信模式把它拉下来的方法。但我认为这就是为什么今天构建软件比 30 年前好不了多少。</p><p class="normal"><a></a>Maybe the biggest reason why I haven't actually undertaken this effort to design a language is that I don't think I have enough insight to know how to describe patterns of sharing and patterns of communication at a high enough level and in a composable enough way to pull it off. But I think that is why constructing software today is so little better than it was 30 years ago.</p>
<p class="normal">我的博士论文是关于<i>程序正确性</i>的证明。我不再使用那个词了。我要说的是，您想让您的开发系统做尽可能多的工作，让您相信代码可以按照您的预期进行。</p><p class="normal">My PhD thesis was about proofs of <i>program correctness</i>. I don't use that term anymore. What I say is you want to have your development system do as much work as possible towards giving you confidence that the code does what you intend it to do.</p>
<p class="normal">程序正确性的旧观念是，这些断言是您以一种可根据代码本身进行机械检查的方式表达您希望代码执行的操作。这种方法存在很多问题。我现在认为，要使软件更可能执行我们预期的操作，途径不是通过断言或归纳断言，而是通过更好、更强大、更深入的声明性符号。</p><p class="normal">The old idea of program correctness was that there were these assertions that were your expressions of what you intend the code to do in a way that was mechanically checkable against the code itself. There were lots of problems with that approach. I now think that the path to software that's more likely to do what we intend it to do lies not through assertions, or inductive assertions, but lies through better, more powerful, deeper declarative notations.</p>
<p class="normal">Jim Morris 是我最喜欢的计算机警句创始人之一，他曾经说过类型检查器只是尼安德特人的正确性证明者。如果要有突破，那就是我认为它来自的地方——来自更强大的方式，以声明的方式谈论我们的程序打算如何构建以及我们的程序打算做什么。</p><p class="normal">Jim Morris, who's one of my favorite originators of computer epigrams, once said that a type checker is just a Neanderthal correctness-prover. If there's going to be a breakthrough, that's where I see it coming from—from more powerful ways of talking declaratively about how our programs are intended to be structured and what our programs are intended to do.</p>
<p class="normal"><b>Seibel：</b>所以，例如，你可以以某种方式表达这个概念，“我正在将这个对象的引用传递给另一个子系统，它会暂时冻结它，我不会用它做任何事情直到我把它拿回来。”</p><p class="normal"><b>Seibel:</b> So, for instance, you could somehow express the notion, “I'm passing a reference to this object over to this other subsystem, which is going to frob it for a while and I'm not going to do anything with it until I get it back.”</p>
<p class="normal"><b>德语：</b>是的。20 世纪 90 年代初我在 Sun 的时候，Sun 正在做一些实验性的工作，研究一种具有与它的概念相似的语言。Dave Gifford 在麻省理工学院对一种称为 FX 的语言进行了一系列研究，该语言还试图更明确地区分计算的功能部分和非功能部分，并更明确地说明指针从某处到某处。</p><p class="normal"><b>Deutsch:</b> Yes. There was some experimental work being done at Sun when I was there in the early '90s on a language that had a concept similar to that in it. And there was a bunch of research done at MIT by Dave Gifford on a language called FX that also tried to be more explicit about the distinction between functional and nonfunctional parts of a computation and to be more explicit about what it meant when a pointer went from somewhere to somewhere.</p>
<p class="normal"><a id="OEBPS/Chapter11.html.page_439"></a>但我觉得所有这些都是从一个相当低的层面来看待这个问题。如果要有突破使像 Windows Vista 这样的灾难变得不可能或不必要，我们只需要新的方式来思考什么是程序以及如何将它们组合在一起。</p><p class="normal"><a></a>But I feel like all of this is looking at the issue from a fairly low level. If there are going to be breakthroughs that make it either impossible or unnecessary to build catastrophes like Windows Vista, we will just need new ways of thinking about what programs are and how to put them together.</p>
<p class="normal"><b>Seibel：</b>所以，尽管它在质量上并不比 Smalltalk 好，但你仍然更喜欢 Python。</p><p class="normal"><b>Seibel:</b> So, despite it not being qualitatively better than Smalltalk, you still like Python better.</p>
<p class="normal"><b>德语：</b>我知道。有几个原因。对于 Python，关于什么是程序、运行程序意味着什么以及成为程序的一部分意味着什么，都有一个非常清晰的故事。有一个模块的概念，模块基本上声明了它们需要从其他模块获得的信息。因此，可以开发一个模块或一组模块并与其他人共享它们，而其他人可以一起来看看这些模块，并且非常准确地知道它们依赖什么并知道它们的边界是什么。</p><p class="normal"><b>Deutsch:</b> I do. There are several reasons. With Python there's a very clear story of what is a program and what it means to run a program and what it means to be part of a program. There's a concept of module, and modules declare basically what information they need from other modules. So it's possible to develop a module or a group of modules and share them with other people and those other people can come along and look at those modules and know pretty much exactly what they depend on and know what their boundaries are.</p>
<p class="normal">在 Smalltalk 中，这样做很尴尬——如果您在 Smalltalk 中以图像模式进行开发，那么程序本身永远不会是一个实体。VisualWorks，也就是 ParcPlace Smalltalk，有三四个不同的概念来说明如何使事物比单个类更大，并且它们随着时间的推移而改变并且它们并没有得到开发工具的很好支持，至少在一种非常直观的方式。几乎没有什么机制可以使什么取决于什么变得清晰、明确和机器可处理。所以如果你在图像模式下开发，除了整个图像之外你不能与任何人分享任何东西。</p><p class="normal">In Smalltalk it is awkward to do this—if you develop in Smalltalk in the image mode, there never is such a thing as the program as an entity in itself. VisualWorks, which is the ParcPlace Smalltalk, has three or four different concepts of how to make things larger than a single class, and they've changed over time and they're not supported all that well by the development tools, at least not in a very visual way. There's little machinery for making it clear and explicit and machine-processable what depends on what. So if you're developing in the image mode, you can't share anything with anybody other than the whole image.</p>
<p class="normal">如果你做所谓的<i>归档</i>——你以文本形式写出程序——你绝对没有办法知道你是否可以再次读回那个程序并让它回来做同样的事情，因为状态图像的一部分不一定是通过读取一组源代码产生的，或者可以产生的。您可能在工作区中做了任意事情；您可能拥有静态变量，其值已随时间修改。你只是不知道。你不能可靠地围绕任何东西画线。</p><p class="normal">If you do what's called <i>filing out</i>—you write out the program in a textual form—you have absolutely no way of knowing whether you can read that program back in again and have it come back and do the same thing that it does because the state of the image is not necessarily one that was produced, or that can be produced, by reading in a set of source code. You might have done arbitrary things in a workspace; you might have static variables whose values have been modified over time. You just don't know. You can't reliably draw lines around anything.</p>
<p class="normal">我在 VisualWorks 开发人员名单上，我看到一遍又一遍地出现的东西是在不使用图像概念的语言中不可能发生的东西。图像概念就像<a id="OEBPS/Chapter11.html.page_440"></a>快速成型，快速开发的世界。这对于永远不会脱离那个人的手的单人项目来说非常棒。如果你想让软件成为一种资产，那就太糟糕了；如果您想与其他人共享软件。所以我认为这是 Smalltalk 开发方法的真正弱点，也是一个严重的弱点。</p><p class="normal">I'm on the VisualWorks developers' list and the stuff that I see coming up over and over again is stuff that cannot happen in languages that don't use the image concept. The image concept is like a number of other things in the <a></a>rapid-prototyping, rapid-development world. It's wonderful for single-person projects that never go outside that person's hands. It's awful if you want software to become an asset; if you want to share software with other people. So I think that's the real weakness of the Smalltalk development approach and a serious one.</p>
<p class="normal">我喜欢 Python 的第二个原因是——也许这就是我的大脑多年来发生的变化——我不能像以前那样在脑海中保留那么多东西了。对我来说，让东西摆在我面前更重要。因此，在 Smalltalk 中，您实际上不能一次在屏幕上放置多个方法，这一事实让我抓狂。就我而言，我使用 Emacs 编辑 Python 程序是一个优势，因为我一次可以看到超过 10 行的内容。</p><p class="normal">The second reason I like Python is that—and maybe this is just the way my brain has changed over the years—I can't keep as much stuff in my head as I used to. It's more important for me to have stuff in front of my face. So the fact that in Smalltalk you effectively cannot put more than one method on the screen at a time drives me nuts. As far as I'm concerned the fact that I edit Python programs with Emacs is an advantage because I can see more than ten lines' worth at a time.</p>
<p class="normal">我已经和我的几个仍在 VisualWorks 工作的伙伴讨论了对象引擎的开源，即时代码生成器，即使是我写的，我仍然认为它比很多外面有什么。天哪，我们这里有 Smalltalk，它拥有非常棒的代码生成机制，现在已经非常成熟——它已有 20 年的历史，而且非常可靠。它是一个相对简单、相对可重定目标、非常高效的即时代码生成器，旨在与非类型声明语言一起很好地工作。另一方面，这里是 Python，这是一种美妙的语言，拥有这些美妙的库和缓慢的实现。如果我们能把两者结合起来不是很好吗？</p><p class="normal">I've talked with the few of my buddies that are still working at VisualWorks about open-sourcing the object engine, the just-in-time code generator, which, even though I wrote it, I still think is better than a lot of what's out there. Gosh, here we have Smalltalk, which has this really great code-generation machinery, which is now very mature—it's about 20 years old and it's extremely reliable. It's a relatively simple, relatively retargetable, quite efficient just-in-time code generator that's designed to work really well with non type-declared languages. On the other hand, here's Python, which is this wonderful language with these wonderful libraries and a slow-as-mud implementation. Wouldn't it be nice if we could bring the two together?</p>
<p class="normal"><b>Seibel：</b>在 Smalltalk 中重新实现 Python 是不是你的 pycore 项目背后的想法？</p><p class="normal"><b>Seibel:</b> Wasn't that sort of the idea behind your pycore project, to reimplement Python in Smalltalk?</p>
<p class="normal"><b>德语：</b>是的。我明白了这一点，我意识到这比我想象的要实际工作要多得多。Python 对象模型和 Smalltalk 对象模型之间的不匹配已经够糟糕了，以至于有些事情不能简单地一对一映射，而必须通过额外级别的方法调用以及这个、那个和另一个来完成。</p><p class="normal"><b>Deutsch:</b> It was. I got it to the point where I realized it would be a lot more work than I thought to actually make it work. The mismatches between the Python object model and the Smalltalk object model were bad enough that there were things that could not be simply mapped one-for-one but had to be done through extra levels of method calls and this, that, and the other.</p>
<p class="normal">即便如此，对于刚刚用 Python 编写的代码，具有即时代码生成功能的 Smalltalk 仍处于与 C 代码解释器相同的范围内。所以我的想法是，如果有可能<a id="OEBPS/Chapter11.html.page_441"></a>开源 Smalltalk 代码生成器，采用该代码生成器并使其适应 Python 对象模型和 Python 数据表示，这并不是什么大问题。</p><p class="normal">Even at that, Smalltalk with just-in-time code generation was, for code that was just written in Python, still in the same range as the C-coded interpreter. So the idea that I had in mind was that if it had been possible to <a></a>open-source the Smalltalk code generator, taking that code generator and adapting it to work well with the Python object model and the Python data representation would not have been a huge deal.</p>
<p class="normal">但这是不可能的。Eliot Miranda 可能是我与 VisualWorks 相关的最激进的伙伴，他尝试过，Cincom 说：“不，这是一项战略资产，我们不能将其开源。”</p><p class="normal">But it can't be done. Eliot Miranda, who's probably the most radical of my buddies associated with VisualWorks, tried, and Cincom said, “Nope, it's a strategic asset, we can't open-source it.”</p>
<p class="normal"><b>Seibel：</b>嗯，你就是说软件应该被视为资本资产的人。</p><p class="normal"><b>Seibel:</b> Well, you're the guy who says software should be treated as a capital asset.</p>
<p class="normal"><b>Deutsch：</b>但这并不一定意味着防止其他人使用它始终是您的最佳策略。</p><p class="normal"><b>Deutsch:</b> But that doesn't necessarily mean that it's always your best strategy to prevent other people from using it.</p>
<p class="normal"><b>Seibel：</b>所以除了从前是 Smalltalker 之外，您还是早期的 Lisp 黑客。但是你也不再使用它了。</p><p class="normal"><b>Seibel:</b> So in addition to being a Smalltalker from way back, you were also an early Lisp hacker. But you're not using it any more either.</p>
<p class="normal"><b>Deutsch：</b>我的博士论文是一个 600 页的 Lisp 程序。我是来自 PDP-1 Lisp、Alto Lisp、Byte Lisp 和 Interlisp 的非常重任的 Lisp 黑客。我不再使用 Lisp 编程的原因是：我无法忍受语法。语法很重要，这只是生活中的一个事实。</p><p class="normal"><b>Deutsch:</b> My PhD thesis was a 600-page Lisp program. I'm a very heavy-duty Lisp hacker from PDP-1 Lisp, Alto Lisp, Byte Lisp, and Interlisp. The reason I don't program in Lisp anymore: I can't stand the syntax. It's just a fact of life that syntax matters.</p>
<p class="normal">语言系统站在三脚架上。有语言，有库，还有工具。一种语言的成功取决于这三者之间复杂的相互作用。Python 拥有伟大的语言、伟大的库，但几乎没有任何工具。</p><p class="normal">Language systems stand on a tripod. There's the language, there's the libraries, and there are the tools. And how successful a language is depends on a complex interaction between those three things. Python has a great language, great libraries, and hardly any tools.</p>
<p class="normal"><b>Seibel：</b> “工具”在哪里包括语言的实际实现？</p><p class="normal"><b>Seibel:</b> Where “tools” includes the actual implementation of the language?</p>
<p class="normal"><b>Deutsch：</b>当然，让我们把它们放在那里。Lisp 作为一种语言具有极好的灵活性，但就其可读性而言，用户价值真的很差。我不知道这些天 Common Lisp 库的状态如何，但我认为语法很重要。</p><p class="normal"><b>Deutsch:</b> Sure, let's put them there. Lisp as a language has fabulous properties of flexibility but really poor user values in terms of its readability. I don't know what the status is of Common Lisp libraries these days, but I think syntax matters a lot.</p>
<p class="normal"><b>Seibel：</b>有些人喜欢 Lisp 语法，有些人受不了。这是为什么？</p><p class="normal"><b>Seibel:</b> Some people love Lisp syntax and some can't stand it. Why is that?</p>
<p class="normal"><b>Deutsch：</b>好吧，我不能代表任何人。但是我可以告诉你为什么我不想再使用 Lisp 语法了。有两个原因。第一，我之前提到过，我越老，对我来说，前面每平方英寸的信息密度就越重要<a id="OEBPS/Chapter11.html.page_442"></a>我的脸很高。中缀语言每平方英寸的信息密度高于 Lisp。</p><p class="normal"><b>Deutsch:</b> Well, I can't speak for anyone else. But I can tell you why I don't want to work with Lisp syntax anymore. There are two reasons. Number one, and I alluded to this earlier, is that the older I've gotten, the more important it is to me that the density of information per square inch in front <a></a>of my face is high. The density of information per square inch in infix languages is higher than in Lisp.</p>
<p class="normal"><b>Seibel：</b>但实际上几乎所有语言都是前缀，除了少数算术运算符。</p><p class="normal"><b>Seibel:</b> But almost all languages are, in fact, prefix, except for a small handful of arithmetic operators.</p>
<p class="normal"><b>Deutsch：</b>事实并非如此。例如，在 Python 中，列表、元组和字典构造就不是这样。这是通过包围完成的。字符串格式化完成中缀。</p><p class="normal"><b>Deutsch:</b> That's not actually true. In Python, for example, it's not true for list, tuple, and dictionary construction. That's done with bracketing. String formatting is done infix.</p>
<p class="normal"><b>Seibel：</b>因为它在 Common Lisp 中与<code>FORMAT</code>.</p><p class="normal"><b>Seibel:</b> As it is in Common Lisp with <code>FORMAT</code>.</p>
<p class="normal"><b>德语：</b>好的，对。但是没有完成的事情是固定的；常见的是循环和条件，不是前缀。它们是通过交替使用关键字及其适用对象来完成的。在这方面，它们实际上比 Lisp 更冗长。但这让我想到了另一半，我更喜欢 Python 语法的另一个原因是 Lisp 在词汇上非常单调。</p><p class="normal"><b>Deutsch:</b> OK, right. But the things that aren't done infix; the common ones, being loops and conditionals, are not prefix. They're done by alternating keywords and what it is they apply to. In that respect they are actually more verbose than Lisp. But that brings me to the other half, the other reason why I like Python syntax better, which is that Lisp is lexically pretty monotonous.</p>
<p class="normal"><b>Seibel：</b>我想 Larry Wall 把它描述成一碗里面有指甲屑的燕麦粥。</p><p class="normal"><b>Seibel:</b> I think Larry Wall described it as a bowl of oatmeal with fingernail clippings in it.</p>
<p class="normal"><b>Deutsch：</b>嗯，我对 Perl 的描述看起来像是出自狗的错误一端。我认为 Larry Wall 在谈论语言设计时很有勇气——Perl 作为一种语言是一种令人厌恶的语言。但是我们不要去那里。</p><p class="normal"><b>Deutsch:</b> Well, my description of Perl is something that looks like it came out of the wrong end of a dog. I think Larry Wall has a lot of nerve talking about language design—Perl is an abomination as a language. But let's not go there.</p>
<p class="normal">如果您查看一段 Lisp 代码，为了提取其含义，​​您必须做两件事，而使用 Python 这样的语言则不必这样做。</p><p class="normal">If you look at a piece of Lisp code, in order to extract its meaning there are two things that you have to do that you don't have to do in a language like Python.</p>
<p class="normal">首先，你必须过滤掉所有那些该死的括号。这不是智力工作，但你的大脑确实在多个层面上理解，我认为它做的第一件事就是符号识别。所以它会识别所有这些括号符号，然后你必须在更高级别过滤掉它们。所以你让大脑的符号识别机制做额外的工作。</p><p class="normal">First you have to filter out all those damn parentheses. It's not intellectual work but your brain does understanding at multiple levels and I think the first thing it does is symbol recognition. So it's going to recognize all those parenthesis symbols and then you have to filter them out at a higher level. So you're making the brain symbol-recognition mechanism do extra work.</p>
<p class="normal">现在可能 Lisp 中的算术函数实际上是用它们的通用名称拼写的，我的意思是，你写加号和乘号等等。</p><p class="normal">These days it may be that the arithmetic functions in Lisp are actually spelled with their common names, I mean, you write plus sign and multiply sign and so forth.</p>
<p class="normal"><a id="OEBPS/Chapter11.html.page_443"></a><b>塞贝尔：</b>是的。</p><p class="normal"><a></a><b>Seibel:</b> Yes.</p>
<p class="normal"><b>Deutsch：</b>好的，所以我要说的第二件事你必须做，你实际上不必再做，那就是使用标记识别而不是符号识别来理解那些东西，这也发生在你的更高层次上脑。</p><p class="normal"><b>Deutsch:</b> Alright, so the second thing I was going to say you have to do, you don't actually have to do anymore, which is understanding those things using token recognition rather than symbol recognition, which also happens at a higher level in your brain.</p>
<p class="normal">然后是第三件事，这可能看起来是一件小事，但我认为不是。也就是说，在中缀世界中，每个运算符都紧挨着它的两个操作数。在前缀世界中它不是。你必须做更多的工作才能看到另一个操作数。你知道，这些听起来都是小事。但对我来说最大的是每平方英寸的信息密度。</p><p class="normal">Then there's a third thing, which may seem like a small thing but I don't think it is. Which is that in an infix world, every operator is next to both of its operands. In a prefix world it isn't. You have to do more work to see the other operand. You know, these all sound like small things. But to me the biggest one is the density of information per square inch.</p>
<p class="normal"><b>Seibel：</b>但是 Lisp 的基本语法，即词法语法，非常接近程序的抽象语法树这一事实确实允许该语言支持宏。宏允许您创建句法抽象，这是压缩您正在查看的内容的最佳方式。</p><p class="normal"><b>Seibel:</b> But the fact that Lisp's basic syntax, the lexical syntax, is pretty close to the abstract syntax tree of the program does permit the language to support macros. And macros allow you to create syntactic abstraction, which is the best way to compress what you're looking at.</p>
<p class="normal"><b>德语：</b>是的，是的。</p><p class="normal"><b>Deutsch:</b> Yes, it is.</p>
<p class="normal"><b>Seibel：</b>在我的 Lisp 书中，我写了一个关于解析二进制文件的章节，以在 MP3 文件中使用 ID3 标签为例。这样做的好处是，您可以在采用规范（在本例中为 ID3 规范）的地方使用这种编程风格，将其括起来，然后使其成为您想要的代码。</p><p class="normal"><b>Seibel:</b> In my Lisp book I wrote a chapter about parsing binary files, using ID3 tags in MP3 files as an example. And the nice thing about that is you can use this style of programming where you take the specification—in this case the ID3 spec—put parentheses around it, and then make that be the code you want.</p>
<p class="normal"><b>德语：</b>对。</p><p class="normal"><b>Deutsch:</b> Right.</p>
<p class="normal"><b>Seibel：</b>所以我对如何解析 ID3 标头的描述基本上与 ID3 标头的规范一样多。</p><p class="normal"><b>Seibel:</b> So my description of how to parse an ID3 header is essentially exactly as many tokens as the specification for an ID3 header.</p>
<p class="normal"><b>Deutsch：</b>嗯，有趣的是我在 Python 中做了几乎完全相同的事情。我遇到过一种情况，我不得不解析非常复杂的文件格式。它是一种更复杂的音乐文件格式。因此，在 Python 中，我编写了一组提供解析和漂亮打印的类。</p><p class="normal"><b>Deutsch:</b> Well, the interesting thing is I did almost exactly the same thing in Python. I had a situation where I had to parse really quite a complex file format. It was one of the more complex music file formats. So in Python I wrote a set of classes that provided both parsing and pretty printing.</p>
<p class="normal">类构造和方法名的对应关系都在一个公共的超类中完成。所以这一切都是面向对象完成的；您不需要宏工具。它看起来不如您可能采用的其他方式那么好，但是您得到的东西大约与<a id="OEBPS/Chapter11.html.page_444"></a>可读为相应的 Lisp 宏。在 Lisp 中，您可以用更简洁、更通用的方式做一些事情。我不同意这一点。</p><p class="normal">The correspondence between the class construction and the method name is all done in a common superclass. So this is all done object-oriented; you don't need a macro facility. It doesn't look quite as nice as some other way you might do it, but what you get is something that is approximately as <a></a>readable as the corresponding Lisp macros. There are some things that you can do in a cleaner and more general way in Lisp. I don't disagree with that.</p>
<p class="normal">如果您查看 Ghostscript 的代码，就会发现 Ghostscript 全部是用 C 语言编写的。但它在 C 语言中增加了数百个预处理器宏。因此，实际上，为了编写将成为 Ghostscript 一部分的代码，您不仅必须学习 C，还必须学习相当于扩展语言的内容。所以你可以在 C 中做类似的事情；你必须在必要时去做。它发生在每种语言中。</p><p class="normal">If you look at the code for Ghostscript, Ghostscript is all written in C. But it's C augmented with hundreds of preprocessor macros. So in effect, in order to write code that's going to become part of Ghostscript, you have to learn not only C, but you have to learn what amounts to an extended language. So you can do things like that in C; you do them when you have to. It happens in every language.</p>
<p class="normal">在 Python 中，我有自己的 Python 扩展。它们不是句法扩展；它们是类，它们是混入——其中许多是混入，它们增强了大多数人认为的语言语义。你在 Python 中获得了一组用于执行此操作的工具，你在 Lisp 中获得了一组不同的工具。有些人更喜欢一个，有些人更喜欢另一个。</p><p class="normal">In Python I have my own what amount to little extensions to Python. They're not syntactic extensions; they're classes, they're mixins—many of them are mixins that augment what most people think of as the semantics of the language. You get one set of facilities for doing that in Python, you get a different set in Lisp. Some people like one better, some people like the other better.</p>
<p class="normal"><b>Seibel：</b>是什么让你从编程转向作曲？</p><p class="normal"><b>Seibel:</b> What was it that made you move from programming to composing?</p>
<p class="normal"><b>Deutsch：</b>我基本上在 Ghostscript 上筋疲力尽。从 1986 年开始，Ghostscript 是我的主要技术兴趣之一，它几乎是我在 1992–93 年左右开始的唯一主要技术项目。大致到 1998 年，我开始感到筋疲力尽，因为我不仅在做所有的技术工作，而且还在做所有的工作。我也在做所有的支持，所有的管理。我是一个人的企业，它已经变得太多了。我雇了一个人基本上建立了一个企业，他开始招聘工程师。</p><p class="normal"><b>Deutsch:</b> I basically burned out on Ghostscript. Ghostscript was one of my primary technical interests starting in 1986 and it was pretty much my only major technical project starting somewhere around 1992–'93. By 1998, roughly, I was starting to feel burned out because I was not only doing all the technical work; I was also doing all the support, all the administration. I was a one-person business, and it had gotten to be too much. I hired someone to basically build up a business, and he started hiring engineers.</p>
<p class="normal">然后又花了两年时间才找到合适的人来代替我。然后又花了两年时间才真正移交了所有东西。到 2002 年，我已经拥有了它。我不想再看到 Ghostscript。</p><p class="normal">Then it took another two years to find the right person to replace me. And then it took another two years after that to get everything really handed over. By 2002, I had had it. I didn't want to ever see Ghostscript again.</p>
<p class="normal">所以我说，“好吧，我会花六个月的时间来减压，看看我下一步想做什么。” 那时我 55 岁；我没有觉得特别老。我想如果我想做的话，我还有一个重要的项目要做。于是，我开始四处寻找。</p><p class="normal">So I said, “OK, I'll take six months to decompress and look around for what I want to do next.” At that point I was 55; I didn't feel particularly old. I figured I had one more major project left in me, if I wanted to do one. So, I started looking around.</p>
<p class="normal">我感兴趣的一个项目是我在施乐时代的老朋友 J. Strother Moore II，他现在是，或者曾经是德克萨斯大学奥斯汀分校计算机科学系的系主任。他伟大的事业<a id="OEBPS/Chapter11.html.page_445"></a>成就是他和 SRI 的一个名叫 Bob Boyer 的人建立了一个非常棒的定理证明器。他围绕这个软件建立了一个完整的团队，并建立了这些关于特定领域的大型定理和引理库。</p><p class="normal">The one project that kind of interested me was an old buddy of mine from the Xerox days, J. Strother Moore II, is, or was, the head of the computer-science department at the University of Texas at Austin. His great career <a></a>achievement was that he and a guy at SRI named Bob Boyer built a really kick-ass theorem prover. And he built up a whole group around this piece of software and built up these big libraries of theorems and lemmas about particular domain areas.</p>
<p class="normal">所以他们有一个蓬勃发展的小组进行定理证明，这是我博士论文的主题，我一直很感兴趣。他们在 AMD CPU 的运算单元上取得了这个惊人的结果。所以我想，“嘿，这是一个有很多正确特征的团体：他们正在做我一直感兴趣的事情；他们由一个我认识并喜欢的人经营；他们的技术是基于 Lisp 的。这对我来说真的很合意。”</p><p class="normal">So they had this thriving little group doing theorem proving, which was the subject of my PhD thesis and which had always interested me. And they had this amazing result on the arithmetic unit of the AMD CPU. So I thought, “Hey, this is a group that has a lot of right characteristics: they're doing something that I've always been interested in; they're run by a guy that I know and like; their technology is Lisp-based. It'll be really congenial to me.”</p>
<p class="normal">所以，我去那里做了一个演讲，如果有的话，定理证明如何帮助提高 Ghostscript 的可靠性？到那时，我们在 Ghostscript 的错误跟踪器方面已经有了很大的历史。所以我随机挑选了 20 个 bug，我观察了每一个，然后说，“好吧，要让定理证明技术有助于发现或预防这个问题，必须发生什么？还有什么必须到位的？</p><p class="normal">So, I went down there and gave a talk about how, if at all, could theorem proving have helped improve the reliability of Ghostscript? By that time, we had a big history in the bug tracker for Ghostscript. So I picked 20 bugs, more or less at random, and I looked at each one and I said, “OK, for theorem-proving technology to have been helpful in finding or preventing this problem, what would have had to happen? What else would have had to be in place?”</p>
<p class="normal">我得出的结论是，定理证明技术可能不会有太大帮助，因为在它可能有的少数地方，形式化软件应该做的事情将是一项艰巨的工作。</p><p class="normal">The conclusion I came to is that theorem-proving technology probably wouldn't have helped a whole lot because in the few places where it could have, formalizing what it was that the software was supposed to do would've been a Herculean job.</p>
<p class="normal">这就是为什么定理证明技术在我看来基本上无法成为提高软件可靠性的实用技术的原因。将你想要建立的属性形式化实在是太难了。</p><p class="normal">That's the reason why theorem-proving technology basically has—in my opinion—failed as a practical technology for improving software reliability. It's just too damn hard to formalize the properties that you want to establish.</p>
<p class="normal">所以我做了这个演讲并且很受欢迎。我和几个研究生聊了聊，和 J. 聊了一会儿，然后就走了。我心里想，“检查清单的项目看起来都不错。但我对此并不感到兴奋。”</p><p class="normal">So I gave this talk and it was pretty well received. I talked with a couple of the graduate students, talked with J. a little bit, and then I went away. I thought to myself, “The checklist items all look pretty good. But I'm just not excited about this.”</p>
<p class="normal">我有点乱来。多年来我一直在合唱。2003 年夏天，我们进行了一场巡回演出，实际上我们在意大利的老教堂里演唱了六场音乐会。那次旅行我的伙伴和我在一起，我们决定之后在欧洲呆两三个星期。</p><p class="normal">I was kind of flailing around. I've sung in a chorus for years. In the summer of 2003 we were on a tour where we actually sang six concerts in old churches in Italy. My partner was with me on that trip and we decided to stay in Europe for two or three weeks afterwards.</p>
<p class="normal"><a id="OEBPS/Chapter11.html.page_446"></a>我们去了维也纳，做了你们在维也纳做的事。旧的哈布斯堡王宫现在已被（其中的一部分）分成十个不同的小型专业博物馆。我在指南上看到有一个旧乐器博物馆。</p><p class="normal"><a></a>We went to Vienna and did the things you do in Vienna. The old Hapsburg Palace has now been divided—part of it—into ten different little specialized museums. I saw in the guidebook that there was a Museum of Old Musical Instruments.</p>
<p class="normal">我去了这个博物馆，它就在这个有着高天花板的老沙龙的长大厅里。它开始于，我不知道它们是否是新石器时代的，但是非常古老的乐器，它一直在发展。当然，他们的大部分乐器都来自西欧的最后几个世纪。我实际上并没有一路走下去；我就像最后一两个沙龙，我站在那里，这里有一架属于利奥波德莫扎特的钢琴。还有勃拉姆斯用来练习的钢琴。还有海顿家里的那架钢琴。</p><p class="normal">I went to this museum, and it's in this long hall of high-ceilinged old salons. And it starts with, I don't know whether they're Neolithic, but very old musical instruments, and it progresses through. Of course, most of their musical instruments are from the last couple of centuries in Western Europe. I didn't actually make it all the way through; I was like one or two salons from the end and I was standing there and here was a piano that had belonged to Leopold Mozart. And the piano that Brahms used for practicing. And the piano that Haydn had in his house.</p>
<p class="normal">我有一点顿悟，我之所以找不到另一个让我兴奋的软件项目，并不是因为我找不到项目。那是因为我不再对软件感到兴奋。尽管现在看起来很疯狂，但我最初进入软件行业的很多动机是我认为你可以通过这样做让世界变得更美好。我不再相信了。并不真地。不是以同样的方式。</p><p class="normal">And I had this little epiphany that the reason that I was having trouble finding another software project to get excited about was not that I was having trouble finding a project. It was that I wasn't excited about software anymore. As crazy as it may seem now, a lot of my motivation for going into software in the first place was that I thought you could actually make the world a better place by doing it. I don't believe that anymore. Not really. Not in the same way.</p>
<p class="normal">这道小小的闪电发生了，突然间我有一种感觉——好吧，不是让世界变得更好的方法，而是为世界做出可能持续数年以上的贡献的方法——做音乐。那一刻，我决定深吸一口气，离开我已经做了 50 年的事情。</p><p class="normal">This little lightning flash happened and all of a sudden I had the feeling that the way—well, not the way to change the world for the better, but the way to contribute something to the world that might last more than a few years was to do music. That was the moment when I decided that I was going to take a deep breath and walk away from what I'd been doing for 50 years.</p>
<p class="normal"><b>Seibel：</b>但你仍然在编程。</p><p class="normal"><b>Seibel:</b> But you do still program.</p>
<p class="normal"><b>Deutsch：</b>我情不自禁——我无法阻止自己想要以我认为有趣的方式做事。随着时间的推移，我已经完成了一堆这样或那样的小软件项目，但只有两个是我在过去几年中持续关注的。</p><p class="normal"><b>Deutsch:</b> I can't help myself—I can't keep myself from wanting to do things in ways that I think are fun and interesting. I've done a bunch of little software projects of one sort or another over time, but only two that I've paid ongoing attention to over the last several years.</p>
<p class="normal">一个是我的邮件服务器的垃圾邮件过滤技术。我不会说这很有趣，但它有一定的兴趣。根据我不时查看的日志，过滤器实际上正在启动——取决于<a id="OEBPS/Chapter11.html.page_447"></a>谁在任何给定时刻在军备竞赛中处于领先地位——大约在传入垃圾邮件的 80% 到 95% 之间。</p><p class="normal">One has been spam-filtering technology for my mail server. I wouldn't say it was fun but it had a certain amount of interest to it. Based on the logs that I look at every now and then, the filter is actually picking up—depending on <a></a>who's ahead in the arms race at any given moment—somewhere between 80 and 95 percent of the incoming spam.</p>
<p class="normal">我经常使用的另一个重要软件是乐谱编辑器。我这样做的原因是我已经对那里可用的东西进行了大量调查。我在朋友家用过几次 Finale。这很糟糕。那个系统的质量太差了，我什至不能告诉你。我有一份西贝柳斯的副本。实际上，我买了一台 Mac 笔记本电脑，主要是为了运行 Sibelius。并发现他们处理用户界面的方式，如果您没有 Num Lock 键，接下来将无法使用。Mac 笔记本电脑没有 Num Lock 键。用户界面还有一些我不喜欢的地方。所以，我决定自己动手。</p><p class="normal">The other substantial piece of software that I keep coming back to is a musical-score editor. And the reason that I do that is that I have done a fair amount of investigation of what's available out there. I used Finale at a friend's house a few times. It sucks. The quality of that system is so bad I can't even tell you. I got a copy of Sibelius. I actually got a Mac laptop primarily so that I could run Sibelius. And discovered that the way that they did the user interface, it is the next thing to unusable if you don't have a Num Lock key. Mac laptops do not have a Num Lock key. And there were some other things about the user interface that I didn't like. So, I decided to roll my own.</p>
<p class="normal">我经历了四种不同的架构，终于找到了我非常喜欢的一种。但这是一种有趣的学习经历。这是一个交互式应用程序，它又大又复杂，以至于确实会出现这些系统问题，这些界面问题。</p><p class="normal">I've been through four different architectures and I finally got one that I like pretty well. But it's been kind of an interesting learning experience. That's an interactive application that's large and complex enough that these system issues do come up, these issues of interfaces.</p>
<p class="normal">在经历了四种不同的架构之后，我最终得出了一个基于方程式编程的程序渲染端的架构——我认为这是迄今为止最难的部分。您根据方程式定义变量值，然后让实现决定何时评估它们。事实证明，这在 Python 中并不难做到。据我所知，至少还有两次。我喜欢我这样做的方式，因为它的样板最少。</p><p class="normal">After having gone through four different architectures I wound up with an architecture for the rendering side of the program—which I think is by far the hardest part—based on equational programming. You define variable values in terms of equations then you let the implementation decide when to evaluate them. Turns out that's not too hard to do in Python. It's been done at least two other times that I know of. I like the way I do it because it has the least boilerplate.</p>
<p class="normal">所以是的，所以我仍然会进行适量的编程，而且我仍然乐在其中。但这不<i>适合</i>任何人，如果我一次几个星期不编程，那也没关系。当那是我专业做的事情时，我总是想参与一个项目。现在，我想要始终处于中间的是至少一两个作品。</p><p class="normal">So yeah, so I still do a moderate amount of programming and I still have fun with it. But it's not <i>for</i> anybody and if I don't do programming for weeks at a time, that's OK. When that was what I did professionally, I always wanted to be in the middle of a project. Now, what I want to always be in the middle of is at least one or two compositions.</p>
<p class="normal"><b>Seibel：</b>你之前说过你认为你可以用软件让世界变得更美好。你认为那会如何发生？</p><p class="normal"><b>Seibel:</b> You said before that you thought you could make the world a better place with software. How did you think that was going to happen?</p>
<p class="normal"><b>Deutsch：</b>其中一部分与软件本身无关；只是看到我周围的任何事情做得不好总是冒犯我<a id="OEBPS/Chapter11.html.page_448"></a>强大，所以我认为我可以做得更好。孩子们就是这样想的。现在这一切看起来很梦幻。</p><p class="normal"><b>Deutsch:</b> Part of it had nothing to do with software per se; it's just that seeing anything around me that's being done badly has always offended me <a></a>mightily, so I thought I could do better. That's the way kids think. It all seems rather dreamlike now.</p>
<p class="normal">当然，在我开始编程的时候，甚至到 1980 年代，计算机技术确实与企业界联系在一起。我的个人政治观点非常反公司。我一直从事的计算工作就是今天我们所说的个人计算、交互式计算。我认为我的部分动机是认为如果你能让很多人掌握计算机的力量，它可能会提供一些对公司力量的平衡。</p><p class="normal">Certainly at the time that I started programming, and even up into the 1980s, computer technology was really associated with the corporate world. And my personal politics were quite anticorporate. The kind of computing that I've always worked on has been what today we would call personal computing, interactive computing. I think part of my motivation was the thought that if you could get computer power into the hands of a lot of people, that it might provide some counterweight to corporate power.</p>
<p class="normal">在我最疯狂的梦想中，我从来没有预测到互联网的发展。而且我从来没有预料到企业对互联网的影响力会随着时间的推移而改变。我原以为互联网天生就是不可控的，现在我不再这么想了。中国表明你可以非常有效地做到这一点。</p><p class="normal">I never in my wildest dreams would have predicted the evolution of the Internet. And I never would've predicted the degree to which corporate influence over the Internet has changed its character over time. I would've thought that the Internet was inherently uncontrollable, and I no longer think that. China shows that you can do it pretty effectively.</p>
<p class="normal">而且我认为，如果 Microsoft 打出正确的牌，他们很有可能锁定 Internet。我相信他们会很乐意，但我认为他们可能足够聪明，可以看到从他们所处的位置到有效控制互联网上使用的所有软件的途径。</p><p class="normal">And I think there's a good chance that if Microsoft plays its cards right, they will have a lock on the Internet. I'm sure they would love to, but I think they might be smart enough to see the path from where they are to having what effectively is control of essentially all the software that gets used on the Internet.</p>
<p class="normal">所以我对计算的未来并不是很乐观。老实说，这就是我不难离开的原因之一。我的意思是，我看到了一个完全被不道德的垄断者主宰的世界，我在其中看不到太多适合我的地方。</p><p class="normal">So I'm not really much of an optimist about the future of computing. To be perfectly honest, that's one of the reasons why it wasn't hard for me to get out. I mean, I saw a world that was completely dominated by an unethical monopolist, and I didn't see much of a place for me in it.</p>
</div>
</div></div>
<div id="OEBPS/Chapter12.html"><div>

<div class="booksection">
<p></p>
<h2 class="chapnum"><a id="OEBPS/Chapter12.html.ch12"></a><a id="OEBPS/Chapter12.html.page_449"></a><img src="data:image/jpg;base64,/9j/4AAQSkZJRgABAgEASABIAAD/7Q3qUGhvdG9zaG9wIDMuMAA4QklNA+0KUmVzb2x1dGlvbgAAAAAQAEgAAAABAAEASAAAAAEAAThCSU0EDRhGWCBHbG9iYWwgTGlnaHRpbmcgQW5nbGUAAAAABAAAAHg4QklNBBkSRlggR2xvYmFsIEFsdGl0dWRlAAAAAAQAAAAeOEJJTQPzC1ByaW50IEZsYWdzAAAACQAAAAAAAAAAAQA4QklNBAoOQ29weXJpZ2h0IEZsYWcAAAAAAQAAOEJJTScQFEphcGFuZXNlIFByaW50IEZsYWdzAAAAAAoAAQAAAAAAAAACOEJJTQP1F0NvbG9yIEhhbGZ0b25lIFNldHRpbmdzAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+BdDb2xvciBUcmFuc2ZlciBTZXR0aW5ncwAAAHAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAOEJJTQQAC0xheWVyIFN0YXRlAAAAAgABOEJJTQQCDExheWVyIEdyb3VwcwAAAAAEAAAAADhCSU0ECAZHdWlkZXMAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4NVVJMIG92ZXJyaWRlcwAAAAQAAAAAOEJJTQQaBlNsaWNlcwAAAAB1AAAABgAAAAAAAAAAAAAAlAAAANIAAAAKAFUAbgB0AGkAdABsAGUAZAAtADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAANIAAACUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhCSU0EERFJQ0MgVW50YWdnZWQgRmxhZwAAAAEBADhCSU0EFBdMYXllciBJRCBHZW5lcmF0b3IgQmFzZQAAAAQAAAACOEJJTQQMFU5ldyBXaW5kb3dzIFRodW1ibmFpbAAACg0AAAABAAAAcAAAAE8AAAFQAABnsAAACfEAGAAB/9j/4AAQSkZJRgABAgEASABI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" alt="图片"></h2><h2 class="chapnum"><a></a><a></a></h2>
<h2 class="chaptitle">肯·汤普森</h2><h2 class="chaptitle">Ken Thompson</h2>
<div class="sidebar">
<p class="normal"><i>Ken Thompson 是最初的大胡子 Unix 黑客。在他的职业生涯中，他一直致力于任何他感兴趣的事情，包括模拟计算、系统编程、正则表达式和计算机象棋。</i></p><p class="normal"><i>Ken Thompson is the original bearded Unix hacker. He has spent a career working on whatever he finds interesting, which has, at various times, included analog computing, systems programming, regular expressions, and computer chess.</i></p>
<p class="normal"><i>在贝尔实验室退出 MULTICS 后，Thompson 被聘为贝尔实验室的一名研究员，从事 MULTICS 项目，Thompson 继续与丹尼斯·里奇 (Dennis Ritchie) 一起发明 Unix，他完全希望为此而被解雇。他还发明了 B 编程语言，即丹尼斯·里奇 (Dennis Ritchie) 的 C 语言的前身。</i></p><p class="normal"><i>Hired as a researcher at Bell Labs to work on the MULTICS project, after Bell Labs pulled out of MULTICS, Thompson went on, with Dennis Ritchie, to invent Unix, an endeavor for which he fully expected to be fired. He also invented the B programming language, the precursor to Dennis Ritchie's C.</i></p>
<p class="normal"><i>后来他对电脑国际象棋产生了兴趣，建造了 Belle，这是第一台专用国际象棋电脑，也是当时最强的电脑国际象棋棋手。他还帮助扩展了国际象棋残局表库，以涵盖所有四件式和五件式残局。</i></p><p class="normal"><i>Later he got interested in computer chess, building Belle, the first special-purpose chess computer and the strongest computerized chess player of its time. He also helped expand chess endgame tablebases to cover all four- and five-piece endgames.</i></p>
<p class="normal"><i>在贝尔实验室的 Plan 9 操作系统上工作时，他设计了现在无处不在的 UTF-8 Unicode 编码。</i></p><p class="normal"><i>When working on Bell Labs' Plan 9 operating system, he devised the now ubiquitous UTF-8 Unicode encoding.</i></p>
<p class="normal"><i>1983 年，汤普森和里奇因“通用操作系统理论的发展，特别是 Unix 操作系统的实现”而获得图灵奖。他还因其在 Unix 方面的工作而获得国家技术奖章和电气和电子工程师协会 Tsutomu Kanai 奖。</i></p><p class="normal"><i>In 1983, Thompson and Ritchie received the Turing Award for their “development of generic operating systems theory and specifically for the implementation of the Unix operating system.” He was also awarded the National Medal of Technology and the Institute of Electrical and Electronics Engineers Tsutomu Kanai Award, both for his work on Unix.</i></p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_450"></a><i>在这次采访中，他谈到了他早年对电子学的热爱，一个相当非正统的学术生涯，让他在还是学生的时候就教授课程，以及为什么现代编程让他害怕。</i></p><p class="normal"><a></a><i>In this interview he talked about his early love of electronics, a rather unorthodox academic career that had him teaching courses while he was still a student, and why modern programming scares him.</i></p>
</div>
<p class="normal"><b>Seibel：</b>你是如何学习编程的？</p><p class="normal"><b>Seibel:</b> How did you learn to program?</p>
<p class="normal"><b>汤普森：</b>我一直对逻辑很着迷，甚至在小学时我就开始研究二进制算术问题，诸如此类。只是因为我着迷了。</p><p class="normal"><b>Thompson:</b> I was always fascinated with logic and even in grade school I'd work on arithmetic problems in binary, stuff like that. Just because I was fascinated.</p>
<p class="normal"><b>Seibel：</b>你是那样转动它们的吗？</p><p class="normal"><b>Seibel:</b> Did you turn them in that way?</p>
<p class="normal"><b>汤普森：</b>不，不。但是我制定了用于添加不同基数的算法，进位意味着什么，每列意味着什么等等。然后我有了一个小计算器，一个十进制计算器。它就像一个十进制算盘。它不是一和二，而是从零到九的幻灯片。它从上一列向下减一，从上一列向上加一。所以你会放一个手写笔，比如四个，如果你想随身携带，就把它拉起来挂在上面。我基于此构建了一些二进制内容以及如何将其推广到<i>n</i>元。</p><p class="normal"><b>Thompson:</b> No, no. But I worked out the algorithms for adding in different bases, what carry means, and what each column means and things like that. Then I had a little calculator, a decimal calculator. It was like a decimal abacus. Instead of one and two it had a slide from zero to nine. It had a subtract one from a previous column down and an add one from the previous column up. So you'd put a stylus in, like a four, and run it up and hook over if you want to carry. And I built some binary stuff based on that and how that generalized to <i>n</i>-ary.</p>
<p class="normal"><b>Seibel：</b>你从哪里得到二进制算术的概念？</p><p class="normal"><b>Seibel:</b> Where did you even get that notion of binary arithmetic?</p>
<p class="normal"><b>汤普森：</b>在我真正开始这样做的时候，他们在课堂上介绍了二进制。</p><p class="normal"><b>Thompson:</b> In the class at the time I actually started doing this, they introduced binary.</p>
<p class="normal"><b>Seibel：</b>你是“新数学”的受害者吗？</p><p class="normal"><b>Seibel:</b> Were you a victim of the “new math?”</p>
<p class="normal"><b>汤普森：</b>不，不。我是数学不好的受害者。我大约每年搬家，我在一些非常非常糟糕的学校上学，然后是一些好学校。所以我必须在一年内完成两年的工作，然后再休假一年。我只是在数学上游荡，所以我的小学数学教育很糟糕。而这一课他们只是描述了二进制算术。我接受了它并将其扩展到任何基地并使用它。这就是我开始的地方。</p><p class="normal"><b>Thompson:</b> No, no. I was victim of bad math. I moved every year or so and I was in some really, really horrible schools and then some good schools. So I would have to do two years of work in one year and then I'd be off a year. I was just loafing through math, so I had a horrible math primary education. And this one class they just described binary arithmetic. I took that and extended it to any base and played with that. So that's kind of where I got started.</p>
<p class="normal"><b>Seibel：</b>那是在小学？</p><p class="normal"><b>Seibel:</b> And that was in grade school?</p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_451"></a><b>汤普森：</b>是的，七年级。然后大约在高中高年级，大约在那个时候，我对电子产品很感兴趣，制造收音机、放大器、振荡器和电子琴。我迷上了模拟计算。这真是太棒了。在那段时间里，电子是我的热情所在。我进入了伯克利的双 E，在大三的时候我第一次看到了真正的数字计算机。</p><p class="normal"><a></a><b>Thompson:</b> Yeah, seventh grade. Then around senior year in high school, somewhere around in that time, I was into electronics a lot, building radios and amplifiers and oscillators and theremins. And I got hooked on analog computing. It was really marvelous. Electronics was my passion during all that time. I went into double E at Berkeley, and there I saw real digital computers for the first time in my junior year.</p>
<p class="normal"><b>Seibel：</b>那会是哪一年呢？</p><p class="normal"><b>Seibel:</b> And so what year would that have been?</p>
<p class="normal"><b>汤普森：</b>我很早就上了大三学期，所以是三个学期。我是 60 年 9 月开学的，所以应该是 62 年的秋季或春季。他们有一台模拟计算机，我玩得很开心。他们有一台 G15，一台鼓式计算机。他们有一节实验课，然后就开放了。任何人都可以玩它，但没有人玩过，所以它是免费的。我基本上只使用它。我自己在上面写了程序来扩展模拟计算机——模拟计算几乎都是可扩展的。</p><p class="normal"><b>Thompson:</b> I went to junior semester early, so it was three semesters in. I started school in September '60, so it would be the fall or spring of '62. They had an analog computer which I had a great time with. And they had a G15, a drum computer. They had one lab class on it and then it was open. Anybody could play with it, but no one did, so it was free. And I used it essentially exclusively. I wrote programs on it, on my own, to scale an analog computer—analog computing is almost all scaling.</p>
<p class="normal"><b>Seibel：</b>缩放的意义？</p><p class="normal"><b>Seibel:</b> Scaling in the sense of?</p>
<p class="normal"><b>Thompson：</b>时间缩放和幅度缩放。基本上你所做的就是构建它来完成一个功能。您输入一些输入，然后得到该输入的函数，然后将这些内容与反馈连接起来。在这个过程中的每一点，你都不能走得太高，否则你会被削掉。</p><p class="normal"><b>Thompson:</b> Time scaling and amplitude scaling. Basically what you do is you build it to do a function. You put some input in and then you get a function of that input out and you concatenate these things with feedback. And at every point in this process you can't go too high or you'll clip.</p>
<p class="normal">同样，还有时间缩放——您可以在不同的地方将频率减半，或者在不同的地方将频率加倍。当你这样做时，一系列线性缩放也会发生变化。因此，如果您有一项不需要缩放的简单工作，那么模拟真的很棒。但是一旦你需要扩展它就会变得非常非常复杂。所以我编写了数字计算机程序来扩展模拟计算机设置。在不计算实际波形的情况下，您可以计算波形在每个点的幅度和频率。然后它会告诉你什么时候你超出了你当时正在做的任何操作的范围。</p><p class="normal">Likewise there's time scaling—you halve the frequency at different places or double the frequency in different places. And when you do that, a bunch of the linear scaling changes also. So if you have a simple job that doesn't need scaling, analog is really great. But as soon as you need scaling it becomes very, very complex. And so I wrote digital computer programs to scale the analog computer setups. Without computing the actual wave forms, you compute the amplitude and frequency of the wave form at every point. And then it tells you when you're out of range for whatever operation you're doing at that time.</p>
<p class="normal"><b>Seibel：</b>数字计算机上的程序是用汇编语言还是 Fortran 语言编写的？</p><p class="normal"><b>Seibel:</b> And the programs on the digital computer were written in assembly or Fortran?</p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_452"></a><b>汤普森：</b>他们主要是在集会。有一种解释性语言被证明太慢了。这就是为什么我被迫去组装并真正了解计算机是什么的原因。</p><p class="normal"><a></a><b>Thompson:</b> They were assembly mostly. There was an interpreted language that turned out to be too slow. That's why I was forced to go to assembly and actually learn what the computer was.</p>
<p class="normal"><b>Seibel：</b>所以加载你的程序，点击运行按钮，然后就可以了。是用穿孔卡吗？</p><p class="normal"><b>Seibel:</b> So load in your program, hit the run button, and away you go. Was it using punch cards?</p>
<p class="normal"><b>汤普森：</b>不，不。那是一台 Flexowriter，就像电传打字机和纸带。你会把它存储在纸带上，然后在 Flexowriter 上与它对话。</p><p class="normal"><b>Thompson:</b> No, no. It was a Flexowriter, which is like a Teletype and paper tape. And you'd store it on paper tape and talk to it on the Flexowriter.</p>
<p class="normal"><b>Seibel：</b>他们真的在那个实验室教过你组装吗？</p><p class="normal"><b>Seibel:</b> Did they actually teach you assembly in that lab?</p>
<p class="normal"><b>汤普森：</b>不。</p><p class="normal"><b>Thompson:</b> Nah.</p>
<p class="normal"><b>Seibel：</b>你下一次接触编程是什么？</p><p class="normal"><b>Seibel:</b> What was your next exposure to programming?</p>
<p class="normal"><b>汤普森：</b>这个 G15 有一个翻译器，叫做 Intercom 501。双 E 类会在 Intercom 中对其进行编程。有一个研究生是我的朋友，他在大型 IBM 机器，大型校园计算设施上为 Intercom 编写了一个解释器。我得到了一份清单，在假期、圣诞节或其他什么时候，我阅读了它并对其进行了剖析。我不知道它是用什么语言写的。碰巧是 NELIAC。这只是一个写得非常棒的程序。我还学习了编程、NELIAC、对讲机，以及如何从中解释某些东西——一切。我只是坐着读了大概整个假期，一个星期。然后回来问他问题，唠叨小虫子之类的。在那之后，我知道了如何编程，而且我很擅长。然后我得到了工作编程。</p><p class="normal"><b>Thompson:</b> This G15 had an interpreter called Intercom 501. And the double-E class would program it in Intercom. There was a graduate student that I was friends with that wrote an interpreter for Intercom on the big IBM machine, the big campuswide computing facility. I got a listing of that and on vacation, Christmas or something, I read it and just dissected it. I didn't know the language it was written in. which happened to be NELIAC. And it was just a marvelously written program. And I learned programming, NELIAC, Intercom, and how to interpret something—everything—from that. I just sat and I read it for probably the entire vacation, a week. And then came back and asked him questions about it, nagging little bugs kinds of things. After that I knew how to program and I was pretty good at it. Then I got jobs programming.</p>
<p class="normal">我基本上是靠自己的方式完成学业、勤工俭学，然后打零工。我是一名研究助理——为研究生完成他的论文编程而做的工作。我是助教。我为计算机中心编程。计算机中心的一部分工作是坐在一个小隔间里，让人们进来说，“我只改变了一件事。” “好吧，让我们看看那一件事，看看你发生了什么事。”</p><p class="normal">I was basically working my way through school, work-study and then odd jobs. I was a research assistant—a grunt for a graduate student to get programming done for his thesis. And I was a TA. I did programming for the computer center. Part of the computer-center stuff was to sit in a little booth and have people come in and say, “I only changed one thing.” “Well, let's look at that one thing and see what happened to you.”</p>
<p class="normal"><b>Seibel：</b>这是否磨练了您的调试技能，或者这一切都是非常愚蠢的事情？</p><p class="normal"><b>Seibel:</b> Did that hone your debugging skills or was it all just incredibly stupid stuff?</p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_453"></a><b>汤普森：</b>它磨练了那种类型的调试——在那之后你真的很了解常见的错误。有人花了好几天的时间在他们的程序上工作会进来，你会说，“就在那里！”</p><p class="normal"><a></a><b>Thompson:</b> It honed that type of debugging—you understood common errors really well after that. Somebody who had spent days working on their program would come in and you'd say, “Right there!”</p>
<p class="normal"><b>Seibel：</b>你的学位是双 E？他们当时提供计算机科学学位吗？</p><p class="normal"><b>Seibel:</b> And your degree was in double E? Did they offer a computer-science degree at that point?</p>
<p class="normal"><b>汤普森：</b>不，当时整个美国的计算机科学都在努力发扬光大，而且是以两种方式发扬光大。它在理论上是通过数学得出的，或者实际上是通过双 E 得出的。在伯克利，当时的计算机科学几乎完全属于电气工程领域。数学很努力，但他们在政治上不够精明，无法与这些头发花白的老家伙竞争。</p><p class="normal"><b>Thompson:</b> No, all over the United States at the time computer science was trying to come out, and it was coming out in two ways. It was coming out theoretically through math, or practically through double E. In Berkeley, computer science at that point was almost exclusively inside of electrical engineering. Math was trying, but they just weren't politically astute enough to compete with these old grizzled guys.</p>
<p class="normal"><b>Seibel：</b>伯克利显然最终以像伯克利系统实验室这样的东西而闻名——建造东西——而不是以对理论的贡献而闻名。</p><p class="normal"><b>Seibel:</b> Berkeley obviously ended up being known for things like the Berkeley Systems Lab—building things—as opposed to being renowned for contributions to theory.</p>
<p class="normal"><b>汤普森：</b>是的，当然。这是理论计算机科学系（如康奈尔大学）或伯克利计算机科学系的起源。它真的给这个地方增添了风味。所以我在那里读了一年研究生，并不是因为我有什么野心。这只是因为我没有别的事可做，而且我玩得很开心。</p><p class="normal"><b>Thompson:</b> Yes, absolutely. This is the genesis of either a theoretical computer-science department, like Cornell, or the Berkeley kind of computer science. It really gives the flavor to the place. So I spent one year in graduate school there, not because I had any ambitions for anything. It's just because I had nothing else to do and I was having a good time.</p>
<p class="normal"><b>Seibel：</b>大学刚毕业？</p><p class="normal"><b>Seibel:</b> Immediately after college?</p>
<p class="normal"><b>汤普森：</b>是的。老实说，我当时在大学打工，连研究生都没申请。其中一位教授基本上是为我申请的，并告诉我我在读研究生。</p><p class="normal"><b>Thompson:</b> Yeah. To be honest, I was working at the university and I didn't even apply for graduate school. One of the professors essentially applied for me and told me I was in graduate school.</p>
<p class="normal"><b>Seibel：</b>还在双E？</p><p class="normal"><b>Seibel:</b> Still in double E?</p>
<p class="normal"><b>汤普森：</b>对。我的高年级和研究生年非常有趣。我没有做任何我不想做的事。没有要求，什么都没有。为了毕业，我参加了美国历史的暑期课程或其他一些要求，以获得学位。但除此之外，在我的大四和研究生阶段，我教授了大约一半的课程。</p><p class="normal"><b>Thompson:</b> Right. My senior year and my graduate year were just immense fun. I didn't do anything that I didn't want to do. There were no requirements, no nothing. To graduate I took a summer course in American history or something, some requirement, to get a degree. But outside of that, my senior year and my graduate year I taught about half of the courses I took.</p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_454"></a>计算的基本理论那时才刚出来。Shell 排序问世，但没有人能弄清楚为什么它比<i>n</i>平方排序快。所以每个人都在对它进行测试并试图弄清楚——很容易看出它的排序，但没有人知道它为什么很快。他们正在使用渐近线并弄清楚为什么它是<i>n</i>到 1.3 或类似的东西。那不是自然数。从那里——shell 排序和对 shell 排序的智力吸引力以及它为什么很快——产生了所有这些计算速度顺序。以及第一个<i>n</i> log <i>n</i> s 和分而治之等等。那是一个了不起、激动人心的时代。</p><p class="normal"><a></a>The basic theory of computing was just coming out then. Shell sort came out and no one could figure out why it was faster than <i>n</i>-squared sort. And so everyone was doing tests on it and trying to figure out—it's pretty easy to see it sorts, but nobody knows why it's fast. And they were taking the asymptote and figuring out why it was <i>n</i> to the 1.3 or something like that. And that's just not a natural number. And from that—shell sort and the intellectual attraction to shell sort and why it was fast—came all this speed order of computing. And the first <i>n</i> log <i>n</i>s and divide and conquer and all that struck. It was an amazing, exciting era.</p>
<p class="normal">我有朋友，一群非常初级的教授——一位我非常亲近的数学教授，一位我亲近的双 E 教授，还有我工作的研究生，等等。他们会为我发明一门课，然后我会教这门课。</p><p class="normal">I had friends, a bunch of these very junior professors—a math professor I was real close to, and a double-E professor I was close to, and the graduate student that I worked for, and others. They would invent a class for me, and then I would teach the class.</p>
<p class="normal"><b>Seibel：</b>你是正式上了这门课，还是你真的在书本上教过这门课？</p><p class="normal"><b>Seibel:</b> Were you officially taking the class or were you actually on the books as teaching it?</p>
<p class="normal"><b>汤普森：</b>不，不，我没有在书上教它。都是double-E 199，意思就是个人研究或者小组研究什么的。他们会发明一个类并给它一个标题，然后把它交给我。那里会有三四个学生。</p><p class="normal"><b>Thompson:</b> No, no, I wasn't on the books as teaching it. They were all double-E 199, which meant individual research or group research or something. And they would invent a class and give it a title and then turn it over to me. And there'd be three or four students there.</p>
<p class="normal"><b>Seibel：</b>正式地说，你是其中之一。</p><p class="normal"><b>Seibel:</b> Of which, officially, you were one.</p>
<p class="normal"><b>汤普森：</b>是的。</p><p class="normal"><b>Thompson:</b> Yes.</p>
<p class="normal"><b>Seibel：</b>你喜欢教书吗？</p><p class="normal"><b>Seibel:</b> Did you like teaching?</p>
<p class="normal"><b>汤普森：</b>在某种程度上。我回去教过两次。休假一年，75-76 年在伯克利任教一年，88 年在悉尼任教一年。很有趣。我真的，真的很享受。我在实验室做研究，然后去伯克利教书，自下而上地学习我所教的课程，因为我从未接受过计算机科学教育。一个普通的访问老师教一个班级。我教了五个班。有些课程我教过两次，我认为它们是最好的，因为第一年我正在学习，第二次我教它，我知道它的去向，我可以有条理地展示它，比学生领先两步。第三节课很无聊。一节课我教了三遍，都是错的。所以我永远无法<a id="OEBPS/Chapter12.html.page_455"></a>成为一名老师，因为你最终一遍又一遍地教你的课。我永远做不到。但我喜欢教学：第一堂课的辛苦，第二堂课的乐趣。然后是第三者的痛苦。</p><p class="normal"><b>Thompson:</b> To an extent. I've gone back and taught twice. Taken a year off and taught one year at Berkeley in '75–'76 and one year in Sydney in '88. It's fun. I really, really enjoy it. I was doing research in the labs and I went to Berkeley to teach and to learn the classes I was teaching from the bottom up since I never had a computer-science education. A normal visiting teacher teaches one class. I taught five classes. Some classes I taught twice and I thought they were the best because the first year I was learning and the second time I taught it I knew where it was going and I could present it organized and be two steps ahead of the students. The third class was just boring. I taught one class three times and it was just wrong. So I could never <a></a>be a teacher because you end up teaching your class over and over and over. I could never do that. But I love the teaching: the hard work of a first class, the fun of the second class. Then the misery of the third.</p>
<p class="normal"><b>Seibel：</b>您编写的第一个有趣的程序是什么？</p><p class="normal"><b>Seibel:</b> What was the first interesting program you wrote?</p>
<p class="normal"><b>Thompson：</b>我写的第一个长计算程序是解决五氨基问题。你知道吗？</p><p class="normal"><b>Thompson:</b> The first long computational program I wrote was solving the pentaminos problem. Do you know it?</p>
<p class="normal"><b>Seibel：</b>瓷砖游戏，对吧？</p><p class="normal"><b>Seibel:</b> The tile game, right?</p>
<p class="normal"><b>汤普森：</b>这是一个瓷砖游戏。我在物理系的 IBM 1620 上运行它。我知道所有地下计算机都在那个地方，我让它们在晚上运行以完成我的工作。另外，在主要的计算机中心，我可能在不同的岩石下有 20 个帐户。有 12 个五氨基。这些是由 5 个正方形拼成的不同拼块。并且有 12 种不同的形状。</p><p class="normal"><b>Thompson:</b> It's a tile game. And I ran it on an IBM 1620 that was in the physics department. I knew where all the underground computers were in the place, and I had them all running at night doing my jobs. Plus, at the main computer center I probably had 20 accounts under different rocks. There are 12 pentaminos. These are different tile pieces made out of 5 squares. And there are 12 different such shapes.</p>
<p class="normal"><b>Seibel：</b>有点像俄罗斯方块。</p><p class="normal"><b>Seibel:</b> Sort of like Tetris tiles.</p>
<p class="normal"><b>汤普森：</b>是的。但是每一块都有五个方块。如果将它们全部放在电路板上，有两种配置——我不知道——很有吸引力。一个最正方形，十乘六，然后是八乘八，中间有一个二乘二的孔。我解决了这两块板的所有配置，以及您如何为这些板放置零件。我通常通过布置木板图案然后布置图案块来做到这一点，然后它会适合图案中的碎片。它不知道那是五氨基。</p><p class="normal"><b>Thompson:</b> Yes. But every piece has five squares. If you put them all together on the board there are two configurations that are—I don't know—appealing. One is the most square, which is ten-by-six, and then the second is eight-by-eight with a two-by-two hole in the middle. And I solved all configurations of those two boards of how you place the pieces for those boards. And I did it generically by laying out a pattern of the boards and then laying out pattern pieces, and then it would fit the pieces in the patterns. It didn't know it was pentaminos.</p>
<p class="normal"><b>Seibel：</b>这基本上是暴力搜索？</p><p class="normal"><b>Seibel:</b> This was basically brute-force search?</p>
<p class="normal"><b>汤普森：</b>蛮力。</p><p class="normal"><b>Thompson:</b> Brute force.</p>
<p class="normal"><b>Seibel：</b>所以这可能也在组装中？</p><p class="normal"><b>Seibel:</b> And so this was also in assembly probably?</p>
<p class="normal"><b>汤普森：</b>我必须考虑一下。是的，这可能是组装。我不记得了。</p><p class="normal"><b>Thompson:</b> I have to think. Yeah, it was probably assembly. I can't remember.</p>
<p class="normal"><b>Seibel：</b>你一定是学过 Fortran 语言的。</p><p class="normal"><b>Seibel:</b> You must have learned Fortran somewhere along the line.</p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_456"></a><b>汤普森：</b>是的，嗯，我不得不在计算机中心教授 Fortran 并调试 Fortran 程序。我从来没有在里面编程过。我很早就写了一个 Unix 的 Fortran 编译器，而 B 是一个尝试的 Fortran 编译器，离我而去。</p><p class="normal"><a></a><b>Thompson:</b> Yeah, well, I had to teach Fortran in the computer center and debug the Fortran programs. I never programmed in it. I wrote a Fortran compiler for Unix early, and B was an attempted Fortran compiler that got away from me.</p>
<p class="normal"><b>Seibel：</b>我以为 B 是你对 BCPL 的翻译。</p><p class="normal"><b>Seibel:</b> I thought B was your translation of BCPL.</p>
<p class="normal"><b>汤普森：</b>有点像。一开始是——我不知道那是什么。从语义上看，原来是BCPL。当我开始的时候，它将是 Fortran。那时我得到了 BCPL 的第一个描述。我喜欢干净的语义。那时我放弃了 Fortran，它基本上变成了 C 语法和 BCPL 语义。</p><p class="normal"><b>Thompson:</b> It sort of was. It started off as—I didn't know what it was. Semantically, it turned out to be BCPL. As I started it, it was going to be Fortran. And at that point I got my first description of BCPL. And I liked the clean semantics. And that's when I abandoned Fortran and it turned into essentially C syntax and BCPL semantics.</p>
<p class="normal"><b>Seibel：</b>从学习到现在，您对编程的看法或练习编程的方式是否真的存在很大差异？您是否觉得您的编程在某种程度上已经成熟了，或者您变得更擅长了，或者您学到的东西让您回头看看并说，“哦，伙计，我当时不知道自己在做什么。”？</p><p class="normal"><b>Seibel:</b> Is there any really big differences in how you think about programming or how you practice programming from when you learned to now? Do you feel like your programming has matured in some way or you got better at it or you learned things that make you look back and say, “Oh, man, I didn't know what I was doing back then.”?</p>
<p class="normal"><b>汤普森：</b>不，不是真的。有时我回顾自己做过的事情并说，“哇。那时我好多了。” 从我花那个星期阅读那个程序到我 30 岁、35 岁那段时间，我深深地知道我写过的每一行代码。我会在白天写一个程序，晚上我会坐在那里逐行检查它并找出错误。第二天我会回去，果然，那是错误的。</p><p class="normal"><b>Thompson:</b> No, not really. Sometimes I look back at stuff I did and say, “Wow. I was much better then.” The period from when I spent that week reading that program to maybe when I was 30, 35 years old, I knew, in a deep sense, every line of code I ever wrote. I'd write a program during the day, and at night I'd sit there and walk through it line by line and find bugs. I'd go back the next day and, sure enough, it would be wrong.</p>
<p class="normal"><b>Seibel：</b>你认为当你 35 岁时，你还记得十年前写的东西吗？</p><p class="normal"><b>Seibel:</b> Do you think when you were 35 you could still remember the stuff you had written a decade before?</p>
<p class="normal"><b>汤普森：</b>是的。然后我开始有选择性地选择我会记住的东西。</p><p class="normal"><b>Thompson:</b> Yes. Then I started being selective about what I'd remember.</p>
<p class="normal"><b>Seibel：</b>对于学习编程，您有什么不同的做法吗？您是否对自己所走的道路感到遗憾，或者您希望自己早点做些什么？</p><p class="normal"><b>Seibel:</b> Is there anything you would have done differently about learning to program? Do you have any regrets about the sort of path you took or do you wish you had done anything earlier?</p>
<p class="normal"><b>汤普森：</b>哦，当然，当然。我希望我在高中时学过打字。我今天打字很差，但谁知道呢。我没有计划任何事情或做任何事情。我没有纪律。我一直在做我接下来想做的事。如果我有一些先见之明或计划之类的，有些事情，比如<a id="OEBPS/Chapter12.html.page_457"></a>打字，如果有机会，我会做的。我会学一些更深入的数学，因为我肯定遇到过需要数学帮助的事情。所以是的，有这样的小事。但是，如果我回去并不得不重新做一遍，我敢肯定我不会让我做任何不同的事情。基本上我什么都没有计划，我只是采取了下一步。如果我必须重新做一遍，我会再次迈出下一步。</p><p class="normal"><b>Thompson:</b> Oh, sure, sure. In high school I wish I'd taken typing. I suffer from poor typing yet today, but who knew. I didn't plan anything or do anything. I have no discipline. I did what I wanted to do next, period, all the time. If I had some foresight or planning or something, there are things, like <a></a>typing, I would have done when I had the chance. I would have taken some deeper math because certainly I've run across things where I have to get help for math. So yeah, there are little things like that. But if I went back and had to do it over I'm sure that I just wouldn't have it in me to do anything differently. Basically I planned nothing and I just took the next step. And if I had to do it over again, I'd just have taken the next step again.</p>
<p class="normal"><b>Seibel：</b>毕业后你直接被贝尔实验室录用了；那是怎么发生的？听起来你在职业生涯的那个阶段不像是一名经典的学术研究人员。</p><p class="normal"><b>Seibel:</b> After school you got hired directly into the Bell Labs; how did that happen? It doesn't sound like you were a classical academic researcher at that point in your career.</p>
<p class="normal"><b>汤普森：</b>我只是随波逐流。很难描述。我当然没有真正意义上的上学。在正式意义上，是的，我是。我的一位教授实际上是我的好朋友，他让贝尔实验室的招聘人员找到了我。但我不是在找工作。事实上，我完全没有野心；没有什么。他约了我去他的小招聘摊位见他，我要么睡过去，要么告诉他我不感兴趣。他一直跟着我。有一次他打电话给我说他想过来看看我。所以他来到我的公寓。还说要我出来贝尔实验室面试。我告诉他没有。他说，“这是一次免费旅行。你可以在那里做你想做的事。” 我说，“好吧，首先我会告诉你我对工作不感兴趣。我' 我会很高兴去免费旅行，因为我在东海岸有朋友。我去看看他们。” 他说，“很好。” 这就是我参加的面试。我去了贝尔实验室呆了两天，然后租了一辆车，在东海岸上下走动，拜访了分布在各地的高中朋友。</p><p class="normal"><b>Thompson:</b> I just drifted. It was hard to describe. I certainly wasn't in school in any real sense. In the formal sense, yes, I was. One of my professors, who is actually a very good friend, sicced the Bell Labs recruiter on me. But I wasn't looking for a job. In fact, I had absolutely no ambitions; nothing. And he made me appointments to see him in his little recruiting booth, and I either slept through them or told him I wasn't interested. And he kept after me. At some point he called me and said that he wanted to come over and see me. So he came over to my apartment. And said that he wanted me to come out and interview at Bell Labs. I told him no. And he said, “It's a free trip. You can do what you want to out there.” And I say, “Well, up front I'll just tell you that I'm not interested in a job. I'll be glad to go for a free trip 'cause I have friends on the East Coast. I'll go visit them.” And he says, “Fine.” So that was the interview that I got into. And I went and spent my two days at Bell Labs and then rented a car and went up and down the East Coast visiting my high-school friends that were spread out all over everywhere.</p>
<p class="normal"><b>Seibel：</b>很明显，贝尔实验室的人在你身上看到了一些东西，并说，“我们应该让这个人进入我们的实验室。”</p><p class="normal"><b>Seibel:</b> Obviously there was something that the folks at Bell Labs saw in you and said, “We should get this guy into our lab.”</p>
<p class="normal"><b>汤普森：</b>我不知道他们的立场。我的观点是，这些人是我在上课/上课时阅读论文的人。我知道他们的名字和声誉。他们还在做有趣的事情。对我来说，工作就是工作，而这些人没有工作。他们玩得很开心。就像学校一样。</p><p class="normal"><b>Thompson:</b> I don't know their side of it. My side of it is that these are people that I was reading the papers of in the classes I was taking/teaching. And I knew them by name and reputation. And they were still doing fun things. To me, work was work and these guys weren't working. They were having a good time. Just like school.</p>
<p class="normal"><b>Seibel：</b>那你刚到那里的时候做了什么？</p><p class="normal"><b>Seibel:</b> And so what kind of things did you do when you first arrived there?</p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_458"></a><b>Thompson：</b>贝尔实验室参与了 MULTICS 项目，我受雇参与 MULTICS 的工作。我做到了。我玩弄了机器，启动了 MULTICS，并做了我的一小部分。在某个时候，贝尔实验室认为 MULTICS 不适合他们，于是他们退出了该项目。</p><p class="normal"><a></a><b>Thompson:</b> Bell Labs was in the MULTICS project and I was hired in to work on MULTICS. And I did. I played with the machines, booted up MULTICS, and did my little piece of it. At some point, Bell Labs decided that MULTICS wasn't for them, and they backed out of the project.</p>
<p class="normal">但是他们有这些 MULTICS 机器，这些机器是专用机器，只是闲置着，直到有人可以将它们运走。所以在大约一年的时间里，我拥有这台非常可怕的机器。我们中可能有两三个人使用过它。所以我开始做操作系统方面的工作，试图启动并运行一个小操作系统。</p><p class="normal">But they had these MULTICS machines which were special-purpose machines that were just sitting around idle until someone could cart them away. So for approximately a year I had this machine that was monstrous. There are maybe two or three of us that used it. So I started doing operating-system stuff, trying to get a little operating system up and running.</p>
<p class="normal">这非常困难，因为它是一台真正复杂的计算机。但我把它放在了它会坐在那里并在建筑物周围的 50 个电传打字机上打招呼的地方。然后它就出了门。所以我四处逛逛，发现了一些其他未使用的机器，并在这些非常非常小的 PDP 机器上构建了 Unix。</p><p class="normal">It was insanely hard because it was a real complex computer. But I got it up where it would sit there and say hello on 50 Teletypes around the building. And then it went out the door. So I shopped around then and found some other unused machines and essentially built Unix on these very, very small PDP machines.</p>
<p class="normal"><b>Seibel：</b>你有时间这样做是因为你的老板知道你正在做的事情并且说这是一个很好的研究项目，还是仅仅是因为你在工作之间？</p><p class="normal"><b>Seibel:</b> Did you have the time to do that because your bosses knew that that's what you were doing and said this is a good research project, or was it just because you were in between jobs?</p>
<p class="normal"><b>汤普森：</b>不，老实说，我有点不可救药。我怀疑我最终会被解雇，但这并没有困扰我。我们应该做基础研究，但有些基础研究我们应该做，有些基础研究我们不应该做。刚刚从 MULTICS 的灰烬中走出来，操作系统是我们<i>不</i>应该做的基础研究之一。因为我们试过了，没有用，是一个巨大的失败，很贵；让我们放下它。所以我有点期待我所做的事情最终会被解雇。我没有。</p><p class="normal"><b>Thompson:</b> No, I was sort of incorrigible, to be honest. I suspected that I would eventually get fired, but it didn't bother me. We were supposed to be doing basic research but there was some basic research we should be doing and some basic research we shouldn't be doing. And just coming out of the ashes of MULTICS, operating systems was one of those basic research things we <i>shouldn't</i> be doing. Because we tried it, it didn't work, it was a huge failure, it was expensive; let's drop it. So I kind of expected that for what I was doing I was going to eventually get fired. I didn't.</p>
<p class="normal"><b>Seibel：</b>您如何设计软件？您是在方格纸上乱涂乱画还是启动 UML 工具或只是开始编码？</p><p class="normal"><b>Seibel:</b> How do you design software? Do you scribble on graph paper or fire up a UML tool or just start coding?</p>
<p class="normal"><b>汤普森：</b>取决于它有多大。大多数时候，它会在我的脑海中停留一段时间——纸上没有任何东西——一段时间，我会专注于困难的部分。简单的部分就会消失——把它们写下来；当您准备好时，它们会立即从您的指尖出来。但是硬的部分我会坐着让它发芽一段时间，也许一个月。在某些时候，碎片会开始从底部掉落，我可以看到金字塔的构建<a id="OEBPS/Chapter12.html.page_459"></a>起来的碎片。当金字塔在我脑海中变得足够高时，我就会从底部开始。</p><p class="normal"><b>Thompson:</b> Depends on how big it is. Most of the time, it sits in the back of my mind—nothing on paper—for a period of time and I'll concentrate on the hard parts. The easy parts just fade away—just write 'em down; they'll come right out of your fingertips when you're ready. But the hard parts I'll sit and let it germinate for a period of time, a month maybe. At some point pieces will start dropping out at the bottom and I can see the pyramid build <a></a>up out of the pieces. When the pyramid gets high enough in my mind, then I'll start at the bottom.</p>
<p class="normal"><b>Seibel：</b>但你不仅仅是在建造树叶——你知道它们要适应的结构。</p><p class="normal"><b>Seibel:</b> But you're not just building leaves—you know the structure they're going to fit into.</p>
<p class="normal"><b>Thompson：</b>假设有人根据假设向我描述一些东西，比如“这是一台计算机，这是操作码”。通过查看底部并想象层次结构，我可以可视化程序的结构以及基于这些操作码的事情是如何高效或低效的。我可以在程序中看到同样的事情。如果有人向我展示库例程或基本的底层内容，我可以看到如何将其构建到不同的程序中以及缺少什么——仍然难以编写的程序类型。所以我可以设想那个金字塔，问题是尝试分解它并得到底部的部分。</p><p class="normal"><b>Thompson:</b> Suppose someone is describing something to me from postulates like, “Here's a computer and here are the op codes.” I can visualize the structure of programs and how things are efficient or inefficient based on those op codes, by seeing the bottom and imagining the hierarchy. And I can see the same thing with programs. If someone shows me library routines or basic bottom-level things, I can see how you can build that into different programs and what's missing—the kinds of programs that would still be hard to write. So I can envision that pyramid, and the problem is to try and decompose it and get the bottom pieces.</p>
<p class="normal">现代编程在很多方面都让我感到害怕，他们只会一层又一层地构建，除了翻译之外什么都不做。<i>阅读必须</i>自上而下阅读的程序让我很困惑。它说“做某事”。然后你去找“东西”。你读了它，它说，“做点别的事”，然后你去找点东西，它说，“做点别的事”，然后它可能会回到顶部。什么也做不了。只是把问题推到更深的层次上。我无法将它牢记在心——我无法理解。</p><p class="normal">Modern programming scares me in many respects, where they will just build layer after layer after layer that does nothing except translate. It confuses me to read a program which you <i>must</i> read top-down. It says “do something.” And you go find “something.” And you read it and it says, “do something else” and you go find something and it says, “do something else” and it goes back to the top maybe. And nothing gets done. It's just relegating the problem to a deeper and deeper level. I can't keep it in my mind—I can't understand it.</p>
<p class="normal"><b>Seibel：</b>那为什么不还是自下而上阅读呢？树叶在那里，某处。</p><p class="normal"><b>Seibel:</b> So why not still read bottom-up? The leaves are there, somewhere.</p>
<p class="normal"><b>汤普森：</b>好吧，你不知道什么是树叶，什么不是。如果它描述得很好，你可以阅读英文并获得它，然后你就不必阅读代码了。但是，如果你实际上只是得到一堆代码并被告知，“阅读它并尝试让它变得更好，或者尝试让它做其他事情，”那么我通常会自上而下地阅读它。</p><p class="normal"><b>Thompson:</b> Well, you don't know what are leaves and what aren't. If it's well described you can read the English and get it and then you don't have to read the code. But if you're actually just given a bunch of code and told, “Read it and try and make it better or try and make it do something else,” then typically I read it top-down.</p>
<p class="normal"><b>Seibel：</b>在开始编写代码之前，您会写下任何东西吗？</p><p class="normal"><b>Seibel:</b> Do you ever write down anything before you start writing code?</p>
<p class="normal"><b>Thompson：</b>我通常在写代码之前先写数据结构。我不写算法——没有流程图，或类似的东西。但是你几乎在每一行代码中都必须引用的东西——数据结构。</p><p class="normal"><b>Thompson:</b> I usually write down data structures before I write down code. I don't write down algorithms—no flowcharts, or stuff like that. But the stuff you have to refer to on almost every line of code—data structures.</p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_460"></a><b>Seibel：</b>如果您正在编写 C 程序，这是否意味着将定义这些数据结构的 C 代码？</p><p class="normal"><a></a><b>Seibel:</b> If you're writing a C program, does that mean C code that would define those data structures?</p>
<p class="normal"><b>汤普森：</b>不，有箭头之类的小盒子。</p><p class="normal"><b>Thompson:</b> No, little boxes with arrows and stuff.</p>
<p class="normal"><b>Seibel：</b>所以你有这张大图，金字塔。一旦你开始编码，你会在多大程度上坚持这个计划？</p><p class="normal"><b>Seibel:</b> So you've got this big picture, the pyramid. How much do you stick to that plan once you start coding?</p>
<p class="normal"><b>汤普森：</b>我不拘泥于代码。如果我在中途发现不同的分区，我会破解并检查它。我认识的很多人，当他们写下一行代码时，此后余生都是具体的，除非有错误。特别是如果他们使用 API 编写例程并将 API 潦草地写在信封或 API 列表上的某处，那么就是这样。它永远不会改变，无论它有多糟糕。如果我找到更适合的不同方式或不同的分区，我总是完全愿意把东西分开。我从来都不是现有代码的爱好者。代码本身几乎腐烂，必须重写。即使什么都没有改变，它也会因为某种原因腐烂。</p><p class="normal"><b>Thompson:</b> I don't stick to code. If I find a different partitioning halfway through, I'll just hack and go over it. A lot of people I know, when they write a line of code, it's concrete from then on for the rest of life, unless there's a bug. Especially if they write a routine with an API and scribble the API somewhere on an envelope or an API list—then that's it. It'll never change, no matter how bad it is. And I've always been totally willing to hack things apart if I find a different way that fits better or a different partitioning. I've never been a lover of existing code. Code by itself almost rots and it's gotta be rewritten. Even when nothing has changed, for some reason it rots.</p>
<p class="normal"><b>Seibel：</b>您如何决定何时需要丢弃代码？</p><p class="normal"><b>Seibel:</b> How do you decide when code needs to be thrown away?</p>
<p class="normal"><b>汤普森：</b>当它很难工作时。我比大多数人做得快得多。只要我想向其中添加一些东西，我就会丢弃代码，而且我觉得我必须做的事情来添加它太难了。我会把它扔掉并重新开始，并提出一个不同的分区，这样可以很容易地做我想做的任何事情。我真的很快就会把东西扔掉。</p><p class="normal"><b>Thompson:</b> When it's hard to work on. I do it much quicker than most people do. I'll throw away code as soon I want to add something to it and I get the feeling that what I have to do to add it is too hard. I'll throw it away and start over and come up with a different partitioning that makes it easy to do whatever I wanted to do. I'm really quick on the trigger for throwing stuff out.</p>
<p class="normal"><b>Seibel：</b>与其他人的代码一起工作也是如此吗？</p><p class="normal"><b>Seibel:</b> Is that true working with other people's code as well?</p>
<p class="normal"><b>汤普森：</b>这取决于我是否有控制权。如果我有控制权，当然，没关系。如果我没有控制权，那是别人的代码，那我就吃亏了。或者不做。</p><p class="normal"><b>Thompson:</b> It depends on whether I have control. If I have control, sure, it doesn't matter. If I don't have control, it's someone else's code, then I'll suffer. Or not do it.</p>
<p class="normal"><b>Seibel：</b>如果您继承了某人的代码，那么重写它就会有危险，您可能会错过它工作方式的一些微妙之处，或者忽略了它所具有的一些功能。你曾经被它咬过吗？</p><p class="normal"><b>Seibel:</b> In the case where you've inherited someone's code there's a danger in rewriting it that maybe you missed some subtlety to the way it works or overlooked some bit of functionality that it had. Have you ever been bitten by that?</p>
<p class="normal"><b>汤普森：</b>嗯，你会被咬，但那只是<a id="OEBPS/Chapter12.html.page_461"></a>调试的一部分。如果你忘记或没有做某事，当你意识到它时，你就会去做。这只是调试的一部分。当你第一次写东西时，它并不完整。你扩展它。</p><p class="normal"><b>Thompson:</b> Well, you get bitten, but that's just <a></a>part of debugging. If there's something you forgot or didn't do, when you realize it you do it. That's just part of debugging. It's not complete when you first write something. You extend it.</p>
<p class="normal"><b>Seibel：</b>一旦你建立了一个系统，你会回去以任何方式记录它吗？</p><p class="normal"><b>Seibel:</b> Once you've built a system, do you go back and document it in any way?</p>
<p class="normal"><b>汤普森：</b>这取决于它的用途。如果是为了我，不，我不会。如果我忘记了参数，我会在用法行中添加。我会在标题处就整个事情的作用发表评论。但是非常非常简短。如果它是系统或库的一部分，或者是要发布的东西，那么我会花时间记录它。但除此之外，没有。</p><p class="normal"><b>Thompson:</b> It depends on what it's for. If it's for me, no I won't. I'll put in a usage line if I forget the arguments. And I'll put in a comment at the header about what the whole thing does. But very, very brief. If it's part of a system or a library or something that's meant to be published, then I'll take the time to document it. But otherwise, no.</p>
<p class="normal">记录和编程一样是一门艺术。我很少能找到我喜欢的级别的文档。通常它比需要的要细得多。它包含一堆无关紧要的内容和悬而未决的引用，这些引用假定知识不存在。记录是非常非常困难的；这很费时间。要做到这一点，你必须像编程一样去做。你必须解构它，以很好的方式将它组合在一起，当它出错时重写它。人们不那样做。</p><p class="normal">Documenting is an art as fine as programming. It's rare I find documentation at the level I like. Usually it's much, much finer-grained than need be. It contains a bunch of irrelevancies and dangling references that assume knowledge not there. Documenting is very, very hard; it's time-consuming. To do it right, you've got to do it like programming. You've got to deconstruct it, put it together in nice ways, rewrite it when it's wrong. People don't do that.</p>
<p class="normal">此外，我更喜欢自下而上的文档，而这通常不是它的编写方式。如果某个程序依赖于其他程序或文件或数据结构，我希望看到对那些我可以离开并阅读它们并且它们不会返回的引用。</p><p class="normal">Also, I prefer bottom-up documentation and that's usually not the way it's written. If some program relies on other programs or files or data structures, I like to see clear a reference to those where I can go off and read those and they don't refer back.</p>
<p class="normal"><b>Seibel：</b>所以你想按照你喜欢的方式来理解代码，也就是自下而上？</p><p class="normal"><b>Seibel:</b> So you'd like to understand code the way you would like to write it, which is from the bottom up?</p>
<p class="normal"><b>汤普森：</b>是的。这是我可以在脑海中处理并记住的方式。否则我读了它，我可能读完它就明白了，但后来它就消失了。如果我理解它的结构，那么它就是我的一部分，我就会理解它。</p><p class="normal"><b>Thompson:</b> Yeah. It's the way I can put a handle on it in my mind and remember. Otherwise I read it and I may understand it right after I read it but then it's gone. If I understand the structure of it, then it's part of me and I'll understand it.</p>
<p class="normal"><b>Seibel：</b>在你的图灵奖演讲中，你提到如果 Dan Bobrow 被迫使用 PDP-11 而不是功能更强大的 PDP-10，他可能会在那天领奖，而不是你和 Dennis Ritchie。</p><p class="normal"><b>Seibel:</b> In your Turing Award talk you mentioned that if Dan Bobrow had been forced to use a PDP-11 instead of the more powerful PDP-10 he might have been receiving the award that day instead of you and Dennis Ritchie.</p>
<p class="normal"><b>汤普森：</b>我只是想说这是偶然的。</p><p class="normal"><b>Thompson:</b> I was just trying to say it was serendipitous.</p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_462"></a><b>Seibel：</b>您认为受制于功能较弱的机器是否对您有益？</p><p class="normal"><a></a><b>Seibel:</b> Do you think you benefited to being constrained by the less powerful machine?</p>
<p class="normal"><b>汤普森：</b>它肯定有一个好处，那就是它体积小而且效率高。但我认为那是我们编写的那种代码。但更重要的是，它正处于小型计算机革命的风口浪尖。10号是计算机中心运行的大型主机。我认为，自主计算而不是集中计算是其中真正偶然的部分。这在 PDP-11 上发挥了作用。</p><p class="normal"><b>Thompson:</b> There was certainly a benefit that it was small and efficient. But I think that was the kind of code we wrote anyway. But it was more the fact that it was right at the cusp of a revolution of minicomputers. The 10 was the big mainframe run by the computer center. Computing going autonomous instead of centralized was, I think, the really serendipitous part of it. And that rode in on the PDP-11.</p>
<p class="normal"><b>Seibel：</b>难道 Unix 不是也受益于用 C 编写，而像 TENEX 和 ITS 这样的操作系统是用汇编编写的，并且不能像 Unix 那样容易地跳转到不同的硬件吗？</p><p class="normal"><b>Seibel:</b> Didn't Unix also benefit from being written in C while OSs like TENEX and ITS were written in assembly and couldn't jump to different hardware as easily as Unix?</p>
<p class="normal"><b>汤普森：</b>有一些很好的系统编程语言可以在某种程度上编写东西。</p><p class="normal"><b>Thompson:</b> There were good system-programming languages that things were written in to some extent.</p>
<p class="normal"><b>Seibel：</b>比如？</p><p class="normal"><b>Seibel:</b> Such as?</p>
<p class="normal"><b>Thompson：</b> NELIAC 是 Algol 58 的系统编程版本。</p><p class="normal"><b>Thompson:</b> NELIAC was a system-programming version of Algol 58.</p>
<p class="normal"><b>Seibel：</b>布利斯也是那个时代的吗？</p><p class="normal"><b>Seibel:</b> Was Bliss also from that era?</p>
<p class="normal"><b>汤普森：</b>我认为幸福是在之后。他们的重点是努力编译好。我认为从一开始就很清楚，你不应该为了编译好而自杀。你应该做得很好但不是真的很好。原因是，在你从好到真正好所花的时间里，摩尔定律已经超越了你。你可以选择 10%，但当你选择那 10% 时，计算机的速度已经提高了一倍，而且可能还有其他一些对优化更重要的东西，比如缓存。我认为做得很好在很大程度上是浪费时间。这真的很难；您修复的错误数量与您生成的错误数量一样多。你应该停下来，而不是花额外的 100% 的时间来完成 10% 的工作。</p><p class="normal"><b>Thompson:</b> Bliss I think was after. And their emphasis was trying to compile well. I think it was pretty clear from the beginning that you shouldn't kill yourself compiling well. You should do well but not really good. And the reason is that in the time it takes you to go from well to really good, Moore's law has already surpassed you. You can pick up 10 percent but while you're picking up that 10 percent, computers have gotten twice as fast and maybe with some other stuff that matters more for optimization, like caches. I think it's largely a waste of time to do really well. It's really hard; you generate as many bugs as you fix. You should stop, not take that extra 100 percent of time to do 10 percent of the work.</p>
<p class="normal"><b>Seibel：</b>您可能听说过 Richard Gabriel 的文章“越坏越好”。</p><p class="normal"><b>Seibel:</b> You've presumably heard of the essay, “Worse Is Better” by Richard Gabriel.</p>
<p class="normal"><b>汤普森：</b>没有。</p><p class="normal"><b>Thompson:</b> No.</p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_463"></a><b>Seibel：</b>他对比了他所谓的 MIT 风格，正确性胜过一切，以及新泽西（即贝尔实验室）风格，其中实施的简单性受到高度重视。他的理论是，新泽西风格，他也称之为“越糟越好”，可以让东西运行起来，并从那里得到改进。</p><p class="normal"><a></a><b>Seibel:</b> He contrasted what he called the MIT style, where correctness trumps everything else, and the New Jersey (i.e., Bell Labs) style, where simplicity of implementation is highly valued. His theory was that the New Jersey style, which he also called “Worse Is Better” made it possible to get stuff out and running and from there it will get improved.</p>
<p class="normal"><b>Thompson：</b>我认为 MIT 一直对 Unix 有自卑感。我在麻省理工学院做了一个 Unix 演讲，我想是 Michael Dertouzos 介绍我的。他阐述了为什么 Unix 不是在麻省理工学院编写的，以及为什么它应该是。为什么他们有机会，他们有人，他们有一切，为什么没有在那里完成。我突然意识到他们的思想中存在竞争。那时不在我的脑海里。我们开发了 Unix，他们开发了 MULTICS，这是一个怪物。这分明就是第二系统综合症。</p><p class="normal"><b>Thompson:</b> I think MIT has always had an inferiority complex over Unix. I gave a Unix talk at MIT and I was introduced by Michael Dertouzos, I think. He expounded on why Unix wasn't written at MIT and why it should have been. Why they had the opportunity, they had the people, they had everything, and why it wasn't done there. And it dawned on me that there was a rivalry in their minds. Not in my mind at that point. We did Unix and they did MULTICS, which was this monster. This was just clearly the second-system syndrome.</p>
<p class="normal"><b>Seibel：</b> MULTICS 是继麻省理工学院的兼容分时系统之后的第二个系统吗？</p><p class="normal"><b>Seibel:</b> Where MULTICS was the second system after the MIT's Compatible Time-Sharing System?</p>
<p class="normal"><b>汤普森：</b>是的。如此过度设计和过度建造以及一切。它几乎无法使用。他们仍然声称这是一个巨大的成功，但事实显然并非如此。</p><p class="normal"><b>Thompson:</b> Yes. So overdesigned and overbuilt and over everything. It was close to unusable. They still claim it's a monstrous success, but it just clearly wasn't.</p>
<p class="normal"><b>Seibel：</b>我的理解是，很多麻省理工学院的黑客都以同样的方式看待 MULTICS。他们更喜欢 ITS 和他们构建的基于 Lisp 的系统。似乎有一个真正的分叉后 MULTICS。正如你所知，Unix 出现了，在麻省理工学院，这些 Lisp 的家伙开始在 PDP-10 上做他们的事情，并构建了基于 Lisp 的系统，我猜这最终催生了 Lisp 机器。</p><p class="normal"><b>Seibel:</b> My understanding was that a lot of the MIT hackers viewed MULTICS that same way. They preferred ITS and the Lisp-based systems that they built. It seems there was a real fork post-MULTICS. Unix came out, as you well know, and at MIT these Lisp guys went off and did their things on PDP-10s and built Lisp-based systems which, eventually I guess, begat the Lisp machines.</p>
<p class="normal"><b>汤普森：</b>是的，是的。我认识所有这些人。我认为这是一份疯狂的工作。我不认为 Lisp 是一种足够独特的语言来保证一台机器。我认为我被证明是正确的。我一直在说，“你疯了。” PDP-11 是一台很棒的 Lisp 机器。PDP-10 是一台很棒的 Lisp 机器。没有必要建造一个速度不快的 Lisp 机器。根本没有理由建造 Lisp 机器。这有点愚蠢。</p><p class="normal"><b>Thompson:</b> Yeah, yeah. I knew all those guys. I thought it was a crazy job. I didn't think that Lisp was a unique enough language to warrant a machine. And I think I was proved right. All along I said, “You're crazy.” The PDP-11's a great Lisp machine. The PDP-10's a great Lisp machine. There's no need to build a Lisp machine that's not faster. There was just no reason to ever build a Lisp machine. It was kind of stupid.</p>
<p class="normal"><b>Seibel：</b> MULTICS 有没有你喜欢但从未进入 Unix 的特性？</p><p class="normal"><b>Seibel:</b> Are there any features of MULTICS that you did like but that never made it into Unix?</p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_464"></a><b>Thompson：</b>我最喜欢的东西是分层文件系统和 shell——一个可以用其他进程替换的独立进程。在此之前，所有系统都有某种“执行”——这是它的典型词——是一种内置的处理语言。每进程执行。每次你输入 shell 时，它都会创建一个新进程并运行你输入的任何内容，当它消失时你会回来，这样你就可以与正在运行的东西保持一定距离。</p><p class="normal"><a></a><b>Thompson:</b> The things that I liked enough to actually take were the hierarchical file system and the shell—a separate process that you can replace with some other process. Before that all systems had some sort of “executive”—that was the typical word for it—which was a built-in processing language. Per-process execution. Every time you type to the shell and it creates a new process and runs whatever you typed and when that dies you come back so that you're at arm's length from the thing you're running.</p>
<p class="normal"><b>Seibel：</b>所以这些都是你拿走的东西；你没有留下什么让你现在后悔的吗？</p><p class="normal"><b>Seibel:</b> So those are all things you did take; there's nothing you left behind that you now regret?</p>
<p class="normal"><b>汤普森：</b>没有。</p><p class="normal"><b>Thompson:</b> No.</p>
<p class="normal"><b>Seibel：</b>从我读到的有关 Unix 的历史来看，听起来您使用了您之前描述的设计过程。你考虑了一会儿，然后你的妻子和孩子离开了一个月，你说，“哦，太好了——现在我可以写代码了。”</p><p class="normal"><b>Seibel:</b> From what I've read about the history of Unix, it sounds like you used the design process that you described earlier. You thought about it for a while and then your wife and kid went away for a month and you said, “Oh, great—now I can write the code.”</p>
<p class="normal"><b>Thompson：</b>是的……我们一群人坐下来讨论文件系统。我们大约有三四个人。唯一不为人所知的人是一个名叫 Rudd Canady 的人。在那些日子里，贝尔实验室的便利设施非常好——你可以拨打一个电话号码并得到转录。你知道，留言说你想把它写下来，第二天它就会以纸的形式出现在你的收件箱里。而 Canady，我们在黑板上讲了一会儿文件系统之后，拿起电话，拨了一个号码，把黑板读到手机里。</p><p class="normal"><b>Thompson:</b> Yeah.... A group of us sat down and talked about a file system. There were about three or four of us. The only person who's not well known is a guy named Rudd Canady. In those days at Bell Labs the amenities were great—you could call a telephone number and get a transcription. You know, leave a message and say you want it written up and it'll appear the next day in your inbox as sheets of paper. And Canady, after we talked about the file system on the blackboard for a little while, picked up the phone, called a number, and read the blackboard into the phone.</p>
<p class="normal">它回来了，它和我们得到的设计文件差不多，除了它有你不会相信的同音异义词。所以我开始严格地在 PDP-7 上实现这个文件系统。在某个时候，我决定必须对其进行测试。所以我写了一些负载生成的东西。但是我在编写驱动文件系统的程序时遇到了麻烦。你想要一些互动的东西。</p><p class="normal">It came back and it was about as close to a design document as we got except that it had homonyms that you wouldn't believe. So I went off and implemented this file system, strictly on a PDP-7. At some point I decided that I had to test it. So I wrote some load-generating stuff. But I was having trouble writing programs to drive the file system. You want something interactive.</p>
<p class="normal"><b>Seibel：</b>你只是想尝试编写一个文件系统？那时您不打算编写操作系统吗？</p><p class="normal"><b>Seibel:</b> And you just wanted to play around with writing a file system? At that point you weren't planning to write an OS?</p>
<p class="normal"><b>Thompson：</b>不，它只是一个文件系统。</p><p class="normal"><b>Thompson:</b> No, it was just a file system.</p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_465"></a><b>Seibel：</b>所以你基本上编写了一个操作系统，这样你就有了一个更好的环境来测试你的文件系统。</p><p class="normal"><a></a><b>Seibel:</b> So you basically wrote an OS so you'd have a better environment to test your file system.</p>
<p class="normal"><b>汤普森：</b>是的。读到一半，我意识到这是一个真正的分时系统。我正在编写 shell 来驱动文件系统。然后我写了几个驱动文件系统的其他程序。就在那里我说，“我只需要一个编辑器，我有一个操作系统。”</p><p class="normal"><b>Thompson:</b> Yes. Halfway through there that I realized it was a real time-sharing system. I was writing the shell to drive the file system. And then I was writing a couple other programs that drove the file system. And right about there I said, “All I need is an editor and I've got an operating system.”</p>
<p class="normal"><b>Seibel：</b>您不得不追踪的最严重的错误是什么？</p><p class="normal"><b>Seibel:</b> What's the worst bug you've ever had to track down?</p>
<p class="normal"><b>Thompson：</b>基本上是内存损坏的错误。它再也不会发生了。我不知道为什么。但在早期，我们总是使用各种实验性硬件，并且会出现一些硬件错误。</p><p class="normal"><b>Thompson:</b> Basically bugs where memory gets corrupted. It never happens anymore. I don't know why. But in the early days we were always working with experimental hardware of various sorts, and there'd be some hardware bug.</p>
<p class="normal"><b>Seibel：</b>所以内存会因硬件故障而不是失控指针而损坏？</p><p class="normal"><b>Seibel:</b> So memory would get corrupted by the hardware screwing up, not by a runaway pointer?</p>
<p class="normal"><b>汤普森：</b>它可能是指针。它可能是硬件。或组合。我真正想到的最糟糕的例子是 PDP-11。它没有乘法，但您可以购买一个乘法单元并将其插入，但它是一个 I/O 外围设备。你会存储一个分子和一个分母然后说走。你会忙循环，然后得出答案、商和余数。这个东西是为非内存管理的 PDP-11 构建的，我们得到了第一个内存管理的 PDP-11 实验硬件，这个乘法单元不适合内存管理。</p><p class="normal"><b>Thompson:</b> It could be pointer. It could be hardware. Or a combination. The one I'm actually thinking of, the worst example, was the on PDP-11. It didn't have multiply but you could buy a multiply unit and plug it in, but it was an I/O peripheral. You would store a numerator and a denominator and say go. You'd busy-loop and then pull out the answer, the quotient and the remainder. And this thing was built for a non-memory-managed PDP-11 and we got the first experimental hardware for a memory-managed PDP-11 and this multiply unit didn't fit with the memory management well.</p>
<p class="normal">所以你会存储到这个东西然后你会忙于测试。在繁忙测试的某些方面，它会向下发送物理地址而不是虚拟地址，并且某些内存会被您试图除以的分子破坏。你要花很长时间才能找到它，而且它会在不同的地方。这是迄今为止我所找到的最难的一个。</p><p class="normal">So you'd store into this thing and then you'd busy-test. And during certain aspects of the busy test it would send a physical address down instead of a virtual address and some piece of memory would get clobbered with a numerator of what you were trying to divide by. And it'd be ages before you'd find it, and it'd be different places. That's by far the hardest one I'd ever had to find.</p>
<p class="normal"><b>Seibel：</b>你是怎么找到它的？</p><p class="normal"><b>Seibel:</b> How did you track it down?</p>
<p class="normal"><b>Thompson：我写了一个程序，目标是创造</b><i>e</i>位数的世界纪录。以前的世界纪录不是受限于计算量（每秒周期数），而是受 I/O 限制。我想出了一个<a id="OEBPS/Chapter12.html.page_466"></a>受计算限制且 I/O 变得微不足道的新算法。它的乘法和除法非常繁重。我们注意到，每当我安装我的程序时，机器就会崩溃。因此我们得到了联系。</p><p class="normal"><b>Thompson:</b> There was a program that I wrote that was going after a world record for the number of digits of <i>e</i>. Previous world records were limited not by computation—by cycles per second—but by I/O. I came up with a <a></a>new algorithm where it was computation-bound and I/O became trivial. It was monstrously heavy on multiply and divide. And we noticed that the machine just crumbled whenever I put on my program. And therefore we got the connection.</p>
<p class="normal"><b>Seibel：</b>所以这给了你乘法器有问题的线索；您最终是否找到了根本原因？</p><p class="normal"><b>Seibel:</b> So that gave you the clue that there was a problem with the multiplier; did you ultimately track it down to some root cause?</p>
<p class="normal"><b>汤普森：</b>在某些时候，我们把它放到乘法单元中存储在乘法器中的位置，然后将它拉回来，它就不在那里了。我们向DEC反映，DEC找不到，不想处理。他们正常人根本不想对付这种混血机体。那时候你真的拿到了机器的电路图，我们真的在电路图中找到了错误。然后我们就打电话给 DEC 说，“连接那根线和那根线。”</p><p class="normal"><b>Thompson:</b> At some point we got it to where you store in the multiplier in the multiply unit, and you pull it back and it wasn't there. We reported that to DEC and DEC couldn't find it, and they didn't want to deal with it. Their normal people didn't want to deal with this hybrid machine. In those days you actually got the circuit diagrams of the machines, and we actually found the bug in the circuit diagrams. Then we just called DEC and said, “Connect that wire and that wire.”</p>
<p class="normal"><b>Seibel：</b>所以，值得庆幸的是，这些天硬件大多不会以这种方式出现在我们身上。</p><p class="normal"><b>Seibel:</b> So, thankfully, hardware mostly doesn't flake out on us that way these days.</p>
<p class="normal"><b>汤普森：</b>是的。这就是为什么我认为它们很少见。此外，事物之间更加孤立——如果你变得异常疯狂，你就会犯错。你也用汇编语言做到了——通过一些子程序调用，很容易在一些寄存器中有错误的东西。当你拥有一种所有参数都必须匹配的高级语言时，这些事情就会变得越来越少。</p><p class="normal"><b>Thompson:</b> Yeah. That's why I think they're rare. Plus things are isolated from each other more—if you go bizarrely wild you'll get a fault. Also you did it in assembly language—it's really easy to have the wrong thing in some register through some subroutine call. When you have a high-level language where the arguments all have to match up, these things become more and more rare.</p>
<p class="normal">在早期，在汇编语言中，你会发现它们很多。如果它是软件，而不是软件/硬件的组合，通常它会发生在一个地方——同一个地方会被破坏。该错误与某些事物之间存在某种关联。你可以坐在那里，在操作系统中放置一个监视器。每隔一段时间，或者非常频繁地，你会检查并查看错误是否发生，并尽可能快地停下来，看看其他地方发生了什么，并以此方式追查他们。所以你可以攻击他们。</p><p class="normal">In the early days, in assembly language, you'd find them a lot. If it was software, as opposed to a combination of software/hardware, usually it would happen in one spot—the same spot would be corrupted. There'd be some correlation of the bug with something. And you could sit there and put a monitor in the operating system. And every so often, or very often, you'd check and see if the error occurred, and stop as quick as you can, and see what's going on elsewhere, and chase them down that way. So you could attack them.</p>
<p class="normal">这个你不能攻击。直到我编写了这个密集的乘法/除法程序，它才发现错误的频率越来越高。与其每隔几天崩溃一次，不如崩溃一次<a id="OEBPS/Chapter12.html.page_467"></a>每隔几分钟。然后，一旦您得到会使机器崩溃的东西，您就有机会找到它。</p><p class="normal">This one you couldn't attack. It wasn't until I wrote this intensive multiply/divide program that it saw the frequency of the error went way, way up. Instead of crashing once every couple of days you'd crash once <a></a>every couple of minutes. And then as soon as you got something that would crash the machine you had a fighting chance to find it.</p>
<p class="normal"><b>Seibel：</b>所以今天有些人会说，“嗯，当然汇编有所有这些机会通过软件错误真正破坏内存，但 C 也比其他一些语言更容易出现这种情况。” 你可以得到指向 la-la land 的指针，你可以走过数组的末端。你不觉得这有什么问题吗？</p><p class="normal"><b>Seibel:</b> So some folks today would say, “Well, certainly assembly has all these opportunities to really corrupt memory through software bugs, but C is also more prone to that than some other languages.” You can get pointers off into la-la land and you can walk past the ends of arrays. You don't find that at all problematic?</p>
<p class="normal"><b>汤普森：</b>不，你可以用语言中的习语来解决这个问题。有些人写的代码很脆弱，有些人写的代码结构非常合理，这是人的一种状态。我认为几乎任何语言都可以编写脆弱的代码。我对脆弱代码的定义是，假设你想添加一个特性——好的代码，有一个地方你可以添加那个特性并且它适合；脆弱的代码，你必须接触十个地方。</p><p class="normal"><b>Thompson:</b> No, you get around that with idioms in the language. Some people write fragile code and some people write very structurally sound code, and this is a condition of people. I think in almost any language you can write fragile code. My definition of fragile code is, suppose you want to add a feature—good code, there's one place where you add that feature and it fits; fragile code, you've got to touch ten places.</p>
<p class="normal"><b>Seibel：</b>因此，当出现安全漏洞并最终证明是由于缓冲区溢出时，对于 C 和 C++ 负有部分责任的批评，您怎么看？如果人们使用一种检查数组边界或进行垃圾回收的语言，他们会避免很多这类问题吗？</p><p class="normal"><b>Seibel:</b> So when there's a security breach that turns out to be due to a buffer overflow, what do you say to the criticism that C and C++ are partly responsible—that if people would use a language that checked array bounds or had garbage collection, they'd avoid a lot of these kinds of problems?</p>
<p class="normal"><b>汤普森：</b>虫子就是虫子。你写的代码有错误，因为你这样做。如果它是运行时安全意义上的安全语言，操作系统就会崩溃，而不是以可利用的方式进行缓冲区溢出。ping of death 是操作系统中的 IP 堆栈。在我看来，会有更多的死亡提示音。不会出现“接管机器成为超级用户”的提示。会有死亡的声音。</p><p class="normal"><b>Thompson:</b> Bugs are bugs. You write code with bugs because you do. If it's a safe language in the sense of run-time-safe, the operating system crashes instead of doing a buffer overflow in a way that's exploitable. The ping of death was the IP stack in the operating system. It seems to me that there'd be more pings of death. There wouldn't be pings of “take over the machine becoming superuser.” There'd be pings of death.</p>
<p class="normal"><b>Seibel：</b>但是拒绝服务攻击和获得 root 权限然后可以用盒子做任何想做的事情之间存在差异。</p><p class="normal"><b>Seibel:</b> But there is a difference between a denial-of-service attack and an exploit where you get root and can then do whatever you want with the box.</p>
<p class="normal"><b>Thompson：</b>但是有两种获取 root 的方法——一种是溢出缓冲区，另一种是让程序做一些它不应该做的事情。而且大部分都是后者，不会溢出一个buffer。您可以在不溢出任何缓冲区的情况下成为 root 用户。所以你的论点不成立。您所要做的就是说服 su 为您提供一个 shell——所有路径都在那里，没有任何运行时错误。</p><p class="normal"><b>Thompson:</b> But there are two ways to get root—one is to overflow a buffer and the other is to talk the program into doing something it shouldn't do. And most of them are the latter, not overflowing a buffer. You can become root without overflowing any buffers. So your argument's just not on. All you've got to do is talk su into giving you a shell—the paths are all there without any run-time errors.</p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_468"></a><b>塞贝尔：</b>好的。撇开它是否会导致崩溃或漏洞利用或其他任何原因——出于同样的原因，C 和 C++ 中会发生一类错误，而这些错误不会发生在 Java 中。因此，对于某些类型的应用程序，允许此类错误所带来的好处真的值得它造成的痛苦吗？</p><p class="normal"><a></a><b>Seibel:</b> OK. Leaving aside whether it results in a crash or an exploit or whatever else—there is a class of bugs that happen in C, and C++ for the same reason, that wouldn't happen in, say, Java. So for certain kinds of applications, is the advantage that you get from allowing that class of bugs really worth the pain that it causes?</p>
<p class="normal"><b>汤普森：</b>我认为阶级实际上是少数问题。当然，每次我编写这些非比较子例程调用之一，<code>strcpy</code>以及类似的东西时，我都知道我正在编写一个错误。而且我以某种方式做出了这个错误是否值得额外争论的经济决定。通常现在我经常把它写出来。但是有一个语义问题，如果你截断一个字符串并使用截断的字符串，你会遇到另一个问题。错误仍然存​​在——它只是没有溢出缓冲区。</p><p class="normal"><b>Thompson:</b> I think that class is actually a minority of the problems. Certainly every time I've written one of these non-compare subroutine calls, <code>strcpy</code> and stuff like that, I know that I'm writing a bug. And I somehow take the economic decision of whether the bug is worth the extra arguments. Usually now I routinely write it out. But there's a semantic problem that if you truncate a string and you use the truncated string are you getting into another problem. The bug is still there—it just hasn't overflown the buffer.</p>
<p class="normal"><b>Seibel：</b>当你调试时，你使用什么工具？</p><p class="normal"><b>Seibel:</b> When you're debugging, what tools do you use?</p>
<p class="normal"><b>汤普森：</b>大多数情况下，我只是打印值。在开发程序时，我会进行大量打印。当我取出或注释掉时，印刷品确实非常坚固。我很少需要回去。</p><p class="normal"><b>Thompson:</b> Mostly I just print values. When I'm developing a program I do a tremendous amount of printing. And by the time I take out, or comment out, the prints it really is pretty solid. I rarely have to go back.</p>
<p class="normal"><b>Seibel：</b>你打印出什么样的东西？</p><p class="normal"><b>Seibel:</b> And what kinds of things do you print out?</p>
<p class="normal"><b>汤普森：</b>无论我需要什么；拖着什么。不变量。但大多数情况下，我只是在开发它的同时进行打印。这就是我调试它的方式。我不会从头开始编写程序。我拿一个程序并修改它。即使是一个大程序，我也会说“main, left, right, print, hello”。好吧，“你好”不是我想从这个程序中得到的。我首先想要的是什么，我将编写并调试该部分。我将每小时运行一个我正在开发的程序 20 次，并逐步建立它。</p><p class="normal"><b>Thompson:</b> Whatever I need; whatever is dragging along. Invariants. But mostly I just print while I'm developing it. That's how I debug it. I don't write programs from scratch. I take a program and modify it. Even a big program, I'll say “main, left, right, print, hello.” And well, “hello” isn't what I wanted out from this program. What's the first thing I want out, and I'll write that and debug that part. I'll run a program 20 times an hour that I'm developing, building up to it.</p>
<p class="normal"><b>Seibel：</b>你打印出不变量；您还使用检查不变量的断言吗？</p><p class="normal"><b>Seibel:</b> You print out invariants; do you also use asserts that check invariants?</p>
<p class="normal"><b>汤普森：</b>很少。我说服自己这是正确的，然后要么注释掉印刷品要么扔掉它们。</p><p class="normal"><b>Thompson:</b> Rarely. I convince myself it's correct and then either comment out the prints or throw them away.</p>
<p class="normal"><b>Seibel：</b>那么为什么打印不变量为真比仅<code>assert</code>用于自动检查更容易呢？</p><p class="normal"><b>Seibel:</b> So why is it easier for you to print that an invariant is true rather than just using <code>assert</code> to check it automatically?</p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_469"></a><b>汤普森：</b>因为当你打印时，你实际上看到了它是什么而不是它是一个特定的值，而且你打印了一堆不是不变的东西。这就是我做事的方式。我不建议将其作为范例。这正是我一直在做的。</p><p class="normal"><a></a><b>Thompson:</b> Because when you print you actually see what it is as opposed to it being a particular value, and you print a bunch of stuff that aren't invariants. It's just the way that I do it. I'm not proposing it as a paradigm. It's just what I've always done.</p>
<p class="normal"><b>Seibel：</b>当我们谈到如何设计软件时，您描述了一个自下而上的过程。你是孤立地构建那些自下而上的部分吗？</p><p class="normal"><b>Seibel:</b> When we talked about how you design software, you described a bottom-up process. Do you build those bottom-up pieces in isolation?</p>
<p class="normal"><b>汤普森：</b>有时我会。</p><p class="normal"><b>Thompson:</b> Sometimes I do.</p>
<p class="normal"><b>Seibel：</b>您是否编写测试脚手架来测试您的低级功能？</p><p class="normal"><b>Seibel:</b> And do you write test scaffolds for testing your low-level functions?</p>
<p class="normal"><b>汤普森：</b>是的，我经常这样做。这真的取决于我正在处理的程序。如果程序是从<i>A</i>到<i>B</i>的翻译器，我将有一大堆<i>A</i>和相应的<i>B</i>。我将通过在所有<i>A</i>中运行并将其与所有<i>B进行比较来回归它</i>秒。编译器或翻译器或正则表达式搜索。像那样的东西。但是还有其他类型的程序不是这样的。我从来没有做过太多的测试，我对那些程序有点不知所措。我会投入一些检查，但通常它们不会在程序中或程序周围持续存在，因为它们太难与程序一起维护。大多数只是回归测试。</p><p class="normal"><b>Thompson:</b> Yeah, very often I do that. It really depends on the program I'm working on. If the program is a translator from <i>A</i> to <i>B</i>, I'll have a whole bunch of <i>A</i>s lying around and the corresponding <i>B</i>s. And I'll regress it by running in all the <i>A</i>s and comparing it to all the <i>B</i>s. A compiler or a translator or a regular-expression search. Something like that. But there are other kinds of programs that aren't like that. I've never been into testing much, and those kinds of programs I'm kind of at a loss. I'll throw in some checks, but very often they don't last in the program or around the program because they're too hard to maintain with the program. Mostly just regression tests.</p>
<p class="normal"><b>Seibel：</b>您所说的更难测试的东西是指设备驱动程序或网络协议之类的东西吗？</p><p class="normal"><b>Seibel:</b> By things that are harder to test, you mean things like device drivers or networking protocols?</p>
<p class="normal"><b>汤普森：</b>嗯，当你实际运行一个操作系统时，它们一直在运行。</p><p class="normal"><b>Thompson:</b> Well, they're run all the time when you're actually running an operating system.</p>
<p class="normal"><b>Seibel：</b>所以你认为你会用这种方式摆脱错误？</p><p class="normal"><b>Seibel:</b> So you figure you'll shake the bugs out that way?</p>
<p class="normal"><b>汤普森：</b>哦，当然。我的意思是，作为对操作系统的测试，有什么比人们殴打它更好的呢？</p><p class="normal"><b>Thompson:</b> Oh, absolutely. I mean, what's better as a test of an operating system than people beating on it?</p>
<p class="normal"><b>Seibel：</b>编程的另一个阶段是优化。有些人从一开始就优化事情。其他人喜欢以一种方式编写它，然后担心稍后对其进行优化。你的方法是什么？</p><p class="normal"><b>Seibel:</b> Another phase of programming is optimization. Some people optimize things from the very beginning. Others like to write it one way and then worry about optimizing it later. What's your approach?</p>
<p class="normal"><b>汤普森：</b>我会在第一次时尽可能简单地做这件事，而且通常这样就足够了。为某些东西建立一个非常复杂的算法<a id="OEBPS/Chapter12.html.page_470"></a>从不跑只是愚蠢。这只是浪费时间。这是一个错误生成器。这使得维护变得不可能，因为你必须有 50 页的数学来告诉下一个人你实际上在做什么。</p><p class="normal"><b>Thompson:</b> I'll do it as simply as possible the first time and very often that suffices for all time. To build a very complex algorithm for something that's <a></a>never run is just stupid. It's just a waste of time. It's a bug generator. And it makes it impossible to maintain because you've got to have 50 pages of math to tell the next guy what you're actually doing.</p>
<p class="normal">百分之九十九的时间一些简单和蛮力会工作得很好。如果你真的在构建一个经常使用的工具并且它有某种次要的二次行为，有时你必须进去并击败它。但通常不会。越简单越好。</p><p class="normal">Ninety-nine percent of the time something simple and brute-force will work fine. If you really are building a tool that is used a lot and it has some sort of minor quadratic behavior sometimes you have to go in and beat on it. But typically not. The simpler the better.</p>
<p class="normal"><b>Seibel：</b>有些人只是为了代码本身而喜欢将代码精简到珠宝般的完美。</p><p class="normal"><b>Seibel:</b> Some people just like bumming code down to a jewel-like perfection, for its own sake.</p>
<p class="normal"><b>汤普森：</b>嗯，我也是，但部分原因是牺牲了代码的算法。我的意思是，通常一个复杂的算法需要复杂的代码。而且我宁愿有一个简单的算法和简单的代码，也不愿有一些大恐怖。如果说我的代码有什么特点的话，那就是它简单、起伏不定而且很少。没有什么花哨。任何人都可以阅读它。</p><p class="normal"><b>Thompson:</b> Well, I do too, but part of that is sacrificing the algorithm for the code. I mean, typically a complex algorithm requires complex code. And I'd much rather have a simple algorithm and simple code than some big horror. And if there's one thing that characterizes my code, it's that it's simple, choppy, and little. Nothing fancy. Anybody can read it.</p>
<p class="normal"><b>Seibel：</b>是否还有一些任务，出于性能原因，人们仍然不得不着手手动调整汇编代码？</p><p class="normal"><b>Seibel:</b> Are there still tasks which, for performance reasons, people still have to get down to hand-tuned assembly code?</p>
<p class="normal"><b>汤普森：</b>这很少见。除非你真的能得到一个数量级而你不能，否则是极其罕见的。如果你真的努力工作，让一个大程序的一小部分运行速度提高一倍，那么只要等一两年，你就可以让整个程序运行速度提高一倍。如果您正在编写一个编译器——您生成的代码中 99% 肯定会运行一次或两次。但其中一些将在一个每天 24 小时运行的操作系统中。其中一些将位于该操作系统的内部循环中。因此，您在此处对编译器进行的优化的 0.1% 可能会对您的用户产生任何影响。但它可以产生深远的影响，所以也许你想这样做。</p><p class="normal"><b>Thompson:</b> It's rare. It's extremely rare unless you can really get an order of magnitude and you can't. If you can really work hard and get some little piece of a big program to run twice as fast, then you could have gotten the whole program to run twice as fast if you had just waited a year or two. If you're writing a compiler—certainly 99 percent of the code you produce is going to be run once or twice. But some of it's going to be in an operating system that's run 24 hours a day. And some of it's going to be in the inner, inner loop of that operating system. So maybe 0.1 percent of the optimization you put into a compiler here is going to have any effect on your users. But it can have profound effect, so there maybe you want to do it.</p>
<p class="normal"><b>Seibel：</b>但这是在编译器中生成更好代码的结果，而不是在汇编中编写编译器本身。</p><p class="normal"><b>Seibel:</b> But that would be a result of generating better code in the compiler rather than writing the compiler itself in assembly.</p>
<p class="normal"><b>汤普森：</b>哦，是的，是的。</p><p class="normal"><b>Thompson:</b> Oh, yes, yes.</p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_471"></a><b>Seibel：</b>现在直接用汇编编写程序可能不那么重要的部分原因是因为编译器变得更好了。</p><p class="normal"><a></a><b>Seibel:</b> And presumably part of the reason writing programs directly in assembly is less important these days is because compilers have gotten better.</p>
<p class="normal"><b>汤普森：</b>不。我认为这主要是因为机器变得更好了。编译器很臭。你看看从 GCC 出来的代码，它很糟糕。真的不好。而且很慢；天啊。我的意思是，编译器本身超过 20 遍。它只是非常慢，但自从 GCC 出现以来，计算机已经快了 1,000 倍。所以看起来它似乎越来越快，因为它并没有像它下面的计算机越来越快那样变慢。</p><p class="normal"><b>Thompson:</b> No. I think it's mostly because the machines have gotten a lot better. Compilers stink. You look at the code coming out of GCC and it's awful. It's really not good. And it's slow; oh, man. I mean, the compiler itself is over 20 passes. It's just monstrously slow, but computers have gotten 1,000 times faster since GCC came out. So it may seem like it's getting faster because it's not getting slower as much as computers are getting faster underneath it.</p>
<p class="normal"><b>Seibel：</b>在某种程度上相关的说明中，垃圾收集怎么样？在 Java 中，GC 终于成为了主流。正如 Dennis Ritchie 曾经说过的那样，C 对垃圾收集持积极的敌意。人们转向垃圾收集语言是好事吗——它是一项最终应该成为主流使用的技术吗？</p><p class="normal"><b>Seibel:</b> On a somewhat related note, what about garbage collection? With Java, GC has finally made it into the mainstream. As Dennis Ritchie once said, C is actively hostile to garbage collection. Is it good that folks are moving toward garbage-collected languages—is it a technology that deserves to finally be in mainstream use?</p>
<p class="normal"><b>汤普森：</b>我不知道。我在这个问题上精神分裂。如果你正在编写操作系统或 C 编译器或被很多人使用的东西，我认为垃圾收集几乎是一个错误。这对您来说是一种欺骗，您可以手工完成并做得更好——更好。你正在做的是你正在放弃你的任务，你的工作，让你的用户更慢。所以我认为这是操作系统的错误。它几乎不适合操作系统。但如果你正在编写一个 hack 程序来完成一项工作，得到一个答案然后扔掉这个程序，那就太好了。它需要一层你不想考虑的东西，以你可以承受的代价，因为计算机是如此之快，而且它只不过是一个双赢的立场。所以我'</p><p class="normal"><b>Thompson:</b> I don't know. I'm schizophrenic on the subject. If you're writing an operating system or a C compiler or something that's used by lots and lots of people, I think garbage collection is a mistake, almost. It's a cheat for you where you can do it by hand and do it better—much better. What you're doing is you're sloughing your task, your job, making it slower for your users. So I think it's a mistake in an operating system. It almost just doesn't fit in an operating system. But if you are writing a hack program to do a job, get an answer and then throw the program away, it's beautiful. It takes a layer of stuff you don't want to think about, at a cost you can afford, because computers are so fast, and it's nothing but a win-win-win position. So I'm really schizophrenic on this subject.</p>
<p class="normal">部分问题在于存在不同的垃圾收集算法，它们具有不同的属性——非常不同的属性。所以你正在编写一些真正通用的东西，比如操作系统——如果你打算用一种在底层进行垃圾收集的语言来编写它，你甚至无法为操作系统选择算法。假设您无法忍受较大的实时间隙，并且您有一个垃圾收集器运行到某个阈值，然后进行标记和清除。你还没开始就完蛋了。</p><p class="normal">Part of the problem is there are different garbage-collection algorithms and they have different properties—massively different properties. So you're writing some really general-purpose thing like an operating system—if you're going to write it in a language that garbage-collects underneath, you don't even have the choice of the algorithm for the operating systems. Suppose that you just can't stand big real-time gaps and you have a garbage collector that runs up to some threshold and then does mark and sweep. You're screwed before you start.</p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_472"></a>因此，如果您正在执行一些您不知道真正的用户是谁的通用任务，那么您就不能这样做。另外，垃圾收集会大规模地与缓存一致性作斗争。并且没有适合所有机器的垃圾收集算法。在有些机器上，您可以通过摆弄缓存将其速度提高五倍或更多。他们应该比现在更依赖于机器。通常他们将它们视为与机器无关的独立算法，但缓存一致性对于垃圾收集算法非常重要。</p><p class="normal"><a></a>So if you're doing some general-purpose task that you don't know who your real users are, you just can't do that. Plus, garbage collection fights cache coherency massively. And there's no garbage-collection algorithm that is right for all machines. There are machines where you can speed it up by a factor of five or more by messing around with the cache. They should be tied to the machine much more than they are. Usually they treat them as separate algorithms that have nothing to do with machines, but the cache coherency is very important for garbage-collection algorithms.</p>
<p class="normal"><b>Seibel：</b>你认为自己是科学家、工程师、艺术家、工匠还是其他什么？</p><p class="normal"><b>Seibel:</b> Do you think of yourself as a scientist, an engineer, an artist, a craftsman, or something else?</p>
<p class="normal"><b>汤普森：</b>我不知道。我讨厌使用<i>科学家</i>这个词，因为我认为它是精英主义者。并意味着博士学位。当你完成科学家课程时，上面没有写着“科学家”的证书，所以我不喜欢也不使用这个词。工程师，我确实有一个学位，上面写着“工程师”，所以我可以使用<i>工程师</i>这个词。当我填写职业时，我会选择工程师或程序员，因为我可以证明这些。但大多数时候我只是不担心。</p><p class="normal"><b>Thompson:</b> I don't know. I hate to use the word <i>scientist</i> because I think it's elitist. And implies a PhD. There's no certificate that says “scientist” on it when you complete the scientist course, so I don't like the term or use it. Engineer, I do have a degree that says “engineer” on it, so I can use the word <i>engineer</i>. And when I fill out an occupation I either put engineer or programmer because I can justify those. But mostly I just don't worry about it.</p>
<p class="normal"><b>Seibel：</b>好吧，抛开你对自己的称呼不谈，你觉得谁最有亲和力？是物理学家、造桥的人、画家还是木匠？</p><p class="normal"><b>Seibel:</b> Well, leaving aside what you call yourself, who do you feel the most affinity with? Is it a physicist, a guy who builds bridges, a painter, or a carpenter?</p>
<p class="normal"><b>汤普森：</b>有点低级的东西。我相信一个工匠，但有一定的艺术性来保持它的活力。</p><p class="normal"><b>Thompson:</b> Kind of the lower things. I believe a craftsman but with a certain amount of artistry to keep it alive.</p>
<p class="normal"><b>Seibel：</b>您如何识别有才华的程序员？</p><p class="normal"><b>Seibel:</b> How do you identify talented programmers?</p>
<p class="normal"><b>汤普森：</b>这只是热情。你问他们做过的最有趣的项目是什么。然后你让他们描述它和它的算法以及发生了什么。如果他们经不起我对他们节目的质问，那他们就不是好人。如果我可以攻击他们或发现他们的算法和解决方案存在问题，而他们无法捍卫它，比我更亲自参与，那么就不会。同时你可以得到一种热情的感觉。这不是你直接问的问题，但在谈话中你会带着这个热情计来，这对我来说非常有帮助。我就是这样面试的。有人告诉我，站在接收端是毁灭性的。</p><p class="normal"><b>Thompson:</b> It's just enthusiasm. You ask them what's the most interesting program they worked on. And then you get them to describe it and its algorithms and what's going on. If they can't withstand my questioning on their program, then they're not good. If I can attack them or find problems with their algorithms and their solutions and they can't defend it, being much more personally involved than I am, then no. At the same time you can get a sense of enthusiasm. It's not something you ask directly, but in the conversation you'll come with this enthusiasm-ometer, and that is tremendously helpful for me. That's how I interview. I've been told that it's devastating to be on the receiving side of that.</p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_473"></a><b>Seibel：</b>我会想象。这有点像口语考试。您认为您是否遇到过那些不具备独立于编程能力而无法处理这种情况的个性的人？</p><p class="normal"><a></a><b>Seibel:</b> I would imagine. It's sort of like an oral exam. Do you suppose you've ever run into people who just didn't have the personality that can deal with that, independent of their programming ability?</p>
<p class="normal"><b>Thompson：</b>不，我不认为它独立于编程。如果我开始问他们经典的计算机科学类问题，那会是这样，但这不是我要问的。我要他们描述他们曾经做过的、他们曾为之付出鲜血的事情。我从来没有遇到过真正为某件事付出鲜血的人，他们不急于描述他们做了什么、他们是如何做的以及为什么这样做。我让他们选择主题。我不选择主题，所以我是业余爱好者，而他们是这个主题的专业人士。如果他们不能忍受一个业余爱好者问他们关于他们职业的问题，那么他们就不属于。</p><p class="normal"><b>Thompson:</b> No, I don't think it's independent of programming. It would be if I started asking them classical computer-science kind of questions, but that's not what I'm asking them. I'm asking them to describe something they've done that they've spent blood on. I've never met anybody who really did spend blood on something who wasn't eager to describe what they've done and how they did it and why. I let them pick the subject. I don't pick the subject, so I'm the amateur and they're the professional in this subject. If they can't stand an amateur asking them questions about their profession, then they don't belong.</p>
<p class="normal"><b>Seibel：</b>你在谷歌做什么？</p><p class="normal"><b>Seibel:</b> What are you doing here at Google?</p>
<p class="normal"><b>汤普森：</b>基础设施。操作系统之类的东西。片之间的胶水。我有任何我想要的宪章。挑战在于让一堆不可靠的机器像可靠的多处理器机器一样工作。我想那是最接近的东西。</p><p class="normal"><b>Thompson:</b> Infrastructure. Operating-systems kind of stuff. Glue between the pieces. I have a charter for anything I want. The challenge is to get a bunch of unreliable machines to work like a reliable multiprocessor machine. I guess that's the closest thing.</p>
<p class="normal"><b>Seibel：</b> Google 著名的 MapReduce 机制的重点不就是它是无共享消息传递而不是共享内存吗？</p><p class="normal"><b>Seibel:</b> Isn't the point of Google's famous MapReduce machinery that it's shared-nothing message-passing rather than a shared memory?</p>
<p class="normal"><b>汤普森：</b>嗯，这是一个具有众所周知的语义且没有反馈循环的过程。如果你有一个可靠的结构来做到这一点，你可以将很多问题放入该结构中。</p><p class="normal"><b>Thompson:</b> Well, it's a process that has well-known semantics and no feedback loops. If you have a reliable structure to do that, you can fit a lot of problems into that structure.</p>
<p class="normal"><b>Seibel：</b>你是在那种框架内工作的吗？</p><p class="normal"><b>Seibel:</b> And are you working on things within that kind of framework?</p>
<p class="normal"><b>Thompson：</b>不，它只是试图将可靠性的负担从个别程序员身上卸下。这是一个真正艰巨的挑战。这里的所有软件都有层层叠叠的层级，如果这不起作用会发生什么，如果那不起作用会发生什么。如果我不工作会发生什么——谁杀了我，谁开始工作，谁做了什么。我猜超过 50% 的代码是假设类型的。</p><p class="normal"><b>Thompson:</b> No, it's just trying to keep the burden of reliability off the individual programmers. It's a real tough challenge. All the software here has layers and layers and layers of what happens if this doesn't work, what happens if that doesn't work. What happens if I don't work—who kills me and who starts up, who does what. I would guess way more than 50 percent of the code is the what-if kind.</p>
<p class="normal"><b>Seibel：</b>所以你的目标是让那一半代码消失？</p><p class="normal"><b>Seibel:</b> So your goal is to have that half of the code go away?</p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_474"></a><b>汤普森：</b>嗯，它会藏在某个地方。它将以系统的方式应用于其他代码。希望。这是一项艰巨的工作。</p><p class="normal"><a></a><b>Thompson:</b> Well, it would be hidden somewhere. It would apply in a systematic way to the other code. Hopefully. It's a hard job.</p>
<p class="normal"><b>Seibel：</b>你喜欢在谷歌工作吗？</p><p class="normal"><b>Seibel:</b> Do you like working here at Google?</p>
<p class="normal"><b>汤普森：</b>我非常喜欢它的一部分。但它的一部分只是很笨重，因为漏洞涉及金钱，而且很多东西都涉及金钱。规模难以想象。就像第一天一样，你会遇到一些问题，而第二天你就有了 200 万用户。你简直无法想象这样的事情。</p><p class="normal"><b>Thompson:</b> Parts of it I like, very much. But parts of it are just ponderous because there's money involved in bugs and there's money involved in lots of the stuff. The size is unimaginable. Like day one you kind of get something crippling along and day two you've got two million users. You just can't imagine such a thing.</p>
<p class="normal"><b>Seibel：</b>你实际上是在生产方面。而不是在谷歌实验室，这可能更类似于你在贝尔实验室的过去。</p><p class="normal"><b>Seibel:</b> And you're actually on the production side. As opposed to being in Google Labs, which might be more akin to your past at Bell Labs.</p>
<p class="normal"><b>汤普森：</b>但我实际上也不是制作人。我在将要投入生产的项目中。但我不会在他们离开后照看他们。可能我的工作描述——不管我是否遵循它，那是一个不同的问题——只是找到让生活更美好的东西。或者对用新东西取代旧东西有一些新想法。努力让它变得更好。不管是什么错误，都需要时间，会导致错误。如果 Google 的结构中有任何东西，任何你可以指指点点的事情都可以做得更好，那就努力做得更好。</p><p class="normal"><b>Thompson:</b> But I'm not actually production either. I'm in projects that will become production. But I don't babysit them after they've gone. Probably my job description—whether I follow it or not, that's a different question—would be just to find something to make life better. Or have some new idea of new stuff that replaces old stuff. Try to make it better. Whatever it is that's wrong, that takes time, that causes bugs. If there's anything in the structure of Google, anything that you can put your finger on that could be done better, try to do it better.</p>
<p class="normal"><b>Seibel：</b>我知道谷歌有一项政策，每位新员工在被允许签入代码之前必须先检查语言。这意味着你必须检查 C。</p><p class="normal"><b>Seibel:</b> I know Google has a policy where every new employee has to get checked out on languages before they're allowed to check code in. Which means you had to get checked out on C.</p>
<p class="normal"><b>汤普森：</b>是的，我没去过。</p><p class="normal"><b>Thompson:</b> Yeah, I haven't been.</p>
<p class="normal"><b>Seibel：</b>你没去过！你不允许签入代码？</p><p class="normal"><b>Seibel:</b> You haven't been! You're not allowed to check in code?</p>
<p class="normal"><b>Thompson：</b>我不允许签入代码，不。</p><p class="normal"><b>Thompson:</b> I'm not allowed to check in code, no.</p>
<p class="normal"><b>Seibel：</b>您只是还没有解决这个问题，或者您对 Google 编码标准有哲学上的反对意见？</p><p class="normal"><b>Seibel:</b> You just haven't gotten around to it, or you have philosophical objections to the Google coding standard?</p>
<p class="normal"><b>汤普森：</b>我只是没做过。到目前为止，我发现没有必要。</p><p class="normal"><b>Thompson:</b> I just haven't done it. I've so far found no need to.</p>
<p class="normal"><b>Seibel：</b>所以你们是在自己的沙盒中做事？你主要用 C 来做你的事情吗？</p><p class="normal"><b>Seibel:</b> So you're doing your stuff in your own sandbox? Do you mostly do your stuff in C?</p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_475"></a><b>Thompson：</b>我主要用 C 编写。我用 C 做所有的测试和玩具，而谷歌是 C++，严格来说是 C++。用 C++ 编程没什么大不了的，但我不喜欢它。我抗拒它。</p><p class="normal"><a></a><b>Thompson:</b> I write mostly in C. I do all my test stuff and toy stuff in C while Google is C++, strictly C++. It's no big deal programming in C++, but I don't like it. I resist it.</p>
<p class="normal"><b>Seibel：</b>你和 Bjarne Stroustrup 一起在 AT&amp;T。您是否参与过 C++ 的开发？</p><p class="normal"><b>Seibel:</b> You were at AT&amp;T with Bjarne Stroustrup. Were you involved at all in the development of C++?</p>
<p class="normal"><b>汤普森：</b>我会惹上麻烦的。</p><p class="normal"><b>Thompson:</b> I'm gonna get in trouble.</p>
<p class="normal"><b>Seibel：</b>没关系。</p><p class="normal"><b>Seibel:</b> That's fine.</p>
<p class="normal"><b>Thompson：</b>我会在语言开发过程中对其进行试用，并对其发表评论。这是那里工作氛围的一部分。你写了一些东西，但第二天就没法用了，因为语言变了。它在很长一段时间内非常不稳定。在某个时候我说，不，不再。</p><p class="normal"><b>Thompson:</b> I would try out the language as it was being developed and make comments on it. It was part of the work atmosphere there. And you'd write something and then the next day it wouldn't work because the language changed. It was very unstable for a very long period of time. At some point I said, no, no more.</p>
<p class="normal">在一次采访中我说得很准确，我没有使用它只是因为它不会连续两天保持静止。当 Stroustrup 阅读采访时，他冲进我的房间尖叫着说我是如何破坏他的，我说的话很重要，我说这是一种糟糕的语言。我从来没有说过这是一种糟糕的语言。一直持续下去。从那以后我有点避免那种东西。</p><p class="normal">In an interview I said exactly that, that I didn't use it just because it wouldn't stay still for two days in a row. When Stroustrup read the interview he came screaming into my room about how I was undermining him and what I said mattered and I said it was a bad language. I never said it was a bad language. On and on and on. Since then I kind of avoid that kind of stuff.</p>
<p class="normal"><b>Seibel：</b>你现在能说说你认为它是一种好语言还是坏语言吗？</p><p class="normal"><b>Seibel:</b> Can you say now whether you think it's a good or bad language?</p>
<p class="normal"><b>汤普森：</b>它当然有它的优点。但总的来说，我认为这是一种糟糕的语言。它做了很多事情，但它只是一堆相互排斥的想法的垃圾堆。我认识的每个人，无论是个人还是公司，都会选择一个子集，而这些子集是不同的。所以它不是一个很好的语言来传输算法——说，“我写了它；给，拿去。” 它太大了，太复杂了。它显然是由一个委员会建造的。</p><p class="normal"><b>Thompson:</b> It certainly has its good points. But by and large I think it's a bad language. It does a lot of things half well and it's just a garbage heap of ideas that are mutually exclusive. Everybody I know, whether it's personal or corporate, selects a subset and these subsets are different. So it's not a good language to transport an algorithm—to say, “I wrote it; here, take it.” It's way too big, way too complex. And it's obviously built by a committee.</p>
<p class="normal">Stroustrup 年复一年地竞选，远远超出了他对这门语言所做的任何技术贡献，以使其被采用和使用。他用鞭子和椅子来管理所有的标准委员会。他对任何人都说“不”。他把曾经存在过的那种语言的每一个特性都放在了一起。它的设计并不简洁——它只是所有出现的东西的结合。我认为它因此遭受了巨大的损失。</p><p class="normal">Stroustrup campaigned for years and years and years, way beyond any sort of technical contributions he made to the language, to get it adopted and used. And he sort of ran all the standards committees with a whip and a chair. And he said “no” to no one. He put every feature in that language that ever existed. It wasn't cleanly designed—it was just the union of everything that came along. And I think it suffered drastically from that.</p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_476"></a><b>Seibel：</b>你认为那仅仅是因为他喜欢所有的想法，还是通过给每个人他们想要的东西来让语言被采纳的一种方式？</p><p class="normal"><a></a><b>Seibel:</b> Do you think that was just because he likes all ideas or was it a way to get the language adopted, by giving everyone what they wanted?</p>
<p class="normal"><b>汤普森：</b>我认为后者比前者更多。</p><p class="normal"><b>Thompson:</b> I think it's more the latter than the former.</p>
<p class="normal"><b>Seibel：</b>似乎有很多人说，“天哪，C++ 太糟糕了。” 然而每个人都在使用它。例如，它是谷歌的四种官方语言之一。如果它这么糟糕，为什么人们会继续使用它？</p><p class="normal"><b>Seibel:</b> It seems there are a lot of people who say, “Gosh, C++ is terrible.” Yet everyone uses it. For instance, it's one of Google's four official languages. Why do folks continue to use it if it's so bad?</p>
<p class="normal"><b>汤普森：</b>我不知道。我认为它正在输给谷歌。现在不喜欢的人比喜欢的人多。</p><p class="normal"><b>Thompson:</b> I don't know. I think it's losing at Google. Now there are more people who don't like it than like it.</p>
<p class="normal"><b>Seibel：</b>然后他们转向 Java？</p><p class="normal"><b>Seibel:</b> And they switch to Java?</p>
<p class="normal"><b>汤普森：</b>我不知道。几乎没有替代品。他们抱怨，但他们不改变。即将毕业的研究生——谷歌雇用的人——都知道这一点。所以很难做其他事情。这就是它继续前进的原因——它节省了大量的教育和再教育。它使人们的工作效率更快。</p><p class="normal"><b>Thompson:</b> I don't know. There's almost no replacement for it. They complain, but they don't switch. Graduate students coming out—the people who are hired by Google—know it. So it's hard to do anything else. That's the reason it keeps going—it saves a tremendous amount of education, re-education. It gets people productive faster.</p>
<p class="normal"><b>Seibel：</b>您喜欢或曾经喜欢使用其他语言进行编程吗？</p><p class="normal"><b>Seibel:</b> Are there other languages that you enjoy, or have enjoyed, programming in?</p>
<p class="normal"><b>Thompson：</b>所有有趣的语言，我都曾经尝试过。比如求解方程式之类的：Maple 和 Macsyma，诸如此类。对于字符串，SNOBOL。不管怎样，我玩过几十种语言，如果它们能做一些有趣的事情的话。</p><p class="normal"><b>Thompson:</b> All of the funny languages at one point I've taken a step in. Like for solving equations and stuff: Maple and Macsyma, things like that. For strings, SNOBOL. Anyway, I've played with dozens and dozens of languages, if they do something that's interesting.</p>
<p class="normal"><b>Seibel：</b>是否有开发工具能让您乐于编程？</p><p class="normal"><b>Seibel:</b> And are there development tools that just make you happy to program?</p>
<p class="normal"><b>汤普森：</b>我喜欢 yacc。我只是喜欢yacc。它只是做你想做的。它的补充，Lex，是可怕的。它做任何你想做的事。</p><p class="normal"><b>Thompson:</b> I love yacc. I just love yacc. It just does exactly what you want done. Its complement, Lex, is horrible. It does nothing you want done.</p>
<p class="normal"><b>Seibel：</b>你还是使用它还是手工编写你的词法分析器？</p><p class="normal"><b>Seibel:</b> Do you use it anyway or do you write your lexers by hand?</p>
<p class="normal"><b>Thompson：</b>我手写词法分析器。容易多了。</p><p class="normal"><b>Thompson:</b> I write my lexers by hand. Much easier.</p>
<p class="normal"><b>Seibel：</b>你做过任何文学编程吗，就像 Donald Knuth？</p><p class="normal"><b>Seibel:</b> Have you ever done any literate programming, a la Donald Knuth?</p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_477"></a><b>汤普森：</b>不。这是个好主意，但在实践中几乎不可能做到。</p><p class="normal"><a></a><b>Thompson:</b> No. It's a great idea, but it's almost impossible to do in practice.</p>
<p class="normal"><b>塞贝尔：</b>为什么？</p><p class="normal"><b>Seibel:</b> Why?</p>
<p class="normal"><b>Thompson：</b>它是同一程序的两种表示形式，它们通常不同步并且相互冲突。而且没有办法解决。如果某些东西用编程语言写得很好，那么它就是可读的。够了。评论不需要那么平行。这些评论可能是针对算法的，或者如果你做了一些棘手的事情，它可能会以警告或其他形式出现。我不是那种喜欢粗暴评论的人。这是传奇。</p><p class="normal"><b>Thompson:</b> It's two representations of the same program that are often out of phase and conflict with each other. And there's no way to resolve it. If something is written well in a programming language, then it's readable. It suffices. The comments don't need to be that parallel. The comments are maybe for algorithms, or if you do something tricky it'd probably be more in the form of a warning or something. I'm not a big, gross comment kind of guy. It's legendary.</p>
<p class="normal"><b>Seibel：</b>当我采访他时，Knuth 说技术写作的关键是以互补的方式说两遍。所以我认为他认为这是文学编程的一个特征，而不是错误。</p><p class="normal"><b>Seibel:</b> When I interviewed him, Knuth said the key to technical writing is to say everything twice in complementary ways. So I think he sees that as a feature of literate programming, not a bug.</p>
<p class="normal"><b>汤普森：</b>好吧，如果你有两种方法，其中一种是真实的：机器执行什么。其中之一不是。只有当一个比另一个更简短时，它才值得。如果是同一卷，你就读那本有用的。如果一个更简洁，更不精确，并且你可以从中得到你需要的东西，那就太好了。但很多时候你无法从中得到你需要的东西——你真的需要细节，然后你就转向另一个。根据您的追求，您可以阅读其中一个。但是要尝试对一种算法进行微观描述，一个用编程语言，一个用英语——也许 Knuth 可以做到，但我做不到。</p><p class="normal"><b>Thompson:</b> Well if you have two ways, one of them is real: what the machine executes. One of them is not. Only if one is massively more brief way than the other is it worthwhile. If it's the same volume, you read the one that works. If one is much more terse, much less precise, and you can get out of it what you need, then that's great. But very often you can't get out of it what you need—you really need the nitty-gritty and then you go to the other. Depending on what you're after, you read one or the other. But to try to have microscopic descriptions of an algorithm, one in the programming language and one in English—maybe Knuth can do it, but I can't.</p>
<p class="normal"><b>Seibel：</b>你读过他的文学程序吗？</p><p class="normal"><b>Seibel:</b> Have you ever read any of his literate programs?</p>
<p class="normal"><b>汤普森：</b>只是他在早期论文中的东西。没有最近的事。</p><p class="normal"><b>Thompson:</b> Just his stuff in the early papers. Nothing recent.</p>
<p class="normal"><b>Seibel：</b>有没有你认为特别重要的书——对你很重要或者你会推荐人们阅读的书？</p><p class="normal"><b>Seibel:</b> And are there books that you think are particularly important—that either were important to you or that you would recommend people to read?</p>
<p class="normal"><b>Thompson：</b>我不读初级编程书籍，所以我很难推荐这些东西。如果我必须学习一门新语言或其他东西，我会尝试找一本书。我更喜欢更密集的书，这些书只会给我<a id="OEBPS/Chapter12.html.page_478"></a>语法和语义，而不是和我聊天，告诉我什么是好的风格，什么是坏的风格。</p><p class="normal"><b>Thompson:</b> I don't read beginning programming books, so I have trouble recommending such things. If I have to learn a new language or something I'll try to find a book. I prefer much denser books that just give me the <a></a>syntax and semantics rather than chatting me up and telling me what's good style and what's bad style.</p>
<p class="normal">当我教书的时候，我必须为我的课程选择一本教科书，我会阅读该地区的所有教科书，然后做出选择。所以在两个时间点，我了解了这些课程的基础文献。但除此之外我不读书。</p><p class="normal">When I taught, I would have to select a textbook for my course and would read all of the textbooks in the area and have to make a selection. So at two points in time, I knew the basic literature for those courses. But outside that I don't read.</p>
<p class="normal"><b>Seibel：</b>当你在发明 Unix 时，你有计划做四个真正能给你一个操作系统的部分。然后你的妻子和孩子离开了，让你可以自由地黑客一个月。我假设你在那个月投入了很长时间。我们为什么这样做？有必要吗？仅仅是因为好玩吗？</p><p class="normal"><b>Seibel:</b> When you were inventing Unix you had your plan to do the four pieces that would actually give you an operating system. Then your wife and kids went away, leaving you free to hack for a month. I assume you put in some long hours in that month. Why do we do that? Is it necessary? Is it just because it's fun?</p>
<p class="normal"><b>汤普森：</b>当你被驱使时，你就会这样做。我认为我不可能<i>没有</i>做到。另一件事是当妻子和孩子在你身边时，你会同步到一个 24 小时周期。当他们离开时，我没有 24 小时循环。没有什么能让我和太阳在一起。所以我通常以 27 或 28 小时为周期睡眠，睡 6 小时。所以我随波逐流。当我睡到醒来时，我的工作状态比我在孩子开始尖叫时睡觉和起床要好。</p><p class="normal"><b>Thompson:</b> You do it when you're driven. I don't think I could have <i>not</i> done it. The other thing is when the wife and kid are around you have this synchronizing to a 24-hour cycle. When they go away, I don't have a 24-hour cycle. There's nothing that keeps me and the sun together. And so I typically sleep on a 27- or 28-hour cycle, sleeping 6 hours. So I drift. When I get to sleep until I wake up I'm in better shape to work than if I get to sleep and get up when the kid starts screaming.</p>
<p class="normal"><b>Seibel：</b>所以那是当你被一个项目驱动并且你醒来想要到计算机开始编写更多代码的时候。但是人们也工作很长时间，因为我们有这样的想法，我们必须把这个产品推向市场，而做到这一点的方法是让每个人每周工作 80、100 小时。</p><p class="normal"><b>Seibel:</b> So that's when you're driven by a project and you wake up wanting to get to the computer to start writing more code. But people also work long hours because we have this idea that we've got to get this product out the door and the way to do it is for everyone to work 80, 100 hours a week.</p>
<p class="normal"><b>汤普森：</b>这会产生倦怠。兴奋编程，我从来没有感到压力。我也遇到过其他情况，在这些情况下，截止日期——外部截止日期——会产生压力。那不好玩；我不喜欢那样。</p><p class="normal"><b>Thompson:</b> That generates burnout. Excitement programming, I never ever felt stress. I've been in other situations too where deadlines—external deadlines—generate stress. That's not fun; I don't like that.</p>
<p class="normal"><b>Seibel：</b>最后你精疲力竭，这显然很糟糕，但就短期内完成工作而言，它有效吗？</p><p class="normal"><b>Seibel:</b> You burn out at the end, which is obviously bad, but in terms of getting things done in the short term, does it work?</p>
<p class="normal"><b>Thompson：</b>通常情况下，你处在这种情况持续不断的位置。一旦该截止日期结束，另一个截止日期就会出现。如果你总是在这样的截止日期前，那么下一个<a id="OEBPS/Chapter12.html.page_479"></a>你的热情会降低，很快你就不能那样生活了。我不能。</p><p class="normal"><b>Thompson:</b> Usually you're in a position where such a thing is continual. That as soon as that deadline is over another one starts coming up over the horizon. If you're constantly under deadlines like that, then the next one <a></a>you'll have less enthusiasm and pretty soon you just can't live like that. I can't.</p>
<p class="normal"><b>Seibel：</b>与努力在最后期限前完成任务相关的是能够估计事情需要多长时间。你能估计写一段给定的代码需要多长时间吗？</p><p class="normal"><b>Seibel:</b> Tied up with trying to meet deadlines is being able to estimate how long things are going to take. Can you estimate how long it's going to take to write a given piece of code?</p>
<p class="normal"><b>Thompson：</b>这取决于我是为我自己写还是为生产而写。如果我为我写作，我可以。我可以忍受这些怪癖。我不能做额外的百分之十。我可以避开我知道那里的大洞。像这样的东西。我可以生产它，然后在闲暇时清理它并继续使用它。也许这是对<i>finished</i>的不同定义。但如果你是为了生产而做，那么通常会有其他人参与和协调——我无法估计。</p><p class="normal"><b>Thompson:</b> It depends on whether I'm writing it for me or writing it for production. I can if I'm writing for me. I can live with the quirks. I can not do the extra ten percent. I can avoid the gaping holes that I know are in there. Things like that. I can produce it and then clean it up at leisure and still use it. Maybe that's a different definition of <i>finished</i>. But if you're doing it for production then usually there are other people involved and coordination—I can't estimate that.</p>
<p class="normal"><b>Seibel：</b>在 1999 年的一次采访中，您说您对 Linux 的看法不多，并且让 Linux 的人都起来了。大约十年后，您现在如何看待它，它正在接管世界？</p><p class="normal"><b>Seibel:</b> In one 1999 interview you said you didn't think much of Linux, and got the Linux guys all up in arms. What do you think of it now about a decade later, and it's taking over the world?</p>
<p class="normal"><b>汤普森：</b>它更可靠——这是毫无疑问的。我偶尔会查看代码。我不像以前那样看它了。对于 Plan 9，我曾经如此。他们总是领先于我们——他们只是拥有更多的资源来处理硬件。因此，当我们遇到一个硬件时，我会查看它的 Linux 驱动程序并为其编写 Plan 9 驱动程序。现在我没有理由去看它。我运行 Linux。我偶尔会看代码，但很少，所以我无法真正判断质量是否变好。但可以肯定的是，可靠性变得更好了。</p><p class="normal"><b>Thompson:</b> It's much more reliable—there's no doubt about that. And I've looked at the code occasionally. I don't look at it as much as I used to. I used to, for Plan 9. They were always ahead of us—they just had massively more resources to deal with hardware. So when we'd run across a piece of hardware, I'd look at the Linux drivers for it and write Plan 9 drivers for it. Now I have no reason to look at it. I run Linux. And I occasionally look at code, but rarely, so I can't really tell whether the quality has gotten better or not. But certainly the reliability has gotten better.</p>
<p class="normal"><b>Seibel：</b>你读过代码只是为了好玩吗？</p><p class="normal"><b>Seibel:</b> Do you ever read code just for fun?</p>
<p class="normal"><b>汤普森：</b>过去我曾经；现在少了。当我第一次来到这里时，我只是为了尝试感受这个地方。你必须这样做。有那么多未说的，你必须知道。</p><p class="normal"><b>Thompson:</b> In the past I used to; less so now. When I first came here I did it just to try and get the feel of the place. You've got to. There's so much unsaid that you've got to know.</p>
<p class="normal"><b>Seibel：</b>你会选择一个程序并完全理解它，还是你只是在寻找他们在这里做事的方式？</p><p class="normal"><b>Seibel:</b> Would you pick a program and completely understand it, or were you just sort of looking for how do they do things around here?</p>
<p class="normal"><b>汤普森：</b>两者都有一点。我当然会首先尝试选择大型图书馆。我会看一些东西的主要程序。编程<a id="OEBPS/Chapter12.html.page_480"></a>Google 的风格非常怪异。他们进行子程序调用，将其打包为 RPC，并将其静态存储在某个地方。这意味着任何人都可以出于任何原因随时调用它。然后他们调用通用的监听代码，某个地方的某个人收到一条消息，离开并找到它，然后调用该子程序。</p><p class="normal"><b>Thompson:</b> A little bit of both. I'd certainly try to pick the big libraries at first. I'd look at the main programs of some of the things. The programming <a></a>style here at Google is so bizarre. They take a subroutine call, package it as an RPC, and store it somewhere static. Which means anybody can call it at any time for any reason. And then they call generic listening kind of code and somebody somewhere gets a message, goes off and finds that, and makes that subroutine call.</p>
<p class="normal"><b>Seibel：</b>所以这是一种分布式计算机制。</p><p class="normal"><b>Seibel:</b> So that's a mechanism for distributed computation.</p>
<p class="normal"><b>汤普森：</b>是的。这就是这个地方所做的一切。很难读。所以你离开并开始阅读绑定代码。然后是这段代码。然后是通用IPC。这使您掌握了可以真正开始阅读和理解内容的地方。在那之前，你什么都不懂。</p><p class="normal"><b>Thompson:</b> Yeah. That's all this place does. It's very hard to read. So you go off and you start reading the binding code. And then this code. And then the general IPC. That gets you a handle into where you can actually start reading stuff and understanding stuff. Before that, you can't understand a thing.</p>
<p class="normal"><b>Seibel：</b>当你在团队中工作时，你喜欢什么样的结构？</p><p class="normal"><b>Seibel:</b> When you work on a team, what's the structure that you like?</p>
<p class="normal"><b>汤普森：</b>只是与优秀、兼容的人一起工作。</p><p class="normal"><b>Thompson:</b> Just working with good, compatible people.</p>
<p class="normal"><b>Seibel：</b>当你和兼容的人一起工作时，你喜欢强大的代码所有权吗？它是我的，我对此负责，”或者更多的共享所有权：“我们共同拥有这段代码，任何人都可以做他们认为合适的事情。”？</p><p class="normal"><b>Seibel:</b> When you're working with compatible people, do you favor strong code ownership: “I wrote this piece of code; it is mine and I'm responsible for it,” or more shared ownership: “We all own this code together and anyone can do what they see fit.”?</p>
<p class="normal"><b>汤普森：</b>我总是在两者之间工作。有人拥有它，如果您有问题，您可以邮寄给他们或告诉他们，他们的工作就是修复它。然后在某个时候他们消失了，他们不想要它，他们不修复它，他们没有响应——然后你修复它。标语是，“你最后碰了它。” 你拥有它。所以它介于两者之间。你不会有一群人随意修改代码。这一切都通过所有者过滤。但是那个所有者可以很容易地改变。</p><p class="normal"><b>Thompson:</b> I've always worked halfway in between. There's somebody who owns it and if you have a problem with it, you mail them or tell them and their job is to fix it. And then at some point they disappear, they don't want it, they don't fix it, they're not responsive—then you fix it. The catchphrase is, “You touched it last.” You own it. So it's halfway between. You don't have a bunch of people going in and modifying the code willy-nilly. It's all filtered through an owner. But that owner can change pretty easily.</p>
<p class="normal"><b>Seibel：</b>现在有些人提倡结对编程，意思是两个人在一个键盘上工作。你曾经那样工作过吗？</p><p class="normal"><b>Seibel:</b> These days there are folks who advocate pair programming, meaning two people working at one keyboard. Have you ever worked that way?</p>
<p class="normal"><b>汤普森：</b>一些小事可以像那样做。很多时候，我正在打字，而显然比我打字更快的其他人会坐下来，他们会打字，我会说话。我已经在几分钟到几小时的时间里完成了，<a id="OEBPS/Chapter12.html.page_481"></a>非常短的时间，完成一件我们两个人可以单独完成的事情。</p><p class="normal"><b>Thompson:</b> Something small can be done like that. Very often I'll be typing and somebody else, who will obviously be faster at it than I, will sit down and they'll type and I'll talk. I've done that on orders of minutes to hours, <a></a>very few hours, to get one thing done that both of us could have done separately.</p>
<p class="normal"><b>Seibel：</b>你发现结果更好还是完成得更快？</p><p class="normal"><b>Seibel:</b> And did you find that the result was better or it got done faster?</p>
<p class="normal"><b>汤普森：</b>结果也好不到哪儿去。调试可能更快——当您输入时，有人可以越过您的肩膀发现错误。所以我认为它会随着你的进行而产生更少的错误。但我并没有发现它是一种哲学，而是一种方法——它只是发生了。</p><p class="normal"><b>Thompson:</b> The result isn't better. Probably debugging is faster—as you're typing, someone can catch a bug over your shoulder. So I think it will generate fewer bugs as you go. But I didn't find it as a philosophy as a way to go—it just happens.</p>
<p class="normal"><b>Seibel：</b>你还喜欢编程吗？</p><p class="normal"><b>Seibel:</b> Do you still enjoy programming?</p>
<p class="normal"><b>汤普森：</b>是的。我喜欢小程序。小，意味着你可以在一个月内完成。如果你想做一些需要一年的艰巨任务，我不能坚持那么久。</p><p class="normal"><b>Thompson:</b> Yes. I like small programs. Small, meaning you can do it in a month. If you're trying to do some monster task that takes a year, I can't keep in it that long.</p>
<p class="normal"><b>Seibel：</b>一直都是这样吗，或者您是否已经失去了进行更长时间项目的精力？</p><p class="normal"><b>Seibel:</b> Was that always the case, or have you lost the energy for longer projects?</p>
<p class="normal"><b>汤普森：</b>我不知道。这取决于实际情况。需要数年的大东西，比如操作系统，你把它细分，就会有很多有趣的部分，所以这算作多个小东西，而不是一个大东西。但是有很多事情只是一件大事，而那些我认为我一直觉得很难的事情。我需要满足，反馈。如果你必须坐在那里工作，工作，工作，工作几天，几个月，除了一堆代码什么都看不到，那么我很难做到。</p><p class="normal"><b>Thompson:</b> I don't know. It depends on the actual thing. Something big that takes years, like an operating system, you subdivide that and there are lots of fun pieces, so that counts as multiple small things as opposed to one big thing. But there are lots of things that are just one big thing, and those I think I've always found difficult. I need gratification, feedback. And if you have to sit there and work and work and work for days, months and see nothing except a pile of code, then I have trouble doing that.</p>
<p class="normal"><b>Seibel：</b>你主要从事研究工作，看起来你有很大的自由度来从事你喜欢的事情，但当它成为一份工作时，它有没有改变？它有没有带走任何乐趣？</p><p class="normal"><b>Seibel:</b> You've mostly worked in research and it seems you've had a lot of latitude to work on what you like, but did it change when it become a job? Did it take any of the fun out of it?</p>
<p class="normal"><b>汤普森：</b>不。这一直很有趣，主要是因为我只是选择了我想做的事情。即使这是一份工作，回到大学，也有无数的工作机会。在我看来，有很多人在做某事，不管是什么，他们需要在旁边完成一些小的编程任务来帮助他们。所以他们对我来说是完美的。这些都是我可以从事的小工作，几天之内进进出出，然后挑选我想从事的工作。</p><p class="normal"><b>Thompson:</b> No. It's always been fun, and mostly because I just selected what I wanted to do. And even when it was a job, back in college, there were tons and tons of jobs available. It seemed to me that there were tons of people who were doing something, whatever it is, and they needed some little programming task done on the side to aid them. So they were perfect for me. They were little tiny jobs that I could get into, get in and out in days and pick and choose which one I wanted to take.</p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_482"></a>我想我的第一个是一位人文教授，他正在为荷马的作品编目。他的卡片上有<i>《伊利亚特</i>》和<i>《奥德赛》。</i>他想要词频和计数——本质上是对这两部作品的统计分析。那很有趣。那是文本处理，那时候计算机还没有完成。所以那是我的第一份零工。</p><p class="normal"><a></a>I think my first one was a humanities professor cataloging Homer's work. And he had <i>The Iliad</i> and <i>The Odyssey</i> on cards. He wanted word frequencies and counts—essentially statistical analysis of these two works. And that was fun. It was text processing, which just wasn't done by computers in those days. So that was my first odd job.</p>
<p class="normal"><b>Seibel：</b>在 1999 年的一次采访中，您谈到了您如何告诉您的儿子他应该学习生物学而不是计算机，因为您认为计算机已经过时了。那是将近十年前的事了。你现在怎么看？</p><p class="normal"><b>Seibel:</b> In a 1999 interview you talked about how you had told your son he should go into biology instead of computers because you thought computers were played out. That was almost ten years ago. How do you feel about that now?</p>
<p class="normal"><b>汤普森：</b>我也有同感。计算机中没有发生任何您无法预料的新鲜事。我认为，最后一件重要的事情是互联网，它肯定在 99 年就已存在。一切都在扩展——个人计算机的速度仍在呈指数增长，但有什么不同呢？</p><p class="normal"><b>Thompson:</b> I feel the same. Nothing much new has happened in computers that you couldn't have predicted. The last significant thing, I think, was the Internet, and that was certainly in place in '99. Everything has expanded—the speed of individual computers is still expanding exponentially, but what's different?</p>
<p class="normal"><b>Seibel：</b>阅读 Unix 的历史，你们似乎基本上发明了一个操作系统，因为你们想要一种玩这台计算机的方法。所以为了做今天可能是非常基本的事情，比如在电脑上写游戏或其他东西，你必须写一个完整的操作系统。你需要编写编译器并构建大量基础设施才能做任何事情。我敢肯定，所有这一切都是为了自己的利益。但我想知道我们之前谈到的现代编程的复杂性，所有这些层都组合在一起，是否只是现代的等价物，“好吧，第一步是你必须构建自己的操作系统”？至少你不必再这样做了。</p><p class="normal"><b>Seibel:</b> Reading the history of Unix, it seems like you guys basically invented an operating system because you wanted a way to play with this computer. So in order to do what today might be a very basic thing, such as write a game or something on a computer, well, you had to write a whole operating system. You needed to write compilers and build a lot of infrastructure to be able to do anything. I'm sure all of that was fun for its own sake. But I wonder if maybe the complexity of modern programming that we talked about before, with all these layers that fit together, is that just the modern equivalent of, “Well, first step is you have to build your own operating system”? At least you don't have to do that anymore.</p>
<p class="normal"><b>汤普森：</b>但比这更糟。操作系统不仅是给定的；这是强制性的。如果你现在采访一个来自计算机科学领域的人，他们根本不了解底层计算。它们与计算机的本质甚至计算理论的抽象程度真的非常可怕。他们就是不明白。</p><p class="normal"><b>Thompson:</b> But it's worse than that. The operating system is not only given; it's mandatory. If you interview somebody coming out of computer science right now, they don't understand the underlying computing at all. It's really, really scary how abstract they are from what a computer is or even the theory of computing. They just don't understand it.</p>
<p class="normal"><b>Seibel：</b>我在想你建议你儿子学习生物学而不是计算。编程是否有一些东西——定义一个可以由这些神奇机器为你执行的过程的智力乐趣——无论你是在非常接近硬件还是在抽象层次上操作，这都是一样的？</p><p class="normal"><b>Seibel:</b> I was thinking about your advice to your son to go into biology instead of computing. Isn't there something about programming—the intellectual fun of defining a process that can be enacted for you by these magical machines—that's the same whether you're operating very close to the hardware or at an abstract level?</p>
<p class="normal"><a id="OEBPS/Chapter12.html.page_483"></a><b>汤普森：</b>这很容易上瘾。但是你不想告诉你的孩子去破解。我认为它已经改变了。这可能只是我老了，但似乎当你只是在另一层之上的另一层之上构建另一层时，你并没有真正获得编写 DFA 的好处。我认为算法是必然的——随着时间的推移，新算法只会变得越来越复杂。一种做某事的新算法是基于其他 50 种小算法。当我还是个孩子的时候，你在做这些小算法，它们很有趣。你可以理解它们，而不是将它分成案例的会计工作，这个案例由你读过但你并不真正了解的算法解决。所以这是不同的。我真的相信它' 它是不同的，大部分是因为整个事情随着时间的推移而分层，而我们正在处理层。可能是我脾气暴躁，无法理解层次。</p><p class="normal"><a></a><b>Thompson:</b> It's addictive. But you wouldn't want to tell your kid to go into crack. And I think it's changed. It might just be my aging, but it seems like when you're just building another layer on top of another layer on top of another layer, you don't really get the benefit of writing, say, a DFA. I think by necessity algorithms—new algorithms are just getting more complex over time. A new algorithm to do something is based on 50 other little algorithms. Back when I was a kid you were doing these little algorithms and they were fun. You could understand them without it being an accounting job where you divide it up into cases and this case is solved by this algorithm that you read about but you don't really know and on and on. So it's different. I really believe it's different and most of it is because the whole thing is layered over time and we're dealing with layers. It might be that I'm too much of a curmudgeon to understand layers.</p>
</div>
</div></div>
<div id="OEBPS/Chapter13.html"><div>

<div class="booksection">
<p></p>
<h2 class="chapnum"><a id="OEBPS/Chapter13.html.ch13"></a><a id="OEBPS/Chapter13.html.page_485"></a><img src="data:image/jpg;base64,/9j/4AAQSkZJRgABAgEASABIAAD/7Q1qUGhvdG9zaG9wIDMuMAA4QklNA+0KUmVzb2x1dGlvbgAAAAAQAEgAAAABAAEASAAAAAEAAThCSU0EDRhGWCBHbG9iYWwgTGlnaHRpbmcgQW5nbGUAAAAABAAAAHg4QklNBBkSRlggR2xvYmFsIEFsdGl0dWRlAAAAAAQAAAAeOEJJTQPzC1ByaW50IEZsYWdzAAAACQAAAAAAAAAAAQA4QklNBAoOQ29weXJpZ2h0IEZsYWcAAAAAAQAAOEJJTScQFEphcGFuZXNlIFByaW50IEZsYWdzAAAAAAoAAQAAAAAAAAACOEJJTQP1F0NvbG9yIEhhbGZ0b25lIFNldHRpbmdzAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+BdDb2xvciBUcmFuc2ZlciBTZXR0aW5ncwAAAHAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAOEJJTQQAC0xheWVyIFN0YXRlAAAAAgABOEJJTQQCDExheWVyIEdyb3VwcwAAAAAEAAAAADhCSU0ECAZHdWlkZXMAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4NVVJMIG92ZXJyaWRlcwAAAAQAAAAAOEJJTQQaBlNsaWNlcwAAAAB1AAAABgAAAAAAAAAAAAAAlAAAANYAAAAKAFUAbgB0AGkAdABsAGUAZAAtADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAANYAAACUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhCSU0EERFJQ0MgVW50YWdnZWQgRmxhZwAAAAEBADhCSU0EFBdMYXllciBJRCBHZW5lcmF0b3IgQmFzZQAAAAQAAAACOEJJTQQMFU5ldyBXaW5kb3dzIFRodW1ibmFpbAAACY4AAAABAAAAcAAAAE0AAAFQAABlEAAACXIAGAAB/9j/4AAQSkZJRgABAgEASABIAAD/7gAOQWRvYmUAZIAAAAAB/9sAhAAMCAgICQgMCQkMEQsKCxEVDwwMDxUYExMVExMYEQwMDAwMDBEMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQ0LCw0ODRAODhAUDg4OFBQODg4OFBEMDAwMDBERDAwMDAwMEQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAz/wAARCABNAHADASIAAhEBAxEB/90ABAAH/8QBPwAAAQUBAQEBAQEAAAAAAAAAAwABAgQFBgcICQoLAQABBQEBAQEBAQAAAAAAAAABAAIDBAUGBwgJCgsQAAEEAQMCBAIFBwYIBQMMMwEAAhEDBCESMQVBUWETInGBMgYUkaGxQiMkFVLBYjM0coLRQwclklPw4fFjczUWorKDJkSTVGRFwqN0NhfSVeJl8rOEw9N14/NGJ5SkhbSVxNTk9KW1xdXl9VZmdoaWprbG1ub2N0dXZ3eHl6e3x9fn9xEAAgIBAgQEAwQFBgcHBgU1AQACEQMhMRIEQVFhcSITBTKBkRShsUIjwVLR8DMkYuFygpJDUxVjczTxJQYWorKDByY1wtJEk1SjF2RFVTZ0ZeLys4TD03Xj80aUpIW0lcTU5PSltcXV5fVWZnaGlqa2xtbm9ic3R1dnd4eXp7fH/9oADAMBAAIRAxEAPwDo/rFbb1H654P1cy8y3B6W/EdlbaXml2VcHuq+xuvYWv8ATZU31fSr/wDSPp73Ruj4HSbsmjCyLnh4rc7FuvdeKh+kDX1NvdZdV9o9+/3/AKT0v5Cx+sdb/wAXHXMcY3Vc3CyqmmWbrIc0nn07ayy2v+w9R6N1f/Ft0KuyvpWbh4wuINrvVL3vInb6l1zrLX7N79m56SnO6D1brmP1r6x14XTLuq1jqLxvGTVWKwBpW1mXY3/wNaX+LS6+/oeU/IL/AFPt+SC2x5eW6t/R75d9D+Si4P1i/wAX/T7sq/D6li1W59pvynesXb7D+fD3O2f9bS6Z9Yv8X/SaH4/T+pYtFVtjrnt9Yumx/wDOPm1z3e5JTyf1v+sbbvrDn5OP1MYtv1dFLen4nqOazJyG2et1Bj62D9J+jb9k9P8APevSen9Qx+p9Mo6himaMqpttfiA4btro/PZ9F6wemfWD/F90nHsxsDqOLVVdY660G4vLrLP5yyx9zrHvc+P3k/S/rF9QOkYLen9P6ljU4jC4sq9YvA3kvftNr7HNa57tySnk/qVgfWHMxuhZ+BVk0AXOf1HqluYX1X47H2Msxf2c62525zW+ix/oVbLK/V/4ZnffWHo2D1LEdbli0vxa7XUmq62mCWz7vs1lXqfzbf5xZ3S/rL9QekYFXTundSxaMSjd6dfrF0bnOtf77XPs/nHu/OViz66/U22t1VnVsVzHgtcPUGoIh3CSnP8A8XXS8X9gYHWXG6zPyKXC22y+6wGXn/A22vob/Ns+hWs36115uV9e2YuPhW9UaOlNt+x15j8IA/aLWfafWrezfs3el6f/AAn/AAa2+m/Wf6h9LwqsDA6ni04tALaq/VLoBJf9Oxz3u9zvznLP6xk/4rut5bc3qebjX5LKxS2wZNlZ2AusayMe2pv07HpKdymh+L9U31HHfg2MxbScd17sh9Ti173M+2Oc59u1zvp715/9U785vUPqwGnI6c7MbZZdmZGS+6rOawQ7GrxS+2mq39z1Ps/p/wA5+kt9Bdjh/WH/ABf4XTB0nG6liswWsdWKTcXe15cbG+pY99vu3u/PVY9Q/wAWRwcLp/27FGN02xt+E0XvDq7GEuY9tzbPW+k/8+xJT2SSwv8Anz9UP/LfF/7cCX/Pn6of+W+L/wBuBJT/AP/Q8/kpSUkkkqkpSUkxJAJAk+CSl5KUldp0H6p/UbqeUzE/5yW5ORZpXTVT9kLjztZ9srv3f1VH/GH9U+kfVurpg6a2zdkuuFz7bC8uDBW6vn2N27vzGJKeNkpSUl0P1Q+pub9Z8h5bZ9lwMdwbkZJbuJcRv9DHb9F9u36bneyn/hP5tJTz0lKSux6iP8WvSMx/T24Wd1d9DjXfleuWAOB2vbVssxmWuY7/AIJlSv5f+LrpnVeiM639Uci14sYbGYeSd2/adr6GWR6lGQx7LK/0rrqvV/0f86kp8/kpSUwIIBHBTpKVJSkpJJKf/9Hz9JJJJKkkkklOp9Vv/FT0f/w7T+Vdt/jm+j0b+vkf9TSuJ+qv/ip6P/4dq/Ku2/xzfR6N/XyP+ppSU+arofq99d+qfV/peZ0zFrY+vJ3vptJLX02vAY65sB3rN9u/0v0f6T/CLnkXFOMMug5jXPxBaw5La9Hmrc31216t/Selv2JKQtaGtDRwBAXsP+Kau6v6pusuP6K3KvfQSdPTG2t3/g9dy4y3K/xVfag9mD1X0WnVjHH03Dz9XJ+17f8AprrPrB0/rHXPq1WPqhm0O6Ia9jcChjqLH1NGx2P9pe9/u/MsxnVYe/8Am70lPl/Urqb+p51+P/R7sm+ymNBsfY99f/QKrJFpaSxzSxzSWuY4QQR7XMc0/Rc1JJSkkkklP//S8/SSSSSpJJMSAJPASU6v1V/8VPR//DtX5V23+Ob6PRv6+R/1NKyvqv8AUD61U/WDp2Xm4X2XFxrm32WutqdowFwZ6dNllm6x3t+iup/xm/VrrPXaenO6TQMl2K+31a97a3RY1ga9vrOrr2t9P3e9JD5Cpii91DsltVjsetwrfeGONbXn6Nb7o9Jljv3NysdT6V1HpGWcLqdBxskND/TLmv8Aa6dj99LrK/zHfnL0j6m9S+r31g+qA+qWU5mLlNqdjvoMNc+SbK83E3e26zf+sWfn15P87Xs2eokvli9I/wATeVdv6rgkk0D0chrezXu9Sm0/1rW1U/8AbS5nO/xffW3DyzjNwH5bZivJoLTW8fvne9jqP6lq7b6r4OF/i/6Jk5/1gyGVZucWudjscHOisFtGJjs+lkX7rbPVfX+i/Sf6Gr1kkPGf4x8WnG+uWcKYAubVe9rREPezbZ/as9P1f+uLmld631W7rPV8vqt7dj8p+4VgzsY0Cqirdpu9OljNzv31SSSpJJJJT//T8/SSSSSpJJJJTD0av3Ql6NX7oU0klLNa1ohogJOa1whwBHgU6SSm3X1frFVfpVdRy66+NjMi0N/zRYqji59hteS+x30rHkucfi9+5ySSSlJJJJKUkkkkp//ZOEJJTQQhGlZlcnNpb24gY29tcGF0aWJpbGl0eSBpbmZvAAAAAFUAAAABAQAAAA8AQQBkAG8AYgBlACAAUABoAG8AdABvAHMAaABvAHAAAAATAEEAZABvAGIAZQAgAFAAaABvAHQAbwBzAGgAbwBwACAANgAuADAAAAABADhCSU0EBgxKUEVHIFF1YWxpdHkAAAAABwAGAAAAAQEA/+4ADkFkb2JlAGRAAAAAAf/bAIQAAgICAgICAgICAgMCAgIDBAMCAgMEBQQEBAQEBQYFBQUFBQUGBgcHCAcHBgkJCgoJCQwMDAwMDAwMDAwMDAwMDAEDAwMFBAUJBgYJDQoJCg0PDg4ODg8PDAwMDAwPDwwMDAwMDA8MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM/8AAEQgAlADWAwERAAIRAQMRAf/dAAQAG//EAaIAAAAHAQEBAQEAAAAAAAAAAAQFAwIGAQAHCAkKCwEAAgIDAQEBAQEAAAAAAAAAAQACAwQFBgcICQoLEAACAQMDAgQCBgcDBAIGAnMBAgMRBAAFIRIxQVEGE2EicYEUMpGhBxWxQiPBUtHhMxZi8CRygvElQzRTkqKyY3PCNUQnk6OzNhdUZHTD0uIIJoMJChgZhJRFRqS0VtNVKBry4/PE1OT0ZXWFlaW1xdXl9WZ2hpamtsbW5vY3R1dnd4eXp7fH1+f3OEhYaHiImKi4yNjo+Ck5SVlpeYmZqbnJ2en5KjpKWmp6ipqqusra6voRAAICAQIDBQUEBQYECAMDbQEAAhEDBCESMUEFURNhIgZxgZEyobHwFMHR4SNCFVJicvEzJDRDghaSUyWiY7LCB3PSNeJEgxdUkwgJChgZJjZFGidkdFU38qOzwygp0+PzhJSktMTU5PRldYWVpbXF1eX1RlZmdoaWprbG1ub2R1dnd4eXp7fH1+f3OEhYaHiImKi4yNjo+DlJWWl5iZmpucnZ6fkqOkpaanqKmqq6ytrq+v/aAAwDAQACEQMRAD8A+0353/m55e/Iv8rvN35o+ZlafT/LFp6kGnxsFkvLuVhFa2sbGoBlldVrSigljsDiofjZ+Xdh/wA5yf8AOfFxqvn+L82bn8mvyrgvZrTSItMuLzTrRnjCh4bS3sXimvBHyo8s8tOfJVaoKIWewfTX5Tf84xf85o/kl+aPkjVh/wA5EXH5qfljPqdvF5/0DUb+8kmFkao7w2uptcxAKDUtFKslAKA0FAiwX6n4sX4n/wDOKv5i/mDrn/Pxf8+fKetee/MOseVdL1bz4mmeWb3VLu40+2W11r0oFhtZJWiQRJ8KBVHEbCgwsjyfpX/zllqup6H/AM41/nZrGi6ldaPq2m+U9QuNO1Syme3uLeVI6rJFNGyujKdwVIIwIHN8sf8APrHzh5t86/8AOPvnHVfOXmnV/NuqW/5hahaQalrV9PfzpbppOkusKy3EkjBAzsQoNASTTc4qX6WYofiH/wA58/m9+bP5h/8AOSHkb/nHD8hPNOsaRrmg2Mj6smgapcae9zqd7D9ceG4e2eNittZwLJuxoXbYEYhlEdX0Z/z7J/5yB1b81/yp17yD511u71rz7+WGoFZr7UpZZ7260q/Z5LeSaaWrO8UqyxGrEhVStKjFS/TDFi/E3/n5150/MbRPzp/JPyx5J/MXzF5Gt/M2kfV7saLqd3YxNLNqXorNJHbTwhyoPfem1fAhlF5h/wA5B+Vf+cqP+cFY/In5g2X/ADldrv5i22uas9k3l/VZ757ZnhjE59awvb68imjZU4Mw4stRQjkCFIov3B/Kfzu35l/lh+Xn5hvYHS387+XNM1yTTa8hA1/bRztGrdwpegPcb4GD5O/5yV/5xQ/N787PzBtPOHkX/nJnzB+UGi2+jW2myeVtL/SHovPDNNI90fqupWicnWVVPwV+AfF0oUg0/J7yT5A/5yF85f8AOVHmf/nGJP8AnKrzvp915am1KJ/OR1TVpY5v0dEJCRaDUlK8+n96afqWVh+xH/OLf/ONn5n/AJEar5uv/wAwPz/1r86LfzFaWlvptnq313jYPbu7PJH9bv7wVkDgHiF+yOvYMSXs3/ORWoX+kf8AOPv566rpV9caZqmmfl75nu9N1K0leC4t7iHSbmSKaKVCrI6MAyspBBFQcVHN+H3/ADiP+S//ADkP/wA5V+UPM/my0/5y387eSE8tawuktYy3+r6gZibeOf1A66pb8ft0pQ9OvgWVgP1i/wCcWf8AnHL8zPyGu/Olx+YP596z+dMfmaGwj0qDVvrtNOa0M5laP63fXg/eiVQeIX7ArXagYkvX/wDnIrUL/SP+cffz11XSr640zVNM/L3zPd6bqVpK8Fxb3EOk3MkU0UqFWR0YBlZSCCKg4qOb8O/+cS/yc/5yL/5yk8m+avOWnf8AOXHnTyO/lTVhpiWdxqWsXYlcW8dwsvrJqcPpgc6fZNKV9gWRID6p/wCfbH/OS35t+f8Azp+YX5Ifmj5im8/jydpcmqaH50nlF3NGLK7hsJ7aS+3a5WYzLJE8hLni5LEEBQgh+v8AixdirsVdir//0Pov/wA/F/InmPz9/wA4redrTyvZTalqPl27sNfn0233lmtLGat0VWo5elE7SkdSE2q1AVMebwf/AJ9pf85J/lK/5GeWfyX1nzVp3lXz75Mu9RiTS9XuYbM6rFqN9dahHNYtK4ExQTFHQHmvCpXiVOKl96eZP+civyR8qeYvLXlDV/zM0I+bPN+q2GjeX/LNldJfX811qVwtrbBre19V40aRqepIFQUNW2xQ9pxV/NR5J/JL/lf3/Oe3/OQnkP8AxtqvkLh5s89an+ntH/3p/wBG1uRfS/vE+FvUqd+33FmeT6f/AD5/594f8q4/Jr8yfPg/5yG86+Y/8J6Fdan+gb+v1a79BOXpS/6QfhagB2wIEt3tX/Por/1m7zt/5srUv+6Po2KJP0i89+ctG/LzyV5r89+YZvQ0TyhpV3q+puKlvRtImlZVABJZuNFAFSSBih/OD/ziz+enmDy7+e/5h/8AOSvmH8m/OH5v635lk1GOxl8vQy3Fvp17qcyTXFZTDNRo7ciGNQw4xsRSnHisyjvyz/O+T8lv+c2x+bc/kTXvym/Ln81dYuINf8ueY4ZLZobDWXja8lDzCFDHbXpE4IFFRQtO2KncP6W1YMAykMrCqsNwQe4xYPwh/wCfrNg2q/n1+QOlJdyWDalpC2q3sRpJCZtU4CRPiXda1HTp18FlE0+krP8A59ZeRNV8x6drf5ofnP55/M+0091ZtL1GcRGdFIJhkuWeaZY3oA3psjU6MDQhRxP1CsLCy0uxstM021isdO06CO1sLGBQkUMMKhI440WgVVUAADoMUIvFX4Zfkef/AI6/+am//H35m7/8uq+/+f6lPR+5uKHiH/OTX/rN3/OQf/mtfNn/AHR7rFMeb8Iv+cIf+cM/yq/5yX8jecPM3n7zvrnlfUPL2urpdla6Xc2MMckJtopubi6gmYtycjYge2LIyp+0X/OLf/OM35ef84zaR5s0PyB5t1PzTB5pu7e+1B9VntJpIXt42iUJ9VihAUht6g74sSbZ3/zk1/6zd/zkH/5rXzZ/3R7rFY834B/84o/84g+Y/wDnI38lPzV8yeUvzK1Hyv5i0C/k03TPKK8xpeqv9Tjm9O7dJkK+qH9PlxYDqQRtiy4qfY//AD6W87eSrOL8yvymu/KVv5b/ADXsJBqepazIJVvtUsIJTA9vOszsYmsZZAvpoqLR6leYdiok/aTFi7FXYq7FX//R+/ZAIIIqD1GKvz6/Nf8A59o/842fmhrl75ktLPWvy61fUpzc6ivle6hhs5pG+231O5guIo+XUiEIK7064pEiEw/Jv/n3F/zjn+TvmPRvONvba75281eXb+LU9B1TzDfK0dndQMGhlitrOK1iYxsodfVV6N8Q6LxVsvvbFD5L/Lj/AJw2/LD8sPz085f85BaBrvmi885+eLnWbrVtM1C6spNMjfXLv65ciCKKyimUK+ycpmovXkd8Uk299/MryDo/5peQfNv5deYLm8s9E85aZPpWqXWnPHHdRw3C8WaF5Y5UVgOhZGHtigPOf+cc/wDnHPyT/wA4x+SdU8heQtU1zV9H1fXJ9fubnX57a4uVuZ7a2tWRGtba1QRhLVCAUJqW3pQBSTbIvzv/ACd0L8+fy61f8sfM+u65oHl/XZbZ9VuPL88FtdzR20qzrCZLi3uU9NnRSw4VNKVpWqoNKH5E/kf5M/5x5/LrTfyz8iy6hdaLp9zdXj6jq0kM19cz3cpleSeSCG3jYqCsa8Y1oiqDUgkqCwb/AJyT/wCcTvyw/wCcpLDytZ/mFda3pVx5QuLibR9X8vz21tdBLtUWaCRrm2ukaNjGjU4ggqKHqCpBp7v5O8tx+TvKnlzynDq+o69D5a0620yDWdXkjmv7mO1jWJJLmSKOFHkKqOTBBU70xQ+d/wA+P+cPvy0/5yG87eSPPvnTXPM+max5BjSPR7bRLqzgtpBHci6HrrcWdy7HmKfC67e++KbfVmKHYq7FXyn5V/5w+/LTyh/zkHr/APzknpuueZ5/PPmOS+kvtKubqzbSUOoRiOX04Us0nAAHw1mNO9cU2+rMUMV89eUdN/MDyT5x8hazPc22j+d9D1DQNVubJkS5jttStpLWZ4HkSRFkVJCVLIwBpUEbYqDT83P+iRf/ADjd/wBTt+Zf/cT0j/vD4suIvpn/AJxs/wCcNvyw/wCcW9S81ap+X+u+aNYuPN9ta2upJ5hurK4REtHkdDCLWytCCTIa8i3bpigm30V568o6b+YHknzj5C1me5ttH876HqGgarc2TIlzHbalbSWszwPIkiLIqSEqWRgDSoI2xQDTx7/nHD/nGTyH/wA4v+Wtf8reQdX1/V9P8xamNVvZvMFxa3EyTCFIOMbWtraqF4oDQqTXv2xSTbBtI/5wl/Kry5/zkHd/85IeW/MHm3y95z1DUrnU9Q0CxvLKPRJ5b2Ix3iSW7WLTMlwzNI4M32zyUrRaK2+xMUOxV2KuxV//0p//ANFlB/7Dl/4eA/7wuNMuF3/RZQf+w5f+HgP+8LjS8Lv+iyg/9hy/8PAf94XGl4Xf9FlB/wCw5f8Ah4D/ALwuNLwu/wCiyg/9hy/8PAf94XGl4Xf9FlB/7Dl/4eA/7wuNLwu/6LKD/wBhy/8ADwH/AHhcaXhd/wBFlB/7Dl/4eA/7wuNLwu/6LKD/ANhy/wDDwH/eFxpeF3/RZQf+w5f+HgP+8LjS8Lv+iyg/9hy/8PAf94XGl4Xf9FlB/wCw5f8Ah4D/ALwuNLwu/wCiyg/9hy/8PAf94XGl4Xf9FlB/7Dl/4eA/7wuNLwu/6LKD/wBhy/8ADwH/AHhcaXhd/wBFlB/7Dl/4eA/7wuNLwu/6LKD/ANhy/wDDwH/eFxpeF3/RZQf+w5f+HgP+8LjS8Lv+iyg/9hy/8PAf94XGl4Xf9FlB/wCw5f8Ah4D/ALwuNLwu/wCiyg/9hy/8PAf94XGl4Xf9FlB/7Dl/4eA/7wuNLwu/6LKD/wBhy/8ADwH/AHhcaXhd/wBFlB/7Dl/4eA/7wuNLwu/6LKD/ANhy/wDDwH/eFxpeF3/RZQf+w5f+HgP+8LjS8Lv+iyg/9hy/8PAf94XGl4X/0/kDX3/H+3/P9RbR+PsdX3/H+3/P9So/H2Or7/j/AG/5/qVH4+x1ff8AH+3/AD/UqPx9jq+/4/2/5/qVH4+x1ff8f7f8/wBSo/H2Or7/AI/2/wCf6lR+PsdX3/H+3/P9So/H2Or7/j/b/n+pUfj7HV9/x/t/z/UqPx9jq+/4/wBv+f6lR+PsdX3/AB/t/wA/1Kj8fY6vv+P9v+f6lR+PsdX3/H+3/P8AUqPx9jq+/wCP9v8An+pUfj7HV9/x/t/z/UqPx9jq+/4/2/5/qVH4+x1ff8f7f8/1Kj8fY6vv+P8Ab/n+pUfj7HV9/wAf7f8AP9So/H2Or7/j/b/n+pUfj7HV9/x/t/z/AFKj8fY6vv8Aj/b/AJ/qVH4+x1ff8f7f8/1Kj8fY6vv+P9v+f6lR+PsdX3/H+3/P9So/H2Or7/j/AG4q/wD/1PkDX3/H+3/P9RbR+PsdX3/H+3/P9So/H2Or7/j/AG/5/qVH4+x1ff8AH+3/AD/UqPx9jq+/4/2/5/qVH4+x1ff8f7f8/wBSo/H2Or7/AI/2/wCf6lR+PsdX3/H+3/P9So/H2Or7/j/b/n+pUfj7HV9/x/t/z/UqPx9jq+/4/wBv+f6lR+PsdX3/AB/t/wA/1Kj8fY6vv+P9v+f6lR+PsdX3/H+3/P8AUqPx9jq+/wCP9v8An+pUfj7HV9/x/t/z/UqPx9jq+/4/2/5/qVH4+x1ff8f7f8/1Kj8fY6vv+P8Ab/n+pUfj7HV9/wAf7f8AP9So/H2Or7/j/b/n+pUfj7HV9/x/t/z/AFKj8fY6vv8Aj/b/AJ/qVH4+x1ff8f7f8/1Kj8fY6vv+P9v+f6lR+PsdX3/H+3/P9So/H2Or7/j/AG4q/wD/1fkDX3/H+3/P9RbR+PsdX3/H+3/P9So/H2Or7/j/AG/5/qVH4+x1ff8AH+3/AD/UqPx9jq+/4/2/5/qVH4+x1ff8f7f8/wBSo/H2Or7/AI/2/wCf6lR+Psej/lZ+Un5h/nX5qXyT+WPl5vM/md7WW9XTFurW0/0eAqJHMt5PBEAvIdWr/BRdfj3P0C8qf8+l/wDnIjV5IX8zeZvJ3lCzb+/Vry6v7pP9WK3t/Sb/AJHD+gQJPpPyn/z548sQDn55/OvVNVLUP1XQtKh0/h4j1rme85ex9NflijifMv8Azn//AM4f/lP/AM4yeUPyt1H8ubjXbi+8wajqFjrV3rV5HctOsMEMkTUihgRGU8vsKAa9NhQpibfl7X3/AB/t/wA/1LIfj7HV9/x/t/z/AFKj8fY6vv8Aj/b/AJ/qVH4+xnn5bflj58/N7zZY+SPy58t3fmnzJfgvHY2oAWKFCA888rsscMSFgGeRlUEgVqRit/j5P2J/K3/n0HYmwgvvzp/NK7S9mjRp/L/lCKONbdurKdQvkmEhpQbWygEdWFMDDiZXef8AOLP/AD7C8qalN5Z8w/mrp36ct3MV1HfedI0lgkUAMkpt2jijYEVIcAg/cFbKca9/z6l/5x787aJHrn5Ufmh5g0mLU4Fk0fVBc2Wv6RIvH4ZEESQPIrHclbinhTFRJ+V//OSf/OGH5x/84zzfpHzLYxeZPIlxKIrDz/o/N7Lm7EJFdxsRJbSkAUDjgSaI7kHiWQP4+T5Hr7/j/b/n+pSPx9jq+/4/2/5/qVH4+x1ff8f7f8/1Kj8fY6vv+P8Ab/n+pUfj7HV9/wAf7f8AP9So/H2Or7/j/b/n+pUfj7HV9/x/t/z/AFKj8fY6vv8Aj/bir//W+QNff8f7f8/1FtH4+x1ff8f7f8/1Kj8fY6vv+P8Ab/n+pUfj7HV9/wAf7f8AP9So/H2Or7/j/b/n+pUfj7HV9/x/t/z/AFKj8fY6vv8Aj/b/AJ/qVH4+xm35f/mT56/KrzFH5s/LzzPeeU/MUUL2y6rYuFkMMhUvGwbkrKxQVBFDTFFX+Pc+svLv/PyH/nL3y/NG835mQeY7WMAGw1fR9MlRqFd2lht4Z60Wh/edyeu4aRwh/Q5/zjN+bl1+e35F/l7+a1/Y2+m6l5qs7g6pZWgcW8d3ZXc9jcCISMzhDLbsVBYmnc9cDAvzl/5/D/8AKCfkr2/3Par/ANQsPuMWUOb8Fa+/4/2/5/qLMfj7HV9/x/t/z/UqPx9jq+/4/wBv+f6lR+Psf1e/84U/848+X/8AnH/8k/LVnb2cTedPONja63591v7cs15cQrItsrkVENsremiigryenJ2qGsl+f/8Az88/5y313S9YP/OOf5c65Po629tFc/mlq9jIYp5TcoJYNKWVSrKnpMss3E/GGWMniJFKyiH4hV9/x/t/z/UWQ/H2P04/59h/n9rnkL867D8o9Q1KabyJ+aXrW8WmSyVhtNZihMttcxKzUVphEYHCj4iyV+wKLEjZ/RJ5o8saB508u6z5T806XBrXl7zBaSWOr6VcqHimglXiykHoe4I3BoRQjAwfyC/85BflZP8Akn+dH5i/ldNMZ4fKeryQ6XcM3J5dPuFW6sJJD8PxvbSxswAoGrTbfC2g/j5PHa+/4/2/5/qVH4+x1ff8f7f8/wBSo/H2Or7/AI/2/wCf6lR+PsdX3/H+3/P9So/H2Or7/j/b/n+pUfj7HV9/x/t/z/UqPx9jq+/4/wBuKv8A/9f5A19/x/t/z/UW0fj7HV9/x/t/z/UqPx9jq+/4/wBv+f6lR+PsdX3/AB/t/wA/1Kj8fY6vv+P9v+f6lR+PsdX3/H+3/P8AUqPx9jq+/wCP9v8An+pUfj7HV9/x/t/z/UqPx9jq+/4/2/5/qVH4+x/U3/z7i/8AWMfyb/8ABh/8SLU8DWXyd/z+H/5QT8le3+57Vf8AqFh9ximHN+Ctff8AH+3/AD/UWY/H2Or7/j/b/n+pUfj7HV9/x/t/z/UqPx9j9h/yD/5+r3nkH8udP8lfmn5DvPOer+VrCKw8u+ZdMu4YHvIYEKQx36TD4WRVVTKhYsN2TkCWFMeF+U/5g+dtY/Mjzz5v8/6/Jz1jzjq95q9+odmWN7uZpfSjLsSEjBCIOygDtsWQ/H2MQr7/AI/2/wCf6lR+Pse6/wDOLwvm/wCck/yBXTjJ9a/5WH5aI9MMxEY1O3MpYIwJQIG5/wCTWu3RQeX48n9guBrfzEf8/Op7ST/nLrzilvLE81to+hx36xkcklNhE4ElCKN6bId+xHbC2R/H2Pz8r7/j/b/n+pSPx9jq+/4/2/5/qVH4+x1ff8f7f8/1Kj8fY6vv+P8Ab/n+pUfj7HV9/wAf7f8AP9So/H2Or7/j/b/n+pUfj7HV9/x/txV//9D5A19/x/t/z/UW0fj7HV9/x/t/z/UqPx9jq+/4/wBv+f6lR+PsdX3/AB/t/wA/1Kj8fY6vv+P9v+f6lR+PsdX3/H+3/P8AUqPx9jq+/wCP9v8An+pUfj7HV9/x/t/z/UqPx9jq+/4/2/5/qVH4+x/U3/z7i/8AWMfyb/8ABh/8SLU8DWXyd/z+H/5QT8le3+57Vf8AqFh9ximHN+Ctff8AH+3/AD/UWY/H2Or7/j/b/n+pUfj7HV9/x/t/z/UqPx9jq+/4/wBv+f6lR+PsdX3/AB/t/wA/1Kj8fY6vv+P9v+f6lR+PsfqB/wA+vPyE1rz1+dNt+cGo2E0Pkj8rUnktdQdaQ3mtXELQQW0ZYEP6KStM5U/CRHX7YwMSX70/nD+cXkP8jPI+q+ffzB1mLS9J06J/qdpyT61qFyEZ47OziZl9SaTjRRWg+0xVQSFiBb+R383vzL1j84vzN87fmdrsa22pectUlv3skf1FtojRLe3VzxLCGJEjBIFQtaDsWwfj7HnFff8AH+3/AD/UqPx9jq+/4/2/5/qVH4+x1ff8f7f8/wBSo/H2Or7/AI/2/wCf6lR+PsdX3/H+3/P9So/H2Or7/j/b/n+pUfj7HV9/x/txV//R+QNff8f7f8/1FtH4+x1ff8f7f8/1Kj8fY6vv+P8Ab/n+pUfj7HV9/wAf7f8AP9So/H2Or7/j/b/n+pUfj7HV9/x/t/z/AFKj8fY6vv8Aj/b/AJ/qVH4+x1ff8f7f8/1Kj8fY6vv+P9v+f6lR+Psf1N/8+4v/AFjH8m//AAYf/Ei1PA1l8nf8/h/+UE/JXt/ue1X/AKhYfcYphzfgrX3/AB/t/wA/1FmPx9jq+/4/2/5/qVH4+x1ff8f7f8/1Kj8fY6vv+P8Ab/n+pUfj7H9H3knR/wDn3Iv5I/lbceb4vyfha+8r6Z9Yu72TTYdanuRbRx3TXLoUvWlWYMJS/wASuDyoRga7Lz7S/LX/AD6Hi1y3ubS68qG/EnrRre6v5jex5OSKPHdXJtOI/lYUHgNsU7v0Mm0rUb38tdHtf+cYPM/kPynoLWg/w3ex6P8ApbRzbsDxazGnX9nCniG4yDxU4ofz6/8AOaH5E/8AOYfl/W7j8wvz6vrn8yNChYwWvnvSpjc6TZRyyELELVFhNgrEL1hRCxADM+FnEh8AV9/x/t/z/UpH4+x1ff8AH+3/AD/UqPx9jq+/4/2/5/qVH4+x1ff8f7f8/wBSo/H2Or7/AI/2/wCf6lR+PsdX3/H+3/P9So/H2Or7/j/b/n+pUfj7HV9/x/txV//S+QNff8f7f8/1FtH4+x1ff8f7f8/1Kj8fY6vv+P8Ab/n+pUfj7HV9/wAf7f8AP9So/H2Or7/j/b/n+pUfj7HV9/x/t/z/AFKj8fY6vv8Aj/b/AJ/qVH4+x1ff8f7f8/1Kj8fY6vv+P9v+f6lR+Psf1N/8+4v/AFjH8m//AAYf/Ei1PA1l8nf8/h/+UE/JXt/ue1X/AKhYfcYphzfgrX3/AB/t/wA/1FmPx9jq+/4/2/5/qVH4+x1ff8f7f8/1Kj8fY6vv+P8Ab/n+pUfj7HV9/wAf7f8AP9So/H2Or7/j/b/n+pUfj7H2H/zhv/zlb5l/5xo/MbT5J9RuLn8rfMd3HD5/8tEtJEInpH+kLeOp43EAo1VFXVfTPYqsSLD+qaWLStf0p4Z4rbWNF1q1KywyKs9tdWtwlCGVqq6SI3Q7EHAwfzI/8/Av+cWbL/nHL8zbHVfJ1u8P5ZfmIk955btSXYaddwMv1uw5sxqq+ojxEmvFuO/Ati2RP4+T4Er7/j/b/n+opH4+x1ff8f7f8/1Kj8fY6vv+P9v+f6lR+PsdX3/H+3/P9So/H2Or7/j/AG/5/qVH4+x1ff8AH+3/AD/UqPx9jq+/4/24q//T+QNff8f7f8/1FtH4+x1ff8f7f8/1Kj8fY6vv+P8Ab/n+pUfj7HV9/wAf7f8AP9So/H2Or7/j/b/n+pUfj7HV9/x/t/z/AFKj8fY6vv8Aj/b/AJ/qVH4+x1ff8f7f8/1Kj8fY6vv+P9v+f6lR+Psf1N/8+4v/AFjH8m//AAYf/Ei1PA1l8nf8/h/+UE/JXt/ue1X/AKhYfcYphzfgrX3/AB/t/wA/1FmPx9jq+/4/2/5/qVH4+x1ff8f7f8/1Kj8fY6vv+P8Ab/n+pUfj7HV9/wAf7f8AP9So/H2Or7/j/b/n+pUfj7HV9/x/t/z/AFKj8fY/rN/5wc82TedP+cTvyQ1q4aV5rfQW0ZnmpzI0S6n0oHZmqCLXY1qRuQDtgayHz9/z9Z8tW2s/84ww61ION15Q826Xf20gIUlblJ7F0NQag/WA1ARuoNdqFTE7v5s6+/4/2/5/qLMfj7HV9/x/t/z/AFKj8fY6vv8Aj/b/AJ/qVH4+x1ff8f7f8/1Kj8fY6vv+P9v+f6lR+PsdX3/H+3/P9So/H2Or7/j/AG4q/wD/1PkDX3/H+3/P9RbR+PsdX3/H+3/P9So/H2Or7/j/AG/5/qVH4+x1ff8AH+3/AD/UqPx9jq+/4/2/5/qVH4+x1ff8f7f8/wBSo/H2Or7/AI/2/wCf6lR+PsdX3/H+3/P9So/H2Or7/j/b/n+pUfj7H9Tf/PuL/wBYx/Jv/wAGH/xItTwNZfJ3/P4f/lBPyV7f7ntV/wCoWH3GKYc34K19/wAf7f8AP9RZj8fY6vv+P9v+f6lR+Psey/8AOP8A+S+u/wDOQX5r+Vvyr8v30WlXPmCSZ73Wp0MsVlZ2sTz3E7Rq6lyqIQq8hyYqtVrUKLr8e5+1f5u/8+wPyU0f8jfNZ/Lex126/NPy3o0+o6Jr1zqEk02p3VnGZjayWtY7YfWOJReCIVYqeVAahiJP576+/wCP9v8An+osx+PsdX3/AB/t/wA/1Kj8fY6vv+P9v+f6lR+Psf1qf84S+U5fJX/OKf5IaHPA9tNL5eXV5YJeXNW1meXUyCG3G9107dMDWXyZ/wA/bfPVpov5F+TfIqXEQ1Xzx5pjufqrE82sNJt5JJ5EAZfszzW43qKHpXcKYv53q+/4/wBv+f6izH4+x1ff8f7f8/1Kj8fY6vv+P9v+f6lR+PsdX3/H+3/P9So/H2Or7/j/AG/5/qVH4+x1ff8AH+3/AD/UqPx9jq+/4/24q//V+QNff8f7f8/1FtH4+x1ff8f7f8/1Kj8fY6vv+P8Ab/n+pUfj7HV9/wAf7f8AP9So/H2Or7/j/b/n+pUfj7HV9/x/t/z/AFKj8fY6vv8Aj/b/AJ/qVH4+xMNL0nVtbu0sNF0271e+cFksrKGS4mIFASEj5N+GK3+Pk9R0r/nHr8/Ncmgg0n8lPPd+9xII42i8v6kU5Vp8UnohVA7kkAd6dggH8fJ/UV/ziL+Wms/k/wD844flT+X3mO0bT/MGi6XLca5p7yLK1veajdz6hPCXQspMb3BU8SRtsSMWsm3yj/z9D/Jj8yPzZ/LLyBfflx5Vv/OV35N1u6n1nRdKiNxei2u7YKJordD6kvF4wpWNWb4gaUBIWUS/BDUfyT/ObR1Z9X/KTzppSICXe80HUYAoU0JJkhWlD/n4FmD+Pk80ljlglkhmRoZoWKSxOCrIymhVgSCCCKEH/aVH4+x7p/zjR+ddx/zj7+dPkv8ANFLOTU7DRJ5INf0qJlElzp15E1vdJGXYLzVH5pUgc1WpArRpB3H48n9ankPz75P/ADN8q6T528h+YLTzN5Z1uIS2GqWcgdD2eNx9qOSNqq6OAyMCrAEUwNb8KP8AnOr/AJwA84eW/Nuv/m5+SXly48zeSfMl1JqHmHyfpUTz32kXc7GS4kt7ZKtJau5LARgmKvHiI1BCzjJ+R80M1tNLb3Eb29xbu0c8EgKOjoaMrKSCCCKEHp+osh+PsfoP/wA4g/8AOBn5hfnl5m0fzJ5/0DUPJ35PWMsd3qWpX8clpcaxGjBvqlgjMkpWUbNOAFVa8WL0XFiZP6P/ADX5t8l/lb5QvfMvmzWLHyj5P8tWq/WL64YRQQQxgLHGigVJNAqIgLE0VQTtgYc38rv/ADl//wA5K6j/AM5N/mze+bkin03ydosX6M8h6HOQJILFG5NNMFcr61w9Xeh2HFKkIDhbBt+Pc+V6+/4/2/5/qUj8fY6vv+P9v+f6lR+PsdX3/H+3/P8AUqPx9jq+/wCP9v8An+pUfj7HV9/x/t/z/UqPx9jq+/4/2/5/qVH4+x1ff8f7cVf/1vkDX3/H+3/P9RbR+PsdX3/H+3/P9So/H2Or7/j/AG/5/qVH4+x1ff8AH+3/AD/UqPx9jq+/4/2/5/qVH4+x1ff8f7f8/wBSo/H2Or7/AI/2/wCf6lR+Pse3f84//n55w/5xw8/f8rG8j6do2q63+jbnS/quuxXE9p6N0ULtwtrq1fkPTFPjp7eCir/Hufb/AP0V1/5yR/6kr8tP+4bq/wD3msUcId/0V1/5yR/6kr8tP+4bq/8A3msV4Q7/AKK6/wDOSP8A1JX5af8AcN1f/vNYrwh3/RXX/nJH/qSvy0/7hur/APeaxXhD8zPMuv3nmnzHr/mfUEhhv/MepXWqX0NuGWFJryZppFjV3ZgoZiACxNO+LIfj7Elr7/j/AG/5/qVH4+x7F+UP5/8A5u/kRqz6t+V3ne+8tG5YNqOlArcafd0I/wB6LKfnC5ovEMV5qK8WXFHP8e5+mPkf/n8H5zsba1tvzF/J7SPMdwHVbvVtB1KXSv3fLdxa3EV8GcL29VAT/KOgpHC9Pf8A5+1fk5Kw1Wb8iNZfX0NI52n05iFqDUXJX1B404dfwaRwvMvO3/P4TzleW93b/l5+TmkeX7guVtNU1/U5tVHDls7WttFYBWK9vVYA/wAwG5pIi/NT85P+ciPzh/PzUodQ/NHztd+YIbOR5NK0VQltp1mXJ/uLSDhEpAPHmQXIHxMcWQ/H2PFa+/4/2/5/qVH4+x1ff8f7f8/1Kj8fY6vv+P8Ab/n+pUfj7HV9/wAf7f8AP9So/H2Or7/j/b/n+pUfj7HV9/x/t/z/AFKj8fY6vv8Aj/b/AJ/qVH4+x1ff8f7cVf/X+QNff8f7f8/1FtH4+x1ff8f7f8/1Kj8fY6vv+P8Ab/n+pUfj7HV9/wAf7f8AP9So/H2Or7/j/b/n+pUfj7HV9/x/t/z/AFKj8fY6vv8Aj/b/AJ/qVH4+x1ff8f7f8/1Kj8fY6vv+P9v+f6lR+PsdX3/H+3/P9So/H2Or7/j/AG/5/qVH4+x1ff8AH+3/AD/UqPx9jq+/4/2/5/qVH4+x1ff8f7f8/wBSo/H2Or7/AI/2/wCf6lR+PsdX3/H+3/P9So/H2Or7/j/b/n+pUfj7HV9/x/t/z/UqPx9jq+/4/wBv+f6lR+PsdX3/AB/t/wA/1Kj8fY6vv+P9v+f6lR+PsdX3/H+3/P8AUqPx9jq+/wCP9v8An+pUfj7HV9/x/t/z/UqPx9jq+/4/2/5/qVH4+x1ff8f7f8/1Kj8fY6vv+P8Abir/AP/Q+QNff8f7f8/1FtH4+x1ff8f7f8/1Kj8fY6vv+P8Ab/n+pUfj7HV9/wAf7f8AP9So/H2Or7/j/b/n+pUfj7HV9/x/t/z/AFKj8fY6vv8Aj/b/AJ/qVH4+x1ff8f7f8/1Kj8fY6vv+P9v+f6lR+PsdX3/H+3/P9So/H2Or7/j/AG/5/qVH4+x1ff8AH+3/AD/UqPx9jq+/4/2/5/qVH4+x1ff8f7f8/wBSo/H2Or7/AI/2/wCf6lR+PsdX3/H+3/P9So/H2Or7/j/b/n+pUfj7HV9/x/t/z/UqPx9jq+/4/wBv+f6lR+PsdX3/AB/t/wA/1Kj8fY6vv+P9v+f6lR+PsdX3/H+3/P8AUqPx9jq+/wCP9v8An+pUfj7HV9/x/t/z/UqPx9jq+/4/2/5/qVH4+x1ff8f7f8/1Kj8fY6vv+P8Abir/AP/R+QPxf58v8/8AP5YW0fj7HfF/ny/z/wA/lio/H2O+L/Pl/n/n8sVH4+x3xf58v8/8/lio/H2O+L/Pl/n/AJ/LFR+Psd8X+fL/AD/z+WKj8fY74v8APl/n/n8sVH4+x3xf58v8/wDP5YqPx9jvi/z5f5/5/LFR+Psd8X+fL/P/AD+WKj8fY74v8+X+f+fyxUfj7HfF/ny/z/z+WKj8fY74v8+X+f8An8sVH4+x3xf58v8AP/P5YqPx9jvi/wA+X+f+fyxUfj7HfF/ny/z/AM/lio/H2O+L/Pl/n/n8sVH4+x3xf58v8/8AP5YqPx9jvi/z5f5/5/LFR+Psd8X+fL/P/P5YqPx9jvi/z5f5/wCfyxUfj7HfF/ny/wA/8/lio/H2O+L/AD5f5/5/LFR+Psd8X+fL/P8Az+WKj8fY74v8+X+f+fyxUfj7HfF/ny/z/wA/lio/H2O+L/Plir//2Q==" alt="图片"></h2><h2 class="chapnum"><a></a><a></a></h2>
<h2 class="chaptitle">弗兰艾伦</h2><h2 class="chaptitle">Fran Allen</h2>
<div class="sidebar">
<p class="normal"><i>弗兰·艾伦 (Fran Allen) 计划成为一名数学老师，但需要还清学生贷款，因此她在 1957 年接受了一份她打算在 IBM Research 担任程序员的临时工作。她的第一项任务是：向抵抗力强的 IBM 科学家教授新发明的 Fortran 语言。</i></p><p class="normal"><i>Planning to be a math teacher but needing to pay off her student loans, in 1957 Fran Allen took what she intended to be a temporary job as a programmer at IBM Research. Her first assignment: teach resistive IBM scientists the newly invented language Fortran.</i></p>
<p class="normal"><i>艾伦没有回到教学岗位，而是在 IBM 待了 45 年，从事一系列编译器项目，包括 STRETCH-HARVEST 机器的编译器和雄心勃勃但从未建成的 ACS-1 超级计算机以及她自己的 PTRAN 项目，它开发了 Fortran 程序的自动并行化技术，并开发了静态单一赋值中间表示，现在广泛用于静态和即时编译器。</i></p><p class="normal"><i>Instead of returning to teaching, Allen stayed at IBM for 45 years and worked on a series of compiler projects, including the compilers for the STRETCH-HARVEST machine and the ambitious but never-built ACS-1 supercomputer as well as her own PTRAN project, which developed techniques for automatic parallelization of Fortran programs and developed the Static Single Assignment intermediate representation, which is now widely used in both static and just-in-time compilers.</i></p>
<p class="normal"><i>2002 年，艾伦因其“对优化编译器技术的理论和实践的开创性贡献”而获得图灵奖，成为该奖项 40 年历史上的第一位女性获奖者。她还是第一位被任命为 IBM 院士的女性，这是 IBM 的最高技术荣誉。她还是 IEEE 和计算机协会的会员，以及美国国家工程院、美国艺术与科学院和美国哲学学会的成员。</i></p><p class="normal"><i>In 2002 Allen was awarded the Turing Award for her “pioneering contributions to the theory and practice of optimizing compiler techniques,” becoming the first female recipient in the 40-year history of the prize. She was also the first woman to be named an IBM Fellow, IBM's top technical honor. She is also a fellow of the IEEE and the Association for Computing Machinery and a member of the National Academy of Engineering, the American Academy of Arts and Sciences, and the American Philosophical Society.</i></p>
<p class="normal"><i>在她的职业生涯中，艾伦观察了女性在计算领域的角色变化，从她最早的时候开始，女性被公司特别招聘<a id="OEBPS/Chapter13.html.page_486"></a>IBM 为“程序员”这个新的、定义不明确的工作，直到后来这个领域主要由男性主导的几十年。</i></p><p class="normal"><i>Over her career, Allen has observed the changing role of women in computing, from her earliest days when women were specifically recruited by companies like <a></a>IBM for the new and ill-defined job of “programmer,” to later decades when the field became largely male-dominated.</i></p>
<p class="normal"><i>在我们的谈话中，她谈到了这种转变是什么样的，以及为什么增加该领域的多样性很重要，以及 C 如何严重伤害了计算机科学研究。</i></p><p class="normal"><i>In our conversation she talks about what that transition was like as well as why it is important to increase the diversity in the field and how C has grievously wounded the study of computer science.</i></p>
</div>
<p class="normal"><b>Seibel：</b>您是如何参与编程的？我知道您最初计划成为一名数学老师，但为了偿还学生贷款而在 IBM 找到了一份工作。</p><p class="normal"><b>Seibel:</b> How did you get involved in programming? I know you started out planning to be a math teacher but took a job at IBM in order to pay your student loans.</p>
<p class="normal"><b>艾伦：</b>要成为纽约州的完全认证教师，需要硕士学位。我拥有数学本科学位，辅修物理，并且教了两年书。然后我去了密歇根大学，非常专注于数学。在密歇根大学，为了获得硕士学位，必须修两门专业以外的课程，所以我修了一门计算机课程。计算机科学在 1957 年还不存在。十年后它才开始真正兴起。但是他们在工程学院有几门课程。</p><p class="normal"><b>Allen:</b> To be a fully certified teacher in New York state required a master's degree. I had an undergraduate degree in mathematics, a minor in physics, and had taught for two years. Then I went to the University of Michigan and focused very much on mathematics. At the University of Michigan, in order to get a master's degree, one had to take two courses outside one's field, so I took a course on computing. Computer science didn't exist then, in 1957. It was ten years later that it started to emerge seriously. But they had a couple of courses in the engineering school.</p>
<p class="normal"><b>Seibel：</b>他们教了你什么？</p><p class="normal"><b>Seibel:</b> What did they teach you?</p>
<p class="normal"><b>艾伦：</b>他们有一台 IBM 650 机器，这台机器与我们今天使用的机器完全不同，学生们学会了为那台机器编程。这不仅包括了解机器本身的所有知识和使用汇编语言编写代码，还包括在机器上运行您的程序。这是一次真正的亲身体验。</p><p class="normal"><b>Allen:</b> They had an IBM 650 machine, which was quite a different machine than what we're used to today, and the students learned to program that machine. That involved not only learning all about the machine itself and coding in, essentially, assembly language but also running your programs on the machine. It was a really hands-on experience.</p>
<p class="normal"><b>Seibel：</b>所以你会打你的甲板，自己把它带到机器上，然后自己喂它？</p><p class="normal"><b>Seibel:</b> So you would punch your deck, take it to the machine yourself, and feed it through yourself?</p>
<p class="normal"><b>艾伦：</b>对。然后去修理它。那是一台鼓机——鼓在不停地旋转，这就是你的指令所在的地方。因此，让它快速运行的方法包括将指令在鼓上的位置间隔开，这样当它转动时，下一条指令就会在正确的位置。</p><p class="normal"><b>Allen:</b> Right. And then go and fix it. It was a drum machine—the drum was constantly spinning and that's where your instructions were. So the way one got it to run fast involved spacing the placement of the instructions on the drum so as it turned the next instruction would be in the right place.</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_487"></a><b>Seibel：</b>然后 IBM 的招聘人员过来了。在 IBM 工作的什么地方吸引了您？</p><p class="normal"><a></a><b>Seibel:</b> Then the IBM recruiters came around. What was it about working at IBM that appealed to you?</p>
<p class="normal"><b>艾伦：</b>嗯，我只是需要一份工作。我背负了这笔债务，招聘人员来到校园，它在正确的地理区域，回到纽约州。所以我填写了一份申请表，但并没有意识到我正在面试的是哪个小组，事实上是 IBM Research。我对此一无所知。</p><p class="normal"><b>Allen:</b> Well, I just needed a job. I had this debt and the recruiter came on campus and it was in the right geographical area, back in New York state. So I filled out an application and really didn't realize much about what group I was interviewing with, the fact that it was IBM Research. I was kind of clueless about that.</p>
<p class="normal">几周后，我在伊利诺伊州南部的一所师范学院面试教职时接到了一个电话。我真的很绝望——该找工作了，但我没有。所以我在路上接到了那个电话，接受了这份工作，看不见，并得到了要在波基普西研究实验室报告的论文。</p><p class="normal">A few weeks later I got a call while I was interviewing for a faculty job at a teacher's college in southern Illinois. I was really getting desperate—it was time to get a job and I didn't have one. So I got that call while I was on the road and took the job, sight unseen, and got the papers to report at what turned out to be the research laboratory in Poughkeepsie.</p>
<p class="normal">所以我去了那里，开始成为一名程序员。IBM 正在迅速扩展到计算领域，并且没有任何计算机科学课程，所以他们从他们找到的任何地方招聘人员。</p><p class="normal">So I went there and got started as a programmer. IBM was expanding rapidly into computing and there weren't any computer-science courses, so they were hiring people from wherever they had found them.</p>
<p class="normal"><b>Seibel：</b>他们给了你什么样的培训？</p><p class="normal"><b>Seibel:</b> What kind of training did they give you?</p>
<p class="normal"><b>艾伦：</b>嗯，我记得这是一种边走边学的方式。有一个公司的方向，但我不记得有任何编程课程本身，回想起来这很奇怪。我想有一些课程，具体取决于您的背景。一切都很随意。</p><p class="normal"><b>Allen:</b> Well, it was a kind of a learn-as-you-go, as I recall. There was an orientation to the company but I don't recall there was any programming class per se, which is odd in retrospect. I suppose there were some classes, depending on what your background was. It was all very informal.</p>
<p class="normal">因为我曾是一名数学老师，所以我接到的第一个任务是教科学家和其他程序员 Fortran。我是 1957 年 7 月加入的，同年 4 月 15 日 Fortran 作为产品发布。IBM Research（我所在的小组）下达了一项法令，要求到 9 月所有编程都必须用 Fortran 语言完成。这是说服他们自己的人使用它的方式，就像他们试图让外界的人使用它一样。</p><p class="normal">The first assignment I got, because I'd been a math teacher, was to teach the scientists and other programmers Fortran. I had joined in July of 1957 and Fortran had been issued as a product on April 15 that same year. And IBM Research—the group I was in—had an edict that by September all the programming had to be done in Fortran. That was the way to convince their own people, just as they were trying to get outside people to, to use it.</p>
<p class="normal"><b>Seibel：</b>所以这些是 IBM 内部的科学家，他们在进行自己的科学计算？</p><p class="normal"><b>Seibel:</b> So these were scientists within IBM, doing their own scientific computation?</p>
<p class="normal"><b>艾伦：</b>是的。他们拥有的机器是 704 机器，这就是 Fortran 最初设计和优化的目标。他们习惯于直接在机器上编写汇编代码，做着和我一样的事情<a id="OEBPS/Chapter13.html.page_488"></a>在密歇根大学完成，运行他们自己的程序——安排一些时间并运行程序。他们认为任何高级语言都不可能像他们对机器本身进行编程一样好。</p><p class="normal"><b>Allen:</b> Yes. The machine they had was the 704 machine and that's what Fortran was originally designed for and optimized to. They were used to writing in assembly code right on the machine, doing the same thing I had <a></a>done at the University of Michigan, running their own programs—scheduling some time and running the programs. They did not believe that it would be possible for any high-level language to do nearly as well as what they could do programming the machine itself.</p>
<p class="normal"><b>Seibel：</b>那是科学家最后一次采用新语言，因为他们仍在使用 Fortran，对吧？</p><p class="normal"><b>Seibel:</b> And that was the last time scientists adopted a new language, because they're still using Fortran, right?</p>
<p class="normal"><b>艾伦：</b>没错。好吧，这是一个不愉快的班级。但最终，这对我们所有人来说都是一次了不起的经历，因为 Fortran 不仅是一种语言，而且他们提供了一个非常先进的编译器，并为今天的编译器结构奠定了基础。</p><p class="normal"><b>Allen:</b> That's right. Well, it was an unhappy class. But in the end, it was an amazing experience for all of us because Fortran was not only a language, but they had provided a compiler which was extremely advanced, and laid the foundations for the structure of compilers today.</p>
<p class="normal"><b>Seibel：</b>据我所知，你参与的下一个大项目是 Stretch 计算机。在这段时间和 Stretch 项目之间，你有做过什么吗？</p><p class="normal"><b>Seibel:</b> The next big project that you worked on, that I know about, was the Stretch computer. Did you work on anything in between this time and the Stretch project?</p>
<p class="normal"><b>Allen：</b>我参与了两个项目，分别是 Fortran 和 Stretch 编译器。其中之一是受监控的自动调试系统，它在 704 的装配级别下降。我真的很喜欢它。</p><p class="normal"><b>Allen:</b> There were two projects that I was involved with between Fortran and the Stretch compiler. One of them was the Monitored Automatic Debugging system, which was down at the assembly level for the 704. I really enjoyed that.</p>
<p class="normal">这是一个非常早期的操作系统。我们三个人参与了这项工作。我们在电脑上安装了一些按钮，因为当时你可以这样做，其中一个是紧急按钮。当程序出现循环时，只需按下紧急按钮即可。然后我们编写了调试器，我的任务之一是采用汇编语言程序并生成二进制列——旋转它的输出。当你使用读卡器时，数据是行二进制的，这意味着每一行都包含与指令相关的位，但在磁带上读取的东西不同，所以它需要是列二进制的。我还有程序。</p><p class="normal">It was a very early operating system. There were three of us who worked on it. We installed some buttons on the computer, because you could do that, at that time and one was a panic button. When the program appeared to loop one could just push the panic button. Then we wrote the debugger, and one of my tasks was to take the assembly-language program and produce the column binary—rotate the output of it. When you used a card reader the data was row-binary, which means each row contained the bits that were associated with the instruction, but on tape things were read differently, so it needed to be column-binary. I still have the program.</p>
<p class="normal">我记得真正享受的一件事是阅读原始程序——并认为它非常优雅。这吸引了我，因为这是一个相当复杂的程序，由在该领域工作了一段时间的人——Roy Nutt 编写的。做得很漂亮。</p><p class="normal">One of the things I remember really enjoying is reading the original program—and considering it very elegant. That captured me because it was quite a sophisticated program written by somebody who had been in the field a while—Roy Nutt. It was beautifully done.</p>
<p class="normal"><b>Seibel：</b>是什么让程序如此美丽？</p><p class="normal"><b>Seibel:</b> What makes a program beautiful?</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_489"></a><b>艾伦：</b>这是一个简单直接的问题解决方案；它有一些内在的结构和显而易见的问题本身并不明显。我可能养成了通过学习现有程序并研究它来学习编程和学习一门新语言的习惯。</p><p class="normal"><a></a><b>Allen:</b> That it is a simple straightforward solution to a problem; that has some intrinsic structure and obviousness about it that isn't obvious from the problem itself. I picked up probably a habit from that of learning about programming and learning about a new language by taking an existing program and studying it.</p>
<p class="normal"><b>Seibel：</b>你如何阅读代码？假设您要学习一门新语言并找到一个程序来阅读——您如何攻击它？</p><p class="normal"><b>Seibel:</b> How do you read code? Let's say you're going to learn a new language and you find a program to read—how do you attack it?</p>
<p class="normal"><b>艾伦：</b>嗯，一个例子是我的一名员工构建了一个解析器。这是后来的 PTRAN 项目。我想了解他的方法。它实际上可能是世界上最好的解析器——现在它是开源的，它确实是一个非凡的解析器，可以在运行中进行纠错。</p><p class="normal"><b>Allen:</b> Well, one example was one of my employees had built a parser. This was later on for the PTRAN project. And I wanted to understand his methods. It's actually probably the best parser in the world—now it's out in open source, and it's really an extraordinary parser that can do error correction in flight.</p>
<p class="normal">我想明白了，就拿过来看了。我知道编写它的人 Philippe Charles 是一位漂亮的程序员。我理解一门新语言或一些非常复杂问题的新实现的方法是从我认识的伟大程序员那里获取一个程序，然后阅读它。</p><p class="normal">I wanted to understand it, so I took it and read it. And I knew that Philippe Charles, the man who had written it, was a beautiful programmer. The way I would approach understanding a new language or a new implementation of some very complex problem would be to take a program from somebody that I knew was a great programmer, and read it.</p>
<p class="normal"><b>Seibel：</b>你是如何进入这样一段代码的？你会追踪整个执行过程吗？或者从上到下阅读并在脑海中构建一个结构？这是一种棘手的阅读问题。</p><p class="normal"><b>Seibel:</b> And how do you get into a piece of code like that? Do you trace through the execution? Or read from top to bottom and just build a structure in your mind? It's a sort of tricky reading problem.</p>
<p class="normal"><b>艾伦：</b>嗯，这是一个棘手的阅读问题，但我通常对解决方案的结构有一些直觉或了解，然后进入并可能从中间开始寻找内核部分。这是一种绝妙的方式，不仅可以学习所使用的算法，还可以学习如何以优雅的方式使用该语言。</p><p class="normal"><b>Allen:</b> Well, it is a tricky reading problem, but I usually had some intuition about or learned what the structure of the solution was, and then would go in and start maybe in the middle and look for the kernel piece. And it was a wonderful way to learn not only the algorithms that were used but how to use the language in an elegant way.</p>
<p class="normal"><b>Seibel：</b>您有什么最喜欢的调试战争故事吗？</p><p class="normal"><b>Seibel:</b> Do you have any favorite debugging war stories?</p>
<p class="normal"><b>艾伦：</b>有一对。我记得来自 MAD 系统的一个。机器操作员在半夜给我打电话，因为它不会运行已提交的用于通宵运行的程序。我们有一种方法可以自动校验和以确保数据正确，因为机器本身没有太多的错误检测，也没有纠错。</p><p class="normal"><b>Allen:</b> There were a couple. I remember one from the MAD system. The machine operator called me in the middle of the night because it wouldn't run a program that had been submitted for running overnight. There was a way in which we did automatic checksumming to ensure that the data was right because the machines themselves didn't have much error detection, and no error correction.</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_490"></a>我在电话里想不通。花了一点时间，但我突然意识到我构建系统校验和部分的方式并没有处理特定的情况。由于我计算校验和的方式，即使程序是正确的，它也无法通过该障碍。然后我给那个人回了电话，有办法绕过它。</p><p class="normal"><a></a>I couldn't figure it out on the phone. It took a little while, but suddenly I realized that the way I had built the checksumming piece of the system did not handle a particular case. Even when the program was correct it couldn't pass that barrier because of the way I had calculated the checksum. And I called the man back and there was a way of getting around it.</p>
<p class="normal">然后是另一个——这个我记得是因为我对自己很满意——我在 Stretch 有一名员工喜欢通宵工作。他早上进来，是一个非常令人生畏的人——大块头，而且是一个非常严肃的人。他在我的桌子上扔了一个调试列表——程序的转储——一个又大又厚的东西。他指着那个转储中的一个特定位，他说，“为什么那个位被设置了？” 他整晚都在为这件事担心。奇怪的是，我知道为什么。这不是一个错误，但他不知道它是干什么用的，并且一直认为这是错误的原因。</p><p class="normal">Then there was another one where—this one I remember because I was very pleased with myself—I had an employee on Stretch who preferred to work all night. He came in in the morning and he was a very intimidating man—giant guy and a very serious fellow. And he threw a debug listing across my desk—a dump of the program—a huge, thick thing. And he pointed to one particular bit in that dump, and he said, “Why is that bit set?” He had been worrying all night on it. And oddly enough, I knew why. It wasn't a bug but it was something that he didn't know what it was there for and had been assuming that that was the cause of the error.</p>
<p class="normal"><b>Seibel：</b>那是后来的事了；你说 MAD 和 Stretch 之间还有另一个项目。</p><p class="normal"><b>Seibel:</b> So that was later; you said there was another project between MAD and the Stretch.</p>
<p class="normal"><b>艾伦：</b>是的。这是给这里的一位科学家做硬件接线图的。这与在当时用于芯片的部件上铺设电线有关。这是我们正在实施的数学解决方案，当然，由于房地产的大小，它有很多限制。我当时是一名程序员。我们有两个人，也许三个人——都是女性。</p><p class="normal"><b>Allen:</b> Yes. It was for a scientist here that was doing wiring diagrams for the hardware. It had to do with laying out wires on what passed for chips at that time. It was a mathematical solution we were implementing and it had a lot of constraints, of course, because of the size of the real estate. I was working as a programmer on that. There were two of us, maybe three—all women.</p>
<p class="normal"><b>Seibel：</b>然后是 Stretch 项目，这是一个很大的项目。</p><p class="normal"><b>Seibel:</b> And then it was on to the Stretch project, which was a big one.</p>
<p class="normal"><b>艾伦：</b>根据我使用 Fortran 的经验以及对该编译器的非常了解，我从研究部被选中去从事 IBM 的下一个大项目——Stretch 机器。它始于 1955 年——我猜它在 56 年得到了 Stretch 这个名字——并且将比世界上任何其他东西快 100 倍——一台绝对令人惊叹的机器。</p><p class="normal"><b>Allen:</b> From my experience with Fortran and knowing that compiler very well, I got drafted from Research to go and work on the next big project at IBM—the Stretch machine. It started in 1955—it got the name Stretch in '56 I guess—and was going to be 100 times faster than anything else in the world—an absolutely amazing machine.</p>
<p class="normal">众所周知，编译器将成为机器成功的关键，而实现该性能的最大挑战将是对内存的访问，而编译器在其中发挥了重要作用。</p><p class="normal">It was well recognized that the compiler was going to be key to the success of the machine and that the biggest challenge to achieve that performance was going to be access to memory and that the compiler played a big role in that.</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_491"></a><b>Seibel：</b>因为处理内存延迟会比程序员手写汇编更复杂？</p><p class="normal"><a></a><b>Seibel:</b> Because dealing with the memory latency was going to be more complex than programmers writing assembly by hand were going to be able to handle?</p>
<p class="normal"><b>艾伦：</b>是的。而且因为内存延迟问题正在通过硬件中的大量并发来解决——非常复杂的并发。并且内存组织本身是多路交错的，并且无法预测将什么顺序数据传递给计算单元。六个访问可以同时进行。计算单元本身有流水线，并且可以同时执行多条指令。机器上最复杂的单元是一个前瞻单元，因为它们在架构设计中有精确的中断，所以它不仅要跟踪所有前进的并发，而且还必须将其取消当有中断时。</p><p class="normal"><b>Allen:</b> Yes. And because the memory-latency problem was being solved by a lot of concurrency in the hardware—very complex concurrency. And the memory organization itself was multiway-interleaved and it was unpredictable what order data would be delivered to the computational unit. Six accesses could be in flight at the same time. There were pipelines in the computational unit itself and there was an ability for multiple instructions to be in execution at the same time. And the most complicated unit on the machine was a look-ahead unit, because they had precise interrupts as part of the architectural design, so not only did it have to keep track of all the concurrency going forward, but they had to back it out when there was an interrupt.</p>
<p class="normal">这是一台极其复杂的机器，也是一台非常适合编程的机器。为了利用它，编译器面临着非常大的挑战。这是一个极具挑战性的项目。</p><p class="normal">It was an extremely complicated machine and a wonderful one to program. The compiler had a very big challenge in order to take advantage of it. It was a wonderfully challenging project.</p>
<p class="normal">因此，我们中的一群人从研究部被选拔出来从事编译器和操作系统软件本身的工作。编译器本身和机器一样宏伟。由于我之前接触过 Fortran 优化器，我最终参与了 Stretch 机器的优化器——结果证明是 Stretch Harvest。编译器的大纲是由另一个委员会制定的，但我们中有四个人负责填写细节，包括编译器中的接口及其规范，并负责其中的不同部分. 我有优化器，其他人有解析器、寄存器分配器和与汇编程序的接口。</p><p class="normal">So a bunch of us were drafted out of Research to come and work on the compiler and the operating-system software itself. The compiler itself was as grandiose as the machine. I ended up, because of my previous exposure to the Fortran optimizer, involved with the optimizer for the Stretch machine—the Stretch Harvest, as it turns out. The outlines of the compiler were established by a different committee but there were four of us who were given the charge of filling in the details, including the interfaces in the compiler and what the specs were for that and taking charge of the different pieces of it. I had the optimizer, and somebody else had the parser, the register allocator, and the interface with the assembly program.</p>
<p class="normal"><b>Seibel：</b>从技术人员的角度来看，该项目是如何构建的？</p><p class="normal"><b>Seibel:</b> How was the project structured in terms of the technical people working on it?</p>
<p class="normal"><b>艾伦：</b>嗯，大约有三个人制定了编译器的总体设计——我们将有一个解析器，我们将有这个和那个，然后是它适合的地方。在他们之上有人——这是一个产品，所以有更多的决策层和管理层。</p><p class="normal"><b>Allen:</b> Well, there were around three people who laid out the overall design of the compiler—we're going to have a parser, we're going to have this and that, and then where it fit. And there was somebody above them—this was a product, so there were more layers of decision-making and management.</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_492"></a>然后他们需要为每个大组件配备项目监督员。所以他们让我们四个人（其中三个是女性）参与进来，作为一个团队聚在一起设计界面。</p><p class="normal"><a></a>Then they needed to have project overseers for each of the big components. So they asked four of us, three of us being women, to get involved, to get together as a team and design the interfaces.</p>
<p class="normal"><b>Seibel：</b>然后还有其他程序员参与实际实施吗？</p><p class="normal"><b>Seibel:</b> And then were there other programmers working on the actual implementation?</p>
<p class="normal"><b>艾伦：</b>是的。我有一群 17 人，都在做编程。</p><p class="normal"><b>Allen:</b> Yes. I had a group of 17, all doing programming.</p>
<p class="normal"><b>Seibel：</b>设计阶段和编码之间的关系是什么？你们四个聚在一起，整理了各个部分之间的接口。这一切是在您的 17 名程序员开始编写代码之前发生的，还是编码反馈到您的设计中的？</p><p class="normal"><b>Seibel:</b> What was the relation between the design phase and the coding? You four got together and sorted out the interfaces between the parts. Did that all happen before your 17 programmers started writing code, or did the coding feed back into your design?</p>
<p class="normal"><b>艾伦：</b>我们去的时候几乎就发生了。我们的限制是由我们向其报告的人设定的。不同部分的负责人，像我一样，向一个人 George Grover 汇报，他在技术上制定了更大的图景。其中很多是由客户的限制驱动的。当时有很多团队合作和很大的灵活性，部分原因是我们在进行过程中进行了一些发明。但在最后期限内。所以没有那么多的管理层级，只是更多地成为团队的一部分。</p><p class="normal"><b>Allen:</b> It was pretty much happening as we went. Our constraints were set by the people we reported to. And the heads of the different pieces, like myself, reported to one person, George Grover, and he had worked out the bigger picture technically. And a lot of it was driven by the constraints of the customers. There was a lot of teamwork and a lot of flexibility at the time, in part, because we were kind of inventing as we went. But under a deadline. So there was not as much management hierarchy, but just being more part of the team.</p>
<p class="normal"><b>Seibel：</b>你下面的人是否曾经编写过代码，然后迫使人们意识到必须重新审视一些关于如何将各个部分组合在一起的高层决策？</p><p class="normal"><b>Seibel:</b> Did the people below you ever write code that would then force the realization that some of the higher-up decisions about how the pieces were going to fit together had to be revisited?</p>
<p class="normal"><b>艾伦：</b>是的，这个界面怎么也行不通。跟踪事情是如何走到一起的是其中的一部分。我们会作为一个团队见面，我们四个人。但我们的大部分时间都花在尝试构建我们负责的组件上——有很多自由。</p><p class="normal"><b>Allen:</b> Yes, how this interface is not going to work. Keeping track of how things were coming together was a part of it. We would meet as a team, the four of us. But most of our time was spent on trying to build the component that we were responsible for—there was a lot of freedom.</p>
<p class="normal">软件工程来得晚得多。当时还没有软件工程，也没有建立大的流程。在我没有参与的 Fred Brooks 运行的后续项目 360 中，软件是一个巨大的危机。360 的工程在 63 年左右做得很好。一些工程师从制造机器——硬件工程师——那些对软件一无所知的人——转而运行软件，因为它太失控了。这真的是一团糟。</p><p class="normal">Software engineering came much later. There wasn't software engineering and there weren't big processes set up yet. On a subsequent project, the 360, run by Fred Brooks, which I wasn't involved with, the software was a huge crisis. The engineering on the 360 was doing pretty well around '63. And some engineers moved over from building the machines—hardware engineers—guys that just knew nothing about software—to run the software because it was so out of hand. And it was really a mess.</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_493"></a>在 360 发货后，其中一个人——我不知道他是否参与过 360——写了一封信给 IBM 的高层，提议建立一个名为 Cleanroom 的软件工程学科。他声明说，如果你遵循他列出的所有这些流程，你就可以编写出完美的程序。由于管理层的经历——这是我的说法——他们买下了整个东西。</p><p class="normal"><a></a>After the 360 got shipped one of the people—I don't know that he'd been involved with the 360—wrote a letter to the higher-ups in IBM proposing a software-engineering discipline called Cleanroom. He made statement that if you followed all these set of processes he was laying out, you could write perfect programs. And because of what management had been through—this is my version—they bought the whole thing.</p>
<p class="normal"><b>Seibel：</b>因为360的项目太痛苦了？</p><p class="normal"><b>Seibel:</b> Because the 360 project had been so painful?</p>
<p class="normal"><b>艾伦：</b>没错。因此，IBM 产品开发非常强烈地转向了 Cleanroom 流程——一整套流程。其中一件事是会有人设定目标，并且会有另一个小组进行设计。设计师会将设计指定为程序员可以写入设计的细节。而且这些组不是交互式的——你只要做得足够干净，完美的软件就出来了。</p><p class="normal"><b>Allen:</b> That's right. So IBM product development moved very strongly over to the Cleanroom processes—a whole set of processes. One of the things was that there would be somebody that would set objectives and there would be another group that did the design. And the designers would specify the design to the detail that the programmers could write to the designs. And these groups were not interactive—you just did this cleanly enough, and perfect software came out.</p>
<p class="normal"><b>Seibel：</b>在360项目中，Brooks负责软件和硬件，对吧？</p><p class="normal"><b>Seibel:</b> On the 360 project, Brooks was in charge of both software and hardware, right?</p>
<p class="normal"><b>艾伦：</b>是的，我认为他拥有一切。但他用有硬件经验的人换掉了一些软件负责人。这确实是正确的做法，因为硬件人员在构建硬件方面已经有了很好的纪律——芯片设计和测试过程等等。那是一种更古老、更严格的表达设计的方式。我们软件人员只是在编造它。</p><p class="normal"><b>Allen:</b> Yes, I think he had the whole thing. But he replaced some of the software heads with people with hardware experience. And it was really the right thing to do because the hardware people already had a wonderful discipline around building hardware—the chip design and the testing process and all of that. And that was an older and much more rigorous ways of expressing designs. We software people were just making it up.</p>
<p class="normal"><b>Seibel：</b>所以你觉得，至少在那个项目上，他们为软件开发过程带来了一些东西，拯救了这个项目？</p><p class="normal"><b>Seibel:</b> So you feel that, at least on that project, that they brought something to the software-development process that saved the project?</p>
<p class="normal"><b>艾伦：</b>这是绝对必要的，但是让这些人——所有这些人——进来，对软件一无所知，只是强加设计审查、设计规范，所有这些东西，对软件人员来说是非常痛苦的。</p><p class="normal"><b>Allen:</b> It was absolutely necessary, but it was so painful for the software people to have these guys—all guys—move in, knowing nothing about software, and just impose design reviews, design specs, all of this stuff.</p>
<p class="normal"><b>Seibel：</b>所以它确实帮助挽救了那个项目。这是否鼓励了人们采取下一步的洁净室流程，这有点过分了？</p><p class="normal"><b>Seibel:</b> So it did help save that project. Did that embolden folks to take this next step to the Cleanroom process that was sort of a step too far?</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_494"></a><b>艾伦：</b>是的，我想是的。这就是顺序。Cleanroom 流程，瀑布流程，是通过管理层大力提倡的。</p><p class="normal"><a></a><b>Allen:</b> Yeah, I think it did. That was the sequence. And the Cleanroom process, the waterfall process, came in through management with a very strong advocate for it.</p>
<p class="normal"><b>Seibel：</b>那个倡导者来自硬件方面？</p><p class="normal"><b>Seibel:</b> And that advocate was from the hardware side?</p>
<p class="normal"><b>艾伦：</b>不，倡导者来自软件方面。但我不认为他是 360 项目的一部分，在试图挽救它的深处。但是我们中一些已经对软件结构有一定经验的人当时对这些说法感到震惊。但有时为了卖东西，必须做出大胆的声明。</p><p class="normal"><b>Allen:</b> No, the advocate was from the software side. But I don't think that he had been part of the 360 project, in the depths of trying to rescue that. But some of us who already had some experience with software structure were appalled at the statements at the time. But sometimes one has to make bold claims in order to sell something.</p>
<p class="normal"><b>Seibel：</b>您曾经参与过使用这种流程的项目吗？</p><p class="normal"><b>Seibel:</b> Did you ever work on a project where that kind of process was used?</p>
<p class="normal"><b>艾伦：</b>哦，是的。并发现它令人沮丧，因为在早期阶段，设计师和程序员无法互动。其中一个问题是——可能仍然是——软件的生命周期很长。在那个时候，如果你要构建一个大型软件，需要数月、数月或数年的时间。而且环境变了，要求也变了。客户确实对他们最终想要什么有发言权。</p><p class="normal"><b>Allen:</b> Oh, yes. And found it frustrating because in its early stages, a designer and the programmer could not interact. One of the problems was—probably still is—that the life cycle of a piece of software is very long. And at that time, if you were building a big piece of software, it took months and months or years. And the environment changed and the requirements changed. And the customers really did have the say in what they wanted in the end.</p>
<p class="normal"><b>Seibel：</b>然后您会在整个过程中一直推动更改吗？还是人们开始缩短流程，直接去找程序员说，“好吧，我们发现客户需要<i>X</i> ”？</p><p class="normal"><b>Seibel:</b> Would you then push changes all the way down through the process? Or did people start short-circuiting the process, going directly to the programmers and saying, “All right, we figured out the customer needs <i>X</i>”?</p>
<p class="normal"><b>艾伦：</b>是的。一个人永远不可能真正编写出在多年的生命周期中在细节层面上足够和有用的规范。那是个问题。现在我们有了另一个过程，当然——做完然后扔掉，有点。</p><p class="normal"><b>Allen:</b> Yeah. One could never really write specs that were going to be adequate and useful at a detail level over the years of the life cycle. That was a problem. And now we have another process, of course—just do it and throw it away, kind of.</p>
<p class="normal"><b>Seibel：</b>嗯，是布鲁克斯在他的名著中说，“建造一个可以扔掉的东西，因为你会扔掉它。”</p><p class="normal"><b>Seibel:</b> Well, it was Brooks, in his famous book, who said, “Build one to throw away because you're going to.”</p>
<p class="normal"><b>艾伦：</b>是的。事实上，这是真的——我非常相信这一点。但很多时候，在我看来，这导致在开始构建之前根本没有考虑。</p><p class="normal"><b>Allen:</b> Yes. And in fact, that is true—I very much believe that. But lots of times, that has led, in my opinion, to not thinking at all before you start building.</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_495"></a>我总是喜欢有一张照片——一个模特。通常是流程图和一些关于接口的规范。当然，我们当时是流程图的重度用户，因为人们不能经常访问机器，这是一个非常好的模型，可以用来思考系统的各个部分如何交互、将要做什么，并指定将在何处完成什么，以及各个组件的功能。我不知道现在的模拟是什么。</p><p class="normal"><a></a>I always like to have a picture—a model. Often a flowchart and some specification about the interfaces. We were heavy users, of course, of flowcharts at that time because one didn't get access to the machine that often and that was a very nice model for thinking through how parts of the system would interact, what would be done, and specifying what would be done where, and the functionality of the various components. I don't know what the analog of that is now.</p>
<p class="normal"><b>Seibel：</b>即使是流程图，也有作为文档生成的正式流程图，然后是你在黑板上画的流程图，试图理解一些东西。是前者多还是后者多？</p><p class="normal"><b>Seibel:</b> Even with flowcharting, there are formal flowcharts produced as documentation and then there are the flowcharts you draw on a blackboard to try and understand something. Was it more of the former or the latter?</p>
<p class="normal"><b>艾伦：</b>在某些情况下，它会是正式的流程图。通常在事物的内核中有一些非常复杂的部分，人们会这样做。否则，它只是非正式的，是解决问题的一种方式。黑板将被覆盖并成为当月或任何时间段的记录。</p><p class="normal"><b>Allen:</b> In some cases, it would be formal flowcharts. Often in the kernels of things there were some very complex pieces and one would do that. Otherwise, it was just informal and a way of working at solving a problem. Blackboards would be covered and become the record for the month or whatever period of time.</p>
<p class="normal"><b>Seibel：</b>所以你领导的大项目是 PTRAN 编译器项目，这是你第一次开始研究显式并发，而不是 CPU 管道中的隐式并发等等。当您开始这样做时，这对您和 IBM 来说都是一件新鲜事。</p><p class="normal"><b>Seibel:</b> So the big project you led was the PTRAN compiler project, which was when you first started working on explicit concurrency, as opposed to the implicit concurrency in the CPU pipelines and so forth. When you started that, that was a new thing, both for you and for IBM.</p>
<p class="normal"><b>艾伦：</b>这对 IBM 来说是新事物，但我们进入它的时间非常非常晚。从真正务实的角度发起它的伟大工作是在 69 和 70 年代在伊利诺伊州开始的。</p><p class="normal"><b>Allen:</b> It was new for IBM, but we were very, very late coming into it. The great work that initiated it from a real pragmatic point of view was at Illinois starting in '69 and '70.</p>
<p class="normal"><b>Seibel：</b> PTRAN 编译器编译的是什么语言？它是没有添加并行结构的直接 Fortran 语言吗？</p><p class="normal"><b>Seibel:</b> And what language did the PTRAN compiler compile? Was it straight Fortran with no added constructs for parallelism?</p>
<p class="normal"><b>艾伦：</b>没错，这就是我们的起点。我想做的是做我们为优化所做的同样的事情：用户以一种对应用程序自然的方式用语言编写顺序代码，然后让编译器进行优化并将其映射到机器上，然后利用并发。</p><p class="normal"><b>Allen:</b> That's right, that's where we started from. What I wanted to do was to do the same thing we'd done for optimization: The user writes a sequential code in the language in a way that's natural for the application and then have the compiler do the optimization and mapping it to the machine and taking advantage of concurrency.</p>
<p class="normal">在 PTRAN 中，想法仍然是采用我们所说的“尘土飞扬的甲板”，指的是现有代码库，并自动利用硬件的并行组件。</p><p class="normal">In PTRAN, the idea was still to take the “dusty decks,” as we called them, referring to an existing code base, and to automatically take advantage of the hardware's parallel components.</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_496"></a><b>Seibel：</b>所以，从本质上讲，这是针对我们今天所认为的对称多处理器？</p><p class="normal"><a></a><b>Seibel:</b> So, essentially, that was targeting what today we would think of as symmetric multiprocessors?</p>
<p class="normal"><b>艾伦：</b>是的，可能是。并行的模型有很多很多，这是难点之一。我认为这可以大大简化。但多核是真正特别有趣的事情之一，至少对我来说是这样。但是有许多并行模型。</p><p class="normal"><b>Allen:</b> Yeah, could be. There are many, many models of parallelism, which is one of the difficulties. I think that that can be greatly simplified. But multicore is one of the things that really are particularly interesting, for me at least. But there are many models of parallelism.</p>
<p class="normal">我们实际上是根据现有工作构建它的，尤其是 Dave Kuck 的工作。纽约大学的一些作品。我们从这些地方聘请了一批新晋的博士，他们已经积累了很多专业知识。我们在实践和理论方面都取得了相当多的重要成果——我们同时致力于这两方面。我坚信人们希望能够将实践转化为可识别的算法、理论和思考如何解决问题的方法，并将算法付诸实践以了解它们的真正价值，以及它们如何应用。我认为当双方在同一项目上工作时，我们的领域做得最好。</p><p class="normal">We actually built it from existing work, particularly Dave Kuck's. Some work from NYU. We hired a group of newly minted PhDs from these places that already had built up a lot of expertise. We had a quite a lot of significant results, both on the practical and on the theoretical side—we worked on both at the same time. I'm a very strong believer that one wants to be able to take the practice into identifiable algorithms, and theory, and ways of thinking about how to solve the problems and also to take the algorithms into practice to see how really valuable they are, and how they apply. I think our field is best done when it works on both sides on the same projects.</p>
<p class="normal"><b>Seibel：</b>在 PTRAN 项目中，您领导着一个团队。那时你还在编码吗？</p><p class="normal"><b>Seibel:</b> On the PTRAN project, you were leading a team. Were you still coding at all by then?</p>
<p class="normal"><b>艾伦：</b>我没有做编码，但我已经非常接近了。例如，当静态单一分配工作完成时，我没有看到如何在任何合理的时间内实施它。我的意思是，这是一个非常好的算法，但我没有看到以某种真实方式在时间和空间上有界的实现。所以我在那里遇到了挑战。我必须看到那个代码。我需要它。它必须得到实施。它不可能只是一篇论文——一篇非常好的论文，一篇著名的论文——它显示了图形和复杂性界限。</p><p class="normal"><b>Allen:</b> I wasn't doing the coding, but I was very close to it. As an example, when the Static Single Assignment work was done, I didn't see how it could be implemented in any reasonable time. I mean, it was a very good algorithm, but I didn't see an implementation that was bounded in time and space in some real way. So I had that challenge out there. I had to see that code. I needed it. It had to be implemented. It couldn't be just a paper—a very nice paper, a famous paper—that shows graphs and complexity bounds.</p>
<p class="normal">如果我们不能在真实系统中实施它，那么挑战仍然存在。它不会像我希望的那样有用。最后，我的一个人有一个编码。我遍历了每一段代码，并查看了所使用的数据结构。这令人震惊。我说：“就是这个。有用。”</p><p class="normal">If we can't implement it in a real system, that challenge would still be out there. It wasn't going to be as useful as I wanted it to be. Finally, one of my people had an encoding. And I walked through that, every piece of that code, and looked at the data structures that were used. And it was astounding. I said, “This is it. It works.”</p>
<p class="normal"><b>Seibel：</b>所以你正在查看将要进入整个系统的所有部分？</p><p class="normal"><b>Seibel:</b> So you were looking at all of the pieces that were going to go into the whole system?</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_497"></a><b>艾伦：</b>是的，是的，是的。</p><p class="normal"><a></a><b>Allen:</b> Yes, yes, yes.</p>
<p class="normal"><b>Seibel：</b>你也管理着所有这些人？或者您是一名技术架构师，其他人负责管理团队？</p><p class="normal"><b>Seibel:</b> You also were managing all these people? Or were you a technical architect with someone else managing the group?</p>
<p class="normal"><b>艾伦：</b>不，我是该小组的研究经理。大约有 10 或 12 名核心人员，我们将工作进行了划分，以便每个人真正拥有其中的一部分。</p><p class="normal"><b>Allen:</b> No, I was the research manager for the group. There were about 10 or 12 core people and we divided the work up so that each person really had ownership of a piece of it.</p>
<p class="normal"><b>Seibel：</b>至少自 Gerald Weinberg 的《<i>计算机编程心理学》</i>一书以来，人们一直在争论，是让人们“拥有”代码更好，以便他们对代码负责，还是让人们更协作地工作，从而避免只有一个孤岛人明白。听起来您认为分割所有权是可行的方法？</p><p class="normal"><b>Seibel:</b> People have been debating at least since Gerald Weinberg's book <i>The Psychology of Computer Programming</i> whether it's better for people to “own” code, so they take responsibility for it, or to have people work more collaboratively so you avoid having silos that only one person understands. It sounds like you thought dividing up the ownership was the way to go?</p>
<p class="normal"><b>艾伦：</b>我们合作过，但合作是关于系统和实施的状态。有些人非常擅长实施，所以他们拥有一块——优化器或过程内分析的一部分肯定是一两个人。但同时，也有很多人在做大量的理论工作，或者写论文的抽象工作，写了很多论文和算法。我认为正是这两个特殊部分的结合才真正让这个团队变得如此强大。</p><p class="normal"><b>Allen:</b> We worked collaboratively, but the collaboration was about the state of the system, of the implementation. And some people were very good at the implementation, and so they'd own a piece—some piece of the optimizer or the intra-procedural analysis was definitely one or two people. But also, there were a number of people that were doing a lot of the theory work, or the abstract work of writing the papers, and writing a lot of the papers and algorithms. And it was the bringing together of those two special parts that I think really made the group so strong.</p>
<p class="normal">这是一个在并行性分析和转换方面进行大量工作的时期。所以我试图做的是，对于每个正在做理论的人，让他们写一些代码，用代码将其表达为系统的一部分。那些只是在做另一部分的人，好吧，我会试着让他们把事情写下来，这样他们就更普遍了。</p><p class="normal">This was a period of a lot of work going on in the analysis and transformations for parallelism. So what I tried to do was, for each of the people that were doing theory to get them to write some code, express it in code as a part of the system. And the people who were just doing the other part, well I'd try to get them to write things up so they were more generally available.</p>
<p class="normal"><b>Seibel：</b>很多程序员会不惜一切代价避免成为经理。管理一些你也喜欢的事情吗？</p><p class="normal"><b>Seibel:</b> A lot of programmers will do anything to avoid becoming a manager. Was managing something that you also enjoyed?</p>
<p class="normal"><b>艾伦：</b>嗯，早期的研究没有区分——做管理不是升职，不是加薪。只是有人必须管理这项工作，然后“好吧，你不想做吗？” 或者，“你是管理这项工作的不二人选。” 这是技术管理；没有太多的人员管理参与。但<a id="OEBPS/Chapter13.html.page_498"></a>在研究人员是 RSM，研究人员，他们进入的那一天，以及他们职业生涯的其余部分。我所有的同事，这就是我们。因此，一个人在没有任何耻辱的情况下进出管理层。</p><p class="normal"><b>Allen:</b> Well, Research in the earlier times did not distinguish—doing management was not a promotion, not a salary raise. It was just somebody had to manage this piece of work, and “OK, don't you want to do it?” Or, “You're the obvious one to manage this piece of work.” And it was technical management; there wasn't much people management involved. But <a></a>in Research people are RSMs, Research Staff Members, the day they enter, and for the rest of their career mostly. All my colleagues, that's what we are. So one moved in and out of management without any stigma attached.</p>
<p class="normal"><b>Seibel：</b>所以大概被选中管理的人是真正擅长管理的人。你是如何掌握这些技能的？</p><p class="normal"><b>Seibel:</b> So presumably the people who got chosen to manage were the ones who were actually good at it. How did you pick up those skills?</p>
<p class="normal"><b>艾伦：</b>嗯，我被送到了管理学院。当我第一次被任命时，每个人都是。但我想这可以追溯到我在农场长大的时候。我是六个孩子中最大的一个，而且我们一排是五个孩子，所以我的父母不知所措。所以在某些方面，这对我来说是一个自然的角色。</p><p class="normal"><b>Allen:</b> Well, I was sent to management school. Everybody was, back when I was first appointed. But I think it goes back to when I grew up on the farm. I was the oldest of six kids and there were five of us in a row, so my parents were pretty overwhelmed. So it was a natural role for me in some ways.</p>
<p class="normal"><b>Seibel：</b>你所做的那种技术管理的困难之一是在对应该如何做的事情有你自己的技术意见和给人们空间来表达他们自己的想法之间找到平衡。</p><p class="normal"><b>Seibel:</b> One of the difficulties of the kind of technical management that you were doing is finding the balance between having your own technical opinions about how stuff should be done and giving people room to put their own ideas in.</p>
<p class="normal"><b>艾伦：</b>我想我在 Stretch 项目上有过一些惨痛的教训。我记得有一天，该项目的一些人进来对我说，我们应该使用列表和哈希函数。好吧，我们知道列表程序，但散列是新的。所以我的几个人来了，说他们想对符号表使用散列。我说，“不，我们不能那样做。我们不知道该怎么做。” 亚达，亚达，亚达。下周一我进来了，他们已经完成了。他们拆除了系统并用散列法重建了它。它奏效了，而且速度更快。所以这对我来说是一个很大的教训。我应该对一些全新的想法更加开放。</p><p class="normal"><b>Allen:</b> I think I had some hard lessons on the Stretch project. I remember some of the people on the project came in and said to me one day that we ought to be using list and hash functions. Well, we knew about list programs but hashing was new. So a couple of my people came and said they wanted to use hashing for the symbol table. And I said, “No, we can't do that. We don't know how to do that.” Yadda, yadda, yadda. The next Monday I came in and they had done it. They had torn down the system and rebuilt it with hashing. It worked, and it was much faster. So that was a big lesson to me. I should be much more open to some brand-new ideas.</p>
<p class="normal"><b>Seibel：</b>所以有时候——甚至可能经常——你的员工实际上知道他们在谈论什么，你不应该干涉太多，因为你可能会扼杀一个好主意。如果你真的是对的，而他们的想法确实有点缺陷，但你不想过分打击他们，那就更棘手了。</p><p class="normal"><b>Seibel:</b> So sometimes—maybe even often—your people actually know what they're talking about and you shouldn't interfere too much because you might stomp out a good idea. It's trickier when you're really right and their idea really is a little bit flawed but you don't want to beat up on them too much.</p>
<p class="normal"><b>艾伦：</b>有一些。通常是有人带着某些领域的知识进来，并希望将这些知识应用到正在进行的项目中，而没有在项目中嵌入足够长的时间来了解，而且往往是在最后期限之前。</p><p class="normal"><b>Allen:</b> There was some of that. It was often where somebody came in with a knowledge of some area and wanted to apply that knowledge to an ongoing piece of project without having been embedded in the project long enough to know, and often up against a deadline.</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_499"></a>我在做一些分包工作时遇到了很多问题。我有一群人在基于我们在这里为 PL/I（一种不同的大语言）所做的工作构建优化器方面做得非常出色。但是为分包商工作的人之一刚刚发现了面向对象的编程，并决定将其应用到极致。而且我无法阻止他，即使我是合同监督员，而且项目被毁了。最终，PL/I 有很多指针，并且一直跟踪一个指针，它需要 11 条指令来跟踪值，以一致地找到一个指针的值。</p><p class="normal"><a></a>I ran into it big time doing some subcontracting work. I had a group of people that was doing wonderful work building an optimizer based on the work we've done here for PL/I, a big, different language. But one of the people working for the subcontractor had just discovered object-oriented programming and decided that he would apply it to the extreme. And I couldn't stop him, even though I was the contract overseer, and the project was destroyed. Ultimately, what did it was PL/I has lots of pointers and tracing a pointer is done all the time, and it took 11 instructions to trace the value, to find the value of one pointer consistently.</p>
<p class="normal"><b>Seibel：</b>你的意思是在生成的代码中。</p><p class="normal"><b>Seibel:</b> You mean in the generated code.</p>
<p class="normal"><b>Allen：</b>在生成的代码和编译器本身中，因为它在引导编译器。每次你迈出一步，你都必须检查它是否有效。你一直在检查，再检查，再检查。它今天仍然发生。其中一些教训我们还没有学好。我想我处理得不是很好，因为我应该指出在那种情况下应用面向对象技术的成本是多少。它实在是太慢了，所以整个事情都被取消了。</p><p class="normal"><b>Allen:</b> In the generated code and in the compiler itself because it was bootstrapping the compiler. Every time you made a step you had to check that the thing's valid. And you were checking, and rechecking, and rechecking. It still happens today. Some of these lessons we haven't learned well. And I guess I was not dealing with it very well, because I should have just pointed out what the cost of applying object-oriented technology in that kind of situation. It was just hopelessly slow, so the whole thing got canceled.</p>
<p class="normal"><b>Seibel：</b>您最直接地为 IBM 构建产品的时间是什么时候，必须满足生产截止日期？</p><p class="normal"><b>Seibel:</b> When were you most directly building a product for IBM, with production deadlines that had to be met?</p>
<p class="normal"><b>艾伦：</b>当然，Stretch 项目就是这样。我从事过两三次产品开发工作，遇到过在截止日期前每周进行一次代码审查的情况。我非常尊重这些流程，以及它们对最终结果和团队的重要性。每周五坐在那里和人们一起阅读代码，解释他们为什么要做他们正在做的事情，并找出其他人的错误，这可能会非常痛苦。</p><p class="normal"><b>Allen:</b> Certainly, the Stretch project was that way. And I've worked in product development two or three times, and been in the situation where one has week-by-week code reviews right up against deadlines. I have a lot of respect for those processes and how important they are for the end result and for the team that's doing it. It can be very painful to sit there every Friday and do code reads with people explaining why they're doing what they're doing and finding other people's errors.</p>
<p class="normal"><b>Seibel：</b>很痛苦，但值得吗？</p><p class="normal"><b>Seibel:</b> Painful, but worthwhile?</p>
<p class="normal"><b>艾伦：</b>绝对值得。在 PTRAN 项目中，当我们将它的一部分交付给产品时，每周都会花半天时间来解释我们代码中的错误，他们的代码，不管是什么。我想这持续了十个月。星期五下午专心致志。</p><p class="normal"><b>Allen:</b> Absolutely worthwhile. On the PTRAN project, towards the end when we were shipping a piece of it to the products, a half a day was devoted to explaining errors in our code, their code, whatever it was, every week. That went on for ten months, I think. Devoted Friday afternoon to it.</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_500"></a><b>Seibel：</b>当你在这些环境下工作时，你是否觉得你有一个过程可以让你估计构建<i>X</i>数量的软件需要多长时间？</p><p class="normal"><a></a><b>Seibel:</b> When you were working in those settings did you feel like you had a process that let you estimate how long it's going to take to build <i>X</i> amount of software with any kind of accuracy?</p>
<p class="normal"><b>艾伦：</b>嗯，他们做到了。产品开发人员当然做到了。一切都被跟踪了，我相信现在仍然如此。其中一部分是从统计上了解代码的质量。是的，本周出现了多少错误。我喜欢产品实验室的环境，因为这是让事情变得真实的地方。</p><p class="normal"><b>Allen:</b> Well, they did. The product-development people certainly did. It was all tracked, and I'm sure it still is. Part of it would be to statistically get a handle on the quality of the code. How many bugs showed up this week, yeah. I liked the environment of a product lab because it's sort of where things get real.</p>
<p class="normal"><b>Seibel：</b>当你招聘程序员时，你在寻找什么？</p><p class="normal"><b>Seibel:</b> When you were hiring programmers what did you look for?</p>
<p class="normal"><b>艾伦：</b>嗯，我在大学里有很多人脉。纽约大学有一些出色的编译器编写教员——他们在编写编译器代码方面训练有素。</p><p class="normal"><b>Allen:</b> Well, I had a lot of connections in the universities. NYU had some fabulous compiler-writer faculty—that group was really well-trained to write compiler code.</p>
<p class="normal"><b>Seibel：</b>所以你可以聘请你认识和信任的教授推荐的人。如果你不得不面试一个没有你信任的人推荐的人，你如何在几个小时内确定他们是否会成为一名优秀的程序员？</p><p class="normal"><b>Seibel:</b> So you could hire people recommended by the professors you knew and trusted. How about when you have to interview someone who doesn't come with a recommendation from someone you trust—how do you figure out in the course of a couple of hours whether they are going to be a good programmer?</p>
<p class="normal"><b>艾伦：</b>对于 IBM Research，我总是从采访任何人开始，试图找出他们对什么感到兴奋。这对我来说是一个基本门槛。并且它与编程或计算机有什么关系并不重要。如果他们不能对某事充满热情，他们就不会在团队中充满活力。</p><p class="normal"><b>Allen:</b> I always start with interviewing anybody for IBM Research by trying to find out what they're excited about. That's kind of a basic threshold for me. And it doesn't matter whether it has anything to do with programming or computers. If they can't get enthusiastic about something, they're not going to get charged up in a group.</p>
<p class="normal">有时一个人冒着很高的风险。我对一个人冒了很大的风险，他的论文导师写道他患有严重的诵读困难症。他在这里的表现不太好，因为他在某些方面不适应，但他创办了自己的公司，我仍然向他寻求建议，寻求如何在技术上做事的见解。他只知道事情。所以那不是一个错误。就项目而言这是一个错误，但就他与我们很多人的关系而言却不是。</p><p class="normal">Sometimes one takes a high risk. I took a high risk on a guy whose thesis adviser wrote that he was very dyslexic. He didn't work out so well here because he didn't fit in some ways, but he started his own company and I still go to him for advice, for insights on how to do things technically. He just knows things. So that wasn't a mistake. It was a mistake in terms of the project, but not in terms of his relationship with a lot of us.</p>
<p class="normal"><b>Seibel：</b>最近您参与了指导工作——IBM 有一个以您的名字命名的指导奖。关于如何让新程序员成为更好的程序员，您有什么想法吗？</p><p class="normal"><b>Seibel:</b> Lately you've been involved in mentoring—there's a mentoring award here at IBM that is named for you. Do you have any ideas about how new programmers should be brought along into being better programmers?</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_501"></a><b>艾伦：</b>这方面的指导，这些天我不太了解。不过，我所做的是鼓励刚起步的年轻人不要跳槽成为经理，这对那些在这方面有天赋的人来说非常有吸引力。获得技术工作的声誉。无论是一门优秀的科学、一种算法，还是编写出色的代码——无论是什么，首先要在那里建立良好的声誉。如果你确实想去管理项目等等，那将对你很有帮助，学习如何做到这一点以及如何以这种方式运作的纪律。</p><p class="normal"><a></a><b>Allen:</b> That aspect of mentoring, I don't get very close to these days. What I do do, though, is encourage a young person starting out to not jump into becoming a manager, which is very tempting for people who have a talent in that direction. Get a reputation for technical work. Whether it's a nice piece of science, an algorithm, or writing great code—whatever it is, establish a strong reputation there first. That'll serve you well if you do want to go to managing projects and so forth, to have learned the discipline of what it takes to do that and how to function in that way.</p>
<p class="normal"><b>Seibel：</b>有没有可能有一位技术上不太熟练，但非常善于组织他人努力的伟大经理？</p><p class="normal"><b>Seibel:</b> Is it possible to have a great manager who's actually not very technically skilled, but is very good at organizing the efforts of others?</p>
<p class="normal"><b>艾伦：</b>是的，只要他不认为自己擅长技术，并且能够区分为他工作的人中谁是好人，谁不是。</p><p class="normal"><b>Allen:</b> Yes, as long as he doesn't think he's good at the technology, and is able to distinguish between who is and who isn't in the people that work for him.</p>
<p class="normal"><b>Seibel：</b>这可能是最棘手的事情。对您来说，真正最好的程序员有什么区别？</p><p class="normal"><b>Seibel:</b> That's probably the trickiest thing. For you, what distinguishes the really best programmers?</p>
<p class="normal"><b>艾伦：</b>嗯，我总是喜欢找到可以在我头顶点亮灯泡的人。这对我来说真的很重要，因为我花了很多时间思考系统，所以我希望有人能够（至少在研究领域）向我展示一些新鲜有趣的东西，或者一种看待事物的新方法——一种新的解决问题的方法。</p><p class="normal"><b>Allen:</b> Well, I always like to find the people who can turn a light bulb on over my head. That's really important for me because I spend a lot of time thinking about systems, so I like to have people that will be able, at least in Research, to show me something new and interesting or a new way of looking at something—a new way of solving a problem.</p>
<p class="normal">另外，我依赖于其他人的想法。我错了很多次，当我发现自己对某个人的评价高于团队时，这是一次真正的学习经历。如果你有一个很好的团队，这是一个很好的方法来找出谁做得很好。</p><p class="normal">Also, I rely on what other people think. I've been wrong plenty and it's a real learning experience when I find myself thinking more highly of somebody than the group does. If you have a good group, it's a very good way of sorting out who's doing good work.</p>
<p class="normal"><b>Seibel：</b>你认为你最后一次编程是什么时候？</p><p class="normal"><b>Seibel:</b> When do you think was the last time that you programmed?</p>
<p class="normal"><b>艾伦：</b>哦，那是很久以前的事了。当 C 出来时，我有点停了下来。那是一个很大的打击。我们在优化和转换方面取得了很大进展。我们只是摆脱了一个又一个的好问题。当 C 出现时，在一次 SIGPLAN 编译器会议上，支持 C 的贝尔实验室的 Steve Johnson 和我们的一个人 Bill Harrison 之间发生了一场辩论，他是<a id="OEBPS/Chapter13.html.page_502"></a>从事我当时支持自动优化的项目。</p><p class="normal"><b>Allen:</b> Oh, it was quite a while ago. I kind of stopped when C came out. That was a big blow. We were making so much good progress on optimizations and transformations. We were getting rid of just one nice problem after another. When C came out, at one of the SIGPLAN compiler conferences, there was a debate between Steve Johnson from Bell Labs, who was supporting C, and one of our people, Bill Harrison, who was <a></a>working on a project that I had at that time supporting automatic optimization.</p>
<p class="normal">争论的焦点是史蒂夫辩护说不必再构建优化器，因为程序员会处理它。这确实是程序员的问题。C 设计的动机是他们在高级语言中无法解决的三个问题： 其中之一是中断处理。另一个是调度资源，接管机器并调度队列中的进程。第三个是分配内存。你不能用高级语言做到这一点。所以这就是C的借口。</p><p class="normal">The nubbin of the debate was Steve's defense of not having to build optimizers anymore because the programmer would take care of it. That it was really a programmer's issue. The motivation for the design of C was three problems they couldn't solve in the high-level languages: One of them was interrupt handling. Another was scheduling resources, taking over the machine and scheduling a process that was in the queue. And a third one was allocating memory. And you couldn't do that from a high-level language. So that was the excuse for C.</p>
<p class="normal"><b>Seibel：</b>如果他们将 C 的使用限制在操作系统内核中，您认为 C 是一种合理的语言吗？</p><p class="normal"><b>Seibel:</b> Do you think C is a reasonable language if they had restricted its use to operating-system kernels?</p>
<p class="normal"><b>艾伦：</b>哦，是的。那样就好了。而且，事实上，你需要有这样的东西，专家可以在没有大瓶颈的情况下真正微调的东西，因为这些是需要解决的关键问题。</p><p class="normal"><b>Allen:</b> Oh, yeah. That would have been fine. And, in fact, you need to have something like that, something where experts can really fine-tune without big bottlenecks because those are key problems to solve.</p>
<p class="normal">到 1960 年，我们有一长串令人惊叹的语言：Lisp、APL、Fortran、COBOL、Algol 60。这些比 C 更高级。自从 C 发展以来，我们已经严重倒退了。C 破坏了我们在自动优化、自动并行化、高级语言到机器的自动映射方面推进最先进技术的能力。这是编译器的原因之一。. . 基本上在大学里教的不多了。</p><p class="normal">By 1960, we had a long list of amazing languages: Lisp, APL, Fortran, COBOL, Algol 60. These are higher-level than C. We have seriously regressed, since C developed. C has destroyed our ability to advance the state of the art in automatic optimization, automatic parallelization, automatic mapping of a high-level language to the machine. This is one of the reasons compilers are . . . basically not taught much anymore in the colleges and universities.</p>
<p class="normal"><b>Seibel：</b>当然还有构建编译器的课程？</p><p class="normal"><b>Seibel:</b> Surely there are still courses on building a compiler?</p>
<p class="normal"><b>艾伦：</b>很多学校都没有。令人震惊。仍然有会议在进行，人们在做很好的算法，很好的工作，但在我看来，这样做的回报非常小。因为像 C 这样的语言完全过度指定了问题的解决方案。这些类型的语言正在摧毁计算机科学作为一项研究。</p><p class="normal"><b>Allen:</b> Not in lots of schools. It's shocking. there are still conferences going on, and people doing good algorithms, good work, but the payoff for that is, in my opinion, quite minimal. Because languages like C totally overspecify the solution of problems. Those kinds of languages are what is destroying computer science as a study.</p>
<p class="normal"><b>Seibel：</b>但如今大多数较新的语言都比 C 语言更高级。比如 Java、C#、Python 和 Ruby。</p><p class="normal"><b>Seibel:</b> But most newer languages these days are higher-level than C. Things like Java and C# and Python and Ruby.</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_503"></a><b>艾伦：</b>但他们仍然过度指定。核心是它指定数据的位置。如果你看看这些其他语言，它们不会指定数据的位置以及如何移动它，将它放在机器中的什么地方。在任何时候，它最终都与它的价值有关。</p><p class="normal"><a></a><b>Allen:</b> But they still overspecify. The core thing is that it specifies location of data. If you look at these other languages, they stayed away from specifying the location of data and how to move it, where to put it in the machine. It was ultimately about its value at any point.</p>
<p class="normal"><b>Seibel：</b>但是除了 C 和 C++ 之外，很少有其他语言拥有原始指针。Java 具有垃圾收集功能，数据会四处移动。你会说这仍然是过度指定的吗？</p><p class="normal"><b>Seibel:</b> But very few languages other than C and C++ have raw pointers anymore. Java has garbage collection and the data moves around. Would you say that's still overspecified?</p>
<p class="normal"><b>艾伦：</b>是的。我相信有机会用数据做我们在优化世界中所做的计算。我们没有很好地管理数据。我们没有自动管理数据的好方法——建立将要一起使用的数据的位置。</p><p class="normal"><b>Allen:</b> Yes. I believe that there's an opportunity to do what we have done with computation in the optimization world with data. We don't manage data very well. We don't have good ways of managing data automatically—establishing locality of data that's going to be used together.</p>
<p class="normal">现在有很多研究线索非常令人兴奋。但我认为缺少的是更大、更大胆的概念。很多这样的事情都发生在一个空间内，这个空间受到已经存在的东西或当前想法的限制。它不会以任何方式在一夜之间改变——那里有数百万行代码。但我们确实需要开始尝试打破“这将在这里完成，那将在那里完成”的界限。</p><p class="normal">There are lots of threads of research now which are very exciting. But I think what's missing is the bigger, bolder concepts. A lot of this is happening within a space that is bounded by what exists already or the current thinking. It's not going to change overnight by any means—there are millions of lines of code out there. But we do need to start trying to break the boundaries of, “This'll be done here and that'll be done there.”</p>
<p class="normal"><b>Seibel：</b>您的职业生涯主要是在高性能计算领域。然而，到 2019 年或其他任何时候，我们应该在笔记本电脑中拥有 1,000 个内核。这是否意味着高性能计算和日常计算将合并？还是高性能计算总是会以一种完全不同的方式做事？</p><p class="normal"><b>Seibel:</b> Your career has been largely in high-performance computing. Yet by 2019, or whatever, we're supposed to have 1,000 cores in a notebook computer. Does that mean high-performance computing and everyday computing will merge? Or will high-performance computing always be out there doing things in a sufficiently different way?</p>
<p class="normal"><b>艾伦：</b>嗯，这在某种程度上取决于一个人在体重秤上的位置。要达到 petaflop，这是我们目前在高性能计算方面的目标——我不知道那会怎样。当然，性能游戏将在多核上进行，因为它是由减少能量和许多好东西以及解决一些基本物理问题驱动的。</p><p class="normal"><b>Allen:</b> Well, it kind of depends on where one is on the scale. To go to the petaflop, which is our current goal in high-performance computing—I don't know how that's going to go. Certainly the game in performance is going to be at the multicore because it's driven by reducing energy and lots of good things and solving some problems with the basic physics.</p>
<p class="normal">并且有一个竞争因素会推动它。但是利用这些多核将问题从硬件空间推向了软件空间。据我所知，这就是我们不准备取得任何进展的地方。为了利用这些多核——我认为这是新的语言级别必须介入的地方。我们应该对它进行端到端的研究。但这需要一些非常新的想法。</p><p class="normal">And there's a competitive element that's just going to drive it. But harnessing those multicores pushes the problem out of the hardware space into the software space. And that is where we're not prepared to make any progress as far as I can see. To harness these multicores—I think that's where the new language levels are going to have to break in. We should do an end-to-end look at it. But it's going to take some very new thinking.</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_504"></a>我认为前 50 年——也许是 60 年；ENIAC 在 44 年、43 年——我们不仅建立了一个美妙、惊人的遗产——令人震惊——而且还建立了一些我们需要摆脱的人工制品。更换这些需要很长时间，我认为很难预测它将如何演变。但如果我们能在正确的地方获得一些新的想法，它就会发展得非常快。我们知道如何对很多东西进行计算。我们不知道如何将数据传递给机器中的计算元件。</p><p class="normal"><a></a>I think these first 50 years—60 years maybe; ENIAC was in '44, '43—we've built up not only a wonderful, amazing legacy—just astounding—but also some artifacts that we need to get rid of. It'll take a very long time to replace these and I think it's a little hard to predict how that will evolve. But it'll evolve very fast if we can get some new thinking going in the right places. We know how to do computations on a lot of stuff. We don't know how to deliver the data to the computation elements in the machine.</p>
<p class="normal"><b>Seibel：</b>你能举一个简单的例子来说明你所说的将数据引入计算与我们现在知道如何做的相比是什么意思吗？</p><p class="normal"><b>Seibel:</b> Can you give a simple example of what you mean by bringing the data to the computation in contrast to what we know how to do now?</p>
<p class="normal"><b>艾伦：</b>对我来说，这意味着接管数据的管理，基本上，我们现在的做法是通过引用——它是由硬件或底层操作系统和支持系统移动的。通常引用是在元素级别。</p><p class="normal"><b>Allen:</b> To me it means taking over the management of the data, Basically, how we do it now is by reference—it's moved by hardware, or by the underlying operating systems and support systems. And often the references are at an element level.</p>
<p class="normal"><b>Seibel：</b>你的意思是说你可以有一个指向结构或数组中间的指针？</p><p class="normal"><b>Seibel:</b> You mean in the sense that you can have a pointer into the middle of a struct or an array?</p>
<p class="normal"><b>艾伦：</b>是的，融入其中。根据硬件和架构本身的协议，这带来了它可以用作计算一部分的价值。</p><p class="normal"><b>Allen:</b> Yeah, into an element of it. And that brings, depending on the protocols of the hardware and of the architecture itself, the value to where it can be used as part of the computation.</p>
<p class="normal">但另一种方法是将数据的位置组织在它们的相对位置作为优化目标。另一部分是，通常对一种计算有利的东西对另一种计算不利。一个组织，即使是像矩阵这样的简单事物，当您实际以不同的方式访问它时，它也是糟糕的。所以它是访问顺序与位置的组合。它可能需要一些架构工作和硬件工作，但我认为，如果我们将一些引用、寻址功能放回到硬件本身中，就可以做到这一点。有些机器有能力在数据进入内存时进行大量转换。映射可以在那里发生。</p><p class="normal">But another way to do that would be to organize locations of data in their relative positions as a target of optimization. The other part of it is that very often what is good for one computation is poor for another. One organization, even of simple things like matrices, is bad when you're actually accessing it in a different way. So it's a combination of the order of the accessing against the location. It may require some architectural work, and hardware work, but I think that one can do this if we put some of the referencing, addressing capabilities back out in the hardware itself. There are machines where one has the ability, at the point data comes into the memory, to do quite a lot of transformations. Mapping can happen there.</p>
<p class="normal">计算速度是我们在高性能计算中主要衡量的指标，因此我们通过各种方式来提高速度。为该计算单元提供数据是我们面临的大问题之一，但我们从未将其作为要解决的一阶问题。我们把它留给硬件。</p><p class="normal">Computation speed is what we measure, mostly, in high-performance computing so we go through all kinds of things to increase that speed. Feeding that computational unit is one of the big issues that we face, but we never made it a first-order problem to solve. We leave it to the hardware.</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_505"></a><b>Seibel：</b>在你的图灵奖演讲中，你说过这样的话：“我们正处于十字路口，我们可能会错过它。我们可能会走错路，然后沿着这条路走很长一段时间。”</p><p class="normal"><a></a><b>Seibel:</b> In your Turing Award lecture you said something along the lines of, “We're at a crossroads here and we might miss it. We might go down the wrong path and then be going down it for quite a while.”</p>
<p class="normal"><b>艾伦：</b>是的。</p><p class="normal"><b>Allen:</b> Yeah.</p>
<p class="normal"><b>Seibel：</b>那么在您看来，正确的道路是回到自动并行化中的那种工作吗？</p><p class="normal"><b>Seibel:</b> So the right path, in your view, is getting back to that kind of work in automatic parallelization?</p>
<p class="normal"><b>艾伦：</b>是的，但它必须针对比我们现在拥有的更高级的语言来完成。</p><p class="normal"><b>Allen:</b> Right, but it has to be done against a higher-level language than we have now.</p>
<p class="normal"><b>Seibel：</b>错误的道路是为人们寻找更好的方式来明确地表达平行性吗？</p><p class="normal"><b>Seibel:</b> And the wrong path is finding better ways for people to express parallelism explicitly?</p>
<p class="normal"><b>艾伦：</b>好吧，我认为我们最终会意识到我们制造的混乱比过去更多。但是我们确实需要更高级别的语言，当然还有特定领域的语言，以及开发事物的方法，这真的非常棒。</p><p class="normal"><b>Allen:</b> Well, I think we would eventually realize that we've created more of a mess than we had. But we do need higher-level languages and there certainly are domain-specific languages, and ways of developing things, which are really quite wonderful.</p>
<p class="normal">但我们必须乐于尝试并利用这一点，同时还要利用系统集成和数据来自各处的事实。它不再封装在程序、代码中。我认为，我们现在看到的是大量可访问的数据。它是数字数据以及信息类型的数据，并将存储在全球各地，特别是如果您从事某些生物信息学方面的工作。我们必须能够创建一个平台，它可能由很多部分组成，它将使这些东西能够聚集在一起——计算能力可能与我们现在拥有的完全不同。而且我们迟早也需要解决这些系统的可用性和完整性问题。</p><p class="normal">But we have to be willing to try and take advantage of that, but also take advantage of the integration of systems and the fact that data's coming from everywhere. It's no longer encapsulated with the program, the code. We're seeing now, I think, vast amounts of data, which is accessible. And it's numeric data as well as the informational kinds of data, and will be stored all over the globe, especially if you're working in some of the bioinformatics kind of stuff. And we have to be able to create a platform, probably composed of a lot of parts, which is going to enable those things to come together—computational capability that is probably quite different than we have now. And we also need to, sooner or later, address usability and integrity of these systems.</p>
<p class="normal"><b>Seibel：</b>从程序员的角度来看可用性，还是这些系统的最终用户的可用性？</p><p class="normal"><b>Seibel:</b> Usability from the point of the programmer, or usability for the end users of these systems?</p>
<p class="normal"><b>艾伦：</b>这些系统的最终用户。这是一种资源，一种巨大的资源。以及系统正确性的完整性。几年前，我在 NSA 的风险管理项目上工作，我突然意识到，在高性能计算中，我们通常不需要<a id="OEBPS/Chapter13.html.page_506"></a>计算到我们拥有的准确度。我们不需要所有数据就能在解决方案上取得进展。因此，我认为在数据方面正在进行一些不错的工作，并提供足够好的答案。我看到这些多核——它们是一个很好的机会——回过头来重新审视很多东西。</p><p class="normal"><b>Allen:</b> Of the end users of these systems. It's a resource, a giant resource. And the integrity of the correctness of the systems. I worked on project for the NSA on risk management, quite a few years ago, and it suddenly dawned on me that we often, in high-performance computing, do not need to <a></a>compute to the accuracy that we have. We do not need all the data to be able to make progress on a solution. And so there's some nice work going on in the data side, I think, with accommodating good enough answers. I see these multicores—they're a wonderful opportunity—to go back and to take another look at lots of things.</p>
<p class="normal"><b>Seibel：</b>你认为自己是科学家、工程师、艺术家还是工匠？</p><p class="normal"><b>Seibel:</b> Do you think of yourself as a scientist, an engineer, an artist, or a craftsman?</p>
<p class="normal"><b>艾伦：</b>我认为自己是一名计算机科学家。我参与了我所在领域的一角，帮助它发展。那是一个有趣的时代——计算机科学的出现——因为有很多关于“这是一门科学吗？任何必须以<i>科学</i>命名的东西都不是科学。” 我当然不清楚这意味着什么。</p><p class="normal"><b>Allen:</b> I think of myself as a computer scientist. I was involved in my corner of the field in helping it develop. And those were interesting times—the emergence of computer science—because there was a lot of question about, “Is this a science? Anything that has to have <i>science</i> in its name isn't a science.” And it was certainly unclear to me what it meant.</p>
<p class="normal">但编译器是一个非常古老的领域——比操作系统还古老。有一天我真的要查一查。<i>编译器</i>这个词实际上来自嵌入要执行的小指令片段。就像机器用非常原始的术语拼写出 add 一样。如果你想做一个添加，那么它会去它定义的库并展开它。</p><p class="normal">But compilers were a very old field—older than operating systems. Some day want I to really look it up. The word <i>compiler</i> comes actually from the embedding of little snippets of instructions to execute. Like an add would be spelled out in very primitive terms for the machine. If you want to do an add, then it would go to its library that defined that and expand it.</p>
<p class="normal">但是汇编器也在使用符号。我不确定这是否准确，但我曾经相信，最早对变量名称使用符号的是一个名叫 Nat Rochester 的人，他在一台非常早期的 IBM 机器上，即 1951 年左右的 701。他负责测试它，他们编写程序来测试机器。在这样做的过程中，他们引入了符号变量。现在，我已经看到了一些其他的东西，因为这让我相信有更早的方式来象征性地表示信息。我认为它出现在 50 年代初期，甚至可能出现在 40 年代。一方面，人们必须回头看看 ENIAC 中究竟是如何表达事物的。</p><p class="normal">But assemblers were also using symbolics. I'm not sure this is accurate, but I used to believe that the first early use of symbolics for names of variables came from a man named Nat Rochester, on a very early IBM machine, the 701 around 1951. He was in charge of testing it and they wrote programs to test the machine. In the process of doing that, they introduced symbolic variables. Now, I've seen some other things since that make me believe that there were earlier ways of representing information symbolically. It emerged in the early '50s, I think, or maybe even in the '40s. One would have to go back and see exactly how things were expressed in the ENIAC, for one thing.</p>
<p class="normal"><b>Seibel：</b>所以在某个时候，你意识到你已经成为一名计算机科学家，开发关于编译器优化等的理论。但是您最初是一名程序员，受雇编写代码。到 PTRAN 项目时，您正在管理一个实际编写软件的团队。你为什么要做那个开关？</p><p class="normal"><b>Seibel:</b> So somewhere along the line, you realized you had become a computer scientist, developing theories about compiler optimization and so forth. But you started out as a programmer, hired to write code. By the time of the PTRAN project you were managing a team of people who were actually writing the software. Why did you make that switch?</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_507"></a><b>艾伦：</b>嗯，可能有两个原因——第一，我不是一个很好的程序员。我往往会犯很多错误——不像当时的传统观点认为女性是优秀的程序员，因为她们注重细节。我不属于那个类别。所以我倾向于对把所有的细节都弄好不感兴趣，我更感兴趣的是系统的工作方式。</p><p class="normal"><a></a><b>Allen:</b> Well, probably two reasons—one, I wasn't a very good programmer. I tended to make quite a few mistakes—unlike the conventional wisdom at the time that said that women make good programmers because they pay attention to details. I didn't fit that category. So I tended to be kind of disinterested in getting all the details right and I was much more interested in the way systems work.</p>
<p class="normal">我对数学的兴趣非常抽象。如果我有足够的钱继续攻读博士学位，我就会成为一名几何学家。我喜欢那个过程的严谨性。这是我真正最喜欢的事情，通过系统来解决问题——通过工程类的事情来解决问题，而不必知道成为一名工程师需要知道的细节，这是一个完全不同的领域。</p><p class="normal">My interest in mathematics was very abstract. If I had had enough money to go on to get a PhD, I would have become a geometer. I loved the rigor of that process. That's what I really most enjoy, puzzling through systems—puzzling through the engineering kinds of things without necessarily knowing the details of what one would need to know to be an engineer, which is quite a different area.</p>
<p class="normal"><b>Seibel：</b>你为 PTRAN 项目做出技术贡献的方式，听起来你对整个项目的运作方式有着宏伟的架构图，并且可以指出不清楚它们将如何运作的部分。</p><p class="normal"><b>Seibel:</b> The way you contributed technically to the PTRAN project, it sounds like you had the big architectural picture of how the whole thing was going to work and could point out the bits that it wasn't clear how they were going to work.</p>
<p class="normal"><b>艾伦：</b>对。</p><p class="normal"><b>Allen:</b> Right.</p>
<p class="normal"><b>Seibel：</b>你认为这种能力是你早年就有的，还是随着时间的推移而发展起来的？</p><p class="normal"><b>Seibel:</b> Do you think that ability was something that you had early on, or did that develop over time?</p>
<p class="normal"><b>艾伦：</b>我认为部分原因是在农场长大。如果你看看我们这个领域发生的许多有趣的工程事情——在这个时代或更早的时候——其中很多都来自农场的孩子。我从我在国家工程院共事的一些人那里偶然发现了这一点——这些年长的人中有一大群来自中西部的农场。他们积极参与设计火箭和其他非常工程化、系统化和实际操作的事情。我认为参与农场和自然，我对如何修复事物以及事物如何运作产生了极大的兴趣？</p><p class="normal"><b>Allen:</b> I think it came partially out of growing up on a farm. If one looks at a lot of the interesting engineering things that happened in our field—in this era or a little earlier—an awful lot of them come from farm kids. I stumbled on this from some of the people that I worked with in the National Academy of Engineering—a whole bunch of these older men came from Midwestern farms. And they got very involved with designing rockets and other very engineering and systemy and hands-on kinds of things. I think that being involved with farms and nature, I had a great interest in, how does one fix things and how do things work?</p>
<p class="normal"><b>Seibel：</b>农场是一个投入和产出的大系统。</p><p class="normal"><b>Seibel:</b> And a farm is a big system of inputs and outputs.</p>
<p class="normal"><b>艾伦：</b>对。因为它非常接近自然，它有自己的循环，自己的系统，你无能为力。因此，人们在其中找到了一个位置，这是一个非常舒适的位置。</p><p class="normal"><b>Allen:</b> Right. And since it's very close to nature, it has its own cycles, its own system that you can do nothing about. So one finds a place in it, and it's a very comfortable one.</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_508"></a><b>Seibel：</b>您之前提到过，当您从事 Stretch 编译器的工作时，领导编译器工作的四个人中有三个是女性。你能谈谈这是怎么发生的吗？</p><p class="normal"><a></a><b>Seibel:</b> You mentioned earlier that when you were working on the Stretch compiler, that three of the four people leading the compiler effort were women. Can you talk about how that came about?</p>
<p class="normal"><b>艾伦：</b>那是在 59 年，大概是这样。当时女性作为程序员发挥着重要作用。在这方面，IBM 一直是一家非常非常棒的公司。我最近看了一些历史，IBM 的多元化政策可以追溯到 1899 年，而且始终如一，在所有这些时期都没有太多关注这一点——非常明确的政策。</p><p class="normal"><b>Allen:</b> This was in '59, something like that. Women were playing a big role at that time as programmers. And IBM has always been a great, great company on that. I saw some history recently, that IBM's diversity policies go back to 1899, just consistently, all through these periods when there wasn't much attention being paid to that—very explicit policies.</p>
<p class="normal"><b>Seibel：</b>您是否认为该项目中的女性人数是由于明确的管理政策——他们说 IBM 应该雇用更多女性？</p><p class="normal"><b>Seibel:</b> Do you think the number of women on that project was due to explicit management policies—that they were saying IBM should hire more women?</p>
<p class="normal"><b>艾伦：</b>我不认为他们说，“我们必须雇用更多的女性。” 他们只雇用有资格的人，而不仅仅是女性。对于非裔美国人来说，那段日子真的很艰难，而 IBM 真的挺身而出。一个不太为人所知的故事是，当时在 Poughkeepsie 有针对黑人的隔离住房，而 IBM 改变了它。</p><p class="normal"><b>Allen:</b> I don't think they said, “We must hire more women.” They just hired whoever was qualified, and it wasn't just women. These were really hard times for African-Americans, and IBM really stepped out. One story that's not very well known is there was segregated housing in Poughkeepsie at that time, regarding blacks, and IBM got it changed.</p>
<p class="normal"><b>Seibel：</b>你曾在一次采访中讲过一个故事，讲的是你有一次参加一个会议。他们看着你说，“弗兰·艾伦？”</p><p class="normal"><b>Seibel:</b> You told a story in an interview once about one time you arrived at a conference. And they looked at you and said, “Fran Allen?”</p>
<p class="normal"><b>艾伦：</b> “你是个女人。”</p><p class="normal"><b>Allen:</b> “You're a woman.”</p>
<p class="normal"><b>Seibel：</b> “我们让你和 Gene Amdahl 住在一起。”</p><p class="normal"><b>Seibel:</b> “We have you rooming with Gene Amdahl.”</p>
<p class="normal"><b>艾伦：</b>哦，是的，那个。这是一次 IBM 会议，当时我们将这里正在进行的 System Y 项目转移到西海岸进行产品开发，并将其重命名为 ACS。我们在河对岸的哈里曼庄园举行了一次大型会议。除了一两个例外，全部都是 IBM 员工。有一个来自西海岸的人负责组织它，他不认识我们任何人。他是按字母顺序做的。</p><p class="normal"><b>Allen:</b> Oh, yes, that one. This was an IBM conference, when we were moving the System Y project that was going on here to the West Coast into product development and had renamed it ACS. We had a big conference at the Harriman Estate across the river. It was all, with one or two exceptions, IBM people. There was a person from the West Coast who was charged with organizing it and he didn't know any of us. He'd done it alphabetically.</p>
<p class="normal"><b>Seibel：</b>所以他们把你整理出来，给你自己找了一个房间？</p><p class="normal"><b>Seibel:</b> So they sorted you out and found you a room by yourself?</p>
<p class="normal"><b>艾伦：</b>是的，阁楼上的女佣房间。</p><p class="normal"><b>Allen:</b> Yeah, a maid's room up in the garret.</p>
<p class="normal"><b>Seibel：</b>你是在 Fran 还是 Frances 的领导下发表论文的？</p><p class="normal"><b>Seibel:</b> Did you publish papers under Fran or Frances?</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_509"></a><b>艾伦：</b> FE艾伦。我不记得我为什么那样做。我认为至少在当时，只使用名字首字母是相当普遍的。</p><p class="normal"><a></a><b>Allen:</b> F.E. Allen. And I don't recall why I did that. I think it was fairly common, at the time at least, to just use first initials.</p>
<p class="normal"><b>Seibel：</b>你之前也提到过，当你开始的时候，人们认为女性会是优秀的程序员，因为女性被认为是注重细节的。如今，传统观点认为，男性具有专注于事物的怪异能力，通常会损害其他一切，这就是为什么大多数程序员都是男性的原因。</p><p class="normal"><b>Seibel:</b> You also mentioned before that when you started, people thought women would be good programmers because women were thought to be detail-oriented. These days the conventional wisdom is that it's men who have a bizarre ability to focus on things, usually to the detriment of everything else, and that's why most programmers are men.</p>
<p class="normal"><b>艾伦：</b>对。</p><p class="normal"><b>Allen:</b> Right.</p>
<p class="normal"><b>Seibel：</b>你一定已经观察到人们在这些方面的态度发生了很多转变。</p><p class="normal"><b>Seibel:</b> You must have observed many shifts in attitudes along those lines.</p>
<p class="normal"><b>艾伦：</b>好吧，今天他们不会说伟大的程序员，但他们在团队中表现出色，因为他们喜欢协作。它转向女性合作，她们合作得很好。所以这就是今天对早期假设的类比，即女性非常注重细节。</p><p class="normal"><b>Allen:</b> Well, today they wouldn't say great programmers, but they're great on teams because they like to collaborate. It shifted to women collaborate and they work together well. So that's today's analog of that earlier assumption that women were quite detail-oriented.</p>
<p class="normal"><b>Seibel：</b>尽管 Stretch 编译器小组中有很多女性，但在您的职业生涯中，您一定也有过几乎完全与男性一起工作的时候。在一个有很多女性的团队中工作是一种不同的体验吗？</p><p class="normal"><b>Seibel:</b> Despite the number of women in that Stretch compiler group, you must have also have had times in your career when you were working almost entirely with men. Was it a different kind of experience working in a group with lots of women?</p>
<p class="normal"><b>艾伦：</b>是的。我认为是的，但不仅是很多女性——我的很多同龄人都是真正的同龄人，因为在我被录用时正在进行大规模招聘，因为她们大多都是同龄人。我们的年龄几乎相同，背景也几乎相同。所以这是一个非常合议的小组。而且，整个地区都很新——很多东西都是未知的。我们不知道我们不知道什么，但我们周围并不是有很多人有多年的经验或知道的更多。</p><p class="normal"><b>Allen:</b> Yes. I think it was, but it was not only lots of women—a lot of my peers were truly peers in the sense that they were mostly all the same age because of this big hiring that was going on at the point I was hired. We were pretty much all the same age and pretty much of the same background. So it was a very collegial group. And also, the whole area was so new—so much was unknown. We didn't know what we didn't know, but it wasn't as if there were a lot of people around us that had years of experience or knew a whole lot more.</p>
<p class="normal"><b>Seibel：</b>所以发生了什么事？这个领域不再是女性；那是什么时候改变的？</p><p class="normal"><b>Seibel:</b> So what happened? The field is not full of women anymore; when did that change?</p>
<p class="normal"><b>艾伦：</b>我花了好几年时间才确定原因。它发生在 60 年代后期，至少在我所处的环境中是这样。我离开研究中心参与 ACS 项目并去了加利福尼亚。然后我回到<a id="OEBPS/Chapter13.html.page_510"></a>研究部门，发现它与我八年前离开的环境截然不同。</p><p class="normal"><b>Allen:</b> It took me quite a few years to identify the cause. It happened in the late '60s, at least in the environments that I was in. I had left Research to be involved with the ACS project and went to California. Then I came back to <a></a>the Research division and found it a very, very different environment than the one I had left essentially eight years earlier.</p>
<p class="normal">有一个重要的玻璃天花板。有适当的流程，管理线。管理结构发生了变化，决策也变得更加正式，尤其是关于做什么项目和如何做的决策。女性人数发生了变化，女性在组织中的地位也发生了显着变化，而且不是为了好。显然，我对此并不高兴。</p><p class="normal">There was a significant glass ceiling. There were processes in place, lines of management. And the management structures had changed and decision-making had become much more formal, particularly about what projects to do and how to do them. And the number of women had changed and the position of women in the organization had significantly changed, and not for the good. And I was not happy about it, obviously.</p>
<p class="normal">在 1970 年、71 年、72 年，我进入了一个充满乐趣和机会的职业生涯 19 年或 18 年。我从未认为自己在进步，但我觉得我可以自由地做我认为正确的事情，并以我喜欢的角色从事有趣的事情。我回来后发现情况并非如此。</p><p class="normal">In 1970, '71, '72, I was 19 years or 18 years into a career that was just full of fun and opportunity. I never saw myself as advancing, but I felt I had the freedom to do what I felt was right and to work on interesting things in roles that I would enjoy. And I came back and found out that wasn't the case.</p>
<p class="normal"><b>Seibel：</b>你认为玻璃天花板实际上以前就存在过，而你还没有碰到它吗？或者发生了什么变化？</p><p class="normal"><b>Seibel:</b> Do you think that glass ceiling had, in fact, been there before and you hadn't bumped up against it yet? Or had something changed?</p>
<p class="normal"><b>艾伦：</b>以前真的没有。最近我意识到这可能是根本原因：计算机科学是在 1960 年到 1970 年间出现的。而且它主要来自工程学院；其中一些来自数学。</p><p class="normal"><b>Allen:</b> It really hadn't been there previously. Recently I realized what was probably the root cause of this: computer science had emerged between 1960 and 1970. And it mostly came out of the engineering schools; some of it came from mathematics.</p>
<p class="normal">那个时期的工程学校大多都是男性。IBM 招聘的人员必须满足特定要求：拥有特定学位并参加过特定的计算机科学课程。所以他们几乎都是男人，因为他们是满足要求的人——因为现在这是一门学科。另一件似乎已经发生的事情是，它是一种职业——有很多流程和管理链来实施这些流程并保持一切顺利运行。所以这是一个非常不同的地方。</p><p class="normal">And the engineering schools were mostly all men in that period. And the people IBM was hiring had to meet certain requirements: have certain degrees and have taken certain courses in computer science. And so they were almost all men because they were the ones that satisfied the requirements—because it was a discipline now. The other thing that seemed to have happened is that it was a profession—there were a lot of processes in place and chains of management that implemented the processes and kept everything running smoothly. So it was a very different place.</p>
<p class="normal"><b>Seibel：</b>我很确定整个社会的性别歧视在 50 年代和 60 年代非常猖獗。然而在那个时期，你在有很多女性的团队中工作。为什么当时对女性如此开放？</p><p class="normal"><b>Seibel:</b> I'm pretty sure sexism in society at large was pretty rampant in the '50s and '60s. Yet in that period you were working in groups that had lots of women in them. Why was it so open to women then?</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_511"></a><b>艾伦：</b>软件是正在发生的最新事物。直到今天，它也可能仍然被认为是科学的一个软部分。这就是女性被吸引的地方。早期他们是 ENIAC 和 Bletchley Park 的程序员。女人就是电脑——这是她们的名字。但在工程和物理学以及更难、更古老的科学领域，女性人数并不多。很早以前，它就是这样划分的。</p><p class="normal"><a></a><b>Allen:</b> Software was the newest-of-the-new stuff that was going on. And it's also probably still to this day considered a soft part of the science. And that's where women gravitated. Early on they were programmers on ENIAC and at Bletchley Park. Women were the computers—that was their name. But in engineering and physics and the harder, older sciences there weren't as many women. It was just divided that way, early on.</p>
<p class="normal">然后女性开始从工程学校走出来。现在工程专业的女性本科生比例约为 20%。卡内基梅隆大学会比这高得多——他们付出了特别的努力。但在计算机科学领域，它基本上是 8%。就数字而言，目前没有哪个领域比计算机科学对女性更糟糕。“坏”这个词用错了——它很低。</p><p class="normal">Then women started to come out of the engineering schools. Now the undergraduate percentage of women in engineering is somewhere around 20 percent. Carnegie Mellon would be much higher than that—they have made a special effort. But in computer science, it's essentially 8 percent. There's no domain that is as bad as computer science for women right now in terms of numbers. “Bad” is the wrong word—it's low.</p>
<p class="normal"><b>Seibel：唱反调</b>，我们能否实现，比如说，Anita Borg 的“到 2020 年 50/50”的目标，即到 2020 年计算机科学领域的女性比例达到 50%，这有什么关系？为什么这一特定领域是否能代表广大人口很重要？</p><p class="normal"><b>Seibel:</b> To play devil's advocate, why does it matter whether we achieve, say, Anita Borg's goal of “50/50 by 2020,” meaning 50 percent women in computer science by the year 2020? Why does it matter whether this one particular field be representative of the population at large?</p>
<p class="normal"><b>艾伦：</b>对于整个社会来说，这是一个变革性的领域。如果没有不同群体的参与，我们所做的事情的结果将不会对我们社会的各个方面都具有吸引力或有用。我们面临的挑战之一是让每个人都可以使用计算及其支持的一切。那是一个理想。但这确实是它的发展方向——麻省理工学院在 100 美元计算机上的工作，以及我们试图通过计算在不发达国家的偏远地区实现非常低水平的商业的方式。</p><p class="normal"><b>Allen:</b> It's such a transformative field for society as a whole. And without the involvement of a diverse group of people, the results of what we do are not going to be appealing or useful to all aspects of our society. A piece of our challenge is to make computing, and all that it enables, accessible to everyone. That's an ideal. But it's really where it's going—the work at MIT on the $100 computer and the way we're trying to enable commerce at a very low level through computing in the remote areas of underdeveloped countries.</p>
<p class="normal"><b>Seibel：</b>很明显，你离最终用户越近，就越容易想象具有不同经验的人会对这些用户可能喜欢如何与计算机交互提出不同的想法。再次扮演唱反调的角色，如果有人说：“当我们谈论设计应用程序时，这一切都很好，但当你设计编译器优化时，谁会关心观点的多样性？”你会怎么说？即使您从事软件的极端技术方面的工作（例如优化编译器），拥有多元化的员工仍然有价值吗？</p><p class="normal"><b>Seibel:</b> So clearly the closer you get to the end user, the easier it is to imagine that people with diverse experiences are going to bring different ideas about how those users might like to interact with a computer. Again playing devil's advocate, what do you say to someone who says, “That's all well and good when we're talking about designing applications, but when you're designing compiler optimizations, who cares about a diversity of point of view?” Is it still valuable to have a diverse staff even when you're working on extremely technical aspects of software, like optimizing compilers?</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_512"></a><b>艾伦：</b>是的。事实上，这是 PTRAN 组的关键之一。许多女性被这个团体所吸引，部分原因是那里已经有其他女性了。但这也使该小组成为一个非常融洽的小组。这是因为混合——不是因为那里有女人，而是因为混合。这些人来自这里的其他组织，也有其他教育背景。</p><p class="normal"><a></a><b>Allen:</b> Yes. In fact, that was one of the keys to the PTRAN group. A lot of women were attracted to the group, partly because there were other women there already. But it also made the group a very congenial group. And it was because of the mix—it wasn't because there were women there, but because of the mix. These people came from other organizations here, but also other educational backgrounds.</p>
<p class="normal">我有来自纽约大学（Courant Institute）的人，他们有自己做事的思考方式，因为他们来自同一所研究生院。然后我有几个来自麻省理工学院的人。尤其是一位女性，她非常注重理论，并且是一位非常出色的思想家，但方式不同。伊利诺斯人有一些不同的特点。因此，即使排除性别差异或其他文化差异，他们来自这些不同地方的事实本身也提供了一个更强大的群体。</p><p class="normal">I had people that came in from NYU—the Courant Institute—who had their own way of thinking about doing things because they'd come through the same graduate school. And then I had a couple people from MIT. One in particular—a woman—was on the very theoretical side and a very wonderful thinker in a different way. The Illinois people had some different characteristics. So even taking out the gender differences or other cultural differences, the fact that they came from these different places provided, in and of itself, a much stronger group.</p>
<p class="normal"><b>Seibel：</b>我想如果我们达到本科计算机科学按性别划分 50/50 的地步，如果每个人都在攻读相同类型的 CS 学位，我们实际上可能会失去一些经验多样性。</p><p class="normal"><b>Seibel:</b> I suppose if we get to the point where undergraduate computer science is split 50/50 by gender we could actually lose some of that experiential diversity, if everyone is going through the same sort of CS degree.</p>
<p class="normal"><b>艾伦：</b>是什么让一些新毕业生对 IBM 非常有吸引力，因为他们不会停留在一个学科中。他们从一门学科转向另一门学科。它们可以是技术性很强但又非常多样化的学科。通常它是有目的的——一个人决定他们想要连接一些大的领域。我和一些这样的人谈过——他们看到了语言学工作和计算工作之间的联系。作为雇员，他们非常有吸引力。</p><p class="normal"><b>Allen:</b> What makes some of the new graduates very appealing to, say, IBM, is that they're not staying in one discipline. They move from one discipline to another. And they can be deeply technical but very diverse disciplines. Often it's done purposefully—a person decides that they want to connect some big fields. I've talked to some people like that—they see a connection between working in linguistics and working in computing. They're very appealing as an employee.</p>
<p class="normal"><b>Seibel：</b>那么您对“2020 年 50/50”项目有何看法？</p><p class="normal"><b>Seibel:</b> So how are you feeling about the “50/50 by 2020” project?</p>
<p class="normal"><b>艾伦：</b>对此非常沮丧。</p><p class="normal"><b>Allen:</b> Pretty discouraged about it.</p>
<p class="normal"><b>Seibel：</b>为实现该目标应采取哪些步骤？初中数学教育需要改变吗？据我了解，这就是很多女孩放弃数学和科学的原因——在此之前，女孩们仍然热爱数学。</p><p class="normal"><b>Seibel:</b> What are the steps that should be taken to get to that goal? Do you need to change math education in junior high school? As I understand it, that's where a lot of girls drop out of math and science—before that girls still love math.</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_513"></a><b>艾伦：</b>这是一个普遍的看法，但我不相信。看看西屋公司的比赛。女人正在赢得那些。在工程领域有很多女性——在高中学习所有艰难的科学和数学。在我位于纽约克罗顿的小高中，我们有一位来自西屋的人在全国排名第五。他们有一个很好的科学项目。今年的七位高层人士中有六位是女性，他们在个人科学领域做出了惊人的贡献。</p><p class="normal"><a></a><b>Allen:</b> That's been a popular belief, but I don't believe it. Look at the Westinghouse competitions. Women are winning those. And there are a lot of women in engineering—taking all the tough sciences and mathematics in high schools. At my little high school in Croton, New York, we had a Westinghouse person nationally come in fifth. And they have a nice science program. Six of the seven people in it this year at the senior level are women doing amazing pieces of individual science.</p>
<p class="normal">这些女性正在发生的事情是她们正在进入与社会相关的领域。计算机科学可能与社会极为相关，但它们正在进入地球科学、生物科学和医学领域。医学很快就会达到 50/50。许多领域都与该理论相悖，但我们没有。</p><p class="normal">What's happening with those women is that they're going into socially relevant fields. Computer science could be extremely socially relevant, but they're going into earth sciences, biological sciences, medicine. Medicine is going to be 50/50 very soon. A lot of fields have belied that theory, but we haven't.</p>
<p class="normal"><b>Seibel：</b>那么，计算机科学有什么不吸引人的地方呢？</p><p class="normal"><b>Seibel:</b> What is it, then, about computer science that is so unappealing?</p>
<p class="normal"><b>艾伦：</b>很多人认为这是整天坐在电脑前的游戏和书呆子。这些新的在线社交网络将如何产生影响将会很有趣。我不知道。但我觉得这是我们要解决的问题。这不是告诉教育工作者改变他们的培训；我们在该领域必须使其更具吸引力。</p><p class="normal"><b>Allen:</b> A lot of people think it's the games and the nerdiness of sitting in front of a computer all day. It's going to be interesting how these new social networks online will have an effect. I don't know. But I feel it's our problem to solve. It's not telling the educators to change their training; we in the field have to make it more appealing.</p>
<p class="normal">我们必须赋予该领域一个身份，使其比它现在似乎拥有的身份更进一步——一个更人性化的身份。我们还没有阐明为什么我们喜欢这个领域，它有什么令人兴奋的地方，未来有什么令人兴奋的地方，以及为什么它是一个伟大的领域。</p><p class="normal">We have to give the field an identity that expands it further than the identity it seems to have now—a much more human identity. We haven't articulated why we like this field and what's exciting about it and what's exciting about the future and why it's a great field to be in.</p>
<p class="normal"><b>Seibel：</b>那你为什么喜欢它？</p><p class="normal"><b>Seibel:</b> So why do you like it?</p>
<p class="normal"><b>艾伦：</b>部分原因是每天都有可能产生新想法。一个人看到了什么，然后说，“哦，那是新的。” 整个领域的刷新频率非常高。想想所有这一切的潜力及其可能产生的影响是非常令人兴奋的。</p><p class="normal"><b>Allen:</b> Part of it is that there's the potential for new ideas every day. One sees something, and says, “Oh, that's new.” The whole field gets refreshed very frequently. It's very exciting to think about what the potential for all of this is and the impacts it can have.</p>
<p class="normal">艾萨克·阿西莫夫 (Isaac Asimov) 就计算机的未来发表了一个声明——我不知道这对不对——它们所做的就是让我们每个人都更有创造力。计算将开启创造力的时代。人们看到其中一些正在发生——尤其是在媒体上。孩子们正在做他们以前不能做的事情——制作电影、创作图片。我们倾向于<a id="OEBPS/Chapter13.html.page_514"></a>将创造力视为一个人拥有的特殊天赋，就像能够读写是黑暗时代的特殊天赋一样——只有少数人能够做到。我发现计算机是创造力的推动者这一想法非常鼓舞人心。</p><p class="normal">Isaac Asimov made a statement about the future of computers—I don't know whether it's right or not—that what they'll do is make every one of us much more creative. Computing would launch the age of creativity. One sees some of that happening—particularly in media. Kids are doing things they weren't able to do before—make movies, create pictures. We tend to <a></a>think of creativity as a special gift that a person has, just as being able to read and write were special gifts in the Dark Ages—things only a few people were able to do. I found the idea that computers are the enablers of creativity very inspiring.</p>
<p class="normal"><b>Seibel：</b>您是许多类别中的第一位女性——第一位图灵奖获得者，第一位 IBM 院士。你觉得在你之前有被忽视的女性吗？</p><p class="normal"><b>Seibel:</b> You have been the first woman in many categories—first Turing Award winner, first IBM Fellow. Do you feel like there were women before you who were overlooked?</p>
<p class="normal"><b>艾伦：</b>哦，是的，当然。</p><p class="normal"><b>Allen:</b> Oh, yes, absolutely.</p>
<p class="normal"><b>Seibel：</b>所以当你赢得图灵奖时，你有没有想过，“哎呀，早就应该有另一个女人赢得这个奖了？”</p><p class="normal"><b>Seibel:</b> So when you won the Turing, did you think to yourself, “Gee, there's another woman who should have won this a long time ago?”</p>
<p class="normal"><b>艾伦：</b>嗯，我首先想到的是它有多棒。然后我开始想到所有其他许多女性，她们的工作从未得到认可。在许多情况下，他们的作品被盗。我想到了那些做了一些非常了不起的事情却没有被认可的女性，即使是她们的同龄人。当我接近他们说，“你需要加入一些专业组织——我会为你写一些建议，”他们有点回避。</p><p class="normal"><b>Allen:</b> Well, the very first thing I thought about was how wonderful it was. And then I started to think about all the many other women who were never recognized at all for their work. In many cases, their work was stolen. I thought about the women who had done some very amazing things that have not been recognized, even by their peers. When I approach them and say, “You need to join some professional organizations—I'll write some recommendations for you,” they kind of shy away from that.</p>
<p class="normal"><b>Seibel：</b>所以你认为部分问题是他们没有得到认可，因为他们没有把自己放在一个容易被认可的地方。</p><p class="normal"><b>Seibel:</b> So you think that part of the problem is they don't get recognized because they're not putting themselves in a place to be recognized as easily.</p>
<p class="normal"><b>艾伦：</b>对。</p><p class="normal"><b>Allen:</b> Right.</p>
<p class="normal"><b>Seibel：</b>有没有什么特别的人你想说出来——现在给予一点认可？</p><p class="normal"><b>Seibel:</b> Are there any particular folks that you would like to name—to give a little recognition now?</p>
<p class="normal"><b>艾伦：</b>好吧，还有伊迪丝·勋伯格，她是一位伟大的计算机科学家。在技​​术工作方面，她的一些论文只是一个接一个。她的作品被盗了——绝对是残忍的盗窃。她写了一篇关于调试并行代码的论文，这是一个非常难的问题。它没有在会议上被接受，并且曾在计划委员会工作的人从中发表了三篇论文。那种事。它发生在我们的领域，我们没有很好的方法来处理它。</p><p class="normal"><b>Allen:</b> Well, there's Edith Schonberg, who is a great computer scientist. In terms of technical work, it's just one first after another on some of her papers. She's had work stolen—absolutely brutally stolen. She wrote a paper on debugging of parallel code, which is a very hard problem. It was not accepted at a conference and somebody who had been on the program committee made three papers out of it. That kind of thing. It happens in our field and we don't have good ways of dealing with it.</p>
<p class="normal"><b>Seibel：</b>而且这种情况更多发生在女性身上？</p><p class="normal"><b>Seibel:</b> And it happens more to women?</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_515"></a><b>艾伦：</b>是的，我认为是的。他们通常被认为不会反抗——他们更加孤立，没有愿意与著名小偷打交道的拥护者。他是个有名的小偷，众所周知，但没人敢碰。还有很多其他方式可以追溯到 Stretch 时代。有一个女人本质上是多道程序设计的发明者，而功劳被最终成为图灵奖获得者的人所接受。</p><p class="normal"><a></a><b>Allen:</b> Yes, I think it does. They were often viewed as not going to put up a fight—that they were more isolated and don't have the advocates who will deal with a famous thief. He was a famous thief, known but nobody dared touch it. And there are plenty of others way back from the Stretch days. There was a woman who essentially was the inventor of multiprogramming and credit was taken by somebody who eventually became a Turing Award winner.</p>
<p class="normal"><b>Seibel：</b>你是否宁愿获得图灵奖，但不必成为第一位女性？有很多报纸报道：“女性获得图灵奖”，我想这可能有点烦人。如果十年前另一个女人赢得了它，并且是第一个，而你也可以在你赢得它的时候赢得它，你认为你会更愿意这样吗？</p><p class="normal"><b>Seibel:</b> Would you have rather won the Turing Award, but not had to have been the first woman? There were a lot of newspaper stories: “Woman Wins the Turing Award,” which I imagine might be a little annoying. If another woman had won it ten years ago, and been the first, and you could have just won it when you did, do you think you would've preferred that?</p>
<p class="normal"><b>艾伦：</b>嗯，我不能说喜欢或不喜欢。我觉得我赢得它的原因有很多。这花了很长时间，因为在某种意义上并不总是很清楚我在做什么。我总是和一群人一起工作。经常和一些伟大的名人一起工作。而且这项工作很容易归功于其他人——John Cocke，他到处传播想法。很多人都获得了赞誉和奖励，因为他们从他那里学到了一些东西，就像我们所有人一样。</p><p class="normal"><b>Allen:</b> Well, I can't say preferred or not preferred. I feel I won it for a very good set of reasons. And it took a long time because it was not always clear what I was doing in some sense. I always worked with a group. Worked with some great, famous people often. And the work could easily be attributed to somebody else—to John Cocke, who distributed ideas everywhere. Lots of people have received accolades and awards because they picked up on something from him, as we all did.</p>
<p class="normal">但我很高兴得到它，部分原因是女人得到它已经晚了。我觉得 40 年里有 50 个人，或者不管是什么，这对社区来说是一种尴尬。所以我觉得有些女人实现它肯定是迟到了，我很高兴成为第一个。但我稍微避开了从这方面大做文章的想法。我试图更多地关注我职业生涯的长度和它的整个历史。</p><p class="normal">But I was very glad to get it and partly because it was late for a woman to get it. I felt it was an embarrassment for the community that there were 50 men in 40 years, or whatever it was. So I felt it was certainly overdue for some woman to achieve it, and I was perfectly happy to be the first. But I steered a little bit clear of making a big deal out of that aspect of it. I tried to focus a lot more on the length of my career and the whole history of it.</p>
<p class="normal"><b>Seibel：</b>在 IBM 度过整个职业生涯感觉如何？</p><p class="normal"><b>Seibel:</b> How does it feel to have spent your whole career at IBM?</p>
<p class="normal"><b>艾伦：</b>为 IBM Research 工作是我经历过的最幸运的事情之一，因为 IBM Research 介于工业界和学术界之间。我有一张我站在石墙上的照片，我可以从任何一个方向看，并从两个方向发现有趣的问题和机会。</p><p class="normal"><b>Allen:</b> Working for IBM Research was one of the most fortunate things that ever happened to me because IBM Research sits between industry and academia. I have a picture of a stone wall that I'm standing on and can look either way and find interesting problems and opportunities in both ways.</p>
<p class="normal"><b>Seibel：</b>从你在这堵石墙上的有利位置来看，你觉得在学术界和工业界之间来回走动是否足够？</p><p class="normal"><b>Seibel:</b> From your vantage point on this stone wall, do you feel there is enough going back and forth between the academy and industry?</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_516"></a><b>艾伦：</b>好吧，NSF 几年前发表了一份精彩的报告，其中有一页图表显示了价值数十亿美元的行业的来源，例如图形、互联网、高性能计算、晶体管。这些价值数十亿美元的产业在 y 轴的下方，而在 x 轴上是一个时间表，显示了它何时开始，工业界的作用是什么，实验室是什么，学术界的作用是什么。</p><p class="normal"><a></a><b>Allen:</b> Well, NSF published a wonderful report with a one-page graph a few years ago which showed where several billion-dollar industries come from, like graphics, the Internet, high-performance computing, transistors. These billion-dollar industries were down the y-axis and on the x-axis was a timeline showing when it started, what was the role of industry, by lab, and what was the role of academia.</p>
<p class="normal">有些人开始从事工业；有些是从学术界开始的。这两个实体共同为建设这些价值数十亿美元的产业做出了几乎同等的贡献。我认为真正重要的是保护这种相互作用，以便有很多想法、技术、方法和投资的交叉渠道，以确保它继续下去。</p><p class="normal">Some started in industry; some started in academia. Together, these two entities had contributed pretty much equally into building these multiple billion-dollar industries. I think the real important thing is to protect the interplay so that there's a lot of cross-channeling of ideas, and of technologies, and methods, and investments to see it continuing.</p>
<p class="normal">目前，美国对保持创新的关注及其重要性，我认为我们在互动、合作和解决问题方面做得很好。并解决阻碍我们解决问题的问题——知识产权就是其中之一。</p><p class="normal">Right now, with the focus that the U.S. has on maintaining innovation, and the importance of it, I think we're doing pretty well in terms of interaction, working together, and solving problems together. And solving the problems that keep us from solving problems—intellectual property being one of them.</p>
<p class="normal"><b>Seibel：</b> IBM 在这方面并非完全无可指责。</p><p class="normal"><b>Seibel:</b> IBM is not exactly blameless there.</p>
<p class="normal"><b>艾伦：</b>一点也不。</p><p class="normal"><b>Allen:</b> Not at all.</p>
<p class="normal"><b>Seibel：</b>你必须在专利上有你的名字。</p><p class="normal"><b>Seibel:</b> You must have your name on patents.</p>
<p class="normal"><b>艾伦：</b>没有，没有。部分原因是软件不可申请专利。另一件事是，我经常在事物的前沿工作，将它引入 IBM 的最佳方式是发布它，然后其他公司会选择它。与获得专利相比，我更感兴趣的是将其应用到产品中。</p><p class="normal"><b>Allen:</b> No, none. Part of it is that software wasn't patentable. The other thing was that I was often working at the leading edge of things and the best way to get it into IBM was to publish it and some other company would pick it up. I was much more interested in getting it into products than to getting a patent on things.</p>
<p class="normal"><b>Seibel：</b>所以这比说服 IBM 内部的某个人根据您的研究构建产品更容易？</p><p class="normal"><b>Seibel:</b> So that was easier than convincing someone within IBM to build a product based on your research?</p>
<p class="normal"><b>艾伦：</b>我们现在有更好的做事方式。但有时，研究中的好想法与产品之间存在很长的路要走。</p><p class="normal"><b>Allen:</b> We have a much better way of doing things now. But there was a long way, sometimes, between a good idea in research and a product.</p>
<p class="normal"><b>Seibel：</b>自从获得图灵奖让您对自己的整个职业生涯有了一些反思，您是否意识到有什么是将这一切联系在一起的？</p><p class="normal"><b>Seibel:</b> Since receiving the Turing Award has caused you to reflect a bit on your whole career, is there anything that you've realized ties it all together?</p>
<p class="normal"><a id="OEBPS/Chapter13.html.page_517"></a><b>艾伦：</b>我认为我的职业生涯和我做事的方式——用一个词来概括它就是“探索”。我喜欢探索边缘——想法、项目和物理地球，无论它是什么——人也是——我觉得这非常令人兴奋。</p><p class="normal"><a></a><b>Allen:</b> I think my career and the way I do things—the one word that kind of sums it up is “exploring.” I love exploring the edges—of ideas, of projects, and the physical earth, whatever it is—people too—and that I find very exciting.</p>
<p class="normal">但也有不利的一面，我是首发者，而不是终结者。我被新事物所吸引。编译器领域只是一个了不起的领域，因为计算机不断提出挑战。正在解决的问题继续变得越来越具有挑战性。</p><p class="normal">But there's a flip side in that I'm a starter, not a finisher. I get attracted to new things. The field of compilers was just a marvelous field because the computers continued to present challenges. And the problems being solved continued to be increasingly challenging.</p>
</div>
</div></div>
<div id="OEBPS/Chapter14.html"><div>

<div class="booksection">
<p></p>
<h2 class="chapnum"><a id="OEBPS/Chapter14.html.ch14"></a><a id="OEBPS/Chapter14.html.page_519"></a><img src="data:image/jpg;base64,/9j/4AAQSkZJRgABAgEASABIAAD/7Q1iUGhvdG9zaG9wIDMuMAA4QklNA+0KUmVzb2x1dGlvbgAAAAAQAEgAAAABAAEASAAAAAEAAThCSU0EDRhGWCBHbG9iYWwgTGlnaHRpbmcgQW5nbGUAAAAABAAAAHg4QklNBBkSRlggR2xvYmFsIEFsdGl0dWRlAAAAAAQAAAAeOEJJTQPzC1ByaW50IEZsYWdzAAAACQAAAAAAAAAAAQA4QklNBAoOQ29weXJpZ2h0IEZsYWcAAAAAAQAAOEJJTScQFEphcGFuZXNlIFByaW50IEZsYWdzAAAAAAoAAQAAAAAAAAACOEJJTQP1F0NvbG9yIEhhbGZ0b25lIFNldHRpbmdzAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+BdDb2xvciBUcmFuc2ZlciBTZXR0aW5ncwAAAHAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAOEJJTQQAC0xheWVyIFN0YXRlAAAAAgABOEJJTQQCDExheWVyIEdyb3VwcwAAAAAEAAAAADhCSU0ECAZHdWlkZXMAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4NVVJMIG92ZXJyaWRlcwAAAAQAAAAAOEJJTQQaBlNsaWNlcwAAAAB1AAAABgAAAAAAAAAAAAAArwAAAPgAAAAKAFUAbgB0AGkAdABsAGUAZAAtADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAPgAAACvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhCSU0EERFJQ0MgVW50YWdnZWQgRmxhZwAAAAEBADhCSU0EFBdMYXllciBJRCBHZW5lcmF0b3IgQmFzZQAAAAQAAAACOEJJTQQMFU5ldyBXaW5kb3dzIFRodW1ibmFpbAAACYUAAAABAAAAcAAAAE8AAAFQAABnsAAACWkAGAAB/9j/4AAQSkZJRgABAgEASABI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" alt="图片"></h2><h2 class="chapnum"><a></a><a></a></h2>
<h2 class="chaptitle">伯尼科塞尔</h2><h2 class="chaptitle">Bernie Cosell</h2>
<div class="sidebar">
<p class="normal"><i>1969 年，当 ARPANET（后来成为互联网核心的网络）的前两个节点上线时，流过 50 千比特/秒租用线路的每个数据包都通过两台称为接口消息处理器 (IMP) 的专用计算机进行路由. IMP 由 Bolt Beranek 和 Newman (BBN) 设计和构建，运行 IMP 的软件由三名程序员组成的团队编写，其中之一是 Bernie Cosell，他三年前离开麻省理工学院，开始时大三时，加入BBN。</i></p><p class="normal"><i>In 1969 when the first two nodes of the ARPANET—the network that would become the core of the Internet—came on line, every packet that flowed over 50 kilobit/second leased lines was routed through two specialized computers called Interface Message Processors, or IMPs. The IMPs were designed and built by Bolt Beranek and Newman (BBN), and the software that ran the IMPs had been written by a team of three programmers, one of whom was Bernie Cosell, who had left MIT three years before, at the beginning of his junior year, to join BBN.</i></p>
<p class="normal"><i>Cosell 最初被聘为一个构建最早的分时系统之一的项目的应用程序程序员，但很快就转向了系统编程方面，并很快成为“PDP-1 分时系统的沙皇”，负责完成操作系统代码并保持系统运行。</i></p><p class="normal"><i>Originally hired as an application programmer on a project building one of the earliest timesharing systems, Cosell quickly moved to the systems programming side of things and was soon “czar of the PDP-1 timesharing system” responsible for finishing the operating-system code and keeping the system running.</i></p>
<p class="normal"><i>在 BBN 的 26 年职业生涯中，Cosell 会处理所有事情，在 BBN 中赢得了调试大师和“修复者”的声誉，他可以被投入到一个困难的项目中来使软件运行。他只是为了好玩而黑客：为了磨练他的 Lisp 技能，他根据 Weizenbaum 在期刊文章中的描述编写了 DOCTOR，这是 Joseph Weizenbaum 的 ELIZA 的一个版本。Cosell 的 DOCTOR 版本使用 BBN-LISP 编写，与 TENEX 操作系统一起在 ARPANET 中传播，它也有广泛的分布——比 Weizenbaum 的原始版本更广泛——激发了新的实现和相关程序。</i></p><p class="normal"><i>Over a 26-year career at BBN, Cosell would work on a little bit of everything, earning a reputation within BBN as a master debugger and “fixer” who could be thrown onto a struggling project to make the software work. And he hacked just for fun: to hone his Lisp skills he wrote DOCTOR, a version of Joseph Weizenbaum's ELIZA, based on Weizenbaum's description in a journal article. Written in BBN-LISP, which spread around the ARPANET along with the TENEX operating system, Cosell's version of DOCTOR also had a wide distribution—wider than Weizenbaum's original—inspiring new implementations and related programs.</i></p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_520"></a><i>1991 年，Cosell 离开 BBN，在弗吉尼亚买了一个绵羊农场，现在他和妻子林恩、三只狗、无数只猫和许多羊住在那里。他为本地 ISP 编写一些程序，对自己的项目进行一些黑客攻击，并教授一些编程和计算机安全方面的课程，但很高兴他不再是一名全职程序员。具有讽刺意味的是，由于搬到乡下，互联网之父之一科塞尔现在只能在家中拨号上网。</i></p><p class="normal"><a></a><i>In 1991 Cosell left BBN and bought a sheep farm in Virginia, where he now lives with his wife Lynn, three dogs, innumerable cats, and lots of sheep. He does some programming for a local ISP, hacks a bit on his own projects, and teaches a few courses in programming and computer security but is glad he no longer works as a full-time programmer. Ironically, as a result of his move to the country, Cosell— one of the fathers of the Internet—now has only dial-up access from his home.</i></p>
<p class="normal"><i>在这次采访中，我们谈到了他如何赢得调试大师的声誉、编写清晰代码的重要性，以及他如何说服 IMP 项目的其他程序员停止修补二进制文件。</i></p><p class="normal"><i>In this interview we talked about how he won his reputation as a master debugger, the importance of writing clear code, and how he convinced the other programmers on the IMP project to stop patching the binary.</i></p>
</div>
<p class="normal"><b>Seibel：</b>您是什么时候开始接触编程的？</p><p class="normal"><b>Seibel:</b> When did you first get involved with programming?</p>
<p class="normal"><b>科塞尔：</b>在高中。我不知道这是不是真的，但有传言说我们的高中是全国第一所真正拥有自己电脑的高中。IBM 向我们的高中捐赠了一台 1620。我认为它是在我到达的前一年到达的，或者是我 59 年到达高中的那一年。</p><p class="normal"><b>Cosell:</b> In high school. I don't know if it was true or not but the rumor was that our high school was the first high school in the country to actually have its own computer. IBM donated a 1620 to our high school. I think it arrived either the year before I arrived, or the year I arrived at high school in '59.</p>
<p class="normal"><b>Seibel：</b>那是哪所高中？</p><p class="normal"><b>Seibel:</b> And what high school was it?</p>
<p class="normal"><b>Cosell：</b>纽约布朗克斯科学高中。我相信上一代学生使用的是哥伦比亚大学的 650。但是数学系主任很高兴他有自己的电脑。事实上，他正在写一本关于编程的书，那是在编程书籍还不多的时候。我最终调试了他所有的例子。关于高中，我唯一记得的几乎就是学习编程。</p><p class="normal"><b>Cosell:</b> Bronx High School of Science in New York. I believe the previous generation of students were using Columbia University's 650. But the head of the math department was very pleased that he had his own computer. In fact, he was writing a book on programming and this was back when there weren't many books on programming. I ended up debugging all of his examples. Almost the only thing I remember about high school is learning to program.</p>
<p class="normal"><b>Seibel：</b>当时你在编程什么？在打孔卡上组装？</p><p class="normal"><b>Seibel:</b> What were you programming then? Assembly on punch cards?</p>
<p class="normal"><b>科塞尔：</b>是的。好吧，它是打孔卡，但 1620 也有一个控制台。它有一台 IBM Selectric 打字机作为输入/输出控制台，您可以从中输入程序。为了向您展示那个时代，他们选择不在其中放置算术硬件。它有查表算法：有一个内存区域，当你想做加法时，一个数字给你行，一个数字给你列，值就在那里。和<a id="OEBPS/Chapter14.html.page_521"></a>每个程序的一部分都是用加法和乘法表加载那部分内存。</p><p class="normal"><b>Cosell:</b> Yeah. Well, it was punch cards but the 1620 also had a console. It had an IBM Selectric typewriter that was the input/output console, and you could input programs from that. To show you the era it was, they chose not to put arithmetic hardware in it. It had table-lookup arithmetic: there was an area of memory and when you wanted to do an addition, one digit gave you the row, one digit gave you the column, and the value was there. And <a></a>part of every program was loading that part of memory with the addition and multiplication tables.</p>
<p class="normal">所以你实际上可以从打字机上打字，但大多数情况下我们打孔卡片并将它们装入。有一个 Fortran 语言，但我从来没有用过 Fortran。大多数情况下，我使用 1620 汇编程序进行编程。</p><p class="normal">So you could actually type from the typewriter but mostly we punched cards and loaded them in. There was a Fortran for it but I never did very much Fortran. Mostly, I programmed in 1620 assembler.</p>
<p class="normal">我在高中学到的另一件事是如何连接插头板。沿途的某个地方，我们有一台旧的 403 计算打印机，我学会了如何连接插板。即使在当时，它也是一种如此原始的艺术，但事实证明它很有用。在 BBN，大约在我上高中十年后，我们实际上需要有人给插板接线，我只是说，“哦，给我那东西的手册。” 我阅读了手册，并让一台旧的独立会计机打印机执行了一个原始协议，作为我们 PDP-1 上的行式打印机。</p><p class="normal">The other thing I learned in high school is how to wire plug boards. Someplace along the route, we had something like an old 403 calculating printers and I learned how to wire a plug board. It was such a primitive art, even at the time, but it turned out to be useful. At BBN, like ten years after I was in high school, we actually needed somebody to wire a plug board and I just said, “Oh, give me the manual on that thing.” And I read the manual and made an old standalone accounting-machine printer do a primitive protocol to serve as a line printer on our PDP-1.</p>
<p class="normal"><b>Seibel：</b>在高中和 BBN 之间，你去了麻省理工学院？</p><p class="normal"><b>Seibel:</b> And in between high school and BBN you went to MIT?</p>
<p class="normal"><b>Cosell：</b>我高中毕业，63 年进入麻省理工学院。我在麻省理工学院主修数学，选修了一门奇怪的计算机课程。计算机仍然是电气工程系偶尔教授的课程。你不能主修计算机科学。人们刚刚开始在 709 或 7094 上构建第一个分时系统，无论他们在计算机中心有什么，但我正忙着做数学。</p><p class="normal"><b>Cosell:</b> I graduated from high school and entered MIT in '63. I was a solid math major at MIT, taking an odd computer course. Computers were still an occasional class taught out of the electrical engineering department; you couldn't major in computer science. Folks were just starting to build the first time-sharing systems on the 709 or 7094, whatever they had at the computer center, but I was pretty busy doing math.</p>
<p class="normal">我参加了一些电子工程课程和逻辑课程，我参加了一些奇怪的计算机课程，并且似乎还不错。我不明白真正优秀的程序员是做什么的，因为我还是个小孩。但我似乎能够编程。</p><p class="normal">I took some EE courses and logic courses and I took the odd computer course and seemed to be OK at it. I didn't understand what the really good programmers did because I was just a little kid. But I seemed to be able to program.</p>
<p class="normal">我确实加入了一个名为 Tech Model Railroad Club 的团体。我真的觉得那很棒。中继逻辑正合我意。他们的铁路布局完全由继电器逻辑和步进开关完成。借此，我与 RLE（电子研究实验室）的人员有了些许联系。那还是在那个时代，我们把所有的时间都花在 26 号楼的地下室里，用打孔器打孔卡，然后我们会把它交给萨满，他会在第二天给我们列表。然后我开始在 Project MAC 闲逛。基本上，当我<a id="OEBPS/Chapter14.html.page_522"></a>本来应该上很多数学课的，但我发现我花在电脑前的时间越来越多。</p><p class="normal">I did fall in with a group called the Tech Model Railroad Club. I really thought that was great. Relay logic was right up my alley. They had a railroad layout completely done with relay logic and stepping switches. Through that, I got slightly in touch with the people at RLE—Research Lab of Electronics. This was still in the era where we spent all of our time in the basement of Building 26 typing up punch cards on the keypunch, which we would then hand to the shaman, who would give us listings back the next day. Then I started hanging out at Project MAC. Basically, when I was <a></a>supposed to have been doing lots of math lessons, I discovered I was spending more and more time hanging out in the computer places.</p>
<p class="normal">在 RLE 之后，你去了 Tech Square。我遇到了 Richard Greenblatt 和 Bill Gosper 这样的人。但我只是在那个世界中漂流；我认为我没有做太多编程。就像我记得我是如何参与 MAC 项目的：我真的被<i>太空大战迷住了！</i>在 PDP-1 上。但我并没有以黑客或程序员的身份来处理它——“让我看看源代码。你是怎么做到的？” 我只是认为游戏是最整洁的东西。那时我只是一个游戏玩家，而不是一个程序员，而且我听说 Project MAC 的人做了一个超级版本的<i>Spacewar！</i>，他们有漂亮的游戏机，还有一个备用的 PDP，所以我就去了那里。所以我遇到了彼得萨姆森，他试图解决纽约市的地铁系统问题，他试图用一张票尽可能快地乘坐整个系统，但失败了。</p><p class="normal">And after RLE, you went over to Tech Square. I met people like Richard Greenblatt and Bill Gosper. But I was just drifting through that world; I don't think I was doing much programming. Like I remember how I got involved with Project MAC: I was really taken by <i>Spacewar!</i> on the PDP-1. But I didn't approach it as a hacker or a programmer—“Let me see the source code. How did you do that?” I just thought the game was the neatest thing. I was just a gamer at that point, as opposed to a programmer, and I had heard that the guys over at Project MAC had done a super version of <i>Spacewar!</i>, that they had fancy consoles, and they had a spare PDP, so I wandered up there. So I got to meet Peter Samson in his great failed attempt to solve the New York City subway system, to ride the whole system on one ticket as fast as possible.</p>
<p class="normal">我可能是一名二年级学生，深深地沉浸在通常的二年级学生中，看着所有这些显然很熟练并且清楚地知道他们在做什么的人。我正在编写小程序来解决迷宫问题。青蛙不得不从一片睡莲叶跳到另一片睡莲叶，然后跳出池塘中央。我记得我编写了那个程序并帮助我宿舍的其他学生让他们的程序工作。但这就是我所在的地方。我不知道在我交出牌组后发生了什么。</p><p class="normal">I was probably a sophomore, deeply entrenched in the usual sophomore things, watching all of these guys who were clearly adept and clearly knew what they were doing. I was writing little programs to solve a maze. The frog had to hop from lily pad to lily pad and get out of the middle of the pond. I remember writing that program and helping other students from my dorm get theirs working. But that's where I was at. I had no clue what happened after I handed my deck in.</p>
<p class="normal">当我回顾过去时，我会说那时候我正在学习编程技巧。我可以让电脑做我想做的事。但灯并没有熄灭。我没有把它内化；我真的不明白发生了什么。这一切都有点神奇和奇怪。这就是我在大学里漂流的方式。真正让我成为一名程序员的是去 BBN 工作。</p><p class="normal">As I look back, I would say that at that point, I was learning the craft of programming. I could sort of make computers do what I wanted. But the light hadn't gone off. I hadn't internalized it; I didn't really understand what was happening. It was all a little bit magical and strange. And that was how I was drifting through college. The thing that really made me a programmer was going to work at BBN.</p>
<p class="normal">我在大学里认识的一个毕业并在 BBN 工作的人说，“到这里来。” 一天晚上他半夜带我出去，因为 BBN 是一个一天 24 小时、一周 7 天的奇怪地方。它是麻省理工学院实验室的延伸。人们随时都可以来来去去。他是夜班的一员。所以我们出去了一天晚上。这一切太神秘太奇妙，难以理解。我只是不知道他在给我看什么。不久之后，他建议他们雇用我。所以他们让我出局，面试我，然后雇用了我。</p><p class="normal">One of the guys I had met at college, who had graduated and worked at BBN said, “Come out here.” He took me out one night in the middle of the night because BBN was a 24-hour-a-day, 7-day-a-week weird place. It was sort of an extension of the MIT labs. People could come and go at all hours. And he was part of the night crew. So we went out one evening. It was all too mysterious and marvelous to understand; I just had no clue what he was showing me. Not long after that, he suggested that they hire me. And so they had me out, interviewed me, and hired me.</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_523"></a><b>Seibel：</b>那是你进入麻省理工学院三年的时候？</p><p class="normal"><a></a><b>Seibel:</b> This was when you were three years into MIT?</p>
<p class="normal"><b>科塞尔：</b>正确。在我大三那年的九月，他们雇用了我兼职。我相信我一直坚持到 10 月才退学并全职工作在 BBN。</p><p class="normal"><b>Cosell:</b> Correct. In September of my junior year they hired me part-time. I believe I made it until October before I dropped out and went to work full-time at BBN.</p>
<p class="normal">回想起来，我不是很好。我见过 PDP-1，但不知道如何编程。我对分时系统一无所知。当然，这并不奇怪，因为地球上可能有 50 人知道分时是什么。</p><p class="normal">In retrospect, I wasn't very good. I had seen a PDP-1 but I had no idea how to program one. I didn't know anything about time-sharing. That, of course, was not surprising, since there were probably maybe 50 people on the planet who knew what time-sharing was.</p>
<p class="normal">但 BBN 正在与马萨诸塞州总医院合作开展一个项目，以试验医院自动化，我也参与了该项目。我最初是一名应用程序程序员，因为那是我的全部优势。我想我花了大约三个星期作为应用程序程序员。我很快成为一名系统程序员，负责他们正在使用的库。不久之后，两位系统大师，也就是编写了大部分 PDP-1 分时系统的人，将我置于他们的羽翼之下，并指定我为他们的继承人。那年冬天，他们都离开了 BBN 回到研究生院。到了 1 月，我成了 PDP-1 分时系统的负责人——我要为整个混乱负责。</p><p class="normal">But BBN was working on a project with Massachusetts General Hospital to experiment with automating hospitals and I got brought onto that project. I started out as an application programmer because that was all I was good for. I think I spent about three weeks as an application programmer. I quickly became a systems programmer, working on the libraries that they were using. And not long after that, the two systems gurus, the guys that had written much of that PDP-1 time-sharing system, took me under their wing and designated me their heir apparent. That winter they both left BBN to go back to grad school. By January I was the czar of the PDP-1 timesharing system—I was responsible for the whole mess.</p>
<p class="normal">但在那一小段时间里，一整串灯泡亮了起来。一下子明白了分时。我了解实时系统。理解了之后，我吸收了分时系统。在那之后，一切对我来说都是走下坡路。</p><p class="normal">But in that little interval, a whole series of lightbulbs lit up. All of a sudden, I understood time-sharing. I understood real-time systems. Once I understood it, I absorbed the time-sharing system. And everything's been downhill for me after that.</p>
<p class="normal">这个项目在当时是非常雄心勃勃的。当时的想法是，每个病房都会有一台 33 型电传打字机——又吵又笨，而且只有大写字母。每个医生的办公室都会有一台 33 型电传打字机。药房里会有一台 33 型电传打字机。我想，招生办公室会有一台 33 型电传打字机。我们的小分时系统将协调所有这些。</p><p class="normal">The project was quite ambitious for its time. The idea was that there would be a Model 33 Teletype—noisy and clunky and uppercase only—on each ward. There would be a Model 33 Teletype in each doctor's office. There would be a Model 33 Teletype in the pharmacy. And there would be, I guess, a Model 33 Teletype in the admissions office. And our little timesharing system was going to coordinate all of that.</p>
<p class="normal">当病人进来时，他们会被分配到一张床位。医生会安排实验室测试。这时，护士的电传打字机会说：“取这些样本。把这个号码放在上面。” 实验室会收到一条消息，说“运行这些测试”。如果医生开了什么药，就会通知药房，推车就会准备好。</p><p class="normal">When a patient got in, they would be assigned a bed. The doctor would schedule lab tests. At which point, the nurse's Teletype would say, “Take these samples. Put this number on it.” The lab would get a message saying, “Run these tests.” If the doctor prescribed something, the pharmacy would be told and the cart would be ready.</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_524"></a>病房里有那些吵闹、愚蠢的小东西真是太棒了。让那种水平的专业人士处理这些笨重的事情真的很冒犯，所以有很多阻力。但我对所有这些都免疫，因为我已经被世界的系统部分所吸引。</p><p class="normal"><a></a>It was amazing to have those little noisy, silly things on the wards. Having that level of professional dealing with these clunky things was really pretty offensive, so there was a lot of resistance. But I was sort of immune to all of that, because I had gravitated off to the systems part of the world.</p>
<p class="normal">我已经决定让系统不停止是非常重要的。我不知道他们是否告诉过我，但我决定我们必须证明——我必须证明——分时制是可行的。这是一件足够好、足够坚固的东西，你会考虑用它来经营一家医院。我想如果病人需要吃药而系统崩溃了怎么办？或者更糟的是，系统丢失了处方并且患者从未服药？还是系统在处理处方，而护士实际上已经开始信任系统了？所以我开始考虑系统不应该崩溃。这个系统应该和 30 年后的 Unix 一样好。</p><p class="normal">And I had decided it was really important that the system not stop. I don't know if they told me that or not, but I decided that we had to prove—I had to prove—that time-sharing could work. That it was a good enough and solid enough thing that you would consider running a hospital with it. I thought about what happened if a patient needed medication and the system crashed? Or worse, the system lost the prescription and the patient never got dosed? Or the system juggled prescriptions and the nurses had actually started trusting the system? So I started thinking the system should not crash. This system should be good as Unix 30 years later.</p>
<p class="normal">但是没有实时调试。当系统崩溃时，基本上运行灯熄灭，仅此而已。你有控制面板开关，你可以在其中读取和写入内存。调试系统的唯一方法就是问：“系统崩溃时正在做什么？” 您不必运行程序；您可以查看记录其正在执行的操作的表格。所以我必须查看内存，在方格纸上跟踪它在做什么。我在这方面做得更好。</p><p class="normal">But there was no real-time debugging. When the system crashed, basically the run light went out and that was it. You had control-panel switches where you could read and write memory. The only way to debug the system was to say, “What was the system doing when it crashed?” You don't get to run a program; you get to look at the table that kept track of what it was doing. So I got to look at memory, keeping track on pieces of graph paper what it was doing. And I got better at that.</p>
<p class="normal">回想起来，我在这方面做得更好。所以他们让我有传呼机。这是在寻呼机还算酷，只有医生才有的时代。这是一个又大又笨重的东西，它只会发出哔哔声。没有双向。没有消息。而且它只在波士顿地区有效，因为它的发射器在保德信中心的顶部。但如果我在波士顿 50 英里以内，它就奏效了。</p><p class="normal">In retrospect, I got scarily better at that. So they had me have a pager. This was back in the era when pagers were sort of cool and only doctors had them. It was a big, clunky thing and all it would do is beep. No two-way. No messages. And it only worked in the Boston area, because its transmitter was on top of the Prudential Center. But if I was within 50 miles of Boston, it worked.</p>
<p class="normal">基本上，我是一个训练有素的小机器人：当我的寻呼机<i>发出哔、哔、哔的声音</i>时，我就打电话找出问题所在。奇怪的是，在没有纸的情况下，在停车场，通过公用电话，我可以让他们检查八进制位置，更改八进制位置，然后我会说，“好的，输入这个地址并点击运行，”然后系统会回来的。我不知道我到底是怎么做到的。但我可以做那些事情。我负责分时系统大概有两三年的时间。</p><p class="normal">And basically, I was a trained little robot: when my pager went <i>beep, beep, beep</i>, I called in to find out what the problem was. What was bizarre was that with no paper, in a parking lot, on a pay phone I could have them examining octal locations, changing octal locations and then I would say, “OK, put this address in and hit run,” and the system would come back up. I don't know how the hell I managed to do that. But I could do those kinds of things. I took care of the time-sharing system for probably a good two or three years.</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_525"></a><b>Seibel：</b>在这一点上，尽管您最初继承了系统，但大概已经编写了很多代码。</p><p class="normal"><a></a><b>Seibel:</b> At this point, you had presumably written a lot of the code despite having originally inherited the system.</p>
<p class="normal"><b>科塞尔：</b>是的。拿到手的时候操作系统还没弄好。它有很多问题，而且当史蒂夫韦斯和鲍勃摩根去读研究生时，它的某些部分还没有完成。我做了他们没有做过的事情——这是我在 BBN 周围出名的事情之一，也就是说，我让事情成功了。</p><p class="normal"><b>Cosell:</b> Yeah. The operating system was not done when I got it. It was buggy and there were pieces of it that were not finished when Steve Weiss and Bob Morgan went off to grad school. I did something that they hadn't done—it was one of the things that I got known for around BBN, which is, I made things work.</p>
<p class="normal">我真的相信计算机是确定性的，你可以理解它们应该做什么，并且没有任何借口可以让计算机不工作，让事情不能正常运行。回想起来，我在保持系统运行、输入新代码并且不破坏系统方面出奇地出色。</p><p class="normal">I really believed that computers were deterministic, that you could understand what they were supposed to do, and that there was no excuse for computers not working, for things not functioning properly. In retrospect, I was surprisingly good at keeping the system running, putting in new code and having it not break the system.</p>
<p class="normal">那是我得到不当声誉的第一个例子。我知道我的老板，可能还有我的其他一些同事，都说我是一个很棒的调试者。这部分是正确的。但是里面有假货。</p><p class="normal">That was the first instance of something I got an undeserved reputation for. I know that my boss, and probably some other of my colleagues, have said I was a great debugger. And that's partly true. But there's a fake in there.</p>
<p class="normal">事实上，我是一个非常细心的程序员，傲慢地认为很少有计算机程序天生就很困难。我会拿一些看起来不起作用的代码，然后尝试阅读它。如果我能理解，那么我通常可以看出问题所在或四处寻找并修复它。但有时我会得到一段代码——通常是其他人无法实现的代码——我会说，“这太复杂了。”</p><p class="normal">Really what I was was a very careful programmer with the arrogance to believe that very few computer programs are inherently difficult. I would take some piece of code that didn't look like it was working and I would try to read it. And if I could understand, then I could usually see what was wrong or poke around with it and fix it. But sometimes I would get a piece of code—often one that other people couldn't make work—and I would say, “This is way too complicated.”</p>
<p class="normal">所以我会想清楚它应该做什么，扔掉它，然后从头开始重新写。一些与我共事的人——比如 Will Crowther——他们是了不起的程序员，无法容忍这种情况。他们会相信，通过这样做，我可能会修复那里的 2 个错误并引入 27 个新错误。但事实是，我很擅长那个。所以我会完全重写一些东西，它的组织方式将与原来的程序员组织它的方式不同，因为我对这个问题的思考方式不同。通常，它比以前更简单，或者至少在我看来更简单。它会起作用的。</p><p class="normal">So I would think through what it was supposed to do, throw it away, and write it again from scratch. Some of the folks I worked with—like Will Crowther—who are terrific programmers, couldn't tolerate that. They would believe that by doing that, I would probably have fixed the 2 bugs that were there and introduced 27 new bugs. But the fact is, I was good at that. So I would rewrite stuff completely and it would be organized differently than the original programmer had organized it because I had thought about the problem differently. Typically, it was simpler than it used to be, or at least simpler to my eyes. And it would work.</p>
<p class="normal">所以我得到了这个名声——我修复了这些其他人无法修复的神秘错误。幸运的是，他们从来没有问过我这个 bug 是什么。因为<a id="OEBPS/Chapter14.html.page_526"></a>事情的真相是，如果他们问，“你是如何修复这个错误的？” 我的回答是，“我无法很好地理解代码以弄清楚它在做什么，所以我重写了它。”</p><p class="normal">So I got this reputation—I fixed these mysterious bugs that nobody else could fix. Fortunately, they never asked me what the bug was. Because the <a></a>truth of the matter is if they'd have asked, “How did you fix the bug?” my answer would have been, “I couldn't understand the code well enough to figure out what it was doing, so I rewrote it.”</p>
<p class="normal">我在 PDP-1 分时系统上做了很多。有一些代码块我会阅读并说，“这没有做我认为程序的这一部分应该做的事情，”或“这很奇怪”。所以我会重写它。唯一让我以这种态度在那里工作的是我有良好的记录。这就是其中之一，如果你不擅长它，你就会制造混乱。但如果你擅长它，世界就会认为你可以做你做不到的事情，真的。</p><p class="normal">I did that a lot on the PDP-1 time-sharing system. There were chunks of the code that I would read and would say, “This doesn't do what I think this part of the program is supposed to be doing,” or “It's weird.” So I'd rewrite it. The only thing that kept me working there, with that attitude, was that I had a good track record. That's one of the things, that if you're not good at it, you make chaos. But if you are good at it, the world thinks that you can do things that you can't, really.</p>
<p class="normal"><b>Seibel：</b>当你离开麻省理工学院时，是否是一个艰难的决定，决定辍学？</p><p class="normal"><b>Seibel:</b> When you left MIT, was it a hard decision at all, deciding to drop out of school?</p>
<p class="normal"><b>Cosell：</b>不。回想起来，这出奇地容易。我讨厌学校。这让我发疯。MIT真是一个充满压力的地方。BBN 就像应许之地。这太棒了。他们玩电脑；公司是如此悠闲。它更像是 MAC 项目而不是 MAC 项目。那是在人们经常带着他们的狗进来的时代。所以宠物在大厅里来回走动；人们日以继夜地工作。</p><p class="normal"><b>Cosell:</b> No. In retrospect, it was surprisingly easy. I was hating school. It was making me crazy. MIT is really a pressure-filled place. And BBN was like the Promised Land. It was wonderful. They played with computers; the company was so laid back. It was more like Project MAC than Project MAC. This was back in an era when people routinely brought their dogs in with them. So pets were padding up and down the halls; people were working day and night.</p>
<p class="normal">我开始兼职工作是因为我在麻省理工学院期间几乎总是有一份兼职工作。它立即感觉像家一样。我简直不敢相信。我在麻省理工学院的东西彻底完蛋了，所以我辍学了，开始全职工作。然后我在 BBN 安顿下来，变得更加成熟，头脑也有了一个更好的地方。所以接下来的秋天，也就是我大四的那年，我实​​际上重新注册了麻省理工学院。我又回来了。所以一切都解决了。</p><p class="normal">I started working part-time because I almost always had a part-time job while I was at MIT. And it just instantly felt like home. I couldn't believe it. My MIT stuff went completely to hell so I dropped out of school and went to full-time. Then I got settled in at BBN and was much more mellow and got my head in a better place. So the following fall, which would have been my senior year, I actually re-enrolled back at MIT. And I got back in again. So that all worked out.</p>
<p class="normal"><b>Seibel：</b>你觉得麻省理工学院的教育对你的工作经验是一个很好的补充吗？</p><p class="normal"><b>Seibel:</b> Did you feel like your MIT education was a good complement to your work experience?</p>
<p class="normal"><b>Cosell：</b>我在麻省理工学院读本科时参加的编程课程在某种抽象方面对我很有帮助，但实际上并没有教给我很多东西。主要是 BBN 的环境。除了 Steve Weiss 之外，没有人真正指导过我，但我从每个人那里吸取了我需要知道的东西。</p><p class="normal"><b>Cosell:</b> The programming courses that I took when I was an MIT undergraduate stood me in good stead in some abstract way, but didn't actually teach me very much. Mostly what did was the environment at BBN. Nobody, other than maybe Steve Weiss, was really mentoring me, but I was sucking what I needed to know from everybody.</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_527"></a><b>Seibel：</b>显然，当时可用的计算机书籍比现在少，但有没有您觉得特别有用的书籍或您认为程序员应该阅读的书籍？</p><p class="normal"><a></a><b>Seibel:</b> Obviously there were fewer computer books available then than there are now, but are there books that you found particularly useful or books that you think programmers should read?</p>
<p class="normal"><b>Cosell：</b>我很难说程序员现在应该做什么。就如何编程而言，我当时肯定什么都记不起来了。最接近的一次是当我拿到 Knuth 的<i>《计算机编程艺术》的</i>副本并从头到尾消化它们时。但我几乎不推荐它作为人们的教程文本。</p><p class="normal"><b>Cosell:</b> Hard for me to say what programmers should do now. There was certainly nothing I can remember from back then in terms of how to program. The closest was when I got my copy of Knuth's <i>The Art of Computer Programming</i> and sort of digested them from cover to cover. But I would hardly recommend that as a tutorial text for people.</p>
<p class="normal"><b>Seibel：</b>你通读 Knuth？</p><p class="normal"><b>Seibel:</b> You read Knuth straight through?</p>
<p class="normal"><b>Cosell：</b>哦，那是热的东西。那时候我正值壮年。因此，每一卷出版后，我们大部分时间都在阅读并全神贯注。</p><p class="normal"><b>Cosell:</b> Oh, it was hot stuff. I was in my prime back then. So each volume as it came out we mostly read and sucked into our heads cover to cover.</p>
<p class="normal"><b>Seibel：</b>这需要相当多的数学知识。你认为大多数程序员需要能够像那样阅读 Knuth 的封面吗？</p><p class="normal"><b>Seibel:</b> That requires a fair bit of mathematical sophistication. Do you think most programmers need to be able to read Knuth cover to cover like that?</p>
<p class="normal"><b>Cosell：</b>我举了 Knuth 的例子。我不会教学生 Knuth 本身有两个原因。首先，它包含所有这些数学内容，他不仅试图展示算法，而且要推导出它们是好是坏。我不确定你需要那个。我了解一点点，但我不确定我是否需要其中的任何内容。但是，感受一下什么快，什么慢，什么时候快，这是一件很重要的事情，即使你不知道快多少或慢多少。</p><p class="normal"><b>Cosell:</b> I brought up Knuth as an example. I would not teach students Knuth per se for two reasons. First, it's got all this mathematical stuff where he's not just trying to present the algorithms but to derive whether they're good or bad. I'm not sure you need that. I understand a little bit of it and I'm not sure I need any of it. But getting a feel for what's fast and what's slow and when, that's an important thing to do even if you don't know how much faster or how much slower.</p>
<p class="normal">第二个问题是一旦学生对此敏感，他们就变得太聪明了一半。他们开始优化程序的一小部分，因为“这是做 AB 不平衡 2-3 双反向反向指针立方体的理想场所，我一直想写一个这样的东西。” 所以他们花了一两个星期的时间来调整程序中一个不需要任何东西的晦涩部分，现在这部分变得更加复杂并且没有使程序变得更好。因此，他们需要对存在所有这些算法、它们如何工作以及如何应用它们有一个温和的理解。这实际上更多的是如何为您尝试做的工作选择正确的一个，而不是知道这个是<i>n</i>阶加三，而这个只是<i>n</i>阶乘以四。</p><p class="normal">The second problem is once students get sensitive to that, they get too clever by half. They start optimizing little parts of the program because, “This is the ideal place to do an AB unbalanced 2-3 double reverse backward pointer cube thing and I always wanted to write one of those.” So they spend a week or two tuning an obscure part of a program that doesn't need anything, which is now more complicated and didn't make the program any better. So they need a tempered understanding that there are all these algorithms, how they work, and how to apply them. It's really more of a case of how to pick the right one for the job you're trying to do as opposed to knowing that this one is an order <i>n</i>-cubed plus three and this one is just order <i>n</i>-squared times four.</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_528"></a>如果他们对此感兴趣，很高兴知道 Knuth 在那里，但普通人不需要知道这一点。但他们需要知道其中的智慧。他们需要知道数据结构。当他们看到我用 Perl 构建链表时，他们不必感到震惊。当您了解所有这些数据结构时，您可以选择正确的一种。您不必选择最快的。您不必选择最适合实施的那个。实际上，您可以选择最适合您的数据的服务，因为您了解备选方案。不要告诉 Don 我努力了，但他为减少那些组合数学所做的大量令人毛骨悚然的数值计算并没有多大用处。但是天哪，我学到了很多关于数据结构的知识，那是好东西。</p><p class="normal"><a></a>If they're interested in that it's nice to know that Knuth is there, but no ordinary person needs to know that. But they need to know the wisdom in there. They need to know the data structures. They need to not be stunned when they see me building linked lists in Perl. When you know all of those data structures you can pick the right one. You don't have to pick the fastest one. You don't have to pick the one that's cutest to implement. You can actually pick the one that best serves your data because you know the alternatives. Don't tell Don that I fought through but didn't have a lot of use for a lot of the gruesome numerical calculations he did to reduce those combinatorics. But boy, did I learn a lot about data structures, and that was good stuff.</p>
<p class="normal"><b>Seibel：</b>您对众多自学成才的程序员有什么建议吗？</p><p class="normal"><b>Seibel:</b> Do you have any advice for the many programmers who are self-taught?</p>
<p class="normal"><b>Cosell：</b>写了很多程序。这当然对我有用。纵观我上过的各种课程，写程序才是真正做到的。编程不仅仅是为了打发时间，而是具体地说，“我应该学习一些这方面的东西；我为什么不试着写一个小程序来做呢？” 确实如此。</p><p class="normal"><b>Cosell:</b> Write a lot of programs. That's certainly what worked for me. Looking at the various courses I've taken, writing programs is what really did it. Not programming just to while away the hours but specifically, “I ought to learn something about this; why don't I try writing a little program to do it?” That really does it.</p>
<p class="normal">在你完成一些之前，你无法看到这些东西是如何工作的以及它们是如何相互作用的。你不知道哪些编程实践是危险的，直到你看到哪些编程实践让你的程序需要数周的调试时间，然后看到一个优秀的程序员在五分钟内修复它。我不认为你可以从课堂上得到这些。课程可以给你很多东西，但最终编程是一门手艺，你必须通过练习来完善它。</p><p class="normal">You can't see how these things work and how they interact until you've done it some. You don't know what programming practices are dangerous until you've seen which ones make your programs take weeks to debug and then seen a good programmer fix it in five minutes. I don't think you can get that from classes. Classes can give you a lot of stuff, but in the end programming is a craft you have to perfect by plying it.</p>
<p class="normal">如果你幸运的话，你可以在工作中做到这一点。但即使在工作环境中，你在工作中学习，我认为要想真正成为一名优秀的人，你必须学得比你的工作让你学到东西的速度更快。你必须补充你的工作要求你做的事情。如果你的工作需要你做一些 Tcl 的事情，那么仅仅学习足够的 Tcl 来为工作构建接口是勉强足够的。正确的做法是，那个周末开始研究一些 Tcl 的东西，这样到周一早上你就可以非常精通它的机制了。</p><p class="normal">If you're lucky, you can do it at work. But even in a work environment, where you're learning on the job, I think that to really be good you have to learn faster than your job will make you learn things. You have to supplement what your job is asking you to do. If your job requires that you do a Tcl thing, just learning enough Tcl to build the interface for the job is barely adequate. The right thing is, that weekend start hacking up some Tcl things so that by Monday morning you're pretty well versed in the mechanics of it.</p>
<p class="normal"><b>Seibel：</b>与有意识地学习特定技术相比，您自己编写的编程有多少是出于乐趣？</p><p class="normal"><b>Seibel:</b> How much of your own programming did you do for fun versus consciously doing things to learn particular techniques?</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_529"></a><b>Cosell：</b>大多数情况下，我将计算机编程视为完成整洁工作的一种方式，并且我学习了如何编程以使事情发生。有些东西对我来说似乎坏了，但我可以修复。我认为做一些 Lisp 编程会很有趣，不是因为我想学习 Lisp，而是因为桥对面的一些朋友都是 Lisp 大佬，这对我来说有点神秘。所以我写了一些程序，这对我来说似乎是很自然的事情，而不是坐在 Dan Murphy 的膝盖上让他给我讲授 CONS、CDR 和 CAR。</p><p class="normal"><a></a><b>Cosell:</b> Mostly I viewed computer programming as a means to get neat things done and I learned how to program in order to make things happen. There were things that seemed broken to me that I could fix. I thought it would be fun to do some Lisp programming not because I wanted to learn Lisp but because some of my friends across the bridge were big Lisp guys and it was all a little mysterious to me. So I wrote some programs and that just seemed like the natural thing for me to do as opposed to sitting at Dan Murphy's knee and having him give me lectures on CONS and CDR and CAR.</p>
<p class="normal"><b>Seibel：</b>您认为正规计算机科学中有哪些领域对最终想成为程序员的人特别有用？</p><p class="normal"><b>Seibel:</b> Are there areas in formal computer science that you think are particularly useful for people who ultimately want to work as programmers?</p>
<p class="normal"><b>Cosell：</b>有很多事情。我知道很多学校在这方面做得很糟糕，但我认为以抽象形式获得一门很好的面向对象编程课程。我和当地一所大学的一些人争论的一件事是使用 C++ 教授面向对象的编程。我问他们如何确保他们的学生理解面向对象编程的哲学概念与 C++ 实现它的特质和怪异之间的区别。</p><p class="normal"><b>Cosell:</b> There are a bunch of things. I know a lot of schools do a terrible job of it, but I think getting a good course in object-oriented programming in its abstract form. One of the things I fought about with some folks at a local college here was teaching object-oriented programming using C++. I asked how they make sure their students understand the distinctions between the philosophical concept of object-oriented programming versus the idiosyncrasies and weirdnesses of C++'s implementation of it.</p>
<p class="normal">我认为学校可以做的另一件事是 Knuth 中的内容。我周围都是认为链表很神奇的人。他们对这 83 种不同的树一无所知，也不知道为什么有些树比其他树好。他们不了解垃圾收集。他们不了解结构和事物。</p><p class="normal">One other thing I think schools can do is the stuff that's in Knuth. I'm surrounded by people who think linked lists are magic. They don't know anything about the 83 different kinds of trees and why some are better than others. They don't understand about garbage collection. They don't understand about structures and things.</p>
<p class="normal">然后是下一卷：排序和搜索。如果编程语言没有排序功能，他们就不会知道不同类型的排序，或者如何搜索东西，什么时候应该建立索引，我们正在使用的数据库存储东西意味着什么在 B 树中。我认为一门好的课程不会给他们提供背景知识，而不是如何用 C 语言编写链表——这是工匠的事情——但链表在抽象意义上做了什么？</p><p class="normal">Then the next volume: sorting and searching. If the programming language didn't have a sort function, they wouldn't have a clue about different types of sorting, or how to search for things, when you should build indexes, what it means that the database we're using stores things in a B-tree. I think a good course would give them background not in, how do you write a linked list in C—that's a craftsman thing—but what do linked lists do in an abstract sense?</p>
<p class="normal"><b>Seibel：</b>也许你参与的最著名的项目是 ARPANET 的开始，当时你、Will Crowther 和 Dave Walden 为最初的 ARPANET IMP 编写了软件。这是怎么来的？</p><p class="normal"><b>Seibel:</b> Perhaps the most famous project you worked on was the beginning of the ARPANET, when you, Will Crowther, and Dave Walden wrote the software for the original ARPANET IMPs. How did that come about?</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_530"></a><b>Cosell：</b>在 Frank Heart 的团队中，我们的部门，Frank 将他所有的程序员人员视为基本稳定。他挑选并选择了如何将人们从一个项目转移到另一个项目。当我的项目用完时，弗兰克会弄清楚我接下来应该做什么。与开始飞往华盛顿并撰写提案的真正的咨询人员相反；我不必那样做。不知何故，弗兰克决定让我担任 IMP 项目的第三人。</p><p class="normal"><a></a><b>Cosell:</b> In Frank Heart's group, our division, Frank viewed all of his programmer guys as this basic stable. He picked and chose how to move people from project to project. When my projects ran out, Frank would figure out what I should work on next. As opposed to the real consulting guys who would start flying to Washington and writing proposals; I was spared having to do that. Somehow, Frank had decided that I was to be the third guy on the IMP project.</p>
<p class="normal">68 年秋天，当 Dave 和 Willy 以及那些人已经开始时，我正在做另一个项目。我认为合同已经授予，但要到一月份才会开始。当我加入这个项目时，并没有做太多事情。我认为他们已经删除了一些代码，但还没有真正循环。当我加入时，Dave 和 Willy 已经开始构思系统的组织方式，并采纳了他们开始编写的大块头。我只是适应并为自己索取了一两件。我们都有不同的技能，但我们都想知道每一行代码是如何为这个东西工作的，因为它不是一个大程序。复杂，但没那么大。</p><p class="normal">I was working on another project in the fall of '68 when Dave and Willy and those guys had started. I think the contract had been awarded but wasn't going to start until January. When I joined the project, not much was done. I think they had scraped out some of the code, but nothing was really cycling yet. When I came on board and Dave and Willy had started blocking out how the system was going to be organized and had taken hunks that they were starting to write. I just fit in and claimed a piece or two for myself. We all had different skills but we were all going to know how every line of code worked for the thing because it wasn't that big a program. Complicated, but not that big.</p>
<p class="normal">而且我知道当我加入时他们不可能完成很多工作，因为他们仍在进行离线组装，这涉及将纸带带到有 516 的霍尼韦尔房间并将纸带穿过，通过以下方式制作组装清单它打孔了一整盒纸带，然后他们不得不将纸带带到另一台机器上，因为霍尼韦尔机器上没有行式打印机来制作装配清单。为此进行软件管理真的很麻烦。我在这个项目上做的第一件具体事情之一是为我们的 PDP-1 编写了一个交叉汇编器。</p><p class="normal">And I know they couldn't have gotten very much done when I joined because they were still doing offline assemblies, which involved taking a paper tape into the Honeywell room where there was a 516 and running paper tapes through, making an assembly listing by having it punch an entire box of paper tape, which they would then have to carry to another machine because there was no line printer on the Honeywell machine to make an assembly listing. It was really pretty cumbersome doing the software management for that. One of the first concrete things I did on the project was I wrote a cross assembler for our PDP-1.</p>
<p class="normal">然后在 PDP-1 上，我们可以编辑文件、组合文件、制作文件的组合列表、在上面运行 TECO 宏。唯一被打孔的是二进制可执行程序的相对较小的纸带，然后它将进入霍尼韦尔机器。</p><p class="normal">Then on the PDP-1 we could edit the files, assemble the files, make assembly listings of the files, run TECO macros over things. The only thing that got punched out was the comparatively small paper tape of the binary executable program, which would then go into the Honeywell machine.</p>
<p class="normal"><b>Seibel：</b>这是编写 IMP 软件的最大挑战：让它运行得更快吗？</p><p class="normal"><b>Seibel:</b> Was that the biggest challenge of writing the IMP software: making it go fast?</p>
<p class="normal"><b>科塞尔：</b>哦，这很有趣。好的，我们等着瞧。我们并没有想太多它有多大，因为我们的想法是系统将要<a id="OEBPS/Chapter14.html.page_531"></a>必须有很大的缓冲空间。而且代码不会那么大。如果代码比压缩后的代码大 10%，那就意味着缓冲区会少一些。所以我们不太担心计算每件事需要多少指令。</p><p class="normal"><b>Cosell:</b> Oh, that's interesting. Well, let's see. We didn't think very much about how big it was because the idea was that the system was going to <a></a>have to have a lot of space for buffering. And the code wasn't going to be that big. And if the code was, say, ten percent larger than it could be if you squeezed it down, that would just mean that there would be a few fewer buffers. So we weren't quite so much worried about counting how many instructions everything took.</p>
<p class="normal"><b>Seibel：</b>就需要占用多少空间而言。</p><p class="normal"><b>Seibel:</b> In terms of how much space it would take.</p>
<p class="normal"><b>科塞尔：</b>对。多少空间。但我们关心的是速度，我们是否要跟上带宽。你如何组织一个系统，使其优雅地降级，特别是，以一种可以从洞中挖出自己而不是崩溃和死亡的方式降级？</p><p class="normal"><b>Cosell:</b> Right. How much space. But we were concerned with speed, whether we were going to keep up with the bandwidth. And how do you organize a system so that it degrades gracefully and, in particular, degrades in a way that it can dig itself out of a hole as opposed to just collapsing and dying?</p>
<p class="normal">第二件事就是让系统正常工作。有很多未经尝试、未经测试的东西。这些协议会起作用吗？威尔提出了一些关于路由算法的想法——这行得通吗？还有很多潜在的问题。关于拥塞控制的问题。我们是否确定如果世界上每个人都向一个可怜的人发送数据包，我们实际上会按正确的顺序拒绝这些数据包并将自己挖出来？</p><p class="normal">The second thing was just making the system work. There was a lot of untried, untested stuff. Were the protocols going to work? Will had come up with some ideas for the routing algorithm—was that going to work? There were still a lot of underlying questions. A question about congestion control. Did we know for sure that if everybody in the world sent packets to one poor guy that we would actually refuse the packets in the right order and dig himself out?</p>
<p class="normal"><b>Seibel：</b>所以这基本上是因为以前没有人尝试过解决这个问题。</p><p class="normal"><b>Seibel:</b> So that was basically because nobody had ever tried to solve this problem before.</p>
<p class="normal"><b>科塞尔：</b>完全正确。当时这是一个研究项目——很多理论。很多人写过论文。许多人认为他们知道发生了什么。那时，橡胶必须与路面接触。我们必须实际查看排队论是否有效，路由算法是否会波动。</p><p class="normal"><b>Cosell:</b> Exactly right. It was a research project at that point—a lot of theory. A lot of people had written dissertations. A lot of people thought they knew what was going on. At that point, the rubber had to meet the road. We had to actually see whether the queuing theory was going to work, whether the routing algorithm could oscillate.</p>
<p class="normal">第三大挑战就是如何调试这个东西。突然之间，您无法与俄亥俄州的辛辛那提通话。什么地方出了错？你怎么想出来的？你打电话给俄亥俄州的辛辛那提，你会在凌晨 3:00 遇到一个昏昏欲睡的守夜人，他走到角落里这个闪烁的小盒子前。他在看什么？你做什么工作？即使您恢复了系统，出了什么问题？你如何解决它？记住，我是一个大事不崩溃，事情会继续工作的人。</p><p class="normal">The third big challenge was simply how do you debug the thing. All of a sudden, you can't talk to Cincinnati, Ohio. What went wrong? How do you figure it out? You call Cincinnati, Ohio, and you get a sleepy night watchman at 3:00 in the morning walking up to this little blinking box in the corner. What does he look at? What do you do? And even if you get the system back up, what went wrong? How do you fix it? Remember, I was a big things-don't-crash, things-are-going to-keep-working guy.</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_532"></a>我知道让 Will 印象深刻的一件事是有一些他们找不到的错误，而我找到了。事实证明这是调制解调器某些协议处理中的错误，它在错误的时间发送了错误的数据包。我把一系列补丁放在一起，这样我就可以在数据包中放置一个标记，当它看到那个特定的数据包时，它会在系统上安装一个补丁来寻找正在发生的其他事情，一旦它看到它，它就会停止系统。然后一旦它停止了系统，我们就可以使用调试器来弄清楚发生了什么。完成后，我花了大约两分钟的时间才找到错误，因为有问题的数据包仍在内存中；它没有被重写。</p><p class="normal"><a></a>I know that one of the things that impressed Will was there was some bug that they could not find and I found it. It turns out it was a bug in the handling of some protocol for the modems and it was sending the wrong packet at the wrong time. I put together a series of patches so that I could put a marker in a packet and when it saw that particular packet, it installed a patch on the system that looked for this other thing happening and as soon as it saw it, it stopped the system. Then once it stopped the system, we could use debuggers to figure out what was going on. Once I had done that, it took about two minutes to find the bug because the offending packet was still in memory; it hadn't been written over.</p>
<p class="normal">我不记得确切的问题，但这是其中一个不是致命的问题。有一个错误的指针损坏了内存并且损坏没有造成任何问题，但是成千上万的机器周期之后，程序崩溃了，因为一些数据结构被损坏了。但事实证明数据结构一直都在使用，所以我们不能输入“发生变化时停止”的代码。所以我考虑了一会儿，最终我放入了这个两阶段或三阶段的补丁，当第一件事发生时，它启用了另一个补丁，该补丁通过代码的不同部分。当发生这种情况时，它启用了另一个补丁来放入另一个东西。然后当它注意到发生了一些不好的事情时，它冻结了系统。我设法想出如何通过动态修补 hack 将它延迟到正确的时间，其中通过代码的一条路径被动态修补到另一段代码。我很幸运，因为我猜对了，我们立即找到了问题所在。</p><p class="normal">I don't remember the exact problem, but it was one of these problems that was not fatal. There was a bad pointer corrupting memory and the corruption wasn't causing any trouble, but thousands and thousands of machine cycles later, the program crashed because some data structure was corrupt. But it turns out the data structure was used all the time, so we couldn't put in code that says, “Stop when it changes.” So I thought about it for a while and eventually I put in this two- or three-stage patch that when this first thing happened, it enabled another patch that went through a different part of the code. When that happened, it enabled another patch to put in another thing. And then when it noticed something bad happening, it froze the system. I managed to figure how to delay it until the right time by doing a dynamic patching hack where one path through the code was patched dynamically to another piece of the code. And I was lucky because I guessed the right thing and we immediately found the problem.</p>
<p class="normal"><b>Seibel：</b>是什么促成了这种直觉？</p><p class="normal"><b>Seibel:</b> What enables that kind of intuition?</p>
<p class="normal"><b>Cosell：</b>在这样的系统上我非常擅长，比如 IMP 系统，当我全神贯注时，或者 PDP-1 分时系统，即使该系统是多道程序、多层、中断驱动的系统，我脑子里有系统的所有动态。我知道事情应该发生的顺序。当事情不应该发生时，我不知何故知道什么不应该发生。这让我可以建立一个模型，“这件事怎么可能发生？”</p><p class="normal"><b>Cosell:</b> On the systems I'm very good with like that, like the IMP system when I had it all in my head, or the PDP-1 time-sharing system, even though the system is a multiprogramming, multilayered, interrupt-driven system, I have all the dynamics of the system in my head. I know what order things are supposed to happen. I know somehow what's not supposed to happen, when things are supposed to not be happening. That lets me build up a model for, “How could this thing possibly have happened?”</p>
<p class="normal">至少其中一些是双机问题，​​这也需要一些奇怪的创造力才能找到。也就是说，问题是我的机器出了问题，而它的证据却出现在你的机器上。我不能<a id="OEBPS/Chapter14.html.page_533"></a>停止——我的机器已经处理了 6,000 个以上的数据包，当你的机器遇到说“我有一个虚假数据包”的陷阱时。那你现在怎么办？我们三个人一起努力，想方设法追踪这些问题并修复它们，基本上让系统变得非常可靠。</p><p class="normal">And at least some of those were two-machine problems, which also required some odd creativity to find. That is, the trouble is something goes wrong on my machine and the evidence of it shows up on yours. I can't <a></a>stop—my machine has already processed 6,000 more packets by the time yours hits the trap that says, “I got a bogus packet.” So now what do you do? We'd work through, the three of us, finding ways to track those things down and fix them and basically make the system pretty solid.</p>
<p class="normal"><b>Seibel：</b>你是否构建了调试代码？</p><p class="normal"><b>Seibel:</b> Did you build in debugging code?</p>
<p class="normal"><b>科塞尔：没有</b>。</p><p class="normal"><b>Cosell:</b> No.</p>
<p class="normal"><b>Seibel：</b>所以你有很多不同的棘手错误，你必须以独特的方式追踪每一个错误？</p><p class="normal"><b>Seibel:</b> So you had many different tricky bugs, each of which you had to track down in a unique way?</p>
<p class="normal"><b>Cosell：</b>据我所知，我们没有构建任何调试工具。我的意思是，这些天来，我总是指出你必须编写程序以便它们可以测试。使程序可测试的唯一方法是在编写第一行代码之前考虑这一点。如果您等到程序开始工作，您就无法改造有效工作的块点和断言点以及测试点并做正确的事情。</p><p class="normal"><b>Cosell:</b> As far as I can remember, we didn't build in any debugging stuff. I mean, these days, I always point out that you've got to make programs so that they are testable. And the only way to make a program testable is to think about that before you write the first line of code. You can't retrofit block points and assert points and test points that work efficiently and do the right thing if you wait until the program is working.</p>
<p class="normal">但我敢肯定，我们没有考虑过这些。我们只是想写这个非常复杂的实时东西，必须要快。这是一个足够困难的问题。我们没有进行任何真正的一致性检查；谁愿意为此浪费时间？所以这些东西都是临时补丁。跳到内存的备用部分，运行一些手工编码的东西来检查这个或那个或另一个，跳回去，然后继续。</p><p class="normal">But I'm sure that we didn't think about any of that. We were just trying to write this incredibly complicated real-time thing that had to be fast. It was a hard enough problem. We didn't put in any real consistency checks; who would want to waste time for that? So these things were all ad hoc patches. Jump off into a spare part of memory, run through some hand-coded stuff to check this or that or the other, jump back, and continue.</p>
<p class="normal">事实上，它甚至被正式化了。其中一件事——我很确定我写了它——是一个补丁程序，你可以在其中向系统提交补丁，它会从循环中拉出一个缓冲区并用它来保存代码并链接到它然后链接背部。我们过去常常做那种事情，但都是临时的。我们会发现一些错误，我们会绞尽脑汁想弄清楚它可能是什么。</p><p class="normal">In fact, it was even formalized. One of the things—I'm pretty sure I wrote it—was a patcher where you could submit a patch to the system and it would pull one buffer out of circulation and use it to hold the code and link up to that and then link back. We used to do that kind of stuff but it was all ad hoc. We would find some bug and we would crack our heads trying to figure out what it could be.</p>
<p class="normal">很多时候，仅仅了解错误是什么就能让您找到正确的代码段。现在你更批判性地阅读它并修复它。其他时候，您需要收集更多数据。其他时候，您需要用头撞墙，试图抓住能说明问题的一点点证据。我们做了其中的一部分。</p><p class="normal">A lot of the times, just understanding what the bug is points you at the right piece of code. Now you read it more critically and you fix it. Other times, you need to collect more data. Other times, you need to bang your head against the wall trying to catch that little bit of evidence that illuminates the thing. And we did some of all of that.</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_534"></a>请记住，我们正在一台没有控制台的机器上运行，什么都没有。一般来说，补丁会隐藏一些数据然后停止机器。然后我们可能会使用前面板，因为我不认为我们可以从终端运行不会破坏机器的调试器。因此，我们会从前控制台查看适当的内存区域，进行检查和存储以弄清楚发生了什么。</p><p class="normal"><a></a>Remember, we're running on a machine that's got no console, no nothing. In general, the patches would stash away some data and then halt the machine. Then we would probably use the front panel because I don't think there was a debugger we could run from the terminal that wouldn't trash the machine. So we'd look through the appropriate areas of memory from the front console, doing examines and deposits to go figure out what was going on.</p>
<p class="normal"><b>Seibel：</b>那真的是一排灯吗？</p><p class="normal"><b>Seibel:</b> So that's literally a row of lights?</p>
<p class="normal"><b>Cosell：</b>是的，一排灯。每盏灯位。</p><p class="normal"><b>Cosell:</b> Yeah, a row of lights. Bit per light.</p>
<p class="normal"><b>Seibel：</b>然后拨动开关输入地址？</p><p class="normal"><b>Seibel:</b> And toggle switches to put in the address?</p>
<p class="normal"><b>科塞尔：</b>对。其实这样更好。PDP-1 有拨动开关。我记得，这个有按钮。</p><p class="normal"><b>Cosell:</b> Right. Actually, this is better. The PDP-1 had toggle switches. This one had, as I recall, push buttons.</p>
<p class="normal"><b>Seibel：</b>你们三个是如何合作的？</p><p class="normal"><b>Seibel:</b> How did the three of you work together?</p>
<p class="normal"><b>Cosell：</b>我记得做的一件事显示了一点风格差异。威尔是一位出色的直觉程序员。大多数人根本无法理解如何做的所有最难的问题，他都会想办法去做。</p><p class="normal"><b>Cosell:</b> One of the things that I remember doing shows a little bit of the style difference. Will was a brilliant intuitive programmer. All of the hardest problems that most people couldn't understand how to do at all, he would find ways to do.</p>
<p class="normal">就像 Adventure 中他用 Fortran 编写的 AI 引擎一样。路由算法和 IMP 系统动态中的各种东西，都是威尔拼凑起来的。实时系统的一个特点是一切都必须超时。你不能永远等待任何事情，因为在实时系统中没有永远。</p><p class="normal">Like the AI engine in Adventure that he did in Fortran of all things. And the routing algorithm and all sorts of stuff in the dynamics of the IMP system, Will had cobbled together. One of the things about a real-time system is everything has to be timed out. You can't wait forever for anything because there's no forever in a real-time system.</p>
<p class="normal">越来越多的超时集合在整个程序中不断增长。我试图理解他们，但很难做到。所以在我对源代码的一次修订中，我试图为所有的超时做一个代数。例如，获得消息确认的总超时时间应该是单个数据包传输网络超时时间的八倍，再加上一些东西。或者，一条消息跟踪网络的总超时时间是网络的最大直径乘以数据包完成一跳的最长时间。</p><p class="normal">And a bigger and bigger collection of time-outs were growing up all over the program. I tried to understand them and had a hard time doing it. So in one of my revisions of the source code, I tried to make an algebra for all of the time-outs. For example, the total time-out to get an acknowledgement for a message should be eight times the time-out for a single packet to transit the net plus something. Or, the total time-out for a message to track the net is the maximum diameter of the net times the maximum time for the packet to make one hop.</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_535"></a>我有点想找出威尔在把东西放在一起时头脑中的基本常量是什么。当两次暂停时间相同时，它们应该是相同的还是巧合的相同？谁知道？当你想改变其中一个常量时，你需要改变多少地方？如果您动态地发现您等待某事发生的时间不够长，而它在不该发生的时候超时了，您就会知道您不能只更改一次超时，因为这些事情是相互关联的。</p><p class="normal"><a></a>I was sort of trying to find out what the basic constants in Will's mind were when he put things together. When two time-outs had the same time were they supposed to be the same or were they coincidentally the same? Who knows? How many places do you have to change when you want to change one of the constants? If you discover dynamically that you're not waiting long enough for something to happen and it is timing out when it shouldn't, you know that you can't just change that one time-out because these things are interrelated.</p>
<p class="normal">所以我做了一大堆尖锐的符号定义，基本上，试图找到最小数量的独立常数。我记得这样做是因为那真的很可怕。这是我涉足的地方之一，实际上没有人理解，因为很多常量是 Will 凭直觉输入的，我们已经调整到一个接一个地工作。超时不够大，所以我们会把它变大，不是通过基本原理或代数来做，而是调整它直到它起作用。</p><p class="normal">So I made a whole bunch of sharp sign defines, basically, to try to find the smallest number of independent constants. I remember doing that because it was just really scary. It was one of the places where I was dabbling in things that really nobody understood because a lot of those constants Will had put in intuitively and we had tuned to make work, one by one. The time-out isn't big enough and so we would make it bigger, not doing it by first principles or algebra, but just tuning it until it works.</p>
<p class="normal"><b>Seibel：</b>您是通过这种方式发现错误，还是只是把它放在更稳固的基础上，以便随着事情的变化，您可以以不需要无休止的重新调整的方式进行更改？</p><p class="normal"><b>Seibel:</b> Did you find bugs that way or did you just put it on a more solid footing so that as things changed, you could change things in a way that wouldn't require endless retuning?</p>
<p class="normal"><b>Cosell：</b>我不记得发现任何错误。但毫无疑问，有些地方的计时器现在具有与过去不同的值，但在操作上并不重要，只是在防御上有所不同。如果需要，您可以更改它；确实如此，它使程序更容易理解。我讨厌有一个程序，其中有 200 个随机选择的独立常量散布在整个程序中，并且知道它们与网络的心跳有关。我认为它简化了一些代码。它使人们更容易理解正在发生的事情。它还让我们可以使用更多的符号常量。八倍直径加上脉冲时间或类似的东西是可以理解的。</p><p class="normal"><b>Cosell:</b> I don't recall finding any bugs. But there were undoubtedly some places where there were timers that now had different values than they used to, but not operationally significant ones, just defensively different ones. It was less so that you could change it if you have to; really it was so that it made the program easier to understand. I hated having a program that had 200 randomly chosen independent constants scattered throughout it and knowing that they have something to do with the heartbeat of the network. I think it simplified some of the code. It made it easier to fathom what was going on. It also let us use more symbolic constants. Eight times diameter plus pulse time or something like that would be understandable.</p>
<p class="normal">威尔是个有想法的人。我记得有一次我向 Frank Heart 抱怨过这个问题，他说他必须开箱即用地从事这些项目，因为 BBN 正在做很多非常前沿的事情，而且他非常善于寻找方法来做一些不可能的事情以前做过。</p><p class="normal">Will was sort of the advanced idea man. I remember complaining to Frank Heart about this once, that he got to work on the projects right out of the box because BBN was doing a lot of very cutting-edge stuff and he was terrific at finding ways to do things that couldn't be done before.</p>
<p class="normal">他不太擅长 100% 完成确定的代码。他真的很擅长获得 75% 或 80% 的非常好的代码，这些代码最有效<a id="OEBPS/Chapter14.html.page_536"></a>的时间。我想，Will 已经继续研究 TIP，而 Dave 和我仍在研究 IMP 系统，那时我重新设计了路由算法，因为它有一些有趣的常量，而且我不理解它。所以它仍然是 Will 的路由算法，但用我的风格重新编码。而且我认为它更坚固一些。至少我明白它是否会震荡，<i>为什么</i>会震荡，因为<i>我</i>让它震荡。</p><p class="normal">He was not as good at getting 100 percent done nailed-down code. He was really good at getting 75 or 80 percent pretty good code that worked most <a></a>of the time. Will had already gone on to, I think, the TIP, and Dave and I were still working on the IMP system and that's when I redid the routing algorithm because it had funny constants and I didn't understand it. So it was still Will's routing algorithm but recoded with my style. And I think it was a little more solid. At least I understood if it was going to oscillate, <i>why</i> it was going to oscillate, because <i>I</i> made it oscillate.</p>
<p class="normal">Will Crowther 和我完全不同的地方之一——我不得不投入数小时的工作，即使在那时他仍持怀疑态度——他相信当你重新组装一个程序时，你添加的错误要多于你删除的错误。因此，他过去常常在笔记本上记上一页又一页的补丁。只要他能在必须重新组装之前修补现有系统，他就会去。这些补丁是补丁上的补丁，而且非常复杂，以至于他的预测常常是一个自我实现的预言。很难，毕竟，把它弄得恰到好处，以至于它原来是补丁的实际意思。</p><p class="normal">One of the places where Will Crowther and I absolutely differed—and I had to put in hours and hours of work and even then he was skeptical—was he believed that when you reassemble a program you add more bugs than you remove. So he used to keep notebooks with pages and pages of patches. He would go as long as he could patching the existing system before he had to reassemble. Those patches were of patches on top of patches and so complicated that often his prediction was a self-fulfilling prophecy. It was hard, after all of that, to get it just right so that it turned out to be what the patches were actually saying.</p>
<p class="normal"><b>Seibel：</b>所以你有一个可以提供给汇编器的原始源列表——</p><p class="normal"><b>Seibel:</b> So you had an original source listing that you could feed to an assembler—</p>
<p class="normal"><b>Cosell：</b>对，还有一个正在运行的二进制映像。然后我们会有一个纸带——或者有时我们只是用手做——在这里跳到一个小区域，这三行代码被这五行代码替换，然后它转移回随后的事情，所以当你执行这段代码时，它会去补丁，执行一些东西，然后回来。</p><p class="normal"><b>Cosell:</b> Right, and a binary image that was running. Then we would have a paper tape—or sometimes we'd just do it by hand—that plants a jump here out to a little area where these three lines of code were replaced by these five lines of code and then it transfers back to the subsequent thing so when you execute this code it goes off to the patch, executes some stuff, and comes back.</p>
<p class="normal"><b>Seibel：</b>所以纸带上有补丁的二进制版本？</p><p class="normal"><b>Seibel:</b> So the paper tape held the binary version of the patch?</p>
<p class="normal"><b>科塞尔：</b>是的。后来，当我构建一个具有我非常喜欢的检查和存款功能的小型交互式调试器时，我们实际上可以构建一个看起来像“转到位置 12785，值，值，值，值。空行。转到位置 12832，值，值，值，值，值。” 如果您必须从头开始加载程序，那么您加载了程序，然后在完成后加载了补丁磁带。</p><p class="normal"><b>Cosell:</b> Yeah. Later on, when I built a little interactive debugger that had the examine and deposit functions I was so fond of, we actually could build a little text tape that looked like, “Go to location 12785, value, value, value, value. Blank line. Go to location 12832, value, value, value, value, value.” If you had to load the program from scratch you loaded the program and then you loaded the patch tape when you were done.</p>
<p class="normal"><b>Seibel：</b>所以在那个时候你实际上没有任何源代码可以组装成运行二进制文件的当前状态？</p><p class="normal"><b>Seibel:</b> So at that point you didn't actually have any source code that would assemble into the current state of the running binary?</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_537"></a><b>科塞尔：</b>完全正确。麻烦之一是我们有不同的列表副本。其中一个列表将在代码中的某个位置有一个墨水标记，其中两行将被划掉，旁边是替换代码。现在，列表的每个副本都得到了吗？威尔很好，因为他有他的笔记本，说了算的不是特定的清单，而是他的笔记本。那是他的方法。</p><p class="normal"><a></a><b>Cosell:</b> Exactly right. One of the troubles was we had different copies of the listings. One of the listings will have an inked mark at some place in the code where two lines will be crossed out and next to it the replacement code. Now, did every copy of the listing get that? Will was very good because he had his notebook and the final say was not a particular listing but his notebooks. That was his approach.</p>
<p class="normal">我的方法是系统应该始终开箱即用。我不想在装配清单上做标记。当我第一次参与这个项目时，很难把他的所有补丁都放进去。我们会工作一整天，然后我会连夜编辑和重新组装系统，这样第二天早上我们就有了另一盘干净的磁带，然后我们就可以开始了。事实证明，当你在一夜之间完成它时，你只有两个或三个更改，并且它们被定位，因此你可以在更改代码时阅读它并且它是有意义的。当然，这马上就定下来了。</p><p class="normal">My approach was that the system should always run out of the box. I do not want to mark on the assembly listing. When I first came on the project it was hard to get all of his patches in. We would work all day and then I would edit and reassemble the system overnight so that the next morning we had another clean tape and we would start with that. It turns out when you're doing it overnight you only have two or three changes and they're located so you can read the code as you change it and it makes sense. Of course, that settled down right away.</p>
<p class="normal">因此，除非补丁错误，否则我们几乎再也不会遇到修复错误并创建新错误的问题。但威尔和我对此意见不一，因为他真的非常喜欢打补丁，如果可以的话，他会远离汇编程序，部分原因是这花了很多时间，而他可以打补丁并继续下去，部分原因是他没有相信这个周期，因为编辑太可怕了。</p><p class="normal">So we almost never again had a problem of fixing a bug creating a new one other than if the patch was wrong. But Will and I were at odds about that because he was really very fond of patching and staying away from assembler if you could, partly because it took a lot of time whereas he can patch and just go on, and partly because he didn't trust the cycle because the editing was too scary.</p>
<p class="normal"><b>Seibel：</b>您认为您在 IMP 上的工作是您重要的技术成就之一吗？</p><p class="normal"><b>Seibel:</b> Do you consider your work on the IMP one of your important technical achievements?</p>
<p class="normal"><b>Cosell：</b>奇怪的是没有。这是一个有趣的、困难的程序，但我写了 Doctor，我在做 Lisp 的东西，我是医院计算机系统的沙皇。当然，那时我所做的最巧妙的事情就是理解这个尖端分时系统中的每一行代码。这东西只是一个小型的独立通信处理器。它没有我们在 PDP-1 上那么多的中断通道。当您只有 32 个交换槽并且有 40 个人登录时，它不必处理您要做什么。</p><p class="normal"><b>Cosell:</b> Oddly enough no. It was an interesting, hard program, but I'd written Doctor, I was doing Lisp stuff, I'd been czar of the hospital computer system. Certainly at that point the neatest thing I had worked on was understanding every line of code in this cutting-edge time-sharing system. This thing was just a little stand-alone communications processor. It didn't have as many interrupt channels as we had on the PDP-1. It didn't have to deal with what do you do when you only have 32 swapping slots and you have 40 people logged on.</p>
<p class="normal">我们三个人相处得很好，所以很有趣也很有挑战性。调试和实施它有些事情很难做到。但很难说我会认为这是我职业生涯的顶峰。这只是下一个节目。另一件虎头蛇尾的事情<a id="OEBPS/Chapter14.html.page_538"></a>IMP 系统是多么的有界。PDP-1 基本上是硬的。这是一个分时系统，它必须随着时间的推移而发展。</p><p class="normal">The three of us got along famously, so it was fun and it was challenging. There were things about debugging it and implementing it that were hard to do. But hard to say that I would've thought it was the crown of my career. It was just the next program. The other thing that was anticlimactic about <a></a>the IMP system was how bounded it was. The PDP-1 was basically hard. It was a time-sharing system and it had to evolve over time.</p>
<p class="normal">IMP 系统如此简洁的地方在于我们如何以如此有纪律的方式做到这一点。他们在一月份正式开始；我在二月份加入了这个项目，并在九月份完成了。“完成”的价值很小——我们仍在努力修复错误和其他东西，但它在 9 月发布并且没有停止。不久之后，Will 开始了他的下一个项目，Dave 和我继续进行，新人进来了。</p><p class="normal">The thing about the IMP system that was so neat is how we did it in such a disciplined fashion. They started officially in January; I joined the project in February and in September it was done. Small value of “done”—we were still working on it fixing bugs and stuff but it got released in September and didn't stop. Not long after that Will went on to his next project and Dave and I continued with it and somebody new came in.</p>
<p class="normal">我必须给予很多信任的人是 Frank Heart。我不明白他是怎么想出让我们像以前一样疯狂的管理风格的。我很难记住一次软件审查会议。我很难记得当我们三个人脑子里都有程序并且不会被很多东西打扰时被麻烦的文档。有一定程度的信任和信心，我们三个人会做这件事，他让我们一个人呆着。回想起来，当过项目经理，这是一件了不起的事情；那太奇怪了。没有每周的员工会议，董事会上没有 PERT 图。威利当然会跟踪需要完成的工作以及我们发现的错误和其他内容，但缺乏监督结构令人印象深刻。</p><p class="normal">The person I have to give a lot of credit to is Frank Heart. I don't understand how he hit on the management style of mostly letting us be as crazy as we were. I'm hard-pressed to remember a software-review meeting. I'm hard-pressed to remember being hassled for documentation when the three of us had the program in our heads and couldn't be bothered with a lot of that stuff. There was a level of trust and confidence that the three of us were going to do this thing and he left us alone. In retrospect, having been a project manager, that's a stunning thing; that's just bizarre. No weekly staff meetings, no PERT charts on the board. Willy was of course keeping track of what needed to be done and bugs we found and stuff, but the lack of oversight structure for that was pretty impressive. Throwing us together and telling us to go do it was, I think, a stroke of management bravery.</p>
<p class="normal">弗兰克在其他项目中所做的另一件事是设计审查。他进行了最可怕的设计审查，而我实际上把这个想法发扬光大了。人们会对他的设计评论感到震惊。这有点像为论文做口头报告。他会在观众中精心挑选一批人，而你必须展示你的设计。他挑选的人总是很好的。让他的设计审查如此可怕的是他知道你什么时候在虚张声势。</p><p class="normal">Another thing that Frank did, on other projects, was design reviews. He had the most scary design reviews and I actually carried that idea forward. People would quake in their boots at his design reviews. This was sort of like taking your orals for your dissertation. He would have a hand-picked collection of people in the audience and you would have to present your design. The people he picked were always good. The thing that made his design reviews so scary is he knew when you were bluffing.</p>
<p class="normal">我敢肯定，您已经完成了设计评审，但您在其中的某些部分做得并不好，因此您可以略过该部分。你认为你做对了，但你并没有真正进行分析，所以你不太清楚发生了什么。他有一种直觉，而且他有一个很好的团队，在你虚张声势的时候抓住你，在你没有想清楚的时候抓住你。</p><p class="normal">I'm sure you've done design reviews where you didn't work on some part of it real well and so you kind of slide past that part. You think you got this right but you didn't really do the analysis so you don't know quite what's going on. He had an instinct, and it was abetted by having a good crew in there, of catching you when you were bluffing, catching you when you hadn't thought it through.</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_539"></a>你做得非常好的部分几乎没有被提及。我们都“哦”了一声。但是您最不满意的部分，我们会重点关注。我知道有些人对此感到害怕。问题是，如果你是一个没有安全感的程序员，你会认为这是一次攻击，而你现在被证明是无能的，生活对你来说很糟糕。</p><p class="normal"><a></a>The parts that you did absolutely fine hardly got a mention. We all said, “Oh.” But the part that you were most uncomfortable with, we would focus in on. I know some people were terrified of it. The trouble is if you were an insecure programmer you assumed that this was an attack and that you have now been shown up as being incompetent, and life sucks for you.</p>
<p class="normal">现实——我必须偶尔站在谈判桌的好一边——事实并非如此。设计审查是为了帮助您正确制定程序。对于您做对的部分，我们无能为力，现在您得到的是 BBN 的四位最聪明的人帮助您修复您没有考虑过的部分。告诉我们为什么你没有考虑清楚。告诉我们你在想什么。你做错了什么？我们有 15 分钟的时间来帮助您。</p><p class="normal">The reality—I got to be on the good side of the table occasionally—was it wasn't. The design review was to help you get your program right. There's nothing we can do to help you for the parts that you got right and now what you've got is four of the brightest people at BBN helping you fix this part that you hadn't thought through. Tell us why you didn't think it through. Tell us what you were thinking. What did you get wrong? We have 15 minutes and we can help you.</p>
<p class="normal">这需要对你作为一名工程师的技能有足够的信心，说，“嗯，这太棒了。这是我的问题。我不知道该怎么做，我希望你们不会注意到，所以你们会在设计审查时给我一个 OK。” 隐含的回答是，“你当然会在设计评审中获得 OK，因为它看起来不错。让我们在所有好人都在这里的时候解决这个问题，这样你就不会再纠结一两周了。”</p><p class="normal">That takes enough confidence in your skill as an engineer, to say, “Well that's wonderful. Here's my problem. I couldn't figure out how to do this and I was hoping you guys wouldn't notice so you'd give me an OK on the design review.” The implicit answer was, “Of course you're going to get an OK on the design review because it looks OK. Let's fix that problem while we've got all the good guys here so you don't flounder with it for another week or two.”</p>
<p class="normal">你想通过设计审查做的是仔细检查他认为他认为正确的部分他确实正确，并可能让他对他不正确的部分有一些了解。一旦我意识到这一点——我只有 20 或 21 岁——这似乎是非常正确的，对高级人才进行审查的明显好处。</p><p class="normal">What you wanted to do with a design review was double-check that the parts that he thought he had right he did have right and potentially give him some insight on the parts that he didn't. Once I apprehended that—I was only like 20 or 21—that seemed so obviously right, such an obvious good use of the senior talent doing the review.</p>
<p class="normal">当然，对客户的设计审查是不同的。对客户的设计审查就是，“我们都知道。一切都会变得完美。” 但内部设计审查是一个机会，我总是很惊讶有多少人对设计审查的前景感到绝对害怕。这些人都是好人，但他们只是说，“我的设计将被撕成碎片。” 很难让他们相信即使它有任何好处也不会被撕成碎片，这些家伙没有报复心。他们将尝试延续 BBN 的神秘感，让它一切顺利。</p><p class="normal">Of course, the design review for the client is different. The design review for the client is all, “We know it all. It's all going to be perfect.” But the internal design review was an opportunity and I was always surprised by how many people were absolutely scared about the prospect of a design review. These are good people but they just said, “My design is going to be torn to shreds.” It's hard to convince them that it won't get torn to shreds if it's any good, that these guys are not vindictive. They're going to try to continue the BBN mystique of getting it all right.</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_540"></a>也很难告诉他们，在您的职业生涯中，您再也不会遇到愿意花一个小时帮助您思考设计的这些人。之后你将要靠自己了，那真是一次美妙的经历。</p><p class="normal"><a></a>It's also hard to tell them that you will never again in your career get this collection of people willing to spend an hour helping you think through your design. You're going to be on your own after this, and that was just a wonderful experience.</p>
<p class="normal"><b>Seibel：</b>这些设计评审多久进行一次？在项目开始时还是整个过程中？</p><p class="normal"><b>Seibel:</b> How often were these design reviews? At the beginning of a project or throughout?</p>
<p class="normal"><b>Cosell：</b>没有多次设计评审；当设计被认为完成时，设计审查基本上是一次。</p><p class="normal"><b>Cosell:</b> There weren't multiple design reviews; the design review was basically once when the design was considered done.</p>
<p class="normal"><b>Seibel：</b>所以设计是在您真正开始编码部分之前完成的？</p><p class="normal"><b>Seibel:</b> So the design was done before you had really started the coding part?</p>
<p class="normal"><b>科塞尔：</b>是的，对。是的。可能已经完成了一些编码，因为包括我在内的很多人不得不开始编写少量代码，以了解事情的实际进展情况。但通常我们处于一个循环中，我们必须提出建议，然后我们才能获得资金来做这些事情。所以我们要做的就是向客户建议，“这就是我们要做的，”你想要一个很好的理解，因为客户在这一点上会给你很多时间和很多钱，并期望它工作。所以通常是在那个时候，我们即将完成提案，我们将对我们要做的事情进行技术描述。现在我们坐下来进行设计审查，以确保我们理解它。我不记得 Frank 是在合同签订后才签订合同的。</p><p class="normal"><b>Cosell:</b> Yeah, right. Yeah. Probably some of the coding had been done because a lot of people, including me, have to start blocking up little bits of code to see how a thing is actually going to work out. But typically we are in a cycle where we have to propose things and then we get funded later to do them. So what we have to do is propose to the client, “This is what we're going to do,” and you want a good understanding because the client at this point is going to give you so much time and so much money and expect it to work. So it was typically at that point, we are about to finalize the proposal, we are going to have the technical description of what we're going to do. Now we sit down for the design review to make sure we understand it. I don't recall Frank stepping into contracts once they were afoot. Certainly the projects I was working on I can't remember an ongoing project review including Frank.</p>
<p class="normal"><b>Seibel：</b>你刚才提到了医生。那是什么？</p><p class="normal"><b>Seibel:</b> You just mentioned Doctor. What was that?</p>
<p class="normal"><b>Cosell：</b>当我在 PDP-1 分时系统上工作时，Dan Murphy 和他的朋友在他们的 PDP-1 上工作，提出了这个 Lisp 系统。所以我想我会学习 Lisp。<i>那年春天，Joe Weizenbaum 为ACM 的通讯</i>写了一篇关于 ELIZA 的文章。我觉得那太酷了。我相信，我现在可能仍然相信，只要我能理解，我就能让计算机做。他描述了 ELIZA 的工作原理，我说，“我打赌我可以写一些东西来做到这一点。” 于是我开始在 BBN 的 Dan Murphy 的 PDP-1 系统上编写 Lisp 程序。我有一台 33 型电传打字机，它在我的 PDP-1 机房里，连接到 Dan Murphy 的<a id="OEBPS/Chapter14.html.page_541"></a>PDP-1 这样我就可以在我的机房里玩他的电脑，假装在我的系统上工作。我编写了那个程序并开始运行。玩它是一个全 BBN 项目。人们会给我留下评论：“如果你这样做会更好”或者“我试过了，但没用。” 这实际上有助于将 Weizenbaum 的想法传播到其边界之外。它最初是用 PDP-1 Lisp 编写的。但当时他们正在 PDP-6 或 PDP-10 上构建 Lisp。但在 ARPANET 中传播开来的是 Lisp。事实证明，所以医生同意了。</p><p class="normal"><b>Cosell:</b> When I was working on the PDP-1 time-sharing system, Dan Murphy and his friends were working on their PDP-1, bringing up this Lisp system. So I thought I would learn Lisp. That spring, Joe Weizenbaum had written an article for <i>Communications of the ACM</i> on ELIZA. I thought that was way cool. And I believed, as I likely still believe now, that anything I can understand, I can make a computer do. He described how ELIZA works and I said, “I bet I could write something to do that.” And so I started writing a Lisp program on Dan Murphy's PDP-1 system at BBN. I had a Model 33 Teletype that was in my PDP-1 computer room connected to Dan Murphy's <a></a>PDP-1 so I could play on his computer from my computer room and pretend to be working on my system. I wrote that program and got it up and working. Playing with it was an all-BBN project. People would leave me comments: “It would be better if you did this” or, “I tried this, and it didn't work.” That actually helped spread Weizenbaum's idea beyond its boundaries. It was written, at first, in the PDP-1 Lisp. But they were building a Lisp on the PDP-6 at that point—or maybe the PDP-10. But it was the Lisp that had spread across the ARPANET. So Doctor went along with it, it turns out.</p>
<p class="normal">我有了一点名气，因为丹尼·博布罗 (Danny Bobrow) 写了一篇“通过的图灵测试”(A Turing Test Passed)。那是我第一次真正因为我的愚蠢黑客行为而得到一些注意：我让 Doctor 离开了。BBN 的一位高管进入 PDP-1 计算机室，认为 Danny Bobrow 被拨入了那里，并认为他正在与 Danny 交谈。对于我们这些玩过 ELIZA 的人来说，我们都认可这些反应，我们没有考虑过它们有多像人类。但对于不太熟悉 ELIZA 的人来说，这似乎非常合理。这很令人讨厌，但他实际上认为那是 Danny Bobrow。“但是告诉我更多关于——” “早​​些时候，你说你想去客户那里。” 像这样的事情在上下文中几乎是有意义的，直到最后他输入了一些东西而他忘记了按下开始按钮，所以程序没有 不要回应。他认为丹尼已经断开连接。所以他打电话给家里的丹尼，对他大吼大叫。丹尼完全不知道发生了什么。除了丹尼知道我的终端机。所以他进来把打字稿从那东西上撕下来，以保存它。</p><p class="normal">I got a little glimmer of fame because Danny Bobrow wrote up “A Turing Test Passed”. That was one of the first times I actually got some notice for my stupid hacking: I had left Doctor up. And one of the execs at BBN came into the PDP-1 computer room and thought that Danny Bobrow was dialed into that and thought he was talking to Danny. For us folk that had played with ELIZA, we all recognized the responses and we didn't think about how humanlike they were. But for somebody who wasn't real familiar with ELIZA, it seemed perfectly reasonable. It was obnoxious but he actually thought it was Danny Bobrow. “But tell me more about—” “Earlier, you said you wanted to go to the client's place.” Things like that almost made sense in context, until eventually he typed something and he forgot to hit the go button, so the program didn't respond. And he thought that Danny had disconnected. So he called Danny up at home and yelled at him. And Danny has absolutely no idea what was going on. Except Danny knew about my terminal. So he came in and tore the typescript off of the thing, to save it.</p>
<p class="normal">这是 Weizenbaum 的东西的一个非常漂亮的版本。我们稍微改进了脚本。许多代的黑客都致力于此。正如我所说，它在网上传播。现在，我想，它有一个用 Emacs 宏编写的版本。但那是我成为一名认真的 Lisp 程序员的考验。</p><p class="normal">It was a very slick version of Weizenbaum's thing. We improved the scripts a little bit. Lots of generations of hackers worked on it. And as I say, it traveled around the Net. And now, I guess, there's a version of it written in Emacs macros. But that was my trial by fire in becoming a serious Lisp programmer.</p>
<p class="normal"><b>Seibel：</b>所以我很好奇——我观察到，编写最繁琐、最复杂代码的程序员往往是那些能够在脑海中记住大量细节的人。你显然有能力记住细节，但仍然非常关心让代码简单明了。</p><p class="normal"><b>Seibel:</b> So I'm curious—I've observed that often the programmers that write the hairiest, most complicated code are the ones who can keep a ton of details in their mind. You obviously had the ability to keep details in your mind but still cared a lot about making code simple and clear.</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_542"></a><b>Cosell：</b>我不得不承认我两者都做了。我会让事情变得简单。但是当我说程序应该简单时，并不一定是程序的特定功能部分必须简单。我可以编写一些非常复杂的代码来做正确的事情，就在那里，人们会畏缩并且不愿意触摸的代码。但它总是在一个封闭的地方。</p><p class="normal"><a></a><b>Cosell:</b> I have to admit that I did both. I would make things simple in the large. But when I say that programs should be easy, it's not necessarily the case that specific pieces of the functionality of the program have to be easy. I could write some very complicated code to do the right thing, right there, code that people would cringe at and not be willing to touch. But it was always in an encapsulated place.</p>
<p class="normal">我遇到的大多数糟糕的程序，那些我把东西扔掉并重新编码的程序，没有一个你可以尝试理解和修复的复杂的小岛，但复杂性已经渗透到程序中了。</p><p class="normal">Most of the bad programs I ran into, the ones where I threw things out and recoded them, there wasn't a little island of complexity you could try to understand and fix, but the complexity had oozed through the program.</p>
<p class="normal">我有一些规则，我试图给人们留下深刻印象，通常是那些刚从大学毕业的人，他们相信他们了解关于编程的一切知识。第一个想法是，天生很难的程序很少。如果您正在查看一段代码并且它看起来很难——如果您无法理解这件事应该做什么——这几乎总是表明它没有经过深思熟虑。那时您不会卷起袖子尝试修复代码；你退后一步，重新考虑一下。当您充分考虑之后，您会发现这很容易。</p><p class="normal">I have a couple of rules that I try to impress on people, usually people fresh out of college, who believe that they understand everything there is to know about programming. The first is the idea that there are very few inherently hard programs. If you're looking at a piece of code and it looks very hard—if you can't understand what this thing is supposed to be doing—that's almost always an indication that it was poorly thought through. At that point you don't roll up your sleeves and try to fix the code; you take a step back and think it through again. When you've thought it through enough, you'll find out that it's easy.</p>
<p class="normal">我们最近在工作中这样做了。他们正在从事一些大型设计项目，而且它变得越来越复杂。所以我们开了个会，开始丢掉东西。我说：“那好像太复杂了。” 突然之间，我们有了一个关于它如何工作的框图。每个人都惊呆了，因为他们明白每个街区如何完成它的工作。我们没有做过那些你必须把它全部写下来的枯燥的事情，但他们明白界面是干净的，他们可以取得进步。我从事这项业务的时间足够长，可以理解存在一些非常棘手的问题。但是很少。总是这样，当他们更努力地思考它时，它变得更容易，突然之间就很容易正确编程了。</p><p class="normal">We just did that recently at work. They were working on some big design project and it was just getting more and more convoluted. So we had a meeting and started shedding away things. I said, “That seems too complicated.” And all of a sudden, we had a block diagram for how the thing would work. And everybody was stunned because they understood how each block could possibly do its job. We hadn't done the dull things where you have to write it all down but they understood that the interfaces were clean and they could make progress. I've done this business long enough to understand that there are some very hard problems. But very few. It's invariably the case that when they think about it harder, it gets easier and all of a sudden it's easy to program correctly.</p>
<p class="normal">另一条规则是要认识到程序是用来阅读的。尽管我早年曾写过几页 TECO 宏，但我很快——可能是在我从事 PDP-1 分时系统工作时，分时系统的复杂性开始陷入——开始相信计算机程序源代码是为人准备的，而不是为计算机准备的。电脑不在乎。我认为 Perl 有一个好东西<a id="OEBPS/Chapter14.html.page_543"></a>“如果”和“除非”。因为事实证明，当你对某事应该做什么有直觉时，说“如果不是某种条件”与说“除非条件”所表达的意思不同。</p><p class="normal">The other rule is to realize that programs are meant to be read. Even though I'm guilty of writing pages of TECO macros back in my early days, I very quickly—probably when I was working on the PDP-1 time-sharing system and the complexity of the time-sharing system started to sink in— came to the belief that computer-program source code is for people, not for computers. Computers don't care. I think it's a good thing that Perl has <a></a>both “if” and “unless.” Because it turns out that when you're getting an intuition for what something is supposed to be doing, saying “if not some condition” doesn't connote the same idea as saying “unless the condition.”</p>
<p class="normal">二进制位是计算机想要的，而文本文件是给我的。我会在我的一个项目中找到人——聪明、非常优秀的人，刚从大学毕业，是他们班上的佼佼者。他们会了解所有关于编程的知识，我会给他们一些项目的工作。我们会在项目审查会议上开始交锋。他们会说，“你为什么抱怨我在这里有我的全局变量，我没有这样做，你不喜欢子程序的布局方式？该程序有效。”</p><p class="normal">The binary bits are what computers want and the text file is for me. I would get people—bright, really good people, right out of college, tops of their classes—on one of my projects. And they would know all about programming and I would give them some piece of the project to work on. And we would start crossing swords at our project-review meetings. They would say, “Why are you complaining about the fact that I have my global variables here, that I'm not doing this, that you don't like the way the subroutines are laid out? The program works.”</p>
<p class="normal">当我告诉他们“我不在乎程序是否有效”时，他们会感到震惊。你在这里工作的事实意味着我希望你能够编写有效的程序。编写有效的程序是一门熟练的手艺，而且您很擅长。现在，你必须学习如何编程。” 其中一些人是非常优秀的程序员，他们从来没有读过任何其他人的代码。事实上，他们中的一些人甚至从未阅读过自己的代码，因此他们从来没有痛苦地看到六个月后发生的事情。</p><p class="normal">They'd be stunned when I tell them, “I don't care that the program works. The fact that you're working here at all means that I expect you to be able to write programs that work. Writing programs that work is a skilled craft and you're good at it. Now, you have to learn how to program.” Some of these guys were fabulously good programmers and they'd never once read a line of anybody else's code. In fact, some of them never even read their own code, so they never had the pain of seeing what happens six months later.</p>
<p class="normal">有些人会反抗。有些人绝对相信他们是优秀的程序员，而我只是一个不知所措的老家伙，不知道自己在做什么。我知道不久前我会说同样的话：“该程序有效。你有什么问题？” 当我说，“你得不到学分是因为这个项目有效。我们将进入下一个阶段。工作计划是给定的，”他们说，“哦。然后他们与其他人交谈，发现这基本上就是 BBN 标准。如果你不够熟练，无法让计算机按照你的想法去做，你就无法在做某事时探索新的想法。</p><p class="normal">Some would rebel. Some were absolutely convinced that they were good programmers and I was just some over-the-hill old guy that didn't know what he was doing. I know I would have said the same thing not long ago: “The program works. What is your problem?” When I say, “You don't get credit because the program works. We're going to the next level. Working programs are a given,” they say, “Oh.” Then they talk to other people and discover that that's basically the BBN standard. You can't explore a new idea in doing something if you are not craftsman enough to make the computer do what you had in your mind.</p>
<p class="normal">我偏爱我喜欢我的全局变量和我喜欢我的子程序的组织方式，我和一个人进行了多天的战斗，他说，“看，它工作得很好”，他是一个非常好的程序员，我没有'想拉排名。我觉得让他明白我不仅仅是一只暴虐的火鸡很重要；我想让他用另一种方式做这件事是有原因的。他没有意识到用一个长达 42 页代码的 C 子例程来理解一个程序是多么困难。</p><p class="normal">I had a preference of how I liked my global variables and how I liked my subroutines organized and I got into a multiday battle with one guy where he said, “Look, it works just fine” and he was such a good programmer that I didn't want to pull rank. I felt it important that he understand that I was not just being a tyrannical turkey; that there was a reason why I wanted him to do it this other way. He didn't realize how hard it is to understand a program with a single C subroutine that's 42 pages of code long.</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_544"></a><b>Seibel：</b>哎呀！</p><p class="normal"><a></a><b>Seibel:</b> Yikes!</p>
<p class="normal"><b>科塞尔：</b>我和他争论是因为我是一次调用子程序的忠实拥护者，其中子程序的唯一功能是抽象父子程序的一小部分。当你阅读父子例程时——在我的编程方法中——你到达代码中的这个地方并且你被这个大的东西的细节分散了注意力，我喜欢把整个块都拉出来。现在你有一个单一的东西，“对表格进行排序并找到最佳路线”，即使这是唯一调用它的地方。优化代码的人会说，“那不应该是一个子程序。把它排成一行。” 但这是一个我可以将其隔离的小子程序。输入是什么一目了然。你可以看到算法，只关心它。他讨厌我过去常说：“你的套路太复杂了。</p><p class="normal"><b>Cosell:</b> I argued with him because I'm a big fan of call-once subroutines where the only function of the subroutine is to abstract some little part of a parent subroutine. When you read the parent subroutine—in my approach to programming—and you get to this place in the code and you get distracted with the details of this big nexus of stuff, I like to pull that whole clump out. Now you have a single thing that says, “Sort the table and find the best route,” even though this is the only place it's called. Someone optimizing the code would say, “That shouldn't be a subroutine. Put that in line.” But it's a little subroutine where I can isolate it. It's obvious what the inputs are. You can see the algorithm, and only be concerned with that. He hated when I used to say, “Your routines are too complicated. Your routines are spanning big chunks of the design” He'd say, “That's OK because I can do it all in one routine.”</p>
<p class="normal">他反叛了，但最终他按照我的方式做了。然后他的下一个任务是从一位从事早期工作的程序员那里获取一大段代码，并使其适合我们的系统。他为此工作了将近一个星期。他非常讨厌其他人的程序，以至于他向我的老板抱怨该部门的编程标准不够严格。另一个人正在按照他想要的方式进行编程，但方式不同。所以他看到了当一个非常热心、非常优秀的程序员不把它细分时会发生什么。你会得到一个非常长的程序——并不是说这个程序是意大利面条式的代码，而是在这个线性套件中有很多级别的复杂性。他差点把我气死了，因为，就像我说的，</p><p class="normal">He rebelled but eventually he did it my way. Then the next task he had was to take a big piece of code from one of the programmers working on an earlier effort and make it fit into our system. He worked on that for almost a week. He so hated the other guy's program that he complained to my boss that there aren't strict enough programming standards in the division. And the other guy was programming the way he had wanted to program but with a different spin. So he saw what happens when one very intense, very good programmer doesn't segment it down. You get one very long program—it's not that the program was spaghetti code but there were just so many levels of complexity in this one linear suite. He almost pissed me off because, as I say, he went over my head to demand that the department had to have standards to not allow that thing to happen.</p>
<p class="normal"><b>Seibel：</b>没有意识到他自己以前的代码可能会与相同的标准发生冲突？</p><p class="normal"><b>Seibel:</b> Not realizing that his own previous code would've probably fallen afoul of the same standards?</p>
<p class="normal"><b>Cosell：</b>不。他明白了。他是一个皈依者。这有点像那些戒烟的人，他们对其他仍在吸烟的人感到最痛苦。他成为我项目中最强大的人之一。当我不够小心——当我妥协时，他常常唠叨我。我的项目是他从事过的第一个同类项目。通信、实时，所有这些东西——对他来说都是新的。但他是个聪明人，他经历了这个小小的顿悟，从中脱颖而出，成为我一直以来的程序员<a id="OEBPS/Chapter14.html.page_545"></a>以为他会。最后我听说，他做得很好。和他一起成功了。其他人不喜欢和我一起工作，因为他们觉得我太专横了；我无法想象为什么。</p><p class="normal"><b>Cosell:</b> No. He got that. He was a convert. It's sort of like the guys who give up smoking and are the most pains in the butt about other people still smoking. He became one of the strongest guys on my project. He used to nag me when I wasn't careful enough—when I compromised. My project was the first project of its type he had ever worked on. Communications, real time, all this stuff—all new to him. But he was a smart guy and he went through this little epiphany and came out of it the programmer I always <a></a>thought he was going to be. Last I heard, he was doing wonderfully. With him it worked out. Other people didn't like working with me because they found me too overbearing; I can't imagine why.</p>
<p class="normal"><b>Seibel：</b>对于评论的多少或多少，你有什么特别的规定吗？</p><p class="normal"><b>Seibel:</b> Did you have particular rules for how much or how little to comment?</p>
<p class="normal"><b>Cosell：</b>我没有在我的代码中添加很多注释，因为我认为您应该编写代码，使其可读，并且您的算法和想法在代码中清晰明了。我在评论中指出这个例程应该这样做，通常还有一些关于如何调用它的描述——当你遇到异常时你会做什么，参数的顺序是什么，等等。但是代码本身应该清楚地表达你在做什么。</p><p class="normal"><b>Cosell:</b> I don't put a lot of comments in my code because I think you should be writing your code so that it is readable and your algorithms and thoughts are clear in the code. I put comments that say this routine is supposed to do this, and usually some description of how you call it—what do you do when you get exceptions, what the order of the arguments is, and things like that. But the code itself should clearly express what you are doing.</p>
<p class="normal">我倾向于在我的代码中添加注释的唯一地方是当我的直觉说，“这段特定的代码，即使它有效，也没有清楚地说明我想要完成的事情。” 所以我在代码中添加了注释，说“这段代码对表格进行排序”，如果它看起来不像您的标准表格排序代码，因为事实证明，我可以利用一些东西。</p><p class="normal">The only place I tend to put comments in my code is when my instinct says, “This particular piece of code, even though it works, doesn't clearly state what I'm trying to accomplish.” And so I put a comment in the code to say, “This code sorts the table,” if it may not look like your standard table-sorting code because, as it turns out, I can take advantage of something.</p>
<p class="normal">我从来都不喜欢结构化编程列表，其中每个子例程的开头必须有 18 行注释，并且参数顺序正确。我没有对我的程序进行一致的细分。我的一些子程序很复杂，有些很简单。我确实担心布局之类的事情；我是争论大括号的队伍中的一员。</p><p class="normal">I have never been a fan of structured programming listings where every subroutine has to have 18 lines of comment at the beginning and the arguments are in the right order. I don't do a consistent segmentation of my programs. Some of my subroutines are complicated and some are simple. I do worry about things like layout; I'm part of the contingent that argues about curly braces.</p>
<p class="normal">原因之一是因为我阅读代码是为了了解它的作用，而不是阅读代码是为了了解它的每一小部分是什么。因此<code>if</code>，例如，当我看到一个语句时，我看到了条件。我现在正在考虑在那个条件下是或否，如果我想跳过<code>if</code>语句，我喜欢有一个程序组织，让我的眼睛向下翻到<code>if</code>语句的末尾，而不必处理大量语法。所以我是那些喜欢排列、打开和关闭牙套的老派人之一。</p><p class="normal">One of the reasons is because I read code to understand what it does as opposed to reading code to see what each little piece of it is. So when I see an <code>if</code> statement, for example, I see the condition. I'm now thinking yea or nay on that condition, and if I want to skip the <code>if</code> statement I like having a program organization that lets my eye flip down to the end of the <code>if</code> statement without me having to process a lot of syntax. So I'm one of those old-fashioned guys that likes lined-up, open and close braces.</p>
<p class="normal">如果你让第五列消失，我的代码看起来像，“运算符，开大括号，闭大括号；运算符，左大括号，右大括号，”这让我看到了运算符的顺序。另一部分与我有关<a id="OEBPS/Chapter14.html.page_546"></a>之前提到过：如果开大括号离闭大括号太远，那么通常它做的太多了，在这种情况下我可以把它拉出来。有时即使它没有做太多，我还是会把它拔掉，因为如果里面有太多垃圾，我无法理解那个小分支在做什么。</p><p class="normal">If you made column five go away, my code would look like, “operator, open brace, close brace; operator, open brace, close brace,” which lets me see the sequence of operators. Another part of that is related to something I <a></a>mentioned before: if the open brace is too far from the close brace then often it's doing too much, in which case I can pull it out. Sometimes even if it's not doing too much I'll still pull it out because I can't apprehend what that little branch is doing if there's too much crap in there.</p>
<p class="normal">我非常努力地隐藏废话，将废话移到某个地方，以便我可以跟随代码的流程，这样我就可以在脑海中构建代码正在做什么的画面。我在阅读某些编程风格时遇到了很多麻烦，因为我在尝试吸收块结构时遇到了太多麻烦。有趣的是，开发 Python 的人显然也有类似的想法。他消除了语法战争，因为他没有左括号和右括号。当您看到<code>if</code>打开的花括号总是隐含地存在并且闭合的花括号也隐含地存在时，如果您需要查找下一个东西，它会排在<code>if</code>. 我使用 C 和 Perl 中的编辑器，我假设 Python 中的编辑器做同样的事情，</p><p class="normal">I try very hard to hide the crap, to move the crap someplace so that I can follow the flow of the code, so I can build the picture in my head of what the code is doing. I have a lot of trouble reading some programming styles because I have too much trouble trying to absorb the block structure. It's interesting that the guy that did Python was clearly of a similar mind. He eliminated the syntax wars because he doesn't have open and close braces. When you see an <code>if</code> the open curly brace is always there implicitly and the closed curly brace is also implicitly there and if you need to find the next thing, it's lined up under the <code>if</code>. I use an editor in C and in Perl, and I assume that editors in Python do the same thing, where you can click on a button and it shrinks the whole thing so you only see the outer structure.</p>
<p class="normal">我不喜欢在一种风格丑陋的基础上打这些风格大战。我喜欢相信我与风格之战作斗争是因为它干扰了我对代码的理解。我一直很擅长这一点。除非你能说服我你比我更擅长理解代码，否则你很难说服我你的方法更好。</p><p class="normal">I don't like to fight these style wars on the basis that one style is ugly. I like to believe I fight the style wars is because it interferes with me understanding the code. I was always pretty good at that. Unless you could convince me you're better at understanding code than I am, you have a tough fight convincing me your way is better.</p>
<p class="normal"><b>Seibel：</b>当然，对新代码冷淡并对其进行调试是一项特殊技能，并非每个优秀的程序员都具备，但听起来您确实具备。</p><p class="normal"><b>Seibel:</b> Certainly coming in cold to new code and debugging it is a particular skill that not every good programmer has, which it sounds like you did.</p>
<p class="normal"><b>科塞尔：</b>确实如此。这有两个方面。还有一个人。他的名字叫史蒂夫·巴特菲尔德。他也是一个很好的修理工，但与我相反。史蒂夫是我见过的最擅长对程序如何工作和修复它一无所知的人。他可以深入研究一个程序，并在代码的内部更改一些丑陋的小部分，使其做一些不同的事情。大而复杂的程序，史蒂夫可以跳进去解决一些小问题，在我看来，这些程序在功能上更好但更糟。</p><p class="normal"><b>Cosell:</b> Indeed. And there are two aspects of that. There was another guy. His name was Steve Butterfield. And he was also a good fixer, but the antithesis of me. Steve was about the best I have seen at not having any clue how a program worked and fixing it. He could dive into a program and change some little ugly piece down in the bowels of the code to make it do something different. Big, complicated programs, Steve could leap in and fix little things leaving them, to my view, functionally better but worse off.</p>
<p class="normal">我总是试图让整个程序变得更好，这通常意味着即使有一个小问题，我也会尝试理解整个程序。我会尝试通过自上而下的推理找到问题，而不是说，“哦，这行不通。做<a id="OEBPS/Chapter14.html.page_547"></a>在这里做手术。” 所以有些事情我只是花了太长时间，花了太多时间试图将整个事情导入我的脑海，而更直接的方法只是去修复它就可以了。</p><p class="normal">I always tried to make the whole program better and that would often mean that even though there was one little problem, I would try to understand the whole program. I would try to find the problem by reasoning down from the top and finding it as opposed to saying, “Oh, this isn't working. Do <a></a>surgery here.” So there were some things where I just took too long and spent too much time trying to import the whole thing into my head, when a more directed approach just to go fix it would do.</p>
<p class="normal">但通常当史蒂夫离开一个项目时，很难修改代码让它做事。虽然我试图保持良好状态，但这意味着如果一个程序真的很大而且很糟糕，我会花很多时间旋转我的轮子，然后我才能舒服地投入其中。但这并不经常发生，因为经常当我调试东西，我不是通过调试来做的。</p><p class="normal">But usually when Steve left a project, it was hard to revise the code to make it do stuff. Whereas I tried to keep things good, but it meant that if a program was really big and awful, I would spend a lot of time spinning my wheels before I felt comfortable diving in. But that didn't happen very often because often when I debug things, I don't do it by debugging.</p>
<p class="normal">正如我之前提到的，有很多错误我从来不知道它们在哪里。我只是说，“这段代码应该是这样做的。这看起来不像是那样做的。我的意思是，怎么会有人写这么复杂的代码来做这么简单的事情呢？” 所以我将其删除并用一个例程替换它，该例程执行我认为该段代码应该做的简单事情。该程序神奇地起作用了。回想起来，发生的事情是程序已经发展，这个小程序不断改变。不是在程序发展时被替换，而是有人修补它来做不同的事情并且错过了一次。</p><p class="normal">As I mentioned before, there were many bugs that I never had any clue where they were. I just get to a point where I say, “This piece of code is supposed to be doing this. This does not look like it's doing that. I mean, how could anybody have written this complicated bit of code to do this simple thing?” So I'd rip it out and replace it with a routine that does the simple thing I thought that piece of code was supposed to do. And the program magically works. In retrospect, what had happened is that the program had evolved and this little routine kept getting changed. Rather than being replaced when the program evolved, somebody was patching it to do different things and missed once.</p>
<p class="normal">我从来没有调试过任何东西。我花了一两天时间来完成所有这些打字工作，但没有人会知道我在做什么，程序也会得到修复。多么好的调试器！这是非常危险的，因为 Will 的格言基本上是正确的，如果你重写一百行代码，你很可能已经修复了一个错误并引入了六个新错误。至少你知道要寻找什么的一个错误；您现在必须开始寻找六个新的。我很幸运，因为多年来我在设法编写大部分有效的代码方面有着非常好的记录。</p><p class="normal">I never debugged any of that stuff. I hack on it for a day or two doing all of this typing and nobody would have a clue of what I'm doing and the program would get fixed. What a debugger! That is very dangerous because Will's dictum is basically right, that if you rewrite a hundred lines of code, you may well have fixed the one bug and introduced six new ones. And at least the one bug you knew what to look for; you now have to start looking for the six new ones. And I was just fortunate because I had a very good track record over the years of managing to write code that, for the most part, worked.</p>
<p class="normal"><b>Seibel：</b>所以你一定有一些阅读代码的策略。即使没有错误，只有一大堆您要处理的代码，您是如何解决的？</p><p class="normal"><b>Seibel:</b> So you must have had some strategies for reading code. Even if there's no bug but just a big pile of code that you're going to work on, how did you tackle that?</p>
<p class="normal"><b>Cosell：</b>结果不是很好。我倾向于重写代码块而不是修复它们的原因之一是因为我达到了我无法再设法弄清楚的地步。我没有像阅读代码那样阅读代码<a id="OEBPS/Chapter14.html.page_548"></a>书。我试图弄清楚程序在做什么，然后从上到下获得有关代码的提示。</p><p class="normal"><b>Cosell:</b> Not very well, it turns out. One of the reasons why I tend to rewrite chunks of code rather than fix them is because I reach points where I can't manage to figure it out anymore. I don't read the code as if it were a <a></a>book. I try to figure out what the program is doing and then get hints about the code from the top down.</p>
<p class="normal">在阅读程序的同时，我也在思考如何解决这个问题。这意味着我正在寻找某些特定的片段，这样我就可以说，“哦，这是程序执行它的地方。” 然后我可以用我一贯傲慢的方式说，写这篇文章的人做错了。或者至少我现在明白他们正在以其他方式做到这一点。</p><p class="normal">In parallel with reading the program I think about how would I solve this problem. Which means I'm looking for certain specific pieces so I can say, “Oh, here's where the program does it.” Then I can say, in my usual arrogant way, that the guy that wrote this did it wrong. Or at least I now understand that they're doing this some other way.</p>
<p class="normal">所以我会自上而下。但我认识的一些人非常擅长自下而上。他们会开始阅读小子程序，并最终找到他们需要的一个子程序。但大多数情况下，我是那种自上而下的人。也就是说，我正在查看程序，试图弄清楚其他程序员<i>应</i>该做什么。这是导致我有时修复我不知道错误是什么的错误的原因之一。我会在某个地方说，“这段代码——我现在理解这个程序——应该是这样做的”然后我正在看的代码没有这样做或者代码是这样的很复杂，似乎还要做其他六件事，这对我来说没有意义。</p><p class="normal">So I would go top-down. But some of the guys I knew were spectacularly good at bottom-up. They would start reading little subroutines and eventually find the one subroutine they needed. But mostly for those kinds of things I was a top-down kind of guy. That is, I'm looking at the program trying to figure out what the other programmers <i>should</i> have done. That was one of the things that led me to sometimes fix bugs where I didn't know what the bug was. I'd hit a place where I say, “This piece of code—as I understand this program now—is supposed to be doing this” and then either the code I'm looking at doesn't do that or the code is so complicated and seems to be doing six other things and it's not making sense to me.</p>
<p class="normal">在任何一种情况下，我通常的反应都是修复那段代码，使其与我认为应该在程序中发生的事情一致。你可以看到这有多么危险，因为没有一个正确的方法来组织一个程序，如果这个程序组织得很好，但以一种与我想要的不同的方式，我现在刚刚杀死了这个程序，现在有一个令人难以置信的雪崩要修复的东西。但我很幸运。通常当我说，“这看起来不对，我要修复它”时，它就被修复了。从早期开始就是如此。</p><p class="normal">In either case my usual response at that point is to fix that piece of code so that it agrees with what I thought was supposed to be happening there in the program. You can see how fabulously dangerous that can be because there is no one correct way to organize a program and if the program was perfectly well organized but in a different way than I wanted, I have now just killed the program and now have an incredible avalanche of stuff to fix. But I was pretty lucky with that. Usually when I said, “This looks wrong and I'm going to fix it ” it got fixed. And that was even true from the early days.</p>
<p class="normal">我参与的第一个大项目，PDP-1 分时系统，我只是一个做大学本科生编程问题的原始程序员，我很快就完成了医院项目，从做应用程序到进入系统的翅膀伙计们。尽管我成为一名专业程序员已经六个月了，但我非常愿意说远程进程交换器的这一小块看起来不太对，我会重写它。</p><p class="normal">The first big program I worked on, the PDP-1 time-sharing system, I was just a raw programmer doing college-undergrad programming problems and I moved through the hospital project very quickly, from doing applications to coming under the wing of the systems guys. Even though I was six months into being a professional programmer I was perfectly willing to say that this little piece of the remote process swapper doesn't look like it's right and I would rewrite it.</p>
<p class="normal"><b>Seibel：</b>除了引入新错误的危险之外，另一个风险是您可能误解了程序应该做什么。</p><p class="normal"><b>Seibel:</b> In addition to the danger of introducing new bugs, another risk is that you may have misapprehended what the program is supposed to do.</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_549"></a><b>科塞尔：</b>没错。如果你愿意的话，我走的路不适合胆小的人。当时我 19 岁，这似乎是做事的唯一方式。我有两个信念，实际上对我很有帮助：程序应该有意义，并且很少有天生的难题。任何看起来非常困难或棘手的事情可能更多是程序员没有完全理解他们需要做什么并用锤子敲打它直到他们得到看起来像是做了正确事情的代码的产物。</p><p class="normal"><a></a><b>Cosell:</b> That's right. The path I took was, if you will, not for the faint at heart. At the time I was 19 years old and that seemed like the only way to do things. I had two convictions, which actually served me well: that programs ought to make sense and there are very, very few inherently hard problems. Anything that looks really hard or tricky is probably more the product of the programmer not fully understanding what they needed to do and pounding it with a hammer 'til they got code that looked like it did the right thing.</p>
<p class="normal">我不知道为什么我有这两个信念。我来到 BBN 时本身并没有任何技能，但出于某种原因，我的脑海中已经有了这些原则。我认为我应该能够理解任何东西，而且不应该那么难。我发现即使对于分时系统和 IMP——对于所有这些类别的程序，这也被证明是正确的。一般来说，一旦我对程序应该做什么有了正确的理解，各个部分就会各就各位。不属于的部分会像拼图游戏中颜色错误的部分一样脱颖而出。</p><p class="normal">I don't know why I had those two convictions. I arrived at BBN with no skill per se, but I had those principles in the back of my head for some reason. I thought I ought to be able to understand anything and it shouldn't be so hard. I found that even for the time-sharing system and the IMPs—for all of those class of programs, that proved to be true. In general once I had the right understanding of what a program was supposed to do, the pieces would fall into place. The pieces that didn't belong would stand out like a miscolored piece in a jigsaw puzzle.</p>
<p class="normal">另一个原则是我一直想要干净的列表。我希望事情恰到好处。当您必须修复程序中的错误时，您永远不会在发现错误的地方修复错误。我的规则是，“如果你那时知道你现在知道这段代码被破坏了，你会如何组织这段程序？” 你之前想错什么了？修复代码，以免发生这种情况。当你完成一个例程时，我希望你处理的每个例程看起来都像刚写好的一样。我不想看到任何事后的想法或出错的证据，然后是纠正错误的东西或一段神秘的代码说，“这个例程时不时地返回错误的值，所以我必须修复它。” 我不想看到这些。</p><p class="normal">Another principle was I always wanted clean listings. I wanted the thing to be just right. When you have to fix a bug in a program you never, ever fix the bug in the place where you find it. My rule is, “If you knew then what you know now about the fact that this piece of code is broken, how would you have organized this piece of the routine?” What were you thinking about wrong before? Fix the code so that can't happen. When you finish with a routine I want every routine you work on to look as if it was just written. I do not want to see any evidence of afterthoughts or things gone wrong followed by something to correct the error or a mysterious piece of code saying, “This routine returns the wrong value every now and then so I've got to fix it.” I don't want to see any of that. I want to see code that looks like through some divine inspiration you got it exactly right the first time.</p>
<p class="normal">然后我将其与另一个小技巧结合起来。我在做 DOD 项目时得到了这个。他们永远不会资助新项目。BBN 和政府都对当前项目投入过多，即使它有严重的局限性需要修复。最常见的是你在程序启动时所做的正确的事情现在是无可救药的错误，因为程序的使用或要求或某些东西已经发展。你想做的就是撕掉<a id="OEBPS/Chapter14.html.page_550"></a>程序的那部分并修复它。他们说，“这会改善什么？” 你说，“它不会改进任何东西，但它会让下周的程序变得更好。” 不会获得这样做的许可。</p><p class="normal">Then I compound that with one other little trick. I got this when I was working on D.O.D. projects. They'll never fund a new project. Both BBN and the government have too much invested in the current program, even when it has limitations that are awful that need to be fixed. The most common one is something that you did that was right when the program started is now hopelessly wrong because the program's use or requirements or something have evolved. What you'd like to do is rip out <a></a>that part of the program and just fix it. And they say, “What is that going to improve?” You say, “It's not going to improve anything but it'll make the program better for next week.” Not going to get permission to do that.</p>
<p class="normal">我采用的方法是偷偷摸摸的方法，这对我的很多程序都非常有效。我对程序的未来版本进行了设计。知道我现在所知道的，这就是程序的外观，现在是程序级别而不是子例程级别。现在当你去修复一个 bug 并且你可以选择如何修复它时，修复它朝着更好的模型前进。不要只是以最短的方式修复它。不要只是以适合的方式修复它，而是将它移向另一个模型，这样在几个月的时间里，而不是程序越来越陷入修复旧的和错误的东西的补丁中，所有关键部分该程序突然看起来像是一种新的做事方式。</p><p class="normal">The method I took is the sneaky way and this has worked very well for me for a lot of programs. I do a design of the future version of the program. Knowing what I know now, this is how the program would have looked, now at the program level rather than at a subroutine level. Now when you go to fix a bug and you have a choice on how to fix it, fix it moving toward the better model. Don't just fix it in the shortest way. Don't just fix it in the way that fits, but move it toward the other model so that over several months instead of the program getting more and more mired in patches fixing up the stuff that was old and wrong, all the critical parts of the program all of a sudden look like they're the new way of doing things. Often you can get to the point where there are so few places left that still do things the old way that you can slip in and get those fixed because you're now not damaging the whole program.</p>
<p class="normal">所以当他们问，“你需要多长时间才能完成这个改变？” 你有三个答案。第一种是绝对最短的方式，改变一行代码。第二个答案是使用我重写子例程的简单规则需要多长时间，就好像你不会犯那个错误一样。然后第三个答案是，如果您实际上是在程序的更好版本中编写此子例程，那么修复该错误需要多长时间。所以你把你的估计值放在最后两个之间的某个地方，然后每次你被分配一个任务时，你就有一点额外的时间可以用来改进程序。我认为这会带来不可思议的改变。它使程序能够干净利落地发展。拥有一个仍处于第一版的程序真是太神奇了，但它就像华盛顿的锤子。它'</p><p class="normal">So when they ask, “How long is it going to take you to put this change in?” you have three answers. The first is the absolute shortest way, changing the one line of code. The second answer is how long it would be using my simple rule of rewriting the subroutine as if you were not going to make that mistake. Then the third answer is how long if you fix that bug if you were actually writing this subroutine in the better version of the program. So you make your estimate someplace between those last two and then every time you get assigned a task you have a little bit of extra time available to make the program better. I think that that makes an incredible difference. It makes for programs that evolve cleanly. It's amazing to have a program that's still in version one but it's like Washington's hammer. It's now a really sleek new thing because all the key parts have gotten fixed without any project manager having to actually authorize you to go rip out the guts and go fix it.</p>
<p class="normal"><b>Seibel</b>：你听说过重构吗？</p><p class="normal"><b>Seibel</b>: Have you heard of refactoring?</p>
<p class="normal"><b>科塞尔</b>：不，那是什么？</p><p class="normal"><b>Cosell</b>: No, what is that?</p>
<p class="normal"><b>Seibel</b>：你刚才描述的。我认为现在可能有更多的人接受这个想法，甚至在项目经理中也是如此。</p><p class="normal"><b>Seibel</b>: What you just described. I think now there's perhaps a bit more acceptance, even among the project managers of this idea.</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_551"></a><b>Cosell：</b>哦，这很好，因为我曾经需要一个错误——我曾经需要一个理由来更改代码片段以执行您刚才所说的操作，因为我永远无法获得许可只是重写它以使其更清晰。所以我将不得不等到出现错误或改进请求来触及那部分代码，但那时我会完全那样做。我想关于重构的事情是你花了一些时间思考正确的目标是什么，因为它不会重构并且让不同的人瞄准不同的方向或者让目标不是正确的事情。</p><p class="normal"><a></a><b>Cosell:</b> Oh, that's good because I used to need a bug that—I used to need a reason to change the piece of the code to do what you just said because I could never get permission just to rewrite it to make it cleaner. So I would have to wait till a bug or an improvement request came along touching that part of code, but then I would do exactly that. I guess the thing about refactoring is that you have spend some time thinking about what the right target is because it won't do to refactor and have different people aiming in different directions or to have the target not be the right thing.</p>
<p class="normal">我从来没有用名字做过。这似乎是我可以做两件事的唯一方法：管理复杂性<i>并</i>获得一个您不必扔掉并重新编码的程序。PDP-1 教会了我这一点。它运行了很多年，是一个如此巨大的项目。它的前两个版本花了三四个人的时间来写，而且没有办法把它扔掉，但它必须变得更好。</p><p class="normal">I never did that with a name; it just seemed like the only way I could do two things: manage the complexity <i>and</i> get a program that you didn't have to throw out and code over. The PDP-1 taught me that. It ran for a lot of years and it was such a huge project. It took three or four guys to write the first two versions of it and there was no way to throw it out, but it had to get better.</p>
<p class="normal"><b>Seibel：</b>你们如何雇佣程序员？你如何识别有才华的人？</p><p class="normal"><b>Seibel:</b> How do you hire programmers? How do you recognize the talented ones?</p>
<p class="normal"><b>Cosell：</b>我永远无法进入标准的面试范式。人们谈论——我认为微软就是以此闻名的——给他们一些小问题来解决。我似乎采取了更直观的方法。我基本上是浏览了男生或女生的简历，以了解他们是否喜欢我的类型。简历通常毫无用处，因为他们只是即将毕业的大学毕业生。你从字里行间读到这个看起来很花哨的项目实际上是某门课程的课堂项目。但我过去常常和他们交谈，只是感觉到他们是否有某种好奇、好奇、精确的头脑，而我已经成长为期望我周围的人拥有这种头脑。</p><p class="normal"><b>Cosell:</b> I couldn't ever get into the standard interviewing paradigm. People talk about—and I think Microsoft was famous for this—giving them little problems to solve. I seem to have taken a more intuitive approach. I basically glanced at the guy's—or girl's—résumé to get a feel for whether they felt like my type of person. Often the résumés were useless because they were just college seniors about to graduate. You read between the lines that this fancy-looking project was really a class project for some course in something or other. But I used to talk to them and just get a feel whether they had somehow the kind of inquiring, curious, precise kind of mind that I had grown to expect people around me to have.</p>
<p class="normal">他们的其他兴趣是什么，他们的非专业兴趣是什么？他们有没有表现出捡东西的能力和好奇心？我做这一切的方式有点草率。我有一个理想化的 BBN 品质人的形象，关于能力、好奇心、学习速度的一些模糊的东西，对很多不同的事物感兴趣，并且有点广泛。我过去常常去寻找，看看我是否觉得这个人将成为 BBN 品质的人。</p><p class="normal">What were their other interests, their nonprofessional interests? Did they show both aptitude for picking things up, and curiosity? It was kind of slapdash how I did all of that. I had this idealized image of a BBN-quality person, some vague thing about aptitude, curiosity, quickness of learning, interested in lots of different things, and kind of broadly based. I used to go on a hunt to see if I got the impression that this person was going to be BBN-quality folk.</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_552"></a><b>Seibel：</b>正如您提到的，Microsoft 以提出谜题类型的问题而闻名。你喜欢拼图。你认为这是衡量某人潜力的一种方式吗？</p><p class="normal"><a></a><b>Seibel:</b> As you mentioned, Microsoft is famous for asking puzzle-type questions. And you like puzzles. What do you think of that as a way of gauging someone's potential?</p>
<p class="normal"><b>Cosell：</b>精心挑选，我认为它有潜力。不是因为这个人解决了这个难题，而是如果它让你对他们如何组织一些事情来解决这个问题有所了解。我从来没有用过它。我当然不会递给某人一个小摆设拼图，然后看着他们试图把它重新拼起来。问题是很多这些谜题需要不同风格的解决方案，你要么知道要么不知道。这不太好，因为我不想要真正擅长做滑块拼图的人，因为他们碰巧知道做这件事的一些好技巧。</p><p class="normal"><b>Cosell:</b> Carefully chosen, I think it has potential. Not because the person solves the puzzle, but if it gives you a glimmer as to how they organize something to approach it. I have never used it. I would certainly not have handed somebody one of the little tchotchke puzzles and watched them while they tried to put it back together again. The problem is that a lot of these puzzles require different styles of solution, and either you know that or you don't. That's not so good because I don't want somebody who's really good at doing a sliding-block puzzle because they happen to know some good tricks for doing that.</p>
<p class="normal">BBN 花了很多时间在未知的水域航行，做我们没有做过的事情，我们不知道该怎么做。这既需要一定程度的勇气，因为这并不容易，也需要一定程度的技巧才能不失败。这就是我正在寻找的那种东西，不是在寻找有解决特定难题的诀窍的人，而是在他们需要处理的这个复杂的事情中，他们能合理地处理它吗？</p><p class="normal">BBN spent a lot of its time sailing in unknown waters, doing things that hadn't been done, that we didn't know how to do. And that requires both a degree of daring, because it's not so easy, and a degree of skill in order to not founder. That's the kind of thing I'm looking for, not looking for somebody with a knack for solving a particular puzzle but, thrown into this complicated thing that they have a need to deal with, can they approach it reasonably?</p>
<p class="normal">一个典型的例子是魔方的到来。我们刚刚听到关于这个奇妙拼图的传言，其中一个人正在英国出差，带回了一包拼图。没有书籍，没有文件，在美国还不是一种现象。只是一个奇怪的小群论难题。我们开始玩它。我们中的几个人以不同的方式解决了这个难题，但有趣的是我们能够解决这样的难题。只是当年那帮BBN人，东西对了。那就是我过去一直在寻找的东西。</p><p class="normal">A case in point was when the Rubik's Cubes arrived. We had just heard rumors about this wonderful puzzle and one of the guys was on a business trip to England and brought back a satchel of them. No books, no documentation, not yet a phenomenon in the U.S. at all. Just a strange little group theoretic puzzle. And we started to play with it. Several of us solved the puzzle in different ways, but it was interesting that we were able to cope with a puzzle like that. It's just that that group of BBN people back then had the right stuff. That was what I used to look for.</p>
<p class="normal">我不知道微软的小测验——我听说谷歌也有能力测验，或者什么——我不知道这些是否能给你暗示这个人有合适的火花。但这正是我过去一直在寻找的。这个人看起来是否已准备好成为 BBN 品质的人？通常我会说不。他们非常好，他们是了不起的工程师，但正如我们所说，我没有得到那种火花。我的方法是寻找火花，我不知道我是怎么做到的。</p><p class="normal">I don't know whether Microsoft's little quizzes—and I've heard that Google has an aptitude test too, or something—I don't know if those can give you a hint that this person has the right spark. But that's what I used to look for. Does this person look like they're ready to be BBN-quality folk? Often I would say no. They're perfectly good, they're terrific engineers, but as we're talking I'm not getting that spark. My approach was to look for the spark, and I don't know how I did it.</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_553"></a><b>Seibel：</b>你认为编程是年轻人的游戏吗？</p><p class="normal"><a></a><b>Seibel:</b> Do you think programming is a young person's game?</p>
<p class="normal"><b>Cosell：</b>我认为可能是这样。当我回顾我在 BBN 职业生涯末期从事的一些项目时，我什至可以看到，为我工作的人正在做我不可能做的事情。为我工作的一个人认为使用 Tcl 对界面的一部分来说是一件好事，所以在一天半的时间里他学到了足够多的 Tcl 来启动它并让它工作，我不认为我本来可以的。我在脑海中回想“哎呀，我以前也能做那样的事情”，这让我觉得很有趣。</p><p class="normal"><b>Cosell:</b> I think that may be the case. I can even see, as I look back at some of the projects I worked on toward the end of my career at BBN, that the people I had doing the work for me were doing things that I couldn't possibly have done. One of the guys working for me thought that using Tcl would be a neat thing for part of the interface, so in a day and a half he learned enough Tcl to bring the thing up and make it work, which I don't think I could've done. It was amusing for me to think in the back of my head, “Gee, I used to be able to do things like that.”</p>
<p class="normal">我认为实际的代码生产——工作的、合乎逻辑的、好的代码——需要一种强度和思维敏捷性来接受新事物，至少我现在觉得这很难做到。硬币的另一面是你对你年轻时肯定没有的事情有了一定的智慧。我现在更清楚如何做事了。所以我发现更好的组合是能够给年轻活跃的人指导。我认为总的来说，我一直在谈论的那种编程类似于关于数学的旧锯子，大多数数学家在 30 岁之前就完成了他们最好的工作。那种强度，那种你需要专注于真正前沿的数学，这可能类似于你需要做的那种疯狂的编程，我小时候曾经做过。</p><p class="normal">I think that the actual production of code—of working, logical, good code—requires an intensity and a mental agility in terms of picking up new things that I, at least, find hard to do now. The other side of the coin is that you get a certain wisdom about things that you certainly didn't have when you were younger. I know better now how to do things. So I find a better mix is to be able to give young and active people guidance. I think that by and large the sort of programming that I've been talking about is similar to the old saw about mathematics, that most mathematicians do most of their best work well before they're 30. The kind of intensity, the kind of focus that you need to do really cutting-edge mathematics is probably similar to what you need to do the kind of crazy programming I used to do back when I was young.</p>
<p class="normal"><b>Seibel：</b>强度的一部分是，长时间工作只会消耗体力。长时间工作是必要的，还是只是我们喜欢它这一事实的副作用？</p><p class="normal"><b>Seibel:</b> One part of the intensity is that it's simply physically draining to work long hours. Are long hours necessary or are they just a side effect of the fact that we love it?</p>
<p class="normal"><b>Cosell：</b>我认为这是性格的副作用。你是否可以放下一些东西然后再回来做，或者你是否被迫坚持下去并完成它，这更多是一种个性问题。我在 BBN 认识的人中肯定有很多杰出的人，他们完全能够正常工作，并且对周末来上班不感兴趣。当然，还有其他处于疯狂边缘的人——有一段时间我在电脑室睡觉，因为我开车回公寓的时间太长了。我只是在电脑室小睡一会儿，我不知道人们认为我这样做有多疯狂。但我不认为那是<a id="OEBPS/Chapter14.html.page_554"></a>必要的; 我认为这是我们所做的事情非常令人兴奋的事实的副产品，尤其是当它开始走到一起时。</p><p class="normal"><b>Cosell:</b> I think that's a personality side effect. The question of whether you can put something down and come back to it or whether you are compelled to stick with it and finish it is more of a personality thing. There were certainly many people I knew of at BBN out in the brilliant end of the spectrum who were perfectly able to work normal hours and not be interested in coming in on weekends. Then, of course, there were the other people who were at the lunatic fringe—for a while I was sleeping in the computer room because it took me too long to drive back to my apartment. I would just take a nap in the computer room and I have no idea how crazy people thought I was for doing that. But I don't think that is <a></a>necessary; I think it's a byproduct of the fact that doing the kind of thing that we do is pretty exciting, especially when it starts to come together.</p>
<p class="normal">BBN 的一位真正优秀的人最终按照完全正常的时间表工作<i>，并且</i>仅仅靠严格的纪律就完成了他的博士论文。他每个星期六都写论文，晚上还写这个写那个。我想，其中一部分正在组织中。如果你能从头到尾做一件事，做起来就容易多了，到那时你就不必考虑要有条理、小心翼翼，或者把它放下再捡起来，因为当你完成后，你可以忘掉它。我最近一直在学习，因为我的生活现在更正常了。我绕过裂缝进行编程，放下东西并重新拾起东西。我发现，如果我两到三周内不再处理它，就很难再重新开始。通常当我在一些小的个人编程事情上落后并且我真的想完成它时，我试着说，“好的，我” 我会像那些锻炼的人一样。我打算每天早上做几个小时。” 这主要对我不起作用。发生的事情是在某个时候我对没有完成它感到厌倦，我会花一两天时间完成它。</p><p class="normal">One of the really good guys at BBN ended up working a perfectly normal schedule <i>and</i> finished his PhD dissertation just by being astoundingly disciplined. He worked every Saturday on his thesis and he worked evenings on this and that. Part of it, I guess, is being organized. It is much easier to do something if you can do it all the way through, at which point you don't have to think about being organized or careful or putting it down and picking it back up, because when you're done you can forget about it. I've been learning that recently since my life is more normal now. I program around the cracks, putting things down and picking things back up. I find that if I don't work on it again for two to three weeks it's surprisingly hard to pick it back up. Often when I am lagging on some little personal programming thing and I really want to get it done, I try to say, “OK, I'm going to be like the people who exercise. I'm going to do it a couple hours every morning.” That mostly doesn't work for me. What happens is at some point I get bored with having it not be done and I'll spend a day or two on it and get it done.</p>
<p class="normal">我可以突然获得以前的那种专注，但不再那么好了。所以我认为这使得这种特别的、花哨的编程——真正的黑客所做的——更像是年轻人的游戏。我不得不承认，几乎所有我认识的人在年轻时就做出了杰出的成就，他们都非常努力。我很难想出任何真正杰出的人每天只做几个小时就好像这是一份工作一样。几乎我认识的每个人都会以这种疯狂的专注和强度去做这件事，然后完成它。但是重点很难。它真的让你筋疲力尽。它肯定曾经让我疲惫不堪。</p><p class="normal">I can, in bursts, get the kind of focus I used to have, but not so well anymore. So I think that makes this kind of special, fancy programming— what the true hackers do—more of a young person's game. I have to admit almost all of the people I know who did stellar things when they were young did it intensely. It's hard for me to think of any folks in the really stellar category who did it just a couple hours a day as if it were a job. Almost everyone I know would do it with this burst of maniacal focus and intensity and then get it done. But the focus is hard. It really wears you out. It certainly used to wear me out.</p>
<p class="normal"><b>Seibel：</b>你认为自己是科学家、工程师、艺术家、工匠还是其他什么？</p><p class="normal"><b>Seibel:</b> Would you consider yourself a scientist, an engineer, an artist, a craftsman, or something else?</p>
<p class="normal"><b>Cosell：</b>很明显，两者的结合。我不认为自己是科学家，因为我了解科学家的工作。我愿意相信我认为自己是艺术家和工匠的结合体。我做工程的方式是艺术与工艺的结合。</p><p class="normal"><b>Cosell:</b> A blend of those, obviously. I don't consider myself a scientist, as I understand what scientists do. I'd like to believe I consider myself a combination of an artist and a craftsman. The way I do engineering is as a combination of art and craft.</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_555"></a><b>Seibel：</b>让我先问一下工程部分。肯定有人，比如 Watts Humphrey 和软件工程学院的人，他们说编程应该像建造桥梁一样成为一门工程学科。人们可以建造桥梁，他们可以预测需要多长时间，而桥梁在大多数情况下不会倒塌。</p><p class="normal"><a></a><b>Seibel:</b> Let me first ask about the engineering part. There are certainly folks, like Watts Humphrey and the folks at the Software Engineering Institute, who say programming should be an engineering discipline just like building bridges. People can build bridges and they can predict how long it's going to take, and the bridges, for the most part, don't fall down.</p>
<p class="normal"><b>科塞尔：</b>完全正确。这个类比非常好，只是他们在中间加上了一个不合逻辑的推理。事实证明，设计桥梁使其不会倒塌的人不是架设电缆或检查电缆以确保钢材正确或浇筑混凝土或做任何其他事情的人。</p><p class="normal"><b>Cosell:</b> Exactly right. The analogy is very good except they put a non sequitur in the middle of it. It turns out that the guy that designs the bridge so it won't fall down is not the guy that strings the cables or that inspects the cables to make sure the steel was right or pours the concrete or does any of those other things.</p>
<p class="normal">在这方面，编程是一门工程学科。你必须知道该怎么做。你必须知道你的能力是什么。在我工作的水平上，我必须能够设想各个部分将如何组合在一起。我必须对什么东西快什么东西慢，什么东西很难构建，什么东西容易构建有一些直觉，并在工程层面上提出一个我认为将要实现的模型发生。</p><p class="normal">Programming is in that regard an engineering discipline. You have to know what to do. You have to know what your capabilities are. At the level I was working, I had to be able to envision how the pieces were going to fit together. I had to have some intuition for what things were fast and what things were slow, what things were hard to build, what things were easy to build, and come up with, at the engineering level, a model of what I thought was going to happen.</p>
<p class="normal">艺术家部分决定设计应该优雅。这些组合在一起是因为在计算机程序中，艺术性会影响它的寿命。我称之为计算机程序的艺术性的部分原因在于，未来的人们能够轻松地更改它而不破坏它。这与构建它的功能无关，而是与它作为现有事物的生命有关。</p><p class="normal">The artist part decides that the design should be elegant. Those fit together because in computer programs the artistry affects the longevity of it. Part of what I call the artistry of the computer program is how easy it is for future people to be able to change it without breaking it. That doesn't have anything to do with constructing its functionality but with its life as an existing thing.</p>
<p class="normal"><b>Seibel：</b>所以对你来说，代码的美与人们将不得不改变它的事实密切相关。</p><p class="normal"><b>Seibel:</b> So for you the beauty of code is tied up with the fact that people are going to have to change it.</p>
<p class="normal"><b>Cosell：</b>我写的一两个东西是黑盒子，只要计算机循环就可以运行，但其中大部分是几代人能够反复敲打的代码，而且大多不会一直崩溃。当我谈论它的艺术性和美感时，我所说的是这样的想法，即当您编写程序时，您有很大的自由裁量权。你如何组织你的例程，你如何在页面上布置它们，你决定在哪里放置注释，你如何命名你的变量，你是否希望你的子例程都具有统一的调用顺序或适合情境的代码。</p><p class="normal"><b>Cosell:</b> One or two things I wrote were black boxes that just had to run as long as the computer cycled, but most of them were code that generations of people were able to hammer on and mostly not keep breaking. When I talk about the artistry and the beauty of it, what I'm talking about is the idea that when you write a program you have a huge amount of discretion. How you organize your routines, how you lay them out on the page, where you decide to put comments, how you name your variables, whether you like your subroutines to all have uniform calling sequences or situational-appropriate code.</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_556"></a>所以你必须在以后的某个时候通过一个新程序员的眼睛来看待这个程序。程序的结构是怎样的？你在做什么？你怎么样？你为什么要这样做？艺术性是下一个阅读该程序并理解该子程序应该执行此操作的人的方式——他得到的信息是，他不应该去把它搞砸去做其他事情，他应该保持结构该程序。</p><p class="normal"><a></a>So you have to look at the program through the eyes of a new programmer sometime down the road. What's the structure of the program? What are you doing? How are you doing it? And why are you doing it? The artistry is how the next guy that reads the program and understands that this subroutine was supposed to do this—he gets the message that it's not right for him to go and muck it up to do something else and that he should keep the structure of the program.</p>
<p class="normal"><b>Seibel：</b>清晰度和效率之间的紧张关系如何？有时最简单、最容易阅读的代码并不是最快的。</p><p class="normal"><b>Seibel:</b> What about the tension between clarity and efficiency? Sometimes the simplest, easiest-to-read code isn't the fastest.</p>
<p class="normal"><b>Cosell：</b>程序员是世界上最糟糕的优化者。他们总是优化代码中最值得优化的部分，而几乎永远不会得到真正需要优化的代码部分。所以你会得到这些毫无意义的非常困难的代码。我总是告诉和我一起工作的人，“尽可能清晰、易读、清晰地编写代码。用简单的方法来做。然后，如果需要加快速度，我们将在稍后处理。如果你做对了，我们可以在这件作品周围画一个小盒子。”</p><p class="normal"><b>Cosell:</b> Programmers are the worst optimizers in the world. They always optimize the part of the code that's most interesting to optimize, and almost never get the part of the code that actually needs optimization. So you get these little nuts of very difficult code that have no point. I always tell the people working with me, “Code it as lucidly, as easy to read, as crystal-clear as you can. Do it the simple way. And then if it needs to be sped up, we'll deal with that later. If you've done it right, we can draw a little box around this piece.”</p>
<p class="normal">很久以前，Emacs 的一个版本有一页源代码，在评论中有一个巨大的骷髅头和交叉骨，上面写着类似这样的话：“严重扭曲的代码遵循这个东西。” 这是搜索代码的一些最核心的内容，或者类似的东西，他们已经从地狱中优化出来了。就是这个地方可以看出这块真的很硬。所以它周围有一个大黑框，上面写着：“不要在这里迷路，除非你知道自己在做什么。”</p><p class="normal">Eons ago one of the versions of Emacs had one page of the source code that was a gigantic skull and crossbones in comments that said something like: “Seriously twisted code follows this thing.” It was some piece of the innermost guts of the search code or something like that that they had optimized the hell out of. That's a place where I can see that this piece is really tough. So there's a big black box around it saying, “Don't stray in here, unless you know what you're doing.”</p>
<p class="normal">但是就我在做 PDP-1 时学到的优雅而言，我们现在编写的程序更大更笨拙，而且速度更慢。这很好。事实证明这无关紧要。现在，那些做视频合成的人和那些做 CGI 动画的人，显然那些人没有那么奢侈。这需要一些非常仔细的编程。我不能再那样做了；为此，我已经过山了。但我可以这样做一次。我理解那些这样做的人。但是我们所做的大多数程序只是例行公事。</p><p class="normal">But programs we write these days are bigger and clumsier, in terms of the elegance I learned when I was doing PDP-1, and slower. And that's fine. It turns out it doesn't matter. Now, the guys doing video synthesis and the guys doing the CGI animation stuff, clearly those guys don't have that luxury. That takes some beaucoup careful programming. I could not do that anymore; I am way over the hill for that. But I could do that once. And I understand the guys that do that. But most of the programs we do are just routine crap.</p>
<p class="normal">在一些大学，他们有一个从 9 月到 5 月的两个学期的课程，你必须在大学学习一些相当困难的课程。<a id="OEBPS/Chapter14.html.page_557"></a>开始。他们没有警告你的是，在四月份他们会让你再次参与这个项目，现在已经真正让你在其他事情上度过了难关。这个想法是为了让你惊讶于记住六个月前你认为自己完全理解的东西是多么困难。</p><p class="normal">At some college they had a two-semester course from September right through May and you had to work on some fairly hard program at the <a></a>beginning. What they didn't warn you was in April they were going to make you work on the program again, having now really run you through the hoops on other things. The idea was for you to be stunned at how hard it was to remember whatever it was you thought you understood perfectly clearly just six months ago.</p>
<p class="normal"><b>Seibel：</b>所以你在最后一个周末之前所做的所有事情都会回来困扰你。</p><p class="normal"><b>Seibel:</b> So all that stuff that you did at the last weekend before it was due comes back to haunt you.</p>
<p class="normal"><b>科塞尔：</b>没错。我认为这是一个绝妙的计划。它给他们上了一课，除非在现实世界中，否则很难得到。</p><p class="normal"><b>Cosell:</b> That's right. I thought that was a brilliant scheme. It's teaching them a lesson that is hard to get except in the real world.</p>
<p class="normal"><b>Seibel：</b>当我与 Ken Thompson 交谈时，我问他 C 语言是否存在导致安全问题的内在问题，他基本上说这不是问题所在。您教授计算机安全课程——您对此有何看法？</p><p class="normal"><b>Seibel:</b> When I talked to Ken Thompson I asked him about whether there were inherent problems in C that lead to security problems and he basically said that's not the problem. You teach courses on computer security—what do you think of that?</p>
<p class="normal"><b>Cosell：</b>我不想和他交锋，但我在我的计算机安全课上说过，现代计算机面临的最大安全问题是 C。它被设计成一种系统编程语言，它是一个非常舒适的系统——所有能手都使用它的编程语言。我们用它构建了操作系统。我们用它构建了实时系统。</p><p class="normal"><b>Cosell:</b> I would hate to cross swords with him, but I say in my computer-security class that the biggest security problem to befall modern computers is C. It was designed to be a systems-programming language and it was such a comfortable systems-programming language that all the hotshots used it. We built operating systems out of it. We built real-time systems out of it.</p>
<p class="normal">我记得帕斯卡时代的战争。争论的焦点是计算机应该帮助你；C 语言太危险了。我记得的两个大声音是 Wirth 和 Dijkstra。另一边是我认识的所有系统程序员，包括我自己。我用 C 写了所有东西。所以 C 在当时推动了无数种语言的发展。</p><p class="normal">I remember the wars in the days of Pascal. The argument was that computers should help you; that C was too dangerous a language. The two big voices I remember were Wirth and Dijkstra. On the other side was every systems programmer I know, including me. I wrote everything in C. So C sort of steamrolled the zillions of languages back then.</p>
<p class="normal">政府试图强制执行 ADA，除非他们在 ADA 中，否则他们不会让合同。C压倒了那些。这真是太棒了。但是当我现在看它时，几乎每天我仍然感到震惊，因为它几乎不可能用 C 语言编写任何真正复杂的程序并且没有安全问题。程序员在没有明确确保缓冲区末尾不会运行的情况下从不读入缓冲区，从不在错误的时间释放内存块以便指针指向其他地方所需要的注意程度程序变得陈旧，永远不会存储大小错误的东西并且碰巧踩到下一个值 - 这些问题很难找到。</p><p class="normal">The government tried to mandate ADA and they wouldn't let contracts unless they were in ADA. C steamrolled over those. It was just amazing. But as I look at it now, I am still stunned almost every day that it borders on the impossible to write a program of any real complexity in C and not have a security problem. The amount of care it takes for a programmer to never do a read into a buffer without explicitly making sure it can't run over the end of the buffer, to never free a block of memory at the wrong time so a pointer way elsewhere in the program becomes stale, to never store something that's the wrong size and happens to step on the next value— those problems can be so hard to find.</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_558"></a>它在系统编程中一直是一个福音。我们将用汇编语言编写我们的系统，并用 Pascal 语言编写我们所有的应用程序的想法让我脊背发凉。我不认为这是正确的答案。但是用 C 编写系统和应用程序，我不得不说已经证明不能很好地工作。太难了。</p><p class="normal"><a></a>It has been such a boon in systems programming. The idea that we would write our systems in assembler and all our applications in Pascal sent shivers down my spine. I don't think that was the right answer. But writing both systems and applications in C, I would have to say has proven just not to work very well. It's just too hard.</p>
<p class="normal">这有点像我们遇到的中断错误问题。您可能会争辩说，编写带有序列中断或中断的程序并没有真正的魔力。这没有真正的问题。需要一点理解，一点用心。但我知道一个事实，即理解所有这些的非常优秀的程序员将这些错误放入他们的程序中。像我这样的程序员必须来修复它，而我必须像 Niklaus Wirth 那样发明一种不会让他们产生中断错误的计算机语言。</p><p class="normal">It's kind of like the problems we had with interrupt bugs. You could argue that there's no real magic in writing a program with sequence breaks or interrupts. There's no real problem with that. It takes a little bit of understanding and a little bit of care. But I know for a fact that very good programmers who understand all of that put those bugs in their programs. A programmer like me would have to come and fix it and I had to do the Niklaus Wirth—style thing of inventing the computer language that wouldn't let them make interrupt bugs.</p>
<p class="normal">对于 IMP 系统，我写了一组复杂的汇编宏，所以你可以声明你在做什么。当你进入一个中断时，你写了一个声明，说“我在调制解调器输入上”或“我在高优先级时钟或低优先级时钟上”。然后当它组装你的程序时，它实际上标记了每条指令它正在运行的中断级别然后有一个我可能用 TECO 宏编写的后处理器，老实说，处理它并寻找分时问题。它会寻找一个被两个不同级别访问的变量，然后它会说，“存在中断冲突。” 现在突然之间，分时错误就会消失。其他程序员可以理解，如果他们放入正确的声明，这些宏将防止他们产生时序错误。</p><p class="normal">For the IMP system I wrote a complicated set of assembler macros, so you could declare what you were doing. When you came in on an interrupt, you wrote a declaration that says, “I am on modem input” or “I am on the high-priority clock or the low-priority clock.” And then when it assembled your program, it actually tagged every instruction with which interrupt level it was running on and then there was a postprocessor that I probably wrote in TECO macros, honest to God, that processed that and looked for timesharing problems. It would look for a variable that was accessed by two different levels and it would say, “There is an interrupt conflict.” Now all of a sudden, the time-sharing bug would go away. Other programmers could understand that if they put the right declarations in, these macros would keep them from making timing bugs. I got a trip to Hungary to present how you could get programmers who don't really understand real-time issues to be able to write solid real-time programs by using this technique to abstract out the conflict problems.</p>
<p class="normal">这就是我对 C 的一点感觉。我确信有优秀的程序员，也许包括我在内，可以编写优秀的 C 程序。但这比必须的要难。在现代环境中，它变得更难了，因为环境要困难得多——C 的弱点可以被利用或忽视的地方的数量，它需要注意的程度。这就是我非常喜欢用 Perl 编写的原因之一。Perl 很慢。我确定它是速度较慢的语言之一，但本质上它<a id="OEBPS/Chapter14.html.page_559"></a>修复了 C 语言编程的所有安全问题。当您在 Perl 中索引数组末尾时会发生什么？它使更多的阵列。</p><p class="normal">That's a little bit the way I feel about C. I'm sure that there are good programmers, perhaps including me, who can write good C programs. But it's just harder than it has to be. In the modern environment it's gotten harder because the environment is so much more difficult—the number of places where C's weaknesses can be exploited or overlooked, the amount of care it takes. That's one reason why I'm very comfortable writing in Perl. Perl is slow. I'm sure it's one of the slower languages, but in essence it <a></a>repairs all of the security problems of programming in C. What happens when you index off the end of the array in Perl? It makes more array.</p>
<p class="normal">它知道它的指针指向什么，所以你永远不会误引用一个指针，因为你只说要通过它，它会告诉你它要去哪里。所以我更愿意在 Perl 中构建安全必要的应用程序，因为我有一个充满 Perl 核心的世界，并且它已经稳定了这么多年。我不认为我们会发现太多分配错误或指针错误，而且无论如何都很难从随机 Perl 代码中利用它们。我不必相信我周围的程序员能够正确检查每个指针。</p><p class="normal">It knows what its pointers point to, so you can never misreference a pointer because you only say to go through it and it tells you where it's going. So I'm much more comfortable building security-necessary applications in Perl because I have a world full of Perl people pounding on the core and it's been stable for so many years. I don't think we're going to find too many allocate bugs or pointer bugs, and they're hard to exploit from random Perl code anyway. I don't have to trust the programmers around me to get every pointer check right.</p>
<p class="normal">即便如此，我们也能得到类似经典程序的程序，其中有人编写了一个网页，该网页在表格中查找某人，而一些黑客在输入中输入了一些内容，看起来像“乔；删除所有表格”。那仍然发生。这显然不是 C 的错，但它表明程序员不够小心。他们看不到所有的地方。而C让地方太多了。对我来说太可怕了，我想公平地说我编写 C 语言的时间比 Ken 少了大约五年。我们不在同一个联盟，但我在 C 方面有很长的历史，并且知道它有多困难，我认为 C 是问题的重要组成部分。</p><p class="normal">And even then we get programs like the classic one where somebody wrote a web page that was looking up somebody in a table and some hacker put something in the input that looked like, “Joe;drop all tables.” That still happens. That's obviously not C's fault, but it shows programmers just can't be careful enough. They don't see all the places. And C makes too many places. Too scary for me, and I guess it's fair to say I've programmed C only about five years less than Ken has. We're not in the same league, but I have a long track record with C and know how difficult it is and I think C is a big part of the problem.</p>
<p class="normal">随着这些应用程序变得越来越复杂，并且建立在越来越复杂的库之上——而且没有人会理解库中的安全漏洞，因为它们非常复杂——我们可能不得不转向更复杂的应用程序开发语言无故障。处理器变得快得让人眼花缭乱，内存变得便宜得离谱。我不知道明天的语言是什么。我不认为 C 或其派生语言（如 C++）真的会成为未来重型程序应用程序（甚至系统开发）的正确工具。</p><p class="normal">As these applications get more complicated, and built on more and more complicated libraries—and nobody will ever understand the security cracks in the libraries because they're so immensely complicated—probably we'll have to move toward application-development languages that are more fault-free. Processors are becoming blindingly fast and memory is becoming ridiculously cheap. I don't know what tomorrow's language is. I don't think C or its derivatives such as C++ are going to really be the right vehicle for heavy-duty program application—even system development—going forward.</p>
<p class="normal">Java感觉不对。我的旧反应击中了我。Java 给我的印象是过于专制。这就是为什么我提到 Perl 感觉很好的原因之一，因为它有安全和检查，但它是如此该死的多维，我的艺术家部分有很多自由板来清晰地表达事物并思考正确的事情做事的方式。我有一些自由。</p><p class="normal">Java didn't feel right. My old reflexes hit me. Java struck me as too authoritarian. That's one of the reasons why I mentioned that Perl felt so good, because it's got the safety and the checks but it is so damn multidimensioned that the artist part of me has a lot of free board to express things clearly and to think about the right way to do things. I have some freedom.</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_560"></a>当我第一次接触 Java 时——当然，那时候它还是一门幼稚的语言——我说，“哦，这只是那些语言中的另一种，它通过限制他们的能力来帮助不太优秀的程序员走直线和走窄路。可以做。” 但也许我们已经到了正确的地步。也许世界已经变得如此危险，你无法拥有一种好的、灵活的语言，让 1% 或 2% 的程序员会用它来创造伟大的艺术，因为世界上现在有 7500 万普通程序员在构建这些极其复杂的应用程序，他们需要的帮助远不止于此。所以也许 Java 是正确的选择。我不知道。</p><p class="normal"><a></a>When I first messed with Java—this was when it was little baby language, of course—I said, “Oh, this is just another one of those languages to help not so-good programmers go down the straight and narrow by restricting what they can do.” But maybe we've come to a point where that's the right thing. Maybe the world has gotten so dangerous you can't have a good, flexible language that one percent or two percent of the programmers will use to make great art because the world is now populated with 75 million run-of-the-mill programmers building these incredibly complicated applications and they need more help than that. So maybe Java's the right thing. I don't know.</p>
<p class="normal"><b>Seibel：</b>当我与在 IBM 从事 Fortran 编译器工作的 Fran Allen 交谈时，她从一个完全不同的角度对 C 感到非常沮丧，因为它太低级了，所以不可能编写真正高度优化的编译器。</p><p class="normal"><b>Seibel:</b> When I spoke with Fran Allen, who worked at IBM on Fortran compilers, she was quite upset about C from a completely different perspective, which was it made it impossible to write really highly optimizing compilers because it was so low-level.</p>
<p class="normal"><b>Cosell：</b>现在，她在另一个阵营。她正在研究编译器；她认为 C 是一个糟糕的、笨拙的步骤，你不能用它做任何事情。而我们使用的是微不足道的汇编程序，而 C 就像一股清新的空气。所以当然，当时大多数最优秀的程序员并不是编写 BASIC 程序的人，也不是编写用于计算的 Fortran 程序的人。真正的重量级人物当然是编写所有汇编代码的人。所以我们去了 C，因为 C 就像呼吸新鲜空气一样。如果您认为 C 在数组检查方面存在问题，请尝试在汇编程序中编写数组循环。所以在这方面，这是一个很大的福音。</p><p class="normal"><b>Cosell:</b> Now, she's in a different camp. She's working on compilers; she sees C as this awful, clunky step down that you can't do anything with. Whereas we were working with bit-twiddling assemblers and C was like a breath of fresh air. So of course most of the very best programmers back then were not the guys writing BASIC programs and not so much writing Fortran programs doing calculations. The real heavy hitters were of course the guys doing all the assembly code. So we went to C because C was like breath of fresh air. If you think C has problems with array checks, try writing your array loops in assembler. So in that regard, it was a great boon.</p>
<p class="normal">我不想说 C 已经失去了它的用处，但我认为它被太多优秀的程序员使用，以至于现在不够优秀的程序员正在使用它来构建应用程序，而底线是它们并不好够了，他们做不到。也许 C 是真正优秀的系统程序员的完美语言，但不幸的是，不太优秀的系统和应用程序程序员正在使用它，他们不应该使用它。</p><p class="normal">I don't want to say that C has outlived its usefulness, but I think it was used by too many good programmers so that now not-good-enough programmers are using it to build applications and the bottom line is they're not good enough and they can't. Maybe C is the perfect language for really good systems programmers, but unfortunately not-so-good systems and applications programmers are using it and they shouldn't be.</p>
<p class="normal"><b>Seibel：</b>您认为编程的本质是否因为我们不再了解它的工作原理而发生了变化？</p><p class="normal"><b>Seibel:</b> Do you think that the nature of programming has changed as a consequence of the fact that we can't know how it all works anymore?</p>
<p class="normal"><b>科塞尔：</b>哦，是的。这是让我更像恐龙的另一件事。一切都建立在假设之前发生的事情之上。我记得在我们旧的 PDP-11，第 7 版 Unix 上，我们正在做一些动画和<a id="OEBPS/Chapter14.html.page_561"></a>图形。那是一件大事。很难编程。显示器不方便。没有图书馆。</p><p class="normal"><b>Cosell:</b> Oh, yeah. That's another thing that makes me a little bit more dinosaurlike. Everything builds assuming what came before. I remember on our old PDP-11, 7th edition Unix, we were doing some animation and <a></a>graphics. That was a big deal. It was hard to program. The displays weren't handy. There were no libraries.</p>
<p class="normal">每一代程序员都离底层的东西越来越远，并且拥有越来越高级的工具来做事。好的部分是他们可以做更聪明的事情。基线是如此之好，以至于接下来的事情非常壮观，然后成为基线，两年后它变得更好。问题是这些基线变得越来越复杂。与正在发生的一些事情相比，PDP-1 指令集就像在公园里散步一样。</p><p class="normal">Each generation of programmers gets farther and farther away from the low-level stuff and has fancier and fancier tools for doing things. The good part is they can do cleverer things. The baseline is so good that the next thing is spectacular and that then becomes the baseline and two years later it becomes even better. The trouble is that these baselines are getting more and more complicated. The PDP-1 instruction set was like a walk in the park compared to some of the stuff that's happening.</p>
<p class="normal">我不想成为 Microsoft 的那些必须构建这些在四核多处理器上运行的操作系统的人。视频卡已经发展到拥有数兆内存的地步，并在其上配备了完整的流水线并行处理器，可以动态处理数组和向量。所以你现在使用你的视频卡作为这个非常奇特的数据处理器。我一直在想对这些东西进行编程是多么困难。</p><p class="normal">I would hate to be the guys at Microsoft who have to build these operating systems that run on the quad-core multiprocessor. Video cards have grown to the point where they have multiple megs of memory, and complete pipeline parallel processors on them that can do array and vector things on the fly. So you now use your video card as this very fancy data processor. I keep thinking how hard it must be to program these things.</p>
<p class="normal">我们有一个叫做 IMLAC 的东西，它是早期的机器之一，它实际上有一个很好的集成矢量显示，就像旧的 PDP-1 那样，但它是一台迷你电脑。有一个程序让你坐在一辆小推车上做一个迷宫的 3-D 显示。所以你看到墙壁过来了。你可以偷看角落。我很着迷，因为它进行了隐藏线抑制。这是在人们在<i>ACM 的通信</i>中撰写有关算法的文章的时代。我有一整本书关于如何使用对称坐标和某人的算法来找出两条线交叉的位置，这样你就知道一条线在哪里穿过一个平面，所以你知道那是你必须停止线的地方，因为它现在被隐藏了。</p><p class="normal">We had a thing called an IMLAC, which is one of the early machines that actually had a nice integrated vector display on it the way the old PDP-1 did but it was a mini computer. There was a program for that that had you sitting on a little cart doing a 3-D display of a maze. So you saw the walls coming by. You could peek around corners. I was fascinated because it did hidden-line suppression. This is in the era where guys are writing articles in <i>Communications of the ACM</i> about algorithms. I have a whole book about how to use symmetric coordinates and somebody's algorithm for figuring out where two lines cross so you know where a line crosses a plane so you know that that's where you have to stop the line because it now becomes hidden.</p>
<p class="normal">做隐藏线的事情在当时是一件大事，那个程序做到了。我只是被那个程序惊呆了。那是大不了的代码——奇异的东西。现在，据我所知，视频卡采用 3-D 坐标，视频卡进行隐藏线抑制。八、九年前，纹理贴图和光线追踪之类的东西很重要。在代码中很难做到。你的程序花了好几个小时才让球体闪闪发光。</p><p class="normal">Doing the hidden-line thing was a big deal back then and that program did it. I was just stunned by that program. That was big deal code—singular stuff. Now, as far as I can tell, the video cards take 3-D coordinates and the video cards do the hidden-line suppression. Eight, nine years ago things like texture mapping and ray tracing were big deals. Hard to do in code. It took your program hours to get the glint off of a sphere.</p>
<p class="normal">现在我发现视频卡可以进行光线追踪。所以一方面你有这些人在 NVIDIA 工作，他们必须做的事情<a id="OEBPS/Chapter14.html.page_562"></a>非常复杂的东西，现代程序员不再满足于只写一个有小线条画墙的东西——他必须掌握这个令人难以置信的 3-D 视频环境，这个环境建立在越来越复杂的库上。它们比自己编写代码更容易，但我无法理解这些天人们如何吸收所有这些代码。它对我来说太巨大了。</p><p class="normal">And now I discover that video cards do the ray tracing. So on the one hand you have these guys working at NVIDIA and stuff who must be doing <a></a>incredibly complicated stuff and you have the modern programmer who no longer can be content just writing a thing with little line-drawn walls—he has to master this incredible 3-D video environment that's built on libraries that have gotten more and more complicated. They're easier than it would be to write the code yourself, but I can't fathom how people can absorb all of that these days. It just seems so huge to me.</p>
<p class="normal">我只是在做 Tk 时遇到了这个问题。我一直在尝试做一个小的 Tk 程序，我对 Tk 的复杂程度和它有多少钩子，以及你需要做什么才能使按钮变大或变小或在这里或那里感到震惊。掌握那东西只是一件大事。相比之下，理解 PDP-1 分时系统就简单多了。</p><p class="normal">I run into that just with doing Tk. I've been trying to do a little Tk program and I am stunned by how complicated Tk is and how many hooks it's got, and what you need to do in order to make the button be bigger or smaller or here or there. Mastering that thing is just a huge thing. Understanding the PDP-1 time-sharing system was simple by comparison.</p>
<p class="normal">所以我不羡慕现代程序员，而且它会变得更糟。简单的东西被打包到库中，只留下困难的东西。事情变得如此复杂，但人们期望的标准令人惊叹。他们给我看的其中一个让我震惊。他给我看谷歌地图，它会为你做路线。您可以做的一件事是，您可以用鼠标抓取一段路线并将该段路线拖到其他地方，以告诉谷歌您希望这条路线去那里。然后它会重新映射路线，使其通过您刚刚拖动点的位置。现在我知道里面发生了什么：一堆用于鼠标跟踪的 JavaScript 代码。当您放开鼠标时，它必须执行 Ajax XML 请求以告诉妈妈系统他刚刚将此点放在路线上。然后路由必须进行增量更新。计算路线。我什至无法想象他们是如何把代码写得这么好的。人们抱怨说你的路线会穿过人们的后院之类的，但最佳路线问题是计算机科学的经典问题之一。如何获取这个任意图并找到通过图的最短路径。简直太棒了。</p><p class="normal">So I don't envy modern programmers, and it's going to get worse. The simple things are getting packaged into libraries, leaving only the hard things. That stuff is getting so complicated, but the standards that people are expecting are stunning. One of the ones they showed me stunned me. He was showing me Google Maps that will do routes for you. One of the things you can do is you can grab a piece of the route with your mouse and drag that piece of the route somewhere else to tell Google that you want the route go there. Then it remaps the route so that it goes through where you just dragged the point. Now I know what's going on in there: a pile of JavaScript code for the mouse tracking. When you let go of the mouse it has to do an Ajax XML request to tell momma system that he just put this point on the route. The route then has to do incremental updates. Calculating the route. I can't even imagine how they do that code so well. People complain that you get routed through people's backyards and stuff like that, but the optimal-route problems are one of the classic problems of computer science. How to take this arbitrary graph and find the shortest path through a graph. Just stunning.</p>
<p class="normal">在某种程度上，我在想，“你能做到这一点真是太酷了。” 另一方面，我内心的程序员在说，“天哪，我很高兴当我还是一名程序员的时候这还不存在。” 我永远不可能编写所有这些代码来做这些事情。这些人是怎么做到的？肯定有一代程序员比我当程序员的时候更好。我很高兴我曾经是一名优秀的程序员而不必再实际证明它而可以享有一点声誉，因为我认为我做不到。</p><p class="normal">At one level I'm thinking, “This is way cool that you can do that.” The other level, the programmer in me is saying, “Jesus, I'm glad that this wasn't around when I was a programmer.” I could never have written all this code to do this stuff. How do these guys do that? There must be a generation of programmers way better than what I was when I was a programmer. I'm glad I can have a little bit of repute as having once been a good programmer without having to actually demonstrate it anymore, because I don't think I could.</p>
<p class="normal"><a id="OEBPS/Chapter14.html.page_563"></a>这是成为名誉退休程序员的好时机，因为你有一些道具，因为你做过一次，但世界是如此奇妙，你可以利用它，甚至可能偶尔获得一点荣誉它不必仍然能够做到这一点。而如果你在大学里——如果你主修计算机科学，你必须走出去，你必须弄清楚你将如何添加到这堆东西中——救救我吧。</p><p class="normal"><a></a>This is a good time to be an over-the-hill programmer emeritus, because you have a few props because you did it once, but the world is so wondrous that you can take advantage of it, maybe even get a little occasional credit for it without having to still be able to do it. Whereas if you were in college—if you major in computer science and you have to go out there and you have to figure out how you are going to add to this pile of stuff—save me.</p>
</div>
</div></div>
<div id="OEBPS/Chapter15.html"><div>

<div class="booksection">
<p></p>
<h2 class="chapnum"><a id="OEBPS/Chapter15.html.ch15"></a><a id="OEBPS/Chapter15.html.page_565"></a><img src="data:image/jpg;base64,/9j/4AAQSkZJRgABAgEASABIAAD/7Q2sUGhvdG9zaG9wIDMuMAA4QklNA+0KUmVzb2x1dGlvbgAAAAAQAEgAAAABAAEASAAAAAEAAThCSU0EDRhGWCBHbG9iYWwgTGlnaHRpbmcgQW5nbGUAAAAABAAAAHg4QklNBBkSRlggR2xvYmFsIEFsdGl0dWRlAAAAAAQAAAAeOEJJTQPzC1ByaW50IEZsYWdzAAAACQAAAAAAAAAAAQA4QklNBAoOQ29weXJpZ2h0IEZsYWcAAAAAAQAAOEJJTScQFEphcGFuZXNlIFByaW50IEZsYWdzAAAAAAoAAQAAAAAAAAACOEJJTQP1F0NvbG9yIEhhbGZ0b25lIFNldHRpbmdzAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+BdDb2xvciBUcmFuc2ZlciBTZXR0aW5ncwAAAHAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAOEJJTQQAC0xheWVyIFN0YXRlAAAAAgABOEJJTQQCDExheWVyIEdyb3VwcwAAAAAEAAAAADhCSU0ECAZHdWlkZXMAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4NVVJMIG92ZXJyaWRlcwAAAAQAAAAAOEJJTQQaBlNsaWNlcwAAAAB1AAAABgAAAAAAAAAAAAAArwAAAPgAAAAKAFUAbgB0AGkAdABsAGUAZAAtADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAPgAAACvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhCSU0EERFJQ0MgVW50YWdnZWQgRmxhZwAAAAEBADhCSU0EFBdMYXllciBJRCBHZW5lcmF0b3IgQmFzZQAAAAQAAAACOEJJTQQMFU5ldyBXaW5kb3dzIFRodW1ibmFpbAAACdAAAAABAAAAcAAAAE8AAAFQAABnsAAACbQAGAAB/9j/4AAQSkZJRgABAgEASABI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" alt="图片"></h2><h2 class="chapnum"><a></a><a></a></h2>
<h2 class="chaptitle">唐纳德高德纳</h2><h2 class="chaptitle">Donald Knuth</h2>
<div class="sidebar">
<p class="normal"><i>在本书的所有主题中，Donald Knuth 也许最不需要介绍。在过去的四十年里，他一直致力于他的多卷巨著《计算机程序设计的艺术》，基本算法和数据结构的圣经，美国科学家将其列入本世纪 12 大物理科学专着的名单，在罗素和怀特海、爱因斯坦、狄拉克、费曼和冯诺依曼的作品公司。他推广了渐近（aka Big-O）符号在分析算法中的使用，发明了 LR 解析，并为 goto 语句辩护免受 Dijkstra 的批评。</i></p><p class="normal"><i>Of all the subjects of this book, Donald Knuth perhaps least needs an introduction. For the past four decades he has been at work on his multivolume masterwork The Art of Computer Programming, the bible of fundamental algorithms and data structures, which American Scientist included on its list of the top 12 physical-sciences monographs of the century, in the company of works by Russell and Whitehead, Einstein, Dirac, Feynman, and von Neumann. He popularized the use of asymptotic (a.k.a. Big-O) notation in analyzing algorithms, invented LR parsing, and defended goto statements from Dijkstra's criticism.</i></p>
<p class="normal"><i>但他不仅仅是一个理论家。1976 年完成《计算机编程艺术》第三卷后，高德纳花了一年的时间编写排版软件 TeX 和 METAFONT，这样他就可以看到他的书排版到他自己满意的程度。十年后，他完成了工作，一路发明了一种新的编程风格，即“文学编程”，以及一种将文本段落分成几行以进行排版的算法，这仍然是最先进的技术。</i></p><p class="normal"><i>But he is not simply a theorist. After finishing Volume III of The Art of Computer Programming in 1976, Knuth took what was supposed to be a year off to write the typesetting software TeX and METAFONT so he could see his books typeset to his own satisfaction. Ten years later he was done, having along the way invented a new style of programming, “literate programming,” and an algorithm for breaking paragraphs of text into lines for typesetting that is still pretty much the state of the art.</i></p>
<p class="normal"><i>他获得的无数奖项包括第一届计算机协会 Grace Murray Hopper 奖（1971 年）、图灵奖（1974 年）和国家科学奖章（1979 年）。1990 年，他停止使用电子邮件，解释说他的工作不是“掌握事物的顶部”，而是“深入事物的底部”，深入理解和解释计算机科学的大部分领域，这样他就可以在他的书中解释它们。</i></p><p class="normal"><i>His numerous awards have included the first Association for Computing Machinery Grace Murray Hopper Award (1971), the Turing Award (1974), and the National Medal of Science (1979). In 1990 he stopped using email, explaining that his job was not “to be on top of things” but “to be on the bottom of things” deeply understanding and explaining large areas of computer science so he could explain them in his books.</i></p>
<p class="normal"><a id="OEBPS/Chapter15.html.page_566"></a><i>在这次采访中，我们谈到了 Knuth 对文学编程的热情、他对黑盒的矛盾心理，以及他认为令人遗憾的“过分强调可重用软件”。</i></p><p class="normal"><a></a><i>In this interview we talked about Knuth's enthusiasm for literate programming, his ambivalence about black boxes, and what he sees as a regrettable “overemphasis on reusable software.”</i></p>
</div>
<p class="normal"><b>Seibel：</b>你什么时候学会编程的？</p><p class="normal"><b>Seibel:</b> When did you learn to program?</p>
<p class="normal"><b>Knuth：</b>我是凯斯理工学院的新生。那是 1956 年的秋天，在那个季度或那个学期，他们得到了一台电脑。</p><p class="normal"><b>Knuth:</b> I was a freshman at Case Institute of Technology. This was the fall of 1956 and during that quarter or semester they got a computer.</p>
<p class="normal"><b>Seibel：</b>这是 IBM 650？</p><p class="normal"><b>Seibel:</b> This was the IBM 650?</p>
<p class="normal"><b>Knuth：</b>是的，是 650。那是他们制造的第一台超过一百台的计算机。我认为他们有数千个，但可能不是一万个。但它是第一台量产的计算机，所以连凯斯也得到了一台。</p><p class="normal"><b>Knuth:</b> It was the 650, yeah. That was the first computer that they made more than a hundred of. I think they had thousands of them but maybe not ten thousand. But it was the first mass-produced computer, so even Case got one.</p>
<p class="normal">我受雇于统计实验室分类卡片。我会为统计学家制作数据表格，这有助于补充我的奖学金。一楼有一个房间，里面有一扇窗户，你可以看到窗户后面的这台机器，灯在闪烁。它看起来很迷人。</p><p class="normal">I was employed in the statistics lab sorting cards. I would tabulate data for the statisticians and that helped supplement my scholarship. There was this room on the first floor with a window in it and you could see this machine behind the window with lights flashing. It looked pretty fascinating.</p>
<p class="normal">一天下午，实验室的一个人走到黑板前，向我们三个新生解释这台机器的功能。我找到了机器的手册，他们有十行程序示例。在我看来，它们有点愚蠢——看起来即使是那些小程序也有改进的方法。</p><p class="normal">One afternoon a guy from the lab went to the blackboard and was explaining to the three of us freshmen what this machine did. I found a manual for the machine and they had example ten-line programs. It seemed to me they were kind of stupid—it looked like there was a way to improve even those little programs.</p>
<p class="normal">结果证明可以在晚上去触摸机器。这很不寻常。我认为达​​特茅斯和凯斯是唯一让本科生接触机器的大学。其他地方他们有专业人士，你提交一副纸牌并在第二天得到答案。但在凯斯，它是亲力亲为的。他们只是说，“哦，是的，注意这个；你不想那样做；它会弄乱机器，”所以我们有一个非常好的机会来玩它。</p><p class="normal">And it turned out it was possible to go at night and touch the machine. This was unusual. I think Dartmouth and Case were the only universities that let undergraduates touch machines. Other places they had professionals and you submitted decks of cards and got your answers the next day. But at Case it was hands-on. They just said, “Oh, yeah, watch out for this; you don't want to do that; it'll mess up the machine,” so we had a really nice chance to play with it.</p>
<p class="normal">不管怎样，我得看看我对程序所做的一些小改动是否也能奏效，而且它确实奏效了。所以我说，“天哪，这太棒了。我只是一个<a id="OEBPS/Chapter15.html.page_567"></a>大一新生，我可以比这本书做得更好——这可能是我的天赋。” 好吧，事实证明我确实有这方面的天赋，但不是我想的那样，因为世界上几乎任何人都可以比那本特定手册中的程序做得更好。</p><p class="normal">Anyway, I got to see if one of my little changes to the program would also work, and it did. So I said, “My goodness, this is pretty amazing. I'm only a <a></a>freshman and I can do better than what was in this book—this might be something I have talent for.” Well, it turned out I did have a talent for it but not in the way I thought, because almost anybody in the world could have done better than that program in that particular manual.</p>
<p class="normal">这台机器是十进制机器，所以它并不像我必须学习二进制算术那样奇怪，尽管我在高中时玩过一点二进制算术。但它是十进制的事实使它在某种程度上更人性化或更舒服。我仍然记得机器语言<i>——65 是重置-添加-降低</i>——它现在帮助我编写密码和其他东西。</p><p class="normal">The machine was a decimal machine, so it wasn't quite as strange as if I had to learn binary arithmetic, although I played with binary arithmetic a little bit when I was in high school. But the fact that it was decimal made it somehow more human or something—comfortable. I can still remember the machine language—<i>sixty-five is reset-add-lower</i>—it helps me making up passwords and things now.</p>
<p class="normal"><b>Seibel：</b>呃哦；你刚刚在那里透露了你的秘密。</p><p class="normal"><b>Seibel:</b> Uh-oh; you just revealed your secret there.</p>
<p class="normal"><b>Knuth：</b>是的，没错。然后我决定写一个小程序来计算一个数的质因数。它大约有 100 行长。我会在没有其他人使用这台机器的晚上来调试它。而且我在我的 100 行程序中发现了 100 多个错误。但 2 周后，我有了一个程序，可以找到你拨入控制台开关的任何 10 位数字的质因数。</p><p class="normal"><b>Knuth:</b> Yeah, right. Then I decided I would write a little program to calculate the prime factors of a number. It was about 100 lines long. I would come at night when nobody else was using the machine, and debug it. And I found more than 100 bugs in my 100-line program. But 2 weeks later I had a program that would find prime factors of any 10-digit number that you dialed into the console switches.</p>
<p class="normal">这就是我学习编程的方式——基本上是我自己编写的一个程序，坐在一台机器前几周，不断让它运行得越来越好。</p><p class="normal">That was how I learned programming—basically taking one program that I made up myself and sitting at a machine over a period of some weeks, and kept getting it to work a little better and a little better.</p>
<p class="normal">我的第二个程序是二进制和十进制之间的转换。但我的第三个程序是一个玩井字游戏的程序，这才是真正让我成为一名程序员的原因。</p><p class="normal">My second program was converting between binary and decimal. But my third program was a program to play tic-tac-toe and that was what really made me a programmer.</p>
<p class="normal">我不得不为此使用数据结构。我做了三个版本的井字棋，其中一个是自学的，一开始它对游戏一无所知，然后每次输了游戏，它都会记住它的动作是可疑的，并且对手做的很好，会提升某些位置的质量，降低其他位置的质量，然后你玩了400场之后，它的井字游戏就相当不错了。</p><p class="normal">I had to use data structures for that. I made three versions of tic-tac-toe, one of which was self-learning so that it would start out knowing nothing about the game and then it would remember every time it lost a game that the moves it made were suspicious and the moves that the opponent made were good, and it would upgrade the quality of certain positions and downgrade the quality of other positions, and then after you played 400 games it would do a fairly decent job of tic-tac-toe.</p>
<p class="normal"><b>Seibel：</b>与我交谈过的很多人在刚起步时似乎都可以直接使用机器。然而 Dijkstra 有一篇论文我敢肯定<a id="OEBPS/Chapter15.html.page_568"></a>你很熟悉，他基本上说我们不应该让计算机科学专业的学生在培训的头几年接触机器；他们应该把所有的时间都花在操纵符号上。</p><p class="normal"><b>Seibel:</b> It seems a lot of the people I've talked to had direct access to a machine when they were starting out. Yet Dijkstra has a paper I'm sure <a></a>you're familiar with, where he basically says we shouldn't let computer-science students touch a machine for the first few years of their training; they should spend all their time manipulating symbols.</p>
<p class="normal"><b>Knuth：</b>但这也不是他学习的方式。他说了很多非常伟大和鼓舞人心的话，但他并不总是对的。我也不是，但我的看法是：选择任何领域的科学家。这位科学家变老了，然后说：“哦，是的，我一直在做的一些事情得到了非常好的回报，而其他事情，我不再使用了。我不会让我的学生把时间浪费在那些不会迈出大步的事情上。我根本不会谈论低级的东西。这些理论概念真的很强大——这就是整个故事。忘了我是怎么走到这一步的吧。”</p><p class="normal"><b>Knuth:</b> But that's not the way he learned either. He said a lot of really great things and inspirational things, but he's not always right. Neither am I, but my take on it is this: Take a scientist in any field. The scientist gets older and says, “Oh, yes, some of the things that I've been doing have a really great payoff and other things, I'm not using anymore. I'm not going to have my students waste time on the stuff that doesn't make giant steps. I'm not going to talk about low-level stuff at all. These theoretical concepts are really so powerful—that's the whole story. Forget about how I got to this point.”</p>
<p class="normal">我认为这是各个领域的科学家所犯的一个根本性错误。他们没有意识到，当您学习某些东西时，您必须看到各个层次的东西。在建造天花板之前，你必须先看看地板。这一切都进入大脑并被推到老年人忘记他们需要它的地步。</p><p class="normal">I think that's a fundamental error made by scientists in every field. They don't realize that when you're learning something you've got to see something at all levels. You've got to see the floor before you build the ceiling. That all goes into the brain and gets shoved down to the point where the older people forget that they needed it.</p>
<p class="normal"><b>Seibel：</b>我问过我为这本书采访过的人，他们读了多少<i>《计算机程序设计的艺术》</i>。大多数人将其用作参考，但也有一些人表示他们已经通读了一遍。每个程序员都应该读你的书吗？这是非常数学密集的东西。</p><p class="normal"><b>Seibel:</b> I've asked the people I've talked to for this book about how much they've read <i>The Art of Computer Programming</i>. Most have used it as a reference but a few said they've read it cover to cover. Should every programmer be able to read your books? It's pretty mathematically intense stuff.</p>
<p class="normal"><b>Knuth：</b>我有时想知道<i>我</i>是否能读懂它们。我试图组织围绕我正在讨论的主题的大量智慧，我从所有这些出现的地方收集它，并将其整合到某种可以发扬光大的统一体中，并使历史正确，并纠正原始来源中的错误和模糊之处。</p><p class="normal"><b>Knuth:</b> I sometimes wonder if <i>I</i> can read them. I'm trying to organize a lot of wisdom that surrounds the topic that I'm discussing and I gather it from all these places where it appeared in parts and put it into some unity that can be carried forward, and gets the history right, and corrects bugs and obscurities in the original sources.</p>
<p class="normal">就像我现在正在写的部分一样，我从数学期刊中的东西开始，这些东西是用行话写的，我不希望很多程序员都学过，我正试图将它去行话化为<i>我</i>至少可以理解的地方。我试着给出关键的想法，并尽我所能简化它们，但后来发生的是我书中的每五页都是某人的职业生涯。</p><p class="normal">Like in the parts that I'm writing now, I'm starting out with stuff that's in math journals that is written in jargon that I wouldn't expect very many programmers to ever learn, and I'm trying to dejargonize it to the point where <i>I</i> can at least understand it. I try to give the key ideas and I try to simplify them the best I can, but then what happens is every five pages of my book is somebody's career.</p>
<p class="normal"><a id="OEBPS/Chapter15.html.page_569"></a>换句话说，除了我这本书的任何五页之外，还有很多东西可以让你终身学习，因为计算机科学就是那么多。计算机科学并不全都归结为一堆简单的事情。如果事实证明计算机科学非常简单，你需要做的就是找到正确的 50 件事，然后把它们学得很好，那么我会说，“好吧，世界上每个人都应该知道这 50 件事并且知道它们彻底。”</p><p class="normal"><a></a>In other words, there's still so much more beyond any five pages of my book that you can make a lifetime's worth of study, because there's just that much in computer science. Computer science doesn't all boil down to a bunch of simple things. If it turned out that computer science was very simple, that all you needed to do was find the right 50 things and then learn them really well, then I would say, “OK, everybody in the world should know those 50 things and know them thoroughly.”</p>
<p class="normal">但事实并非如此。我有几千页和习题，我把它写下来放在书里，这样我就不用全都记在脑子里了。我必须回到它并重新学习它。我有这些练习的答案，因为我知道十年后我不会记得怎么做这该死的事情，我需要很长时间才能重建它。所以我至少给自己提供了如何重建东西的线索。</p><p class="normal">But it isn't that way. I've got thousands of pages and exercises, and I write it down and put it in the book so that I don't have to have it all in my head. I have to come back to it and learn it again. And I have the answers to the exercises because I know that ten years from now I won't remember how to do the darn thing and it will take me a long time to reconstruct it. So I give myself at least the clues to how to reconstruct stuff.</p>
<p class="normal">我经常在说，“好吧，这太复杂了;”之间左右为难。你最好根本不谈论它，”人们说的另一种感觉是，“但是你在书中写的一切都是那么微不足道；没有什么好东西。” 我可以在任何特定时间争辩说我应该把所有东西都剪掉，或者我的东西太少了。</p><p class="normal">I'm constantly torn between saying, “Well, this is too complicated; you'd better not talk about it at all,” and the other feeling that people are saying, “But all you've put in your book is just so trivial; there's nothing good.” I can argue at any particular time that I should cut everything out or that I have way too little.</p>
<p class="normal">真正归结为，所有可以在半页中解释的非常酷的东西都必须在我的书中，在大约半页上。我所看到的所有东西都太好了，不能被排除在外。所以我发现我刚刚写的关于二元决策图的部分，原来我有超过 260 个练习，因为有越来越多的东西，在我看来，这不仅仅是一个微不足道的观众。但我并不是说每个人都是所有这些 260 度的观众。尽管如此，我知道对于其中的每一个，都有很多人会欣赏它。</p><p class="normal">What it really boils down to is, all of the really cool things that can be explained in a half a page have to be in my book, on some half a page. And all the things I've seen that are just too good to be left out. So I find out that the section I just wrote about binary decision diagrams, it turned out that I had more than 260 exercises because there just was more and more stuff that seemed to me there would be more than a trivial audience for. But I'm not saying everybody is the audience for all 260 of these things. Still, I know there are a large number, for each of these, that are going to appreciate it.</p>
<p class="normal">我认为有些人确实在我的书中进行了掩护，这真是令人惊讶。在大多数情况下，我知道人们会挑选他们喜欢的部分。但他们知道，如果他们进一步挖掘，那么他们将得到只有一种行话描述的东西，而不是所有不同种类的符号和术语——如果我不写书，人们将更难找到东西出来。这就是让我兴奋的原因。</p><p class="normal">I consider it amazing that some people do go cover to cover in my books. In most cases I know that people are going to pick and choose the parts that they like. But they know that if they dig further then they'll get something that has only one subset of jargon describing it instead of all different kinds of notations and terminology—if I didn't write the books it would be much harder for people to find stuff out. That's what turns me on.</p>
<p class="normal">此外，我尝试以与实际程序员最相关的方式而不是最学术的方式来探索这个领域<a id="OEBPS/Chapter15.html.page_570"></a>发表的东西在理论上很有趣，但不会真正用于实际程序中。</p><p class="normal">Also, I try to explore the territory in a way that is most relevant to a practical programmer rather than the most academic cachet for getting <a></a>something published that's theoretically interesting but wouldn't really be used in a real program.</p>
<p class="normal">我遗漏的事情是有人有一个数据结构，只有当<i>n</i>大于二到一百万时，它才会保存 log log <i>n的因子。</i>有很多论文正在这样做。他们在原则上玩游戏，如果计算机像上帝一样，那么我们就可以拥有更快的算法。但即使是像平衡树或 AVL 树这样的算法，我也不会在我自己的程序中使用，除非我知道它将成为一棵非常大的树。<i></i></p><p class="normal">The things that I leave out are where somebody has a data structure that saves a factor of log log <i>n</i> only when <i>n</i> gets bigger than two to the million. And there are lots and lots of papers that are doing that. They're playing games where in principal, if computers were godlike, then we could have algorithms that are faster. But even an algorithm like a balanced tree or AVL tree, I don't use in my own programs unless I know that it's going to be a really big tree.</p>
<p class="normal"><b>Seibel：</b>你用什么？</p><p class="normal"><b>Seibel:</b> What do you use?</p>
<p class="normal"><b>Knuth：</b>我使用一个普通的二叉搜索树和一个我刚刚放入的随机化它的小技巧。</p><p class="normal"><b>Knuth:</b> I use an ordinary binary search tree with a little trick for randomizing it that I just put in.</p>
<p class="normal"><b>Seibel：</b>说到实际工作，在编写<i>计算机编程艺术的过程中，</i>您花了十年的时间来编写排版系统 TeX。我了解到您完全脱离计算机编写了第一个版本的 TeX。</p><p class="normal"><b>Seibel:</b> Speaking of practical work, in the middle of working on <i>The Art of Computer Programming</i> you took what turned into a ten-year break to write your typesetting system TeX. I understand you wrote the first version of TeX completely away from the computer.</p>
<p class="normal"><b>Knuth：</b>当我最初在 1977 年和 78 年编写 TeX 时，我当然没有文学编程，但我确实有结构化编程。我用铅笔手写在一个大笔记本上。</p><p class="normal"><b>Knuth:</b> When I wrote TeX originally in 1977 and '78, of course I didn't have literate programming but I did have structured programming. I wrote it in a big notebook in longhand, in pencil.</p>
<p class="normal">六个月后，在完成整个项目后，我开始在电脑上打字。当我在 77 年 10 月开始编写程序时，我在 78 年 3 月进行了调试。其代码在斯坦福档案中——都是用铅笔写的——当然，我会回来更改一个子程序，因为我知道它应该是什么。</p><p class="normal">Six months later, after I had gone through the whole project, I started typing into the computer. And did the debugging in March of '78 while I had started writing the program in October of '77. The code for that is in the Stanford archives—it's all in pencil—and of course I would come back and change a subroutine as I learned what it should be.</p>
<p class="normal">这是第一代系统，所以可能有很多不同的体系结构，但在我使用它一段时间并了解其中的内容之前，必须放弃它们。这是一个先有鸡还是先有蛋的问题——在你有字体之前你不能排版，但是在你能排版之前你不能有字体。</p><p class="normal">This was a first-generation system, so lots of different architectures were possible and had to be discarded until I'd lived with it for a while and knew what was there. And it was a chicken-and-egg problem—you couldn't typeset until you had fonts but then you couldn't have fonts until you could typeset.</p>
<p class="normal">但是结构化编程给了我不变量的概念，让我知道如何制作我能理解的黑盒子。所以我有信心<a id="OEBPS/Chapter15.html.page_571"></a>当我最终调试它时，代码会起作用。我觉得如果我等六个月再测试任何东西，我会节省很多时间。我有足够的信心相信代码大致是正确的。</p><p class="normal">But structured programming gave me the idea of invariants and knowing how to make black boxes that I could understand. So I had the confidence <a></a>that the code would work when I finally would debug it. I felt that I would be saving a lot of time if I waited six months before testing anything. I had enough confidence that the code was approximately right.</p>
<p class="normal"><b>Seibel：</b>节省时间是因为您不会花时间构建脚手架和存根来测试不完整的代码？</p><p class="normal"><b>Seibel:</b> And the time savings would be because you wouldn't spend time building scaffolding and stubs to test incomplete code?</p>
<p class="normal"><b>克纳特：</b>对。</p><p class="normal"><b>Knuth:</b> Right.</p>
<p class="normal"><b>Seibel：</b>除了它们现在排版非常漂亮之外，如果您没有花十年时间编写 TeX，您认为您的书会有很大不同吗？</p><p class="normal"><b>Seibel:</b> Other than the fact that they're so nicely typeset now, do you think your books would be very different if you hadn't spent ten years writing TeX?</p>
<p class="normal"><b>Knuth：问得好</b>。以非纯粹学术的方式使用结构化编程的经验——换句话说，我不只是在考虑玩具程序中的不变量，而是在实际程序中——可能对我在新东西中描述算法的方式产生了相当大的影响我现在写。或者如果没有，它应该。</p><p class="normal"><b>Knuth:</b> Good question. The experience of using structured programming in a not purely academic way—in other words, I'm not just thinking about invariants in toy programs, but in real programs—probably had a fair influence on how I'm describing algorithms in the new stuff I write now. Or if it hasn't, it should.</p>
<p class="normal">如果我只是继续从文学到写书的相同模式，我就不会知道缓存和计算机变化方式的趋势以及类似的事情。当我编写第一、二和三卷时，我并没有编写像 TeX 这样的程序，而这在大型编程实践中更为典型。它们将是玩具程序。所以它让我对数字和数量有了更多的看法。</p><p class="normal">I wouldn't have known about caching and trends in the way computers change and things like that if I was just going on in the same mold of going from the literature to writing my books. While I was writing Volumes I, II, and III, I wasn't writing programs like TeX that that would be more typical of a large programming practice. They would be toy programs. So it gave me more of a perspective on numbers and quantity.</p>
<p class="normal">不过，当你写一本书时，你会选择不同的词，这真的很神奇。它是如何进入那里的，这很神秘。这是编写 TeX 最重要的影响——它给了我一种不同的思维方式，使我的句子与众不同。他们会少一些对冲。整个事情都有一种基调，自信之类的。</p><p class="normal">It's really amazing, though, when you're writing a book, the influences that will make you choose different words. It's mysterious how it gets in there. That's the most important influence of writing TeX—that it gave me a different kind of a mental take on things so that my sentences come out different. They'll be a little bit less hedgy. There is a tone that comes out in the whole thing, of confidence or something.</p>
<p class="normal"><b>Seibel：</b>你认为当你完成 TeX 时，你是一个比刚开始时好得多的程序员吗？</p><p class="normal"><b>Seibel:</b> Do you think you were a dramatically better programmer when you finished TeX than when you started?</p>
<p class="normal"><b>Knuth：</b>嗯，是的，因为文学编程。</p><p class="normal"><b>Knuth:</b> Well, yes, because of literate programming.</p>
<p class="normal"><b>Seibel：</b>所以你有更好的工具，但你真的提高了你的技能吗？</p><p class="normal"><b>Seibel:</b> So you had better tools, but had you actually improved your skills?</p>
<p class="normal"><a id="OEBPS/Chapter15.html.page_572"></a><b>Knuth：</b>我在做的时候学到了很多东西。我学到的一件事是软件占据了大脑的多少。这是一项比我预期的要困难得多的任务。我不能全职教课和全职编写软件。我可以全职教课，全职写书，但软件需要非常注重细节。它填满了我的大部分大脑，其他东西都被排除在外。因此，这让我对从事大型软件项目的人产生了特别的钦佩——如果我自己没有遇到过，我永远不会猜到这一点。</p><p class="normal"><a></a><b>Knuth:</b> I learned a terrific amount while I was doing it. One of the things I learned was how much software occupies the brain. It was a much more difficult task than I expected. I couldn't teach classes full-time and write software full-time. I could teach classes full-time and write a book full-time but software required so much attention to detail. It filled that much of my brain to the exclusion of other stuff. So it gave me a special admiration for people who do large software projects—I would never have guessed it without having been faced with that myself.</p>
<p class="normal"><b>Seibel：</b>所以编程比写书更难，我在某个地方读到一些东西，你说不可能估计写书需要多长时间。这是否意味着更难估计编程需要多长时间？</p><p class="normal"><b>Seibel:</b> So programming is harder than writing books, and somewhere I read something where you said that it's impossible to estimate how long it will take to write books. Does that then mean that it's even harder to estimate how long programming will take?</p>
<p class="normal"><b>Knuth：</b>是的，没错。这是一个很好的推论。</p><p class="normal"><b>Knuth:</b> Yeah, right. That's a very good corollary.</p>
<p class="normal">今年我大概写了三个主要的程序，它们正在推动一百页的代码——文学代码，有 8.5?11 页。其中两个是相互关联的，所以更像是两个半的主要节目。以及大约150个小程序。可能比我去年做的更多。所以今年我在小程序上编写了大量的程序，但其中一些是需要一个月或更长时间才能完成的事情。</p><p class="normal">This year I've written probably three major programs which are pushing one hundred pages of code—literate code, with 8.5?11 pages. Two of them are related to each other, so it's more like two and a half major programs. And about 150 small programs. Probably more than I did the previous year. So I programmed galore this year on small programs but also, a couple of them were things that took a month or more to do.</p>
<p class="normal"><b>Seibel：</b>你认为他们需要一个月的时间吗？</p><p class="normal"><b>Seibel:</b> And did you expect them to take a month?</p>
<p class="normal"><b>Knuth：</b>嗯，我预计其中一个需要一个月的时间。我知道这并不容易，但我不知道会有多少丰富性，所以我在开始使用它们时添加了更多功能。我认为管理程序员的人不应该期望它是可预测的，这总是正确的。</p><p class="normal"><b>Knuth:</b> Well, I expected one of them to take a month. I knew that it wasn't going to be easy but I didn't know how much richness there was going to be, so I added more features as I got to using them. I think it is always going to be true that a person who manages programmers should not expect it to be predictable.</p>
<p class="normal"><b>Seibel：</b>除了编写<i>计算机编程艺术</i>和 TeX，您还是文学编程的发明者和提倡者，这是一种编写代码的方式，可以让人们更容易阅读。你编写了<code>WEB</code>和<code>CWEB</code>工具来实现基于 Pascal 和 C 的文学编程语言。</p><p class="normal"><b>Seibel:</b> In addition to writing <i>The Art of Computer Programming</i> and TeX, you're also the inventor of—and advocate for—literate programming, a way of writing code so it can be more easily read by people. And you wrote <code>WEB</code> and <code>CWEB</code>, tools that implement literate programming languages based on Pascal and C.</p>
<p class="normal"><b>Knuth：</b>所以你说<i>提倡</i>- 说这很好是我的技巧。但我也是那种不喜欢讲道或试图讲道的人<a id="OEBPS/Chapter15.html.page_573"></a>转换某人。我认为编程很像宗教；人们有自己的信仰。有些人喜欢把自己的信仰强加于人。其他人说，你知道，这就是我的想法；我无法证明这是最好的，但它确实对我有用。然后你希望其他人会尝试并得出相同的结论。但我不喜欢出去告诉人们他们应该相信什么。</p><p class="normal"><b>Knuth:</b> So you say <i>advocate</i>—it's sort of my shtick to say that this is good. But I also am the kind of guy that's uncomfortable preaching or trying to <a></a>convert someone. I think programming is a lot like religion; people have their beliefs. Some people like to force their beliefs on others. Others say, you know, here's what I think; I can't prove that this is the best thing, but it sure works for me. Then you hope that other people will try it and come to the same conclusion. But I don't like going out and telling people what they ought to believe.</p>
<p class="normal"><b>Seibel：</b>嗯，也许你可以解释一下为什么你如此喜欢它，以及它与文盲编程有何不同。</p><p class="normal"><b>Seibel:</b> Well, maybe you can explain why you like it so much and how it differs from illiterate programming.</p>
<p class="normal"><b>Knuth：</b>写作的首要规则是了解你的读者——当然，你越了解你的读者，你就能写得越好。第二条规则，对于技术写作，是以互补的方式将所有内容说两遍，这样阅读它的人就有机会以相互强化的方式将这些想法输入他或她的大脑。</p><p class="normal"><b>Knuth:</b> The first rule of writing is to understand your audience—the better you know your reader the better you can write, of course. The second rule, for technical writing, is say everything twice in complementary ways so that the person who's reading it has a chance to put the ideas into his or her brain in ways that reinforce each other.</p>
<p class="normal">所以在技术写作中通常会有冗余。事情有正式和非正式的说法。或者你给出了一个定义，然后你说，“因此，某某是真的，”只有你理解了这个定义，你才能理解。</p><p class="normal">So in technical writing usually there's redundancy. Things are said both formally and informally. Or you give a definition and then you say, “Therefore, such and such is true,” which you can only understand if you've understood the definition.</p>
<p class="normal">或者你会说，“我们定义<i>一个</i>等于某某的所有主要元素的集合。” 因此，这个非正式术语，<i>即所有主要元素的集合，由我们如何构建集合</i><i>a</i>的数学描述来补充。</p><p class="normal">Or you'll say, “We define <i>a</i> equals the such-and-such to be the set of all leading elements.” So this informal term, <i>the set of all leading elements</i>, is complemented by the mathematical description of how we constructed the set <i>a</i>.</p>
<p class="normal">所以文学编程是基于这样的想法，即最好的交流方式是非正式和正式地说出相关的事情。它只是提供了一个自然的框架，用于在自然语言、英语和形式语言、C 或 Lisp 或任何形式语言之间切换，并将它们组合在一起。所以，对我来说，必须是文档的胜利。</p><p class="normal">So literate programming is based on this idea that the best way to communicate is to say things both informally and formally that are related. And it just provides a natural framework for switching between the natural language, English, and the formal language, C or Lisp or whatever is your formal language, and putting this together. So that, to me, has to be a win for documentation.</p>
<p class="normal">现在，另一件事是，当我编写程序时，我不必以编译器希望看到的形式呈现它。我以我认为最容易让读者理解的形式呈现。</p><p class="normal">Now, the other thing is, as I write the program, I don't have to present it in the form that the compiler wants to see it. I present it in the form that I think is easiest for a reader to understand.</p>
<p class="normal">您可以自下而上地编写代码并编写子例程，这些子例程可以为您提供越来越大的东西，并且您的信心会增强，因为现在您可以做到<a id="OEBPS/Chapter15.html.page_574"></a>更多的东西。其他人自上而下地写；他们开始说，“好吧，我有这个问题要解决，所以我先做这个，然后再做这个。”</p><p class="normal">You can write your code bottom-up and make subroutines that give you bigger and bigger things and your confidence builds because now you can do <a></a>more things. Other people write top-down; they start out and say, “Well, I have this problem to solve, so first I'll do this and then I'll do this.”</p>
<p class="normal">当我编写一个有读写能力的程序时，我可以根据自己的喜好在这些之间进行选择。而且几乎总是我的最终程序出来的方式是按照我自己实际想到的东西的顺序。所以我会开始，我会说，“我有这个问题要解决，所以我首先要解决这个问题，然后再解决那个问题。”</p><p class="normal">When I write a literate program I can choose between these as I like. And almost always the way my final program comes out is in the order in which I actually thought of the things myself. So I'll start out and I'll say, “I have this problem to solve, so first I'm going to have to solve this and then I'm going to have to solve that.”</p>
<p class="normal">但后来我说，“现在让我们开始自下而上地构建一些工具。” 我们心中有目标，但我们构建了一些自下而上的工具，然后我们会回去做一点自上而下的事情。但是我们这样做的顺序是，首先我写下我必须解决这个问题的第一天的想法。然后，下一章将是我决定接下来要解决的问题。</p><p class="normal">But then I say, “Now let's start building some tools bottom-up.” We have the goal in mind but we build a few bottom-up tools and then we'll go back and do a little top-down. But in what order we do this is, first I write about what I thought about the first day I had to work on this problem. And then, the next chapter would be the thing I decided to tackle next.</p>
<p class="normal">我开始解决最让我担心但我现在也准备好解决的事情。如果我现在准备好做某事，而不是将某事推迟到糟糕的一天，我会把它放在一边。但这是不同的顺序——既不是自上而下也不是自下而上。这是心理上的，“我发现什么是让我最满意接下来完成的事情，我已经准备好去做了？” 它没有太多的未知数。因此，将程序按照人类可以理解的顺序排列的自由对我来说非常重要。</p><p class="normal">And I start to tackle the thing that's most worrying to me but that I'm also ready to solve at the moment. Instead of postponing something 'til an evil day, if I'm ready to do it now, I get that out of the way. But it's a different order—it's neither top-down nor bottom-up. It's psychologically, “What do I find is the thing that's going to make me most satisfied to get done next and I'm ready to do it?” It doesn't have too many unknowns in it. So the freedom to put the program into that human-understandable order is very important to me.</p>
<p class="normal">现在，为什么这还没有传遍全世界，为什么不是每个人都这样做呢？我不确定是谁一针见血——我想是乔恩·本特利 (Jon Bentley)。简化是这样的：世界上只有百分之二的人天生就是超级程序员。只有百分之二的人天生就是超级作家。高德纳希望每个人都能两者兼得。</p><p class="normal">Now, why hasn't this spread over the whole world and why isn't everybody doing it? I'm not sure who it was who hit the nail on the head—I think it was Jon Bentley. Simplified it is like this: only two percent of the world's population is born to be super programmers. And only two percent of the population is born to be super writers. And Knuth is expecting everybody to be both.</p>
<p class="normal">我认为我们不会将世界上程序员的总数增加到超过 2%——我的意思是真正与机器产生共鸣的程序员，这是他们生来就是为了谋生的程序员。但是现在人们开始写博客了，我看到普通人表达自己的平均能力有了很大的提高。所以那个论点的第二部分不再那么有力了。</p><p class="normal">I don't think we're going to increase the total number of programmers in the world to more than two percent—I mean programmers who really resonate with the machine and that's their bread and butter that they've been born to do. But now that people are blogging, I've seen a great rise in the average ability of ordinary everybody to express themselves. So the second part of that that argument isn't so strong anymore.</p>
<p class="normal"><a id="OEBPS/Chapter15.html.page_575"></a>我在斯坦福大学只尝试了有限的数量。我和一群本科生一起工作。他们会在暑期项目上编写程序，我向他们介绍了这种文学编程的想法。那个夏天只有七个人和我一起工作。其中有六个人非常喜欢它，以至于他们今天仍在使用它。第七个人讨厌它。他编写文学程序的想法是采用普通程序并在其周围包裹起来并说“这是模块一”，等等。当然，斯坦福大学承认优秀的作家，所以这不是随机抽样。</p><p class="normal"><a></a>I tried it only a limited amount at Stanford. I worked with a group of undergraduates. They would write their programs on a summer project and I introduced them to this idea of literate programming. There were only seven of them working with me that summer. And six of them loved it to the point that they're still using it today. The seventh one hated it. His idea of writing a literate program was to take an ordinary program and put a wrapper around it and say, “This is module one,” and so on. Of course, Stanford admits people who are good writers, so this isn't a random sample.</p>
<p class="normal"><b>Seibel：</b>你有没有写过一个文学程序，你戏剧性地将它重组为不同的解释顺序？我很难想象意识流<i>总是</i>最好的组织原则。</p><p class="normal"><b>Seibel:</b> Have you ever written a literate program where you dramatically reorganized it into a different order for explication? It's hard for me to imagine that stream of consciousness is <i>always</i> the best organizing principle.</p>
<p class="normal"><b>Knuth：</b>这几乎从未发生过。我不记得回去并真正改变章节的顺序。似乎总是只有一个选择下一步要攻击什么。我无法准确解释，但似乎一个人会进入下一个。</p><p class="normal"><b>Knuth:</b> It just hardly ever happened. I can't remember going back and really changing the order of the chapters. It just always seemed like there was almost only one choice what to attack next. I can't explain it exactly, but it just seemed that one would segue into the next.</p>
<p class="normal"><b>Seibel：</b>您是否为除您之外没人会看到的程序编写文学代码？</p><p class="normal"><b>Seibel:</b> Do you write literate code for programs that no one but you will ever see?</p>
<p class="normal"><b>克纳特：</b>没错。这就是文学编程的伟大之处——我可以自言自语。一年后我可以阅读我的程序并确切地知道我在想什么。</p><p class="normal"><b>Knuth:</b> Exactly. This is what literate programming is so great for—I can talk to myself. I can read my program a year later and know exactly what I was thinking.</p>
<p class="normal"><b>Seibel：</b>那总是有效吗？</p><p class="normal"><b>Seibel:</b> Does that always work?</p>
<p class="normal"><b>Knuth：</b>好吧，一年后通常比以前更难理解。但将其与没有它的情况进行比较。它不会使复杂的事情变得微不足道，但它比我知道的任何其他方法都要好得多。</p><p class="normal"><b>Knuth:</b> Well, it's often a lot harder to understand a year later than before. But compare that to what I had without it. It doesn't make the complicated thing trivial, but it's just way better than any other method I know.</p>
<p class="normal">我刚刚打印出大量子例程的一小部分，这些子例程都是用 C 语言编写的，它们几乎是处理 BDD 的最先进技术——布尔决策图。<code>CWEB</code>这与现在世界上几乎每个人在开发包时所做的相反。他们通过相当有纪律的评论惯例来做到这一点，这些评论惯例被广大社区所理解。代码并不难理解，因为它被分离成一种逻辑形式，你有这些头文件，我可以看到数据结构，还有注释<a id="OEBPS/Chapter15.html.page_576"></a>在数据结构的每个部分解释它在做什么。所以这是另一种有效的编程风格。</p><p class="normal">I just printed out a small subset of a large collection of subroutines that are all written in C that are pretty much state of the art for manipulating BDDs—Boolean decision diagrams. This is the opposite of <code>CWEB</code>—this is what almost everyone in the world does when they're developing packages now. They do it by means of fairly disciplined commenting conventions that are understood by a large community. And the code is not real difficult to understand because it's separated out into a logical form and you've got these header files and I can see the data structures and there are comments <a></a>on each part of the data structure explaining what it's doing. So this is another style of programming that works.</p>
<p class="normal">然而，我不禁认为它大大低于文字编程所能达到的水平。因为很多无形的东西我无法证明。对我来说最有说服力的是，我相信我已经编写了一些程序，如果没有文学编程，我<i>根本无法编写这些程序。</i>例如，<code>MMIX</code>模拟器将是一个智力挑战，如果我必须以传统方式来做，我想我永远也做不完。仅仅将它分离成子程序不足以简化它以使其在智能上易于管理。</p><p class="normal">Yet I can't help but think that it's considerably below what can be achieved with literate programming. Because of lots of intangible things that I can't prove. The most convincing to me was that I believe that I've written some programs that I <i>could not</i> have written at all without literate programming. For example, the <code>MMIX</code> simulator would have been such an intellectual challenge that if I had to do it in the conventional style, I don't think I ever would have finished it. Just separating it out into subroutines wasn't enough to simplify it to make it intellectually manageable.</p>
<p class="normal">这是一个模拟器，它采用了计算机的极其通用的规格：它有哪些功能单元，一次可以执行多少条指令，缓存策略，总线如何工作，输出如何工作，你如何进行分支预测，以及如何维护管道。</p><p class="normal">This is a simulator that takes an extremely general specification of a computer: what functional units it has, how many instructions can execute at a time, the caching strategies, how the bus works, how the output works, how are you doing branch prediction, and how you maintain the pipeline.</p>
<p class="normal">所以你可以想象一台计算机有六个分区单元和一个特定阶段的管道，这将模拟它。如果你有这台机器，你能更快地计算质数吗？您不必构建机器。</p><p class="normal">So you can imagine a computer that would have six division units and a pipeline of certain stages and this will simulate it. Would you be able to calculate prime numbers faster if you had this machine? You don't have to build the machine.</p>
<p class="normal">我并不是说不可能采用该程序并将其放入子例程中，但我永远不会那样完成它。而且它只有 170 页，而且可以理解它——我不是世界上唯一理解它的人。</p><p class="normal">I'm not saying it's impossible to take that program and put it into subroutines, but I would never have finished it that way. And also it's only 170 pages and it is possible to understand it—I'm not the only person in the world who understands it.</p>
<p class="normal"><b>Seibel：</b>我读了你对<i>冒险</i>游戏的重新实现，并注意到它看起来有点单一。它看起来像是识字风格，因为它可以让你插入东西，让你远离将东西分解成子程序。</p><p class="normal"><b>Seibel:</b> I read your literate reimplementation of the game <i>Adventure</i> and noticed that it seemed somewhat monolithic. It seemed like the literate style, because it lets you interpolate things, draws you away from breaking things down into subroutines.</p>
<p class="normal"><b>克纳特：</b>这是真的。不是调用子例程，而是一直内联子例程。子例程的想法是存在的，但它不作为子例程出现在您的最终程序中。它在某些方面更像是一个宏。但问题是，在概念层面上，如果您有其他方法以您正在使用的语言执行此操作，则子例程调用机制不是必需的。</p><p class="normal"><b>Knuth:</b> This is true. Instead of calling a subroutine, it's like inline subroutines all the way through. The idea of a subroutine is there but it's not in your final program as a subroutine. It's more like a macro in some ways. But the thing is, at the conceptual level, the subroutine-calling mechanism isn't necessary if you have some other way to do it in the language you're using.</p>
<p class="normal"><a id="OEBPS/Chapter15.html.page_577"></a>在<i>Adventure</i>中，我认为我实际上并没有从 Don Woods 的 Fortran 程序中删除子例程——我正在使用他的 Fortran 程序并将其转换为英语和 C。但是当你查看我的 TeX 代码时，你确实会发现有多少子例程在子程序堆栈中，它可能是 4 或 5，而由其他人编写的程序，如果没有文学编程，则可能是 50 或 100。</p><p class="normal"><a></a>In <i>Adventure</i> I don't think I actually removed subroutines from Don Woods's Fortran program—I was taking his Fortran program and putting it into English and C. But it's true that when you look at my code for TeX, the number of subroutines that you're in, on the subroutine stack, might be 4 or 5 whereas a program written by somebody else, without literate programming, it might be 50 or 100.</p>
<p class="normal">我尝试处理的是与我头脑中的方式相对应的单位，而不是逻辑学家可能希望它在某些形式系统中的方式。我的程序应该比其他人的严格框架更符合我的直觉。</p><p class="normal">What I try to work on is units that correspond to the way I have it in my head, rather than the way a logician might want it to be in some formal system. My programs are supposed to match my intuition more than somebody else's rigid framework.</p>
<p class="normal">当然，最终它必须进入计算机，它是僵硬的，有其精确的理解规则。但对我来说，正确类型的程序的想法是尽可能符合我的想法，而不是尽可能符合机器。我必须找到进行转换的方法，但我的源文本试图更接近我的大脑而不是机器。</p><p class="normal">Of course, eventually it has to go into a computer, which is rigid, which has its precise rules of understanding. But to me the idea of the right kind of a program is something that matches the way I think as closely as possible rather than something that matches the machine as closely as possible. I have to find the way to do the conversion, but my source text tries to stay closer to my brain than to the machine.</p>
<p class="normal">我还相信文学编程是一种强大的文档风格，可用于跨人群交流。我有很多人非常了解 TeX 的代码，足以构建它可能会失败的场景。我认为，在他们生命中的某一时刻，比任何其他同等规模的项目都更了解该项目。</p><p class="normal">I also believe that literate programming is a powerful style of documentation that can be used to communicate across groups of people. I had many people who understood the code for TeX well enough to construct scenarios where it would fail. I think more people, at one point in their life, understood that program than any other program of its size.</p>
<p class="normal"><b>Seibel：</b>你有没有发现，即便如此，你仍然有人读过这件事，然后给你发了一些问题，让你觉得，“哇，他们真的错过了一些东西”？</p><p class="normal"><b>Seibel:</b> Did you ever find, even with that, that you still had people who had read the thing and then sent you questions that made you think, “Wow, they really missed something here”?</p>
<p class="normal"><b>克纳特：</b>当然。这种情况总是会发生，但这是我的阐述中的一个错误。让我给你一个简单的例子。在<i>计算机编程的艺术中，</i>我谈到了面向位运算的早期历史，我有以下句子：“曼彻斯特 Mark 1 计算机，与 EDSAC 大约同时建造，不仅包括按位<i>与，</i>而且还包括<i>或</i>和<i>独占或</i>。当艾伦图灵在 1950 年编写其第一本编程手册时，他说按位<i>非</i>可以通过使用<i>排他或</i>与一行的组合来获得。”</p><p class="normal"><b>Knuth:</b> Of course. That always happens, but it's a mistake in my exposition. Let me give you a simple example. In <i>The Art of Computer Programming</i> I'm talking about the early history of bit-oriented operations and I have the following sentence: “The Manchester Mark 1 computer, built about the same time as the EDSAC, included not only bitwise <i>and</i> but also <i>or</i> and <i>exclusive or</i>. When Alan Turing wrote its first programming manual in 1950 he remarked that bitwise <i>not</i> can be obtained by using <i>exclusive or</i> in combination with a row of ones.”</p>
<p class="normal"><a id="OEBPS/Chapter15.html.page_578"></a>现在，在我的句子中，我说的是，“Alan Turing 写了第一本编程手册”，意思是曼彻斯特 Mark 1 的第一本编程手册。但是四五个读者独立说，我一定是指“他的”：“当 Alan图灵于 1950 年编写了<i>他的第一本编程手册”。</i></p><p class="normal"><a></a>Now, in my sentence I'm saying, “Alan Turing wrote its first programming manual,” meaning the first programming manual for the Manchester Mark 1. But four or five readers independently said, I must have meant “his”: “When Alan Turing wrote <i>his</i> first programming manual in 1950”.</p>
<p class="normal">嗯，其实他写过其他的编程手册，所以我说的是对的，但是被人曲解了。所以现在我说，“当 Alan Turing 在 1950 年为 Mark I 编写第一本编程手册时……”</p><p class="normal">Well, actually, he had written other programming manuals, so what I said was correct but it was misinterpreted by people. So now I say, “When Alan Turing wrote the first programming manual for the Mark I, in 1950. …”</p>
<p class="normal">数学方面的东西：同样，我也会遇到想念它的人。那么我会说，你知道，我实际上说对了，但我知道我仍然需要改变它并让它变得更好。</p><p class="normal">Mathematical things: similarly I'll get people who miss it. So then I'll say, you know, I actually said it correctly, but I know I still have to change it and make it better.</p>
<p class="normal"><b>Seibel：</b>当你发布一个文学程序时，它通常是程序的最终形式。您常说：“过早优化是万恶之源。” 但是当你达到最终形式时，还为时过早——你可能已经优化了一些部分，使其非常聪明。但这不会让阅读变得困难吗？</p><p class="normal"><b>Seibel:</b> When you publish a literate program, it's the final form of the program, typically. And you are often credited with saying, “Premature optimization is the root of all evil.” But by the time you get to the final form it's not premature—you may have optimized some parts to be very clever. But doesn't that make it hard to read?</p>
<p class="normal"><b>Knuth：</b>不。一个好的文字程序会展示它的历史。一个好的文字程序会说，“这是显而易见的方法，然后为什么我们不遵循这条路呢？”</p><p class="normal"><b>Knuth:</b> No. A good literate program will show its history. A good literate program will say, “Here's the obvious way to do it and then why we don't follow that road?”</p>
<p class="normal">当你在你的程序中加入微妙的东西时，有文化的编程就会大放异彩，因为你不仅拥有执行它的代码，而且还有你的文档。你说，“这是一个肮脏的把戏，它之所以有效是因为——”然后你非常仔细地陈述了原因和假设。</p><p class="normal">When you put subtle stuff in your program, literate programming shines because you don't just have the code that does it but also your documentation. You say, “This is a dirty trick here, it works because—” and then you state very carefully the reasons and the assumptions.</p>
<p class="normal">我会使用肮脏的技巧有两个原因。一个是，如果它真的会给我带来性能改进，而我的应用程序就是性能改进将受到赞赏的应用程序。或者有时我会说，“这很棘手；我今天忍不住要耍花样，因为它太可爱了。” 所以只是为了纯粹的乐趣。无论如何，我记录下来；我不只是把它放在那里。</p><p class="normal">I'll use dirty tricks for two reasons. One is, if it's really going to give me a performance improvement and my application is one that the performance improvement is going to be appreciated. Or sometimes I'll say, “This is tricky; I couldn't resist being tricky today because it's so cute.” So just for pure pleasure. In any case, I document it; I don't just put it in there.</p>
<p class="normal"><b>Seibel：</b>在散文中会更多吗？</p><p class="normal"><b>Seibel:</b> Would that be more in the prose?</p>
<p class="normal"><b>Knuth：</b>在散文部分。我没有显示我取出的代码。我可以。</p><p class="normal"><b>Knuth:</b> It's in the prose part. I don't show the code that I've taken out. I could.</p>
<p class="normal"><a id="OEBPS/Chapter15.html.page_579"></a><b>Seibel：</b>是否有任何工具<code>CWEB</code>可以实际包含不属于应用程序一部分的代码，因此您可以说，“这是此函数的一个非常简单的版本，而不是仅仅在散文中记录它。”</p><p class="normal"><a></a><b>Seibel:</b> Is there any facility in <code>CWEB</code> for actually including code that isn't part of the application, so rather than just document it in the prose, you can say, “Here's a really dirt-simple version of this function.”</p>
<p class="normal"><b>Knuth：</b>你只有代码，但你从不使用它。它出现在文档中说此代码从未使用过。</p><p class="normal"><b>Knuth:</b> You just have the code but you never use it. It comes out in the documentation saying this code is never used.</p>
<p class="normal"><b>Seibel：</b>所以它只是一个你永远不会引用的片段？</p><p class="normal"><b>Seibel:</b> So it would just be a fragment that you would never reference?</p>
<p class="normal"><b>克努特：</b>是的。另外，我在其中有代码，然后我可以从调试器调用这些代码。我可以说，“用某某参数调用某某某某”。该子例程实际上从未在程序本身中调用过，但它在文档中。所以我可以在中间停止一个程序，我可以调用这个子程序，它会看看它是怎么做的，看看事情有多大。</p><p class="normal"><b>Knuth:</b> Yeah. Also, I have code in there that I can then invoke from the debugger. I can say, “Call such-and-such with such-and-such parameters.” The subroutine is never actually called in the program itself, but it's there in the documentation. So I can stop a program in the middle and I can call this subroutine and it'll take a look and see how it's doing, see how big things have gotten.</p>
<p class="normal"><b>Seibel：出于</b>同样的原因，你可以这样写，“第一节——这是这个算法的简单实现；第二部分——这是第一部分的略微加强版；第三部分，这是我们实际使用的部分，如果您没有阅读前两部分，您将永远无法理解。”</p><p class="normal"><b>Seibel:</b> So by the same token you could write, “Section one—here's a naive implementation of this algorithm; section two—here's a slightly souped-up version of section one; and section three, here's the one we actually use which you would never understand if you hadn't read the first two sections.”</p>
<p class="normal"><b>克纳特：</b>没错。我在 Web 上有一些解决 15 难题的程序。我经历了三个不同的版本。我说，“阅读第一版，否则你永远不会理解第二版。阅读第二版，否则你永远无法理解第三版。”</p><p class="normal"><b>Knuth:</b> Exactly. I have some programs on the Web that solve the 15 puzzle. And I go through three different versions. And I say, “Read version one or you'll never understand version two. And read version two or you'll never understand version three.”</p>
<p class="normal">我编写了各种不同类型的程序。有时我会编写一个我不太关心效率的程序——我只想得到答案。我会使用蛮力，我保证我不需要思考——不会有任何微妙之处，所以我不会智取自己。我没有做任何过早的优化。</p><p class="normal">I write a whole variety of different kinds of programs. Sometimes I'll write a program where I couldn't care less about efficiency—I just want to get the answer. I'll use brute force, something that I'm guaranteed I won't have to think—there'll be no subtlety at all so I won't be outsmarting myself. There I'm not doing any premature optimization.</p>
<p class="normal">然后我可以将其更改为其他内容，看看我是否得到与我的蛮力方式一致的内容。然后我可以扩大程序并处理更大的案例。大多数程序会在那个阶段停止，因为您不会将代码执行一万亿次。当我为<i>The Art of Computer Programming</i>做插图时，我可能会多次更改插图，翻译我的书的人可能不得不重做程序，但它<a id="OEBPS/Chapter15.html.page_580"></a>我用非常慢的方法绘制插图并不重要，因为我只需要生成该文件一次，然后它就会交给出版商并印在一本书中。</p><p class="normal">Then I can change that into something else and see if I get something that agrees with my brute-force way. Then I can scale up the program and go to larger cases. Most programs stop at that stage because you're not going to execute the code a trillion times. When I'm doing an illustration for <i>The Art of Computer Programming</i> I may change that illustration several times and the people who translate my book might have to redo the program, but it <a></a>doesn't matter that I drew the illustration by a very slow method because I've only got to generate that file once and then it goes off to the publisher and gets printed in a book.</p>
<p class="normal">但现在我正在研究组合算法，根据定义，这些算法是规模巨大的问题。所以为了在我的书中有有趣的例子，我必须编写程序来解决读者会说的问题，“哦，是的，我不能只用简单的方法做到这一点，所以我需要学习一些关于编程艺术，否则用蛮力方法解决这个问题需要 100 年。”</p><p class="normal">But right now I'm working on combinatorial algorithms, which are, by definition, humongous-size problems. So in order to have interesting examples in my book I've got to write programs that solve problems that readers will say, “Oh, yeah, I couldn't have done that just by simple methods, so I need to learn something about the art of programming or it'll take 100 years to solve this problem by the brute-force method.”</p>
<p class="normal">组合算法之所以令人着迷，是因为一个好主意可以为您节省十个数量级的运行时间。但我不会嘲笑那些在你执行一万亿次后可以节省百分之二十的想法。因为如果你能在一个已经完成一万亿次的循环中节省一百纳秒，我认为你就节省了一天。如果该代码将被大量使用，那么它确实可以带来回报，因此您必须使用不易理解的微妙技巧。</p><p class="normal">Combinatorial algorithms are fascinating because one good idea can save you ten orders of magnitude in running time. But I don't sneer at ideas that save you twenty percent when you're doing it a trillion times. Because if you can save a hundred nanoseconds in a loop that's being done a trillion times, I think you're saving a day. If the code is going to be used a lot it can really pay off so you've got to go to subtle tricks that aren't easy to understand.</p>
<p class="normal">大约一年前，我在<i>Computing Reviews</i>上看到一篇评论——那个人正在评论一本书；标题是<i>编程技巧</i>或类似的东西。评论的主旨是，“如果我发现任何为我工作的程序员使用这些技巧，我会解雇他们。” 所以我自然而然地出去看了这本书，因为我想，“这是一本我想看并从中学习的书。”不幸的是，这些技巧实际上并没有那么好。</p><p class="normal">About a year ago I saw a review in <i>Computing Reviews</i>—the guy was reviewing a book; the title was <i>Programming Tricks</i> or something like this. And the thrust of the review was, “If I ever caught any of the programmers working for me using any of these tricks, I would fire them.” And so naturally I went out and looked at the book because I thought, “This is a book I want to see and learn from." Unfortunately, the tricks weren't actually that good.</p>
<p class="normal"><b>Seibel：</b>他们真的在开火吗？</p><p class="normal"><b>Seibel:</b> Were they really firing offenses?</p>
<p class="normal"><b>Knuth：</b>实际上，他们非常虚弱。它没有系统地介绍所有内容，但我认为它们非常明显。这是一种完全不同的文化。但是那个说他要解雇人的人，他希望编程是一种一切都以低效的方式完成的东西，因为这应该符合他的有序理念。他不关心这个程序好不好——就它的速度和性能而言——他关心它是否满足其他标准，就像任何人都能维护它一样。好吧，人们还有很多其他有趣的想法。</p><p class="normal"><b>Knuth:</b> They were very weak, actually. It wasn't presented systematically and everything, but I thought they were pretty obvious. It was a different culture entirely. But the guy who said he was going to fire people, he wants programming to be something where everything is done in an inefficient way because it's supposed to fit into his idea of orderliness. He doesn't care if the program is good or not—as far as its speed and performance—he cares about that it satisfies other criteria, like any bloke can be able to maintain it. Well, people have lots of other funny ideas.</p>
<p class="normal">人们有这样一种奇怪的想法，即我们希望将我们的程序编写为他们自己的世界，以便其他人只需设置一些参数<a id="OEBPS/Chapter15.html.page_581"></a>我们的程序会为他们做这件事。所以世界上会有一些程序员编写库，然后有人为这些库编写用户手册，然后有人应用这些库，仅此而已。</p><p class="normal">People have this strange idea that we want to write our programs as worlds unto themselves so that everybody else can just set up a few parameters <a></a>and our program will do it for them. So there'll be a few programmers in the world who write the libraries, and then there are people who write the user manuals for these libraries, and then there are people who apply these libraries and that's it.</p>
<p class="normal">问题在于，如果您不能自己编写库，那么如果您所能做的就是从库中调用东西，那么编码就没有乐趣了。如果编码的工作只是找到正确的参数组合，那是很明显的事情，那么谁愿意从事这个职业呢？</p><p class="normal">The problem is that coding isn't fun if all you can do is call things out of a library, if you can't write the library yourself. If the job of coding is just to be finding the right combination of parameters, that does fairly obvious things, then who'd want to go into that as a career?</p>
<p class="normal">过分强调可重用软件，您永远无法打开盒子，看看盒子里有什么。有这些黑盒子很好，但是，几乎总是，如果你能看到盒子的内部，你就可以改进它，一旦你知道盒子里有什么，就可以让它更好地工作。取而代之的是，人们将这些封闭的包装器包裹在所有东西上，并将闭包呈现给全世界的程序员，而全世界的程序员都不允许这样做。他们所能做的就是组装零件。所以你记得当你调用这个子程序时你输入了<i>x0</i> , <i>y0</i> , <i>x1</i> , <i>y1</i>但是当你调用这个子程序时它是<i>x0</i> , <i>x1</i> , <i>y0</i> , <i>y1</i>. 你做对了，这就是你的工作。</p><p class="normal">There's this overemphasis on reusable software where you never get to open up the box and see what's inside the box. It's nice to have these black boxes but, almost always, if you can look inside the box you can improve it and make it work better once you know what's inside the box. Instead people make these closed wrappers around everything and present the closure to the programmers of the world, and the programmers of the world aren't allowed to diddle with that. All they're able to do is assemble the parts. And so you remember that when you call this subroutine you put <i>x0</i>, <i>y0</i>, <i>x1</i>, <i>y1</i> but when you call this subroutine it's <i>x0</i>, <i>x1</i>, <i>y0</i>, <i>y1</i>. You get that right, and that's your job.</p>
<p class="normal"><b>Seibel：</b>很多人会同意你的看法，是的，自己编写代码更有趣。但除了乐趣——</p><p class="normal"><b>Seibel:</b> Many people will agree with you that, yes, it's more fun to write the code yourself. But other than the fun—</p>
<p class="normal"><b>Knuth：</b>这不仅有趣。数学家的工作是证明，但几乎从来没有，当你解决一个数学问题时，你会找到一个定理，其假设正是你正在解决的问题所需要的。几乎总是你得到的东西<i>有点像</i>书中的定理。所以你所做的就是查看该定理的证明，然后说，“哦，这就是我必须如何更改该证明以证明我真正拥有的假设。” 所以数学书上塞满了定理，但你永远不会准确地插入定理——你想看那个证明，因为只有百分之一的时间你会找到你想要的定理。我认为这与软件完全相同。</p><p class="normal"><b>Knuth:</b> It's not only fun. The job of a mathematician is to make proofs but almost never, when you're solving a mathematical problem, do you find a theorem for which the hypotheses are exactly what you need for the problem you're solving. Almost always you've got something that's <i>sort of like</i> the theorem that's in the book. So what you do is you look at the proof of that theorem and you say, “Oh, here's how I have to change that proof in order to prove the hypothesis that I really have.” So mathematical books are packed with theorems, but you never plug in exactly the theorem—you want to see that proof because it's one time in a hundred when you'll find just the theorem that you wanted. I think it's exactly the same with software.</p>
<p class="normal"><b>Seibel：</b>然而，软件不就是——我想你自己也说过——是人类有史以来最复杂的东西吗？</p><p class="normal"><b>Seibel:</b> Yet isn't software—I think you've said it yourself—about the most complex thing human beings have ever made?</p>
<p class="normal"><a id="OEBPS/Chapter15.html.page_582"></a><b>Knuth：</b>我认为首先是 Dijkstra，但是是的。这是因为将某些东西放在一起的复杂性是如此不均匀。纯数学往往有一些普遍适用的规则——描述一个系统的三到四个公理。计算机程序有很多部分——第一步与第二步不同，与第三步不同。它汇集了所有这些东西，它们必须以一种复杂的方式相适应。</p><p class="normal"><a></a><b>Knuth:</b> It was Dijkstra, I think, first, but yeah. It's because the complexity of putting something together is so nonuniform. Pure mathematics tends to have a few rules that are applied universally—three or four axioms that describe a system. Computer programs have many parts—step one is different from step two is different from step three. It brings together all these things and they have to fit in an intricate way.</p>
<p class="normal"><b>Seibel：</b>考虑到这种复杂性，似乎在某些时候你必须拿一些黑盒子说，“好吧，我们知道它是如何工作的，我们可以使用它。” 如果我们被迫查看每个黑匣子的内部，我们将永远无法完成。</p><p class="normal"><b>Seibel:</b> So given that complexity, it seems like at some point you have to take some black boxes and say, “OK, we know how this thing works, and we can use it.” If we were forced to look inside every black box, we'd never finish.</p>
<p class="normal"><b>Knuth：</b>我并不是说黑匣子没有用。我是说，如果我不被允许打开它们——如果我必须用图书馆或类似的东西做所有事情，我会想出非常非常糟糕的结果，而且速度也会慢得多。</p><p class="normal"><b>Knuth:</b> I'm not saying black boxes are useless. I'm saying that if I'm not allowed to open 'em up—if I have to do everything with a library or something like this, I would come up with much, much worse results and much slower.</p>
<p class="normal"><b>Seibel：</b>运行较慢还是开发较慢？</p><p class="normal"><b>Seibel:</b> Slower-running or slower-developing?</p>
<p class="normal"><b>克纳特：</b>两者都有。好吧，好吧，我可以让程序快速运行，所以我不能这么说。它只是花了我更长的时间，因为我必须搜索更多的参考手册并找到合适的部分，所以它更像是一个搜索问题而不是一个创意问题。</p><p class="normal"><b>Knuth:</b> Both. Well, OK, I can get programs to work in a hurry, so I can't claim that. It's just taking me longer because I have to search through more reference manuals and find the right parts, so it's more of a search problem than a creative problem.</p>
<p class="normal"><b>Seibel：不久前</b>，编写标准 Java 集合库的人写了一篇文章，讲述了九年来他们的二分搜索实现中如何存在一个错误。基本上他们把最小值和最大值加在一起然后除以二。但是，当然，如果添加溢出，那就是一个错误。所以，标准库中有一个错误是很糟糕的，但他们最终找到了它并修复了它。如果每个人都自己写二分查找，那么二分查找出错的百分比可能会很高。</p><p class="normal"><b>Seibel:</b> A while back the guy who wrote the standard Java collection libraries wrote an article about how there had been a bug in their implementation of binary search for nine years. Basically they took the min and the max and added them together and divided by two. But, of course, if that addition overflows, that's a bug. So, it's bad the standard library had a bug in it, but they found it eventually and fixed it. If everyone wrote binary search themselves, the percentage of binary searches that would be wrong would probably be quite high.</p>
<p class="normal"><b>克纳特：</b>是的。而这只是众多例子中的一个。二进制搜索是一个特殊的例子，我们在 70 年代开始了我们的编程课程。第一天上课，每个人都写了一个二分查找的程序，我们把它们收集起来，让助教看一下。而你发现不到百分之十是正确的。并且有四六个不同的错误。但不是关于你提到的溢出，这是一个<a id="OEBPS/Chapter15.html.page_583"></a>新的——在我的课堂上并没有发生我们认为将这两个数字相加可能是一个问题。</p><p class="normal"><b>Knuth:</b> That's true. And that's just one of a huge number of examples. Binary search is a particular example that we started out our programming classes in the '70s. The first day of class everyone writes a program for binary search and we collect them and the TAs take a look. And you find that fewer than ten percent are correct. And there are four or six different bugs. But not with respect to the overflow that you mentioned, which is a <a></a>new one—it didn't occur in my classes that we thought adding these two numbers might be a problem.</p>
<p class="normal">但是这个黑盒子的想法——我为什么这么讨厌它？我们正在谈论算术，假设您有一个矩阵乘法程序。你有一个矩阵乘法黑盒，然后你将数据类型从实数更改为复数，这样你就有了一个复数矩阵乘法盒，它需要 4× <i>n3</i>个步骤而不是<i>n3</i>个步骤。如果真实案例需要一定时间<i>t</i>，那么复杂案例需要时间 4 <i>t</i>。但是如果你被允许打开盒子，那么你只需要三个实数矩阵乘法而不是四个，因为有一个恒等式可以描述两个复杂矩阵的乘积。这只是一个小例子——它还在继续。</p><p class="normal">But this black-box idea—why do I hate it so much? We're talking arithmetic, so say you have a program for matrix multiplication. You have a matrix multiply black box and then you change the data type from real to complex and so then you've got a complex matrix multiply box and it takes 4×<i>n3</i> steps instead of <i>n3</i> steps. If the real case takes a certain time, <i>t</i>, then the complex case takes time 4<i>t</i>. But if you're allowed to open the box, then you'll only need three real matrix multiplications instead of four because there's an identity that will describe the product of two complex matrices. That's just one small example—it just goes on and on.</p>
<p class="normal">我会有一个优先级队列或者我会有某种堆结构；不管它是什么——二进制搜索——我都会有一个很好的算法来源，但它不太适合我想要的，所以我每次都会调整它。我想我会过得更好。我知道我反对很多认为他们的工作是编写每个人都会使用的东西的人，所以如果其中有任何错误，他们会修复它们并且其他人的程序现在会开始更好地工作. 好的。我对这样的世界不满意。我喜欢看他们的节目。</p><p class="normal">I'll have a priority queue or I'll have some kind of a heap structure; whatever it is—binary search—I'll have a good source for the algorithm but it won't quite fit what I want, so I'll adapt it every time. And I think I'll be better off. I know I'm going against a lot of people who think their job is to write things that everybody is going to use, so if there are any bugs in it, they get to fix 'em and everybody else's program will start working better now. OK. I'm unhappy with that kind of world. I like to see their program.</p>
<p class="normal"><i>当我写《计算机程序设计艺术》</i>第一卷时，人们没有意识到他们可以在自己的程序中使用链表，也没有意识到他们可以使用数据结构的指针。</p><p class="normal">When I wrote Volume I of <i>The Art of Computer Programming</i> people didn't realize that they could use linked lists in their own programs, that they could use pointers for data structures.</p>
<p class="normal">如果您遇到的问题涉及数组之外的问题，您会使用某人的程序包，或者使用像 IPL-V 或 Lisp 这样的解释型语言。还有 Fortran 版本，您可以获得这些子例程，然后您将学习如何使用该包，并在其中编写您的程序。有人教普通程序员如何在他们的程序中包含链表是完全荒谬的。一切都应该由这些固定的例程来完成。</p><p class="normal">If you had a problem that had something beyond arrays, you would go to somebody's package, or an interpreted language like IPL-V or Lisp. There were also Fortran versions and you could get these subroutines and then you would learn how to use that package and you would do your program in that. It was completely preposterous for somebody to teach an ordinary programmer how to include linked lists in their program. Everything was supposed to be done by these canned routines.</p>
<p class="normal">但是一般的包必须有所有这些额外的机制来处理只针对少数用户的情况。所以我的书让人们大开眼界：“哦，我的天哪，我可以理解并改编它，这样我就可以同时拥有两个列表中的元素。我可以改变数据结构。” 它成为了可以成为主流的东西，而不仅仅是包含在这些包中。</p><p class="normal">But general packages have got to have all of this extra machinery in order to handle cases that only come up for a small number of the users. So my book sort of opened people's eyes: “Oh my gosh, I can understand this and adapt it so I can have elements that are in two lists at once. I can change the data structure.” It became something that could be mainstream instead of just enclosed in these packages.</p>
<p class="normal"><a id="OEBPS/Chapter15.html.page_584"></a>好吧，我现在看到了同样的事情，因为我正在写关于 BDD 结构的文章。目前有三四个子程序包可以与 BDD 一起工作，但我现在为<i>计算机编程的艺术</i>所写的主旨是，您也可以为许多应用程序编写 BDD 的简单版本，并且它会非常远。您可以将它们用于许多不同类型的问题，在这些问题中您不需要这些其他软件包的所有功能，并且您可以做的这些事情很容易理解并且很容易放入您自己编写的程序中。</p><p class="normal"><a></a>Well, I'm seeing the same thing now that I'm writing about BDD structures. At the moment there are three or four packages of subroutines that work with BDDs but the thrust of what I'm writing now for <i>The Art of Computer Programming</i> is that you too can program simple versions of BDDs for lots of applications and it'll go very far. You can use them for lots of different kinds of problems where you don't need all the bells and whistles of these other packages and these things you can do are easy to understand and easy to put into programs you're writing yourself.</p>
<p class="normal">今年早些时候，我完成了关于按位技巧和技术的部分，这些东西多年来一直是黑客社区的黑科技。我决定是时候说这些东西有一个理论，你可以理解这些想法，它们是如何组合在一起的。您可以放心地自己使用它们。你可以在去年根本不知道如何做好的事情的基础上再接再厉，做出令人惊奇的事情。它穿过地下直到现在；这是我们不妨教给人们的东西——值得成为常识的东西。</p><p class="normal">Earlier this year I finished my section on bitwise tricks and techniques and these are things that have been a black art in the hacker community for years. I decided it's time to say that there's a theory of these things that you can understand the ideas, how they fit together. You can use them yourself with confidence. And you can build on things and do amazing things that last year you didn't know how to do well at all. It went through the underground until now; it's something that we might as well teach to people—something that deserves to be common knowledge.</p>
<p class="normal">我写了很多程序，我不能说是典型的，但我可以说我得到了很多程序来处理各种各样的事情，如果我不得不把所有的时间都花在学习如何做，我会发现它更难使用别人的套路。学习一些基本概念然后通过文本编辑以前工作的代码来重用代码对我来说要容易得多。</p><p class="normal">I write a lot of programs and I can't claim to be typical but I can claim that I get a lot of them working for a large variety of things and I would find it harder if I had to spend all my time learning how to use somebody else's routines. It's much easier for me to learn a few basic concepts and then reuse code by text-editing the code that previously worked.</p>
<p class="normal"><b>Seibel：</b>从早期到现在，您对编程的看法发生了怎样的变化？</p><p class="normal"><b>Seibel:</b> How has the way you think about programming changed from those earliest days to now?</p>
<p class="normal"><b>Knuth：</b>我们已经讨论过文学编程——这是一个根本性的背离，我将自己视为一个解释者，而不是试图将正确的指令放在一起。Dijkstra 提出了同样的进化。最终他的程序甚至比我的更有文化，因为它们甚至没有进入机器。他们<i>只是</i>识字。</p><p class="normal"><b>Knuth:</b> We already talked about literate programming—that's a radical departure, that I'm viewing myself as an expositor rather than trying to just put together the right instructions. Dijkstra came out with that same evolution. In the end his programs were even more literate than mine in the sense that they didn't even go into the machine. They were <i>only</i> literate.</p>
<p class="normal">他是主要负责结构化编程的人之一，在结构化编程中，我们看到了可以用来扩展程序的模式，这样我们就可以制作更大的程序，同时保持头脑清醒。你写了一个十倍大的程序，但你不必为此损失十倍的睡眠，因为你有工具可以让你<a id="OEBPS/Chapter15.html.page_585"></a>在一个更大的系统中可靠地把东西放在一起。那绝对是不同的。</p><p class="normal">And he was one of the people largely responsible for structured programming, where we saw patterns that we could use to scale up our program so that we could make larger programs and still keep our head straight. You write a program that's ten times as big but you don't have to lose ten times as much sleep over it because you have tools that allow you <a></a>to put things together reliably in a larger system. That was definitely different.</p>
<p class="normal">所以这是一个重要的方面，我们必须理解的抽象概念，允许我们处理大型系统的抽象，并且仍然非常有信心我们处于控制之中并且我们知道我们在做什么，即使它们是一件令人难以置信的复杂事情。</p><p class="normal">So that's one important aspect, the idea of the abstractions that we have to understand, the abstractions that allow us to deal with large systems and still be pretty confident that we're in control and we know what we're doing, even though they're a mind-bogglingly complex things.</p>
<p class="normal">还有很多其他事情看起来像是重要的变化，但对我来说它们似乎并没有太大的不同。这些是表面，不同类型的语法糖和我们拥有的不同语言方言。有许多不同的口味可以吸引不同的性格类型。例如，有些人比我更有逻辑。他们真的很喜欢有很多括号，并且事情相互匹配，然后说，“我现在要开始做某事，”然后在最后你说，“我现在要完成它。” 这对我没有吸引力。我不这么认为。但这就是其他人的思维方式，而且没有最好的思维方式。</p><p class="normal">There are lots of other things that look like they're important changes but to me they don't seem to make that much difference. These are the surface, the different type of syntactic sugar and the different dialects of languages that we have. There are many different flavors that appeal to different personality types. Some people are more logical than I am, for example. They really like to have lots of parentheses, and things matching up and saying that, “I'm now going to start something,” and then at the end you say, “I'm now going to finish it.” And that's not as appealing to me. That's not the way I think. But that's the way other people think and there's no one best way to think.</p>
<p class="normal">对我来说，编程语言最重要的革命之一是在 C 语言中使用指针。当您拥有非平凡的数据结构时，您通常需要结构的一部分指向另一部分，人们尝试用不同的方式将其放入更高级的语言中。例如，托尼·霍尔 (Tony Hoare) 有一个相当不错的干净系统，但 C 语言添加的东西——起初我认为是一个大错误，后来发现我喜欢它——是 when<code>x</code>是一个指针，然后你说，<code>x + 1</code>，这并不意味着在 之后多一个字节，<code>x</code>而是在 之后多一个节点<code>x</code>，这取决于<code>x</code>指向什么：如果它指向一个大节点，则<code>x + 1</code>跳转大量；如果<code>x</code>指向一个小东西，<code>x + 1</code>只是移动一点。对我来说，这是符号学中最惊人的改进之一。</p><p class="normal">To me one of the most important revolutions in programming languages was the use of pointers in the C language. When you have nontrivial data structures, you often need one part of the structure to point to another part, and people played around with different ways to put that into a higher-level language. Tony Hoare, for example, had a pretty nice clean system but the thing that the C language added—which at first I thought was a big mistake and then it turned out I loved it—was that when <code>x</code> is a pointer and then you say, <code>x + 1</code>, that doesn't mean one more byte after <code>x</code> but it means one more node after <code>x</code>, depending on what <code>x</code> points to: if it points to a big node, <code>x + 1</code> jumps by a large amount; if <code>x</code> points to a small thing, <code>x + 1</code> just moves a little. That, to me, is one of the most amazing improvements in notation.</p>
<p class="normal"><b>Seibel：</b>因此，与之前的产品相比，这无疑是强大的。但从那以后，很多人认为使用指向内存的原始指针是非常危险的，他们宁愿使用行为很像指针但没有一些危险的引用。</p><p class="normal"><b>Seibel:</b> So that's certainly powerful compared to what preceded it. But since then, a lot of people have decided that having raw pointers to memory is pretty dangerous and that they'd rather have references that behave a lot like pointers but without some of the dangers.</p>
<p class="normal"><b>Knuth：</b>指针已经失宠到现在我不得不大发雷霆的地步，因为在我这里的 64 位计算机上，如果我真的<a id="OEBPS/Chapter15.html.page_586"></a>关心使用我的机器的能力 我发现我最好不要使用指针，因为我有一台有 64 位寄存器的机器，但它只有 2 GB 的 RAM。所以一个指针永远不会超过 32 个有效位。但每次我使用指针时，它都会占用我 64 位，这会使我的数据结构的大小翻倍。更糟糕的是，它进入了缓存，而我的一半缓存不见了，这需要花钱——缓存很贵。</p><p class="normal"><b>Knuth:</b> Pointers have gone out of favor to the point now where I had to flame about it because on my 64-bit computer that I have here, if I really <a></a>care about using the capability of my machine I find that I'd better not use pointers because I have a machine that has 64-bit registers but it only has 2 gigabytes of RAM. So a pointer never has more than 32 significant bits to it. But every time I use a pointer it's costing me 64 bits and that doubles the size of my data structure. Worse, it goes into the cache and half of my cache is gone and that costs cash—cache is expensive.</p>
<p class="normal">所以如果我现在真的想挑战极限，我必须使用数组而不是指针。我制作了复杂的宏，所以看起来我在使用指针，但实际上不是。在某种程度上，这是一件小事，而且已经过时了。但对我来说，这是较低级别的符号中的一个重要想法；在工作和调试等时候，我还是很感谢Thompson和Ritchie。我不知道是谁想出了那个特别的。</p><p class="normal">So if I'm really trying to push the envelope now, I have to use arrays instead of pointers. I make complicated macros so that it looks like I'm using pointers, but I'm not really. In a way it's a small thing and it's going out of fashion. But to me it was an important idea in notation at the lower levels; when I'm working and debugging and so on I'm still very grateful to Thompson and Ritchie. I don't know who came up with that particular one.</p>
<p class="normal"><b>Seibel：</b>您的编程工具包中还有其他重要的部分吗？</p><p class="normal"><b>Seibel:</b> Are there any other important parts of your programming toolkit?</p>
<p class="normal"><b>Knuth：</b>更改文件是我通过文学编程得到的东西，我不知道任何其他程序员工具包中的相应工具，所以让我向您解释一下。</p><p class="normal"><b>Knuth:</b> Change files are something that I've got with literate programming that I don't know of corresponding tools in any other programmers' toolkits, so let me explain them to you.</p>
<p class="normal">我写了 TeX 和 Metafont，人们开始要求它。他们有 200 或 300 种编程语言、操作系统和计算机的组合，所以我想让我的代码很容易适应任何人的系统。所以我们想出了一个解决方案，我将编写一个在斯坦福工作的主程序，然后有一个称为<i>更改文件</i>的附加组件，可以根据其他任何人的机器对其进行自定义。</p><p class="normal">I had written TeX and Metafont and people started asking for it. And they had 200 or 300 combinations of programming language and operating system and computer, so I wanted to make it easy to adapt my code to anybody's system. So we came up with the solution that I would write a master program that worked at Stanford and then there was this add-on called a <i>change file</i> which could customize it to anybody else's machine.</p>
<p class="normal">更改文件是一件非常简单的事情。它由一堆小的变化组成。每个更改都从几行代码开始。你匹配<a id="OEBPS/Chapter15.html.page_587"></a>直到您在主文件中找到与您更改的第一行一致的第一行。当您到达应该与主文件匹配的更改部分的末尾时，就会出现“用这些行替换它”的部分。</p><p class="normal">A change file is a very simple thing. It consists of a bunch of little blobs of changes. Each change starts out with a few lines of code. You match <a></a>until you find the first line in the master file that agrees with the first line of your change. When you get to the end of the part of the change that was supposed to match the master file, then comes the part which says, “Replace that by these lines instead.”</p>
<p class="normal">也许变化是说，“用这十二行替换这六行。或者没有线。一旦你得到一场比赛，你就会坚持你改变的十二个。然后你去下一个。您必须按顺序编写更改——它不会为匹配做任何智能的事情；它只是说，“去</p><p class="normal">Maybe the change says, “Replace these six lines by these twelve lines. Or by no lines. As soon as you get a match, you stick in the twelve that you changed. Then you go onto the next one.” You've got to write the changes in order—it doesn't do anything intelligent for matching; it just says, “Go</p>
<p class="normal">直到找到下一个更改的第一行必须与主文件中的某行相匹配。”</p><p class="normal">until you find the first line of the next change that has to match some line in the master file.”</p>
<p class="normal">这是一个只需要一个小时就可以编程的系统，而且它已经足够好了。然后，我们拥有的用于文学编程的所有工具，weave 和 tangle 程序，将采用主文件和更改文件。</p><p class="normal">It's a system that only takes an hour to program and it's good enough for the purpose. Then all the tools that we have for literate programming, the weave and tangle programs, will take the master file and the change file.</p>
<p class="normal">所以每隔一段时间我就不得不发布一个新的主程序。全世界这数百人都有他们的更改文件——也许他们的六行本应与我的匹配的不再匹配，因此他们可能不得不进行一些更改。但他们不必做很多事情。每次我纠正错误时，它几乎都会自动生效——错误修复也会应用于他们的程序。这非常简单地解决了问题并且有效。任何人都可以弄清楚并做到这一点。</p><p class="normal">So every so often I'd have to release a new master program. All these hundreds of people around the world had their change files—maybe their six lines that were supposed to match mine no longer matched, so they might have to make some changes. But they wouldn't have to do very much. Every time I would correct a bug it would almost automatically work—the bug fix would also apply to their program. This solved the problem very simply and it worked. Anybody could figure it out and do it.</p>
<p class="normal">一个极端的例子就是 TeX 适配 Unicode。他们的变更文件可能是主程序的 10 倍长。换句话说，他们从一个 8 位程序变成了一个 16 位程序，但他们没有仔细研究并重做我的主程序，而是如此着迷于更改文件，以至于他们只是将他们称之为 Omega 的整个草稿写为更改文件，作为 TeX 的 20,000 行代码或其他东西的一百万行更改文件。所以这是极端的。</p><p class="normal">The extreme example of this was when TeX was adapted to Unicode. They had a change file maybe 10 times as long as the master program. In other words, they changed from an 8-bit program to a 16-bit program but instead of going through and redoing my master program, they were so into change files that they just wrote their whole draft of what they called Omega as change files, as a million lines of change files to TeX's 20,000 lines of code or something. So that's the extreme.</p>
<p class="normal">但现在我一直在使用更改文件，因为我正在为自己编写程序，我正在使用这些程序来写我的书——我有很多问题需要解决，我想尝试不同的版本。<i>就像昨天一样，我想找出用于n</i>位数字乘法的布尔电路有多大。我有一个程序，它接受任何布尔函数并找出它的 BDD 有多大。所以我有一个程序可以接受任何布尔函数并计算它的 BDD。</p><p class="normal">But now I use change files all the time because I'm writing programs for myself that I'm using writing my book—I've got lots of problems that I want to solve and I want to experiment with different versions. Like yesterday I wanted to find out how big a Boolean circuit is for multiplication of <i>n</i>-bit numbers. I have a program that takes any Boolean function and finds out how big its BDD is. So I've got a program that takes any Boolean function and computes its BDD.</p>
<p class="normal">在我的原始程序中，你在线输入函数的真值表——它说，“给我一个真值表，”然后我输入一个十六进制数，因为我有很多小函数用作示例。但它只适用于小函数，即我想在真值表中输入的函数。</p><p class="normal">In my original program you input the truth table of the function online—it says, “Give me a truth table,” and I type in a hexadecimal number, because I had a lot of small functions that I'm using as examples. But it only works for small functions, the ones that I want to type in the truth table.</p>
<p class="normal">然后我得到了一个大函数，比如“将所有 8 位数字对相乘”。这是 16 个变量的函数——x 中有 8<i>位</i>，<i>y</i>中有 8 位。所以我写了一个<i></i><a id="OEBPS/Chapter15.html.page_588"></a>一个小的更改文件，该文件删除了这个交互式对话框，并将其替换为一个为乘法制作真值表的程序。</p><p class="normal">Then I've got a big function like, “Multiply all pairs of 8-bit numbers.” This is a function of 16 variables—there are 8 bits in <i>x</i> and 8 bits in <i>y</i>. So I write a <a></a>little change file that takes out this interactive dialog and replaces it with a program that makes a truth table for multiplication.</p>
<p class="normal">然后我通过说“让我们从右到左而不是从左到右读取位来改变它，这会给你一个不同的 BDD。” 或者，“让我尝试六个变量的所有布尔函数，我将遍历它们并找出哪个具有最大的 BDD。” 但所有这些都是我原来的东西的定制。</p><p class="normal">Then I changed that by saying, “Let's read the bits from right to left instead of from left to right, which gives you a different BDD.” Or, “Let me try all Boolean functions of six variables and I'll run through them all and find out which one has the largest BDD.” But all of these are customizations of my original thing.</p>
<p class="normal">我可能会有 15 个易于理解的程序变体。这是文字编程的一个意想不到的副产品，因为我们需要将主文件发送给许多正在为他们自己的系统更改它的人；我现在以完全不同的方式使用它。</p><p class="normal">I'll have maybe 15 variants of that program that are easily understood. This was an unexpected spin-off from literate programming because of our need for sending out master files to a lot of people that were changing it for their own system; I'm now using it in a completely different way.</p>
<p class="normal"><b>Seibel：</b>这似乎很明显为什么这对你正在做的工作有用，你想在不同主题上做很多变化。</p><p class="normal"><b>Seibel:</b> It seems sort of obvious why that would be useful for you in the kind of work you're doing, where you want to do a lot of variations on different themes.</p>
<p class="normal"><b>Knuth：</b>是的，我正在写一本书。</p><p class="normal"><b>Knuth:</b> Yeah, I'm writing a book.</p>
<p class="normal"><b>Seibel：</b>您认为这种机制可以更广泛地适用吗？</p><p class="normal"><b>Seibel:</b> Do you think this mechanism could be more broadly applicable?</p>
<p class="normal"><b>Knuth：</b>我不知道。如果我在一个 50 人的团队中，我不确定它会如何工作。但我希望个人程序员为了学习一些东西而编写程序的想法不是一个垂死的品种。</p><p class="normal"><b>Knuth:</b> I have no idea. I'm not sure how it would work if I was in a team of 50 people. But I hope that the idea of an individual programmer writing programs in order to learn something is not a dying breed.</p>
<p class="normal"><b>Seibel：</b>在你最早的日子里，你在写机器代码；然后你发现了结构化编程，它实际上提供了一种组织程序的结构。然后你发明了文学编程，这给了你另一种构建程序的方法。自文学编程发明以来，是否还有其他任何事情极大地改变了您对编程的看法？</p><p class="normal"><b>Seibel:</b> In your earliest days you were writing machine code; then you found structured programming, which provided literally a structure for organizing programs. And then you invented literate programming, which gave you another way to structure programs. Since the invention of literate programming, has there been anything else that's as dramatically changed the way you think about programming?</p>
<p class="normal"><b>Knuth：</b>我有更好的调试工具来进行文学编程；基本上就这些了。</p><p class="normal"><b>Knuth:</b> I've got better debugging tools for literate programming; that's basically all.</p>
<p class="normal"><b>Seibel：</b>好的，让我们谈谈调试吧。你现在有什么更好的工具？</p><p class="normal"><b>Seibel:</b> OK, let's talk about debugging. What better tools do you have now?</p>
<p class="normal"><a id="OEBPS/Chapter15.html.page_589"></a><b>Knuth：</b>事实证明，GNU 调试器的发明者意识到你可以让预处理器编写程序。因此，您可以使用完全不同的语言将低级内容与高级资源相关联。S 我正在写入，<code>CWEB</code>但我仍然不必查看较低级别的内容，因为它会<code>CWEB</code>在我逐步执行程序时显示我的源代码。</p><p class="normal"><a></a><b>Knuth:</b> It turned out that the inventors of the GNU debugger realized t you could have preprocessors writing programs. So you can correlate th low-level stuff to a high-level source in a completely different language. S I'm writing in <code>CWEB</code> but I still never have to look at the lower-level things because it'll flash my <code>CWEB</code> source as I'm stepping through the program.</p>
<p class="normal"><a id="OEBPS/Chapter15.html.page_590"></a><b>Seibel：</b>那么这是 GDB 中内置的一个工具，<code>CWEB</code>可以利用它吗？</p><p class="normal"><a></a><b>Seibel:</b> So that's a facility built into GDB which <code>CWEB</code> takes advantage of?</p>
<p class="normal"><b>Knuth：</b>它内置于 GDB 中，因为它内置于 C 中以具有<code>#line</code>指令。我们必须努力利用这些<code>#line</code>指令，但它的效果很好。计算机坐在那里，有一条二进制指令，但 GDB 知道这来自我的 WEB 源文件中的某些东西，尽管 WEB 比 C 晚了 10、20 年。所以这是他们设计中非常好的、非常有前瞻性的部分那个工作。</p><p class="normal"><b>Knuth:</b> And was built into GDB because it was built into C to have <code>#line</code> directives. We had to work to make use of the <code>#line</code> directives, but it works beautifully. The computer is sitting there with a binary instruction but GDB knows that this came from something in my WEB source file even though WEB came 10, 20 years after C. So it was a very good, very forward-looking part of their design to make that work.</p>
<p class="normal"><b>Seibel：</b>所以你使用 GDB。您还使用哪些其他调试技术？</p><p class="normal"><b>Seibel:</b> So you use GDB. What other debugging techniques do you use?</p>
<p class="normal"><b>Knuth：</b>我将添加大量代码来检查我的数据结构及其所有冗余是否正确完成。如果我打开它，这种健全性检查可能会使整个事情的速度降低 100 倍。</p><p class="normal"><b>Knuth:</b> I'll add a lot of code that will check to see if my data structures, with all their redundancies, are properly done. This sanity checking migh slow the whole thing down by a factor of 100 if I turn it on.</p>
<p class="normal">例如，我有一个涉及引用计数的复杂数据结构。所以我正在编写一些非常复杂的程序，并且正确地获取引用计数是令人费解的。每隔一段时间我就必须增加或减少引用计数。但是当指针在寄存器中或者是子程序的参数时，这是否算作数据结构中的引用？所以我得到了经过数百万计数的健全性检查 wri，看看有多少引用是真实的，数字是否正确？然后我会做一些计算并检查整个事情。这样，错误将在崩溃中浮出水面之前被检测到数十亿秒。</p><p class="normal">For instance, I had a complicated data structure that involves reference counts. So I'm writing some pretty complicated programs, and getting th reference counts correct is mystifying. Every once in a while I have to increase the reference count or decrease the reference count. But when pointer is in a register or is a parameter to a subroutine, does that coun a reference in the data structure or not? So I've got the sanity check wri that goes through the millions of counts seeing how many references are really made and are the numbers correct? Then I'll do a little computatio and check the whole thing. That way errors will be detected billions of s before they would surface in a crash.</p>
<p class="normal">有一个程序以一种新的方式做乘法，所以我试了一遍。我制作了 256 个数字，然后将它们中的每一个相乘，但在每个数字之后我都会进行健全性检查。我用 2 乘以 3 失败了！所以我修好了。然后是别的东西。最后，我得到了所有 256 x 256 都在工作并得到正确答案的地方。</p><p class="normal">There was a program that does multiplication in a new way, so I tried it exhaustively. I made 256 numbers and I multiplied each of them by each other one, but after each one I would do a sanity check. I multiply 2 by 3 fails! So I fixed that. And then something else. Finally I got it to where all 256 by 256 were working and getting the right answer.</p>
<p class="normal">所以这对我来说是一项重要的调试技术。可能百分之十的代码用于一些我不需要的东西，除非我正在调试。完整性检查代码还记录了数据结构。</p><p class="normal">So that's an important debugging technique for me. Maybe ten percent of the code is devoted to something that I don't need except when I'm debugging. And the sanity-check code also documents the data structure.</p>
<p class="normal">我还会写一些东西，提供一个很好的数据结构符号形式，这样我就不必解码一大堆二进制的东西。然后，如有必要，我可以以某种体面的结构化形式打印出一个数据结构，或者我可以将它转储到一个文件中，然后我可以编写另一个程序来分析它以找出问题所在。</p><p class="normal">I'll also write something that gives a nice symbolic form of a data structure so I don't have to decode a whole bunch of binary things. Then, if necessary, I can print out a data structure in some decent structured form or I can dump it out in a file and I can write another program that analyzes it to find out what's going wrong.</p>
<p class="normal"><b>Seibel：</b>与不变量和各种断言相关，像 Dijkstra 这样的人会争辩说，我们必须在程序的每一步都放置非常正式的断言，这样我们才能证明我们的程序是正确的。我读过你谈到想要证明你的程序“非正式正确”的地方；您如何看待我们应该超越这一点并正式证明事情正确的想法？</p><p class="normal"><b>Seibel:</b> Related to invariants and various kinds of assertions, folks like Dijkstra would argue that we've got to put very formal assertions at every step of our program so that we can then prove our programs correct. I've read where you've talked about wanting to prove your programs “informally correct”; what's your take on the idea that we should go beyond that and formally prove things correct?</p>
<p class="normal"><b>Knuth：</b>一方面，你不可能证明某件事。有人会说他们有一个经过验证的程序，而且它只是经过验证，因为它符合某些验证者的规范。但是验证器可能有一个错误。规范中可能有错误。所以你永远不知道程序是正确的。你有更多的理由相信它，但你永远不会走到循环的尽头。理论上是不可能的。</p><p class="normal"><b>Knuth:</b> On one hand you have this impossibility of ever having something proved. Somebody will say they have a program that's verified and it's only verified because it met its specifications according to some verifier. But the verifier might have a bug in it. The specifications might have bugs in them. So you never know that the program is correct. You have more reason to believe it, but you never get to the end of the loop. It's theoretically impossible.</p>
<p class="normal">Tony Hoare 关于正式证明的第一篇论文“Proof of a Program: FIND”是一项伟大的成就，推动了最先进的技术水平。但是那个证明中有两三个错误。他们没有想到您必须验证下标是否在边界内或类似的东西。总是有机会出现差距。不过，在这一点上，他比其他任何人都更证实了这一点。</p><p class="normal">The very first paper by Tony Hoare about formal proof, “Proof of a Program: FIND,” was a great achievement and advanced the state of the art. But there were two or three bugs in that proof. It hadn't occurred to them that you had to verify that subscripts lie in-bounds or something like this. There's always a chance for gaps. Still, he had verified it much more than anybody else had at that point.</p>
<p class="normal">现在，我昨天做的程序——我不知道我将如何陈述那里的所有断言。我永远不会完成，因为我对自己的断言不会比对程序更有信心。</p><p class="normal">Now, the program that I did yesterday—I have no idea how I would state all of the assertions that are there. I would never get done because I wouldn't have any more confidence in my assertions than I would in the program.</p>
<p class="normal">或者 TeX，例如，是一个正式的混乱。它旨在供人类使用，而不是供计算机使用。定义 TeX 正确的含义<a id="OEBPS/Chapter15.html.page_591"></a>将是不可理解的。形式语义的一些方法非常复杂，以至于没有人能够理解<i>正确性</i>的定义。</p><p class="normal">Or TeX, for example, is a formal mess. It was intended to be for human use, not for computer use. To define what it means for TeX to be correct <a></a>would be incomprehensible. Some methods for formal semantics are so complicated that nobody can comprehend the definition of <i>correctness</i>.</p>
<p class="normal"><b>Seibel：</b>当你在 TeX 上工作时，你写了一个非常可怕的程序折磨测试。</p><p class="normal"><b>Seibel:</b> When you were working on TeX you wrote a really horrendous torture test of the program.</p>
<p class="normal"><b>克纳特：</b>对。</p><p class="normal"><b>Knuth:</b> Right.</p>
<p class="normal"><b>Seibel：</b>你是怎么想到去做那件事的？程序员往往想要保护他们的孩子，所以他们不会尽可能地努力测试。</p><p class="normal"><b>Seibel:</b> How do you get in the frame of mind to do that? Programmers often tend to want to protect their baby, and so they don't test as hard as they could.</p>
<p class="normal"><b>Knuth：</b>好吧，我这辈子都是个吹毛求疵的人。因此，如果我能从发现错误中解脱出来，那么我只需要确保我忘记了我是该程序的作者。我试着想象其他人是作者。但除此之外，我很容易进入攻击模式。我不知道为什么。</p><p class="normal"><b>Knuth:</b> Well, I've been a nitpicker all my life. So if I can get my kicks out of finding errors then I just have to make sure that I forget that I was the author of the program. I try to imagine that somebody else was the author. But otherwise it's fairly easy for me to get into attack mode. I don't know why.</p>
<p class="normal">例如，我为 Burroughs Corporation 所做的一些最好的工作就是调试他们的硬件设计。他们的工程师会向我展示他们计算机的规格，我会查看它，然后我会尝试构建示例，在这些示例中，它们会相差 1 左右。在他们投入生产之前，我从他们的 B-5000 系列机器中发现了 200 多个错误，尽管它已经通过了模拟器。</p><p class="normal">For example, some of the best work I did for Burroughs Corporation was to debug their hardware designs. Their engineers would show me the specs for their computer and I would look at it and I would try to construct examples where they would be off by 1 or something. I got more than 200 bugs out of their B-5000–series machines before they went into production, although it had passed the simulators.</p>
<p class="normal"><b>Seibel：</b>所以基本上你是在发明根据语言语义正确的程序，但机器会错误地执行？</p><p class="normal"><b>Seibel:</b> So essentially you were inventing programs that were correct according to the semantics of the language but the machine would then execute incorrectly?</p>
<p class="normal"><b>克纳特：</b>对。当然，如果他们的浮点数不能计算两个数字的正确乘积，我会尝试找到浮点数不起作用的数字示例。但也有他们在硬件中实现堆栈的情况，并且他们有寄存器为空或不在堆栈顶部的情况，我会发现他们的逻辑会被搞砸的情况。</p><p class="normal"><b>Knuth:</b> Right. Certainly if their floating point isn't calculating the right product of two numbers, I would try to find examples of numbers where the floating point didn't work. But also there were cases where they were implementing a stack in hardware and they had cases where registers would be empty or not at the top of the stack and I would find scenarios where their logic would get screwed up.</p>
<p class="normal"><b>Seibel：</b>你有系统的方法来做到这一点吗？你是怎么找到他们的？</p><p class="normal"><b>Seibel:</b> Did you have a systematic way of doing that? How did you find them?</p>
<p class="normal"><a id="OEBPS/Chapter15.html.page_592"></a><b>Knuth：</b>我只是个卑鄙的人吗？我不知道。但如果我试图证明某件事——数学中的定理——而不是证明它是正确的，通常对我来说更容易说，“好吧，找一个反例。” 我会很兴奋地找到其中的漏洞或解释为什么它不起作用。然后，当我找不到任何漏洞时，我就会看到证据。</p><p class="normal"><a></a><b>Knuth:</b> Am I just a mean guy? I don't know. But if I'm trying to prove something—a theorem in mathematics—instead of proving that it's correct, it's easier for me, usually, to say, “Well, find a counterexample.” I can get psyched up to find a hole in this or explain why it doesn't work. And then when I can't find any holes, then I see the proof.</p>
<p class="normal">我认为这只是我的个性，我喜欢攻击事物并发现错误。当我作为对手玩游戏时，我的能量就会发挥作用，而不是如果我只是坐在那里试图说，“哦，是的；现在为什么会这样？</p><p class="normal">I think it's just my personality that I like to attack things and find errors. My juices are working when I'm playing the game as the opponent rather than if I'm just sitting there trying to say, “Oh, yeah; now why is this working?”</p>
<p class="normal"><b>Seibel：</b>奇怪的是，这就是你前进的动力，但你毕生的工作就是解释事情。你认为这种方法会以某种方式影响你解释事物的方式吗？</p><p class="normal"><b>Seibel:</b> It's curious that that's what gets you going, yet your life's work is explaining things. Do you think that approach somehow feeds into how you explain things?</p>
<p class="normal"><b>Knuth：</b>对于我的解释，我唯一可以声称的是，我试图匹配一种自然的大脑过程，即一次以两种不同的方式看待事物，以便更好地理解事物。我认为关键通常是要有立体视图而不是一维视图。我不知道这对攻击业务有何影响。</p><p class="normal"><b>Knuth:</b> The only thing I can claim for my explanations is that I try to match a natural brain process of seeing things in two different ways at a time in order to understand something better. I think the key is usually to have a stereo view instead of a one-dimensional view. I don't know how that affects this attacking business.</p>
<p class="normal">但是当你进攻时——当你在玩游戏，试图打败某些东西时——它会激发竞争性荷尔蒙或某种以某种方式刺激大脑的东西，这可能只是意味着我正在尝试不止一种方法来达到目标它。一个好的解释是类似的事情。一个好的解释以某种方式结合了不同的观点。</p><p class="normal">But when you're attacking—when you're playing the game, trying to defeat something—it arouses competitive hormones or something that just stimulates the brain in a way that probably just means that I'm trying more than one way to get at it. A good explanation is a similar thing. A good explanation somehow combines different viewpoints.</p>
<p class="normal"><b>Seibel：</b>你在“The Errors of TeX”中描述的 TeX 工作的另一件事是你在程序中发现的每个错误的日志。像软件工程研究所这样的人说，成熟的软件工程过程的一部分是跟踪所有错误并学习如何防止将来出现同类错误。但是你说保留了这个日志，并不能帮助你防止以后的错误。</p><p class="normal"><b>Seibel:</b> Another thing that came out of working on TeX, which you described in “The Errors of TeX,” was a log of every error that you found in the program. Folks like the Software Engineering Institute people say that part of a mature software-engineering process is keeping track of all your bugs and learning how to prevent the same kind of errors in the future. But you said that having kept this log, it doesn't help you prevent future errors.</p>
<p class="normal"><b>克努特：</b>是的。虽然很难说没有日志我不会更糟。</p><p class="normal"><b>Knuth:</b> Yeah. Though it's hard to say that I wouldn't have been even worse without the log.</p>
<p class="normal"><b>Seibel：</b>但你不会觉得，“啊，既然我已经看到了，我不会再这样做了。”</p><p class="normal"><b>Seibel:</b> But you didn't feel like, “Ah, now that I've seen this I won't do it again.”</p>
<p class="normal"><a id="OEBPS/Chapter15.html.page_593"></a><b>Knuth：</b>我只是要认清自己的罪过。如果你知道神学术语，人们会不断回来寻求赦免。</p><p class="normal"><a></a><b>Knuth:</b> I just got to recognize my sins. People keep coming back for absolution, if you know theological terms.</p>
<p class="normal"><b>Seibel：</b>所以你发现自己现在在你的程序中制造错误，然后说，“哦，我又做了一次，同样的错误。”</p><p class="normal"><b>Seibel:</b> So you find yourself now making bugs in your programs and then saying, “Oh, I've done it again, that same kind of bug.”</p>
<p class="normal"><b>克努特：</b>是的。</p><p class="normal"><b>Knuth:</b> Yeah.</p>
<p class="normal"><b>Seibel：</b>那是为什么呢？错误的性质是否有某种原因使得很难吸取教训以防止再次犯错？</p><p class="normal"><b>Seibel:</b> So why is that? Is there something about the nature of the mistakes that makes it hard to distill a lesson that will prevent making them again?</p>
<p class="normal"><b>Knuth：</b>我认为我可能会尝试更努力的事情。我总是尝试在我极限范围内的事情。如果我必须回去重新编写那些类型的程序，那些更简单的程序，我就不会犯那么多错误了。但现在我知道了更多，我正在尝试写更难的东西。所以我会犯错误，因为我总是在我的极限下工作。如果我一直都呆在舒适的区域，那就没那么有趣了。</p><p class="normal"><b>Knuth:</b> I think it's probably more that I'll try harder things. I always try things that are at my limit. If I had to go back and write those kinds of programs again, the easier ones, I wouldn't make so many mistakes. But now that I know some more, I'm trying to write harder stuff. So I make mistakes because I'm always operating at my limit. If I only stay in comfortable territory all the time, that's not so much fun.</p>
<p class="normal"><b>Seibel：</b>那么，如果你的余生都一直在写排版系统呢？</p><p class="normal"><b>Seibel:</b> So if you just kept writing typesetting systems for the rest of your life?</p>
<p class="normal"><b>Knuth：</b>是的，我会得到那些很好的。但是我们不断提高标准，然后我们偶然发现了它。正如我们之前所说，我们正在处理的事情处于人类可以处理的边缘，而且比以前更复杂。</p><p class="normal"><b>Knuth:</b> Yeah, I would get those pretty good. But we keep raising the bar and then we stumble on it. We're dealing with—as we said earlier—things that are on the edge of what human beings can handle and more complicated than have been done before.</p>
<p class="normal">如果我们把自己限制在真正容易的事情上，那是不令人满意的，因为我们的胃口总是要突破界限，直到达到我们几乎做不到的程度。一旦我们到达那里，我们就会想要突破这个界限等等。</p><p class="normal">If we restrict ourselves to the things that are really easy, then that's not satisfactory because our appetite is always to push the boundary and go until it gets to something we can barely do. And once we've got to there, then we're going to want to push that boundary and so on.</p>
<p class="normal">因此，除非我们决定永远不会编写任何扩展我们能力的东西，否则我们不可避免地会遇到错误。那么我们如何才能做得更好呢？每三年就会出现另一个流行词，它会解决所有这些问题并使其真正发挥作用。<i>极限编程</i>是最近两三年的事情之一。在那之前还有别的东西。有人会想出另一个所谓的灵丹妙药，会有很多人加入这个潮流，然后他们会发现，“哦，它仍然很难。”</p><p class="normal">So inevitably we're going to have bugs unless we decide we're never going to write anything that stretches our capabilities. So how are we going to do it better? Every three years there'll be another buzz word as to something that's going to solve all these problems and make it really work. <i>Extreme programming</i> was one the last two or three years. Before that there was something else. Somebody will come up with another supposedly silver bullet and there'll be a lot of people jumping on that bandwagon and then they'll find, “Oh, it's still hard.”</p>
<p class="normal"><a id="OEBPS/Chapter15.html.page_594"></a><b>Seibel：</b>随着时间的推移，什么样的人可以成为一名优秀的程序员？</p><p class="normal"><a></a><b>Seibel:</b> Has the kind of person who can be a good programmer changed over time?</p>
<p class="normal"><b>Knuth：</b>在很长一段时间里，我的经验几乎是一个不变的是，每次我接触来自某些人群的 100 个人时，除了计算机科学专业的人，其中 2 人是程序员，因为他们真正与机器产生共鸣。阿拉斯加的瓦西拉有 10,000 人，因此它可能有 200 名程序员。</p><p class="normal"><b>Knuth:</b> Pretty much a constant in my experience, over a long period of years, is that every time I'm exposed to 100 people from some population or other, except majors in computer science, 2 of them are programmers in the sense that they really resonate with the machine. Wasilla, Alaska, has 10,000 people, so it's probably got 200 programmers.</p>
<p class="normal"><b>Seibel：</b>那么编程是否发生了足够大的变化，以至于属于那 2% 的那类人发生了变化？还是真的还是一样？</p><p class="normal"><b>Seibel:</b> So has programming changed enough that the kind of person who falls in that two percent has changed? Or is it still really the same?</p>
<p class="normal"><b>Knuth：</b>我不知道——你可以在不同的意义上使用<i>编程这个词。</i>我们一直在制造旨在使人们的大脑更加匹配并在计算机上完成某些事情的工具。我主要是在谈论当机器被推到信封而不是仅仅得到答案时机器真正工作的方式。</p><p class="normal"><b>Knuth:</b> I don't know—you can use the word <i>programming</i> in different senses. We're always making tools that are intended to make more of a match between people's brains and getting something done in a computer. I'm mostly talking about the way a machine really works when the machine is being pushed to the envelope rather than just getting an answer out.</p>
<p class="normal">我们现在拥有如此强大的机器，以我深奥的感觉，不擅长编程的人也能够从这些机器中得到答案，而这需要大量专家才能在旧机器上完成。但是有了新机器，我所说的这些人将要解决旧机器无法处理的问题。</p><p class="normal">We've got machines that are so powerful now that people who aren't really good at programming, in my esoteric sense, are able to get answers out of these machines that would have taken a huge expert to do on old machines. But with the new machines, the people that I'm talking about are going to be doing the problems that couldn't be handled by the old machines.</p>
<p class="normal">所以有这种变化，然后是我真正担心的变化：今天很多编程的方式没有任何乐趣，因为它只是插入魔法咒语——结合别人的软件并启动它。它没有太多的创造力。我担心它会变得太无聊，因为你没有机会做任何新鲜事。你的兴奋来自于看到机器产生的有趣结果，但不是我通过创造新事物总是得到的那种刺激。现在的乐趣在于，在您完成无聊的工作之后，您会突然间得到一个很棒的图像。但这项工作过去并不乏味。</p><p class="normal">So there's that change and then there's the change that I'm really worried about: that the way a lot of programming goes today isn't any fun because it's just plugging in magic incantations—combine somebody else's software and start it up. It doesn't have much creativity. I'm worried that it's becoming too boring because you don't have a chance to do anything much new. Your kick comes out of seeing fun results coming out of the machine, but not the kind of kick that I always got by creating something new. The kick now is after you've done your boring work then all of the sudden you get a great image. But the work didn't used to be boring.</p>
<p class="normal"><b>Seibel：</b>但你仍然觉得你从事的编程很有趣吗？</p><p class="normal"><b>Seibel:</b> But you still find the kind of programming you do interesting?</p>
<p class="normal"><b>Knuth：</b>天哪，是的。我有这种编程的<i>需要</i>。我早上醒来时会听到文字程序的句子。早餐前——我确定<a id="OEBPS/Chapter15.html.page_595"></a>诗人一定有这种感觉——我必须到电脑前写下这段话，然后我才能吃饭，我很开心。这是一种强迫症；我不得不承认。</p><p class="normal"><b>Knuth:</b> Oh my God, yes. I've got this <i>need</i> to program. I wake up in the morning with sentences of a literate program. Before breakfast—I'm sure <a></a>poets must feel this—I have to go to the computer and write this paragraph and then I can eat and I'm happy. It's a compulsion; that I have to admit.</p>
<p class="normal">OK，给大家看一下我昨天写的程序。我乘以比宇宙大得多的巨大整数——它们是特殊的整数，你可以压缩表示，所以我可以处理它们，即使我不能用普通的符号表示它们，而且我'我一直在乘这些大得难以置信的整数，我一直在计算它们的平方，并找出它们在平方后的样子。我对发生的事情感到非常困惑，但这让我很兴奋。</p><p class="normal">OK, let me show you the program I wrote yesterday. I'm multiplying huge integers that are way bigger than the universe—they're special integers that you can compress the representation down, and so I can deal with them even though I couldn't represent them in an ordinary notation, and I've been multiplying these integers that are inconceivably large and I've been squaring them and finding out how they look after squaring them. I'm very puzzled about what's going on, but this is exciting to me.</p>
<p class="normal"><b>Seibel：</b>您是一名学者，但也曾在大型系统上工作过，并在工业界做过一些工作。您如何看待学术计算机科学与工业实践之间的关系？</p><p class="normal"><b>Seibel:</b> You're an academic but also have worked on big systems and have done some work in industry. How do you see the relation between academic computer science and industrial practice?</p>
<p class="normal"><b>Knuth：</b>它一波接一波地消失了。在 20 世纪 60 年代，学术界远远领先于工业界，工业界制作的程序，也许除了航空公司预订系统，对大学里的每个人来说都是可笑的。</p><p class="normal"><b>Knuth:</b> It's gone in waves. In the '60s the academics were way ahead of the industry and the programs that were produced in industry, except for maybe airline-reservation systems, were laughable to everybody in universities.</p>
<p class="normal">到 1980 年，情况发生了很大的逆转，大学里的人写的程序被工业界的人嘲笑，因为大学已经进入神学模式，你不能使用<code>goto</code>陈述。我为了简化而夸大其词，但基本上大学课程中有一些禁忌让人们束手无策，工业界人士不必为此担心。</p><p class="normal">By 1980 the situation had pretty much reversed and the programs that were being written by people in universities were laughed at by the people in industry because the universities had gone into theological mode and you weren't allowed to use <code>goto</code> statements. I'm exaggerating to simplify, but basically there were no-nos in university programs that were keeping people's hands tied, and the people in industry didn't have to worry about that.</p>
<p class="normal">但后来在大学里，人们想出了一些关于联网和处理大量数据等更好的想法，并取得了成功。所以它来回走动。但是很多算法和数据结构社区的趋势并不是我喜欢的，因为他们有很多数据结构……<i>巴洛克式</i>是我唯一能想到的词。他们复杂而聪明，你不得不佩服他们的智力挑战，但我发现他们没有成果。他们不与生活联系；他们在另一个世界工作。这是一个不错的世界，它有自己的结构，他们是友好和善良的人，但它对我个人没有吸引力，也与实践无关。</p><p class="normal">But then in universities people came up with some better ideas about networking and dealing with large pieces of data and so on, and got ahead. So it goes back and forth. But the trend in a lot of the algorithm and data-structure community has not been to my liking when they have lots of data structures that are just … <i>baroque</i> is the only word I can think of. They're intricate and clever and you have to admire them for the intellectual challenge, but I find them sterile. They don't connect with life; they're working in another world. It's an OK world and it's got its structure, and they're friendly and nice people, but it doesn't appeal to me personally and it doesn't really relate to practice.</p>
<p class="normal"><a id="OEBPS/Chapter15.html.page_596"></a>我不知道为什么这对我来说是否与练习有关很重要。有些数学家从不考虑任何有限的东西，他们几乎从不考虑可数的无限——他们发表了很棒的论文，只是谈论各种令人难以置信的无穷，他们能够从中弄明白，这给了他们满足。在算法中也有类似的东西。但对我来说，我能在我的机器上使用的想法让我更加兴奋。</p><p class="normal"><a></a>I don't know why it's important to me if something relates to practice or not. There are mathematicians who never think about anything finite, and they hardly ever come down to countably infinite—they publish terrific papers just talking about kinds of infinity that are mind-boggling and they're able to make sense out of it and that gives them satisfaction. And there are similar things like that in algorithms. But for me I'm turned on much more by the ideas that I would be able to use in my machine.</p>
<p class="normal"><b>Seibel：</b> 1974 年你说到 1984 年我们将拥有“Utopia 84”，一种完美的编程语言，它将取代 COBOL 和 Fortran，你当时说有迹象表明这种语言正在慢慢形成。自 84 年以来已有几十年了，但似乎并没有发生这种情况。</p><p class="normal"><b>Seibel:</b> In 1974 you said that by 1984 we would have “Utopia 84,” the sort of perfect programming language, and it would supplant COBOL and Fortran, and you said then that there were indications that such language is very slowly taking shape. It's now a couple of decades since '84 and it doesn't seem like that's happened.</p>
<p class="normal"><b>克努特：没有</b>。</p><p class="normal"><b>Knuth:</b> No.</p>
<p class="normal"><b>Seibel：</b>那只是年轻的乐观主义吗？</p><p class="normal"><b>Seibel:</b> Was that just youthful optimism?</p>
<p class="normal"><b>Knuth：</b>当我写这篇文章时，我正在考虑 Simula 和面向对象编程的趋势。我认为每次出现一种新语言时，它都会清除对旧语言的理解，然后添加一些新的、实验性的等等，没有人会达到这样的地步，即他们有了一种新语言，然后他们想停在所理解的东西上。他们总是想更进一步。</p><p class="normal"><b>Knuth:</b> I was thinking about Simula and trends in object-oriented programming when I wrote that, clearly. I think what happens is that every time a new language comes out it cleans up what's understood about the old languages and then adds something new, experimental and so on, and nobody has ever come to the point where they have a new language and then they want to stop at what's understood. They're always wanting to push further.</p>
<p class="normal">也许有一天有人会说，“不，我不会创新；我只是要干净和简单，我会坚持下去。” Pascal 是从这种哲学开始的，但后来没有继续下去。也许我们会有一天有人会说，“让我们把眼光放低一点，真正尝试做一些稳定的东西。” 这可能是个好主意。</p><p class="normal">Maybe someday somebody will say, “No, I'm not going to be innovative; I'm just going to be clean and simple, and I'm going to stick to it.” Pascal was started with that philosophy but then didn't continue. Maybe we'll get to a time when somebody will say, “Let's set our sights lower and really try to make something that's going to be stable.” It might be a good idea.</p>
<p class="normal"><b>Seibel：</b>这不是问题的一部分，虽然有错误的特征，但也有缺失的特征，如果有什么缺失，你必须弥补一些东西来填补这个空白。</p><p class="normal"><b>Seibel:</b> Isn't part of the problem that while there are misfeatures, there are also missing features and if a thing is missing you've got to make up something to fill that gap.</p>
<p class="normal"><b>Knuth：</b>是的，没错。它必须以某种方式可扩展。Java 并没有以一种好的方式使自己具有可扩展性。</p><p class="normal"><b>Knuth:</b> Yeah, that's right. It's got to be extensible somehow. Java didn't make itself extensible in a good way.</p>
<p class="normal"><a id="OEBPS/Chapter15.html.page_597"></a><b>Seibel：</b>您自己设计了一些语言——可能使用最广泛的是 TeX。</p><p class="normal"><a></a><b>Seibel:</b> You've designed some languages yourself—probably the most widely used of which is TeX.</p>
<p class="normal"><b>Knuth：</b>所以 TeX 是一种编程语言，但我不得不投入那些踢腿和尖叫的功能。Guy Steele、Terry Winograd、Leslie Lamport 和其他人在使用 TeX 作为他们材料的前端时需要一些东西。我想 Terry Winograd 正在写一本关于自然语言语法的书，所以他想写一些非常强大的宏来制作他书中的图表。这极大地推动了 TeX 在早期成为一种编程语言。</p><p class="normal"><b>Knuth:</b> So TeX is a programming language but I had to put in those features kicking and screaming. Guy Steele, Terry Winograd, Leslie Lamport, and different people needed things when they were using TeX as a front end for their material. I think Terry Winograd was writing a book on the syntax of natural languages, so he had some really powerful macros that he wanted to write in order to make the diagrams in his book. That pushed TeX a lot towards becoming a programming language in the earliest days.</p>
<p class="normal"><b>Seibel：</b>作为一种语言，您是否曾经希望自己更多地关注语言的设计？</p><p class="normal"><b>Seibel:</b> Do you ever wish you had focused more on the design of the language, as a language?</p>
<p class="normal"><b>克纳特：</b>我不知道。大概吧。在某种程度上，我讨厌让每一种语言都通用，因为它们会以不同的方式通用。这有点像 Unix 在同一个屋檐下定义了 30 种正则表达式——根据您使用的 Unix 的哪个部分，您的正则表达式风格会略有不同。如果您拥有的每个工具都包含一个图灵机，那么这真的是可行的方法吗？我真的认为 TeX 是这样一种东西，它的编程越多，它完成排版的真正使命就越少。</p><p class="normal"><b>Knuth:</b> I don't know. I guess so. In a way I resent having every language be universal because they'll be universal in a different way. It's a little bit like Unix having 30 definitions of regular expressions under one roof— depending on which part of Unix you're using you've got a slightly different flavor of regular expressions. If every tool that you have includes a Turing machine inside, is this really the way to go? I was really thinking of TeX as something that the more programming it had in it, the less it was doing its real mission of typesetting.</p>
<p class="normal">当我将素数的计算写入 TeX 手册时，我并没有想到这是使用 TeX 的方式。我在想，“哦，顺便说一句，看看这个：狗可以用后腿站立，而 TeX 可以计算素数。”</p><p class="normal">When I put in the calculation of prime numbers into the TeX manual I was not thinking of this as the way to use TeX. I was thinking, “Oh, by the way, look at this: dogs can stand on their hind legs and TeX can calculate prime numbers.”</p>
<p class="normal"><b>Seibel：</b>但是人们利用它是一种图灵完备的编程语言这一事实​​来进行与排版相关的计算。如果它不是图灵完备的，他们将无法做那些事情。</p><p class="normal"><b>Seibel:</b> But people use the fact that it's a Turing-complete programming language to do typesetting-related computations. If it wasn't Turing-complete they would be unable to do those things.</p>
<p class="normal"><b>Knuth：</b>是的，没错。我在 60 年代写了一种用于模拟的编程语言，我不得不努力工作才能杀死它，因为它有很多用户，但是当 Simula 出现时，我更喜欢 Simula，我告诉人们停止使用我的 SOL 语言。大多数情况下，我不认为我在语言设计方面有很大的天赋。</p><p class="normal"><b>Knuth:</b> Yeah, that's right. I wrote a programming language for simulation in the '60s that I had to work hard to kill because it had a lot of users, but then when Simula came out I liked Simula better and I told people to stop using my SOL language. Mostly I don't consider that I have great talent for language design.</p>
<p class="normal"><a id="OEBPS/Chapter15.html.page_598"></a>通过 TeX，我正在与数百年的人类历史互动，我不想扔掉书籍设计师几个世纪以来学到的所有东西并重新开始说，“好吧，忘记那些家伙；你知道，我们现在要合乎逻辑了。” 在这种情况下，游戏的名称主要是解决一个极其复杂的问题，并找到一个相当小的原语集来支持它。我没有 1,000 个基元，而是 100 个基元或类似的东西。但是减少到 50 个基元，10 个基元——如果我们想在数学上保持干净我们会这样做——我相信是行不通的。做书的问题把世界的复杂化太多了，就是不想简单化。</p><p class="normal"><a></a>With TeX I was interacting with hundreds of years of human history and I didn't want to throw out all of the things that book designers have learned over centuries and start anew and say, “Well, forget that guys; you know, we're going to be logical now.” In this case, the name of the game was mostly to take an enormously complicated problem and find a fairly small set of primitives that would support it. Instead of having 1,000 primitives, I have 100 primitives or something like that. But going down to 50 primitives, 10 primitives—which we would do if we wanted to be mathematically clean—I believe wouldn't work. The problem of making books goes too much into the complexity of the world, which just doesn't want to be simplified.</p>
<p class="normal"><b>Seibel：</b>我还没有真正做过研究，但现在似乎绝大多数数学和科学论文都是用 TeX 排版的。一定有一些你在 TeX 中看到的排版让你觉得，“哇，我的程序在其中发挥了作用。”</p><p class="normal"><b>Seibel:</b> I haven't really done a study, but it seems like the vast majority of mathematical and scientific papers are typeset with TeX these days. There must have been things you've seen typeset in TeX that made you think, “Wow, my program played a part in this.”</p>
<p class="normal"><b>Knuth：</b>嗯，费马大定理的证明就是其中之一。这是最著名的数学论文之一。我经常看到那些我知道如果作者不得不像过去那样通过渠道就不会被写出来的书。这又是一些黑匣子的事情。</p><p class="normal"><b>Knuth:</b> Well, the proof of Fermat's Last Theorem was one of those. It's one of the most famous mathematical papers. And it happens all the time that I see books that I know wouldn't have been written if the authors had had to go through channels the way they used to. It's again a little bit of the black-box thing.</p>
<p class="normal">过去是，你必须输入一些东西，然后将其输入排字机，然后以样张校样的形式返回，等等。你会经历各种级别的非数学家，然后最终推出产品。所以你不敢做任何会使该行中的任何人感到困惑的事情。</p><p class="normal">It used to be, you would have to type something up and that would go into a compositor and it would come back in galley proofs, and so on. You're going through all kinds of levels of people who aren't mathematicians and then coming out with the product at the end. So you don't dare do anything that would confuse any of the people in that line.</p>
<p class="normal">但是如果你自己能看到它会是什么样子，并且你能编出一个不在别人的样式表中的符号，因为它恰好是解决你的问题的正确符号，那么你会被鼓励做更多的事情更好的工作。</p><p class="normal">But if you can see yourself what it's going to look like, and you can make up a notation that isn't in somebody's style sheet because it just happens to be the right one for your problem, then you're encouraged to do a much better job.</p>
<p class="normal">因此，当我知道人们能够突破这一点并将他们的创造力直接传递给读者时，这一直给我带来极大的满足感。</p><p class="normal">So this brings me great satisfaction all the time when I know that people have been able to cut through this and their creativity goes directly to the reader.</p>
<p class="normal"><a id="OEBPS/Chapter15.html.page_599"></a><b>Seibel：</b>你觉得程序员和计算机科学家是否足够了解我们领域的历史？毕竟，这是一段相当短的历史。</p><p class="normal"><a></a><b>Seibel:</b> Do you feel like programmers and computer scientists are aware enough of the history of our field? It is, after all, a pretty short history.</p>
<p class="normal"><b>Knuth：</b>学者并不多。即使在我 1963 年开始写书的时候，我也不认为人们知道 1959 年发生了什么。上周我在<i>美国科学家</i>杂志上读到有人重新发现了博耶和摩尔在 1980 年发现的算法。它发生了人们没有意识到我们拥有的光荣历史的时间。70 年代人们知道一两件事的想法对很多年轻的程序员来说很奇怪。</p><p class="normal"><b>Knuth:</b> There aren't too many that are scholars. Even when I started writing my books in 1963, I didn't think people knew what had happened in 1959. I was reading in <i>American Scientist</i> last week about people who had rediscovered an algorithm that Boyer and Moore had discovered in 1980. It happens all the time that people don't realize the glorious history that we have. The idea that people knew a thing or two in the '70s is strange to a lot of young programmers.</p>
<p class="normal">在如此复杂的领域中，人们不可避免地会遗漏一些东西。希望像维基百科这样的东西，成就不会像以前那样被遗忘。但我希望我也能向更多人灌输我对阅读原始资料的热爱。不仅要知道某某某事因做某事而受到赞扬，还要回头看看那个人用他自己的话说了什么。我认为这是提高自己技能的绝佳方式。</p><p class="normal">It's inevitable that in such a complicated field that people will be missing stuff. Hopefully with things like Wikipedia, achievements don't get forgotten the way they were before. But I wish I could also instill in more people the love that I have for reading original sources. Not just knowing that so-and-so gets credit for doing something, but looking back and seeing what that person said in his own words. I think it's a tremendous way to improve your own skills.</p>
<p class="normal">能够深入了解别人的思维方式，破译他们的词汇，他们的符号是非常重要的。如果你能了解他们的思维方式和发现的方式，那么这有助于你做出自己的发现。我经常阅读过去杰出人士对这些东西的评价的原始资料。今天的约定会以不同寻常的方式表达它，但我值得深入了解他们的符号并尝试进入他们的想法。</p><p class="normal">It's very important to be able to get inside of somebody else's way of thinking, to decode their vocabulary, their notation. If you can understand something about the way they thought and the way they made a discovery, then that helps you make your own discoveries. I often read source materials of what brilliant people have said about this stuff in the past. It'll be expressed in unusual ways by today's conventions, but it's worth it to me to penetrate their notation and to try to get into their idea.</p>
<p class="normal">例如，我花了很多时间试图查看 4000 年前他们如何描述算法的巴比伦手稿，他们是怎么想的？他们有 while 循环和类似的东西吗？他们会如何描述它？对我来说，这对于了解大脑如何工作以及他们如何发现事物非常有价值。</p><p class="normal">For example I spent a good deal of time trying to look at Babylonian manuscripts of how they described algorithms 4,000 years ago, and what did they think about? Did they have while loops and stuff like this? How would they describe it? And to me this was very worthwhile for understanding about how the brain works, but also about how they discovered things.</p>
<p class="normal">几年前，我发现了一份 13 世纪的关于组合数学的古老梵文文献。几乎没有作者认识的人对他在说什么一头雾水。但我找到了这份文件的翻译，它在对我说话。当我开始从事计算机编程时，我也有过类似的想法。</p><p class="normal">A couple of years ago I found an old Sanskrit document from the 13th century that was about combinatorial math. Almost nobody the author knew would have had the foggiest idea what he was talking about. But I found a translation of this document and it was speaking to me. I had done similar kinds of thinking when I was beginning in computer programming.</p>
<p class="normal"><a id="OEBPS/Chapter15.html.page_600"></a>所以对我来说，阅读原始资料对我自己的生活和创造力来说是一种极大的丰富。</p><p class="normal"><a></a>And so to me reading source materials is great enrichment for my own life and creativity.</p>
<p class="normal">我无法将其传递给我的任何学生。现在在计算机科学领域有一些人在这方面做得很好——为数不多。但是我可以指望像我一样热爱原始资料的人。</p><p class="normal">I was unable to pass that on to any of my students. There are people alive now in computer science who are doing this well—a few. But I could count on the fingers of one hand the people who love source materials the way I do.</p>
<p class="normal">我收集了很多源代码。我有编译器，1960 年代的 Digitek 编译器是以一种非常有趣的方式编写的。他们有自己的语言，他们使用 30 个字符长但非常具有描述性的标识符，他们的编译器在当时绕着竞争对手跑了一圈——这家公司制造了 1963 年或 64 年最先进的编译器。</p><p class="normal">I've got lots of collections of source code. I have compilers, the Digitek compilers from the 1960s were written in a very interesting way. They had their own language and they used identifiers that were 30 characters long but very descriptive, and their compilers ran circles around the competition at the time—this company made the state-of-the-art compilers of 1963 or '64.</p>
<p class="normal">而且我有 THE 操作系统的 Dijkstra 源代码。我没读过。到目前为止我只是略读了一下，但我收集了它，因为我确信如果我有时间阅读它会很有趣。</p><p class="normal">And I've got Dijkstra's source code for the THE operating system. I haven't read that. I've just skimmed it so far but I collected it because I'm sure it would be interesting to read if I had time.</p>
<p class="normal">有一次我摔断了胳膊——从自行车上摔下来了——有一个月我什么都做不了，所以我读了源代码，听说其中有一些聪明的想法，但没有被记录下来。我认为这些对我来说都是极其重要的经历。</p><p class="normal">One time I broke my arm—fell off a bike—and I had a month where I couldn't do anything much, so I read source code that I had heard had some clever ideas in it that hadn't been documented. I think those were all extremely important experiences for me.</p>
<p class="normal"><b>Seibel：</b>您如何解决阅读源代码的问题？即使是用你已经知道的编程语言阅读一些东西也是一个棘手的问题。</p><p class="normal"><b>Seibel:</b> How do you tackle reading source code? Even reading something in a programming language you already know is a tricky problem.</p>
<p class="normal"><b>Knuth：</b>但它在您的大脑中构建的内容确实值得。那我该怎么做呢？有一台叫做 Bunker Ramo 300 的机器，有人告诉我这台机器的 Fortran 编译器真的快得惊人，但没人知道它为什么能工作。我得到了它的源代码清单的副本。我没有这台机器的手册，所以我什至不确定机器语言是什么。</p><p class="normal"><b>Knuth:</b> But it's really worth it for what it builds in your brain. So how do I do it? There was a machine called the Bunker Ramo 300 and somebody told me that the Fortran compiler for this machine was really amazingly fast, but nobody had any idea why it worked. I got a copy of the source-code listing for it. I didn't have a manual for the machine, so I wasn't even sure what the machine language was.</p>
<p class="normal">但我把它当作一个有趣的挑战。我可以弄清楚<code>BEGIN</code>然后我会开始解码。操作代码有一些两个字母的助记符，所以我可以开始弄清楚“这可能是一个加载指令，这可能是一个分支。” 我知道这是一个 Fortran<a id="OEBPS/Chapter15.html.page_601"></a>编译器，所以在某些时候它会查看卡片的第七列，这就是它会判断它是否是评论的地方。</p><p class="normal">But I took it as an interesting challenge. I could figure out <code>BEGIN</code> and then I would start to decode. The operation codes had some two-letter mnemonics and so I could start to figure out “This probably was a load instruction, this probably was a branch.” And I knew it was a Fortran <a></a>compiler, so at some point it looked at column seven of a card, and that was where it would tell if it was a comment or not.</p>
<p class="normal">三个小时后，我对这台机器有了一些了解。然后我发现了这些大的分支表。所以这是一个难题，我一直只是制作小图表，就像我在一家安全机构工作，试图破译密码一样。但我知道它是有效的，而且我知道它是一个 Fortran 编译器——它并没有被加密，因为它是有意隐藏的；它只是在代码中，因为我没有得到机器的手册。</p><p class="normal">After three hours I had figured out a little bit about the machine. Then I found these big, branching tables. So it was a puzzle and I kept just making little charts like I'm working at a security agency trying to decode a secret code. But I knew it worked and I knew it was a Fortran compiler—it wasn't encrypted in the sense that it was intentionally obscure; it was only in code because I hadn't gotten the manual for the machine.</p>
<p class="normal">最终我能够弄清楚为什么这个编译器如此之快。不幸的是，这不是因为算法很棒；而是因为算法很棒。这只是因为他们使用了非结构化编程并手动优化了代码。</p><p class="normal">Eventually I was able to figure out why this compiler was so fast. Unfortunately it wasn't because the algorithms were brilliant; it was just because they had used unstructured programming and hand optimized the code to the hilt.</p>
<p class="normal">这基本上就是解决某种未知难题的方法——制作表格和图表，在这里获取更多信息并做出假设。一般来说，当我阅读一篇技术论文时，它是同样的挑战。我试图进入作者的思想，试图弄清楚这个概念是什么。在我看来，你越是学会阅读别人的东西，你就越有能力在未来发明自己的东西。</p><p class="normal">It was just basically the way you solve some kind of an unknown puzzle—make tables and charts and get a little more information here and make a hypothesis. In general when I'm reading a technical paper, it's the same challenge. I'm trying to get into the author's mind, trying to figure out what the concept is. The more you learn to read other people's stuff, the more able you are to invent your own in the future, it seems to me.</p>
<p class="normal">我们应该发布代码。狮子书可用。多亏了 Apple，Bill Atkinson 的程序现在可以公开访问了，用不了多久我们就能读到它。这是有据可查的代码，其中包含许多开创性的图形算法。</p><p class="normal">We ought to publish code. The Lions Book is available. And Bill Atkinson's programs are now publicly available thanks to Apple, and it won't be too long before we'll be able to read that. That's well-documented code with lots of pioneering graphics algorithms in it.</p>
<p class="normal"><b>Seibel：</b>当然，对于开源来说，有比过去更多的代码可供阅读。</p><p class="normal"><b>Seibel:</b> Certainly with open source there's a lot more code out there to read than there used to be.</p>
<p class="normal"><b>Knuth：</b>是的，没错。但是更多不同类型的符号仍然有用——不要只阅读像你这样编码的人。</p><p class="normal"><b>Knuth:</b> Yeah, that's right. But the more varieties of different kinds of notations are still useful—don't only read the people who code like you.</p>
</div>
</div></div>
<div id="OEBPS/Appendix.html"><div>

<div class="booksection">
<p></p>
<h2 class="chapnum"><a id="OEBPS/Appendix.html.appa"></a><a id="OEBPS/Appendix.html.page_603"></a><img src="data:image/jpg;base64,/9j/4AAQSkZJRgABAgEASABIAAD/7QysUGhvdG9zaG9wIDMuMAA4QklNA+0KUmVzb2x1dGlvbgAAAAAQAEgAAAABAAEASAAAAAEAAThCSU0EDRhGWCBHbG9iYWwgTGlnaHRpbmcgQW5nbGUAAAAABAAAAHg4QklNBBkSRlggR2xvYmFsIEFsdGl0dWRlAAAAAAQAAAAeOEJJTQPzC1ByaW50IEZsYWdzAAAACQAAAAAAAAAAAQA4QklNBAoOQ29weXJpZ2h0IEZsYWcAAAAAAQAAOEJJTScQFEphcGFuZXNlIFByaW50IEZsYWdzAAAAAAoAAQAAAAAAAAACOEJJTQP1F0NvbG9yIEhhbGZ0b25lIFNldHRpbmdzAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+BdDb2xvciBUcmFuc2ZlciBTZXR0aW5ncwAAAHAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAOEJJTQQAC0xheWVyIFN0YXRlAAAAAgABOEJJTQQCDExheWVyIEdyb3VwcwAAAAAEAAAAADhCSU0ECAZHdWlkZXMAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4NVVJMIG92ZXJyaWRlcwAAAAQAAAAAOEJJTQQaBlNsaWNlcwAAAAB1AAAABgAAAAAAAAAAAAAArwAAAPgAAAAKAFUAbgB0AGkAdABsAGUAZAAtADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAPgAAACvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhCSU0EERFJQ0MgVW50YWdnZWQgRmxhZwAAAAEBADhCSU0EFBdMYXllciBJRCBHZW5lcmF0b3IgQmFzZQAAAAQAAAACOEJJTQQMFU5ldyBXaW5kb3dzIFRodW1ibmFpbAAACNAAAAABAAAAcAAAAE8AAAFQAABnsAAACLQAGAAB/9j/4AAQSkZJRgABAgEASABI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" alt="图片"></h2><h2 class="chapnum"><a></a><a></a></h2>
<h2 class="chaptitle">参考书目</h2><h2 class="chaptitle">Bibliography</h2>
<p class="hangingindent"><i>计算机编程的艺术</i>，Donald Knuth（Addison-Wesley，1997 年）</p><p class="hangingindent"><i>The Art of Computer Programming</i>, Donald Knuth (Addison-Wesley, 1997)</p>
<p class="hangingindent"><i>Beautiful Code: Leading Programmers Explain How They Think</i>，Andy Oram，Greg Wilson（编）（O'Reilly，2007 年）</p><p class="hangingindent"><i>Beautiful Code: Leading Programmers Explain How They Think</i>, Andy Oram, Greg Wilson (eds.) (O'Reilly, 2007)</p>
<p class="hangingindent"><i>字节</i>，卷。6，第 8 期，“Smalltalk 问题”，1981 年 8 月</p><p class="hangingindent"><i>Byte</i>, Vol. 6, No. 8, “Smalltalk issue,” August 1981</p>
<p class="hangingindent"><i>代码完成</i>，Steve McConnell（微软出版社，1993 年）</p><p class="hangingindent"><i>Code Complete</i>, Steve McConnell (Microsoft Press, 1993)</p>
<p class="hangingindent"><i>Compiling with Continuations</i>，Andrew W. Appel（剑桥大学出版社，1992 年）</p><p class="hangingindent"><i>Compiling with Continuations</i>, Andrew W. Appel (Cambridge University Press, 1992)</p>
<p class="hangingindent"><i>计算机算法的设计与分析</i>，Alfred V. Aho、John E. Hopcroft 和 Jeffrey D. Ullman（Addison-Wesley，1974 年）</p><p class="hangingindent"><i>The Design and Analysis of Computer Algorithms</i>, Alfred V. Aho, John E. Hopcroft, and Jeffrey D. Ullman (Addison-Wesley, 1974)</p>
<p class="hangingindent"><i>设计模式：可重用面向对象软件的要素</i>，Eric Gamma、Richard Helf、Ralph Johnson 和 John M. Vlissides（Addison-Wesley Professional，1994 年）</p><p class="hangingindent"><i>Design Patterns: Elements of Reusable Object-Oriented Software</i>, Eric Gamma, Richard Helf, Ralph Johnson, and John M. Vlissides (Addison-Wesley Professional, 1994)</p>
<p class="hangingindent"><i>编程学科</i>，Edsger W. Dijkstra（Prentice Hall, Inc.，1976 年）</p><p class="hangingindent"><i>A Discipline of Programming</i>, Edsger W. Dijkstra (Prentice Hall, Inc., 1976)</p>
<p class="hangingindent"><i>Effective Java</i>，Joshua Bloch（Prentice Hall，2008 年）</p><p class="hangingindent"><i>Effective Java</i>, Joshua Bloch (Prentice Hall, 2008)</p>
<p class="hangingindent"><i>编程风格的要素</i>，Brian Kernighan 和 PJ Plauger（Computing McGraw-Hill，1978 年）</p><p class="hangingindent"><i>The Elements of Programming Style</i>, Brian Kernighan and P.J. Plauger (Computing McGraw-Hill, 1978)</p>
<p class="hangingindent"><i>风格元素</i>，William Strunk 和 EB White（朗文出版社，1999 年）</p><p class="hangingindent"><i>Elements of Style</i>, William Strunk and E.B. White (Longman, 1999)</p>
<p class="hangingindent"><a id="OEBPS/Appendix.html.page_604"></a><i>专家 C 编程</i>，Peter van der Linden（Prentice Hall PTR，1994 年）</p><p class="hangingindent"><a></a><i>Expert C Programming</i>, Peter van der Linden (Prentice Hall PTR, 1994)</p>
<p class="hangingindent"><i>工作中的创始人</i>，杰西卡利文斯顿（Apress，2007）</p><p class="hangingindent"><i>Founders at Work</i>, Jessica Livingston (Apress, 2007)</p>
<p class="hangingindent"><i>黑客的喜悦</i>，Henry S. Warren（Addison-Wesley，2002 年）</p><p class="hangingindent"><i>Hacker's Delight</i>, Henry S. Warren (Addison-Wesley, 2002)</p>
<p class="hangingindent"><i>高阶 Perl</i>，Mark Jason Dominus（Morgan Kaufmann，2005 年）</p><p class="hangingindent"><i>Higher-Order Perl</i>, Mark Jason Dominus (Morgan Kaufmann, 2005)</p>
<p class="hangingindent"><i>Java 并发实践</i>，Brian Goetz、Tim Peierls、Joshua Bloch、Joseph Bowbeer、David Holmes 和 Doug Lea（Addison-Wesley，2006 年）</p><p class="hangingindent"><i>Java Concurrency in Practice</i>, Brian Goetz, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, and Doug Lea (Addison-Wesley, 2006)</p>
<p class="hangingindent"><i>Java 谜题：陷阱、陷阱和极端案例</i>，Joshua Bloch 和 Neil Gafter（Addison-Wesley，2005 年）</p><p class="hangingindent"><i>Java Puzzlers: Traps, Pitfalls, and Corner Cases</i>, Joshua Bloch and Neil Gafter (Addison-Wesley, 2005)</p>
<p class="hangingindent"><i>Lisp 1.5 程序员手册</i>，John McCarthy（麻省理工学院出版社，1962 年）</p><p class="hangingindent"><i>The Lisp 1.5 Programmer's Manual</i>, John McCarthy (MIT Press, 1962)</p>
<p class="hangingindent"><i>文学编程</i>，Donald Knuth（语言和信息研究中心，1992 年）</p><p class="hangingindent"><i>Literate Programming</i>, Donald Knuth (Center for the Study of Language and Information, 1992)</p>
<p class="hangingindent"><i>机器智能 1</i>，NL Collins 和 Donald Michie（编辑）（Oliver 和 Boyd，1967 年）</p><p class="hangingindent"><i>Machine Intelligence 1</i>, N.L. Collins and Donald Michie (eds.) (Oliver and Boyd, 1967)</p>
<p class="hangingindent"><i>机器智能 2</i>，Ella Dale 和 Donald Michie（编）（Oliver 和 Boyd，1968 年）</p><p class="hangingindent"><i>Machine Intelligence 2</i>, Ella Dale and Donald Michie (eds.) (Oliver and Boyd, 1968)</p>
<p class="hangingindent"><i>机器智能 3</i>，Donald Michie（编）（爱丁堡大学出版社，1968 年）</p><p class="hangingindent"><i>Machine Intelligence 3</i>, Donald Michie (ed.) (Edinburgh University Press, 1968)</p>
<p class="hangingindent"><i>机器智能 4</i>，Bernard Meltzer 和 Donald Michie（编）（爱丁堡大学出版社，1969 年）</p><p class="hangingindent"><i>Machine Intelligence 4</i>, Bernard Meltzer and Donald Michie (eds.) (Edinburgh University Press, 1969)</p>
<p class="hangingindent"><i>魔法数字屋</i>，欧文·阿德勒 (HarperCollins, 1974)</p><p class="hangingindent"><i>Magic House of Numbers</i>, Irving Adler (HarperCollins, 1974)</p>
<p class="hangingindent">“META II 一种面向语法的编译器编写语言”，DV Schorre 在<i>1964 年第 19 届 ACM 全国会议论文</i>集中，（ACM，1964 年）</p><p class="hangingindent">“META II a Syntax-Oriented Compiler Writing Language,” D.V. Schorre in <i>Proceedings of the 1964 19th ACM national conference</i>, (ACM, 1964)</p>
<p class="hangingindent"><i>头脑风暴：儿童、计算机和强大的想法</i>，Seymour A. Papert（基础书籍，1993 年）</p><p class="hangingindent"><i>Mindstorms: Children, Computers, and Powerful Ideas</i>, Seymour A. Papert (Basic Books, 1993)</p>
<p class="hangingindent"><i>人月神话：软件工程论文集</i>，Frederick P. Brooks（Addison-Wesley Professional，1995 年）</p><p class="hangingindent"><i>The Mythical Man-Month: Essays on Software Engineering</i>, Frederick P. Brooks (Addison-Wesley Professional, 1995)</p>
<p class="hangingindent"><i>编译器设计原理</i>，Alfred Aho 和 Jeffrey Ullman（Addison-Wesley，1977 年）</p><p class="hangingindent"><i>Principles of Compiler Design</i>, Alfred Aho and Jeffrey Ullman (Addison-Wesley, 1977)</p>
<p class="hangingindent">“程序证明：FIND”，CAR Hoare 在<i>ACM 的通讯中，</i>第 1卷。14，第 1 期（ACM，1971 年）</p><p class="hangingindent">“Proof of a Program: FIND”, C.A.R. Hoare in <i>Communications of the ACM,</i> Vol. 14, Issue 1 (ACM, 1971)</p>
<p class="hangingindent"><a id="OEBPS/Appendix.html.page_605"></a><i>编程珍珠</i>，Jon Bentley（ACM 出版社，1999 年）</p><p class="hangingindent"><a></a><i>Programming Pearls</i>, Jon Bentley (ACM Press, 1999)</p>
<p class="hangingindent"><i>纯功能数据结构</i>，Chris Okasaki（剑桥大学出版社，2008 年）</p><p class="hangingindent"><i>Purely Functional Data Structures</i>, Chris Okasaki (Cambridge University Press, 2008)</p>
<p class="hangingindent"><i>可重定向的 C 编译器：设计和实现</i>，David Hanson 和 Christopher Fraser（Addison-Wesley Professional，1995 年）</p><p class="hangingindent"><i>A Retargetable C Compiler: Design and Implementation</i>, David Hanson and Christopher Fraser (Addison-Wesley Professional, 1995)</p>
<p class="hangingindent"><i>Smalltalk-80：交互式编程环境</i>，Adele Goldberg（Addison-Wesley，1983 年）</p><p class="hangingindent"><i>Smalltalk-80: The Interactive Programming Environment</i>, Adele Goldberg (Addison-Wesley, 1983)</p>
<p class="hangingindent"><i>Smalltalk-80：语言及其实现</i>，David Robson 和 Adele Goldberg（Addison-Wesley，1983 年）</p><p class="hangingindent"><i>Smalltalk-80: The Language &amp; Its Implementation</i>, David Robson and Adele Goldberg (Addison-Wesley, 1983)</p>
<p class="hangingindent"><i>计算机程序的结构和解释</i>，Harold Abelson 和 Gerald Jay Sussman（麻省理工学院出版社，1996 年）</p><p class="hangingindent"><i>Structure and Interpretation of Computer Programs</i>, Harold Abelson and Gerald Jay Sussman (MIT Press, 1996)</p>
<p class="hangingindent"><i>TeX：程序</i>，Donald Knuth（Addison-Wesley，1986 年）</p><p class="hangingindent"><i>TeX: The Program</i>, Donald Knuth (Addison-Wesley, 1986)</p>
<p class="hangingindent"><i>编程语言 LISP：它的操作和应用程序</i>，Edmund Berkeley 和 Daniel Bobrow，编辑。（麻省理工学院出版社，1966 年）</p><p class="hangingindent"><i>The Programming Language LISP: Its Operation and Applications</i>, Edmund Berkeley and Daniel Bobrow, eds. (MIT Press, 1966)</p>
<p class="hangingindent"><i>计算机程序设计心理学：二十周年纪念版</i>，Gerald Weinberg（多塞特学院，1998 年）</p><p class="hangingindent"><i>The Psychology of Computer Programming: Silver Anniversary Edition</i>, Gerald Weinberg (Dorset House, 1998)</p>
<p class="hangingindent"><i>TeXbook</i>，Donald Knuth（Addison-Wesley Professional，1986 年）</p><p class="hangingindent"><i>The TeXbook</i>, Donald Knuth (Addison-Wesley Professional, 1986)</p>
<p class="hangingindent"><i>工作中的作家：巴黎评论访谈</i>，马尔科姆·考利（企鹅出版社，1977 年）</p><p class="hangingindent"><i>Writers at Work: The Paris Review Interviews</i>, Malcolm Cowley (Penguin, 1977)</p>
<p class="hangingindent"><i>禅与摩托车维修艺术：对价值观的探究</i>，罗伯特·波西格 (Robert Pirsig)（矮脚鸡，1984 年）</p><p class="hangingindent"><i>Zen and the Art of Motorcycle Maintenance: An Inquiry into Values</i>, Robert Pirsig (Bantam, 1984)</p>
</div>
</div></div>
<div id="OEBPS/Index.html"><div>

<div class="booksection">
<p></p>
<h2 class="chapnum"><img src="data:image/jpg;base64,/9j/4AAQSkZJRgABAgEASABIAAD/7QoyUGhvdG9zaG9wIDMuMAA4QklNA+0KUmVzb2x1dGlvbgAAAAAQAEgAAAABAAEASAAAAAEAAThCSU0EDRhGWCBHbG9iYWwgTGlnaHRpbmcgQW5nbGUAAAAABAAAAHg4QklNBBkSRlggR2xvYmFsIEFsdGl0dWRlAAAAAAQAAAAeOEJJTQPzC1ByaW50IEZsYWdzAAAACQAAAAAAAAAAAQA4QklNBAoOQ29weXJpZ2h0IEZsYWcAAAAAAQAAOEJJTScQFEphcGFuZXNlIFByaW50IEZsYWdzAAAAAAoAAQAAAAAAAAACOEJJTQP1F0NvbG9yIEhhbGZ0b25lIFNldHRpbmdzAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+BdDb2xvciBUcmFuc2ZlciBTZXR0aW5ncwAAAHAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAOEJJTQQAC0xheWVyIFN0YXRlAAAAAgABOEJJTQQCDExheWVyIEdyb3VwcwAAAAAEAAAAADhCSU0ECAZHdWlkZXMAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4NVVJMIG92ZXJyaWRlcwAAAAQAAAAAOEJJTQQaBlNsaWNlcwAAAAB1AAAABgAAAAAAAAAAAAAAogAAAPYAAAAKAFUAbgB0AGkAdABsAGUAZAAtADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAPYAAACiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhCSU0EERFJQ0MgVW50YWdnZWQgRmxhZwAAAAEBADhCSU0EFBdMYXllciBJRCBHZW5lcmF0b3IgQmFzZQAAAAQAAAACOEJJTQQMFU5ldyBXaW5kb3dzIFRodW1ibmFpbAAABlUAAAABAAAAcAAAAEoAAAFQAABhIAAABjkAGAAB/9j/4AAQSkZJRgABAgEASABI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" alt="图片"></h2>
<h2 class="chaptitle">指数</h2><h2 class="chaptitle">Index</h2>
<h3 class="h3">一种</h3><h3 class="h3">A</h3>
<p class="index">抽象, <a href="#OEBPS/Chapter01.html.page_22">22</a> , <a href="#OEBPS/Chapter01.html.page_29">29</a></p><p class="index">abstraction, <a href="#OEBPS/Chapter01.html.page_22">22</a>, <a href="#OEBPS/Chapter01.html.page_29">29</a></p>
<p class="index"><b><i>ACS-1 超级计算机</i></b>,<a href="#OEBPS/Chapter13.html.page_485"> 485</a></p><p class="index"><b><i>ACS-1 supercomputer</i></b>, <a href="#OEBPS/Chapter13.html.page_485">485</a></p>
<p class="index"><b>动作脚本</b>, <a href="#OEBPS/Chapter04.html.page_143">143</a></p><p class="index"><b>ActionScript</b>, <a href="#OEBPS/Chapter04.html.page_143">143</a></p>
<p class="index"><b>艾达</b>, <a href="#OEBPS/Chapter09.html.page_349">349</a></p><p class="index"><b>Ada</b>, <a href="#OEBPS/Chapter09.html.page_349">349</a></p>
<p class="index"><b>广告安全</b>, <a href="#OEBPS/Chapter03.html.page_99">99</a></p><p class="index"><b>ADsafe</b>, <a href="#OEBPS/Chapter03.html.page_99">99</a></p>
<p class="index"><b><i>冒险</i></b>,<a href="#OEBPS/Chapter15.html.page_576"> 576</a> ,<a href="#OEBPS/Chapter15.html.page_577"> 577</a></p><p class="index"><b><i>Adventure</i></b>, <a href="#OEBPS/Chapter15.html.page_576">576</a>, <a href="#OEBPS/Chapter15.html.page_577">577</a></p>
<p class="index"><b>美学</b>, <a href="#OEBPS/Chapter01.html.page_26">26</a> , <a href="#OEBPS/Chapter06.html.page_234">234</a> , <a href="#OEBPS/Chapter06.html.page_235">235</a> , <a href="#OEBPS/Chapter07.html.page_283">283</a> , <a href="#OEBPS/Chapter07.html.page_284">284</a> , <a href="#OEBPS/Chapter07.html.page_285">285</a> , <a href="#OEBPS/Chapter09.html.page_369">369</a> , <a href="#OEBPS/Chapter09.html.page_371">371</a> , <a href="#OEBPS/Chapter09.html.page_372">372</a> , <a href="#OEBPS/Chapter13.html.page_488">488</a> , <a href="#OEBPS/Chapter14.html.page_555">555</a></p><p class="index"><b>aesthetics</b>, <a href="#OEBPS/Chapter01.html.page_26">26</a>, <a href="#OEBPS/Chapter06.html.page_234">234</a>, <a href="#OEBPS/Chapter06.html.page_235">235</a>, <a href="#OEBPS/Chapter07.html.page_283">283</a>, <a href="#OEBPS/Chapter07.html.page_284">284</a>, <a href="#OEBPS/Chapter07.html.page_285">285</a>, <a href="#OEBPS/Chapter09.html.page_369">369</a>, <a href="#OEBPS/Chapter09.html.page_371">371</a>, <a href="#OEBPS/Chapter09.html.page_372">372</a>, <a href="#OEBPS/Chapter13.html.page_488">488</a>, <a href="#OEBPS/Chapter14.html.page_555">555</a></p>
<p class="index"><b>阿戈里克斯</b>, <a href="#OEBPS/Chapter03.html.page_95">95</a></p><p class="index"><b>Agorics</b>, <a href="#OEBPS/Chapter03.html.page_95">95</a></p>
<p class="index"><b>AI</b> , <a href="#OEBPS/Chapter01.html.page_3">3</a> , <a href="#OEBPS/Chapter06.html.page_206">206</a> , <a href="#OEBPS/Chapter08.html.page_300">300</a> , <a href="#OEBPS/Chapter08.html.page_301">301</a></p><p class="index"><b>AI</b>, <a href="#OEBPS/Chapter01.html.page_3">3</a>, <a href="#OEBPS/Chapter06.html.page_206">206</a>, <a href="#OEBPS/Chapter08.html.page_300">300</a>, <a href="#OEBPS/Chapter08.html.page_301">301</a></p>
<p class="index"><b><i>阿贾克斯</i></b>,<a href="#OEBPS/Chapter03.html.page_91"> 91</a> ,<a href="#OEBPS/Chapter03.html.page_97"> 97</a> ,<a href="#OEBPS/Chapter03.html.page_101"> 101</a> ,<a href="#OEBPS/Chapter03.html.page_102"> 102</a> ,<a href="#OEBPS/Chapter03.html.page_111"> 111</a> ,<a href="#OEBPS/Chapter03.html.page_125"> 125</a> ,<a href="#OEBPS/Chapter04.html.page_142"> 142</a> ,<a href="#OEBPS/Chapter04.html.page_158"> 158</a></p><p class="index"><b><i>Ajax</i></b>, <a href="#OEBPS/Chapter03.html.page_91">91</a>, <a href="#OEBPS/Chapter03.html.page_97">97</a>, <a href="#OEBPS/Chapter03.html.page_101">101</a>, <a href="#OEBPS/Chapter03.html.page_102">102</a>, <a href="#OEBPS/Chapter03.html.page_111">111</a>, <a href="#OEBPS/Chapter03.html.page_125">125</a>, <a href="#OEBPS/Chapter04.html.page_142">142</a>, <a href="#OEBPS/Chapter04.html.page_158">158</a></p>
<p class="index"><b>大陵五</b>, <a href="#OEBPS/Chapter07.html.page_243">243</a> , <a href="#OEBPS/Chapter07.html.page_248">248</a></p><p class="index"><b>Algol</b>, <a href="#OEBPS/Chapter07.html.page_243">243</a>, <a href="#OEBPS/Chapter07.html.page_248">248</a></p>
<p class="index"><b>艾伦，弗兰</b>，<a href="#OEBPS/Chapter14.html.page_560">560</a></p><p class="index"><b>Allen, Fran</b>, <a href="#OEBPS/Chapter14.html.page_560">560</a></p>
<p class="index"><b>牵牛星</b>，<a href="#OEBPS/Chapter07.html.page_245">245</a></p><p class="index"><b>Altair</b>, <a href="#OEBPS/Chapter07.html.page_245">245</a></p>
<p class="index"><b>安德森</b>，<b>马克</b>，<a href="#OEBPS/Chapter01.html.page_14">14</a>岁，<a href="#OEBPS/Chapter01.html.page_18">18 岁</a>，<a href="#OEBPS/Chapter01.html.page_19">19 岁</a></p><p class="index"><b>Andreessen</b>, <b>Marc</b>, <a href="#OEBPS/Chapter01.html.page_14">14</a>, <a href="#OEBPS/Chapter01.html.page_18">18</a>, <a href="#OEBPS/Chapter01.html.page_19">19</a></p>
<p class="index"><b>机器人</b>, <a href="#OEBPS/Chapter02.html.page_71">71</a></p><p class="index"><b>Android</b>, <a href="#OEBPS/Chapter02.html.page_71">71</a></p>
<p class="index"><b>美国标准 C</b> , <a href="#OEBPS/Chapter11.html.page_420">420</a></p><p class="index"><b>ANSI C</b>, <a href="#OEBPS/Chapter11.html.page_420">420</a></p>
<p class="index"><b>美国在线</b>, <a href="#OEBPS/Chapter02.html.page_53">53</a></p><p class="index"><b>AOL</b>, <a href="#OEBPS/Chapter02.html.page_53">53</a></p>
<p class="index"><b>阿帕奇</b>, <a href="#OEBPS/Chapter02.html.page_58">58</a> , <a href="#OEBPS/Chapter02.html.page_61">61</a></p><p class="index"><b>Apache</b>, <a href="#OEBPS/Chapter02.html.page_58">58</a>, <a href="#OEBPS/Chapter02.html.page_61">61</a></p>
<p class="index">APL, <a href="#OEBPS/Chapter01.html.page_2">2</a> , <a href="#OEBPS/Chapter03.html.page_93">93</a> , <a href="#OEBPS/Chapter09.html.page_325">325</a> , <a href="#OEBPS/Chapter09.html.page_327">327</a> , <a href="#OEBPS/Chapter09.html.page_328">328</a> , <a href="#OEBPS/Chapter09.html.page_340">340</a> , <a href="#OEBPS/Chapter09.html.page_344">344</a> , <a href="#OEBPS/Chapter09.html.page_352">352</a> , <a href="#OEBPS/Chapter09.html.page_353">353</a></p><p class="index">APL, <a href="#OEBPS/Chapter01.html.page_2">2</a>, <a href="#OEBPS/Chapter03.html.page_93">93</a>, <a href="#OEBPS/Chapter09.html.page_325">325</a>, <a href="#OEBPS/Chapter09.html.page_327">327</a>, <a href="#OEBPS/Chapter09.html.page_328">328</a>, <a href="#OEBPS/Chapter09.html.page_340">340</a>, <a href="#OEBPS/Chapter09.html.page_344">344</a>, <a href="#OEBPS/Chapter09.html.page_352">352</a>, <a href="#OEBPS/Chapter09.html.page_353">353</a></p>
<p class="index"><b>应用引擎</b>, <a href="#OEBPS/Chapter02.html.page_64">64</a> , <a href="#OEBPS/Chapter02.html.page_65">65</a> , <a href="#OEBPS/Chapter02.html.page_66">66</a></p><p class="index"><b>App Engine</b>, <a href="#OEBPS/Chapter02.html.page_64">64</a>, <a href="#OEBPS/Chapter02.html.page_65">65</a>, <a href="#OEBPS/Chapter02.html.page_66">66</a></p>
<p class="index"><b><i>苹果二代</i></b>,<a href="#OEBPS/Chapter02.html.page_49"> 49</a> ,<a href="#OEBPS/Chapter02.html.page_50"> 50</a> ,<a href="#OEBPS/Chapter04.html.page_135"> 135</a></p><p class="index"><b><i>Apple II</i></b>, <a href="#OEBPS/Chapter02.html.page_49">49</a>, <a href="#OEBPS/Chapter02.html.page_50">50</a>, <a href="#OEBPS/Chapter04.html.page_135">135</a></p>
<p class="index"><b>苹果用户组</b>, <a href="#OEBPS/Chapter01.html.page_3">3</a></p><p class="index"><b>Apple Users Group</b>, <a href="#OEBPS/Chapter01.html.page_3">3</a></p>
<p class="index"><b>阿姆斯特朗，乔</b>，<a href="#OEBPS/Chapter04.html.page_150">150 岁</a></p><p class="index"><b>Armstrong, Joe</b>, <a href="#OEBPS/Chapter04.html.page_150">150</a></p>
<p class="index"><b><i>阿帕网</i></b>,<a href="#OEBPS/Chapter14.html.page_519"> 519</a> ,<a href="#OEBPS/Chapter14.html.page_529"> 529</a> ,<a href="#OEBPS/Chapter14.html.page_541"> 541</a></p><p class="index"><b><i>ARPANET</i></b>, <a href="#OEBPS/Chapter14.html.page_519">519</a>, <a href="#OEBPS/Chapter14.html.page_529">529</a>, <a href="#OEBPS/Chapter14.html.page_541">541</a></p>
<p class="index"><b><i>计算机编程艺术，The</i></b> ,<a href="#OEBPS/Chapter15.html.page_565"> 565</a> ,<a href="#OEBPS/Chapter15.html.page_568"> 568</a> ,<a href="#OEBPS/Chapter15.html.page_570"> 570</a> ,<a href="#OEBPS/Chapter15.html.page_572"> 572</a> ,<a href="#OEBPS/Chapter15.html.page_577"> 577</a> ,<a href="#OEBPS/Chapter15.html.page_579"> 579</a> ,<a href="#OEBPS/Chapter15.html.page_583"> 583</a> ,<a href="#OEBPS/Chapter15.html.page_584"> 584</a></p><p class="index"><b><i>Art of Computer Programming, The</i></b>, <a href="#OEBPS/Chapter15.html.page_565">565</a>, <a href="#OEBPS/Chapter15.html.page_568">568</a>, <a href="#OEBPS/Chapter15.html.page_570">570</a>, <a href="#OEBPS/Chapter15.html.page_572">572</a>, <a href="#OEBPS/Chapter15.html.page_577">577</a>, <a href="#OEBPS/Chapter15.html.page_579">579</a>, <a href="#OEBPS/Chapter15.html.page_583">583</a>, <a href="#OEBPS/Chapter15.html.page_584">584</a></p>
<p class="index"><b>断言</b>, <a href="#OEBPS/Chapter01.html.page_31">31</a> , <a href="#OEBPS/Chapter01.html.page_32">32</a> , <a href="#OEBPS/Chapter09.html.page_364">364</a> , <a href="#OEBPS/Chapter09.html.page_365">365</a></p><p class="index"><b>assertions</b>, <a href="#OEBPS/Chapter01.html.page_31">31</a>, <a href="#OEBPS/Chapter01.html.page_32">32</a>, <a href="#OEBPS/Chapter09.html.page_364">364</a>, <a href="#OEBPS/Chapter09.html.page_365">365</a></p>
<p class="index"><b>断言</b>, <a href="#OEBPS/Chapter12.html.page_468">468</a></p><p class="index"><b>asserts</b>, <a href="#OEBPS/Chapter12.html.page_468">468</a></p>
<p class="index"><b>雅达利 800</b> , <a href="#OEBPS/Chapter03.html.page_94">94</a></p><p class="index"><b>Atari 800</b>, <a href="#OEBPS/Chapter03.html.page_94">94</a></p>
<p class="index"><b>阿特拉斯</b>, <a href="#OEBPS/Chapter03.html.page_102">102</a></p><p class="index"><b>Atlas</b>, <a href="#OEBPS/Chapter03.html.page_102">102</a></p>
<p class="index"><b>145</b> _ <a href="#OEBPS/Chapter04.html.page_145">_</a></p><p class="index"><b>awk</b>, <a href="#OEBPS/Chapter04.html.page_145">145</a></p>
<p class="index"><b>基本</b>, <a href="#OEBPS/Chapter01.html.page_2">2</a> , <a href="#OEBPS/Chapter02.html.page_50">50</a> , <a href="#OEBPS/Chapter02.html.page_62">62</a> , <a href="#OEBPS/Chapter05.html.page_168">168</a> , <a href="#OEBPS/Chapter05.html.page_169">169</a> , <a href="#OEBPS/Chapter05.html.page_170">170</a> , <a href="#OEBPS/Chapter08.html.page_288">288</a> , <a href="#OEBPS/Chapter08.html.page_289">289</a> , <a href="#OEBPS/Chapter10.html.page_373">373</a> , <a href="#OEBPS/Chapter10.html.page_377">377</a> , <a href="#OEBPS/Chapter10.html.page_383">383</a> , <a href="#OEBPS/Chapter10.html.page_386">386</a></p><p class="index"><b>BASIC</b>, <a href="#OEBPS/Chapter01.html.page_2">2</a>, <a href="#OEBPS/Chapter02.html.page_50">50</a>, <a href="#OEBPS/Chapter02.html.page_62">62</a>, <a href="#OEBPS/Chapter05.html.page_168">168</a>, <a href="#OEBPS/Chapter05.html.page_169">169</a>, <a href="#OEBPS/Chapter05.html.page_170">170</a>, <a href="#OEBPS/Chapter08.html.page_288">288</a>, <a href="#OEBPS/Chapter08.html.page_289">289</a>, <a href="#OEBPS/Chapter10.html.page_373">373</a>, <a href="#OEBPS/Chapter10.html.page_377">377</a>, <a href="#OEBPS/Chapter10.html.page_383">383</a>, <a href="#OEBPS/Chapter10.html.page_386">386</a></p>
<h3 class="h3">乙</h3><h3 class="h3">B</h3>
<p class="index"><b>基础四</b>, <a href="#OEBPS/Chapter03.html.page_94">94</a> , <a href="#OEBPS/Chapter03.html.page_121">121</a></p><p class="index"><b>Basic Four</b>, <a href="#OEBPS/Chapter03.html.page_94">94</a>, <a href="#OEBPS/Chapter03.html.page_121">121</a></p>
<p class="index"><b><i>BBN</i></b> ,<a href="#OEBPS/Chapter14.html.page_519"> 519</a> ,<a href="#OEBPS/Chapter14.html.page_520"> 520</a> ,<a href="#OEBPS/Chapter14.html.page_521"> 521</a> ,<a href="#OEBPS/Chapter14.html.page_522"> 522</a> ,<a href="#OEBPS/Chapter14.html.page_523"> 523</a> ,<a href="#OEBPS/Chapter14.html.page_525"> 525</a> ,<a href="#OEBPS/Chapter14.html.page_526"> 526</a> ,<a href="#OEBPS/Chapter14.html.page_535"> 535</a> ,<a href="#OEBPS/Chapter14.html.page_539"> 539</a> ,<a href="#OEBPS/Chapter14.html.page_540"> 540</a> ,<a href="#OEBPS/Chapter14.html.page_541"> 541</a> ,<a href="#OEBPS/Chapter14.html.page_543"> 543</a> ,<a href="#OEBPS/Chapter14.html.page_549"> 549</a> ,<a href="#OEBPS/Chapter14.html.page_551"> 551</a> ,<a href="#OEBPS/Chapter14.html.page_552"> 552</a> ,<a href="#OEBPS/Chapter14.html.page_553"> 553</a> ,<a href="#OEBPS/Chapter14.html.page_554"> 554</a></p><p class="index"><b><i>BBN</i></b>, <a href="#OEBPS/Chapter14.html.page_519">519</a>, <a href="#OEBPS/Chapter14.html.page_520">520</a>, <a href="#OEBPS/Chapter14.html.page_521">521</a>, <a href="#OEBPS/Chapter14.html.page_522">522</a>, <a href="#OEBPS/Chapter14.html.page_523">523</a>, <a href="#OEBPS/Chapter14.html.page_525">525</a>, <a href="#OEBPS/Chapter14.html.page_526">526</a>, <a href="#OEBPS/Chapter14.html.page_535">535</a>, <a href="#OEBPS/Chapter14.html.page_539">539</a>, <a href="#OEBPS/Chapter14.html.page_540">540</a>, <a href="#OEBPS/Chapter14.html.page_541">541</a>, <a href="#OEBPS/Chapter14.html.page_543">543</a>, <a href="#OEBPS/Chapter14.html.page_549">549</a>, <a href="#OEBPS/Chapter14.html.page_551">551</a>, <a href="#OEBPS/Chapter14.html.page_552">552</a>, <a href="#OEBPS/Chapter14.html.page_553">553</a>, <a href="#OEBPS/Chapter14.html.page_554">554</a></p>
<p class="index"><b>论坛</b>, <a href="#OEBPS/Chapter02.html.page_52">52</a></p><p class="index"><b>BBS</b>, <a href="#OEBPS/Chapter02.html.page_52">52</a></p>
<p class="index"><b>BCPL</b> , <a href="#OEBPS/Chapter07.html.page_244">244</a> , <a href="#OEBPS/Chapter07.html.page_246">246</a> , <a href="#OEBPS/Chapter07.html.page_255">255</a> , <a href="#OEBPS/Chapter12.html.page_456">456</a></p><p class="index"><b>BCPL</b>, <a href="#OEBPS/Chapter07.html.page_244">244</a>, <a href="#OEBPS/Chapter07.html.page_246">246</a>, <a href="#OEBPS/Chapter07.html.page_255">255</a>, <a href="#OEBPS/Chapter12.html.page_456">456</a></p>
<p class="index"><b>BDD</b> , <a href="#OEBPS/Chapter15.html.page_575">575</a> , <a href="#OEBPS/Chapter15.html.page_584">584</a> , <a href="#OEBPS/Chapter15.html.page_587">587</a> , <a href="#OEBPS/Chapter15.html.page_588">588</a></p><p class="index"><b>BDDs</b>, <a href="#OEBPS/Chapter15.html.page_575">575</a>, <a href="#OEBPS/Chapter15.html.page_584">584</a>, <a href="#OEBPS/Chapter15.html.page_587">587</a>, <a href="#OEBPS/Chapter15.html.page_588">588</a></p>
<p class="index"><b><i>贝尔实验室</i></b>,<a href="#OEBPS/Chapter12.html.page_449"> 449</a> ,<a href="#OEBPS/Chapter12.html.page_457"> 457</a> ,<a href="#OEBPS/Chapter12.html.page_458"> 458</a> ,<a href="#OEBPS/Chapter12.html.page_463"> 463</a> ,<a href="#OEBPS/Chapter12.html.page_464"> 464</a> ,<a href="#OEBPS/Chapter12.html.page_474"> 474</a></p><p class="index"><b><i>Bell Labs</i></b>, <a href="#OEBPS/Chapter12.html.page_449">449</a>, <a href="#OEBPS/Chapter12.html.page_457">457</a>, <a href="#OEBPS/Chapter12.html.page_458">458</a>, <a href="#OEBPS/Chapter12.html.page_463">463</a>, <a href="#OEBPS/Chapter12.html.page_464">464</a>, <a href="#OEBPS/Chapter12.html.page_474">474</a></p>
<p class="index"><b><i>贝儿</i></b>，<a href="#OEBPS/Chapter12.html.page_449"> 449</a></p><p class="index"><b><i>Belle</i></b>, <a href="#OEBPS/Chapter12.html.page_449">449</a></p>
<p class="index"><b>伯克利</b>, <a href="#OEBPS/Chapter12.html.page_451">451</a> , <a href="#OEBPS/Chapter12.html.page_453">453</a> , <a href="#OEBPS/Chapter12.html.page_454">454</a></p><p class="index"><b>Berkeley</b>, <a href="#OEBPS/Chapter12.html.page_451">451</a>, <a href="#OEBPS/Chapter12.html.page_453">453</a>, <a href="#OEBPS/Chapter12.html.page_454">454</a></p>
<p class="index"><b>老大哥数据库</b>, <a href="#OEBPS/Chapter01.html.page_9">9</a></p><p class="index"><b>Big Brother Database</b>, <a href="#OEBPS/Chapter01.html.page_9">9</a></p>
<p class="index"><b>大整数</b>, <a href="#OEBPS/Chapter05.html.page_176">176</a></p><p class="index"><b>BigInteger</b>, <a href="#OEBPS/Chapter05.html.page_176">176</a></p>
<p class="index"><b><i>大O</i></b>，<a href="#OEBPS/Chapter15.html.page_565"> 565</a></p><p class="index"><b><i>Big-O</i></b>, <a href="#OEBPS/Chapter15.html.page_565">565</a></p>
<p class="index"><b>埃里克·比娜</b>，<a href="#OEBPS/Chapter01.html.page_16">16 岁</a></p><p class="index"><b>Bina, Eric</b>, <a href="#OEBPS/Chapter01.html.page_16">16</a></p>
<p class="index"><b>小玩意</b>, <a href="#OEBPS/Chapter05.html.page_172">172</a></p><p class="index"><b>bit twiddling</b>, <a href="#OEBPS/Chapter05.html.page_172">172</a></p>
<p class="index"><b><i>BitBlt</i></b> ,<a href="#OEBPS/Chapter10.html.page_373"> 373</a> ,<a href="#OEBPS/Chapter10.html.page_380"> 380</a> ,<a href="#OEBPS/Chapter10.html.page_384"> 384</a> ,<a href="#OEBPS/Chapter10.html.page_385"> 385</a> ,<a href="#OEBPS/Chapter10.html.page_386"> 386</a> ,<a href="#OEBPS/Chapter10.html.page_387"> 387</a> ,<a href="#OEBPS/Chapter10.html.page_394"> 394</a> ,<a href="#OEBPS/Chapter10.html.page_395"> 395</a> ,<a href="#OEBPS/Chapter10.html.page_409"> 409</a> ,<a href="#OEBPS/Chapter10.html.page_410"> 410</a></p><p class="index"><b><i>BitBlt</i></b>, <a href="#OEBPS/Chapter10.html.page_373">373</a>, <a href="#OEBPS/Chapter10.html.page_380">380</a>, <a href="#OEBPS/Chapter10.html.page_384">384</a>, <a href="#OEBPS/Chapter10.html.page_385">385</a>, <a href="#OEBPS/Chapter10.html.page_386">386</a>, <a href="#OEBPS/Chapter10.html.page_387">387</a>, <a href="#OEBPS/Chapter10.html.page_394">394</a>, <a href="#OEBPS/Chapter10.html.page_395">395</a>, <a href="#OEBPS/Chapter10.html.page_409">409</a>, <a href="#OEBPS/Chapter10.html.page_410">410</a></p>
<p class="index"><b>比约克伦德，马丁</b>，<a href="#OEBPS/Chapter06.html.page_230">230</a></p><p class="index"><b>Björklund, Martin</b>, <a href="#OEBPS/Chapter06.html.page_230">230</a></p>
<p class="index"><b><i>布利斯</i></b>,<a href="#OEBPS/Chapter09.html.page_325"> 325</a> ,<a href="#OEBPS/Chapter09.html.page_353"> 353</a> ,<a href="#OEBPS/Chapter12.html.page_462"> 462</a></p><p class="index"><b><i>Bliss</i></b>, <a href="#OEBPS/Chapter09.html.page_325">325</a>, <a href="#OEBPS/Chapter09.html.page_353">353</a>, <a href="#OEBPS/Chapter12.html.page_462">462</a></p>
<p class="index"><b>博布罗，丹</b>，<a href="#OEBPS/Chapter12.html.page_461">461</a></p><p class="index"><b>Bobrow, Dan</b>, <a href="#OEBPS/Chapter12.html.page_461">461</a></p>
<p class="index"><b>博布罗，丹尼</b>，<a href="#OEBPS/Chapter11.html.page_430">430</a></p><p class="index"><b>Bobrow, Danny</b>, <a href="#OEBPS/Chapter11.html.page_430">430</a></p>
<p class="index"><b><i>博尔特·贝拉内克和纽曼 (BBN)</i></b>，<a href="#OEBPS/Chapter14.html.page_519"> 519</a></p><p class="index"><b><i>Bolt Beranek and Newman (BBN)</i></b>, <a href="#OEBPS/Chapter14.html.page_519">519</a></p>
<p class="index"><b>书籍</b>, <a href="#OEBPS/Chapter01.html.page_43">43</a> , <a href="#OEBPS/Chapter01.html.page_44">44</a> , <a href="#OEBPS/Chapter02.html.page_81">81</a> , <a href="#OEBPS/Chapter04.html.page_160">160</a> , <a href="#OEBPS/Chapter04.html.page_161">161</a> , <a href="#OEBPS/Chapter05.html.page_171">171</a> , <a href="#OEBPS/Chapter07.html.page_276">276</a> , <a href="#OEBPS/Chapter08.html.page_299">299</a> , <a href="#OEBPS/Chapter09.html.page_326">326</a> , <a href="#OEBPS/Chapter09.html.page_327">327</a> , <a href="#OEBPS/Chapter09.html.page_330">330</a> , <a href="#OEBPS/Chapter09.html.page_332">332</a> , <a href="#OEBPS/Chapter09.html.page_334">334</a> , <a href="#OEBPS/Chapter10.html.page_401">401</a> , <a href="#OEBPS/Chapter12.html.page_477">477</a> , <a href="#OEBPS/Chapter14.html.page_527">527</a></p><p class="index"><b>books</b>, <a href="#OEBPS/Chapter01.html.page_43">43</a>, <a href="#OEBPS/Chapter01.html.page_44">44</a>, <a href="#OEBPS/Chapter02.html.page_81">81</a>, <a href="#OEBPS/Chapter04.html.page_160">160</a>, <a href="#OEBPS/Chapter04.html.page_161">161</a>, <a href="#OEBPS/Chapter05.html.page_171">171</a>, <a href="#OEBPS/Chapter07.html.page_276">276</a>, <a href="#OEBPS/Chapter08.html.page_299">299</a>, <a href="#OEBPS/Chapter09.html.page_326">326</a>, <a href="#OEBPS/Chapter09.html.page_327">327</a>, <a href="#OEBPS/Chapter09.html.page_330">330</a>, <a href="#OEBPS/Chapter09.html.page_332">332</a>, <a href="#OEBPS/Chapter09.html.page_334">334</a>, <a href="#OEBPS/Chapter10.html.page_401">401</a>, <a href="#OEBPS/Chapter12.html.page_477">477</a>, <a href="#OEBPS/Chapter14.html.page_527">527</a></p>
<p class="index"><b>书籍</b>, <a href="#OEBPS/Chapter05.html.page_175">175</a></p><p class="index"><b>Books</b>, <a href="#OEBPS/Chapter05.html.page_175">175</a></p>
<p class="index"><b>布尔决策图 (BDD)</b> , <a href="#OEBPS/Chapter15.html.page_575">575</a></p><p class="index"><b>Boolean decision diagrams (BDDs)</b>, <a href="#OEBPS/Chapter15.html.page_575">575</a></p>
<p class="index"><b>机器人</b>, <a href="#OEBPS/Chapter02.html.page_53">53</a></p><p class="index"><b>bots</b>, <a href="#OEBPS/Chapter02.html.page_53">53</a></p>
<p class="index"><b><i>英国机器人协会,</i></b> 206,<a href="#OEBPS/Chapter06.html.page_209"> 209</a></p><p class="index"><b><i>British Robotics Association,</i></b> 206, <a href="#OEBPS/Chapter06.html.page_209">209</a></p>
<p class="index"><b></b><a href="#OEBPS/Chapter13.html.page_494">布鲁克斯</a>，<b>弗雷德</b>，<a href="#OEBPS/Chapter13.html.page_492">492，493，494</a> _ <a href="#OEBPS/Chapter13.html.page_493">_</a><a href="#OEBPS/Chapter13.html.page_494"></a></p><p class="index"><b>Brooks, Fred</b>, <a href="#OEBPS/Chapter13.html.page_492">492</a>, <a href="#OEBPS/Chapter13.html.page_493">493</a>, <a href="#OEBPS/Chapter13.html.page_494">494</a></p>
<p class="index"><b>伙伴编程</b>, <a href="#OEBPS/Chapter05.html.page_200">200</a></p><p class="index"><b>buddy programming</b>, <a href="#OEBPS/Chapter05.html.page_200">200</a></p>
<p class="index"><b>巴特菲尔德，史蒂夫</b>，<a href="#OEBPS/Chapter14.html.page_546">546</a></p><p class="index"><b>Butterfield, Steve</b>, <a href="#OEBPS/Chapter14.html.page_546">546</a></p>
<h3 class="h3">C</h3><h3 class="h3">C</h3>
<p class="index">C 、<a href="#OEBPS/Chapter01.html.page_30">30、52、72、134、137、144、147、184、191、197、213、221-2、325、353、355、388、406、420、444、456、467-</a>、<a href="#OEBPS/Chapter02.html.page_52">5 </a><a href="#OEBPS/Chapter02.html.page_72">_</a> _ <a href="#OEBPS/Chapter04.html.page_134">_</a> _ <a href="#OEBPS/Chapter04.html.page_137">_</a> _ <a href="#OEBPS/Chapter04.html.page_144">_</a> _ <a href="#OEBPS/Chapter04.html.page_147">_</a> _ <a href="#OEBPS/Chapter05.html.page_184">_</a> _ <a href="#OEBPS/Chapter05.html.page_191">_</a> _ <a href="#OEBPS/Chapter05.html.page_197">_</a> _ <a href="#OEBPS/Chapter06.html.page_213">_</a> _ <a href="#OEBPS/Chapter06.html.page_221">_</a> _ <a href="#OEBPS/Chapter09.html.page_325">_</a> _ <a href="#OEBPS/Chapter09.html.page_353">_</a> _ <a href="#OEBPS/Chapter09.html.page_355">_</a> _ <a href="#OEBPS/Chapter10.html.page_388">_</a> _ <a href="#OEBPS/Chapter10.html.page_406">_</a> _ <a href="#OEBPS/Chapter11.html.page_420">_</a> _ <a href="#OEBPS/Chapter11.html.page_444">_</a> _ <a href="#OEBPS/Chapter12.html.page_456">_</a> _ <a href="#OEBPS/Chapter12.html.page_460">_</a> _ <a href="#OEBPS/Chapter12.html.page_467">_</a> _ <a href="#OEBPS/Chapter13.html.page_501">_</a> _ 3, <a href="#OEBPS/Chapter14.html.page_557">557</a> , <a href="#OEBPS/Chapter14.html.page_559">559</a> -60, <a href="#OEBPS/Chapter15.html.page_585">585</a> 589</p><p class="index">C, <a href="#OEBPS/Chapter01.html.page_30">30</a>, <a href="#OEBPS/Chapter02.html.page_52">52</a>, <a href="#OEBPS/Chapter02.html.page_72">72</a>, <a href="#OEBPS/Chapter04.html.page_134">134</a>, <a href="#OEBPS/Chapter04.html.page_137">137</a>, <a href="#OEBPS/Chapter04.html.page_144">144</a>, <a href="#OEBPS/Chapter04.html.page_147">147</a>, <a href="#OEBPS/Chapter05.html.page_184">184</a>, <a href="#OEBPS/Chapter05.html.page_191">191</a>, <a href="#OEBPS/Chapter05.html.page_197">197</a>, <a href="#OEBPS/Chapter06.html.page_213">213</a>, <a href="#OEBPS/Chapter06.html.page_221">221</a> -2, <a href="#OEBPS/Chapter09.html.page_325">325</a>, <a href="#OEBPS/Chapter09.html.page_353">353</a>, <a href="#OEBPS/Chapter09.html.page_355">355</a>, <a href="#OEBPS/Chapter10.html.page_388">388</a>, <a href="#OEBPS/Chapter10.html.page_406">406</a>, <a href="#OEBPS/Chapter11.html.page_420">420</a>, <a href="#OEBPS/Chapter11.html.page_444">444</a>, <a href="#OEBPS/Chapter12.html.page_456">456</a>, <a href="#OEBPS/Chapter12.html.page_460">460</a>, <a href="#OEBPS/Chapter12.html.page_467">467</a>, <a href="#OEBPS/Chapter13.html.page_501">501</a>-3, <a href="#OEBPS/Chapter14.html.page_557">557</a>, <a href="#OEBPS/Chapter14.html.page_559">559</a>-60, <a href="#OEBPS/Chapter15.html.page_585">585</a> 589</p>
<p class="index"><b></b><a href="#OEBPS/Chapter07.html.page_264">中——</a> , <b>264</b><a href="#OEBPS/Chapter07.html.page_264"></a></p><p class="index"><b>C--</b>, <a href="#OEBPS/Chapter07.html.page_264">264</a></p>
<p class="index"><b>C 代码</b>, <a href="#OEBPS/Chapter01.html.page_11">11</a></p><p class="index"><b>C code</b>, <a href="#OEBPS/Chapter01.html.page_11">11</a></p>
<p class="index"><b>C语言</b>, <a href="#OEBPS/Chapter01.html.page_10">10</a></p><p class="index"><b>C language</b>, <a href="#OEBPS/Chapter01.html.page_10">10</a></p>
<p class="index"><b><i>C*</i></b> ,<a href="#OEBPS/Chapter09.html.page_325"> 325</a> ,<a href="#OEBPS/Chapter09.html.page_354"> 354</a></p><p class="index"><b><i>C*</i></b>, <a href="#OEBPS/Chapter09.html.page_325">325</a>, <a href="#OEBPS/Chapter09.html.page_354">354</a></p>
<p class="index"><b>C++</b> , <a href="#OEBPS/Chapter01.html.page_9">9</a> - <a href="#OEBPS/Chapter01.html.page_11">11</a> , <a href="#OEBPS/Chapter01.html.page_20">20</a> - <a href="#OEBPS/Chapter01.html.page_1">1</a> , <a href="#OEBPS/Chapter01.html.page_38">38</a> , <a href="#OEBPS/Chapter02.html.page_49">49</a> , <a href="#OEBPS/Chapter02.html.page_62">62</a> - <a href="#OEBPS/Chapter01.html.page_4">4</a> , <a href="#OEBPS/Chapter02.html.page_80">80</a> 85, <a href="#OEBPS/Chapter04.html.page_138">138</a> - <a href="#OEBPS/Chapter01.html.page_9">9</a> , <a href="#OEBPS/Chapter04.html.page_147">147</a> - <a href="#OEBPS/Chapter01.html.page_8">8</a> , <a href="#OEBPS/Chapter04.html.page_156">156</a> , <a href="#OEBPS/Chapter04.html.page_162">162</a> - <a href="#OEBPS/Chapter01.html.page_4">4</a> , <a href="#OEBPS/Chapter05.html.page_170">170 </a> <a href="#OEBPS/Chapter05.html.page_184">184</a> - <a href="#OEBPS/Chapter01.html.page_6">6</a> , <a href="#OEBPS/Chapter05.html.page_191">191</a> , <a href="#OEBPS/Chapter05.html.page_193">193</a> , <a href="#OEBPS/Chapter05.html.page_198">198</a> ,224,247 262, <a href="#OEBPS/Chapter09.html.page_325">325</a> , <a href="#OEBPS/Chapter09.html.page_349">349</a> , <a href="#OEBPS/Chapter09.html.page_353">353</a> - <a href="#OEBPS/Chapter01.html.page_4">4</a> , <a href="#OEBPS/Chapter10.html.page_377">377</a> , <a href="#OEBPS/Chapter10.html.page_389">389</a> <a href="#OEBPS/Chapter10.html.page_406">406</a> - <a href="#OEBPS/Chapter01.html.page_7">7</a> , <a href="#OEBPS/Chapter12.html.page_467">467</a> - <a href="#OEBPS/Chapter01.html.page_8">8</a> , <a href="#OEBPS/Chapter12.html.page_475">475</a> - <a href="#OEBPS/Chapter01.html.page_6">6</a> , <a href="#OEBPS/Chapter13.html.page_503">503</a> , <a href="#OEBPS/Chapter14.html.page_529">529</a> , <a href="#OEBPS/Chapter14.html.page_559">559</a></p><p class="index"><b>C++</b>, <a href="#OEBPS/Chapter01.html.page_9">9</a>-<a href="#OEBPS/Chapter01.html.page_11">11</a>, <a href="#OEBPS/Chapter01.html.page_20">20</a>-<a href="#OEBPS/Chapter01.html.page_1">1</a>, <a href="#OEBPS/Chapter01.html.page_38">38</a>, <a href="#OEBPS/Chapter02.html.page_49">49</a>, <a href="#OEBPS/Chapter02.html.page_62">62</a>-<a href="#OEBPS/Chapter01.html.page_4">4</a>, <a href="#OEBPS/Chapter02.html.page_80">80</a> 85, <a href="#OEBPS/Chapter04.html.page_138">138</a>-<a href="#OEBPS/Chapter01.html.page_9">9</a>, <a href="#OEBPS/Chapter04.html.page_147">147</a>-<a href="#OEBPS/Chapter01.html.page_8">8</a>, <a href="#OEBPS/Chapter04.html.page_156">156</a>, <a href="#OEBPS/Chapter04.html.page_162">162</a>-<a href="#OEBPS/Chapter01.html.page_4">4</a>, <a href="#OEBPS/Chapter05.html.page_170">170</a> <a href="#OEBPS/Chapter05.html.page_184">184</a>-<a href="#OEBPS/Chapter01.html.page_6">6</a>, <a href="#OEBPS/Chapter05.html.page_191">191</a>, <a href="#OEBPS/Chapter05.html.page_193">193</a>, <a href="#OEBPS/Chapter05.html.page_198">198</a>,224,247 262, <a href="#OEBPS/Chapter09.html.page_325">325</a>, <a href="#OEBPS/Chapter09.html.page_349">349</a>, <a href="#OEBPS/Chapter09.html.page_353">353</a>-<a href="#OEBPS/Chapter01.html.page_4">4</a>, <a href="#OEBPS/Chapter10.html.page_377">377</a>, <a href="#OEBPS/Chapter10.html.page_389">389</a> <a href="#OEBPS/Chapter10.html.page_406">406</a>-<a href="#OEBPS/Chapter01.html.page_7">7</a>, <a href="#OEBPS/Chapter12.html.page_467">467</a>-<a href="#OEBPS/Chapter01.html.page_8">8</a>, <a href="#OEBPS/Chapter12.html.page_475">475</a>-<a href="#OEBPS/Chapter01.html.page_6">6</a>, <a href="#OEBPS/Chapter13.html.page_503">503</a>, <a href="#OEBPS/Chapter14.html.page_529">529</a>, <a href="#OEBPS/Chapter14.html.page_559">559</a></p>
<p class="index"><b>剑桥</b>, <a href="#OEBPS/Chapter07.html.page_241">241</a> , <a href="#OEBPS/Chapter07.html.page_244">244</a> , <a href="#OEBPS/Chapter07.html.page_245">245</a> , <a href="#OEBPS/Chapter07.html.page_246">246</a> , <a href="#OEBPS/Chapter07.html.page_247">247</a> , <a href="#OEBPS/Chapter07.html.page_249">249</a> , <a href="#OEBPS/Chapter07.html.page_255">255</a></p><p class="index"><b>Cambridge</b>, <a href="#OEBPS/Chapter07.html.page_241">241</a>, <a href="#OEBPS/Chapter07.html.page_244">244</a>, <a href="#OEBPS/Chapter07.html.page_245">245</a>, <a href="#OEBPS/Chapter07.html.page_246">246</a>, <a href="#OEBPS/Chapter07.html.page_247">247</a>, <a href="#OEBPS/Chapter07.html.page_249">249</a>, <a href="#OEBPS/Chapter07.html.page_255">255</a></p>
<p class="index"><b><i>剑桥</i></b><a href="#OEBPS/Chapter11.html.page_416">电子</a><a href="#OEBPS/Chapter11.html.page_414">加速器</a>，413、414、416<a href="#OEBPS/Chapter11.html.page_416"></a></p><p class="index"><b><i>Cambridge Electron Accelerator,</i></b> 413, <a href="#OEBPS/Chapter11.html.page_414">414</a>, <a href="#OEBPS/Chapter11.html.page_416">416</a></p>
<p class="index"><b>卡纳迪，陆克文</b>，<a href="#OEBPS/Chapter12.html.page_464">464</a></p><p class="index"><b>Canady, Rudd</b>, <a href="#OEBPS/Chapter12.html.page_464">464</a></p>
<p class="index"><b>卡耐基梅隆大学</b>，<a href="#OEBPS/Chapter09.html.page_353">353 岁</a></p><p class="index"><b>Carnegie Mellon</b>, <a href="#OEBPS/Chapter09.html.page_353">353</a></p>
<p class="index"><b>卡内基梅隆大学 (CMU)</b> , <a href="#OEBPS/Chapter01.html.page_3">3</a> , <a href="#OEBPS/Chapter01.html.page_4">4</a></p><p class="index"><b>Carnegie Mellon University (CMU)</b>, <a href="#OEBPS/Chapter01.html.page_3">3</a>, <a href="#OEBPS/Chapter01.html.page_4">4</a></p>
<p class="index"><b><i>卡内基梅隆大学</i></b>，<a href="#OEBPS/Chapter05.html.page_167"> 167</a></p><p class="index"><b><i>Carnegie-Mellon University</i></b>, <a href="#OEBPS/Chapter05.html.page_167">167</a></p>
<p class="index"><b>凯斯理工学院</b>, <a href="#OEBPS/Chapter15.html.page_566">566</a></p><p class="index"><b>Case Institute of Technology</b>, <a href="#OEBPS/Chapter15.html.page_566">566</a></p>
<p class="index"><b>电脑动画</b>, <a href="#OEBPS/Chapter02.html.page_53">53</a> , <a href="#OEBPS/Chapter02.html.page_54">54</a> , <a href="#OEBPS/Chapter02.html.page_56">56</a> , <a href="#OEBPS/Chapter02.html.page_57">57</a></p><p class="index"><b>CGI</b>, <a href="#OEBPS/Chapter02.html.page_53">53</a>, <a href="#OEBPS/Chapter02.html.page_54">54</a>, <a href="#OEBPS/Chapter02.html.page_56">56</a>, <a href="#OEBPS/Chapter02.html.page_57">57</a></p>
<p class="index"><b>更改文件</b>, <a href="#OEBPS/Chapter15.html.page_586">586</a> , <a href="#OEBPS/Chapter15.html.page_587">587</a> , <a href="#OEBPS/Chapter15.html.page_588">588</a></p><p class="index"><b>change files</b>, <a href="#OEBPS/Chapter15.html.page_586">586</a>, <a href="#OEBPS/Chapter15.html.page_587">587</a>, <a href="#OEBPS/Chapter15.html.page_588">588</a></p>
<p class="index"><b>查尔斯·菲利普</b>，<a href="#OEBPS/Chapter13.html.page_489">489</a></p><p class="index"><b>Charles, Philippe</b>, <a href="#OEBPS/Chapter13.html.page_489">489</a></p>
<p class="index"><b>铬</b>, <a href="#OEBPS/Chapter02.html.page_71">71</a></p><p class="index"><b>Chrome</b>, <a href="#OEBPS/Chapter02.html.page_71">71</a></p>
<p class="index"><b>铬合金</b>, <a href="#OEBPS/Chapter07.html.page_248">248</a></p><p class="index"><b>Chromix</b>, <a href="#OEBPS/Chapter07.html.page_248">248</a></p>
<p class="index"><b>教堂，阿朗佐</b>，<a href="#OEBPS/Chapter04.html.page_146">146</a></p><p class="index"><b>Church, Alonzo</b>, <a href="#OEBPS/Chapter04.html.page_146">146</a></p>
<p class="index"><b>吉姆·克拉克</b>，<a href="#OEBPS/Chapter04.html.page_136">136 岁</a></p><p class="index"><b>Clark, Jim</b>, <a href="#OEBPS/Chapter04.html.page_136">136</a></p>
<p class="index"><b></b><a href="#OEBPS/Chapter07.html.page_256">克拉克</a>，<b>托马斯</b>，<a href="#OEBPS/Chapter07.html.page_245">245，253，256</a> _ <a href="#OEBPS/Chapter07.html.page_253">_</a><a href="#OEBPS/Chapter07.html.page_256"></a></p><p class="index"><b>Clarke, Thomas</b>, <a href="#OEBPS/Chapter07.html.page_245">245</a>, <a href="#OEBPS/Chapter07.html.page_253">253</a>, <a href="#OEBPS/Chapter07.html.page_256">256</a></p>
<p class="index"><b>洁净室工艺</b>, <a href="#OEBPS/Chapter13.html.page_493">493</a> , <a href="#OEBPS/Chapter13.html.page_494">494</a></p><p class="index"><b>Cleanroom process</b>, <a href="#OEBPS/Chapter13.html.page_493">493</a>, <a href="#OEBPS/Chapter13.html.page_494">494</a></p>
<p class="index"><b>卡内基梅隆大学</b>, <a href="#OEBPS/Chapter05.html.page_190">190</a></p><p class="index"><b>CMU</b>, <a href="#OEBPS/Chapter05.html.page_190">190</a></p>
<p class="index"><b>CMU Common Lisp</b> , <a href="#OEBPS/Chapter01.html.page_3">3</a></p><p class="index"><b>CMU Common Lisp</b>, <a href="#OEBPS/Chapter01.html.page_3">3</a></p>
<p class="index"><b><i>COBOL</i></b> ,<a href="#OEBPS/Chapter09.html.page_325"> 325</a> ,<a href="#OEBPS/Chapter09.html.page_353"> 353</a> ,<a href="#OEBPS/Chapter10.html.page_376"> 376</a> ,<a href="#OEBPS/Chapter10.html.page_398"> 398</a> ,<a href="#OEBPS/Chapter15.html.page_596"> 596</a></p><p class="index"><b><i>COBOL</i></b>, <a href="#OEBPS/Chapter09.html.page_325">325</a>, <a href="#OEBPS/Chapter09.html.page_353">353</a>, <a href="#OEBPS/Chapter10.html.page_376">376</a>, <a href="#OEBPS/Chapter10.html.page_398">398</a>, <a href="#OEBPS/Chapter15.html.page_596">596</a></p>
<p class="index"><b>约翰·科克</b>，<a href="#OEBPS/Chapter13.html.page_515">515</a></p><p class="index"><b>Cocke, John</b>, <a href="#OEBPS/Chapter13.html.page_515">515</a></p>
<p class="index"><b>代码设计</b>, <a href="#OEBPS/Chapter04.html.page_154">154</a> , <a href="#OEBPS/Chapter04.html.page_155">155</a></p><p class="index"><b>code design</b>, <a href="#OEBPS/Chapter04.html.page_154">154</a>, <a href="#OEBPS/Chapter04.html.page_155">155</a></p>
<p class="index"><b>代码所有权</b>, <a href="#OEBPS/Chapter05.html.page_201">201</a></p><p class="index"><b>code ownership</b>, <a href="#OEBPS/Chapter05.html.page_201">201</a></p>
<p class="index"><b><i>读码</i></b>,<a href="#OEBPS/Chapter03.html.page_92"> 92</a> ,<a href="#OEBPS/Chapter03.html.page_102"> 102</a> ,<a href="#OEBPS/Chapter03.html.page_103"> 103</a> ,<a href="#OEBPS/Chapter03.html.page_104"> 104</a> ,<a href="#OEBPS/Chapter03.html.page_105"> 105</a> ,<a href="#OEBPS/Chapter03.html.page_107"> 107</a> ,<a href="#OEBPS/Chapter03.html.page_116"> 116</a> ,<a href="#OEBPS/Chapter03.html.page_129"> 129</a> ,<a href="#OEBPS/Chapter05.html.page_182"> 182</a></p><p class="index"><b><i>code reading</i></b>, <a href="#OEBPS/Chapter03.html.page_92">92</a>, <a href="#OEBPS/Chapter03.html.page_102">102</a>, <a href="#OEBPS/Chapter03.html.page_103">103</a>, <a href="#OEBPS/Chapter03.html.page_104">104</a>, <a href="#OEBPS/Chapter03.html.page_105">105</a>, <a href="#OEBPS/Chapter03.html.page_107">107</a>, <a href="#OEBPS/Chapter03.html.page_116">116</a>, <a href="#OEBPS/Chapter03.html.page_129">129</a>, <a href="#OEBPS/Chapter05.html.page_182">182</a></p>
<p class="index"><b>协作</b>, <a href="#OEBPS/Chapter01.html.page_19">19</a></p><p class="index"><b>Collabra</b>, <a href="#OEBPS/Chapter01.html.page_19">19</a></p>
<p class="index"><b><i>哥伦比亚大学</i></b>,<a href="#OEBPS/Chapter05.html.page_167"> 167</a></p><p class="index"><b><i>Columbia University</i></b>, <a href="#OEBPS/Chapter05.html.page_167">167</a></p>
<p class="index"><b>组合算法</b>, <a href="#OEBPS/Chapter15.html.page_580">580</a></p><p class="index"><b>combinatorial algorithms</b>, <a href="#OEBPS/Chapter15.html.page_580">580</a></p>
<p class="index"><b>评论</b>, <a href="#OEBPS/Chapter01.html.page_36">36</a> , <a href="#OEBPS/Chapter14.html.page_541">541</a> , <a href="#OEBPS/Chapter14.html.page_545">545</a> , <a href="#OEBPS/Chapter14.html.page_555">555</a> , <a href="#OEBPS/Chapter14.html.page_556">556</a></p><p class="index"><b>comments</b>, <a href="#OEBPS/Chapter01.html.page_36">36</a>, <a href="#OEBPS/Chapter14.html.page_541">541</a>, <a href="#OEBPS/Chapter14.html.page_545">545</a>, <a href="#OEBPS/Chapter14.html.page_555">555</a>, <a href="#OEBPS/Chapter14.html.page_556">556</a></p>
<p class="index"><b><i>普通 Lisp</i></b> ,<a href="#OEBPS/Chapter09.html.page_325"> 325</a> ,<a href="#OEBPS/Chapter09.html.page_338"> 338</a> ,<a href="#OEBPS/Chapter09.html.page_343"> 343</a> ,<a href="#OEBPS/Chapter09.html.page_350"> 350</a> ,<a href="#OEBPS/Chapter09.html.page_351"> 351</a> ,<a href="#OEBPS/Chapter09.html.page_353"> 353</a> ,<a href="#OEBPS/Chapter09.html.page_365"> 365</a> ,<a href="#OEBPS/Chapter09.html.page_372"> 372</a></p><p class="index"><b><i>Common Lisp</i></b>, <a href="#OEBPS/Chapter09.html.page_325">325</a>, <a href="#OEBPS/Chapter09.html.page_338">338</a>, <a href="#OEBPS/Chapter09.html.page_343">343</a>, <a href="#OEBPS/Chapter09.html.page_350">350</a>, <a href="#OEBPS/Chapter09.html.page_351">351</a>, <a href="#OEBPS/Chapter09.html.page_353">353</a>, <a href="#OEBPS/Chapter09.html.page_365">365</a>, <a href="#OEBPS/Chapter09.html.page_372">372</a></p>
<p class="index"><b>计算机</b><a href="#OEBPS/Chapter08.html.page_298">科学</a>, <a href="#OEBPS/Chapter01.html.page_41">41</a> , <a href="#OEBPS/Chapter01.html.page_42">42</a> , <a href="#OEBPS/Chapter02.html.page_52">52</a> , <a href="#OEBPS/Chapter02.html.page_66">66</a> , <a href="#OEBPS/Chapter02.html.page_68">68</a> , <a href="#OEBPS/Chapter03.html.page_130">130</a> , <a href="#OEBPS/Chapter04.html.page_135">135</a> , <a href="#OEBPS/Chapter04.html.page_137">137</a> , <a href="#OEBPS/Chapter04.html.page_150">150</a> , <a href="#OEBPS/Chapter04.html.page_160">160</a> , <a href="#OEBPS/Chapter06.html.page_205">205</a> , <a href="#OEBPS/Chapter06.html.page_208">208</a> , <a href="#OEBPS/Chapter06.html.page_209">209</a> , <a href="#OEBPS/Chapter06.html.page_217">217</a> , <a href="#OEBPS/Chapter06.html.page_233">233</a> , <a href="#OEBPS/Chapter07.html.page_244">244</a> , <a href="#OEBPS/Chapter07.html.page_247">247</a> , <a href="#OEBPS/Chapter07.html.page_249">249</a> , <a href="#OEBPS/Chapter07.html.page_250">250</a> , <a href="#OEBPS/Chapter08.html.page_288">288</a> , <a href="#OEBPS/Chapter08.html.page_295">295</a> , <a href="#OEBPS/Chapter08.html.page_290">29</a> , 29 <a href="#OEBPS/Chapter08.html.page_297">_</a> , <a href="#OEBPS/Chapter08.html.page_311">311</a> , <a href="#OEBPS/Chapter09.html.page_331">331</a> ,<a href="#OEBPS/Chapter08.html.page_295"></a><a href="#OEBPS/Chapter08.html.page_297"></a><a href="#OEBPS/Chapter08.html.page_298"></a><a href="#OEBPS/Chapter08.html.page_311"></a><a href="#OEBPS/Chapter09.html.page_331"></a><a href="#OEBPS/Chapter09.html.page_332">332</a> , <a href="#OEBPS/Chapter09.html.page_333">333</a> , <a href="#OEBPS/Chapter09.html.page_347">347</a> , <a href="#OEBPS/Chapter10.html.page_379">379</a> , <a href="#OEBPS/Chapter10.html.page_390">390</a> , <a href="#OEBPS/Chapter10.html.page_393">393</a> , <a href="#OEBPS/Chapter10.html.page_400">400</a> , <a href="#OEBPS/Chapter10.html.page_410">410</a> , <a href="#OEBPS/Chapter11.html.page_431">431</a> , <a href="#OEBPS/Chapter12.html.page_453">453</a> , <a href="#OEBPS/Chapter12.html.page_482">482</a> , <a href="#OEBPS/Chapter13.html.page_486">486</a> , <a href="#OEBPS/Chapter13.html.page_502">502</a> , <a href="#OEBPS/Chapter13.html.page_506">506</a> , <a href="#OEBPS/Chapter13.html.page_510">510</a> , <a href="#OEBPS/Chapter13.html.page_511">511</a> , <a href="#OEBPS/Chapter13.html.page_512">512</a> , <a href="#OEBPS/Chapter13.html.page_513">513</a> , <a href="#OEBPS/Chapter15.html.page_565">565</a> , <a href="#OEBPS/Chapter15.html.page_569">569</a> , <a href="#OEBPS/Chapter15.html.page_595">6,594</a> , <a href="#OEBPS/Chapter15.html.page_594">594</a> , <a href="#OEBPS/Chapter15.html.page_600">5</a><a href="#OEBPS/Chapter15.html.page_595"></a><a href="#OEBPS/Chapter15.html.page_600"></a></p><p class="index"><b>computer science</b>, <a href="#OEBPS/Chapter01.html.page_41">41</a>, <a href="#OEBPS/Chapter01.html.page_42">42</a>, <a href="#OEBPS/Chapter02.html.page_52">52</a>, <a href="#OEBPS/Chapter02.html.page_66">66</a>, <a href="#OEBPS/Chapter02.html.page_68">68</a>, <a href="#OEBPS/Chapter03.html.page_130">130</a>, <a href="#OEBPS/Chapter04.html.page_135">135</a>, <a href="#OEBPS/Chapter04.html.page_137">137</a>, <a href="#OEBPS/Chapter04.html.page_150">150</a>, <a href="#OEBPS/Chapter04.html.page_160">160</a>, <a href="#OEBPS/Chapter06.html.page_205">205</a>, <a href="#OEBPS/Chapter06.html.page_208">208</a>, <a href="#OEBPS/Chapter06.html.page_209">209</a>, <a href="#OEBPS/Chapter06.html.page_217">217</a>, <a href="#OEBPS/Chapter06.html.page_233">233</a>, <a href="#OEBPS/Chapter07.html.page_244">244</a>, <a href="#OEBPS/Chapter07.html.page_247">247</a>, <a href="#OEBPS/Chapter07.html.page_249">249</a>, <a href="#OEBPS/Chapter07.html.page_250">250</a>, <a href="#OEBPS/Chapter08.html.page_288">288</a>, <a href="#OEBPS/Chapter08.html.page_290">290</a>, <a href="#OEBPS/Chapter08.html.page_295">295</a>, <a href="#OEBPS/Chapter08.html.page_297">297</a>, <a href="#OEBPS/Chapter08.html.page_298">298</a>, <a href="#OEBPS/Chapter08.html.page_311">311</a>, <a href="#OEBPS/Chapter09.html.page_331">331</a>, <a href="#OEBPS/Chapter09.html.page_332">332</a>, <a href="#OEBPS/Chapter09.html.page_333">333</a>, <a href="#OEBPS/Chapter09.html.page_347">347</a>, <a href="#OEBPS/Chapter10.html.page_379">379</a>, <a href="#OEBPS/Chapter10.html.page_390">390</a>, <a href="#OEBPS/Chapter10.html.page_393">393</a>, <a href="#OEBPS/Chapter10.html.page_400">400</a>, <a href="#OEBPS/Chapter10.html.page_410">410</a>, <a href="#OEBPS/Chapter11.html.page_431">431</a>, <a href="#OEBPS/Chapter12.html.page_453">453</a>, <a href="#OEBPS/Chapter12.html.page_482">482</a>, <a href="#OEBPS/Chapter13.html.page_486">486</a>, <a href="#OEBPS/Chapter13.html.page_502">502</a>, <a href="#OEBPS/Chapter13.html.page_506">506</a>, <a href="#OEBPS/Chapter13.html.page_510">510</a>, <a href="#OEBPS/Chapter13.html.page_511">511</a>, <a href="#OEBPS/Chapter13.html.page_512">512</a>, <a href="#OEBPS/Chapter13.html.page_513">513</a>, <a href="#OEBPS/Chapter15.html.page_565">565</a>, <a href="#OEBPS/Chapter15.html.page_569">569</a>, <a href="#OEBPS/Chapter15.html.page_594">594</a>, <a href="#OEBPS/Chapter15.html.page_595">595</a>, <a href="#OEBPS/Chapter15.html.page_600">600</a></p>
<p class="index"><b>并发</b>, <a href="#OEBPS/Chapter07.html.page_271">271</a> , <a href="#OEBPS/Chapter07.html.page_274">274</a></p><p class="index"><b>concurrency</b>, <a href="#OEBPS/Chapter07.html.page_271">271</a>, <a href="#OEBPS/Chapter07.html.page_274">274</a></p>
<p class="index"><b>并发编程</b>, <a href="#OEBPS/Chapter06.html.page_237">237</a></p><p class="index"><b>concurrent programming</b>, <a href="#OEBPS/Chapter06.html.page_237">237</a></p>
<p class="index"><b>继续声明</b>，<a href="#OEBPS/Chapter03.html.page_106">106</a></p><p class="index"><b>continue statement</b>, <a href="#OEBPS/Chapter03.html.page_106">106</a></p>
<p class="index"><b>克罗克福德</b>，道<a href="#OEBPS/Chapter04.html.page_148">格</a>，<a href="#OEBPS/Chapter04.html.page_142">142，143，144，146，148</a> _ <a href="#OEBPS/Chapter04.html.page_143">_</a> _ <a href="#OEBPS/Chapter04.html.page_144">_ </a><a href="#OEBPS/Chapter04.html.page_146">_</a><a href="#OEBPS/Chapter04.html.page_148"></a></p><p class="index"><b>Crockford, Doug</b>, <a href="#OEBPS/Chapter04.html.page_142">142</a>, <a href="#OEBPS/Chapter04.html.page_143">143</a>, <a href="#OEBPS/Chapter04.html.page_144">144</a>, <a href="#OEBPS/Chapter04.html.page_146">146</a>, <a href="#OEBPS/Chapter04.html.page_148">148</a></p>
<p class="index"><b></b><a href="#OEBPS/Chapter14.html.page_547">克劳瑟</a>、<b>威尔</b>、<a href="#OEBPS/Chapter14.html.page_525">525、529、531、532、534、535、536、537、538、547 </a><a href="#OEBPS/Chapter14.html.page_529">_</a> _ <a href="#OEBPS/Chapter14.html.page_531">_</a> _ <a href="#OEBPS/Chapter14.html.page_532">_</a> _ <a href="#OEBPS/Chapter14.html.page_534">_</a> _ <a href="#OEBPS/Chapter14.html.page_535">_</a> _ <a href="#OEBPS/Chapter14.html.page_536">_</a> _ <a href="#OEBPS/Chapter14.html.page_537">_</a> _ <a href="#OEBPS/Chapter14.html.page_538">_</a> _<a href="#OEBPS/Chapter14.html.page_547"></a></p><p class="index"><b>Crowther, Will</b>, <a href="#OEBPS/Chapter14.html.page_525">525</a>, <a href="#OEBPS/Chapter14.html.page_529">529</a>, <a href="#OEBPS/Chapter14.html.page_531">531</a>, <a href="#OEBPS/Chapter14.html.page_532">532</a>, <a href="#OEBPS/Chapter14.html.page_534">534</a>, <a href="#OEBPS/Chapter14.html.page_535">535</a>, <a href="#OEBPS/Chapter14.html.page_536">536</a>, <a href="#OEBPS/Chapter14.html.page_537">537</a>, <a href="#OEBPS/Chapter14.html.page_538">538</a>, <a href="#OEBPS/Chapter14.html.page_547">547</a></p>
<p class="index"><b>好奇心</b>, <a href="#OEBPS/Chapter01.html.page_44">44</a></p><p class="index"><b>curiosity</b>, <a href="#OEBPS/Chapter01.html.page_44">44</a></p>
<p class="index"><b>大括号语言</b>, <a href="#OEBPS/Chapter03.html.page_107">107</a></p><p class="index"><b>curly-brace languages</b>, <a href="#OEBPS/Chapter03.html.page_107">107</a></p>
<p class="index"><b></b><a href="#OEBPS/Chapter15.html.page_572">中环</a>, <b>572</b> , <a href="#OEBPS/Chapter15.html.page_575">575</a> , <a href="#OEBPS/Chapter15.html.page_579">579</a> , <a href="#OEBPS/Chapter15.html.page_589">589</a></p><p class="index"><b>CWEB</b>, <a href="#OEBPS/Chapter15.html.page_572">572</a>, <a href="#OEBPS/Chapter15.html.page_575">575</a>, <a href="#OEBPS/Chapter15.html.page_579">579</a>, <a href="#OEBPS/Chapter15.html.page_589">589</a></p>
<h3 class="h3">丁</h3><h3 class="h3">D</h3>
<p class="index"><b><i>丹加互动</i></b>,<a href="#OEBPS/Chapter02.html.page_49"> 49</a></p><p class="index"><b><i>Danga Interactive</i></b>, <a href="#OEBPS/Chapter02.html.page_49">49</a></p>
<p class="index"><b>托马斯·德贝利斯</b>，<a href="#OEBPS/Chapter05.html.page_169">169 岁</a></p><p class="index"><b>De Bellis, Thomas</b>, <a href="#OEBPS/Chapter05.html.page_169">169</a></p>
<p class="index"><b>调试</b>, <a href="#OEBPS/Chapter01.html.page_8">8</a> , <a href="#OEBPS/Chapter01.html.page_29">29</a> , <a href="#OEBPS/Chapter01.html.page_31">31</a> , <a href="#OEBPS/Chapter01.html.page_32">32</a> , <a href="#OEBPS/Chapter01.html.page_43">43</a> , <a href="#OEBPS/Chapter02.html.page_78">78</a> , <a href="#OEBPS/Chapter02.html.page_79">79</a> , <a href="#OEBPS/Chapter02.html.page_86">86</a> , <a href="#OEBPS/Chapter03.html.page_120">120</a> , <a href="#OEBPS/Chapter03.html.page_121">121</a> , <a href="#OEBPS/Chapter04.html.page_151">151</a> , <a href="#OEBPS/Chapter04.html.page_152">152</a> , <a href="#OEBPS/Chapter04.html.page_153">153</a> , <a href="#OEBPS/Chapter05.html.page_183">183</a> , <a href="#OEBPS/Chapter05.html.page_187">187</a> , <a href="#OEBPS/Chapter05.html.page_189">189</a> , <a href="#OEBPS/Chapter05.html.page_190">190</a> , <a href="#OEBPS/Chapter06.html.page_207">207</a> , <a href="#OEBPS/Chapter06.html.page_225">225</a> , <a href="#OEBPS/Chapter06.html.page_226">226</a> , <a href="#OEBPS/Chapter06.html.page_227">227</a> , <a href="#OEBPS/Chapter07.html.page_266">269</a> , <a href="#OEBPS/Chapter07.html.page_268">269</a> , , <a href="#OEBPS/Chapter07.html.page_269">_ </a><a href="#OEBPS/Chapter08.html.page_295">295</a> , <a href="#OEBPS/Chapter08.html.page_300">300</a> , <a href="#OEBPS/Chapter08.html.page_312">312</a>，<a href="#OEBPS/Chapter08.html.page_313">313、314、315、335、337、342、362、364、364、365、366、367、388、395、397、397、399、404、404、405、406、452、452、453、460</a> _ <a href="#OEBPS/Chapter08.html.page_314">_</a> _ <a href="#OEBPS/Chapter08.html.page_315">_</a> _ <a href="#OEBPS/Chapter09.html.page_335">_</a> _ <a href="#OEBPS/Chapter09.html.page_337">_</a> _ <a href="#OEBPS/Chapter09.html.page_342">_</a> _ <a href="#OEBPS/Chapter09.html.page_362">_</a> _ <a href="#OEBPS/Chapter09.html.page_364">_</a> _ <a href="#OEBPS/Chapter09.html.page_365">_</a> _ <a href="#OEBPS/Chapter09.html.page_366">_</a> _ <a href="#OEBPS/Chapter09.html.page_367">_</a> _ <a href="#OEBPS/Chapter09.html.page_368">_</a> _ <a href="#OEBPS/Chapter10.html.page_388">_</a> _ <a href="#OEBPS/Chapter10.html.page_395">_</a> _ <a href="#OEBPS/Chapter10.html.page_397">_</a> _ <a href="#OEBPS/Chapter10.html.page_399">_</a> _ <a href="#OEBPS/Chapter10.html.page_404">_</a> _ <a href="#OEBPS/Chapter10.html.page_405">_</a> _ <a href="#OEBPS/Chapter10.html.page_406">_</a> _ <a href="#OEBPS/Chapter12.html.page_452">_</a> _ <a href="#OEBPS/Chapter12.html.page_453">_</a> _ <a href="#OEBPS/Chapter12.html.page_460">_</a> _ <a href="#OEBPS/Chapter12.html.page_465">_</a> _ <a href="#OEBPS/Chapter12.html.page_466">_</a> _ <a href="#OEBPS/Chapter12.html.page_468">_</a> , <a href="#OEBPS/Chapter12.html.page_470">470</a> , <a href="#OEBPS/Chapter12.html.page_477">477</a> ,<a href="#OEBPS/Chapter12.html.page_481">481</a> , <a href="#OEBPS/Chapter13.html.page_488">488</a> , <a href="#OEBPS/Chapter13.html.page_489">489</a> , <a href="#OEBPS/Chapter13.html.page_514">514</a> , <a href="#OEBPS/Chapter14.html.page_520">520</a> , <a href="#OEBPS/Chapter14.html.page_524">524</a> , <a href="#OEBPS/Chapter14.html.page_533">533</a> , <a href="#OEBPS/Chapter14.html.page_535">535</a> , <a href="#OEBPS/Chapter14.html.page_537">537</a> , <a href="#OEBPS/Chapter14.html.page_546">546</a> , <a href="#OEBPS/Chapter14.html.page_547">547</a> , <a href="#OEBPS/Chapter15.html.page_570">570</a> , <a href="#OEBPS/Chapter15.html.page_586">586</a> , <a href="#OEBPS/Chapter15.html.page_588">588</a> , <a href="#OEBPS/Chapter15.html.page_589">589</a> , <a href="#OEBPS/Chapter15.html.page_590">590</a></p><p class="index"><b>debugging</b>, <a href="#OEBPS/Chapter01.html.page_8">8</a>, <a href="#OEBPS/Chapter01.html.page_29">29</a>, <a href="#OEBPS/Chapter01.html.page_31">31</a>, <a href="#OEBPS/Chapter01.html.page_32">32</a>, <a href="#OEBPS/Chapter01.html.page_43">43</a>, <a href="#OEBPS/Chapter02.html.page_78">78</a>, <a href="#OEBPS/Chapter02.html.page_79">79</a>, <a href="#OEBPS/Chapter02.html.page_86">86</a>, <a href="#OEBPS/Chapter03.html.page_120">120</a>, <a href="#OEBPS/Chapter03.html.page_121">121</a>, <a href="#OEBPS/Chapter04.html.page_151">151</a>, <a href="#OEBPS/Chapter04.html.page_152">152</a>, <a href="#OEBPS/Chapter04.html.page_153">153</a>, <a href="#OEBPS/Chapter05.html.page_183">183</a>, <a href="#OEBPS/Chapter05.html.page_187">187</a>, <a href="#OEBPS/Chapter05.html.page_189">189</a>, <a href="#OEBPS/Chapter05.html.page_190">190</a>, <a href="#OEBPS/Chapter06.html.page_207">207</a>, <a href="#OEBPS/Chapter06.html.page_225">225</a>, <a href="#OEBPS/Chapter06.html.page_226">226</a>, <a href="#OEBPS/Chapter06.html.page_227">227</a>, <a href="#OEBPS/Chapter07.html.page_266">266</a>, <a href="#OEBPS/Chapter07.html.page_268">268</a>, <a href="#OEBPS/Chapter07.html.page_269">269</a>, <a href="#OEBPS/Chapter08.html.page_295">295</a>, <a href="#OEBPS/Chapter08.html.page_300">300</a>, <a href="#OEBPS/Chapter08.html.page_312">312</a>, <a href="#OEBPS/Chapter08.html.page_313">313</a>, <a href="#OEBPS/Chapter08.html.page_314">314</a>, <a href="#OEBPS/Chapter08.html.page_315">315</a>, <a href="#OEBPS/Chapter09.html.page_335">335</a>, <a href="#OEBPS/Chapter09.html.page_337">337</a>, <a href="#OEBPS/Chapter09.html.page_342">342</a>, <a href="#OEBPS/Chapter09.html.page_362">362</a>, <a href="#OEBPS/Chapter09.html.page_364">364</a>, <a href="#OEBPS/Chapter09.html.page_365">365</a>, <a href="#OEBPS/Chapter09.html.page_366">366</a>, <a href="#OEBPS/Chapter09.html.page_367">367</a>, <a href="#OEBPS/Chapter09.html.page_368">368</a>, <a href="#OEBPS/Chapter10.html.page_388">388</a>, <a href="#OEBPS/Chapter10.html.page_395">395</a>, <a href="#OEBPS/Chapter10.html.page_397">397</a>, <a href="#OEBPS/Chapter10.html.page_399">399</a>, <a href="#OEBPS/Chapter10.html.page_404">404</a>, <a href="#OEBPS/Chapter10.html.page_405">405</a>, <a href="#OEBPS/Chapter10.html.page_406">406</a>, <a href="#OEBPS/Chapter12.html.page_452">452</a>, <a href="#OEBPS/Chapter12.html.page_453">453</a>, <a href="#OEBPS/Chapter12.html.page_460">460</a>, <a href="#OEBPS/Chapter12.html.page_465">465</a>, <a href="#OEBPS/Chapter12.html.page_466">466</a>, <a href="#OEBPS/Chapter12.html.page_468">468</a>, <a href="#OEBPS/Chapter12.html.page_470">470</a>, <a href="#OEBPS/Chapter12.html.page_477">477</a>, <a href="#OEBPS/Chapter12.html.page_481">481</a>, <a href="#OEBPS/Chapter13.html.page_488">488</a>, <a href="#OEBPS/Chapter13.html.page_489">489</a>, <a href="#OEBPS/Chapter13.html.page_514">514</a>, <a href="#OEBPS/Chapter14.html.page_520">520</a>, <a href="#OEBPS/Chapter14.html.page_524">524</a>, <a href="#OEBPS/Chapter14.html.page_533">533</a>, <a href="#OEBPS/Chapter14.html.page_535">535</a>, <a href="#OEBPS/Chapter14.html.page_537">537</a>, <a href="#OEBPS/Chapter14.html.page_546">546</a>, <a href="#OEBPS/Chapter14.html.page_547">547</a>, <a href="#OEBPS/Chapter15.html.page_570">570</a>, <a href="#OEBPS/Chapter15.html.page_586">586</a>, <a href="#OEBPS/Chapter15.html.page_588">588</a>, <a href="#OEBPS/Chapter15.html.page_589">589</a>, <a href="#OEBPS/Chapter15.html.page_590">590</a></p>
<p class="index"><b>十二月</b>, <a href="#OEBPS/Chapter09.html.page_327">327</a> , <a href="#OEBPS/Chapter09.html.page_331">331</a> , <a href="#OEBPS/Chapter09.html.page_354">354</a></p><p class="index"><b>DEC</b>, <a href="#OEBPS/Chapter09.html.page_327">327</a>, <a href="#OEBPS/Chapter09.html.page_331">331</a>, <a href="#OEBPS/Chapter09.html.page_354">354</a></p>
<p class="index"><b>设计审查</b>, <a href="#OEBPS/Chapter14.html.page_538">538</a> , <a href="#OEBPS/Chapter14.html.page_540">540</a></p><p class="index"><b>design reviews</b>, <a href="#OEBPS/Chapter14.html.page_538">538</a>, <a href="#OEBPS/Chapter14.html.page_540">540</a></p>
<p class="index"><b><i>设计软件</i></b>,<a href="#OEBPS/Chapter09.html.page_326"> 326</a> ,<a href="#OEBPS/Chapter09.html.page_340"> 340</a> ,<a href="#OEBPS/Chapter12.html.page_458"> 458</a></p><p class="index"><b><i>designing software</i></b>, <a href="#OEBPS/Chapter09.html.page_326">326</a>, <a href="#OEBPS/Chapter09.html.page_340">340</a>, <a href="#OEBPS/Chapter12.html.page_458">458</a></p>
<p class="index"><b><i>Deutsch, L. Peter</i></b> ,<a href="#OEBPS/Chapter10.html.page_373"> 373</a> ,<a href="#OEBPS/Chapter10.html.page_387"> 387</a></p><p class="index"><b><i>Deutsch, L. Peter</i></b>, <a href="#OEBPS/Chapter10.html.page_373">373</a>, <a href="#OEBPS/Chapter10.html.page_387">387</a></p>
<p class="index"><b>开发团队</b>, <a href="#OEBPS/Chapter01.html.page_37">37</a> , <a href="#OEBPS/Chapter01.html.page_38">38</a></p><p class="index"><b>development teams</b>, <a href="#OEBPS/Chapter01.html.page_37">37</a>, <a href="#OEBPS/Chapter01.html.page_38">38</a></p>
<p class="index"><b>迪亚斯，约翰</b>，<a href="#OEBPS/Chapter07.html.page_265">265</a></p><p class="index"><b>Dias, John</b>, <a href="#OEBPS/Chapter07.html.page_265">265</a></p>
<p class="index"><b>迪克斯特拉</b>, <a href="#OEBPS/Chapter03.html.page_124">124</a> , <a href="#OEBPS/Chapter15.html.page_565">565</a> , <a href="#OEBPS/Chapter15.html.page_567">567</a> , <a href="#OEBPS/Chapter15.html.page_582">582</a> , <a href="#OEBPS/Chapter15.html.page_584">584</a> , <a href="#OEBPS/Chapter15.html.page_590">590</a> , <a href="#OEBPS/Chapter15.html.page_600">600</a></p><p class="index"><b>Dijkstra</b>, <a href="#OEBPS/Chapter03.html.page_124">124</a>, <a href="#OEBPS/Chapter15.html.page_565">565</a>, <a href="#OEBPS/Chapter15.html.page_567">567</a>, <a href="#OEBPS/Chapter15.html.page_582">582</a>, <a href="#OEBPS/Chapter15.html.page_584">584</a>, <a href="#OEBPS/Chapter15.html.page_590">590</a>, <a href="#OEBPS/Chapter15.html.page_600">600</a></p>
<p class="index"><b>医生</b>, <a href="#OEBPS/Chapter14.html.page_537">537</a> , <a href="#OEBPS/Chapter14.html.page_540">540</a> , <a href="#OEBPS/Chapter14.html.page_541">541</a></p><p class="index"><b>Doctor</b>, <a href="#OEBPS/Chapter14.html.page_537">537</a>, <a href="#OEBPS/Chapter14.html.page_540">540</a>, <a href="#OEBPS/Chapter14.html.page_541">541</a></p>
<p class="index"><b><i>医生</i></b>,<a href="#OEBPS/Chapter14.html.page_519"> 519</a></p><p class="index"><b><i>DOCTOR</i></b>, <a href="#OEBPS/Chapter14.html.page_519">519</a></p>
<p class="index"><b>文档</b>, <a href="#OEBPS/Chapter01.html.page_7">7</a> , <a href="#OEBPS/Chapter05.html.page_179">179</a> , <a href="#OEBPS/Chapter05.html.page_181">181</a> , <a href="#OEBPS/Chapter05.html.page_196">196</a> , <a href="#OEBPS/Chapter06.html.page_230">230</a> , <a href="#OEBPS/Chapter06.html.page_231">231</a> , <a href="#OEBPS/Chapter06.html.page_232">232</a> , <a href="#OEBPS/Chapter12.html.page_461">461</a></p><p class="index"><b>documentation</b>, <a href="#OEBPS/Chapter01.html.page_7">7</a>, <a href="#OEBPS/Chapter05.html.page_179">179</a>, <a href="#OEBPS/Chapter05.html.page_181">181</a>, <a href="#OEBPS/Chapter05.html.page_196">196</a>, <a href="#OEBPS/Chapter06.html.page_230">230</a>, <a href="#OEBPS/Chapter06.html.page_231">231</a>, <a href="#OEBPS/Chapter06.html.page_232">232</a>, <a href="#OEBPS/Chapter12.html.page_461">461</a></p>
<p class="index"><b>记录</b>, <a href="#OEBPS/Chapter12.html.page_461">461</a> , <a href="#OEBPS/Chapter12.html.page_464">464</a></p><p class="index"><b>documenting</b>, <a href="#OEBPS/Chapter12.html.page_461">461</a>, <a href="#OEBPS/Chapter12.html.page_464">464</a></p>
<p class="index"><b>动态语言</b>, <a href="#OEBPS/Chapter04.html.page_139">139</a></p><p class="index"><b>dynamic languages</b>, <a href="#OEBPS/Chapter04.html.page_139">139</a></p>
<h3 class="h3">乙</h3><h3 class="h3">E</h3>
<p class="index"><b>乙</b>, <a href="#OEBPS/Chapter03.html.page_95">95</a> , <a href="#OEBPS/Chapter03.html.page_96">96</a></p><p class="index"><b>E</b>, <a href="#OEBPS/Chapter03.html.page_95">95</a>, <a href="#OEBPS/Chapter03.html.page_96">96</a></p>
<p class="index"><b><i>ECMA脚本</i></b>,<a href="#OEBPS/Chapter09.html.page_325"> 325</a> ,<a href="#OEBPS/Chapter09.html.page_351"> 351</a></p><p class="index"><b><i>ECMAScript</i></b>, <a href="#OEBPS/Chapter09.html.page_325">325</a>, <a href="#OEBPS/Chapter09.html.page_351">351</a></p>
<p class="index"><b>ECMA脚本 3</b> , <a href="#OEBPS/Chapter04.html.page_142">142</a></p><p class="index"><b>ECMAScript 3</b>, <a href="#OEBPS/Chapter04.html.page_142">142</a></p>
<p class="index"><b><i>ECMAScript</i></b><a href="#OEBPS/Chapter03.html.page_91"> 4、91、96、134、142</a> __<a href="#OEBPS/Chapter03.html.page_96"> _</a> _<a href="#OEBPS/Chapter04.html.page_134"> _</a> _<a href="#OEBPS/Chapter04.html.page_142"> _</a></p><p class="index"><b><i>ECMAScript 4</i></b>, <a href="#OEBPS/Chapter03.html.page_91">91</a>, <a href="#OEBPS/Chapter03.html.page_96">96</a>, <a href="#OEBPS/Chapter04.html.page_134">134</a>, <a href="#OEBPS/Chapter04.html.page_142">142</a></p>
<p class="index"><b><i>ECMAScript 4 (ES4)</i></b> ,<a href="#OEBPS/Chapter03.html.page_91"> 91</a></p><p class="index"><b><i>ECMAScript 4 (ES4)</i></b>, <a href="#OEBPS/Chapter03.html.page_91">91</a></p>
<p class="index"><b>布伦丹·艾奇</b>，<a href="#OEBPS/Chapter03.html.page_99">99岁</a></p><p class="index"><b>Eich, Brendan</b>, <a href="#OEBPS/Chapter03.html.page_99">99</a></p>
<p class="index"><b>埃菲尔铁塔</b>, <a href="#OEBPS/Chapter03.html.page_121">121</a></p><p class="index"><b>Eiffel</b>, <a href="#OEBPS/Chapter03.html.page_121">121</a></p>
<p class="index"><b><i>EISCAT 科学协会</i></b>,<a href="#OEBPS/Chapter06.html.page_206"> 206</a> ,<a href="#OEBPS/Chapter06.html.page_209"> 209</a></p><p class="index"><b><i>EISCAT scientific association</i></b>, <a href="#OEBPS/Chapter06.html.page_206">206</a>, <a href="#OEBPS/Chapter06.html.page_209">209</a></p>
<p class="index"><b><i>电气社区</i></b>,<a href="#OEBPS/Chapter03.html.page_91"> 91</a> ,<a href="#OEBPS/Chapter03.html.page_95"> 95</a> ,<a href="#OEBPS/Chapter03.html.page_96"> 96</a> ,<a href="#OEBPS/Chapter03.html.page_112"> 112</a></p><p class="index"><b><i>Electric Communities</i></b>, <a href="#OEBPS/Chapter03.html.page_91">91</a>, <a href="#OEBPS/Chapter03.html.page_95">95</a>, <a href="#OEBPS/Chapter03.html.page_96">96</a>, <a href="#OEBPS/Chapter03.html.page_112">112</a></p>
<p class="index"><b><i>伊丽莎</i></b>,<a href="#OEBPS/Chapter14.html.page_519"> 519</a> ,<a href="#OEBPS/Chapter14.html.page_540"> 540</a> ,<a href="#OEBPS/Chapter14.html.page_541"> 541</a></p><p class="index"><b><i>ELIZA</i></b>, <a href="#OEBPS/Chapter14.html.page_519">519</a>, <a href="#OEBPS/Chapter14.html.page_540">540</a>, <a href="#OEBPS/Chapter14.html.page_541">541</a></p>
<p class="index"><b>埃尔金德，杰里</b>，<a href="#OEBPS/Chapter11.html.page_430">430</a></p><p class="index"><b>Elkind, Jerry</b>, <a href="#OEBPS/Chapter11.html.page_430">430</a></p>
<p class="index"><b>Emacs</b> , <a href="#OEBPS/Chapter01.html.page_9">9</a> , <a href="#OEBPS/Chapter01.html.page_13">13</a> , <a href="#OEBPS/Chapter01.html.page_35">35</a> , <a href="#OEBPS/Chapter01.html.page_36">36</a> , <a href="#OEBPS/Chapter01.html.page_39">39</a> , <a href="#OEBPS/Chapter02.html.page_85">85</a> , <a href="#OEBPS/Chapter07.html.page_266">266</a> , <a href="#OEBPS/Chapter09.html.page_325">325</a> , <a href="#OEBPS/Chapter09.html.page_335">335</a> , <a href="#OEBPS/Chapter09.html.page_344">344</a> , <a href="#OEBPS/Chapter09.html.page_345">345</a> , <a href="#OEBPS/Chapter09.html.page_346">346</a> , <a href="#OEBPS/Chapter09.html.page_347">347</a> , <a href="#OEBPS/Chapter09.html.page_354">354</a> , <a href="#OEBPS/Chapter11.html.page_419">419</a> , <a href="#OEBPS/Chapter11.html.page_440">440</a> , <a href="#OEBPS/Chapter14.html.page_541">541</a> , <a href="#OEBPS/Chapter14.html.page_556">556</a></p><p class="index"><b>Emacs</b>, <a href="#OEBPS/Chapter01.html.page_9">9</a>, <a href="#OEBPS/Chapter01.html.page_13">13</a>, <a href="#OEBPS/Chapter01.html.page_35">35</a>, <a href="#OEBPS/Chapter01.html.page_36">36</a>, <a href="#OEBPS/Chapter01.html.page_39">39</a>, <a href="#OEBPS/Chapter02.html.page_85">85</a>, <a href="#OEBPS/Chapter07.html.page_266">266</a>, <a href="#OEBPS/Chapter09.html.page_325">325</a>, <a href="#OEBPS/Chapter09.html.page_335">335</a>, <a href="#OEBPS/Chapter09.html.page_344">344</a>, <a href="#OEBPS/Chapter09.html.page_345">345</a>, <a href="#OEBPS/Chapter09.html.page_346">346</a>, <a href="#OEBPS/Chapter09.html.page_347">347</a>, <a href="#OEBPS/Chapter09.html.page_354">354</a>, <a href="#OEBPS/Chapter11.html.page_419">419</a>, <a href="#OEBPS/Chapter11.html.page_440">440</a>, <a href="#OEBPS/Chapter14.html.page_541">541</a>, <a href="#OEBPS/Chapter14.html.page_556">556</a></p>
<p class="index"><b>Emacs Lisp</b> , <a href="#OEBPS/Chapter01.html.page_12">12</a></p><p class="index"><b>Emacs Lisp</b>, <a href="#OEBPS/Chapter01.html.page_12">12</a></p>
<p class="index"><b><i>恩西纳</i></b>,<a href="#OEBPS/Chapter05.html.page_167"> 167</a></p><p class="index"><b><i>Encina</i></b>, <a href="#OEBPS/Chapter05.html.page_167">167</a></p>
<p class="index"><b>充满活力</b>, <a href="#OEBPS/Chapter01.html.page_9">9</a> , <a href="#OEBPS/Chapter01.html.page_30">30</a></p><p class="index"><b>Energize</b>, <a href="#OEBPS/Chapter01.html.page_9">9</a>, <a href="#OEBPS/Chapter01.html.page_30">30</a></p>
<p class="index"><b>激励团队</b>, <a href="#OEBPS/Chapter01.html.page_13">13</a></p><p class="index"><b>Energize team</b>, <a href="#OEBPS/Chapter01.html.page_13">13</a></p>
<p class="index"><b>埃尼亚克</b>, <a href="#OEBPS/Chapter13.html.page_504">504</a> , <a href="#OEBPS/Chapter13.html.page_506">506</a> , <a href="#OEBPS/Chapter13.html.page_511">511</a></p><p class="index"><b>ENIAC</b>, <a href="#OEBPS/Chapter13.html.page_504">504</a>, <a href="#OEBPS/Chapter13.html.page_506">506</a>, <a href="#OEBPS/Chapter13.html.page_511">511</a></p>
<p class="index"><b><i>爱立信</i></b>,<a href="#OEBPS/Chapter06.html.page_205"> 205</a> ,<a href="#OEBPS/Chapter06.html.page_206"> 206</a> ,<a href="#OEBPS/Chapter06.html.page_220"> 220</a> ,<a href="#OEBPS/Chapter06.html.page_221"> 221</a></p><p class="index"><b><i>Ericsson</i></b>, <a href="#OEBPS/Chapter06.html.page_205">205</a>, <a href="#OEBPS/Chapter06.html.page_206">206</a>, <a href="#OEBPS/Chapter06.html.page_220">220</a>, <a href="#OEBPS/Chapter06.html.page_221">221</a></p>
<p class="index"><b><i>二郎</i></b>,<a href="#OEBPS/Chapter06.html.page_205"> 205</a> ,<a href="#OEBPS/Chapter06.html.page_206"> 206</a> ,<a href="#OEBPS/Chapter06.html.page_211"> 211</a> ,<a href="#OEBPS/Chapter06.html.page_212"> 212</a> ,<a href="#OEBPS/Chapter06.html.page_214"> 214</a> ,<a href="#OEBPS/Chapter06.html.page_218"> 218</a> ,<a href="#OEBPS/Chapter06.html.page_219"> 219</a> ,<a href="#OEBPS/Chapter06.html.page_221"> 221</a> ,<a href="#OEBPS/Chapter06.html.page_222"> 222</a> ,<a href="#OEBPS/Chapter06.html.page_223"> 223</a> ,<a href="#OEBPS/Chapter06.html.page_224"> 224</a> ,<a href="#OEBPS/Chapter06.html.page_225"> 225</a> ,<a href="#OEBPS/Chapter06.html.page_226"> 226</a> ,<a href="#OEBPS/Chapter06.html.page_228"> 228</a> ,<a href="#OEBPS/Chapter06.html.page_232"> 232</a> ,<a href="#OEBPS/Chapter06.html.page_233"> 233</a> ,<a href="#OEBPS/Chapter06.html.page_235"> 235</a> ,<a href="#OEBPS/Chapter06.html.page_236"> 236</a> ,<a href="#OEBPS/Chapter06.html.page_237"> 237</a> ,<a href="#OEBPS/Chapter06.html.page_238"> 238</a> ,<a href="#OEBPS/Chapter06.html.page_239"> 23</a> ,<a href="#OEBPS/Chapter07.html.page_263"> 23</a></p><p class="index"><b><i>Erlang</i></b>, <a href="#OEBPS/Chapter06.html.page_205">205</a>, <a href="#OEBPS/Chapter06.html.page_206">206</a>, <a href="#OEBPS/Chapter06.html.page_211">211</a>, <a href="#OEBPS/Chapter06.html.page_212">212</a>, <a href="#OEBPS/Chapter06.html.page_214">214</a>, <a href="#OEBPS/Chapter06.html.page_218">218</a>, <a href="#OEBPS/Chapter06.html.page_219">219</a>, <a href="#OEBPS/Chapter06.html.page_221">221</a>, <a href="#OEBPS/Chapter06.html.page_222">222</a>, <a href="#OEBPS/Chapter06.html.page_223">223</a>, <a href="#OEBPS/Chapter06.html.page_224">224</a>, <a href="#OEBPS/Chapter06.html.page_225">225</a>, <a href="#OEBPS/Chapter06.html.page_226">226</a>, <a href="#OEBPS/Chapter06.html.page_228">228</a>, <a href="#OEBPS/Chapter06.html.page_232">232</a>, <a href="#OEBPS/Chapter06.html.page_233">233</a>, <a href="#OEBPS/Chapter06.html.page_235">235</a>, <a href="#OEBPS/Chapter06.html.page_236">236</a>, <a href="#OEBPS/Chapter06.html.page_237">237</a>, <a href="#OEBPS/Chapter06.html.page_238">238</a>, <a href="#OEBPS/Chapter06.html.page_239">239</a>, <a href="#OEBPS/Chapter07.html.page_263">263</a></p>
<p class="index"><b><i>ES3</i></b> ,<a href="#OEBPS/Chapter03.html.page_91"> 91</a> ,<a href="#OEBPS/Chapter03.html.page_96"> 96</a> ,<a href="#OEBPS/Chapter03.html.page_100"> 100</a> ,<a href="#OEBPS/Chapter04.html.page_146"> 146</a> ,<a href="#OEBPS/Chapter09.html.page_351"> 351</a></p><p class="index"><b><i>ES3</i></b>, <a href="#OEBPS/Chapter03.html.page_91">91</a>, <a href="#OEBPS/Chapter03.html.page_96">96</a>, <a href="#OEBPS/Chapter03.html.page_100">100</a>, <a href="#OEBPS/Chapter04.html.page_146">146</a>, <a href="#OEBPS/Chapter09.html.page_351">351</a></p>
<p class="index"><b><i>ES4</i></b> ,<a href="#OEBPS/Chapter03.html.page_91"> 91</a> ,<a href="#OEBPS/Chapter03.html.page_92"> 92</a> ,<a href="#OEBPS/Chapter03.html.page_99"> 99</a> ,<a href="#OEBPS/Chapter03.html.page_100"> 100</a> ,<a href="#OEBPS/Chapter04.html.page_143"> 143</a> ,<a href="#OEBPS/Chapter04.html.page_146"> 146</a> ,<a href="#OEBPS/Chapter04.html.page_157"> 157</a> ,<a href="#OEBPS/Chapter09.html.page_351"> 351</a></p><p class="index"><b><i>ES4</i></b>, <a href="#OEBPS/Chapter03.html.page_91">91</a>, <a href="#OEBPS/Chapter03.html.page_92">92</a>, <a href="#OEBPS/Chapter03.html.page_99">99</a>, <a href="#OEBPS/Chapter03.html.page_100">100</a>, <a href="#OEBPS/Chapter04.html.page_143">143</a>, <a href="#OEBPS/Chapter04.html.page_146">146</a>, <a href="#OEBPS/Chapter04.html.page_157">157</a>, <a href="#OEBPS/Chapter09.html.page_351">351</a></p>
<p class="index"><b><i>ES5</i></b> ,<a href="#OEBPS/Chapter03.html.page_92"> 92</a></p><p class="index"><b><i>ES5</i></b>, <a href="#OEBPS/Chapter03.html.page_92">92</a></p>
<p class="index"><b>道德责任</b>, <a href="#OEBPS/Chapter02.html.page_88">88</a></p><p class="index"><b>ethical responsibilities</b>, <a href="#OEBPS/Chapter02.html.page_88">88</a></p>
<p class="index"><b>电子玩具</b>, <a href="#OEBPS/Chapter10.html.page_382">382</a> , <a href="#OEBPS/Chapter10.html.page_392">392</a></p><p class="index"><b>eToys</b>, <a href="#OEBPS/Chapter10.html.page_382">382</a>, <a href="#OEBPS/Chapter10.html.page_392">392</a></p>
<p class="index"><b>专家技术 (ETI)</b> , <a href="#OEBPS/Chapter01.html.page_4">4</a> , <a href="#OEBPS/Chapter01.html.page_5">5</a></p><p class="index"><b>Expert Technologies (ETI)</b>, <a href="#OEBPS/Chapter01.html.page_4">4</a>, <a href="#OEBPS/Chapter01.html.page_5">5</a></p>
<p class="index"><b>显式内存管理与垃圾回收</b>，<a href="#OEBPS/Chapter02.html.page_64">64</a></p><p class="index"><b>explicit memory management versus garbage collection</b>, <a href="#OEBPS/Chapter02.html.page_64">64</a></p>
<h3 class="h3">F</h3><h3 class="h3">F</h3>
<p class="index"><b>法尔曼</b>,<b>斯科特</b>, <a href="#OEBPS/Chapter01.html.page_3">3</a> , <a href="#OEBPS/Chapter01.html.page_4">4</a></p><p class="index"><b>Fahlman</b>, <b>Scott</b>, <a href="#OEBPS/Chapter01.html.page_3">3</a>, <a href="#OEBPS/Chapter01.html.page_4">4</a></p>
<p class="index"><b>快速GCI</b> , <a href="#OEBPS/Chapter02.html.page_58">58</a></p><p class="index"><b>FastGCI</b>, <a href="#OEBPS/Chapter02.html.page_58">58</a></p>
<p class="index"><b>特征收敛</b>, <a href="#OEBPS/Chapter03.html.page_102">102</a></p><p class="index"><b>feature convergence</b>, <a href="#OEBPS/Chapter03.html.page_102">102</a></p>
<p class="index"><b><i>火狐</i></b>,<a href="#OEBPS/Chapter04.html.page_133"> 133</a> ,<a href="#OEBPS/Chapter04.html.page_138"> 138</a></p><p class="index"><b><i>Firefox</i></b>, <a href="#OEBPS/Chapter04.html.page_133">133</a>, <a href="#OEBPS/Chapter04.html.page_138">138</a></p>
<p class="index"><b>菲茨帕特里克</b>，<b>布拉德</b>，<a href="#OEBPS/Chapter01.html.page_48">48 岁</a></p><p class="index"><b>Fitzpatrick</b>, <b>Brad</b>, <a href="#OEBPS/Chapter01.html.page_48">48</a></p>
<p class="index"><b>Fortran</b> , <a href="#OEBPS/Chapter01.html.page_2">2</a> , <a href="#OEBPS/Chapter03.html.page_91">91</a> , <a href="#OEBPS/Chapter03.html.page_92">92</a> , <a href="#OEBPS/Chapter03.html.page_93">93</a> , <a href="#OEBPS/Chapter03.html.page_104">104</a> , <a href="#OEBPS/Chapter03.html.page_105">105</a> , <a href="#OEBPS/Chapter04.html.page_134">134</a> , <a href="#OEBPS/Chapter05.html.page_168">168</a> , <a href="#OEBPS/Chapter05.html.page_170">170</a> , <a href="#OEBPS/Chapter05.html.page_172">172</a> , <a href="#OEBPS/Chapter06.html.page_206">206</a> , <a href="#OEBPS/Chapter06.html.page_210">210</a> , <a href="#OEBPS/Chapter06.html.page_224">224</a> , <a href="#OEBPS/Chapter06.html.page_226">226</a> , <a href="#OEBPS/Chapter09.html.page_325">325</a> , <a href="#OEBPS/Chapter09.html.page_326">326</a> , <a href="#OEBPS/Chapter09.html.page_327">327</a> , <a href="#OEBPS/Chapter09.html.page_328">328</a> , <a href="#OEBPS/Chapter09.html.page_330">330</a> , <a href="#OEBPS/Chapter09.html.page_352">352</a> , 3 <a href="#OEBPS/Chapter09.html.page_353">7</a> , <a href="#OEBPS/Chapter09.html.page_358">3</a> , <a href="#OEBPS/Chapter10.html.page_373">3</a> , <a href="#OEBPS/Chapter10.html.page_374">3</a> , 3 <a href="#OEBPS/Chapter10.html.page_375">375</a> , <a href="#OEBPS/Chapter10.html.page_376">376</a> , <a href="#OEBPS/Chapter10.html.page_377">377</a>, <a href="#OEBPS/Chapter10.html.page_396">396</a> , <a href="#OEBPS/Chapter10.html.page_398">398</a> , <a href="#OEBPS/Chapter10.html.page_399">399</a> , <a href="#OEBPS/Chapter12.html.page_451">451</a> , <a href="#OEBPS/Chapter12.html.page_455">455</a> , <a href="#OEBPS/Chapter12.html.page_456">456</a> , <a href="#OEBPS/Chapter13.html.page_485">485</a> , <a href="#OEBPS/Chapter13.html.page_487">487</a> , <a href="#OEBPS/Chapter13.html.page_488">488</a> , <a href="#OEBPS/Chapter13.html.page_490">490</a> , <a href="#OEBPS/Chapter13.html.page_491">491</a> , <a href="#OEBPS/Chapter13.html.page_495">495</a> , <a href="#OEBPS/Chapter13.html.page_502">502</a> , <a href="#OEBPS/Chapter14.html.page_521">521</a> , <a href="#OEBPS/Chapter14.html.page_534">534</a> , <a href="#OEBPS/Chapter14.html.page_560">560</a> , <a href="#OEBPS/Chapter15.html.page_577">577</a> , <a href="#OEBPS/Chapter15.html.page_583">583</a> , <a href="#OEBPS/Chapter15.html.page_596">596</a> , <a href="#OEBPS/Chapter15.html.page_600">600</a> , <a href="#OEBPS/Chapter15.html.page_601">601</a></p><p class="index"><b>Fortran</b>, <a href="#OEBPS/Chapter01.html.page_2">2</a>, <a href="#OEBPS/Chapter03.html.page_91">91</a>, <a href="#OEBPS/Chapter03.html.page_92">92</a>, <a href="#OEBPS/Chapter03.html.page_93">93</a>, <a href="#OEBPS/Chapter03.html.page_104">104</a>, <a href="#OEBPS/Chapter03.html.page_105">105</a>, <a href="#OEBPS/Chapter04.html.page_134">134</a>, <a href="#OEBPS/Chapter05.html.page_168">168</a>, <a href="#OEBPS/Chapter05.html.page_170">170</a>, <a href="#OEBPS/Chapter05.html.page_172">172</a>, <a href="#OEBPS/Chapter06.html.page_206">206</a>, <a href="#OEBPS/Chapter06.html.page_210">210</a>, <a href="#OEBPS/Chapter06.html.page_224">224</a>, <a href="#OEBPS/Chapter06.html.page_226">226</a>, <a href="#OEBPS/Chapter09.html.page_325">325</a>, <a href="#OEBPS/Chapter09.html.page_326">326</a>, <a href="#OEBPS/Chapter09.html.page_327">327</a>, <a href="#OEBPS/Chapter09.html.page_328">328</a>, <a href="#OEBPS/Chapter09.html.page_330">330</a>, <a href="#OEBPS/Chapter09.html.page_352">352</a>, <a href="#OEBPS/Chapter09.html.page_353">353</a>, <a href="#OEBPS/Chapter09.html.page_358">358</a>, <a href="#OEBPS/Chapter10.html.page_373">373</a>, <a href="#OEBPS/Chapter10.html.page_374">374</a>, <a href="#OEBPS/Chapter10.html.page_375">375</a>, <a href="#OEBPS/Chapter10.html.page_376">376</a>, <a href="#OEBPS/Chapter10.html.page_377">377</a>, <a href="#OEBPS/Chapter10.html.page_396">396</a>, <a href="#OEBPS/Chapter10.html.page_398">398</a>, <a href="#OEBPS/Chapter10.html.page_399">399</a>, <a href="#OEBPS/Chapter12.html.page_451">451</a>, <a href="#OEBPS/Chapter12.html.page_455">455</a>, <a href="#OEBPS/Chapter12.html.page_456">456</a>, <a href="#OEBPS/Chapter13.html.page_485">485</a>, <a href="#OEBPS/Chapter13.html.page_487">487</a>, <a href="#OEBPS/Chapter13.html.page_488">488</a>, <a href="#OEBPS/Chapter13.html.page_490">490</a>, <a href="#OEBPS/Chapter13.html.page_491">491</a>, <a href="#OEBPS/Chapter13.html.page_495">495</a>, <a href="#OEBPS/Chapter13.html.page_502">502</a>, <a href="#OEBPS/Chapter14.html.page_521">521</a>, <a href="#OEBPS/Chapter14.html.page_534">534</a>, <a href="#OEBPS/Chapter14.html.page_560">560</a>, <a href="#OEBPS/Chapter15.html.page_577">577</a>, <a href="#OEBPS/Chapter15.html.page_583">583</a>, <a href="#OEBPS/Chapter15.html.page_596">596</a>, <a href="#OEBPS/Chapter15.html.page_600">600</a>, <a href="#OEBPS/Chapter15.html.page_601">601</a></p>
<p class="index"><b><i>堡垒</i></b>,<a href="#OEBPS/Chapter09.html.page_325"> 325</a> ,<a href="#OEBPS/Chapter09.html.page_339"> 339</a> ,<a href="#OEBPS/Chapter09.html.page_347"> 347</a> ,<a href="#OEBPS/Chapter09.html.page_350"> 350</a> ,<a href="#OEBPS/Chapter09.html.page_356"> 356</a> ,<a href="#OEBPS/Chapter09.html.page_357"> 357</a> ,<a href="#OEBPS/Chapter09.html.page_358"> 358</a> ,<a href="#OEBPS/Chapter09.html.page_365"> 365</a></p><p class="index"><b><i>Fortress</i></b>, <a href="#OEBPS/Chapter09.html.page_325">325</a>, <a href="#OEBPS/Chapter09.html.page_339">339</a>, <a href="#OEBPS/Chapter09.html.page_347">347</a>, <a href="#OEBPS/Chapter09.html.page_350">350</a>, <a href="#OEBPS/Chapter09.html.page_356">356</a>, <a href="#OEBPS/Chapter09.html.page_357">357</a>, <a href="#OEBPS/Chapter09.html.page_358">358</a>, <a href="#OEBPS/Chapter09.html.page_365">365</a></p>
<p class="index"><b>前向引用</b>, <a href="#OEBPS/Chapter03.html.page_109">109</a></p><p class="index"><b>forward references</b>, <a href="#OEBPS/Chapter03.html.page_109">109</a></p>
<p class="index"><b>自由软件基金会 (FSF)</b> , <a href="#OEBPS/Chapter01.html.page_10">10</a></p><p class="index"><b>Free Software Foundation (FSF)</b>, <a href="#OEBPS/Chapter01.html.page_10">10</a></p>
<p class="index"><b>自由投票</b>, <a href="#OEBPS/Chapter02.html.page_54">54</a></p><p class="index"><b>FreeVote</b>, <a href="#OEBPS/Chapter02.html.page_54">54</a></p>
<p class="index"><b>Fröberg, Magnus</b> , <a href="#OEBPS/Chapter06.html.page_230">230</a></p><p class="index"><b>Fröberg, Magnus</b>, <a href="#OEBPS/Chapter06.html.page_230">230</a></p>
<p class="index"><b>函数式编程</b>, <a href="#OEBPS/Chapter07.html.page_241">241</a> , <a href="#OEBPS/Chapter07.html.page_242">242</a> , <a href="#OEBPS/Chapter07.html.page_250">250</a> , <a href="#OEBPS/Chapter07.html.page_251">251</a> , <a href="#OEBPS/Chapter07.html.page_254">254</a> , <a href="#OEBPS/Chapter07.html.page_255">255</a> , <a href="#OEBPS/Chapter07.html.page_257">257</a> , <a href="#OEBPS/Chapter07.html.page_260">260</a> , <a href="#OEBPS/Chapter07.html.page_266">266</a> , <a href="#OEBPS/Chapter07.html.page_275">275</a> , <a href="#OEBPS/Chapter07.html.page_276">276</a> , <a href="#OEBPS/Chapter07.html.page_278">278</a> , <a href="#OEBPS/Chapter07.html.page_280">280</a></p><p class="index"><b>functional programming</b>, <a href="#OEBPS/Chapter07.html.page_241">241</a>, <a href="#OEBPS/Chapter07.html.page_242">242</a>, <a href="#OEBPS/Chapter07.html.page_250">250</a>, <a href="#OEBPS/Chapter07.html.page_251">251</a>, <a href="#OEBPS/Chapter07.html.page_254">254</a>, <a href="#OEBPS/Chapter07.html.page_255">255</a>, <a href="#OEBPS/Chapter07.html.page_257">257</a>, <a href="#OEBPS/Chapter07.html.page_260">260</a>, <a href="#OEBPS/Chapter07.html.page_266">266</a>, <a href="#OEBPS/Chapter07.html.page_275">275</a>, <a href="#OEBPS/Chapter07.html.page_276">276</a>, <a href="#OEBPS/Chapter07.html.page_278">278</a>, <a href="#OEBPS/Chapter07.html.page_280">280</a></p>
<p class="index"><b>外汇</b>, <a href="#OEBPS/Chapter11.html.page_438">438</a></p><p class="index"><b>FX</b>, <a href="#OEBPS/Chapter11.html.page_438">438</a></p>
<h3 class="h3">G</h3><h3 class="h3">G</h3>
<p class="index"><b>加布里埃尔，迪克</b>，<a href="#OEBPS/Chapter09.html.page_353">353</a></p><p class="index"><b>Gabriel, Dick</b>, <a href="#OEBPS/Chapter09.html.page_353">353</a></p>
<p class="index"><b>加布里埃尔，理查德</b>，<a href="#OEBPS/Chapter12.html.page_462">462</a></p><p class="index"><b>Gabriel, Richard</b>, <a href="#OEBPS/Chapter12.html.page_462">462</a></p>
<p class="index"><b>盖姆</b>，<a href="#OEBPS/Chapter02.html.page_70">70 岁</a></p><p class="index"><b>Gaim</b>, <a href="#OEBPS/Chapter02.html.page_70">70</a></p>
<p class="index"><b>盖茨，比尔</b>，<a href="#OEBPS/Chapter06.html.page_236">236</a></p><p class="index"><b>Gates, Bill</b>, <a href="#OEBPS/Chapter06.html.page_236">236</a></p>
<p class="index"><b>海湾合作委员会</b>, <a href="#OEBPS/Chapter01.html.page_13">13</a> , <a href="#OEBPS/Chapter02.html.page_63">63</a> , <a href="#OEBPS/Chapter02.html.page_80">80</a></p><p class="index"><b>GCC</b>, <a href="#OEBPS/Chapter01.html.page_13">13</a>, <a href="#OEBPS/Chapter02.html.page_63">63</a>, <a href="#OEBPS/Chapter02.html.page_80">80</a></p>
<p class="index"><b>GDB</b> , <a href="#OEBPS/Chapter01.html.page_8">8</a> , <a href="#OEBPS/Chapter01.html.page_9">9</a> , <a href="#OEBPS/Chapter01.html.page_13">13</a> , <a href="#OEBPS/Chapter01.html.page_30">30</a> , <a href="#OEBPS/Chapter15.html.page_589">589</a></p><p class="index"><b>GDB</b>, <a href="#OEBPS/Chapter01.html.page_8">8</a>, <a href="#OEBPS/Chapter01.html.page_9">9</a>, <a href="#OEBPS/Chapter01.html.page_13">13</a>, <a href="#OEBPS/Chapter01.html.page_30">30</a>, <a href="#OEBPS/Chapter15.html.page_589">589</a></p>
<p class="index"><b>仿制药</b>, <a href="#OEBPS/Chapter05.html.page_191">191</a> , <a href="#OEBPS/Chapter05.html.page_192">192</a> , <a href="#OEBPS/Chapter05.html.page_193">193</a> , <a href="#OEBPS/Chapter05.html.page_194">194</a></p><p class="index"><b>generics</b>, <a href="#OEBPS/Chapter05.html.page_191">191</a>, <a href="#OEBPS/Chapter05.html.page_192">192</a>, <a href="#OEBPS/Chapter05.html.page_193">193</a>, <a href="#OEBPS/Chapter05.html.page_194">194</a></p>
<p class="index"><b>GHC</b> , <a href="#OEBPS/Chapter07.html.page_241">241</a> , <a href="#OEBPS/Chapter07.html.page_261">261</a> , <a href="#OEBPS/Chapter07.html.page_262">262</a> , <a href="#OEBPS/Chapter07.html.page_264">264</a> , <a href="#OEBPS/Chapter07.html.page_265">265</a> , <a href="#OEBPS/Chapter07.html.page_266">266</a> , <a href="#OEBPS/Chapter07.html.page_267">267</a> , <a href="#OEBPS/Chapter07.html.page_268">268</a> , <a href="#OEBPS/Chapter07.html.page_269">269</a> , <a href="#OEBPS/Chapter07.html.page_278">278</a> , <a href="#OEBPS/Chapter07.html.page_279">279</a> , <a href="#OEBPS/Chapter07.html.page_280">280</a> , <a href="#OEBPS/Chapter07.html.page_284">284</a> , <a href="#OEBPS/Chapter07.html.page_285">285</a></p><p class="index"><b>GHC</b>, <a href="#OEBPS/Chapter07.html.page_241">241</a>, <a href="#OEBPS/Chapter07.html.page_261">261</a>, <a href="#OEBPS/Chapter07.html.page_262">262</a>, <a href="#OEBPS/Chapter07.html.page_264">264</a>, <a href="#OEBPS/Chapter07.html.page_265">265</a>, <a href="#OEBPS/Chapter07.html.page_266">266</a>, <a href="#OEBPS/Chapter07.html.page_267">267</a>, <a href="#OEBPS/Chapter07.html.page_268">268</a>, <a href="#OEBPS/Chapter07.html.page_269">269</a>, <a href="#OEBPS/Chapter07.html.page_278">278</a>, <a href="#OEBPS/Chapter07.html.page_279">279</a>, <a href="#OEBPS/Chapter07.html.page_280">280</a>, <a href="#OEBPS/Chapter07.html.page_284">284</a>, <a href="#OEBPS/Chapter07.html.page_285">285</a></p>
<p class="index"><b>人机交互</b>, <a href="#OEBPS/Chapter07.html.page_267">267</a></p><p class="index"><b>GHCI</b>, <a href="#OEBPS/Chapter07.html.page_267">267</a></p>
<p class="index"><b><i>Ghostscript</i></b> ,<a href="#OEBPS/Chapter11.html.page_413"> 413</a> ,<a href="#OEBPS/Chapter11.html.page_414"> 414</a> ,<a href="#OEBPS/Chapter11.html.page_418"> 418</a> ,<a href="#OEBPS/Chapter11.html.page_420"> 420</a> ,<a href="#OEBPS/Chapter11.html.page_427"> 427</a> ,<a href="#OEBPS/Chapter11.html.page_432"> 432</a> ,<a href="#OEBPS/Chapter11.html.page_433"> 433</a> ,<a href="#OEBPS/Chapter11.html.page_444"> 444</a> ,<a href="#OEBPS/Chapter11.html.page_445"> 445</a></p><p class="index"><b><i>Ghostscript</i></b>, <a href="#OEBPS/Chapter11.html.page_413">413</a>, <a href="#OEBPS/Chapter11.html.page_414">414</a>, <a href="#OEBPS/Chapter11.html.page_418">418</a>, <a href="#OEBPS/Chapter11.html.page_420">420</a>, <a href="#OEBPS/Chapter11.html.page_427">427</a>, <a href="#OEBPS/Chapter11.html.page_432">432</a>, <a href="#OEBPS/Chapter11.html.page_433">433</a>, <a href="#OEBPS/Chapter11.html.page_444">444</a>, <a href="#OEBPS/Chapter11.html.page_445">445</a></p>
<p class="index"><b>乔治·吉尔德</b>，<a href="#OEBPS/Chapter04.html.page_137">137 岁</a></p><p class="index"><b>Gilder, George</b>, <a href="#OEBPS/Chapter04.html.page_137">137</a></p>
<p class="index"><b><i>格拉斯哥 Haskell 编译器 (GHC)</i></b>，<a href="#OEBPS/Chapter07.html.page_241"> 241</a></p><p class="index"><b><i>Glasgow Haskell Compiler (GHC)</i></b>, <a href="#OEBPS/Chapter07.html.page_241">241</a></p>
<p class="index"><b><i>肾上腺素</i></b>,<a href="#OEBPS/Chapter09.html.page_325"> 325</a> ,<a href="#OEBPS/Chapter09.html.page_353"> 353</a></p><p class="index"><b><i>GNAL</i></b>, <a href="#OEBPS/Chapter09.html.page_325">325</a>, <a href="#OEBPS/Chapter09.html.page_353">353</a></p>
<p class="index"><b>戈茨，布赖恩</b>，<a href="#OEBPS/Chapter05.html.page_172">172 岁</a>，<a href="#OEBPS/Chapter05.html.page_186">186 岁</a></p><p class="index"><b>Goetz, Brian</b>, <a href="#OEBPS/Chapter05.html.page_172">172</a>, <a href="#OEBPS/Chapter05.html.page_186">186</a></p>
<p class="index"><b>戈尔丁，唐</b>，<a href="#OEBPS/Chapter08.html.page_312">312</a></p><p class="index"><b>Goldin, Don</b>, <a href="#OEBPS/Chapter08.html.page_312">312</a></p>
<p class="index"><b></b>谷<b>歌</b>, <a href="#OEBPS/Chapter02.html.page_55">55</a> , <a href="#OEBPS/Chapter02.html.page_62">62</a> , <a href="#OEBPS/Chapter02.html.page_63">63</a> , <a href="#OEBPS/Chapter02.html.page_64">64</a> , <a href="#OEBPS/Chapter02.html.page_65">65</a> , <a href="#OEBPS/Chapter02.html.page_68">68</a> , <a href="#OEBPS/Chapter02.html.page_71">71</a> , <a href="#OEBPS/Chapter02.html.page_72">72</a> , <a href="#OEBPS/Chapter02.html.page_73">73</a> , <a href="#OEBPS/Chapter02.html.page_75">75</a> , <a href="#OEBPS/Chapter02.html.page_77">77</a> , <a href="#OEBPS/Chapter02.html.page_78">78</a> , <a href="#OEBPS/Chapter02.html.page_79">79</a> , <a href="#OEBPS/Chapter02.html.page_80">80</a> , <a href="#OEBPS/Chapter02.html.page_82">82</a> , <a href="#OEBPS/Chapter02.html.page_84">84</a> , <a href="#OEBPS/Chapter02.html.page_85">85</a> , <a href="#OEBPS/Chapter02.html.page_86">86</a> , <a href="#OEBPS/Chapter04.html.page_163">163</a> , <a href="#OEBPS/Chapter05.html.page_167">167</a> , <a href="#OEBPS/Chapter05.html.page_184">184</a> , <a href="#OEBPS/Chapter05.html.page_185">185</a> , <a href="#OEBPS/Chapter05.html.page_186">186</a> , <a href="#OEBPS/Chapter08.html.page_287">287 </a><a href="#OEBPS/Chapter08.html.page_296">296</a> , <a href="#OEBPS/Chapter08.html.page_298">298</a> , <a href="#OEBPS/Chapter08.html.page_301">301</a> ,<a href="#OEBPS/Chapter08.html.page_303">303</a> , <a href="#OEBPS/Chapter08.html.page_304">304</a> , <a href="#OEBPS/Chapter08.html.page_305">305</a> , <a href="#OEBPS/Chapter08.html.page_307">307</a> , <a href="#OEBPS/Chapter08.html.page_308">308</a> , <a href="#OEBPS/Chapter08.html.page_311">311</a> , <a href="#OEBPS/Chapter08.html.page_320">320</a> , <a href="#OEBPS/Chapter08.html.page_322">322</a> , <a href="#OEBPS/Chapter12.html.page_473">473</a> , 474 , <a href="#OEBPS/Chapter12.html.page_475">475</a> , <a href="#OEBPS/Chapter12.html.page_476">476</a> , <a href="#OEBPS/Chapter12.html.page_480">480</a></p><p class="index"><b>Google</b>, <a href="#OEBPS/Chapter02.html.page_55">55</a>, <a href="#OEBPS/Chapter02.html.page_62">62</a>, <a href="#OEBPS/Chapter02.html.page_63">63</a>, <a href="#OEBPS/Chapter02.html.page_64">64</a>, <a href="#OEBPS/Chapter02.html.page_65">65</a>, <a href="#OEBPS/Chapter02.html.page_68">68</a>, <a href="#OEBPS/Chapter02.html.page_71">71</a>, <a href="#OEBPS/Chapter02.html.page_72">72</a>, <a href="#OEBPS/Chapter02.html.page_73">73</a>, <a href="#OEBPS/Chapter02.html.page_75">75</a>, <a href="#OEBPS/Chapter02.html.page_77">77</a>, <a href="#OEBPS/Chapter02.html.page_78">78</a>, <a href="#OEBPS/Chapter02.html.page_79">79</a>, <a href="#OEBPS/Chapter02.html.page_80">80</a>, <a href="#OEBPS/Chapter02.html.page_82">82</a>, <a href="#OEBPS/Chapter02.html.page_84">84</a>, <a href="#OEBPS/Chapter02.html.page_85">85</a>, <a href="#OEBPS/Chapter02.html.page_86">86</a>, <a href="#OEBPS/Chapter04.html.page_163">163</a>, <a href="#OEBPS/Chapter05.html.page_167">167</a>, <a href="#OEBPS/Chapter05.html.page_184">184</a>, <a href="#OEBPS/Chapter05.html.page_185">185</a>, <a href="#OEBPS/Chapter05.html.page_186">186</a>, <a href="#OEBPS/Chapter08.html.page_287">287</a>, <a href="#OEBPS/Chapter08.html.page_296">296</a>, <a href="#OEBPS/Chapter08.html.page_298">298</a>, <a href="#OEBPS/Chapter08.html.page_301">301</a>, <a href="#OEBPS/Chapter08.html.page_303">303</a>, <a href="#OEBPS/Chapter08.html.page_304">304</a>, <a href="#OEBPS/Chapter08.html.page_305">305</a>, <a href="#OEBPS/Chapter08.html.page_307">307</a>, <a href="#OEBPS/Chapter08.html.page_308">308</a>, <a href="#OEBPS/Chapter08.html.page_311">311</a>, <a href="#OEBPS/Chapter08.html.page_320">320</a>, <a href="#OEBPS/Chapter08.html.page_322">322</a>, <a href="#OEBPS/Chapter12.html.page_473">473</a>,
474, <a href="#OEBPS/Chapter12.html.page_475">475</a>, <a href="#OEBPS/Chapter12.html.page_476">476</a>, <a href="#OEBPS/Chapter12.html.page_480">480</a></p>
<p class="index"><b>戈斯珀，比尔</b>，<a href="#OEBPS/Chapter14.html.page_522">522</a></p><p class="index"><b>Gosper, Bill</b>, <a href="#OEBPS/Chapter14.html.page_522">522</a></p>
<p class="index"><b><i>goto 语句</i></b>,<a href="#OEBPS/Chapter15.html.page_565"> 565</a> ,<a href="#OEBPS/Chapter15.html.page_595"> 595</a></p><p class="index"><b><i>goto statements</i></b>, <a href="#OEBPS/Chapter15.html.page_565">565</a>, <a href="#OEBPS/Chapter15.html.page_595">595</a></p>
<p class="index"><b>格林布拉特，理查德</b>，<a href="#OEBPS/Chapter14.html.page_522">522</a></p><p class="index"><b>Greenblatt, Richard</b>, <a href="#OEBPS/Chapter14.html.page_522">522</a></p>
<p class="index"><b>格罗弗，乔治</b>，<a href="#OEBPS/Chapter13.html.page_492">492</a></p><p class="index"><b>Grover, George</b>, <a href="#OEBPS/Chapter13.html.page_492">492</a></p>
<p class="index"><b>Guibas，狮子座</b>，<a href="#OEBPS/Chapter11.html.page_421">421</a></p><p class="index"><b>Guibas, Leo</b>, <a href="#OEBPS/Chapter11.html.page_421">421</a></p>
<p class="index"><b>金威特</b>, <a href="#OEBPS/Chapter03.html.page_100">100</a></p><p class="index"><b>GWT</b>, <a href="#OEBPS/Chapter03.html.page_100">100</a></p>
<h3 class="h3">H</h3><h3 class="h3">H</h3>
<p class="index"><b>人居</b>, <a href="#OEBPS/Chapter03.html.page_95">95</a> , <a href="#OEBPS/Chapter03.html.page_112">112</a></p><p class="index"><b>Habitat</b>, <a href="#OEBPS/Chapter03.html.page_95">95</a>, <a href="#OEBPS/Chapter03.html.page_112">112</a></p>
<p class="index"><b><i>黑客词典，第</i></b>325<a href="#OEBPS/Chapter09.html.page_325">页</a></p><p class="index"><b><i>Hacker's Dictionary, The</i></b>, <a href="#OEBPS/Chapter09.html.page_325">325</a></p>
<p class="index"><b>哈里斯，蒂姆</b>，<a href="#OEBPS/Chapter07.html.page_275">275</a></p><p class="index"><b>Harris, Tim</b>, <a href="#OEBPS/Chapter07.html.page_275">275</a></p>
<p class="index"><b><i>哈佛</i></b>,<a href="#OEBPS/Chapter09.html.page_325"> 325</a> ,<a href="#OEBPS/Chapter09.html.page_329"> 329</a> ,<a href="#OEBPS/Chapter09.html.page_330"> 330</a> ,<a href="#OEBPS/Chapter09.html.page_331"> 331</a> ,<a href="#OEBPS/Chapter09.html.page_333"> 333</a> ,<a href="#OEBPS/Chapter10.html.page_374"> 374</a> ,<a href="#OEBPS/Chapter11.html.page_413"> 413</a> ,<a href="#OEBPS/Chapter11.html.page_425"> 425</a></p><p class="index"><b><i>Harvard</i></b>, <a href="#OEBPS/Chapter09.html.page_325">325</a>, <a href="#OEBPS/Chapter09.html.page_329">329</a>, <a href="#OEBPS/Chapter09.html.page_330">330</a>, <a href="#OEBPS/Chapter09.html.page_331">331</a>, <a href="#OEBPS/Chapter09.html.page_333">333</a>, <a href="#OEBPS/Chapter10.html.page_374">374</a>, <a href="#OEBPS/Chapter11.html.page_413">413</a>, <a href="#OEBPS/Chapter11.html.page_425">425</a></p>
<p class="index"><b><i>哈斯克尔</i></b>,<a href="#OEBPS/Chapter07.html.page_241"> 241</a> ,<a href="#OEBPS/Chapter07.html.page_251"> 251</a> ,<a href="#OEBPS/Chapter07.html.page_254"> 254</a> ,<a href="#OEBPS/Chapter07.html.page_259"> 259</a> ,<a href="#OEBPS/Chapter07.html.page_261"> 261</a> ,<a href="#OEBPS/Chapter07.html.page_266"> 266</a> ,<a href="#OEBPS/Chapter07.html.page_267"> 267</a> ,<a href="#OEBPS/Chapter07.html.page_268"> 268</a> ,<a href="#OEBPS/Chapter07.html.page_270"> 270</a> ,<a href="#OEBPS/Chapter07.html.page_275"> 275</a> ,<a href="#OEBPS/Chapter07.html.page_276"> 276</a> ,<a href="#OEBPS/Chapter07.html.page_278"> 278</a> ,<a href="#OEBPS/Chapter07.html.page_280"> 280</a> ,<a href="#OEBPS/Chapter07.html.page_283"> 283</a> ,<a href="#OEBPS/Chapter08.html.page_296"> 296</a> ,<a href="#OEBPS/Chapter09.html.page_325"> 325</a> ,<a href="#OEBPS/Chapter09.html.page_354"> 354</a> ,<a href="#OEBPS/Chapter09.html.page_357"> 357</a> ,<a href="#OEBPS/Chapter09.html.page_358"> 358</a> ,<a href="#OEBPS/Chapter09.html.page_359"> 359</a> ,<a href="#OEBPS/Chapter11.html.page_437"> 4</a> ,3<a href="#OEBPS/Chapter09.html.page_365"> _ </a><a href="#OEBPS/Chapter11.html.page_436">_</a><a href="#OEBPS/Chapter11.html.page_437"></a></p><p class="index"><b><i>Haskell</i></b>, <a href="#OEBPS/Chapter07.html.page_241">241</a>, <a href="#OEBPS/Chapter07.html.page_251">251</a>, <a href="#OEBPS/Chapter07.html.page_254">254</a>, <a href="#OEBPS/Chapter07.html.page_259">259</a>, <a href="#OEBPS/Chapter07.html.page_261">261</a>, <a href="#OEBPS/Chapter07.html.page_266">266</a>, <a href="#OEBPS/Chapter07.html.page_267">267</a>, <a href="#OEBPS/Chapter07.html.page_268">268</a>, <a href="#OEBPS/Chapter07.html.page_270">270</a>, <a href="#OEBPS/Chapter07.html.page_275">275</a>, <a href="#OEBPS/Chapter07.html.page_276">276</a>, <a href="#OEBPS/Chapter07.html.page_278">278</a>, <a href="#OEBPS/Chapter07.html.page_280">280</a>, <a href="#OEBPS/Chapter07.html.page_283">283</a>, <a href="#OEBPS/Chapter08.html.page_296">296</a>, <a href="#OEBPS/Chapter09.html.page_325">325</a>, <a href="#OEBPS/Chapter09.html.page_354">354</a>, <a href="#OEBPS/Chapter09.html.page_357">357</a>, <a href="#OEBPS/Chapter09.html.page_358">358</a>, <a href="#OEBPS/Chapter09.html.page_359">359</a>, <a href="#OEBPS/Chapter09.html.page_365">365</a>, <a href="#OEBPS/Chapter11.html.page_436">436</a>, <a href="#OEBPS/Chapter11.html.page_437">437</a></p>
<p class="index"><b></b><a href="#OEBPS/Chapter14.html.page_538">心</a>，<b>弗兰克</b>，<a href="#OEBPS/Chapter14.html.page_530">530，535，538</a> _ <a href="#OEBPS/Chapter14.html.page_535">_</a><a href="#OEBPS/Chapter14.html.page_538"></a></p><p class="index"><b>Heart, Frank</b>, <a href="#OEBPS/Chapter14.html.page_530">530</a>, <a href="#OEBPS/Chapter14.html.page_535">535</a>, <a href="#OEBPS/Chapter14.html.page_538">538</a></p>
<p class="index"><b>赫利希，莫里斯</b>，<a href="#OEBPS/Chapter07.html.page_275">275</a></p><p class="index"><b>Herlihy, Maurice</b>, <a href="#OEBPS/Chapter07.html.page_275">275</a></p>
<p class="index"><b>赫尔曼·戴夫</b>，<a href="#OEBPS/Chapter04.html.page_144">144 岁</a></p><p class="index"><b>Herman, Dave</b>, <a href="#OEBPS/Chapter04.html.page_144">144</a></p>
<p class="index"><b>历史</b>, <a href="#OEBPS/Chapter15.html.page_568">568</a> , <a href="#OEBPS/Chapter15.html.page_577">577</a> , <a href="#OEBPS/Chapter15.html.page_578">578</a> , <a href="#OEBPS/Chapter15.html.page_598">598</a> , <a href="#OEBPS/Chapter15.html.page_599">599</a></p><p class="index"><b>history</b>, <a href="#OEBPS/Chapter15.html.page_568">568</a>, <a href="#OEBPS/Chapter15.html.page_577">577</a>, <a href="#OEBPS/Chapter15.html.page_578">578</a>, <a href="#OEBPS/Chapter15.html.page_598">598</a>, <a href="#OEBPS/Chapter15.html.page_599">599</a></p>
<p class="index"><b></b><a href="#OEBPS/Chapter15.html.page_590">霍尔</a>，<b>托尼</b>，<a href="#OEBPS/Chapter05.html.page_196">196，585，590</a> _ <a href="#OEBPS/Chapter15.html.page_585">_</a><a href="#OEBPS/Chapter15.html.page_590"></a></p><p class="index"><b>Hoare, Tony</b>, <a href="#OEBPS/Chapter05.html.page_196">196</a>, <a href="#OEBPS/Chapter15.html.page_585">585</a>, <a href="#OEBPS/Chapter15.html.page_590">590</a></p>
<p class="index"><b>霍瓦特·瓦尔德玛</b>，<a href="#OEBPS/Chapter04.html.page_143">143</a></p><p class="index"><b>Horwat, Waldemar</b>, <a href="#OEBPS/Chapter04.html.page_143">143</a></p>
<p class="index">霍克，克里斯，<a href="#OEBPS/Chapter01.html.page_16">16 岁</a></p><p class="index">Houck, Chris, <a href="#OEBPS/Chapter01.html.page_16">16</a></p>
<p class="index"><b></b><a href="#OEBPS/Chapter07.html.page_263">休斯</a>，<b>约翰</b>，<a href="#OEBPS/Chapter07.html.page_257">257，258，263</a> _ <a href="#OEBPS/Chapter07.html.page_258">_</a><a href="#OEBPS/Chapter07.html.page_263"></a></p><p class="index"><b>Hughes, John</b>, <a href="#OEBPS/Chapter07.html.page_257">257</a>, <a href="#OEBPS/Chapter07.html.page_258">258</a>, <a href="#OEBPS/Chapter07.html.page_263">263</a></p>
<p class="index"><b>超级卡</b>, <a href="#OEBPS/Chapter10.html.page_382">382</a></p><p class="index"><b>HyperCard</b>, <a href="#OEBPS/Chapter10.html.page_382">382</a></p>
<h3 class="h3">我</h3><h3 class="h3">I</h3>
<p class="index"><b><i>IBM</i></b> ,<a href="#OEBPS/Chapter09.html.page_325"> 325</a> ,<a href="#OEBPS/Chapter09.html.page_326"> 326</a> ,<a href="#OEBPS/Chapter09.html.page_327"> 327</a> ,<a href="#OEBPS/Chapter09.html.page_328"> 328</a> ,<a href="#OEBPS/Chapter09.html.page_329"> 329</a> ,<a href="#OEBPS/Chapter09.html.page_332"> 332</a> ,<a href="#OEBPS/Chapter09.html.page_340"> 340</a> ,<a href="#OEBPS/Chapter09.html.page_353"> 353</a> ,<a href="#OEBPS/Chapter09.html.page_362"> 362</a> ,<a href="#OEBPS/Chapter09.html.page_370"> 370</a> ,<a href="#OEBPS/Chapter13.html.page_485"> 485</a> ,<a href="#OEBPS/Chapter13.html.page_486"> 486</a> ,<a href="#OEBPS/Chapter13.html.page_487"> 487</a> ,<a href="#OEBPS/Chapter13.html.page_490"> 490</a> ,<a href="#OEBPS/Chapter13.html.page_493"> 493</a> ,<a href="#OEBPS/Chapter13.html.page_495"> 495</a> ,<a href="#OEBPS/Chapter13.html.page_499"> 499</a> ,<a href="#OEBPS/Chapter13.html.page_500"> 500</a> ,<a href="#OEBPS/Chapter13.html.page_506"> 506</a> ,<a href="#OEBPS/Chapter13.html.page_508"> 508</a> ,<a href="#OEBPS/Chapter13.html.page_510"> 5</a> ,14,<a href="#OEBPS/Chapter13.html.page_512"> 512</a> ,<a href="#OEBPS/Chapter13.html.page_515"> 512 </a><a href="#OEBPS/Chapter13.html.page_514">_ </a><a href="#OEBPS/Chapter13.html.page_516">516</a><a href="#OEBPS/Chapter13.html.page_515"></a><a href="#OEBPS/Chapter13.html.page_516"></a></p><p class="index"><b><i>IBM</i></b>, <a href="#OEBPS/Chapter09.html.page_325">325</a>, <a href="#OEBPS/Chapter09.html.page_326">326</a>, <a href="#OEBPS/Chapter09.html.page_327">327</a>, <a href="#OEBPS/Chapter09.html.page_328">328</a>, <a href="#OEBPS/Chapter09.html.page_329">329</a>, <a href="#OEBPS/Chapter09.html.page_332">332</a>, <a href="#OEBPS/Chapter09.html.page_340">340</a>, <a href="#OEBPS/Chapter09.html.page_353">353</a>, <a href="#OEBPS/Chapter09.html.page_362">362</a>, <a href="#OEBPS/Chapter09.html.page_370">370</a>, <a href="#OEBPS/Chapter13.html.page_485">485</a>, <a href="#OEBPS/Chapter13.html.page_486">486</a>, <a href="#OEBPS/Chapter13.html.page_487">487</a>, <a href="#OEBPS/Chapter13.html.page_490">490</a>, <a href="#OEBPS/Chapter13.html.page_493">493</a>, <a href="#OEBPS/Chapter13.html.page_495">495</a>, <a href="#OEBPS/Chapter13.html.page_499">499</a>, <a href="#OEBPS/Chapter13.html.page_500">500</a>, <a href="#OEBPS/Chapter13.html.page_506">506</a>, <a href="#OEBPS/Chapter13.html.page_508">508</a>, <a href="#OEBPS/Chapter13.html.page_510">510</a>, <a href="#OEBPS/Chapter13.html.page_512">512</a>, <a href="#OEBPS/Chapter13.html.page_514">514</a>, <a href="#OEBPS/Chapter13.html.page_515">515</a>, <a href="#OEBPS/Chapter13.html.page_516">516</a></p>
<p class="index"><b>IBM 研究院</b>, <a href="#OEBPS/Chapter05.html.page_185">185</a></p><p class="index"><b>IBM Research</b>, <a href="#OEBPS/Chapter05.html.page_185">185</a></p>
<p class="index"><b>伊博拉，佩佩</b>，<a href="#OEBPS/Chapter07.html.page_268">268</a></p><p class="index"><b>Iborra, Pepe</b>, <a href="#OEBPS/Chapter07.html.page_268">268</a></p>
<p class="index"><b>561</b>号<a href="#OEBPS/Chapter14.html.page_561">_</a></p><p class="index"><b>IMLAC</b>, <a href="#OEBPS/Chapter14.html.page_561">561</a></p>
<p class="index"><b><i>IMP,</i></b> 520,<a href="#OEBPS/Chapter14.html.page_530"> 530</a> ,<a href="#OEBPS/Chapter14.html.page_532"> 532</a> ,<a href="#OEBPS/Chapter14.html.page_534"> 534</a> ,<a href="#OEBPS/Chapter14.html.page_536"> 536</a> ,<a href="#OEBPS/Chapter14.html.page_537"> 537</a> ,<a href="#OEBPS/Chapter14.html.page_538"> 538</a> ,<a href="#OEBPS/Chapter14.html.page_558"> 558</a></p><p class="index"><b><i>IMP,</i></b> 520, <a href="#OEBPS/Chapter14.html.page_530">530</a>, <a href="#OEBPS/Chapter14.html.page_532">532</a>, <a href="#OEBPS/Chapter14.html.page_534">534</a>, <a href="#OEBPS/Chapter14.html.page_536">536</a>, <a href="#OEBPS/Chapter14.html.page_537">537</a>, <a href="#OEBPS/Chapter14.html.page_538">538</a>, <a href="#OEBPS/Chapter14.html.page_558">558</a></p>
<p class="index"><b><i>IMP</i></b> ,<a href="#OEBPS/Chapter14.html.page_519"> 519</a> ,<a href="#OEBPS/Chapter14.html.page_529"> 529</a> ,<a href="#OEBPS/Chapter14.html.page_549"> 549</a></p><p class="index"><b><i>IMPs</i></b>, <a href="#OEBPS/Chapter14.html.page_519">519</a>, <a href="#OEBPS/Chapter14.html.page_529">529</a>, <a href="#OEBPS/Chapter14.html.page_549">549</a></p>
<p class="index"><b><i>接口消息处理器 (IMP)</i></b> ,<a href="#OEBPS/Chapter14.html.page_519"> 519</a></p><p class="index"><b><i>Interface Message Processors (IMPs)</i></b>, <a href="#OEBPS/Chapter14.html.page_519">519</a></p>
<p class="index"><b><i>Interlisp</i></b> ,<a href="#OEBPS/Chapter11.html.page_413"> 413</a> ,<a href="#OEBPS/Chapter11.html.page_414"> 414</a> ,<a href="#OEBPS/Chapter11.html.page_418"> 418</a> ,<a href="#OEBPS/Chapter11.html.page_441"> 441</a></p><p class="index"><b><i>Interlisp</i></b>, <a href="#OEBPS/Chapter11.html.page_413">413</a>, <a href="#OEBPS/Chapter11.html.page_414">414</a>, <a href="#OEBPS/Chapter11.html.page_418">418</a>, <a href="#OEBPS/Chapter11.html.page_441">441</a></p>
<p class="index"><b>不变量</b>, <a href="#OEBPS/Chapter02.html.page_79">79</a> , <a href="#OEBPS/Chapter10.html.page_406">406</a> , <a href="#OEBPS/Chapter12.html.page_468">468</a> , <a href="#OEBPS/Chapter12.html.page_469">469</a></p><p class="index"><b>invariants</b>, <a href="#OEBPS/Chapter02.html.page_79">79</a>, <a href="#OEBPS/Chapter10.html.page_406">406</a>, <a href="#OEBPS/Chapter12.html.page_468">468</a>, <a href="#OEBPS/Chapter12.html.page_469">469</a></p>
<h3 class="h3">杰</h3><h3 class="h3">J</h3>
<p class="index"><b>范·雅各布森</b>，<a href="#OEBPS/Chapter04.html.page_153">153 岁</a></p><p class="index"><b>Jacobson, Van</b>, <a href="#OEBPS/Chapter04.html.page_153">153</a></p>
<p class="index"><b>Java</b> , <a href="#OEBPS/Chapter01.html.page_11">11</a> , <a href="#OEBPS/Chapter01.html.page_21">21</a> , <a href="#OEBPS/Chapter02.html.page_49">49</a> , <a href="#OEBPS/Chapter02.html.page_52">52</a> , <a href="#OEBPS/Chapter02.html.page_62">62</a> , <a href="#OEBPS/Chapter02.html.page_63">63</a> , <a href="#OEBPS/Chapter02.html.page_65">65</a> , <a href="#OEBPS/Chapter02.html.page_66">66</a> , <a href="#OEBPS/Chapter02.html.page_81">81</a> , <a href="#OEBPS/Chapter02.html.page_85">85</a> , <a href="#OEBPS/Chapter04.html.page_134">134</a> , <a href="#OEBPS/Chapter04.html.page_136">136</a> , <a href="#OEBPS/Chapter04.html.page_141">141</a> , <a href="#OEBPS/Chapter04.html.page_143">143</a> , <a href="#OEBPS/Chapter04.html.page_145">145</a> , <a href="#OEBPS/Chapter04.html.page_146">146</a> , <a href="#OEBPS/Chapter04.html.page_147">147</a> , <a href="#OEBPS/Chapter04.html.page_149">149</a> , <a href="#OEBPS/Chapter04.html.page_161">161</a> , <a href="#OEBPS/Chapter04.html.page_162">162</a> , <a href="#OEBPS/Chapter04.html.page_164">164</a> , <a href="#OEBPS/Chapter05.html.page_168">168</a> , <a href="#OEBPS/Chapter05.html.page_167">167</a> , 1 <a href="#OEBPS/Chapter05.html.page_170">_ </a><a href="#OEBPS/Chapter05.html.page_172">172</a> , <a href="#OEBPS/Chapter05.html.page_173">173</a> , <a href="#OEBPS/Chapter05.html.page_174">174</a> ,<a href="#OEBPS/Chapter05.html.page_168"></a><a href="#OEBPS/Chapter05.html.page_170"></a><a href="#OEBPS/Chapter05.html.page_172"></a><a href="#OEBPS/Chapter05.html.page_173"></a><a href="#OEBPS/Chapter05.html.page_174"></a><a href="#OEBPS/Chapter05.html.page_176">176、177、179、183、184、185、186、191、191、193、193、195、1919、197、197、325、334、339、343、349、349、351、351、352、354、355、355、356、356，355、356，355、355、356，355</a> _ <a href="#OEBPS/Chapter05.html.page_177">_</a> _ <a href="#OEBPS/Chapter05.html.page_179">_</a> _ <a href="#OEBPS/Chapter05.html.page_183">_</a> _ <a href="#OEBPS/Chapter05.html.page_184">_</a> _ <a href="#OEBPS/Chapter05.html.page_185">_</a> _ <a href="#OEBPS/Chapter05.html.page_186">_</a> _ <a href="#OEBPS/Chapter05.html.page_191">_</a> _ <a href="#OEBPS/Chapter05.html.page_192">_</a> _ <a href="#OEBPS/Chapter05.html.page_193">_</a> _ <a href="#OEBPS/Chapter05.html.page_195">_</a> _ <a href="#OEBPS/Chapter05.html.page_196">_</a> _ <a href="#OEBPS/Chapter05.html.page_197">_</a> _ <a href="#OEBPS/Chapter05.html.page_198">_</a> _ <a href="#OEBPS/Chapter09.html.page_325">_</a> _ <a href="#OEBPS/Chapter09.html.page_334">_</a> _ <a href="#OEBPS/Chapter09.html.page_339">_</a> _ <a href="#OEBPS/Chapter09.html.page_343">_</a> _ <a href="#OEBPS/Chapter09.html.page_349">_</a> _ <a href="#OEBPS/Chapter09.html.page_350">_</a> _ <a href="#OEBPS/Chapter09.html.page_351">_</a> _ <a href="#OEBPS/Chapter09.html.page_352">_</a> _ <a href="#OEBPS/Chapter09.html.page_354">_</a> _ <a href="#OEBPS/Chapter09.html.page_355">_</a> _ <a href="#OEBPS/Chapter09.html.page_356">_</a> _ <a href="#OEBPS/Chapter09.html.page_358">358</a> , <img src="data:image/jpg;base64,/9j/4AAQSkZJRgABAgEASABIAAD/7QbCUGhvdG9zaG9wIDMuMAA4QklNA+0KUmVzb2x1dGlvbgAAAAAQAEgAAAABAAEASAAAAAEAAThCSU0EDRhGWCBHbG9iYWwgTGlnaHRpbmcgQW5nbGUAAAAABAAAAHg4QklNBBkSRlggR2xvYmFsIEFsdGl0dWRlAAAAAAQAAAAeOEJJTQPzC1ByaW50IEZsYWdzAAAACQAAAAAAAAAAAQA4QklNBAoOQ29weXJpZ2h0IEZsYWcAAAAAAQAAOEJJTScQFEphcGFuZXNlIFByaW50IEZsYWdzAAAAAAoAAQAAAAAAAAACOEJJTQP1F0NvbG9yIEhhbGZ0b25lIFNldHRpbmdzAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+BdDb2xvciBUcmFuc2ZlciBTZXR0aW5ncwAAAHAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAOEJJTQQAC0xheWVyIFN0YXRlAAAAAgABOEJJTQQCDExheWVyIEdyb3VwcwAAAAAEAAAAADhCSU0ECAZHdWlkZXMAAAAAEAAAAAEAAAJAAAACQAAAAAA4QklNBB4NVVJMIG92ZXJyaWRlcwAAAAQAAAAAOEJJTQQaBlNsaWNlcwAAAAB1AAAABgAAAAAAAAAAAAAAFAAAABQAAAAKAFUAbgB0AGkAdABsAGUAZAAtADEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhCSU0EERFJQ0MgVW50YWdnZWQgRmxhZwAAAAEBADhCSU0EFBdMYXllciBJRCBHZW5lcmF0b3IgQmFzZQAAAAQAAAACOEJJTQQMFU5ldyBXaW5kb3dzIFRodW1ibmFpbAAAAuUAAAABAAAAFAAAABQAAAA8AAAEsAAAAskAGAAB/9j/4AAQSkZJRgABAgEASABI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" alt="图片"><a href="#OEBPS/Chapter10.html.page_377">377</a> , <a href="#OEBPS/Chapter10.html.page_378">378</a>, <a href="#OEBPS/Chapter10.html.page_379">379</a> , <a href="#OEBPS/Chapter10.html.page_389">389</a> , <a href="#OEBPS/Chapter12.html.page_468">468</a> , <a href="#OEBPS/Chapter12.html.page_471">471</a> , <a href="#OEBPS/Chapter12.html.page_476">476</a> , <a href="#OEBPS/Chapter13.html.page_502">502</a> , <a href="#OEBPS/Chapter13.html.page_503">503</a> , <a href="#OEBPS/Chapter14.html.page_559">559</a> , <a href="#OEBPS/Chapter14.html.page_560">560</a> , <a href="#OEBPS/Chapter15.html.page_582">582</a> , <a href="#OEBPS/Chapter15.html.page_596">596</a></p><p class="index"><b>Java</b>, <a href="#OEBPS/Chapter01.html.page_11">11</a>, <a href="#OEBPS/Chapter01.html.page_21">21</a>, <a href="#OEBPS/Chapter02.html.page_49">49</a>, <a href="#OEBPS/Chapter02.html.page_52">52</a>, <a href="#OEBPS/Chapter02.html.page_62">62</a>, <a href="#OEBPS/Chapter02.html.page_63">63</a>, <a href="#OEBPS/Chapter02.html.page_65">65</a>, <a href="#OEBPS/Chapter02.html.page_66">66</a>, <a href="#OEBPS/Chapter02.html.page_81">81</a>, <a href="#OEBPS/Chapter02.html.page_85">85</a>, <a href="#OEBPS/Chapter04.html.page_134">134</a>, <a href="#OEBPS/Chapter04.html.page_136">136</a>, <a href="#OEBPS/Chapter04.html.page_141">141</a>, <a href="#OEBPS/Chapter04.html.page_143">143</a>, <a href="#OEBPS/Chapter04.html.page_145">145</a>, <a href="#OEBPS/Chapter04.html.page_146">146</a>, <a href="#OEBPS/Chapter04.html.page_147">147</a>, <a href="#OEBPS/Chapter04.html.page_149">149</a>, <a href="#OEBPS/Chapter04.html.page_161">161</a>, <a href="#OEBPS/Chapter04.html.page_162">162</a>, <a href="#OEBPS/Chapter04.html.page_164">164</a>, <a href="#OEBPS/Chapter05.html.page_167">167</a>, <a href="#OEBPS/Chapter05.html.page_168">168</a>, <a href="#OEBPS/Chapter05.html.page_170">170</a>, <a href="#OEBPS/Chapter05.html.page_172">172</a>, <a href="#OEBPS/Chapter05.html.page_173">173</a>, <a href="#OEBPS/Chapter05.html.page_174">174</a>, <a href="#OEBPS/Chapter05.html.page_176">176</a>, <a href="#OEBPS/Chapter05.html.page_177">177</a>, <a href="#OEBPS/Chapter05.html.page_179">179</a>, <a href="#OEBPS/Chapter05.html.page_183">183</a>, <a href="#OEBPS/Chapter05.html.page_184">184</a>, <a href="#OEBPS/Chapter05.html.page_185">185</a>, <a href="#OEBPS/Chapter05.html.page_186">186</a>, <a href="#OEBPS/Chapter05.html.page_191">191</a>, <a href="#OEBPS/Chapter05.html.page_192">192</a>, <a href="#OEBPS/Chapter05.html.page_193">193</a>, <a href="#OEBPS/Chapter05.html.page_195">195</a>, <a href="#OEBPS/Chapter05.html.page_196">196</a>, <a href="#OEBPS/Chapter05.html.page_197">197</a>, <a href="#OEBPS/Chapter05.html.page_198">198</a>, <a href="#OEBPS/Chapter09.html.page_325">325</a>, <a href="#OEBPS/Chapter09.html.page_334">334</a>, <a href="#OEBPS/Chapter09.html.page_339">339</a>, <a href="#OEBPS/Chapter09.html.page_343">343</a>, <a href="#OEBPS/Chapter09.html.page_349">349</a>, <a href="#OEBPS/Chapter09.html.page_350">350</a>, <a href="#OEBPS/Chapter09.html.page_351">351</a>, <a href="#OEBPS/Chapter09.html.page_352">352</a>, <a href="#OEBPS/Chapter09.html.page_354">354</a>, <a href="#OEBPS/Chapter09.html.page_355">355</a>, <a href="#OEBPS/Chapter09.html.page_356">356</a>, <a href="#OEBPS/Chapter09.html.page_358">358</a>, <a href="#OEBPS/Chapter10.html.page_377">377</a>, <a href="#OEBPS/Chapter10.html.page_378">378</a>, <a href="#OEBPS/Chapter10.html.page_379">379</a>, <a href="#OEBPS/Chapter10.html.page_389">389</a>, <a href="#OEBPS/Chapter12.html.page_468">468</a>, <a href="#OEBPS/Chapter12.html.page_471">471</a>, <a href="#OEBPS/Chapter12.html.page_476">476</a>, <a href="#OEBPS/Chapter13.html.page_502">502</a>, <a href="#OEBPS/Chapter13.html.page_503">503</a>, <a href="#OEBPS/Chapter14.html.page_559">559</a>, <a href="#OEBPS/Chapter14.html.page_560">560</a>, <a href="#OEBPS/Chapter15.html.page_582">582</a>, <a href="#OEBPS/Chapter15.html.page_596">596</a></p>
<p class="index"><b><i>Java 集合框架，</i></b> 167</p><p class="index"><b><i>Java Collections Framework,</i></b> 167</p>
<p class="index"><b>Java 社区进程</b>, <a href="#OEBPS/Chapter09.html.page_349">349</a> , <a href="#OEBPS/Chapter09.html.page_350">350</a></p><p class="index"><b>Java Community Process</b>, <a href="#OEBPS/Chapter09.html.page_349">349</a>, <a href="#OEBPS/Chapter09.html.page_350">350</a></p>
<p class="index"><b>Java文档</b>, <a href="#OEBPS/Chapter09.html.page_356">356</a></p><p class="index"><b>Javadoc</b>, <a href="#OEBPS/Chapter09.html.page_356">356</a></p>
<p class="index"><b><i>JavaScript</i></b> ,<a href="#OEBPS/Chapter03.html.page_91"> 91</a> ,<a href="#OEBPS/Chapter03.html.page_93"> 93</a> ,<a href="#OEBPS/Chapter03.html.page_96"> 96</a> ,<a href="#OEBPS/Chapter03.html.page_97"> 97</a> ,<a href="#OEBPS/Chapter03.html.page_98"> 98</a> ,<a href="#OEBPS/Chapter03.html.page_99"> 99</a> ,<a href="#OEBPS/Chapter03.html.page_100"> 100</a> ,<a href="#OEBPS/Chapter03.html.page_101"> 101</a> ,<a href="#OEBPS/Chapter03.html.page_102"> 102</a> ,<a href="#OEBPS/Chapter03.html.page_105"> 105</a> ,<a href="#OEBPS/Chapter03.html.page_106"> 106</a> ,<a href="#OEBPS/Chapter03.html.page_108"> 108</a> ,<a href="#OEBPS/Chapter03.html.page_117"> 117</a> ,<a href="#OEBPS/Chapter03.html.page_118"> 118</a> ,<a href="#OEBPS/Chapter03.html.page_119"> 119</a> ,<a href="#OEBPS/Chapter03.html.page_120"> 120</a> ,<a href="#OEBPS/Chapter03.html.page_122"> 122</a> ,<a href="#OEBPS/Chapter03.html.page_123"> 123</a> ,<a href="#OEBPS/Chapter03.html.page_125"> 125</a> ,<a href="#OEBPS/Chapter03.html.page_128"> 128</a> ,<a href="#OEBPS/Chapter03.html.page_129"> 129</a> ,<a href="#OEBPS/Chapter03.html.page_130"> 130</a> ,<a href="#OEBPS/Chapter04.html.page_134"> 130</a> ,130<a href="#OEBPS/Chapter04.html.page_133"> _ </a><a href="#OEBPS/Chapter04.html.page_136">136</a> ,<a href="#OEBPS/Chapter04.html.page_139"> 139</a> ,<a href="#OEBPS/Chapter04.html.page_140"> 140</a><a href="#OEBPS/Chapter04.html.page_134"></a><a href="#OEBPS/Chapter04.html.page_136"></a><a href="#OEBPS/Chapter04.html.page_139"></a><a href="#OEBPS/Chapter04.html.page_140"></a>, <a href="#OEBPS/Chapter04.html.page_141">141</a> , <a href="#OEBPS/Chapter04.html.page_142">142</a> , <a href="#OEBPS/Chapter04.html.page_143">143</a> , <a href="#OEBPS/Chapter04.html.page_144">144</a> , <a href="#OEBPS/Chapter04.html.page_145">145</a> , <a href="#OEBPS/Chapter04.html.page_146">146</a> , <a href="#OEBPS/Chapter04.html.page_147">147</a> , <a href="#OEBPS/Chapter04.html.page_148">148</a> , <a href="#OEBPS/Chapter04.html.page_149">149</a> , <a href="#OEBPS/Chapter04.html.page_150">150</a> , <a href="#OEBPS/Chapter04.html.page_155">155</a> , <a href="#OEBPS/Chapter04.html.page_159">159</a> , <a href="#OEBPS/Chapter04.html.page_160">160</a> , <a href="#OEBPS/Chapter04.html.page_165">165</a> , <a href="#OEBPS/Chapter04.html.page_166">166</a> , <a href="#OEBPS/Chapter10.html.page_373">373</a> , <a href="#OEBPS/Chapter10.html.page_379">379</a> , <a href="#OEBPS/Chapter10.html.page_380">380</a> , <a href="#OEBPS/Chapter10.html.page_381">381</a> , <a href="#OEBPS/Chapter10.html.page_392">392</a> , , <a href="#OEBPS/Chapter10.html.page_401">4801</a> , <a href="#OEBPS/Chapter10.html.page_405">4801 </a><a href="#OEBPS/Chapter10.html.page_408">_</a></p><p class="index"><b><i>JavaScript</i></b>, <a href="#OEBPS/Chapter03.html.page_91">91</a>, <a href="#OEBPS/Chapter03.html.page_93">93</a>, <a href="#OEBPS/Chapter03.html.page_96">96</a>, <a href="#OEBPS/Chapter03.html.page_97">97</a>, <a href="#OEBPS/Chapter03.html.page_98">98</a>, <a href="#OEBPS/Chapter03.html.page_99">99</a>, <a href="#OEBPS/Chapter03.html.page_100">100</a>, <a href="#OEBPS/Chapter03.html.page_101">101</a>, <a href="#OEBPS/Chapter03.html.page_102">102</a>, <a href="#OEBPS/Chapter03.html.page_105">105</a>, <a href="#OEBPS/Chapter03.html.page_106">106</a>, <a href="#OEBPS/Chapter03.html.page_108">108</a>, <a href="#OEBPS/Chapter03.html.page_117">117</a>, <a href="#OEBPS/Chapter03.html.page_118">118</a>, <a href="#OEBPS/Chapter03.html.page_119">119</a>, <a href="#OEBPS/Chapter03.html.page_120">120</a>, <a href="#OEBPS/Chapter03.html.page_122">122</a>, <a href="#OEBPS/Chapter03.html.page_123">123</a>, <a href="#OEBPS/Chapter03.html.page_125">125</a>, <a href="#OEBPS/Chapter03.html.page_128">128</a>, <a href="#OEBPS/Chapter03.html.page_129">129</a>, <a href="#OEBPS/Chapter03.html.page_130">130</a>, <a href="#OEBPS/Chapter04.html.page_133">133</a>, <a href="#OEBPS/Chapter04.html.page_134">134</a>, <a href="#OEBPS/Chapter04.html.page_136">136</a>, <a href="#OEBPS/Chapter04.html.page_139">139</a>, <a href="#OEBPS/Chapter04.html.page_140">140</a>, <a href="#OEBPS/Chapter04.html.page_141">141</a>, <a href="#OEBPS/Chapter04.html.page_142">142</a>, <a href="#OEBPS/Chapter04.html.page_143">143</a>, <a href="#OEBPS/Chapter04.html.page_144">144</a>, <a href="#OEBPS/Chapter04.html.page_145">145</a>, <a href="#OEBPS/Chapter04.html.page_146">146</a>, <a href="#OEBPS/Chapter04.html.page_147">147</a>, <a href="#OEBPS/Chapter04.html.page_148">148</a>, <a href="#OEBPS/Chapter04.html.page_149">149</a>, <a href="#OEBPS/Chapter04.html.page_150">150</a>, <a href="#OEBPS/Chapter04.html.page_155">155</a>, <a href="#OEBPS/Chapter04.html.page_159">159</a>, <a href="#OEBPS/Chapter04.html.page_160">160</a>, <a href="#OEBPS/Chapter04.html.page_165">165</a>, <a href="#OEBPS/Chapter04.html.page_166">166</a>, <a href="#OEBPS/Chapter10.html.page_373">373</a>, <a href="#OEBPS/Chapter10.html.page_379">379</a>, <a href="#OEBPS/Chapter10.html.page_380">380</a>, <a href="#OEBPS/Chapter10.html.page_381">381</a>, <a href="#OEBPS/Chapter10.html.page_392">392</a>, <a href="#OEBPS/Chapter10.html.page_401">401</a>, <a href="#OEBPS/Chapter10.html.page_405">405</a>, <a href="#OEBPS/Chapter10.html.page_408">408</a></p>
<p class="index"><b>John Reiser C 预处理器</b>，<a href="#OEBPS/Chapter04.html.page_135">135</a></p><p class="index"><b>John Reiser C preprocessor</b>, <a href="#OEBPS/Chapter04.html.page_135">135</a></p>
<p class="index"><b>焦耳</b>, <a href="#OEBPS/Chapter03.html.page_95">95</a></p><p class="index"><b>Joule</b>, <a href="#OEBPS/Chapter03.html.page_95">95</a></p>
<p class="index"><b><i>乔伊，比尔</i></b>，<a href="#OEBPS/Chapter09.html.page_325"> 325</a></p><p class="index"><b><i>Joy, Bill</i></b>, <a href="#OEBPS/Chapter09.html.page_325">325</a></p>
<p class="index"><b>JSLint</b> , <a href="#OEBPS/Chapter03.html.page_114">114</a> , <a href="#OEBPS/Chapter03.html.page_118">118</a> , <a href="#OEBPS/Chapter03.html.page_120">120</a></p><p class="index"><b>JSLint</b>, <a href="#OEBPS/Chapter03.html.page_114">114</a>, <a href="#OEBPS/Chapter03.html.page_118">118</a>, <a href="#OEBPS/Chapter03.html.page_120">120</a></p>
<p class="index"><b><i>JSON</i></b> ,<a href="#OEBPS/Chapter03.html.page_91"> 91</a> ,<a href="#OEBPS/Chapter03.html.page_125"> 125</a></p><p class="index"><b><i>JSON</i></b>, <a href="#OEBPS/Chapter03.html.page_91">91</a>, <a href="#OEBPS/Chapter03.html.page_125">125</a></p>
<p class="index"><b>JS单元</b>, <a href="#OEBPS/Chapter03.html.page_122">122</a></p><p class="index"><b>JsUnit</b>, <a href="#OEBPS/Chapter03.html.page_122">122</a></p>
<h3 class="h3">钾</h3><h3 class="h3">K</h3>
<p class="index"><b>K&amp;R风格</b>, <a href="#OEBPS/Chapter03.html.page_107">107</a> , <a href="#OEBPS/Chapter03.html.page_108">108</a></p><p class="index"><b>K&amp;R style</b>, <a href="#OEBPS/Chapter03.html.page_107">107</a>, <a href="#OEBPS/Chapter03.html.page_108">108</a></p>
<p class="index"><b>凯</b>、<a href="#OEBPS/Chapter10.html.page_404">艾伦</a>、<a href="#OEBPS/Chapter03.html.page_94">94、373、376、378、383、389、391、404</a> _ <a href="#OEBPS/Chapter10.html.page_373">_</a> _ <a href="#OEBPS/Chapter10.html.page_376">_</a> _ <a href="#OEBPS/Chapter10.html.page_378">_</a> _ <a href="#OEBPS/Chapter10.html.page_383">_</a> _ <a href="#OEBPS/Chapter10.html.page_389">_</a> _ <a href="#OEBPS/Chapter10.html.page_391">_</a><a href="#OEBPS/Chapter10.html.page_404"></a></p><p class="index"><b>Kay, Alan</b>, <a href="#OEBPS/Chapter03.html.page_94">94</a>, <a href="#OEBPS/Chapter10.html.page_373">373</a>, <a href="#OEBPS/Chapter10.html.page_376">376</a>, <a href="#OEBPS/Chapter10.html.page_378">378</a>, <a href="#OEBPS/Chapter10.html.page_383">383</a>, <a href="#OEBPS/Chapter10.html.page_389">389</a>, <a href="#OEBPS/Chapter10.html.page_391">391</a>, <a href="#OEBPS/Chapter10.html.page_404">404</a></p>
<p class="index"><b></b><a href="#OEBPS/Chapter03.html.page_124">高</a><a href="#OEBPS/Chapter03.html.page_117">德纳</a>，<b>唐纳德</b>，<a href="#OEBPS/Chapter03.html.page_114">114，115，116，117，124</a> _ <a href="#OEBPS/Chapter03.html.page_115">_</a> _ <a href="#OEBPS/Chapter03.html.page_116">_</a> _<a href="#OEBPS/Chapter03.html.page_117"></a><a href="#OEBPS/Chapter03.html.page_124"></a></p><p class="index"><b>Knuth, Donald</b>, <a href="#OEBPS/Chapter03.html.page_114">114</a>, <a href="#OEBPS/Chapter03.html.page_115">115</a>, <a href="#OEBPS/Chapter03.html.page_116">116</a>, <a href="#OEBPS/Chapter03.html.page_117">117</a>, <a href="#OEBPS/Chapter03.html.page_124">124</a></p>
<p class="index"><b>KWIC指数</b>, <a href="#OEBPS/Chapter09.html.page_328">328</a></p><p class="index"><b>KWIC index</b>, <a href="#OEBPS/Chapter09.html.page_328">328</a></p>
<h3 class="h3">大号</h3><h3 class="h3">L</h3>
<p class="index"><b><i>Lambda 论文</i></b>，<a href="#OEBPS/Chapter09.html.page_325"> 325</a></p><p class="index"><b><i>Lambda Papers, The</i></b>, <a href="#OEBPS/Chapter09.html.page_325">325</a></p>
<p class="index"><b>拉内特，马克</b>，<a href="#OEBPS/Chapter01.html.page_16">16 岁</a></p><p class="index"><b>Lanett, Mark</b>, <a href="#OEBPS/Chapter01.html.page_16">16</a></p>
<p class="index"><b>惰性评估</b>, <a href="#OEBPS/Chapter07.html.page_241">241</a> , <a href="#OEBPS/Chapter07.html.page_257">257</a> , <a href="#OEBPS/Chapter07.html.page_258">258</a> , <a href="#OEBPS/Chapter07.html.page_259">259</a> , <a href="#OEBPS/Chapter07.html.page_260">260</a> , <a href="#OEBPS/Chapter07.html.page_262">262</a></p><p class="index"><b>lazy evaluation</b>, <a href="#OEBPS/Chapter07.html.page_241">241</a>, <a href="#OEBPS/Chapter07.html.page_257">257</a>, <a href="#OEBPS/Chapter07.html.page_258">258</a>, <a href="#OEBPS/Chapter07.html.page_259">259</a>, <a href="#OEBPS/Chapter07.html.page_260">260</a>, <a href="#OEBPS/Chapter07.html.page_262">262</a></p>
<p class="index">l<b>叶节点</b>, <a href="#OEBPS/Chapter01.html.page_37">37</a></p><p class="index">l<b>eaf nodes</b>, <a href="#OEBPS/Chapter01.html.page_37">37</a></p>
<p class="index"><b>里尔森，T. 文森特</b>，<a href="#OEBPS/Chapter09.html.page_326">326</a></p><p class="index"><b>Learson, T. Vincent</b>, <a href="#OEBPS/Chapter09.html.page_326">326</a></p>
<p class="index"><b>Linux</b> , <a href="#OEBPS/Chapter12.html.page_479">479</a></p><p class="index"><b>Linux</b>, <a href="#OEBPS/Chapter12.html.page_479">479</a></p>
<p class="index"><b>口齿不清</b>, <a href="#OEBPS/Chapter01.html.page_3">3</a> , <a href="#OEBPS/Chapter01.html.page_4">4</a> , <a href="#OEBPS/Chapter01.html.page_7">7</a> , <a href="#OEBPS/Chapter01.html.page_8">8</a> , <a href="#OEBPS/Chapter01.html.page_30">30</a> , <a href="#OEBPS/Chapter01.html.page_31">31</a> , <a href="#OEBPS/Chapter03.html.page_127">127</a> , <a href="#OEBPS/Chapter03.html.page_128">128</a> , <a href="#OEBPS/Chapter09.html.page_325">325</a> , <a href="#OEBPS/Chapter09.html.page_329">329</a> , <a href="#OEBPS/Chapter09.html.page_330">330</a> , <a href="#OEBPS/Chapter09.html.page_332">332</a> , <a href="#OEBPS/Chapter09.html.page_336">336</a> , <a href="#OEBPS/Chapter09.html.page_341">341</a> , <a href="#OEBPS/Chapter09.html.page_345">345</a> , <a href="#OEBPS/Chapter09.html.page_350">350</a> , <a href="#OEBPS/Chapter09.html.page_351">351</a> , <a href="#OEBPS/Chapter09.html.page_352">352</a> , <a href="#OEBPS/Chapter09.html.page_353">353</a> , <a href="#OEBPS/Chapter09.html.page_365">365</a> , <a href="#OEBPS/Chapter10.html.page_374">374</a> , <a href="#OEBPS/Chapter10.html.page_377">387</a> , <a href="#OEBPS/Chapter10.html.page_378">387</a> , , <a href="#OEBPS/Chapter10.html.page_387">_ </a><a href="#OEBPS/Chapter11.html.page_413">413</a> , <a href="#OEBPS/Chapter11.html.page_414">414</a> , <a href="#OEBPS/Chapter11.html.page_415">415</a> ,<a href="#OEBPS/Chapter11.html.page_417">417</a> , <a href="#OEBPS/Chapter11.html.page_418">418</a> , <a href="#OEBPS/Chapter11.html.page_425">425</a> , <a href="#OEBPS/Chapter11.html.page_429">429</a> , <a href="#OEBPS/Chapter11.html.page_441">441</a> , <a href="#OEBPS/Chapter11.html.page_442">442</a> , <a href="#OEBPS/Chapter11.html.page_443">443</a> , <a href="#OEBPS/Chapter11.html.page_444">444</a> , <a href="#OEBPS/Chapter11.html.page_445">445</a> , <a href="#OEBPS/Chapter14.html.page_519">519</a> , <a href="#OEBPS/Chapter14.html.page_529">529</a> , <a href="#OEBPS/Chapter14.html.page_537">537</a> , <a href="#OEBPS/Chapter14.html.page_540">540</a> , <a href="#OEBPS/Chapter14.html.page_541">541</a></p><p class="index"><b>Lisp</b>, <a href="#OEBPS/Chapter01.html.page_3">3</a>, <a href="#OEBPS/Chapter01.html.page_4">4</a>, <a href="#OEBPS/Chapter01.html.page_7">7</a>, <a href="#OEBPS/Chapter01.html.page_8">8</a>, <a href="#OEBPS/Chapter01.html.page_30">30</a>, <a href="#OEBPS/Chapter01.html.page_31">31</a>, <a href="#OEBPS/Chapter03.html.page_127">127</a>, <a href="#OEBPS/Chapter03.html.page_128">128</a>, <a href="#OEBPS/Chapter09.html.page_325">325</a>, <a href="#OEBPS/Chapter09.html.page_329">329</a>, <a href="#OEBPS/Chapter09.html.page_330">330</a>, <a href="#OEBPS/Chapter09.html.page_332">332</a>, <a href="#OEBPS/Chapter09.html.page_336">336</a>, <a href="#OEBPS/Chapter09.html.page_341">341</a>, <a href="#OEBPS/Chapter09.html.page_345">345</a>, <a href="#OEBPS/Chapter09.html.page_350">350</a>, <a href="#OEBPS/Chapter09.html.page_351">351</a>, <a href="#OEBPS/Chapter09.html.page_352">352</a>, <a href="#OEBPS/Chapter09.html.page_353">353</a>, <a href="#OEBPS/Chapter09.html.page_365">365</a>, <a href="#OEBPS/Chapter10.html.page_374">374</a>, <a href="#OEBPS/Chapter10.html.page_377">377</a>, <a href="#OEBPS/Chapter10.html.page_378">378</a>, <a href="#OEBPS/Chapter10.html.page_387">387</a>, <a href="#OEBPS/Chapter11.html.page_413">413</a>, <a href="#OEBPS/Chapter11.html.page_414">414</a>, <a href="#OEBPS/Chapter11.html.page_415">415</a>, <a href="#OEBPS/Chapter11.html.page_417">417</a>, <a href="#OEBPS/Chapter11.html.page_418">418</a>, <a href="#OEBPS/Chapter11.html.page_425">425</a>, <a href="#OEBPS/Chapter11.html.page_429">429</a>, <a href="#OEBPS/Chapter11.html.page_441">441</a>, <a href="#OEBPS/Chapter11.html.page_442">442</a>, <a href="#OEBPS/Chapter11.html.page_443">443</a>, <a href="#OEBPS/Chapter11.html.page_444">444</a>, <a href="#OEBPS/Chapter11.html.page_445">445</a>, <a href="#OEBPS/Chapter14.html.page_519">519</a>, <a href="#OEBPS/Chapter14.html.page_529">529</a>, <a href="#OEBPS/Chapter14.html.page_537">537</a>, <a href="#OEBPS/Chapter14.html.page_540">540</a>, <a href="#OEBPS/Chapter14.html.page_541">541</a></p>
<p class="index"><b>扫盲计划</b>, <a href="#OEBPS/Chapter15.html.page_574">574</a> , <a href="#OEBPS/Chapter15.html.page_575">575</a> , <a href="#OEBPS/Chapter15.html.page_578">578</a> , <a href="#OEBPS/Chapter15.html.page_594">594</a></p><p class="index"><b>literate program</b>, <a href="#OEBPS/Chapter15.html.page_574">574</a>, <a href="#OEBPS/Chapter15.html.page_575">575</a>, <a href="#OEBPS/Chapter15.html.page_578">578</a>, <a href="#OEBPS/Chapter15.html.page_594">594</a></p>
<p class="index"><b>识字</b><a href="#OEBPS/Chapter15.html.page_588">编程</a>, <a href="#OEBPS/Chapter03.html.page_109">109</a> , <a href="#OEBPS/Chapter03.html.page_114">114</a> , <a href="#OEBPS/Chapter03.html.page_116">116</a> , <a href="#OEBPS/Chapter08.html.page_317">317</a> , <a href="#OEBPS/Chapter08.html.page_318">318</a> , <a href="#OEBPS/Chapter08.html.page_319">319</a> , <a href="#OEBPS/Chapter10.html.page_407">407</a> , <a href="#OEBPS/Chapter12.html.page_476">476</a> , <a href="#OEBPS/Chapter12.html.page_477">477</a> , <a href="#OEBPS/Chapter15.html.page_565">565</a> , <a href="#OEBPS/Chapter15.html.page_566">566</a> , <a href="#OEBPS/Chapter15.html.page_570">570</a> , <a href="#OEBPS/Chapter15.html.page_571">571</a> , <a href="#OEBPS/Chapter15.html.page_572">572</a> , <a href="#OEBPS/Chapter15.html.page_573">573</a> , <a href="#OEBPS/Chapter15.html.page_575">575</a> , <a href="#OEBPS/Chapter15.html.page_576">576</a> , <a href="#OEBPS/Chapter15.html.page_577">577</a> , <a href="#OEBPS/Chapter15.html.page_578">578</a> , <a href="#OEBPS/Chapter15.html.page_586">586</a> , <a href="#OEBPS/Chapter15.html.page_587">8</a> , 5 <a href="#OEBPS/Chapter15.html.page_584">_</a><a href="#OEBPS/Chapter15.html.page_586"></a><a href="#OEBPS/Chapter15.html.page_587"></a><a href="#OEBPS/Chapter15.html.page_588"></a></p><p class="index"><b>literate programming</b>, <a href="#OEBPS/Chapter03.html.page_109">109</a>, <a href="#OEBPS/Chapter03.html.page_114">114</a>, <a href="#OEBPS/Chapter03.html.page_116">116</a>, <a href="#OEBPS/Chapter08.html.page_317">317</a>, <a href="#OEBPS/Chapter08.html.page_318">318</a>, <a href="#OEBPS/Chapter08.html.page_319">319</a>, <a href="#OEBPS/Chapter10.html.page_407">407</a>, <a href="#OEBPS/Chapter12.html.page_476">476</a>, <a href="#OEBPS/Chapter12.html.page_477">477</a>, <a href="#OEBPS/Chapter15.html.page_565">565</a>, <a href="#OEBPS/Chapter15.html.page_566">566</a>, <a href="#OEBPS/Chapter15.html.page_570">570</a>, <a href="#OEBPS/Chapter15.html.page_571">571</a>, <a href="#OEBPS/Chapter15.html.page_572">572</a>, <a href="#OEBPS/Chapter15.html.page_573">573</a>, <a href="#OEBPS/Chapter15.html.page_575">575</a>, <a href="#OEBPS/Chapter15.html.page_576">576</a>, <a href="#OEBPS/Chapter15.html.page_577">577</a>, <a href="#OEBPS/Chapter15.html.page_578">578</a>, <a href="#OEBPS/Chapter15.html.page_584">584</a>, <a href="#OEBPS/Chapter15.html.page_586">586</a>, <a href="#OEBPS/Chapter15.html.page_587">587</a>, <a href="#OEBPS/Chapter15.html.page_588">588</a></p>
<p class="index"><b>扫盲计划</b>, <a href="#OEBPS/Chapter09.html.page_337">337</a> , <a href="#OEBPS/Chapter09.html.page_338">338</a></p><p class="index"><b>literate programs</b>, <a href="#OEBPS/Chapter09.html.page_337">337</a>, <a href="#OEBPS/Chapter09.html.page_338">338</a></p>
<p class="index"><b><i>LiveJournal</i></b> ,<a href="#OEBPS/Chapter02.html.page_49"> 49</a> ,<a href="#OEBPS/Chapter02.html.page_50"> 50</a> ,<a href="#OEBPS/Chapter02.html.page_54"> 54</a> ,<a href="#OEBPS/Chapter02.html.page_55"> 55</a> ,<a href="#OEBPS/Chapter02.html.page_56"> 56</a> ,<a href="#OEBPS/Chapter02.html.page_57"> 57</a> ,<a href="#OEBPS/Chapter02.html.page_58"> 58</a> ,<a href="#OEBPS/Chapter02.html.page_60"> 60</a> ,<a href="#OEBPS/Chapter02.html.page_65"> 65</a> ,<a href="#OEBPS/Chapter02.html.page_68"> 68</a> ,<a href="#OEBPS/Chapter02.html.page_74"> 74</a> ,<a href="#OEBPS/Chapter02.html.page_75"> 75</a> ,<a href="#OEBPS/Chapter02.html.page_76"> 76</a> ,<a href="#OEBPS/Chapter02.html.page_80"> 80</a> ,<a href="#OEBPS/Chapter02.html.page_82"> 82</a></p><p class="index"><b><i>LiveJournal</i></b>, <a href="#OEBPS/Chapter02.html.page_49">49</a>, <a href="#OEBPS/Chapter02.html.page_50">50</a>, <a href="#OEBPS/Chapter02.html.page_54">54</a>, <a href="#OEBPS/Chapter02.html.page_55">55</a>, <a href="#OEBPS/Chapter02.html.page_56">56</a>, <a href="#OEBPS/Chapter02.html.page_57">57</a>, <a href="#OEBPS/Chapter02.html.page_58">58</a>, <a href="#OEBPS/Chapter02.html.page_60">60</a>, <a href="#OEBPS/Chapter02.html.page_65">65</a>, <a href="#OEBPS/Chapter02.html.page_68">68</a>, <a href="#OEBPS/Chapter02.html.page_74">74</a>, <a href="#OEBPS/Chapter02.html.page_75">75</a>, <a href="#OEBPS/Chapter02.html.page_76">76</a>, <a href="#OEBPS/Chapter02.html.page_80">80</a>, <a href="#OEBPS/Chapter02.html.page_82">82</a></p>
<p class="index"><b><i>活跃内核</i></b>,<a href="#OEBPS/Chapter10.html.page_373"> 373</a> ,<a href="#OEBPS/Chapter10.html.page_379"> 379</a> ,<a href="#OEBPS/Chapter10.html.page_380"> 380</a> ,<a href="#OEBPS/Chapter10.html.page_381"> 381</a> ,<a href="#OEBPS/Chapter10.html.page_382"> 382</a> ,<a href="#OEBPS/Chapter10.html.page_390"> 390</a> ,<a href="#OEBPS/Chapter10.html.page_394"> 394</a> ,<a href="#OEBPS/Chapter10.html.page_404"> 404</a></p><p class="index"><b><i>Lively Kernel</i></b>, <a href="#OEBPS/Chapter10.html.page_373">373</a>, <a href="#OEBPS/Chapter10.html.page_379">379</a>, <a href="#OEBPS/Chapter10.html.page_380">380</a>, <a href="#OEBPS/Chapter10.html.page_381">381</a>, <a href="#OEBPS/Chapter10.html.page_382">382</a>, <a href="#OEBPS/Chapter10.html.page_390">390</a>, <a href="#OEBPS/Chapter10.html.page_394">394</a>, <a href="#OEBPS/Chapter10.html.page_404">404</a></p>
<p class="index"><b>长时间</b>, <a href="#OEBPS/Chapter01.html.page_16">16</a> , <a href="#OEBPS/Chapter02.html.page_75">75</a> , 553 <a href="#OEBPS/Chapter14.html.page_553">_</a></p><p class="index">l<b>ong hours</b>, <a href="#OEBPS/Chapter01.html.page_16">16</a>, <a href="#OEBPS/Chapter02.html.page_75">75</a>, <a href="#OEBPS/Chapter14.html.page_553">553</a></p>
<p class="index"><b>莲花 1-2-3</b> , <a href="#OEBPS/Chapter10.html.page_398">398</a> , <a href="#OEBPS/Chapter10.html.page_410">410</a></p><p class="index"><b>Lotus 1-2-3</b>, <a href="#OEBPS/Chapter10.html.page_398">398</a>, <a href="#OEBPS/Chapter10.html.page_410">410</a></p>
<p class="index"><b><i>LR 解析</i></b>,<a href="#OEBPS/Chapter15.html.page_565"> 565</a></p><p class="index"><b><i>LR parsing</i></b>, <a href="#OEBPS/Chapter15.html.page_565">565</a></p>
<p class="index"><b><i>卢卡斯影业</i></b>,<a href="#OEBPS/Chapter03.html.page_91"> 91</a> ,<a href="#OEBPS/Chapter03.html.page_94"> 94</a> ,<a href="#OEBPS/Chapter03.html.page_95"> 95</a></p><p class="index"><b><i>Lucasfilm</i></b>, <a href="#OEBPS/Chapter03.html.page_91">91</a>, <a href="#OEBPS/Chapter03.html.page_94">94</a>, <a href="#OEBPS/Chapter03.html.page_95">95</a></p>
<p class="index"><b>清醒</b>, <a href="#OEBPS/Chapter01.html.page_6">6</a> , <a href="#OEBPS/Chapter01.html.page_8">8</a> , <a href="#OEBPS/Chapter01.html.page_9">9</a> , <a href="#OEBPS/Chapter01.html.page_10">10</a> , <a href="#OEBPS/Chapter01.html.page_12">12</a> , <a href="#OEBPS/Chapter01.html.page_14">14</a> , <a href="#OEBPS/Chapter01.html.page_39">39</a></p><p class="index"><b>Lucid</b>, <a href="#OEBPS/Chapter01.html.page_6">6</a>, <a href="#OEBPS/Chapter01.html.page_8">8</a>, <a href="#OEBPS/Chapter01.html.page_9">9</a>, <a href="#OEBPS/Chapter01.html.page_10">10</a>, <a href="#OEBPS/Chapter01.html.page_12">12</a>, <a href="#OEBPS/Chapter01.html.page_14">14</a>, <a href="#OEBPS/Chapter01.html.page_39">39</a></p>
<p class="index"><b>Lucid Common Lisp</b> , <a href="#OEBPS/Chapter01.html.page_6">6</a></p><p class="index"><b>Lucid Common Lisp</b>, <a href="#OEBPS/Chapter01.html.page_6">6</a></p>
<h3 class="h3">米</h3><h3 class="h3">M</h3>
<p class="index"><b><i>Maclisp</i></b> ,<a href="#OEBPS/Chapter09.html.page_325"> 325</a> ,<a href="#OEBPS/Chapter09.html.page_330"> 330</a> ,<a href="#OEBPS/Chapter09.html.page_340"> 340</a> ,<a href="#OEBPS/Chapter09.html.page_341"> 341</a> ,<a href="#OEBPS/Chapter09.html.page_342"> 342</a> ,<a href="#OEBPS/Chapter09.html.page_353"> 353</a> ,<a href="#OEBPS/Chapter09.html.page_363"> 363</a></p><p class="index"><b><i>Maclisp</i></b>, <a href="#OEBPS/Chapter09.html.page_325">325</a>, <a href="#OEBPS/Chapter09.html.page_330">330</a>, <a href="#OEBPS/Chapter09.html.page_340">340</a>, <a href="#OEBPS/Chapter09.html.page_341">341</a>, <a href="#OEBPS/Chapter09.html.page_342">342</a>, <a href="#OEBPS/Chapter09.html.page_353">353</a>, <a href="#OEBPS/Chapter09.html.page_363">363</a></p>
<p class="index"><b>麦克西玛</b>, <a href="#OEBPS/Chapter09.html.page_330">330</a> , <a href="#OEBPS/Chapter09.html.page_341">341</a> , <a href="#OEBPS/Chapter09.html.page_363">363</a> , <a href="#OEBPS/Chapter12.html.page_476">476</a></p><p class="index"><b>Macsyma</b>, <a href="#OEBPS/Chapter09.html.page_330">330</a>, <a href="#OEBPS/Chapter09.html.page_341">341</a>, <a href="#OEBPS/Chapter09.html.page_363">363</a>, <a href="#OEBPS/Chapter12.html.page_476">476</a></p>
<p class="index"><b>疯了</b>, <a href="#OEBPS/Chapter13.html.page_489">489</a> , <a href="#OEBPS/Chapter13.html.page_490">490</a></p><p class="index"><b>MAD</b>, <a href="#OEBPS/Chapter13.html.page_489">489</a>, <a href="#OEBPS/Chapter13.html.page_490">490</a></p>
<p class="index"><b>邮件阅读器</b>, <a href="#OEBPS/Chapter01.html.page_17">17</a> , <a href="#OEBPS/Chapter01.html.page_18">18</a> , <a href="#OEBPS/Chapter01.html.page_19">19</a> , <a href="#OEBPS/Chapter01.html.page_21">21</a></p><p class="index"><b>mail reader</b>, <a href="#OEBPS/Chapter01.html.page_17">17</a>, <a href="#OEBPS/Chapter01.html.page_18">18</a>, <a href="#OEBPS/Chapter01.html.page_19">19</a>, <a href="#OEBPS/Chapter01.html.page_21">21</a></p>
<p class="index"><b>维护软件</b>, <a href="#OEBPS/Chapter01.html.page_34">34</a></p><p class="index"><b>maintaining software</b>, <a href="#OEBPS/Chapter01.html.page_34">34</a></p>
<p class="index"><b>枫木</b>, <a href="#OEBPS/Chapter12.html.page_476">476</a></p><p class="index"><b>Maple</b>, <a href="#OEBPS/Chapter12.html.page_476">476</a></p>
<p class="index"><b></b><a href="#OEBPS/Chapter09.html.page_330">马丁</a>，<b>比尔</b>，<a href="#OEBPS/Chapter09.html.page_329">329，330</a><a href="#OEBPS/Chapter09.html.page_330"></a></p><p class="index"><b>Martin, Bill</b>, <a href="#OEBPS/Chapter09.html.page_329">329</a>, <a href="#OEBPS/Chapter09.html.page_330">330</a></p>
<p class="index"><b>混搭</b>, <a href="#OEBPS/Chapter03.html.page_98">98</a> , <a href="#OEBPS/Chapter03.html.page_128">128</a> , <a href="#OEBPS/Chapter03.html.page_129">129</a></p><p class="index"><b>mash-ups</b>, <a href="#OEBPS/Chapter03.html.page_98">98</a>, <a href="#OEBPS/Chapter03.html.page_128">128</a>, <a href="#OEBPS/Chapter03.html.page_129">129</a></p>
<p class="index"><b>数学</b>, <a href="#OEBPS/Chapter01.html.page_44">44</a> , <a href="#OEBPS/Chapter01.html.page_45">45</a> , <a href="#OEBPS/Chapter02.html.page_77">77</a> , <a href="#OEBPS/Chapter02.html.page_81">81</a> , <a href="#OEBPS/Chapter03.html.page_124">124</a> , <a href="#OEBPS/Chapter05.html.page_176">176</a> , <a href="#OEBPS/Chapter05.html.page_183">183</a> , <a href="#OEBPS/Chapter08.html.page_298">298</a> , <a href="#OEBPS/Chapter09.html.page_333">333</a> , <a href="#OEBPS/Chapter09.html.page_339">339</a> , <a href="#OEBPS/Chapter09.html.page_347">347</a> , <a href="#OEBPS/Chapter09.html.page_348">348</a> , <a href="#OEBPS/Chapter09.html.page_366">366</a> , <a href="#OEBPS/Chapter09.html.page_371">371</a> , <a href="#OEBPS/Chapter10.html.page_380">380</a> , <a href="#OEBPS/Chapter10.html.page_397">397</a> , <a href="#OEBPS/Chapter10.html.page_400">400</a> , <a href="#OEBPS/Chapter10.html.page_401">401</a> , <a href="#OEBPS/Chapter12.html.page_450">450</a></p><p class="index"><b>mathematics</b>, <a href="#OEBPS/Chapter01.html.page_44">44</a>, <a href="#OEBPS/Chapter01.html.page_45">45</a>, <a href="#OEBPS/Chapter02.html.page_77">77</a>, <a href="#OEBPS/Chapter02.html.page_81">81</a>, <a href="#OEBPS/Chapter03.html.page_124">124</a>, <a href="#OEBPS/Chapter05.html.page_176">176</a>, <a href="#OEBPS/Chapter05.html.page_183">183</a>, <a href="#OEBPS/Chapter08.html.page_298">298</a>, <a href="#OEBPS/Chapter09.html.page_333">333</a>, <a href="#OEBPS/Chapter09.html.page_339">339</a>, <a href="#OEBPS/Chapter09.html.page_347">347</a>, <a href="#OEBPS/Chapter09.html.page_348">348</a>, <a href="#OEBPS/Chapter09.html.page_366">366</a>, <a href="#OEBPS/Chapter09.html.page_371">371</a>, <a href="#OEBPS/Chapter10.html.page_380">380</a>, <a href="#OEBPS/Chapter10.html.page_397">397</a>, <a href="#OEBPS/Chapter10.html.page_400">400</a>, <a href="#OEBPS/Chapter10.html.page_401">401</a>, <a href="#OEBPS/Chapter12.html.page_450">450</a></p>
<p class="index"><b>麦克洛斯基，迈克</b>，<a href="#OEBPS/Chapter05.html.page_176">176 岁</a></p><p class="index"><b>McCloskey, Mike</b>, <a href="#OEBPS/Chapter05.html.page_176">176</a></p>
<p class="index"><b>麦克罗伊，道格</b>，<a href="#OEBPS/Chapter04.html.page_156">156 岁</a>，<a href="#OEBPS/Chapter04.html.page_157">157 岁</a></p><p class="index"><b>McIlroy, Doug</b>, <a href="#OEBPS/Chapter04.html.page_156">156</a>, <a href="#OEBPS/Chapter04.html.page_157">157</a></p>
<p class="index"><b><i>内存缓存</i></b>,<a href="#OEBPS/Chapter02.html.page_49"> 49</a> ,<a href="#OEBPS/Chapter02.html.page_59"> 59</a> ,<a href="#OEBPS/Chapter02.html.page_60"> 60</a> ,<a href="#OEBPS/Chapter02.html.page_64"> 64</a> ,<a href="#OEBPS/Chapter02.html.page_83"> 83</a></p><p class="index"><b><i>memcached</i></b>, <a href="#OEBPS/Chapter02.html.page_49">49</a>, <a href="#OEBPS/Chapter02.html.page_59">59</a>, <a href="#OEBPS/Chapter02.html.page_60">60</a>, <a href="#OEBPS/Chapter02.html.page_64">64</a>, <a href="#OEBPS/Chapter02.html.page_83">83</a></p>
<p class="index"><b>记忆延迟</b>, <a href="#OEBPS/Chapter13.html.page_491">491</a></p><p class="index"><b>memory latency</b>, <a href="#OEBPS/Chapter13.html.page_491">491</a></p>
<p class="index"><b>指导</b>, <a href="#OEBPS/Chapter13.html.page_500">500</a> , <a href="#OEBPS/Chapter13.html.page_501">501</a></p><p class="index"><b>mentoring</b>, <a href="#OEBPS/Chapter13.html.page_500">500</a>, <a href="#OEBPS/Chapter13.html.page_501">501</a></p>
<p class="index"><b>导师</b>, <a href="#OEBPS/Chapter01.html.page_40">40</a></p><p class="index"><b>mentors</b>, <a href="#OEBPS/Chapter01.html.page_40">40</a></p>
<p class="index"><b>元字体</b>, <a href="#OEBPS/Chapter15.html.page_586">586</a></p><p class="index"><b>Metafont</b>, <a href="#OEBPS/Chapter15.html.page_586">586</a></p>
<p class="index"><b>元字体</b>, <a href="#OEBPS/Chapter09.html.page_369">369</a> , <a href="#OEBPS/Chapter15.html.page_565">565</a></p><p class="index"><b>METAFONT</b>, <a href="#OEBPS/Chapter09.html.page_369">369</a>, <a href="#OEBPS/Chapter15.html.page_565">565</a></p>
<p class="index"><b><i></i></b><a href="#OEBPS/Chapter06.html.page_209">米奇</a>，<b><i>唐纳德</i></b>，<a href="#OEBPS/Chapter06.html.page_205"> 205，208，209</a> _<a href="#OEBPS/Chapter06.html.page_208"> _</a><a href="#OEBPS/Chapter06.html.page_209"></a></p><p class="index"><b><i>Michie, Donald</i></b>, <a href="#OEBPS/Chapter06.html.page_205">205</a>, <a href="#OEBPS/Chapter06.html.page_208">208</a>, <a href="#OEBPS/Chapter06.html.page_209">209</a></p>
<p class="index"><b><i>微软研究院</i></b>,<a href="#OEBPS/Chapter07.html.page_241"> 241</a> ,<a href="#OEBPS/Chapter07.html.page_242"> 242</a> ,<a href="#OEBPS/Chapter07.html.page_250"> 250</a> ,<a href="#OEBPS/Chapter07.html.page_254"> 254</a></p><p class="index"><b><i>Microsoft Research</i></b>, <a href="#OEBPS/Chapter07.html.page_241">241</a>, <a href="#OEBPS/Chapter07.html.page_242">242</a>, <a href="#OEBPS/Chapter07.html.page_250">250</a>, <a href="#OEBPS/Chapter07.html.page_254">254</a></p>
<p class="index"><b><i>MicroUnity</i></b> ,<a href="#OEBPS/Chapter04.html.page_133"> 133</a> ,<a href="#OEBPS/Chapter04.html.page_137"> 137</a></p><p class="index"><b><i>MicroUnity</i></b>, <a href="#OEBPS/Chapter04.html.page_133">133</a>, <a href="#OEBPS/Chapter04.html.page_137">137</a></p>
<p class="index"><b>迁移</b>, <a href="#OEBPS/Chapter02.html.page_59">59</a> , <a href="#OEBPS/Chapter02.html.page_61">61</a> , <a href="#OEBPS/Chapter02.html.page_75">75</a></p><p class="index"><b>migration</b>, <a href="#OEBPS/Chapter02.html.page_59">59</a>, <a href="#OEBPS/Chapter02.html.page_61">61</a>, <a href="#OEBPS/Chapter02.html.page_75">75</a></p>
<p class="index"><b>米兰达，艾略特</b>，<a href="#OEBPS/Chapter11.html.page_441">441</a></p><p class="index"><b>Miranda, Eliot</b>, <a href="#OEBPS/Chapter11.html.page_441">441</a></p>
<p class="index"><b><i>麻省理工</i></b>学院,<a href="#OEBPS/Chapter09.html.page_325"> 325</a> ,<a href="#OEBPS/Chapter09.html.page_327"> 327</a> ,<a href="#OEBPS/Chapter09.html.page_329"> 329</a> ,<a href="#OEBPS/Chapter09.html.page_330"> 330</a> ,<a href="#OEBPS/Chapter09.html.page_331"> 331</a> ,<a href="#OEBPS/Chapter09.html.page_334"> 334</a> ,<a href="#OEBPS/Chapter09.html.page_336"> 336</a> ,<a href="#OEBPS/Chapter09.html.page_342"> 342</a> ,<a href="#OEBPS/Chapter09.html.page_344"> 344</a> ,<a href="#OEBPS/Chapter09.html.page_366"> 366</a> ,<a href="#OEBPS/Chapter11.html.page_413"> 413</a> ,<a href="#OEBPS/Chapter11.html.page_414"> 414</a> ,<a href="#OEBPS/Chapter11.html.page_417"> 417</a> ,<a href="#OEBPS/Chapter11.html.page_425"> 425</a> ,<a href="#OEBPS/Chapter11.html.page_428"> 428</a> ,<a href="#OEBPS/Chapter11.html.page_430"> 430</a> ,<a href="#OEBPS/Chapter11.html.page_438"> 438</a> ,<a href="#OEBPS/Chapter12.html.page_463"> 463</a> ,<a href="#OEBPS/Chapter14.html.page_519"> 519</a> ,<a href="#OEBPS/Chapter14.html.page_521"> 521</a> ,<a href="#OEBPS/Chapter14.html.page_526"> 3</a> ,<a href="#OEBPS/Chapter14.html.page_522"> 522 </a><a href="#OEBPS/Chapter14.html.page_523">_</a><a href="#OEBPS/Chapter14.html.page_526"></a></p><p class="index"><b><i>MIT</i></b>, <a href="#OEBPS/Chapter09.html.page_325">325</a>, <a href="#OEBPS/Chapter09.html.page_327">327</a>, <a href="#OEBPS/Chapter09.html.page_329">329</a>, <a href="#OEBPS/Chapter09.html.page_330">330</a>, <a href="#OEBPS/Chapter09.html.page_331">331</a>, <a href="#OEBPS/Chapter09.html.page_334">334</a>, <a href="#OEBPS/Chapter09.html.page_336">336</a>, <a href="#OEBPS/Chapter09.html.page_342">342</a>, <a href="#OEBPS/Chapter09.html.page_344">344</a>, <a href="#OEBPS/Chapter09.html.page_366">366</a>, <a href="#OEBPS/Chapter11.html.page_413">413</a>, <a href="#OEBPS/Chapter11.html.page_414">414</a>, <a href="#OEBPS/Chapter11.html.page_417">417</a>, <a href="#OEBPS/Chapter11.html.page_425">425</a>, <a href="#OEBPS/Chapter11.html.page_428">428</a>, <a href="#OEBPS/Chapter11.html.page_430">430</a>, <a href="#OEBPS/Chapter11.html.page_438">438</a>, <a href="#OEBPS/Chapter12.html.page_463">463</a>, <a href="#OEBPS/Chapter14.html.page_519">519</a>, <a href="#OEBPS/Chapter14.html.page_521">521</a>, <a href="#OEBPS/Chapter14.html.page_522">522</a>, <a href="#OEBPS/Chapter14.html.page_523">523</a>, <a href="#OEBPS/Chapter14.html.page_526">526</a></p>
<p class="index"><b>米特豪瑟</b>，<b>乔恩</b>，<a href="#OEBPS/Chapter01.html.page_16">16 岁</a></p><p class="index"><b>Mittelhauser</b>, <b>Jon</b>, <a href="#OEBPS/Chapter01.html.page_16">16</a></p>
<p class="index"><b>MMIX 模拟器</b>, <a href="#OEBPS/Chapter15.html.page_576">576</a></p><p class="index"><b>MMIX simulator</b>, <a href="#OEBPS/Chapter15.html.page_576">576</a></p>
<p class="index"><b>嘲笑</b>，<a href="#OEBPS/Chapter02.html.page_69">69</a></p><p class="index"><b>mocks</b>, <a href="#OEBPS/Chapter02.html.page_69">69</a></p>
<p class="index"><b>卢蒙图利</b><a href="#OEBPS/Chapter01.html.page_16">16</a>岁_ <b>_</b><a href="#OEBPS/Chapter01.html.page_16"></a></p><p class="index"><b>Montulli</b>, <b>Lou</b>, <a href="#OEBPS/Chapter01.html.page_16">16</a></p>
<p class="index"><b>穆尔斯，卡尔文</b>，<a href="#OEBPS/Chapter11.html.page_429">429</a></p><p class="index"><b>Mooers, Calvin</b>, <a href="#OEBPS/Chapter11.html.page_429">429</a></p>
<p class="index"><b>摩尔，J. 斯特罗瑟，II</b>，<a href="#OEBPS/Chapter11.html.page_444">444</a></p><p class="index"><b>Moore, J. Strother, II</b>, <a href="#OEBPS/Chapter11.html.page_444">444</a></p>
<p class="index"><b>莫尔，特伦查德</b>，<a href="#OEBPS/Chapter09.html.page_344">344</a></p><p class="index"><b>More, Trenchard</b>, <a href="#OEBPS/Chapter09.html.page_344">344</a></p>
<p class="index"><b>摩根，鲍勃</b>，<a href="#OEBPS/Chapter14.html.page_525">525</a></p><p class="index"><b>Morgan, Bob</b>, <a href="#OEBPS/Chapter14.html.page_525">525</a></p>
<p class="index"><b>晨星</b>，<a href="#OEBPS/Chapter03.html.page_106">筹码</a>，<a href="#OEBPS/Chapter03.html.page_95">95，106</a><a href="#OEBPS/Chapter03.html.page_106"></a></p><p class="index"><b>Morningstar, Chip</b>, <a href="#OEBPS/Chapter03.html.page_95">95</a>, <a href="#OEBPS/Chapter03.html.page_106">106</a></p>
<p class="index"><b>摩西，乔尔</b>，<a href="#OEBPS/Chapter09.html.page_330">330</a></p><p class="index"><b>Moses, Joel</b>, <a href="#OEBPS/Chapter09.html.page_330">330</a></p>
<p class="index"><b>莫斯拉</b>, <a href="#OEBPS/Chapter01.html.page_25">25</a> , <a href="#OEBPS/Chapter04.html.page_133">133</a> , <a href="#OEBPS/Chapter04.html.page_138">138</a> , <a href="#OEBPS/Chapter04.html.page_143">143</a> , <a href="#OEBPS/Chapter04.html.page_150">150</a> , <a href="#OEBPS/Chapter04.html.page_151">151</a> , <a href="#OEBPS/Chapter04.html.page_154">154</a> , <a href="#OEBPS/Chapter04.html.page_156">156</a> , <a href="#OEBPS/Chapter04.html.page_157">157</a> , <a href="#OEBPS/Chapter04.html.page_158">158</a></p><p class="index"><b>Mozilla</b>, <a href="#OEBPS/Chapter01.html.page_25">25</a>, <a href="#OEBPS/Chapter04.html.page_133">133</a>, <a href="#OEBPS/Chapter04.html.page_138">138</a>, <a href="#OEBPS/Chapter04.html.page_143">143</a>, <a href="#OEBPS/Chapter04.html.page_150">150</a>, <a href="#OEBPS/Chapter04.html.page_151">151</a>, <a href="#OEBPS/Chapter04.html.page_154">154</a>, <a href="#OEBPS/Chapter04.html.page_156">156</a>, <a href="#OEBPS/Chapter04.html.page_157">157</a>, <a href="#OEBPS/Chapter04.html.page_158">158</a></p>
<p class="index"><b>操作系统</b>, <a href="#OEBPS/Chapter11.html.page_419">419</a></p><p class="index"><b>MS-DOS</b>, <a href="#OEBPS/Chapter11.html.page_419">419</a></p>
<p class="index"><b></b><a href="#OEBPS/Chapter12.html.page_463">多</a>路<a href="#OEBPS/Chapter12.html.page_458">通信</a>、<b>127、449、458、463 </b><a href="#OEBPS/Chapter03.html.page_127">_</a> _ <a href="#OEBPS/Chapter12.html.page_449">_</a> _<a href="#OEBPS/Chapter12.html.page_458"></a><a href="#OEBPS/Chapter12.html.page_463"></a></p><p class="index"><b>MULTICS</b>, <a href="#OEBPS/Chapter03.html.page_127">127</a>, <a href="#OEBPS/Chapter12.html.page_449">449</a>, <a href="#OEBPS/Chapter12.html.page_458">458</a>, <a href="#OEBPS/Chapter12.html.page_463">463</a></p>
<p class="index"><b>MySQL</b> , <a href="#OEBPS/Chapter02.html.page_60">60</a></p><p class="index"><b>MySQL</b>, <a href="#OEBPS/Chapter02.html.page_60">60</a></p>
<p class="index"><b><i>美国宇航局</i></b>,<a href="#OEBPS/Chapter08.html.page_287"> 287</a> ,<a href="#OEBPS/Chapter08.html.page_288"> 288</a> ,<a href="#OEBPS/Chapter08.html.page_308"> 308</a> ,<a href="#OEBPS/Chapter08.html.page_309"> 309</a> ,<a href="#OEBPS/Chapter08.html.page_311"> 311</a> ,<a href="#OEBPS/Chapter08.html.page_312"> 312</a> ,<a href="#OEBPS/Chapter08.html.page_313"> 313</a></p><p class="index"><b><i>NASA</i></b>, <a href="#OEBPS/Chapter08.html.page_287">287</a>, <a href="#OEBPS/Chapter08.html.page_288">288</a>, <a href="#OEBPS/Chapter08.html.page_308">308</a>, <a href="#OEBPS/Chapter08.html.page_309">309</a>, <a href="#OEBPS/Chapter08.html.page_311">311</a>, <a href="#OEBPS/Chapter08.html.page_312">312</a>, <a href="#OEBPS/Chapter08.html.page_313">313</a></p>
<p class="index"><b>国家安全局/马赛克</b>, <a href="#OEBPS/Chapter01.html.page_14">14</a></p><p class="index"><b>NCSA/Mosaic</b>, <a href="#OEBPS/Chapter01.html.page_14">14</a></p>
<h3 class="h3">否</h3><h3 class="h3">N</h3>
<p class="index"><b>内利亚克</b>, <a href="#OEBPS/Chapter12.html.page_452">452</a> , <a href="#OEBPS/Chapter12.html.page_462">462</a></p><p class="index"><b>NELIAC</b>, <a href="#OEBPS/Chapter12.html.page_452">452</a>, <a href="#OEBPS/Chapter12.html.page_462">462</a></p>
<p class="index"><b></b><a href="#OEBPS/Chapter04.html.page_165">网</a><b>景</b>、<a href="#OEBPS/Chapter01.html.page_10">10、12、14、16、19、21、31、33、34、38、133、137、138、141、143、155、156、157、165</a> _ <a href="#OEBPS/Chapter01.html.page_12">_</a> _ <a href="#OEBPS/Chapter01.html.page_14">_</a> _ <a href="#OEBPS/Chapter01.html.page_16">_</a> _ <a href="#OEBPS/Chapter01.html.page_19">_</a> _ <a href="#OEBPS/Chapter01.html.page_21">_</a> _ <a href="#OEBPS/Chapter01.html.page_31">_</a> _ <a href="#OEBPS/Chapter01.html.page_33">_</a> _ <a href="#OEBPS/Chapter01.html.page_34">_</a> _ <a href="#OEBPS/Chapter01.html.page_38">_</a> _ <a href="#OEBPS/Chapter04.html.page_133">_</a> _ <a href="#OEBPS/Chapter04.html.page_137">_</a> _ <a href="#OEBPS/Chapter04.html.page_138">_</a> _ <a href="#OEBPS/Chapter04.html.page_141">_</a> _ <a href="#OEBPS/Chapter04.html.page_143">_</a> _ <a href="#OEBPS/Chapter04.html.page_155">_</a> _ <a href="#OEBPS/Chapter04.html.page_156">_</a> _ <a href="#OEBPS/Chapter04.html.page_157">_</a> _<a href="#OEBPS/Chapter04.html.page_165"></a></p><p class="index"><b>Netscape</b>, <a href="#OEBPS/Chapter01.html.page_10">10</a>, <a href="#OEBPS/Chapter01.html.page_12">12</a>, <a href="#OEBPS/Chapter01.html.page_14">14</a>, <a href="#OEBPS/Chapter01.html.page_16">16</a>, <a href="#OEBPS/Chapter01.html.page_19">19</a>, <a href="#OEBPS/Chapter01.html.page_21">21</a>, <a href="#OEBPS/Chapter01.html.page_31">31</a>, <a href="#OEBPS/Chapter01.html.page_33">33</a>, <a href="#OEBPS/Chapter01.html.page_34">34</a>, <a href="#OEBPS/Chapter01.html.page_38">38</a>, <a href="#OEBPS/Chapter04.html.page_133">133</a>, <a href="#OEBPS/Chapter04.html.page_137">137</a>, <a href="#OEBPS/Chapter04.html.page_138">138</a>, <a href="#OEBPS/Chapter04.html.page_141">141</a>, <a href="#OEBPS/Chapter04.html.page_143">143</a>, <a href="#OEBPS/Chapter04.html.page_155">155</a>, <a href="#OEBPS/Chapter04.html.page_156">156</a>, <a href="#OEBPS/Chapter04.html.page_157">157</a>, <a href="#OEBPS/Chapter04.html.page_165">165</a></p>
<p class="index"><b>牛顿文字</b>, <a href="#OEBPS/Chapter04.html.page_145">145</a></p><p class="index"><b>NewtonScript</b>, <a href="#OEBPS/Chapter04.html.page_145">145</a></p>
<p class="index"><b></b><a href="#OEBPS/Chapter07.html.page_277">诺曼</a>，<b>亚瑟</b>，<a href="#OEBPS/Chapter07.html.page_255">255，265，277</a> _ <a href="#OEBPS/Chapter07.html.page_265">_</a><a href="#OEBPS/Chapter07.html.page_277"></a></p><p class="index"><b>Norman, Arthur</b>, <a href="#OEBPS/Chapter07.html.page_255">255</a>, <a href="#OEBPS/Chapter07.html.page_265">265</a>, <a href="#OEBPS/Chapter07.html.page_277">277</a></p>
<p class="index"><b>Norvig</b> ,<b>彼得</b>, <a href="#OEBPS/Chapter01.html.page_5">5</a> , <a href="#OEBPS/Chapter01.html.page_6">6</a> , <a href="#OEBPS/Chapter04.html.page_148">148</a> , <a href="#OEBPS/Chapter04.html.page_155">155</a></p><p class="index"><b>Norvig</b>, <b>Peter</b>, <a href="#OEBPS/Chapter01.html.page_5">5</a>, <a href="#OEBPS/Chapter01.html.page_6">6</a>, <a href="#OEBPS/Chapter04.html.page_148">148</a>, <a href="#OEBPS/Chapter04.html.page_155">155</a></p>
<p class="index"><b>纳特，罗伊</b>，<a href="#OEBPS/Chapter13.html.page_488">488</a></p><p class="index"><b>Nutt, Roy</b>, <a href="#OEBPS/Chapter13.html.page_488">488</a></p>
<p class="index"><b>纽约大学</b>, <a href="#OEBPS/Chapter13.html.page_496">496</a> , <a href="#OEBPS/Chapter13.html.page_500">500</a> , <a href="#OEBPS/Chapter13.html.page_512">512</a></p><p class="index"><b>NYU</b>, <a href="#OEBPS/Chapter13.html.page_496">496</a>, <a href="#OEBPS/Chapter13.html.page_500">500</a>, <a href="#OEBPS/Chapter13.html.page_512">512</a></p>
<h3 class="h3">欧</h3><h3 class="h3">O</h3>
<p class="index"><b>罗伯特·奥卡拉汉</b>，<a href="#OEBPS/Chapter04.html.page_152">152岁</a></p><p class="index"><b>O'Callahan, Robert</b>, <a href="#OEBPS/Chapter04.html.page_152">152</a></p>
<p class="index"><b>奥利里，威尔弗雷德 L.</b>，<a href="#OEBPS/Chapter09.html.page_329">329</a></p><p class="index"><b>O'Leary, Wilfred L.</b>, <a href="#OEBPS/Chapter09.html.page_329">329</a></p>
<p class="index"><b>面向对象设计</b>, <a href="#OEBPS/Chapter10.html.page_389">389</a> , <a href="#OEBPS/Chapter11.html.page_434">434</a></p><p class="index"><b>object-oriented design</b>, <a href="#OEBPS/Chapter10.html.page_389">389</a>, <a href="#OEBPS/Chapter11.html.page_434">434</a></p>
<p class="index"><b>面向对象语言</b>, <a href="#OEBPS/Chapter05.html.page_170">170</a></p><p class="index"><b>object-oriented language</b>, <a href="#OEBPS/Chapter05.html.page_170">170</a></p>
<p class="index"><b>面向对象语言</b>, <a href="#OEBPS/Chapter06.html.page_213">213</a></p><p class="index"><b>object-oriented languages</b>, <a href="#OEBPS/Chapter06.html.page_213">213</a></p>
<p class="index"><b>面向对象编程</b>, <a href="#OEBPS/Chapter07.html.page_247">247</a> , <a href="#OEBPS/Chapter15.html.page_596">596</a></p><p class="index"><b>object-oriented programming</b>, <a href="#OEBPS/Chapter07.html.page_247">247</a>, <a href="#OEBPS/Chapter15.html.page_596">596</a></p>
<p class="index"><b>OCaml</b>，<a href="#OEBPS/Chapter04.html.page_161">161</a>，<a href="#OEBPS/Chapter04.html.page_162">162</a>，<a href="#OEBPS/Chapter04.html.page_163">163</a>，<a href="#OEBPS/Chapter06.html.page_222">222</a></p><p class="index"><b>OCaml</b>, <a href="#OEBPS/Chapter04.html.page_161">161</a>, <a href="#OEBPS/Chapter04.html.page_162">162</a>, <a href="#OEBPS/Chapter04.html.page_163">163</a>, <a href="#OEBPS/Chapter06.html.page_222">222</a></p>
<p class="index"><b>OO（面向对象语言）</b>，<a href="#OEBPS/Chapter05.html.page_171">171</a></p><p class="index"><b>OO (object -oriented language)</b>, <a href="#OEBPS/Chapter05.html.page_171">171</a></p>
<p class="index"><b><i>开放电信平台 (OTP)</i></b> ,<a href="#OEBPS/Chapter06.html.page_205"> 205</a></p><p class="index"><b><i>Open Telecom Platform (OTP)</i></b>, <a href="#OEBPS/Chapter06.html.page_205">205</a></p>
<p class="index"><b>优化</b>, <a href="#OEBPS/Chapter02.html.page_80">80</a> , <a href="#OEBPS/Chapter12.html.page_462">462</a> , <a href="#OEBPS/Chapter12.html.page_469">469</a> , <a href="#OEBPS/Chapter12.html.page_470">470</a></p><p class="index"><b>optimization</b>, <a href="#OEBPS/Chapter02.html.page_80">80</a>, <a href="#OEBPS/Chapter12.html.page_462">462</a>, <a href="#OEBPS/Chapter12.html.page_469">469</a>, <a href="#OEBPS/Chapter12.html.page_470">470</a></p>
<p class="index"><b>组织</b>, <a href="#OEBPS/Chapter01.html.page_36">36</a></p><p class="index"><b>organization</b>, <a href="#OEBPS/Chapter01.html.page_36">36</a></p>
<p class="index"><b><i>OTP（开放</i></b>式<a href="#OEBPS/Chapter06.html.page_211">电信</a><a href="#OEBPS/Chapter06.html.page_230">平台</a>）、<a href="#OEBPS/Chapter06.html.page_205"> 205、211、230</a><a href="#OEBPS/Chapter06.html.page_211"></a><a href="#OEBPS/Chapter06.html.page_230"></a></p><p class="index"><b><i>OTP (Open Telecom Platform)</i></b>, <a href="#OEBPS/Chapter06.html.page_205">205</a>, <a href="#OEBPS/Chapter06.html.page_211">211</a>, <a href="#OEBPS/Chapter06.html.page_230">230</a></p>
<p class="index"><b>过度工程</b>, <a href="#OEBPS/Chapter01.html.page_22">22</a> , <a href="#OEBPS/Chapter01.html.page_23">23</a></p><p class="index"><b>overengineering</b>, <a href="#OEBPS/Chapter01.html.page_22">22</a>, <a href="#OEBPS/Chapter01.html.page_23">23</a></p>
<p class="index"><b>所有权</b>, <a href="#OEBPS/Chapter02.html.page_73">73</a></p><p class="index"><b>ownership</b>, <a href="#OEBPS/Chapter02.html.page_73">73</a></p>
<h3 class="h3">P</h3><h3 class="h3">P</h3>
<p class="index"><b>结对编程</b>, <a href="#OEBPS/Chapter02.html.page_72">72</a> , <a href="#OEBPS/Chapter06.html.page_228">228</a> , <a href="#OEBPS/Chapter06.html.page_229">229</a> , <a href="#OEBPS/Chapter08.html.page_288">288</a> , <a href="#OEBPS/Chapter08.html.page_294">294</a> , <a href="#OEBPS/Chapter08.html.page_295">295</a> , <a href="#OEBPS/Chapter10.html.page_395">395</a> , <a href="#OEBPS/Chapter12.html.page_480">480</a></p><p class="index"><b>pair programming</b>, <a href="#OEBPS/Chapter02.html.page_72">72</a>, <a href="#OEBPS/Chapter06.html.page_228">228</a>, <a href="#OEBPS/Chapter06.html.page_229">229</a>, <a href="#OEBPS/Chapter08.html.page_288">288</a>, <a href="#OEBPS/Chapter08.html.page_294">294</a>, <a href="#OEBPS/Chapter08.html.page_295">295</a>, <a href="#OEBPS/Chapter10.html.page_395">395</a>, <a href="#OEBPS/Chapter12.html.page_480">480</a></p>
<p class="index"><b>并行度</b>, <a href="#OEBPS/Chapter06.html.page_237">237</a> , <a href="#OEBPS/Chapter06.html.page_238">238</a> , <a href="#OEBPS/Chapter13.html.page_495">495</a> , <a href="#OEBPS/Chapter13.html.page_496">496</a> , <a href="#OEBPS/Chapter13.html.page_497">497</a> , <a href="#OEBPS/Chapter13.html.page_505">505</a></p><p class="index"><b>parallelism</b>, <a href="#OEBPS/Chapter06.html.page_237">237</a>, <a href="#OEBPS/Chapter06.html.page_238">238</a>, <a href="#OEBPS/Chapter13.html.page_495">495</a>, <a href="#OEBPS/Chapter13.html.page_496">496</a>, <a href="#OEBPS/Chapter13.html.page_497">497</a>, <a href="#OEBPS/Chapter13.html.page_505">505</a></p>
<p class="index"><b><i>ParcPlace</i></b> ,<a href="#OEBPS/Chapter11.html.page_413"> 413</a> ,<a href="#OEBPS/Chapter11.html.page_418"> 418</a> ,<a href="#OEBPS/Chapter11.html.page_434"> 434</a> ,<a href="#OEBPS/Chapter11.html.page_439"> 439</a></p><p class="index"><b><i>ParcPlace</i></b>, <a href="#OEBPS/Chapter11.html.page_413">413</a>, <a href="#OEBPS/Chapter11.html.page_418">418</a>, <a href="#OEBPS/Chapter11.html.page_434">434</a>, <a href="#OEBPS/Chapter11.html.page_439">439</a></p>
<p class="index"><b>帕斯卡</b>, <a href="#OEBPS/Chapter02.html.page_52">52</a> , <a href="#OEBPS/Chapter04.html.page_134">134</a> , <a href="#OEBPS/Chapter04.html.page_135">135</a> , <a href="#OEBPS/Chapter09.html.page_335">335</a> , <a href="#OEBPS/Chapter09.html.page_338">338</a> , <a href="#OEBPS/Chapter09.html.page_349">349</a> , <a href="#OEBPS/Chapter14.html.page_557">557</a> , <a href="#OEBPS/Chapter14.html.page_558">558</a></p><p class="index"><b>Pascal</b>, <a href="#OEBPS/Chapter02.html.page_52">52</a>, <a href="#OEBPS/Chapter04.html.page_134">134</a>, <a href="#OEBPS/Chapter04.html.page_135">135</a>, <a href="#OEBPS/Chapter09.html.page_335">335</a>, <a href="#OEBPS/Chapter09.html.page_338">338</a>, <a href="#OEBPS/Chapter09.html.page_349">349</a>, <a href="#OEBPS/Chapter14.html.page_557">557</a>, <a href="#OEBPS/Chapter14.html.page_558">558</a></p>
<p class="index"><b>Perl</b> , <a href="#OEBPS/Chapter01.html.page_11">11</a> , <a href="#OEBPS/Chapter02.html.page_49">49</a> , <a href="#OEBPS/Chapter02.html.page_53">53</a> , <a href="#OEBPS/Chapter02.html.page_55">55</a> , <a href="#OEBPS/Chapter02.html.page_56">56</a> , <a href="#OEBPS/Chapter02.html.page_59">59</a> , <a href="#OEBPS/Chapter02.html.page_62">62</a> , <a href="#OEBPS/Chapter02.html.page_63">63</a> , <a href="#OEBPS/Chapter02.html.page_64">64</a> , <a href="#OEBPS/Chapter02.html.page_76">76</a> , <a href="#OEBPS/Chapter02.html.page_79">79</a> , <a href="#OEBPS/Chapter02.html.page_80">80</a> , <a href="#OEBPS/Chapter02.html.page_81">81</a> , <a href="#OEBPS/Chapter02.html.page_86">86</a> , <a href="#OEBPS/Chapter09.html.page_354">354</a> , <a href="#OEBPS/Chapter11.html.page_442">442</a> , <a href="#OEBPS/Chapter14.html.page_528">528</a> , <a href="#OEBPS/Chapter14.html.page_542">542</a> , <a href="#OEBPS/Chapter14.html.page_546">546</a> , <a href="#OEBPS/Chapter14.html.page_558">558</a> , <a href="#OEBPS/Chapter14.html.page_559">559</a></p><p class="index"><b>Perl</b>, <a href="#OEBPS/Chapter01.html.page_11">11</a>, <a href="#OEBPS/Chapter02.html.page_49">49</a>, <a href="#OEBPS/Chapter02.html.page_53">53</a>, <a href="#OEBPS/Chapter02.html.page_55">55</a>, <a href="#OEBPS/Chapter02.html.page_56">56</a>, <a href="#OEBPS/Chapter02.html.page_59">59</a>, <a href="#OEBPS/Chapter02.html.page_62">62</a>, <a href="#OEBPS/Chapter02.html.page_63">63</a>, <a href="#OEBPS/Chapter02.html.page_64">64</a>, <a href="#OEBPS/Chapter02.html.page_76">76</a>, <a href="#OEBPS/Chapter02.html.page_79">79</a>, <a href="#OEBPS/Chapter02.html.page_80">80</a>, <a href="#OEBPS/Chapter02.html.page_81">81</a>, <a href="#OEBPS/Chapter02.html.page_86">86</a>, <a href="#OEBPS/Chapter09.html.page_354">354</a>, <a href="#OEBPS/Chapter11.html.page_442">442</a>, <a href="#OEBPS/Chapter14.html.page_528">528</a>, <a href="#OEBPS/Chapter14.html.page_542">542</a>, <a href="#OEBPS/Chapter14.html.page_546">546</a>, <a href="#OEBPS/Chapter14.html.page_558">558</a>, <a href="#OEBPS/Chapter14.html.page_559">559</a></p>
<p class="index"><b><i>珀尔巴尔</i></b>,<a href="#OEBPS/Chapter02.html.page_49"> 49</a> ,<a href="#OEBPS/Chapter02.html.page_59"> 59</a> ,<a href="#OEBPS/Chapter02.html.page_60"> 60</a> ,<a href="#OEBPS/Chapter02.html.page_62"> 62</a> ,<a href="#OEBPS/Chapter02.html.page_86"> 86</a></p><p class="index"><b><i>Perlbal</i></b>, <a href="#OEBPS/Chapter02.html.page_49">49</a>, <a href="#OEBPS/Chapter02.html.page_59">59</a>, <a href="#OEBPS/Chapter02.html.page_60">60</a>, <a href="#OEBPS/Chapter02.html.page_62">62</a>, <a href="#OEBPS/Chapter02.html.page_86">86</a></p>
<p class="index"><b>照片托管服务</b>, <a href="#OEBPS/Chapter02.html.page_57">57</a></p><p class="index"><b>photo hosting-service</b>, <a href="#OEBPS/Chapter02.html.page_57">57</a></p>
<p class="index"><b>PL/I</b> , <a href="#OEBPS/Chapter09.html.page_327">327</a> , <a href="#OEBPS/Chapter09.html.page_349">349</a> , <a href="#OEBPS/Chapter10.html.page_377">377</a> , <a href="#OEBPS/Chapter13.html.page_499">499</a></p><p class="index"><b>PL/I</b>, <a href="#OEBPS/Chapter09.html.page_327">327</a>, <a href="#OEBPS/Chapter09.html.page_349">349</a>, <a href="#OEBPS/Chapter10.html.page_377">377</a>, <a href="#OEBPS/Chapter13.html.page_499">499</a></p>
<p class="index"><b>PL/Z</b> , <a href="#OEBPS/Chapter07.html.page_248">248</a></p><p class="index"><b>PL/Z</b>, <a href="#OEBPS/Chapter07.html.page_248">248</a></p>
<p class="index"><b><i>计划 9</i></b> ,<a href="#OEBPS/Chapter12.html.page_449"> 449</a> ,<a href="#OEBPS/Chapter12.html.page_479"> 479</a></p><p class="index"><b><i>Plan 9</i></b>, <a href="#OEBPS/Chapter12.html.page_449">449</a>, <a href="#OEBPS/Chapter12.html.page_479">479</a></p>
<p class="index"><b>后记</b>, <a href="#OEBPS/Chapter11.html.page_418">418</a> , <a href="#OEBPS/Chapter11.html.page_419">419</a> , <a href="#OEBPS/Chapter11.html.page_420">420</a> , <a href="#OEBPS/Chapter11.html.page_433">433</a></p><p class="index"><b>PostScript</b>, <a href="#OEBPS/Chapter11.html.page_418">418</a>, <a href="#OEBPS/Chapter11.html.page_419">419</a>, <a href="#OEBPS/Chapter11.html.page_420">420</a>, <a href="#OEBPS/Chapter11.html.page_433">433</a></p>
<p class="index"><b><i>幻灯片</i></b>,<a href="#OEBPS/Chapter08.html.page_287"> 287</a></p><p class="index"><b><i>PowerPoint</i></b>, <a href="#OEBPS/Chapter08.html.page_287">287</a></p>
<p class="index">编程与写作，<a href="#OEBPS/Chapter01.html.page_26">26</a></p><p class="index">programming versus writing, <a href="#OEBPS/Chapter01.html.page_26">26</a></p>
<p class="index"><b><i>精灵计划</i></b>,<a href="#OEBPS/Chapter11.html.page_413"> 413</a> ,<a href="#OEBPS/Chapter11.html.page_417"> 417</a> ,<a href="#OEBPS/Chapter11.html.page_425"> 425</a></p><p class="index"><b><i>Project Genie</i></b>, <a href="#OEBPS/Chapter11.html.page_413">413</a>, <a href="#OEBPS/Chapter11.html.page_417">417</a>, <a href="#OEBPS/Chapter11.html.page_425">425</a></p>
<p class="index"><b>MAC</b><a href="#OEBPS/Chapter14.html.page_526">项目</a>，<a href="#OEBPS/Chapter14.html.page_521">521，522，526</a> _ <a href="#OEBPS/Chapter14.html.page_522">_</a> _<a href="#OEBPS/Chapter14.html.page_526"></a></p><p class="index"><b>Project MAC</b>, <a href="#OEBPS/Chapter14.html.page_521">521</a>, <a href="#OEBPS/Chapter14.html.page_522">522</a>, <a href="#OEBPS/Chapter14.html.page_526">526</a></p>
<p class="index"><b><i>序言</i></b>,<a href="#OEBPS/Chapter06.html.page_205"> 205</a> ,<a href="#OEBPS/Chapter06.html.page_213"> 213</a> ,<a href="#OEBPS/Chapter06.html.page_221"> 221</a> ,<a href="#OEBPS/Chapter06.html.page_224"> 224</a> ,<a href="#OEBPS/Chapter06.html.page_225"> 225</a> ,<a href="#OEBPS/Chapter06.html.page_233"> 233</a></p><p class="index"><b><i>Prolog</i></b>, <a href="#OEBPS/Chapter06.html.page_205">205</a>, <a href="#OEBPS/Chapter06.html.page_213">213</a>, <a href="#OEBPS/Chapter06.html.page_221">221</a>, <a href="#OEBPS/Chapter06.html.page_224">224</a>, <a href="#OEBPS/Chapter06.html.page_225">225</a>, <a href="#OEBPS/Chapter06.html.page_233">233</a></p>
<p class="index"><b><i>证明</i></b>,<a href="#OEBPS/Chapter09.html.page_326"> 326</a> ,<a href="#OEBPS/Chapter09.html.page_364"> 364</a> ,<a href="#OEBPS/Chapter09.html.page_366"> 366</a> ,<a href="#OEBPS/Chapter09.html.page_367"> 367</a> ,<a href="#OEBPS/Chapter09.html.page_368"> 368</a></p><p class="index"><b><i>proofs</i></b>, <a href="#OEBPS/Chapter09.html.page_326">326</a>, <a href="#OEBPS/Chapter09.html.page_364">364</a>, <a href="#OEBPS/Chapter09.html.page_366">366</a>, <a href="#OEBPS/Chapter09.html.page_367">367</a>, <a href="#OEBPS/Chapter09.html.page_368">368</a></p>
<p class="index"><b>原型制作</b>, <a href="#OEBPS/Chapter08.html.page_303">303</a> , <a href="#OEBPS/Chapter08.html.page_304">304</a></p><p class="index"><b>prototyping</b>, <a href="#OEBPS/Chapter08.html.page_303">303</a>, <a href="#OEBPS/Chapter08.html.page_304">304</a></p>
<p class="index"><b><i>PTRAN</i></b> ,<a href="#OEBPS/Chapter13.html.page_485"> 485</a> ,<a href="#OEBPS/Chapter13.html.page_489"> 489</a> ,<a href="#OEBPS/Chapter13.html.page_495"> 495</a> ,<a href="#OEBPS/Chapter13.html.page_496"> 496</a> ,<a href="#OEBPS/Chapter13.html.page_499"> 499</a> ,<a href="#OEBPS/Chapter13.html.page_506"> 506</a> ,<a href="#OEBPS/Chapter13.html.page_507"> 507</a> ,<a href="#OEBPS/Chapter13.html.page_512"> 512</a></p><p class="index"><b><i>PTRAN</i></b>, <a href="#OEBPS/Chapter13.html.page_485">485</a>, <a href="#OEBPS/Chapter13.html.page_489">489</a>, <a href="#OEBPS/Chapter13.html.page_495">495</a>, <a href="#OEBPS/Chapter13.html.page_496">496</a>, <a href="#OEBPS/Chapter13.html.page_499">499</a>, <a href="#OEBPS/Chapter13.html.page_506">506</a>, <a href="#OEBPS/Chapter13.html.page_507">507</a>, <a href="#OEBPS/Chapter13.html.page_512">512</a></p>
<p class="index"><b>蟒蛇</b>, <a href="#OEBPS/Chapter07.html.page_252">252</a> , <a href="#OEBPS/Chapter07.html.page_258">258</a> , <a href="#OEBPS/Chapter09.html.page_357">357</a> , <a href="#OEBPS/Chapter11.html.page_435">435</a> , <a href="#OEBPS/Chapter11.html.page_436">436</a> , <a href="#OEBPS/Chapter11.html.page_439">439</a> , <a href="#OEBPS/Chapter11.html.page_440">440</a> , <a href="#OEBPS/Chapter11.html.page_441">441</a> , <a href="#OEBPS/Chapter11.html.page_442">442</a> , <a href="#OEBPS/Chapter11.html.page_443">443</a> , <a href="#OEBPS/Chapter11.html.page_444">444</a> , <a href="#OEBPS/Chapter11.html.page_447">447</a></p><p class="index"><b>Python</b>, <a href="#OEBPS/Chapter07.html.page_252">252</a>, <a href="#OEBPS/Chapter07.html.page_258">258</a>, <a href="#OEBPS/Chapter09.html.page_357">357</a>, <a href="#OEBPS/Chapter11.html.page_435">435</a>, <a href="#OEBPS/Chapter11.html.page_436">436</a>, <a href="#OEBPS/Chapter11.html.page_439">439</a>, <a href="#OEBPS/Chapter11.html.page_440">440</a>, <a href="#OEBPS/Chapter11.html.page_441">441</a>, <a href="#OEBPS/Chapter11.html.page_442">442</a>, <a href="#OEBPS/Chapter11.html.page_443">443</a>, <a href="#OEBPS/Chapter11.html.page_444">444</a>, <a href="#OEBPS/Chapter11.html.page_447">447</a></p>
<p class="index">质量, 代码, <a href="#OEBPS/Chapter01.html.page_17">17</a></p><p class="index">quality, code, <a href="#OEBPS/Chapter01.html.page_17">17</a></p>
<h3 class="h3">问</h3><h3 class="h3">Q</h3>
<p class="index"><b>快速检查</b>, <a href="#OEBPS/Chapter07.html.page_267">267</a> , <a href="#OEBPS/Chapter07.html.page_270">270</a></p><p class="index"><b>QuickCheck</b>, <a href="#OEBPS/Chapter07.html.page_267">267</a>, <a href="#OEBPS/Chapter07.html.page_270">270</a></p>
<h3 class="h3">R</h3><h3 class="h3">R</h3>
<p class="index"><b>拉姆齐，诺曼</b>，<a href="#OEBPS/Chapter07.html.page_265">265</a></p><p class="index"><b>Ramsey, Norman</b>, <a href="#OEBPS/Chapter07.html.page_265">265</a></p>
<p class="index"><b>读码</b>, <a href="#OEBPS/Chapter04.html.page_157">157</a> , <a href="#OEBPS/Chapter04.html.page_158">158</a> , <a href="#OEBPS/Chapter09.html.page_334">334</a> , <a href="#OEBPS/Chapter09.html.page_337">337</a> , <a href="#OEBPS/Chapter09.html.page_338">338</a> , <a href="#OEBPS/Chapter09.html.page_339">339</a> , <a href="#OEBPS/Chapter10.html.page_407">407</a> , <a href="#OEBPS/Chapter12.html.page_479">479</a> , <a href="#OEBPS/Chapter13.html.page_489">489</a> , <a href="#OEBPS/Chapter14.html.page_545">545</a> , <a href="#OEBPS/Chapter14.html.page_547">547</a> , <a href="#OEBPS/Chapter15.html.page_600">600</a></p><p class="index"><b>reading code</b>, <a href="#OEBPS/Chapter04.html.page_157">157</a>, <a href="#OEBPS/Chapter04.html.page_158">158</a>, <a href="#OEBPS/Chapter09.html.page_334">334</a>, <a href="#OEBPS/Chapter09.html.page_337">337</a>, <a href="#OEBPS/Chapter09.html.page_338">338</a>, <a href="#OEBPS/Chapter09.html.page_339">339</a>, <a href="#OEBPS/Chapter10.html.page_407">407</a>, <a href="#OEBPS/Chapter12.html.page_479">479</a>, <a href="#OEBPS/Chapter13.html.page_489">489</a>, <a href="#OEBPS/Chapter14.html.page_545">545</a>, <a href="#OEBPS/Chapter14.html.page_547">547</a>, <a href="#OEBPS/Chapter15.html.page_600">600</a></p>
<p class="index"><b>重构</b>, <a href="#OEBPS/Chapter01.html.page_28">28</a> , <a href="#OEBPS/Chapter03.html.page_106">106</a> , <a href="#OEBPS/Chapter03.html.page_110">110</a> , <a href="#OEBPS/Chapter03.html.page_117">117</a> , <a href="#OEBPS/Chapter05.html.page_180">180</a> , <a href="#OEBPS/Chapter07.html.page_278">278</a> , <a href="#OEBPS/Chapter07.html.page_285">285</a> , <a href="#OEBPS/Chapter14.html.page_550">550</a> , <a href="#OEBPS/Chapter14.html.page_551">551</a></p><p class="index"><b>refactoring</b>, <a href="#OEBPS/Chapter01.html.page_28">28</a>, <a href="#OEBPS/Chapter03.html.page_106">106</a>, <a href="#OEBPS/Chapter03.html.page_110">110</a>, <a href="#OEBPS/Chapter03.html.page_117">117</a>, <a href="#OEBPS/Chapter05.html.page_180">180</a>, <a href="#OEBPS/Chapter07.html.page_278">278</a>, <a href="#OEBPS/Chapter07.html.page_285">285</a>, <a href="#OEBPS/Chapter14.html.page_550">550</a>, <a href="#OEBPS/Chapter14.html.page_551">551</a></p>
<p class="index"><b>电子研究实验室 (RLE)</b> , <a href="#OEBPS/Chapter14.html.page_521">521</a></p><p class="index"><b>Research Lab of Electronics (RLE)</b>, <a href="#OEBPS/Chapter14.html.page_521">521</a></p>
<p class="index"><b>重写</b>, <a href="#OEBPS/Chapter01.html.page_35">35</a></p><p class="index"><b>rewriting</b>, <a href="#OEBPS/Chapter01.html.page_35">35</a></p>
<p class="index"><b><i>里奇</i></b>，<a href="#OEBPS/Chapter12.html.page_471">丹尼斯</a>，<a href="#OEBPS/Chapter12.html.page_449"> 449，461，471</a> _<a href="#OEBPS/Chapter12.html.page_461"> _</a><a href="#OEBPS/Chapter12.html.page_471"></a></p><p class="index"><b><i>Ritchie, Dennis</i></b>, <a href="#OEBPS/Chapter12.html.page_449">449</a>, <a href="#OEBPS/Chapter12.html.page_461">461</a>, <a href="#OEBPS/Chapter12.html.page_471">471</a></p>
<p class="index"><b>RLE</b> , <a href="#OEBPS/Chapter14.html.page_521">521</a> , <a href="#OEBPS/Chapter14.html.page_522">522</a></p><p class="index"><b>RLE</b>, <a href="#OEBPS/Chapter14.html.page_521">521</a>, <a href="#OEBPS/Chapter14.html.page_522">522</a></p>
<p class="index"><b>罗切斯特，自然</b>，<a href="#OEBPS/Chapter13.html.page_506">506</a></p><p class="index"><b>Rochester, Nat</b>, <a href="#OEBPS/Chapter13.html.page_506">506</a></p>
<p class="index"><b>红宝石</b>, <a href="#OEBPS/Chapter04.html.page_147">147</a> , <a href="#OEBPS/Chapter04.html.page_158">158</a></p><p class="index"><b>Ruby</b>, <a href="#OEBPS/Chapter04.html.page_147">147</a>, <a href="#OEBPS/Chapter04.html.page_158">158</a></p>
<h3 class="h3">小号</h3><h3 class="h3">S</h3>
<p class="index"><b>S-1 口齿不清</b>，<a href="#OEBPS/Chapter09.html.page_353">353</a></p><p class="index"><b>S-1 Lisp</b>, <a href="#OEBPS/Chapter09.html.page_353">353</a></p>
<p class="index"><b>旧金山州</b>，<a href="#OEBPS/Chapter03.html.page_92">92</a></p><p class="index"><b>San Francisco State</b>, <a href="#OEBPS/Chapter03.html.page_92">92</a></p>
<p class="index"><b>圣克拉拉</b>，<a href="#OEBPS/Chapter04.html.page_134">134</a></p><p class="index"><b>Santa Clara</b>, <a href="#OEBPS/Chapter04.html.page_134">134</a></p>
<p class="index"><b>斯卡拉</b>, <a href="#OEBPS/Chapter05.html.page_192">192</a> , <a href="#OEBPS/Chapter05.html.page_197">197</a> , <a href="#OEBPS/Chapter05.html.page_198">198</a></p><p class="index"><b>Scala</b>, <a href="#OEBPS/Chapter05.html.page_192">192</a>, <a href="#OEBPS/Chapter05.html.page_197">197</a>, <a href="#OEBPS/Chapter05.html.page_198">198</a></p>
<p class="index"><b>方案</b>, <a href="#OEBPS/Chapter03.html.page_96">96</a> , <a href="#OEBPS/Chapter03.html.page_128">128</a> , <a href="#OEBPS/Chapter05.html.page_197">197</a> , <a href="#OEBPS/Chapter09.html.page_325">325</a> , <a href="#OEBPS/Chapter09.html.page_350">350</a> , <a href="#OEBPS/Chapter09.html.page_351">351</a> , <a href="#OEBPS/Chapter09.html.page_353">353</a> , <a href="#OEBPS/Chapter09.html.page_355">355</a></p><p class="index"><b>Scheme</b>, <a href="#OEBPS/Chapter03.html.page_96">96</a>, <a href="#OEBPS/Chapter03.html.page_128">128</a>, <a href="#OEBPS/Chapter05.html.page_197">197</a>, <a href="#OEBPS/Chapter09.html.page_325">325</a>, <a href="#OEBPS/Chapter09.html.page_350">350</a>, <a href="#OEBPS/Chapter09.html.page_351">351</a>, <a href="#OEBPS/Chapter09.html.page_353">353</a>, <a href="#OEBPS/Chapter09.html.page_355">355</a></p>
<p class="index"><b>勋伯格，伊迪丝</b>，<a href="#OEBPS/Chapter13.html.page_514">514</a></p><p class="index"><b>Schonberg, Edith</b>, <a href="#OEBPS/Chapter13.html.page_514">514</a></p>
<p class="index"><b>科幻小说</b>, <a href="#OEBPS/Chapter01.html.page_3">3</a></p><p class="index"><b>science fiction</b>, <a href="#OEBPS/Chapter01.html.page_3">3</a></p>
<p class="index"><b>第二系统效应</b>, <a href="#OEBPS/Chapter03.html.page_112">112</a></p><p class="index"><b>second-system effect</b>, <a href="#OEBPS/Chapter03.html.page_112">112</a></p>
<p class="index">第二<b>系统综合症</b>, <a href="#OEBPS/Chapter01.html.page_15">15</a> , <a href="#OEBPS/Chapter01.html.page_20">20</a></p><p class="index">s<b>econd-system syndrome</b>, <a href="#OEBPS/Chapter01.html.page_15">15</a>, <a href="#OEBPS/Chapter01.html.page_20">20</a></p>
<p class="index"><b>自我</b>, <a href="#OEBPS/Chapter04.html.page_144">144</a> , <a href="#OEBPS/Chapter04.html.page_145">145</a></p><p class="index"><b>Self</b>, <a href="#OEBPS/Chapter04.html.page_144">144</a>, <a href="#OEBPS/Chapter04.html.page_145">145</a></p>
<p class="index"><b>自学程序员</b>, <a href="#OEBPS/Chapter01.html.page_42">42</a> , <a href="#OEBPS/Chapter02.html.page_69">69</a> , <a href="#OEBPS/Chapter03.html.page_129">129</a></p><p class="index"><b>self-taught programmers</b>, <a href="#OEBPS/Chapter01.html.page_42">42</a>, <a href="#OEBPS/Chapter02.html.page_69">69</a>, <a href="#OEBPS/Chapter03.html.page_129">129</a></p>
<p class="index"><b>SGI</b>（<a href="#OEBPS/Chapter04.html.page_152">硅</a><a href="#OEBPS/Chapter04.html.page_151">图形</a>）、<a href="#OEBPS/Chapter04.html.page_136">136、137、140、151、152</a> _ <a href="#OEBPS/Chapter04.html.page_137">_</a> _ <a href="#OEBPS/Chapter04.html.page_140">_</a><a href="#OEBPS/Chapter04.html.page_151"></a><a href="#OEBPS/Chapter04.html.page_152"></a></p><p class="index"><b>SGI (Silicon Graphics)</b>, <a href="#OEBPS/Chapter04.html.page_136">136</a>, <a href="#OEBPS/Chapter04.html.page_137">137</a>, <a href="#OEBPS/Chapter04.html.page_140">140</a>, <a href="#OEBPS/Chapter04.html.page_151">151</a>, <a href="#OEBPS/Chapter04.html.page_152">152</a></p>
<p class="index"><b>西贝柳斯</b>, <a href="#OEBPS/Chapter11.html.page_447">447</a></p><p class="index"><b>Sibelius</b>, <a href="#OEBPS/Chapter11.html.page_447">447</a></p>
<p class="index"><b><i>硅图形</i></b>,<a href="#OEBPS/Chapter04.html.page_133"> 133</a> ,<a href="#OEBPS/Chapter04.html.page_136"> 136</a> ,<a href="#OEBPS/Chapter04.html.page_151"> 151</a></p><p class="index"><b><i>Silicon Graphics</i></b>, <a href="#OEBPS/Chapter04.html.page_133">133</a>, <a href="#OEBPS/Chapter04.html.page_136">136</a>, <a href="#OEBPS/Chapter04.html.page_151">151</a></p>
<p class="index"><b>模拟 67</b> , <a href="#OEBPS/Chapter11.html.page_435">435</a></p><p class="index"><b>Simula-67</b>, <a href="#OEBPS/Chapter11.html.page_435">435</a></p>
<p class="index"><b>六个分开</b>, <a href="#OEBPS/Chapter02.html.page_75">75</a></p><p class="index"><b>Six Apart</b>, <a href="#OEBPS/Chapter02.html.page_75">75</a></p>
<p class="index"><b>SK 组合器</b>, <a href="#OEBPS/Chapter07.html.page_255">255</a></p><p class="index"><b>S-K combinators</b>, <a href="#OEBPS/Chapter07.html.page_255">255</a></p>
<p class="index"><b>技能</b>, <a href="#OEBPS/Chapter04.html.page_137">137</a> , <a href="#OEBPS/Chapter04.html.page_140">140</a> , <a href="#OEBPS/Chapter04.html.page_150">150</a> , <a href="#OEBPS/Chapter06.html.page_223">223</a> , <a href="#OEBPS/Chapter06.html.page_233">233</a> , <a href="#OEBPS/Chapter06.html.page_235">235</a> , <a href="#OEBPS/Chapter06.html.page_236">236</a> , <a href="#OEBPS/Chapter08.html.page_290">290</a> , <a href="#OEBPS/Chapter08.html.page_292">292</a> , <a href="#OEBPS/Chapter08.html.page_295">295</a> , <a href="#OEBPS/Chapter08.html.page_298">298</a> , <a href="#OEBPS/Chapter08.html.page_299">299</a> , <a href="#OEBPS/Chapter08.html.page_310">310</a> , <a href="#OEBPS/Chapter09.html.page_334">334</a> , <a href="#OEBPS/Chapter09.html.page_354">354</a> , <a href="#OEBPS/Chapter11.html.page_428">428</a> , <a href="#OEBPS/Chapter11.html.page_430">430</a> , <a href="#OEBPS/Chapter13.html.page_498">498</a> , <a href="#OEBPS/Chapter14.html.page_539">539</a> , <a href="#OEBPS/Chapter14.html.page_546">546</a> , <a href="#OEBPS/Chapter14.html.page_549">529</a> _ <a href="#OEBPS/Chapter14.html.page_552">_</a></p><p class="index"><b>skills</b>, <a href="#OEBPS/Chapter04.html.page_137">137</a>, <a href="#OEBPS/Chapter04.html.page_140">140</a>, <a href="#OEBPS/Chapter04.html.page_150">150</a>, <a href="#OEBPS/Chapter06.html.page_223">223</a>, <a href="#OEBPS/Chapter06.html.page_233">233</a>, <a href="#OEBPS/Chapter06.html.page_235">235</a>, <a href="#OEBPS/Chapter06.html.page_236">236</a>, <a href="#OEBPS/Chapter08.html.page_290">290</a>, <a href="#OEBPS/Chapter08.html.page_292">292</a>, <a href="#OEBPS/Chapter08.html.page_295">295</a>, <a href="#OEBPS/Chapter08.html.page_298">298</a>, <a href="#OEBPS/Chapter08.html.page_299">299</a>, <a href="#OEBPS/Chapter08.html.page_310">310</a>, <a href="#OEBPS/Chapter09.html.page_334">334</a>, <a href="#OEBPS/Chapter09.html.page_354">354</a>, <a href="#OEBPS/Chapter11.html.page_428">428</a>, <a href="#OEBPS/Chapter11.html.page_430">430</a>, <a href="#OEBPS/Chapter13.html.page_498">498</a>, <a href="#OEBPS/Chapter14.html.page_539">539</a>, <a href="#OEBPS/Chapter14.html.page_546">546</a>, <a href="#OEBPS/Chapter14.html.page_549">549</a>, <a href="#OEBPS/Chapter14.html.page_552">552</a></p>
<p class="index"><b>技能</b>,<b>重要</b>, <a href="#OEBPS/Chapter01.html.page_44">44</a> , <a href="#OEBPS/Chapter02.html.page_86">86</a> , <a href="#OEBPS/Chapter02.html.page_87">87</a></p><p class="index"><b>skills</b>, <b>important</b>, <a href="#OEBPS/Chapter01.html.page_44">44</a>, <a href="#OEBPS/Chapter02.html.page_86">86</a>, <a href="#OEBPS/Chapter02.html.page_87">87</a></p>
<p class="index"><b>SKIM（滑雪机）</b>，<a href="#OEBPS/Chapter07.html.page_256">256</a></p><p class="index"><b>SKIM (SKI Machine)</b>, <a href="#OEBPS/Chapter07.html.page_256">256</a></p>
<p class="index"><b></b>小<a href="#OEBPS/Chapter10.html.page_399">话</a>，<b>113，127，128，129，144，147，161，373，377，378，382，385，386，387，388，389，390，391，392，395，39，39，39 </b><a href="#OEBPS/Chapter03.html.page_113">_</a> _ <a href="#OEBPS/Chapter03.html.page_127">_</a> _ <a href="#OEBPS/Chapter03.html.page_128">_</a> _ <a href="#OEBPS/Chapter03.html.page_129">_</a> _ <a href="#OEBPS/Chapter04.html.page_144">_</a> _ <a href="#OEBPS/Chapter04.html.page_147">_</a> _ <a href="#OEBPS/Chapter04.html.page_161">_</a> _ <a href="#OEBPS/Chapter10.html.page_373">_</a> _ <a href="#OEBPS/Chapter10.html.page_377">_</a> _ <a href="#OEBPS/Chapter10.html.page_378">_</a> _ <a href="#OEBPS/Chapter10.html.page_382">_</a> _ <a href="#OEBPS/Chapter10.html.page_385">_</a> _ <a href="#OEBPS/Chapter10.html.page_386">_</a> _ <a href="#OEBPS/Chapter10.html.page_387">_</a> _ <a href="#OEBPS/Chapter10.html.page_388">_</a> _ <a href="#OEBPS/Chapter10.html.page_389">_</a> _ <a href="#OEBPS/Chapter10.html.page_390">_</a> _ <a href="#OEBPS/Chapter10.html.page_391">_</a> _ <a href="#OEBPS/Chapter10.html.page_392">_</a> _ <a href="#OEBPS/Chapter10.html.page_395">_</a> _ <a href="#OEBPS/Chapter10.html.page_396">_</a> _ <a href="#OEBPS/Chapter10.html.page_397">_</a> _ <a href="#OEBPS/Chapter10.html.page_398">_</a> _ <a href="#OEBPS/Chapter10.html.page_400">400</a> , <a href="#OEBPS/Chapter10.html.page_401">401</a> , <a href="#OEBPS/Chapter10.html.page_402">402</a><a href="#OEBPS/Chapter10.html.page_399"></a><a href="#OEBPS/Chapter10.html.page_400"></a><a href="#OEBPS/Chapter10.html.page_401"></a><a href="#OEBPS/Chapter10.html.page_402"></a>, <a href="#OEBPS/Chapter10.html.page_405">405</a> , <a href="#OEBPS/Chapter10.html.page_408">408</a> , <a href="#OEBPS/Chapter10.html.page_409">409</a> , <a href="#OEBPS/Chapter10.html.page_410">410</a> , <a href="#OEBPS/Chapter11.html.page_413">413</a> , <a href="#OEBPS/Chapter11.html.page_418">418</a> , <a href="#OEBPS/Chapter11.html.page_435">435</a> , <a href="#OEBPS/Chapter11.html.page_439">439</a> , <a href="#OEBPS/Chapter11.html.page_440">440</a></p><p class="index"><b>Smalltalk</b>, <a href="#OEBPS/Chapter03.html.page_113">113</a>, <a href="#OEBPS/Chapter03.html.page_127">127</a>, <a href="#OEBPS/Chapter03.html.page_128">128</a>, <a href="#OEBPS/Chapter03.html.page_129">129</a>, <a href="#OEBPS/Chapter04.html.page_144">144</a>, <a href="#OEBPS/Chapter04.html.page_147">147</a>, <a href="#OEBPS/Chapter04.html.page_161">161</a>, <a href="#OEBPS/Chapter10.html.page_373">373</a>, <a href="#OEBPS/Chapter10.html.page_377">377</a>, <a href="#OEBPS/Chapter10.html.page_378">378</a>, <a href="#OEBPS/Chapter10.html.page_382">382</a>, <a href="#OEBPS/Chapter10.html.page_385">385</a>, <a href="#OEBPS/Chapter10.html.page_386">386</a>, <a href="#OEBPS/Chapter10.html.page_387">387</a>, <a href="#OEBPS/Chapter10.html.page_388">388</a>, <a href="#OEBPS/Chapter10.html.page_389">389</a>, <a href="#OEBPS/Chapter10.html.page_390">390</a>, <a href="#OEBPS/Chapter10.html.page_391">391</a>, <a href="#OEBPS/Chapter10.html.page_392">392</a>, <a href="#OEBPS/Chapter10.html.page_395">395</a>, <a href="#OEBPS/Chapter10.html.page_396">396</a>, <a href="#OEBPS/Chapter10.html.page_397">397</a>, <a href="#OEBPS/Chapter10.html.page_398">398</a>, <a href="#OEBPS/Chapter10.html.page_399">399</a>, <a href="#OEBPS/Chapter10.html.page_400">400</a>, <a href="#OEBPS/Chapter10.html.page_401">401</a>, <a href="#OEBPS/Chapter10.html.page_402">402</a>, <a href="#OEBPS/Chapter10.html.page_405">405</a>, <a href="#OEBPS/Chapter10.html.page_408">408</a>, <a href="#OEBPS/Chapter10.html.page_409">409</a>, <a href="#OEBPS/Chapter10.html.page_410">410</a>, <a href="#OEBPS/Chapter11.html.page_413">413</a>, <a href="#OEBPS/Chapter11.html.page_418">418</a>, <a href="#OEBPS/Chapter11.html.page_435">435</a>, <a href="#OEBPS/Chapter11.html.page_439">439</a>, <a href="#OEBPS/Chapter11.html.page_440">440</a></p>
<p class="index"><b>斯诺布尔</b>, <a href="#OEBPS/Chapter12.html.page_476">476</a></p><p class="index"><b>SNOBOL</b>, <a href="#OEBPS/Chapter12.html.page_476">476</a></p>
<p class="index"><b>软件设计</b>, <a href="#OEBPS/Chapter02.html.page_69">69</a> , <a href="#OEBPS/Chapter05.html.page_178">178</a> , <a href="#OEBPS/Chapter05.html.page_179">179</a> , <a href="#OEBPS/Chapter05.html.page_181">181</a> , <a href="#OEBPS/Chapter07.html.page_264">264</a> , <a href="#OEBPS/Chapter08.html.page_302">302</a></p><p class="index"><b>software design</b>, <a href="#OEBPS/Chapter02.html.page_69">69</a>, <a href="#OEBPS/Chapter05.html.page_178">178</a>, <a href="#OEBPS/Chapter05.html.page_179">179</a>, <a href="#OEBPS/Chapter05.html.page_181">181</a>, <a href="#OEBPS/Chapter07.html.page_264">264</a>, <a href="#OEBPS/Chapter08.html.page_302">302</a></p>
<p class="index"><b>香料 Lisp</b> , <a href="#OEBPS/Chapter01.html.page_3">3</a></p><p class="index"><b>Spice Lisp</b>, <a href="#OEBPS/Chapter01.html.page_3">3</a></p>
<p class="index"><b>乔尔·斯波尔斯基</b>，<a href="#OEBPS/Chapter04.html.page_155">155岁</a></p><p class="index"><b>Spolsky, Joel</b>, <a href="#OEBPS/Chapter04.html.page_155">155</a></p>
<p class="index"><b><i>吱吱声</i></b>,<a href="#OEBPS/Chapter10.html.page_373"> 373</a> ,<a href="#OEBPS/Chapter10.html.page_379"> 379</a> ,<a href="#OEBPS/Chapter10.html.page_380"> 380</a> ,<a href="#OEBPS/Chapter10.html.page_381"> 381</a> ,<a href="#OEBPS/Chapter10.html.page_387"> 387</a> ,<a href="#OEBPS/Chapter10.html.page_391"> 391</a> ,<a href="#OEBPS/Chapter10.html.page_392"> 392</a> ,<a href="#OEBPS/Chapter10.html.page_394"> 394</a> ,<a href="#OEBPS/Chapter10.html.page_399"> 399</a> ,<a href="#OEBPS/Chapter10.html.page_401"> 401</a> ,<a href="#OEBPS/Chapter10.html.page_407"> 407</a></p><p class="index"><b><i>Squeak</i></b>, <a href="#OEBPS/Chapter10.html.page_373">373</a>, <a href="#OEBPS/Chapter10.html.page_379">379</a>, <a href="#OEBPS/Chapter10.html.page_380">380</a>, <a href="#OEBPS/Chapter10.html.page_381">381</a>, <a href="#OEBPS/Chapter10.html.page_387">387</a>, <a href="#OEBPS/Chapter10.html.page_391">391</a>, <a href="#OEBPS/Chapter10.html.page_392">392</a>, <a href="#OEBPS/Chapter10.html.page_394">394</a>, <a href="#OEBPS/Chapter10.html.page_399">399</a>, <a href="#OEBPS/Chapter10.html.page_401">401</a>, <a href="#OEBPS/Chapter10.html.page_407">407</a></p>
<p class="index"><b>社会责任研究所</b>, <a href="#OEBPS/Chapter03.html.page_94">94</a></p><p class="index"><b>SRI</b>, <a href="#OEBPS/Chapter03.html.page_94">94</a></p>
<p class="index"><b>斯托曼</b>，<a href="#OEBPS/Chapter01.html.page_9">9岁</a></p><p class="index"><b>Stallman</b>, <a href="#OEBPS/Chapter01.html.page_9">9</a></p>
<p class="index"><b></b><a href="#OEBPS/Chapter09.html.page_347">斯托曼</a>，<b>理查德</b>，<a href="#OEBPS/Chapter09.html.page_345">345，346，347</a> _ <a href="#OEBPS/Chapter09.html.page_346">_</a><a href="#OEBPS/Chapter09.html.page_347"></a></p><p class="index"><b>Stallman, Richard</b>, <a href="#OEBPS/Chapter09.html.page_345">345</a>, <a href="#OEBPS/Chapter09.html.page_346">346</a>, <a href="#OEBPS/Chapter09.html.page_347">347</a></p>
<p class="index"><b>斯坦福</b>, <a href="#OEBPS/Chapter04.html.page_134">134</a> , <a href="#OEBPS/Chapter10.html.page_374">374</a> , <a href="#OEBPS/Chapter10.html.page_375">375</a> , <a href="#OEBPS/Chapter10.html.page_376">376</a> , <a href="#OEBPS/Chapter10.html.page_400">400</a> , <a href="#OEBPS/Chapter15.html.page_570">570</a> , <a href="#OEBPS/Chapter15.html.page_575">575</a> , <a href="#OEBPS/Chapter15.html.page_586">586</a></p><p class="index"><b>Stanford</b>, <a href="#OEBPS/Chapter04.html.page_134">134</a>, <a href="#OEBPS/Chapter10.html.page_374">374</a>, <a href="#OEBPS/Chapter10.html.page_375">375</a>, <a href="#OEBPS/Chapter10.html.page_376">376</a>, <a href="#OEBPS/Chapter10.html.page_400">400</a>, <a href="#OEBPS/Chapter15.html.page_570">570</a>, <a href="#OEBPS/Chapter15.html.page_575">575</a>, <a href="#OEBPS/Chapter15.html.page_586">586</a></p>
<p class="index"><b><i>静态单一分配</i></b>,<a href="#OEBPS/Chapter13.html.page_485"> 485</a> ,<a href="#OEBPS/Chapter13.html.page_496"> 496</a></p><p class="index"><b><i>Static Single Assignment</i></b>, <a href="#OEBPS/Chapter13.html.page_485">485</a>, <a href="#OEBPS/Chapter13.html.page_496">496</a></p>
<p class="index"><b>STM</b> , <a href="#OEBPS/Chapter07.html.page_271">271</a> , <a href="#OEBPS/Chapter07.html.page_272">272</a> , <a href="#OEBPS/Chapter07.html.page_273">273</a> , <a href="#OEBPS/Chapter07.html.page_274">274</a> , <a href="#OEBPS/Chapter07.html.page_275">275</a> , <a href="#OEBPS/Chapter07.html.page_276">276</a></p><p class="index"><b>STM</b>, <a href="#OEBPS/Chapter07.html.page_271">271</a>, <a href="#OEBPS/Chapter07.html.page_272">272</a>, <a href="#OEBPS/Chapter07.html.page_273">273</a>, <a href="#OEBPS/Chapter07.html.page_274">274</a>, <a href="#OEBPS/Chapter07.html.page_275">275</a>, <a href="#OEBPS/Chapter07.html.page_276">276</a></p>
<p class="index"><b>STM（软件事务</b><a href="#OEBPS/Chapter05.html.page_199">内存</a>），<a href="#OEBPS/Chapter05.html.page_198">198，199</a><a href="#OEBPS/Chapter05.html.page_199"></a></p><p class="index"><b>STM (Software Transactional Memory)</b>, <a href="#OEBPS/Chapter05.html.page_198">198</a>, <a href="#OEBPS/Chapter05.html.page_199">199</a></p>
<p class="index"><b>斯托伊，威廉</b>，<a href="#OEBPS/Chapter07.html.page_256">256</a></p><p class="index"><b>Stoye, William</b>, <a href="#OEBPS/Chapter07.html.page_256">256</a></p>
<p class="index"><b>斯特雷奇，克里斯托弗</b>，<a href="#OEBPS/Chapter08.html.page_289">289</a></p><p class="index"><b>Strachey, Christopher</b>, <a href="#OEBPS/Chapter08.html.page_289">289</a></p>
<p class="index"><b>拉伸</b>, <a href="#OEBPS/Chapter13.html.page_488">488</a> , <a href="#OEBPS/Chapter13.html.page_490">490</a> , <a href="#OEBPS/Chapter13.html.page_491">491</a> , <a href="#OEBPS/Chapter13.html.page_498">498</a> , <a href="#OEBPS/Chapter13.html.page_499">499</a> , <a href="#OEBPS/Chapter13.html.page_508">508</a> , <a href="#OEBPS/Chapter13.html.page_509">509</a> , <a href="#OEBPS/Chapter13.html.page_515">515</a></p><p class="index"><b>Stretch</b>, <a href="#OEBPS/Chapter13.html.page_488">488</a>, <a href="#OEBPS/Chapter13.html.page_490">490</a>, <a href="#OEBPS/Chapter13.html.page_491">491</a>, <a href="#OEBPS/Chapter13.html.page_498">498</a>, <a href="#OEBPS/Chapter13.html.page_499">499</a>, <a href="#OEBPS/Chapter13.html.page_508">508</a>, <a href="#OEBPS/Chapter13.html.page_509">509</a>, <a href="#OEBPS/Chapter13.html.page_515">515</a></p>
<p class="index"><b><i>拉伸收割机</i></b>,<a href="#OEBPS/Chapter13.html.page_485"> 485</a></p><p class="index"><b><i>STRETCH-HARVEST machine</i></b>, <a href="#OEBPS/Chapter13.html.page_485">485</a></p>
<p class="index"><b>Stroustrup, Bjarne</b> , <a href="#OEBPS/Chapter09.html.page_355">355</a> , <a href="#OEBPS/Chapter12.html.page_475">475</a></p><p class="index"><b>Stroustrup, Bjarne</b>, <a href="#OEBPS/Chapter09.html.page_355">355</a>, <a href="#OEBPS/Chapter12.html.page_475">475</a></p>
<p class="index"><b>风格指南</b>, <a href="#OEBPS/Chapter02.html.page_72">72</a></p><p class="index"><b>style guides</b>, <a href="#OEBPS/Chapter02.html.page_72">72</a></p>
<p class="index"><b><i>太阳微系统公司</i></b>,<a href="#OEBPS/Chapter05.html.page_167"> 167</a> ,<a href="#OEBPS/Chapter05.html.page_171"> 171</a> ,<a href="#OEBPS/Chapter11.html.page_413"> 413</a></p><p class="index"><b><i>Sun Microsystems</i></b>, <a href="#OEBPS/Chapter05.html.page_167">167</a>, <a href="#OEBPS/Chapter05.html.page_171">171</a>, <a href="#OEBPS/Chapter11.html.page_413">413</a></p>
<p class="index"><b><i>苏斯曼，杰拉尔德</i></b>，<a href="#OEBPS/Chapter09.html.page_325"> 325</a></p><p class="index"><b><i>Sussman, Gerald</i></b>, <a href="#OEBPS/Chapter09.html.page_325">325</a></p>
<p class="index"><b><i>瑞典航天公司</i></b>,<a href="#OEBPS/Chapter06.html.page_206"> 206</a> ,<a href="#OEBPS/Chapter06.html.page_210"> 210</a> ,<a href="#OEBPS/Chapter06.html.page_220"> 220</a> ,<a href="#OEBPS/Chapter06.html.page_227"> 227</a></p><p class="index"><b><i>Swedish Space Corporation</i></b>, <a href="#OEBPS/Chapter06.html.page_206">206</a>, <a href="#OEBPS/Chapter06.html.page_210">210</a>, <a href="#OEBPS/Chapter06.html.page_220">220</a>, <a href="#OEBPS/Chapter06.html.page_227">227</a></p>
<h3 class="h3">吨</h3><h3 class="h3">T</h3>
<p class="index"><b>天赋</b>, <a href="#OEBPS/Chapter12.html.page_472">472</a></p><p class="index"><b>talent</b>, <a href="#OEBPS/Chapter12.html.page_472">472</a></p>
<p class="index"><b>人才</b>,<b>认可</b>, <a href="#OEBPS/Chapter01.html.page_38">38</a></p><p class="index"><b>talent</b>, <b>recognition of</b>, <a href="#OEBPS/Chapter01.html.page_38">38</a></p>
<p class="index"><b>台电</b>, <a href="#OEBPS/Chapter14.html.page_528">528</a> , <a href="#OEBPS/Chapter14.html.page_553">553</a></p><p class="index"><b>Tcl</b>, <a href="#OEBPS/Chapter14.html.page_528">528</a>, <a href="#OEBPS/Chapter14.html.page_553">553</a></p>
<p class="index"><b>技术模型铁路俱乐部</b>，<a href="#OEBPS/Chapter14.html.page_521">521</a></p><p class="index"><b>Tech Model Railroad Club</b>, <a href="#OEBPS/Chapter14.html.page_521">521</a></p>
<p class="index"><b>东元宏</b>, <a href="#OEBPS/Chapter14.html.page_530">530</a> , <a href="#OEBPS/Chapter14.html.page_542">542</a> , <a href="#OEBPS/Chapter14.html.page_558">558</a></p><p class="index"><b>TECO macros</b>, <a href="#OEBPS/Chapter14.html.page_530">530</a>, <a href="#OEBPS/Chapter14.html.page_542">542</a>, <a href="#OEBPS/Chapter14.html.page_558">558</a></p>
<p class="index"><b>泰克</b>, <a href="#OEBPS/Chapter02.html.page_53">53</a></p><p class="index"><b>Tektronix</b>, <a href="#OEBPS/Chapter02.html.page_53">53</a></p>
<p class="index"><b><i>特耐克斯</i></b>,<a href="#OEBPS/Chapter14.html.page_519"> 519</a></p><p class="index"><b><i>TENEX</i></b>, <a href="#OEBPS/Chapter14.html.page_519">519</a></p>
<p class="index"><b>测试</b>, <a href="#OEBPS/Chapter01.html.page_33">33</a> , <a href="#OEBPS/Chapter01.html.page_34">34</a> , <a href="#OEBPS/Chapter03.html.page_122">122</a> , <a href="#OEBPS/Chapter07.html.page_253">253</a> , <a href="#OEBPS/Chapter07.html.page_267">267</a> , <a href="#OEBPS/Chapter07.html.page_270">270</a> , <a href="#OEBPS/Chapter08.html.page_300">300</a> , <a href="#OEBPS/Chapter08.html.page_305">305</a> , <a href="#OEBPS/Chapter08.html.page_308">308</a> , <a href="#OEBPS/Chapter09.html.page_342">342</a> , <a href="#OEBPS/Chapter09.html.page_365">365</a> , <a href="#OEBPS/Chapter09.html.page_368">368</a> , <a href="#OEBPS/Chapter10.html.page_384">384</a> , <a href="#OEBPS/Chapter10.html.page_393">393</a> , <a href="#OEBPS/Chapter10.html.page_394">394</a> , <a href="#OEBPS/Chapter10.html.page_406">406</a> , <a href="#OEBPS/Chapter12.html.page_469">469</a></p><p class="index"><b>testing</b>, <a href="#OEBPS/Chapter01.html.page_33">33</a>, <a href="#OEBPS/Chapter01.html.page_34">34</a>, <a href="#OEBPS/Chapter03.html.page_122">122</a>, <a href="#OEBPS/Chapter07.html.page_253">253</a>, <a href="#OEBPS/Chapter07.html.page_267">267</a>, <a href="#OEBPS/Chapter07.html.page_270">270</a>, <a href="#OEBPS/Chapter08.html.page_300">300</a>, <a href="#OEBPS/Chapter08.html.page_305">305</a>, <a href="#OEBPS/Chapter08.html.page_308">308</a>, <a href="#OEBPS/Chapter09.html.page_342">342</a>, <a href="#OEBPS/Chapter09.html.page_365">365</a>, <a href="#OEBPS/Chapter09.html.page_368">368</a>, <a href="#OEBPS/Chapter10.html.page_384">384</a>, <a href="#OEBPS/Chapter10.html.page_393">393</a>, <a href="#OEBPS/Chapter10.html.page_394">394</a>, <a href="#OEBPS/Chapter10.html.page_406">406</a>, <a href="#OEBPS/Chapter12.html.page_469">469</a></p>
<p class="index"><b>TeX</b> , <a href="#OEBPS/Chapter03.html.page_115">115</a> , <a href="#OEBPS/Chapter03.html.page_116">116</a> , <a href="#OEBPS/Chapter08.html.page_306">306</a> , <a href="#OEBPS/Chapter09.html.page_325">325</a> , <a href="#OEBPS/Chapter09.html.page_336">336</a> , <a href="#OEBPS/Chapter09.html.page_337">337</a> , <a href="#OEBPS/Chapter09.html.page_354">354</a> , <a href="#OEBPS/Chapter09.html.page_369">369</a> , <a href="#OEBPS/Chapter09.html.page_371">371</a> , <a href="#OEBPS/Chapter09.html.page_372">372</a> , <a href="#OEBPS/Chapter10.html.page_384">384</a> , <a href="#OEBPS/Chapter10.html.page_400">400</a> , <a href="#OEBPS/Chapter15.html.page_565">565</a> , <a href="#OEBPS/Chapter15.html.page_570">570</a> , <a href="#OEBPS/Chapter15.html.page_571">571</a> , <a href="#OEBPS/Chapter15.html.page_572">572</a> , <a href="#OEBPS/Chapter15.html.page_577">577</a> , <a href="#OEBPS/Chapter15.html.page_586">586</a> , <a href="#OEBPS/Chapter15.html.page_587">587</a> , <a href="#OEBPS/Chapter15.html.page_592">510</a> , <a href="#OEBPS/Chapter15.html.page_590">59</a> , <a href="#OEBPS/Chapter15.html.page_598">59</a> , <a href="#OEBPS/Chapter15.html.page_591">59 </a><a href="#OEBPS/Chapter15.html.page_597">_</a> _<a href="#OEBPS/Chapter15.html.page_592"></a><a href="#OEBPS/Chapter15.html.page_597"></a><a href="#OEBPS/Chapter15.html.page_598"></a></p><p class="index"><b>TeX</b>, <a href="#OEBPS/Chapter03.html.page_115">115</a>, <a href="#OEBPS/Chapter03.html.page_116">116</a>, <a href="#OEBPS/Chapter08.html.page_306">306</a>, <a href="#OEBPS/Chapter09.html.page_325">325</a>, <a href="#OEBPS/Chapter09.html.page_336">336</a>, <a href="#OEBPS/Chapter09.html.page_337">337</a>, <a href="#OEBPS/Chapter09.html.page_354">354</a>, <a href="#OEBPS/Chapter09.html.page_369">369</a>, <a href="#OEBPS/Chapter09.html.page_371">371</a>, <a href="#OEBPS/Chapter09.html.page_372">372</a>, <a href="#OEBPS/Chapter10.html.page_384">384</a>, <a href="#OEBPS/Chapter10.html.page_400">400</a>, <a href="#OEBPS/Chapter15.html.page_565">565</a>, <a href="#OEBPS/Chapter15.html.page_570">570</a>, <a href="#OEBPS/Chapter15.html.page_571">571</a>, <a href="#OEBPS/Chapter15.html.page_572">572</a>, <a href="#OEBPS/Chapter15.html.page_577">577</a>, <a href="#OEBPS/Chapter15.html.page_586">586</a>, <a href="#OEBPS/Chapter15.html.page_587">587</a>, <a href="#OEBPS/Chapter15.html.page_590">590</a>, <a href="#OEBPS/Chapter15.html.page_591">591</a>, <a href="#OEBPS/Chapter15.html.page_592">592</a>, <a href="#OEBPS/Chapter15.html.page_597">597</a>, <a href="#OEBPS/Chapter15.html.page_598">598</a></p>
<p class="index"><b></b><a href="#OEBPS/Chapter14.html.page_557">汤普森</a>，<b>肯</b>，<a href="#OEBPS/Chapter08.html.page_309">309，413，557</a> _ <a href="#OEBPS/Chapter11.html.page_413">_</a><a href="#OEBPS/Chapter14.html.page_557"></a></p><p class="index"><b>Thompson, Ken</b>, <a href="#OEBPS/Chapter08.html.page_309">309</a>, <a href="#OEBPS/Chapter11.html.page_413">413</a>, <a href="#OEBPS/Chapter14.html.page_557">557</a></p>
<p class="index"><b>TI Explorer Lisp 机器</b>, <a href="#OEBPS/Chapter01.html.page_5">5</a></p><p class="index"><b>TI Explorer Lisp machines</b>, <a href="#OEBPS/Chapter01.html.page_5">5</a></p>
<p class="index"><b>分时</b>, <a href="#OEBPS/Chapter14.html.page_521">521</a> , <a href="#OEBPS/Chapter14.html.page_523">523</a> , <a href="#OEBPS/Chapter14.html.page_524">524</a> , <a href="#OEBPS/Chapter14.html.page_526">526</a> , <a href="#OEBPS/Chapter14.html.page_532">532</a> , <a href="#OEBPS/Chapter14.html.page_537">537</a> , <a href="#OEBPS/Chapter14.html.page_538">538</a> , <a href="#OEBPS/Chapter14.html.page_540">540</a> , <a href="#OEBPS/Chapter14.html.page_542">542</a> , <a href="#OEBPS/Chapter14.html.page_548">548</a> , <a href="#OEBPS/Chapter14.html.page_549">549</a> , <a href="#OEBPS/Chapter14.html.page_558">558</a> , <a href="#OEBPS/Chapter14.html.page_562">562</a></p><p class="index"><b>time-sharing</b>, <a href="#OEBPS/Chapter14.html.page_521">521</a>, <a href="#OEBPS/Chapter14.html.page_523">523</a>, <a href="#OEBPS/Chapter14.html.page_524">524</a>, <a href="#OEBPS/Chapter14.html.page_526">526</a>, <a href="#OEBPS/Chapter14.html.page_532">532</a>, <a href="#OEBPS/Chapter14.html.page_537">537</a>, <a href="#OEBPS/Chapter14.html.page_538">538</a>, <a href="#OEBPS/Chapter14.html.page_540">540</a>, <a href="#OEBPS/Chapter14.html.page_542">542</a>, <a href="#OEBPS/Chapter14.html.page_548">548</a>, <a href="#OEBPS/Chapter14.html.page_549">549</a>, <a href="#OEBPS/Chapter14.html.page_558">558</a>, <a href="#OEBPS/Chapter14.html.page_562">562</a></p>
<p class="index"><b>托蒂克，亚历克斯</b>，<a href="#OEBPS/Chapter01.html.page_16">16 岁</a></p><p class="index"><b>Totic, Aleks</b>, <a href="#OEBPS/Chapter01.html.page_16">16</a></p>
<p class="index"><b><i>跟踪猴子</i></b>，<a href="#OEBPS/Chapter04.html.page_133"> 133</a></p><p class="index"><b><i>TraceMonkey</i></b>, <a href="#OEBPS/Chapter04.html.page_133">133</a></p>
<p class="index"><b>追踪</b>, <a href="#OEBPS/Chapter09.html.page_335">335</a> , <a href="#OEBPS/Chapter09.html.page_339">339</a></p><p class="index"><b>tracing</b>, <a href="#OEBPS/Chapter09.html.page_335">335</a>, <a href="#OEBPS/Chapter09.html.page_339">339</a></p>
<p class="index"><b><i>跨弧</i></b>,<a href="#OEBPS/Chapter05.html.page_167"> 167</a> ,<a href="#OEBPS/Chapter05.html.page_188"> 188</a> ,<a href="#OEBPS/Chapter05.html.page_190"> 190</a></p><p class="index"><b><i>Transarc</i></b>, <a href="#OEBPS/Chapter05.html.page_167">167</a>, <a href="#OEBPS/Chapter05.html.page_188">188</a>, <a href="#OEBPS/Chapter05.html.page_190">190</a></p>
<p class="index"><b>图灵</b>, <a href="#OEBPS/Chapter06.html.page_209">209</a></p><p class="index"><b>Turing</b>, <a href="#OEBPS/Chapter06.html.page_209">209</a></p>
<p class="index"><b>类型推断</b>，<a href="#OEBPS/Chapter07.html.page_261">261</a></p><p class="index"><b>type inference</b>, <a href="#OEBPS/Chapter07.html.page_261">261</a></p>
<h3 class="h3">ü</h3><h3 class="h3">U</h3>
<p class="index"><b>加州大学伯克利分校</b>, <a href="#OEBPS/Chapter01.html.page_5">5</a> , <a href="#OEBPS/Chapter11.html.page_413">413</a></p><p class="index"><b>UC Berkeley</b>, <a href="#OEBPS/Chapter01.html.page_5">5</a>, <a href="#OEBPS/Chapter11.html.page_413">413</a></p>
<p class="index"><b>伦敦大学学院</b>, <a href="#OEBPS/Chapter07.html.page_249">249</a></p><p class="index"><b>UCL</b>, <a href="#OEBPS/Chapter07.html.page_249">249</a></p>
<p class="index"><b>通用语言</b>, <a href="#OEBPS/Chapter05.html.page_181">181</a> , <a href="#OEBPS/Chapter08.html.page_307">307</a></p><p class="index"><b>UML</b>, <a href="#OEBPS/Chapter05.html.page_181">181</a>, <a href="#OEBPS/Chapter08.html.page_307">307</a></p>
<p class="index"><b>昂加尔，戴夫</b>，<a href="#OEBPS/Chapter04.html.page_144">144</a></p><p class="index"><b>Ungar, Dave</b>, <a href="#OEBPS/Chapter04.html.page_144">144</a></p>
<p class="index"><b>单元测试</b>, <a href="#OEBPS/Chapter01.html.page_33">33</a> , <a href="#OEBPS/Chapter01.html.page_34">34</a></p><p class="index"><b>unit tests</b>, <a href="#OEBPS/Chapter01.html.page_33">33</a>, <a href="#OEBPS/Chapter01.html.page_34">34</a></p>
<p class="index"><b>尤尼维克</b>, <a href="#OEBPS/Chapter11.html.page_425">425</a></p><p class="index"><b>UNIVAC</b>, <a href="#OEBPS/Chapter11.html.page_425">425</a></p>
<p class="index"><b>伦敦大学学院</b>, <a href="#OEBPS/Chapter06.html.page_207">207</a></p><p class="index"><b>University College of London</b>, <a href="#OEBPS/Chapter06.html.page_207">207</a></p>
<p class="index"><b>伊利诺伊大学香槟分校</b>，<a href="#OEBPS/Chapter04.html.page_136">136</a></p><p class="index"><b>University of Illinois Champaign-Urbana</b>, <a href="#OEBPS/Chapter04.html.page_136">136</a></p>
<p class="index"><b>密歇根大学</b>, <a href="#OEBPS/Chapter13.html.page_486">486</a> , <a href="#OEBPS/Chapter13.html.page_488">488</a></p><p class="index"><b>University of Michigan</b>, <a href="#OEBPS/Chapter13.html.page_486">486</a>, <a href="#OEBPS/Chapter13.html.page_488">488</a></p>
<p class="index"><b>Unix</b> , <a href="#OEBPS/Chapter01.html.page_9">9</a> , <a href="#OEBPS/Chapter01.html.page_14">14</a> , <a href="#OEBPS/Chapter01.html.page_16">16</a> , <a href="#OEBPS/Chapter01.html.page_17">17</a> , <a href="#OEBPS/Chapter01.html.page_20">20</a> , <a href="#OEBPS/Chapter02.html.page_53">53</a> , <a href="#OEBPS/Chapter02.html.page_54">54</a> , <a href="#OEBPS/Chapter02.html.page_57">57</a> , <a href="#OEBPS/Chapter02.html.page_58">58</a> , <a href="#OEBPS/Chapter04.html.page_134">134</a> , <a href="#OEBPS/Chapter04.html.page_135">135</a> , <a href="#OEBPS/Chapter04.html.page_147">147</a> , <a href="#OEBPS/Chapter04.html.page_151">151</a> , <a href="#OEBPS/Chapter04.html.page_156">156</a> , <a href="#OEBPS/Chapter04.html.page_161">161</a> , <a href="#OEBPS/Chapter06.html.page_213">213</a> , <a href="#OEBPS/Chapter06.html.page_230">230</a> , <a href="#OEBPS/Chapter08.html.page_291">291</a> , <a href="#OEBPS/Chapter11.html.page_413">413</a> , <a href="#OEBPS/Chapter11.html.page_426">426</a> , <a href="#OEBPS/Chapter12.html.page_449">649</a> , 4 <a href="#OEBPS/Chapter12.html.page_456">286</a> , <a href="#OEBPS/Chapter12.html.page_462">4 </a><a href="#OEBPS/Chapter12.html.page_458">286</a> , <a href="#OEBPS/Chapter12.html.page_463">463</a> , <a href="#OEBPS/Chapter12.html.page_464">464</a> , <a href="#OEBPS/Chapter12.html.page_478">478</a> ,<a href="#OEBPS/Chapter12.html.page_462"></a><a href="#OEBPS/Chapter12.html.page_463"></a><a href="#OEBPS/Chapter12.html.page_464"></a><a href="#OEBPS/Chapter12.html.page_478"></a><a href="#OEBPS/Chapter12.html.page_482">482</a> , <a href="#OEBPS/Chapter14.html.page_524">524</a> , <a href="#OEBPS/Chapter14.html.page_560">560</a></p><p class="index"><b>Unix</b>, <a href="#OEBPS/Chapter01.html.page_9">9</a>, <a href="#OEBPS/Chapter01.html.page_14">14</a>, <a href="#OEBPS/Chapter01.html.page_16">16</a>, <a href="#OEBPS/Chapter01.html.page_17">17</a>, <a href="#OEBPS/Chapter01.html.page_20">20</a>, <a href="#OEBPS/Chapter02.html.page_53">53</a>, <a href="#OEBPS/Chapter02.html.page_54">54</a>, <a href="#OEBPS/Chapter02.html.page_57">57</a>, <a href="#OEBPS/Chapter02.html.page_58">58</a>, <a href="#OEBPS/Chapter04.html.page_134">134</a>, <a href="#OEBPS/Chapter04.html.page_135">135</a>, <a href="#OEBPS/Chapter04.html.page_147">147</a>, <a href="#OEBPS/Chapter04.html.page_151">151</a>, <a href="#OEBPS/Chapter04.html.page_156">156</a>, <a href="#OEBPS/Chapter04.html.page_161">161</a>, <a href="#OEBPS/Chapter06.html.page_213">213</a>, <a href="#OEBPS/Chapter06.html.page_230">230</a>, <a href="#OEBPS/Chapter08.html.page_291">291</a>, <a href="#OEBPS/Chapter11.html.page_413">413</a>, <a href="#OEBPS/Chapter11.html.page_426">426</a>, <a href="#OEBPS/Chapter12.html.page_449">449</a>, <a href="#OEBPS/Chapter12.html.page_456">456</a>, <a href="#OEBPS/Chapter12.html.page_458">458</a>, <a href="#OEBPS/Chapter12.html.page_462">462</a>, <a href="#OEBPS/Chapter12.html.page_463">463</a>, <a href="#OEBPS/Chapter12.html.page_464">464</a>, <a href="#OEBPS/Chapter12.html.page_478">478</a>, <a href="#OEBPS/Chapter12.html.page_482">482</a>, <a href="#OEBPS/Chapter14.html.page_524">524</a>, <a href="#OEBPS/Chapter14.html.page_560">560</a></p>
<p class="index"><b><i>编码为 8</i></b> ,<a href="#OEBPS/Chapter12.html.page_449"> 449</a></p><p class="index"><b><i>UTF-8</i></b>, <a href="#OEBPS/Chapter12.html.page_449">449</a></p>
<p class="index"><b>乌托邦 84</b> , <a href="#OEBPS/Chapter15.html.page_596">596</a></p><p class="index"><b>Utopia 84</b>, <a href="#OEBPS/Chapter15.html.page_596">596</a></p>
<h3 class="h3">V</h3><h3 class="h3">V</h3>
<p class="index"><b>范罗森，圭多</b>，<a href="#OEBPS/Chapter08.html.page_309">309</a></p><p class="index"><b>van Rossum, Guido</b>, <a href="#OEBPS/Chapter08.html.page_309">309</a></p>
<p class="index"><b></b><a href="#OEBPS/Chapter06.html.page_235">维丁</a>，<b>罗伯特</b>，<a href="#OEBPS/Chapter06.html.page_221">221，228，229，235</a> _ <a href="#OEBPS/Chapter06.html.page_228">_</a> _ <a href="#OEBPS/Chapter06.html.page_229">_</a><a href="#OEBPS/Chapter06.html.page_235"></a></p><p class="index"><b>Virding, Robert</b>, <a href="#OEBPS/Chapter06.html.page_221">221</a>, <a href="#OEBPS/Chapter06.html.page_228">228</a>, <a href="#OEBPS/Chapter06.html.page_229">229</a>, <a href="#OEBPS/Chapter06.html.page_235">235</a></p>
<p class="index"><b>视觉计算器</b>, <a href="#OEBPS/Chapter10.html.page_398">398</a></p><p class="index"><b>VisiCalc</b>, <a href="#OEBPS/Chapter10.html.page_398">398</a></p>
<h3 class="h3">W</h3><h3 class="h3">W</h3>
<p class="index"><b>瓦尔德玛，霍瓦特</b>，<a href="#OEBPS/Chapter04.html.page_143">143</a></p><p class="index"><b>Waldemar, Horwat</b>, <a href="#OEBPS/Chapter04.html.page_143">143</a></p>
<p class="index"><b></b><a href="#OEBPS/Chapter14.html.page_538">沃尔登</a>，<b>戴夫</b>，<a href="#OEBPS/Chapter14.html.page_529">529，530，536，538</a> _ <a href="#OEBPS/Chapter14.html.page_530">_</a> _ <a href="#OEBPS/Chapter14.html.page_536">_</a><a href="#OEBPS/Chapter14.html.page_538"></a></p><p class="index"><b>Walden, Dave</b>, <a href="#OEBPS/Chapter14.html.page_529">529</a>, <a href="#OEBPS/Chapter14.html.page_530">530</a>, <a href="#OEBPS/Chapter14.html.page_536">536</a>, <a href="#OEBPS/Chapter14.html.page_538">538</a></p>
<p class="index"><b>沃尔，拉里</b>，<a href="#OEBPS/Chapter04.html.page_151">151</a></p><p class="index"><b>Wall, Larry</b>, <a href="#OEBPS/Chapter04.html.page_151">151</a></p>
<p class="index"><b>沃什布鲁克，约翰</b>，<a href="#OEBPS/Chapter07.html.page_249">249</a></p><p class="index"><b>Washbrook, John</b>, <a href="#OEBPS/Chapter07.html.page_249">249</a></p>
<p class="index"><b>WEB 工具</b>, <a href="#OEBPS/Chapter15.html.page_572">572</a> , <a href="#OEBPS/Chapter15.html.page_589">589</a></p><p class="index"><b>WEB tool</b>, <a href="#OEBPS/Chapter15.html.page_572">572</a>, <a href="#OEBPS/Chapter15.html.page_589">589</a></p>
<p class="index"><b>魏斯，史蒂夫</b>，<a href="#OEBPS/Chapter14.html.page_525">525</a></p><p class="index"><b>Weiss, Steve</b>, <a href="#OEBPS/Chapter14.html.page_525">525</a></p>
<p class="index"><b>魏斯曼</b>，<b>特里</b>，<a href="#OEBPS/Chapter01.html.page_18">18 岁</a>，<a href="#OEBPS/Chapter01.html.page_19">19 岁</a>，<a href="#OEBPS/Chapter01.html.page_21">21 岁</a></p><p class="index"><b>Weissman</b>, <b>Terry</b>, <a href="#OEBPS/Chapter01.html.page_18">18</a>, <a href="#OEBPS/Chapter01.html.page_19">19</a>, <a href="#OEBPS/Chapter01.html.page_21">21</a></p>
<p class="index"><b><i></i></b><a href="#OEBPS/Chapter14.html.page_541">魏泽鲍姆</a>，<b><i>乔</i></b>，<a href="#OEBPS/Chapter14.html.page_519"> 519，540，541</a> _<a href="#OEBPS/Chapter14.html.page_540"> _</a><a href="#OEBPS/Chapter14.html.page_541"></a></p><p class="index"><b><i>Weizenbaum, Joe</i></b>, <a href="#OEBPS/Chapter14.html.page_519">519</a>, <a href="#OEBPS/Chapter14.html.page_540">540</a>, <a href="#OEBPS/Chapter14.html.page_541">541</a></p>
<p class="index"><b>威灵斯，拉尔夫</b>，<a href="#OEBPS/Chapter09.html.page_330">330</a></p><p class="index"><b>Wellings, Ralph</b>, <a href="#OEBPS/Chapter09.html.page_330">330</a></p>
<p class="index"><b>惠特克，布拉德</b>，<a href="#OEBPS/Chapter02.html.page_51">51</a>岁，<a href="#OEBPS/Chapter02.html.page_53">53 岁</a>，<a href="#OEBPS/Chapter02.html.page_56">56 岁</a>，<a href="#OEBPS/Chapter02.html.page_74">74 岁</a></p><p class="index"><b>Whitaker, Brad</b>, <a href="#OEBPS/Chapter02.html.page_51">51</a>, <a href="#OEBPS/Chapter02.html.page_53">53</a>, <a href="#OEBPS/Chapter02.html.page_56">56</a>, <a href="#OEBPS/Chapter02.html.page_74">74</a></p>
<p class="index"><b>怀特，乔治</b>，<a href="#OEBPS/Chapter10.html.page_376">376</a></p><p class="index"><b>White, George</b>, <a href="#OEBPS/Chapter10.html.page_376">376</a></p>
<p class="index"><b>沃利</b>,<b>斯凯夫</b>, <a href="#OEBPS/Chapter01.html.page_3">3</a> , <a href="#OEBPS/Chapter01.html.page_40">40</a></p><p class="index"><b>Wholey</b>, <b>Skef</b>, <a href="#OEBPS/Chapter01.html.page_3">3</a>, <a href="#OEBPS/Chapter01.html.page_40">40</a></p>
<p class="index"><b>威廉姆斯，迈克</b>，<a href="#OEBPS/Chapter06.html.page_221">221</a></p><p class="index"><b>Williams, Mike</b>, <a href="#OEBPS/Chapter06.html.page_221">221</a></p>
<p class="index"><b>温诺格拉德，特里</b>，<a href="#OEBPS/Chapter15.html.page_597">597</a></p><p class="index"><b>Winograd, Terry</b>, <a href="#OEBPS/Chapter15.html.page_597">597</a></p>
<p class="index"><b><i>女性</i></b>,<a href="#OEBPS/Chapter13.html.page_485"> 485</a> ,<a href="#OEBPS/Chapter13.html.page_490"> 490</a> ,<a href="#OEBPS/Chapter13.html.page_492"> 492</a> ,<a href="#OEBPS/Chapter13.html.page_507"> 507</a> ,<a href="#OEBPS/Chapter13.html.page_508"> 508</a> ,<a href="#OEBPS/Chapter13.html.page_509"> 509</a> ,<a href="#OEBPS/Chapter13.html.page_510"> 510</a> ,<a href="#OEBPS/Chapter13.html.page_511"> 511</a> ,<a href="#OEBPS/Chapter13.html.page_512"> 512</a> ,<a href="#OEBPS/Chapter13.html.page_513"> 513</a> ,<a href="#OEBPS/Chapter13.html.page_514"> 514</a></p><p class="index"><b><i>women</i></b>, <a href="#OEBPS/Chapter13.html.page_485">485</a>, <a href="#OEBPS/Chapter13.html.page_490">490</a>, <a href="#OEBPS/Chapter13.html.page_492">492</a>, <a href="#OEBPS/Chapter13.html.page_507">507</a>, <a href="#OEBPS/Chapter13.html.page_508">508</a>, <a href="#OEBPS/Chapter13.html.page_509">509</a>, <a href="#OEBPS/Chapter13.html.page_510">510</a>, <a href="#OEBPS/Chapter13.html.page_511">511</a>, <a href="#OEBPS/Chapter13.html.page_512">512</a>, <a href="#OEBPS/Chapter13.html.page_513">513</a>, <a href="#OEBPS/Chapter13.html.page_514">514</a></p>
<p class="index"><b>编写代码</b>，<a href="#OEBPS/Chapter06.html.page_220">220</a></p><p class="index"><b>writing code</b>, <a href="#OEBPS/Chapter06.html.page_220">220</a></p>
<h3 class="h3">XYZ</h3><h3 class="h3">XYZ</h3>
<p class="index"><b>X 视窗</b>, <a href="#OEBPS/Chapter06.html.page_211">211</a> , <a href="#OEBPS/Chapter06.html.page_223">223</a></p><p class="index"><b>X Windows</b>, <a href="#OEBPS/Chapter06.html.page_211">211</a>, <a href="#OEBPS/Chapter06.html.page_223">223</a></p>
<p class="index"><b>X11 调用</b>, <a href="#OEBPS/Chapter01.html.page_26">26</a> , <a href="#OEBPS/Chapter01.html.page_27">27</a></p><p class="index"><b>X11 calls</b>, <a href="#OEBPS/Chapter01.html.page_26">26</a>, <a href="#OEBPS/Chapter01.html.page_27">27</a></p>
<p class="index"><b>赛尼克斯</b>, <a href="#OEBPS/Chapter04.html.page_136">136</a></p><p class="index"><b>Xenix</b>, <a href="#OEBPS/Chapter04.html.page_136">136</a></p>
<p class="index"><b><i>施乐 PARC</i></b> ,<a href="#OEBPS/Chapter10.html.page_373"> 373</a> ,<a href="#OEBPS/Chapter10.html.page_375"> 375</a> ,<a href="#OEBPS/Chapter11.html.page_413"> 413</a> ,<a href="#OEBPS/Chapter11.html.page_421"> 421</a></p><p class="index"><b><i>Xerox PARC</i></b>, <a href="#OEBPS/Chapter10.html.page_373">373</a>, <a href="#OEBPS/Chapter10.html.page_375">375</a>, <a href="#OEBPS/Chapter11.html.page_413">413</a>, <a href="#OEBPS/Chapter11.html.page_421">421</a></p>
<p class="index"><b>软件</b>, <a href="#OEBPS/Chapter01.html.page_3">3</a></p><p class="index"><b>XLISP</b>, <a href="#OEBPS/Chapter01.html.page_3">3</a></p>
<p class="index"><b>经验值</b>, <a href="#OEBPS/Chapter11.html.page_432">432</a> , <a href="#OEBPS/Chapter11.html.page_434">434</a></p><p class="index"><b>XP</b>, <a href="#OEBPS/Chapter11.html.page_432">432</a>, <a href="#OEBPS/Chapter11.html.page_434">434</a></p>
<p class="index"><b>屏幕保护程序</b>, <a href="#OEBPS/Chapter01.html.page_12">12</a> , <a href="#OEBPS/Chapter01.html.page_24">24</a> , <a href="#OEBPS/Chapter01.html.page_26">26</a></p><p class="index"><b>XScreenSaver</b>, <a href="#OEBPS/Chapter01.html.page_12">12</a>, <a href="#OEBPS/Chapter01.html.page_24">24</a>, <a href="#OEBPS/Chapter01.html.page_26">26</a></p>
<p class="index"><b>亚克</b>, <a href="#OEBPS/Chapter12.html.page_476">476</a></p><p class="index"><b>yacc</b>, <a href="#OEBPS/Chapter12.html.page_476">476</a></p>
</div>
</div></div>
</div>

<div id="html-container"></div>
<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>
