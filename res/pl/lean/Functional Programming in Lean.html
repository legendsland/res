<!DOCTYPE html><html lang="en" class="js sidebar-visible light" style=""><!--
 Page saved with SingleFile 
 url: https://leanprover.github.io/functional_programming_in_lean/print.html 
 saved date: Fri Oct 18 2024 15:27:42 GMT+0800 (Hong Kong Standard Time)
--><head>
<meta name="dc.identifier" content="res/863b33babed85deccd162e928dd11958d229fe50">
<meta charset="utf-8">
        <!-- Book generated using mdBook -->
        
        <title>Functional Programming in Lean</title>
        <meta name="robots" content="noindex">
        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="rgba(0, 0, 0, 0)">

        
        
        <style>:root{--sidebar-width:300px;--page-padding:15px;--content-max-width:750px;--menu-bar-height:50px}.ayu{--bg:hsl(210,25%,8%);--fg:#c5c5c5;--sidebar-bg:#14191f;--sidebar-fg:#c8c9db;--sidebar-non-existant:#5c6773;--sidebar-active:#ffb454;--sidebar-spacer:#2d334f;--scrollbar:var(--sidebar-fg);--icons:#737480;--icons-hover:#b7b9cc;--links:#0096cf;--inline-code-color:#ffb454;--theme-popup-bg:#14191f;--theme-popup-border:#5c6773;--theme-hover:#191f26;--quote-bg:hsl(226,15%,17%);--quote-border:hsl(226,15%,22%);--table-border-color:hsl(210,25%,13%);--table-header-bg:hsl(210,25%,28%);--table-alternate-bg:hsl(210,25%,11%);--searchbar-border-color:#848484;--searchbar-bg:#424242;--searchbar-fg:#fff;--searchbar-shadow-color:#d4c89f;--searchresults-header-fg:#666;--searchresults-border-color:#888;--searchresults-li-bg:#252932;--search-mark-bg:#e3b171}.coal{--bg:hsl(200,7%,8%);--fg:#98a3ad;--sidebar-bg:#292c2f;--sidebar-fg:#a1adb8;--sidebar-non-existant:#505254;--sidebar-active:#3473ad;--sidebar-spacer:#393939;--scrollbar:var(--sidebar-fg);--icons:#43484d;--icons-hover:#b3c0cc;--links:#2b79a2;--inline-code-color:#c5c8c6;--theme-popup-bg:#141617;--theme-popup-border:#43484d;--theme-hover:#1f2124;--quote-bg:hsl(234,21%,18%);--quote-border:hsl(234,21%,23%);--table-border-color:hsl(200,7%,13%);--table-header-bg:hsl(200,7%,28%);--table-alternate-bg:hsl(200,7%,11%);--searchbar-border-color:#aaa;--searchbar-bg:#b7b7b7;--searchbar-fg:#000;--searchbar-shadow-color:#aaa;--searchresults-header-fg:#666;--searchresults-border-color:#98a3ad;--searchresults-li-bg:#2b2b2f;--search-mark-bg:#355c7d}.light{--bg:hsl(0,0%,100%);--fg:hsl(0,0%,0%);--sidebar-bg:#fafafa;--sidebar-fg:hsl(0,0%,0%);--sidebar-non-existant:#aaaaaa;--sidebar-active:#1f1fff;--sidebar-spacer:#f4f4f4;--scrollbar:#8F8F8F;--icons:#747474;--icons-hover:#000000;--links:#20609f;--inline-code-color:#301900;--theme-popup-bg:#fafafa;--theme-popup-border:#cccccc;--theme-hover:#e6e6e6;--quote-bg:hsl(197,37%,96%);--quote-border:hsl(197,37%,91%);--table-border-color:hsl(0,0%,95%);--table-header-bg:hsl(0,0%,80%);--table-alternate-bg:hsl(0,0%,97%);--searchbar-border-color:#aaa;--searchbar-bg:#fafafa;--searchbar-fg:#000;--searchbar-shadow-color:#aaa;--searchresults-header-fg:#666;--searchresults-border-color:#888;--searchresults-li-bg:#e4f2fe;--search-mark-bg:#a2cff5}.navy{--bg:hsl(226,23%,11%);--fg:#bcbdd0;--sidebar-bg:#282d3f;--sidebar-fg:#c8c9db;--sidebar-non-existant:#505274;--sidebar-active:#2b79a2;--sidebar-spacer:#2d334f;--scrollbar:var(--sidebar-fg);--icons:#737480;--icons-hover:#b7b9cc;--links:#2b79a2;--inline-code-color:#c5c8c6;--theme-popup-bg:#161923;--theme-popup-border:#737480;--theme-hover:#282e40;--quote-bg:hsl(226,15%,17%);--quote-border:hsl(226,15%,22%);--table-border-color:hsl(226,23%,16%);--table-header-bg:hsl(226,23%,31%);--table-alternate-bg:hsl(226,23%,14%);--searchbar-border-color:#aaa;--searchbar-bg:#aeaec6;--searchbar-fg:#000;--searchbar-shadow-color:#aaa;--searchresults-header-fg:#5f5f71;--searchresults-border-color:#5c5c68;--searchresults-li-bg:#242430;--search-mark-bg:#a2cff5}.rust{--bg:hsl(60,9%,87%);--fg:#262625;--sidebar-bg:#3b2e2a;--sidebar-fg:#c8c9db;--sidebar-non-existant:#505254;--sidebar-active:#e69f67;--sidebar-spacer:#45373a;--scrollbar:var(--sidebar-fg);--icons:#737480;--icons-hover:#262625;--links:#2b79a2;--inline-code-color:#6e6b5e;--theme-popup-bg:#e1e1db;--theme-popup-border:#b38f6b;--theme-hover:#99908a;--quote-bg:hsl(60,5%,75%);--quote-border:hsl(60,5%,70%);--table-border-color:hsl(60,9%,82%);--table-header-bg:#b3a497;--table-alternate-bg:hsl(60,9%,84%);--searchbar-border-color:#aaa;--searchbar-bg:#fafafa;--searchbar-fg:#000;--searchbar-shadow-color:#aaa;--searchresults-header-fg:#666;--searchresults-border-color:#888;--searchresults-li-bg:#dec2a2;--search-mark-bg:#e69f67}@media (prefers-color-scheme:dark){.light.no-js{--bg:hsl(200,7%,8%);--fg:#98a3ad;--sidebar-bg:#292c2f;--sidebar-fg:#a1adb8;--sidebar-non-existant:#505254;--sidebar-active:#3473ad;--sidebar-spacer:#393939;--scrollbar:var(--sidebar-fg);--icons:#43484d;--icons-hover:#b3c0cc;--links:#2b79a2;--inline-code-color:#c5c8c6;--theme-popup-bg:#141617;--theme-popup-border:#43484d;--theme-hover:#1f2124;--quote-bg:hsl(234,21%,18%);--quote-border:hsl(234,21%,23%);--table-border-color:hsl(200,7%,13%);--table-header-bg:hsl(200,7%,28%);--table-alternate-bg:hsl(200,7%,11%);--searchbar-border-color:#aaa;--searchbar-bg:#b7b7b7;--searchbar-fg:#000;--searchbar-shadow-color:#aaa;--searchresults-header-fg:#666;--searchresults-border-color:#98a3ad;--searchresults-li-bg:#2b2b2f;--search-mark-bg:#355c7d}}</style>
        <style>:root{--sidebar-width:300px;--page-padding:15px;--content-max-width:750px;--menu-bar-height:50px}.ayu{--bg:hsl(210,25%,8%);--fg:#c5c5c5;--sidebar-bg:#14191f;--sidebar-fg:#c8c9db;--sidebar-non-existant:#5c6773;--sidebar-active:#ffb454;--sidebar-spacer:#2d334f;--scrollbar:var(--sidebar-fg);--icons:#737480;--icons-hover:#b7b9cc;--links:#0096cf;--inline-code-color:#ffb454;--theme-popup-bg:#14191f;--theme-popup-border:#5c6773;--theme-hover:#191f26;--quote-bg:hsl(226,15%,17%);--quote-border:hsl(226,15%,22%);--table-border-color:hsl(210,25%,13%);--table-header-bg:hsl(210,25%,28%);--table-alternate-bg:hsl(210,25%,11%);--searchbar-border-color:#848484;--searchbar-bg:#424242;--searchbar-fg:#fff;--searchbar-shadow-color:#d4c89f;--searchresults-header-fg:#666;--searchresults-border-color:#888;--searchresults-li-bg:#252932;--search-mark-bg:#e3b171}.coal{--bg:hsl(200,7%,8%);--fg:#98a3ad;--sidebar-bg:#292c2f;--sidebar-fg:#a1adb8;--sidebar-non-existant:#505254;--sidebar-active:#3473ad;--sidebar-spacer:#393939;--scrollbar:var(--sidebar-fg);--icons:#43484d;--icons-hover:#b3c0cc;--links:#2b79a2;--inline-code-color:#c5c8c6;--theme-popup-bg:#141617;--theme-popup-border:#43484d;--theme-hover:#1f2124;--quote-bg:hsl(234,21%,18%);--quote-border:hsl(234,21%,23%);--table-border-color:hsl(200,7%,13%);--table-header-bg:hsl(200,7%,28%);--table-alternate-bg:hsl(200,7%,11%);--searchbar-border-color:#aaa;--searchbar-bg:#b7b7b7;--searchbar-fg:#000;--searchbar-shadow-color:#aaa;--searchresults-header-fg:#666;--searchresults-border-color:#98a3ad;--searchresults-li-bg:#2b2b2f;--search-mark-bg:#355c7d}.light{--bg:hsl(0,0%,100%);--fg:hsl(0,0%,0%);--sidebar-bg:#fafafa;--sidebar-fg:hsl(0,0%,0%);--sidebar-non-existant:#aaaaaa;--sidebar-active:#1f1fff;--sidebar-spacer:#f4f4f4;--scrollbar:#8F8F8F;--icons:#747474;--icons-hover:#000000;--links:#20609f;--inline-code-color:#301900;--theme-popup-bg:#fafafa;--theme-popup-border:#cccccc;--theme-hover:#e6e6e6;--quote-bg:hsl(197,37%,96%);--quote-border:hsl(197,37%,91%);--table-border-color:hsl(0,0%,95%);--table-header-bg:hsl(0,0%,80%);--table-alternate-bg:hsl(0,0%,97%);--searchbar-border-color:#aaa;--searchbar-bg:#fafafa;--searchbar-fg:#000;--searchbar-shadow-color:#aaa;--searchresults-header-fg:#666;--searchresults-border-color:#888;--searchresults-li-bg:#e4f2fe;--search-mark-bg:#a2cff5}.navy{--bg:hsl(226,23%,11%);--fg:#bcbdd0;--sidebar-bg:#282d3f;--sidebar-fg:#c8c9db;--sidebar-non-existant:#505274;--sidebar-active:#2b79a2;--sidebar-spacer:#2d334f;--scrollbar:var(--sidebar-fg);--icons:#737480;--icons-hover:#b7b9cc;--links:#2b79a2;--inline-code-color:#c5c8c6;--theme-popup-bg:#161923;--theme-popup-border:#737480;--theme-hover:#282e40;--quote-bg:hsl(226,15%,17%);--quote-border:hsl(226,15%,22%);--table-border-color:hsl(226,23%,16%);--table-header-bg:hsl(226,23%,31%);--table-alternate-bg:hsl(226,23%,14%);--searchbar-border-color:#aaa;--searchbar-bg:#aeaec6;--searchbar-fg:#000;--searchbar-shadow-color:#aaa;--searchresults-header-fg:#5f5f71;--searchresults-border-color:#5c5c68;--searchresults-li-bg:#242430;--search-mark-bg:#a2cff5}.rust{--bg:hsl(60,9%,87%);--fg:#262625;--sidebar-bg:#3b2e2a;--sidebar-fg:#c8c9db;--sidebar-non-existant:#505254;--sidebar-active:#e69f67;--sidebar-spacer:#45373a;--scrollbar:var(--sidebar-fg);--icons:#737480;--icons-hover:#262625;--links:#2b79a2;--inline-code-color:#6e6b5e;--theme-popup-bg:#e1e1db;--theme-popup-border:#b38f6b;--theme-hover:#99908a;--quote-bg:hsl(60,5%,75%);--quote-border:hsl(60,5%,70%);--table-border-color:hsl(60,9%,82%);--table-header-bg:#b3a497;--table-alternate-bg:hsl(60,9%,84%);--searchbar-border-color:#aaa;--searchbar-bg:#fafafa;--searchbar-fg:#000;--searchbar-shadow-color:#aaa;--searchresults-header-fg:#666;--searchresults-border-color:#888;--searchresults-li-bg:#dec2a2;--search-mark-bg:#e69f67}@media (prefers-color-scheme:dark){.light.no-js{--bg:hsl(200,7%,8%);--fg:#98a3ad;--sidebar-bg:#292c2f;--sidebar-fg:#a1adb8;--sidebar-non-existant:#505254;--sidebar-active:#3473ad;--sidebar-spacer:#393939;--scrollbar:var(--sidebar-fg);--icons:#43484d;--icons-hover:#b3c0cc;--links:#2b79a2;--inline-code-color:#c5c8c6;--theme-popup-bg:#141617;--theme-popup-border:#43484d;--theme-hover:#1f2124;--quote-bg:hsl(234,21%,18%);--quote-border:hsl(234,21%,23%);--table-border-color:hsl(200,7%,13%);--table-header-bg:hsl(200,7%,28%);--table-alternate-bg:hsl(200,7%,11%);--searchbar-border-color:#aaa;--searchbar-bg:#b7b7b7;--searchbar-fg:#000;--searchbar-shadow-color:#aaa;--searchresults-header-fg:#666;--searchresults-border-color:#98a3ad;--searchresults-li-bg:#2b2b2f;--search-mark-bg:#355c7d}}:root{font-size:62.5%}html{font-family:"Open Sans",sans-serif;color:var(--fg);background-color:var(--bg);text-size-adjust:none;-webkit-text-size-adjust:none}body{margin:0;font-size:1.6rem;overflow-x:hidden}code{font-family:"Source Code Pro",Consolas,"Ubuntu Mono",Menlo,"DejaVu Sans Mono",monospace,monospace!important;font-size:0.875em}h1 code,h2 code,h3 code,h4 code,h5 code,h6 code{font-size:unset}.left{float:left}.right{float:right}.boring{opacity:0.6}.hide-boring .boring{display:none}.hidden{display:none!important}h2,h3{margin-top:2.5em}h4,h5{margin-top:2em}.header+.header h3,.header+.header h4,.header+.header h5{margin-top:1em}h1:target::before,h2:target::before,h3:target::before,h4:target::before,h5:target::before,h6:target::before{display:inline-block;content:"Â»";margin-left:-30px;width:30px}:target{scroll-margin-top:calc(var(--menu-bar-height) + 0.5em)}.page{outline:0;padding:0 var(--page-padding);margin-top:calc(0px - var(--menu-bar-height))}.page-wrapper{box-sizing:border-box}.js:not(.sidebar-resizing) .page-wrapper{transition:margin-left 0.3s ease,transform 0.3s ease}.content{overflow-y:auto;padding:0 15px;padding-bottom:50px}.content main{margin-left:auto;margin-right:auto;max-width:var(--content-max-width)}.content p{line-height:1.45em}.content ol{line-height:1.45em}.content ul{line-height:1.45em}.content a{text-decoration:none}.content a:hover{text-decoration:underline}.content img,.content video{max-width:100%}.content .header:link,.content .header:visited{color:var(--fg)}.content .header:link,.content .header:visited:hover{text-decoration:none}table{margin:0 auto;border-collapse:collapse}table td{padding:3px 20px;border:1px var(--table-border-color) solid}table thead{background:var(--table-header-bg)}table thead td{font-weight:700;border:none}table thead th{padding:3px 20px}table thead tr{border:1px var(--table-header-bg) solid}table tbody tr:nth-child(2n){background:var(--table-alternate-bg)}blockquote{margin:20px 0;padding:0 20px;color:var(--fg);background-color:var(--quote-bg);border-top:.1em solid var(--quote-border);border-bottom:.1em solid var(--quote-border)}:not(.footnote-definition)+.footnote-definition,.footnote-definition+:not(.footnote-definition){margin-top:2em}.footnote-definition{font-size:0.9em;margin:0.5em 0}.footnote-definition p{display:inline}.tooltiptext{position:absolute;visibility:hidden;color:#fff;background-color:#333;transform:translateX(-50%);left:-8px;top:-35px;font-size:0.8em;text-align:center;border-radius:6px;padding:5px 8px;margin:5px;z-index:1000}.tooltipped .tooltiptext{visibility:visible}.chapter li.part-title{color:var(--sidebar-fg);margin:5px 0px;font-weight:bold}.result-no-output{font-style:italic}</style>
        <style>:root{--sidebar-width:300px;--page-padding:15px;--content-max-width:750px;--menu-bar-height:50px}.ayu{--bg:hsl(210,25%,8%);--fg:#c5c5c5;--sidebar-bg:#14191f;--sidebar-fg:#c8c9db;--sidebar-non-existant:#5c6773;--sidebar-active:#ffb454;--sidebar-spacer:#2d334f;--scrollbar:var(--sidebar-fg);--icons:#737480;--icons-hover:#b7b9cc;--links:#0096cf;--inline-code-color:#ffb454;--theme-popup-bg:#14191f;--theme-popup-border:#5c6773;--theme-hover:#191f26;--quote-bg:hsl(226,15%,17%);--quote-border:hsl(226,15%,22%);--table-border-color:hsl(210,25%,13%);--table-header-bg:hsl(210,25%,28%);--table-alternate-bg:hsl(210,25%,11%);--searchbar-border-color:#848484;--searchbar-bg:#424242;--searchbar-fg:#fff;--searchbar-shadow-color:#d4c89f;--searchresults-header-fg:#666;--searchresults-border-color:#888;--searchresults-li-bg:#252932;--search-mark-bg:#e3b171}.coal{--bg:hsl(200,7%,8%);--fg:#98a3ad;--sidebar-bg:#292c2f;--sidebar-fg:#a1adb8;--sidebar-non-existant:#505254;--sidebar-active:#3473ad;--sidebar-spacer:#393939;--scrollbar:var(--sidebar-fg);--icons:#43484d;--icons-hover:#b3c0cc;--links:#2b79a2;--inline-code-color:#c5c8c6;--theme-popup-bg:#141617;--theme-popup-border:#43484d;--theme-hover:#1f2124;--quote-bg:hsl(234,21%,18%);--quote-border:hsl(234,21%,23%);--table-border-color:hsl(200,7%,13%);--table-header-bg:hsl(200,7%,28%);--table-alternate-bg:hsl(200,7%,11%);--searchbar-border-color:#aaa;--searchbar-bg:#b7b7b7;--searchbar-fg:#000;--searchbar-shadow-color:#aaa;--searchresults-header-fg:#666;--searchresults-border-color:#98a3ad;--searchresults-li-bg:#2b2b2f;--search-mark-bg:#355c7d}.light{--bg:hsl(0,0%,100%);--fg:hsl(0,0%,0%);--sidebar-bg:#fafafa;--sidebar-fg:hsl(0,0%,0%);--sidebar-non-existant:#aaaaaa;--sidebar-active:#1f1fff;--sidebar-spacer:#f4f4f4;--scrollbar:#8F8F8F;--icons:#747474;--icons-hover:#000000;--links:#20609f;--inline-code-color:#301900;--theme-popup-bg:#fafafa;--theme-popup-border:#cccccc;--theme-hover:#e6e6e6;--quote-bg:hsl(197,37%,96%);--quote-border:hsl(197,37%,91%);--table-border-color:hsl(0,0%,95%);--table-header-bg:hsl(0,0%,80%);--table-alternate-bg:hsl(0,0%,97%);--searchbar-border-color:#aaa;--searchbar-bg:#fafafa;--searchbar-fg:#000;--searchbar-shadow-color:#aaa;--searchresults-header-fg:#666;--searchresults-border-color:#888;--searchresults-li-bg:#e4f2fe;--search-mark-bg:#a2cff5}.navy{--bg:hsl(226,23%,11%);--fg:#bcbdd0;--sidebar-bg:#282d3f;--sidebar-fg:#c8c9db;--sidebar-non-existant:#505274;--sidebar-active:#2b79a2;--sidebar-spacer:#2d334f;--scrollbar:var(--sidebar-fg);--icons:#737480;--icons-hover:#b7b9cc;--links:#2b79a2;--inline-code-color:#c5c8c6;--theme-popup-bg:#161923;--theme-popup-border:#737480;--theme-hover:#282e40;--quote-bg:hsl(226,15%,17%);--quote-border:hsl(226,15%,22%);--table-border-color:hsl(226,23%,16%);--table-header-bg:hsl(226,23%,31%);--table-alternate-bg:hsl(226,23%,14%);--searchbar-border-color:#aaa;--searchbar-bg:#aeaec6;--searchbar-fg:#000;--searchbar-shadow-color:#aaa;--searchresults-header-fg:#5f5f71;--searchresults-border-color:#5c5c68;--searchresults-li-bg:#242430;--search-mark-bg:#a2cff5}.rust{--bg:hsl(60,9%,87%);--fg:#262625;--sidebar-bg:#3b2e2a;--sidebar-fg:#c8c9db;--sidebar-non-existant:#505254;--sidebar-active:#e69f67;--sidebar-spacer:#45373a;--scrollbar:var(--sidebar-fg);--icons:#737480;--icons-hover:#262625;--links:#2b79a2;--inline-code-color:#6e6b5e;--theme-popup-bg:#e1e1db;--theme-popup-border:#b38f6b;--theme-hover:#99908a;--quote-bg:hsl(60,5%,75%);--quote-border:hsl(60,5%,70%);--table-border-color:hsl(60,9%,82%);--table-header-bg:#b3a497;--table-alternate-bg:hsl(60,9%,84%);--searchbar-border-color:#aaa;--searchbar-bg:#fafafa;--searchbar-fg:#000;--searchbar-shadow-color:#aaa;--searchresults-header-fg:#666;--searchresults-border-color:#888;--searchresults-li-bg:#dec2a2;--search-mark-bg:#e69f67}@media (prefers-color-scheme:dark){.light.no-js{--bg:hsl(200,7%,8%);--fg:#98a3ad;--sidebar-bg:#292c2f;--sidebar-fg:#a1adb8;--sidebar-non-existant:#505254;--sidebar-active:#3473ad;--sidebar-spacer:#393939;--scrollbar:var(--sidebar-fg);--icons:#43484d;--icons-hover:#b3c0cc;--links:#2b79a2;--inline-code-color:#c5c8c6;--theme-popup-bg:#141617;--theme-popup-border:#43484d;--theme-hover:#1f2124;--quote-bg:hsl(234,21%,18%);--quote-border:hsl(234,21%,23%);--table-border-color:hsl(200,7%,13%);--table-header-bg:hsl(200,7%,28%);--table-alternate-bg:hsl(200,7%,11%);--searchbar-border-color:#aaa;--searchbar-bg:#b7b7b7;--searchbar-fg:#000;--searchbar-shadow-color:#aaa;--searchresults-header-fg:#666;--searchresults-border-color:#98a3ad;--searchresults-li-bg:#2b2b2f;--search-mark-bg:#355c7d}}::-webkit-scrollbar{background:var(--bg)}::-webkit-scrollbar-thumb{background:var(--scrollbar)}html{scrollbar-color:var(--scrollbar) var(--bg)}#searchresults a,.content a:link,a:visited,a>.hljs{color:var(--links)}#menu-bar,#menu-bar-hover-placeholder{z-index:101;margin:auto calc(0px - var(--page-padding))}#menu-bar{position:relative;display:flex;flex-wrap:wrap;background-color:var(--bg);border-bottom-color:var(--bg);border-bottom-width:1px;border-bottom-style:solid}#menu-bar.sticky,.js #menu-bar-hover-placeholder:hover+#menu-bar,.js #menu-bar:hover,.js.sidebar-visible #menu-bar{position:-webkit-sticky;position:sticky;top:0!important}#menu-bar-hover-placeholder{position:sticky;position:-webkit-sticky;top:0;height:var(--menu-bar-height)}#menu-bar.bordered{border-bottom-color:var(--table-border-color)}#menu-bar i,#menu-bar .icon-button{position:relative;padding:0 8px;z-index:10;line-height:var(--menu-bar-height);cursor:pointer;transition:color 0.5s}@media only screen and (max-width:420px){#menu-bar i,#menu-bar .icon-button{padding:0 5px}}.icon-button{border:none;background:none;padding:0;color:inherit}.icon-button i{margin:0}.right-buttons{margin:0 15px}.right-buttons a{text-decoration:none}.left-buttons{display:flex;margin:0 5px}.no-js .left-buttons{display:none}.menu-title{display:inline-block;font-weight:200;font-size:2.4rem;line-height:var(--menu-bar-height);text-align:center;margin:0;flex:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.js .menu-title{cursor:pointer}.menu-bar,.menu-bar:visited,.nav-chapters,.nav-chapters:visited,.mobile-nav-chapters,.mobile-nav-chapters:visited,.menu-bar .icon-button,.menu-bar a i{color:var(--icons)}.menu-bar i:hover,.menu-bar .icon-button:hover,.nav-chapters:hover,.mobile-nav-chapters i:hover{color:var(--icons-hover)}.nav-chapters{font-size:2.5em;text-align:center;text-decoration:none;position:fixed;top:0;bottom:0;margin:0;max-width:150px;min-width:90px;display:flex;justify-content:center;align-content:center;flex-direction:column;transition:color 0.5s,background-color 0.5s}.nav-chapters:hover{text-decoration:none;background-color:var(--theme-hover);transition:background-color 0.15s,color 0.15s}.nav-wrapper{margin-top:50px;display:none}.mobile-nav-chapters{font-size:2.5em;text-align:center;text-decoration:none;width:90px;border-radius:5px;background-color:var(--sidebar-bg)}.previous{float:left}.next{float:right;right:var(--page-padding)}@media only screen and (max-width:1080px){.nav-wide-wrapper{display:none}.nav-wrapper{display:block}}@media only screen and (max-width:1380px){.sidebar-visible .nav-wide-wrapper{display:none}.sidebar-visible .nav-wrapper{display:block}}:not(pre)>.hljs{display:inline;padding:0.1em 0.3em;border-radius:3px}:not(pre):not(a)>.hljs{color:var(--inline-code-color);overflow-x:initial}a:hover>.hljs{text-decoration:underline}pre{position:relative}pre>.buttons{position:absolute;z-index:100;right:5px;top:5px;color:var(--sidebar-fg);cursor:pointer}pre>.buttons :hover{color:var(--sidebar-active)}pre>.buttons i{margin-left:8px}pre>.buttons button{color:inherit;background:transparent;border:none;cursor:inherit}pre>.result{margin-top:10px}#searchresults a{text-decoration:none}mark{border-radius:2px;padding:0 3px 1px 3px;margin:0-3px -1px -3px;background-color:var(--search-mark-bg);transition:background-color 300ms linear;cursor:pointer}mark.fade-out{background-color:rgba(0,0,0,0)!important;cursor:auto}.searchbar-outer{margin-left:auto;margin-right:auto;max-width:var(--content-max-width)}#searchbar{width:100%;margin:5px auto 0px auto;padding:10px 16px;transition:box-shadow 300ms ease-in-out;border:1px solid var(--searchbar-border-color);border-radius:3px;background-color:var(--searchbar-bg);color:var(--searchbar-fg)}#searchbar:focus,#searchbar.active{box-shadow:0 0 3px var(--searchbar-shadow-color)}.searchresults-header{font-weight:bold;font-size:1em;padding:18px 0 0 5px;color:var(--searchresults-header-fg)}.searchresults-outer{margin-left:auto;margin-right:auto;max-width:var(--content-max-width);border-bottom:1px dashed var(--searchresults-border-color)}ul#searchresults{list-style:none;padding-left:20px}ul#searchresults li{margin:10px 0px;padding:2px;border-radius:2px}ul#searchresults li.focus{background-color:var(--searchresults-li-bg)}ul#searchresults span.teaser{display:block;clear:both;margin:5px 0 0 20px;font-size:0.8em}ul#searchresults span.teaser em{font-weight:bold;font-style:normal}.sidebar{position:fixed;left:0;top:0;bottom:0;width:var(--sidebar-width);font-size:0.875em;box-sizing:border-box;-webkit-overflow-scrolling:touch;overscroll-behavior-y:contain;background-color:var(--sidebar-bg);color:var(--sidebar-fg)}.sidebar-resizing{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.js:not(.sidebar-resizing) .sidebar{transition:transform 0.3s}.sidebar code{line-height:2em}.sidebar .sidebar-scrollbox{overflow-y:auto;position:absolute;top:0;bottom:0;left:0;right:0;padding:10px 10px}.sidebar .sidebar-resize-handle{position:absolute;cursor:col-resize;width:0;right:0;top:0;bottom:0}.js .sidebar .sidebar-resize-handle{cursor:col-resize;width:5px}.sidebar-hidden .sidebar{transform:translateX(calc(0px - var(--sidebar-width)))}.sidebar::-webkit-scrollbar{background:var(--sidebar-bg)}.sidebar::-webkit-scrollbar-thumb{background:var(--scrollbar)}.sidebar-visible .page-wrapper{transform:translateX(var(--sidebar-width))}@media only screen and (min-width:620px){.sidebar-visible .page-wrapper{transform:none;margin-left:var(--sidebar-width)}}.chapter{list-style:none outside none;padding-left:0;line-height:2.2em}.chapter ol{width:100%}.chapter li{display:flex;color:var(--sidebar-non-existant)}.chapter li a{display:block;padding:0;text-decoration:none;color:var(--sidebar-fg)}.chapter li a:hover{color:var(--sidebar-active)}.chapter li a.active{color:var(--sidebar-active)}.chapter li>a.toggle{cursor:pointer;display:block;margin-left:auto;padding:0 10px;user-select:none;opacity:0.68}.chapter li>a.toggle div{transition:transform 0.5s}.chapter li:not(.expanded)+li>ol{display:none}.chapter li.chapter-item{line-height:1.5em;margin-top:0.6em}.chapter li.expanded>a.toggle div{transform:rotate(90deg)}.spacer{width:100%;height:3px;margin:5px 0px}.chapter .spacer{background-color:var(--sidebar-spacer)}@media (-moz-touch-enabled:1),(pointer:coarse){.chapter li a{padding:5px 0}.spacer{margin:10px 0}}.section{list-style:none outside none;padding-left:20px;line-height:1.9em}.theme-popup{position:absolute;left:10px;top:var(--menu-bar-height);z-index:1000;border-radius:4px;font-size:0.7em;color:var(--fg);background:var(--theme-popup-bg);border:1px solid var(--theme-popup-border);margin:0;padding:0;list-style:none;display:none}.theme-popup .default{color:var(--icons)}.theme-popup .theme{width:100%;border:0;margin:0;padding:2px 10px;line-height:25px;white-space:nowrap;text-align:left;cursor:pointer;color:inherit;background:inherit;font-size:inherit}.theme-popup .theme:hover{background-color:var(--theme-hover)}.theme-popup .theme:hover:first-child,.theme-popup .theme:hover:last-child{border-top-left-radius:inherit;border-top-right-radius:inherit}</style>
        <style media="print">#sidebar,#menu-bar,.nav-chapters,.mobile-nav-chapters{display:none}#page-wrapper.page-wrapper{transform:none;margin-left:0px;overflow-y:initial}#content{max-width:none;margin:0;padding:0}.page{overflow-y:initial}code{background-color:#666666;border-radius:5px;-webkit-print-color-adjust:exact}pre>.buttons{z-index:2}a,a:visited,a:active,a:hover{color:#4183c4;text-decoration:none}h1,h2,h3,h4,h5,h6{page-break-inside:avoid;page-break-after:avoid}pre,code{page-break-inside:avoid;white-space:pre-wrap}.fa{display:none!important}</style>
        <!-- Fonts -->
        <style>/*!
 *  Font Awesome 4.7.0 by @davegandy - http://fontawesome.io - @fontawesome
 *  License - http://fontawesome.io/license (Font: SIL OFL 1.1, CSS: MIT License)
 */@font-face{font-family:"FontAwesome";src:url(data:application/vnd.ms-fontobject;base64,bocCAKyGAgABAAIAAAAAAAAAAAAAAAAAAAABAJABAAAAAExQAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAWXjPkAAAAAAAAAAAAAAAAAAAAAAAABYARgBvAG4AdABBAHcAZQBzAG8AbQBlAAAADgBSAGUAZwB1AGwAYQByAAAAJABWAGUAcgBzAGkAbwBuACAANAAuADcALgAwACAAMgAwADEANgAAABYARgBvAG4AdABBAHcAZQBzAG8AbQBlAAAAAAAAAQAAAA0AgAADAFBGRlRNa75HuQAChpAAAAAcR0RFRgLwAAQAAoZwAAAAIE9TLzKIMnpAAAABWAAAAGBjbWFwCr86fwAADKgAAALyZ2FzcP//AAMAAoZoAAAACGdseWaP965NAAAarAACTLxoZWFkEInlLQAAANwAAAA2aGhlYQ8DCrUAAAEUAAAAJGhtdHhFeRiFAAABuAAACvBsb2NhAvWiXAAAD5wAAAsQbWF4cAMsAhwAAAE4AAAAIG5hbWXjl4usAAJnaAAABIZwb3N0r4+boQACa/AAABp1AAEAAAAEAcuQz3hZXw889QALBwAAAAAA1DPNMgAAAADUM80y////AAkBBgAAAAAIAAIAAQAAAAAAAQAABgD/AAAACQD/////CQEAAQAAAAAAAAAAAAAAAAAAArUAAQAAAsMCGQAnAAAAAAACAAAAAQABAAAAQAAAAAAAAAADBmkBkAAFAAAEjAQzAAAAhgSMBDMAAAJzAAABigAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABweXJzAEAAIPUABgD/AAAABgABAAAAAAEAAAAAAAAAAAAAACAAAQOAAHAAAAAAAlUAAAHAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAABdBgAAAAaAAAAHAAAABwAAAAaAAAAGgAAABQAAAAeAAAAGgAAABwAAAAcAAAAHAAB5BYAAbgaAAAAGgAAABgAAAAcAAAAGAAAABYAAAAaAABoGAAAABgAAAAeAADIGgAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABwAAAASAAAAHAABABoAAAAMAAAAEgAAABoAAAAWAAAAHAAAABgAAAAeAAAAGgAAKBQAAAAaAAAAHgAAABoAAAAWAAAAEAAAABwAAAAYAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAeAAAAGAAAABAAAAAYAAAAEAAAABwAAAAaAAAAGgAAABwAAAAQAAAAHAAAABoAAegWAAAAGAAAABgAAAAaAAAAHAAAABAAAAAYCAAEFAACaBQAAWgYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAABABgAAAAaAADUGgAA1BwAAAAYAAAAGAAANBYAAAAWAAAAGgAB6BgAAAAYAAAAHAAAABYAAAAcAAAAHAAAABwAAEAWAAAAGgAAABwAAAAcAAAAGAAAABwAAWgcAAFoHgAAABoAAAAaAAAAHgAAAAwAAQAcAAAAIAAAABgAAAAYAAAAHAAAABwAAAAeAAAAHAAAABgAAAAYAAAADgAAABwAAAAaAAAAGAAAABIAAAAcAAAAGAAAABoAAAAYAAAAGgAAABgAAAAWAAAAFgAAABQAAAAYAAAAGgAAsBAAAXwYAAAAGgAAAB4AAAAWAAAAGAAAABwAAAAcAAEAGAAACBwAAAAcAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABoAAFQcAAAAFgAAFBwAAAAYAAAAHgAAABoAAEAeAAAAGgABzBwAAAQcAAAAFgAAEBgAAAAYAAAAGAAAABwAAAAcAAA8HAAAABgAAAAaAAAAGgAAbBwAAQAYAAAAGAAAABgAAAAkAAAAHgAAABAAAAAQAAAACgABAAoAAAAaAAAAEAAAABAAAAAQAAAAHAAAABgAAAAYAAAAHAAAoBwAAAAcAAAAHAAAAA4AAAQcAAAAGgAAABwAAAAQAAAAHAAAAB4AAAAeAAAAFgAAABYAAAAcAAAAHAABAB4AAAAWAAAAGAAAABYAAAAWAAAAHgABABwAAAAeAAAAGgABABgAAAAYAAAAEAAAtBAAADQSAAE0EgABNAoAALQKAAA0EgABNBIAATQeAAAAHgAAABIAAAAMAAAAGAAAABoAAAAaAAAAHAABABgAAAAcAAAAGgAAABoAAAAeAAAAHAAAABwAAAAYAAAAGAAAABgAAAAeAAAAHgAAABwAAQAcAAEAGgAANB4AALQcAAAAGgAACBYAAAgaAAAAEAAAABoAAAAQAAGACgAAAAoAAYgYAAAUGAAAFB4AAAQaAAAAEgAAABYAADQUAAAAGgAAABYAAAwaAACQHAAAABgAAAAYAAAAGAAAABgAAAAWAAAAHAAAMBwAAAASAAAAGAAAABYAAAAGAAAAGAAAABgAAAAcAADYGAAAABYAAAAQAAAMEAAADBgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAEAAAABAAAAAQAADQDggAABAMABAUAAAAHAAAABQAAOAYAAAAGAAAABoAAIgaAACIHAAAiBwAAIgYAACIGAAAiBoAAAAaAAAAGAAAABgAAGwWAAAUGAAAABwAAAAcAAEAGAAALBgAAAAYAAAAGAAAABYAAAAYAAAAEAABEBgAAAAMAAAMDAAADBwAAQAcAAAAFgAAABoAAAAWAAAAGAAALBgAAAAYAAAAFAAAsBgAAAAUAAAAEAAAABgAAAAcAACwGAAAABwAAQAaAACAHgP//BwAAAAYAAAAFgAAABQAAFQYAAAAGAAAABgAAAAYAAAAGgAAABgAAAASAAAAFgAAACIAAAAaAAAAGAAAABwAAAAcAAAAIAAAACQAAAAYAAG0GAAAABwAAAAYAAAAGAAAAB4AAAAYAAAAIAAAABgAAAAf2ACkGAAAABgAAAAYAAAAHAAAABgAAAAUAAEAGgAAAAwAAQAcAAAAJAAAACAAAAAYAAAAHAAAABgAAAAcAABAIAAAACAAAAAYAACAGAAAABAAAAAkAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAJwcAAAAIAAAABwAAAAcAACAHAAATBwAAAAYAAAAHAABEBgAAAAUAADkHAAASCAAAAAcAAAAHAAAABgAAAAYAAAAHAAA+BQAAGAYAAAAGAAAABgAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAGQcAAGQGAABZCAAAAAgAACoHAAAABgAACQcAACcJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAIAAAOCAAADgWAAAAGAAAABgAAAAcAAAAHAAAABwAAAAgAAAAHAAAACAAAAAcAAAAGAAAACAAAAAgAAAAJAAAABgAAAAgAAAAFAAALCAAAAAYAAAAGAAAABgAAAAgAAAAGAAAABgAAAAgAAAAIAAAABgAAAAgAAAAIAAAABoAAAAaAAAAIAAAACAAAEwYAAAAJAAAABgAAAAcAAAAFAAACBgAAAAUAAAAGAAACBwAAAAcA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AaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwG4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gHfAeAB4QHiAeMB5AHlAeYB5wHoAekB6gHrAewB7QHuAe8B8AHxAfIB8wH0AfUB9gH3AfgB+QH6AfsB/AH9Af4B/wIAAgECAgIDAgQCBQIGAgcCCAAiAgkCCgILAgwCDQIOAg8CEAIRAhICEwIUAhUCFgIXAhgCGQIaAhsCHAIdAh4CHwIgAiECIgIjAiQCJQImAicCKAIpAioCKwIsAi0CLgIvAjACMQIyAjMCNAI1AjYCNwI4AjkCOgI7AjwCPQI+Aj8CQAJBAkICQwJEAkUCRgJHAkgCSQJKAksCTAJNAk4CTwJQAlECUgJTANICVAJVAlYCVwJYAlkCWgJbAlwCXQJeAl8CYAJhAmICYwJkAmUCZgJnAmgCaQJqAmsCbAJtAm4CbwJwAnECcgJzAnQCdQJ2AncCeAJ5AnoCewJ8An0CfgJ/AoACgQKCAoMChAKFAoYChwKIAokCigKLAowCjQKOAo8CkAKRApICkwKUApUClgKXApgCmQKaApsCnAKdAp4CnwKgAqECogKjAqQCpQKmAqcCqAKpAqoCqwKsAq0CrgKvArACsQKyArMCtAK1ArYCtwK4ArkCugK7ArwCvQK+Ar8CwALBAsICwwLEAsUCxgLHAsgCyQLKAssCzALNAs4CzwLQAtEC0gLTAtQC1QLWAtcC2ALZAtoC2wLcAt0C3gLfAuAC4QLiAuMC5ALlAuYC5wLoAukC6gLrAuwC7QLuAu8C8ALxAvIC8wL0AvUC9gL3AvgC+QL6AvsC/AL9Av4C/wMAAwEDAgMDAwQDBQMGAwcDCAMJAwoDCwMMAw0DDgMPAxADEQMSAxMDFAMVAxYDFwMYAxkDGgMbAxwDHQMeAx8DIAMhAyIDIwMkAyUDJgMnAygDKQMqAysDLAMtAy4DLwMwAzEDMgMzAzQDNQM2AzcDOAM5AzoDOwM8Az0DPgM/A0ADQQNCA0MDRANFA0YDRwNIA0kDSgNLA0wDTQNOA08DUANRA1IDUwNUA1UDVgNXA1gDWQNaA1sDXANdA14DXwNgA2EDYgNjA2QDZQNmA2cDaANpA2oDawNsA20DbgNvA3ADcQNyA3MDdAN1A3YDdwN4A3kDegN7A3wDfQN+A38DgAOBA4IDgwOEA4UDhgOHA4gDiQOKA4sDjAONA44DjwOQA5EDkgOTA5QDlQOWA5cDmAOZA5oDmwOcA50DngOfA6ADoQOiA6MDpAOlA6YDpwOoA6kDqgOrA6wDrQOuA68DsAOxAJQFZ2xhc3MFbXVzaWMGc2VhcmNoCGVudmVsb3BlBWhlYXJ0BHN0YXIKc3Rhcl9lbXB0eQR1c2VyBGZpbG0IdGhfbGFyZ2UCdGgHdGhfbGlzdAJvawZyZW1vdmUHem9vbV9pbgh6b29tX291dANvZmYGc2lnbmFsA2NvZwV0cmFzaARob21lCGZpbGVfYWx0BHRpbWUEcm9hZAxkb3dubG9hZF9hbHQIZG93bmxvYWQGdXBsb2FkBWluYm94C3BsYXlfY2lyY2xlBnJlcGVhdAdyZWZyZXNoCGxpc3RfYWx0BGxvY2sEZmxhZwpoZWFkcGhvbmVzCnZvbHVtZV9vZmYLdm9sdW1lX2Rvd24Jdm9sdW1lX3VwBnFyY29kZQdiYXJjb2RlA3RhZwR0YWdzBGJvb2sIYm9va21hcmsFcHJpbnQGY2FtZXJhBGZvbnQEYm9sZAZpdGFsaWMLdGV4dF9oZWlnaHQKdGV4dF93aWR0aAphbGlnbl9sZWZ0DGFsaWduX2NlbnRlcgthbGlnbl9yaWdodA1hbGlnbl9qdXN0aWZ5BGxpc3QLaW5kZW50X2xlZnQMaW5kZW50X3JpZ2h0DmZhY2V0aW1lX3ZpZGVvB3BpY3R1cmUGcGVuY2lsCm1hcF9tYXJrZXIGYWRqdXN0BHRpbnQEZWRpdAVzaGFyZQVjaGVjawRtb3ZlDXN0ZXBfYmFja3dhcmQNZmFzdF9iYWNrd2FyZAhiYWNrd2FyZARwbGF5BXBhdXNlBHN0b3AHZm9yd2FyZAxmYXN0X2ZvcndhcmQMc3RlcF9mb3J3YXJkBWVqZWN0DGNoZXZyb25fbGVmdA1jaGV2cm9uX3JpZ2h0CXBsdXNfc2lnbgptaW51c19zaWduC3JlbW92ZV9zaWduB29rX3NpZ24NcXVlc3Rpb25fc2lnbglpbmZvX3NpZ24Kc2NyZWVuc2hvdA1yZW1vdmVfY2lyY2xlCW9rX2NpcmNsZQpiYW5fY2lyY2xlCmFycm93X2xlZnQLYXJyb3dfcmlnaHQIYXJyb3dfdXAKYXJyb3dfZG93bglzaGFyZV9hbHQLcmVzaXplX2Z1bGwMcmVzaXplX3NtYWxsEGV4Y2xhbWF0aW9uX3NpZ24EZ2lmdARsZWFmBGZpcmUIZXllX29wZW4JZXllX2Nsb3NlDHdhcm5pbmdfc2lnbgVwbGFuZQhjYWxlbmRhcgZyYW5kb20HY29tbWVudAZtYWduZXQKY2hldnJvbl91cAxjaGV2cm9uX2Rvd24HcmV0d2VldA1zaG9wcGluZ19jYXJ0DGZvbGRlcl9jbG9zZQtmb2xkZXJfb3Blbg9yZXNpemVfdmVydGljYWwRcmVzaXplX2hvcml6b250YWwJYmFyX2NoYXJ0DHR3aXR0ZXJfc2lnbg1mYWNlYm9va19zaWduDGNhbWVyYV9yZXRybwNrZXkEY29ncwhjb21tZW50cw10aHVtYnNfdXBfYWx0D3RodW1ic19kb3duX2FsdAlzdGFyX2hhbGYLaGVhcnRfZW1wdHkHc2lnbm91dA1saW5rZWRpbl9zaWduB3B1c2hwaW4NZXh0ZXJuYWxfbGluawZzaWduaW4GdHJvcGh5C2dpdGh1Yl9zaWduCnVwbG9hZF9hbHQFbGVtb24FcGhvbmULY2hlY2tfZW1wdHkOYm9va21hcmtfZW1wdHkKcGhvbmVfc2lnbgd0d2l0dGVyCGZhY2Vib29rBmdpdGh1YgZ1bmxvY2sLY3JlZGl0X2NhcmQDcnNzA2hkZAhidWxsaG9ybgRiZWxsC2NlcnRpZmljYXRlCmhhbmRfcmlnaHQJaGFuZF9sZWZ0B2hhbmRfdXAJaGFuZF9kb3duEWNpcmNsZV9hcnJvd19sZWZ0EmNpcmNsZV9hcnJvd19yaWdodA9jaXJjbGVfYXJyb3dfdXARY2lyY2xlX2Fycm93X2Rvd24FZ2xvYmUGd3JlbmNoBXRhc2tzBmZpbHRlcglicmllZmNhc2UKZnVsbHNjcmVlbgVncm91cARsaW5rBWNsb3VkBmJlYWtlcgNjdXQEY29weQpwYXBlcl9jbGlwBHNhdmUKc2lnbl9ibGFuawdyZW9yZGVyAnVsAm9sDXN0cmlrZXRocm91Z2gJdW5kZXJsaW5lBXRhYmxlBW1hZ2ljBXRydWNrCXBpbnRlcmVzdA5waW50ZXJlc3Rfc2lnbhBnb29nbGVfcGx1c19zaWduC2dvb2dsZV9wbHVzBW1vbmV5CmNhcmV0X2Rvd24IY2FyZXRfdXAKY2FyZXRfbGVmdAtjYXJldF9yaWdodAdjb2x1bW5zBHNvcnQJc29ydF9kb3duB3NvcnRfdXAMZW52ZWxvcGVfYWx0CGxpbmtlZGluBHVuZG8FbGVnYWwJZGFzaGJvYXJkC2NvbW1lbnRfYWx0DGNvbW1lbnRzX2FsdARib2x0B3NpdGVtYXAIdW1icmVsbGEFcGFzdGUKbGlnaHRfYnVsYghleGNoYW5nZQ5jbG91ZF9kb3dubG9hZAxjbG91ZF91cGxvYWQHdXNlcl9tZAtzdGV0aG9zY29wZQhzdWl0Y2FzZQhiZWxsX2FsdAZjb2ZmZWUEZm9vZA1maWxlX3RleHRfYWx0CGJ1aWxkaW5nCGhvc3BpdGFsCWFtYnVsYW5jZQZtZWRraXQLZmlnaHRlcl9qZXQEYmVlcgZoX3NpZ24EZjBmZRFkb3VibGVfYW5nbGVfbGVmdBJkb3VibGVfYW5nbGVfcmlnaHQPZG91YmxlX2FuZ2xlX3VwEWRvdWJsZV9hbmdsZV9kb3duCmFuZ2xlX2xlZnQLYW5nbGVfcmlnaHQIYW5nbGVfdXAKYW5nbGVfZG93bgdkZXNrdG9wBmxhcHRvcAZ0YWJsZXQMbW9iaWxlX3Bob25lDGNpcmNsZV9ibGFuawpxdW90ZV9sZWZ0C3F1b3RlX3JpZ2h0B3NwaW5uZXIGY2lyY2xlBXJlcGx5CmdpdGh1Yl9hbHQQZm9sZGVyX2Nsb3NlX2FsdA9mb2xkZXJfb3Blbl9hbHQKZXhwYW5kX2FsdAxjb2xsYXBzZV9hbHQFc21pbGUFZnJvd24DbWVoB2dhbWVwYWQIa2V5Ym9hcmQIZmxhZ19hbHQOZmxhZ19jaGVja2VyZWQIdGVybWluYWwEY29kZQlyZXBseV9hbGwPc3Rhcl9oYWxmX2VtcHR5DmxvY2F0aW9uX2Fycm93BGNyb3AJY29kZV9mb3JrBnVubGluawRfMjc5C2V4Y2xhbWF0aW9uC3N1cGVyc2NyaXB0CXN1YnNjcmlwdARfMjgzDHB1enpsZV9waWVjZQptaWNyb3Bob25lDm1pY3JvcGhvbmVfb2ZmBnNoaWVsZA5jYWxlbmRhcl9lbXB0eRFmaXJlX2V4dGluZ3Vpc2hlcgZyb2NrZXQGbWF4Y2RuEWNoZXZyb25fc2lnbl9sZWZ0EmNoZXZyb25fc2lnbl9yaWdodA9jaGV2cm9uX3NpZ25fdXARY2hldnJvbl9zaWduX2Rvd24FaHRtbDUEY3NzMwZhbmNob3IKdW5sb2NrX2FsdAhidWxsc2V5ZRNlbGxpcHNpc19ob3Jpem9udGFsEWVsbGlwc2lzX3ZlcnRpY2FsBF8zMDMJcGxheV9zaWduBnRpY2tldA5taW51c19zaWduX2FsdAtjaGVja19taW51cwhsZXZlbF91cApsZXZlbF9kb3duCmNoZWNrX3NpZ24JZWRpdF9zaWduBF8zMTIKc2hhcmVfc2lnbgdjb21wYXNzCGNvbGxhcHNlDGNvbGxhcHNlX3RvcARfMzE3A2V1cgNnYnADdXNkA2lucgNqcHkDcnViA2tydwNidGMEZmlsZQlmaWxlX3RleHQQc29ydF9ieV9hbHBoYWJldARfMzI5EnNvcnRfYnlfYXR0cmlidXRlcxZzb3J0X2J5X2F0dHJpYnV0ZXNfYWx0DXNvcnRfYnlfb3JkZXIRc29ydF9ieV9vcmRlcl9hbHQEXzMzNARfMzM1DHlvdXR1YmVfc2lnbgd5b3V0dWJlBHhpbmcJeGluZ19zaWduDHlvdXR1YmVfcGxheQdkcm9wYm94DXN0YWNrZXhjaGFuZ2UJaW5zdGFncmFtBmZsaWNrcgNhZG4EZjE3MQ5iaXRidWNrZXRfc2lnbgZ0dW1ibHILdHVtYmxyX3NpZ24PbG9uZ19hcnJvd19kb3duDWxvbmdfYXJyb3dfdXAPbG9uZ19hcnJvd19sZWZ0EGxvbmdfYXJyb3dfcmlnaHQHd2luZG93cwdhbmRyb2lkBWxpbnV4B2RyaWJibGUFc2t5cGUKZm91cnNxdWFyZQZ0cmVsbG8GZmVtYWxlBG1hbGUGZ2l0dGlwA3N1bgRfMzY2B2FyY2hpdmUDYnVnAnZrBXdlaWJvBnJlbnJlbgRfMzcyDnN0YWNrX2V4Y2hhbmdlBF8zNzQVYXJyb3dfY2lyY2xlX2FsdF9sZWZ0BF8zNzYOZG90X2NpcmNsZV9hbHQEXzM3OAx2aW1lb19zcXVhcmUEXzM4MA1wbHVzX3NxdWFyZV9vBF8zODIEXzM4MwRfMzg0BF8zODUEXzM4NgRfMzg3BF8zODgEXzM4OQd1bmlGMUEwBGYxYTEEXzM5MgRfMzkzBGYxYTQEXzM5NQRfMzk2BF8zOTcEXzM5OARfMzk5BF80MDAEZjFhYgRfNDAyBF80MDMEXzQwNAd1bmlGMUIxBF80MDYEXzQwNwRfNDA4BF80MDkEXzQxMARfNDExBF80MTIEXzQxMwRfNDE0BF80MTUEXzQxNgRfNDE3BF80MTgEXzQxOQd1bmlGMUMwB3VuaUYxQzEEXzQyMgRfNDIzBF80MjQEXzQyNQRfNDI2BF80MjcEXzQyOARfNDI5BF80MzAEXzQzMQRfNDMyBF80MzMEXzQzNAd1bmlGMUQwB3VuaUYxRDEHdW5pRjFEMgRfNDM4BF80MzkHdW5pRjFENQd1bmlGMUQ2B3VuaUYxRDcEXzQ0MwRfNDQ0BF80NDUEXzQ0NgRfNDQ3BF80NDgEXzQ0OQd1bmlGMUUwBF80NTEEXzQ1MgRfNDUzBF80NTQEXzQ1NQRfNDU2BF80NTcEXzQ1OARfNDU5BF80NjAEXzQ2MQRfNDYyBF80NjMEXzQ2NAd1bmlGMUYwBF80NjYEXzQ2NwRmMWYzBF80NjkEXzQ3MARfNDcxBF80NzIEXzQ3MwRfNDc0BF80NzUEXzQ3NgRmMWZjBF80NzgEXzQ3OQRfNDgwBF80ODEEXzQ4MgRfNDgzBF80ODQEXzQ4NQRfNDg2BF80ODcEXzQ4OARfNDg5BF80OTAEXzQ5MQRfNDkyBF80OTMEXzQ5NARmMjEwBF80OTYEZjIxMgRfNDk4BF80OTkEXzUwMARfNTAxBF81MDIEXzUwMwRfNTA0BF81MDUEXzUwNgRfNTA3BF81MDgEXzUwOQV2ZW51cwRfNTExBF81MTIEXzUxMwRfNTE0BF81MTUEXzUxNgRfNTE3BF81MTgEXzUxOQRfNTIwBF81MjEEXzUyMgRfNTIzBF81MjQEXzUyNQRfNTI2BF81MjcEXzUyOARfNTI5BF81MzAEXzUzMQRfNTMyBF81MzMEXzUzNARfNTM1BF81MzYEXzUzNwRfNTM4BF81MzkEXzU0MARfNTQxBF81NDIEXzU0MwRfNTQ0BF81NDUEXzU0NgRfNTQ3BF81NDgEXzU0OQRfNTUwBF81NTEEXzU1MgRfNTUzBF81NTQEXzU1NQRfNTU2BF81NTcEXzU1OARfNTU5BF81NjAEXzU2MQRfNTYyBF81NjMEXzU2NARfNTY1BF81NjYEXzU2NwRfNTY4BF81NjkEZjI2MARmMjYxBF81NzIEZjI2MwRfNTc0BF81NzUEXzU3NgRfNTc3BF81NzgEXzU3OQRfNTgwBF81ODEEXzU4MgRfNTgzBF81ODQEXzU4NQRfNTg2BF81ODcEXzU4OARfNTg5BF81OTAEXzU5MQRfNTkyBF81OTMEXzU5NARfNTk1BF81OTYEXzU5NwRfNTk4BGYyN2UHdW5pRjI4MAd1bmlGMjgxBF82MDIEXzYwMwRfNjA0B3VuaUYyODUHdW5pRjI4NgRfNjA3BF82MDgEXzYwOQRfNjEwBF82MTEEXzYxMgRfNjEzBF82MTQEXzYxNQRfNjE2BF82MTcEXzYxOARfNjE5BF82MjAEXzYyMQRfNjIyBF82MjMEXzYyNARfNjI1BF82MjYEXzYyNwRfNjI4BF82MjkHdW5pRjJBMAd1bmlGMkExB3VuaUYyQTIHdW5pRjJBMwd1bmlGMkE0B3VuaUYyQTUHdW5pRjJBNgd1bmlGMkE3B3VuaUYyQTgHdW5pRjJBOQd1bmlGMkFBB3VuaUYyQUIHdW5pRjJBQwd1bmlGMkFEB3VuaUYyQUUHdW5pRjJCMAd1bmlGMkIxB3VuaUYyQjIHdW5pRjJCMwd1bmlGMkI0B3VuaUYyQjUHdW5pRjJCNgd1bmlGMkI3B3VuaUYyQjgHdW5pRjJCOQd1bmlGMkJBB3VuaUYyQkIHdW5pRjJCQwd1bmlGMkJEB3VuaUYyQkUHdW5pRjJDMAd1bmlGMkMxB3VuaUYyQzIHdW5pRjJDMwd1bmlGMkM0B3VuaUYyQzUHdW5pRjJDNgd1bmlGMkM3B3VuaUYyQzgHdW5pRjJDOQd1bmlGMkNBB3VuaUYyQ0IHdW5pRjJDQwd1bmlGMkNEB3VuaUYyQ0UHdW5pRjJEMAd1bmlGMkQxB3VuaUYyRDIHdW5pRjJEMwd1bmlGMkQ0B3VuaUYyRDUHdW5pRjJENgd1bmlGMkQ3B3VuaUYyRDgHdW5pRjJEOQd1bmlGMkRBB3VuaUYyREIHdW5pRjJEQwd1bmlGMkREB3VuaUYyREUHdW5pRjJFMAd1bmlGMkUxB3VuaUYyRTIHdW5pRjJFMwd1bmlGMkU0B3VuaUYyRTUHdW5pRjJFNgd1bmlGMkU3BF82OTgHdW5pRjJFOQd1bmlGMkVBB3VuaUYyRUIHdW5pRjJFQwd1bmlGMkVEB3VuaUYyRUUAAAAAAAAB//8AAgABAAAADgAAABgAAAAAAAIAAQABAsIAAQAEAAAAAgAAAAAAAQAAAADMPaLPAAAAAMtPPDAAAAAA1DFouQ==);src:url(data:application/vnd.ms-fontobject;base64,bocCAKyGAgABAAIAAAAAAAAAAAAAAAAAAAABAJABAAAAAExQAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAWXjPkAAAAAAAAAAAAAAAAAAAAAAAABYARgBvAG4AdABBAHcAZQBzAG8AbQBlAAAADgBSAGUAZwB1AGwAYQByAAAAJABWAGUAcgBzAGkAbwBuACAANAAuADcALgAwACAAMgAwADEANgAAABYARgBvAG4AdABBAHcAZQBzAG8AbQBlAAAAAAAAAQAAAA0AgAADAFBGRlRNa75HuQAChpAAAAAcR0RFRgLwAAQAAoZwAAAAIE9TLzKIMnpAAAABWAAAAGBjbWFwCr86fwAADKgAAALyZ2FzcP//AAMAAoZoAAAACGdseWaP965NAAAarAACTLxoZWFkEInlLQAAANwAAAA2aGhlYQ8DCrUAAAEUAAAAJGhtdHhFeRiFAAABuAAACvBsb2NhAvWiXAAAD5wAAAsQbWF4cAMsAhwAAAE4AAAAIG5hbWXjl4usAAJnaAAABIZwb3N0r4+boQACa/AAABp1AAEAAAAEAcuQz3hZXw889QALBwAAAAAA1DPNMgAAAADUM80y////AAkBBgAAAAAIAAIAAQAAAAAAAQAABgD/AAAACQD/////CQEAAQAAAAAAAAAAAAAAAAAAArUAAQAAAsMCGQAnAAAAAAACAAAAAQABAAAAQAAAAAAAAAADBmkBkAAFAAAEjAQzAAAAhgSMBDMAAAJzAAABigAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABweXJzAEAAIPUABgD/AAAABgABAAAAAAEAAAAAAAAAAAAAACAAAQOAAHAAAAAAAlUAAAHAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAABdBgAAAAaAAAAHAAAABwAAAAaAAAAGgAAABQAAAAeAAAAGgAAABwAAAAcAAAAHAAB5BYAAbgaAAAAGgAAABgAAAAcAAAAGAAAABYAAAAaAABoGAAAABgAAAAeAADIGgAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABwAAAASAAAAHAABABoAAAAMAAAAEgAAABoAAAAWAAAAHAAAABgAAAAeAAAAGgAAKBQAAAAaAAAAHgAAABoAAAAWAAAAEAAAABwAAAAYAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAeAAAAGAAAABAAAAAYAAAAEAAAABwAAAAaAAAAGgAAABwAAAAQAAAAHAAAABoAAegWAAAAGAAAABgAAAAaAAAAHAAAABAAAAAYCAAEFAACaBQAAWgYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAABABgAAAAaAADUGgAA1BwAAAAYAAAAGAAANBYAAAAWAAAAGgAB6BgAAAAYAAAAHAAAABYAAAAcAAAAHAAAABwAAEAWAAAAGgAAABwAAAAcAAAAGAAAABwAAWgcAAFoHgAAABoAAAAaAAAAHgAAAAwAAQAcAAAAIAAAABgAAAAYAAAAHAAAABwAAAAeAAAAHAAAABgAAAAYAAAADgAAABwAAAAaAAAAGAAAABIAAAAcAAAAGAAAABoAAAAYAAAAGgAAABgAAAAWAAAAFgAAABQAAAAYAAAAGgAAsBAAAXwYAAAAGgAAAB4AAAAWAAAAGAAAABwAAAAcAAEAGAAACBwAAAAcAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABoAAFQcAAAAFgAAFBwAAAAYAAAAHgAAABoAAEAeAAAAGgABzBwAAAQcAAAAFgAAEBgAAAAYAAAAGAAAABwAAAAcAAA8HAAAABgAAAAaAAAAGgAAbBwAAQAYAAAAGAAAABgAAAAkAAAAHgAAABAAAAAQAAAACgABAAoAAAAaAAAAEAAAABAAAAAQAAAAHAAAABgAAAAYAAAAHAAAoBwAAAAcAAAAHAAAAA4AAAQcAAAAGgAAABwAAAAQAAAAHAAAAB4AAAAeAAAAFgAAABYAAAAcAAAAHAABAB4AAAAWAAAAGAAAABYAAAAWAAAAHgABABwAAAAeAAAAGgABABgAAAAYAAAAEAAAtBAAADQSAAE0EgABNAoAALQKAAA0EgABNBIAATQeAAAAHgAAABIAAAAMAAAAGAAAABoAAAAaAAAAHAABABgAAAAcAAAAGgAAABoAAAAeAAAAHAAAABwAAAAYAAAAGAAAABgAAAAeAAAAHgAAABwAAQAcAAEAGgAANB4AALQcAAAAGgAACBYAAAgaAAAAEAAAABoAAAAQAAGACgAAAAoAAYgYAAAUGAAAFB4AAAQaAAAAEgAAABYAADQUAAAAGgAAABYAAAwaAACQHAAAABgAAAAYAAAAGAAAABgAAAAWAAAAHAAAMBwAAAASAAAAGAAAABYAAAAGAAAAGAAAABgAAAAcAADYGAAAABYAAAAQAAAMEAAADBgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAEAAAABAAAAAQAADQDggAABAMABAUAAAAHAAAABQAAOAYAAAAGAAAABoAAIgaAACIHAAAiBwAAIgYAACIGAAAiBoAAAAaAAAAGAAAABgAAGwWAAAUGAAAABwAAAAcAAEAGAAALBgAAAAYAAAAGAAAABYAAAAYAAAAEAABEBgAAAAMAAAMDAAADBwAAQAcAAAAFgAAABoAAAAWAAAAGAAALBgAAAAYAAAAFAAAsBgAAAAUAAAAEAAAABgAAAAcAACwGAAAABwAAQAaAACAHgP//BwAAAAYAAAAFgAAABQAAFQYAAAAGAAAABgAAAAYAAAAGgAAABgAAAASAAAAFgAAACIAAAAaAAAAGAAAABwAAAAcAAAAIAAAACQAAAAYAAG0GAAAABwAAAAYAAAAGAAAAB4AAAAYAAAAIAAAABgAAAAf2ACkGAAAABgAAAAYAAAAHAAAABgAAAAUAAEAGgAAAAwAAQAcAAAAJAAAACAAAAAYAAAAHAAAABgAAAAcAABAIAAAACAAAAAYAACAGAAAABAAAAAkAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAJwcAAAAIAAAABwAAAAcAACAHAAATBwAAAAYAAAAHAABEBgAAAAUAADkHAAASCAAAAAcAAAAHAAAABgAAAAYAAAAHAAA+BQAAGAYAAAAGAAAABgAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAGQcAAGQGAABZCAAAAAgAACoHAAAABgAACQcAACcJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAIAAAOCAAADgWAAAAGAAAABgAAAAcAAAAHAAAABwAAAAgAAAAHAAAACAAAAAcAAAAGAAAACAAAAAgAAAAJAAAABgAAAAgAAAAFAAALCAAAAAYAAAAGAAAABgAAAAgAAAAGAAAABgAAAAgAAAAIAAAABgAAAAgAAAAIAAAABoAAAAaAAAAIAAAACAAAEwYAAAAJAAAABgAAAAcAAAAFAAACBgAAAAUAAAAGAAACBwAAAAcA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AaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwG4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gHfAeAB4QHiAeMB5AHlAeYB5wHoAekB6gHrAewB7QHuAe8B8AHxAfIB8wH0AfUB9gH3AfgB+QH6AfsB/AH9Af4B/wIAAgECAgIDAgQCBQIGAgcCCAAiAgkCCgILAgwCDQIOAg8CEAIRAhICEwIUAhUCFgIXAhgCGQIaAhsCHAIdAh4CHwIgAiECIgIjAiQCJQImAicCKAIpAioCKwIsAi0CLgIvAjACMQIyAjMCNAI1AjYCNwI4AjkCOgI7AjwCPQI+Aj8CQAJBAkICQwJEAkUCRgJHAkgCSQJKAksCTAJNAk4CTwJQAlECUgJTANICVAJVAlYCVwJYAlkCWgJbAlwCXQJeAl8CYAJhAmICYwJkAmUCZgJnAmgCaQJqAmsCbAJtAm4CbwJwAnECcgJzAnQCdQJ2AncCeAJ5AnoCewJ8An0CfgJ/AoACgQKCAoMChAKFAoYChwKIAokCigKLAowCjQKOAo8CkAKRApICkwKUApUClgKXApgCmQKaApsCnAKdAp4CnwKgAqECogKjAqQCpQKmAqcCqAKpAqoCqwKsAq0CrgKvArACsQKyArMCtAK1ArYCtwK4ArkCugK7ArwCvQK+Ar8CwALBAsICwwLEAsUCxgLHAsgCyQLKAssCzALNAs4CzwLQAtEC0gLTAtQC1QLWAtcC2ALZAtoC2wLcAt0C3gLfAuAC4QLiAuMC5ALlAuYC5wLoAukC6gLrAuwC7QLuAu8C8ALxAvIC8wL0AvUC9gL3AvgC+QL6AvsC/AL9Av4C/wMAAwEDAgMDAwQDBQMGAwcDCAMJAwoDCwMMAw0DDgMPAxADEQMSAxMDFAMVAxYDFwMYAxkDGgMbAxwDHQMeAx8DIAMhAyIDIwMkAyUDJgMnAygDKQMqAysDLAMtAy4DLwMwAzEDMgMzAzQDNQM2AzcDOAM5AzoDOwM8Az0DPgM/A0ADQQNCA0MDRANFA0YDRwNIA0kDSgNLA0wDTQNOA08DUANRA1IDUwNUA1UDVgNXA1gDWQNaA1sDXANdA14DXwNgA2EDYgNjA2QDZQNmA2cDaANpA2oDawNsA20DbgNvA3ADcQNyA3MDdAN1A3YDdwN4A3kDegN7A3wDfQN+A38DgAOBA4IDgwOEA4UDhgOHA4gDiQOKA4sDjAONA44DjwOQA5EDkgOTA5QDlQOWA5cDmAOZA5oDmwOcA50DngOfA6ADoQOiA6MDpAOlA6YDpwOoA6kDqgOrA6wDrQOuA68DsAOxAJQFZ2xhc3MFbXVzaWMGc2VhcmNoCGVudmVsb3BlBWhlYXJ0BHN0YXIKc3Rhcl9lbXB0eQR1c2VyBGZpbG0IdGhfbGFyZ2UCdGgHdGhfbGlzdAJvawZyZW1vdmUHem9vbV9pbgh6b29tX291dANvZmYGc2lnbmFsA2NvZwV0cmFzaARob21lCGZpbGVfYWx0BHRpbWUEcm9hZAxkb3dubG9hZF9hbHQIZG93bmxvYWQGdXBsb2FkBWluYm94C3BsYXlfY2lyY2xlBnJlcGVhdAdyZWZyZXNoCGxpc3RfYWx0BGxvY2sEZmxhZwpoZWFkcGhvbmVzCnZvbHVtZV9vZmYLdm9sdW1lX2Rvd24Jdm9sdW1lX3VwBnFyY29kZQdiYXJjb2RlA3RhZwR0YWdzBGJvb2sIYm9va21hcmsFcHJpbnQGY2FtZXJhBGZvbnQEYm9sZAZpdGFsaWMLdGV4dF9oZWlnaHQKdGV4dF93aWR0aAphbGlnbl9sZWZ0DGFsaWduX2NlbnRlcgthbGlnbl9yaWdodA1hbGlnbl9qdXN0aWZ5BGxpc3QLaW5kZW50X2xlZnQMaW5kZW50X3JpZ2h0DmZhY2V0aW1lX3ZpZGVvB3BpY3R1cmUGcGVuY2lsCm1hcF9tYXJrZXIGYWRqdXN0BHRpbnQEZWRpdAVzaGFyZQVjaGVjawRtb3ZlDXN0ZXBfYmFja3dhcmQNZmFzdF9iYWNrd2FyZAhiYWNrd2FyZARwbGF5BXBhdXNlBHN0b3AHZm9yd2FyZAxmYXN0X2ZvcndhcmQMc3RlcF9mb3J3YXJkBWVqZWN0DGNoZXZyb25fbGVmdA1jaGV2cm9uX3JpZ2h0CXBsdXNfc2lnbgptaW51c19zaWduC3JlbW92ZV9zaWduB29rX3NpZ24NcXVlc3Rpb25fc2lnbglpbmZvX3NpZ24Kc2NyZWVuc2hvdA1yZW1vdmVfY2lyY2xlCW9rX2NpcmNsZQpiYW5fY2lyY2xlCmFycm93X2xlZnQLYXJyb3dfcmlnaHQIYXJyb3dfdXAKYXJyb3dfZG93bglzaGFyZV9hbHQLcmVzaXplX2Z1bGwMcmVzaXplX3NtYWxsEGV4Y2xhbWF0aW9uX3NpZ24EZ2lmdARsZWFmBGZpcmUIZXllX29wZW4JZXllX2Nsb3NlDHdhcm5pbmdfc2lnbgVwbGFuZQhjYWxlbmRhcgZyYW5kb20HY29tbWVudAZtYWduZXQKY2hldnJvbl91cAxjaGV2cm9uX2Rvd24HcmV0d2VldA1zaG9wcGluZ19jYXJ0DGZvbGRlcl9jbG9zZQtmb2xkZXJfb3Blbg9yZXNpemVfdmVydGljYWwRcmVzaXplX2hvcml6b250YWwJYmFyX2NoYXJ0DHR3aXR0ZXJfc2lnbg1mYWNlYm9va19zaWduDGNhbWVyYV9yZXRybwNrZXkEY29ncwhjb21tZW50cw10aHVtYnNfdXBfYWx0D3RodW1ic19kb3duX2FsdAlzdGFyX2hhbGYLaGVhcnRfZW1wdHkHc2lnbm91dA1saW5rZWRpbl9zaWduB3B1c2hwaW4NZXh0ZXJuYWxfbGluawZzaWduaW4GdHJvcGh5C2dpdGh1Yl9zaWduCnVwbG9hZF9hbHQFbGVtb24FcGhvbmULY2hlY2tfZW1wdHkOYm9va21hcmtfZW1wdHkKcGhvbmVfc2lnbgd0d2l0dGVyCGZhY2Vib29rBmdpdGh1YgZ1bmxvY2sLY3JlZGl0X2NhcmQDcnNzA2hkZAhidWxsaG9ybgRiZWxsC2NlcnRpZmljYXRlCmhhbmRfcmlnaHQJaGFuZF9sZWZ0B2hhbmRfdXAJaGFuZF9kb3duEWNpcmNsZV9hcnJvd19sZWZ0EmNpcmNsZV9hcnJvd19yaWdodA9jaXJjbGVfYXJyb3dfdXARY2lyY2xlX2Fycm93X2Rvd24FZ2xvYmUGd3JlbmNoBXRhc2tzBmZpbHRlcglicmllZmNhc2UKZnVsbHNjcmVlbgVncm91cARsaW5rBWNsb3VkBmJlYWtlcgNjdXQEY29weQpwYXBlcl9jbGlwBHNhdmUKc2lnbl9ibGFuawdyZW9yZGVyAnVsAm9sDXN0cmlrZXRocm91Z2gJdW5kZXJsaW5lBXRhYmxlBW1hZ2ljBXRydWNrCXBpbnRlcmVzdA5waW50ZXJlc3Rfc2lnbhBnb29nbGVfcGx1c19zaWduC2dvb2dsZV9wbHVzBW1vbmV5CmNhcmV0X2Rvd24IY2FyZXRfdXAKY2FyZXRfbGVmdAtjYXJldF9yaWdodAdjb2x1bW5zBHNvcnQJc29ydF9kb3duB3NvcnRfdXAMZW52ZWxvcGVfYWx0CGxpbmtlZGluBHVuZG8FbGVnYWwJZGFzaGJvYXJkC2NvbW1lbnRfYWx0DGNvbW1lbnRzX2FsdARib2x0B3NpdGVtYXAIdW1icmVsbGEFcGFzdGUKbGlnaHRfYnVsYghleGNoYW5nZQ5jbG91ZF9kb3dubG9hZAxjbG91ZF91cGxvYWQHdXNlcl9tZAtzdGV0aG9zY29wZQhzdWl0Y2FzZQhiZWxsX2FsdAZjb2ZmZWUEZm9vZA1maWxlX3RleHRfYWx0CGJ1aWxkaW5nCGhvc3BpdGFsCWFtYnVsYW5jZQZtZWRraXQLZmlnaHRlcl9qZXQEYmVlcgZoX3NpZ24EZjBmZRFkb3VibGVfYW5nbGVfbGVmdBJkb3VibGVfYW5nbGVfcmlnaHQPZG91YmxlX2FuZ2xlX3VwEWRvdWJsZV9hbmdsZV9kb3duCmFuZ2xlX2xlZnQLYW5nbGVfcmlnaHQIYW5nbGVfdXAKYW5nbGVfZG93bgdkZXNrdG9wBmxhcHRvcAZ0YWJsZXQMbW9iaWxlX3Bob25lDGNpcmNsZV9ibGFuawpxdW90ZV9sZWZ0C3F1b3RlX3JpZ2h0B3NwaW5uZXIGY2lyY2xlBXJlcGx5CmdpdGh1Yl9hbHQQZm9sZGVyX2Nsb3NlX2FsdA9mb2xkZXJfb3Blbl9hbHQKZXhwYW5kX2FsdAxjb2xsYXBzZV9hbHQFc21pbGUFZnJvd24DbWVoB2dhbWVwYWQIa2V5Ym9hcmQIZmxhZ19hbHQOZmxhZ19jaGVja2VyZWQIdGVybWluYWwEY29kZQlyZXBseV9hbGwPc3Rhcl9oYWxmX2VtcHR5DmxvY2F0aW9uX2Fycm93BGNyb3AJY29kZV9mb3JrBnVubGluawRfMjc5C2V4Y2xhbWF0aW9uC3N1cGVyc2NyaXB0CXN1YnNjcmlwdARfMjgzDHB1enpsZV9waWVjZQptaWNyb3Bob25lDm1pY3JvcGhvbmVfb2ZmBnNoaWVsZA5jYWxlbmRhcl9lbXB0eRFmaXJlX2V4dGluZ3Vpc2hlcgZyb2NrZXQGbWF4Y2RuEWNoZXZyb25fc2lnbl9sZWZ0EmNoZXZyb25fc2lnbl9yaWdodA9jaGV2cm9uX3NpZ25fdXARY2hldnJvbl9zaWduX2Rvd24FaHRtbDUEY3NzMwZhbmNob3IKdW5sb2NrX2FsdAhidWxsc2V5ZRNlbGxpcHNpc19ob3Jpem9udGFsEWVsbGlwc2lzX3ZlcnRpY2FsBF8zMDMJcGxheV9zaWduBnRpY2tldA5taW51c19zaWduX2FsdAtjaGVja19taW51cwhsZXZlbF91cApsZXZlbF9kb3duCmNoZWNrX3NpZ24JZWRpdF9zaWduBF8zMTIKc2hhcmVfc2lnbgdjb21wYXNzCGNvbGxhcHNlDGNvbGxhcHNlX3RvcARfMzE3A2V1cgNnYnADdXNkA2lucgNqcHkDcnViA2tydwNidGMEZmlsZQlmaWxlX3RleHQQc29ydF9ieV9hbHBoYWJldARfMzI5EnNvcnRfYnlfYXR0cmlidXRlcxZzb3J0X2J5X2F0dHJpYnV0ZXNfYWx0DXNvcnRfYnlfb3JkZXIRc29ydF9ieV9vcmRlcl9hbHQEXzMzNARfMzM1DHlvdXR1YmVfc2lnbgd5b3V0dWJlBHhpbmcJeGluZ19zaWduDHlvdXR1YmVfcGxheQdkcm9wYm94DXN0YWNrZXhjaGFuZ2UJaW5zdGFncmFtBmZsaWNrcgNhZG4EZjE3MQ5iaXRidWNrZXRfc2lnbgZ0dW1ibHILdHVtYmxyX3NpZ24PbG9uZ19hcnJvd19kb3duDWxvbmdfYXJyb3dfdXAPbG9uZ19hcnJvd19sZWZ0EGxvbmdfYXJyb3dfcmlnaHQHd2luZG93cwdhbmRyb2lkBWxpbnV4B2RyaWJibGUFc2t5cGUKZm91cnNxdWFyZQZ0cmVsbG8GZmVtYWxlBG1hbGUGZ2l0dGlwA3N1bgRfMzY2B2FyY2hpdmUDYnVnAnZrBXdlaWJvBnJlbnJlbgRfMzcyDnN0YWNrX2V4Y2hhbmdlBF8zNzQVYXJyb3dfY2lyY2xlX2FsdF9sZWZ0BF8zNzYOZG90X2NpcmNsZV9hbHQEXzM3OAx2aW1lb19zcXVhcmUEXzM4MA1wbHVzX3NxdWFyZV9vBF8zODIEXzM4MwRfMzg0BF8zODUEXzM4NgRfMzg3BF8zODgEXzM4OQd1bmlGMUEwBGYxYTEEXzM5MgRfMzkzBGYxYTQEXzM5NQRfMzk2BF8zOTcEXzM5OARfMzk5BF80MDAEZjFhYgRfNDAyBF80MDMEXzQwNAd1bmlGMUIxBF80MDYEXzQwNwRfNDA4BF80MDkEXzQxMARfNDExBF80MTIEXzQxMwRfNDE0BF80MTUEXzQxNgRfNDE3BF80MTgEXzQxOQd1bmlGMUMwB3VuaUYxQzEEXzQyMgRfNDIzBF80MjQEXzQyNQRfNDI2BF80MjcEXzQyOARfNDI5BF80MzAEXzQzMQRfNDMyBF80MzMEXzQzNAd1bmlGMUQwB3VuaUYxRDEHdW5pRjFEMgRfNDM4BF80MzkHdW5pRjFENQd1bmlGMUQ2B3VuaUYxRDcEXzQ0MwRfNDQ0BF80NDUEXzQ0NgRfNDQ3BF80NDgEXzQ0OQd1bmlGMUUwBF80NTEEXzQ1MgRfNDUzBF80NTQEXzQ1NQRfNDU2BF80NTcEXzQ1OARfNDU5BF80NjAEXzQ2MQRfNDYyBF80NjMEXzQ2NAd1bmlGMUYwBF80NjYEXzQ2NwRmMWYzBF80NjkEXzQ3MARfNDcxBF80NzIEXzQ3MwRfNDc0BF80NzUEXzQ3NgRmMWZjBF80NzgEXzQ3OQRfNDgwBF80ODEEXzQ4MgRfNDgzBF80ODQEXzQ4NQRfNDg2BF80ODcEXzQ4OARfNDg5BF80OTAEXzQ5MQRfNDkyBF80OTMEXzQ5NARmMjEwBF80OTYEZjIxMgRfNDk4BF80OTkEXzUwMARfNTAxBF81MDIEXzUwMwRfNTA0BF81MDUEXzUwNgRfNTA3BF81MDgEXzUwOQV2ZW51cwRfNTExBF81MTIEXzUxMwRfNTE0BF81MTUEXzUxNgRfNTE3BF81MTgEXzUxOQRfNTIwBF81MjEEXzUyMgRfNTIzBF81MjQEXzUyNQRfNTI2BF81MjcEXzUyOARfNTI5BF81MzAEXzUzMQRfNTMyBF81MzMEXzUzNARfNTM1BF81MzYEXzUzNwRfNTM4BF81MzkEXzU0MARfNTQxBF81NDIEXzU0MwRfNTQ0BF81NDUEXzU0NgRfNTQ3BF81NDgEXzU0OQRfNTUwBF81NTEEXzU1MgRfNTUzBF81NTQEXzU1NQRfNTU2BF81NTcEXzU1OARfNTU5BF81NjAEXzU2MQRfNTYyBF81NjMEXzU2NARfNTY1BF81NjYEXzU2NwRfNTY4BF81NjkEZjI2MARmMjYxBF81NzIEZjI2MwRfNTc0BF81NzUEXzU3NgRfNTc3BF81NzgEXzU3OQRfNTgwBF81ODEEXzU4MgRfNTgzBF81ODQEXzU4NQRfNTg2BF81ODcEXzU4OARfNTg5BF81OTAEXzU5MQRfNTkyBF81OTMEXzU5NARfNTk1BF81OTYEXzU5NwRfNTk4BGYyN2UHdW5pRjI4MAd1bmlGMjgxBF82MDIEXzYwMwRfNjA0B3VuaUYyODUHdW5pRjI4NgRfNjA3BF82MDgEXzYwOQRfNjEwBF82MTEEXzYxMgRfNjEzBF82MTQEXzYxNQRfNjE2BF82MTcEXzYxOARfNjE5BF82MjAEXzYyMQRfNjIyBF82MjMEXzYyNARfNjI1BF82MjYEXzYyNwRfNjI4BF82MjkHdW5pRjJBMAd1bmlGMkExB3VuaUYyQTIHdW5pRjJBMwd1bmlGMkE0B3VuaUYyQTUHdW5pRjJBNgd1bmlGMkE3B3VuaUYyQTgHdW5pRjJBOQd1bmlGMkFBB3VuaUYyQUIHdW5pRjJBQwd1bmlGMkFEB3VuaUYyQUUHdW5pRjJCMAd1bmlGMkIxB3VuaUYyQjIHdW5pRjJCMwd1bmlGMkI0B3VuaUYyQjUHdW5pRjJCNgd1bmlGMkI3B3VuaUYyQjgHdW5pRjJCOQd1bmlGMkJBB3VuaUYyQkIHdW5pRjJCQwd1bmlGMkJEB3VuaUYyQkUHdW5pRjJDMAd1bmlGMkMxB3VuaUYyQzIHdW5pRjJDMwd1bmlGMkM0B3VuaUYyQzUHdW5pRjJDNgd1bmlGMkM3B3VuaUYyQzgHdW5pRjJDOQd1bmlGMkNBB3VuaUYyQ0IHdW5pRjJDQwd1bmlGMkNEB3VuaUYyQ0UHdW5pRjJEMAd1bmlGMkQxB3VuaUYyRDIHdW5pRjJEMwd1bmlGMkQ0B3VuaUYyRDUHdW5pRjJENgd1bmlGMkQ3B3VuaUYyRDgHdW5pRjJEOQd1bmlGMkRBB3VuaUYyREIHdW5pRjJEQwd1bmlGMkREB3VuaUYyREUHdW5pRjJFMAd1bmlGMkUxB3VuaUYyRTIHdW5pRjJFMwd1bmlGMkU0B3VuaUYyRTUHdW5pRjJFNgd1bmlGMkU3BF82OTgHdW5pRjJFOQd1bmlGMkVBB3VuaUYyRUIHdW5pRjJFQwd1bmlGMkVEB3VuaUYyRUUAAAAAAAAB//8AAgABAAAADgAAABgAAAAAAAIAAQABAsIAAQAEAAAAAgAAAAAAAQAAAADMPaLPAAAAAMtPPDAAAAAA1DFouQ==)format("embedded-opentype"),url(data:font/woff2;base64,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)format("woff2"),url(data:font/woff;base64,d09GRgABAAAAAX7oAA0AAAAChqwABAAHAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAABMAAAABwAAAAca75HuUdERUYAAAFMAAAAHwAAACAC8AAET1MvMgAAAWwAAAA+AAAAYIgyekBjbWFwAAABrAAAAWkAAALyCr86f2dhc3AAAAMYAAAACAAAAAj//wADZ2x5ZgAAAyAAAV95AAJMvI/3rk1oZWFkAAFinAAAADMAAAA2EInlLWhoZWEAAWLQAAAAHwAAACQPAwq1aG10eAABYvAAAAL0AAAK8EV5GIVsb2NhAAFl5AAABxYAAAsQAvWiXG1heHAAAWz8AAAAHwAAACADLAIcbmFtZQABbRwAAAJEAAAEhuOXi6xwb3N0AAFvYAAAD4UAABp1r4+boQAAAAEAAAAAzD2izwAAAADLTzwwAAAAANQxaLl4nGNgZGBg4ANiCQYQYGJgZGBkOgQkWcA8BgAMuAD3AHicY2Bmy2ScwMDKwMDSw2LMwMDQBqGZihkYGLsY8ICCyqJiBgcGha8MbAz/gXw2BkaQMCOSEgUGRgDQywhuAAB4nM2S30ricRDF52dqZeb5PsAi6gNEvYDIPoAIe9NFiE8gPoH4BOITiJcbLCLRdche7KUIW1tb+cPdavtvc6b11l+/Teii6yU6MGc4MMwHhhGRBZnXB/FCF+8uTN5zjnrDsNekIDFZl4xsS1d25ZscZXO5dK6iKU1rXota1qrWtalt7eqODtTXic6YYpprzLPIMquss8k2u9zjgD4nnFnK0pa3opWtanVrWtu6tmcD820ylSAIyRn5/Ioo6jSrBS1pRWva0JZ2tKd9HepYlULHDNdZYIkV1thgix322OeQY6qJOctawUpWsZo1rGUd61nfhjb+RwzOgq1gM/gUfAw2/KvR/eiLW3VJl3DLbskturiLuahbcBFM8RePMBCKB0xwjzvc4gbXuMIl/uAC5zjDb/zCGD5GOMUJjvETRzjEDxxgH99Xv86v/bby4vKC9SKhRV4PzF/hPSgeSyxGk0vLK/957xNi+cPzAAAAAAAAAf//AAJ4nLy9CYBU1ZUw/O69b6l9e7V1dXV3VVfVq+pu6G5qbXotmp1udgQExBZFkUVBQRAXSiEqiBso4t5oRMkyYxbzJUacyqaTRWISYja/+dokJpm4jJPkNxG6Ht+591VVVzcN6Mz8H3S9d/f13HvPOfec8zjMbeY4YhPhwUkclwnag8QetA+hvJrdjAc3C4FTm0XuFEf/Ie6SM5z4jJDjasDjlJA9GHc7xVCwXkmmE0E7UlLJbpQIxmuR+ExT4S6U9SmKbzhHnyhbuKspHPMIOU8sLMwIQXSBU5IK/BEO72gKeap1umpaBwd1cFBHE3jsTguub8bJbpyIe+zCaG8ynUHpRNwtctPWXbXiqnXT4DXx6mWF0V6llmRNtlibEDg9GJ/X5HI1zbsCXlFc9X6hozKAvFaXMCCOb+Mwa0MO2iBxQei3jQvQH4Ku1kcRPMIKtjnS4QDvdrhgGNx8Tv1YvVf9GEnoOiL1J9Nh9dhX3rpPPX382muPIwHVIuH4tTejZREMCZCkJVZzyX4FLb15JMW1x9XT9731FfVYhM4GdyYncQLH+bgubi7HReyixEsW3AQjgKJKRInanW4Y67S9EzcTmAPR5fS4PbV8B453k0w6040ydm1yUnY6PTBQuUBE/duTieymVoRaN2UTT6p/iwRks5A3y0gQTbpTWbN88FtviO31mWYnQs7mTH27+Ma30pfkVveeyvauXt0r5HtXBwgXrj2xp6l10qTWpj0nasMFzizLfAw79HadQZDNz289/KwwyRdxOCK+ScKzh5seGDidp7l5WoY2x7RvOc7PcTwMaTOfghbGa7Gnm8CE0jEljyYdhfsNof7OFnWo+7ZrF4TDC669rXtIfafwQM6BV+jCl15x79S3/tE0OxsOZ2c3/eOt//1O4Xmt7C/C3A1x9RqMylAcnbeIAE8A0IxMwTQTkdNxjyzAmPjUh5Yil1N2qT1qD0yoCy9VH6xqQx+9LXfKb6OP2siNbp/6pGqSzK4a03vvmWpcogX9Da2pdkX0s9FrDQ3q5Nl6uj5wuW49hV49ihhhaklEKLXj3M3gt6C4uuL4cXUFis9GO9GN6DXWroZzNws7UUM3ulW9vVv9hbrytdeIodTM+HlaSduYE+jYu+gqjhQhJAkD7w5k4rWEs4kBxZYOCNwty4c/t/wWe/PMbf270cbd/dtmNtvPcG+r3377bdS9d9Pjj2+66OFHNk3P5aZveuRh8i0t/G0YByNdPxJdP1aujmvherj53KXctdwu7j7uKe6fOU5IJZUmVC/WIKe7AwEIX8CP7EmFQXgR5NHY+E+Z/kL1jV04KKf42C52jgfPKb4CRz0EnsPcSIxQkVPNVaa6UJmw5D5mi0aERZMtR6FHx3MWfJgVrNInPxJ+esRJKpOo45ZS4XzpFKtbYAuWp8AtVs4n3ZlHjVAVGjNiF4gnXH9S5ZL9/UnMniNukjtXDOboltmfRPSJf1ThGf7RuWI4tjDZXnM2LHLIpbWqC2mtso/xj43/n/aPrQ9zbTE1H2tri6EsfY64ca7SV8idO+6Tp6x0owBz0gf6ZdlZGHGScUMvmKCiMAChcefif3wWPvmoChAzzMIIhJ3mzh1X6f4vjtWooYBz6kbOIt7Jf5lzgw/OB0msb0FISfYgOBH08KhD4p3+woS7/Av8d6mH/H7qQAq+n/rJXxawKP9daD31+/3qr/AD4IVyrznzgeDgD3Ahjgs7rUisj+oRLVtJZvSjy3c7JT0SHKxk9dfqr7WSkAKuYm1IKZb+awg9b6y/XIqGu2j7RQjOwWnaDDdpDzotIW1uOmBbhkfcXYPg7EdFLIs7F5bFc7J5SDYDijIE6MaIcxTu1Zc6F+6Fh87KSZ1/qEDIXlzfdw6ErLJPVs7DtZ4FtZ+s/YU8rRVnP12rWXs/cUuLZ7xIl1sDl6JYEBb5ALQmlXRk0m6PW5Qs0PpawBMhSIk2I8AVPW4H3bO1HZri1DtPqL9X/1X9/YmdRw40XV0XsDau2bBw3/E3ju9buGFNozVQt77xwJFCrn9dP/zh3OM05c4TyP/411DvpoClqfHqwJw3b1wHySHXuhvfnBO4urHJEtikvoLnFNgGjdkGDf+EMj44si9wkTK4aEASsWt+2r7x/OhCfs5hyVsc7IFyn849UHI4rlOZE2Xh+ZcCc2PqRtcN05eF0CD0l1PMI1DPyHwweuIa8CeVetHpjlMIgvUpwYw4YUZCsEZFCf7TVsNyjUoUkJQoRRMBl4egZkQHAxZwphSagFWcBlyf9RAWtCcDaDRQARSFtiAJgmoB7g6dPHToJD5kM31DdoZmGfTV97tNln0TWmxmqebfLC7kn9Rwj8FqMd4alXTWWY5qy/8y22zGlyxVsakGve8Bt9k8OvG9eqvZdFuYJfZZITF20xoOoU3/ZnJjfzoSX27yGSL36jd6rHfF/Xbz122uDXrjdWmD2WR0rayKT6rGLjNL29w8eaHJZDCH7zNsqExs2J7QWbTErX7sYmcH4K0jOEgHN5W7SsNDKmdZuIBfBtrWWUtp1G6EgjC6QVESGKSVEZZQaU1nGC0LY8jOEIeFzSk80DncueGcxUpIllgthQGUb5UM6ncMErnWYRlY3TsM+NQAA53UDOs8esLMs85AKYuDBCrAyHIOd6GWfHW4H2DeHuHnbNNjrH8Igof7F9+4bTH5Oqv9uUgyGXnOoa1/HwzYlQLhZLb+Wdeg40X8K6VH7gwAWoidDFEKa5SSBlAq7scuuwc2FcBP1dwZwLkAV8U9uAf9n26dmZh1hf5Cv8lk1nXrsAH/OLA88De2NH5jwDigBihiSxFdNIR4hH6tKnjKHD2W8JTCv+gQ1s8xVOvwMp/vR9+hfVPXfY3S/NreSqdYhpbDuQVQ6xqDQHoke1CJwpmj9SJoF172x9pip9iZSnKxAf8etMNgUl8zocvVAUB8OH6PfyB2OkfjRTi7Y/5p6l01JjTZdMrBw9mOBhlTg5TXphP27gkjmK227xTBhrM1o4AF2WpRIM3ZMOymsLXDzk5gk9B2hCENHAYPnFJ/eerAgVModgpdd0J9Sl2tPnXiBLoMPY0uI0NqGW4oLBRUSHWgmANfWpn0xAk2j3HAl+bB9mgHaOdQijQjSqZIxCVqdI4zBNRNFIIptSMREaidetgYEIXcerq5sGR05wjRMURufpkXOc0vmZ3Iixymv5kc+KPmQtbsQE4IVj+EcCdymAvZZh86ogs70WIIsULIUUhihSRosTOsQ0d82M8jdjKped5kswFtKZsRZQOYz8Bzdrqbd8p+2aztm2Zwnn6vu0RHiBQJtHIRrgswlOJeWHrLo6bd44730NWH3BLFY5CSoWwmDSBc9mBc0DhISGGvowAODElDP7mz/fH2u9AbsTb1m/Y6NetIO9Rsnd3eiIA0Q5T44hqPJrVc9A8FRvC+u9rgD9sbatSsLKN8TUMU5RndlK2AFS8XZjiAs9yuMqi47AnYLorA0o1sCl8BL/yAQf2W0WtU81adzp1nCwf+flSGmQMHzoIaPGAyqd/S61HWJjsZ3FjUQQeOV0Da8bNAZ5y2anucthlqLAiKCaJzt3V1RQsNqAeajbLWn563qQ861UG2yQ04LCYT6tHr1bwNfXyepmIGExQFMLOVH2xGURIkcHgFPcHICDRkZG039shucgZ1IoJOFjpPwgt1XoqyeEDxnYKNquoDQ8pHsr6U4YMqnCVGjD5UbfDKP63WMi7kb7u7cKyqvr6q8MuuijGyctVcVMPD2aFLK0zD2Jxj2fODgcKQ1W6zBQLBOhw476LHz85xqHm9To7gXER2yGr+h+db9ajcpkR5L4oqPUgJ1Vsw4GyJOD3v4/Rgl0S+jGQm4jyc/YDacRRSG+32un0Pfr+EfG0/OVuyWQ179Ui3Sf3BF0ZQtYNI3nA7QLjAqVmfEovW7ttbRPHWXWrA+n26KsOeB2hK1Ib8J3Zeu/Y2WESV+EyYm8lWAeaC9WFAWEb2a6A84JiNl5GT0sJOsq6U8Zwu5OCCrO1wVv8RZdV16gcH1P/YcJucpNMFK0/eO/Orl93xpxnGRgBHs1xF+weh0L1i4GtmeQp6FMkHkHPD7ZANDQlY/Zv6lWuuvE3WilCS8t7eWbdfZ7/CIxOZZoeQfXu1ALOETGgudE1WKCjqzskv4NAYjDR1Af9YujR1Ab88hmsln8WF0giBcz14iB9mHsLIjPHdkOgU81Cu7yi+LhooF/fXcVyF8QIrohOEuYdpffzcSoYvW+O8xk+vo2s8RXd7VyWPiNKCcP5SStANy5mirCRbIroDSIc2I10g1ka4/PpDh9arQwW2X2OIzn8d6dR/fD3fRuEyW6Qj7FyGwWV5w4PtLq1hgxSrbsaheo0PS9c5xZkBZU7E6bUC1J5lHcr2re8T8lXVv3i065ZVd8/Oqx/abT6lztX+3jc2vHSrEk/vumSx2acI3CzltIV2nP+LMivV17etIFRVW7ZOSE44oFd8+A8Bj6VmR3uH3JhsVBjdX+Kl9dEWWjEg/q7ROGoN/GBBpJIYthrsctbR47yMmpVgDGgEDL0qEphirtP5Dffe5SPY6Mwb6qfVvKD+Qv2y+osXaqbV3zBzJG75Xvc3nJ13DKEk6kfJoTvwvqMPTgou3hAYQT4DMztNl655EImPP66eenDNpabOmYERpDSwYXFw0oNHH0be13fufF39k9avAOH4IcDh2L4Fx2IZduGgcRM4q2X1K+optg+LaC4sVX7wNF3haC6EUDRzrrYGKbwE+Bwra+L4pXHaRDLGdbKZsOsDz7h1oNxFMwxWn+Ktr/fSn+KzGmaMU7HqOLzbL0SqXTWuqpbelip4V0eEaga6sN99A+ZsJmvPbG7Dp2kTHKnFUHYnA/Q2I97GxgGFB4DosOEoJcjLKT5xj9BFn9tvNlUr0TbnnMWL5zjboorPbN6PPqf+zAxgGpXqpObwTfv23RRuBieL/NknH4WMekItdAiKL+qssaaf+fozaWuNMwrQ3/E1NanuWgkxYQ9v5qt8K5ENxZFtpa8KvJ4wJFnJmRiRT2Ge3jEaYWeVOQ+cuHVw4rfAOUfXqiuUkuEXhB9itIo9SN+A7ttRMRxot1TIHrIHXYkU0pLYUQ7+kRyQXpTsoD/C0ecZrpDjczkarebYuwD/BfjRIMLRbMMI7ULFfDQW51QWTvnMEIhZQhpMfxy7ByydDWf3I8o1FfvSQfnjiZA9If83fj3wLxBYXVf3BPx1d99aV9fD/p7o6YG/W9nf6p6e46tX02Q9PULu1G3Crv/Sj86LdqY/JLzL9uiaCh5FESMCCqJMiSE3ysPm2LeevyGiuqLJVKSQUlL9STSYyin4hxHeSCP71GwqojojEfyjSC6FBpP9KaWQjpZw04ekDcW6UheqTdBCgfqDPZHGhRKfoBUox4LDzbXozQiNy6WGPkH7kizQXweZoDL8AyWlNZtwBsB5boQ2L+Gu4LYCxAJNYqF0FyznTBLWrpLpxmwZK/Q51gFRokdiXSrmk0QPO+YBDY+6BZG5e1BaGSHlKvziVTG3+r58/ZThtXPv83vdIoIzEZtcomeCjgiY+ImrkUcSz4d5uYVHOowtblFnN8vOYNSPFDP+eM4Ct/pBeOYlw49VG40G7w7yWE1ahyZIWDn9Pm+y4AFzFe8CR2EQHOvOCuHrJ88aviG7bMO8qZ18s0VXLRqd1QZlg2KI6Yz1Ynhzvb5ZMIcE3zZFF9LrnD6dKRKMVrmRSPSb5wzfsH261VY9o85HfuMOWWvLaIuaLzu1u9uHheK9MIp7NC4AY4PpGVxoYAHnNb/f4wpGo0G5qjWkzlRnhls0v8sj5PTmtvpTf69vM+sC6Hl1eZD6BT349aW9PCdqe5EJaP5OjmvQNhPG9wmWQDFjL7KsNQwtVDqei2BZx1gUFF2A3WcYfoP0roXPaYSobB7ScJchs7xlPuAxeDA24D/sj2Xnb0Ec3XPaYoMFjfbMqgNmeZBiM4NAQg/O34IDlFlx2D8QO8NtKcoBaDRzkGuAHlCRC8Cji8jACAJVZlcV+dA2MvuDY8c+OEaGKMp0KkefQwl5bQpzqbVyonDVCD+ZDByjSfHsQ+uHWToCz7smzZw56a7TOVSWWRjhLWu43AKYJRIHxCmjQO18RkYdiBJoDpg5KoqAKB9SdNUDws9LgPjHu4VUEg63iAhYTS1JUC4ljRRDIv7554I/niwry4Z/gD29rQnF9D7y9qV05PXggQbr0hqnVd5nFVGPmu1X/xzldyOPzqU3C92LkNrtW+vvUPoJwu3/3q6LkAXkJ2o3jwvDN8yXjAY5WofX4ZMWSQ3MUx+5tP5/t080WWtERRbsvM2CmkJ+Ac5gg0lnO/JtgtvV96vcdQ6g1qJ6h1NnKdLR7OxywQ5/GcdF3ImAPRltBtpLgs45xVpEGO4IXcM0jPXZyRZ+N9+JUjZI24IoiQbJaonLaSESAA+8QmxkcNOcXrSjoXp676Wz22f7EUY6sXHqop1rEu1XbO2NL9Chwu+xdX9YMooCcvPhVHNC4Neg3+/2rPDM+MzNq9qCE5d0px59fca2p55fNeGFCevVa6wBNP+63gmdQTtvSJ1M6rbPuQS/Kfl6ti6ZcXWH3xz/QaJ6va95ePNq3ms11Ub8La64QN5s0pn1Ao8WYxn52pfc0pdcNrk94A29+tAVT1053S+6NdqUp+uzneNcdE+DtehD0VQzjmYoaQpdpncLEvRQxPCkHGlRqqebd4jOs909f0q134x2rkfernmyHPynW9pb197jFyy190V0JlGPq2+0Y7fDgpD9eWI2Nhlrtvr3TUt8/daLJFm2hHolnMTGUJXZKJCrsF4Q9DgaN0Ssckuw3fxg4e0l+jWLLrI6+OoJGeLEjhF4PQVtruZugdmLu63abRhdy9CuHu0mjDJHEKUBKC1Al1E3Bnh1MxAVJUDJcLSZ0H7QvdjjdMAclwAcygtTGIZdgo6IPYkpQUfhnBG6FgzZ7eIbQYfzVmc7/BzBBQsqPR//JG16DeYtfF8YRcRao8uia+SdPBaiNVU1xGZGokmWarD98vi8gB7xgmCIPR8WSH2/+vspMJPEfvFGrywizBPjw8EdTrk26Gu05CK+p33wF+G5kmuY489Uw/wiJJiNCG0eWlBj4Scs0c+bjnR6ghHi+YWZ1YWvHrFdOyvoarLFDBYrwk5HAumrAz5LI7poLXpw7TZc7fE7eZPXYt5+FfY50C5tjAnjB1zGPcRxcnEcw7zHPWYQUwodFDaIdSjlpMvgHOPYjZOAAzOBstEjiaiYEL0wgeXTDAOdCjrdTnp7AlOkAB5N6F0irMBgUoG8C7WxnYEuQ9z2oKdyYC0Gu9BVe+uCjY16BItu3HGV9AQJdMR448MNf7NpYyvUmjozWd7n47OZTpPZKpBhjghW89hQnoYKu2DMMeJRoGLI585AZhFjXliYOZzMvPr0rPGH3Lb1n+/8ApFqdNKcWQvTgqnaaNq+jo35qTPRCWnianOR9ISoK1wXwjhUF3aNG8hpfNdRPA12u/bfuWOXOMX3MZMWEYuSLaeZdInAmKuK7xTziVwxjqXk4ZkfETa58gLO/0ft1sQTSa7YbuYTStI6zIf/f2j3WBmFC/lHt7tytCvH+r880v9P2nxh96ds83l4dWNvj+0X8I8HN+eLv1DfESebGWp7jocI8aeYRwDk9xR3rphzuYfKpaHrx3MO/7Xs5McNHT8bu4s/a0w1PjS950hqErefdjTOGp2cbLbo1SG9HgX0FrMsgP9j1kORNeU0e/LZse6RNGSIilLQ7H76uHDPKjs5bh+LvH+Nn0MlZP67fRygHWScQQs0UTj2abuIT/hpCZq4CLhU/afoosZnZPLDdWz+GBVV6lOJuK5BiHGZJC5qNlU71E3Hthey248d247z24+hg45qkzlKmUSNdkFGB4+WYo5tfxYdAAS6TE9JGj1g4Wq5ZjqSlD5Jx4GsSiEYyAqWNlSseMawtXFu8+DmzYP85lM5lB3EgE18zPoh0pE4WCkFydtows2FvJrNs6QoAIPHBoyHLIHTjJXN54syi4C3vyts4ESg8qq4CMcFM1HJlXChJGDpCFB0oFuA9Ib22REgH4iygQETRBtWvrsyh29wG6TCbyV44lopjQaH8+qA8G7kqDpwNJxOKe9GINWGHBl001QGN031A3VgOI8G8VAqchQNPqsof44W8U9ek/3wjOZ0WBDlaSiM8U00IQ10KKg+aOuZ1WNVDwbRBPQ8mkCKshXcphnDp4KKEiTijE0n0QT15Ci5EplKiNezu6pRF9Tcg/SuiTw45lZqgM9qN1D4P8++O9T49ZyQB5qH8l+B2iFRpZ6h9S5ofDpC78op05IAlRMHBI543Jhzohq3X+KB1vMDZDn71vdhTj2pLldPLhS3XHyNXx9PJnT+ay7eIi5EuXAQNQUzHpvNkwk2oWA41df34kkV+nXygdv1z9z9q0tq6+trL/nV3c/od2nrVfwH9FMEGJvMdXOzoFXabHIKzKU7g+TRoE1lYKxUuKHyQgWWJqD7bsKmXIIJZzJwZMfWw1sHMBewq0/bA3a0euGx7cMMykm2J20lxDTJ4vC4hxkYEgAxfdYaG0CBwoA6xK9apQ6t8i8Ach0NQDFtAzhfLqfw41e0UrYfq5JsdihGFDVBkNW9t5qhFBt+XR0qQFHYvwoFVvmhlAXl8Wf35E3cirGytpPiGjpNj6fKnlFazOOWtfvLLhQKSKLsZqueStd3S/SGhUkHQZeFXKmL3Bmz7JvbZhA3l3rn8Ptssut9NcdW/6B6/PrtE4lHx9sMBvfkxpDkCnXMu3bfi+sHYcvwybCT45BaKPVTNlcLvnq+1Ms3ZYPZa9Pp0VtqDvaLxvzuveoLHiM2W+qvGtjTNmnJwILFU9qjbrbBQJJkqe+7YK5bmOSgfbxppV08e2LpTiZr9/GjpRxHulueUYOZiKPn1GAWRecfh3/q7fWqi7zea+CNJHwnvK7x4tXqt0dPpQGXp1KFqTQQHToJeb3on1gGr/oxZKWFaHozVB6eyrdMLZ4zjNVE2UclAQLGWgq6nGLplKWbM+NJla7pmYxSkF5jeRAs9zOcnAQcFVAh5qQPQIwAaWVOGXHsooBGUyd9QDSi0YjDj3669PLo2ir4AFQPKM34UNDs6BhZK5c9nSE/k30+udCu5yuk5fXC9bLJdyrrM8n4Vb2hsKKEcwPGvcKgr9APaRpb/jmqYYnSGbFc29l14ldl31k1t5+jCZDY5Cu0s7bsLPK7qsZpS7Jc8+LKmmX5PLXB6I4Uz/p6s7BL2EO1JvRIZN1ia3TdqTc8waBHaPXgywq1ZqdPyPucZnCFK2Q8izjMWfL4wljVH64o+c+0AIZzlT4hO0L1VFJASgl2S/WcVYs4imIaVc5IXlEbO0+5a55iDyXWW1GaSIcOBoinT5kOHwwdHTnosImOqQG/yhwwcvAw+fCrBn25/BKcnFW+xz76ypRWNV6No8Hk3LWD4+jIAOGjBn1lY0atidFtGduIcu2V9Y6ucUxFbL6hBhEJIsBJNcfJ2qbAZgNVzAitxzICYxT2hFcrpgVPLA2xr/AHTRZK8Z2Bpzaej555lD8q/AEwJk6P3Zr0eHE/ohspf7DwPpZl+SidCR9A+R/AcVTmf1Z4v/A+c2pB8KBptDJXQJlXFss8SxCdFroYitLyylAKKxwKwAdpDcwD/7UENOEo2Kf3hxzV7gkF7ZoKj8se1PR4EkG7psyTssMJMUp6J0+7zMb9DOs/0jxMMCw7VnwnW4w5Ow9qOluWqUKeqNiuUmvObkOFLtC4tRZp3rG1VPa/id2dJlsQFRdooZI1VsYss1L8tg5J7OlOxHsYbxNGfFQbbpFffFGWV8jVPurwVYPz7BC0e0zb0JPnS14MQSfOOTYeJudFWwtoOKCVrK0e2koqt1jRPoF3rIR5V9f9Fp4rHQ60nlaB6xzDY+Uq6/0OqFm9+rdQtcMPhMwhmaabM6YNlfJe7dwMwJjH6o0lmxEQByIbs6JgCJzJkgWVUsD5m+nmw2NEQMsy49y1R5f9NWf17JFMNn0qWJ9s7Yu19lzNIpuCgfr2uiqUG9P6wbJwOf6n5YcW/dzruEI0TfN6k0Gl2e3fNjVMo+Uu2eGa1DKnaywwjPSJ0l7tpT7ZR0CP8bnLQEjGdHmUxB/nsAyUBFoHNGllcFd0EJ/V+EEI5GgsONQ8eznIvYPFEMe3xrZ3BA5amO5PWRekGUXLPBcLkhIUAaL+WuQpq4l0I40vA/HltJCvXEY3ypTTQj4og//iJrqQNgWObGTLaeORwNgAdL3iuy/y7hHmPfJu5D4aPyYAc+fKXQ5AE86dvRgwWi4zxKTYOU3xR9I2xh5YEEntSqJInVhh5TrT55JDnH3A4DPs3QuPAwb6Nozxv34+yUT0/fEzlf1V5xdPPlt2Wl+Bfdeh4qFxTiHKg+oKurx/LctXwvsgopv8lfLO8wpT/gzyyEhhKVkWmvfUJ2znZzg952B6wckoYnd2ApOrBKCChmk6MkWNHSGwrGDZO3jt9w8sHa7Cf73zWSCjhcDO19Xfqf+q/o4KPcGW0IZqXse7j9xRsF687MAPX8Z/WXlg+MGnUY/6qvpbJmFZi9pRDXXRczB7JgVt6IORKuoOsdnV+GopjbHGVLIQQ6ymJAtZFFGUPiqGUNgWieC76X1In6Kov8H55BScy6X61F+HN4b7IW4/E1bYpyhzlPWQoE/DR1JCvlifxttiRy8q86i0iWIUoZCPFLZFk4kolI8ihWxyypQkzqu/gfqVZErBd0dwNh2hzeiDClCkLwW1IwVqhwyFbXRD51Iwxn1ClmrMo1LHyliPdvAXu0kRlz4oiWo9/ZoVxToCReG7Q5l0hFaXOk9baFs13CJ15kWoM1fS9S4NZrFbZdyrOLZQKe1lCp4wUtSBlP5kLtmPFDp+fRGch7itdDwpj6cvElF/DWPd30/nQoG+R0dwzjyF9yItR+WpLQIcYs6irnkzjmLoqyOYsJfoNZVSUENrHntky5rukCDYrTaTZLKSXamn8feHgMrCHAGqTKVkF+JMdemLtg2uzUwTQ3qr0673wUlZc/S1O9BBiolAKm7UedqitcTjHsHOS8uPyam1oBLeRbcXjen2V4P61ftlTZgWqr8f9cOiv454qFv9KnUbDKj//qIELXrfx9KXhXJpekg+m8ni0gyQ3scyJJWiDJ/5zD3CX4Xrtfadqx3najeTexunIedoN86O2xB8cNxmcyU5TEHTUSyuxzKwlldIGYAoRUV1ZweY/ibVL6EKJMyDBmNtJDBeKEtfrAtDXUSjocbwiWm5p5mYK58vllRSEtVoT0o/pZhOjBUOvuiI3psgaqo7E+EM7IGzzyOU2xtJU20wURKEHzRX+7K+q5rVjxikqx81XwX+6mZkAKcWhQzaIjAUo9SP0B8g+BqIfkR9nalSJx6B8Gsg/tFHSzEowbSzXy/HVJ4HlEaZyKQ4HaUdf6wOPpGTURoAOKqsheAWbcsubfn4yw5z3ux0wsOBHQaD5S2LwWB3Wr5hkYWxeMjp/3jFIjvNr5idMroSbzKJOp1oKhw0WK2luy1oV5Yzc26gludQLMmeCrrsriLel2A3zE53OMmQ50Rc0xur1AnTKCxm6YSdzgnN9EncTQbVfNif94fVtu/c6muCmcO/bIs1+W75dgy9AHgUTC9Mp4ZNff2S3bsv2dCVy3VtoC70dYvjq23oZD6vTmirqq4ma4/UtS1og7+6I4MUDSvBlKZxuPul3XOffXYuvBwan0zS7DjMY3zlUD0vMv4soK5U6CycoFxmkdN4gIjqD1AhOiqYqul90st1TOV2unlqe0MAHOcL6lu/2wmry+uqXu3ci6Sv+bDibFbf/c2bQw/usx7w2FqaumuaGqqwjpDuOd1+rF/28CubMl/9ypcfihqizvqoN9oTsBElqVx+7E6XF1acd7V88zokXrpmSP32po0twpxsfzbUyFtEsxSam26X+WmGROr6nz61PeywEn00YojaPfpVe7aWeBzQQ5GDdZOA1Tr2hsXJNt2ohzE4BdjBPdFant4ljdyTneEmzR8YmD9pKo9W7N+7IqP5eonmGyxLr/PyvD2XLJ41a2ViIIdQw5Ktt31hTSlk9e3FkCIuQcedpzLmQW4SrEslCru+xg8XJTcAO5sLjVHOpHg5OgsBjkonpOHtEXOH3+nSBK+63jn8GfQAOokeKLzod97yFX/Mv3Opk2x07lejhb+o0f1O5370K2xBv9qPs+9tW3fjN6jK8DduXLftvdf/+lc8Oeb/yi1Ov9+5dKf602mhP6jvIvc7oWmhd5Bb/fM7TK92UKIy2XquiuvipnIXAeRnmhFrqmNsOyO0nUXuKqSgYhe0xcE40yqlPH4ZaCHk5hn7mYeTOpxRohlAtHHTvGVroC/P4b0jvUB3ovXqqqsnGRymnbYJ9/3ncqfzEfQqMl+8Mm1wCL5wbZDYIk/ejrw6lHdGZxxSt/3bnJPo6huvf67n0n+e/P17evIbaD9VFV8z0s3/kPDxgunli20zoNi+Kb/cW9df9y6y2S+zmWSHjA1q693vxNFHE/fMqM8u/MIrexwfvPyV6zdnv3ypNnc22J8+ZPAUpBA1lv47e08iyC2VpTwRvezgK+5qYVcyG98ymou7kplwoYi9o/4UV99hj4QIZ++c0XkENibZQh9oD/qhSTIaJYuaMZjN5IVTuZ6emvr6Giq+WxcOF8+kjcJGqvcH27cVySVud1SPGOe7CVGxf6oQxLYhPdLcHgGWvDAwIdt/ZFCw5yQTT6yi+u9qISWYB/QWbNUfHzZiZAC3iL+NiMpbCDbmLDb8yGB/XhhI5vuPFGbJlgERETMaVgvftlsG9Ng4fFyymU2X6VEKEeTR2WzGnFl4arA/S0+yM9odxdmy0CUp6Pnc9RznKUpyR8a8UaW/zLwp7scV6TJj4iKjhB7L5F6wwpaAO4cC6hAaQFk1rw6OdeMh5s7RJ+FoiOZWB0dUaSBNORyx0gIjkSjXnzzFNNhzq3uzvauR9oIQrd5AlmXLZlFgGMpHee0NoTiAAkzqlRofGP4iS0Iz5CuC555mBk8EeA7Q64UB7dlfpGNgPQtDQMVkuC1Up09q5ivEFEp32F0IiJpmMZrO1PKJoKZKgBzlyCAcBbCELZUSDkyYr1ssp8aPds511yYSfROGmHrrKUHUq3l6nx1Y37Yi2R/vTbZXdxSTUC3okrofTXKGa53X2egNNNc0TO1adsmOaVoZYwJLufi6VS9OzMxqqGEshmGLn5YC6wshIlk89c1d0Uu+yuKpHqL6LbK9lKC2s6e5e1Pvih0LliaCLPOoEC35yP0LbIcUNQWEBFaUKMAepkRTSlqhh6CQoeYRuhFVpJO4D9Ur/jaj71X11KQp9mqeCMiATVhqdTV4a41PvHjvh6j/a39Dj5Nm9bPqrz6v++epFh12OxBv463EgnUpT1vzrNjFSDx0+/tfWPv50TR/gmnyupwMKyqdZLD/1JJ4NymfbBfk5n9PPaLOUo98T9PcaOlc1NzYvKizRfNSA0QqYyBSHz/Kh/O576uvvPgi6v2+xmJM9itunndTQojyh68cSVqZrcgfXsG5xKN8gPJyI1KlZZHSHdVBxho+ixv8+rMl7u6zckrG78hyoVpOlfjDQ+JR8m6JP3zW7Z14kPGHz+IG419CGbSsFBQqa4zpZ1mhGm6UgzM6QrWsNBtXzaQTdaFRmq+a3n+Q3fqXLuJS2k2cRq0ywx7ED6Q+vasTOKpHpzNKPAZawoqycqeMslbFl8dZm35Qwjmrmne2O9U8DSvkaRjVuSvlgDXOG0S76ESDaBBwLDvKud1qzu6lwmbGvAE95LWrOY8HsSCUM+X1xpEs6kAF/ygnaDrU7dTGiyZtwRffVGtQEugdcdk4H8PzqLSx1iHew6QumOUO8iP2+lHQe/o9s5ccpvM9DDSmzVaNv/QjjdFtq7KYeAnxX/IpSWbtQ/sjeZXzRsjOToOtlYqy+4wNdZMEkgG32VHnUqTSHVBR38159v1RDeN15PasOp1dtWfPKgRPPLhqDxksMD/J02dgT/lOXFoG5chco0bta+dySd2dSiVRTQkkJUeXLy2rU19oeqz3dL4+VYcWgIvP1qfUY8P51Se61H8WULHiAPxm1YXUrYmZvtq6ENoPb9Q+eOksdavI2/mKxlBeDofzIpOt4RgQjb3KHbm4xXlYZGOuaSuuWflfJ+l6rbiF5bnypas2figrcSSv1VW6Ox57Uzz6XnjcAkdufcfc8hZvdYt2WHQl/SYzYLguOmdBu6aFFbQn7CUfzsEIwE/g/sEBMGoeqkBF5XeGgeI6nYMd7xTQvAWOamSdpqtxhGfRymXZ6ZUGPFRDQj2AbtKXEgWE1ENxHsAr6Yvy6YBkiabP2hS5tinTqqZM71q17Cbhtt/Or1nZkrpido3b7HNtmLb1AZ/3wX/a/N39aycBbdx4bPswk2si+e3HyJNV+thcxdx707IaWdp6Wbztui5Uhfu2WXR8zyK0gqyeuf2xY0sc+okIj+Q6NuouNEz1U4qXevZEJkS3ikxKYXz2kCtRsrSR4Ido/pdfq32nZdrOnuvveuZf/7XwHg1iIglQOF78pwfb2tCP9YMHPv+nwhe1ujQSY8QmDsWrqIZZM9ddpPQqsPZ0SdoqmApyNiUg2twB6iZBABOpUoVeM7wGtCQV8nC0xSx/YTJHw4eofU8+VzTsN/w21YiDbg5/N1u4Wcz1pU5xqb6+lAhP/GW/Y3UvPctjbTomljT87RyqQ91v08w8zH/+hn253GmWQaBPNuezxIOMTp1ZlH+i08zIbdoFOsHMsmYzjkqeIgNNk8RLOsJFa5CZkjplLU+ymwc3yw2NCzYX3+Q7a+z6aH0TGXjLP68x5i9c9sLxZ15/BcUHn3l9N7p8gDTXB9bYzQZxwZKLJ5MXBjdvXtDYIG8uvlXOviYAhwNkjjXO8+Ondr/+zCCKv/L6M8dfUJ8YIE1wyNnXGMS5i1b0amwE7oxVygkfwgzZYV52cce509yIXJfWP+iZveyqsPPjOo+hn09v5qfCyA9iMkFMMogS+bA50HpYdoWKA1HxIFYWVXH2wF4B5WslQKvs/53MJMegiByCI6FvfZ/2VHMW/WNGV32bJHm2y0bD9ZGY0SR5XjI6kKe+4QbJbDTcLxm6bR7TYYOlnNS9gyatb6pMqjPRpKZOq8cISXHuIZMjwe/Eun6L0+m09OvwTj7hMD30kNme4PnutmJEokHkd/AJu/mhT5u+aMroDEPCAYD5VNGh3v8Ng4y8oYbWqUa9SardLq2QTRtbvFbDIwbXxZLuM9V6g2Wee4LiRXZjZVJd7Q3SCodlY3NFUp3R1u9urfdge2Fov81aXbWliiczV7swdq2eSXjwVlttEFHjoRE4HLgEomY24Bk0zlNjJR/+V3KV5UYYLhxhUq82kWHDzBwQTHYSMOFunrEI6D0ILEwJ8IVakUIaVVyOiqEAXbFhgEpYu9RM0MvqN/9l6YqbHw3HiVHGgLRjgYhICNtqXIab730ZTUe3oum4896bDa4aW1hAItVXhGROUzz86M0rlqr/+f322iMotvWWOzy3HSJ3q39+b69teUwPlCeRRJGXCBXbcEVi3lk/3X73e3v3Fvbu+MksbyziUkQEkbwoSsRiQ5I+tty2h1+xZNWHd8ztm/lmGe9munOd3KYRazOI3o4m0/R+vkwJwREOPaUkJvSrG8GBQ3lksCKdbGWwn9iE6SCN7Kd0UVLKieqcQAIqGq2ZpOGPzourgwPZAZ830uDO8ErVhHBD1BYImCM1LZ5W4We7b8wLtSFHymkNNOUm6RXATr9wT/iSgW/etNWtDtH9EznCa9sneT1KUzSx5I4ZrS+sO6zZrMG5xNz2H3asWe274TNNnmlCPJAKhR2FnChZdXY8+zlfrW32nEB8elWXHa0KXzwnGJ471eVeO/fuIxObYn0pnEv1eXf3papu3NMYmbJv2yWXH+bKNpiYLGk3pS0rdrQom2s2HmmNYyJZBG3EBKrnhz10I1dSVJmVnoilbY6JjVIbW+XjB6CGbmGSqzyk5fFqClidKUeoVlizLLf7Z0Krp6UmYg4EbNGG8IQqhc+4GyJeHwwoGojPyx1e90JrKHTHkkS0Pmb0yq0da8PqB2zQAu6tuVeu3rz/i6iTKPpJvKZkqXKhVcjeVTU9XqdEZttqfRctmo3tOqskFnKOcCgViAvTPE2fucG3ek3HD9vnxq86fPklN0ybPiUSXLN4qSs+d7dXG7fYhAlP7hXmrnW7ps4NB2cXcYIvkiyjyQFXOsu6L8mOtd4rDJ363tnmeSvXJtV/nUxvKZsJo9TpQNZbCBybQBNlinjmGJvJYq5p6sCqdTvWzvI6uh3eWWt3rFs1MLXpm3g6nvZy7p3CA45z2FMmX1h48+xmW2LuVL/b7Z86N2Frnn3zwue/WXgDt7z8PDWq7BjP3HIZJxcDsJfEKD4XcbotuBLXcBUDinKa7biWlG/Mysm0GzKcw0iwmlUmpUktSxW9lPeBqOVtu2jgyaBcGKKCiFlGmOTptVlggA+4fGZNMF02M8/q3kK2dzXmJSOOJ2kWSBwo2jgIALJbGCrpAWu4LrVFBXRjJmEPwc7HTm3tVoBKUdRLiVTITcDNDmLXWDT0/T/+8SM0Y+vsmZNRxyw8+48Hdtw1G/+RkD9K1s4JW9HJStRzJ/7am8lp05KJ6dOHn0P3PvrktrW9hf1oj+IITXoCX1+JbTLeN7OZYqQy9UhDJ+wMn6ANIBZqCixKGAWUTtiLxB2l+OywCw0Bhgd/GOhMdXEC202oWuhXN/qUJy4vm15MXv4EHkRMtIPZJVP/CQjRGpO9Gr2j+G76HuY0Ok/lvlemv+heGh3P/m+NZt+3UtC/bIVxvHu/EZFczBpQyJblj5l5NCp4+kJhq3b9h/e/IGuiinhAzZcEcVnCkhAuM8hIFlGhRpaP3QLSfPQ6csTGlIfC6TlgUF/uU1IBTKeorRAKNmKKfGpBbn48EETXH9tOFdkZzCLWE3WoCLPFMMD0Hx0fFFGikK2AXJzXIFengXWZ3qey72ZuNr1vSAH1546kgk4JTieXUzvBELv4Kc2DdkfCdmVqT6TIWEpVUMXoB3POcMf575zh5txzPLf4nte3NKaUmq6pfdsclmGYkm19U7tqlFTjltfvWdwWQwFoGWV1BmJt+J6nfzIw7/mPBn7ydM3zJ3Iz7986X0g31M9NpOesnK5ZmJm+ck46Mbe+IS3M33r/zFysTeNh0stQfYXOAqVs6gCeJnBx7jbuASpfG1WoWQTtmUlHi35PGrrB3sxfS1U4nBkakkZUe8LldIATzigLprcW0GF2IkNCZoCKzl9GydA7UZjnbuxx07PHQiRNVRsqcoyFZyzxkl6An0cAHEQSxBYsSYhIOjdGRNQJ4kps1PPwazYZurAbYye+XdN1+O6jDjsS5eSEJp2nHgtGYrSIjkaTrWlCwCL5Js2ZFU15a+SZVb72/e3GUL9c4035m7JdSgjZHY9+F3GV+wVaIEpQtyQ1S4TX6Qg/iecxLxAsIwlLOkmcKfFEgh9vs1mhxToeTWeqISefU/+/JLGZkk2IIH2dr8OKBKNO4qvdfr8ktrjFqtTlM+a3d88Rq202u11y14pzutvnT16WCtv4umxsDTbZSBIZ8Z2Ve1LJdkKezR3bB85vv48Z2kxnKLhp9+taFLVoVmTBncuC3+ddl3chrutyF/o8M+LXSIUvqeTlGY4aN0N5B8xZvk45hxG/tlmz2trwQKy0TGOAqeZlWc3Wls9Z4QzA4CTucnrOMtVkig+ya2Cmlg+EFdU4djGRDmdJMZwiMI6ME2uGfrS0LKPGY9MkBrW0DLTgdAYUeZfFaDLoDAZeL89zdv6po+mqqW17pwzsmlTl9rq9l1VNfnvyi1fd9vPtuf3Dj938g8m/bYOw2WvdVeHZuaXzHv32zs4/tsv9zoVz4AQ0YZsDvzrh7upa/0SfZ6U74kD6Vo/XnZ40+9//47bYYINn2YQad1144i+Q8+5n1W+ezkyoqbl2tne5J3ak4dqfn/jalI6uea2GtUs8Kzxmrz7Ax56olIWgun5ORpsCPc6QN44uJ75ovIjZlqV9wnTbKXbPU0s001nUiamGhpBzGl1rV6+qTvbULdCvmbtL/WB+a4jUGh1Soi1etazaIjlCRiVgJTWWyVMnGyQX6v/uXlxvqdY72uKdTktNI181eYY8QyQoVr2sKt6WkBzGWhJqnY8cu+au0S+o60lWr1q91mV0EhHSTa7iG2sszs54m0NfbanHe7/bj1ySAcq21BBrQDGGHFLpDCvbkOUupJjGD4zoh6z+txEVku3HBK507tC4wZEI7dzWbJiImj1DO8p4kHxeYya5YQ49d/HF6DnTOa2acKcVdOiii9T1worz2zcZ4bHN5JYxHJKPUrsU9PKfGjFAZQEA6hQAvWG2oIHy4Ty1AjPYdzajjQ9Map4oCn63wdoUbjBLsslNLr+3DZtFqWFSg8FJiNdX7TEYW1PN0wTBLDlwJ5r8WbHV0VAVtk0+6HKP2daWGQ2eap+XEKcB8kuiGWfuu5y4TbJkbgg3WQ1uvyBObJ4U4N2ug5Nt4aoGR6v4WfW1TuyQzIIwrTlFJlfuS4jKYolL4HyfxLiKsPawBfEapUrvsbVXF3J72N23m/cU7WtR/mNaXDL1UtT/2JvqT7+g/ufboaa3X7j6aF3Q39S4+eC0eb3zJtyIVr6qO37H/oFNA5GrL+HXrZlu8d+uFj74X5se4PfhWy4TjJ4vbeMVMuHexcv7HvqKQQnfcfxK1+TrewyMPrj0TI78C+BNjP/NOIRBEqL2ZuzaXRv5lyeWdqJIVFVPnOHOvPHFg8Lf1H/MmnVc/WVBj/+OYr9+6XWO6TqfeY7N6xJuFXcFt4G7ntvJ3c7dpUnZuJycJGpbUbSbp9QaHJhWKmLdDOiBh25FxEPRBCoBgloAya1FlG8EP9KD2CYHaz2VdMjlI7fyPcpLj+akVO9yZuIZGlcS3FF/86dqH0pOXnnZlIb5kYn+9VHlklcvsaWu80+MzG/IXrZyctTgau2d4pE7nE6XTTRJkrvJYDB3z5rq9iBf9Z/U35y4iBgMhBj0IUlvEOEX1ut1er0jrjOZdHqzaQqxAY1rnWq32W3t2GbjA0wS6Cen1WvnCl4HOdh12UTRm56/+6Lty1Zu0ce8Xp/PGJio37Jy2faLbl+Q9orhqQZDU0MgxhO9xSIIhjaPR2kxI55X1vIOrzAXPXD6J+iy4V2SQAQ4en2CUS8KRoMimcyS4AvrjCY9/GxGgXfzomTGRjN2GTHx6kbddURGWaZW6KQnRtvrodgYYC5iTvHBGXXo5KGBkY8MAFbObO6QfEnXgNrkybfFKqwefoOa5Cnx7IvfWqkq2iEr8abLdbkY1FF2h53pQ9BNL5OidtSCLnGI7mOakq1ZFnOy2Sx/DM8BxOUQlLu6d0StFoKHhszyaU4244HCoFmm5tJymkyMoOkAB6lV37IGsFtjctJjhHE1KQcTVp/bIZRjMBceiTMxO/SaQjDejGVHzZ1VYexWv/lOVdBl9wmDKLzlujuxGTsd/vt8EWT6svo79ZZfVIWcDh9BIvo/L33zTaRpCavf8ztdwap30HQ3DlfdWeOwm++8bov61tPVTmeo6hdoN6r5shlFqu4DQsn85jdfUoNFPVOueLdWxzVQDIcbc7/mGfttmWDJ/HLFvllhrZa3tfS2tPSiFvZ6qlJh+XScf/wJ3msZ/ovFy/Nf0kba9j37qgyxZFbZv2dDl/Vq2ejfhyWDy1TV+330W7Pdbi7cWiSRs1VxvDrV25sqPB1nZ8Buxkdo5pIMGihVCD8uYoE90ILgmLYgeq6nM2Vr5wEKNMTOCXZezFFWSn9SvVTd1t7LK07RMalFqXn2C83SRLmaGOw7WZ1D6Cvo9WR/Tr1B3YduJDnG9032o5VBefWGaHBKoqOhtj1e3ei5rfOGJVvSq3upjdFcf3I4TF5Sf9qg/qWR8Z2yZziR3qUZAX6nAGGeZDhVPaVnUJCzJ5sBMcAuGyNs2AcK6BDTPc6R0ax6UjaSg25w5H5bx0WBq2YXbhCc6ketKx556ZEVrXweOpKFBaZmk/3xRcu7on9+Rde2oE33yp+jXcsXvRC4qMNmm30VakUTsDOxcU1Pz5qNicJ76slkP111/cnGVQc/95e7DyPBLzvp8nPKfvX04bv/8rmDq9iax4BLqsItjDYDykK0sicV6ZeYzLXETKzTZw9jodJnJq0965jVR/r0uLUnzQ35hYF9tQZT7OWUqa6m4aVWQ4NJqnPeeae/scHQ+lJDTZ0p9XLMZKjdNyZVQ82dd9Y0jE6Dc2OyYTfNZmwYydboH110g8FUd/fdtUbDqDTlb5LRdZ7i1o3lpzKpQqo+IxVvNyiDEPa9Sn5qiUUoFhmqRU3eEq7RLVA8k9dufYJlbqpwdF68kK8N114809vrNcdmzaydPjMQmPXK9xYeL3JRUR9A4sNXH+ODjJP6meOf7SiyUQMGj9dVbfHiKSFzrL6lR7nlGTe6oZKZ6pycWtw0tevuCa7swoVVkwu5bLaSidqfuvpw92SNgzq9Q2ME6mW73+onczKuRd3Z0B07p3Ue5irGJwW74BaOiyTsml0i9p+aDGM0gYt9rA12D4p6eUR638mo9240hoxiVEYP0i5iNFIjEdRQFyqO56kVGX42EAiEpnTGanT8rJjFi2SH26WbeTEMVyEfn9efRH0aZ5W/bNmSV19B6zRSqy+lDnV89pVd976AUBcJ8seufvjwOnSD+5lblJ6W+pg5NAV7LdUur8eAAqm+HM55441BvbAw6wbCIKh4uqY2LU5Nds5NJPsZYzUwZ7bNG7hoUTarFAe2AOPUMf2x/UL/lW7X5O7DV191uHPazjtC2e5FrswcAuNnl/V9XKX9/yJc8aVhoKYamlE9uyOW7NrNp52Z79W+dsf+s6ONMerFilOvWShSLmntW4GMOQL4C8X6SmTn0VHTnDwLEjBAQo5OeWH8Kb9qBDBWaJ8y7KyEx3MB7dJPAJ1lUB41Pkmuk36vkeqpMSEAxvuh/y28BkE4YWfEaspOcV43rDbqw2WrE7Aviey+h92zUnXUosFaJv1VoUVKqbhstnCeWW+ePDLpuSIVX5zs9BQ62ek5N945ZrLZ2umYjrMAiLMuBLUhDWhJFxvawjQNUmul80NqEa5H00J1DCti+piZdFH1UBKddQjRLwzQkDH6mVQYWjUcl+WV9NsBh1Y6HCvRenCC4zj6iGqEjqexeVxTVKTpIal6CHKB4/j5dThZ27gk/fgT1YWERpV1RlkT3fEMylRqHAoCK1trjGpgGOJHxaai9SuReWzT1qZZ64uN8Y00FFKr59TTLLYrquloIq0pPaisVcs+zhAera95Vs/LlSHL2FZdyVrrOEdfChdqVwsbrrJwqKZI6vQg1qxRNlCoHuk4PXewUTm7XVeMzPI4MMCdOZ8enBH9Enu50XoPFiTFNevOcL4rlI3Sg0Ql6pSSihgtkeT1FhRSYDVDYkpppZVogkVJQKe53PR4oFFAh7kt2Eqzw3+J/mjqbpSi15AhN5P7hyPXnY66WQrRo1gQraGeFpmmBTLsz02N6YluidLGlBik0s1pJoIjaYV4Mm6PQoUCgH6M0iOd8n0ybinNsBPaLncGthTJA2+xyBRC4KHGHhkfKJPWDFnHa6EiFhuKuzVuEbP3RxkNUFRGi6OEuDuTTolRQPco45rlpaMkuurpJWw3URg/jspsUhq+G7FQ5GZCEiF3mtKkSsadYZXDrkfb2Y0A8UqmIIN2SxuNZ+oBV0/TrJS7TF/pJJuQdIixm2GM6FshaSb+Hk0X7T5KFuKhTEJm3VKBBBaeuqAltQzbozYh4W+sBguZhq0iFgQk2ixKvR17CPESbDIiUW/BBoOIsBUjQgRRJyEiEhETI7HaDKKeSAKyOokuCW8Jmf088QE5KmEkCjwxypQvLQrhqqAoSiaCiR6ZJBKyCmZeb5AFC9Gb9DxvsuoMyG7TIb2g0xG/Qa6WqkUBGQ1mbBGx2QA1CoKOSAED77ULPI8IbyHNraIo2HC9TrCIEnRIwrzVorOJBy6WBB4DYS6iJhkTM7IhIknQOkzsZnMQWu4wQZU67EGIIFJFEOZF7LNiImCsg1zEYHFi0abTu0VBxNhschKhWmcw2QWrXwrLWDBKWPAJkNCps9Q5BIIxr8ciQk4suAVihnHCSC9io0mWEL3yr5fMMhUmMPGYNh6GEUlNolUSsOAlVQKBngkGbNRJOkT/WSWDAVnsvEuUeATDrZcEQdCbdJJQRyRMeDe2E+IwG2zEpCd2bHXbj594gMjEISJJbyPYwBtFiU4VRi6rYNIbRQHDYhKIVW/hzRjmDsuYJ5JcjXmbDZ2loKR+D9mRwYQknSjqZOxGABZuZDMDSGEYer2XCNATSRQMBowQjCtGgsgj3ibyeh0W9Lyol4loESS7WWfjdS6R3QPA2FirBJ3ebNYLyGIloodOrNXEWwUvjKWBKlc4oAIAB+QBuKtCVp0FmawwZpJegkADj2BeeScvVPF6gqAFOmgGDLfVB03QI4sk2PQ8EUWTSCwwkgvulRCyQReMyG/nYc4sMI0oEOWRaSIhMR3ClF8SEkW/HjYzmgc7G6t4wcUTqE1y2dxYrHbpdWFRMosGDIPOQ1/reVmHzA4jER0iL+i8mNRYg0gPcCM5eJ2X6DFAMUAA4Ao2swlaIBOrjhDM6xpthqDdhq0EUfulAI1ELxrNyC5UOwhPAHyJYDHEwGU3Sjq9Xkccsh4JOl626aEmI7Fhk0GnkyQRw6gKOmTksRl6ACsNYYMoDN8efgTqAWTBRFurg2mmkEagAlhWWBQAiqtEWLlGrCe8DTpDDHFznb3K6ualah3TjnCdcYm3MprJRTUhSyi+vqiRS+VXawHMmcQEZ+PYtyickuDyaJ+j0FAr/LnCUqqjul5R8LHow/gtT8u792jKQO27Jths6m++JTx4k95qL96F/B6SRzZSLVZ8bM3DaH906h3PaUylYK2x3nhsaANZOdPJVX6TU9PjqIbTtQMol2AqiEq/C3zLdayf5yjur+Z4bhhcVJoQfyJLkMxMP/wNZ0tsL2r+4g/n8lDaWwDa+yaBY3Kqbqls5o4qHLNvRcWFm+x1qsys253hZFWmH4ESuEb+Vw01qlzwMcN2nOxDf0Dv1zRQpWK+fM9NmNxlC/teScUYBF0lm1MhV5B9h2Ds1SqmXxDg+OK3VegVPP0Q+sAZKPtjbnUvGtBYeGigd7XA5QqcGtDYKYO0a4MwBFTxJNe7WjMKXvpedpGnz+kxZRO4Rr4MpGcnUInxlKZKQVLpI0aazSwrBEW18aAZWaxA1CfQ5fdDp0sfDLpffUJ94n46QMWPAd2PLocA2WcyxegdGkuDLodM7EtaeZ/CLICR342frzY6Jhc1AEZz0RSsbpaC1i3Imlwlx+yc27lJ3GRuCreYW8m4+ZRAsWmchAw1rF2WaReo9It28ySUuHSlr1cz0xFMXIkJEENeXEyBFz591R2LNt8s9u3omNor8LkDNw4fuvGA5AqkZ6ztMvQuuOOuOxb0GrrWzkgHXNKwZpePLC1Kx5Lg5kV3XPX0QqF3aseOPvFmTfgRAxQunIcua2zyRGruLlh23H33jtTabVdcOjXWlGqCv9jUS6/YtlaIM9lCta74qezCU/MW3iRsu7sm4mlqROtZZElP7X5xs/AhF+SmclcXraUAKVzLM7INSLERwy5pVDL8UgrLlESDiCfNaZr42j4TLdoAKCqPUR6Lh7mEF/xv+GONtSRglKW2mLXKZ6ojQf+J6oaY/6C/MMV/wh+L1hz0+9+obhibiuy66ODiHTcuPrF4+fKlO3cseWPJGD/KxqD0AKkz+aqssTZJNoK7Meb/cbXvgB//CRz+6gP+KCSqrhudqPD2h4sPLL7ox4t33LR0+XIoebS3aOMyx2x7cxpccNRACzWpSD+IpV3DSrVIyr391Ok8bJf3bsVowsknEeqYMbD+UMNtz6PcU2/DHrrnN2m/9SSa8MK93YfW9/XU/gTojethzZmZfn2QWn1nUJfRJPuLkjZN9BgIomjKHrK7hL+3TV9/Ord+ehv6e7ZkWkvxZdX31A/xv6ofOnPLL96162JShe4ryqRtmaYuRl+si6D71C0RbdtBRdlMiZvHreLWczu4O7j9XNnmv4AYf5HtcQw5txSXOsPZE0wwl8lo1rNvyLDraIZtUyHh4qRT5mKameFm5EQiTrqZySAoi/qotRUohFlxRxLkiiKXxIz5gztDayUa4wxtRKf9RKjNmW12S2HeNToecOI1i/c8cNfSFUZpzaI9BxZP05t37jTrpy0+sGfRGkloaLpo7wN7Fq+RIKXuGvxli91mztUKxH96VXN84aor5kS1V/PCeHN0zhWrtBeyDAQt833EIgCe9IsBPAQ75qAecD4L7yMDucI/voSNWDskfep1znDIlgWUb3cvjya1zr0ntWTekpv6700tqTPrZ8/Wm+uWpO7t79gYnb8kee/c1kmI70W7dVLWFgo79zXuSXSE6aPQkdjTGGYPPNhuDDt1LT5iA7QI/XsAZ7Pqwi0DOszzNt6n5rPo8D7Ca/cw2rlRx9VzES5Bvywx6h6meEKWtFVc9nRCQkE9Csr0ECl+ojOZLnvEwdKNUGGIfhEC0U9CULsC0zpz6s9RU4E9v4s6VWaZAHMx8kvNyZdNCqBA8dsTkBnKUL8e+7n6c/x59efqZ1En1SmiX61AXGxg+B98TvMxnjZ/Zo9ws3AzswLtLFnV0Cx3FAX0i1obiDGbkhV+15j0ws1PbrvziuG/b3nrqSevx5cYumxmQ+Hp+VeuP9BPdD2Lskt6Ct/01dcoVehRQ7fNZFCv7Llu0fIuPP2Kh7c9eQXRXf/4U/+2pfC0wWTrMuBL5x5af3X/8N97lmQX9eDpXqUmUK1eCXHdBvRo1/JF10Fha0bJ9lEd7enaNz6YPB/7fsyIXr89UWJ5jdVBHatz56FYGv0gEEdyOadB/aOh1ardyOVguAkMt5qr0AzOlb9Nyobf64+xjxPlLJMMqMrgLCn2n+Y0SxGYq7jdkYdZrMC+Wqr+yT8wSvdkXDt8ldfr/MBotRXtfo7da2n2jj+1Ze/Rdv7O5a6w3v2H8ZzsjM9L1A6Ddr8W5TIUoylpsDlKt4ZjaufOEX62VWl2b6j9CR9W3rSdyo0TWOl+g2VD92sGhgfLhpTJ78aGoBFL09qwWplu6d+5Wljx/bBrb+Ruhu2ArYKMtjqkaDfOpOrFEPuQFZxHsivImK7afUm0m10OU2ZuInW2IfJgKpGk2KYoRTMJ+wUH4ZZNC9f3Tp40uabpap9uUli2TbGtR3MvTXRi9ZDY0tvbUlPVHLrIe2n77CumLZqOdgl/1sbBYdEGSv3SBoR1jTPvWi+8VxlTOVpLFqzqXT6xxp/VtRmmNjgQTh1efr1pDs4+FXYkliSbJniqqts7EpMXz4wvbs5Udarf0sbM4pDJDZdf3nCkwWSP9O9SN6q3lCPGjOvIXYqVS3Fr2V46SrgxoinHpDWjsNoHJKgyDTvYypcDJFi0llu6jdMUWijenMpo0kqeoq03Kv0lMkXlj5kUI/qO39N6x2cQH9/We63BaBFMSyzx1PKd102b2tv78+nr2iPvocekBk9rZNaC2Qtuum7h/slWHaUbr7TWWoXQxKbujtnZvrkTWxbW49zIt/eyoYlrVryY2yWbwsqCmzod1UBTPtS2sqN9+eypU7udzX7vGS6aunZtW2uoudXh8sRsJp3FvLG1VolMwPVzFN3kSNjlrvZ1dk1bMrumgi96OdW2l5UWzRAu61M8I3lcojYgbpdHruit1uNmbcisCEDL4854yoNF07tl98jIaXdYsOFElbF2DVsjOmKu7kzuqV+6aGttWy3CndlO2YyQRZwY6lp+8bplbU2t9rDdJVmB5pbrm66w4CWv9+8AWn9idLZoJTqL6LL6lDl9GzYdeG7b9s4ut81eJSx1WEY+oy4EMV6OeIkAjW/J6vVVlhvMUfEd9U83z+sItvgdwbC/rX324/PXHFzaMdUVQpgsNRAzVsyS14SMotUnxYyyeud3NvU3T2mfHAg2t/T1b1/wBJr7clX41O2luXFwnKEswzH2mwL3cU9pFiMq+24f4x87Nv/T/rH1jf1GKP1OecUn6ivco2NU7txxnzxlpZuSu0wWQaAicWWbhujeslMdcRLLeKEXTFBRGJpX+YVRug9Xn3msaI9CZvqSTdTCBxC+KMzkvVvKdkwjnv/L25sAtlGcfeM7s5fOlbSry5It67Akx2dsWZJvK7FzOHES507IZXI6DpCbQEKCCKGQcIUA4SbmKtCQQrl5Ca3aAqXc4YVSWmhNS3kLLUfblwKxtfnPzK4OHyG87//7Poi1s7uzuzOzszPPM8/z/H54pGgD4DRb5ocguEH+PSwTT54UY+KLoshyeHvylZUrPR70By56/vnmZvRH/0E9kr5TTdDPkmvfieFr0aUxfK344nXkpGelPESua34+vVw9Aj1qgqw9JLLyv5lyUjPyLOwYCxqreNmwHItVYEIBxSGC/CIBTFH8kCDTSmNAKAKPEckFe8uvguSdRu0vtazi2g+6NJLgM4RprJRiTTZBhw0+QdIgxR0wWsn4otTm7g+5GKTJKLEAEAmL6Hpj+sdkl0kNUSaHoKUBwL4S+A8AWis4TBjTVBOzV7v96CaulAIgkJNhplEZHAY8EGHVHocYEZAiGsf/KkYIlQVTESkxh15UjX110JwD4zVg6w6HLXEnNm5okrSV1r6WC3/au+NP16x/8uIl5d0zPBpogJwlcuLBmx7cv6FlmqAJOmK1rQsKVlmY1+UMeuhssk7rXTbF/5Nww/4vD295aU9jz+4ftPfe6TV4+fGcw9py1k3v3Xvpjz5f2BLYvri4duKW+Z018vLJG5aAiz45oViBcnXrypP7M7UTFXIwtXJk8P3OymXwppT44XT5fIe2wra++Ym/TN71ZF/vE7vPKp81w2hjdCxnqX3j/hvvv7yvGVfOHq1pme9c6bQ8lR9jvHOR/+FwPQj/ad4dF3Y29Oy6bOLa272sTqiwOKTWRYffufuSB/6+sNm/fWFxzYTNc6fWyCtX35oNRM7ZttxEXsPYiT5bRFDhBGodcVxqMxZ0gpFoIIpkHFvEFhkpodI3cvLh92j3+PmxVVddtWppS+85N/YPDPTf9wpYfO6556H/gJgvw8IdrtA+Z10scM1L1zStWY1XX97agbOdBy8bJt3i+e8eLcUuU7GArTCPFNvr4Ikrt5X0MDrui/rsQRsWwwLRSDRiY+/4sfzTN2+Uv3x+27bngflG4HntV9sf3nVi584Tu+ZeeVZ7MYf0qscN9KoTb5048Rbc+Kb87FM4IygD5ue3pX62+aJ3ht65qGrSopmBobY2nOfEiewaIsZoMFCFVAXRBAl1Ke+I4SCjEiTq+atgXSusRTqFRfmCcdiOzVc3akTH0fPJLTfMKDPidcWyGXsO75lRpmxgWd/hwST+7pjk4U9Drm/JigOPAYWTPSC1vztolQc+vurgRTNnXnRQ2chlkMIXyOSXTuT4gkIq1gCD9BvKmImSIXgGqBgMJckJjNaZkAhZEn0WSUsgJdVlcB6Q2kjRCeVaUgUVAQEDkAwRzIEUxhxIAeIrISkO+cq1CSoJMUKAMcusq0IbYM0+9yAmkX8fKcOnnIQJJq/MCpCgA8AEKbPyLBx+kyl8SH3u8NiaIoqK+IhvZBDzQY6eW/thTzopseemk7BHoc7OzndMcrDfKHmZnsGkxLyWz0OC+2eKUbDn3CNbVRzRTsPbODSi2X6X1xJjtCF5DnrcGd/dsBup19KUWsYzvDt65HNz8cQujEaS++7tDsbhgU2Q2L6DMQwdRvECUw5JYEEJseKqNFHKQnlFA+i7vGHK+REAIudPafgRmNpQvrJTvmKpbkJ5S8yBpudYS/kE3RL5R/7W8+bOYFMTVtCNQx8TL3xXTejfq8qqa2qqy3b9IQwWzDoYkQcTfHVRiSiWFFXzic+cZde3zexdTt75I2g8O4fE/ZWr+BZ2xVUXexOSFX2Fot5m8YnmauCzBUiIJVgmPwlWgHXz4JzV6364mrlWfmr2grb5Nr38FBL7QSe0lk1Z13b0TfraIR/9R1DbuXJl57Szzx76IP0SFNfvmBTxRNLvgmvBl+PHH/SOry/+c+a9KeNrHZkTcTh2STiEw/8jeNUN+/SQuYPjRyzzY4A/BqnmO1+XP7r9Ifnlc3mg2a8zmfnOt3f0Pndg9uwDz/WufHzy/ryV+b0bgHT97aDwdbpQfkn+6PWd1+3TFWgOaKFuRS/K/ia6asrEA3kr95es2bjzdVTG0lM27m/sb7FPm28YaC0OTvVwON6XVY+1MiQcmnWoXaiKw8gBrLp2JDAktIQNY+zbDBbs34IbCO/ujaHyU9QeoVSANsbMaOhC2q13iS5jaaHcW6jV2vUe2hPSmS06C2eFggCWjpUV3DxG1j2AKserVBuC0eA5wSDAlrFygJ4lQCuHMpl1IXSB3q7VkpUyI7qV3o1uqkE3t0H0GPSs0VlRqcbIuucUVY7qEs5heCj+xJi9FVs2pudiq7PCnBSrAjiKnfh7YC7hkhE5Mh5xwMwrdh9LhvkdJAkLMtArm6/XcO7aKn5N83KztfvWA1ZzBVxJzqRfIRuo5rvyailw8gcB6WqMZgXOAV1fXgPImelQpUc+Ava4KgW3S97LzmiecaC0e0bzFkHJ8QrZbFfypeTBPxQVfQC4J/FNrvlSfjwzLiiYW3Y8/1FIUEOyD4ak52MKGn1JzBxicmBcGH5gOBoXAYnuknvlO05cu3eh21l1867yhkktr4JVJ06A2XkYXazJOQqk60twO/gruJ1JXvn3/ZtemVbbs2R22zkhTnPl34H491/lgLtsljFwu34MwkeP5tYgcOxGI7U6vxbZOtSF8Fv4DhQF8N34CUj8oxfLr8v/vqOv5+yAv7AiOnP6LUB3xx3pOzFuwvEzoCuwjd8LVeEaJtn76No5N9fXz7NKxTqh99FXH/3r/r+fAWph8JszoyzsuuAEGh/AKYq+CI1hPsUOqxgg4hKrGCdUZ3g0StBBHPCyXdSnPzIWMTqLhXlB7mM0olFkf804zWCq5GKPgqs0jES/bHUO7iqAbKGZLl0D9CYn3SCIBRaNTq5ZCfO5P+YPXw9FSg+ST0eSI495jBhuA7kJXsHzsflUFEGeqi9VQgp7ZIqsyI6511UHlX0SeFjaAzFyX2l9fjhiKpXJPcZeXVcqcy0+muqqS9XnZJMU0mZnUYtVuSjj8I6RcyyxWmWVEatNXMYUhL3JwIhdMpkpuAQxCs8a2CQEbCE/T25HJ29+8+ZQXWjm6pm+VtonGfWGmkWNHReU8zZGbxH1jI0v33HFDrIrWsjuBR2Ni2oMeqMEKqlTYP5PrwLGgft8IE2VVZRh39/n08d7b765F4swtTNn1sIOfcgo6aqqpjXrSjiLhSvRNU/LT1dV6SQjC58Cliu6r//zAQjfWgnhSiyUMlm7igZpxG6sgbA+xZbiG7VY4svGcLcMJ0Uhq/c0kmzxurucxOyMabKaCVOoDhQol9+BVM7YUl/KoJTNhOeCJF7KB/3Am8WKTZ+L8s9Pk3feryzTY9OK0YTmg56sXEm4YMxUKbWU2CZJWLmqM6HmV6MarApTdiRG9N24FXu4ZaExsGZIArbIm8v8YXfyKFEdIByQXNI5dbhctaum90/aePmByzdO6tCN0yWNHxmTaNuRXFfZ1MxUFxRUGtuqrN3Lu61VbcbKgoJqprmpct3i65766VPXLabJymtVLbqbt6tu6kWzKitnXTR1zSx9hf6W6667BW1mrbltc03X1trCWNDtDtYVOZxVtRV1dRW1VU5HUR0+Fius3dpVs/m2VUc3T5iw+SgZ/xXsWReJQSHL1DnbkMIjSdwlzHm4lKFcoLoCZ2Y82S8ZDQb551otSBCqyB5MhkhQJk/2E5TfHgVFEvSgWqB/OpQPMy4mMEKkBH0ZsEiytJyFhMxgBBJuoiiJAS7PWYAytixMEMh+h12ZpURhgNx4AJNR9mAyyhU6mLE2X3U+tjbfDuimKSv6Do/bez/sEUTQQ+w8/YQBsx9Va4XhbWKD3vt+3GN8G1T8+GDr4b6u1uITo8sYJo7LCj5F1g83oiJCnLaM+DGoFe7S5RX2O8rYL+CaoPwGgyDKpI1BjyR/dppCZvq7Gv+1iOrJWXTYrK8GHUdfKQEpUEAJcBSmN446AP56M2hmYTIcDdsPheuwD6aHyTp2KKZeJqS4beiDjb0d9sbJm/o3TWko2Acm7yvoO+yt7673dvV2ke2kJgAYnaajtzGol1OqG8fviAl794UHDlzYsefw1iWmuo5XrKtbujdt6m5ZbX2ltbi3t7g1cbhvcVEZ/rjLihZjvIzcXscOv25CcV2ZZFqy9fAe+reqQ0c2tlxpixk5SS+O1B+LlfGWYMISlWKUmH3IF4HepTem+OKTNSHl7eFwYZtyhkgStdmwhSkNCnz0ve+HXJzO0hzAbu++4uNAc7zYh9OBZouOc4XevxcfapiCWodWnA4SrStt8vYjH354ZJ/1twcJpIanBElxonweWb07JKKdEg/E/GAHf2vdRw5eaVvZippG5fpU7KpYmw0qvlFsDh4d6U6RrCuUiqEeyXhEyf0E1ZHpH6KSigsUpPYtTaCDTBKDxu1bSqP0IJK3FM+ngaHU0n0stQ+1aS5GLDIiQuz7R4XRie8ZCPa9Ar8U2TChyvZ+8qZJZYFP6fSow5aP4Fvlkpu6E4nub7/kqcN9g1TfYT7x4ZHEvqUY7RIvwhyhx/dvkpPpFHo+o0V9yovbCw5gdq4cFnolNVGRBvhshKnSpUiXsSvYK8PTbDZnnrQDk1MaCPB/w5R8GAUcxUKR42iYOL4Pu9qxqXQSfRZDX+GPgNajDwUq8LA9xBmvf2T6W8KZAdHoTXv3HVfsvkr8ioRmAwUDdy5hNLCNNLLzFh/mRAXqDG/JAeQq+dgRVsCRVkH2OPZzUC3vydKewn3gAp1B/pUBrCLuDRQGHc5AzggiHMik8o+KArOvsKd0MInvwhErfId8RZEBNBhOigyFxYGTFN2TMRoJ/Tnr3ikql8YR31n8+tG2pIepn1FvUH+kvkASlAkUg0rQMpq3Ojpinx2xPzL/SN7qkefPtP//+voz5R9ZX4wIbsl4W47CYsK80lkxLYfXTeXSp/LS9GmOny79fyM/PM3x4WXG+Km4bgQYi8pnfx/I1vRfoyuedyz9rzEOjpX6P5VRHutg7ufk9Rh0dEAR4PLcgfEK5Hd8M09Rv6e++n//lfxvemnWLyOvvxaADN9AIDrc26gFRGyj8e0jvqwG83+ld3/f3ncKa8JoHMRppReSU3nlSar3y/RNkECjJObBSfwf66Nn6FFD1zNJLx6wvYNJ0q/olFLQnp6sY5WSrsx9PoBcIQ+EkNCRyPKYY9trM0YGyre+EgjXjDgnkdeXZY8IZCgkbNm3WRtTACCGGWhDxDobU2yz2WmYLLvJr4DknYLmlzxkKXLgFSStE1O3gp2fSWKuylTGXku+G5f0opRw9StWHHUJD2m4kP+lQZc+RvZp76j74CSswuafjOUW+3T2uxLobsRfPZTBllBw68NUDfoWO5UoyjNW/XtJhUR7GqOKaUVaTBLph0kNpvpz0qIXHQT9Y9fm8+8UIjP4HAQXHlsqOCPgA4oIXk5HI5YAHwhjq2A0HI1jQ2Y0HnGgo9EmqPj6goiDRdo6nwTyh3L/QEL+/STc/D39iUR/qsfrTaZSSa+3J4X3iTA0CQQTA6AneVADE170P1LDBK0X9A94U16NM+nUoO0A6PdqsSKY8BaO1xH9IaH6n3CoFxLrBBZzbb5onLRnOO6L+5CYhPG2p0cZNDEkk0c+THjBgJdOeRM43uIUFZ0uJ1Kp1IdHQCKRTKa8QwPDOFMx80mOLnWE36MCD0LwD0fhABE/PpnK8dbCDHNqvu02pdiuMAVGxoaFBwQZewHQ/zHCN3FEub4Pl+tY5ZJTStlSyrOUUiVGlkwhc00opRt+AWwcXjCI5OwZ9L+YCJLixmGNdiQXLq8FzFgH4VZdrc6lk6t0OvAWStTqdPIOsB8cGPPwMZIiR9CPkmWHvEM39mFSLiMq139mykXlfFtynLrMWAfhXPxw5b770RPITcFbqFxjHYYzlLKSvf1gv1riKt3Yh3G5ZlBXMxFm7rD2Gs4PIY51kImcqdbDDn82qqj4+eD8MQ9TSrmOoXJtzW+vERwT4lgHUblOW90xDsNjo18uyoELNsZhPBah/gW3kveIS6UFI+mWUUdScw/rN/RnYzcWGd9Q34Bzs/f83p3gdG+b3HMGMDIReq5yz//BCwTnnu6d4HtWontuzZXzezY+XXma5lTt0IrcWK3gpeaj9Ci2fKsnq5HXtYJo3hiClxq/JSIClyC2/fSA16uQpHu9aQKRxOFgLi9NZIohnJWegV3QgrNbjHgMEZq7Qzl3tDwfEBOJWMdj23BLQwDkYc/hsmIRUJUZI2xtHRoBrRHQn3VymzjYLxkZ8vjBFF4I7Vdgm/rpTWZzv9kMKAU9VEG/pXtyC9zS0FyyWN2DZqmsPzijyDoONLNn5ZzgmK2Wv2Sg4Dz8UG0BI600Vg4Lby1ZQBhQVpSHcAno14Y56jFKAci6iUPxRj/d0yFpgiYwksIAvEkAkahTSKqjSB3Rbwo3QT8Y31UnU8rqQ13XCgU3iTSBst5Pz/B6vUMkA4N/8+cfPSoPRalMta1AMU5mWZ5vyJLSHjo0ipaW6c8jrX1uLKwHdU73EfafXH1aYRPIEB1nacjy6X7GzkBTm7rlZPcmbOIns1mi73B96UD3Jjp5mhMwgQ9v6oYp7BpApr7DfUj4VbKPcZwas9wCzFNzkKxH5ul8mqLvzkBTowq2qRskcblPc4JJpRMjSwxIiU9zHBdZg2T5BFkv1FIWgoqGv78mNdZAwdGpzUYMZqILrMryay7eYOwcitceFKZH67qm98EWxbh+JdkwaUIV0Dd9qHn5vuXL9zFfqqZ3BdBs776lmPVx6b5f9k3HGeX/UqR1xZCevgbfcPp0+h/40uXpe5STSkiCvEW5MiPHZvsslY90wY1EJVF9G/M64zD+WmClMaSCCmKK/cHZ8uH+VzZLxCuh0fFi2mTgDWaThWUDrSs333LbSkxaK1MS1iHRBw9/fXcU9P9Q/jPvd2ktVpM2wHXE1/Rvnx8rNuCYXZIN/2AUV/ncH2SxZCny3dVQi/BMIAB/FagjLHt5aYeCKuUPK/6RHhrTldGSlReYgL+KCWcsY8q6OV5WJ4u/MFnQMq+lAP/AW7LJZw6cP+7WKQ9Nubn8/AOJlYd+MOeBOT84tDIx0BK6/PqfH146M3n/gSv6fK1XuCPn3Lvh+rtv2Lf+3g0R9xWgt3teR8e84T8XXfCATa+3PXDBokunVwpC5fRLgeaNi2Zsag5oOWlc6+oJu9787MicRdvWzpoX8M6ZuXbbwtn9w78rB34L6riHv5rvHH0VtiSkiqcTOfMzJo0dRaA0AMm5RBZSEP51JKOSwmO5ncU8lmEcIQXqFBA71MIEtBfEgr7oyIIhxZXNMS/ll4tYzB127qvoYKp0iUv+nRhlEqVLC0BIHLySpjLYhbjQgKo4yDZUye+VH2ofTGXLjTS7VOwsuwkuC5QXyzc6zYGKYrDB/nh/ripHQVN00j2tjfKN0Um5yiztr6ki8xqbx0deSJVQdYRliJhQQwRuhOBBtwIPGAnqR5mroFeAZg9EI7+YT1J+XvBl+eWgxukqqNYUXP7A5QWa8bVOWaf40kxXfGmmrz36mTz02dG1aAuYz45+PJJo/bULb7jhQnQDdJvuVau6XU5zNXijT7mafPoyvmxt7jZouB7x3Y5dNzuB8VPs/djjAn8u/4O6aZy149VaVRe4nBpcVzn+P6tbpKDanKmWBt0GVRVq/7d10xPf/XJs5c/4IeIu9v2rlAy50kTfhEmXHPqf1UQxCoIn/keFV+U8tFFmmfbvt0LCjPDvKjFTAX84wCkQEL5aOiEKKVFICqIS8ZBJwoRaGXUjv/126tD7h1Jvy2+Dirfp5NsgNeoanFxHqqN6eBGc8mQSVIAHAGYxN2XXRfBYjP2o8Vw5l1pBbaB2UJeSldd7qMeIFR/VCQ0HqB7xvHQ4L43yoPeG0qgWwdPnOePx06XZ/LQlm47ifYmwk420CZh7zOhf0jxgRv/UPYYyDyGBke4xp7PnyQaMvZvZypS6n9ui227CF3yLptXp0W8JdiZG0ASbSI4v837TX446JI+xo26AslH/yf0knxnHnw4l8R9+EI1/FZE6oa7V2akyagGW1jK+QbyF8IQQbAAwwmyoWgcz0XHY0ZTJokfEidtrJmIMDe7JB/fPaVv9wPJjH391PH72qni8sKLhgsFzA0XE3lUUQH2LTQV0/O9uWjS5MDF5U+Na+asVJtFs9hYHFl59b+emX2wKRXYet2uLi4vB32DvEm9N/OL0g5tNwQK3YKc3BxotgwKxv/3T0oiN2tvTbFhkmW0BwecpXNSo1UhB+HHAaitvCbXGpU0G1ixacexPpu4s6sFlVC01mdqCv0OOt8Uk8ovS4SgaKrWoOWykUg4bqhc6iepqs///ahY68cQrrz320Nvv0p/87UarxNYba6UqV0Wgwu5wSWuf2CBZy2ouOPbg/krfDYMP/a/aCjpT5jXP9IBHXtCc/9xGuf7pbZUDnJYu5Jy8xOkZhv5DY1TLHbdA/rklmufLwOf/u4bEa0tILiHrByUKG+eI9QO7dWT8Kewca0FBx1SKwhAxhNJ41Bo39iqKXJkXeYf7cOWp6/m5zGfk+Q0qx+jw5TW7VYtmdEyShgPpMYT1mMWE68dabdPBSfKVjMPQajQyYLuSgFePWYH9Y69EMb6TX6GLLYzDyOqVRLp37MrlfOOfpWwYUwfYMvA0uEIYt5IA1mEiCsVPUsTueiMy2dATkChLEGwUcbtoXFjeKkmc0V8eLeQ0Vo4ugOU3Jt65a3gecNvxB8GLkzG6iip7Y0fwSfIWHAkwo/Gm3bvrDRagcYGD902ZZRwckU8+WfjzY4qsCk8d4/awA5SOKkV1qERtT1scLB3WAongtwYJ5xFmPIphwiMkgUusBzB3AyDfPtFzpAm0NhvAV/KNC1i7w+KQ2+Q2tLGzC+QbvGIl+PeH1qJC24fg35UibD9Zp2sGE4daih8AqyaCqHynbPAFDX//uyHow1xJ3jiPqZLGyQ2dfJzKYO8miY8xlQPV9/kx4BtQsC/YC9NJSymrs7vTKXtAJ1pZymh2iyaeuWeQCkA2YIcJd0WpDiZ5SRiXwdrEsjlEo0k9QfDXAp9iAcya+XyqL4Wi6OZIqOOo9+F1POL0UgnnppPo7xiTzJgqhvqHWS7ouf9G/UWr/ZoYdlDW36G/njzrBt2TZ+H4WqtFuf89dEykVP4iJsejMj23jiKO8BnHvkcKR0wRIAtgRN2LZ8Y5Gx77kFjMRtUDAPtNZf7Bp8nm5roKONB+RXJuRR3SRusq1E1sdXxCV1nYQnad5BLmabKZSn576hYXyB9eHCovbZ3kKlhchxV3dIiuy6Vlk6vYUhAsa56lHlSw7pMkltOItPcgknSXUr3UNmqvyhCsrjzarQ7FJ5b4uITy5EU2G6MQxuBaaFDAzv9xOxoZAJ8Fy3EAPkScEdvUQAQm7xYg79bssIeCp05ReqdeqwUUfnn9CtPSQF4sLAsVCBz5UZvtC2Bxz3FfX1gofy4GbKB7XvqmL+QvVDgdIKJj8iMqYg6YaYPX5N0m/U/l1uCmYQ8E2lMU6QmAbCJ54bgDJH//BRgmB8yyBUT5czdQwHWA9IUNPWoBXC4CUQXckT//0oaKtOB8coH8E9t6hTSKyrvlfcMehseDHvSRDJF1zWbFr3OY5RuPZkL+UeLorsJCk7kUxEUfdl5NOZE04yQ/oLk4PKUiPC6O9ky2vTObape1TCgPTDWKBuO9RlbTD8Z33713DnBmLnDCqbHlTc1uu2NegaU4KFXOvT7gbqwuSxQVnGXW7NZ5jEDX2ntTRteG+Hv2YB6tfOQLhaY3M5HZ8DdLj5zdksoacMiVSGSosFEiqXDRKEBkWdgLkFQNY+lUiFlLDEtK4CukVqIfT5Z3ZMRDJFrRp8N0SI3hzr+9pxCE8W4YFIIgtswGgXcAn8Q/DJcmGWkCiIZHLIqV2Q3om5mG6xrA0f2E4tAEfNGIRAeiPgJ5EIm1QZ8tQEvA5iPuxEzmHYUVDhsSqROJ0pd8c8SpoWlAM0Bnuk2Wky88sx9Yr4Q2dJDWFFwFwO6nX4WfpmWaqZt51sy6pnGRKsG+3hWcu/68K2qmL+qK03+9//6hMq2B5rXQ6jx5PwgA8wMfMSGtQWso++gB+Sv5t/D+192FYqKvva2q1ReqCevdS4NFE3asql/e1Fje7OtW5iEW+5DRe1HdOr9f3djT143+/nX7e1pm6OF16z7nvCsmrVo9jTlz1d573V0JRtds4vr2xo5wN6kXQLrXxayCN0cFsQ+7HS/DkB4RIvMYXjlNgu40JT/CfWXSFwwlQ41pKtRmRmkapWmUJjh7TNQ/vXCIqhjnR1sGbZX1vvfJWNqrYGQR9GyMJ2vz85gUJhSty8UeY2IfNW6gGvjD/qgFY2RgQRcHMGcClgktEqaKseHmx1gbCgEQUhAWzxrXWdkRPM8L7Hr/xb1VLfMC4wLnzJ53vifoqQp2rzisDWqNAEJYHKQPr+gOVqHj58/vPgflmteS+Gs1YFngDFRU2htqusvnLAFPzsanLgrfHGaR2KGLNgQ7KjvHzVq8ZE55d02DvbIi4IQMhAAw1IhL1ZI0RD0jnqbKZUyScNlFyPdI8TZfhi2dOKCHKPx1kpV3yqum8ZTgJVOC184k5ffeIzCE6noDoN6T38PLBwRkESVOUcflb45j/1s6kfxAfsa5T3Gu3OcEUz5QhgwFv5Gg5KyVqX3Hj++D+Bd71yK5Zivxd23HMzu6YbY4WqB40fOo0fMKOaoCYT4f88BuDQIFBB2Y1uAQDWa9fNPxffFYz9nnPEPKO6o+u8+T0bg/R6dj3iJbeWf6+uP71t4HZ61Zt1GpQBR65JuS+45LPRG1Iq5hVTV2yDp0pQvfAm/RHXANz8/6SSs8SX7FzwF9nZLFKrCE8DKLRc4k5MSO5X9Lta/av21P1GwoNJije7btX9WuOLzABEwOXts27Wn6kTS14MFLL5rT6cKMba7OORdd+uACZWBU5SUqiw8RwLYAh8/iC47wfhi9PyJiSBX0sinUomhyOYk+v5zjJ53nBIoJL04StsXk8omYQU/ZoCNIeksBLwHRIPJdXnrmIDFRsTiSiDDnKb9dpN1oIvMOILmvK+dfHlRhHYNVONRpuGNtPIqRB9TPGselZR2kfehkkMDFQMWznP6hQWNgaDmhF05RG69TJr/dq7xNm6a0WBlLqdnosBhYqX7C+vqC5fuWC6BK0IMUzaCrWOWd98gps5YHPVDUr3U8snWITFW0t+9Bz8bqpmk+TYA31Dp13ukTJollFbhWvmK9CHsAr8V1Kznl5RS7ZGWubsCKpVcas/ARBB+kamRTuPzxWAk2PvUTQRU4b3p09hYrFOQkrzXoE0Z2vvxf8t9pTtAmLIYBnRns6uk+DuYBVrAyisQKkt/KNz7W3SNfZtYNMFr80qygYD7QJiQrSArQumX2s9dIGf8h7oSibwDah7mSyvHWh/5oH8G35k7cKz/6qLHQXf/gq/Kjr8p/wr+3MENrftLUXAYH0yydqPf6hqbQz+A/MGV2Z+fPhvvB4AGHCsZjdUjDymDVcyQaJd/UQ1+9VpLk10BEktZija5RksCLUh38wYhVzavxWRBB+eokfEWjkhm+e1p8deX56NFhFZDeoVXB3/OfD19Dj1Nuh24LIvJrpCD05JHPx6XCRVOK+RrKh6840/NBPJaJdlEg8LUjns9cnVcbKVdJMLIBgNICIwsLRhZgjHeQaX5tpiFGvoPKUfVSXsLIpeXPSCOMfGFwxxhtkCCxIxbSw+KoZ2FImoDERqJByRcGPpoNMn3moauq4Wr7C88bH7aDPgasq01fZJLr2WQy/dP0L+ijD6c//SgavUr+dDVYBb1PgHdOrrz7btJ/DacS3H+rGHI+LZR8PIvuK/niPiCxH8r/Hno/PXkKGFcEfgg+7hic2sg8Exqcioa3V+SvgB6svv6uu8BcMO5naluZeYWzY37et6qMQ9WAQ60UHoVD6wGOPLU5TwG1RTJWbksriGfAaumUMiqttWoYg37ZDnmzXCdv3rFMKzAaKxoxe+wajWl1+1c3KsJ24+TDbx+e3Kjs3PhV+2qTRmMHPYLIfEzGpqF+ud+ugdpl195//7XLtFA5aZXMq5fstsLLifR+j3/7ZOwNOXm7/x5yIH2hdfeS1WbJKirfP5EbAqM4trA/J2EiVZEECFsv482RenlVyUCl+8qZxAgWcILweT2DS46fLqeG27MUHZ9IKzmk25CXM9u9lJlS/05nE1EgbIFdjX0CZytEpWT5/6EzGEXgpwpk7dmg9UN8PZyXvbQiveeMlh2ynoJE9ySdwdMapTGO9J0e5UudrC8l7ZTCHqBjp2lvJjXmT9bnBeRwvUaVw3KG/fxyjPUDcmUAvx0rmc85zVNuKoqtrlnfF0y0SexEhCMBENkjBKtACWZxIMftjKicGM3QCBWXYfAjo/zMJ4LVYrz1fT0QjUmjFVzMrv3JJ/KHtwpanWh8FSw9wZMTOj0ozveMVCL6/Z+AKUZgRedFoH//VqPFarwVFH/yk7Us0OnIUf6EfO+rRlGnpV8b6S+Zs+FhnJN8BgwylBNyHqJLjGJJeBS7WBX7vF6z2WIahZyfvkmcJoKEJErBdDIoabToXcZORblX2JeJLIfepZbNzRZ4kFaWhGOobflwRgImK2EOuxUpCs3p5+XnwXrYhwZkzD2SPozG7T4xRl85tD24IbinflN//e5gkL4S7ezGO3uCTLP8fBpjreKr6nBufFUdvh5eO7QtiC7q34TybQjSB4LoIrSzO7hhWLsouv/IkOUxfFkVh1l6lF8t8V5VlhiGe6vm+Pfy+vawFYYz+HXhBcohsuZDK0huOYeuZD7vKRzIrtfLtYQWVclJ782nQEXjJCoRfZK9mCrEftblIAdWjr3BAzn6X/qkWJrCQVc2jcbQrzWDRKpUtLhAQmxFr9xN3xfEK6ai1ZTSw2QwWAySdruc9JK5DMnB6BkU7m1SZv1GdSXEVIIWH5EQY17s/pUqLXHLKXRTOeWyoEfKKUHfb9RqWUoShu6a5pXRfUGyOBSESX1KsErDZYGSPFkAhHOywKjP8Bhcq87ulf+pigNYJlqb/xY/g2tVWQDlUTLfKtE/yH+fuXGfQyO7TX2nDh47pRN4BdJ+WtoCVDIj02gfuRturqvvAW8JFvkDi1GwgIBFHoReeSA9QCeXFhbeXNhduBT2D2Nlfejmup568B9GfIlgxJekE9AL0LcpD8CepeiKmwsLl/ac7rsvwP61qt8lzxVnGIPiQFlAGNNr20vg4dOfKg0B7QdFt8EYHtHtewBSIsLjinA+0nIon8RaYFl+SXLlCOJYaW1m0CkCfoFVlijisTDEJMbK3iiEss9AD3op/Z5w6Y5fXHp2vU93v17gOTtd0Vf1wFWlBoMLhoY112MoPxoJerC5pD/ctqJn55rmJ/5ooLVOsHJHXXV/mYWFqWGNlRv/IXqzIuUh9hRgARY0eQPV83AYDRUO5MBBNzJFe/NcDEc5IIJUMglmpf90ikIa+QfESVHJDVeMmJJzeG4Y8apSxetQPhrUDCNHipGtxFwoOuSUNFGSUw7RUgqTpTerfp5G7PM5/M3RywLFcsLtBqniQCDtHeYUOmL8GlEmZbhQB4kzl8lSmk6WWkQHmiUmSiDh2H76MoF7AoFAMUi53XKiWP7d9y8T8VNW7L8xBzhjmRL4/gHlWb/Pt4WO6Nx35TWlBbdt+u80GYnJFfTrw3mOsSDzL1SmHjQiOeycCQh8wE+FsyJ1KJ5NxijC1o2EbmIuZTEIiCKEo4JyDiWJF54JxhTTho2N9JsB2qBnGaPkdKMXIH0q3922AjfQREi340KtbAdnD6xdqtdydDltNzKMyVrgLhb2vFQL3jZrdbSTdctOmgavmJCE4ISiXt49/pWLxZLiQpuZYY1Gw1+OGGyYpoVjWZaBgP1AMm42Sg3jRWGLIL4FKAd6vvEINs8CmqFpmNxkMAhbXMEOg8G0SW/avp9m0IUAsjyv6uP0EGqPtpxX7fCVfQXlBRsCcfgWR6iwOdVhTYFcV1dy6CHU5B2CKBnPXoFruuLrnz1zGKkI67RGo44t66mc3wtqSCDZG+BOUbgbvchr5etwzsOoi10sGS8VxD8e/cNuTYHuYj2AWrawZHnXu6JwqVGSL3tCATUGVN0pin4L6Q8rFZ71rIiJvRjbMPCTY7wC0YvXW+lwlQYb6rJrTZilW62GSiWJoYXot351RBQuN0oTd3V3FLAW0zrebNLCzXuDwdm7PMHuuli4cmb1xHFVBZbn75CMlwtiw4b2ZpGzGGZrTIKRdsRbF5atuMBSFpxeVR2t74lPCrrAils+cD2MW+NhbUVlxImedbkOQj1c5dIsmFVY6x/nsJnFgLtiXEPTtHEH3vQ8jmGiH+H8vjIzJ1oPmQCto8VAkWNBh6si7A5IotVRHWqdsEh9Z3vRO2vNyOAC4O0qU3CYCmedh+NZASaUkcMzoeDlwO7A1pq9ovCA4+0f3Q9KBJ3G9kuzVn4dY31s2neXXZ5P1tTuaPjP63DRaPL9fVJtOYq0wbK1gnjwceuj8q1mUTSAja9qjRcbpQVzRAGd2CwZL8N5UbJlrkhADZGogcqLpHVfQAXyV2FKst1NETlqMcIyUl8lkkbjaiTTzWy5Dmfl4JKHUKcgMYrAq2x/I/9Mo9GJv5B070pB3Tj+Zxrbzyw6rUb+1bukz/0B+JUtqgqYJgrrjNJ8Ueg1SnCi2WwW5YWhhc5FFnCvZBYs6eckY68gzpeM6wRRftIoqbz3it5RT3R13PExV0p+ybKdMffpZFPKqMZIe/twVFcf2Jh+SX4IfEsWLHnJeH/GRJ2xW0P3S/S6ly6SE+Auec9/nz/SkQ0duBGVfbsg5vEPaSgDknYK0Gh7HuoZUkCyWx11MSnuc/gi4QA+gJQg5YCiI9Kkx9ABWmGSprOlzY2HdOa9+KRhWztPZxcceGyrh7OPTAcAbAvI73vBXVcGJoMjM++ejY5s9MnvEvzud+7lnUec/A9P3I+2egvsfxPX52HfNXhz7mJWpzPvd7FngXVn8849Tn4lOHcZ69pv1unYJRtxluv8j6ExYz4oR+ozgxm+Hkomk2mkSsvvoB106Fgy6UW9NH2z0wl70a+gg71E1lZWlsEik9HglG8GvU7l12A0yQ+oGbB+W3+KYv6K2jFCTSWYQ3ZMfCIwvC0Q9YdtAYsffUZxJAVZIqGABTsoOmrj0YgthoFQPTRdV8X4CQhpbSuHd9DUgHZaOeZa8cbt24x8ZOa2i+fc2l12qzhVeql4Y63GzOmMXRvfTvhunVN666ydvS0nPBVTmhfVztJoGkMdNROqajzSlIKS5trO8gk82+SfWNEUKhHp5JNdhYevnHLO5Go7c2oQDFGnwFMRcAiA4o57ARj6Gn41xBc3nZ2+o6S+pMDAQfnHgGYNZpe/Cnzji/gcOg4A+TU0PWgER3GVgotBsCXUeEls5HewSsxg3pTMUHYB3CwI6QfqS6E3CxHhRergbwVB7hXs3tL6wYEM4oPC55G9byn6bqbiNnX4LBhUfniMttUunQGme+Q+exw9s9QudOQXpf6lsaAoRqaZEsGOi5x+PldajFmV9mZ1MyCMlcTypx/VaTeHUc5LqInUHFSjCKYGCvBoMgIKDlNGfVImHaJVsZjoKtYGMIUB9oLBLAYACR82nDEqYYaCcICP4K0UkZj7fzLVgKnwmPSXOvnnOqNBL6fwSlyK+LJgt5eO9NNgs0GLSdMM4l8vgHH5Ws6kF7S2b96SB6ZX/6t6uvzh5I/v/pjp/V21mbECv2HQkwGBMktWlkBvnOwXL/vkLGgRtVoa0Fv/sjj9uUbUQwh30Jf09R082NcHD6f7FNtPfr3rcL2DuXqzp603GFEz+jvb4XvU+45htZNO2wrZav9prFrLQ7nqMRePagIdkr92oP7rV3HTsF7WQHViDLngd7zi4SsGIx0hzrQPB8auMuPNX1nAqn6SdOQk2ZFJ5wQpsnOKIjvot2esWudBv//zDEllusvU35Sr/8hanr49Rq2gnGGfGVYB2Tt2a8D+EXUe1hq5dvJmq7JlrKYAW87cAKTPs6+rfb4dewQHiZGfWO5P3+eDVgztHQ6F44ocGg9gXkI16gl/ABjAAMkI2O0C85GwExc11bV2dtROTt95mkp/7qrv3j6ptcophk3mYGjeGjO0za7o+8HBc3fd65HL7weQ14itc1K7/tjWN21LV2zBWHWOt+44d06NWcNv5hnj9oWOwmvXrD/0HKzesgU8wjtZs8EoNi54Jr2FGlX3OPGGztX9u8e5EdWTvqs5vkfd38yv3y+/oyEYtfKDPxqr9kMjq8lGxmyPDG5kQl2HXZp564rDxsh1PxajDNp5O+ES43iMzQwIbS8xGxNIQgzHChVEX5sVk4JBHi8vUSGXOxh0u0L9IZdMbLzA6wox/XETXWWxmMLaxsRlJV2WibcvnLEr4AqVFDh7azp8okur5fWFVslV1VntM2mBJIm0oGGAbeYWYrVB94TubAAH+l3QVuHtaqlvaQhumtQFi92ucgCCLnhJQRDCLYmFPrE5WBauaLZKtuLa0maPM9RV4eecVmGLuuaPxv0EiTFzqziM2Zc3UoMP2m1EG4YO7ARD4Iwx+S9UaIzVJsHt0URjDjXyx1tP1xDr42DzTPlvjEagRdEKtCZfdWeVS7IW6nmt1iX6Omp6nQUlIVdg14yFt0+0dJVclmjUhk0WSxVNZ1oi/RelDUh7PNyyaOYWwerkgqUzQk5Pc2ltsU2yNleEy4LNom9hYguEwQJ4iSsIQLnLXQy7Jm0KNqCG6/JiFPrMWoaW2JHKqRbUGqupi6mrqDupR6lfEF4T7BmPV8kiGFotiARG9H+URX+qES+iLt9bWNVHCGXB4iNeZbBZMywxaEAkTrBFIGCzotx1sTrMaYSDNGpBHaGl83kJOqkKfukl/QyJ93w4QMAwbRFMdEo8tpC4pCzcYSAOi1qOgFqOUQt4NxVZzGZL0dMTJ6Zf6J42E/ykPRz0abmJAAhWO2jjDeMCvvZ2b8k4Az8IaYM7Wldksxatddsu8zs5IF+SSECbpJtYfoX8d/mzKyom6KxW3YTy/TC0vxyl08azpkeiM3mvJqCfBny2opqI22ZzR2qKbE+0txM463ZOj+4Ovs5f4PnkjlrzgPmoPxL562R5Mbh/8h75utLKQksQ+OV/OqGpGDg3HqqzlY0rAZ/dVVpme1JbJNjF0pC76ZImdyhU1NA1IeICBpuerr89Erm9Lk3/ZG5FE2sysU0VC489Mq+8Gaeby+fRTaD0l790LHWsi//6gr2NRejaRrJxN4Mt8l+KzdAJzPLvg6K7EmiGr+GirwONl38h8bKZ/rGEWkXtpvZTt1EPEz0doxSid80ioaeuNhjBeLqWiG+M15J5eVHUO6Lk5QWjAdJhWkBk1IuNY4YbP9qtJQy4POclXQRDhqNe4SU9BERodHcMnhyRMn1P6We47wXH6KH0K2GH3e4IgzlnnTXUuEF+af1q4F282OMWabBYY6gaHwPHtJZYbfnixZXjYxYtmLMEDWtVj7nD7R3hwqLwpKlIUYHp/gUL4BsuYVHj02nX042LjS6UbnoKfkzSQ661F64WqoOFfVPAk4WhjvZQYWGovSNUCGYtidZWGTVLAC26PaDkP9vtoNLeUVXVcXj58vSvwOfyD8pstBecI19Y4wy2LH+h01Ufey+9fnw87p5rjOhKJi1cNysYiQRnHUObqNutpX/x1qRJb01OL/x0W1M3Z7Nx3U2bPsdp3mrlUZoR5M3yP4Bp2oF18+RvJz88G10d6n64G99kjmyMtwadEXBAvs4H7eVgt+JLiXlz/01JOPofcIoGHZdqwxmFGa8K2zKLMiAG8EE4X/e1O/SFzapLA3CXQa91fFHqol/W69Nfgm69Tmf/oswpHxMhKAj/w06vEeVpVX7MW4BeoclUCVabbUNngfQtVoupEp7npa+pzIzRytgkZflF8HoPtiDYaM6BvbDigBwBdkD2YmGAxHDHKOPLHlvx06KG1+x+XqvVmJ8plug4b3nWI8lrkLpt9T4t8hqtPARu0fx+2CI1DT7w6w2W3wL5h4JgLKFnGwLpMJR9AaRgg/cB/E/zFaMxaygdTzH/RqlOsoYv1TLFAIPeK2z2RQBTc5qAgPQEX6ikGiozCerZLSBE+OZbuUgM/gp8JBc+8wBo6OwEXsHn9HoETgqjUgIg8SWCIHi8Th8aIQblK96Q3xhfU1ISnOAcnUPwgkFw88k0WKdlGZrmdGaHiStYGk9cN670iuuuiy9GE7LDpONoWsIs1Qyr8xaMOm/G50VKwcHiUuwBYlvFDMjFaFhgbMAW5qMg6kD/4jatASnsn8s/ku1shWxH+rjjerAAALAwPRsskEX5x2wVmCM75AfBQvCJ/GNZpFvkN+Q/gzb5o3Pk3xM+9uA5PaAQs6XJHzG/lf8svwkE+Z/yP+SfgyJ6j/xz+Z9gPBLe9Whc+or4mOjRyKSUB+M/ByzoLxhneUxJiv9owGux5xurHby7n72zf2iOjzb50ova4Tvt6f9eC9eufQ98kJQD6Udpbw8YSCdhsuKO+26HrkPysevgk7vSp3bRu9IX98BLTt515MgYvhezqHU5L5cMGG0G57bEH0JyEZaOaLuVU/qAh47V2rH0BOKtdIig2GI5gqbMeeOcOTfMZdw0vB/LT3/8MZgK5sS6YrEueYpw5dQL5xfVdln1Jha3HGvSW7tqi+ZfOPXK05+C57G6j95cJMcWvfmRjiVp8DJOQztx6AD3Kk/5mDwklvyetx1+Sj5v9P1Jeth3bSI4HyP9ZSLZyNdMtAqhOlK+NHDrRY9cdNEj8BGyyfAYKV/g0AP4mPov/zkQzV6YB1zysREtiMR9w1y1qF/L58HYcjkqR5f3Qh0YHImUcEh+fQA+lp7RD2rGik/uZi9h70H6BI6ubMd9Adi5MI4ziqF3V4XJctFLRG9TQu+5hEW9ATtOI2lRIvEQSIak0fzVBpC44wGcxBHchSA6zOAzmDMjXsJi3w+6WrM9Gi4qDJV0xjcKL65sm04z1y9dsvMj69SKGvkD+bPyqoToWRpv/uj9tujSBRqTsaJkwRsvrKuaMidhLfBy4h9hfMDGmZ9wzWcryn1D8q3fHDLZjCwPtQGbS0sX+etLPLuPg11g3G3NZgDva+vyWubMsYiGJsuGLRWFF05aktRoboY73QGtprqG1/ldhQEtX1So0QSGRNea9k7r+GraorH6o4Ge583aG27g/PX00/fLTk9doWVPyL3JUDTOXaetfWnXQ1NdlR6PSV8lBhdWdVlbCQ6s8q40ZLRvRDo5YbcOESriWJyEs5NQfQm3Dx4zsfKBRlWpLhYKo4/GBAiHIW7YGOZTYDleaWsPjY4zWFcRRwmG3XNKykF5eN40zaJ9fTSMV06+9klre7jitgcrQu02Y5Xf8+JbvpLaej1rukvuvdvAukzVd3z7mN9julxrKd/0W/kf+5aHyiOMxl7CAQ0nGtc/BugnnMXFzHhQOsyad2t5ld26XnTEWiaeZ1jaXrPIWjwHNNpcHGu1cnyBVXLySLFg+YI0zYcLmL4+znBr/Wx31SppQh/8VdQe97W5DX6Tdbyn46qXS9g6q1/fbS1cYrSGbEAPakfMQ4DqwDFgqFn92B6Ih5UqGkliUdSfCMKgz+azWD2oBelHuh2PLO49tmmm74GpWzrGW1nAM/8NZsiPGr3t42e+8VmgFcD6pRdc0Ai977oWLtu4sJLl5UVD6ZOeuqgHwHw7v8IgG0ZTWxWMWnxR7NCBBj4eCYT4Wa1glC10U2tFU0ldgQ6AU9RxDWALoms69pYvvG3VpMvB3fntN/0pO3CUjnOAa34BJusqFvQuKLhPXt6wrW8CBOOZ6uG2UPpUAqZR3TFqj31slR5+ZTbKd+uMgk6+w6jRWlW8QKS0meWkTgeSZkliiM1iMONTQsE0m8L3VP1WsrDJcTVIDKaz97GZjWA5vjtYZWQkaZA4cDMDITNAN5eTZuUdJQDNU3Sa3DODgp/BwHco4Bk8hUswolBwYPgzVgqkBoofMqC5lHpPxS49HD0fs+qkcBFGlApeipriTkGTXwXUQFl//M2oPUMk6lFV57CwHvDTMKpK21hmJxqfwhEKMtyqCtGdw2pnN4fnXZKsWbJgQsvs2ZGbb7x+8+ajU9f3+itXrp2yY3ld3azAhAPyh0Wetlgs2E5Pn/YIoNEMM2H37ue9Xp8f7bD//OjQQY/H759QkmiPLN980YvMzpbp09tiop678ZwN42gzzRiy/vwEi1yRDihgCVoIm5O6hT9KL8B/XHJoO3btgmJ6+3JYCf8rfS6MpncMfb4b3kifN/QxvAO7dSu4s+weMt8XIkl0BtKBKKo2RuYnRt2yyiymdG4FypIEVLZgdZcsLoSJjRAHWmLveuzJWozdGHCgOE++DPXDqLWDD7wOh9cOjnvtdq9jaLCsuWlBczMzK1E5vXlB84Hm8rJmMK0qAX+8ITm0KnnOFN5g5KeueHvFVN5o4MFhfL65rLyZKXLg+yj/3mguk+eUNzeXgx+XNUvptVWJP+O9Pyu/iSp4K7gx/sL27S/ELzXynGFfWdk+A8cb0zdmripvakLzKJa7viWcGybKDzRIFQiCCOgE/yB4KgFM6VTr4EI8qhQI4XGH5/D43Uo3gxAS4LHAo8g7eJkEncSSD5npQjF1OQUP8mjUj8fqougw57AGqlA3xsT0HOZAwpohTwKgHLV2jgSvkimWxmM/jacEoHCcoFkipMwIaPrEwSMCXrHB3oZWAZIh0Y6z4PdASkm8K8nVHmiLoRkGDVjoahLIjzMQA24Mz0GRVqRw4ALZ7I5ankO6L64So0xV4To05/tx0mFFF9dhYS4gYLEfTfv4DrUx4IG4OIBAs9AEvAgNk2GlKfADcCNg6RBESRFx4WjeihqSlBCvu5HVuBA+SdbhUL3jyvwYIWA2vJrXTiRPclvURrhZ1RurLe1h4U16LcNK7FLGpHNqaPk2pAXQNK/TMhYGQAggPT/O8DQNeaAFumkBp2+hTx8uNgG91iYajUDwF9gZxqoPm5o4DWcvCBbq9CKSKiwFdvMGEWjHFdDAX+gugkBr4XUco+ctAFidFisAdq0mDIysTrDr3PbqOCxze1mtnqW1BmuntsJVEEPTgrmgzBLy+9x2I4Qcp+eNdOGsmN1WZqeBp8goOmZpIOA0Ni8DOYaFsKSKLWWsD2jNdLFHUyZUhRkjB2irruqCyyocegNEz+RstANCC7SbSkD7zPRdtJ7TQlpH03oa3AO1Fo7VshykhTJRq39cZ6A5hqEFRgNjrJE2abUsDYEOMoxG0ACzAONWO+SdjqArpAmtKLSsDYkOnd9TsUDqslZMKYkUFt2bkBIl5U5W5wcADeE6YYHF47RFvRG/1ihCA8sAP037rZcEnKsnOMrLadGqu3B8R6WeQYOf6OE1QXvIep5gYGBdd3hCtK+kYRKL5IRV8cUmJG7odW53zC+6Ra0A7SHRbJV09WeVNrV0Rsfrw16fjxaAYHKZ3cwaIAHOgHZNtN7IyXOAxsKyGj1qXx2twS8cyreKTlOB21yk8/Pl7PjzrNa2u7eVQqZyZ1W4uVg0gNY5nhK7bYJfQ3sAqK0D9MQCycQzCdZTatPSmj0mpEDyDRMBaCg2VRRDWq8FRZLdA8pKGJNgcADBxWocJj2AFmDQWrQCh0pCc8WMxCAJlGFMDgAMZsmkZbSQZRmO5oHQ7DLoW4u1NF/QNr6jiHugQVyrcdqK2woLJQCYCWsMXsZxudZUVUqbmmqqnB0aswayWr7ObJoa0nBVBe1I3Za2eW3rF7vEoFdPl1lcEGpZYLL+QsPTDK3jeADNcQaIA3qLBjAMYNw0Cz+FnAaagNHIMUaWo1G7AebkS4YCh91usRpFRprmNvOitsiOejJ6S4XeAgCajahnGyx6x0K9eXywRGtgdKLf3+mzsrTRVMY5DXa9qUOwaLkCDecVaK6ibkLY8tO6aX6t02wvwnTea2Md1mvrNr141q5yGyhylx3pWLFj8/qmNxfWTCmF0B9Era6RDEVsUJgXn7x7whTWVxMoQNUq0OunTTEURzxuvUmNj8eymEB5kRxdRdVSrdQC7FUUDNEBbPTHHGN0KMz48CztUOiA0ViCBgovG+LxIAf8fIzF8zvaYaRQGF9FRpNWUOthHLFhEQRlKyE0x27Yc0XA9PSn+1psXvnX8mGwqLv2+gO7QkFGXHfBRQdSXlBFv//WrxaO23jD0D/QpA5nPfNN16xLt07aOaXZ9BF9CGit7dN3TyrAqxAlMyZ3NEfLPbqdI/SwEnwlZ5ux8JoZ+sPw+prWZbxw0YeLF9+2vEMwAvY379w34Z83fdFc/MXH0/9CnwvAdfdKP3rbNSnWbJP9f30UGAoSDZ2F0TLWiboXjbQDFr40Fh6j2n6t1HKsf1TR1QBzJ0dqPbTie4WZiCGOhy0GhFsex83SGTtKK1SItzjCNKugz2GpKIYJGUWMPcfcGG5cNKOm11NYJpoOlneUllS4qhs2PdTTkdzYHpq2oPnQWXZv94TI7Jqy2qLayH8/2PmDjRPBhg+P7O2d0XmtPPjcRnO3ugNYvAPeq50bq3DqnTxvNrssM5w+vzNRGV9cVdy2sbNlSXNQKLEL1tJwxFtZ6W2uXHppcPL2g0c+7DZvfA6w13bO6N2r7MiDeIfo5xVId3iFxLK0UR0k4ipjD4kTfPJaQlMcyrNyxuKcDruUEAdfgAntsvCpdMwF6L8G2UJbut5RzIGAw+P7wu6hnUam2Cb/Dq9Gg7NE/8emGa0Mx9ndtT75H0atRl5u7zTEu+bQF6xI2O9kWmcwM3/h8Putg4+hB/S4TEWmvS02dG1ZUdD9eae8W/6VxW6rsFt1WtldwGvtXeze+Iq+vqFPLaABXEqNWHdQNJVRnppnwDjFdmkiM4MB1WKb3esPuU4SkwyLflMMsfcOUYSYHBJLLrHn0kIuUygTV4b9rwYI/6NihQrTAZtkJ35Mw8hZ6uJSNECrbG0k9hvJ8pmYH5aqL40U/bnya23IlZpY1V81MeUKab+u/HNRpLTeDKjOdSC5rhNQZrnn0v+49NL/AAOl9eVg/j55jUl0heQvqyZOrALmkEs0gdv2yUfL60uLnCC5YYOcdNI9+IJLlbIyuKxB4omrCruB02yVNsvis1H13fWJiUsnkj+U3tQNk92b5AFSGjohKzx5PUObSEnelMfjLX1QJhh/oL970ybwWq4cynu0YVbBIOqSoXAow2qHF9vsjpL8BR4WLDdbiqpLF7Q4S5qbSpwtC8ZVFVnMzKIRA8yn4D37tJ5iF5JXSksL/cBV3DPNfs0YY0QF0i/eZk+hftSJV/4IYRsaEGpbQRANKzjOLRwkMdYscQsOhrALJ5Yz40HiI8zGCdk8wfBhiSOuw86mltz2zqfv3LZE2YCNjFl+32gS5Pcf13l1j8vvCyaj/L6ZYbWPP65lGTMoQSdByeNav/ZxUIJOghL1JNTnboM2URPbI79u1um45d8Yjd8s53Q6M6jtYU0WwzffGM3oLKhVzhoMyln5dXTWbPzmG4Oq+/2UvZgSUQ+lgnhcw8MaR0bASG1JkGPUoU6MlRBJGUN8YMdhIokzn8fqn5Rffrz316fWHv1s70E0X4aWy5cN3I4pZre+AMRbKiyib8GSQydvOP+8ccUC/wmqTezJ1H3N8o/f3fvZ0bW7fvnKv3a+DgpvvwU4Xt3NwXHjime+sfWGk4ciYrFQqmCbcSnVpl2uejASc75vlB//qNiWRB6aBlyb/wWjMyfJGQ7zYP1Qgf+jhgjSB7HCgh/mcDgIjof3VD/Xw6aoidgbjCL8DrzDbiXdAI2L6LPwV8HqDPViG1BJH5qAJYy/j2KCEKQCBAEfBhLgekKugfY3JUmMiS+y1sTEleOTkTWdTYLpKWuhU5Joy8uNCtzHMSlUJx2ju45JdSHp2IBLnpxOPgt0z8Kz6kJHd5yQ6iRJeoE1j/O6MDicOxw2Cm/YzGLU+uct/bhiIeVC5Tby7yB12bPPog/81CkK8LuZKdRlxGcQr6fhpUusWUCk6rFcCM2NNBr1HVZCgYGXffARpGYR4BwksuA5Ev966Np4K0OwI4jChXsK0mmsBA+GrIrj1TzF/gEdQaTD8Lsdx5zjSj3FvFTlZ8DVtTTPa8pCpyhnwmr1dDdMcNI6p2QCPMOIga1TDm9e5izQBc7pvbqZoxlTGRANdpY1a6x1JnNRrLy00Ag5UatjocBzBc1G0WyP/secqNUt8BAJ9JxF0Ij+stZgczWDRHLIWXXAG67l6G8SH3ujkbIGdxkSaeGlZ7GmkKeAYa0Gg23BpGoNYJ2BSeWmAo6VaGbchHanU1d6TT/grjbbWU5CsiZD6221GwqLmhfVFLJAU9LY21k60Wjwa6Fd0rsgMLCWYl9j3eKQvtVfXayFjKt8SWvvhToTBh+hAWRNWsIV/CPua3Y6pSMjXjU1n1pPXYy+xqxOjGdjkkT6pyOD94kaNVgFSniOwR9iPFYSRHovGhVxbK2IdrE66MFOa9gojz5bolpCD1ABQ2NIu1RUyiA5Rg6hE1hlxyo6vAebfmfa7GLH7G0arVEo4i0ewfNE5Z82bphdXX2ib+MKpCP2y6cO/VH+vaDtB+DQH0EQhKYd/Lmclj+W//udvVcmHwSLp02oZDjBxHFX/qaqshKygs7QsLRj27wCSVPuQAWzLmpzljGsy9kM5i+MhLW1MZemsKS19aGFheMNxYW7/jnkn2wSXD7/JK/7NqObZfXGYoHVL1/bU+J/ZsWype6iJ5p7bpgsOD47pGyu6bj20t7W9h1PnbMVMMkHfzAtcZ1gQL0ANrW0bTUKetShGtfDFct31aOnozK09RjR053jWOOsnvRWt0usdc95vGNSVOSK66s51/R82WILpaUkzBdP+G2Rpu3Ba56Qx6TMJcDMo4HSYmdE5tyjLzx/9MAv/YFfyrelX33iflDCRJ94Nf0YKLnfv3z5wm8OHvyGbZHdQ/LZq94FzmfBpN+ky+S/vrsKHBkCf/H8Rn5WWetDssNOJKdtwGsvNBZVOYonKB9oLBYgNh8A9HHFcJrFabYYxKJVLNL7GQFpOGh4wmsjAv6QOZxkd3oXLe9dtXxWs9myWT7ypuRyScdA+dqSqcsXrVww17flpcu3tBVEXbx9SseKOQsSldzki1cuaIn47Cxj0Lin1NcJoUjnuc0lLGcVNTxSj4Tq2KIVl3TAcMvM+fO6miwWRy3nnN69Y9s14Cfd21q8tOAp0Ok+kr8FrlABeOe4IGqMFdP2zK22BmZ2VVzaD2hIW4rqp22dXGiRxjW1tdWYzDs7OeukaZs2X91R0Nl91qK5k2MmE7PUxTvaoo3F0DHz4jktHhF9PvT1V/COpqoQrEFiiw3JLn9jKeJJbiXxVUTCAorPPrD5LPgvaMswMjF/2zq7QR5KfzF7K/ObwbLM39bZ9MzZW4F74vwd8r+Accf8iWDyKeoUmIp+rmpvn7djR56ciRHKatT4oDFpTO2nCe5ikiqRaYZkUyEyffC7Ar3gNWPwmR79roCvYTKxWtbhbKz5ZKziacuKOUtxAXNUrJjJtP87CzugFhG0YWZUhZFVPvWdpR0lvytrprlijpTfR1kbqJDLalHCzixWHEP7HQFqKexbZVDDxgyhoRe/RzwYj7794lwcvngaxgDVnlv2XbwBanQ98H4nfYDq474MyeQ2KoYjQYk4hqWxuAPPrVQEC6UOMhrRCpBYnJCLYkuD5LP5cLSXRJ9a2yi/+ezt8te3nfiRZechwD+z553t0N14ijKaSy1fyKXOIN0DNcKC2MTlvR1BcL+83gx+VWr5CCx79bE/3Aa0tz8Bylovjf3xsmfkb/d+4NqS5APgA5+T1lsKIm3LJ046m5f/mEwG5IZhOrbC6xMLh2j0+njsPqksauKlUYcSm4XtCpI4yjvRoDv6X7MrQvP1zFWB8rDR69nbtN59jruuS99Qa2o2dfTc8af3Tw57n3t/y2nkf0k9De8/GPv1cwZ+mbPH2V73WPz38cdACLjBxcMsaCqeAyoj1n+tkFHUsKyDURuI5qczYVhIcClCch9ryyQsMUo9ySSfk4//rF8Q36U5ndbo+CSzFQV0EOwwuRzyDnVzHDDkKEz9TD7+nCjAVRMBpzMnHZopy7Kpk1irfGIba8V7Fy7LJOQCI7D+FHv65mK/Ayr6tE0NM1Iqkx2Mslax7xkPLiuslnI/UX57lBiUnjNGh4/KT+70XdHialysBuN4hgnjX7difYsqSnAVUGiNsY896i0+IsEQV1TAx9Hk5sCRvj6O9yPxFAigHNCRWjogYYhe4GEirC8EzznvziT6pPnGGTMaecmYSN55HrO47BLz4p2VlTsXmy8p46LR2R0dg/Ppr9/7omGTu1AecC2u7FlWdMcdRct6qha5gJcRqms7S8BLQ9ptoD+RqPY5C6DFaYEFTl91IsHbaVOkoqQiYqLt/FDJphLP+BvGy78JlY13OrFXKHgTDIA3sYcoY/QV2LoT6veBsUTmEP9k/LFiDVGxIiGlMpfMEDS0ATqXDKturEjDzCVVeDvUEFI8BoI0y37ROnfZQ/X8vKbqGaa4/HJcM6+5ussUv6XI1jI7XnH7+ttd9uY58Yo7osqJGIjFNPNx5ujdNnvz/OaKO9bf6xwaArH18svwm9ktZ/ua7re5mhbEKu/ru9fpwIl7otruFnTt/0fbd8BHVWX/v3vfe/Omtze9ZvqkJzOZmfROgJCEEHpooXcJIB1haGIDFaWoKFERG3YsKLpZ+1pQF7fgz4K7uLu2tRcgc/nf+95MCMj+dD///z8w7936yn23nHPPOd8TA2Vx6Qhyldg+i7lydDy/Z24PKZLIuz0hGV6RP1QTRy+WStHpuaBi/oV7NdmCJtUFOiJAl3ZkXwbSruxD6R6b6cBpvAxJpJpNBKrBQCUS+oTb430pNq2+flrhc4XKHHlpmK4Nlyay+3rDpVWBwsdDtEPt4C1Gg9HC4xANFL6a83VNzpwAh3wG0zr/oEFZq7KkQSlqIc4UZmaXl4YDw61ZS2yQl+lkROkFn3j4oHk4lZElCrYHLO7Ng6kR1FRqMUXxeAULQgEhkxZEP0GNuKdBeCe+P8kb9MX9xIW3aOKJqX2WN5mFNRB/W8jx8VgJlcXgpRoSkJ0gXm7iVJY/juNB4gMEx03rG8CiF//NSlmN1M60oM8Kcng1z785bL1SJ6E1yvaV96B/pdO4LPlcMPLlG4BirjzRzDBKiR735hok+RIw6zZ0z6XXTHn7oc8r+u4AC0DL19u3f40OoRvRIRICo0EnqPrkiis+QS+gA+gFEoLJO3f18VPApUDKhyodnaqzFF1Os9DjBHIgA0o9rwZS9BSS0rWZ1J5n5nWNSCgtvF3jUvrZ+cdSqyRsXhbT8eAL76B9s+CBe+fnwJLzbtwiPMypJ6/4BFRd8AyZtUdofz3RFwM6NugnY8SfMEoYo4Ex6wAfSARDMcbMVKOvT6Jr/vwHMOn4cfQpiH1GPxBIfXfDituB8Q3iojRp2J/acc1P+20Hgyeu3fMPF9uOatDqJSObnAc9azM65oLfKSUVpIoI8oDRl+7Cvhjw6KK6Ab9z2HFsJhile+neZLbjtNyRnQR4TUpm/lc4sk/hjAoJDvyMAxIKJUUEkLNUCt/43E+EJyUe7ZIZX9FJmWi7TugF3iR0lATPmiKJtL+tALG6NRo4Pq3jiXPJZBtPBDJ+vST/1jMH0Z/RfvTng4weVptKTEy76UwPo2RSl+aWSmrKy6FcpunVyOSwvLxOMRY9ZjIxXTib6YJH0IuDlg/C/0Hl4xwHtQVShHnDo95bZvqHDgqi4WoF/lODR4KDhgbfWjNHWiAFXQCgHvz+C88m2RtEnRbAEwEFH6QgkWdgNktvrqYTJFhMAO3oCarq3OxaVRidfXhSeSSvoWbb73MC13euLIzHSssdtb42+Q7YkKpSKOALg8BLIHy1RrPoS/xkVZ/e8OZYtTo0vfxy3c9pnzjsx8IaSgEPGWXifhceWf5olpnDTyEQeZjOohMemoJ/Uj6BHnrvVnTy6KpVR4HjVpD3l3fWPLnhf5LJ/9kwdsfkJo8EtcB/N1QdR/f3kgKgHDiOrvrDH1Zs/Aj9/NHGoiETOwKiXpk4TxC7Vy/VJkgjTEQ5MCgo0ZP9tYg/DdgcYdMUpylBgG2CId5MPHwL2KaYnqIlXNrQw4wPTDTij5VgbtA/YJbAs4OJGazVVqN/V2u1Er2kaNXKYokeHStpjsWawe9izSU4dKZphn/j4zWvksRA3PYBLxl0aIOvJNIUcEuA5aWXgYVz+cGsi4xHsFirqa7WaCWS4mLJu/hiuC91Bsg1SzqKm/ydEmDPD5TEmmORYtaIXuU6A03FvnKN3bn9tde2Z1k1Zc9ccEEcOh8HSyN4cyLzqdBO3nQ7kWYKZJrJxPaHEkLjBEMJM/l2/6GpRGv70C/1luj7VarYFzGVitWyOUdzWC1CBdUF+bX5oEM8/6UyN8e9+Ob4/SDfTeQuRcZndUzlzYtcebmVWTb263vv+1pidYPoefgTu/FF8TUlkpwcyS53QYFQM30enFPpbmO+C2Xl4avn5rB69L2kNasyxxVRWc2rH3hgtdWiKgYnL86XuPDsQxCZE2nwsX61FOEFRZUTJ2BjaUWVKsCFjKQDnacmOa3z0p5LHUH77qUdI5baDbwdXLmLnDorL71jKRhxIf9y2F49vHvRcPSJwW43rFzdsWRxO8CLqYOPf7R6ncHu4NfYHGvalywBD1zI1ZA56k4uyU4SnlvARRIfWjSx73deLzw0x3oyOeaEmMUEK0dV9j3y6BkwBAdSDz3c9wK4Fgw58+gjfZtewCl06XKiHpPa+9DPZx4FcnQ6t6IiFy64/9vvD15Rfjv68dEzpx4Gyqpy9G1ORUXOQH6F4H1QAeJmXHSPehH6mO1N1aKsSZtgLzgxaVPtwO/bA07A3k2TUFaqdhPjPF9hT4p/NinF/AP3aBm+j06wdg8IuDlkefBYgU8H8EpBG6MxnmBT4H8BHU4bGB7yRuoLMGQNuOnNN9/sgMbU52AIeook3AwNOGcwOgwGr2H+0ZcND+O8xehaXGYwPAxcb7yB/tbXcWfHfjGxPzhgfMkEbNQi4luIEthuYvMxIKRNA3lzugSx7YBC3CdGfsGIm1piuXZHTgz9kA7AdQ9fZuDNibFrj0XrL7v7kcuaG54+lqi6jDafp0TZmOzUAKMOjEhOIOdUMVA+R7eVT5GkNmcf5eFcHPX3PYWD4Ofz21dOZZ+VcW/i+XQjdYR6jTpKvU/9nfon9Sn1JfUV4UFdNFHQV0OugPURTVIX5wYmHA2KBiQliWqIpwfCogqaN4xIbJMlEc/7AkdtzlDYUJJG6SCCkhCZQAQbOXNCTZsTBVyoAOYQ1yuYLHXBGmA0Y+JOWiPqLBGFVcyl0eSC+IkEyi5h5oAITB2qhlE8NEkmH8WpMaMG1EDm5WFXTp9dl+uZUDmoaNVef16lPVQwfahcwsgkeZyb1dMSAAAn1dG+zVkhD6RhRQKPRP/uKuvMbofEiFxurUWnBv+QKoy8nWXMEo2Nu1Oms+o0TwBwl6nwusJEobwxl+2ozkvkGIxyizJCh/N9oIrVcWqJnJMxnMamL1Svm6ANN9Y4B0uVWVkmpemntY68bKtX7VPkSjmYPbzvkLo0T0fn/hQ6HJfZnWYrXLWmqhadKlo4FNxO+8qipQxnHF7nQIO6JPJ8JX/MLc+mVwFI/k2hC5tWTB1SOi9R5UrUaAN7HziycypkWBkb4JxKlzVg8thqsltwn5Br3c0mVVmVEdpik9bdZGBs3SatxkzPU5tUcoaFQJWlC5h0GhMd1tqe7Cn2e2mDRavn84basrS0WuV31zqs4TBUaP7MGqUaCSbgIc2AXJfHVmAfKZPlOwBegaZMMfpD5nxdGd+ikcXG3PVyLi2Ty/g4p+gbZct1xwtK2XwF7Vc+UoTe1gBOo5ByIBeqOHipQQeUqbUjlZJiAIQrizyuHo+xf1NmTJNNojbhZS2Y3g0h+rNkI1+wthTUmsVRJqjUcbiTCLrlcVBC0GuI+h2RxwBBmY0oIwhacYLGlyG91sdKcL8TumwizR8x17K8a0nzhlpWqtBwQOqdPy2SPTaXU+bxBnOs0OIstqllOjOtkahlWjWvsPsUUjkrN4NOuTnf5Ulu9NuHDh/XnVi6H8IWZ0NT2a7lq7NsbXWDDb7CLIcztvZt9Dl6G/3jT8lQRcewjkJe3eyrcvnzpBvK8g7mGv2jG0YmQhFebfIWYw7DIM9y0DTjsXPKzYVqjVyZZzFIOQNUMXJGQkONWqOTMEpQaMrPd4wcBcLl5WEAbpnZXWLQ1bXWAlA1tBrQ3oLslUf3o3/+bsHSV4CjZ/zdaxcPq3XKpQFD2OIYP+KWoLPNrrIMGrJ83f3UQOwtF14lO6mVeD7QQDUIZex5E0HMVZs5iQGTEzU0bcaEgldicNNcISwAiQIRRwiPf5NoRBoi2+kJMyHACumEm0hUXIA2SDiTYDlMtEU1dKgGVhOFGlyRKejZ7ap7YLS2e+joleMHmQrqlLsVgUBgTsC1+/bnlHuUgTnNAeeent2373Y15tmbOleOblmqHHU/PXvl6OYl6jHPNCp2C2Vce3rwP2dtobFlJpzVYitoUOKM5jlCxu17nA1PjVEsbRu9ErzVs8dVW2Bs6lw1eki3dsyDdco9isCcYIAUhHpyx+a55I74n6vh8FgNfrBV05oNhWd2jl41ebAjr1EoMid9Q1ftA6MVSxlz66WK0U82pJ83ndWQbxs2a5Xot0PEzBhEjaMmUFOo2dQ86krqTrKfEywUXNWFRGXOUFpDMREk06HEICpy4n+C0THRvcRjgciFBB1PUWWTFhQ0faRUQpCGJSKsOQQCOhaY6RCeds2A1eFPSG4hIMKI+yJCXWK6jQcX0Ami7FBJSCdotyR0bCQPZxp1cDswGwx5uVwj09AwwsK4aUmLcYNa1wils6QhF4SAtZktejkDJAFFeeEMKK9XyKwMA2mrg7aW1CovYxnVWzSnDLpcNrOaAbTHUOTndfC5mqvP/AyfSDUzx2c9PuOvs/KPoQJYhU7fFg9v3FHuGTX8mxqpXMo4PMzQBwZPuW60xh2Qg519p9WpAk7FEoVoDWZ/CyBmdCsYA3iN5qQyg5ONwdltUzSQgcw4yxN215Uy4IUKKdG7k7Mcx+gkOiihtVof9DG0HAClEUbK2MgIh6QEgmJwQqMya5S0WWPDw5BRK+GOv+ekbvoXI/00FXfD692pf7kvqaMrngJrT+tUPfUjrcq2Ak6Gpw49DBQ7/ZwOM9LJM3/4UfKdCkAmLgMS1q8GyZcvmW9EkwV74wz2ArHpG0yNxT1hBbWV2k3dTT1J9fbv9PQ7h2XPhywn9APx7WQ850ZPxGPX/Ur8/3d5XgQW8+hAFtnPTJIDe6K8ade8vp76yaVh2BPucuxxhFNZAtDRfzwA6v8uv6snXJpKMsnJ9ee8K9/pXT4oRc3bNbleQoVLw/gxusJnkv3VgPpiQXTR1P+mANgOqNJwD6KIN2+iQy+h0rKbGmo4ngMWUesFD4IPUb+j3qI+wpTYWaABblAIai6y49fvJFFsd91/Gaf/y+/5W/rHhUA+/7fX+3/5fKygrHJG1FLpPed24H8/JH9rwXMHSA3wTPSbawHqv7+ThAraTgn7XBJ8RAMgZ7/9teCj/cGLQyBdPHhGwEwRDvC/qNb3X5Q9D4YJ85q1Z7VML9uFR0mI7BheoFRHZJ0ZZSGzyZCxMmX2o/fTunXofYfDOdxxEnSfdLQ7HKhHVLB7H73f96qgWpdESUG1rhT4SQHHyZOkwieibh2b9r1M9lOcgtRoBJF/iXwPph0JXwJEXzEgvYSyEUZPLCrw7Ofz4gziNCYwoDTBBgkIvmFEcgrTZ8rguKqWtZX42LqmEt03qrVlU5NwAFctB/qnvDX1uY1f1dSnmp/svvttMKRqXLByTSs5rgUzWkc1bWohByZcOb9t6d6h5HhL6lj78kV7m9tXLLq18AX06dKCKqeic/yOMcceXH6sbX5l8y1L8XHo3qVzVrQ37120vL351kXE/uosBYkvcKOIucib0sbu4sPjZ4e9S6bkQ7+t1+aH+VOWjN51367R9NfXvxToe13QBIsFXro++d2tt353DlMkY3fkxlQ80LGhfKAiH1FEUk1jhQibqJhqScJkKlkLn041pZrY0353qtZR70jVuv0FQdhryjPB3mDBJDAJrv10MUIIpihfpQ4ltVqQ1FX6aCpcrwaUVHqWUteLUHn4/lLRj8k5q2icxQaE52BB+hzKxMlzsWTHF9OsYiD9gAHhgJ9SWHzxAQpOhGrBjWgBWsC+OyCSJ4YPo8FoMHsq6EG11lorqmVoyKaDnmCuDzyKf73muBn0+nLBo/6crl5Qvr/7gQceSG3LhFbeBeT7u5999tlUFeryV2tPqNUnIP4jZ221H/QEa7VPg+vwsVcu79XWBlH309paUaaCpBQL8XvLcLsHqQKqjuzWGj00QTYN0pjCi0KPFzM/lNgjOY/BFPBEYiU+T8xDeHWfJ0A8j+EcocPSPg9XigA429fZLQF79Adqlus+mIEO/zkF2KNXvTkTpi5ZeiYOwm++gv4IrG0TnkN96HPYMfaKZTUHl1xaPHJJsil1K/PAWvTHuZ0vpJ6sTaA3gfQvbwP+ig+v1LkWrYrcfei5oa3X/cXRsG7C4x1ZB1YNWzOq3Jb+hpn9TBcVoPLwmwwW/PxcsBrywu4T2VsgGw20L4YpVUP6xOIynnjsHLoPgSaiI2YfHnq4UQZKwo6hbWDdsp5r54eaR7U+fOeKqYefXQvljUPALWDnhuT+2y5/s/oqxdDixQrENM0DNej350vB0PV9Xy5dfFtOSXfZ8Bwdev6pzsnokeOL52S1DJIbNj9ycOPW/b/zhsElq0vrgbw1w2txGZz7EEFn7fdaIOzBmjP6ZyFCmYMBCEUJA+UDwhxSiMeVoD5DgGwpScG1r1177WupbTvm2O1zWuvc7j0txg5D1vLBc+i3H1u3/rHH1q97bBf64Qgapnx+86qnrf8AW4ZPVpkIxoDimSNAwbhJ/WvPPPf2DkmOe3dLa61b6pFWDqU/WvcYrv/oo+ufRT+i3294dM+lE8EDtxZBsPsZIEU/UOfxjlL8Pg1UaxoJgGyfUiI3KJgvx/FDx89thFVlGI9AJP2dOJq8fSCzvyy2CWEO31vSs3hxD9Je2lE62VpSULnSaolWdZgMHXSf+CUOGm6YMudmORi/69ixXTf+EX4s44dVo7+IH+in7a9u2zZj5jY6u2fxkuHti9GrB5aWFxkM+BqVKy0eFi4UP+ZNgyauvGZ237Gdu469cyN6DgRWgHdxOuqZsW3bq9u3EbTxs2MkX7FnKRXul/mYTx4moCbRXEAQvmIGymTHHDOtATTRbo0nQoBYGwHModE8aQEgoQMhnmglskTqxKlZLohTEnQgQRTX2Dim6k10owaiiXjsKziNzAvb8g7dUDO1yE0zz+kgJ/UNv0aSPKIs5vWDb5T+4xh339/KUqHC99AL/MeG9rCl2FdkKYK739UrTKqwv8rTpPD+E5St3f4+mrTb2zGoUqcDO91xpSIEFqHrTE66LGAvbfZP5JSwHG2ZOOT6uaOMRjDTVqnT11w2JvUZusnpoxmO3Q8WgXkPaE0m+tEadM0zSjDD7WCgwZRnjaOX0M5Am8/gNZnkenoIWPDClyPR1YYx42+e1KBSAdqu0VSJfaRWKvZ5sq/bcA4tgvfg1iJEJNefMtBw1JMxIM04EsHtR7qHmagwgBOTN0+evHkj/fN4aJGlKJkFsrSQhPTqru6e7j4KH7rU+k2THHPNd0yjqWl3mOc6Jm0C60ihyeAEmCnleWnKKkYphEn2JHG9mRSPmJ5L4tJ3Tl6/fjKatEm0q5WS6TZKVWA+vnUAr/a/PLCIs+xJe8Qy8xm7WXDu3dMpXNakTRd99KSIipckL3DqtPi4Mwa8N+MR0mBy0yTyErXk8WvF47mXOEHIrBPkVVCW0Exgo9gAfc8IUUwPZGEe5YTwfpSfDFRXBuuPbAIR92kJ8mb9R9GfMFEiFI/siaANRYDcb0W9Vr8coIgtyIMdnwjHl8gxSWDhk3zQ9hLYgY+fgB2dJUHdtqDV57MGt+mCOPeG/kOS5xGuEEQLhcOAucZI5VKNgi5MGjRJnOXTZtjxBE71DEjNElJ5nOoX9hP7SzOCez4wUDVttuv3aMvNOXYTm7V50d/u59W8o8v3JfrDTbuKfFbOtXoDML9jUVt9C8Lr0KMPv9Fjdme7Fc4tD+4D+bONvDP3zQvh55uy+KVeWa7BKbXPVti/CBu35aiiVp/Us1blA7pC89BhhVzA5c6RBhqrlNkTLhAGAdGXLf4mPKGGiV82juYwjx3CoQSf8DAUescCzIjN2+5Cx0ChBX0KzuAwyGfeST3tRlNd6CsXKISDXWCfC+hceOzp8O8aGcVcSqnxCks82ldSQ6hR1DRqOrUYc6TbqOuo26iDVC/1LvG2RXqplxiNkhkbR3EzkrblaIM54zwgRnYHvYXEtjdhJoo4sVCiBM/2tJkz+IT0KKbZz2W404o7OIJzZIDnDIJnJOIi2ZS4MCZGRLvwMkCTbLIG8kSMae6PYXrVxHPFQgzysXjaGF/AbxaoOpJACUIKWotJSJVcplargUpmAjkKpUqqlaqAXCGRqRUy2ZkvDAaohjodVI+z2aBUZjbLpMB2xGpVyKHRCOWKyWYzVKqMRpWyC8fVEpnBIJOowQb0kdEo57QQ80taTj6Z5xVSHMJxqWIaTjPwOKKSypTgypc1Gg1mCdRqjUEzXa3WmrRAqQRak+ZPar1NDyQSJZTLFFJODZlZB5b1/Vuld4zuegG4dLGyZQf2fwMVcrVanvrhG7mq5Bhs1kpZVqqVpJ4FnwM5p5BxKrAguU4mW5eUNb31ukz+2lsyPDI//+FLheLLH5Rs3/cq1fd9KvdnP2pl3I+fSWTIBBeizT9yCv2PYK1eMRzlfS9V8N+Dd3lFFpJ8azR+C07LVKqUDn6G4FdyjVrxFUAKtdqFDF8otFrFF+ALpVaLpP9U6fWqJcvgWloj41ipPnXjsrugXkVvMsu96FSv6QCVwSegBB/GdgGBlKKy/Ak81ZAd+ipg+t9jjABOLUZL4pAH74G9K46i21AXuu3oCrD3V+KHQQ+YdjQTP0pTY0bdJ+pj3Deq774BEZAzIMLk4FNSjOHTgP1cnrJRPmoyHjuX4rGzFc9Jv9yvM3M6D/GnLChbExEuEKRlZBNXwhnFPXMOCn77iD07INYhRrIHS2wOKmBEsL/Hr40PmLJQAyAx40mOmLzH8L+QgaNJ0RC5ioQN+siYLGGPOML9AMrJcJdjM1gpV6JXlGA6sTVLURB5ohXlN7i0aggkdUWX13xw/03jNSoLYOWMbPJotQyWJBr9FpVK4TYCs1IvI8bwygSyl4yODgUbNCr8OAJChRKs3boTmtiWqL3UBVdYLm0pUjPMZmGLLQPDHHY0oiucSlCmPK1nKGLQdpqCI2wurtiEmSsAgmGPpQKd5pSAkdvCs/NlGghHd1+xruOWSFhjLJRAmnWtGbQf2S2Xh8fRq3M6uQAdZhiA65pwe6Tmxu2YKG5YOGZRqcLiAIA6r5+J32jUb/s2vJEAGuPWj0XJ5joOC5B+tEQDfCUFxDUbAVYntJ0Ptzgdjf1qS89t2r8vydGQoQFLJ/ftb0Lvdk5nIWTw00vgdUuugyxgGAjZ6Z2/odno5PzUfPCJwaaVWmivDNnhzvnzUbPBZiTOdtksGfSkPpK5JUajzQCemP/Ldhj529qBmAL4CKgnkQZDN/CROC02hgDhRsQNhUCI8/SvNgLIB9Zhs1k5i1+agSxHz28BvsbeFxrQp82zGSWNexcjUcxrQR82Pvv8b2iGz+bNu53jpYyE4WTM7fPmAR2wzZ+/j+MZGl9HuQ+3ydfok4yOzMD3LxV0gX9rC2COUvTTjSkNguwIfDoycgnY4q+/cxYYPOnKlpyG4c01RR3ouomAXbGyxF1a7f5tL3i3xpzsGLHSzs9P/QlYgFLv6Rjv1lzsnXKoyG+ceXSeWMIMGFFdyvCrr8Ak+6hesvnR3tONadLf8NygF/X2kirJblKFIGdmnjWzL0OeN0E1CyjrMZ+Rjfmc6bPx19/BR8DFdUCwEBa0oON8LEqcJMI0GQ2TREmQ/OjK//XtkklEwW3zpdd/eL3UOD053OQ9Ivh6Y5ID/sCvvXEyiaeyd9CdduvIhQtHWu01oDWZtCGb4J+xX+d1wLcqo1oEbbbftE4YM14j+x03JOIE6FEbEpHVTFoBdSUUIV5BCwBJMQgpv945MZFDfEce2EQYg00HtOCQm9+wQRs3GFndjBk61qh/1m4YO1YfD0K+pISHvOG3zE4FUlPqBHElebewb3y3JjXYsg/s2WeU6HQx4xr0/BpjTKu50TCpbxIP/TFD2Y1lhphed5E+Hf2t4/TCvSE202oCGmY08utLoeCFGAlHegFpFrUM/QRkst+0jtHJTF2AjxC/fy95fyDvBHLZRb5/ghpG8JN+05tVE9tRQLTfiYWpYL7iMXG04LcIEFV3Yr6IqVxMKPBiWZIZ+vWP3yW1KaIKWvrEE1IaB2zSv6nxy6rVf7swHS1XaeBV0KSqSZ9/U4vgKwTxlb77Dl8hiK8E8nn8h45dmJ6S4CvS5NJyHOj7PQ5gnid0djd7HLcX0dDF5JEEio595JjrMdkI7ZQI9ntcx4OAqCQN3O5jj8+cWveHOwrbOxx1c2cs7RprB3bbuFWrh9+7fPsdbx969LlyztpQUad3l0ditX+8oxq+9LL5CvTt7bb8Il1sybUfAw5c8tZ7aDf66uWue78cAsKHe3841rtvPWCUoazZI8Z2Tp/w9F/SMn1OnNcklBxzU3rMmVoJNgAPdAE2EZKBQGbDGfNuOjaAaRSdIe1UjLAkIgv9VzgBPYoe//3v6SgOfYcebQVavHh9fTVoS93FvPl79DhQpe6io96+N415xr43vV46igM4ASxCl4DZH/k3bOh7H+w49NHlTzzxxKSPwGx0CfpqA4D+Q2AHuik39WG2OfWhSgW95mzozTZDL6bkPzRn8Frxi7Arcb8cK/ZJYdfO58mFgoSjH8CD6N3rcSYQmGeirZDBC3ex0fQuHpfRAfN5Ra9a0kVXfnE3o6HPDAaQve+LSyYq9y+b0joMhB47ACx3gtNv3LP2ytnaGmVDa6K1NZY3oq5u6IjFdavuvmfNtdMm1beUtDeX5Q6vqx/asahm9X2wr+CV1fs/BfJ/3nXJ0/FQ7tI7ym8+cjv64k6JBX29evt0w1B1XUM81pjT2NHRmHPtilXbpy6orY+WDRITtp1vfyBibxKrmgThP843GvBn4VeJmBMgESxJhCRaKgsfvSFOnxUXfMuyZjwBcyYDfO2Xqv+wF22+//mO+zqeP/PN8w7H852wHqwVE15Lu4qlZzzf2fm8Q0JdRFNY3Ukq4aqkwv1oc+o5IQEEPxYrS5+/X7ycsF+TJTnB/oWgQIBzCk56osxPEXyCrGqy5R+KmRi95MSV/0S9qAf1/vPK50H70Q/QB2m/trPQBx8cBe3Pw+TDJPPKf4Lah/8Eln7tPpmPev6xUXRju/EfoCv/pPtrtI3ohPN4Pvs3bsPpuKfH9YlIMR6FjKBMIhiwA2LmTjY1E8R8Iy5oAxGCkWQKAbVgFS8auxcwmOuJmopdUrM+rVvOS//6Eguk4dpSDzt0SGROa7VWG3Jo7Cq1PDs/R62aE2oz8CBkNNze4wnRjGm4wzE7r4Pn3V5DoWf8iMEmY+VQC5OVU5ytVqk5eTh/eHFjbpGDB/SH6JKzh9Ghz7fAXcfBajxCpNFZK/bsPDA4EtK6ddropiUzXE5rsccmkSzVNdnsRYuy3E8+XrDY6wkM1umWqoc4naW3HK7Ndxs8Om1s7Yq13bNHVul0KtrprY+0N8+as3EwSqEZ/7jxZ9Ah0j1CX1NiPjdMtVOTqAXUKupK6ibibyPoJ54T8H/M1HH4GNQmzBKOqF0TK0YuFk+E4glznOaIIZeEqO6YcRdMBENEa5t0S5KLjxF8AXwZPFGmi4XifkqLj6LuJa6QIFWEWqQrUAOMYRjROOY8NXh63tvotnnlzry6G9/X1aX+NtJkL5s2rczFd/hYafk8dNvbpXW692+sy1v9qVr9L3fD4bLOopKJJUWdZYcb3P9Sqz/11B+uGFeUtyCvaFzF4XqUU1dKigd9ZfNAF6OdVmY3jfT7OnhXmanMFyQ3Ka17B3QB1daT6EV0AL14cuvWk6ASdILKk49dZIDMqpe8ddBbHCm7J2+MEuoclSWeQ+DmQ57SUseM7oXoX96Db0nqgXJM3j1lETihPWdMTvvE1jsa9N/I5d/oG+5onSgkTWq5o1H/tVz+tb7xjhYYrIeKMTn3luaUeg6+lbofzTrkKal0zF7YPcNRWuoJenDGvTljFBDfGq+d5Mm2DnxauO9i2vnnZFkcpcVU3yBqLrWUaDcGDERKHI3Q6bMpEZP4Mmr3RoL+Tw4EXoSwHWQaFjiQUJyPCquGj9A3bEzEjY+YojEfSSNuBcj0GzX6cGVaEB6Jgpj4hS5QYdOk+dNm+ZtbW/3BA21lkcoxyyvygtmLw40tuSe62uzFxa2d8sDgKyG8kganXXial/lkc+lrmEo/oLWYe9O7S4O16NWiIcWRpmI4Y6BI7GR9TS3YOXpUZzRwmdO5ZExkjobWNcYsdGBWfoNPe6ShVs26LXlSzSXDLQ4ZmmpPgE0FZnMRWhmRrTJ2fAyXdRgs7sJlNIDHA/GKoAW+50/EA/5YfOQFGK8SqhHPQ0cEDGytsIe5gFpBvHr4vMS/Ak1WJBIgI0PwpC4gs7BGrccrqCbHCPMQS8vxzRHgI1r1oShRtQ8YBVSrmC4a8wqI/QSeH+dEjcRVmM6Q1vwW1z848q7bDu6uqKxYu3YFUPlztTvWhkP5g8eMGZyPdg5afUndEw01Q6Y8d01XxzTwxIcM8yEDJw2eXd0ZcUohZ5EYg12Sv0vu15SpR4+tSn3dVlbePryi3DRjzkx6YlXH9VvBm68p5bnZ6x8zS4Mhd7bZ6MofWYbetpbNb76rkskevdDBWO4dcfXhwr7n8sfDqZO9ngmpW8Y/8mIoXNk1rgJMYaDkuZa4L3vtcwy6YROjvnTs2PKKcdQv/FLLgI/GkwftA7roL+w9soG8+1aLIeeWlYCbCf9ynlK6AXyHu0LeRFCKeHSEvup837NlZynmFfyNnAJWkAgOxkEiASPbXkERuZGYpBALcQEbRoCdJNq7IrAQ2WQWwI+JYgUmQujmJcMro9Wxn/KB3cjiYaI2Bpsaw1WDtYt7wL/3ou9uq20wmlnWb4yWTX002dKSfPR5fCqRq4LZ8tpJe/+6/DagYgw9i30Nw9E2ZDF5oN2w7rvfPb6xsnOYL6d9cQEe2N/vVbMBfGdGla6OT1OXzDGEDWp+zfYVf907cS9eB/XpdZAgNacVZRMEWoRYbkvcRGudjGNgTFNVBIXSxxF4TbOI1pR2KSMo2uLeJjqWIfvpAlAMEVWIjRTTArXUpAI69eHLrj68ZUtxR2XE6zYoQUJPM61jQ36ZUWdUaAEmsiqGGkYmpJBha/8dWzqiViNV10qzH+jwNS4fVWdwKyoMjBzCopUqlpHqh2YDhqHN8D3eYyjXmqqVV4PcyvqEMV7e1jS9vZwd2aAuUQKWBUv+sCB3icaQZXRDwNw8yBAoyGEskql6E89CBoD8MK2xxQPhkBOaAISQVjxbTRuyGxgZiBcAPkN3VWM683kBJ9yDaeShAobsOaJ9oKgbXjwZ4CBD+oMwOENcwk9QRQiyHNFeMYugc1qBUjXBxkh2bn19bjZtjYbt+fn2cPSLYjEFHiwJkZRQCfrRHboXnbzT7PPYiqrtHbLUEPThC6D1pYdB2TG46MpliVd2NZICdwLHvbcDx/2MvCMSDYeiaIojL9/uyM8DX12YcB9zMzq1t62ZpuWMDq5/73Xgvhc47tz8aapm2Z/GPr4wsO1b4Pp227bvRPwSyVncNK60r2GBZw3QIkRSDPMMBDlLwHaQnPRIzlKsXa1TqFDFt3q3Ssab6a4zx9CyAA29kqQGrwg/WMKnKadWyh5Gx80M5zGASYyvb/od6uwwT/fKzuElnGV/wpxo1nl3BZm7pu8JeMDKwMD7pr5Bf9Y71TLehMIBmvZJkj70+genZ4F2egrynrv7X9Bho3D3F3+vzg4Z6F7jaTWb2/fSlXB939/Pm3dKhDmB0B/4y4m8bNSUVt0XNPrxVzVxmZlIgAsWPi57vkNb0XxfQq0+ik7uPYheW8gB6ZVyjZYb+u6KOc9eNWLEVc/OmXao6UrijhrV2oLhkGvjfMDfsBc4jqZOZ5T3TghKaLQDvUqwua7fLLdKr5JB+ZQ5uPrb+CqD669yhcJEl5B45t4wc9Hqo3tQvzZfV0Z/7Zz+ip3wFWqoFehwbQE4z5psI+oTKWuBBJ91P7j+AsEhS+HMgYXQk7+QDVbjez2P77UF05Np7TNhlsQzCBHTCWCERtpgdtFprm5giRBuN4I8DDJun/AIE7g3onVu5Iloz0PmIr4kVAAvXkK4rmRH3iP5eQ/nWWzevHKtBwBVIDUpqAIgoK2NhK2WwsMFufflmK3u7LjGQ7AvWalapqks8FssBYcLcu7NsVq9uaUaH65og89YcUWffkTUasWXzD2Ya7X68stxpldbWei3JDku2+p2MXK5cQXYapQzjNyItm03ySXA6bblcVyOxeVi5XLzyjI6ny6wR7whi0TOOIS8PJvLDiVy49Wo16igaYUR1F6NA+ZgOtMBWLn5qr4RK4xyDjpdtjwBY8hyNskg3MZ5afwIwfzknIK2rz9ElO9FO+F4NsG7QAFLhLFJaL91gdV/rc+2wOa7Ydq6+tpx41YtAhHwkdXPNgx11gKJVRE7k7T6/Vbm+TPV5Ay+VhaWr1q2/cDK5dkBv8BHkD5FDfA7QjSIG6jBmNoxemKBX2gKe2K80RcjZ/rCvAv3ynA54qYSdKEeKLjXSuO69fT1nDghoVJZJ84l0slzYVh74kRfD9khHQAiFwQ4Dqlksg//mPNyEDUwli4myrfTvumJNgXxHoLbkODs4Zkcr6MB0jmzcDqenVjMCbFxpnfLM8+gH5+BaM/EdTi4Zd1EMAcSuDcSRHsgBHMmQooUeWaL0nRoDMkac8ikFKvhkAUnnjdWA1SMovyiDWwcs0ymqLiVjJcaLuMcLyEYxP7ClI+lLhs3quobCL+pGjXussseXge/qR6JA+NGVn8D1z0MLhtIKqUeXle+UqvWrixf9zAuwmlXll328GVlK7XcuMvoEwPpJq6fd9Thb11NtVDjqBmYe6AoYdtX2OEVBBOJODATnD2NgIBwjpGLElz1iBvwwuZxWmvWhJfOgbG42HeF+TOUVl0RpOoitkuJCI1mgIMMRdYFB/LkBqtKkaP3bhhlpZ8q+L6R52vHE9xU9DcCyyrAqT5xey0f4xvPyJUq+QSZTG6Td8rfV1gUnXK5zC6bIMvSqwXgky71g3qHHv/fPYEUleNiNrmMvjlikOcdWGAtkrPhURu8CvBAwXeN+IK1tz9xbeYewEVwX8fX8nwjyEtXxFe2fyUcZULKM8K1e9K30usHZe6PnyiNS0DalqEM5MuDAEt74AVbQCBOzIB5czBkZgMJCZfgiVGwOcHynCmSCPEBOBW4gXshupX95R4Qs3DnrK9rLt/1VQx9jD6OfbVra/XXs3a6QNPVly77cdmlV4Mm+Pbbb6OHmeRFGNwzQ14/Q48/ARqUR1vW7tu3tuWoEj17Yjx95vXNYfTnQaHQIJATpgTfdWn/0BmbgqGC1xCyw3AH9Sh1hMwOGc/VaVfuF8TBr+QHMkpNvl8r+ev5nlgJywjADtUMXgFdjO6CIrp+x6FA9BIpuoo8F4S1F01OPe8IQhi0w7P/TS2QTCG0EW1MIV20fdtjQAWqgfLQtvao7lyZoB0l7cET/TrwA7yLoiUXS90RtG/YYA+m/osq4CqVfA4EM+UqXUnLsNbyQKC8dVhLCRp7rsQofEl84X65XxoXwSBo75SlccD65yWeIBoRQV8mQRAlRMygH9qN7Q/B3qAtaEN4Qj7FWeC/CLytGMUz+T0Wru84gToCWQTsNxNielM4PyUsFZCi55pTtbC3L4nSiwJeJCgzSKTdnZOjSOcKz+wkFKeBI9pCTAjgBSqorwFmQASRnHCW/E8ggBbt6rkTVRxGux4H89YW3tmzC1wXnNccQN2fgeuD85iK4Nwg6sZlCtcKRQ6Dl0iZ6wPN83Hdz8B1AUH2bz2rlPxT8NtnpMoFr0QDURAu4uvSxWLqJi7Ae8bNEResZvGo14vWdwlaEPun/SXwgvMFFzCn1wCjLhE30XPXP7oe/wc/ruscv379+M51H9cOP3PPyIrcCYMnRMc7RsNGu4Sx+bhFbI25MTg4OrSq+eVVZ0bNr182p20MA6QeDjBjh89ZVjd35JlV1pwQo6EnNzCfNkw2hnJox8gVK0aOWr58VPqMfoa3jB3aODE1xew1aXBN4JDQVtsEgppPSxRas9uyczb6+6HFvqzC6GLQBKAUoAeXRAqz/EsOAfvsnYESO5TT8Ikhs2YNSTVr7CWkzWbg9XBvWk5L8CRwzxLcien4BLHBNyaADng4In7l6eT10H399akzY0DTcUw0t6Gnjx9HSxYybagNPEp+KSmi7Wf+efw4c1+fArXh8+XAI/bh8WcBex+bwpxgLp612qiZZKaCpKkFIkrkggUAz5BEAxjBrjGI43gxIiIuQBbAUJAWwDnTfh4I5oXg5MZPvqCexVEWT9oSEW1VUKnBxWgWsMpQ/KxPxQCWqdwNKjTFVot9F128En2p8/FKVqrP8ameHZw3ymyly7h7owGb+r5CNavzFYHlr7dJHalOtqK8FF0utWeD1vKwjA7CW2inBr3cYAHmArXLBZovi8gcgaJdkuPr0fuqLKlsco7GqFTLmx9r4hUyefBkQhMaB73WSMvjjbDVqffKctGR+J8NaqMcGFuNEWOuDoTq7ZwJjphl0I2DY3z23EkauU+f+v2rIYO8RSOFmCApDIOZ99dLeJ35gzLBvl+U4yTPs32wUz5MtxKfNfjrCVSeToB5jJ33IzSssEno0Rm48yAdPDGGQkSSnxIsNVgKYaLp3A8TecGSoCR5mlKwr2Oarrv9VLK9G1Ck0llM3dGUUI/ql8cLv75aulcEEmZqz/R63EHmvTOCripTm8RVcygV92cBb8GN57YRmC5Lj1qjIeHFzEraiiZB9P0EIDAB/8rnJc6IBfIbry1COo8pGBxO44KdS2cM4R2XdVw2B7as37h+GK3fLW/74h9ftMl3U2cVyiv+tWf0/etnlEPdLvlmsBIkwcrN8l1IoXgMrUelaP1jCoVut/wZyEAbZJ6R71bdYMjKy8syrI3gv116lbx13LhWuUq/C2ilc6fnVVfn7dIr5Zt37NgsV+JEjezWfftulZGCT7/xxtOkINGCE+xmhH3MgVKpGmoYNZKaTs2n1uDBeYFPOOq/PBNsSBHVLhIfmDYQ6047QAd7II0LksOIXgR4XTgh8UQPGxi7aCI9rGVOC/6PMvUz5ngsPgpJr7eUnBYk5yw+xuaJtcl/8LpwQq8PjF00MZUE56T38KyY1SvAUov8BrpLSKOp0xQpJyFH4hHvLMV+JSG4eoOEfRDo8RGYPAIfIBhBkY3JCiC4vxEmEKJkIbp0MvhCmAmkhSZKZDTSMVH6ld40FnnzrEGWSUA2ZD1jtNAyn94vY4Obtsx+qHtWzKIANMMMv6mg/cPFV3d2ztDDkUCBjpuc9L/YfCcc411fNH8xvXrUStTosfHogMbmcRlLT3R/VBqA5tDcKbubaiQ0oCsem7/h044wBKBLmvpR7jGxv3MGbXz2fjKHh9JrrZzS4xk8TLgqM8V7IB3EzJ+Eg3Q8oef1JEUGtDTxbxMUdQ/04LCHB/IuVL/+a6XeQO8vbhn+SJg59vHnINeHqrIRxcyZ2YDet45geC2YbfSxS+kuG6ZdZ4HDoETrQ7e88jyIA8cHJ9FBcC06kuLRYngTHUr1onFoLSyCCpAP7FqrzYBmi7IRmWg3oqEslAPzOIIfeuCLEwliwszSuG9yTEBwC8RHAR3lfaxgKULAHYyiijBnipqIure4iR93gwBm4ehoImoyRy/sxdyTV6lLaEZJK09vLFfUou8hSADNHTrb8iFbHwJs4MCcA3DPoPY1ewHYURSsDI1pMpmbF228FV5TnFdc0BTXgN5knenHB33vspqbky0lPwvdSYqP0BvYLpNnyRMrQSiuGj4RNY9vWuFEEG5IrYMbtfblk2cNMfuNriyP4jovWDljXqPVazR5gFV6Szx1qMvUTD9/RrgYK/RNS3/bEGuJXCpK1WJOfxyeCWZTi6nV1F7qKeoV6hPqFFAAK27TStAMxoE14GqyC51xzoGZwyDUJyRQb47rYcikh5ywpx4T9tVANOYzRo0VMEZ8SxujMXM0QRtzQawCGKOhSDQRLykE3lwciUX9Jf1CfX/E7GPEuRjH4umQ1+wNeYOCNAVPs8WRmKDaWmw2moycg/iL90kCUSLJ8nKi92N81ZJoxAmEk9EcJVBMGTa7BuA7B0mGOSHu/Ar76JgdJc8fFzZ5ibdkH74MeQXiSDtj5UXyQuRO0XN3wVcxpTNDokmRcN0Lb3pehXRmJo/z+siWD9kNMAibkwnCGCeIcDUYIu0U/AW+z5TkTbOfvWLEiCuOzLkpuWnylDvXTZywfv2EiZM2Tpm8KXnTnCMk79nZN8GZnI6jnQwrkbC0hGGlkKYJKIrwBwEe7GdMJl5vMul5cFcl2wS2mjB9w+tPm/1ms38r0Zkk5cieO2CgUAmC00dcTmuWRu22aFwuj8vpcR1wOnU24mjEoXm0UG22mg1Kk8fmKlRZ3FaDyupxejZKVSq+qMjlcBQaZzqDIZfHpNYbvdxM/yaz0uVyyqUymT7kcfJqvU5vNut5rdrg8Bx1uTR2ZyjkdKi3mJVOJykmXe90akpDIYdT3UY0hiGhSCFDM5DEhCckTz174ABi7h+Nm2o2aZbR80EVqBw5HR1D706fDvJA/pr56AX0wjxSYs5sXKLvOE3rDCqVQaNSoTJIy1lAWkHF5gUtVj1vGZvlFgNWv5WcnIARngKK7UOUbskz4IcYjfMsFoN26zC/fxj5NTZoDeHqsMHilUBGrlFY1BaDhwR1arPOorZypip7dra9KrI97M4K8SaNR5kVwvVbfIyDwRW1FhWwBC1Ki/bqzKVWZ7Kvblw92JBdmW2gyRcjLQKFpyB/5JtDQZcaMJ8MnApE//TCXCDHswHZ+aunxlLTqHl4JriMuoq6WfBySBBhBYffBiHAEkN4XcY5PJuWIcfPDSnBUaiIcS2MKkGWnFb0iWUGBdCpgRKynnP0QkDwRM8nyOhL/0BU0Lwit4v9QmoIyvzOSp2uyuGXfF3LG2pOjZwxfMqU5vxKV10dqM1OOI12o9PizS7Lq/QXBKS8w1RkzskbHK0FpkB2cU1NQW4wHG6ePas5h/mpbh96Ed2LDAhJPLZg3wPzds2btwvA6wZ3jh+8/e2nVixduuIpsLV9bkt16dQ6GfC0Jn6WJlpbE9zPiVb4U9Rje9/uVpXMXNI8CT0WjI4Hrf8K5xnkerXWaM8LJMK+bK1KojQZ7Hnh2qrs1kBdpKgh2GqYuWNm6kmoCY/bseGaoiB8kdx0nhSMOXEC3Scr7SxtLkOPXaNtKyxBj22B/jPK0ra2UuZ7fCTkuL7/20FMkasxH+rA9HgQc6PDqQnUUepveAZngQz4QQ2YRlF8NAQSZDLG81rAHDOXkOk3EhBPQDyx0RBx6s75QkZfyMf5eLzKRc0JYFAz3iCeEEMcJvTNCVzN6NNFjeLF+o24dHhhNAtzPSb7ExGyF+OC8UyizmcMkf/CVEjWXiHG9fO4Qgb+eYz4c5MfJ9gg4bq4p5GFQsRJT5CHNkg4F3BiDp90DfIoEUFEJ6SVxAtoIdFMdoUGPCZBcBM7MEG8KxBRpY1Ehm+Ku0DCKMnkSQR5RDrPBWhdpjm8sRKc6g2qGQH7IiG0TmzF+HxY19x05/btoGr6s+FRI7OBJ6djRC76jBzB6+Pz+kz1k8smb7ZutTZd2nXJvNGtcI9C57CELNmyde0jz1KAae94ayH64PjxPTfeyL4r9q1F1oT1PX6xATrlcmA212aPlllLrX/3PnHIeth8alD4oKU4dU1u7sume9vEbrgy6nokYUYvukvfMTd+Fo+gO8HYRMkxY4X7QamUgboy9z2VqXyLyaqvs3gH1d1cVI4+txptujqAmVazvqn2pmLMl/z1r7tvvBF9WQ9/mrVunddbHPGWhDeu8PuKi31fWWovu8xjDeQGrLHwhuX+8uE3Tly92Xa5ddiGLTVcjsat1EnsfufEqQunL6HHLEhdPnx4cSLedsnxSs+gsLMKfOusDC4oRN+8i/8qK4EGnQXgqadS7xpcBhUHwYTOTqAZP76vFGjKcL3UO58khg9PwANVVQUFhYXTgXqMWakEsKqqvByszsN/Jvw3dWpe3mNgKymZ6jSl/8rL0eUVFeNVs6Yz0rEWyxlzWCbzOuP5HuN0oHGBeyw47nHFZD6NSc5NAxrgTF2K71qK7wrvRd8ATerSMeVWrZwL+kM5ZVatDEgC6pm+cqtKCVhFwEUSDYwE1qNvX3+9snLLVRV4dpXrnHww/Cf8NakjR8j4VPSPTwXmunx4XI6kLqG2UPuoB6nD1B/S3qjS+0S4S/s4whEQxIeB6QLoCEdLCOYI0WcTpGQsHxeSB1hv4zMuQQnFNSAkQJWQ3msWMxLgN1/JINbgYyVCeU6AO0kQ03DxAU0XzsPw02jA6YsEHAFah5lVHVToTTYLmBL1O/0k9fQ9rdU9PKwDUkmLAeqBUq810WOmgVg2SVHT9sYhMweVOyr1jGoQD56Xsq0Kbl4eqxvGSkP5oEOFo9RZsK61ep9BuEiHkvnlRWyDyEXwekAu8oGqWSEUrefhqaFsDp5JoIIP+7kl59HVywPFWY5A1LMyxwXmKxjjvf6IEN9eEePRHImcv0Qqp+HUvwFWIveEFwytaLIYlDItMMpl8r27tDIWLtnMdEtVctBdmq6iuvSXVYCW0YKDQK1AXZCV8YD3mfDtzOCj85ZissfSvxZrqAg1BK/EE6gF1KXU1dQt4jqMF1RC/bK+uLAKC+tuetnl0ojchJYNCstuIg4SvpiGjqbNKEWFLlZYgPHkq4sSXEleWMEFK9dQGk0ycY6BFzIk6foC+RsMRX+BySmpMvIes97pKANPXCKJRE99Ud/ozwqW1+sbOloLiuoaQu4iZ4dbP6RrRFEUM1tdG/QFuuq84NCswixlDrhSo8oqlMs37bKVagt37YKX5IcH18akm3f5s0ZGq1BeQX1BQT39cFFkcteimsS8mRXassG5BjP7MzyfS1o1KOCTnXCNmfZpRZ1VZVLbPN1ZwVBTeZ1Fbda6rfrF2YFs4Fu01bhEOvt/RvldiuVc5CXr1XSWqxRlg4gbPQT+8uHqspLSwtQa625FaR14kdy5EH2+uKZ285JkZSI8283zhWr4yHkfjqbUmCf+VkIJ45wgK+nNpIHIfnCIjZQIY5msMsBEYEoIGluc+KeqZogbiczmE168zETVXmKq+rKlBNXuencnAJRWWzE6azYTlQL5zw/L7dJROPA0H+kYVxX67DlpaXupdO1zMXAHzoEH0d5XS1rm7do576Gs0RVa7dDZklq5XXbqPimUd+ECt2d5cybecN+3V+8BrIM3EP16A6/fMAnMxwVEe7Zz72HCdEQb2RXqf/ioDKRdM2pB/9slPEE6oSfWA7/6Yoz4KkNTP9ELcx7fMummziKmN/OiO+EPB6oWVYGGUb/6og+nXw58Dn8et6xm2oIoSqJa8cU3PAO0U9Fe5p6u3/ri/RjHbLJfzpUgmkPEd6EwhepEtKdfiwMPHhoeCcdm/AqKA8SX8QGREPdx3MTTC6QuDtM0MJw6AXqLODl6Qc7Ri/TqLtGBgyBwBLEmTVsY1IbbNE0gptb3QEGUkxKq/ocw/e9lMghlO3G4r2XkqmUj6aeE29wdKCkJ3K0fgGWcJ2g6El0EAjlEiZAutJNQTt6qgdpSGbEa/E86KMy6oUtXlb2JvgTa170jZ3eUapdrNw255pEntzdeI5OskMj7fk1HBRxdGGnLxePmrdeBVmbPHpK/UKttyi1+csful4pymjiZjM79NS2WgXJ4NfHTKrwD2cQQbPNZomziFWe29NavXkCbrBE9cZpNeMUkZXGn1lIer/CuZI4kcBoCnuIAuHKKfmP+5JrV06rmT+3qGQ1LmtdcM0zCc1MKHWzJvsm3P7L5b1vGXhGECiBjl7NSFq5krVmO8nH1RWg/ej+jCX/yEYVNmi0FUD7rzBbBj5/gnw+MA/fAUwtWVy04MLV79ZZXdIsOTotCEPNE6sf97sFbgfyWwbV8qUSpYBWpmy2WkA3IQlXL2zD1PzHTRNfJoKJYqVTJRnaSS4JS4Di6Go3r19sS9vV8ZE+PMmmJTZBBA4g8n3gEYUM88YqZFtoTfxcyEAJGSeORyR/Pkcv/KLfJ56buCsReP0vVJgNwwlwxbc5Hk/pegrW9qV4JdQT9NOmjOTjxj3KhbLIWUK/HhLJC2pyPJ5+uFcr2pvXIkCCHzE776OCozF47iAuOG0yUj2jaEl3kRDUjGd40Nx8d2jJ11brHJ8J1FX1Ph7aOBAz64S9rnltazjWWVmuy1da65llzJNSkpppxqavXTDi8PjkKNsTP/NiywDT4T+j7SXe8sZyNhLyB+kkVfs158tD8fjQ9AaE6ImBoihCXMCrEIOk2gpfKNGCxC/JGooMpYsdyAoTXxSOEkyGaZp7+fyJHI2pTMbFzMsVfRjjqFJXfHnS4cn2WsMnk9LcX5Lf7XUZzyOLLdTmC7Z1ipleI5KfL5Be0+50mU5iU+WUVIRfX6W6vJX4RxH+17d1nqCGlsWG8w+vgg53wP0aSRKjjsFvsJrWWt9ocTquV16pNOMEhpAohUNsr5jpsYu4FBW1Wu6m3vRv0otrMr5vWto4cFnPmWbLc5cEbW/5jRBzzgryKJXS4x0i8QGC2Hf+k1M8Ung4AdSoJemEtDp5OMlRfEuK+l+rt943SK6yDWrwSUpj8F7w+4VktynuIHxD8/Rk9TUHvPPTJre+I8807z9DsygX7U9Q7eN6Bl6c+XLAyMwulqFvRJ/PgHTSFJ7jzns2deTayZJCRRoZbSBhhxPiOLBnC83JUSLsqtRUPlE9RVy8cSgLg7VVanRE8ptaL73ACtRp1QqlMIbFMSJ/2t8RRzFiqi1CSBLeYEXWGJSHiXbkftES0EcFrFxTVoYkTFBFtWyKAuhIpp88FzVwwJBCSrFIud5X4A2DQsZ0Vc9taImWuYkVWxbiVHV0PzvrTrY+MKLWP0jjBJnT2hh+uGHv9K3PHXjd7bHlFTrmt68oRS4M1HWPHNZcq6IcWtY0uAkqTi9lgc5ibi5voWonPmW1XySd8s+P3gfiU9vXDL3eMmDsuvOjRrp6vptTE9nj9YM9tAOyY+9ruicHqaTMuX7oj/urU9pzKLLc5v2Juk1Z3yX6GNuco7Pns9GIjMNaftxaMFWT2RPcwVJLZvvKZMCkdEvFIDALyLV74TILiKkvayGwU5/5EP3SxMMy56EVw6vd85vOHZQws9sd1wMBPCsk9g6Lta6F26gxnOGIHIyumNpnLQoOGJ0fOfGIezUx6cOHTkwyKypwl45fu2T+n+9ICqc+U7U+UtuTM3zPnPD8GJx+ol6sCDqhSQH+hRuMfHJc7DUvbOW3XOKdU48i2seVN1xXunLViSHH3UzPAgicWX2K3LGwf8uCyuffMX2GcUj6hrDFkvxp+cr7BA52W8YoYolHqfM+7frKx7yEqTJwHR/VaPIMRQwct7iUePA0yybQeq3iiBa1YtG7F1VevABvnPHvVO2RtS1GZVY4mIWg5VyFz6kTfozfQ950jrgJ3X0AfDLAnpAS0fMoCxLvD9NMApl+tH7O+/feZ1X9v5tHz7ghQ+tIZGuL68x5GmP+Jigc+EetLC6aOCCoX/s41RBQi0ZKxEYpiMh94OJOZEUD5ie2B4A+O0A1ZeArJIj7KEiGyjJJ+g1MIzya4p43i0R9KhwjgWjQCT6OXwz7Lkbohm48c2bz04Tuf1peBxSALZU2fa2TZI5srqx7UyE0ao0//4KQjQAoq0Sm0HZ0a3lSH9uk9L5n77jmMTgHu8JKZVwqqlSAJHhv9oagY6TEAxYSZh0GyKeuM+wj6+cj1X42uuREkN8/e+SKQHrGgPnOJWuEEzJSNm48A4br4SlMfqJmGcm373wccWAK4xJPBkmCSiOYdqDtvoF01J/ScXIKnR10gT+YzYFS0RJAFw/P8CPsuxLfSlRDJJzEXM/MZ+TAjym6dQ1ifuW+e2ccOYYMuJugK/tNhSCUNDocBJg3gICmcovAhaZ0tewTYwRhgf0Q21wwUA+S/UAmSZqfTjJKuggJ4SdjhCDtSE1J3JWPDhsWS4hFO6F4EXm5bXlm5vA2VzxLWhStw3/sZrwsFBFuAEoe88O0wDy3iWEU9BAVKMCPwiIIsj4khkjFAGANRiRL3gZA4f1QAgeD0E+ggPJewT0b8qXp/JOKHz/mB1NyXQ8L0NePQew88go49ZKb/TBL6Lh0HQg9s/vbBOWBpxL9Jt+l99NbdP6L5058luZtxHBTf8wPYOf2IPwL/3hSNNkXHjBkV8fkj197zEHr3kUx49kPfgM2+yOjRd6O3PtgE5McjfiEGij/YhH48HiF2FYqzFPND+tvacf9fJmCK02Z9DPOGgq10AX41gqVkJhB7ElpwTk2EV2RdkdBpkVZcV0KsUfziRoWLSUQE+CQRkhyPEyNODoYkvrTrNUzkmdILj7Bdcc5QWFQV503malYQG9JESRyKaP6QPrxk2V3BMnSNiw54lTk+9OY+XZamctWwIt4wfPZmr9qcpQqW1TsN0dusFadu/fste/B3KkV/WBpQKnMbx47rcGo5i1bDOBqrsmrHB2jmSpnUA0fEO+71lEhbS5XOh5y58SWjJztWVzmz7+xo2/S8BEoKshuqhwcGd+yrGh5UT76vb8+i7p3vMZejp4zghYbSvu52aY4Vchy9ZRoaL2fBlPd9fT/4D1xjU1vastqn1cbRrdk11++/714Ac4ta9MUxBevyljh4hoE873fYTJaCKwa5l7qUSig/Cjl1bOjeEV5PrXKOTun9cHxi5lpbs6t6tQYcnds+M/WMTqJdf8n1M4dMG7oANWmqJ0+q3YX6nrskpwyozvn7I+ufjYoLOPEUiA5czHzp1Y8sdIH/mBMPkM0nGAp6sgiIvPAFiX8PE+PJImDv1YDHNCyte0t978Y7Dj99zY33qF5nq6JlNXJbPDQF/vmo+p5M+htMdYSkx0LFCbDQnS/ROOCY1K2pa0ezVp0k3+XKl+jNkjywFfBw2ljWomMLXL0/U1B72+P/evX5zx/sqW1ataxoSIP/6gsTWp5469UqqVIPa2oYjUpa+co7b79SJVWrWU9WHaNWyypfpl8/TaatzLrCduF2cVIVosZjGiA9OMCjozDSBY/DapBZ7DOeHeOZCH1C8C3Z042+FgKYYX9768ktILnl5FZUROI4EWi7e4QAfR3SCmW+7u45kyQhFrPlW07+H+a+O7CJI/t/Z4tWvRdblmXJsiRXuciSbINl2ZhibMCYZrrppptOgIDoJEBCT4BAuBBSCCnkm94wuUtCChzJQQ4Skji5NO6SXL65Sw5safjNzEq2bLjcfe/7/eMH1u7s7OzszOzMmzdv3vs8UBPZgZ7SKhlhEU8daWFaBBsQNsEGJEg0eKie2rGcgFXNxwGrUVz81q2unL5ORR1yL4a33oOjSUtJeifJYkGHFGis9G2stliq1/kqDQHEuk9Ishj8RkvSJMTdBwz0oCofvOarQsG0ilO+qtVbmjrON23Z0sQWNG2hn1uIc8EH2O6rLC6u9LUbjV/juK87z0sP+CorfXC6wfBMdiV9qOvpLYm+C2k0NWMtQnsKsOP/kpvsCnfDj3ZfBQH4ChwAXwEBsIaedXxpJLT0+PGlTOvS4+B12h25B3H/FCijH+qKP467g6kTj3EQNYKaRDVTc6mF1HK0CtxA3UHtpPZR91FHqAeph6nj1JPUC9TL1GvUaepdAeuYIRahTGwX1C7CP4GuMcTglhHQD3TFOEoXo212P/4JsBM6gqOLjqhiDoDuABJrCmjcIh7YTU6UJ4YB5R0BBphAQGcHfs6LVjgmI2MPABXw+nijRo8fMmkCGhPIB7wm4BY5HZzJIKGdbg3He4FJl0+jXsO43BLax+gcOsBXAOKOTgZMfjFl1p9lkvWnGXtSshq2aIo1cIHGbEpnT+uTmXP65BT9WyD9fTbdZNaCbWq/GtylxXd/b7LxL+uSI26wER6/Gx4HzdrsyFhAn1e98rJCTT8CV71GZ8Nv1bn0k4ANaazGCLxUAZapK+EIMEgcaeHASLiVRaNkVwi+e+j00UdYIH7Muh9kffYZe/aUiFmmju6+CP+IvmdmdOUW8HX2COD8YQMDjOJLnBjWAn+k9Sj6x5YXrMv8Pc08tnYQR681pLHwPolEj05PisWmdK1er7cnieVgCJuml0jAVC5Nj9KARsCCDBWYLRUn2Q3onz1JJIcHgN2oUMJX2LTIWTAZHlYzFlYi5eC9orfA2NfFNGg9c0bdMVzEVQ+ZCaTwbAjusAA/fJRVodQnRRxYXgUqH/rk1ZNixgdooFacBAoZfPsQKPvuUzG8NvBtWt72eQ58A54GXtV2+OUnuWBLB40awoDaCywHLCyEL4JfPoNfR+6AX4GUP/2pH5gpZdFnzoze18AI8hKC/48x7yjS/TsHA/rWCYp4z6+nvwZNz6+P/H398+z5p0IeaPGEKvOYxvWnwPT2qg2vvbYh4xnwKMYwh3pPH4HerEfj7XZKSjx7Y3kMSzGYcUF8C4fYXnSBFplASzmFCw4jxfmpgIg3Mg/B38L0ZfqzoOl8A5g6vj9cGX1j/vhgC+2HRxfRGjAlUwmvwNCyGczvTz+x+eBcMPA9Q30lN+s2mApPjx51Hkw6e2flmAXR03DlgDFgHV3W0RtMpfVLx81YDoPwY6W+qHK46SyonXfvhidjtEFMsf8gur+YkusELz9khyQH6PyIzfZ7bVi5k4nHM3ihixgZwTkdT7xDmfwmftrB9avPnP5iz54vTp8Jr+IOtgH66oEDVwEN/3vtuUOrHnujbd++tjceWzXztqfGvHPixE+BP+y599Onjixc9f6S94+deIdd3iEuHbtnz9hS9tqaWbM6HiqtZKKDt28fHGFych1z5qQzW9l7DlZFhnmLps/mBD76GJqbx3baW4z7n8uhb7ruAlhNQFohtMUKuCtW/Xi9lRzgl1b9NBxGB3jl1mFuy3cPdWQ89N3qmdLfLJg+OA9kv7o3slu5+cQx+hOD1WqIOnBCWoeP0e/xETyOj3AYCc8i4X3o+NBD33330OI3itLdC37T5/k/747srSqxf0xhbUnqRlAk2M4IftoMxFObnfhqy6MKKR9VSpVTlVRfqgbR5aGIMo+mxiPqPIOaTc2nFlHLqJWIQm9EFHo7otF7qf3UMeoiGhFY9OMkR5/dgK3XTD1/AROf+MMuiRJ/AOOC/coP3/caAv/krgnrsxj4W/yccQ6LgN9Yab+gjubo1KcDIpeA9W80eQMeERZei6jItaiYu6/9DL2XPtp+Zqgz/q9CNVOVhn5Wcm5WDZmpmrkc/W6LnSOVC4F+ETAsAvqF5C8W7njBueiBnvE/Dl7UmbEzumXtCy+sXff88/Cyu3d1b3fLJDOT1mdiaqDEEagfEsjKNKTXqBA3niGxKs1GeWrAZxdR7TvgE6ChkjkcmQw/4jLffht+uGjRnoS/u9Pz7cp0Tzr+Keye9HSPPX+CJ92Df+Pz0z3s+xk9/sETQxZ1j1k0JKNbnujP8fw6obTg9owsCQd0hkJvRbbUmJvmyeeBTG9IEhlNZUDFyBgRLTXlxf0LLELjbzvBe8jusYa9lXFezI0sZjQm3t92+HAbAw+33X9/G2iryLt2Ka+iIg88mRuifwrlgifzKsAWfO8wTtiy4DBb0v5KbkVFLleNj7/5DTrG+NBMRL8uo/MYRL24ONwR37U/TwTNGB+QFbxEUIkQSTHNAZ+wyRFXZRce8HP7ALvng48OjziwYmHzjIXL7x124Lfn7596aQRns4iVht7T4M9rNn6+GaScW37x8M6Nm46Nmb5x7UTrDI0+TfPH+8tmlxeJVYbkXk9NOAXZUubF997Ydej9wLjlGzYuHxd4fv+hl2rL2VSdQZnka5yz+MNNZ4F61NaHH9k6auW0iWGnVa8drL//vDPXaVDpUvrUdLzmTFXFeFnsfxzbEuRgjCiiwkB8UqYCoirWCxCQEYxFEseyZ2NnHfGwQPwKoI8QJ3VBEGDiMhUri5fhLHbQi6UWxIcvCUS/FnTIBVXyd23JHd8Bnkti7sVJIpTZZXTSJ98TxCbqZJWM5QF70uxiuueCA9FExXKmFVJJTmYFn5okVRdgjD6z0lvNMgEUVGjTjE7e1YVrj+st6OMPE3qbKq5GTzygmYCxKAD+0zpzlKtYtxu9djdiMnWAwtDYVHT3f1xr3S7gxDfgx7t0KOcblA7nl/4/r7vgR0Pg37E3TjmxNUO3dBLG7tbZJbTdaWcIQ+8UtsyJZw+MU2AvukDPhxfAVTA+2u+O92A7bGOiKObVyOv08ffgD/R8MAa2wXYwGoSVtDoS0pZpIyE1rQRhrZ0N2xkqOoPeH4kwLPG3EfmG3k8CIDwdUtp8TYTS61lKk6+lKWzHiSrJf4/mohrqHsTpUxwWy/NuAkX964eAYBz7Tw/OxEQaBm+ba7zYzagBQ4BiHw2Mpiv1v3olMDg5H55meB36yOExw4Zp/dphw1D4nx5wol+7P6w9LyFV6AON3noyLGwDhU9a9ZoPdIk5/errQAhgEx+I+ouQoe6f/X7l7m34bkODTtcQAk5QZi6XloEcbBwOL5ZJy83wTfixFt1s+NVMWLMAuRkff1zcl0sfailF2XWoJXUqAGJOINNjviAFN44S7IAaa2cxKCAWDKM7xx4TcHsxoRWILcZnMRYRkBZAgFyNvJe3MnSoqQk3RLgJUDQtHdlvEm/hJ/UbKSV6ujL0x8g5hUyjNSkyPDqpQiaXKaQ6T4bCpNXIFJyckZFU4IFdt0X23bZLkuoZ6hvzoZF+/QNN3wxbrnVO7znWXFtGX80Hr/MpHzZUjM5Wg9ZwCJtIhcJ0EUuLdTStE9OsVsLwPGsXm8V6Xs6yyY705OR0RzLLynk9irSzPM9IIkdvu/PO28oX3jFvkvlKKCTXZ5aUZgd3ZDuDQWf2jmB2aUnm0CGf29ccuTu2bxBFtKwOcawt2NpFSWOrChfZKCEiUEeC4NvVaRNupU12L5aEBsheO+7uMaEEYtVNeK8JcbABu+AinYjbM4H/Jhm7OCqvXvfyjN98r5YPGdK/aZ4z5QbVt1MMXleXtPJZYg4WHrxpSm4qTS0a8anVxbGupKhd32+hLmUavvlfi9bvuPudaxcWPWWCbzr0Ws3u/NwNr7zChYH4le4yd/D3Gae21PGyL4/Mf6v/7Pov16W445LxlLx5iNSlFKUaw3lWk9Uyc6EOvdbsOlGRYr4c7dg5P82WhlZ0WPD+Sk9xe8y/ERfm2hCPOwTPhHa9krZ5aAFPw4iVbJQsb2WxJ3QCrEFMGBlBVpWocdKplxebMbjwyrM/w/afz66sWry8vzmX5dLMZU2lmSrAFExed+rCqXWTCxigyixtKjOncWyuuf/yxVUw7DKHBBMn1Hq1PhD21TYRX1cV08rT0sqnVRQO8TvkKCuUoTQlyaRmZWkOq15vzUiTs8okU4oU5YTykzv8Q5ghEDsUCwv7Efjnq60Fjwg+sehOnzUpRHvKjiH8BAxLtx19/xQg+HLRmYwAzXkYmFbEy9CMgHcT7DGMSNoUZLAAnQKFnJRloju1xdroDk4NFhgdXL/XROlGQ7poV4mWds+Ad88XO3R5srW/Ezly07nFcPQM2BZcO78+I6N+/tpgG6QpkYRho49otfQYWptiAMnRaXqzWQ++anGAEzsPfqLR01wWbKCf0JtTDLDg4M4r13JqQhkZoZqca5iHo29QbJiLENsaCugpXuON9+pOQV0n3q7GA2jifZbVZuC9IvRjw/Dy5bYu0BghuO9va+WyrZ9vPA6yn4hQQo/Dez9M6yfwRdSXEpIK6kSs+gmgPbjp610q3S74Z62wm4OfStwHxbaA3X1CEm/IdLqHJhvAJhADwvEKZaPUXKvZRV4A160ee/Diny8eHItOS969D6yGHURYOSNeNHidQ18bCmpLIrj2vneXCKnxQ6vBapJNe7irLp26KCymzeWC7ZzWgJrQ8CtN6HNRROMMURyssmPFVINQEl4ULzQT3HkSNaqA2EBeKwQvw8sndx6rEOk0fQ3i3NbvWnPFqeUanagi+mBXJdjfDYB/eRi38oaER0lwQxLo/8nDwDCg6aQ6RT9r3bpZ+hT1yY4rCVUi/YHMNVXUQLznHFN4j1cDg8f9i/rhLuKnMBFw4vEdrxRLYZv5+NdYfav67f3bOrka2N5deqWRurFJqY1uTvg2qLOgr0O6zKYbh9++dQVRJ9IcfA/kmJRV/aBW2dGU+LXoTtvS2Rg95D+pG/52ATffCTls6CZtj08GgU6kYr+teyNw/7oR0EdeXTxNYpYWSIFk5nxyBxEhG765cdbI2I0xpYfBrsP/YSvhbvD2Yd98KRDnilOki1o2kT4fL9fsCbEbU0pWr76pFbHsh8b6TlyUKqGCVC3VQHZmjLToVqTD/k+ICO4haNY0UmiSdIvUTBFhSFxk4gUaLJPTgCIURvMnYUtEUL72b/sSKAakepAbDXCfPffYY+fOAndkN2JdWhfNOHBgxiIys9LX71i27A469CKuxYvkBvPXg/CHJ9TdSNHNBOkcyNMZFi0y6OAfou+sB3PWr4d74C+lx75oe7hUaHLEkLOqIUNUMAJitKH04bYvjpVivg3cEPG4v/Wj6qkJ1Jxb9TnEPosoXpTh9jABYep0duphdu+cptiAAsWEUTEFgVNvNKFWowJ4twvRRQobFpJObAWibj2trsKYBn96/gN4tM+S87vrxZI7v9i89OPRpP8kpuuV/twuEgkp9oGP0F8k/OkxBijf9X2yGTUk04oaEEXAn1AE25TY1yb+EH4ORsypH50SzTj66bLNf96rEsZgKDHVwImSRSgOHtG7ktsfJodHIqZU6wegwrl8F7we4REXhGIsaR/A0ygGtaEotq8xELXhOKr5V9oQ9Zl/izARdyNCU5K+R1i9gEuNe19nn1OjLhfu0YQ2+I9nP3tpydabxuzB67ebkoHipbaXdj3xdmxUUmEMFYCqs2TagQPTlrzIlAqdj1x2H6eo7Z6BkZT0VYNVNw9WzYsg/YGXgSo1fdUkMhq/iXVDMB93v9KHQevDpZHOrgdDD5d20x3qRZDjE+dMvlNZku8+ewa6NCb/6Tx6cZtE4kFEaNvg7vPp4BNC/ImLvz6vfrhNakYJJduHdJ9fB58Q4k9c/CfzLH2DJfNsKfHnaKQMepol27paf8DX9ZF5AdRJqEa8nl3dgo7Vhw5fBu4n4IfHN36+VYYpC9n8PDJOKMQ7aC34jlCfccKN6121YVYlwRc/eRj+eZdOtevrTQeB9gm18NmOjROeeVune1vIaNwxcqMj3H0eQis6PsyujteFoKALpU4glyIK6/EJ3JbR5PXFN0HtcTCq+Lfh5+p08CNJiiRPKn0RfhSj8f+kjMD1olSahxJ3hLqqRM9FFYYfCTdeFKggmoeeANmd7SNEvii8JfL9TfMq+TZYPiTwkJ1AcBReESCWt5MNwOwiKQl6QezjR/mE1iUMYvQ+ohM+Fc9UsV4SfbfHOxGBDbMYTxiDt8eYUaqzO2MtLwpe7+QjN3f1VnQCCXMm7euKRycqAYctI8HXpsYbwIqv3gBRJcQAw15NJ3DcY46iIge87S3rV/nVKyoWbTl65kzUjuO4cJGj/bijiB727Z6SEvB7yZFdj30bfRzdGOkoomLv4jB9q8M7YXhdwBqJ09F0l1spwsZR6KXaQJfYXdAFZ4nQlACbC7u2HqZ2w4k3ZxwG6uOuhqUnZlRvSpVmyKzG7CKnUqLKGcPbmuvLqxvHhAITKgpTFB8/dQb+PTk12WqkVd4hOUbmsTmn7mou3giPNL1wfO2gUIl7d86UnIaaIk56KG3cV2CMtbJ52K6hwar2YMWwopHNS2bmP34aRt/KbSjIkVjGMKqG2XPjcukVqO02ofVEECOWUAIyCdE9J+vsgOCOzEi0EQGpEMEZQhFMIs4tHzBq4zBkGO9OR5SPmPfMj3K0Rj0vv3Tj5B11AwDTP8kiSuJ1KrG4qC+XXl0yUS5Vtay5+sjUqY9chei0fMhPhxFZB6Z3li9/B17d/9vjcOKWOcvfoYsaJZzUnuP2BfN2tcweJR7bx8goDPotvKFGyotrQr4CHg6JZYJOa949dnVQMzcdZwLPwavvLJ+wCex9+g/7Uc7Er0sMf0zAC9IRGbEbtQJasQTsPrsG/TpNlRLC2k6cEeKPhvywii+FfyJbSX1JSX17UsKF8HfvdQrrUuNfmIDS3EtusLZ4iBZSRm1YYEhTXcfOfUeCxZ2DLWcom0uNcQVBjIVN0CKJzwP2uPYIcXBuiAuTOG98BYM1UrFnvInw9c8xOj8dAk0KnU4Bj+gUrQodPIIvQBO5iNrqigFVPQOLhniDzd9vWrlOP+Sep+8ZotdtGPFZcR0djgH8w/tvflrIN9paXPdD0Z23+aYtmTqxT6amHP3TNNUVx3Wi+X+Q+nmpkQn1wz1RBQS0DAEL0FdcQYYYRlslMh18xP2V4wncQmJFjTZSTcJ8ddXz2esSyRaJQim5fl2iVKAgDvSIiRqedTqHGUzdKnwADDyg11lSLWZnZ32jn/3zTLpinnX6fc5hTFflV6zQiFI8dr8zQS9WS5kJ/SKskqCnH/uE8a5n79SkAZQIze83qHZEyIkQiA7tu7Bv3wVu5Of3R0PoEiOhhQAm8wTrDBrx3X2h+z9H4XAXli6mY0ai5cJ4DXbebrBLcF93231ehqi86NCs1toKfwiAGjgNHkT/p4GaAPyhtRVQoA9YAfpAas4lEQVDreHWSCuDT6A1iqqFpqs4fRHeg+caB6bPLKbPiKchn6pCcKud4dXGPYuierOY7+945qJabexoM6rVF5/pQHzZj8SJE8oZ0fqXN0bC617g3lFlZqre4V5Yx4Q3vtzeSnw2gfMY3qkTby7h3TmCNOLW76cT3k/9y7J8IfgsDUXbGCi4NA1hK5RbFktw9Qpex8WKJl7E92ruRHRoKfG/YiGYNxoyQcTceWMhidEkobEPebcTz9USIETSI5KTNGqYb0jV65RWcIMJ0cbon9nZlgIT7E8nR2/kwhWgWuNQyulUlh3bMTvZIb4qzTexi/UW1Q2KmRE5DKR0v44vktMUV5ivmMip/vQKWmURwZ/obvjqqp746nZNT0z1dqoHkjp7XNB+S6KG3xCJH+RuxOyU86lqahAVASKgBSnAieh8b9AfDAUTwBywDPwXeB1cBlcBpBXo82GkNBfBSTNyWNqNPTG7XaIACROnZiIhDVZA8BuBN52Pgeu4Y9uZxS601OKDtBUAI+KdjUKOrJM4qcbY7XhxETsWC+tbky827eG9UMTG4akuCLD4x10c8MSeQ6s+vZUxYYAlF08wljysOwPDLAW8QQZbd5kEkSrgDVgLFZUYJ/IGgZXcISioDj3vF95pwKh9qIAmP9DjI64ZXiQJXhTRMindbTQVodpzRNHCRXxnmVDDFGK7MvxEAHEePpGJtJMVy24DLirmP8FXzLh4n8goxLs49HP7RA7BjYlTRDxco/QiHhWANfkzUHMUB0E5MJA3E8xAt1LsELmVDEbDcQsxeMFvZPwYWdClBCbh8xCFXfwUYhKMBG7KgcpkYomLehF5xmEocuJq8X6fAJeHfUCirDi/gA2rF4oJPhW7tMk+GjSkoEoV8y5dsg/Qw1KMxlLFqPS8gZsLMvPbFypGCkEP/TbIcqSk+13FFq5lSH1LS9uUv61KmX/70qH0T2IdD8aG/QWNxujQ6O9MowpHvgxoTicWJStTeInMkmpVmCwOs1Yv432NMolENZhOd1k4hUfJ0NIsqUplqgbBBRabQaweaCpjGJrluZTCgqLMFfnl03feoc8utgfl9DDgm9x7RAbgeJamAVNmqtGiicMyv3f/JKVGli0BrDpXwVlc6fQQpUQsb/RJeaDXmh0Wk9JuTpFJxRaFCf4sabCyKRa9bbAjWdHHquCYEq9qoFWZLTMY1dbrr1kbJHadJSUztVqR7HCqvAFW8pKyly4jz2NOZi6LNQyj0GTmgiTY9u1DD337kH/mLMBLU9emSVgO/iRmWPoCzYpEsvRN8F51VqlKyzBSru/rjHMDMD10AhgO2hlAa6pU5hJvGsfyUlok4eVitVjHzipl5Va1RcT8VxLtz8+VizWSslQwlNFUu7Nua+Qc6/zekQoT+9s3Jh+bJDLRaRJ5rlQHaEY3gtbT0+ATdfVicWXo/HkA2CNsklIHGJUqWylJo9Xy9/7rTbqJa1ye7eqrYaQjvf51W9VOXpKsM1ZxrNeQEG5MqZQoHHbPXI4bkZ4QZqtU4rwUR1GOSTdw5sw9Mz+am9end40oc277FVmaSVOyoB9N52cnJ2cV0MzBYUZtmkwqMaamSqRKvTJVLLegT6aqoaV9fa6coF3jlCZrOS3DAg7IRJmMiKXtaRktJat9alMqMKuTlIyS9lhYrafMV6MQqxRiJbMa/mP4nVIdo0xSKZWWJE3x6tIWh81OS+ksTo7y4RiUY5LYpbFVZGb5+knowiQV6kQWucSi1iokUovVIGaeTE22TXWuTNWxS7M3lilsSmVomlolBYtWMdWbCqfaklO1rC515dY0ZdnGbJFKPbVSU7lqPovacvRsxu3artPyYv363jS9/tjiJceOLVkMXagjpixFg0rGDOjzEtvYiJpdP7yBU9Fnei1LFou06j2p9DqTYvubgcLX9ysMNINBfGgejMlGQ1KsKOTEIg67tgQSvUYnY2igKa2QiD0KRWoGapboBqW6/1KZ3Dfb76un6d5XKkoWlBdvmcRKgIjW6kwyhWxYn/SzBsPuQoeRYQyW3mGQ769y2cGgOtR/kvRalmPFr03otc0/2yeXLeunVhai4tcLPEMfCeBeJZx5L+LPu5uWArCidvUWWVlMkvgg50GnDA/P/b1py6RJW6KLJm1patoSHVM6e/Mdvz0L3KD00tY/3DMpj8nuP2fVoBenpU4c39TPJR9yAJ58BF658uq6RdXV9vwc/NAk8ugkrrD36FpvpknJSU22/JIBQ6fNqTw0xrt44vSh9b29aWqGVluLvQN7DQ8MjescxPxypRFU0FpqBvbmQnX3VIQRHbvBNOuKECuC+HY0z3tZsljkO8UJWPmGtrHauM2zziDo3Akg14jrj1+5bKKeWIhsFnwCvvfZhg2fgWLQAIpxKDr3ZqTnhWq1Ta0GK2fVOlLJEj/VMVSwbI6bSn9Aote/tJ6cz8Er55gmlzkSjgOqc60bPoPv9Xjb726BCx0drIb4XW3qUK3PUaZZiOUFCzVlDh9T28MwG/4giNPGr18/XgjtOncuchdNUBEJVG/cnkwi4MqbCF+H12JejaNHU/gIN2XoqVpVZOTD18M8WotpldeIEjxPbORrfROqrrVWTZhQxYeqJvhqWQrzstFWEBYE+hHB9v0IDPtqj+BkDEl8pJbqUaaUzjLF5BE9imBIBjcVFbH1HEUT+6DEUvQoIioORbfW+noUIdrUvYzA9n9RHgYtbf9/Kg+NONL/s/LQneUxoVFL/U9KIv71UjD/1vuxLIljVyK6YSEonui1urirTOLRxBXz/G5i5xL3H+veluqTTiYXyE7BMzqzXJ6ZKZenaMH3VncmzEDRteg2+B26x2myubZsDacT8KsZLOvDPgpsBoxYpdHb0dHmFtkdPq/Np0FHTTEJm/zoDhOCreEwCIVC8MeWFvhjKARC4TBsRWd1SwtQh7hwG2wKR9vawrt2hdtoWxgcIUGhOeN2DXFvDzkE9aIXkZxiXBiiiKTBIxWdfXbOQJww+zQ+h8GJCkI0WlEpiT/dmME6PhP7dYMYjVgY7qAgdm4b5iiAsXqxSEWEfh3CGaLYCErFhLFz1CjqwTdQeuwLWHiKpUDcP247FvqjCMHnAw5FKdKDwjTuRfgBSsDOQRVDdUrrlBF5Yz4sRnWvVfe6aRzxGoLEWjoMXqe9q6rYe7Ad/VA/89ljWaHVuE9C6oprgv6EojNYdIQ1nlCto1S4HUVy6NeBbqAqCH4pcET8EYbAGAvP4h9NzjDmHJgcO2JNQZPtj6hwB7Vb7J24AbrWghqM7wk0iaMDXYhMdtxreZaKNGEAFC6UWUJcFIPbVUUvFDUAG2wSYksyI00lAxpQpIpKtLUREb/KFHYCVwH8zrj0A9Nu7HCxm6XQ8mup8hfl8Cdg60AduwScybS8YGnKjFDxVwPqmhSlOMSgDgFsmSXMEXSvCSXKjBUC91NRAn5WEvqmldRwaiqxuuwEJPR3ho1eI0ecpaAxacDgEDanD+N9F5P1InZ35SKWzAFiuuYTPG5jP6Qa+82mTvz9aSaxdP9+qdiksJoY+datjAyYOmZ+Wddnzm2+LVnZYAD9zpRpc1asmDNtSkGzxbLm+cm5uZOfXzONqRlZVRpqqELsJCwFfxk4sTtEUXGxk6O30dyTReksWAvYNlAM3yur6dWiUgNgX1DMiye/NFnMe1vkKpoWZdY3LW6qzxSxd/n7coy4jydQxaB1dw3j74Y/xHW2E8Y6MFMeKoh7gBLxHxmokho/RTyfeYjrThsLiCE3sVDVsqi2Qfomq6kxszZsoCdvmDULjD0Ef7p/2eVD4w+hbxwEStoy/4W/rYd/eApefvIJkP0EyFv78wvzQWNiLYGbfjbr1T+/iv6yogOzwPvwdfgTyuHysvuB8tAhWLf154eaHoAfvvQY/Pj4tEe/Y0TdcbCYbrwa4i25HrT9Jvxog6PLgM1IcPu6sKnCOkVHK5ZusiGFLjyhqoOQehZNB2jsxO8dORKPbMLJYtHsoK7EE0DwyJH4nXAsLubvVYxpN9Zl9VHl1AhqLpbFYCkdxpHXdMp/O6W+aPndeUFQxuNJ2LhMS9hxIYqF/iKTleV6RohaEe2krmMKSoFnlRWZNOHC2snsRjdlViihgcxgfzFMXjXZAP5Ctg8rqvLzq/LZHePv2r1h913j+y2c2sxq67Rs89SF/TqoW8WyIex9IRpiwijL9p+74Ik4GXopCZX2719KAup8nH1kUs3iKru9anGNbNv7z73E2+38S8+9v012y9hEGWceNQj1WjXNG7VxlYcuF1xqbcBFaxI28cltEGR8djSmTVZscadkDHbUtd0elIQLXzxy5KLQJqTITZ3XnGBPeeegHYv6Rah+i3YM0plMOnzFxq+4MOyA82fNgvNhRwI6Ewd2ohGxE3AJKE29U9c8/dOGDT89vSaVt2fa+e6XibLVPDIf/c9qmAPsepMdm07Tbgeq37+sVluEkjA/SKoXbKv7um7bgup/vyZVwfL2Puv+enJNWtqak39d110ujMve6z8rO4N6uwONg3+n6COYkSNK/c/P+HrG8/5/v+Tnnn46otz+dnb229u796f+/7v+JOLtrv+sM90xm35l9h3/u47k3bnTK3ShhO+gokqxRzuuB0kJBMUBj9htV4p5q9ik63GXa+sq+WTGnF5WWF88OjcnJ3d0cX1hWbqZYSO3ip3c9VRIqwzjMzqEAs0jG0O1eZVWi8VamVcbahzZHLhVHNaViT+UoDtBoVl8FvouZLc35lJd4xYCqNQmvE9EaDwqekDnjwGOCWndiUF3EfEFTg7oQQLSJUwKQKh2kUkw42PQ4sgWKvBUkYMD+N0uM42WxdI5UhJb5FZK0KmyiBMPryyt6tWcnmKbuk0xV9RSHw0PnwPfq9s+RcaJtk4s9gxgw7W+8PiCPlUeOMx6Ap/b8h3wkrsCL3uTszLAMxlZv+Bo2+2ZlWK6yhNe4R3EgXBRur+Qv3vqL95SWJeUX9+yZDjIrJneNmU7mLjO0Ldrr6cJfeNCCgNy4WZxCLYgySAOwghIy6Bm8cWsRBwJ58628OMlEs8ILJkbxKz+hG0KP3N4XJWtalzVAVfIV4tVcUP0U+l+vo6rEuJtz2xZlKYzTdk+8x5xnfL2odH63nMzYNi7b9bgou1TTLo0LlzlibbQamweGv3xBnXWW+vLSYeUNzcd7LWlgJ+I3eiP8QT0Ds/r/cvZ7VM0om0zoTIzB84Z0hzIp6nqkbP2pYOnp2xny+P7QIIOsAvNogOpydiPMYfXV4KYJWAXVMY7kaa5mLoSz4kYzH8K8EV4Q4Z0GZ4jGL04KggYZxyWmjPEMEcCeHuSIXcFG38+5ruiHHiJaSQW9HBs4cmjFaZgDQc7Zu3bN2tB7sCx+2Z58ujFaADvmzMSPj7u7oNHrRlVHrMeNBRWgBAOwU8t2hy1uqJIrwVN1oxvo0uTjL7aPCetjJIVKW266pk/p6EGDMvxoyXoe1sycLuXFvf1uOA74e2FPs66pK9Luu/CPo1lff2sfZq/7psVndq41TDCRL/Vf6AyYPdUSQ9I64tuUCiwQSE2G5zGopDkiDLAaK6Ja32ZVcozodpZtbPerMiZHqF0I2R9c+n7fLWr7YXwkifYz3P+fL9c8VBf9gDN9s6+R9aDGQQfD/Uk0OnErxw4O5kV/BHcQhhoilHXIiwXxpjF4IYGeww1yWsnWhWxVQEe1rjfmjiMzhwTfq0pn5dB917aUg/D9S3wi+in9S2PLgMPZkcbpu4WV7bUi1rHR3/rDkUqzS5GrZF605hQpBWFxQPy6PDYzBIuJC1Kg32rJqCxXKhWgPKkVKxUbnaJqJLCyN/uPwMPYY8vJ+9uqbctezS8ecqQGbb6luutYMqhNYyi2GW2OTz6NJfNZc5V5paVZKpUranOCVU2s4s/rPCkvEEEWAImHubtiqjFmGahNT8aTeTgj0G8pYAY1Bs2qGVikCTYZMnBYO10BxMHk9IlBFGD6XAzFQWAYKjHc75iMwjEwU4Yhw4HwbuDbtNNU3CL+VXjNetHDVunHzZDv27Y6I3Kccv5ldKAsSC9MHnmvtIiyFWPKHSVSx5cs1NS7ioIMRvMUyRBV34Vs5hnxVPFxXb6uex00FFSW4yG6tnQAIYN5bvLJYvN+5iKG9TEWrCz1JtnBJ+kWMdvkY6YM2MofBCcGDpj0SjpneOTHJDic9RWmWzPzGCLC27wisIFruhIeoyroCpfpYh+Au51eqs8SjlMtyy2wvm2LDNYmdOnuMb89Z9YIAeZCq0sv7rABa10i1JZUB3b88Xt6iUIJFMIEtetKV254GTc4UuYB4QAGrVuQu68ZCbomghuJny6mJcp/MOyu3uyqooHCsTvnNHBjUsqqS8RpoiBfjRZDPTP3muUThmYX7ygf0rqhHWWcermqmiRQAj3zuzfa9+fbcCG/zg0H0AKht/x1xUTIphiAC1Nky9n9S7JLMfzQGhMYEitr4kuCwwJH5x9he5rGMVvnnB58Vy4IzRUIIMz73HQjln72mN2aMIvYV/cSbzYTqLWEU8riVX0aZiYClMaELBWMaCvkU8XqQgUIelEpnQlE0OwFKYO1K9QFzRg/fhAfPoQuiaItThDUF/cwrraTxZWKoCXXpy4d/520wjD1sbo1Fn7/qrZN6t+vUWDCFWKoe+Sl+wB5cD+gaJ6RJuqnjQ6DWaxYoO0yoOij0hCHZXia9NzKt5EVKk2dEZZlemrZS25fWUjdNs1A7J9Q8W5/c6f9/QLeuClQvvqWh9zm6ni6MkJ4+DjI+fsQ7wSvTjPM2vf2IG5CzAhhh1cTSDDevRgRSFo0Js9VZvV6hytBX6KwxlW0KTVF1WAGcak6NK+8z1XaROmu9EwrXTm1bb/xZ8DhtU0jIXvuDx9i0vxrJexBb7nq+3EgeGfYSkqmfCPhltr7hQZOZ2RJ7FuGcb1Skcn4tjH7fLpBOBQHdmU1gmYMKN1CvihVrFZoYN/VOi0SiZZoWOVg4BEqtgk1wLPq2LDcr3klTyglW9WSCWD0fkuveSKVMoo2E8k+u0KLdO2RKGNXCAP52oVS5RanTRSoZBJNXK6Do7S6cBj0aflGqlUyZyWa3TRa0kpvENCi3WauA6DsKaWUNlUmWCH4BbcOPhNsbq4mS5vswIgmTAPGukemyRUwgYJ3jBhtb3tw1c+UDWg+KxYItbdqxe/flCrFPSgXeHgiMkjakR58AL88Y0lS94AapAL1CT00S12IZjKRrsWfjPwMtyqUao1YC58AOeDYXCS0u6bPm53hpTxL3kD/tgjP1jbIyMUSqx3HqI1xNMVKAr487GRH5qguE54ozTsiqkCcYceVuAV7P9espuapsf+ET1+f7NSlifSqmUsq9KnWJ26uslNA5191WqZSi32KVSMOtfXkLfnd68zcpRUmifW/Iuku9943X1zY0YfvHnzCOQ3a7UNCpZWMKxcpZTzUwfVTbEolTJAywfrdaw6LVl/eseuUziVkvlXqdjCWzQ7MNziG+JxFLrRxrdyNqJTQklYE++WgICEcQdMEsCj/3QbJnTRJvrII00DoA20nYaf0UfoI9EmdA3aoO00sDfBMN2GhZz4BkmGo9Nwolgy/NjnTSBMdZMb4Xe6EelEbzLxEmAKuCVcwB2QADffs+vSZ4EKXm1sbYJXgSlz1BpYxuSCN2EZ/G9gQrHABK9mjmLqblHJ57AxSuMplAQ/GEaPVIE30aP/jbI7hbJDDzaC67folFhWfUVCcRmonDrKEvOy2ZcahnpouLtXgPiuKhdTL/MTJ8LEVwpJhal+RizkFdTslYAAsAEMzVVkpQ3FQTquyauzK4l6OpYGYo0OtDQn8MW0j6jN2Inzc3prwOUOBNyuALsuMDgQGBxxLziyAP2xaxfUD1m44Eik79FFi48++PVRdt3RxYuOoovIZ/C/T91+YdWqC7efYh6D8AN4Gi65sH/sqL3n6KHwJ7gOu1QAq1mwJjcomXcAXju48dv6/AbZCFv91Y0H4bUD8yTBXDB3L7jvizZwJ50ivD5A47f7J+B3LlgASBlayYuPAvT7+ijMBKuBatXF9ourWNn8eWMPXFiy6P17J0R5HI0+A3oty3rXeO956T54bX/LlJKVxtucUxbsB+L7XroHxU9d0IL6zPQbFHuA0EUd1hcmYI3oYNB3KecAK8AeyXlTTPkdrT5jyuUBrHXkYQQ9JCuLaClWLLICpjfcAn8BUrAcSOG+F9avf2E9yFWwisw896IzNUBmtcrTRqb1OQN/ThuJgmlANuDdhe68TJREmlEQsnP6qgEtpWMfcrrsoYIMegmQvvwKyumXV14GB9ePH7d+/bjx0YdT8jKy7Mk1hgEkF4XVWn0G/t2KAiNxfoaaZHtWRl6K3qrUmlmlw2z0JiebtUprAn4YT/mpINFWje/ae4CIV9LprnwSwppHJqwkhJ1koRkVXaKjvzifxvwvrXbZRGqj7Sbx8f3jN4wfvwF4pRm90qSuVeuWpqSk9cqQGjP7DLvbe1eh0SgxlhtPLRyEjhKj8VTx9uF9Mvu/Bv/+2mtATq9IhDplIM5pfPQXfRKXLE7KzNBqk7kkfV6vXJ+y+K6CWAaL6oQsXytW+nJ7AS2Qv4ZzA992xzcVZBAvoHprBb91eJFDNKEROYg5L+/kyCWgkxUVpVaO2fIVPP3kU/D011vGhejT+Q6wx9m3EK39X4WvOjyFfTPAXjsXHlsZvf4UbP168+avQegpmg+N67hkxwCLhX3t8B3gt/ct9KbDVfaYjvq9iAbMwH2OA9jUxuVzURgQutjlsxuUtMlImbCSOo16m48zCApcRL3OX+wrQqsOFMUzRq0JeGiUAH8miuc+hJeT4c+VwNcAj400jF2cC+j+7qHFajO4PS/tI6Puw1TXURr07mOwz7HNq0iqnghCF3frggvtFxVf8eBFZf9eZvAeAFuD0Z/sM+jnC6M3NgIATjP6d4oWjeRc4iLaUuboFdkxtRwczHaDL3196SKQT3s8/f5a/eHeQCHNZ4gAKKSDRbCfPQo1zHVXoRIgqpLLbu8I1SbgaUupJGoh4mp3JVA8vPJUsjwIsk49j7GxUfujWpJVQRrZbsWAOAQyG9Ersl5SYT4/gDEJ0UU+8eyHOd18si4QEfdtVuwPGA3lCjQwBQ2PxBm722zAPGtPNrvSi1C2EyRLNm2dyMCj/PIN2ybQdzYzlmRW0WvgJ+vViCEQAfWAgW89DpJ0CjRI6AWH0/pKZVy1ci5tT2EVyXr9oLYNKlqB0qn6V7z3pFsuc87fn1YilbGlyhFrPoSX4Evw0odr1nwIMkE/kPnhZ7eYYOj1Zhcujn0Y3Vc8d9W6saLoK/y8levH9n77OK1VKaTpLYdsfVCW1aqZtNPKKlIzmdrPN6gYOX7tgD7nHgdGtVykk8tbDlhROq5KMbdEogjVfrpOTuMqKAZ8Q16+JrFA9Np/xkeB2NxqpNIxOg7AO2tOF/pc/gwJMLIBxoVmErXTqKURxXACP+3OwPgkiLAwt//4h2+XR81H4N+98LswmIcWjUMHAOOBry/Ah94S/a6MmXru7q/h38HeRtk0WNJ+8mT7SRFFr9j0g1vy8C7wyP2PwznRmXfvSYXl9utgzRUgC+yDp+An0WEblfT89aBiqegkfgiPKxr3L+5tsptgo9wuGi2smSAWUQTwGGKIzifNm9wiKzYEwlgbShbNg24rwGZBHhwwobKzlM5IKwHLbIZfwb5zyrT97p0hky1UZH+/2L+eT671jhCrZMmcaUyJaqvW4K3P8k6ocZaXStDyyZhl7v3o7QNPHtk7OyVH3Cdv1NQU1c47ACIpLD3igUvw6g0K5F1bD4aDviBnPPxGyWiGLqTzft9bjBg/wA118KYC6at9cgaVpPASr5tmyzJoXqsQMxOHyspz0mqm+8a++4TLNaz/cTBm/iA4G76x5gZ15cSUuCwnhuMfEPw1skTFFWt/ovkpQAw/XJjgYdjZXui7AT1NoBT8Wl8x7Sa+FbXcxWOvH4TfTa8dzbKja6cD/cHXj90Gzz6aqnwS/u7LTbhvPMc8AgrBgwe2NC+9Y+mBt948sGzzstmb7+Es83atGd++PXt7+/g1u+bNWQ7Ee34A1Sefwz0JLItca4WPra4YXgImf/knMLl0WOXt8ERsfaJG3+1HKofyURVUP+Lvxi6sWhHbgkuNCol1LQJap4jRUmh1goHMMAyOkSEkG383QGR+WMEV2MmiFhHFjrUf75nyeBF4uOQreO6Rlx/98qHv8zTj3gL6F/5WAV4EyVYVdePpUPOIgtpp/WYNn7Prtnf7eq+/OWnkontWPO+ZDK7Rl7hLd+/4Iz2qpGDXG+OH3//3jcMWA37Rkd6PguZfhsDv0YQzESwxByZXLT7+HHhq2OR++Y/O39yxauT4YQM+3XSWHnjXa6/F5WxhXvAzgnEBbrmrabhpv9CXuDFN6RTXyY6lSNjNjNoA2YiIkI0I0BS14Q1LUahqArAxJGEE72cyZyOC/kt8vyEc03kRymVE8+KfUblMeOdY58V7aYISNPofe3tWp7mjn+GwTp+bbLUJrq/RqHK67nyjX0mGR8kkaXUs7bWWToQ/FlRXs9+CYnQqePqCGubQ+uxBgZV1tuzydIdBqtWP6J03qNTr0IAL1Vw4NKJk6cbZhyaO1kl+GPtYc3UBl4QfbP+2oPoDMGVa3sB+hXJzVUr1a0ePnhnsygop5DJTfqFt6pPC+lZ5g+JuI/KSftRj1BtoVuUFiBBBFRorkGMl7phZFFnE4SBaIRj5m61XAjHTFZOR0xOI4nSSic9B8jF5NTGLK0GVHUWmgTjsseCLSRNDbxMu0RoSt1bsM+qx5VsMJwaXgTHqO4uKUxPNdjIQUY0W7Dpw9Ni9e+YvCGbL2WIvB7SWoumTwxt23L0xPEkkVckNGdBQVWGwaFRSSbCKk6rUtFZcVaW2ahUivrJSa00Bb3nyhtZ/+NOH9Q05KiApLpI6ewNmysw9u8+/v6vMb1Gp0WrPJWveMaB/8+z+oXkbmp7eVLN921tntvmSaLHUbjSkGTTMXKs1chFkrvLMXXHbh/VD8zxpEpnMrJDws6aF92xcm6JFpE+x7tEH771DJloQDIUqWlp2zRhpEYstgBnTd9X0yf6SkgAqMcvonHQDKbG0vIpT0yolL62sUqdquapKjTVl4NJ5M4fWjxtX39Bs51M0asuUajCM3tI049yu3efVsiKvmGFEd8+Y1q9//YBGOKVPzaanJr65fds2Xzotk0jFnElFP6IyzYOp2cN1nnH1Q2e2gPNivVph5sdmlxRK85MVarY0VIb7TOoNSvS5CGOPBanFWMLm9Bv1aDpwpHuwW2DilNnEOv1OjDaDODTU2RG3r6QdSiabFgBu/EaM2ZeGGRIsLVAyZJueCwhfHg0UJzFAtDIGoCfGCP5yoGREKpVRpQiu3f/Z0mU/PHNsarqYFUkVXOscsBEceA3cK9Po070arcSQr+EMdnOuLgeIlGIJJ8L6v6JZRZ5VcEOK06VU/ClzsE4nU7qWbdmxvjlY0nj78m1Tigzpo0SG3sW9tfCj3DGrT06f+sCkyuRoU7+qmuFWZa/muZW9RaJUnTowtE9hcOyS8VkSlYQD7JLCp0ZmfqCeXTgsSynV5e038hLsQlRwFkvT6gIRLwePplUVZctkbc5Ber3M2GtUpqhg2N1jh28bX5NlkdBrKm0+2uhsCKT0XjqnobCoZvyQ9Ojhkfm5xuTJeSUP0Pr8iZ02P2EyR3mJhtbsBJvQOKpyl21uZ8gZw7T0xTAuuR7Xgn7pr1irx4y1iIvumGNwRAgxsRRONxIdMCWE2XB7mKESkAwSghxVV9ylv9KEyW9T7CjYogsahQnhdi02PaRDPXMiwW7toyJeDrxEg82QOCcUGbG+3b/GAv0XDYraikWTQlRQG0FFiKBVIZZEd1WdSfRPFb5lq6EYcCSeRhv9gKVab6qzEB5864aq694n3IhzIX3C2QVx5iJUudP3UMwO3WTU/5+1wyhsZf7KK4KN+auvClbn8etXXpFEbP9Z09xz6+w6r2Hb/6699GgdlUmVYKxYiQCaFGulmLX+/1UDcSZISc1S2CYU/QoQ6tLR9J81C90bUhIJsAkNgnIj2UbL/oPGAJ08b2qMjgAyNcdPCdIJ0Gp20UkaU/zoMl8nevIiymWObASPK11mKJw6hHh0FOSKrLD2IV5HqKJAp5w8Dn7gJDslnSIjP3htQ5CYfQ4Hj4BceAE2wgs0hSuz65zWon0UtKqiC/Ar6LvZQuE2yAWP1KF753bhZMseFWSaTvSdPyZzlJPo4BARVJe4petjYaSmeLG6qGkMuAGzkQbR+1LpdktmO7E3pUOCVSqVaYm8AgQTVYbgpLW3Zlq2k5Q0alv2j+irb7dgQEiCBOYyhywdV4iOv5lpFQDCUHKcprVVkLeLKa6D6BXjsUwJe8k8ELmdXFxj2h9A3Bfn9HMaTuNE/wE6819ajNpoOCkpem/0XqlSp0GXNLqkm+lmW0cSHepoom1sW7SN+1lvbw/rbfwNSib75RdOprdz+BKQS8WBDunX7C+KDull9pf2KPvL5Q5pomxYg0rli883eKOWtCQqj/0WMfGNcDyscLFpSqHTQBsvRifQxrPfdrvseEQsoimtTiEWQXQSIWa9PaQXo86jQ3O7XgxwoGcMc4OS6toRk84AFOAQzx7fr7HxeJhj+xoThRVie3hUiZ8F7U63iBMRU8xAkA9gJQms6kkLjlPAu91PP8Kpf5837XHYXpwu1zNsEudU2lVmpYrb9fCP4D7wLbiPrk2A9RT+gAc+CC8/pn28RMoApUxl5OxKp7mgoI97TPTuJ4D7scc67XkTyu0hiK49bIPiZ7x3gsZLGsZzQ/w45ssz/GoX0HdWCMupfS6/C7uU4ALEJxV2CmMFt6zZVdgMD71/97pRKUmee1fmlPYtfw9Mef99MBRXuF/tm7C9sJJTJbEMB6S0nOYLDFlJVtmhZ7tEHfSzN9c7vPW7O1reHVjUNHZoxRyXSLz1O6D9Dm59AjWG+Mk+SjGiM6yaVSG2UOwzlXgGZI4Gon3rvj8xbdqJ78l3lLAU9w/UA0WUlFJgKq1BfyAZkDM244XoP01+aMCNBu7oSXiJWRY9CTLZwzhMD4GXcSyRGzbcaBU9zoWIHboIUI50xsXQ2HtrMGb1qhXWNwE/itRyRtHjUvga/K+v7pqc2zhghHbuoKRHPPeNmLjYlGsMVHpnTBMrVpSGloNhHUz7d3ASHAr4I6AKiOomG+7JvFMsWbsVfj7y+m9+M2KrGdwhE3euY0UCLoOUIGvbAaOzow4sotoptvyTT6KbPvkElKOJgQLH6GUgC/4xegc8H+/X8We1VCU1IvY8TzC3A+6AGzva5tBKN4DVlGOgINgGC62hDHYfWnVijR1vwJGOOeniIA18REnPp7GjlVwsHS4Hs01em5Y8e3ZyWq18os/mg/tsyeAJR9WAwo0bmur0UkUNaN0r4mgATrm+EbEsI0+hl/p5jobfm4aZ5Mp+uPhsq33YwuTS0uSFw+xNTUdt+YZArVO56PYBYTFcp5QDvnGkEgCWlXJgfVgkYupTUlJlkd+OREshRi6ixdOMvB7epZTQkpFC3acSGoT3e4ZiL6NYz5BsyNhimzAxiHanLghMHFEtwWPF52RYouAA8OxC5hngRwuM9NjCFK0Z9YLnQVccBlrPU72K5BfhDlgPd16UeYOLh43o/RHIWswkKcEC7YCcYGPjqlHw6WaQ+3HZiGGL2x8YtaqxMVjeyCD2XmqVZR05ciRLZpXKZDn3TGiccI9x1ajG8mAj/XTZxGRP0UF4bf9+ID6Yn588qaxhScW9UlqiUDNDnXkol1HBgTBTck/5EvgNeUkjbJJZZVJpdmZmtlQqTZPlFEkkRdfwy0atIn267w1a9DJqlwIsfQgyeBsKazrYrQzq1BqRHLF+GJQooAS83e9h89EKqi9Qj9j5GgB7vgHz5jd3HAQzH/nDH9+uGQe/hw9sf/VnmvnyDwW91fRKsS04pKHaaNx8/c0D9Ferv3l378g/vPnyjVfmH22wmft44ebAQNpfA5p+9xMYPrn3+gmDVg8qMasA4IasuyfeX4luvYBGn0JRqKfFWArcIbERSSez5JVQE6quIQYHG3FgMxUR4lH+geJsdFMUq5iDdGLCgrigtraqCZ26nS8Tu5UCPL87yZYc7giCP8kA8SYlCKwReUQsHmVPcDhqYhzYPqXICpRAVPDRwJ+37762Y8TOt+atv1r3x3nw/nd+Az+6sHr1BeD6zUWwAIboZxfDWvjDc3EJ73OABcduv9/dtMWWJ5fm/TJ/+Z07ru2a99bOEbfNuf3R1tUX4EeIeqAsPqT7wSNR+FEXrYQ/X4WLjwBiToLayYbq0RbD043hEQTswK0BaYjO0XbA7Y4eGMeMan/2BfZ+/e7od2AclEceBVOZXmDdPZFPFzNjoslNEyMPgSH0msindK9424S5H8l+7u2ooxCP5J0uazrDHLZEIZos6IyuEb8aP/s6z0Ha6NV0+iQ2CHA56Jgq7D4gYmko8lvpbs+gs0EjnOmwukmN/mgqfo6GW460RHF054+T82pgs+fabXkuwyC1pjev7peirdFlFgE1L+cS09LqNnXXX1QNQlhhDbbSP6rVLXQLOpCfiMcGv5tVDpPNZnKoNFKVSv2BSqGSbwSA4UUtsYTRHS1qwccj6auzBAQsgd0qB3ajycoRvj4O8iasJFE/47CXLjtR+BG8PGGpVSAo6gVixAfPwI50JYvVobH7RzEqH2wViyW8OvKQ06PWpJnSbJomxKkTnh+ipWSTrSzXY3FrdSZLbl4SvNd4ZyNW2mm809iclJdrMem0bosnt8w22zA5iCsdnGyYrbGhfDRqj5MdY1PTH4td4laOlWrDZbOdGUFbhropnrlW2aRP8bvq3Fm+0pr04XP2Xdg3Z3h6Takvy13n8qfoS/ujr9K/VJ1hC2Y4Z5eFtXpZd90AHo1iO+FJiPILpcY2QF4S6qHUsnpISTRaAujn18Mhz0TX0Ztvpa0SbBkMFPAfgH0hEgYKMPMWmyeYhlxG38WNuOEyahA1ifggdovi+E14H0uQVRtNmNy7hS1+ogHX5b1D8BFnBSbBDTx+TO12ERFVhrozCoudCBcgmlvt49V8VpJcnmaRmlZ8sHLTF/459cbckKl2Jv4crHHI/P1v39Xx50d/PLM3CIK//QsYa1q8v32SKStJZ5Zr+/fXyosrtJMAtcmUZdKZFdo5c7QKszmoBc/1mmjIy0+yMNJSa/8BK99fses2y2BTKNdYu/fC3vmD7zrz10f3f2l84Uv422+SX77tyR12habC3AzoZnMwQ2G+qxomvZWu0AbND77+2wfMFRqtPAXxFBk3KO4K2Yefh9hIMuvhsSrgMmIPCBw2f8GCNKyemwaIT1LWjbfffXERG8H4cmQDD0ssvohXUytjsoq5K6ufWbPmmdVXFx2077o694WVk/0OucSSN2xWQ26K2GSZ485ctE+b558wvsaiWnzXjKyssZveWrH8zNoxLmuOP1dDi3Tm4gyPRa9qdDqrp2RLXdWrR9XdPr6mIF0npRWj16wZPWbNmlOqJ5cODA3O7jNyeINXqcuv9GY48nu5len5KVYaTG8w5+W6ivLSFXxgzMI7JgzesX5SaXHDrJleT01OqlSqdflH+dU6AIKDnUkuf0Gv1ORSfyjQz1/jTbTDE+zXb9o9cPa4TnTETbdqlTfI2hOgI+h+Fe7pc7uJJiO5SygUC4MbPTxrd/Fygr5NgFjTd1rDU7YgUHvQAh6ojc5EX2mJsobYNZ3f3aYdHAaZ7bt2tcNL6Ah+wGVo7SoUOXA9C97xxK72zqcGdyt6Qrgb/4o9Gt7Ukt1cmIcScwCtv9ZWN7UP06N9/mnrBBJtNf9Va8zrqs//oAl66kc5qXLEa+iIQTOBVweIgSda3IISfOe5yIiFQ4InPNJGQthvM4o+cTA6Xer1cKpOxzhE40deHz6SyUgGFFk04QOVnAHXu4pdiEajI4bjCsO3LEaDwWgBpUz/yHWGT7Inety0/+YGJfiewBQqHr7/889jdnb4ZCAIRb2oGmxnB/AUlQPiOr8xDxho7nIzHsQRETVrZ7zkRmGUdIZ1fqzjwojwpOcHjIPobcY+A9GfxXqxOXGUf0yfSSlVi8QDPB2UZ4B4kQpfg2lmB22js4rx0ZkMjmDHF8UuEI6dm2y0ozgL3XOYuWRnx+rxG6bpto15WNBXf3jMNt20DeNlffMexrBfKCKvL4NbMDrL07u3h96HgpE2OssMjpgdbJYZNiWnh1AYwyw0kebpChtQOIt14IssOp39CE4FLzbOx7fnN8L+4L7cEhwuQf3fjvrlZ2QNNgR7yHIwePPLztiLTEYiXGKINijqFY7OEO4lRI6UECJg20ae8XaGcA7MZyEYYmAJnwRfDIGASiplSzgzfHEon9SmlkqYwRCFPleR0Nv4hFKC/iEcJilB/6F8cpsqljIWwvlIsDjqBgWutSXdoORKZVsSfAFNb2pQEj+jQ1sSEO6BATgOnomf5XJh/TkbzTN7Y/aaGmJxb+I1Jp6RMBoG6woCNP6JtSUapARlk6nZs3fvnvXgPDwHimDBjfEgBFvHUzfo34fmHz/9y+nj80PxAPjTnr3Mtr17IpPAeVCE/p+PHqJujIen4Cn0AGhBY/Wtt1cVFq56G5Si8VoqhIWxmXmDYi51lotyBtyagFuHJQVYcRKd6OGPo382MDX6FfzjHLAYbpsDsuiUBSdOgHknTkT/G94X/ZJ+C16aA5aAJXPgJfqt6JeCXU1M1wvLY7KoQorqlBx1SpBEBM1Ph6VfRH6IpV+YOLOxOxxV11xX1xytIye27nMBqW+toqNNZ0M9UMHayDnaFLvzHk5Xx5DkdTAtDuzXqte2o05u1ms5dHo5Fk3kRsyN/qIo9yKRkqhRSVOxPxjs9kWXBUAhJk/+IoDdPkhAIQ6bmpmkyH1aJT8NnKP3wOeiP74Ji94UF3EF03ilNnIfk0QuxUwwIqGXKnIMoDgiEY2N3kdPNUU3wvcMOYroncw/0JUpQd7Whr4E3nUpxH5RfQ5AbMjdGPCKIExyerxcF9Qn0wXlScHtB54s0Fx65AjTt3nr5utNoPHanrUwk2AbhKeMhtEXVpwr09Xpys6teAFGR0/5ERwCX4NDP9KtbdEL4zJoMLG2qX4SALe3tb58bPqaQ5/ObASgceanh9ZMP/by+8JkEMduiMtPhHWWjspE/IBg821w+HTEE5m960dE/cDNE+OT2BSHVmYc+uuht0czkUiE+Qk+BkZgtdxoE+OWi21w0wcfwE02sVwuZi+J0ZLtRTiL3voJOnwxMtiRGRw5MsheCo6kF4TD1I01ayBGP6CEcORB/MQN6rHH0JgUd2SiPNgJ+/bt03c9NrKbzkoanpVAbMNelAawto7JyuJ9UxxDAw9Hu21yFI/B2QzAAZS0h2bCzSVbz6dnjJa63cFpjb5cCZtbv3jR7tr9ABT5LIPegw11C4b1KvPUutEwOg18V+9ssHJKhQL0aYbfGLc2n9j7En3+dw3vLNZpMtXWtJxpGyYM14iH33l83RJblYhJzzCUoZG/uve6Q/deeRMUbRnQcvKRr47/adnw4Sb4Ikilk5S0bSSVoNuWT3awiId5ygN41uZ0KclespJG9JUoICAKGvBidXJvUSCIoe9pN+bxYyOS7bEW6YlS1HOtwk2V55lhB/wWdpjz5Cnm1+fSKWaLRGpMlihz1WK/JlvjF6tzlZJko1RiMafQc183w+eJgJPeOv9V9OQXsOPV+fNfBRywAu5VWAvPwC/PrVhxDlhACbCQ0JlbrX9GFKeIgkFRSnGeyCM//Ono/obkAimbpd+6fPlWfRYrLUg29B/96WG5R3SUiFMX9HgTDs1ZcQ5+2eOFsOBWamio11cj+v1yrI0HoBgjMYchqx8dgbV3xzQ4UXuibi/yAKKTixEa0eTmpAWlaT0oCpBVBbYtxHqCRm5VNZfLlmeJmNxSxnF3YM8dY8/u3DT9juUPAvHeZ+2NZZztr+ZqK/g2Q67JOQsWZe1pbt4zM/LRrDFbd726p2PX4q29z9K/9MuPXs4uAUyfXPC4eMGaS/fdMW3TznPj7lyYAnJH/cbKVTWmXjTxWviVIb9P0bd68Ggzzqb9tfKti3e173llz9bGuTvPUj19/A4mvuB6+PjFKAG8khY2u0l0kPl/1X0JfBvF2ffO7KX7Wmll3bJOy4dkS7Lk24rtOIkdJ45zx4nj3PcJOUmIIeTghgRSIORqgHC2JdBwFRqgJZQWSLkbWpoE3raUEiiUtpBo883Myo7thNK+7/f+ft+XWDs7s7Ozs7PPzDzPzPM8/zTxa0Fgi4g2S1RWMoFeHTS4obcOIpazP39LL89BFO/HbnnctUUhr8tKYhZHwuMqL56YrAi7EkqDWrFYxfDrP7zq/TPSuU8fmjv3oU8BQ0Jw62CmuL23RBM4HW+vcltMZqee7OM1+asDfoPWFvAUVjvM9Rqug7erjj4GGlFx/YuVnhjESqP2CJ+n2clEPqxDXEs3tpHtXc1BLRDCCGGob3mAQBNdDSINO7B2D+lzSEikBdknpwfw2AejBxMEJo+wH/vyIYB6WKUDiFg1qBz8oGfq1J5OcENNo066ldcxNK9eDw402vTaeLnLRsMX2fF+RmUy87zgMaqZ6JvWKa1ecD/PI2ZKWlLUmZcX4NQxf10B9rW2gd7poZVqM7dS+iWtoGk184vOIZnOzsyQrD/uF63giIaHtEJ7vbRXSh8ttHN2m7bGYYSTwf57PsgLCFoAaY05Tw8RP7rRV5D9B6uhgfa+FScr0tO8zQ5R4xUMSjBdeqRMwUJWHVE9DD4GDIRKBfF9RlMfKinGiUZaNeKey6hWag61Cc9wNJvM2QABoQ9dgsgEIRluDXMA/eYIRHM078fuM5NROpxw055/I8UK/vkQoCfN6U4lOxdnXwCC7j2dIP0urTJJX1kELSxWmsBInZmuPntM+kJnNuuA5mVwB9A7a4sSoUq7AQCgs1eEiiJ1LiN8CqXXXUi39aYfyeWvGJgOoBso75u4UNqwEryS1eDS68boA0b4lc78knTlb1Ef+pvOLM1WBxbNWFNUsmZBp8OhcHVO3VwdWztvst3+H6bL+59sD/sF1UJNRRLK1WhawMD32Kk+AWcMozYJJdPYkQdZgSRo6TBn3c4TZ3lYJLRe0FSrAwIas+SlHUTvVhERqujDheAFIJJi4OUEJFKGckloluDhAjviLBRKpT5g7crzaTkVqwDBIFCwKk7ry+uyBvRKpQLAgH2i14zkisrR9S4PR5eFQmUVjvrLaTrjs5m9E/fZQ0IwiDH/WlstT6ZMgrB8OY7t2nUQR6bMmDEFR5dcfvmSO9Vda5VMiUOhU6tZi+BieqQeDAnJqtU6haOEUa7tUou1GoXJGBufbtTwi05IX5xYtD7cGQDApNDU0odC5UIQvSmGLGx9q1X4McaZWwlqVuKEXdKkXS/jhM4/A+rPnThpCZryfiX9ifhJN+ODoqeP1/UQbKM0VY/mYoynNR3Nx8uoNYjyt1E3U9+j9hE7e7KjEsiFMBcOTv/WfIN2NL8t/l3ht90PoOy5+PskkP/g9/unZb9/cY6vvcTLMlxOAmn5JWKsHGQHxC6ZMxcD3V0XngDlQOq6OG1A5Jxuv3w3/gO3XBw5Kwf0gNilMsp/Od9l3DmO6vMIP5IaRy2grqBuQKxArtVSvUiZgAe9FlTybElb+oylUgRWDXc9Yu1D1huJvNfb9kE5TVbqkJcjvWJQxp3DDKqMvyayYq/uZi5Blvv/QI5jATUFSayPkAj82JoM+D2ukP7UPiyJL9xlTQR8BeGAjJmA8vRiN2RJftCMgs3Tpl6DgtdA4DVwHeHnhHy+6W6LwmBMWp4AQaXFptYUG6a+KvIGQ9LyyX1k0eEueemh5Dw1BVDb5AhVPWtSLOIP1TVE9p3CqzILK2eMLw1HkzPSMooKrlMOGOJ9cgvR9sAuHnG447XXbsasnSgcXoUehCpw7RbC6p3ZjaLo6Tk9XPo8pcjm9CzmUT8i/HzO8p1wuynsgStGrGty4Ip49tER028+LqvE4haNE818NN+FwkEZ6g+jZAopUzrlxqZJfCqHiYfOiMf8IHHMR3OyNjteBU/3fityLvOIdUTNIO3ru5DIJVdD0criQZlRVNuMdcHy1oDKVxqsM9rgZb1n1bkr0gTjSH/d8EQpraWn7ikwOgImi8UUcBgL9kzlDE7pg890+gLjfrVO/PVtxtvXeUbHeU9z7IpbCuoZtrRgXGu0/LJ5ATv9aF8Ou7/EZZPzMIpAun8u0794FNA5gR8/C2ZguS/cWl6Rr/CEfeVX50JIUoHJbzd6jGD22ECrUak0tgbGzobQsZb3g4y1TLsGqHcD42wbXzfKXj10nBE9G9VTVaKKm1o3SEdxDumr3dJns0W/R84BSgN9OQLfUvYAm2OBakI87FS83020o0LePj0pxJwSbAoSIz0RiXa5fsoR9X+5n9J4jwRx8b12dxhvhw6Fsaob48UdRPrtayi45slr5uMuhAmeQJsEwgW+QMK6ayGm4X2n9CGXxx9IWjt3Z184nX1W49Pcr9FwGXT42D6s4arO17U+eDRH7jty5A8+xHA8OCL3k/SMZDRcOn5G5UKyrLkv0lAX8kdik2ZVo96TvQEXi0r1aTgOHbUf24bduaDzdU3/NXwzNYmgLmEID9nPeG6PB2/x51iBMGblMUsAie2+rIXu9+G9DjQ/4h6Vc3pSR3yJ5xTGExd7R6NnahFDiLhCs7oq2dzktDqN4A+jtBZt5zZIl32RV9x1e8uBnTbAiLrWkkKLyy3yeUM9/krbvIkdOyZbOIGl1auXlI4GNKt8coBxXtbRGH85rqYBnJWZ9HBIly9V6q5gFW1QPD3kY85460+m79jLQd/Y5MxYXsxrQ52TF11NHb5JixfuaBcnixquxgSUUD/QTA9xqUHEQ51gz1M2xKdSxF8dkmggBmZBDYStdEwy+mpYvkJakfb7+mDSzZiAcNPQaURshbJKF0HRTHiNZsjLroHcAP6J0bqs4fCCxcbA0Bjj1JhV0JAxCPALvYIT2zOeQ0/qOZVLYe3afLh7277wxFToHpAfjXrzvSXt5UUiy6tUKvDhN0OveHZpMgVWj2TpOQcniB5hPfN6nsujt1ZJ/7i2eOyoGACsRtUGyts6s4d4LaANymkKIXC9p/PRO7oObS/vWdDoBNZwfHgov6B+2uruQiWkwVenF59+4UZBKd0xU/p+gK6s0/I/RTQE0Py3iT1L1VIdiI+hMGoqXkbAUjAqOUdI2GcL9lBSAuSxDbBBcoId51jjsoEcFpB4awzSvYrsHuyvjhOBgBeB9QBbv5NxmqflLUUlkEMhFxdQC+JMqTQisnqv44Pash0F6uFczJv9q7RfGa5MhQAjZSKVENaEwdPZf0TiHFcZVIFT0oFQKcel/JwOHP0NYIBVb37ar7M5LE+fYANnAA3y1F5Pi+MmyAGvib5Xz+hLNemFMLKjPPOBrzAR/MSm8+W35QGV9I3FEvS3mv+6XW/xBUcZn5+jcOcBDayIhCvo6abbCiofjNZIs7xFTIW3oiCYYr01kXASZNhMxF9S06WqDwZKYHcQRLUbrWPyQ69sDMIQ4AALPKNsVrVzJ2BhyWJwSPr7iJb3q52putiDtYW3WYOgIn8M4rq90n5wzN8umPJ80lQwxj/KKNhD0oyf6Vmz4WSkBlTKY6Cbp9iZ6GtNQ/IAYmGCMngBokcOTYV4rZXYmqSwNodIRgQiiyLxHRKX/3YgR8No1sMQXX5snUsTwALBHLQGBBgkbhooTPFibiRFny0YtoLRkJlwb6WFYVS8jjPBJ4FmqfFyjUm1YepsoAKv7zSbO89/DyWpBdWGjNTEV0Xof55RaqsraakiXJQHNqh11zILTxb7oJf/EZ0sA8ZHH5c+bhzeJS11miesdxY4D19pBh1K/nFY+aOp7rDSbDBrRIWVPrvyJa2gyhj+S5A+/ZNnpOem32de0pqVKGENneTzrKyUkobTSObl6RHOgqJsI6Mq5n4O9pSX08Ua6SnV3M5lwAQsyzMPTF34LKwucK6fYHY6zVceNjJ8rx7Z9xiJXYC4/BjBy8WjqaxeSgYBK8fn1HG9WHJKpcWwGeqBL4xhnsJi2BIKu5FghRfdsFqRPPzigVQGVmLsO2/7w5927Nz+xc7uCV6+oe3Qh6dAx0lvQ2XkV/v26Vz5YzcNL9HT6fSILZOWZMe2nRguwMIXF/l99uiy6i5HS553BfjBu/sOHNj37s5/7PDUZZx/v//BTz99cHKbNjCz9aj02mzAem+8/40fdg717f8+fOd09Xnpqda1m4JC1622VHVwnL3YbRhfteC2JbVti3r9Y5G5w05FqCiaT8cRDx5EfYzLuQvAOBkEJdmbogngFS9Wg5QRzxZhkU0SjQMCcojfOMeKDZosGLszUize9afdd19WXsJYa4bc9frrIPn6YajyxCdWWiyq90NMe9VUcFUiMnZoe17LFhdzY1OyKjHKYgQj+k8O4LNRQ23KeGbVwYOrLntAKCq2/EZ65a23QTYvVr/21stmiPT1wHD5kvYnwndH5g6fYBWGDikIGmcPSa4JJVvKCz+/aE7off/RRG8u2duHoMyhY/vF3LSIbX2tskoPJ2N54fUg7JkKEoUfHBDdKjJ1DtzuPS82znXx4Vg4aNYUqBkFawxsHX9spJFlVJoClcWPrvCZreK1UKE3aBI6f6Z4WKRoeFHGr0toDToFvBaAwath14isflJG4PSixiUKNgOcLoz2j5p4r3+0MB3q88wWl0bUc8J1LlaMimyhoHT73ehPYS5gRXB28DoYoPSoHVagdsCtkJJxwGRFJoI7SBxwWXPwYFDWa8rZM8nNJDebTOpYgwLKjiYS8Rx4Od2+9e1Kh1KnMzWYXKn61npNcPNoZ9L5Pq8wW83jxKDNW5eqm5JKTq5N1XnswbyxRptZwb+PsozaEtDUj6xPuvQNZpNO6ci8x/aA66+oWhe7hXcEnN5iIezUOzu252vUnKs5X10R1LKsP1LgcBRE/CyrD1ap85tdnFrjvW4Myhg2F3kcQTt/U+n6qmvXD6KB6f9XaWCwBwOWkukgiuhAXaAhdLBlwkttJk6FF9fMiPEgdHAdVOgM2oTWP0SmgyF+bVKr1yvAdYAa0BkQEegmDcFa0zkiqE+OCiAiCLWFRkKDTSYCtQ4TQQwTgUomAqVQRIu0elBfALJOIuKr8ainY2X2B71ggOX4OlAP8OISS+QnmgsTC2AuCmMgWZ5En9lEoddnrek6BjHVSmro8oZyUaRVCau+eUi7IjZfekj6/dQ3Y6MM+mFPjt0y8mnEcyvVHPeC3ttzeodEbe/Y2l6oAdx1Hx8FS37BCpXlzRVJ3VwYSgybkWzYsKaBo6JTm0cUxjjTp1FXfaiY87yse7j8SoOb5x2t3qDWE6I5US0dcvF5kyFwRn1GAACXBktBDVDqfSUjoo8ybd1X3DKkY01Lfj8/WM2IZ+6iZhPdNjMfRuN7v58vnOZD/X94VR+N7f1+aHjk0+KAXxIG/ET4wOQQMAlEL9soq2eTA1vI/uWkEH7n0eL6PfNqR4/WhUaGdKNaGubtqS47/E5YOPkpy545hTNEa/fOaxyBBvdwSM6xtzb66NtBC8rh3iN9uXfNe3umTt3z3pq9QLtnRHZZdhm8Ff4sW5OtYX+WJfgFsKfEoxs1ogndGDv8blD86HOOO3NaKHj3cNGQvfOHDh+tK/T5C3WjRzTO34dzoIf/heM+PSUUvHM4Vrtvft3oUTpPdD/Q75m258TaNSewx2Y9dGehdBXYBCWw6etfgrvpNNgtzTn3C7rzXI+UAUfpHnC0T8+S2BJFqBTGN+Nz+jBIoOh1phxMAB3HY7NX1MdAQgDG/FQa612G024AxsLH7Nl5S/esm2ZtLbnh2DH69/+Q3FZ/unzk2MV1ByvNZunDj56hJ5z7r6AC3jer3TZnIxsavnfpuez02wV2+Ms30PQNL5/45ova8ctGjinLhy/a706Wp5Lwd9knwBdnH0ibGN34G1yNvseoXl/vOV0+M5VPlVCVaDRcSq2lbqH+eMHaAIlJoZz3QTTTXToy8BxwOTfZaTRUmHq9yllTva5GTWEskHFYCEvLHtXQ0EEUSsjdOSW+3itkREb9kcX29Yy+F/WK2LGHiURCRqx0KExGXzKS0WQSxxIdlLl1ItThgZ24pORFOYEe56vw+SqujtQURFzuyMMFNZGI2xX5QQSFNb0B0IyT3vvhFW/f0mGZf/Vad22F25tGv6Ved4WzTLv86puGG93TU6fdYw/vWDZLKzVnZmbqZ9fDVa3fm9l2S7q0c2755IAxUc60jgfWxpoq6UwnU12UKyCNfrGKKYtXT0slVwz1hie3Hi3NM5UMWdxQLQpWaKZV9jzDxK+3+x3VE8dWshotIpeQYU+BzV+SnsL8qSoWq4p9M26lu6jIvdJdXOz+l2fwlf3H5j10cu2kCT989/vSW3Mq4+Sfx9YFhMdaOeHLCas33bbrd82l8HB89Oh4YvRo6WT3fYubq/ctmb9Q4CqSdnPTiyuXSZ80ZPbYwcqijHx/Y2lTOxA83Xz06MqK+ZXX3n3luKTLRps5fTRkXnYNk6lkedaoFwCXp0Hz8+fusvb+MryNChItgWQ435LoU6C15jgwRGXBRLm/3G/xWxKWxIA9t9s5addvNBvbZ91ww6xpNfMX377/5Mn99/4STF6yZCn6B0yDWAi4Jt9zzcjJN790c/Wc2Vi/4o01S0nG1YO5Azw3BHPjZZig1GFqRYMcb/QbozkngRjBRl4xI5sLiEw5quwH94yQPhx/z2v760f2HOkZWf/cnbNm6V5Mtk1SX2e2hxjq3FOlumR1qfQDdpJteVNnT09n03JbU7EeRkwQ+8rE4/QYgtPBot44gZpK3UZRpngKdQ42yoZlkLh6EIWoPnrgN8axzwCy+Y0xybBdNZmKQ9aE0Y/d0qFM2KQBTWYpNwajJlwNQ8qTJ2t54USHPVghLgD0Td5YdRl1G3Rwc9ix+h3tXm+7l1OqKu1xf1TcOPZseyWoelSsCo5UT23Yu5v1ahw6iwJELls+Kla5zNhSbvZCVX5Rk4e/pnvanoZ5hyZX/trpKNpa/LwNya6GdrNrkToJKFIsUITs0ijH0ub86enCjQ0111yxrFQ6Jd1FFLPu1TW4qgtrMoFVszo6Zh3yZ8pS/oQDsd6z7CHQk8lkOG2LL1OYtN7QxXQPPdz0mloNYMPe7EmApDu1Qvrtspi5opKLm9JWVWFmdB6kHh/Z+GX+uPwEjJ+w0gmPMCkvcL2+oQUVhbXR7aEhY1WljZrySsanDjfFgD1kh/vtIV2TM2l1qisqNMaAvdwzxBAaoHMRJFzEBQYojcRSrGcLragBRRCQtROwiZaO9uFtrHCIk5UYWDcTr6N5qqvhm0xDl1pRZ2luXn/vUnZ6aXtVe3wqt/Te9c3NljqFOvsrwHeoaUVIYVf/cTnbVYaul3WxT+9R21Eare4AvKo9PqqtpW1MaQe98lyUQLK8oVfyaWNV+bR17czw/GDQ18y2r5tWXmVM88rs/T+tVdjUSVToA2NofDV/OL31clRWUm1T1P5UUeMrEcWYt36g3mMZ1Y4lcJDzAaOji7Cil+zJIocI6KarIVaBD6RTomBELxuM4lxkqx21wcUIBBj+vA7fhFsMolZ5IaygVUWHrmTChaNbggAEW0YVh9i1h8KoskGFQ931FttWPDQPgLyhxW0sgGm1/aUpQzuld+j2wmac3FzYTr/7i6pyHY+NBImbD9zAkSvAS1wg2taKy2xtiwaKTp+eFIHLEuiNfVfNoL3euNUaz/cw065yk7ZhlCMOMnUen89Tx7xUrKCzIXr/2IqWP8AGt9/vboD37SuLa/hzGPqVfuQcsaal91eEVoIZrNtflpdX5ncHHj7SgcmFUlOW8xT7ST/7DjvlpnxUCMmicWo1IiNrDFUrzAIrHQZBGoUxNKdy2EYbsHQQpHkrSU6HeaKHkdbDMI9NWWNYo53l/KHycIgO1QPsZFc+poNxKytaBGLobbFiHxtpbMuKXW1gQRbdDFpe8b0HTMCklt6SznxY+hViImt10n5w43Q4D0Jm1Hg+Ww+oJuljZq7+DzB7CqwSpMn0XebT8BYO8gC6HzMLwxTMn3l+Js9I7zNQ8RGThnxtFxgOFV1bYDdUgkdZGtRyZm71lSy7juXG0exrHPsVA/Vm5qcceOcvb0uJE1+9C7a+DYb9Knv6HdD0snSw/bPRQK+kk80c3Psy+PUjZx/78z2fwxUvgKcOnnvm45sWTGfYNVM/6Pkov2wVSz/DsmMPsPSfIQRfMMDIM8EJHJjOsyWzFeANFb0N3MmwUhlP146H3BUtDFOxlKOvpOltDLdyG83CO9n+PJwLjfzjyaop7dcxWPDzyauhiGzpC8yKJeciYSDm1gXnCQPOmEfVntL2BJd2J2LRWMKd5hLtpR71uFqYqR33yJ3v3In+4AaTrrur4WyGIGYcbegiJhvdfUdQWDl7zrASJt+Qp1LlGfKZkmFzZleOmDED7l58xx2LF91xhzT6qM50Et/OEtiNk0TTuyd3zO0nkHdUUkXUZGoBsZ/LaYGgEYvpfR3ER1UDNxuvYy7xLn3OIS56c8tFGG2M/Gql0RExr4Ef3ZA92jBa6SwZU87ycUuJKxKKuEoscfiYoO0mAMq544BW0ArnKUF7lqCKMKg30xvQqy5Cryw96asdMXlkpHHevMbSzoVtScajtirRP6vaAxjU7Qkys3zs3yq4MJa49sFWw0IOJ0ch8yT5aIwbQo2hVmF74SjsowBI3gj2gmXn4FJ6/XEbvyMuTw/lstMAYurWe9Zv5YgyRdoruVJHcWFhYbGjlKtsj5haUpBKjd3yky1bfsL4+qvSW/TZl/UWix5W6C0DVOzRbCLt7++AQyLQLBx6dzC+Z9GsSsapNyuVZr2TqZy1qGc8rMeFb5H+0OeAApgqcMn4ANQXUkfhb9KfJuXv0yVjA17cfluIJIGJBFvikakuHXcD2LufPMgfR/l3xIUBtHUJFwuXwLVhqJaURKVaLm7Y6/+DJkUU9HVGxvru758BQ36jmeXrTF/zvt0z/qIWBs+Q5s129zXkmb7W/aov7VycIQSJqbx/EwvMqxd6QtfAuRhraBSgeYM4IfXJILmER5adSlKGXs+MvSqOX4qb1zQ+9dpTjWs2iwtBC7gStFyb0zaGp276THr8iSMDFAZ/vvtVQ8vYsS2GV3fv+uEP4WEZDfwUSEm3ST/+6yDFwgv1MlABqpjYaogmi/mCmiV2DJlzHmgxW00J0ZuOh3KVha/IJd2IFSR3SI9/hspkltx+Qa3x9obPN4PFmz9/IFdhjsK6lEd+jCp8801/Ba3k9rPDXv3mblnXUvro7m9eBcN6eg7kaj0Qj8UjW9uAAUNeuleBwWKmSK1SBgFvBcAw5w1zZBeReTQ2flpD8cs3nnvwxpeLG6aNj40ec92zx5+9bgySOGRd7KJJG/fsvFW6+tadezZOgp/rSmdueXPzXe+/f9fmN7fMLNVt3Dkf5UY3zd8JhdzLfHPq5rmfATO/aRMv/eWzuTf3+ZtmZX8LNsqP9Xr79SYxPqArYYPaSwA79aFpDugKYyra32uvGBPZvu25bdueAwfOodGVlrmkc4TWMJkfxfSNSHpCz4QJPYtnV7a2Vs4GTxFSPruf7f4GIzmxr36T6R1WcyMChnnvHQuwbkkRVU21Up3UHDyekn1IJL7L29W4ut82nA6OB/vGS/mNLhpe+1Dj8wfv3fbofU2xzJOZWJNPX18MHiyu7yGqMMxy1MVJ/4PoXaWeXuNIQJyu5EykZJOpvlwYTNOk+xrF+YEdvyk1bWI8k4lPnJZKt7WBg0TXRjp5Yezs8+fS79AvESwl7de/q/+rduwj2RwhwG8bU4OD4uwgDdiLx9hLExJux/piaUJxfb/W/O+3Y8/XiOS4o4OHzybUdum+lgTvkFbMXnCM9MUlGvFC2rnDTPdZTJYDh0xIfJSdRv3ITtAZDdDvg0aDCTs5ZIiSM1mZAgkRb4AjQYaTvdli546ySSReOUogXuaPb5z64PjxD1oqRV+qfEQkml+24KFrDjU2gq2rkLgy4sapw9ZMbcifsXiX9OHvtm37ALhuX/fJsTsnHLguNq2qtgF+isSjSukl6UXpZ9IvjEU1zUUuw4zOxXNul7Y42pd2Dgm1dKQdl/8CRB54EBS9cvnwG579+trnpJ8vah7R2jsezFFS7G7KiySGO6mfEhtPojaFXkcgyxC5RXoD0fkP9lm+ku9nvqAm0etVD3VCsqSGsvRXiLCQzX9ZexJvlhLEGKIzQZbY8MIHYzW7WaJZEiJxwBou6A+kU0aCL4TtTWVnmEiC+bnXAjT1s069HV4eErz1M8vWXBGfAG06s5Kt97vOHrOH/C6m0h56t9E2OWxQ84ZQFKUYaX2RtYFWaatElqG9oVR5qNAVNwBg4hxr7igb1lxmczmESLwmUhN2GhQcrVBpjCqrs0DlaBheC9+8TqgaNc5rcFeNVj4RSVYtgKJaUCu8QvOVM7s1cI4ln9ZvBE6wHYwHxsQCh+Con9tx7Bvpj2+Mn0TbDTZxgyscsqMfHLF1VmiMWaXhlIXx8dGRqUJWE9OK9pH6Kr3NYqsEDANL3cG6aLQuOLOuyMyykDaoi55fn163ZPGaZHmk1KDUmF1CItGSKcX+pCyi2mm1jTM3j9y/TTrzX972abUeg37YWPUfQMnm44vWLKEtGqvRrBTyH9gsffRwYf/1hjwy6wupEI+EOBG7qbKKPKgEfBx7gLnICPvencqw99x+l8WQ9zsILGpeLc1AFLL4ZAYuvoQ9wn/BHxeHNNJjaqeNHwoadQpWJV37kTj/3gDcfSmDAq7Pt5OW7CQnCA4qldP9S6WNCaMbWDGKomw4SEjMm0qbiZ/wNDGEtBhFIWd5g38QjyzNVT1VzT1NNei0pukZoHqmR1by6yHnPUfJP2z8XjPbQl9/bpVldk3b1hKawklZqmRr25ZnntnylPQ14J86shkew7Fs5WZwnWxcQwxs/p+oO7w++/9t3cH10v9K3csTlv/1ul9//X+n5v3rriTzslz7vrqjueQ/rzf6+3dqPXrFitH/cY0NfRhMeKUJe6tvpkZRE6guai61lFpNXUltpW6idlF7ZY8XoNdXYBSkZWy5fGPOkUpKtGLsTJhzSc3k7IBSvfHeMCmnBAanD87/Lff33scNCtk7VarsTSq7qkOlKh4uVLTMXbjrPIUZ6YXPDet6raMYXcqXFXWnkEBW5M3el1PelTWCqQGJ/TNKJ/pHchlkC+Qp/Y4sj56D6oGqYVcVd/5p1rBdC88iRh1z9R0tYdeQYpVKOkTum3LRMUmK6PmWqycuSgldlIItW/t89QWpEoKYOpRqozYieftG6nZqD3Uv9Qj1Y+pZ7MEX73j1sXzEUL0vhv6oQdreoVwoDoqHLsFdVoMcHp5IlhXRBMQhuulPNnGR+pZyvq38wem9ca5Hdo5YPyRLDakXtNhxM8yYnCaTs4Mco+S4o9+5fGQ6ZG4dSSa7Fi4eGZ0fEdXqQrVaeokEYkDpDCbKWzG+47mei+5+41+myE8DR48+sOoF/ITVorjUaLUan171wFHwA3zNFO13NF2Uku0TD2DPwl2jBJ13YOWil8f9GHPJBI5edG/Hv0yR/wjPiHUdKVZC42yGGk6tkHW8eCTOElbOC8wYNgGrvuL/2H15APFxhGPDPCRe5kfcH1YXTQXSKSTP95lVmGVfedhbHsCKxYS7JPZgeEspSvZfU25AnzZ68kTpnJjnMYKj0C397T0FRl1gIFDse/6I9PKPN5w+MB2An+3jIU0DBQR6xW2n1yn41T8F9M33gNj7m7OnNz+9efPT4OCiaQrE21h5VVXDqpdWbDmqVTUOUfF5LDQopi+C9DUfXH3LP28FkyYse3fmlCkz31068X5AfS5tmEBrlKUmr15JjwHxJx8HJfer+MWP/HHjk9Lro2mlJU8Z0yg1TNXvQdmhmwH7/HqlasVx6f0gfubm89T6t4dxClWyQKVK7ehY9vQMjf5nW6beX6NSRZJKBddyYuPm09dy/Na/5nyTy3bFApoPCJr7IJRlNEycRd9D3o2Q5WYMP9zdX14BcjkA2y1Sg+U3fsC9J8lyZm5hiO7z70BTGjTWUxFgjEA0esvrsjkUrgvV6asTTWURoWAoeCTv0+gB2f29CwGwW3ZyDlGm8+gKpHC6vJ6I0/EKQVefX3b87tjXLhVMp5IxQA4hnx6EQ2QvEjspzKGgWJHEP3il7ns7VKqPP1apdqBhFYV21aA4vKz/q7/7bdlycUbo36Z0v/rJ6z7/tl/cQbX8GD/ngQfk56BQNSh+TnvxJwYPXDpvX1x6laG6B8qsvWM8oSUMhH0RWx8F8exK6TW2+xI8PJgLk9lfgeOX4td5UjYkuh/YF2uUaqR+Rr2FrUx06LXrAMvJpnHYTs7a10Ryw4R7r4nmIOnmBLUH9XghRbYA+TrgAakw3vDEciDe6UQX0TiC9czSobCPaFdhWRNbn3DoAr6OcS7RcINRcvBGdjoK+TomIRI9GVG+zorWUFjHoAEmZSI6ptiifTD2CKvWF2jUuqRBmqKw8goFb1Xwe/0avzak0cjBOpzEK0QDuN63MxWKMi1tmRAUeYHT0SzNv0hbvT6uYNJQoVCjgQEO0HRRBadaOK5msdPNBxKekgk6Z41BGw8LUa1Wqyop00LIg6DbJvrn+PKnHDEAlV5vKSqMDBeg0mu0VuR5LFqdgi9YyAKnVsu4RY+gh0o/FG2Fgk4rlLz0hGfCakds0fz68N/Rh3wMfbHHyBdrQ1+s7XMmYDQWmIxs4C2FQiHiVxI7/FptSOvT+jWasMa/GqcrFAZxSqYo5GybOcHsDkALZ1FZ9KI5TzKZXTqzaljaoFUDUFJijqhUeR3xcVtUfKIsMbslpWcyFYtXWtRCnh2AuBPd5GJo5/Try3WiYUks6ntimEGtMdmqRKNQ64acErB6lgd8JFg+t3Te5a5CjuPjkfrqxgZ3yp7nToWKvWrbYaDsTm6qmDZ+LA3BukvaoIO+dViMEGgUiX15PUjQgp9oJOYWoeoYlMZBjFTjz2fL8XcXTGHsl6qczY+nMWHg/HjdD3LzHg0Gm0qM+fN0/DyXviY1UfrHxClgjr+sNhYvNE2bzCXYHZ+UFGdvkLZvaiwDCloNY02bwFr43PWfcAaGneb1TGjO/tapZ0dkVwCWpmHJ8Juk56TnNzXFgSL71qhWRm0L1xW+F5Q6alkOaObatKVpuBns+LI2qs2bq3E0ZadN3bBulTG3H0J0XIxUMVWKeO6xuZU7JA/oGL8x7qadgMURSBSua2jMYpPEhNEP0I8Phf1IhBMSAou6C+vz+4qAMZ4QU+EQWy7bc5SjDOlL2qvcBQBkFTqlEknvENQAwKgVSpahGY7lFCwNzn6wfj04vHCf06zZu6hkZBF4gKUNJq8lYrQomE5z4IEKGoBaRu9zRT2rlvLuWNz7eP8tOfjhEUZUGHgFDcqhgjaw4qx1wKrQc0rVbqji1RwGGODUrO4MeE8qAO/97rYRKKiQXgb1ukarwWbQsDRKSOyu27fF5fXrfXdJBe5ALW0atNfBUqXnoaKV/Sea0SyUHbXizSgxFCZey0QKDysxrNMv4NEE4M0FoqrJ19HY8wUfwkpfEI1psF5GIuDR+4exgTUePNBN2NKN58Kc30vRvpCfwzAEojVKx0AU5YPWHGOEh7IAg7giZg3HaqNXLlrlMe5tAB3StPttXpoZF2TXF/mK3ez+DW9KH+zbKf1toVtfc9/3tkUK8guUDH3lLw+ub2b0Fb4rvn781mBQ9NsZXflxKbvtSOS67RvD4ZvXvnimRWdv/v3rpb7hnYEgRstpAYikjf4gGjyiwxbFXTRkKwsayhI+hVB/MAPVYyPbnOV6n3cv8IPKXb89/XNAK9yzlzw0kfa9Lb0Dq50jn0iVd9w0BJZmxkVFae8BEHhr44LuqrmJIRaOoYErGFSpLQ1tNYEVX1ZxkYYmW55BKdhm5M0ImpnuA9OGqDXW0CywASi3tR2XPrksX21X0WAK0IL4xgWddrumOXTtzZsLC6FFb89zODQqT43Ce/uNrxy8bJbTp2+pCY26TGpG3y94XsO9x/6NsqJekKEmEo9TqVA4B42GFT74FNBBJoC5zDo6zdmBBiBWkzdDM/EhRDZkABsFxegCB60hWMcQfHk6RYWxXyU3o6PRB2drXcMmVG2bY9Lo/VZPlSNQXxTMM2vVKrAi+fxfpC+kbz5/fB4L9KoQk5j/BRgHusGUy83wyzHbf3L8J9vHyAFYPuSP0qfSL6X3JelIu7uMHXnTs6c++/vp11rzq2o00rv/VEBo3/jG9m6Ldfatp7YvfubATPh58UOVYZfZYVWxNKNXaYPBgkB+nhZkf7np6Rl5ic1HgfWeyMTIWu1xaask3aU5cI9Dy0DP8efwJtBzcsDtPD5LMebRv0v3HDsASv72xvfmRKzj77ksfpN01d/ApCYWlTz1tmd//fpPdkyG7tk7Xpf1ScgYQ/YB8RpKPdHpXkZtQn1kH/VDihIsfh/2UIl4R+y5MvE/jQ/mhdBYVkR+5dgFaCJe/j+MH11uKDWgv+XfETI/qig4dxT7TKUzBRWIMfruW0gIqB6DweBFv3/3bP83GfwYFj/srAKnoCuff0co6xDG0Pw2Bn2bWzCvKdvhxrA0FQrTQaMVa9+EYoDYndTia8TFipGldViE7lX1I/gpVrYEsMTqoDfFg43NRKvAGmWAlRx0sQtbp7mx2ZkR+z4W9UC27tUD8jg0zQS1IIgtfzn3oaetWq0ubn06rY0P086V/nrcAPPyI4bloWRouSGSnwcNx6W/ztUOi2vTT1vjOq3W+vQhl11Z6AIpAgz5CqN0+Bi7AxdkT4q5coD+EuUA/aByHHbG51Ay0isE0zLlKlTawcH8RdqEFVVq4f5QQhUExXdLx86YCj2CwtTzDtYFfKfHpBA8haYzoPJu6a2gKhHavxCVZk1oF+Vz0Vg+V7dnTx0IFBeyuKSoTicXJL11N6i8dEHSsbtB8cCC2MLiAMAFcfmxaK/NjMyHm7BEBTCTiycVDs8qAZMSiCY0hzA8C0JYRkbjVoB9nm/fcXzV5e/fu4BHZ79etRuYHwbDpINr16nUR6S3jpyzgU5yDkqOHIJ3wemrf3NgDs+Puvn1VeRMuZ06z9RK96ySXrnvCenlY7ZrQOflIH3fk6DimE2cJK8/5vD/dKheIqpZivigUwO/EE5becS8lAArHw6iH/NdcH2PH0z88KGyx0ZZPrdIQ0Hp1dJxcOLzeZ+BTT/teA7W4glNekH64M0NG94EPkRtvjf/cil545z0BOiSvg9W55fNjcMFqJSr18z7bO6UMc+N6SJ3behfElxzCa4QyaznAT+FPU9NomZSi6k11FXUQ9QT1AvUq9R71EfUGfSO2AanDoRlSGEaW+KgeRqLGLTs7wqbPXNEhCBSglWUVyVSZDHCGifzPZ51UowoL1/UASDqADkRqdy6Bda3E0mXxAqMIroljLPk1juiMJXG3Y7glaYQk4HYYpArTb6BlEdgjXCyXAzoe57YP3NYzoFS2RQTS5bQ7MgWVjevxE0zkKd5lsc+0NUKtZpzBxzAoLRo1Cl3ZKHVEA8WiWOa3RETfwvLeXQODs4EXKLZzIxt58wWFwM38Zp4mbGpNX5uCGfQ62w0bXDCiRreF9Go0SFrCdSjSdxkQkeWETQVQ0Iah3PINUPLF09ZYr5qb60GzPvbsDg9dk1hqC7AlC9s8m7d9+iw4dvXTYpxyWaL9+xKndIslGnJ8WHG5HMytGAwOpl7GYtZ8CksZnN+drFB73TUGgz6VB38hjHo9bgaqDI/0StFMeVWFZeDaJ4Z5NljTz0angOBEUJAA5qhoZZVsRwNWIMV6HkkYzm0pmih88YNt4Chsxloz9eCVQq1jteHTF+qQ0FrSHH/PqULhAzS187y2XlKLe253y0/zM5JJ4yRPIURH+hUSiOYMnaHxiRkgbMxpKloMAsamFkhfT2ynm7vYtNKMKxk/ohO3YqbD1TVbF85Vjn+ykpr2sIPmb5thKGjex5cbi7TobcmR1RBl0IwotdmhHPVZh/DWAp8LGOlFzrq0Ws7nHU+Q3ac3sbQRp3ejupzWkwZ9KrilFf1fwBUC+G2AAAAeJxjYGRgYGBhPD3hfEVkPL/NVwZudgYQuGJ81ghG////n4GTkQ3E5WBgYgDqAABkIwvXAHicY2BkYGBj+M/AwMDJ8B8IOBkZgCLIgGkrAHsKBc4AeJyNVktrFEEQrnn0PIybLIYVNQRWSUyULIqo6EXmsB69iB4MiCLiRSKCJ3Nq/Bn+D8Gjv0q8rVUzVT3ftJOsSz6qu7q63tWTzNNn4l/6kij5RVTSf+F1wbTwPU/WAid7PzxjfHWePplMYXcYruNdK3TPd++ZzBjkXt7pbkQu031r2/d61YcLzvwEmRzsr41VfcmppxhvOeSdOvQdzouUEvblO+P4rNhG0KieB4Ky50+cD7k7xdxYDhRTF9VC5Y5beIijy2UjMlWUb8sD2KfMQx76moS4kZqvrj8/4py8CTmyWHp7EneKPp8JTzON20W1nyr9wvxEZfK4lxhbA7897ZSWd0WtOnOtZeqpSTVvxsOeUt2H2Eecr8TyhT1TQvxQuwZzEs58Vx+NK/jIuhaMCdfgmYB9WzDC3mzkXY0xVsv1sKejfoHZtLNG52/C+4XeTdnH1HKi9K3kifGO7zsByyeF+sLyE5tPXmdM98bqrXm5aLNvvMQP8v3Q+Gw3E6ybL6jd/ewb04xyp3EzfQQ9dkPA/BaFwUOvE+1ID0Y9vBHHoXaX7Qzxn0DzafNscuEu+3KkNLxDpfK0DvPSr1b4prLsbGRWwqyKTAX+W71l9utO/gTf6TBX1L8P5W+6Fc+T+mlvcxtXjXd6Oq16/tzqUa+pWYQD81n9nzO2wcZS/XnM60sghz4/4fMrI+9CjKuM93z+Sv2+rXpqpge1+h6D5TYF+F1AvVVELb9Qh3bNPm7gu4x1wDuDtdZX99sF6NQeT62v4L1NZUZZvtCzlNftXNhsQJ2DriryIe6J6g+9qHU/lifrbYy7gPOSzu8NzCfmsvwxOAv9yPY+tHd/9vpD/MOaXGa5Taa7Y32h7/h+Nc5/Hvn3FGzNzReIbW8sLtV9nfcfWe+h8rNyqFvWS51/6cfMZlz1B3m3ov1Cv0cO7Xnawh6xb5We79dDW7Oov/7pDeDv2t18BPC/RRLPRUAKve7pruRcfbwTZDzdFHre7y/1CnzxeJyllntUz2ccx9/P404uuYYQGmnNQpFkihBiIeMQi7kzs2mbTYaJZYwk17k0l61NyD3kHic0cg+5h5BpriHsZf/4f+uc9/n+vs/zubzf78/zfU7Sv38e/wExkqkIFkg2AmRIhYJBnlQ4VCrqCq5IxUdKJcYC9kuyXsoNnJIcoqTSA6UyCVJZ3svx7khZx8VSeXIq0KNCplRxIiiQKtGvspdUpZzkRJ5TulR1tFQtCMRJ1ennzHoN8moWB3CqRS+XGQBOteOlOp5SXRfJlRhXuNULlOpnS270bAA3d/LcU5BHD49H0nv0b+gPeL4fDtjzRLPnSqkRPRvDqQk9veDlxbs3tb3h650sNeV30zBATjM4NkOnjwOgjs8mqTleNefpOxTkSi32SH7oaQk+8APwasVeK3r7k+9PnQD4B1C7dS+QL7Whdxu4B1IrkPi27LXjvT1x7bOkIOp2QH9HH6lTohRMTGdyuqC/Czy74PuHSVIInELg1xUdXfGpGzy7MYPuxHVnvqHs96BmT3zsRd3e+NQHX/pQOwyuYXDpS1w//O5Hj4+pEY6OAeQPwMeBhQFcBoUAzsHgVGkINYfQcxjch6F9OLMYQd8RcBoJt0+pP4r8z9gfzdn4HM+/oPcYzlIE84kg90tyxlEnknMTiT/jWR9P3HfR0gTmMZG1SU4AnpPxMIrZRVF/CrlT4DkVjT/QJxru0+AwnfwZadJPxM9kbxY5Mcwxhr3ZnI9Y+MWyFgufWNZiOZdz6D+HnDg0xlErDo/mwn8e53E+81/ArBY6S4vguoj5/EyvxfizhHpL2VuKd8uYWTz7v+DPcjQvR8MKZrYCniuZ1yrqJHDWVuN7IrUS8XIN72typLX0WofGdcwxCW5JnOv1eLSe72MD3DfwHWyA30Z6bWQWm5jLZvzaTN0t1NqCH1s5h1vhnUzeNuK3wWl7+lvsgEcKmneibxc6d1NvDzPchx/78Go//FLplYrfB/DwADoP4n8aZyYNPofodYg6h6lzBL5HWEuHy5/EHKXnUXQcg38GtY6j/zjzO4HWEzxP0uMk6yfRfApPTrN/Gr/O4PsZ8s4yp0x0Z6LhHGvn4HUeb8/D4QK+XKBHFryz4HyR2IvovISWy+xd5pu4AuerrF/Dl+touM65yIbjDeJvMuNbxN2idw7rt/kW74C7IBff7nGW/+JM3mfvAb48RNMjch/zHT3BhyfwfEp+Pt7nU+sZZ+I5vV7Qs4BvpQCOL9H3Et4v4f8Kza9Ye11cRhVlimySKfpIpli+TPEMmRIDZUqWAwtkSjnJOBQGK2VKe8iU4SouGy3jyG/HeJny6TIVfEA213SMTCU3QGzlXqBApsoeGacomapjZapFylQPlXE+JVPDH/CsSU4t6tdiz4W82sTXIbYu3OqOlHFlz5Ue9YfKuOXIuAfLeFCjIc9GEQDeja/INPEESTJeCTLerDclppmrDHehaR4k44se3zyZFvTzg49fpkwrOPo7ywTQs3WaTBsQuFimLfHtQPvRMkE8O8CnowtAYyc4B6O7M750QUMI4C4z3eDQPVAmlLgecPsoHBDbkx69vAAxvdHSG+/64G8f4sPQ3Bce/dgLj5PpT6/+KTID4PkJeQMTZQahZTDah2TJDGVOw8JkhsNnFBpG03sMdb5C29dwH4u2b6j/7QyZceRE8hyPPu4qM4G8CcxzAjOeiK+TqPs98ZPhNpn9KPKn4N9UfkezN43cH5nr9DeA30w0zcTbWfgaQ7/ZnJs55MfxnIuuucx6HrXnE7sQXYuot5i4JcxxCRqXsrYMz5Yxw/hUmeXMZQW9V6JlFX1/nSjzGz0S4MsdZBJy3+J3vPiDc7Uab1dzFhLxZQ1c1vK+Fr3r6L+O9yT8SOJ9Cx5uRWMy3nDPmO3sb8ffHZyHHehLgVMKfXfSb9cbsLabWnvwfy8c98JvPzn7mXcqeg6g+SD9D8IlDd6HwGH6HGEvHc1H4XyM+hn0PM5sTzCrkyGAvdPM6Qy9znKWzuJRJuf1PPwvUDMLXKQWd4W5RL3LcLmKD9fIy4bHDfZu+sncgtct9OXAP4czdZs+d+h5h9934ZiLj7nJgNr3qHUffffRlIeGPPz6G20P4POQvIf4/5i6T/h+n3Dun8LtKT7lw+8Za895f4FnBcQUoIV7w7zkLLyix5v74nWGrPGStc6yhTxkCw+VLXJKtliIbAnWS/Lb4Yps6TzZsk6y5VhzzJat4CdbkfhKgP+vbBVPWScf2aqustWiZavzu8Ym2ZqhIF3WJVK2NrXrJMq6Bsu+Q3y9INn6xLo9km0wQ9adNfcs2XfjZD14NqRWw1xZT9AoSraxPyiQbZIs6xUh681+U3Kbu8j6ku8L1xYOgJp+biBTtiXcWhHvv0A2AB1t4mUDqdGO96BwQH4H+AWn/B/8A2W9n3QAAHicY2BkYGA6zCTJoM4AAkxAzAiEDAwOYD4DAB0oAU0AeJyVk99qE0EUxr/dpE1rpGDRUryQQUTBi920lBaCN9s/6U1oYgilV+o2O0mWJrthdpKQa19A8AXEKx9AvBe89FUEH8FvJ2MTsUJNSOY3Z+b8+c7ZBbDtPIWD+cfHG8sOyvhk2UUJ3ywXcA8/LRdRdh5aXsGmU7e8SvvUcgkv3WeW13DXfW95HXfcL5bLeOD+sLyBR4WAWZziOnevTMacHWzhnWWXtz5bLuAxvlsuYstxLa/gCXXNeZX215ZL+Oi8tbyGbXdmeR333Q+Wy3jufrW8gReFAo6QYoQZFGL00IeGwDFCTCBJp6QEEc8FdlHBDvbhkQMM+BVLXpnZSa6Sa+4d8SaO0tFMxb2+FsfhRIrTMIlmYreys++JYDAQ5igTSmZSTWREhxrrSRgvwNRESzHkilqa6GAqs3TITYuWHsasIGQutGRvPAhV7tvAGdqo0/sQVe7atJ3gAk1yizvUGmftenBYbbRrJxfNRqt9u4znRlVGtfldgT1qO+CvstQXnEuVxWki9rwDr2JE3i54k0IkpWSm5XkTuyadoF9q/vvm5KZR5T4d0u/CulzVkk/X5s8tijkiWoembVe0hbRqE++S7VxESbjmu46pmVNpDmSYSc6pK5XQqdB9KRajzWRH58K7qTInXaoTWoWRHIbqSoRaq/hybK4kqY47MrODVqayv3qjtLhuzk3PIhbPEkwfNPtS5SvuX+sN/4jpGWXoaz2q+n5eXjiP78Xp/0TwOal5VxLTef8fMf0BRSaZ9PELz4vYEXicfVcFdOPIsnVVmWInGVimt8yU2JacLE9gmZm9st22NZYtjSAwy8zMzMyPmfYxv33MzLCPmaqk9kzm/HN+TtIk3b7dfW9XKSlM/b8/+BoXkMIUpW5KXZ+6LnVj6pbUrakbUrelbgYEgjRkIAs5yMMQFKAIwzACo7AMlsMKWAkbwcawCWwKm8HmsAVsCVvB1rANvAm2he1ge9gBdoSdYGfYBXaF3WB32AP2hL1gb9gH9oUxGIcSlKECBphQhQmYhP1gfzgADoSD4GA4BFbBFEzDDMzCoXAYHA5HwJFwFBwNx8CxcBwcDyfAiXASnAynwKlwGpwOZ8CZcBacDefAuVCD88CCemo09UZqBBrQBAUtaEMHbFgNXXCgB31wwYM14EMAIUQwB/OwAIuwFs6HC+BCuAguhkvgUrgMLocr4Eq4Cq6Ga+BauA6uhxvgRrgJboZb4Fa4DW6HO+BOuAvuhnvgXrgP7ocH4EF4CB6GR+BReAwehyfgSXgKnoZn4Fl4Dp6HF+BFeAlehlfgVXgzvAXeCm+Dt8M74J3wLng3vAfeC++D98MH4IPwIfgwvAYfgY/Cx+Dj8An4JHwKPg2fgc/C5+Dz8AX4IrwOX4Ivw1fgq/A1+Dp8A74J34Jvw3fgu/A9+D78AH4IP4Ifw0/gp/Az+Dn8An4Jv4Jfw2/gt/AG/A5+D3+AP8Kf4M/wF/gr/A3+Dv+Af8K/4N/wH/gvphAQkTCNGcxiDvOpHXAIC1jEYRzBUVyGy3EFrsSNcGPcBDfFzXBz3AK3xK1wa9wG34Tb4na4Pe6AO+JOuDPugrvibrg77oF74l64N+6D++IYjmMJy1hBA02s4gRO4n64Px6AB+JBeDAegqtwCqdxBmfxUDwMD8cj8Eg8Co/GY/BYPA6PxxPwRDwp9TqejKfgqXgano5n4Jl4Fp6N5+C5WMPz0MI6NrCJClvYxg7auBq76GAP++iih2vQxwBDjHAO53EBF3Etno8X4IV4EV6Ml+CleBlejlfglXgVXo3X4LV4HV6PN+CNeBPejLfgrXgb3o534J14F96N9+C9eB/ejw/gg/gQPoyP4KP4GD6OT+CT+BQ+jc/gs/gcPo8v4Iv4Er6Mr+Cr+GZ8C74V34Zvx3fgO/Fd+G58D74X34fvxw/gB/FD+GF8DT+CH8WP4cfxE/hJ/BR+Gj+Dn8XP4efxC/hFfB2/hF/Gr+BX8Wv4dfwGfhO/hd/G7+B38Xv4ffwB/hB/hD/Gn+BP8Wf4c/wF/hJ/hb/G3+Bv8Q38Hf4e/4B/xD/hn/Ev+Ff8G/4d/4H/xH/hv/E/+F9KERASUZoylKUc5WmIClSkYRqhUVpGy2kFraSNaGPahDalzWhz2oK2pK1oa9qG3kTb0na0Pe1AO9JOtDPtQrvSbrQ77UF70l60N+1D+9IYjVOJylQhg0yq0gRN0n60Px1AB9JBdDAdQqtoiqZphmbpUDqMDqcj6Eg6io6mY+hYOo6OpxPoRDqJTqZT6FQ6jU6nM+hMOovOpnPoXKrReWRRnRrUJEUtalOHbFpNXXKoR31yyaM15FNAIUU0R/O0QIu0ls6nC+hCuogupkvoUrqMLqcr6Eq6iq6ma+hauo6upxvoRrqJbqZb6Fa6jW6nO+hOuovupnvoXrqP7qcH6EF6iB6mR+hReowepyfoSXqKnqZn6Fl6jp6nF+hFeoleplfo1dQdmbZjBUGmFwV2Ixsoy2908qo/pxzXU5kO98N0EFp+QYqa6nnhYjoKlJ9u2U4vH3ZqjuW3FYadnLTtIES3m/VVz51TubWu26vZ/Xxcu1FIbquVDex233Ko4bYzoW8FnXTH7ak8z6ZqlhOmQ7un0r5rNYeb7nzf4YYM5wedbORJlbH7dXeh6DnWYq1h+w1HMaenrDDnq5avgk5elhJP6LiNbrrlWO0Cb6bpddy+CgpzrhP1VI3XU9RNIRjS7cjLrvEbblPl6lZcU2i10/wXpOuu281L0bP8bsbz7X6YbVg95VvpltsP+bnTzNqh5diNYqgWwlpH2e1OWIjb83Yz7BT4Wbtfc1QrHE6aDdUPlV9MOr68PpK0V0dBaLcW07KXot1v8nsJTrfjd0dbVkPJqdXm7KZyc57dCCNfZT3Vb9hOoWd5NVmr8rNWUybkE+Z1qqYdZoKO5atMo6P4hESwkSBUXq1uNbrzlt8caVl8hINeftBIy6FnPItNwMZwvVzL9WV8OH590Iln0p2MWq0a4TDzzPlusvORQSfewpDnREFNjFHo2X3dLCYmits5txvXI2sixUfCOOkN2f2Wm8CChq9UP+i44YiGJa4YYmDSKtSt/qBp+b47H6+jmDTjVeSTduTp57Ej4iMSH/FyAnutqrUixxnW7aBnOc5ytdBwrJ61blnptt1i2ymrxXfEV3m1yEZjNYak0XDcQA3zqfTtfjt+PcPn2Vf5huWoftPys77Vb7q9XMPt9VjjbM9q91VYGJxX5K07R1kf2z2cVyoc4a17nkzZ4As73GIXKj8hK+qOLGGZXvic8kObGVfofsf17bVsX8sZYsfXGh2ZJJy3Q/ZlcvBiMrF93BtOHF9jct+lrlpM820O8nrJwUjYiXr1gNcqB7dM92S50h+KA0nHclrFOLokMSUn83KIGHHsfpfNmRxlzouCDm9rhG+P8jls1ORxHELsfpbJvc5isW0zQz3xQRIdhCbjsA/4cOW+F2OLJ0Sjg8ubdAvxCwmZ3nB+sNdsMnM26ksMKbLF+NLIATfJDwLqNPlSsBv48PrpunKcYkOOtcUHG6pCh2XU7o6b4rZc3Iq8ZEQOZEXiyNp6R67cYCSeYNkGQ5G3IUim4Rju1lV23uc738mEVtANshxReTNDdd9WrYYVqII4N7knmbbvRl5azjLDHoma2bqyOEJQIwpZSo9PxfJi/9heOrDmVEHOp1Zno3bZca7PfsLIQdfhiOHbXRV2eMJ2ZyjiuOTztIrXUHdUhs1rNzjMR43uEMvI6+HrO7quFR/78rbrtnk362JAcclAhjVUiwU+cxXGO80nTb6kSSO+xEkzPiu+NxzC+0E6cH22GhfJPYlbfHkGmS1OKgOvpXndLhumzf5vckqqu6xxUdtZ3hweWDvOKBzjQ/ZrqDi25tnbPmtvcUTkmFdwZBE1tkU9z3GBdW6r0fiIa4MMNpx0E6fmJJXWes0iY8OOG/Dhq3wQ2aEolhdTCWO2wYlKKc4wLkdlyZRxOpEt1CPb4R208wz2JO8MWT1mt/oNle2pZtcOiy1ZErOsVrx0xXmgk4Sp1lhLrWi6UV2s1JcTj/23wUjivw2G2H8b9GVfhfX44hJgfoAorH8111RBl9NG1rE8qWKjhMM9ty77im/jsPZ37LfCmsgN9dRJM9GZd9vv82aSdzOc/Z3Fgg4FfDDLl4bAOAwtCYPSL6gFT25hoi4L6CXvZYIeLyTT4qvVp57q5Noc6zyrmecwF/siL98S8uZo3IhDC7u5mecz5uxlOWn5YhiKF8SvOcvWxTsdgDiYJMkivr/pBkexIYFIuuxKsGFXpmul6mRxSWYpBhHfSL6+tse2jupJi1+bKA970dq1cna2aihOoDKhHOPo+mYt/vDq2Mppjg4STbKaFZKiauwm9lBkBx0+UZ+DnZLEs9BocoDS2SYYfLSs3GBEB6ilQxKglvbjANUJe46RbgRBOcve5JBZSKKqNjFHJs6OG7HfbS+wgyUJacW6sUHSStfKY+Wh+NNP5s/yIK93dP2XQ5yuk5AfD+YdxZdebJg0Yscmz+PPiDisx1eiVh4vFZKUH2cEvvZ8rSWzJQZZ7xS2rrxdJRX51K57FAVNsvs+rfYWyY/q1PXnqR425DNZDa27s8vjOFQXY3gdq843slYuTa5cNxpyOK1HoQo2/b9Dsq2RwXAcg1ds0ItjU61crkhhDC9yNo3qeiO6k15gmYcWBp8e696Rw8w12Sz8Uc0hnb/0BsGLv7G43/atXrbF37Rdn6wmh47x6vho3Q7rkRy9loEjoeMXkyoeWua4TLQ+S40s6Ufe0qfiq+VL+skVn+fPXHc+yPE19V27meGLES3wMu265Jagu+hxUnMjP1gTsWL8OcBWcbMtDsuOSkshCTy0PQoikdY0c/LPjT2nqB61ca6bmVd23eV/HPr8yy9US6Px3muDzctYZZNkSYOc6yQ5Rx6Zo003XPJAxiaG5/hTnL9K4zXxyMTYSJLZ4oGaK0MlKcpSiFYThhSmFFUpJqSYzEV9+9DxVWN81tY4j0wKaLIsXQFNCmhSQJMCmhTQ5GS6VhmLEXVplaQoS1FJZpsal44pRVWKCSkEND4mhTwdF9C4gMYrUhhSCGJcEOOCGNdrmx7TteBKgisJriS4kuBKgisJriS4kjCVhaksiLIgyoIo6+XN6AlnxnUdvyHQsqacMXRt6lomr8gcFWGtCGtFWCvxA4FWNHRWiA0hNmRaQ0CGgAwBGQIyBGQIyJClmoIwBWEKwhSEqZd6aPxMQGaVz7sVPxNQVR5UBVQVUFUeVIWmKjRVU15uSEtoqoKYEMSEIMQXFfFFRXxREV9UxBcV8UVFfFGZEMSkICYFIaaoTApispJulWIZ2RTcih8IQkxhsCm4GJeiJEVZiooUhhSmFFUpJqSYzMwpDpvcFEsYMpchljDEEoZYwhBLGGIJQyxhjAtJSUhKghAzGGIGQ8xgiBkMMYMhZjDEDIaYwRAzGGIGQ8xgiBkMCV9GWRBlQZQFIR4wyoKoCKIiiIogRHpDpDdEekOkN0R6Q6Q3KoIwBCG6G6K7IboborshuhuiuyG6G6K7IboborshuhuiuyG6G6YgTEGI6IYpCFMQLHqrxAguBMGic0sQIrohohtVQVQFIaIbIrohohsiuiGiGyK6IaIbIrohohsiuiGiGyK6IaIbIrohohsiujEpCIkEhkQCQyKBwaK3SlUV27Q0MaZrxpkivSnSmzoelCYMXZsyWJViQgrmM8VLpuhviv6m6G+K/qbob4r+puhviv6m6G+K/qbob4r+puhviv6m6G+K/qbob4r+Zim5lqVVeoWrxnVd0nVZ13qpq/RSV5m6rup6QteD+VbpekrX07qe0fVsUk9p3inNO6V5pzTvlOad0rxTmndK805p3inNO6V5pzTvlOad0rxTmlcHzdK05p3WvNOad1rzTmveac07rXmnNe+05p3WvNOad1rzTmveac2rY2tJx9bSjOad0bwzmldH2JKOsKUZzTujeWc074zmndG8M5p3RvPOaN5ZzTureWc176zmndW8s5p3VvPOilMmNemsJp3VpLOadFaTzmrS2dn/AboJB4wAAAA=)format("woff"),url(data:font/ttf;base64,AAEAAAANAIAAAwBQRkZUTWu+R7kAAoaQAAAAHEdERUYC8AAEAAKGcAAAACBPUy8yiDJ6QAAAAVgAAABgY21hcAq/On8AAAyoAAAC8mdhc3D//wADAAKGaAAAAAhnbHlmj/euTQAAGqwAAky8aGVhZBCJ5S0AAADcAAAANmhoZWEPAwq1AAABFAAAACRobXR4RXkYhQAAAbgAAArwbG9jYQL1olwAAA+cAAALEG1heHADLAIcAAABOAAAACBuYW1l45eLrAACZ2gAAASGcG9zdK+Pm6EAAmvwAAAadQABAAAABAHLkM94WV8PPPUACwcAAAAAANQzzTIAAAAA1DPNMv///wAJAQYAAAAACAACAAEAAAAAAAEAAAYA/wAAAAkA/////wkBAAEAAAAAAAAAAAAAAAAAAAK1AAEAAALDAhkAJwAAAAAAAgAAAAEAAQAAAEAAAAAAAAAAAwZpAZAABQAABIwEMwAAAIYEjAQzAAACcwAAAYoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcHlycwBAACD1AAYA/wAAAAYAAQAAAAABAAAAAAAAAAAAAAAgAAEDgABwAAAAAAJVAAABwAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAXQYAAAAGgAAABwAAAAcAAAAGgAAABoAAAAUAAAAHgAAABoAAAAcAAAAHAAAABwAAeQWAAG4GgAAABoAAAAYAAAAHAAAABgAAAAWAAAAGgAAaBgAAAAYAAAAHgAAyBoAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAcAAAAEgAAABwAAQAaAAAADAAAABIAAAAaAAAAFgAAABwAAAAYAAAAHgAAABoAACgUAAAAGgAAAB4AAAAaAAAAFgAAABAAAAAcAAAAGAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHgAAABgAAAAQAAAAGAAAABAAAAAcAAAAGgAAABoAAAAcAAAAEAAAABwAAAAaAAHoFgAAABgAAAAYAAAAGgAAABwAAAAQAAAAGAgABBQAAmgUAAFoGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAQAYAAAAGgAA1BoAANQcAAAAGAAAABgAADQWAAAAFgAAABoAAegYAAAAGAAAABwAAAAWAAAAHAAAABwAAAAcAABAFgAAABoAAAAcAAAAHAAAABgAAAAcAAFoHAABaB4AAAAaAAAAGgAAAB4AAAAMAAEAHAAAACAAAAAYAAAAGAAAABwAAAAcAAAAHgAAABwAAAAYAAAAGAAAAA4AAAAcAAAAGgAAABgAAAASAAAAHAAAABgAAAAaAAAAGAAAABoAAAAYAAAAFgAAABYAAAAUAAAAGAAAABoAALAQAAF8GAAAABoAAAAeAAAAFgAAABgAAAAcAAAAHAABABgAAAgcAAAAHAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAaAABUHAAAABYAABQcAAAAGAAAAB4AAAAaAABAHgAAABoAAcwcAAAEHAAAABYAABAYAAAAGAAAABgAAAAcAAAAHAAAPBwAAAAYAAAAGgAAABoAAGwcAAEAGAAAABgAAAAYAAAAJAAAAB4AAAAQAAAAEAAAAAoAAQAKAAAAGgAAABAAAAAQAAAAEAAAABwAAAAYAAAAGAAAABwAAKAcAAAAHAAAABwAAAAOAAAEHAAAABoAAAAcAAAAEAAAABwAAAAeAAAAHgAAABYAAAAWAAAAHAAAABwAAQAeAAAAFgAAABgAAAAWAAAAFgAAAB4AAQAcAAAAHgAAABoAAQAYAAAAGAAAABAAALQQAAA0EgABNBIAATQKAAC0CgAANBIAATQSAAE0HgAAAB4AAAASAAAADAAAABgAAAAaAAAAGgAAABwAAQAYAAAAHAAAABoAAAAaAAAAHgAAABwAAAAcAAAAGAAAABgAAAAYAAAAHgAAAB4AAAAcAAEAHAABABoAADQeAAC0HAAAABoAAAgWAAAIGgAAABAAAAAaAAAAEAABgAoAAAAKAAGIGAAAFBgAABQeAAAEGgAAABIAAAAWAAA0FAAAABoAAAAWAAAMGgAAkBwAAAAYAAAAGAAAABgAAAAYAAAAFgAAABwAADAcAAAAEgAAABgAAAAWAAAABgAAABgAAAAYAAAAHAAA2BgAAAAWAAAAEAAADBAAAAwYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABAAAAAQAAAAEAAA0A4IAAAQDAAQFAAAABwAAAAUAADgGAAAABgAAAAaAACIGgAAiBwAAIgcAACIGAAAiBgAAIgaAAAAGgAAABgAAAAYAABsFgAAFBgAAAAcAAAAHAABABgAACwYAAAAGAAAABgAAAAWAAAAGAAAABAAARAYAAAADAAADAwAAAwcAAEAHAAAABYAAAAaAAAAFgAAABgAACwYAAAAGAAAABQAALAYAAAAFAAAABAAAAAYAAAAHAAAsBgAAAAcAAEAGgAAgB4D//wcAAAAGAAAABYAAAAUAABUGAAAABgAAAAYAAAAGAAAABoAAAAYAAAAEgAAABYAAAAiAAAAGgAAABgAAAAcAAAAHAAAACAAAAAkAAAAGAABtBgAAAAcAAAAGAAAABgAAAAeAAAAGAAAACAAAAAYAAAAH9gApBgAAAAYAAAAGAAAABwAAAAYAAAAFAABABoAAAAMAAEAHAAAACQAAAAgAAAAGAAAABwAAAAYAAAAHAAAQCAAAAAgAAAAGAAAgBgAAAAQAAAAJAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABgAAAAYAACcHAAAACAAAAAcAAAAHAAAgBwAAEwcAAAAGAAAABwAARAYAAAAFAAA5BwAAEggAAAAHAAAABwAAAAYAAAAGAAAABwAAPgUAABgGAAAABgAAAAYAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAABkHAABkBgAAWQgAAAAIAAAqBwAAAAYAAAkHAAAnCQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACAAADggAAA4FgAAABgAAAAYAAAAHAAAABwAAAAcAAAAIAAAABwAAAAgAAAAHAAAABgAAAAgAAAAIAAAACQAAAAYAAAAIAAAABQAACwgAAAAGAAAABgAAAAYAAAAIAAAABgAAAAYAAAAIAAAACAAAAAYAAAAIAAAACAAAAAaAAAAGgAAACAAAAAgAABMGAAAACQAAAAYAAAAHAAAABQAAAgYAAAAFAAAABgAAAgcAAAAHAAACB4AAAQgAAAYGAAAABQAAAggAAAQFAAAABQAAAAcAAAAHAAAABgAAAAUAAAAGAAAABwAAAAgAAAAIAAAACAAAAAYAAAAGAAAABgAAAAcAAAAGAAAACPgAVAkAAAAHAAAACQAAAAkAAAAJAAAACQAAAAkAAAAFAAAABAAAAAgAAAAJAAAABgAAAAYAAAAJAAAACQAAAAcAAAAJAAAABgAAAAYAAAAGAAAABgAAAAYAAAAGAAAABwAAAAcAAAAIAAAA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AAD8uAAA/QwAAP1gAAD9tAAA/ggAAP64AAD/CAABABQAAQW0AAEG9AABB/gAAQjQAAEJZAABChAAAQqYAAELGAABDAQAAQykAAENLAABDgAAAQ+IAAERLAABEaAAARLMAAETOAABE+QAARSQAAEVKAABFaQAARZYAAEW/AABF8AAARiEAAEZeAABGnwAARtUAAEc1AABHUAAAR3UAAEekAABHwQAAR98AAEgpAABIcAAASJ4AAEjCAABI2wAASQEAAEkzAABJ2gAASjoAAEqTAABLFQAAS5MAAExdAABMfQAATLgAAEzMAABM7AAATSoAAE1dAABNlQAATckAAE4DAABOUgAAToQAAE68AABO5AAATyEAAE82AABP1gAAUAcAAFBwAABQsgAAUPIAAFEnAABRUgAAUZIAAFHcAABSEgAAUl4AAFKIAABSuQAAUvUAAFMoAABTRgAAU5AAAFQQAABUaAAAVLgAAFTRAABVCAAAVVMAAFWYAABVtQAAVdYAAFYNAABWKAAAVoEAAFaiAABW2QAAVvgAAFcfAABXdgAAV6gAAFglAABYUgAAWG8AAFi8AABY1gAAWSsAAFldAABZmgAAWfcAAFotAABaVwAAWp4AAFuhAABcEAAAXPgAAF2EAABd8gAAXiQAAF5iAABeowAAXtoAAF8jAABfRwAAX2kAAF/XAABf5gAAX/4AAGAbAABgXQAAYKQAAGDNAABg6QAAYTIAAGFsAABhqQAAYh0AAGJjAABijgAAYs4AAGLoAABjkwAAY6oAAGPVAABkBAAAZEUAAGTkAABlBQAAZUEAAGV/AABlvgAAZegAAGZfAABmsgAAZwQAAGdCAABndgAAZ58AAGfGAABn+gAAaDEAAGiDAABozQAAaR4AAGlsAABpoAAAadMAAGoHAABqJAAAajsAAGo7AABqOwAAalYAAGqKAABqyAAAavMAAGsrAABragAAa4gAAGuiAABrwQAAa+oAAGwQAABsIgAAba8AAG3bAABuOAAAbl0AAG6BAABupQAAbskAAG7pAABvAgAAbx4AAG9TAABvkwAAb6kAAG/IAABwEgAAcEYAAHBxAABwwQAAcPkAAHEoAABxVQAAcYoAAHG7AAByAwAAckMAAHKiAABy6AAAcz4AAHOHAABz5QAAdBsAAHRZAAB0twAAdNQAAHT+AAB1YQAAdZ4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AgoCCwIMAg0CDgIPAhACEQISAhMCFAIVAhYCFwIYAhkCGgIbAhwCHQIeAh8CIAIhAiICIwIkAiUCJgInAigCKQIqAisCLAItAi4CLwIwAjECMgIzAjQCNQI2AjcCOAI5AjoCOwI8Aj0CPgI/AkACQQJCAkMCRAJFAkYCRwJIAkkCSgJLAkwCTQJOAk8CUAJRAlICUwDSAlQCVQJWAlcCWAJZAloCWwJcAl0CXgJfAmACYQJiAmMCZAJlAmYCZwJoAmkCagJrAmwCbQJuAm8CcAJxAnICcwJ0AnUCdgJ3AngCeQJ6AnsCfAJ9An4CfwKAAoECggKDAoQChQKGAocCiAKJAooCiwKMAo0CjgKPApACkQKSApMClAKVApYClwKYApkCmgKbApwCnQKeAp8CoAKhAqICowKkAqUCpgKnAqgCqQKqAqsCrAKtAq4CrwKwArECsgKzArQCtQK2ArcCuAK5AroCuwK8Ar0CvgK/AsACwQLCAsMCxALFAsYCxwLIAskCygLLAswCzQLOAs8C0ALRAtIC0wLUAtUC1gLXAtgC2QLaAtsC3ALdAt4C3wLgAuEC4gLjAuQC5QLmAucC6ALpAuoC6wLsAu0C7gLvAvAC8QLyAvMC9AL1AvYC9wL4AvkC+gL7AvwC/QL+Av8DAAMBAwIDAwMEAwUDBgMHAwgDCQMKAwsDDAMNAw4DDwMQAxEDEgMTAxQDFQMWAxcDGAMZAxoDGwMcAx0DHgMfAyADIQMiAyMDJAMlAyYDJwMoAykDKgMrAywDLQMuAy8DMAMxAzIDMwM0AzUDNgM3AzgDOQM6AzsDPAM9Az4DPwNAA0EDQgNDA0QDRQNGA0cDSANJA0oDSwNMA00DTgNPA1ADUQNSA1MDVANVA1YDVwNYA1kDWgNbA1wDXQNeA18DYANhA2IDYwNkA2UDZgNnA2gDaQNqA2sDbANtA24DbwNwA3EDcgNzA3QDdQN2A3cDeAN5A3oDewN8A30DfgN/A4ADgQOCA4MDhAOFA4YDhwOIA4kDigOLA4wDjQOOA48DkAORA5IDkwOUA5UDlgOXA5gDmQOaA5sDnAOdA54DnwOgA6EDogOjA6QDpQOmA6cDqAOpA6oDqwOsA60DrgOvA7ADsQCUBWdsYXNzBW11c2ljBnNlYXJjaAhlbnZlbG9wZQVoZWFydARzdGFyCnN0YXJfZW1wdHkEdXNlcgRmaWxtCHRoX2xhcmdlAnRoB3RoX2xpc3QCb2sGcmVtb3ZlB3pvb21faW4Iem9vbV9vdXQDb2ZmBnNpZ25hbANjb2cFdHJhc2gEaG9tZQhmaWxlX2FsdAR0aW1lBHJvYWQMZG93bmxvYWRfYWx0CGRvd25sb2FkBnVwbG9hZAVpbmJveAtwbGF5X2NpcmNsZQZyZXBlYXQHcmVmcmVzaAhsaXN0X2FsdARsb2NrBGZsYWcKaGVhZHBob25lcwp2b2x1bWVfb2ZmC3ZvbHVtZV9kb3duCXZvbHVtZV91cAZxcmNvZGUHYmFyY29kZQN0YWcEdGFncwRib29rCGJvb2ttYXJrBXByaW50BmNhbWVyYQRmb250BGJvbGQGaXRhbGljC3RleHRfaGVpZ2h0CnRleHRfd2lkdGgKYWxpZ25fbGVmdAxhbGlnbl9jZW50ZXILYWxpZ25fcmlnaHQNYWxpZ25fanVzdGlmeQRsaXN0C2luZGVudF9sZWZ0DGluZGVudF9yaWdodA5mYWNldGltZV92aWRlbwdwaWN0dXJlBnBlbmNpbAptYXBfbWFya2VyBmFkanVzdAR0aW50BGVkaXQFc2hhcmUFY2hlY2sEbW92ZQ1zdGVwX2JhY2t3YXJkDWZhc3RfYmFja3dhcmQIYmFja3dhcmQEcGxheQVwYXVzZQRzdG9wB2ZvcndhcmQMZmFzdF9mb3J3YXJkDHN0ZXBfZm9yd2FyZAVlamVjdAxjaGV2cm9uX2xlZnQNY2hldnJvbl9yaWdodAlwbHVzX3NpZ24KbWludXNfc2lnbgtyZW1vdmVfc2lnbgdva19zaWduDXF1ZXN0aW9uX3NpZ24JaW5mb19zaWduCnNjcmVlbnNob3QNcmVtb3ZlX2NpcmNsZQlva19jaXJjbGUKYmFuX2NpcmNsZQphcnJvd19sZWZ0C2Fycm93X3JpZ2h0CGFycm93X3VwCmFycm93X2Rvd24Jc2hhcmVfYWx0C3Jlc2l6ZV9mdWxsDHJlc2l6ZV9zbWFsbBBleGNsYW1hdGlvbl9zaWduBGdpZnQEbGVhZgRmaXJlCGV5ZV9vcGVuCWV5ZV9jbG9zZQx3YXJuaW5nX3NpZ24FcGxhbmUIY2FsZW5kYXIGcmFuZG9tB2NvbW1lbnQGbWFnbmV0CmNoZXZyb25fdXAMY2hldnJvbl9kb3duB3JldHdlZXQNc2hvcHBpbmdfY2FydAxmb2xkZXJfY2xvc2ULZm9sZGVyX29wZW4PcmVzaXplX3ZlcnRpY2FsEXJlc2l6ZV9ob3Jpem9udGFsCWJhcl9jaGFydAx0d2l0dGVyX3NpZ24NZmFjZWJvb2tfc2lnbgxjYW1lcmFfcmV0cm8Da2V5BGNvZ3MIY29tbWVudHMNdGh1bWJzX3VwX2FsdA90aHVtYnNfZG93bl9hbHQJc3Rhcl9oYWxmC2hlYXJ0X2VtcHR5B3NpZ25vdXQNbGlua2VkaW5fc2lnbgdwdXNocGluDWV4dGVybmFsX2xpbmsGc2lnbmluBnRyb3BoeQtnaXRodWJfc2lnbgp1cGxvYWRfYWx0BWxlbW9uBXBob25lC2NoZWNrX2VtcHR5DmJvb2ttYXJrX2VtcHR5CnBob25lX3NpZ24HdHdpdHRlcghmYWNlYm9vawZnaXRodWIGdW5sb2NrC2NyZWRpdF9jYXJkA3JzcwNoZGQIYnVsbGhvcm4EYmVsbAtjZXJ0aWZpY2F0ZQpoYW5kX3JpZ2h0CWhhbmRfbGVmdAdoYW5kX3VwCWhhbmRfZG93bhFjaXJjbGVfYXJyb3dfbGVmdBJjaXJjbGVfYXJyb3dfcmlnaHQPY2lyY2xlX2Fycm93X3VwEWNpcmNsZV9hcnJvd19kb3duBWdsb2JlBndyZW5jaAV0YXNrcwZmaWx0ZXIJYnJpZWZjYXNlCmZ1bGxzY3JlZW4FZ3JvdXAEbGluawVjbG91ZAZiZWFrZXIDY3V0BGNvcHkKcGFwZXJfY2xpcARzYXZlCnNpZ25fYmxhbmsHcmVvcmRlcgJ1bAJvbA1zdHJpa2V0aHJvdWdoCXVuZGVybGluZQV0YWJsZQVtYWdpYwV0cnVjawlwaW50ZXJlc3QOcGludGVyZXN0X3NpZ24QZ29vZ2xlX3BsdXNfc2lnbgtnb29nbGVfcGx1cwVtb25leQpjYXJldF9kb3duCGNhcmV0X3VwCmNhcmV0X2xlZnQLY2FyZXRfcmlnaHQHY29sdW1ucwRzb3J0CXNvcnRfZG93bgdzb3J0X3VwDGVudmVsb3BlX2FsdAhsaW5rZWRpbgR1bmRvBWxlZ2FsCWRhc2hib2FyZAtjb21tZW50X2FsdAxjb21tZW50c19hbHQEYm9sdAdzaXRlbWFwCHVtYnJlbGxhBXBhc3RlCmxpZ2h0X2J1bGIIZXhjaGFuZ2UOY2xvdWRfZG93bmxvYWQMY2xvdWRfdXBsb2FkB3VzZXJfbWQLc3RldGhvc2NvcGUIc3VpdGNhc2UIYmVsbF9hbHQGY29mZmVlBGZvb2QNZmlsZV90ZXh0X2FsdAhidWlsZGluZwhob3NwaXRhbAlhbWJ1bGFuY2UGbWVka2l0C2ZpZ2h0ZXJfamV0BGJlZXIGaF9zaWduBGYwZmURZG91YmxlX2FuZ2xlX2xlZnQSZG91YmxlX2FuZ2xlX3JpZ2h0D2RvdWJsZV9hbmdsZV91cBFkb3VibGVfYW5nbGVfZG93bgphbmdsZV9sZWZ0C2FuZ2xlX3JpZ2h0CGFuZ2xlX3VwCmFuZ2xlX2Rvd24HZGVza3RvcAZsYXB0b3AGdGFibGV0DG1vYmlsZV9waG9uZQxjaXJjbGVfYmxhbmsKcXVvdGVfbGVmdAtxdW90ZV9yaWdodAdzcGlubmVyBmNpcmNsZQVyZXBseQpnaXRodWJfYWx0EGZvbGRlcl9jbG9zZV9hbHQPZm9sZGVyX29wZW5fYWx0CmV4cGFuZF9hbHQMY29sbGFwc2VfYWx0BXNtaWxlBWZyb3duA21laAdnYW1lcGFkCGtleWJvYXJkCGZsYWdfYWx0DmZsYWdfY2hlY2tlcmVkCHRlcm1pbmFsBGNvZGUJcmVwbHlfYWxsD3N0YXJfaGFsZl9lbXB0eQ5sb2NhdGlvbl9hcnJvdwRjcm9wCWNvZGVfZm9yawZ1bmxpbmsEXzI3OQtleGNsYW1hdGlvbgtzdXBlcnNjcmlwdAlzdWJzY3JpcHQEXzI4MwxwdXp6bGVfcGllY2UKbWljcm9waG9uZQ5taWNyb3Bob25lX29mZgZzaGllbGQOY2FsZW5kYXJfZW1wdHkRZmlyZV9leHRpbmd1aXNoZXIGcm9ja2V0Bm1heGNkbhFjaGV2cm9uX3NpZ25fbGVmdBJjaGV2cm9uX3NpZ25fcmlnaHQPY2hldnJvbl9zaWduX3VwEWNoZXZyb25fc2lnbl9kb3duBWh0bWw1BGNzczMGYW5jaG9yCnVubG9ja19hbHQIYnVsbHNleWUTZWxsaXBzaXNfaG9yaXpvbnRhbBFlbGxpcHNpc192ZXJ0aWNhbARfMzAzCXBsYXlfc2lnbgZ0aWNrZXQObWludXNfc2lnbl9hbHQLY2hlY2tfbWludXMIbGV2ZWxfdXAKbGV2ZWxfZG93bgpjaGVja19zaWduCWVkaXRfc2lnbgRfMzEyCnNoYXJlX3NpZ24HY29tcGFzcwhjb2xsYXBzZQxjb2xsYXBzZV90b3AEXzMxNwNldXIDZ2JwA3VzZANpbnIDanB5A3J1YgNrcncDYnRjBGZpbGUJZmlsZV90ZXh0EHNvcnRfYnlfYWxwaGFiZXQEXzMyORJzb3J0X2J5X2F0dHJpYnV0ZXMWc29ydF9ieV9hdHRyaWJ1dGVzX2FsdA1zb3J0X2J5X29yZGVyEXNvcnRfYnlfb3JkZXJfYWx0BF8zMzQEXzMzNQx5b3V0dWJlX3NpZ24HeW91dHViZQR4aW5nCXhpbmdfc2lnbgx5b3V0dWJlX3BsYXkHZHJvcGJveA1zdGFja2V4Y2hhbmdlCWluc3RhZ3JhbQZmbGlja3IDYWRuBGYxNzEOYml0YnVja2V0X3NpZ24GdHVtYmxyC3R1bWJscl9zaWduD2xvbmdfYXJyb3dfZG93bg1sb25nX2Fycm93X3VwD2xvbmdfYXJyb3dfbGVmdBBsb25nX2Fycm93X3JpZ2h0B3dpbmRvd3MHYW5kcm9pZAVsaW51eAdkcmliYmxlBXNreXBlCmZvdXJzcXVhcmUGdHJlbGxvBmZlbWFsZQRtYWxlBmdpdHRpcANzdW4EXzM2NgdhcmNoaXZlA2J1ZwJ2awV3ZWlibwZyZW5yZW4EXzM3Mg5zdGFja19leGNoYW5nZQRfMzc0FWFycm93X2NpcmNsZV9hbHRfbGVmdARfMzc2DmRvdF9jaXJjbGVfYWx0BF8zNzgMdmltZW9fc3F1YXJlBF8zODANcGx1c19zcXVhcmVfbwRfMzgyBF8zODMEXzM4NARfMzg1BF8zODYEXzM4NwRfMzg4BF8zODkHdW5pRjFBMARmMWExBF8zOTIEXzM5MwRmMWE0BF8zOTUEXzM5NgRfMzk3BF8zOTgEXzM5OQRfNDAwBGYxYWIEXzQwMgRfNDAzBF80MDQHdW5pRjFCMQRfNDA2BF80MDcEXzQwOARfNDA5BF80MTAEXzQxMQRfNDEyBF80MTMEXzQxNARfNDE1BF80MTYEXzQxNwRfNDE4BF80MTkHdW5pRjFDMAd1bmlGMUMxBF80MjIEXzQyMwRfNDI0BF80MjUEXzQyNgRfNDI3BF80MjgEXzQyOQRfNDMwBF80MzEEXzQzMgRfNDMzBF80MzQHdW5pRjFEMAd1bmlGMUQxB3VuaUYxRDIEXzQzOARfNDM5B3VuaUYxRDUHdW5pRjFENgd1bmlGMUQ3BF80NDMEXzQ0NARfNDQ1BF80NDYEXzQ0NwRfNDQ4BF80NDkHdW5pRjFFMARfNDUxBF80NTIEXzQ1MwRfNDU0BF80NTUEXzQ1NgRfNDU3BF80NTgEXzQ1OQRfNDYwBF80NjEEXzQ2MgRfNDYzBF80NjQHdW5pRjFGMARfNDY2BF80NjcEZjFmMwRfNDY5BF80NzAEXzQ3MQRfNDcyBF80NzMEXzQ3NARfNDc1BF80NzYEZjFmYwRfNDc4BF80NzkEXzQ4MARfNDgxBF80ODIEXzQ4MwRfNDg0BF80ODUEXzQ4NgRfNDg3BF80ODgEXzQ4OQRfNDkwBF80OTEEXzQ5MgRfNDkzBF80OTQEZjIxMARfNDk2BGYyMTIEXzQ5OARfNDk5BF81MDAEXzUwMQRfNTAyBF81MDMEXzUwNARfNTA1BF81MDYEXzUwNwRfNTA4BF81MDkFdmVudXMEXzUxMQRfNTEyBF81MTMEXzUxNARfNTE1BF81MTYEXzUxNwRfNTE4BF81MTkEXzUyMARfNTIxBF81MjIEXzUyMwRfNTI0BF81MjUEXzUyNgRfNTI3BF81MjgEXzUyOQRfNTMwBF81MzEEXzUzMgRfNTMzBF81MzQEXzUzNQRfNTM2BF81MzcEXzUzOARfNTM5BF81NDAEXzU0MQRfNTQyBF81NDMEXzU0NARfNTQ1BF81NDYEXzU0NwRfNTQ4BF81NDkEXzU1MARfNTUxBF81NTIEXzU1MwRfNTU0BF81NTUEXzU1NgRfNTU3BF81NTgEXzU1OQRfNTYwBF81NjEEXzU2MgRfNTYzBF81NjQEXzU2NQRfNTY2BF81NjcEXzU2OARfNTY5BGYyNjAEZjI2MQRfNTcyBGYyNjMEXzU3NARfNTc1BF81NzYEXzU3NwRfNTc4BF81NzkEXzU4MARfNTgxBF81ODIEXzU4MwRfNTg0BF81ODUEXzU4NgRfNTg3BF81ODgEXzU4OQRfNTkwBF81OTEEXzU5MgRfNTkzBF81OTQEXzU5NQRfNTk2BF81OTcEXzU5OARmMjdlB3VuaUYyODAHdW5pRjI4MQRfNjAyBF82MDMEXzYwNAd1bmlGMjg1B3VuaUYyODYEXzYwNwRfNjA4BF82MDkEXzYxMARfNjExBF82MTIEXzYxMwRfNjE0BF82MTUEXzYxNgRfNjE3BF82MTgEXzYxOQRfNjIwBF82MjEEXzYyMgRfNjIzBF82MjQEXzYyNQRfNjI2BF82MjcEXzYyOARfNjI5B3VuaUYyQTAHdW5pRjJBMQd1bmlGMkEyB3VuaUYyQTMHdW5pRjJBNAd1bmlGMkE1B3VuaUYyQTYHdW5pRjJBNwd1bmlGMkE4B3VuaUYyQTkHdW5pRjJBQQd1bmlGMkFCB3VuaUYyQUMHdW5pRjJBRAd1bmlGMkFFB3VuaUYyQjAHdW5pRjJCMQd1bmlGMkIyB3VuaUYyQjMHdW5pRjJCNAd1bmlGMkI1B3VuaUYyQjYHdW5pRjJCNwd1bmlGMkI4B3VuaUYyQjkHdW5pRjJCQQd1bmlGMkJCB3VuaUYyQkMHdW5pRjJCRAd1bmlGMkJFB3VuaUYyQzAHdW5pRjJDMQd1bmlGMkMyB3VuaUYyQzMHdW5pRjJDNAd1bmlGMkM1B3VuaUYyQzYHdW5pRjJDNwd1bmlGMkM4B3VuaUYyQzkHdW5pRjJDQQd1bmlGMkNCB3VuaUYyQ0MHdW5pRjJDRAd1bmlGMkNFB3VuaUYyRDAHdW5pRjJEMQd1bmlGMkQyB3VuaUYyRDMHdW5pRjJENAd1bmlGMkQ1B3VuaUYyRDYHdW5pRjJENwd1bmlGMkQ4B3VuaUYyRDkHdW5pRjJEQQd1bmlGMkRCB3VuaUYyREMHdW5pRjJERAd1bmlGMkRFB3VuaUYyRTAHdW5pRjJFMQd1bmlGMkUyB3VuaUYyRTMHdW5pRjJFNAd1bmlGMkU1B3VuaUYyRTYHdW5pRjJFNwRfNjk4B3VuaUYyRTkHdW5pRjJFQQd1bmlGMkVCB3VuaUYyRUMHdW5pRjJFRAd1bmlGMkVFAAAAAAAAAf//AAIAAQAAAA4AAAAYAAAAAAACAAEAAQLCAAEABAAAAAIAAAAAAAEAAAAAzD2izwAAAADLTzwwAAAAANQxaLk=)format("truetype"),url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiID4KPHN2Zz4KPG1ldGFkYXRhPgpDcmVhdGVkIGJ5IEZvbnRGb3JnZSAyMDEyMDczMSBhdCBNb24gT2N0IDI0IDE3OjM3OjQwIDIwMTYKIEJ5ICwsLApDb3B5cmlnaHQgRGF2ZSBHYW5keSAyMDE2LiBBbGwgcmlnaHRzIHJlc2VydmVkLgo8L21ldGFkYXRhPgo8ZGVmcz4KPGZvbnQgaWQ9IkZvbnRBd2Vzb21lIiBob3Jpei1hZHYteD0iMTUzNiIgPgogIDxmb250LWZhY2UgCiAgICBmb250LWZhbWlseT0iRm9udEF3ZXNvbWUiCiAgICBmb250LXdlaWdodD0iNDAwIgogICAgZm9udC1zdHJldGNoPSJub3JtYWwiCiAgICB1bml0cy1wZXItZW09IjE3OTIiCiAgICBwYW5vc2UtMT0iMCAwIDAgMCAwIDAgMCAwIDAgMCIKICAgIGFzY2VudD0iMTUzNiIKICAgIGRlc2NlbnQ9Ii0yNTYiCiAgICBiYm94PSItMS4wMjA4MyAtMjU2Ljk2MiAyMzA0LjYgMTUzNy4wMiIKICAgIHVuZGVybGluZS10aGlja25lc3M9IjAiCiAgICB1bmRlcmxpbmUtcG9zaXRpb249IjAiCiAgICB1bmljb2RlLXJhbmdlPSJVKzAwMjAtRjUwMCIKICAvPgo8bWlzc2luZy1nbHlwaCBob3Jpei1hZHYteD0iODk2IiAKZD0iTTIyNCAxMTJoNDQ4djEzMTJoLTQ0OHYtMTMxMnpNMTEyIDB2MTUzNmg2NzJ2LTE1MzZoLTY3MnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iLm5vdGRlZiIgaG9yaXotYWR2LXg9Ijg5NiIgCmQ9Ik0yMjQgMTEyaDQ0OHYxMzEyaC00NDh2LTEzMTJ6TTExMiAwdjE1MzZoNjcydi0xNTM2aC02NzJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Ii5udWxsIiBob3Jpei1hZHYteD0iMCIgCiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im5vbm1hcmtpbmdyZXR1cm4iIGhvcml6LWFkdi14PSI1OTciIAogLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzcGFjZSIgdW5pY29kZT0iICIgaG9yaXotYWR2LXg9IjQ0OCIgCiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImRpZXJlc2lzIiB1bmljb2RlPSImI3hhODsiIGhvcml6LWFkdi14PSIxNzkyIiAKIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY29weXJpZ2h0IiB1bmljb2RlPSImI3hhOTsiIGhvcml6LWFkdi14PSIxNzkyIiAKIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icmVnaXN0ZXJlZCIgdW5pY29kZT0iJiN4YWU7IiBob3Jpei1hZHYteD0iMTc5MiIgCiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImFjdXRlIiB1bmljb2RlPSImI3hiNDsiIGhvcml6LWFkdi14PSIxNzkyIiAKIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iQUUiIHVuaWNvZGU9IiYjeGM2OyIgaG9yaXotYWR2LXg9IjE3OTIiIAogLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJPc2xhc2giIHVuaWNvZGU9IiYjeGQ4OyIgaG9yaXotYWR2LXg9IjE3OTIiIAogLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ0cmFkZW1hcmsiIHVuaWNvZGU9IiYjeDIxMjI7IiBob3Jpei1hZHYteD0iMTc5MiIgCiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImluZmluaXR5IiB1bmljb2RlPSImI3gyMjFlOyIgaG9yaXotYWR2LXg9IjE3OTIiIAogLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJub3RlcXVhbCIgdW5pY29kZT0iJiN4MjI2MDsiIGhvcml6LWFkdi14PSIxNzkyIiAKIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZ2xhc3MiIHVuaWNvZGU9IiYjeGYwMDA7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xNjk5IDEzNTBxMCAtMzUgLTQzIC03OGwtNjMyIC02MzJ2LTc2OGgzMjBxMjYgMCA0NSAtMTl0MTkgLTQ1dC0xOSAtNDV0LTQ1IC0xOWgtODk2cS0yNiAwIC00NSAxOXQtMTkgNDV0MTkgNDV0NDUgMTloMzIwdjc2OGwtNjMyIDYzMnEtNDMgNDMgLTQzIDc4cTAgMjMgMTggMzYuNXQzOCAxNy41dDQzIDRoMTQwOHEyMyAwIDQzIC00dDM4IC0xNy41dDE4IC0zNi41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJtdXNpYyIgdW5pY29kZT0iJiN4ZjAwMTsiIApkPSJNMTUzNiAxMzEydi0xMTIwcTAgLTUwIC0zNCAtODl0LTg2IC02MC41dC0xMDMuNSAtMzJ0LTk2LjUgLTEwLjV0LTk2LjUgMTAuNXQtMTAzLjUgMzJ0LTg2IDYwLjV0LTM0IDg5dDM0IDg5dDg2IDYwLjV0MTAzLjUgMzJ0OTYuNSAxMC41cTEwNSAwIDE5MiAtMzl2NTM3bC03NjggLTIzN3YtNzA5cTAgLTUwIC0zNCAtODl0LTg2IC02MC41dC0xMDMuNSAtMzJ0LTk2LjUgLTEwLjV0LTk2LjUgMTAuNXQtMTAzLjUgMzJ0LTg2IDYwLjV0LTM0IDg5CnQzNCA4OXQ4NiA2MC41dDEwMy41IDMydDk2LjUgMTAuNXExMDUgMCAxOTIgLTM5djk2N3EwIDMxIDE5IDU2LjV0NDkgMzUuNWw4MzIgMjU2cTEyIDQgMjggNHE0MCAwIDY4IC0yOHQyOCAtNjh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InNlYXJjaCIgdW5pY29kZT0iJiN4ZjAwMjsiIGhvcml6LWFkdi14PSIxNjY0IiAKZD0iTTExNTIgNzA0cTAgMTg1IC0xMzEuNSAzMTYuNXQtMzE2LjUgMTMxLjV0LTMxNi41IC0xMzEuNXQtMTMxLjUgLTMxNi41dDEzMS41IC0zMTYuNXQzMTYuNSAtMTMxLjV0MzE2LjUgMTMxLjV0MTMxLjUgMzE2LjV6TTE2NjQgLTEyOHEwIC01MiAtMzggLTkwdC05MCAtMzhxLTU0IDAgLTkwIDM4bC0zNDMgMzQycS0xNzkgLTEyNCAtMzk5IC0xMjRxLTE0MyAwIC0yNzMuNSA1NS41dC0yMjUgMTUwdC0xNTAgMjI1dC01NS41IDI3My41CnQ1NS41IDI3My41dDE1MCAyMjV0MjI1IDE1MHQyNzMuNSA1NS41dDI3My41IC01NS41dDIyNSAtMTUwdDE1MCAtMjI1dDU1LjUgLTI3My41cTAgLTIyMCAtMTI0IC0zOTlsMzQzIC0zNDNxMzcgLTM3IDM3IC05MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZW52ZWxvcGUiIHVuaWNvZGU9IiYjeGYwMDM7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xNjY0IDMydjc2OHEtMzIgLTM2IC02OSAtNjZxLTI2OCAtMjA2IC00MjYgLTMzOHEtNTEgLTQzIC04MyAtNjd0LTg2LjUgLTQ4LjV0LTEwMi41IC0yNC41aC0xaC0xcS00OCAwIC0xMDIuNSAyNC41dC04Ni41IDQ4LjV0LTgzIDY3cS0xNTggMTMyIC00MjYgMzM4cS0zNyAzMCAtNjkgNjZ2LTc2OHEwIC0xMyA5LjUgLTIyLjV0MjIuNSAtOS41aDE0NzJxMTMgMCAyMi41IDkuNXQ5LjUgMjIuNXpNMTY2NCAxMDgzdjExdjEzLjV0LTAuNSAxMwp0LTMgMTIuNXQtNS41IDl0LTkgNy41dC0xNCAyLjVoLTE0NzJxLTEzIDAgLTIyLjUgLTkuNXQtOS41IC0yMi41cTAgLTE2OCAxNDcgLTI4NHExOTMgLTE1MiA0MDEgLTMxN3E2IC01IDM1IC0yOS41dDQ2IC0zNy41dDQ0LjUgLTMxLjV0NTAuNSAtMjcuNXQ0MyAtOWgxaDFxMjAgMCA0MyA5dDUwLjUgMjcuNXQ0NC41IDMxLjV0NDYgMzcuNXQzNSAyOS41cTIwOCAxNjUgNDAxIDMxN3E1NCA0MyAxMDAuNSAxMTUuNXQ0Ni41IDEzMS41egpNMTc5MiAxMTIwdi0xMDg4cTAgLTY2IC00NyAtMTEzdC0xMTMgLTQ3aC0xNDcycS02NiAwIC0xMTMgNDd0LTQ3IDExM3YxMDg4cTAgNjYgNDcgMTEzdDExMyA0N2gxNDcycTY2IDAgMTEzIC00N3Q0NyAtMTEzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJoZWFydCIgdW5pY29kZT0iJiN4ZjAwNDsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTg5NiAtMTI4cS0yNiAwIC00NCAxOGwtNjI0IDYwMnEtMTAgOCAtMjcuNSAyNnQtNTUuNSA2NS41dC02OCA5Ny41dC01My41IDEyMXQtMjMuNSAxMzhxMCAyMjAgMTI3IDM0NHQzNTEgMTI0cTYyIDAgMTI2LjUgLTIxLjV0MTIwIC01OHQ5NS41IC02OC41dDc2IC02OHEzNiAzNiA3NiA2OHQ5NS41IDY4LjV0MTIwIDU4dDEyNi41IDIxLjVxMjI0IDAgMzUxIC0xMjR0MTI3IC0zNDRxMCAtMjIxIC0yMjkgLTQ1MGwtNjIzIC02MDAKcS0xOCAtMTggLTQ0IC0xOHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ic3RhciIgdW5pY29kZT0iJiN4ZjAwNTsiIGhvcml6LWFkdi14PSIxNjY0IiAKZD0iTTE2NjQgODg5cTAgLTIyIC0yNiAtNDhsLTM2MyAtMzU0bDg2IC01MDBxMSAtNyAxIC0yMHEwIC0yMSAtMTAuNSAtMzUuNXQtMzAuNSAtMTQuNXEtMTkgMCAtNDAgMTJsLTQ0OSAyMzZsLTQ0OSAtMjM2cS0yMiAtMTIgLTQwIC0xMnEtMjEgMCAtMzEuNSAxNC41dC0xMC41IDM1LjVxMCA2IDIgMjBsODYgNTAwbC0zNjQgMzU0cS0yNSAyNyAtMjUgNDhxMCAzNyA1NiA0Nmw1MDIgNzNsMjI1IDQ1NXExOSA0MSA0OSA0MXQ0OSAtNDFsMjI1IC00NTUKbDUwMiAtNzNxNTYgLTkgNTYgLTQ2eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzdGFyX2VtcHR5IiB1bmljb2RlPSImI3hmMDA2OyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNMTEzNyA1MzJsMzA2IDI5N2wtNDIyIDYybC0xODkgMzgybC0xODkgLTM4MmwtNDIyIC02MmwzMDYgLTI5N2wtNzMgLTQyMWwzNzggMTk5bDM3NyAtMTk5ek0xNjY0IDg4OXEwIC0yMiAtMjYgLTQ4bC0zNjMgLTM1NGw4NiAtNTAwcTEgLTcgMSAtMjBxMCAtNTAgLTQxIC01MHEtMTkgMCAtNDAgMTJsLTQ0OSAyMzZsLTQ0OSAtMjM2cS0yMiAtMTIgLTQwIC0xMnEtMjEgMCAtMzEuNSAxNC41dC0xMC41IDM1LjVxMCA2IDIgMjBsODYgNTAwCmwtMzY0IDM1NHEtMjUgMjcgLTI1IDQ4cTAgMzcgNTYgNDZsNTAyIDczbDIyNSA0NTVxMTkgNDEgNDkgNDF0NDkgLTQxbDIyNSAtNDU1bDUwMiAtNzNxNTYgLTkgNTYgLTQ2eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1c2VyIiB1bmljb2RlPSImI3hmMDA3OyIgaG9yaXotYWR2LXg9IjEyODAiIApkPSJNMTI4MCAxMzdxMCAtMTA5IC02Mi41IC0xODd0LTE1MC41IC03OGgtODU0cS04OCAwIC0xNTAuNSA3OHQtNjIuNSAxODdxMCA4NSA4LjUgMTYwLjV0MzEuNSAxNTJ0NTguNSAxMzF0OTQgODl0MTM0LjUgMzQuNXExMzEgLTEyOCAzMTMgLTEyOHQzMTMgMTI4cTc2IDAgMTM0LjUgLTM0LjV0OTQgLTg5dDU4LjUgLTEzMXQzMS41IC0xNTJ0OC41IC0xNjAuNXpNMTAyNCAxMDI0cTAgLTE1OSAtMTEyLjUgLTI3MS41dC0yNzEuNSAtMTEyLjUKdC0yNzEuNSAxMTIuNXQtMTEyLjUgMjcxLjV0MTEyLjUgMjcxLjV0MjcxLjUgMTEyLjV0MjcxLjUgLTExMi41dDExMi41IC0yNzEuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZmlsbSIgdW5pY29kZT0iJiN4ZjAwODsiIGhvcml6LWFkdi14PSIxOTIwIiAKZD0iTTM4NCAtNjR2MTI4cTAgMjYgLTE5IDQ1dC00NSAxOWgtMTI4cS0yNiAwIC00NSAtMTl0LTE5IC00NXYtMTI4cTAgLTI2IDE5IC00NXQ0NSAtMTloMTI4cTI2IDAgNDUgMTl0MTkgNDV6TTM4NCAzMjB2MTI4cTAgMjYgLTE5IDQ1dC00NSAxOWgtMTI4cS0yNiAwIC00NSAtMTl0LTE5IC00NXYtMTI4cTAgLTI2IDE5IC00NXQ0NSAtMTloMTI4cTI2IDAgNDUgMTl0MTkgNDV6TTM4NCA3MDR2MTI4cTAgMjYgLTE5IDQ1dC00NSAxOWgtMTI4CnEtMjYgMCAtNDUgLTE5dC0xOSAtNDV2LTEyOHEwIC0yNiAxOSAtNDV0NDUgLTE5aDEyOHEyNiAwIDQ1IDE5dDE5IDQ1ek0xNDA4IC02NHY1MTJxMCAyNiAtMTkgNDV0LTQ1IDE5aC03NjhxLTI2IDAgLTQ1IC0xOXQtMTkgLTQ1di01MTJxMCAtMjYgMTkgLTQ1dDQ1IC0xOWg3NjhxMjYgMCA0NSAxOXQxOSA0NXpNMzg0IDEwODh2MTI4cTAgMjYgLTE5IDQ1dC00NSAxOWgtMTI4cS0yNiAwIC00NSAtMTl0LTE5IC00NXYtMTI4cTAgLTI2IDE5IC00NQp0NDUgLTE5aDEyOHEyNiAwIDQ1IDE5dDE5IDQ1ek0xNzkyIC02NHYxMjhxMCAyNiAtMTkgNDV0LTQ1IDE5aC0xMjhxLTI2IDAgLTQ1IC0xOXQtMTkgLTQ1di0xMjhxMCAtMjYgMTkgLTQ1dDQ1IC0xOWgxMjhxMjYgMCA0NSAxOXQxOSA0NXpNMTQwOCA3MDR2NTEycTAgMjYgLTE5IDQ1dC00NSAxOWgtNzY4cS0yNiAwIC00NSAtMTl0LTE5IC00NXYtNTEycTAgLTI2IDE5IC00NXQ0NSAtMTloNzY4cTI2IDAgNDUgMTl0MTkgNDV6TTE3OTIgMzIwdjEyOApxMCAyNiAtMTkgNDV0LTQ1IDE5aC0xMjhxLTI2IDAgLTQ1IC0xOXQtMTkgLTQ1di0xMjhxMCAtMjYgMTkgLTQ1dDQ1IC0xOWgxMjhxMjYgMCA0NSAxOXQxOSA0NXpNMTc5MiA3MDR2MTI4cTAgMjYgLTE5IDQ1dC00NSAxOWgtMTI4cS0yNiAwIC00NSAtMTl0LTE5IC00NXYtMTI4cTAgLTI2IDE5IC00NXQ0NSAtMTloMTI4cTI2IDAgNDUgMTl0MTkgNDV6TTE3OTIgMTA4OHYxMjhxMCAyNiAtMTkgNDV0LTQ1IDE5aC0xMjhxLTI2IDAgLTQ1IC0xOQp0LTE5IC00NXYtMTI4cTAgLTI2IDE5IC00NXQ0NSAtMTloMTI4cTI2IDAgNDUgMTl0MTkgNDV6TTE5MjAgMTI0OHYtMTM0NHEwIC02NiAtNDcgLTExM3QtMTEzIC00N2gtMTYwMHEtNjYgMCAtMTEzIDQ3dC00NyAxMTN2MTM0NHEwIDY2IDQ3IDExM3QxMTMgNDdoMTYwMHE2NiAwIDExMyAtNDd0NDcgLTExM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idGhfbGFyZ2UiIHVuaWNvZGU9IiYjeGYwMDk7IiBob3Jpei1hZHYteD0iMTY2NCIgCmQ9Ik03NjggNTEydi0zODRxMCAtNTIgLTM4IC05MHQtOTAgLTM4aC01MTJxLTUyIDAgLTkwIDM4dC0zOCA5MHYzODRxMCA1MiAzOCA5MHQ5MCAzOGg1MTJxNTIgMCA5MCAtMzh0MzggLTkwek03NjggMTI4MHYtMzg0cTAgLTUyIC0zOCAtOTB0LTkwIC0zOGgtNTEycS01MiAwIC05MCAzOHQtMzggOTB2Mzg0cTAgNTIgMzggOTB0OTAgMzhoNTEycTUyIDAgOTAgLTM4dDM4IC05MHpNMTY2NCA1MTJ2LTM4NHEwIC01MiAtMzggLTkwdC05MCAtMzgKaC01MTJxLTUyIDAgLTkwIDM4dC0zOCA5MHYzODRxMCA1MiAzOCA5MHQ5MCAzOGg1MTJxNTIgMCA5MCAtMzh0MzggLTkwek0xNjY0IDEyODB2LTM4NHEwIC01MiAtMzggLTkwdC05MCAtMzhoLTUxMnEtNTIgMCAtOTAgMzh0LTM4IDkwdjM4NHEwIDUyIDM4IDkwdDkwIDM4aDUxMnE1MiAwIDkwIC0zOHQzOCAtOTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InRoIiB1bmljb2RlPSImI3hmMDBhOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNNTEyIDI4OHYtMTkycTAgLTQwIC0yOCAtNjh0LTY4IC0yOGgtMzIwcS00MCAwIC02OCAyOHQtMjggNjh2MTkycTAgNDAgMjggNjh0NjggMjhoMzIwcTQwIDAgNjggLTI4dDI4IC02OHpNNTEyIDgwMHYtMTkycTAgLTQwIC0yOCAtNjh0LTY4IC0yOGgtMzIwcS00MCAwIC02OCAyOHQtMjggNjh2MTkycTAgNDAgMjggNjh0NjggMjhoMzIwcTQwIDAgNjggLTI4dDI4IC02OHpNMTE1MiAyODh2LTE5MnEwIC00MCAtMjggLTY4dC02OCAtMjhoLTMyMApxLTQwIDAgLTY4IDI4dC0yOCA2OHYxOTJxMCA0MCAyOCA2OHQ2OCAyOGgzMjBxNDAgMCA2OCAtMjh0MjggLTY4ek01MTIgMTMxMnYtMTkycTAgLTQwIC0yOCAtNjh0LTY4IC0yOGgtMzIwcS00MCAwIC02OCAyOHQtMjggNjh2MTkycTAgNDAgMjggNjh0NjggMjhoMzIwcTQwIDAgNjggLTI4dDI4IC02OHpNMTE1MiA4MDB2LTE5MnEwIC00MCAtMjggLTY4dC02OCAtMjhoLTMyMHEtNDAgMCAtNjggMjh0LTI4IDY4djE5MnEwIDQwIDI4IDY4dDY4IDI4CmgzMjBxNDAgMCA2OCAtMjh0MjggLTY4ek0xNzkyIDI4OHYtMTkycTAgLTQwIC0yOCAtNjh0LTY4IC0yOGgtMzIwcS00MCAwIC02OCAyOHQtMjggNjh2MTkycTAgNDAgMjggNjh0NjggMjhoMzIwcTQwIDAgNjggLTI4dDI4IC02OHpNMTE1MiAxMzEydi0xOTJxMCAtNDAgLTI4IC02OHQtNjggLTI4aC0zMjBxLTQwIDAgLTY4IDI4dC0yOCA2OHYxOTJxMCA0MCAyOCA2OHQ2OCAyOGgzMjBxNDAgMCA2OCAtMjh0MjggLTY4ek0xNzkyIDgwMHYtMTkyCnEwIC00MCAtMjggLTY4dC02OCAtMjhoLTMyMHEtNDAgMCAtNjggMjh0LTI4IDY4djE5MnEwIDQwIDI4IDY4dDY4IDI4aDMyMHE0MCAwIDY4IC0yOHQyOCAtNjh6TTE3OTIgMTMxMnYtMTkycTAgLTQwIC0yOCAtNjh0LTY4IC0yOGgtMzIwcS00MCAwIC02OCAyOHQtMjggNjh2MTkycTAgNDAgMjggNjh0NjggMjhoMzIwcTQwIDAgNjggLTI4dDI4IC02OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idGhfbGlzdCIgdW5pY29kZT0iJiN4ZjAwYjsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTUxMiAyODh2LTE5MnEwIC00MCAtMjggLTY4dC02OCAtMjhoLTMyMHEtNDAgMCAtNjggMjh0LTI4IDY4djE5MnEwIDQwIDI4IDY4dDY4IDI4aDMyMHE0MCAwIDY4IC0yOHQyOCAtNjh6TTUxMiA4MDB2LTE5MnEwIC00MCAtMjggLTY4dC02OCAtMjhoLTMyMHEtNDAgMCAtNjggMjh0LTI4IDY4djE5MnEwIDQwIDI4IDY4dDY4IDI4aDMyMHE0MCAwIDY4IC0yOHQyOCAtNjh6TTE3OTIgMjg4di0xOTJxMCAtNDAgLTI4IC02OHQtNjggLTI4aC05NjAKcS00MCAwIC02OCAyOHQtMjggNjh2MTkycTAgNDAgMjggNjh0NjggMjhoOTYwcTQwIDAgNjggLTI4dDI4IC02OHpNNTEyIDEzMTJ2LTE5MnEwIC00MCAtMjggLTY4dC02OCAtMjhoLTMyMHEtNDAgMCAtNjggMjh0LTI4IDY4djE5MnEwIDQwIDI4IDY4dDY4IDI4aDMyMHE0MCAwIDY4IC0yOHQyOCAtNjh6TTE3OTIgODAwdi0xOTJxMCAtNDAgLTI4IC02OHQtNjggLTI4aC05NjBxLTQwIDAgLTY4IDI4dC0yOCA2OHYxOTJxMCA0MCAyOCA2OHQ2OCAyOApoOTYwcTQwIDAgNjggLTI4dDI4IC02OHpNMTc5MiAxMzEydi0xOTJxMCAtNDAgLTI4IC02OHQtNjggLTI4aC05NjBxLTQwIDAgLTY4IDI4dC0yOCA2OHYxOTJxMCA0MCAyOCA2OHQ2OCAyOGg5NjBxNDAgMCA2OCAtMjh0MjggLTY4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJvayIgdW5pY29kZT0iJiN4ZjAwYzsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE2NzEgOTcwcTAgLTQwIC0yOCAtNjhsLTcyNCAtNzI0bC0xMzYgLTEzNnEtMjggLTI4IC02OCAtMjh0LTY4IDI4bC0xMzYgMTM2bC0zNjIgMzYycS0yOCAyOCAtMjggNjh0MjggNjhsMTM2IDEzNnEyOCAyOCA2OCAyOHQ2OCAtMjhsMjk0IC0yOTVsNjU2IDY1N3EyOCAyOCA2OCAyOHQ2OCAtMjhsMTM2IC0xMzZxMjggLTI4IDI4IC02OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icmVtb3ZlIiB1bmljb2RlPSImI3hmMDBkOyIgaG9yaXotYWR2LXg9IjE0MDgiIApkPSJNMTI5OCAyMTRxMCAtNDAgLTI4IC02OGwtMTM2IC0xMzZxLTI4IC0yOCAtNjggLTI4dC02OCAyOGwtMjk0IDI5NGwtMjk0IC0yOTRxLTI4IC0yOCAtNjggLTI4dC02OCAyOGwtMTM2IDEzNnEtMjggMjggLTI4IDY4dDI4IDY4bDI5NCAyOTRsLTI5NCAyOTRxLTI4IDI4IC0yOCA2OHQyOCA2OGwxMzYgMTM2cTI4IDI4IDY4IDI4dDY4IC0yOGwyOTQgLTI5NGwyOTQgMjk0cTI4IDI4IDY4IDI4dDY4IC0yOGwxMzYgLTEzNnEyOCAtMjggMjggLTY4CnQtMjggLTY4bC0yOTQgLTI5NGwyOTQgLTI5NHEyOCAtMjggMjggLTY4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ6b29tX2luIiB1bmljb2RlPSImI3hmMDBlOyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNMTAyNCA3MzZ2LTY0cTAgLTEzIC05LjUgLTIyLjV0LTIyLjUgLTkuNWgtMjI0di0yMjRxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC02NHEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djIyNGgtMjI0cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2NjRxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWgyMjR2MjI0cTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoNjRxMTMgMCAyMi41IC05LjV0OS41IC0yMi41di0yMjRoMjI0CnExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6TTExNTIgNzA0cTAgMTg1IC0xMzEuNSAzMTYuNXQtMzE2LjUgMTMxLjV0LTMxNi41IC0xMzEuNXQtMTMxLjUgLTMxNi41dDEzMS41IC0zMTYuNXQzMTYuNSAtMTMxLjV0MzE2LjUgMTMxLjV0MTMxLjUgMzE2LjV6TTE2NjQgLTEyOHEwIC01MyAtMzcuNSAtOTAuNXQtOTAuNSAtMzcuNXEtNTQgMCAtOTAgMzhsLTM0MyAzNDJxLTE3OSAtMTI0IC0zOTkgLTEyNHEtMTQzIDAgLTI3My41IDU1LjUKdC0yMjUgMTUwdC0xNTAgMjI1dC01NS41IDI3My41dDU1LjUgMjczLjV0MTUwIDIyNXQyMjUgMTUwdDI3My41IDU1LjV0MjczLjUgLTU1LjV0MjI1IC0xNTB0MTUwIC0yMjV0NTUuNSAtMjczLjVxMCAtMjIwIC0xMjQgLTM5OWwzNDMgLTM0M3EzNyAtMzcgMzcgLTkweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ6b29tX291dCIgdW5pY29kZT0iJiN4ZjAxMDsiIGhvcml6LWFkdi14PSIxNjY0IiAKZD0iTTEwMjQgNzM2di02NHEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTU3NnEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djY0cTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoNTc2cTEzIDAgMjIuNSAtOS41dDkuNSAtMjIuNXpNMTE1MiA3MDRxMCAxODUgLTEzMS41IDMxNi41dC0zMTYuNSAxMzEuNXQtMzE2LjUgLTEzMS41dC0xMzEuNSAtMzE2LjV0MTMxLjUgLTMxNi41dDMxNi41IC0xMzEuNXQzMTYuNSAxMzEuNXQxMzEuNSAzMTYuNXoKTTE2NjQgLTEyOHEwIC01MyAtMzcuNSAtOTAuNXQtOTAuNSAtMzcuNXEtNTQgMCAtOTAgMzhsLTM0MyAzNDJxLTE3OSAtMTI0IC0zOTkgLTEyNHEtMTQzIDAgLTI3My41IDU1LjV0LTIyNSAxNTB0LTE1MCAyMjV0LTU1LjUgMjczLjV0NTUuNSAyNzMuNXQxNTAgMjI1dDIyNSAxNTB0MjczLjUgNTUuNXQyNzMuNSAtNTUuNXQyMjUgLTE1MHQxNTAgLTIyNXQ1NS41IC0yNzMuNXEwIC0yMjAgLTEyNCAtMzk5bDM0MyAtMzQzcTM3IC0zNyAzNyAtOTB6CiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJvZmYiIHVuaWNvZGU9IiYjeGYwMTE7IiAKZD0iTTE1MzYgNjQwcTAgLTE1NiAtNjEgLTI5OHQtMTY0IC0yNDV0LTI0NSAtMTY0dC0yOTggLTYxdC0yOTggNjF0LTI0NSAxNjR0LTE2NCAyNDV0LTYxIDI5OHEwIDE4MiA4MC41IDM0M3QyMjYuNSAyNzBxNDMgMzIgOTUuNSAyNXQ4My41IC01MHEzMiAtNDIgMjQuNSAtOTQuNXQtNDkuNSAtODQuNXEtOTggLTc0IC0xNTEuNSAtMTgxdC01My41IC0yMjhxMCAtMTA0IDQwLjUgLTE5OC41dDEwOS41IC0xNjMuNXQxNjMuNSAtMTA5LjUKdDE5OC41IC00MC41dDE5OC41IDQwLjV0MTYzLjUgMTA5LjV0MTA5LjUgMTYzLjV0NDAuNSAxOTguNXEwIDEyMSAtNTMuNSAyMjh0LTE1MS41IDE4MXEtNDIgMzIgLTQ5LjUgODQuNXQyNC41IDk0LjVxMzEgNDMgODQgNTB0OTUgLTI1cTE0NiAtMTA5IDIyNi41IC0yNzB0ODAuNSAtMzQzek04OTYgMTQwOHYtNjQwcTAgLTUyIC0zOCAtOTB0LTkwIC0zOHQtOTAgMzh0LTM4IDkwdjY0MHEwIDUyIDM4IDkwdDkwIDM4dDkwIC0zOHQzOCAtOTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InNpZ25hbCIgdW5pY29kZT0iJiN4ZjAxMjsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTI1NiA5NnYtMTkycTAgLTE0IC05IC0yM3QtMjMgLTloLTE5MnEtMTQgMCAtMjMgOXQtOSAyM3YxOTJxMCAxNCA5IDIzdDIzIDloMTkycTE0IDAgMjMgLTl0OSAtMjN6TTY0MCAyMjR2LTMyMHEwIC0xNCAtOSAtMjN0LTIzIC05aC0xOTJxLTE0IDAgLTIzIDl0LTkgMjN2MzIwcTAgMTQgOSAyM3QyMyA5aDE5MnExNCAwIDIzIC05dDkgLTIzek0xMDI0IDQ4MHYtNTc2cTAgLTE0IC05IC0yM3QtMjMgLTloLTE5MnEtMTQgMCAtMjMgOXQtOSAyMwp2NTc2cTAgMTQgOSAyM3QyMyA5aDE5MnExNCAwIDIzIC05dDkgLTIzek0xNDA4IDg2NHYtOTYwcTAgLTE0IC05IC0yM3QtMjMgLTloLTE5MnEtMTQgMCAtMjMgOXQtOSAyM3Y5NjBxMCAxNCA5IDIzdDIzIDloMTkycTE0IDAgMjMgLTl0OSAtMjN6TTE3OTIgMTM3NnYtMTQ3MnEwIC0xNCAtOSAtMjN0LTIzIC05aC0xOTJxLTE0IDAgLTIzIDl0LTkgMjN2MTQ3MnEwIDE0IDkgMjN0MjMgOWgxOTJxMTQgMCAyMyAtOXQ5IC0yM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY29nIiB1bmljb2RlPSImI3hmMDEzOyIgCmQ9Ik0xMDI0IDY0MHEwIDEwNiAtNzUgMTgxdC0xODEgNzV0LTE4MSAtNzV0LTc1IC0xODF0NzUgLTE4MXQxODEgLTc1dDE4MSA3NXQ3NSAxODF6TTE1MzYgNzQ5di0yMjJxMCAtMTIgLTggLTIzdC0yMCAtMTNsLTE4NSAtMjhxLTE5IC01NCAtMzkgLTkxcTM1IC01MCAxMDcgLTEzOHExMCAtMTIgMTAgLTI1dC05IC0yM3EtMjcgLTM3IC05OSAtMTA4dC05NCAtNzFxLTEyIDAgLTI2IDlsLTEzOCAxMDhxLTQ0IC0yMyAtOTEgLTM4CnEtMTYgLTEzNiAtMjkgLTE4NnEtNyAtMjggLTM2IC0yOGgtMjIycS0xNCAwIC0yNC41IDguNXQtMTEuNSAyMS41bC0yOCAxODRxLTQ5IDE2IC05MCAzN2wtMTQxIC0xMDdxLTEwIC05IC0yNSAtOXEtMTQgMCAtMjUgMTFxLTEyNiAxMTQgLTE2NSAxNjhxLTcgMTAgLTcgMjNxMCAxMiA4IDIzcTE1IDIxIDUxIDY2LjV0NTQgNzAuNXEtMjcgNTAgLTQxIDk5bC0xODMgMjdxLTEzIDIgLTIxIDEyLjV0LTggMjMuNXYyMjJxMCAxMiA4IDIzdDE5IDEzCmwxODYgMjhxMTQgNDYgMzkgOTJxLTQwIDU3IC0xMDcgMTM4cS0xMCAxMiAtMTAgMjRxMCAxMCA5IDIzcTI2IDM2IDk4LjUgMTA3LjV0OTQuNSA3MS41cTEzIDAgMjYgLTEwbDEzOCAtMTA3cTQ0IDIzIDkxIDM4cTE2IDEzNiAyOSAxODZxNyAyOCAzNiAyOGgyMjJxMTQgMCAyNC41IC04LjV0MTEuNSAtMjEuNWwyOCAtMTg0cTQ5IC0xNiA5MCAtMzdsMTQyIDEwN3E5IDkgMjQgOXExMyAwIDI1IC0xMHExMjkgLTExOSAxNjUgLTE3MHE3IC04IDcgLTIyCnEwIC0xMiAtOCAtMjNxLTE1IC0yMSAtNTEgLTY2LjV0LTU0IC03MC41cTI2IC01MCA0MSAtOThsMTgzIC0yOHExMyAtMiAyMSAtMTIuNXQ4IC0yMy41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ0cmFzaCIgdW5pY29kZT0iJiN4ZjAxNDsiIGhvcml6LWFkdi14PSIxNDA4IiAKZD0iTTUxMiA4MDB2LTU3NnEwIC0xNCAtOSAtMjN0LTIzIC05aC02NHEtMTQgMCAtMjMgOXQtOSAyM3Y1NzZxMCAxNCA5IDIzdDIzIDloNjRxMTQgMCAyMyAtOXQ5IC0yM3pNNzY4IDgwMHYtNTc2cTAgLTE0IC05IC0yM3QtMjMgLTloLTY0cS0xNCAwIC0yMyA5dC05IDIzdjU3NnEwIDE0IDkgMjN0MjMgOWg2NHExNCAwIDIzIC05dDkgLTIzek0xMDI0IDgwMHYtNTc2cTAgLTE0IC05IC0yM3QtMjMgLTloLTY0cS0xNCAwIC0yMyA5dC05IDIzdjU3NgpxMCAxNCA5IDIzdDIzIDloNjRxMTQgMCAyMyAtOXQ5IC0yM3pNMTE1MiA3NnY5NDhoLTg5NnYtOTQ4cTAgLTIyIDcgLTQwLjV0MTQuNSAtMjd0MTAuNSAtOC41aDgzMnEzIDAgMTAuNSA4LjV0MTQuNSAyN3Q3IDQwLjV6TTQ4MCAxMTUyaDQ0OGwtNDggMTE3cS03IDkgLTE3IDExaC0zMTdxLTEwIC0yIC0xNyAtMTF6TTE0MDggMTEyMHYtNjRxMCAtMTQgLTkgLTIzdC0yMyAtOWgtOTZ2LTk0OHEwIC04MyAtNDcgLTE0My41dC0xMTMgLTYwLjVoLTgzMgpxLTY2IDAgLTExMyA1OC41dC00NyAxNDEuNXY5NTJoLTk2cS0xNCAwIC0yMyA5dC05IDIzdjY0cTAgMTQgOSAyM3QyMyA5aDMwOWw3MCAxNjdxMTUgMzcgNTQgNjN0NzkgMjZoMzIwcTQwIDAgNzkgLTI2dDU0IC02M2w3MCAtMTY3aDMwOXExNCAwIDIzIC05dDkgLTIzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJob21lIiB1bmljb2RlPSImI3hmMDE1OyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNMTQwOCA1NDR2LTQ4MHEwIC0yNiAtMTkgLTQ1dC00NSAtMTloLTM4NHYzODRoLTI1NnYtMzg0aC0zODRxLTI2IDAgLTQ1IDE5dC0xOSA0NXY0ODBxMCAxIDAuNSAzdDAuNSAzbDU3NSA0NzRsNTc1IC00NzRxMSAtMiAxIC02ek0xNjMxIDYxM2wtNjIgLTc0cS04IC05IC0yMSAtMTFoLTNxLTEzIDAgLTIxIDdsLTY5MiA1NzdsLTY5MiAtNTc3cS0xMiAtOCAtMjQgLTdxLTEzIDIgLTIxIDExbC02MiA3NHEtOCAxMCAtNyAyMy41dDExIDIxLjUKbDcxOSA1OTlxMzIgMjYgNzYgMjZ0NzYgLTI2bDI0NCAtMjA0djE5NXEwIDE0IDkgMjN0MjMgOWgxOTJxMTQgMCAyMyAtOXQ5IC0yM3YtNDA4bDIxOSAtMTgycTEwIC04IDExIC0yMS41dC03IC0yMy41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJmaWxlX2FsdCIgdW5pY29kZT0iJiN4ZjAxNjsiIApkPSJNMTQ2OCAxMTU2cTI4IC0yOCA0OCAtNzZ0MjAgLTg4di0xMTUycTAgLTQwIC0yOCAtNjh0LTY4IC0yOGgtMTM0NHEtNDAgMCAtNjggMjh0LTI4IDY4djE2MDBxMCA0MCAyOCA2OHQ2OCAyOGg4OTZxNDAgMCA4OCAtMjB0NzYgLTQ4ek0xMDI0IDE0MDB2LTM3NmgzNzZxLTEwIDI5IC0yMiA0MWwtMzEzIDMxM3EtMTIgMTIgLTQxIDIyek0xNDA4IC0xMjh2MTAyNGgtNDE2cS00MCAwIC02OCAyOHQtMjggNjh2NDE2aC03Njh2LTE1MzZoMTI4MHoKIiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InRpbWUiIHVuaWNvZGU9IiYjeGYwMTc7IiAKZD0iTTg5NiA5OTJ2LTQ0OHEwIC0xNCAtOSAtMjN0LTIzIC05aC0zMjBxLTE0IDAgLTIzIDl0LTkgMjN2NjRxMCAxNCA5IDIzdDIzIDloMjI0djM1MnEwIDE0IDkgMjN0MjMgOWg2NHExNCAwIDIzIC05dDkgLTIzek0xMzEyIDY0MHEwIDE0OCAtNzMgMjczdC0xOTggMTk4dC0yNzMgNzN0LTI3MyAtNzN0LTE5OCAtMTk4dC03MyAtMjczdDczIC0yNzN0MTk4IC0xOTh0MjczIC03M3QyNzMgNzN0MTk4IDE5OHQ3MyAyNzN6TTE1MzYgNjQwCnEwIC0yMDkgLTEwMyAtMzg1LjV0LTI3OS41IC0yNzkuNXQtMzg1LjUgLTEwM3QtMzg1LjUgMTAzdC0yNzkuNSAyNzkuNXQtMTAzIDM4NS41dDEwMyAzODUuNXQyNzkuNSAyNzkuNXQzODUuNSAxMDN0Mzg1LjUgLTEwM3QyNzkuNSAtMjc5LjV0MTAzIC0zODUuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icm9hZCIgdW5pY29kZT0iJiN4ZjAxODsiIGhvcml6LWFkdi14PSIxOTIwIiAKZD0iTTExMTEgNTQwdjRsLTI0IDMyMHEtMSAxMyAtMTEgMjIuNXQtMjMgOS41aC0xODZxLTEzIDAgLTIzIC05LjV0LTExIC0yMi41bC0yNCAtMzIwdi00cS0xIC0xMiA4IC0yMHQyMSAtOGgyNDRxMTIgMCAyMSA4dDggMjB6TTE4NzAgNzNxMCAtNzMgLTQ2IC03M2gtNzA0cTEzIDAgMjIgOS41dDggMjIuNWwtMjAgMjU2cS0xIDEzIC0xMSAyMi41dC0yMyA5LjVoLTI3MnEtMTMgMCAtMjMgLTkuNXQtMTEgLTIyLjVsLTIwIC0yNTYKcS0xIC0xMyA4IC0yMi41dDIyIC05LjVoLTcwNHEtNDYgMCAtNDYgNzNxMCA1NCAyNiAxMTZsNDE3IDEwNDRxOCAxOSAyNiAzM3QzOCAxNGgzMzlxLTEzIDAgLTIzIC05LjV0LTExIC0yMi41bC0xNSAtMTkycS0xIC0xNCA4IC0yM3QyMiAtOWgxNjZxMTMgMCAyMiA5dDggMjNsLTE1IDE5MnEtMSAxMyAtMTEgMjIuNXQtMjMgOS41aDMzOXEyMCAwIDM4IC0xNHQyNiAtMzNsNDE3IC0xMDQ0cTI2IC02MiAyNiAtMTE2eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkb3dubG9hZF9hbHQiIHVuaWNvZGU9IiYjeGYwMTk7IiBob3Jpei1hZHYteD0iMTY2NCIgCmQ9Ik0xMjgwIDE5MnEwIDI2IC0xOSA0NXQtNDUgMTl0LTQ1IC0xOXQtMTkgLTQ1dDE5IC00NXQ0NSAtMTl0NDUgMTl0MTkgNDV6TTE1MzYgMTkycTAgMjYgLTE5IDQ1dC00NSAxOXQtNDUgLTE5dC0xOSAtNDV0MTkgLTQ1dDQ1IC0xOXQ0NSAxOXQxOSA0NXpNMTY2NCA0MTZ2LTMyMHEwIC00MCAtMjggLTY4dC02OCAtMjhoLTE0NzJxLTQwIDAgLTY4IDI4dC0yOCA2OHYzMjBxMCA0MCAyOCA2OHQ2OCAyOGg0NjVsMTM1IC0xMzYKcTU4IC01NiAxMzYgLTU2dDEzNiA1NmwxMzYgMTM2aDQ2NHE0MCAwIDY4IC0yOHQyOCAtNjh6TTEzMzkgOTg1cTE3IC00MSAtMTQgLTcwbC00NDggLTQ0OHEtMTggLTE5IC00NSAtMTl0LTQ1IDE5bC00NDggNDQ4cS0zMSAyOSAtMTQgNzBxMTcgMzkgNTkgMzloMjU2djQ0OHEwIDI2IDE5IDQ1dDQ1IDE5aDI1NnEyNiAwIDQ1IC0xOXQxOSAtNDV2LTQ0OGgyNTZxNDIgMCA1OSAtMzl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImRvd25sb2FkIiB1bmljb2RlPSImI3hmMDFhOyIgCmQ9Ik0xMTIwIDYwOHEwIC0xMiAtMTAgLTI0bC0zMTkgLTMxOXEtMTEgLTkgLTIzIC05dC0yMyA5bC0zMjAgMzIwcS0xNSAxNiAtNyAzNXE4IDIwIDMwIDIwaDE5MnYzNTJxMCAxNCA5IDIzdDIzIDloMTkycTE0IDAgMjMgLTl0OSAtMjN2LTM1MmgxOTJxMTQgMCAyMyAtOXQ5IC0yM3pNNzY4IDExODRxLTE0OCAwIC0yNzMgLTczdC0xOTggLTE5OHQtNzMgLTI3M3Q3MyAtMjczdDE5OCAtMTk4dDI3MyAtNzN0MjczIDczdDE5OCAxOTh0NzMgMjczCnQtNzMgMjczdC0xOTggMTk4dC0yNzMgNzN6TTE1MzYgNjQwcTAgLTIwOSAtMTAzIC0zODUuNXQtMjc5LjUgLTI3OS41dC0zODUuNSAtMTAzdC0zODUuNSAxMDN0LTI3OS41IDI3OS41dC0xMDMgMzg1LjV0MTAzIDM4NS41dDI3OS41IDI3OS41dDM4NS41IDEwM3QzODUuNSAtMTAzdDI3OS41IC0yNzkuNXQxMDMgLTM4NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1cGxvYWQiIHVuaWNvZGU9IiYjeGYwMWI7IiAKZD0iTTExMTggNjYwcS04IC0yMCAtMzAgLTIwaC0xOTJ2LTM1MnEwIC0xNCAtOSAtMjN0LTIzIC05aC0xOTJxLTE0IDAgLTIzIDl0LTkgMjN2MzUyaC0xOTJxLTE0IDAgLTIzIDl0LTkgMjNxMCAxMiAxMCAyNGwzMTkgMzE5cTExIDkgMjMgOXQyMyAtOWwzMjAgLTMyMHExNSAtMTYgNyAtMzV6TTc2OCAxMTg0cS0xNDggMCAtMjczIC03M3QtMTk4IC0xOTh0LTczIC0yNzN0NzMgLTI3M3QxOTggLTE5OHQyNzMgLTczdDI3MyA3M3QxOTggMTk4CnQ3MyAyNzN0LTczIDI3M3QtMTk4IDE5OHQtMjczIDczek0xNTM2IDY0MHEwIC0yMDkgLTEwMyAtMzg1LjV0LTI3OS41IC0yNzkuNXQtMzg1LjUgLTEwM3QtMzg1LjUgMTAzdC0yNzkuNSAyNzkuNXQtMTAzIDM4NS41dDEwMyAzODUuNXQyNzkuNSAyNzkuNXQzODUuNSAxMDN0Mzg1LjUgLTEwM3QyNzkuNSAtMjc5LjV0MTAzIC0zODUuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iaW5ib3giIHVuaWNvZGU9IiYjeGYwMWM7IiAKZD0iTTEwMjMgNTc2aDMxNnEtMSAzIC0yLjUgOC41dC0yLjUgNy41bC0yMTIgNDk2aC03MDhsLTIxMiAtNDk2cS0xIC0zIC0yLjUgLTguNXQtMi41IC03LjVoMzE2bDk1IC0xOTJoMzIwek0xNTM2IDU0NnYtNDgycTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtMTQwOHEtMjYgMCAtNDUgMTl0LTE5IDQ1djQ4MnEwIDYyIDI1IDEyM2wyMzggNTUycTEwIDI1IDM2LjUgNDJ0NTIuNSAxN2g4MzJxMjYgMCA1Mi41IC0xN3QzNi41IC00MmwyMzggLTU1MgpxMjUgLTYxIDI1IC0xMjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InBsYXlfY2lyY2xlIiB1bmljb2RlPSImI3hmMDFkOyIgCmQ9Ik0xMTg0IDY0MHEwIC0zNyAtMzIgLTU1bC01NDQgLTMyMHEtMTUgLTkgLTMyIC05cS0xNiAwIC0zMiA4cS0zMiAxOSAtMzIgNTZ2NjQwcTAgMzcgMzIgNTZxMzMgMTggNjQgLTFsNTQ0IC0zMjBxMzIgLTE4IDMyIC01NXpNMTMxMiA2NDBxMCAxNDggLTczIDI3M3QtMTk4IDE5OHQtMjczIDczdC0yNzMgLTczdC0xOTggLTE5OHQtNzMgLTI3M3Q3MyAtMjczdDE5OCAtMTk4dDI3MyAtNzN0MjczIDczdDE5OCAxOTh0NzMgMjczek0xNTM2IDY0MApxMCAtMjA5IC0xMDMgLTM4NS41dC0yNzkuNSAtMjc5LjV0LTM4NS41IC0xMDN0LTM4NS41IDEwM3QtMjc5LjUgMjc5LjV0LTEwMyAzODUuNXQxMDMgMzg1LjV0Mjc5LjUgMjc5LjV0Mzg1LjUgMTAzdDM4NS41IC0xMDN0Mjc5LjUgLTI3OS41dDEwMyAtMzg1LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InJlcGVhdCIgdW5pY29kZT0iJiN4ZjAxZTsiIApkPSJNMTUzNiAxMjgwdi00NDhxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC00NDhxLTQyIDAgLTU5IDQwcS0xNyAzOSAxNCA2OWwxMzggMTM4cS0xNDggMTM3IC0zNDkgMTM3cS0xMDQgMCAtMTk4LjUgLTQwLjV0LTE2My41IC0xMDkuNXQtMTA5LjUgLTE2My41dC00MC41IC0xOTguNXQ0MC41IC0xOTguNXQxMDkuNSAtMTYzLjV0MTYzLjUgLTEwOS41dDE5OC41IC00MC41cTExOSAwIDIyNSA1MnQxNzkgMTQ3cTcgMTAgMjMgMTJxMTUgMCAyNSAtOQpsMTM3IC0xMzhxOSAtOCA5LjUgLTIwLjV0LTcuNSAtMjIuNXEtMTA5IC0xMzIgLTI2NCAtMjA0LjV0LTMyNyAtNzIuNXEtMTU2IDAgLTI5OCA2MXQtMjQ1IDE2NHQtMTY0IDI0NXQtNjEgMjk4dDYxIDI5OHQxNjQgMjQ1dDI0NSAxNjR0Mjk4IDYxcTE0NyAwIDI4NC41IC01NS41dDI0NC41IC0xNTYuNWwxMzAgMTI5cTI5IDMxIDcwIDE0cTM5IC0xNyAzOSAtNTl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InJlZnJlc2giIHVuaWNvZGU9IiYjeGYwMjE7IiAKZD0iTTE1MTEgNDgwcTAgLTUgLTEgLTdxLTY0IC0yNjggLTI2OCAtNDM0LjV0LTQ3OCAtMTY2LjVxLTE0NiAwIC0yODIuNSA1NXQtMjQzLjUgMTU3bC0xMjkgLTEyOXEtMTkgLTE5IC00NSAtMTl0LTQ1IDE5dC0xOSA0NXY0NDhxMCAyNiAxOSA0NXQ0NSAxOWg0NDhxMjYgMCA0NSAtMTl0MTkgLTQ1dC0xOSAtNDVsLTEzNyAtMTM3cTcxIC02NiAxNjEgLTEwMnQxODcgLTM2cTEzNCAwIDI1MCA2NXQxODYgMTc5cTExIDE3IDUzIDExNwpxOCAyMyAzMCAyM2gxOTJxMTMgMCAyMi41IC05LjV0OS41IC0yMi41ek0xNTM2IDEyODB2LTQ0OHEwIC0yNiAtMTkgLTQ1dC00NSAtMTloLTQ0OHEtMjYgMCAtNDUgMTl0LTE5IDQ1dDE5IDQ1bDEzOCAxMzhxLTE0OCAxMzcgLTM0OSAxMzdxLTEzNCAwIC0yNTAgLTY1dC0xODYgLTE3OXEtMTEgLTE3IC01MyAtMTE3cS04IC0yMyAtMzAgLTIzaC0xOTlxLTEzIDAgLTIyLjUgOS41dC05LjUgMjIuNXY3cTY1IDI2OCAyNzAgNDM0LjV0NDgwIDE2Ni41CnExNDYgMCAyODQgLTU1LjV0MjQ1IC0xNTYuNWwxMzAgMTI5cTE5IDE5IDQ1IDE5dDQ1IC0xOXQxOSAtNDV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Imxpc3RfYWx0IiB1bmljb2RlPSImI3hmMDIyOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMzg0IDM1MnYtNjRxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC02NHEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djY0cTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoNjRxMTMgMCAyMi41IC05LjV0OS41IC0yMi41ek0zODQgNjA4di02NHEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTY0cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2NjRxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWg2NHExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6Ck0zODQgODY0di02NHEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTY0cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2NjRxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWg2NHExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6TTE1MzYgMzUydi02NHEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTk2MHEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djY0cTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoOTYwcTEzIDAgMjIuNSAtOS41dDkuNSAtMjIuNXoKTTE1MzYgNjA4di02NHEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTk2MHEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djY0cTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoOTYwcTEzIDAgMjIuNSAtOS41dDkuNSAtMjIuNXpNMTUzNiA4NjR2LTY0cTAgLTEzIC05LjUgLTIyLjV0LTIyLjUgLTkuNWgtOTYwcS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2NjRxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWg5NjBxMTMgMCAyMi41IC05LjUKdDkuNSAtMjIuNXpNMTY2NCAxNjB2ODMycTAgMTMgLTkuNSAyMi41dC0yMi41IDkuNWgtMTQ3MnEtMTMgMCAtMjIuNSAtOS41dC05LjUgLTIyLjV2LTgzMnEwIC0xMyA5LjUgLTIyLjV0MjIuNSAtOS41aDE0NzJxMTMgMCAyMi41IDkuNXQ5LjUgMjIuNXpNMTc5MiAxMjQ4di0xMDg4cTAgLTY2IC00NyAtMTEzdC0xMTMgLTQ3aC0xNDcycS02NiAwIC0xMTMgNDd0LTQ3IDExM3YxMDg4cTAgNjYgNDcgMTEzdDExMyA0N2gxNDcycTY2IDAgMTEzIC00Nwp0NDcgLTExM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibG9jayIgdW5pY29kZT0iJiN4ZjAyMzsiIGhvcml6LWFkdi14PSIxMTUyIiAKZD0iTTMyMCA3NjhoNTEydjE5MnEwIDEwNiAtNzUgMTgxdC0xODEgNzV0LTE4MSAtNzV0LTc1IC0xODF2LTE5MnpNMTE1MiA2NzJ2LTU3NnEwIC00MCAtMjggLTY4dC02OCAtMjhoLTk2MHEtNDAgMCAtNjggMjh0LTI4IDY4djU3NnEwIDQwIDI4IDY4dDY4IDI4aDMydjE5MnEwIDE4NCAxMzIgMzE2dDMxNiAxMzJ0MzE2IC0xMzJ0MTMyIC0zMTZ2LTE5MmgzMnE0MCAwIDY4IC0yOHQyOCAtNjh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImZsYWciIHVuaWNvZGU9IiYjeGYwMjQ7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0zMjAgMTI4MHEwIC03MiAtNjQgLTExMHYtMTI2NnEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTY0cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2MTI2NnEtNjQgMzggLTY0IDExMHEwIDUzIDM3LjUgOTAuNXQ5MC41IDM3LjV0OTAuNSAtMzcuNXQzNy41IC05MC41ek0xNzkyIDEyMTZ2LTc2M3EwIC0yNSAtMTIuNSAtMzguNXQtMzkuNSAtMjcuNXEtMjE1IC0xMTYgLTM2OSAtMTE2cS02MSAwIC0xMjMuNSAyMnQtMTA4LjUgNDgKdC0xMTUuNSA0OHQtMTQyLjUgMjJxLTE5MiAwIC00NjQgLTE0NnEtMTcgLTkgLTMzIC05cS0yNiAwIC00NSAxOXQtMTkgNDV2NzQycTAgMzIgMzEgNTVxMjEgMTQgNzkgNDNxMjM2IDEyMCA0MjEgMTIwcTEwNyAwIDIwMCAtMjl0MjE5IC04OHEzOCAtMTkgODggLTE5cTU0IDAgMTE3LjUgMjF0MTEwIDQ3dDg4IDQ3dDU0LjUgMjFxMjYgMCA0NSAtMTl0MTkgLTQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJoZWFkcGhvbmVzIiB1bmljb2RlPSImI3hmMDI1OyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNMTY2NCA2NTBxMCAtMTY2IC02MCAtMzE0bC0yMCAtNDlsLTE4NSAtMzNxLTIyIC04MyAtOTAuNSAtMTM2LjV0LTE1Ni41IC01My41di0zMnEwIC0xNCAtOSAtMjN0LTIzIC05aC02NHEtMTQgMCAtMjMgOXQtOSAyM3Y1NzZxMCAxNCA5IDIzdDIzIDloNjRxMTQgMCAyMyAtOXQ5IC0yM3YtMzJxNzEgMCAxMzAgLTM1LjV0OTMgLTk1LjVsNjggMTJxMjkgOTUgMjkgMTkzcTAgMTQ4IC04OCAyNzl0LTIzNi41IDIwOXQtMzE1LjUgNzgKdC0zMTUuNSAtNzh0LTIzNi41IC0yMDl0LTg4IC0yNzlxMCAtOTggMjkgLTE5M2w2OCAtMTJxMzQgNjAgOTMgOTUuNXQxMzAgMzUuNXYzMnEwIDE0IDkgMjN0MjMgOWg2NHExNCAwIDIzIC05dDkgLTIzdi01NzZxMCAtMTQgLTkgLTIzdC0yMyAtOWgtNjRxLTE0IDAgLTIzIDl0LTkgMjN2MzJxLTg4IDAgLTE1Ni41IDUzLjV0LTkwLjUgMTM2LjVsLTE4NSAzM2wtMjAgNDlxLTYwIDE0OCAtNjAgMzE0cTAgMTUxIDY3IDI5MXQxNzkgMjQyLjUKdDI2NiAxNjMuNXQzMjAgNjF0MzIwIC02MXQyNjYgLTE2My41dDE3OSAtMjQyLjV0NjcgLTI5MXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idm9sdW1lX29mZiIgdW5pY29kZT0iJiN4ZjAyNjsiIGhvcml6LWFkdi14PSI3NjgiIApkPSJNNzY4IDExODR2LTEwODhxMCAtMjYgLTE5IC00NXQtNDUgLTE5dC00NSAxOWwtMzMzIDMzM2gtMjYycS0yNiAwIC00NSAxOXQtMTkgNDV2Mzg0cTAgMjYgMTkgNDV0NDUgMTloMjYybDMzMyAzMzNxMTkgMTkgNDUgMTl0NDUgLTE5dDE5IC00NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idm9sdW1lX2Rvd24iIHVuaWNvZGU9IiYjeGYwMjc7IiBob3Jpei1hZHYteD0iMTE1MiIgCmQ9Ik03NjggMTE4NHYtMTA4OHEwIC0yNiAtMTkgLTQ1dC00NSAtMTl0LTQ1IDE5bC0zMzMgMzMzaC0yNjJxLTI2IDAgLTQ1IDE5dC0xOSA0NXYzODRxMCAyNiAxOSA0NXQ0NSAxOWgyNjJsMzMzIDMzM3ExOSAxOSA0NSAxOXQ0NSAtMTl0MTkgLTQ1ek0xMTUyIDY0MHEwIC03NiAtNDIuNSAtMTQxLjV0LTExMi41IC05My41cS0xMCAtNSAtMjUgLTVxLTI2IDAgLTQ1IDE4LjV0LTE5IDQ1LjVxMCAyMSAxMiAzNS41dDI5IDI1dDM0IDIzdDI5IDM2CnQxMiA1Ni41dC0xMiA1Ni41dC0yOSAzNnQtMzQgMjN0LTI5IDI1dC0xMiAzNS41cTAgMjcgMTkgNDUuNXQ0NSAxOC41cTE1IDAgMjUgLTVxNzAgLTI3IDExMi41IC05M3Q0Mi41IC0xNDJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InZvbHVtZV91cCIgdW5pY29kZT0iJiN4ZjAyODsiIGhvcml6LWFkdi14PSIxNjY0IiAKZD0iTTc2OCAxMTg0di0xMDg4cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOXQtNDUgMTlsLTMzMyAzMzNoLTI2MnEtMjYgMCAtNDUgMTl0LTE5IDQ1djM4NHEwIDI2IDE5IDQ1dDQ1IDE5aDI2MmwzMzMgMzMzcTE5IDE5IDQ1IDE5dDQ1IC0xOXQxOSAtNDV6TTExNTIgNjQwcTAgLTc2IC00Mi41IC0xNDEuNXQtMTEyLjUgLTkzLjVxLTEwIC01IC0yNSAtNXEtMjYgMCAtNDUgMTguNXQtMTkgNDUuNXEwIDIxIDEyIDM1LjV0MjkgMjV0MzQgMjN0MjkgMzYKdDEyIDU2LjV0LTEyIDU2LjV0LTI5IDM2dC0zNCAyM3QtMjkgMjV0LTEyIDM1LjVxMCAyNyAxOSA0NS41dDQ1IDE4LjVxMTUgMCAyNSAtNXE3MCAtMjcgMTEyLjUgLTkzdDQyLjUgLTE0MnpNMTQwOCA2NDBxMCAtMTUzIC04NSAtMjgyLjV0LTIyNSAtMTg4LjVxLTEzIC01IC0yNSAtNXEtMjcgMCAtNDYgMTl0LTE5IDQ1cTAgMzkgMzkgNTlxNTYgMjkgNzYgNDRxNzQgNTQgMTE1LjUgMTM1LjV0NDEuNSAxNzMuNXQtNDEuNSAxNzMuNQp0LTExNS41IDEzNS41cS0yMCAxNSAtNzYgNDRxLTM5IDIwIC0zOSA1OXEwIDI2IDE5IDQ1dDQ1IDE5cTEzIDAgMjYgLTVxMTQwIC01OSAyMjUgLTE4OC41dDg1IC0yODIuNXpNMTY2NCA2NDBxMCAtMjMwIC0xMjcgLTQyMi41dC0zMzggLTI4My41cS0xMyAtNSAtMjYgLTVxLTI2IDAgLTQ1IDE5dC0xOSA0NXEwIDM2IDM5IDU5cTcgNCAyMi41IDEwLjV0MjIuNSAxMC41cTQ2IDI1IDgyIDUxcTEyMyA5MSAxOTIgMjI3dDY5IDI4OXQtNjkgMjg5CnQtMTkyIDIyN3EtMzYgMjYgLTgyIDUxcS03IDQgLTIyLjUgMTAuNXQtMjIuNSAxMC41cS0zOSAyMyAtMzkgNTlxMCAyNiAxOSA0NXQ0NSAxOXExMyAwIDI2IC01cTIxMSAtOTEgMzM4IC0yODMuNXQxMjcgLTQyMi41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJxcmNvZGUiIHVuaWNvZGU9IiYjeGYwMjk7IiBob3Jpei1hZHYteD0iMTQwOCIgCmQ9Ik0zODQgMzg0di0xMjhoLTEyOHYxMjhoMTI4ek0zODQgMTE1MnYtMTI4aC0xMjh2MTI4aDEyOHpNMTE1MiAxMTUydi0xMjhoLTEyOHYxMjhoMTI4ek0xMjggMTI5aDM4NHYzODNoLTM4NHYtMzgzek0xMjggODk2aDM4NHYzODRoLTM4NHYtMzg0ek04OTYgODk2aDM4NHYzODRoLTM4NHYtMzg0ek02NDAgNjQwdi02NDBoLTY0MHY2NDBoNjQwek0xMTUyIDEyOHYtMTI4aC0xMjh2MTI4aDEyOHpNMTQwOCAxMjh2LTEyOGgtMTI4djEyOGgxMjh6Ck0xNDA4IDY0MHYtMzg0aC0zODR2MTI4aC0xMjh2LTM4NGgtMTI4djY0MGgzODR2LTEyOGgxMjh2MTI4aDEyOHpNNjQwIDE0MDh2LTY0MGgtNjQwdjY0MGg2NDB6TTE0MDggMTQwOHYtNjQwaC02NDB2NjQwaDY0MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYmFyY29kZSIgdW5pY29kZT0iJiN4ZjAyYTsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTYzIDBoLTYzdjE0MDhoNjN2LTE0MDh6TTEyNiAxaC0zMnYxNDA3aDMydi0xNDA3ek0yMjAgMWgtMzF2MTQwN2gzMXYtMTQwN3pNMzc3IDFoLTMxdjE0MDdoMzF2LTE0MDd6TTUzNCAxaC02MnYxNDA3aDYydi0xNDA3ek02NjAgMWgtMzF2MTQwN2gzMXYtMTQwN3pNNzIzIDFoLTMxdjE0MDdoMzF2LTE0MDd6TTc4NiAxaC0zMXYxNDA3aDMxdi0xNDA3ek05NDMgMWgtNjN2MTQwN2g2M3YtMTQwN3pNMTEwMCAxaC02M3YxNDA3aDYzdi0xNDA3egpNMTIyNiAxaC02M3YxNDA3aDYzdi0xNDA3ek0xMzUyIDFoLTYzdjE0MDdoNjN2LTE0MDd6TTE0NDYgMWgtNjN2MTQwN2g2M3YtMTQwN3pNMTYzNSAxaC05NHYxNDA3aDk0di0xNDA3ek0xNjk4IDFoLTMydjE0MDdoMzJ2LTE0MDd6TTE3OTIgMGgtNjN2MTQwOGg2M3YtMTQwOHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idGFnIiB1bmljb2RlPSImI3hmMDJiOyIgCmQ9Ik00NDggMTA4OHEwIDUzIC0zNy41IDkwLjV0LTkwLjUgMzcuNXQtOTAuNSAtMzcuNXQtMzcuNSAtOTAuNXQzNy41IC05MC41dDkwLjUgLTM3LjV0OTAuNSAzNy41dDM3LjUgOTAuNXpNMTUxNSA1MTJxMCAtNTMgLTM3IC05MGwtNDkxIC00OTJxLTM5IC0zNyAtOTEgLTM3cS01MyAwIC05MCAzN2wtNzE1IDcxNnEtMzggMzcgLTY0LjUgMTAxdC0yNi41IDExN3Y0MTZxMCA1MiAzOCA5MHQ5MCAzOGg0MTZxNTMgMCAxMTcgLTI2LjV0MTAyIC02NC41Cmw3MTUgLTcxNHEzNyAtMzkgMzcgLTkxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ0YWdzIiB1bmljb2RlPSImI3hmMDJjOyIgaG9yaXotYWR2LXg9IjE5MjAiIApkPSJNNDQ4IDEwODhxMCA1MyAtMzcuNSA5MC41dC05MC41IDM3LjV0LTkwLjUgLTM3LjV0LTM3LjUgLTkwLjV0MzcuNSAtOTAuNXQ5MC41IC0zNy41dDkwLjUgMzcuNXQzNy41IDkwLjV6TTE1MTUgNTEycTAgLTUzIC0zNyAtOTBsLTQ5MSAtNDkycS0zOSAtMzcgLTkxIC0zN3EtNTMgMCAtOTAgMzdsLTcxNSA3MTZxLTM4IDM3IC02NC41IDEwMXQtMjYuNSAxMTd2NDE2cTAgNTIgMzggOTB0OTAgMzhoNDE2cTUzIDAgMTE3IC0yNi41dDEwMiAtNjQuNQpsNzE1IC03MTRxMzcgLTM5IDM3IC05MXpNMTg5OSA1MTJxMCAtNTMgLTM3IC05MGwtNDkxIC00OTJxLTM5IC0zNyAtOTEgLTM3cS0zNiAwIC01OSAxNHQtNTMgNDVsNDcwIDQ3MHEzNyAzNyAzNyA5MHEwIDUyIC0zNyA5MWwtNzE1IDcxNHEtMzggMzggLTEwMiA2NC41dC0xMTcgMjYuNWgyMjRxNTMgMCAxMTcgLTI2LjV0MTAyIC02NC41bDcxNSAtNzE0cTM3IC0zOSAzNyAtOTF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImJvb2siIHVuaWNvZGU9IiYjeGYwMmQ7IiBob3Jpei1hZHYteD0iMTY2NCIgCmQ9Ik0xNjM5IDEwNThxNDAgLTU3IDE4IC0xMjlsLTI3NSAtOTA2cS0xOSAtNjQgLTc2LjUgLTEwNy41dC0xMjIuNSAtNDMuNWgtOTIzcS03NyAwIC0xNDguNSA1My41dC05OS41IDEzMS41cS0yNCA2NyAtMiAxMjdxMCA0IDMgMjd0NCAzN3ExIDggLTMgMjEuNXQtMyAxOS41cTIgMTEgOCAyMXQxNi41IDIzLjV0MTYuNSAyMy41cTIzIDM4IDQ1IDkxLjV0MzAgOTEuNXEzIDEwIDAuNSAzMHQtMC41IDI4cTMgMTEgMTcgMjh0MTcgMjMKcTIxIDM2IDQyIDkydDI1IDkwcTEgOSAtMi41IDMydDAuNSAyOHE0IDEzIDIyIDMwLjV0MjIgMjIuNXExOSAyNiA0Mi41IDg0LjV0MjcuNSA5Ni41cTEgOCAtMyAyNS41dC0yIDI2LjVxMiA4IDkgMTh0MTggMjN0MTcgMjFxOCAxMiAxNi41IDMwLjV0MTUgMzV0MTYgMzZ0MTkuNSAzMnQyNi41IDIzLjV0MzYgMTEuNXQ0Ny41IC01LjVsLTEgLTNxMzggOSA1MSA5aDc2MXE3NCAwIDExNCAtNTZ0MTggLTEzMGwtMjc0IC05MDYKcS0zNiAtMTE5IC03MS41IC0xNTMuNXQtMTI4LjUgLTM0LjVoLTg2OXEtMjcgMCAtMzggLTE1cS0xMSAtMTYgLTEgLTQzcTI0IC03MCAxNDQgLTcwaDkyM3EyOSAwIDU2IDE1LjV0MzUgNDEuNWwzMDAgOTg3cTcgMjIgNSA1N3EzOCAtMTUgNTkgLTQzek01NzUgMTA1NnEtNCAtMTMgMiAtMjIuNXQyMCAtOS41aDYwOHExMyAwIDI1LjUgOS41dDE2LjUgMjIuNWwyMSA2NHE0IDEzIC0yIDIyLjV0LTIwIDkuNWgtNjA4cS0xMyAwIC0yNS41IC05LjUKdC0xNi41IC0yMi41ek00OTIgODAwcS00IC0xMyAyIC0yMi41dDIwIC05LjVoNjA4cTEzIDAgMjUuNSA5LjV0MTYuNSAyMi41bDIxIDY0cTQgMTMgLTIgMjIuNXQtMjAgOS41aC02MDhxLTEzIDAgLTI1LjUgLTkuNXQtMTYuNSAtMjIuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYm9va21hcmsiIHVuaWNvZGU9IiYjeGYwMmU7IiBob3Jpei1hZHYteD0iMTI4MCIgCmQ9Ik0xMTY0IDE0MDhxMjMgMCA0NCAtOXEzMyAtMTMgNTIuNSAtNDF0MTkuNSAtNjJ2LTEyODlxMCAtMzQgLTE5LjUgLTYydC01Mi41IC00MXEtMTkgLTggLTQ0IC04cS00OCAwIC04MyAzMmwtNDQxIDQyNGwtNDQxIC00MjRxLTM2IC0zMyAtODMgLTMzcS0yMyAwIC00NCA5cS0zMyAxMyAtNTIuNSA0MXQtMTkuNSA2MnYxMjg5cTAgMzQgMTkuNSA2MnQ1Mi41IDQxcTIxIDkgNDQgOWgxMDQ4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJwcmludCIgdW5pY29kZT0iJiN4ZjAyZjsiIGhvcml6LWFkdi14PSIxNjY0IiAKZD0iTTM4NCAwaDg5NnYyNTZoLTg5NnYtMjU2ek0zODQgNjQwaDg5NnYzODRoLTE2MHEtNDAgMCAtNjggMjh0LTI4IDY4djE2MGgtNjQwdi02NDB6TTE1MzYgNTc2cTAgMjYgLTE5IDQ1dC00NSAxOXQtNDUgLTE5dC0xOSAtNDV0MTkgLTQ1dDQ1IC0xOXQ0NSAxOXQxOSA0NXpNMTY2NCA1NzZ2LTQxNnEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTIyNHYtMTYwcTAgLTQwIC0yOCAtNjh0LTY4IC0yOGgtOTYwcS00MCAwIC02OCAyOHQtMjggNjgKdjE2MGgtMjI0cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2NDE2cTAgNzkgNTYuNSAxMzUuNXQxMzUuNSA1Ni41aDY0djU0NHEwIDQwIDI4IDY4dDY4IDI4aDY3MnE0MCAwIDg4IC0yMHQ3NiAtNDhsMTUyIC0xNTJxMjggLTI4IDQ4IC03NnQyMCAtODh2LTI1Nmg2NHE3OSAwIDEzNS41IC01Ni41dDU2LjUgLTEzNS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjYW1lcmEiIHVuaWNvZGU9IiYjeGYwMzA7IiBob3Jpei1hZHYteD0iMTkyMCIgCmQ9Ik05NjAgODY0cTExOSAwIDIwMy41IC04NC41dDg0LjUgLTIwMy41dC04NC41IC0yMDMuNXQtMjAzLjUgLTg0LjV0LTIwMy41IDg0LjV0LTg0LjUgMjAzLjV0ODQuNSAyMDMuNXQyMDMuNSA4NC41ek0xNjY0IDEyODBxMTA2IDAgMTgxIC03NXQ3NSAtMTgxdi04OTZxMCAtMTA2IC03NSAtMTgxdC0xODEgLTc1aC0xNDA4cS0xMDYgMCAtMTgxIDc1dC03NSAxODF2ODk2cTAgMTA2IDc1IDE4MXQxODEgNzVoMjI0bDUxIDEzNgpxMTkgNDkgNjkuNSA4NC41dDEwMy41IDM1LjVoNTEycTUzIDAgMTAzLjUgLTM1LjV0NjkuNSAtODQuNWw1MSAtMTM2aDIyNHpNOTYwIDEyOHExODUgMCAzMTYuNSAxMzEuNXQxMzEuNSAzMTYuNXQtMTMxLjUgMzE2LjV0LTMxNi41IDEzMS41dC0zMTYuNSAtMTMxLjV0LTEzMS41IC0zMTYuNXQxMzEuNSAtMzE2LjV0MzE2LjUgLTEzMS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJmb250IiB1bmljb2RlPSImI3hmMDMxOyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNNzI1IDk3N2wtMTcwIC00NTBxMzMgMCAxMzYuNSAtMnQxNjAuNSAtMnExOSAwIDU3IDJxLTg3IDI1MyAtMTg0IDQ1MnpNMCAtMTI4bDIgNzlxMjMgNyA1NiAxMi41dDU3IDEwLjV0NDkuNSAxNC41dDQ0LjUgMjl0MzEgNTAuNWwyMzcgNjE2bDI4MCA3MjRoNzVoNTNxOCAtMTQgMTEgLTIxbDIwNSAtNDgwcTMzIC03OCAxMDYgLTI1Ny41dDExNCAtMjc0LjVxMTUgLTM0IDU4IC0xNDQuNXQ3MiAtMTY4LjVxMjAgLTQ1IDM1IC01NwpxMTkgLTE1IDg4IC0yOS41dDg0IC0yMC41cTYgLTM4IDYgLTU3cTAgLTUgLTAuNSAtMTMuNXQtMC41IC0xMi41cS02MyAwIC0xOTAgOHQtMTkxIDhxLTc2IDAgLTIxNSAtN3QtMTc4IC04cTAgNDMgNCA3OGwxMzEgMjhxMSAwIDEyLjUgMi41dDE1LjUgMy41dDE0LjUgNC41dDE1IDYuNXQxMSA4dDkgMTF0Mi41IDE0cTAgMTYgLTMxIDk2LjV0LTcyIDE3Ny41dC00MiAxMDBsLTQ1MCAycS0yNiAtNTggLTc2LjUgLTE5NS41dC01MC41IC0xNjIuNQpxMCAtMjIgMTQgLTM3LjV0NDMuNSAtMjQuNXQ0OC41IC0xMy41dDU3IC04LjV0NDEgLTRxMSAtMTkgMSAtNThxMCAtOSAtMiAtMjdxLTU4IDAgLTE3NC41IDEwdC0xNzQuNSAxMHEtOCAwIC0yNi41IC00dC0yMS41IC00cS04MCAtMTQgLTE4OCAtMTR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImJvbGQiIHVuaWNvZGU9IiYjeGYwMzI7IiBob3Jpei1hZHYteD0iMTQwOCIgCmQ9Ik01NTUgMTVxNzQgLTMyIDE0MCAtMzJxMzc2IDAgMzc2IDMzNXEwIDExNCAtNDEgMTgwcS0yNyA0NCAtNjEuNSA3NHQtNjcuNSA0Ni41dC04MC41IDI1dC04NCAxMC41dC05NC41IDJxLTczIDAgLTEwMSAtMTBxMCAtNTMgLTAuNSAtMTU5dC0wLjUgLTE1OHEwIC04IC0xIC02Ny41dC0wLjUgLTk2LjV0NC41IC04My41dDEyIC02Ni41ek01NDEgNzYxcTQyIC03IDEwOSAtN3E4MiAwIDE0MyAxM3QxMTAgNDQuNXQ3NC41IDg5LjV0MjUuNSAxNDIKcTAgNzAgLTI5IDEyMi41dC03OSA4MnQtMTA4IDQzLjV0LTEyNCAxNHEtNTAgMCAtMTMwIC0xM3EwIC01MCA0IC0xNTF0NCAtMTUycTAgLTI3IC0wLjUgLTgwdC0wLjUgLTc5cTAgLTQ2IDEgLTY5ek0wIC0xMjhsMiA5NHExNSA0IDg1IDE2dDEwNiAyN3E3IDEyIDEyLjUgMjd0OC41IDMzLjV0NS41IDMyLjV0MyAzNy41dDAuNSAzNHYzNS41djMwcTAgOTgyIC0yMiAxMDI1cS00IDggLTIyIDE0LjV0LTQ0LjUgMTF0LTQ5LjUgN3QtNDguNSA0LjUKdC0zMC41IDNsLTQgODNxOTggMiAzNDAgMTEuNXQzNzMgOS41cTIzIDAgNjggLTAuNXQ2OCAtMC41cTcwIDAgMTM2LjUgLTEzdDEyOC41IC00MnQxMDggLTcxdDc0IC0xMDQuNXQyOCAtMTM3LjVxMCAtNTIgLTE2LjUgLTk1LjV0LTM5IC03MnQtNjQuNSAtNTcuNXQtNzMgLTQ1dC04NCAtNDBxMTU0IC0zNSAyNTYuNSAtMTM0dDEwMi41IC0yNDhxMCAtMTAwIC0zNSAtMTc5LjV0LTkzLjUgLTEzMC41dC0xMzggLTg1LjV0LTE2My41IC00OC41CnQtMTc2IC0xNHEtNDQgMCAtMTMyIDN0LTEzMiAzcS0xMDYgMCAtMzA3IC0xMXQtMjMxIC0xMnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iaXRhbGljIiB1bmljb2RlPSImI3hmMDMzOyIgaG9yaXotYWR2LXg9IjEwMjQiIApkPSJNMCAtMTI2bDE3IDg1cTIyIDcgNjEuNSAxNi41dDcyIDE5dDU5LjUgMjMuNXEyOCAzNSA0MSAxMDFxMSA3IDYyIDI4OXQxMTQgNTQzLjV0NTIgMjk2LjV2MjVxLTI0IDEzIC01NC41IDE4LjV0LTY5LjUgOHQtNTggNS41bDE5IDEwM3EzMyAtMiAxMjAgLTYuNXQxNDkuNSAtN3QxMjAuNSAtMi41cTQ4IDAgOTguNSAyLjV0MTIxIDd0OTguNSA2LjVxLTUgLTM5IC0xOSAtODlxLTMwIC0xMCAtMTAxLjUgLTI4LjV0LTEwOC41IC0zMy41CnEtOCAtMTkgLTE0IC00Mi41dC05IC00MHQtNy41IC00NS41dC02LjUgLTQycS0yNyAtMTQ4IC04Ny41IC00MTkuNXQtNzcuNSAtMzU1LjVxLTIgLTkgLTEzIC01OHQtMjAgLTkwdC0xNiAtODMuNXQtNiAtNTcuNWwxIC0xOHExNyAtNCAxODUgLTMxcS0zIC00NCAtMTYgLTk5cS0xMSAwIC0zMi41IC0xLjV0LTMyLjUgLTEuNXEtMjkgMCAtODcgMTB0LTg2IDEwcS0xMzggMiAtMjA2IDJxLTUxIDAgLTE0MyAtOXQtMTIxIC0xMXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idGV4dF9oZWlnaHQiIHVuaWNvZGU9IiYjeGYwMzQ7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xNzQ0IDEyOHEzMyAwIDQyIC0xOC41dC0xMSAtNDQuNWwtMTI2IC0xNjJxLTIwIC0yNiAtNDkgLTI2dC00OSAyNmwtMTI2IDE2MnEtMjAgMjYgLTExIDQ0LjV0NDIgMTguNWg4MHYxMDI0aC04MHEtMzMgMCAtNDIgMTguNXQxMSA0NC41bDEyNiAxNjJxMjAgMjYgNDkgMjZ0NDkgLTI2bDEyNiAtMTYycTIwIC0yNiAxMSAtNDQuNXQtNDIgLTE4LjVoLTgwdi0xMDI0aDgwek04MSAxNDA3bDU0IC0yN3ExMiAtNSAyMTEgLTVxNDQgMCAxMzIgMgp0MTMyIDJxMzYgMCAxMDcuNSAtMC41dDEwNy41IC0wLjVoMjkzcTYgMCAyMSAtMC41dDIwLjUgMHQxNiAzdDE3LjUgOXQxNSAxNy41bDQyIDFxNCAwIDE0IC0wLjV0MTQgLTAuNXEyIC0xMTIgMiAtMzM2cTAgLTgwIC01IC0xMDlxLTM5IC0xNCAtNjggLTE4cS0yNSA0NCAtNTQgMTI4cS0zIDkgLTExIDQ4dC0xNC41IDczLjV0LTcuNSAzNS41cS02IDggLTEyIDEyLjV0LTE1LjUgNnQtMTMgMi41dC0xOCAwLjV0LTE2LjUgLTAuNQpxLTE3IDAgLTY2LjUgMC41dC03NC41IDAuNXQtNjQgLTJ0LTcxIC02cS05IC04MSAtOCAtMTM2cTAgLTk0IDIgLTM4OHQyIC00NTVxMCAtMTYgLTIuNSAtNzEuNXQwIC05MS41dDEyLjUgLTY5cTQwIC0yMSAxMjQgLTQyLjV0MTIwIC0zNy41cTUgLTQwIDUgLTUwcTAgLTE0IC0zIC0yOWwtMzQgLTFxLTc2IC0yIC0yMTggOHQtMjA3IDEwcS01MCAwIC0xNTEgLTl0LTE1MiAtOXEtMyA1MSAtMyA1MnY5cTE3IDI3IDYxLjUgNDN0OTguNSAyOXQ3OCAyNwpxMTkgNDIgMTkgMzgzcTAgMTAxIC0zIDMwM3QtMyAzMDN2MTE3cTAgMiAwLjUgMTUuNXQwLjUgMjV0LTEgMjUuNXQtMyAyNHQtNSAxNHEtMTEgMTIgLTE2MiAxMnEtMzMgMCAtOTMgLTEydC04MCAtMjZxLTE5IC0xMyAtMzQgLTcyLjV0LTMxLjUgLTExMXQtNDIuNSAtNTMuNXEtNDIgMjYgLTU2IDQ0djM4M3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idGV4dF93aWR0aCIgdW5pY29kZT0iJiN4ZjAzNTsiIApkPSJNODEgMTQwN2w1NCAtMjdxMTIgLTUgMjExIC01cTQ0IDAgMTMyIDJ0MTMyIDJxNzAgMCAyNDYuNSAxdDMwNC41IDAuNXQyNDcgLTQuNXEzMyAtMSA1NiAzMWw0MiAxcTQgMCAxNCAtMC41dDE0IC0wLjVxMiAtMTEyIDIgLTMzNnEwIC04MCAtNSAtMTA5cS0zOSAtMTQgLTY4IC0xOHEtMjUgNDQgLTU0IDEyOHEtMyA5IC0xMSA0Ny41dC0xNSA3My41dC03IDM2cS0xMCAxMyAtMjcgMTlxLTUgMiAtNjYgMnEtMzAgMCAtOTMgMXQtMTAzIDEKdC05NCAtMnQtOTYgLTdxLTkgLTgxIC04IC0xMzZsMSAtMTUydjUycTAgLTU1IDEgLTE1NHQxLjUgLTE4MHQwLjUgLTE1M3EwIC0xNiAtMi41IC03MS41dDAgLTkxLjV0MTIuNSAtNjlxNDAgLTIxIDEyNCAtNDIuNXQxMjAgLTM3LjVxNSAtNDAgNSAtNTBxMCAtMTQgLTMgLTI5bC0zNCAtMXEtNzYgLTIgLTIxOCA4dC0yMDcgMTBxLTUwIDAgLTE1MSAtOXQtMTUyIC05cS0zIDUxIC0zIDUydjlxMTcgMjcgNjEuNSA0M3Q5OC41IDI5dDc4IDI3CnE3IDE2IDExLjUgNzR0NiAxNDUuNXQxLjUgMTU1dC0wLjUgMTUzLjV0LTAuNSA4OXEwIDcgLTIuNSAyMS41dC0yLjUgMjIuNXEwIDcgMC41IDQ0dDEgNzN0MCA3Ni41dC0zIDY3LjV0LTYuNSAzMnEtMTEgMTIgLTE2MiAxMnEtNDEgMCAtMTYzIC0xMy41dC0xMzggLTI0LjVxLTE5IC0xMiAtMzQgLTcxLjV0LTMxLjUgLTExMS41dC00Mi41IC01NHEtNDIgMjYgLTU2IDQ0djM4M3pNMTMxMCAxMjVxMTIgMCA0MiAtMTkuNXQ1Ny41IC00MS41CnQ1OS41IC00OXQzNiAtMzBxMjYgLTIxIDI2IC00OXQtMjYgLTQ5cS00IC0zIC0zNiAtMzB0LTU5LjUgLTQ5dC01Ny41IC00MS41dC00MiAtMTkuNXEtMTMgMCAtMjAuNSAxMC41dC0xMCAyOC41dC0yLjUgMzMuNXQxLjUgMzN0MS41IDE5LjVoLTEwMjRxMCAtMiAxLjUgLTE5LjV0MS41IC0zM3QtMi41IC0zMy41dC0xMCAtMjguNXQtMjAuNSAtMTAuNXEtMTIgMCAtNDIgMTkuNXQtNTcuNSA0MS41dC01OS41IDQ5dC0zNiAzMHEtMjYgMjEgLTI2IDQ5CnQyNiA0OXE0IDMgMzYgMzB0NTkuNSA0OXQ1Ny41IDQxLjV0NDIgMTkuNXExMyAwIDIwLjUgLTEwLjV0MTAgLTI4LjV0Mi41IC0zMy41dC0xLjUgLTMzdC0xLjUgLTE5LjVoMTAyNHEwIDIgLTEuNSAxOS41dC0xLjUgMzN0Mi41IDMzLjV0MTAgMjguNXQyMC41IDEwLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImFsaWduX2xlZnQiIHVuaWNvZGU9IiYjeGYwMzY7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xNzkyIDE5MnYtMTI4cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtMTY2NHEtMjYgMCAtNDUgMTl0LTE5IDQ1djEyOHEwIDI2IDE5IDQ1dDQ1IDE5aDE2NjRxMjYgMCA0NSAtMTl0MTkgLTQ1ek0xNDA4IDU3NnYtMTI4cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtMTI4MHEtMjYgMCAtNDUgMTl0LTE5IDQ1djEyOHEwIDI2IDE5IDQ1dDQ1IDE5aDEyODBxMjYgMCA0NSAtMTl0MTkgLTQ1ek0xNjY0IDk2MHYtMTI4cTAgLTI2IC0xOSAtNDUKdC00NSAtMTloLTE1MzZxLTI2IDAgLTQ1IDE5dC0xOSA0NXYxMjhxMCAyNiAxOSA0NXQ0NSAxOWgxNTM2cTI2IDAgNDUgLTE5dDE5IC00NXpNMTI4MCAxMzQ0di0xMjhxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0xMTUycS0yNiAwIC00NSAxOXQtMTkgNDV2MTI4cTAgMjYgMTkgNDV0NDUgMTloMTE1MnEyNiAwIDQ1IC0xOXQxOSAtNDV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImFsaWduX2NlbnRlciIgdW5pY29kZT0iJiN4ZjAzNzsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE3OTIgMTkydi0xMjhxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0xNjY0cS0yNiAwIC00NSAxOXQtMTkgNDV2MTI4cTAgMjYgMTkgNDV0NDUgMTloMTY2NHEyNiAwIDQ1IC0xOXQxOSAtNDV6TTE0MDggNTc2di0xMjhxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC04OTZxLTI2IDAgLTQ1IDE5dC0xOSA0NXYxMjhxMCAyNiAxOSA0NXQ0NSAxOWg4OTZxMjYgMCA0NSAtMTl0MTkgLTQ1ek0xNjY0IDk2MHYtMTI4cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOQpoLTE0MDhxLTI2IDAgLTQ1IDE5dC0xOSA0NXYxMjhxMCAyNiAxOSA0NXQ0NSAxOWgxNDA4cTI2IDAgNDUgLTE5dDE5IC00NXpNMTI4MCAxMzQ0di0xMjhxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC02NDBxLTI2IDAgLTQ1IDE5dC0xOSA0NXYxMjhxMCAyNiAxOSA0NXQ0NSAxOWg2NDBxMjYgMCA0NSAtMTl0MTkgLTQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhbGlnbl9yaWdodCIgdW5pY29kZT0iJiN4ZjAzODsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE3OTIgMTkydi0xMjhxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0xNjY0cS0yNiAwIC00NSAxOXQtMTkgNDV2MTI4cTAgMjYgMTkgNDV0NDUgMTloMTY2NHEyNiAwIDQ1IC0xOXQxOSAtNDV6TTE3OTIgNTc2di0xMjhxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0xMjgwcS0yNiAwIC00NSAxOXQtMTkgNDV2MTI4cTAgMjYgMTkgNDV0NDUgMTloMTI4MHEyNiAwIDQ1IC0xOXQxOSAtNDV6TTE3OTIgOTYwdi0xMjhxMCAtMjYgLTE5IC00NQp0LTQ1IC0xOWgtMTUzNnEtMjYgMCAtNDUgMTl0LTE5IDQ1djEyOHEwIDI2IDE5IDQ1dDQ1IDE5aDE1MzZxMjYgMCA0NSAtMTl0MTkgLTQ1ek0xNzkyIDEzNDR2LTEyOHEwIC0yNiAtMTkgLTQ1dC00NSAtMTloLTExNTJxLTI2IDAgLTQ1IDE5dC0xOSA0NXYxMjhxMCAyNiAxOSA0NXQ0NSAxOWgxMTUycTI2IDAgNDUgLTE5dDE5IC00NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYWxpZ25fanVzdGlmeSIgdW5pY29kZT0iJiN4ZjAzOTsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE3OTIgMTkydi0xMjhxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0xNjY0cS0yNiAwIC00NSAxOXQtMTkgNDV2MTI4cTAgMjYgMTkgNDV0NDUgMTloMTY2NHEyNiAwIDQ1IC0xOXQxOSAtNDV6TTE3OTIgNTc2di0xMjhxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0xNjY0cS0yNiAwIC00NSAxOXQtMTkgNDV2MTI4cTAgMjYgMTkgNDV0NDUgMTloMTY2NHEyNiAwIDQ1IC0xOXQxOSAtNDV6TTE3OTIgOTYwdi0xMjhxMCAtMjYgLTE5IC00NQp0LTQ1IC0xOWgtMTY2NHEtMjYgMCAtNDUgMTl0LTE5IDQ1djEyOHEwIDI2IDE5IDQ1dDQ1IDE5aDE2NjRxMjYgMCA0NSAtMTl0MTkgLTQ1ek0xNzkyIDEzNDR2LTEyOHEwIC0yNiAtMTkgLTQ1dC00NSAtMTloLTE2NjRxLTI2IDAgLTQ1IDE5dC0xOSA0NXYxMjhxMCAyNiAxOSA0NXQ0NSAxOWgxNjY0cTI2IDAgNDUgLTE5dDE5IC00NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibGlzdCIgdW5pY29kZT0iJiN4ZjAzYTsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTI1NiAyMjR2LTE5MnEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTE5MnEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djE5MnEwIDEzIDkuNSAyMi41dDIyLjUgOS41aDE5MnExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6TTI1NiA2MDh2LTE5MnEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTE5MnEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djE5MnEwIDEzIDkuNSAyMi41dDIyLjUgOS41aDE5MnExMyAwIDIyLjUgLTkuNQp0OS41IC0yMi41ek0yNTYgOTkydi0xOTJxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC0xOTJxLTEzIDAgLTIyLjUgOS41dC05LjUgMjIuNXYxOTJxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWgxOTJxMTMgMCAyMi41IC05LjV0OS41IC0yMi41ek0xNzkyIDIyNHYtMTkycTAgLTEzIC05LjUgLTIyLjV0LTIyLjUgLTkuNWgtMTM0NHEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djE5MnEwIDEzIDkuNSAyMi41dDIyLjUgOS41aDEzNDQKcTEzIDAgMjIuNSAtOS41dDkuNSAtMjIuNXpNMjU2IDEzNzZ2LTE5MnEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTE5MnEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djE5MnEwIDEzIDkuNSAyMi41dDIyLjUgOS41aDE5MnExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6TTE3OTIgNjA4di0xOTJxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC0xMzQ0cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2MTkycTAgMTMgOS41IDIyLjUKdDIyLjUgOS41aDEzNDRxMTMgMCAyMi41IC05LjV0OS41IC0yMi41ek0xNzkyIDk5MnYtMTkycTAgLTEzIC05LjUgLTIyLjV0LTIyLjUgLTkuNWgtMTM0NHEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djE5MnEwIDEzIDkuNSAyMi41dDIyLjUgOS41aDEzNDRxMTMgMCAyMi41IC05LjV0OS41IC0yMi41ek0xNzkyIDEzNzZ2LTE5MnEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTEzNDRxLTEzIDAgLTIyLjUgOS41dC05LjUgMjIuNXYxOTIKcTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoMTM0NHExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImluZGVudF9sZWZ0IiB1bmljb2RlPSImI3hmMDNiOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMzg0IDk5MnYtNTc2cTAgLTEzIC05LjUgLTIyLjV0LTIyLjUgLTkuNXEtMTQgMCAtMjMgOWwtMjg4IDI4OHEtOSA5IC05IDIzdDkgMjNsMjg4IDI4OHE5IDkgMjMgOXExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6TTE3OTIgMjI0di0xOTJxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC0xNzI4cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2MTkycTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoMTcyOHExMyAwIDIyLjUgLTkuNQp0OS41IC0yMi41ek0xNzkyIDYwOHYtMTkycTAgLTEzIC05LjUgLTIyLjV0LTIyLjUgLTkuNWgtMTA4OHEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djE5MnEwIDEzIDkuNSAyMi41dDIyLjUgOS41aDEwODhxMTMgMCAyMi41IC05LjV0OS41IC0yMi41ek0xNzkyIDk5MnYtMTkycTAgLTEzIC05LjUgLTIyLjV0LTIyLjUgLTkuNWgtMTA4OHEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djE5MnEwIDEzIDkuNSAyMi41dDIyLjUgOS41aDEwODgKcTEzIDAgMjIuNSAtOS41dDkuNSAtMjIuNXpNMTc5MiAxMzc2di0xOTJxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC0xNzI4cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2MTkycTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoMTcyOHExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImluZGVudF9yaWdodCIgdW5pY29kZT0iJiN4ZjAzYzsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTM1MiA3MDRxMCAtMTQgLTkgLTIzbC0yODggLTI4OHEtOSAtOSAtMjMgLTlxLTEzIDAgLTIyLjUgOS41dC05LjUgMjIuNXY1NzZxMCAxMyA5LjUgMjIuNXQyMi41IDkuNXExNCAwIDIzIC05bDI4OCAtMjg4cTkgLTkgOSAtMjN6TTE3OTIgMjI0di0xOTJxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC0xNzI4cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2MTkycTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoMTcyOHExMyAwIDIyLjUgLTkuNQp0OS41IC0yMi41ek0xNzkyIDYwOHYtMTkycTAgLTEzIC05LjUgLTIyLjV0LTIyLjUgLTkuNWgtMTA4OHEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djE5MnEwIDEzIDkuNSAyMi41dDIyLjUgOS41aDEwODhxMTMgMCAyMi41IC05LjV0OS41IC0yMi41ek0xNzkyIDk5MnYtMTkycTAgLTEzIC05LjUgLTIyLjV0LTIyLjUgLTkuNWgtMTA4OHEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djE5MnEwIDEzIDkuNSAyMi41dDIyLjUgOS41aDEwODgKcTEzIDAgMjIuNSAtOS41dDkuNSAtMjIuNXpNMTc5MiAxMzc2di0xOTJxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC0xNzI4cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2MTkycTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoMTcyOHExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImZhY2V0aW1lX3ZpZGVvIiB1bmljb2RlPSImI3hmMDNkOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTc5MiAxMTg0di0xMDg4cTAgLTQyIC0zOSAtNTlxLTEzIC01IC0yNSAtNXEtMjcgMCAtNDUgMTlsLTQwMyA0MDN2LTE2NnEwIC0xMTkgLTg0LjUgLTIwMy41dC0yMDMuNSAtODQuNWgtNzA0cS0xMTkgMCAtMjAzLjUgODQuNXQtODQuNSAyMDMuNXY3MDRxMCAxMTkgODQuNSAyMDMuNXQyMDMuNSA4NC41aDcwNHExMTkgMCAyMDMuNSAtODQuNXQ4NC41IC0yMDMuNXYtMTY1bDQwMyA0MDJxMTggMTkgNDUgMTlxMTIgMCAyNSAtNQpxMzkgLTE3IDM5IC01OXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icGljdHVyZSIgdW5pY29kZT0iJiN4ZjAzZTsiIGhvcml6LWFkdi14PSIxOTIwIiAKZD0iTTY0MCA5NjBxMCAtODAgLTU2IC0xMzZ0LTEzNiAtNTZ0LTEzNiA1NnQtNTYgMTM2dDU2IDEzNnQxMzYgNTZ0MTM2IC01NnQ1NiAtMTM2ek0xNjY0IDU3NnYtNDQ4aC0xNDA4djE5MmwzMjAgMzIwbDE2MCAtMTYwbDUxMiA1MTJ6TTE3NjAgMTI4MGgtMTYwMHEtMTMgMCAtMjIuNSAtOS41dC05LjUgLTIyLjV2LTEyMTZxMCAtMTMgOS41IC0yMi41dDIyLjUgLTkuNWgxNjAwcTEzIDAgMjIuNSA5LjV0OS41IDIyLjV2MTIxNgpxMCAxMyAtOS41IDIyLjV0LTIyLjUgOS41ek0xOTIwIDEyNDh2LTEyMTZxMCAtNjYgLTQ3IC0xMTN0LTExMyAtNDdoLTE2MDBxLTY2IDAgLTExMyA0N3QtNDcgMTEzdjEyMTZxMCA2NiA0NyAxMTN0MTEzIDQ3aDE2MDBxNjYgMCAxMTMgLTQ3dDQ3IC0xMTN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InBlbmNpbCIgdW5pY29kZT0iJiN4ZjA0MDsiIApkPSJNMzYzIDBsOTEgOTFsLTIzNSAyMzVsLTkxIC05MXYtMTA3aDEyOHYtMTI4aDEwN3pNODg2IDkyOHEwIDIyIC0yMiAyMnEtMTAgMCAtMTcgLTdsLTU0MiAtNTQycS03IC03IC03IC0xN3EwIC0yMiAyMiAtMjJxMTAgMCAxNyA3bDU0MiA1NDJxNyA3IDcgMTd6TTgzMiAxMTIwbDQxNiAtNDE2bC04MzIgLTgzMmgtNDE2djQxNnpNMTUxNSAxMDI0cTAgLTUzIC0zNyAtOTBsLTE2NiAtMTY2bC00MTYgNDE2bDE2NiAxNjVxMzYgMzggOTAgMzgKcTUzIDAgOTEgLTM4bDIzNSAtMjM0cTM3IC0zOSAzNyAtOTF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im1hcF9tYXJrZXIiIHVuaWNvZGU9IiYjeGYwNDE7IiBob3Jpei1hZHYteD0iMTAyNCIgCmQ9Ik03NjggODk2cTAgMTA2IC03NSAxODF0LTE4MSA3NXQtMTgxIC03NXQtNzUgLTE4MXQ3NSAtMTgxdDE4MSAtNzV0MTgxIDc1dDc1IDE4MXpNMTAyNCA4OTZxMCAtMTA5IC0zMyAtMTc5bC0zNjQgLTc3NHEtMTYgLTMzIC00Ny41IC01MnQtNjcuNSAtMTl0LTY3LjUgMTl0LTQ2LjUgNTJsLTM2NSA3NzRxLTMzIDcwIC0zMyAxNzlxMCAyMTIgMTUwIDM2MnQzNjIgMTUwdDM2MiAtMTUwdDE1MCAtMzYyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhZGp1c3QiIHVuaWNvZGU9IiYjeGYwNDI7IiAKZD0iTTc2OCA5NnYxMDg4cS0xNDggMCAtMjczIC03M3QtMTk4IC0xOTh0LTczIC0yNzN0NzMgLTI3M3QxOTggLTE5OHQyNzMgLTczek0xNTM2IDY0MHEwIC0yMDkgLTEwMyAtMzg1LjV0LTI3OS41IC0yNzkuNXQtMzg1LjUgLTEwM3QtMzg1LjUgMTAzdC0yNzkuNSAyNzkuNXQtMTAzIDM4NS41dDEwMyAzODUuNXQyNzkuNSAyNzkuNXQzODUuNSAxMDN0Mzg1LjUgLTEwM3QyNzkuNSAtMjc5LjV0MTAzIC0zODUuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idGludCIgdW5pY29kZT0iJiN4ZjA0MzsiIGhvcml6LWFkdi14PSIxMDI0IiAKZD0iTTUxMiAzODRxMCAzNiAtMjAgNjlxLTEgMSAtMTUuNSAyMi41dC0yNS41IDM4dC0yNSA0NHQtMjEgNTAuNXEtNCAxNiAtMjEgMTZ0LTIxIC0xNnEtNyAtMjMgLTIxIC01MC41dC0yNSAtNDR0LTI1LjUgLTM4dC0xNS41IC0yMi41cS0yMCAtMzMgLTIwIC02OXEwIC01MyAzNy41IC05MC41dDkwLjUgLTM3LjV0OTAuNSAzNy41dDM3LjUgOTAuNXpNMTAyNCA1MTJxMCAtMjEyIC0xNTAgLTM2MnQtMzYyIC0xNTB0LTM2MiAxNTB0LTE1MCAzNjIKcTAgMTQ1IDgxIDI3NXE2IDkgNjIuNSA5MC41dDEwMSAxNTF0OTkuNSAxNzh0ODMgMjAxLjVxOSAzMCAzNCA0N3Q1MSAxN3Q1MS41IC0xN3QzMy41IC00N3EyOCAtOTMgODMgLTIwMS41dDk5LjUgLTE3OHQxMDEgLTE1MXQ2Mi41IC05MC41cTgxIC0xMjcgODEgLTI3NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZWRpdCIgdW5pY29kZT0iJiN4ZjA0NDsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTg4OCAzNTJsMTE2IDExNmwtMTUyIDE1MmwtMTE2IC0xMTZ2LTU2aDk2di05Nmg1NnpNMTMyOCAxMDcycS0xNiAxNiAtMzMgLTFsLTM1MCAtMzUwcS0xNyAtMTcgLTEgLTMzdDMzIDFsMzUwIDM1MHExNyAxNyAxIDMzek0xNDA4IDQ3OHYtMTkwcTAgLTExOSAtODQuNSAtMjAzLjV0LTIwMy41IC04NC41aC04MzJxLTExOSAwIC0yMDMuNSA4NC41dC04NC41IDIwMy41djgzMnEwIDExOSA4NC41IDIwMy41dDIwMy41IDg0LjVoODMyCnE2MyAwIDExNyAtMjVxMTUgLTcgMTggLTIzcTMgLTE3IC05IC0yOWwtNDkgLTQ5cS0xNCAtMTQgLTMyIC04cS0yMyA2IC00NSA2aC04MzJxLTY2IDAgLTExMyAtNDd0LTQ3IC0xMTN2LTgzMnEwIC02NiA0NyAtMTEzdDExMyAtNDdoODMycTY2IDAgMTEzIDQ3dDQ3IDExM3YxMjZxMCAxMyA5IDIybDY0IDY0cTE1IDE1IDM1IDd0MjAgLTI5ek0xMzEyIDEyMTZsMjg4IC0yODhsLTY3MiAtNjcyaC0yODh2Mjg4ek0xNzU2IDEwODRsLTkyIC05MgpsLTI4OCAyODhsOTIgOTJxMjggMjggNjggMjh0NjggLTI4bDE1MiAtMTUycTI4IC0yOCAyOCAtNjh0LTI4IC02OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ic2hhcmUiIHVuaWNvZGU9IiYjeGYwNDU7IiBob3Jpei1hZHYteD0iMTY2NCIgCmQ9Ik0xNDA4IDU0N3YtMjU5cTAgLTExOSAtODQuNSAtMjAzLjV0LTIwMy41IC04NC41aC04MzJxLTExOSAwIC0yMDMuNSA4NC41dC04NC41IDIwMy41djgzMnEwIDExOSA4NC41IDIwMy41dDIwMy41IDg0LjVoMjU1djBxMTMgMCAyMi41IC05LjV0OS41IC0yMi41cTAgLTI3IC0yNiAtMzJxLTc3IC0yNiAtMTMzIC02MHEtMTAgLTQgLTE2IC00aC0xMTJxLTY2IDAgLTExMyAtNDd0LTQ3IC0xMTN2LTgzMnEwIC02NiA0NyAtMTEzdDExMyAtNDdoODMyCnE2NiAwIDExMyA0N3Q0NyAxMTN2MjE0cTAgMTkgMTggMjlxMjggMTMgNTQgMzdxMTYgMTYgMzUgOHEyMSAtOSAyMSAtMjl6TTE2NDUgMTA0M2wtMzg0IC0zODRxLTE4IC0xOSAtNDUgLTE5cS0xMiAwIC0yNSA1cS0zOSAxNyAtMzkgNTl2MTkyaC0xNjBxLTMyMyAwIC00MzggLTEzMXEtMTE5IC0xMzcgLTc0IC00NzNxMyAtMjMgLTIwIC0zNHEtOCAtMiAtMTIgLTJxLTE2IDAgLTI2IDEzcS0xMCAxNCAtMjEgMzF0LTM5LjUgNjguNXQtNDkuNSA5OS41CnQtMzguNSAxMTR0LTE3LjUgMTIycTAgNDkgMy41IDkxdDE0IDkwdDI4IDg4dDQ3IDgxLjV0NjguNSA3NHQ5NC41IDYxLjV0MTI0LjUgNDguNXQxNTkuNSAzMC41dDE5Ni41IDExaDE2MHYxOTJxMCA0MiAzOSA1OXExMyA1IDI1IDVxMjYgMCA0NSAtMTlsMzg0IC0zODRxMTkgLTE5IDE5IC00NXQtMTkgLTQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjaGVjayIgdW5pY29kZT0iJiN4ZjA0NjsiIGhvcml6LWFkdi14PSIxNjY0IiAKZD0iTTE0MDggNjA2di0zMThxMCAtMTE5IC04NC41IC0yMDMuNXQtMjAzLjUgLTg0LjVoLTgzMnEtMTE5IDAgLTIwMy41IDg0LjV0LTg0LjUgMjAzLjV2ODMycTAgMTE5IDg0LjUgMjAzLjV0MjAzLjUgODQuNWg4MzJxNjMgMCAxMTcgLTI1cTE1IC03IDE4IC0yM3EzIC0xNyAtOSAtMjlsLTQ5IC00OXEtMTAgLTEwIC0yMyAtMTBxLTMgMCAtOSAycS0yMyA2IC00NSA2aC04MzJxLTY2IDAgLTExMyAtNDd0LTQ3IC0xMTN2LTgzMgpxMCAtNjYgNDcgLTExM3QxMTMgLTQ3aDgzMnE2NiAwIDExMyA0N3Q0NyAxMTN2MjU0cTAgMTMgOSAyMmw2NCA2NHExMCAxMCAyMyAxMHE2IDAgMTIgLTNxMjAgLTggMjAgLTI5ek0xNjM5IDEwOTVsLTgxNCAtODE0cS0yNCAtMjQgLTU3IC0yNHQtNTcgMjRsLTQzMCA0MzBxLTI0IDI0IC0yNCA1N3QyNCA1N2wxMTAgMTEwcTI0IDI0IDU3IDI0dDU3IC0yNGwyNjMgLTI2M2w2NDcgNjQ3cTI0IDI0IDU3IDI0dDU3IC0yNGwxMTAgLTExMApxMjQgLTI0IDI0IC01N3QtMjQgLTU3eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJtb3ZlIiB1bmljb2RlPSImI3hmMDQ3OyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTc5MiA2NDBxMCAtMjYgLTE5IC00NWwtMjU2IC0yNTZxLTE5IC0xOSAtNDUgLTE5dC00NSAxOXQtMTkgNDV2MTI4aC0zODR2LTM4NGgxMjhxMjYgMCA0NSAtMTl0MTkgLTQ1dC0xOSAtNDVsLTI1NiAtMjU2cS0xOSAtMTkgLTQ1IC0xOXQtNDUgMTlsLTI1NiAyNTZxLTE5IDE5IC0xOSA0NXQxOSA0NXQ0NSAxOWgxMjh2Mzg0aC0zODR2LTEyOHEwIC0yNiAtMTkgLTQ1dC00NSAtMTl0LTQ1IDE5bC0yNTYgMjU2cS0xOSAxOSAtMTkgNDUKdDE5IDQ1bDI1NiAyNTZxMTkgMTkgNDUgMTl0NDUgLTE5dDE5IC00NXYtMTI4aDM4NHYzODRoLTEyOHEtMjYgMCAtNDUgMTl0LTE5IDQ1dDE5IDQ1bDI1NiAyNTZxMTkgMTkgNDUgMTl0NDUgLTE5bDI1NiAtMjU2cTE5IC0xOSAxOSAtNDV0LTE5IC00NXQtNDUgLTE5aC0xMjh2LTM4NGgzODR2MTI4cTAgMjYgMTkgNDV0NDUgMTl0NDUgLTE5bDI1NiAtMjU2cTE5IC0xOSAxOSAtNDV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InN0ZXBfYmFja3dhcmQiIHVuaWNvZGU9IiYjeGYwNDg7IiBob3Jpei1hZHYteD0iMTAyNCIgCmQ9Ik05NzkgMTM5NXExOSAxOSAzMiAxM3QxMyAtMzJ2LTE0NzJxMCAtMjYgLTEzIC0zMnQtMzIgMTNsLTcxMCA3MTBxLTkgOSAtMTMgMTl2LTY3OHEwIC0yNiAtMTkgLTQ1dC00NSAtMTloLTEyOHEtMjYgMCAtNDUgMTl0LTE5IDQ1djE0MDhxMCAyNiAxOSA0NXQ0NSAxOWgxMjhxMjYgMCA0NSAtMTl0MTkgLTQ1di02NzhxNCAxMCAxMyAxOXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZmFzdF9iYWNrd2FyZCIgdW5pY29kZT0iJiN4ZjA0OTsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE3NDcgMTM5NXExOSAxOSAzMiAxM3QxMyAtMzJ2LTE0NzJxMCAtMjYgLTEzIC0zMnQtMzIgMTNsLTcxMCA3MTBxLTkgOSAtMTMgMTl2LTcxMHEwIC0yNiAtMTMgLTMydC0zMiAxM2wtNzEwIDcxMHEtOSA5IC0xMyAxOXYtNjc4cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtMTI4cS0yNiAwIC00NSAxOXQtMTkgNDV2MTQwOHEwIDI2IDE5IDQ1dDQ1IDE5aDEyOHEyNiAwIDQ1IC0xOXQxOSAtNDV2LTY3OHE0IDEwIDEzIDE5bDcxMCA3MTAKcTE5IDE5IDMyIDEzdDEzIC0zMnYtNzEwcTQgMTAgMTMgMTl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImJhY2t3YXJkIiB1bmljb2RlPSImI3hmMDRhOyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNMTYxOSAxMzk1cTE5IDE5IDMyIDEzdDEzIC0zMnYtMTQ3MnEwIC0yNiAtMTMgLTMydC0zMiAxM2wtNzEwIDcxMHEtOSA5IC0xMyAxOXYtNzEwcTAgLTI2IC0xMyAtMzJ0LTMyIDEzbC03MTAgNzEwcS0xOSAxOSAtMTkgNDV0MTkgNDVsNzEwIDcxMHExOSAxOSAzMiAxM3QxMyAtMzJ2LTcxMHE0IDEwIDEzIDE5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJwbGF5IiB1bmljb2RlPSImI3hmMDRiOyIgaG9yaXotYWR2LXg9IjE0MDgiIApkPSJNMTM4NCA2MDlsLTEzMjggLTczOHEtMjMgLTEzIC0zOS41IC0zdC0xNi41IDM2djE0NzJxMCAyNiAxNi41IDM2dDM5LjUgLTNsMTMyOCAtNzM4cTIzIC0xMyAyMyAtMzF0LTIzIC0zMXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icGF1c2UiIHVuaWNvZGU9IiYjeGYwNGM7IiAKZD0iTTE1MzYgMTM0NHYtMTQwOHEwIC0yNiAtMTkgLTQ1dC00NSAtMTloLTUxMnEtMjYgMCAtNDUgMTl0LTE5IDQ1djE0MDhxMCAyNiAxOSA0NXQ0NSAxOWg1MTJxMjYgMCA0NSAtMTl0MTkgLTQ1ek02NDAgMTM0NHYtMTQwOHEwIC0yNiAtMTkgLTQ1dC00NSAtMTloLTUxMnEtMjYgMCAtNDUgMTl0LTE5IDQ1djE0MDhxMCAyNiAxOSA0NXQ0NSAxOWg1MTJxMjYgMCA0NSAtMTl0MTkgLTQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzdG9wIiB1bmljb2RlPSImI3hmMDRkOyIgCmQ9Ik0xNTM2IDEzNDR2LTE0MDhxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0xNDA4cS0yNiAwIC00NSAxOXQtMTkgNDV2MTQwOHEwIDI2IDE5IDQ1dDQ1IDE5aDE0MDhxMjYgMCA0NSAtMTl0MTkgLTQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJmb3J3YXJkIiB1bmljb2RlPSImI3hmMDRlOyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNNDUgLTExNXEtMTkgLTE5IC0zMiAtMTN0LTEzIDMydjE0NzJxMCAyNiAxMyAzMnQzMiAtMTNsNzEwIC03MTBxOSAtOSAxMyAtMTl2NzEwcTAgMjYgMTMgMzJ0MzIgLTEzbDcxMCAtNzEwcTE5IC0xOSAxOSAtNDV0LTE5IC00NWwtNzEwIC03MTBxLTE5IC0xOSAtMzIgLTEzdC0xMyAzMnY3MTBxLTQgLTEwIC0xMyAtMTl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImZhc3RfZm9yd2FyZCIgdW5pY29kZT0iJiN4ZjA1MDsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTQ1IC0xMTVxLTE5IC0xOSAtMzIgLTEzdC0xMyAzMnYxNDcycTAgMjYgMTMgMzJ0MzIgLTEzbDcxMCAtNzEwcTkgLTkgMTMgLTE5djcxMHEwIDI2IDEzIDMydDMyIC0xM2w3MTAgLTcxMHE5IC05IDEzIC0xOXY2NzhxMCAyNiAxOSA0NXQ0NSAxOWgxMjhxMjYgMCA0NSAtMTl0MTkgLTQ1di0xNDA4cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtMTI4cS0yNiAwIC00NSAxOXQtMTkgNDV2Njc4cS00IC0xMCAtMTMgLTE5bC03MTAgLTcxMApxLTE5IC0xOSAtMzIgLTEzdC0xMyAzMnY3MTBxLTQgLTEwIC0xMyAtMTl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InN0ZXBfZm9yd2FyZCIgdW5pY29kZT0iJiN4ZjA1MTsiIGhvcml6LWFkdi14PSIxMDI0IiAKZD0iTTQ1IC0xMTVxLTE5IC0xOSAtMzIgLTEzdC0xMyAzMnYxNDcycTAgMjYgMTMgMzJ0MzIgLTEzbDcxMCAtNzEwcTkgLTkgMTMgLTE5djY3OHEwIDI2IDE5IDQ1dDQ1IDE5aDEyOHEyNiAwIDQ1IC0xOXQxOSAtNDV2LTE0MDhxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0xMjhxLTI2IDAgLTQ1IDE5dC0xOSA0NXY2NzhxLTQgLTEwIC0xMyAtMTl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImVqZWN0IiB1bmljb2RlPSImI3hmMDUyOyIgaG9yaXotYWR2LXg9IjE1MzgiIApkPSJNMTQgNTU3bDcxMCA3MTBxMTkgMTkgNDUgMTl0NDUgLTE5bDcxMCAtNzEwcTE5IC0xOSAxMyAtMzJ0LTMyIC0xM2gtMTQ3MnEtMjYgMCAtMzIgMTN0MTMgMzJ6TTE0NzMgMGgtMTQwOHEtMjYgMCAtNDUgMTl0LTE5IDQ1djI1NnEwIDI2IDE5IDQ1dDQ1IDE5aDE0MDhxMjYgMCA0NSAtMTl0MTkgLTQ1di0yNTZxMCAtMjYgLTE5IC00NXQtNDUgLTE5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjaGV2cm9uX2xlZnQiIHVuaWNvZGU9IiYjeGYwNTM7IiBob3Jpei1hZHYteD0iMTI4MCIgCmQ9Ik0xMTcxIDEyMzVsLTUzMSAtNTMxbDUzMSAtNTMxcTE5IC0xOSAxOSAtNDV0LTE5IC00NWwtMTY2IC0xNjZxLTE5IC0xOSAtNDUgLTE5dC00NSAxOWwtNzQyIDc0MnEtMTkgMTkgLTE5IDQ1dDE5IDQ1bDc0MiA3NDJxMTkgMTkgNDUgMTl0NDUgLTE5bDE2NiAtMTY2cTE5IC0xOSAxOSAtNDV0LTE5IC00NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY2hldnJvbl9yaWdodCIgdW5pY29kZT0iJiN4ZjA1NDsiIGhvcml6LWFkdi14PSIxMjgwIiAKZD0iTTExMDcgNjU5bC03NDIgLTc0MnEtMTkgLTE5IC00NSAtMTl0LTQ1IDE5bC0xNjYgMTY2cS0xOSAxOSAtMTkgNDV0MTkgNDVsNTMxIDUzMWwtNTMxIDUzMXEtMTkgMTkgLTE5IDQ1dDE5IDQ1bDE2NiAxNjZxMTkgMTkgNDUgMTl0NDUgLTE5bDc0MiAtNzQycTE5IC0xOSAxOSAtNDV0LTE5IC00NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icGx1c19zaWduIiB1bmljb2RlPSImI3hmMDU1OyIgCmQ9Ik0xMjE2IDU3NnYxMjhxMCAyNiAtMTkgNDV0LTQ1IDE5aC0yNTZ2MjU2cTAgMjYgLTE5IDQ1dC00NSAxOWgtMTI4cS0yNiAwIC00NSAtMTl0LTE5IC00NXYtMjU2aC0yNTZxLTI2IDAgLTQ1IC0xOXQtMTkgLTQ1di0xMjhxMCAtMjYgMTkgLTQ1dDQ1IC0xOWgyNTZ2LTI1NnEwIC0yNiAxOSAtNDV0NDUgLTE5aDEyOHEyNiAwIDQ1IDE5dDE5IDQ1djI1NmgyNTZxMjYgMCA0NSAxOXQxOSA0NXpNMTUzNiA2NDBxMCAtMjA5IC0xMDMgLTM4NS41CnQtMjc5LjUgLTI3OS41dC0zODUuNSAtMTAzdC0zODUuNSAxMDN0LTI3OS41IDI3OS41dC0xMDMgMzg1LjV0MTAzIDM4NS41dDI3OS41IDI3OS41dDM4NS41IDEwM3QzODUuNSAtMTAzdDI3OS41IC0yNzkuNXQxMDMgLTM4NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJtaW51c19zaWduIiB1bmljb2RlPSImI3hmMDU2OyIgCmQ9Ik0xMjE2IDU3NnYxMjhxMCAyNiAtMTkgNDV0LTQ1IDE5aC03NjhxLTI2IDAgLTQ1IC0xOXQtMTkgLTQ1di0xMjhxMCAtMjYgMTkgLTQ1dDQ1IC0xOWg3NjhxMjYgMCA0NSAxOXQxOSA0NXpNMTUzNiA2NDBxMCAtMjA5IC0xMDMgLTM4NS41dC0yNzkuNSAtMjc5LjV0LTM4NS41IC0xMDN0LTM4NS41IDEwM3QtMjc5LjUgMjc5LjV0LTEwMyAzODUuNXQxMDMgMzg1LjV0Mjc5LjUgMjc5LjV0Mzg1LjUgMTAzdDM4NS41IC0xMDN0Mjc5LjUgLTI3OS41CnQxMDMgLTM4NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJyZW1vdmVfc2lnbiIgdW5pY29kZT0iJiN4ZjA1NzsiIApkPSJNMTE0OSA0MTRxMCAyNiAtMTkgNDVsLTE4MSAxODFsMTgxIDE4MXExOSAxOSAxOSA0NXEwIDI3IC0xOSA0NmwtOTAgOTBxLTE5IDE5IC00NiAxOXEtMjYgMCAtNDUgLTE5bC0xODEgLTE4MWwtMTgxIDE4MXEtMTkgMTkgLTQ1IDE5cS0yNyAwIC00NiAtMTlsLTkwIC05MHEtMTkgLTE5IC0xOSAtNDZxMCAtMjYgMTkgLTQ1bDE4MSAtMTgxbC0xODEgLTE4MXEtMTkgLTE5IC0xOSAtNDVxMCAtMjcgMTkgLTQ2bDkwIC05MHExOSAtMTkgNDYgLTE5CnEyNiAwIDQ1IDE5bDE4MSAxODFsMTgxIC0xODFxMTkgLTE5IDQ1IC0xOXEyNyAwIDQ2IDE5bDkwIDkwcTE5IDE5IDE5IDQ2ek0xNTM2IDY0MHEwIC0yMDkgLTEwMyAtMzg1LjV0LTI3OS41IC0yNzkuNXQtMzg1LjUgLTEwM3QtMzg1LjUgMTAzdC0yNzkuNSAyNzkuNXQtMTAzIDM4NS41dDEwMyAzODUuNXQyNzkuNSAyNzkuNXQzODUuNSAxMDN0Mzg1LjUgLTEwM3QyNzkuNSAtMjc5LjV0MTAzIC0zODUuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ib2tfc2lnbiIgdW5pY29kZT0iJiN4ZjA1ODsiIApkPSJNMTI4NCA4MDJxMCAyOCAtMTggNDZsLTkxIDkwcS0xOSAxOSAtNDUgMTl0LTQ1IC0xOWwtNDA4IC00MDdsLTIyNiAyMjZxLTE5IDE5IC00NSAxOXQtNDUgLTE5bC05MSAtOTBxLTE4IC0xOCAtMTggLTQ2cTAgLTI3IDE4IC00NWwzNjIgLTM2MnExOSAtMTkgNDUgLTE5cTI3IDAgNDYgMTlsNTQzIDU0M3ExOCAxOCAxOCA0NXpNMTUzNiA2NDBxMCAtMjA5IC0xMDMgLTM4NS41dC0yNzkuNSAtMjc5LjV0LTM4NS41IC0xMDN0LTM4NS41IDEwMwp0LTI3OS41IDI3OS41dC0xMDMgMzg1LjV0MTAzIDM4NS41dDI3OS41IDI3OS41dDM4NS41IDEwM3QzODUuNSAtMTAzdDI3OS41IC0yNzkuNXQxMDMgLTM4NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJxdWVzdGlvbl9zaWduIiB1bmljb2RlPSImI3hmMDU5OyIgCmQ9Ik04OTYgMTYwdjE5MnEwIDE0IC05IDIzdC0yMyA5aC0xOTJxLTE0IDAgLTIzIC05dC05IC0yM3YtMTkycTAgLTE0IDkgLTIzdDIzIC05aDE5MnExNCAwIDIzIDl0OSAyM3pNMTE1MiA4MzJxMCA4OCAtNTUuNSAxNjN0LTEzOC41IDExNnQtMTcwIDQxcS0yNDMgMCAtMzcxIC0yMTNxLTE1IC0yNCA4IC00MmwxMzIgLTEwMHE3IC02IDE5IC02cTE2IDAgMjUgMTJxNTMgNjggODYgOTJxMzQgMjQgODYgMjRxNDggMCA4NS41IC0yNnQzNy41IC01OQpxMCAtMzggLTIwIC02MXQtNjggLTQ1cS02MyAtMjggLTExNS41IC04Ni41dC01Mi41IC0xMjUuNXYtMzZxMCAtMTQgOSAtMjN0MjMgLTloMTkycTE0IDAgMjMgOXQ5IDIzcTAgMTkgMjEuNSA0OS41dDU0LjUgNDkuNXEzMiAxOCA0OSAyOC41dDQ2IDM1dDQ0LjUgNDh0MjggNjAuNXQxMi41IDgxek0xNTM2IDY0MHEwIC0yMDkgLTEwMyAtMzg1LjV0LTI3OS41IC0yNzkuNXQtMzg1LjUgLTEwM3QtMzg1LjUgMTAzdC0yNzkuNSAyNzkuNQp0LTEwMyAzODUuNXQxMDMgMzg1LjV0Mjc5LjUgMjc5LjV0Mzg1LjUgMTAzdDM4NS41IC0xMDN0Mjc5LjUgLTI3OS41dDEwMyAtMzg1LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImluZm9fc2lnbiIgdW5pY29kZT0iJiN4ZjA1YTsiIApkPSJNMTAyNCAxNjB2MTYwcTAgMTQgLTkgMjN0LTIzIDloLTk2djUxMnEwIDE0IC05IDIzdC0yMyA5aC0zMjBxLTE0IDAgLTIzIC05dC05IC0yM3YtMTYwcTAgLTE0IDkgLTIzdDIzIC05aDk2di0zMjBoLTk2cS0xNCAwIC0yMyAtOXQtOSAtMjN2LTE2MHEwIC0xNCA5IC0yM3QyMyAtOWg0NDhxMTQgMCAyMyA5dDkgMjN6TTg5NiAxMDU2djE2MHEwIDE0IC05IDIzdC0yMyA5aC0xOTJxLTE0IDAgLTIzIC05dC05IC0yM3YtMTYwcTAgLTE0IDkgLTIzCnQyMyAtOWgxOTJxMTQgMCAyMyA5dDkgMjN6TTE1MzYgNjQwcTAgLTIwOSAtMTAzIC0zODUuNXQtMjc5LjUgLTI3OS41dC0zODUuNSAtMTAzdC0zODUuNSAxMDN0LTI3OS41IDI3OS41dC0xMDMgMzg1LjV0MTAzIDM4NS41dDI3OS41IDI3OS41dDM4NS41IDEwM3QzODUuNSAtMTAzdDI3OS41IC0yNzkuNXQxMDMgLTM4NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzY3JlZW5zaG90IiB1bmljb2RlPSImI3hmMDViOyIgCmQ9Ik0xMTk3IDUxMmgtMTA5cS0yNiAwIC00NSAxOXQtMTkgNDV2MTI4cTAgMjYgMTkgNDV0NDUgMTloMTA5cS0zMiAxMDggLTExMi41IDE4OC41dC0xODguNSAxMTIuNXYtMTA5cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtMTI4cS0yNiAwIC00NSAxOXQtMTkgNDV2MTA5cS0xMDggLTMyIC0xODguNSAtMTEyLjV0LTExMi41IC0xODguNWgxMDlxMjYgMCA0NSAtMTl0MTkgLTQ1di0xMjhxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0xMDkKcTMyIC0xMDggMTEyLjUgLTE4OC41dDE4OC41IC0xMTIuNXYxMDlxMCAyNiAxOSA0NXQ0NSAxOWgxMjhxMjYgMCA0NSAtMTl0MTkgLTQ1di0xMDlxMTA4IDMyIDE4OC41IDExMi41dDExMi41IDE4OC41ek0xNTM2IDcwNHYtMTI4cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtMTQzcS0zNyAtMTYxIC0xNTQuNSAtMjc4LjV0LTI3OC41IC0xNTQuNXYtMTQzcTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtMTI4cS0yNiAwIC00NSAxOXQtMTkgNDV2MTQzCnEtMTYxIDM3IC0yNzguNSAxNTQuNXQtMTU0LjUgMjc4LjVoLTE0M3EtMjYgMCAtNDUgMTl0LTE5IDQ1djEyOHEwIDI2IDE5IDQ1dDQ1IDE5aDE0M3EzNyAxNjEgMTU0LjUgMjc4LjV0Mjc4LjUgMTU0LjV2MTQzcTAgMjYgMTkgNDV0NDUgMTloMTI4cTI2IDAgNDUgLTE5dDE5IC00NXYtMTQzcTE2MSAtMzcgMjc4LjUgLTE1NC41dDE1NC41IC0yNzguNWgxNDNxMjYgMCA0NSAtMTl0MTkgLTQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJyZW1vdmVfY2lyY2xlIiB1bmljb2RlPSImI3hmMDVjOyIgCmQ9Ik0xMDk3IDQ1N2wtMTQ2IC0xNDZxLTEwIC0xMCAtMjMgLTEwdC0yMyAxMGwtMTM3IDEzN2wtMTM3IC0xMzdxLTEwIC0xMCAtMjMgLTEwdC0yMyAxMGwtMTQ2IDE0NnEtMTAgMTAgLTEwIDIzdDEwIDIzbDEzNyAxMzdsLTEzNyAxMzdxLTEwIDEwIC0xMCAyM3QxMCAyM2wxNDYgMTQ2cTEwIDEwIDIzIDEwdDIzIC0xMGwxMzcgLTEzN2wxMzcgMTM3cTEwIDEwIDIzIDEwdDIzIC0xMGwxNDYgLTE0NnExMCAtMTAgMTAgLTIzdC0xMCAtMjMKbC0xMzcgLTEzN2wxMzcgLTEzN3ExMCAtMTAgMTAgLTIzdC0xMCAtMjN6TTEzMTIgNjQwcTAgMTQ4IC03MyAyNzN0LTE5OCAxOTh0LTI3MyA3M3QtMjczIC03M3QtMTk4IC0xOTh0LTczIC0yNzN0NzMgLTI3M3QxOTggLTE5OHQyNzMgLTczdDI3MyA3M3QxOTggMTk4dDczIDI3M3pNMTUzNiA2NDBxMCAtMjA5IC0xMDMgLTM4NS41dC0yNzkuNSAtMjc5LjV0LTM4NS41IC0xMDN0LTM4NS41IDEwM3QtMjc5LjUgMjc5LjV0LTEwMyAzODUuNQp0MTAzIDM4NS41dDI3OS41IDI3OS41dDM4NS41IDEwM3QzODUuNSAtMTAzdDI3OS41IC0yNzkuNXQxMDMgLTM4NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJva19jaXJjbGUiIHVuaWNvZGU9IiYjeGYwNWQ7IiAKZD0iTTExNzEgNzIzbC00MjIgLTQyMnEtMTkgLTE5IC00NSAtMTl0LTQ1IDE5bC0yOTQgMjk0cS0xOSAxOSAtMTkgNDV0MTkgNDVsMTAyIDEwMnExOSAxOSA0NSAxOXQ0NSAtMTlsMTQ3IC0xNDdsMjc1IDI3NXExOSAxOSA0NSAxOXQ0NSAtMTlsMTAyIC0xMDJxMTkgLTE5IDE5IC00NXQtMTkgLTQ1ek0xMzEyIDY0MHEwIDE0OCAtNzMgMjczdC0xOTggMTk4dC0yNzMgNzN0LTI3MyAtNzN0LTE5OCAtMTk4dC03MyAtMjczdDczIC0yNzN0MTk4IC0xOTgKdDI3MyAtNzN0MjczIDczdDE5OCAxOTh0NzMgMjczek0xNTM2IDY0MHEwIC0yMDkgLTEwMyAtMzg1LjV0LTI3OS41IC0yNzkuNXQtMzg1LjUgLTEwM3QtMzg1LjUgMTAzdC0yNzkuNSAyNzkuNXQtMTAzIDM4NS41dDEwMyAzODUuNXQyNzkuNSAyNzkuNXQzODUuNSAxMDN0Mzg1LjUgLTEwM3QyNzkuNSAtMjc5LjV0MTAzIC0zODUuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYmFuX2NpcmNsZSIgdW5pY29kZT0iJiN4ZjA1ZTsiIApkPSJNMTMxMiA2NDNxMCAxNjEgLTg3IDI5NWwtNzU0IC03NTNxMTM3IC04OSAyOTcgLTg5cTExMSAwIDIxMS41IDQzLjV0MTczLjUgMTE2LjV0MTE2IDE3NC41dDQzIDIxMi41ek0zMTMgMzQ0bDc1NSA3NTRxLTEzNSA5MSAtMzAwIDkxcS0xNDggMCAtMjczIC03M3QtMTk4IC0xOTl0LTczIC0yNzRxMCAtMTYyIDg5IC0yOTl6TTE1MzYgNjQzcTAgLTE1NyAtNjEgLTMwMHQtMTYzLjUgLTI0NnQtMjQ1IC0xNjR0LTI5OC41IC02MXQtMjk4LjUgNjEKdC0yNDUgMTY0dC0xNjMuNSAyNDZ0LTYxIDMwMHQ2MSAyOTkuNXQxNjMuNSAyNDUuNXQyNDUgMTY0dDI5OC41IDYxdDI5OC41IC02MXQyNDUgLTE2NHQxNjMuNSAtMjQ1LjV0NjEgLTI5OS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhcnJvd19sZWZ0IiB1bmljb2RlPSImI3hmMDYwOyIgCmQ9Ik0xNTM2IDY0MHYtMTI4cTAgLTUzIC0zMi41IC05MC41dC04NC41IC0zNy41aC03MDRsMjkzIC0yOTRxMzggLTM2IDM4IC05MHQtMzggLTkwbC03NSAtNzZxLTM3IC0zNyAtOTAgLTM3cS01MiAwIC05MSAzN2wtNjUxIDY1MnEtMzcgMzcgLTM3IDkwcTAgNTIgMzcgOTFsNjUxIDY1MHEzOCAzOCA5MSAzOHE1MiAwIDkwIC0zOGw3NSAtNzRxMzggLTM4IDM4IC05MXQtMzggLTkxbC0yOTMgLTI5M2g3MDRxNTIgMCA4NC41IC0zNy41CnQzMi41IC05MC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhcnJvd19yaWdodCIgdW5pY29kZT0iJiN4ZjA2MTsiIApkPSJNMTQ3MiA1NzZxMCAtNTQgLTM3IC05MWwtNjUxIC02NTFxLTM5IC0zNyAtOTEgLTM3cS01MSAwIC05MCAzN2wtNzUgNzVxLTM4IDM4IC0zOCA5MXQzOCA5MWwyOTMgMjkzaC03MDRxLTUyIDAgLTg0LjUgMzcuNXQtMzIuNSA5MC41djEyOHEwIDUzIDMyLjUgOTAuNXQ4NC41IDM3LjVoNzA0bC0yOTMgMjk0cS0zOCAzNiAtMzggOTB0MzggOTBsNzUgNzVxMzggMzggOTAgMzhxNTMgMCA5MSAtMzhsNjUxIC02NTFxMzcgLTM1IDM3IC05MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYXJyb3dfdXAiIHVuaWNvZGU9IiYjeGYwNjI7IiBob3Jpei1hZHYteD0iMTY2NCIgCmQ9Ik0xNjExIDU2NXEwIC01MSAtMzcgLTkwbC03NSAtNzVxLTM4IC0zOCAtOTEgLTM4cS01NCAwIC05MCAzOGwtMjk0IDI5M3YtNzA0cTAgLTUyIC0zNy41IC04NC41dC05MC41IC0zMi41aC0xMjhxLTUzIDAgLTkwLjUgMzIuNXQtMzcuNSA4NC41djcwNGwtMjk0IC0yOTNxLTM2IC0zOCAtOTAgLTM4dC05MCAzOGwtNzUgNzVxLTM4IDM4IC0zOCA5MHEwIDUzIDM4IDkxbDY1MSA2NTFxMzUgMzcgOTAgMzdxNTQgMCA5MSAtMzdsNjUxIC02NTEKcTM3IC0zOSAzNyAtOTF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImFycm93X2Rvd24iIHVuaWNvZGU9IiYjeGYwNjM7IiBob3Jpei1hZHYteD0iMTY2NCIgCmQ9Ik0xNjExIDcwNHEwIC01MyAtMzcgLTkwbC02NTEgLTY1MnEtMzkgLTM3IC05MSAtMzdxLTUzIDAgLTkwIDM3bC02NTEgNjUycS0zOCAzNiAtMzggOTBxMCA1MyAzOCA5MWw3NCA3NXEzOSAzNyA5MSAzN3E1MyAwIDkwIC0zN2wyOTQgLTI5NHY3MDRxMCA1MiAzOCA5MHQ5MCAzOGgxMjhxNTIgMCA5MCAtMzh0MzggLTkwdi03MDRsMjk0IDI5NHEzNyAzNyA5MCAzN3E1MiAwIDkxIC0zN2w3NSAtNzVxMzcgLTM5IDM3IC05MXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ic2hhcmVfYWx0IiB1bmljb2RlPSImI3hmMDY0OyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTc5MiA4OTZxMCAtMjYgLTE5IC00NWwtNTEyIC01MTJxLTE5IC0xOSAtNDUgLTE5dC00NSAxOXQtMTkgNDV2MjU2aC0yMjRxLTk4IDAgLTE3NS41IC02dC0xNTQgLTIxLjV0LTEzMyAtNDIuNXQtMTA1LjUgLTY5LjV0LTgwIC0xMDF0LTQ4LjUgLTEzOC41dC0xNy41IC0xODFxMCAtNTUgNSAtMTIzcTAgLTYgMi41IC0yMy41dDIuNSAtMjYuNXEwIC0xNSAtOC41IC0yNXQtMjMuNSAtMTBxLTE2IDAgLTI4IDE3cS03IDkgLTEzIDIyCnQtMTMuNSAzMHQtMTAuNSAyNHEtMTI3IDI4NSAtMTI3IDQ1MXEwIDE5OSA1MyAzMzNxMTYyIDQwMyA4NzUgNDAzaDIyNHYyNTZxMCAyNiAxOSA0NXQ0NSAxOXQ0NSAtMTlsNTEyIC01MTJxMTkgLTE5IDE5IC00NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icmVzaXplX2Z1bGwiIHVuaWNvZGU9IiYjeGYwNjU7IiAKZD0iTTc1NSA0ODBxMCAtMTMgLTEwIC0yM2wtMzMyIC0zMzJsMTQ0IC0xNDRxMTkgLTE5IDE5IC00NXQtMTkgLTQ1dC00NSAtMTloLTQ0OHEtMjYgMCAtNDUgMTl0LTE5IDQ1djQ0OHEwIDI2IDE5IDQ1dDQ1IDE5dDQ1IC0xOWwxNDQgLTE0NGwzMzIgMzMycTEwIDEwIDIzIDEwdDIzIC0xMGwxMTQgLTExNHExMCAtMTAgMTAgLTIzek0xNTM2IDEzNDR2LTQ0OHEwIC0yNiAtMTkgLTQ1dC00NSAtMTl0LTQ1IDE5bC0xNDQgMTQ0bC0zMzIgLTMzMgpxLTEwIC0xMCAtMjMgLTEwdC0yMyAxMGwtMTE0IDExNHEtMTAgMTAgLTEwIDIzdDEwIDIzbDMzMiAzMzJsLTE0NCAxNDRxLTE5IDE5IC0xOSA0NXQxOSA0NXQ0NSAxOWg0NDhxMjYgMCA0NSAtMTl0MTkgLTQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJyZXNpemVfc21hbGwiIHVuaWNvZGU9IiYjeGYwNjY7IiAKZD0iTTc2OCA1NzZ2LTQ0OHEwIC0yNiAtMTkgLTQ1dC00NSAtMTl0LTQ1IDE5bC0xNDQgMTQ0bC0zMzIgLTMzMnEtMTAgLTEwIC0yMyAtMTB0LTIzIDEwbC0xMTQgMTE0cS0xMCAxMCAtMTAgMjN0MTAgMjNsMzMyIDMzMmwtMTQ0IDE0NHEtMTkgMTkgLTE5IDQ1dDE5IDQ1dDQ1IDE5aDQ0OHEyNiAwIDQ1IC0xOXQxOSAtNDV6TTE1MjMgMTI0OHEwIC0xMyAtMTAgLTIzbC0zMzIgLTMzMmwxNDQgLTE0NHExOSAtMTkgMTkgLTQ1dC0xOSAtNDUKdC00NSAtMTloLTQ0OHEtMjYgMCAtNDUgMTl0LTE5IDQ1djQ0OHEwIDI2IDE5IDQ1dDQ1IDE5dDQ1IC0xOWwxNDQgLTE0NGwzMzIgMzMycTEwIDEwIDIzIDEwdDIzIC0xMGwxMTQgLTExNHExMCAtMTAgMTAgLTIzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJwbHVzIiB1bmljb2RlPSImI3hmMDY3OyIgaG9yaXotYWR2LXg9IjE0MDgiIApkPSJNMTQwOCA4MDB2LTE5MnEwIC00MCAtMjggLTY4dC02OCAtMjhoLTQxNnYtNDE2cTAgLTQwIC0yOCAtNjh0LTY4IC0yOGgtMTkycS00MCAwIC02OCAyOHQtMjggNjh2NDE2aC00MTZxLTQwIDAgLTY4IDI4dC0yOCA2OHYxOTJxMCA0MCAyOCA2OHQ2OCAyOGg0MTZ2NDE2cTAgNDAgMjggNjh0NjggMjhoMTkycTQwIDAgNjggLTI4dDI4IC02OHYtNDE2aDQxNnE0MCAwIDY4IC0yOHQyOCAtNjh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im1pbnVzIiB1bmljb2RlPSImI3hmMDY4OyIgaG9yaXotYWR2LXg9IjE0MDgiIApkPSJNMTQwOCA4MDB2LTE5MnEwIC00MCAtMjggLTY4dC02OCAtMjhoLTEyMTZxLTQwIDAgLTY4IDI4dC0yOCA2OHYxOTJxMCA0MCAyOCA2OHQ2OCAyOGgxMjE2cTQwIDAgNjggLTI4dDI4IC02OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYXN0ZXJpc2siIHVuaWNvZGU9IiYjeGYwNjk7IiBob3Jpei1hZHYteD0iMTY2NCIgCmQ9Ik0xNDgyIDQ4NnE0NiAtMjYgNTkuNSAtNzcuNXQtMTIuNSAtOTcuNWwtNjQgLTExMHEtMjYgLTQ2IC03Ny41IC01OS41dC05Ny41IDEyLjVsLTI2NiAxNTN2LTMwN3EwIC01MiAtMzggLTkwdC05MCAtMzhoLTEyOHEtNTIgMCAtOTAgMzh0LTM4IDkwdjMwN2wtMjY2IC0xNTNxLTQ2IC0yNiAtOTcuNSAtMTIuNXQtNzcuNSA1OS41bC02NCAxMTBxLTI2IDQ2IC0xMi41IDk3LjV0NTkuNSA3Ny41bDI2NiAxNTRsLTI2NiAxNTQKcS00NiAyNiAtNTkuNSA3Ny41dDEyLjUgOTcuNWw2NCAxMTBxMjYgNDYgNzcuNSA1OS41dDk3LjUgLTEyLjVsMjY2IC0xNTN2MzA3cTAgNTIgMzggOTB0OTAgMzhoMTI4cTUyIDAgOTAgLTM4dDM4IC05MHYtMzA3bDI2NiAxNTNxNDYgMjYgOTcuNSAxMi41dDc3LjUgLTU5LjVsNjQgLTExMHEyNiAtNDYgMTIuNSAtOTcuNXQtNTkuNSAtNzcuNWwtMjY2IC0xNTR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImV4Y2xhbWF0aW9uX3NpZ24iIHVuaWNvZGU9IiYjeGYwNmE7IiAKZD0iTTc2OCAxNDA4cTIwOSAwIDM4NS41IC0xMDN0Mjc5LjUgLTI3OS41dDEwMyAtMzg1LjV0LTEwMyAtMzg1LjV0LTI3OS41IC0yNzkuNXQtMzg1LjUgLTEwM3QtMzg1LjUgMTAzdC0yNzkuNSAyNzkuNXQtMTAzIDM4NS41dDEwMyAzODUuNXQyNzkuNSAyNzkuNXQzODUuNSAxMDN6TTg5NiAxNjF2MTkwcTAgMTQgLTkgMjMuNXQtMjIgOS41aC0xOTJxLTEzIDAgLTIzIC0xMHQtMTAgLTIzdi0xOTBxMCAtMTMgMTAgLTIzdDIzIC0xMGgxOTIKcTEzIDAgMjIgOS41dDkgMjMuNXpNODk0IDUwNWwxOCA2MjFxMCAxMiAtMTAgMThxLTEwIDggLTI0IDhoLTIyMHEtMTQgMCAtMjQgLThxLTEwIC02IC0xMCAtMThsMTcgLTYyMXEwIC0xMCAxMCAtMTcuNXQyNCAtNy41aDE4NXExNCAwIDIzLjUgNy41dDEwLjUgMTcuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZ2lmdCIgdW5pY29kZT0iJiN4ZjA2YjsiIApkPSJNOTI4IDE4MHY1NnY0Njh2MTkyaC0zMjB2LTE5MnYtNDY4di01NnEwIC0yNSAxOCAtMzguNXQ0NiAtMTMuNWgxOTJxMjggMCA0NiAxMy41dDE4IDM4LjV6TTQ3MiAxMDI0aDE5NWwtMTI2IDE2MXEtMjYgMzEgLTY5IDMxcS00MCAwIC02OCAtMjh0LTI4IC02OHQyOCAtNjh0NjggLTI4ek0xMTYwIDExMjBxMCA0MCAtMjggNjh0LTY4IDI4cS00MyAwIC02OSAtMzFsLTEyNSAtMTYxaDE5NHE0MCAwIDY4IDI4dDI4IDY4ek0xNTM2IDg2NHYtMzIwCnEwIC0xNCAtOSAtMjN0LTIzIC05aC05NnYtNDE2cTAgLTQwIC0yOCAtNjh0LTY4IC0yOGgtMTA4OHEtNDAgMCAtNjggMjh0LTI4IDY4djQxNmgtOTZxLTE0IDAgLTIzIDl0LTkgMjN2MzIwcTAgMTQgOSAyM3QyMyA5aDQ0MHEtOTMgMCAtMTU4LjUgNjUuNXQtNjUuNSAxNTguNXQ2NS41IDE1OC41dDE1OC41IDY1LjVxMTA3IDAgMTY4IC03N2wxMjggLTE2NWwxMjggMTY1cTYxIDc3IDE2OCA3N3E5MyAwIDE1OC41IC02NS41dDY1LjUgLTE1OC41CnQtNjUuNSAtMTU4LjV0LTE1OC41IC02NS41aDQ0MHExNCAwIDIzIC05dDkgLTIzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJsZWFmIiB1bmljb2RlPSImI3hmMDZjOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTI4MCA4MzJxMCAyNiAtMTkgNDV0LTQ1IDE5cS0xNzIgMCAtMzE4IC00OS41dC0yNTkuNSAtMTM0dC0yMzUuNSAtMjE5LjVxLTE5IC0yMSAtMTkgLTQ1cTAgLTI2IDE5IC00NXQ0NSAtMTlxMjQgMCA0NSAxOXEyNyAyNCA3NCA3MXQ2NyA2NnExMzcgMTI0IDI2OC41IDE3NnQzMTMuNSA1MnEyNiAwIDQ1IDE5dDE5IDQ1ek0xNzkyIDEwMzBxMCAtOTUgLTIwIC0xOTNxLTQ2IC0yMjQgLTE4NC41IC0zODN0LTM1Ny41IC0yNjgKcS0yMTQgLTEwOCAtNDM4IC0xMDhxLTE0OCAwIC0yODYgNDdxLTE1IDUgLTg4IDQydC05NiAzN3EtMTYgMCAtMzkuNSAtMzJ0LTQ1IC03MHQtNTIuNSAtNzB0LTYwIC0zMnEtNDMgMCAtNjMuNSAxNy41dC00NS41IDU5LjVxLTIgNCAtNiAxMXQtNS41IDEwdC0zIDkuNXQtMS41IDEzLjVxMCAzNSAzMSA3My41dDY4IDY1LjV0NjggNTZ0MzEgNDhxMCA0IC0xNCAzOHQtMTYgNDRxLTkgNTEgLTkgMTA0cTAgMTE1IDQzLjUgMjIwdDExOSAxODQuNQp0MTcwLjUgMTM5dDIwNCA5NS41cTU1IDE4IDE0NSAyNS41dDE3OS41IDl0MTc4LjUgNnQxNjMuNSAyNHQxMTMuNSA1Ni41bDI5LjUgMjkuNXQyOS41IDI4dDI3IDIwdDM2LjUgMTZ0NDMuNSA0LjVxMzkgMCA3MC41IC00NnQ0Ny41IC0xMTJ0MjQgLTEyNHQ4IC05NnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZmlyZSIgdW5pY29kZT0iJiN4ZjA2ZDsiIGhvcml6LWFkdi14PSIxNDA4IiAKZD0iTTE0MDggLTE2MHYtNjRxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC0xMzQ0cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2NjRxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWgxMzQ0cTEzIDAgMjIuNSAtOS41dDkuNSAtMjIuNXpNMTE1MiA4OTZxMCAtNzggLTI0LjUgLTE0NHQtNjQgLTExMi41dC04Ny41IC04OHQtOTYgLTc3LjV0LTg3LjUgLTcydC02NCAtODEuNXQtMjQuNSAtOTYuNXEwIC05NiA2NyAtMjI0bC00IDFsMSAtMQpxLTkwIDQxIC0xNjAgODN0LTEzOC41IDEwMHQtMTEzLjUgMTIyLjV0LTcyLjUgMTUwLjV0LTI3LjUgMTg0cTAgNzggMjQuNSAxNDR0NjQgMTEyLjV0ODcuNSA4OHQ5NiA3Ny41dDg3LjUgNzJ0NjQgODEuNXQyNC41IDk2LjVxMCA5NCAtNjYgMjI0bDMgLTFsLTEgMXE5MCAtNDEgMTYwIC04M3QxMzguNSAtMTAwdDExMy41IC0xMjIuNXQ3Mi41IC0xNTAuNXQyNy41IC0xODR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImV5ZV9vcGVuIiB1bmljb2RlPSImI3hmMDZlOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTY2NCA1NzZxLTE1MiAyMzYgLTM4MSAzNTNxNjEgLTEwNCA2MSAtMjI1cTAgLTE4NSAtMTMxLjUgLTMxNi41dC0zMTYuNSAtMTMxLjV0LTMxNi41IDEzMS41dC0xMzEuNSAzMTYuNXEwIDEyMSA2MSAyMjVxLTIyOSAtMTE3IC0zODEgLTM1M3ExMzMgLTIwNSAzMzMuNSAtMzI2LjV0NDM0LjUgLTEyMS41dDQzNC41IDEyMS41dDMzMy41IDMyNi41ek05NDQgOTYwcTAgMjAgLTE0IDM0dC0zNCAxNHEtMTI1IDAgLTIxNC41IC04OS41CnQtODkuNSAtMjE0LjVxMCAtMjAgMTQgLTM0dDM0IC0xNHQzNCAxNHQxNCAzNHEwIDg2IDYxIDE0N3QxNDcgNjFxMjAgMCAzNCAxNHQxNCAzNHpNMTc5MiA1NzZxMCAtMzQgLTIwIC02OXEtMTQwIC0yMzAgLTM3Ni41IC0zNjguNXQtNDk5LjUgLTEzOC41dC00OTkuNSAxMzl0LTM3Ni41IDM2OHEtMjAgMzUgLTIwIDY5dDIwIDY5cTE0MCAyMjkgMzc2LjUgMzY4dDQ5OS41IDEzOXQ0OTkuNSAtMTM5dDM3Ni41IC0zNjhxMjAgLTM1IDIwIC02OXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZXllX2Nsb3NlIiB1bmljb2RlPSImI3hmMDcwOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNNTU1IDIwMWw3OCAxNDFxLTg3IDYzIC0xMzYgMTU5dC00OSAyMDNxMCAxMjEgNjEgMjI1cS0yMjkgLTExNyAtMzgxIC0zNTNxMTY3IC0yNTggNDI3IC0zNzV6TTk0NCA5NjBxMCAyMCAtMTQgMzR0LTM0IDE0cS0xMjUgMCAtMjE0LjUgLTg5LjV0LTg5LjUgLTIxNC41cTAgLTIwIDE0IC0zNHQzNCAtMTR0MzQgMTR0MTQgMzRxMCA4NiA2MSAxNDd0MTQ3IDYxcTIwIDAgMzQgMTR0MTQgMzR6TTEzMDcgMTE1MXEwIC03IC0xIC05CnEtMTA2IC0xODkgLTMxNiAtNTY3dC0zMTUgLTU2NmwtNDkgLTg5cS0xMCAtMTYgLTI4IC0xNnEtMTIgMCAtMTM0IDcwcS0xNiAxMCAtMTYgMjhxMCAxMiA0NCA4N3EtMTQzIDY1IC0yNjMuNSAxNzN0LTIwOC41IDI0NXEtMjAgMzEgLTIwIDY5dDIwIDY5cTE1MyAyMzUgMzgwIDM3MXQ0OTYgMTM2cTg5IDAgMTgwIC0xN2w1NCA5N3ExMCAxNiAyOCAxNnE1IDAgMTggLTZ0MzEgLTE1LjV0MzMgLTE4LjV0MzEuNSAtMTguNXQxOS41IC0xMS41CnExNiAtMTAgMTYgLTI3ek0xMzQ0IDcwNHEwIC0xMzkgLTc5IC0yNTMuNXQtMjA5IC0xNjQuNWwyODAgNTAycTggLTQ1IDggLTg0ek0xNzkyIDU3NnEwIC0zNSAtMjAgLTY5cS0zOSAtNjQgLTEwOSAtMTQ1cS0xNTAgLTE3MiAtMzQ3LjUgLTI2N3QtNDE5LjUgLTk1bDc0IDEzMnEyMTIgMTggMzkyLjUgMTM3dDMwMS41IDMwN3EtMTE1IDE3OSAtMjgyIDI5NGw2MyAxMTJxOTUgLTY0IDE4Mi41IC0xNTN0MTQ0LjUgLTE4NHEyMCAtMzQgMjAgLTY5egoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0id2FybmluZ19zaWduIiB1bmljb2RlPSImI3hmMDcxOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTAyNCAxNjF2MTkwcTAgMTQgLTkuNSAyMy41dC0yMi41IDkuNWgtMTkycS0xMyAwIC0yMi41IC05LjV0LTkuNSAtMjMuNXYtMTkwcTAgLTE0IDkuNSAtMjMuNXQyMi41IC05LjVoMTkycTEzIDAgMjIuNSA5LjV0OS41IDIzLjV6TTEwMjIgNTM1bDE4IDQ1OXEwIDEyIC0xMCAxOXEtMTMgMTEgLTI0IDExaC0yMjBxLTExIDAgLTI0IC0xMXEtMTAgLTcgLTEwIC0yMWwxNyAtNDU3cTAgLTEwIDEwIC0xNi41dDI0IC02LjVoMTg1CnExNCAwIDIzLjUgNi41dDEwLjUgMTYuNXpNMTAwOCAxNDY5bDc2OCAtMTQwOHEzNSAtNjMgLTIgLTEyNnEtMTcgLTI5IC00Ni41IC00NnQtNjMuNSAtMTdoLTE1MzZxLTM0IDAgLTYzLjUgMTd0LTQ2LjUgNDZxLTM3IDYzIC0yIDEyNmw3NjggMTQwOHExNyAzMSA0NyA0OXQ2NSAxOHQ2NSAtMTh0NDcgLTQ5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJwbGFuZSIgdW5pY29kZT0iJiN4ZjA3MjsiIGhvcml6LWFkdi14PSIxNDA4IiAKZD0iTTEzNzYgMTM3NnE0NCAtNTIgMTIgLTE0OHQtMTA4IC0xNzJsLTE2MSAtMTYxbDE2MCAtNjk2cTUgLTE5IC0xMiAtMzNsLTEyOCAtOTZxLTcgLTYgLTE5IC02cS00IDAgLTcgMXEtMTUgMyAtMjEgMTZsLTI3OSA1MDhsLTI1OSAtMjU5bDUzIC0xOTRxNSAtMTcgLTggLTMxbC05NiAtOTZxLTkgLTkgLTIzIC05aC0ycS0xNSAyIC0yNCAxM2wtMTg5IDI1MmwtMjUyIDE4OXEtMTEgNyAtMTMgMjNxLTEgMTMgOSAyNWw5NiA5N3E5IDkgMjMgOQpxNiAwIDggLTFsMTk0IC01M2wyNTkgMjU5bC01MDggMjc5cS0xNCA4IC0xNyAyNHEtMiAxNiA5IDI3bDEyOCAxMjhxMTQgMTMgMzAgOGw2NjUgLTE1OWwxNjAgMTYwcTc2IDc2IDE3MiAxMDh0MTQ4IC0xMnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY2FsZW5kYXIiIHVuaWNvZGU9IiYjeGYwNzM7IiBob3Jpei1hZHYteD0iMTY2NCIgCmQ9Ik0xMjggLTEyOGgyODh2Mjg4aC0yODh2LTI4OHpNNDgwIC0xMjhoMzIwdjI4OGgtMzIwdi0yODh6TTEyOCAyMjRoMjg4djMyMGgtMjg4di0zMjB6TTQ4MCAyMjRoMzIwdjMyMGgtMzIwdi0zMjB6TTEyOCA2MDhoMjg4djI4OGgtMjg4di0yODh6TTg2NCAtMTI4aDMyMHYyODhoLTMyMHYtMjg4ek00ODAgNjA4aDMyMHYyODhoLTMyMHYtMjg4ek0xMjQ4IC0xMjhoMjg4djI4OGgtMjg4di0yODh6TTg2NCAyMjRoMzIwdjMyMGgtMzIwdi0zMjB6Ck01MTIgMTA4OHYyODhxMCAxMyAtOS41IDIyLjV0LTIyLjUgOS41aC02NHEtMTMgMCAtMjIuNSAtOS41dC05LjUgLTIyLjV2LTI4OHEwIC0xMyA5LjUgLTIyLjV0MjIuNSAtOS41aDY0cTEzIDAgMjIuNSA5LjV0OS41IDIyLjV6TTEyNDggMjI0aDI4OHYzMjBoLTI4OHYtMzIwek04NjQgNjA4aDMyMHYyODhoLTMyMHYtMjg4ek0xMjQ4IDYwOGgyODh2Mjg4aC0yODh2LTI4OHpNMTI4MCAxMDg4djI4OHEwIDEzIC05LjUgMjIuNXQtMjIuNSA5LjVoLTY0CnEtMTMgMCAtMjIuNSAtOS41dC05LjUgLTIyLjV2LTI4OHEwIC0xMyA5LjUgLTIyLjV0MjIuNSAtOS41aDY0cTEzIDAgMjIuNSA5LjV0OS41IDIyLjV6TTE2NjQgMTE1MnYtMTI4MHEwIC01MiAtMzggLTkwdC05MCAtMzhoLTE0MDhxLTUyIDAgLTkwIDM4dC0zOCA5MHYxMjgwcTAgNTIgMzggOTB0OTAgMzhoMTI4djk2cTAgNjYgNDcgMTEzdDExMyA0N2g2NHE2NiAwIDExMyAtNDd0NDcgLTExM3YtOTZoMzg0djk2cTAgNjYgNDcgMTEzdDExMyA0NwpoNjRxNjYgMCAxMTMgLTQ3dDQ3IC0xMTN2LTk2aDEyOHE1MiAwIDkwIC0zOHQzOCAtOTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InJhbmRvbSIgdW5pY29kZT0iJiN4ZjA3NDsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTY2NiAxMDU1cS02MCAtOTIgLTEzNyAtMjczcS0yMiA0NSAtMzcgNzIuNXQtNDAuNSA2My41dC01MSA1Ni41dC02MyAzNXQtODEuNSAxNC41aC0yMjRxLTE0IDAgLTIzIDl0LTkgMjN2MTkycTAgMTQgOSAyM3QyMyA5aDIyNHEyNTAgMCA0MTAgLTIyNXpNMTc5MiAyNTZxMCAtMTQgLTkgLTIzbC0zMjAgLTMyMHEtOSAtOSAtMjMgLTlxLTEzIDAgLTIyLjUgOS41dC05LjUgMjIuNXYxOTJxLTMyIDAgLTg1IC0wLjV0LTgxIC0xdC03MyAxCnQtNzEgNXQtNjQgMTAuNXQtNjMgMTguNXQtNTggMjguNXQtNTkgNDB0LTU1IDUzLjV0LTU2IDY5LjVxNTkgOTMgMTM2IDI3M3EyMiAtNDUgMzcgLTcyLjV0NDAuNSAtNjMuNXQ1MSAtNTYuNXQ2MyAtMzV0ODEuNSAtMTQuNWgyNTZ2MTkycTAgMTQgOSAyM3QyMyA5cTEyIDAgMjQgLTEwbDMxOSAtMzE5cTkgLTkgOSAtMjN6TTE3OTIgMTE1MnEwIC0xNCAtOSAtMjNsLTMyMCAtMzIwcS05IC05IC0yMyAtOXEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41CnYxOTJoLTI1NnEtNDggMCAtODcgLTE1dC02OSAtNDV0LTUxIC02MS41dC00NSAtNzcuNXEtMzIgLTYyIC03OCAtMTcxcS0yOSAtNjYgLTQ5LjUgLTExMXQtNTQgLTEwNXQtNjQgLTEwMHQtNzQgLTgzdC05MCAtNjguNXQtMTA2LjUgLTQydC0xMjggLTE2LjVoLTIyNHEtMTQgMCAtMjMgOXQtOSAyM3YxOTJxMCAxNCA5IDIzdDIzIDloMjI0cTQ4IDAgODcgMTV0NjkgNDV0NTEgNjEuNXQ0NSA3Ny41cTMyIDYyIDc4IDE3MXEyOSA2NiA0OS41IDExMQp0NTQgMTA1dDY0IDEwMHQ3NCA4M3Q5MCA2OC41dDEwNi41IDQydDEyOCAxNi41aDI1NnYxOTJxMCAxNCA5IDIzdDIzIDlxMTIgMCAyNCAtMTBsMzE5IC0zMTlxOSAtOSA5IC0yM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY29tbWVudCIgdW5pY29kZT0iJiN4ZjA3NTsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE3OTIgNjQwcTAgLTE3NCAtMTIwIC0zMjEuNXQtMzI2IC0yMzN0LTQ1MCAtODUuNXEtNzAgMCAtMTQ1IDhxLTE5OCAtMTc1IC00NjAgLTI0MnEtNDkgLTE0IC0xMTQgLTIycS0xNyAtMiAtMzAuNSA5dC0xNy41IDI5djFxLTMgNCAtMC41IDEydDIgMTB0NC41IDkuNWw2IDl0NyA4LjV0OCA5cTcgOCAzMSAzNC41dDM0LjUgMzh0MzEgMzkuNXQzMi41IDUxdDI3IDU5dDI2IDc2cS0xNTcgODkgLTI0Ny41IDIyMHQtOTAuNSAyODEKcTAgMTMwIDcxIDI0OC41dDE5MSAyMDQuNXQyODYgMTM2LjV0MzQ4IDUwLjVxMjQ0IDAgNDUwIC04NS41dDMyNiAtMjMzdDEyMCAtMzIxLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im1hZ25ldCIgdW5pY29kZT0iJiN4ZjA3NjsiIApkPSJNMTUzNiA3MDR2LTEyOHEwIC0yMDEgLTk4LjUgLTM2MnQtMjc0IC0yNTEuNXQtMzk1LjUgLTkwLjV0LTM5NS41IDkwLjV0LTI3NCAyNTEuNXQtOTguNSAzNjJ2MTI4cTAgMjYgMTkgNDV0NDUgMTloMzg0cTI2IDAgNDUgLTE5dDE5IC00NXYtMTI4cTAgLTUyIDIzLjUgLTkwdDUzLjUgLTU3dDcxIC0zMHQ2NCAtMTN0NDQgLTJ0NDQgMnQ2NCAxM3Q3MSAzMHQ1My41IDU3dDIzLjUgOTB2MTI4cTAgMjYgMTkgNDV0NDUgMTloMzg0CnEyNiAwIDQ1IC0xOXQxOSAtNDV6TTUxMiAxMzQ0di0zODRxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0zODRxLTI2IDAgLTQ1IDE5dC0xOSA0NXYzODRxMCAyNiAxOSA0NXQ0NSAxOWgzODRxMjYgMCA0NSAtMTl0MTkgLTQ1ek0xNTM2IDEzNDR2LTM4NHEwIC0yNiAtMTkgLTQ1dC00NSAtMTloLTM4NHEtMjYgMCAtNDUgMTl0LTE5IDQ1djM4NHEwIDI2IDE5IDQ1dDQ1IDE5aDM4NHEyNiAwIDQ1IC0xOXQxOSAtNDV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNoZXZyb25fdXAiIHVuaWNvZGU9IiYjeGYwNzc7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xNjgzIDIwNWwtMTY2IC0xNjVxLTE5IC0xOSAtNDUgLTE5dC00NSAxOWwtNTMxIDUzMWwtNTMxIC01MzFxLTE5IC0xOSAtNDUgLTE5dC00NSAxOWwtMTY2IDE2NXEtMTkgMTkgLTE5IDQ1LjV0MTkgNDUuNWw3NDIgNzQxcTE5IDE5IDQ1IDE5dDQ1IC0xOWw3NDIgLTc0MXExOSAtMTkgMTkgLTQ1LjV0LTE5IC00NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjaGV2cm9uX2Rvd24iIHVuaWNvZGU9IiYjeGYwNzg7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xNjgzIDcyOGwtNzQyIC03NDFxLTE5IC0xOSAtNDUgLTE5dC00NSAxOWwtNzQyIDc0MXEtMTkgMTkgLTE5IDQ1LjV0MTkgNDUuNWwxNjYgMTY1cTE5IDE5IDQ1IDE5dDQ1IC0xOWw1MzEgLTUzMWw1MzEgNTMxcTE5IDE5IDQ1IDE5dDQ1IC0xOWwxNjYgLTE2NXExOSAtMTkgMTkgLTQ1LjV0LTE5IC00NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJyZXR3ZWV0IiB1bmljb2RlPSImI3hmMDc5OyIgaG9yaXotYWR2LXg9IjE5MjAiIApkPSJNMTI4MCAzMnEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTk2MHEtOCAwIC0xMy41IDJ0LTkgN3QtNS41IDh0LTMgMTEuNXQtMSAxMS41djEzdjExdjE2MHY0MTZoLTE5MnEtMjYgMCAtNDUgMTl0LTE5IDQ1cTAgMjQgMTUgNDFsMzIwIDM4NHExOSAyMiA0OSAyMnQ0OSAtMjJsMzIwIC0zODRxMTUgLTE3IDE1IC00MXEwIC0yNiAtMTkgLTQ1dC00NSAtMTloLTE5MnYtMzg0aDU3NnExNiAwIDI1IC0xMWwxNjAgLTE5MnE3IC0xMCA3IC0yMQp6TTE5MjAgNDQ4cTAgLTI0IC0xNSAtNDFsLTMyMCAtMzg0cS0yMCAtMjMgLTQ5IC0yM3QtNDkgMjNsLTMyMCAzODRxLTE1IDE3IC0xNSA0MXEwIDI2IDE5IDQ1dDQ1IDE5aDE5MnYzODRoLTU3NnEtMTYgMCAtMjUgMTJsLTE2MCAxOTJxLTcgOSAtNyAyMHEwIDEzIDkuNSAyMi41dDIyLjUgOS41aDk2MHE4IDAgMTMuNSAtMnQ5IC03dDUuNSAtOHQzIC0xMS41dDEgLTExLjV2LTEzdi0xMXYtMTYwdi00MTZoMTkycTI2IDAgNDUgLTE5dDE5IC00NXoKIiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InNob3BwaW5nX2NhcnQiIHVuaWNvZGU9IiYjeGYwN2E7IiBob3Jpei1hZHYteD0iMTY2NCIgCmQ9Ik02NDAgMHEwIC01MiAtMzggLTkwdC05MCAtMzh0LTkwIDM4dC0zOCA5MHQzOCA5MHQ5MCAzOHQ5MCAtMzh0MzggLTkwek0xNTM2IDBxMCAtNTIgLTM4IC05MHQtOTAgLTM4dC05MCAzOHQtMzggOTB0MzggOTB0OTAgMzh0OTAgLTM4dDM4IC05MHpNMTY2NCAxMDg4di01MTJxMCAtMjQgLTE2LjUgLTQyLjV0LTQwLjUgLTIxLjVsLTEwNDQgLTEyMnExMyAtNjAgMTMgLTcwcTAgLTE2IC0yNCAtNjRoOTIwcTI2IDAgNDUgLTE5dDE5IC00NQp0LTE5IC00NXQtNDUgLTE5aC0xMDI0cS0yNiAwIC00NSAxOXQtMTkgNDVxMCAxMSA4IDMxLjV0MTYgMzZ0MjEuNSA0MHQxNS41IDI5LjVsLTE3NyA4MjNoLTIwNHEtMjYgMCAtNDUgMTl0LTE5IDQ1dDE5IDQ1dDQ1IDE5aDI1NnExNiAwIDI4LjUgLTYuNXQxOS41IC0xNS41dDEzIC0yNC41dDggLTI2dDUuNSAtMjkuNXQ0LjUgLTI2aDEyMDFxMjYgMCA0NSAtMTl0MTkgLTQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJmb2xkZXJfY2xvc2UiIHVuaWNvZGU9IiYjeGYwN2I7IiBob3Jpei1hZHYteD0iMTY2NCIgCmQ9Ik0xNjY0IDkyOHYtNzA0cTAgLTkyIC02NiAtMTU4dC0xNTggLTY2aC0xMjE2cS05MiAwIC0xNTggNjZ0LTY2IDE1OHY5NjBxMCA5MiA2NiAxNTh0MTU4IDY2aDMyMHE5MiAwIDE1OCAtNjZ0NjYgLTE1OHYtMzJoNjcycTkyIDAgMTU4IC02NnQ2NiAtMTU4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJmb2xkZXJfb3BlbiIgdW5pY29kZT0iJiN4ZjA3YzsiIGhvcml6LWFkdi14PSIxOTIwIiAKZD0iTTE4NzkgNTg0cTAgLTMxIC0zMSAtNjZsLTMzNiAtMzk2cS00MyAtNTEgLTEyMC41IC04Ni41dC0xNDMuNSAtMzUuNWgtMTA4OHEtMzQgMCAtNjAuNSAxM3QtMjYuNSA0M3EwIDMxIDMxIDY2bDMzNiAzOTZxNDMgNTEgMTIwLjUgODYuNXQxNDMuNSAzNS41aDEwODhxMzQgMCA2MC41IC0xM3QyNi41IC00M3pNMTUzNiA5Mjh2LTE2MGgtODMycS05NCAwIC0xOTcgLTQ3LjV0LTE2NCAtMTE5LjVsLTMzNyAtMzk2bC01IC02cTAgNCAtMC41IDEyLjUKdC0wLjUgMTIuNXY5NjBxMCA5MiA2NiAxNTh0MTU4IDY2aDMyMHE5MiAwIDE1OCAtNjZ0NjYgLTE1OHYtMzJoNTQ0cTkyIDAgMTU4IC02NnQ2NiAtMTU4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJyZXNpemVfdmVydGljYWwiIHVuaWNvZGU9IiYjeGYwN2Q7IiBob3Jpei1hZHYteD0iNzY4IiAKZD0iTTcwNCAxMjE2cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtMTI4di0xMDI0aDEyOHEyNiAwIDQ1IC0xOXQxOSAtNDV0LTE5IC00NWwtMjU2IC0yNTZxLTE5IC0xOSAtNDUgLTE5dC00NSAxOWwtMjU2IDI1NnEtMTkgMTkgLTE5IDQ1dDE5IDQ1dDQ1IDE5aDEyOHYxMDI0aC0xMjhxLTI2IDAgLTQ1IDE5dC0xOSA0NXQxOSA0NWwyNTYgMjU2cTE5IDE5IDQ1IDE5dDQ1IC0xOWwyNTYgLTI1NnExOSAtMTkgMTkgLTQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJyZXNpemVfaG9yaXpvbnRhbCIgdW5pY29kZT0iJiN4ZjA3ZTsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE3OTIgNjQwcTAgLTI2IC0xOSAtNDVsLTI1NiAtMjU2cS0xOSAtMTkgLTQ1IC0xOXQtNDUgMTl0LTE5IDQ1djEyOGgtMTAyNHYtMTI4cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOXQtNDUgMTlsLTI1NiAyNTZxLTE5IDE5IC0xOSA0NXQxOSA0NWwyNTYgMjU2cTE5IDE5IDQ1IDE5dDQ1IC0xOXQxOSAtNDV2LTEyOGgxMDI0djEyOHEwIDI2IDE5IDQ1dDQ1IDE5dDQ1IC0xOWwyNTYgLTI1NnExOSAtMTkgMTkgLTQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJiYXJfY2hhcnQiIHVuaWNvZGU9IiYjeGYwODA7IiBob3Jpei1hZHYteD0iMjA0OCIgCmQ9Ik02NDAgNjQwdi01MTJoLTI1NnY1MTJoMjU2ek0xMDI0IDExNTJ2LTEwMjRoLTI1NnYxMDI0aDI1NnpNMjA0OCAwdi0xMjhoLTIwNDh2MTUzNmgxMjh2LTE0MDhoMTkyMHpNMTQwOCA4OTZ2LTc2OGgtMjU2djc2OGgyNTZ6TTE3OTIgMTI4MHYtMTE1MmgtMjU2djExNTJoMjU2eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ0d2l0dGVyX3NpZ24iIHVuaWNvZGU9IiYjeGYwODE7IiAKZD0iTTEyODAgOTI2cS01NiAtMjUgLTEyMSAtMzRxNjggNDAgOTMgMTE3cS02NSAtMzggLTEzNCAtNTFxLTYxIDY2IC0xNTMgNjZxLTg3IDAgLTE0OC41IC02MS41dC02MS41IC0xNDguNXEwIC0yOSA1IC00OHEtMTI5IDcgLTI0MiA2NXQtMTkyIDE1NXEtMjkgLTUwIC0yOSAtMTA2cTAgLTExNCA5MSAtMTc1cS00NyAxIC0xMDAgMjZ2LTJxMCAtNzUgNTAgLTEzMy41dDEyMyAtNzIuNXEtMjkgLTggLTUxIC04cS0xMyAwIC0zOSA0CnEyMSAtNjMgNzQuNSAtMTA0dDEyMS41IC00MnEtMTE2IC05MCAtMjYxIC05MHEtMjYgMCAtNTAgM3ExNDggLTk0IDMyMiAtOTRxMTEyIDAgMjEwIDM1LjV0MTY4IDk1dDEyMC41IDEzN3Q3NSAxNjJ0MjQuNSAxNjguNXEwIDE4IC0xIDI3cTYzIDQ1IDEwNSAxMDl6TTE1MzYgMTEyMHYtOTYwcTAgLTExOSAtODQuNSAtMjAzLjV0LTIwMy41IC04NC41aC05NjBxLTExOSAwIC0yMDMuNSA4NC41dC04NC41IDIwMy41djk2MHEwIDExOSA4NC41IDIwMy41CnQyMDMuNSA4NC41aDk2MHExMTkgMCAyMDMuNSAtODQuNXQ4NC41IC0yMDMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZmFjZWJvb2tfc2lnbiIgdW5pY29kZT0iJiN4ZjA4MjsiIApkPSJNMTI0OCAxNDA4cTExOSAwIDIwMy41IC04NC41dDg0LjUgLTIwMy41di05NjBxMCAtMTE5IC04NC41IC0yMDMuNXQtMjAzLjUgLTg0LjVoLTE4OHY1OTVoMTk5bDMwIDIzMmgtMjI5djE0OHEwIDU2IDIzLjUgODR0OTEuNSAyOGwxMjIgMXYyMDdxLTYzIDkgLTE3OCA5cS0xMzYgMCAtMjE3LjUgLTgwdC04MS41IC0yMjZ2LTE3MWgtMjAwdi0yMzJoMjAwdi01OTVoLTUzMnEtMTE5IDAgLTIwMy41IDg0LjV0LTg0LjUgMjAzLjV2OTYwCnEwIDExOSA4NC41IDIwMy41dDIwMy41IDg0LjVoOTYweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjYW1lcmFfcmV0cm8iIHVuaWNvZGU9IiYjeGYwODM7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik05MjggNzA0cTAgMTQgLTkgMjN0LTIzIDlxLTY2IDAgLTExMyAtNDd0LTQ3IC0xMTNxMCAtMTQgOSAtMjN0MjMgLTl0MjMgOXQ5IDIzcTAgNDAgMjggNjh0NjggMjhxMTQgMCAyMyA5dDkgMjN6TTExNTIgNTc0cTAgLTEwNiAtNzUgLTE4MXQtMTgxIC03NXQtMTgxIDc1dC03NSAxODF0NzUgMTgxdDE4MSA3NXQxODEgLTc1dDc1IC0xODF6TTEyOCAwaDE1MzZ2MTI4aC0xNTM2di0xMjh6TTEyODAgNTc0cTAgMTU5IC0xMTIuNSAyNzEuNQp0LTI3MS41IDExMi41dC0yNzEuNSAtMTEyLjV0LTExMi41IC0yNzEuNXQxMTIuNSAtMjcxLjV0MjcxLjUgLTExMi41dDI3MS41IDExMi41dDExMi41IDI3MS41ek0yNTYgMTIxNmgzODR2MTI4aC0zODR2LTEyOHpNMTI4IDEwMjRoMTUzNnYxMTh2MTM4aC04MjhsLTY0IC0xMjhoLTY0NHYtMTI4ek0xNzkyIDEyODB2LTEyODBxMCAtNTMgLTM3LjUgLTkwLjV0LTkwLjUgLTM3LjVoLTE1MzZxLTUzIDAgLTkwLjUgMzcuNXQtMzcuNSA5MC41djEyODAKcTAgNTMgMzcuNSA5MC41dDkwLjUgMzcuNWgxNTM2cTUzIDAgOTAuNSAtMzcuNXQzNy41IC05MC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJrZXkiIHVuaWNvZGU9IiYjeGYwODQ7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik04MzIgMTAyNHEwIDgwIC01NiAxMzZ0LTEzNiA1NnQtMTM2IC01NnQtNTYgLTEzNnEwIC00MiAxOSAtODNxLTQxIDE5IC04MyAxOXEtODAgMCAtMTM2IC01NnQtNTYgLTEzNnQ1NiAtMTM2dDEzNiAtNTZ0MTM2IDU2dDU2IDEzNnEwIDQyIC0xOSA4M3E0MSAtMTkgODMgLTE5cTgwIDAgMTM2IDU2dDU2IDEzNnpNMTY4MyAzMjBxMCAtMTcgLTQ5IC02NnQtNjYgLTQ5cS05IDAgLTI4LjUgMTZ0LTM2LjUgMzN0LTM4LjUgNDB0LTI0LjUgMjYKbC05NiAtOTZsMjIwIC0yMjBxMjggLTI4IDI4IC02OHEwIC00MiAtMzkgLTgxdC04MSAtMzlxLTQwIDAgLTY4IDI4bC02NzEgNjcxcS0xNzYgLTEzMSAtMzY1IC0xMzFxLTE2MyAwIC0yNjUuNSAxMDIuNXQtMTAyLjUgMjY1LjVxMCAxNjAgOTUgMzEzdDI0OCAyNDh0MzEzIDk1cTE2MyAwIDI2NS41IC0xMDIuNXQxMDIuNSAtMjY1LjVxMCAtMTg5IC0xMzEgLTM2NWwzNTUgLTM1NWw5NiA5NnEtMyAzIC0yNiAyNC41dC00MCAzOC41dC0zMyAzNi41CnQtMTYgMjguNXEwIDE3IDQ5IDY2dDY2IDQ5cTEzIDAgMjMgLTEwcTYgLTYgNDYgLTQ0LjV0ODIgLTc5LjV0ODYuNSAtODZ0NzMgLTc4dDI4LjUgLTQxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjb2dzIiB1bmljb2RlPSImI3hmMDg1OyIgaG9yaXotYWR2LXg9IjE5MjAiIApkPSJNODk2IDY0MHEwIDEwNiAtNzUgMTgxdC0xODEgNzV0LTE4MSAtNzV0LTc1IC0xODF0NzUgLTE4MXQxODEgLTc1dDE4MSA3NXQ3NSAxODF6TTE2NjQgMTI4cTAgNTIgLTM4IDkwdC05MCAzOHQtOTAgLTM4dC0zOCAtOTBxMCAtNTMgMzcuNSAtOTAuNXQ5MC41IC0zNy41dDkwLjUgMzcuNXQzNy41IDkwLjV6TTE2NjQgMTE1MnEwIDUyIC0zOCA5MHQtOTAgMzh0LTkwIC0zOHQtMzggLTkwcTAgLTUzIDM3LjUgLTkwLjV0OTAuNSAtMzcuNQp0OTAuNSAzNy41dDM3LjUgOTAuNXpNMTI4MCA3MzF2LTE4NXEwIC0xMCAtNyAtMTkuNXQtMTYgLTEwLjVsLTE1NSAtMjRxLTExIC0zNSAtMzIgLTc2cTM0IC00OCA5MCAtMTE1cTcgLTExIDcgLTIwcTAgLTEyIC03IC0xOXEtMjMgLTMwIC04Mi41IC04OS41dC03OC41IC01OS41cS0xMSAwIC0yMSA3bC0xMTUgOTBxLTM3IC0xOSAtNzcgLTMxcS0xMSAtMTA4IC0yMyAtMTU1cS03IC0yNCAtMzAgLTI0aC0xODZxLTExIDAgLTIwIDcuNXQtMTAgMTcuNQpsLTIzIDE1M3EtMzQgMTAgLTc1IDMxbC0xMTggLTg5cS03IC03IC0yMCAtN3EtMTEgMCAtMjEgOHEtMTQ0IDEzMyAtMTQ0IDE2MHEwIDkgNyAxOXExMCAxNCA0MSA1M3Q0NyA2MXEtMjMgNDQgLTM1IDgybC0xNTIgMjRxLTEwIDEgLTE3IDkuNXQtNyAxOS41djE4NXEwIDEwIDcgMTkuNXQxNiAxMC41bDE1NSAyNHExMSAzNSAzMiA3NnEtMzQgNDggLTkwIDExNXEtNyAxMSAtNyAyMHEwIDEyIDcgMjBxMjIgMzAgODIgODl0NzkgNTlxMTEgMCAyMSAtNwpsMTE1IC05MHEzNCAxOCA3NyAzMnExMSAxMDggMjMgMTU0cTcgMjQgMzAgMjRoMTg2cTExIDAgMjAgLTcuNXQxMCAtMTcuNWwyMyAtMTUzcTM0IC0xMCA3NSAtMzFsMTE4IDg5cTggNyAyMCA3cTExIDAgMjEgLThxMTQ0IC0xMzMgMTQ0IC0xNjBxMCAtOCAtNyAtMTlxLTEyIC0xNiAtNDIgLTU0dC00NSAtNjBxMjMgLTQ4IDM0IC04MmwxNTIgLTIzcTEwIC0yIDE3IC0xMC41dDcgLTE5LjV6TTE5MjAgMTk4di0xNDBxMCAtMTYgLTE0OSAtMzEKcS0xMiAtMjcgLTMwIC01MnE1MSAtMTEzIDUxIC0xMzhxMCAtNCAtNCAtN3EtMTIyIC03MSAtMTI0IC03MXEtOCAwIC00NiA0N3QtNTIgNjhxLTIwIC0yIC0zMCAtMnQtMzAgMnEtMTQgLTIxIC01MiAtNjh0LTQ2IC00N3EtMiAwIC0xMjQgNzFxLTQgMyAtNCA3cTAgMjUgNTEgMTM4cS0xOCAyNSAtMzAgNTJxLTE0OSAxNSAtMTQ5IDMxdjE0MHEwIDE2IDE0OSAzMXExMyAyOSAzMCA1MnEtNTEgMTEzIC01MSAxMzhxMCA0IDQgN3E0IDIgMzUgMjAKdDU5IDM0dDMwIDE2cTggMCA0NiAtNDYuNXQ1MiAtNjcuNXEyMCAyIDMwIDJ0MzAgLTJxNTEgNzEgOTIgMTEybDYgMnE0IDAgMTI0IC03MHE0IC0zIDQgLTdxMCAtMjUgLTUxIC0xMzhxMTcgLTIzIDMwIC01MnExNDkgLTE1IDE0OSAtMzF6TTE5MjAgMTIyMnYtMTQwcTAgLTE2IC0xNDkgLTMxcS0xMiAtMjcgLTMwIC01MnE1MSAtMTEzIDUxIC0xMzhxMCAtNCAtNCAtN3EtMTIyIC03MSAtMTI0IC03MXEtOCAwIC00NiA0N3QtNTIgNjgKcS0yMCAtMiAtMzAgLTJ0LTMwIDJxLTE0IC0yMSAtNTIgLTY4dC00NiAtNDdxLTIgMCAtMTI0IDcxcS00IDMgLTQgN3EwIDI1IDUxIDEzOHEtMTggMjUgLTMwIDUycS0xNDkgMTUgLTE0OSAzMXYxNDBxMCAxNiAxNDkgMzFxMTMgMjkgMzAgNTJxLTUxIDExMyAtNTEgMTM4cTAgNCA0IDdxNCAyIDM1IDIwdDU5IDM0dDMwIDE2cTggMCA0NiAtNDYuNXQ1MiAtNjcuNXEyMCAyIDMwIDJ0MzAgLTJxNTEgNzEgOTIgMTEybDYgMnE0IDAgMTI0IC03MApxNCAtMyA0IC03cTAgLTI1IC01MSAtMTM4cTE3IC0yMyAzMCAtNTJxMTQ5IC0xNSAxNDkgLTMxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjb21tZW50cyIgdW5pY29kZT0iJiN4ZjA4NjsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE0MDggNzY4cTAgLTEzOSAtOTQgLTI1N3QtMjU2LjUgLTE4Ni41dC0zNTMuNSAtNjguNXEtODYgMCAtMTc2IDE2cS0xMjQgLTg4IC0yNzggLTEyOHEtMzYgLTkgLTg2IC0xNmgtM3EtMTEgMCAtMjAuNSA4dC0xMS41IDIxcS0xIDMgLTEgNi41dDAuNSA2LjV0MiA2bDIuNSA1dDMuNSA1LjV0NCA1dDQuNSA1dDQgNC41cTUgNiAyMyAyNXQyNiAyOS41dDIyLjUgMjl0MjUgMzguNXQyMC41IDQ0cS0xMjQgNzIgLTE5NSAxNzd0LTcxIDIyNApxMCAxMzkgOTQgMjU3dDI1Ni41IDE4Ni41dDM1My41IDY4LjV0MzUzLjUgLTY4LjV0MjU2LjUgLTE4Ni41dDk0IC0yNTd6TTE3OTIgNTEycTAgLTEyMCAtNzEgLTIyNC41dC0xOTUgLTE3Ni41cTEwIC0yNCAyMC41IC00NHQyNSAtMzguNXQyMi41IC0yOXQyNiAtMjkuNXQyMyAtMjVxMSAtMSA0IC00LjV0NC41IC01dDQgLTV0My41IC01LjVsMi41IC01dDIgLTZ0MC41IC02LjV0LTEgLTYuNXEtMyAtMTQgLTEzIC0yMnQtMjIgLTcKcS01MCA3IC04NiAxNnEtMTU0IDQwIC0yNzggMTI4cS05MCAtMTYgLTE3NiAtMTZxLTI3MSAwIC00NzIgMTMycTU4IC00IDg4IC00cTE2MSAwIDMwOSA0NXQyNjQgMTI5cTEyNSA5MiAxOTIgMjEydDY3IDI1NHEwIDc3IC0yMyAxNTJxMTI5IC03MSAyMDQgLTE3OHQ3NSAtMjMweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ0aHVtYnNfdXBfYWx0IiB1bmljb2RlPSImI3hmMDg3OyIgCmQ9Ik0yNTYgMTkycTAgMjYgLTE5IDQ1dC00NSAxOXQtNDUgLTE5dC0xOSAtNDV0MTkgLTQ1dDQ1IC0xOXQ0NSAxOXQxOSA0NXpNMTQwOCA3NjhxMCA1MSAtMzkgODkuNXQtODkgMzguNWgtMzUycTAgNTggNDggMTU5LjV0NDggMTYwLjVxMCA5OCAtMzIgMTQ1dC0xMjggNDdxLTI2IC0yNiAtMzggLTg1dC0zMC41IC0xMjUuNXQtNTkuNSAtMTA5LjVxLTIyIC0yMyAtNzcgLTkxcS00IC01IC0yMyAtMzB0LTMxLjUgLTQxdC0zNC41IC00Mi41CnQtNDAgLTQ0dC0zOC41IC0zNS41dC00MCAtMjd0LTM1LjUgLTloLTMydi02NDBoMzJxMTMgMCAzMS41IC0zdDMzIC02LjV0MzggLTExdDM1IC0xMS41dDM1LjUgLTEyLjV0MjkgLTEwLjVxMjExIC03MyAzNDIgLTczaDEyMXExOTIgMCAxOTIgMTY3cTAgMjYgLTUgNTZxMzAgMTYgNDcuNSA1Mi41dDE3LjUgNzMuNXQtMTggNjlxNTMgNTAgNTMgMTE5cTAgMjUgLTEwIDU1LjV0LTI1IDQ3LjVxMzIgMSA1My41IDQ3dDIxLjUgODF6TTE1MzYgNzY5CnEwIC04OSAtNDkgLTE2M3E5IC0zMyA5IC02OXEwIC03NyAtMzggLTE0NHEzIC0yMSAzIC00M3EwIC0xMDEgLTYwIC0xNzhxMSAtMTM5IC04NSAtMjE5LjV0LTIyNyAtODAuNWgtMzZoLTkzcS05NiAwIC0xODkuNSAyMi41dC0yMTYuNSA2NS41cS0xMTYgNDAgLTEzOCA0MGgtMjg4cS01MyAwIC05MC41IDM3LjV0LTM3LjUgOTAuNXY2NDBxMCA1MyAzNy41IDkwLjV0OTAuNSAzNy41aDI3NHEzNiAyNCAxMzcgMTU1cTU4IDc1IDEwNyAxMjgKcTI0IDI1IDM1LjUgODUuNXQzMC41IDEyNi41dDYyIDEwOHEzOSAzNyA5MCAzN3E4NCAwIDE1MSAtMzIuNXQxMDIgLTEwMS41dDM1IC0xODZxMCAtOTMgLTQ4IC0xOTJoMTc2cTEwNCAwIDE4MCAtNzZ0NzYgLTE3OXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idGh1bWJzX2Rvd25fYWx0IiB1bmljb2RlPSImI3hmMDg4OyIgCmQ9Ik0yNTYgMTA4OHEwIDI2IC0xOSA0NXQtNDUgMTl0LTQ1IC0xOXQtMTkgLTQ1dDE5IC00NXQ0NSAtMTl0NDUgMTl0MTkgNDV6TTE0MDggNTEycTAgMzUgLTIxLjUgODF0LTUzLjUgNDdxMTUgMTcgMjUgNDcuNXQxMCA1NS41cTAgNjkgLTUzIDExOXExOCAzMSAxOCA2OXEwIDM3IC0xNy41IDczLjV0LTQ3LjUgNTIuNXE1IDMwIDUgNTZxMCA4NSAtNDkgMTI2dC0xMzYgNDFoLTEyOHEtMTMxIDAgLTM0MiAtNzNxLTUgLTIgLTI5IC0xMC41CnQtMzUuNSAtMTIuNXQtMzUgLTExLjV0LTM4IC0xMXQtMzMgLTYuNXQtMzEuNSAtM2gtMzJ2LTY0MGgzMnExNiAwIDM1LjUgLTl0NDAgLTI3dDM4LjUgLTM1LjV0NDAgLTQ0dDM0LjUgLTQyLjV0MzEuNSAtNDF0MjMgLTMwcTU1IC02OCA3NyAtOTFxNDEgLTQzIDU5LjUgLTEwOS41dDMwLjUgLTEyNS41dDM4IC04NXE5NiAwIDEyOCA0N3QzMiAxNDVxMCA1OSAtNDggMTYwLjV0LTQ4IDE1OS41aDM1MnE1MCAwIDg5IDM4LjV0MzkgODkuNXoKTTE1MzYgNTExcTAgLTEwMyAtNzYgLTE3OXQtMTgwIC03NmgtMTc2cTQ4IC05OSA0OCAtMTkycTAgLTExOCAtMzUgLTE4NnEtMzUgLTY5IC0xMDIgLTEwMS41dC0xNTEgLTMyLjVxLTUxIDAgLTkwIDM3cS0zNCAzMyAtNTQgODJ0LTI1LjUgOTAuNXQtMTcuNSA4NC41dC0zMSA2NHEtNDggNTAgLTEwNyAxMjdxLTEwMSAxMzEgLTEzNyAxNTVoLTI3NHEtNTMgMCAtOTAuNSAzNy41dC0zNy41IDkwLjV2NjQwcTAgNTMgMzcuNSA5MC41dDkwLjUgMzcuNQpoMjg4cTIyIDAgMTM4IDQwcTEyOCA0NCAyMjMgNjZ0MjAwIDIyaDExMnExNDAgMCAyMjYuNSAtNzl0ODUuNSAtMjE2di01cTYwIC03NyA2MCAtMTc4cTAgLTIyIC0zIC00M3EzOCAtNjcgMzggLTE0NHEwIC0zNiAtOSAtNjlxNDkgLTczIDQ5IC0xNjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InN0YXJfaGFsZiIgdW5pY29kZT0iJiN4ZjA4OTsiIGhvcml6LWFkdi14PSI4OTYiIApkPSJNODMyIDE1MDR2LTEzMzlsLTQ0OSAtMjM2cS0yMiAtMTIgLTQwIC0xMnEtMjEgMCAtMzEuNSAxNC41dC0xMC41IDM1LjVxMCA2IDIgMjBsODYgNTAwbC0zNjQgMzU0cS0yNSAyNyAtMjUgNDhxMCAzNyA1NiA0Nmw1MDIgNzNsMjI1IDQ1NXExOSA0MSA0OSA0MXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iaGVhcnRfZW1wdHkiIHVuaWNvZGU9IiYjeGYwOGE7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xNjY0IDk0MHEwIDgxIC0yMS41IDE0M3QtNTUgOTguNXQtODEuNSA1OS41dC05NCAzMXQtOTggOHQtMTEyIC0yNS41dC0xMTAuNSAtNjR0LTg2LjUgLTcydC02MCAtNjEuNXEtMTggLTIyIC00OSAtMjJ0LTQ5IDIycS0yNCAyOCAtNjAgNjEuNXQtODYuNSA3MnQtMTEwLjUgNjR0LTExMiAyNS41dC05OCAtOHQtOTQgLTMxdC04MS41IC01OS41dC01NSAtOTguNXQtMjEuNSAtMTQzcTAgLTE2OCAxODcgLTM1NWw1ODEgLTU2MGw1ODAgNTU5CnExODggMTg4IDE4OCAzNTZ6TTE3OTIgOTQwcTAgLTIyMSAtMjI5IC00NTBsLTYyMyAtNjAwcS0xOCAtMTggLTQ0IC0xOHQtNDQgMThsLTYyNCA2MDJxLTEwIDggLTI3LjUgMjZ0LTU1LjUgNjUuNXQtNjggOTcuNXQtNTMuNSAxMjF0LTIzLjUgMTM4cTAgMjIwIDEyNyAzNDR0MzUxIDEyNHE2MiAwIDEyNi41IC0yMS41dDEyMCAtNTh0OTUuNSAtNjguNXQ3NiAtNjhxMzYgMzYgNzYgNjh0OTUuNSA2OC41dDEyMCA1OHQxMjYuNSAyMS41CnEyMjQgMCAzNTEgLTEyNHQxMjcgLTM0NHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ic2lnbm91dCIgdW5pY29kZT0iJiN4ZjA4YjsiIGhvcml6LWFkdi14PSIxNjY0IiAKZD0iTTY0MCA5NnEwIC00IDEgLTIwdDAuNSAtMjYuNXQtMyAtMjMuNXQtMTAgLTE5LjV0LTIwLjUgLTYuNWgtMzIwcS0xMTkgMCAtMjAzLjUgODQuNXQtODQuNSAyMDMuNXY3MDRxMCAxMTkgODQuNSAyMDMuNXQyMDMuNSA4NC41aDMyMHExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjVxMCAtNCAxIC0yMHQwLjUgLTI2LjV0LTMgLTIzLjV0LTEwIC0xOS41dC0yMC41IC02LjVoLTMyMHEtNjYgMCAtMTEzIC00N3QtNDcgLTExM3YtNzA0CnEwIC02NiA0NyAtMTEzdDExMyAtNDdoMjg4aDExaDEzdDExLjUgLTF0MTEuNSAtM3Q4IC01LjV0NyAtOXQyIC0xMy41ek0xNTY4IDY0MHEwIC0yNiAtMTkgLTQ1bC01NDQgLTU0NHEtMTkgLTE5IC00NSAtMTl0LTQ1IDE5dC0xOSA0NXYyODhoLTQ0OHEtMjYgMCAtNDUgMTl0LTE5IDQ1djM4NHEwIDI2IDE5IDQ1dDQ1IDE5aDQ0OHYyODhxMCAyNiAxOSA0NXQ0NSAxOXQ0NSAtMTlsNTQ0IC01NDRxMTkgLTE5IDE5IC00NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibGlua2VkaW5fc2lnbiIgdW5pY29kZT0iJiN4ZjA4YzsiIApkPSJNMjM3IDEyMmgyMzF2Njk0aC0yMzF2LTY5NHpNNDgzIDEwMzBxLTEgNTIgLTM2IDg2dC05MyAzNHQtOTQuNSAtMzR0LTM2LjUgLTg2cTAgLTUxIDM1LjUgLTg1LjV0OTIuNSAtMzQuNWgxcTU5IDAgOTUgMzQuNXQzNiA4NS41ek0xMDY4IDEyMmgyMzF2Mzk4cTAgMTU0IC03MyAyMzN0LTE5MyA3OXEtMTM2IDAgLTIwOSAtMTE3aDJ2MTAxaC0yMzFxMyAtNjYgMCAtNjk0aDIzMXYzODhxMCAzOCA3IDU2cTE1IDM1IDQ1IDU5LjV0NzQgMjQuNQpxMTE2IDAgMTE2IC0xNTd2LTM3MXpNMTUzNiAxMTIwdi05NjBxMCAtMTE5IC04NC41IC0yMDMuNXQtMjAzLjUgLTg0LjVoLTk2MHEtMTE5IDAgLTIwMy41IDg0LjV0LTg0LjUgMjAzLjV2OTYwcTAgMTE5IDg0LjUgMjAzLjV0MjAzLjUgODQuNWg5NjBxMTE5IDAgMjAzLjUgLTg0LjV0ODQuNSAtMjAzLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InB1c2hwaW4iIHVuaWNvZGU9IiYjeGYwOGQ7IiBob3Jpei1hZHYteD0iMTE1MiIgCmQ9Ik00ODAgNjcydjQ0OHEwIDE0IC05IDIzdC0yMyA5dC0yMyAtOXQtOSAtMjN2LTQ0OHEwIC0xNCA5IC0yM3QyMyAtOXQyMyA5dDkgMjN6TTExNTIgMzIwcTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtNDI5bC01MSAtNDgzcS0yIC0xMiAtMTAuNSAtMjAuNXQtMjAuNSAtOC41aC0xcS0yNyAwIC0zMiAyN2wtNzYgNDg1aC00MDRxLTI2IDAgLTQ1IDE5dC0xOSA0NXEwIDEyMyA3OC41IDIyMS41dDE3Ny41IDk4LjV2NTEycS01MiAwIC05MCAzOAp0LTM4IDkwdDM4IDkwdDkwIDM4aDY0MHE1MiAwIDkwIC0zOHQzOCAtOTB0LTM4IC05MHQtOTAgLTM4di01MTJxOTkgMCAxNzcuNSAtOTguNXQ3OC41IC0yMjEuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZXh0ZXJuYWxfbGluayIgdW5pY29kZT0iJiN4ZjA4ZTsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE0MDggNjA4di0zMjBxMCAtMTE5IC04NC41IC0yMDMuNXQtMjAzLjUgLTg0LjVoLTgzMnEtMTE5IDAgLTIwMy41IDg0LjV0LTg0LjUgMjAzLjV2ODMycTAgMTE5IDg0LjUgMjAzLjV0MjAzLjUgODQuNWg3MDRxMTQgMCAyMyAtOXQ5IC0yM3YtNjRxMCAtMTQgLTkgLTIzdC0yMyAtOWgtNzA0cS02NiAwIC0xMTMgLTQ3dC00NyAtMTEzdi04MzJxMCAtNjYgNDcgLTExM3QxMTMgLTQ3aDgzMnE2NiAwIDExMyA0N3Q0NyAxMTN2MzIwCnEwIDE0IDkgMjN0MjMgOWg2NHExNCAwIDIzIC05dDkgLTIzek0xNzkyIDE0NzJ2LTUxMnEwIC0yNiAtMTkgLTQ1dC00NSAtMTl0LTQ1IDE5bC0xNzYgMTc2bC02NTIgLTY1MnEtMTAgLTEwIC0yMyAtMTB0LTIzIDEwbC0xMTQgMTE0cS0xMCAxMCAtMTAgMjN0MTAgMjNsNjUyIDY1MmwtMTc2IDE3NnEtMTkgMTkgLTE5IDQ1dDE5IDQ1dDQ1IDE5aDUxMnEyNiAwIDQ1IC0xOXQxOSAtNDV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InNpZ25pbiIgdW5pY29kZT0iJiN4ZjA5MDsiIApkPSJNMTE4NCA2NDBxMCAtMjYgLTE5IC00NWwtNTQ0IC01NDRxLTE5IC0xOSAtNDUgLTE5dC00NSAxOXQtMTkgNDV2Mjg4aC00NDhxLTI2IDAgLTQ1IDE5dC0xOSA0NXYzODRxMCAyNiAxOSA0NXQ0NSAxOWg0NDh2Mjg4cTAgMjYgMTkgNDV0NDUgMTl0NDUgLTE5bDU0NCAtNTQ0cTE5IC0xOSAxOSAtNDV6TTE1MzYgOTkydi03MDRxMCAtMTE5IC04NC41IC0yMDMuNXQtMjAzLjUgLTg0LjVoLTMyMHEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41CnEwIDQgLTEgMjB0LTAuNSAyNi41dDMgMjMuNXQxMCAxOS41dDIwLjUgNi41aDMyMHE2NiAwIDExMyA0N3Q0NyAxMTN2NzA0cTAgNjYgLTQ3IDExM3QtMTEzIDQ3aC0yODhoLTExaC0xM3QtMTEuNSAxdC0xMS41IDN0LTggNS41dC03IDl0LTIgMTMuNXEwIDQgLTEgMjB0LTAuNSAyNi41dDMgMjMuNXQxMCAxOS41dDIwLjUgNi41aDMyMHExMTkgMCAyMDMuNSAtODQuNXQ4NC41IC0yMDMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idHJvcGh5IiB1bmljb2RlPSImI3hmMDkxOyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNNDU4IDY1M3EtNzQgMTYyIC03NCAzNzFoLTI1NnYtOTZxMCAtNzggOTQuNSAtMTYydDIzNS41IC0xMTN6TTE1MzYgOTI4djk2aC0yNTZxMCAtMjA5IC03NCAtMzcxcTE0MSAyOSAyMzUuNSAxMTN0OTQuNSAxNjJ6TTE2NjQgMTA1NnYtMTI4cTAgLTcxIC00MS41IC0xNDN0LTExMiAtMTMwdC0xNzMgLTk3LjV0LTIxNS41IC00NC41cS00MiAtNTQgLTk1IC05NXEtMzggLTM0IC01Mi41IC03Mi41dC0xNC41IC04OS41cTAgLTU0IDMwLjUgLTkxCnQ5Ny41IC0zN3E3NSAwIDEzMy41IC00NS41dDU4LjUgLTExNC41di02NHEwIC0xNCAtOSAtMjN0LTIzIC05aC04MzJxLTE0IDAgLTIzIDl0LTkgMjN2NjRxMCA2OSA1OC41IDExNC41dDEzMy41IDQ1LjVxNjcgMCA5Ny41IDM3dDMwLjUgOTFxMCA1MSAtMTQuNSA4OS41dC01Mi41IDcyLjVxLTUzIDQxIC05NSA5NXEtMTEzIDUgLTIxNS41IDQ0LjV0LTE3MyA5Ny41dC0xMTIgMTMwdC00MS41IDE0M3YxMjhxMCA0MCAyOCA2OHQ2OCAyOGgyODh2OTYKcTAgNjYgNDcgMTEzdDExMyA0N2g1NzZxNjYgMCAxMTMgLTQ3dDQ3IC0xMTN2LTk2aDI4OHE0MCAwIDY4IC0yOHQyOCAtNjh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImdpdGh1Yl9zaWduIiB1bmljb2RlPSImI3hmMDkyOyIgCmQ9Ik01MTkgMzM2cTQgNiAtMyAxM3EtOSA3IC0xNCAycS00IC02IDMgLTEzcTkgLTcgMTQgLTJ6TTQ5MSAzNzdxLTUgNyAtMTIgNHEtNiAtNCAwIC0xMnE3IC04IDEyIC01cTYgNCAwIDEzek00NTAgNDE3cTIgNCAtNSA4cS03IDIgLTggLTJxLTMgLTUgNCAtOHE4IC0yIDkgMnpNNDcxIDM5NHEyIDEgMS41IDQuNXQtMy41IDUuNXEtNiA3IC0xMCAzdDEgLTExcTYgLTYgMTEgLTJ6TTU1NyAzMTlxMiA3IC05IDExcS05IDMgLTEzIC00CnEtMiAtNyA5IC0xMXE5IC0zIDEzIDR6TTU5OSAzMTZxMCA4IC0xMiA4cS0xMCAwIC0xMCAtOHQxMSAtOHQxMSA4ek02MzggMzIzcS0yIDcgLTEzIDV0LTkgLTlxMiAtOCAxMiAtNnQxMCAxMHpNMTI4MCA2NDBxMCAyMTIgLTE1MCAzNjJ0LTM2MiAxNTB0LTM2MiAtMTUwdC0xNTAgLTM2MnEwIC0xNjcgOTggLTMwMC41dDI1MiAtMTg1LjVxMTggLTMgMjYuNSA1dDguNSAyMHEwIDUyIC0xIDk1cS02IC0xIC0xNS41IC0yLjV0LTM1LjUgLTJ0LTQ4IDQKdC00My41IDIwdC0yOS41IDQxLjVxLTIzIDU5IC01NyA3NHEtMiAxIC00LjUgMy41bC04IDh0LTcgOS41dDQgNy41dDE5LjUgMy41cTYgMCAxNSAtMnQzMCAtMTUuNXQzMyAtMzUuNXExNiAtMjggMzcuNSAtNDJ0NDMuNSAtMTR0MzggMy41dDMwIDkuNXE3IDQ3IDMzIDY5cS00OSA2IC04NiAxOC41dC03MyAzOXQtNTUuNSA3NnQtMTkuNSAxMTkuNXEwIDc5IDUzIDEzN3EtMjQgNjIgNSAxMzZxMTkgNiA1NC41IC03LjV0NjAuNSAtMjkuNWwyNiAtMTYKcTU4IDE3IDEyOCAxN3QxMjggLTE3cTExIDcgMjguNSAxOHQ1NS41IDI2dDU3IDlxMjkgLTc0IDUgLTEzNnE1MyAtNTggNTMgLTEzN3EwIC01NyAtMTQgLTEwMC41dC0zNS41IC03MHQtNTMuNSAtNDQuNXQtNjIuNSAtMjZ0LTY4LjUgLTEycTM1IC0zMSAzNSAtOTVxMCAtNDAgLTAuNSAtODl0LTAuNSAtNTFxMCAtMTIgOC41IC0yMHQyNi41IC01cTE1NCA1MiAyNTIgMTg1LjV0OTggMzAwLjV6TTE1MzYgMTEyMHYtOTYwCnEwIC0xMTkgLTg0LjUgLTIwMy41dC0yMDMuNSAtODQuNWgtOTYwcS0xMTkgMCAtMjAzLjUgODQuNXQtODQuNSAyMDMuNXY5NjBxMCAxMTkgODQuNSAyMDMuNXQyMDMuNSA4NC41aDk2MHExMTkgMCAyMDMuNSAtODQuNXQ4NC41IC0yMDMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idXBsb2FkX2FsdCIgdW5pY29kZT0iJiN4ZjA5MzsiIGhvcml6LWFkdi14PSIxNjY0IiAKZD0iTTEyODAgNjRxMCAyNiAtMTkgNDV0LTQ1IDE5dC00NSAtMTl0LTE5IC00NXQxOSAtNDV0NDUgLTE5dDQ1IDE5dDE5IDQ1ek0xNTM2IDY0cTAgMjYgLTE5IDQ1dC00NSAxOXQtNDUgLTE5dC0xOSAtNDV0MTkgLTQ1dDQ1IC0xOXQ0NSAxOXQxOSA0NXpNMTY2NCAyODh2LTMyMHEwIC00MCAtMjggLTY4dC02OCAtMjhoLTE0NzJxLTQwIDAgLTY4IDI4dC0yOCA2OHYzMjBxMCA0MCAyOCA2OHQ2OCAyOGg0MjdxMjEgLTU2IDcwLjUgLTkyCnQxMTAuNSAtMzZoMjU2cTYxIDAgMTEwLjUgMzZ0NzAuNSA5Mmg0MjdxNDAgMCA2OCAtMjh0MjggLTY4ek0xMzM5IDkzNnEtMTcgLTQwIC01OSAtNDBoLTI1NnYtNDQ4cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtMjU2cS0yNiAwIC00NSAxOXQtMTkgNDV2NDQ4aC0yNTZxLTQyIDAgLTU5IDQwcS0xNyAzOSAxNCA2OWw0NDggNDQ4cTE4IDE5IDQ1IDE5dDQ1IC0xOWw0NDggLTQ0OHEzMSAtMzAgMTQgLTY5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJsZW1vbiIgdW5pY29kZT0iJiN4ZjA5NDsiIApkPSJNMTQwNyA3MTBxMCA0NCAtNyAxMTMuNXQtMTggOTYuNXEtMTIgMzAgLTE3IDQ0dC05IDM2LjV0LTQgNDguNXEwIDIzIDUgNjguNXQ1IDY3LjVxMCAzNyAtMTAgNTVxLTQgMSAtMTMgMXEtMTkgMCAtNTggLTQuNXQtNTkgLTQuNXEtNjAgMCAtMTc2IDI0dC0xNzUgMjRxLTQzIDAgLTk0LjUgLTExLjV0LTg1IC0yMy41dC04OS41IC0zNHEtMTM3IC01NCAtMjAyIC0xMDNxLTk2IC03MyAtMTU5LjUgLTE4OS41dC04OCAtMjM2dC0yNC41IC0yNDguNQpxMCAtNDAgMTIuNSAtMTIwdDEyLjUgLTEyMXEwIC0yMyAtMTEgLTY2LjV0LTExIC02NS41dDEyIC0zNi41dDM0IC0xNC41cTI0IDAgNzIuNSAxMXQ3My41IDExcTU3IDAgMTY5LjUgLTE1LjV0MTY5LjUgLTE1LjVxMTgxIDAgMjg0IDM2cTEyOSA0NSAyMzUuNSAxNTIuNXQxNjYgMjQ1LjV0NTkuNSAyNzV6TTE1MzUgNzEycTAgLTE2NSAtNzAgLTMyNy41dC0xOTYgLTI4OHQtMjgxIC0xODAuNXEtMTI0IC00NCAtMzI2IC00NApxLTU3IDAgLTE3MCAxNC41dC0xNjkgMTQuNXEtMjQgMCAtNzIuNSAtMTQuNXQtNzMuNSAtMTQuNXEtNzMgMCAtMTIzLjUgNTUuNXQtNTAuNSAxMjguNXEwIDI0IDExIDY4dDExIDY3cTAgNDAgLTEyLjUgMTIwLjV0LTEyLjUgMTIxLjVxMCAxMTEgMTggMjE3LjV0NTQuNSAyMDkuNXQxMDAuNSAxOTR0MTUwIDE1NnE3OCA1OSAyMzIgMTIwcTE5NCA3OCAzMTYgNzhxNjAgMCAxNzUuNSAtMjR0MTczLjUgLTI0cTE5IDAgNTcgNXQ1OCA1CnE4MSAwIDExOCAtNTAuNXQzNyAtMTM0LjVxMCAtMjMgLTUgLTY4dC01IC02OHEwIC0xMyAyIC0yNXQzLjUgLTE2LjV0Ny41IC0yMC41dDggLTIwcTE2IC00MCAyNSAtMTE4LjV0OSAtMTM2LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InBob25lIiB1bmljb2RlPSImI3hmMDk1OyIgaG9yaXotYWR2LXg9IjE0MDgiIApkPSJNMTQwOCAyOTZxMCAtMjcgLTEwIC03MC41dC0yMSAtNjguNXEtMjEgLTUwIC0xMjIgLTEwNnEtOTQgLTUxIC0xODYgLTUxcS0yNyAwIC01MyAzLjV0LTU3LjUgMTIuNXQtNDcgMTQuNXQtNTUuNSAyMC41dC00OSAxOHEtOTggMzUgLTE3NSA4M3EtMTI3IDc5IC0yNjQgMjE2dC0yMTYgMjY0cS00OCA3NyAtODMgMTc1cS0zIDkgLTE4IDQ5dC0yMC41IDU1LjV0LTE0LjUgNDd0LTEyLjUgNTcuNXQtMy41IDUzcTAgOTIgNTEgMTg2CnE1NiAxMDEgMTA2IDEyMnEyNSAxMSA2OC41IDIxdDcwLjUgMTBxMTQgMCAyMSAtM3ExOCAtNiA1MyAtNzZxMTEgLTE5IDMwIC01NHQzNSAtNjMuNXQzMSAtNTMuNXEzIC00IDE3LjUgLTI1dDIxLjUgLTM1LjV0NyAtMjguNXEwIC0yMCAtMjguNSAtNTB0LTYyIC01NXQtNjIgLTUzdC0yOC41IC00NnEwIC05IDUgLTIyLjV0OC41IC0yMC41dDE0IC0yNHQxMS41IC0xOXE3NiAtMTM3IDE3NCAtMjM1dDIzNSAtMTc0cTIgLTEgMTkgLTExLjV0MjQgLTE0CnQyMC41IC04LjV0MjIuNSAtNXExOCAwIDQ2IDI4LjV0NTMgNjJ0NTUgNjJ0NTAgMjguNXExNCAwIDI4LjUgLTd0MzUuNSAtMjEuNXQyNSAtMTcuNXEyNSAtMTUgNTMuNSAtMzF0NjMuNSAtMzV0NTQgLTMwcTcwIC0zNSA3NiAtNTNxMyAtNyAzIC0yMXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY2hlY2tfZW1wdHkiIHVuaWNvZGU9IiYjeGYwOTY7IiBob3Jpei1hZHYteD0iMTQwOCIgCmQ9Ik0xMTIwIDEyODBoLTgzMnEtNjYgMCAtMTEzIC00N3QtNDcgLTExM3YtODMycTAgLTY2IDQ3IC0xMTN0MTEzIC00N2g4MzJxNjYgMCAxMTMgNDd0NDcgMTEzdjgzMnEwIDY2IC00NyAxMTN0LTExMyA0N3pNMTQwOCAxMTIwdi04MzJxMCAtMTE5IC04NC41IC0yMDMuNXQtMjAzLjUgLTg0LjVoLTgzMnEtMTE5IDAgLTIwMy41IDg0LjV0LTg0LjUgMjAzLjV2ODMycTAgMTE5IDg0LjUgMjAzLjV0MjAzLjUgODQuNWg4MzIKcTExOSAwIDIwMy41IC04NC41dDg0LjUgLTIwMy41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJib29rbWFya19lbXB0eSIgdW5pY29kZT0iJiN4ZjA5NzsiIGhvcml6LWFkdi14PSIxMjgwIiAKZD0iTTExNTIgMTI4MGgtMTAyNHYtMTI0Mmw0MjMgNDA2bDg5IDg1bDg5IC04NWw0MjMgLTQwNnYxMjQyek0xMTY0IDE0MDhxMjMgMCA0NCAtOXEzMyAtMTMgNTIuNSAtNDF0MTkuNSAtNjJ2LTEyODlxMCAtMzQgLTE5LjUgLTYydC01Mi41IC00MXEtMTkgLTggLTQ0IC04cS00OCAwIC04MyAzMmwtNDQxIDQyNGwtNDQxIC00MjRxLTM2IC0zMyAtODMgLTMzcS0yMyAwIC00NCA5cS0zMyAxMyAtNTIuNSA0MXQtMTkuNSA2MnYxMjg5CnEwIDM0IDE5LjUgNjJ0NTIuNSA0MXEyMSA5IDQ0IDloMTA0OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icGhvbmVfc2lnbiIgdW5pY29kZT0iJiN4ZjA5ODsiIApkPSJNMTI4MCAzNDNxMCAxMSAtMiAxNnQtMTggMTYuNXQtNDAuNSAyNXQtNDcuNSAyNi41dC00NS41IDI1dC0yOC41IDE1cS01IDMgLTE5IDEzdC0yNSAxNXQtMjEgNXEtMTUgMCAtMzYuNSAtMjAuNXQtMzkuNSAtNDV0LTM4LjUgLTQ1dC0zMy41IC0yMC41cS03IDAgLTE2LjUgMy41dC0xNS41IDYuNXQtMTcgOS41dC0xNCA4LjVxLTk5IDU1IC0xNzAgMTI2LjV0LTEyNyAxNzAuNXEtMiAzIC04LjUgMTR0LTkuNSAxN3QtNi41IDE1LjUKdC0zLjUgMTYuNXEwIDEzIDIwLjUgMzMuNXQ0NSAzOC41dDQ1IDM5LjV0MjAuNSAzNi41cTAgMTAgLTUgMjF0LTE1IDI1dC0xMyAxOXEtMyA2IC0xNSAyOC41dC0yNSA0NS41dC0yNi41IDQ3LjV0LTI1IDQwLjV0LTE2LjUgMTh0LTE2IDJxLTQ4IDAgLTEwMSAtMjJxLTQ2IC0yMSAtODAgLTk0LjV0LTM0IC0xMzAuNXEwIC0xNiAyLjUgLTM0dDUgLTMwLjV0OSAtMzN0MTAgLTI5LjV0MTIuNSAtMzN0MTEgLTMwcTYwIC0xNjQgMjE2LjUgLTMyMC41CnQzMjAuNSAtMjE2LjVxNiAtMiAzMCAtMTF0MzMgLTEyLjV0MjkuNSAtMTB0MzMgLTl0MzAuNSAtNXQzNCAtMi41cTU3IDAgMTMwLjUgMzR0OTQuNSA4MHEyMiA1MyAyMiAxMDF6TTE1MzYgMTEyMHYtOTYwcTAgLTExOSAtODQuNSAtMjAzLjV0LTIwMy41IC04NC41aC05NjBxLTExOSAwIC0yMDMuNSA4NC41dC04NC41IDIwMy41djk2MHEwIDExOSA4NC41IDIwMy41dDIwMy41IDg0LjVoOTYwcTExOSAwIDIwMy41IC04NC41dDg0LjUgLTIwMy41egoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idHdpdHRlciIgdW5pY29kZT0iJiN4ZjA5OTsiIGhvcml6LWFkdi14PSIxNjY0IiAKZD0iTTE2MjAgMTEyOHEtNjcgLTk4IC0xNjIgLTE2N3ExIC0xNCAxIC00MnEwIC0xMzAgLTM4IC0yNTkuNXQtMTE1LjUgLTI0OC41dC0xODQuNSAtMjEwLjV0LTI1OCAtMTQ2dC0zMjMgLTU0LjVxLTI3MSAwIC00OTYgMTQ1cTM1IC00IDc4IC00cTIyNSAwIDQwMSAxMzhxLTEwNSAyIC0xODggNjQuNXQtMTE0IDE1OS41cTMzIC01IDYxIC01cTQzIDAgODUgMTFxLTExMiAyMyAtMTg1LjUgMTExLjV0LTczLjUgMjA1LjV2NHE2OCAtMzggMTQ2IC00MQpxLTY2IDQ0IC0xMDUgMTE1dC0zOSAxNTRxMCA4OCA0NCAxNjNxMTIxIC0xNDkgMjk0LjUgLTIzOC41dDM3MS41IC05OS41cS04IDM4IC04IDc0cTAgMTM0IDk0LjUgMjI4LjV0MjI4LjUgOTQuNXExNDAgMCAyMzYgLTEwMnExMDkgMjEgMjA1IDc4cS0zNyAtMTE1IC0xNDIgLTE3OHE5MyAxMCAxODYgNTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImZhY2Vib29rIiB1bmljb2RlPSImI3hmMDlhOyIgaG9yaXotYWR2LXg9IjEwMjQiIApkPSJNOTU5IDE1MjR2LTI2NGgtMTU3cS04NiAwIC0xMTYgLTM2dC0zMCAtMTA4di0xODloMjkzbC0zOSAtMjk2aC0yNTR2LTc1OWgtMzA2djc1OWgtMjU1djI5NmgyNTV2MjE4cTAgMTg2IDEwNCAyODguNXQyNzcgMTAyLjVxMTQ3IDAgMjI4IC0xMnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZ2l0aHViIiB1bmljb2RlPSImI3hmMDliOyIgCmQ9Ik03NjggMTQwOHEyMDkgMCAzODUuNSAtMTAzdDI3OS41IC0yNzkuNXQxMDMgLTM4NS41cTAgLTI1MSAtMTQ2LjUgLTQ1MS41dC0zNzguNSAtMjc3LjVxLTI3IC01IC00MCA3dC0xMyAzMHEwIDMgMC41IDc2LjV0MC41IDEzNC41cTAgOTcgLTUyIDE0MnE1NyA2IDEwMi41IDE4dDk0IDM5dDgxIDY2LjV0NTMgMTA1dDIwLjUgMTUwLjVxMCAxMTkgLTc5IDIwNnEzNyA5MSAtOCAyMDRxLTI4IDkgLTgxIC0xMXQtOTIgLTQ0bC0zOCAtMjQKcS05MyAyNiAtMTkyIDI2dC0xOTIgLTI2cS0xNiAxMSAtNDIuNSAyN3QtODMuNSAzOC41dC04NSAxMy41cS00NSAtMTEzIC04IC0yMDRxLTc5IC04NyAtNzkgLTIwNnEwIC04NSAyMC41IC0xNTB0NTIuNSAtMTA1dDgwLjUgLTY3dDk0IC0zOXQxMDIuNSAtMThxLTM5IC0zNiAtNDkgLTEwM3EtMjEgLTEwIC00NSAtMTV0LTU3IC01dC02NS41IDIxLjV0LTU1LjUgNjIuNXEtMTkgMzIgLTQ4LjUgNTJ0LTQ5LjUgMjRsLTIwIDNxLTIxIDAgLTI5IC00LjUKdC01IC0xMS41dDkgLTE0dDEzIC0xMmw3IC01cTIyIC0xMCA0My41IC0zOHQzMS41IC01MWwxMCAtMjNxMTMgLTM4IDQ0IC02MS41dDY3IC0zMHQ2OS41IC03dDU1LjUgMy41bDIzIDRxMCAtMzggMC41IC04OC41dDAuNSAtNTQuNXEwIC0xOCAtMTMgLTMwdC00MCAtN3EtMjMyIDc3IC0zNzguNSAyNzcuNXQtMTQ2LjUgNDUxLjVxMCAyMDkgMTAzIDM4NS41dDI3OS41IDI3OS41dDM4NS41IDEwM3pNMjkxIDMwNXEzIDcgLTcgMTIKcS0xMCAzIC0xMyAtMnEtMyAtNyA3IC0xMnE5IC02IDEzIDJ6TTMyMiAyNzFxNyA1IC0yIDE2cS0xMCA5IC0xNiAzcS03IC01IDIgLTE2cTEwIC0xMCAxNiAtM3pNMzUyIDIyNnE5IDcgMCAxOXEtOCAxMyAtMTcgNnEtOSAtNSAwIC0xOHQxNyAtN3pNMzk0IDE4NHE4IDggLTQgMTlxLTEyIDEyIC0yMCAzcS05IC04IDQgLTE5cTEyIC0xMiAyMCAtM3pNNDUxIDE1OXEzIDExIC0xMyAxNnEtMTUgNCAtMTkgLTd0MTMgLTE1cTE1IC02IDE5IDZ6Ck01MTQgMTU0cTAgMTMgLTE3IDExcS0xNiAwIC0xNiAtMTFxMCAtMTMgMTcgLTExcTE2IDAgMTYgMTF6TTU3MiAxNjRxLTIgMTEgLTE4IDlxLTE2IC0zIC0xNCAtMTV0MTggLTh0MTQgMTR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVubG9jayIgdW5pY29kZT0iJiN4ZjA5YzsiIGhvcml6LWFkdi14PSIxNjY0IiAKZD0iTTE2NjQgOTYwdi0yNTZxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC02NHEtMjYgMCAtNDUgMTl0LTE5IDQ1djI1NnEwIDEwNiAtNzUgMTgxdC0xODEgNzV0LTE4MSAtNzV0LTc1IC0xODF2LTE5Mmg5NnE0MCAwIDY4IC0yOHQyOCAtNjh2LTU3NnEwIC00MCAtMjggLTY4dC02OCAtMjhoLTk2MHEtNDAgMCAtNjggMjh0LTI4IDY4djU3NnEwIDQwIDI4IDY4dDY4IDI4aDY3MnYxOTJxMCAxODUgMTMxLjUgMzE2LjV0MzE2LjUgMTMxLjUKdDMxNi41IC0xMzEuNXQxMzEuNSAtMzE2LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNyZWRpdF9jYXJkIiB1bmljb2RlPSImI3hmMDlkOyIgaG9yaXotYWR2LXg9IjE5MjAiIApkPSJNMTc2MCAxNDA4cTY2IDAgMTEzIC00N3Q0NyAtMTEzdi0xMjE2cTAgLTY2IC00NyAtMTEzdC0xMTMgLTQ3aC0xNjAwcS02NiAwIC0xMTMgNDd0LTQ3IDExM3YxMjE2cTAgNjYgNDcgMTEzdDExMyA0N2gxNjAwek0xNjAgMTI4MHEtMTMgMCAtMjIuNSAtOS41dC05LjUgLTIyLjV2LTIyNGgxNjY0djIyNHEwIDEzIC05LjUgMjIuNXQtMjIuNSA5LjVoLTE2MDB6TTE3NjAgMHExMyAwIDIyLjUgOS41dDkuNSAyMi41djYwOGgtMTY2NHYtNjA4CnEwIC0xMyA5LjUgLTIyLjV0MjIuNSAtOS41aDE2MDB6TTI1NiAxMjh2MTI4aDI1NnYtMTI4aC0yNTZ6TTY0MCAxMjh2MTI4aDM4NHYtMTI4aC0zODR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InJzcyIgdW5pY29kZT0iJiN4ZjA5ZTsiIGhvcml6LWFkdi14PSIxNDA4IiAKZD0iTTM4NCAxOTJxMCAtODAgLTU2IC0xMzZ0LTEzNiAtNTZ0LTEzNiA1NnQtNTYgMTM2dDU2IDEzNnQxMzYgNTZ0MTM2IC01NnQ1NiAtMTM2ek04OTYgNjlxMiAtMjggLTE3IC00OHEtMTggLTIxIC00NyAtMjFoLTEzNXEtMjUgMCAtNDMgMTYuNXQtMjAgNDEuNXEtMjIgMjI5IC0xODQuNSAzOTEuNXQtMzkxLjUgMTg0LjVxLTI1IDIgLTQxLjUgMjB0LTE2LjUgNDN2MTM1cTAgMjkgMjEgNDdxMTcgMTcgNDMgMTdoNXExNjAgLTEzIDMwNiAtODAuNQp0MjU5IC0xODEuNXExMTQgLTExMyAxODEuNSAtMjU5dDgwLjUgLTMwNnpNMTQwOCA2N3EyIC0yNyAtMTggLTQ3cS0xOCAtMjAgLTQ2IC0yMGgtMTQzcS0yNiAwIC00NC41IDE3LjV0LTE5LjUgNDIuNXEtMTIgMjE1IC0xMDEgNDA4LjV0LTIzMS41IDMzNnQtMzM2IDIzMS41dC00MDguNSAxMDJxLTI1IDEgLTQyLjUgMTkuNXQtMTcuNSA0My41djE0M3EwIDI4IDIwIDQ2cTE4IDE4IDQ0IDE4aDNxMjYyIC0xMyA1MDEuNSAtMTIwdDQyNS41IC0yOTQKcTE4NyAtMTg2IDI5NCAtNDI1LjV0MTIwIC01MDEuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iaGRkIiB1bmljb2RlPSImI3hmMGEwOyIgCmQ9Ik0xMDQwIDMyMHEwIC0zMyAtMjMuNSAtNTYuNXQtNTYuNSAtMjMuNXQtNTYuNSAyMy41dC0yMy41IDU2LjV0MjMuNSA1Ni41dDU2LjUgMjMuNXQ1Ni41IC0yMy41dDIzLjUgLTU2LjV6TTEyOTYgMzIwcTAgLTMzIC0yMy41IC01Ni41dC01Ni41IC0yMy41dC01Ni41IDIzLjV0LTIzLjUgNTYuNXQyMy41IDU2LjV0NTYuNSAyMy41dDU2LjUgLTIzLjV0MjMuNSAtNTYuNXpNMTQwOCAxNjB2MzIwcTAgMTMgLTkuNSAyMi41dC0yMi41IDkuNQpoLTEyMTZxLTEzIDAgLTIyLjUgLTkuNXQtOS41IC0yMi41di0zMjBxMCAtMTMgOS41IC0yMi41dDIyLjUgLTkuNWgxMjE2cTEzIDAgMjIuNSA5LjV0OS41IDIyLjV6TTE3OCA2NDBoMTE4MGwtMTU3IDQ4MnEtNCAxMyAtMTYgMjEuNXQtMjYgOC41aC03ODJxLTE0IDAgLTI2IC04LjV0LTE2IC0yMS41ek0xNTM2IDQ4MHYtMzIwcTAgLTY2IC00NyAtMTEzdC0xMTMgLTQ3aC0xMjE2cS02NiAwIC0xMTMgNDd0LTQ3IDExM3YzMjBxMCAyNSAxNiA3NQpsMTk3IDYwNnExNyA1MyA2MyA4NnQxMDEgMzNoNzgycTU1IDAgMTAxIC0zM3Q2MyAtODZsMTk3IC02MDZxMTYgLTUwIDE2IC03NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYnVsbGhvcm4iIHVuaWNvZGU9IiYjeGYwYTE7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xNjY0IDg5NnE1MyAwIDkwLjUgLTM3LjV0MzcuNSAtOTAuNXQtMzcuNSAtOTAuNXQtOTAuNSAtMzcuNXYtMzg0cTAgLTUyIC0zOCAtOTB0LTkwIC0zOHEtNDE3IDM0NyAtODEyIDM4MHEtNTggLTE5IC05MSAtNjZ0LTMxIC0xMDAuNXQ0MCAtOTIuNXEtMjAgLTMzIC0yMyAtNjUuNXQ2IC01OHQzMy41IC01NXQ0OCAtNTB0NjEuNSAtNTAuNXEtMjkgLTU4IC0xMTEuNSAtODN0LTE2OC41IC0xMS41dC0xMzIgNTUuNXEtNyAyMyAtMjkuNSA4Ny41CnQtMzIgOTQuNXQtMjMgODl0LTE1IDEwMXQzLjUgOTguNXQyMiAxMTAuNWgtMTIycS02NiAwIC0xMTMgNDd0LTQ3IDExM3YxOTJxMCA2NiA0NyAxMTN0MTEzIDQ3aDQ4MHE0MzUgMCA4OTYgMzg0cTUyIDAgOTAgLTM4dDM4IC05MHYtMzg0ek0xNTM2IDI5MnY5NTRxLTM5NCAtMzAyIC03NjggLTM0M3YtMjcwcTM3NyAtNDIgNzY4IC0zNDF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImJlbGwiIHVuaWNvZGU9IiYjeGYwYTI7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik05MTIgLTE2MHEwIDE2IC0xNiAxNnEtNTkgMCAtMTAxLjUgNDIuNXQtNDIuNSAxMDEuNXEwIDE2IC0xNiAxNnQtMTYgLTE2cTAgLTczIDUxLjUgLTEyNC41dDEyNC41IC01MS41cTE2IDAgMTYgMTZ6TTI0NiAxMjhoMTMwMHEtMjY2IDMwMCAtMjY2IDgzMnEwIDUxIC0yNCAxMDV0LTY5IDEwM3QtMTIxLjUgODAuNXQtMTY5LjUgMzEuNXQtMTY5LjUgLTMxLjV0LTEyMS41IC04MC41dC02OSAtMTAzdC0yNCAtMTA1cTAgLTUzMiAtMjY2IC04MzJ6Ck0xNzI4IDEyOHEwIC01MiAtMzggLTkwdC05MCAtMzhoLTQ0OHEwIC0xMDYgLTc1IC0xODF0LTE4MSAtNzV0LTE4MSA3NXQtNzUgMTgxaC00NDhxLTUyIDAgLTkwIDM4dC0zOCA5MHE1MCA0MiA5MSA4OHQ4NSAxMTkuNXQ3NC41IDE1OC41dDUwIDIwNnQxOS41IDI2MHEwIDE1MiAxMTcgMjgyLjV0MzA3IDE1OC41cS04IDE5IC04IDM5cTAgNDAgMjggNjh0NjggMjh0NjggLTI4dDI4IC02OHEwIC0yMCAtOCAtMzlxMTkwIC0yOCAzMDcgLTE1OC41CnQxMTcgLTI4Mi41cTAgLTEzOSAxOS41IC0yNjB0NTAgLTIwNnQ3NC41IC0xNTguNXQ4NSAtMTE5LjV0OTEgLTg4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjZXJ0aWZpY2F0ZSIgdW5pY29kZT0iJiN4ZjBhMzsiIApkPSJNMTM3NiA2NDBsMTM4IC0xMzVxMzAgLTI4IDIwIC03MHEtMTIgLTQxIC01MiAtNTFsLTE4OCAtNDhsNTMgLTE4NnExMiAtNDEgLTE5IC03MHEtMjkgLTMxIC03MCAtMTlsLTE4NiA1M2wtNDggLTE4OHEtMTAgLTQwIC01MSAtNTJxLTEyIC0yIC0xOSAtMnEtMzEgMCAtNTEgMjJsLTEzNSAxMzhsLTEzNSAtMTM4cS0yOCAtMzAgLTcwIC0yMHEtNDEgMTEgLTUxIDUybC00OCAxODhsLTE4NiAtNTNxLTQxIC0xMiAtNzAgMTlxLTMxIDI5IC0xOSA3MApsNTMgMTg2bC0xODggNDhxLTQwIDEwIC01MiA1MXEtMTAgNDIgMjAgNzBsMTM4IDEzNWwtMTM4IDEzNXEtMzAgMjggLTIwIDcwcTEyIDQxIDUyIDUxbDE4OCA0OGwtNTMgMTg2cS0xMiA0MSAxOSA3MHEyOSAzMSA3MCAxOWwxODYgLTUzbDQ4IDE4OHExMCA0MSA1MSA1MXE0MSAxMiA3MCAtMTlsMTM1IC0xMzlsMTM1IDEzOXEyOSAzMCA3MCAxOXE0MSAtMTAgNTEgLTUxbDQ4IC0xODhsMTg2IDUzcTQxIDEyIDcwIC0xOXEzMSAtMjkgMTkgLTcwCmwtNTMgLTE4NmwxODggLTQ4cTQwIC0xMCA1MiAtNTFxMTAgLTQyIC0yMCAtNzB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImhhbmRfcmlnaHQiIHVuaWNvZGU9IiYjeGYwYTQ7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0yNTYgMTkycTAgMjYgLTE5IDQ1dC00NSAxOXQtNDUgLTE5dC0xOSAtNDV0MTkgLTQ1dDQ1IC0xOXQ0NSAxOXQxOSA0NXpNMTY2NCA3NjhxMCA1MSAtMzkgODkuNXQtODkgMzguNWgtNTc2cTAgMjAgMTUgNDguNXQzMyA1NXQzMyA2OHQxNSA4NC41cTAgNjcgLTQ0LjUgOTcuNXQtMTE1LjUgMzAuNXEtMjQgMCAtOTAgLTEzOXEtMjQgLTQ0IC0zNyAtNjVxLTQwIC02NCAtMTEyIC0xNDVxLTcxIC04MSAtMTAxIC0xMDYKcS02OSAtNTcgLTE0MCAtNTdoLTMydi02NDBoMzJxNzIgMCAxNjcgLTMydDE5My41IC02NHQxNzkuNSAtMzJxMTg5IDAgMTg5IDE2N3EwIDI2IC01IDU2cTMwIDE2IDQ3LjUgNTIuNXQxNy41IDczLjV0LTE4IDY5cTUzIDUwIDUzIDExOXEwIDI1IC0xMCA1NS41dC0yNSA0Ny41aDMzMXE1MiAwIDkwIDM4dDM4IDkwek0xNzkyIDc2OXEwIC0xMDUgLTc1LjUgLTE4MXQtMTgwLjUgLTc2aC0xNjlxLTQgLTYyIC0zNyAtMTE5cTMgLTIxIDMgLTQzCnEwIC0xMDEgLTYwIC0xNzhxMSAtMTM5IC04NSAtMjE5LjV0LTIyNyAtODAuNXEtMTMzIDAgLTMyMiA2OXEtMTY0IDU5IC0yMjMgNTloLTI4OHEtNTMgMCAtOTAuNSAzNy41dC0zNy41IDkwLjV2NjQwcTAgNTMgMzcuNSA5MC41dDkwLjUgMzcuNWgyODhxMTAgMCAyMS41IDQuNXQyMy41IDE0dDIyLjUgMTh0MjQgMjIuNXQyMC41IDIxLjV0MTkgMjEuNXQxNCAxN3E2NSA3NCAxMDAgMTI5cTEzIDIxIDMzIDYydDM3IDcydDQwLjUgNjN0NTUgNDkuNQp0NjkuNSAxNy41cTEyNSAwIDIwNi41IC02N3Q4MS41IC0xODlxMCAtNjggLTIyIC0xMjhoMzc0cTEwNCAwIDE4MCAtNzZ0NzYgLTE3OXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iaGFuZF9sZWZ0IiB1bmljb2RlPSImI3hmMGE1OyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTM3NiAxMjhoMzJ2NjQwaC0zMnEtMzUgMCAtNjcuNSAxMnQtNjIuNSAzN3QtNTAgNDZ0LTQ5IDU0cS04IDkgLTEyIDE0cS03MiA4MSAtMTEyIDE0NXEtMTQgMjIgLTM4IDY4cS0xIDMgLTEwLjUgMjIuNXQtMTguNSAzNnQtMjAgMzUuNXQtMjEuNSAzMC41dC0xOC41IDExLjVxLTcxIDAgLTExNS41IC0zMC41dC00NC41IC05Ny41cTAgLTQzIDE1IC04NC41dDMzIC02OHQzMyAtNTV0MTUgLTQ4LjVoLTU3NnEtNTAgMCAtODkgLTM4LjUKdC0zOSAtODkuNXEwIC01MiAzOCAtOTB0OTAgLTM4aDMzMXEtMTUgLTE3IC0yNSAtNDcuNXQtMTAgLTU1LjVxMCAtNjkgNTMgLTExOXEtMTggLTMyIC0xOCAtNjl0MTcuNSAtNzMuNXQ0Ny41IC01Mi41cS00IC0yNCAtNCAtNTZxMCAtODUgNDguNSAtMTI2dDEzNS41IC00MXE4NCAwIDE4MyAzMnQxOTQgNjR0MTY3IDMyek0xNjY0IDE5MnEwIDI2IC0xOSA0NXQtNDUgMTl0LTQ1IC0xOXQtMTkgLTQ1dDE5IC00NXQ0NSAtMTl0NDUgMTl0MTkgNDV6Ck0xNzkyIDc2OHYtNjQwcTAgLTUzIC0zNy41IC05MC41dC05MC41IC0zNy41aC0yODhxLTU5IDAgLTIyMyAtNTlxLTE5MCAtNjkgLTMxNyAtNjlxLTE0MiAwIC0yMzAgNzcuNXQtODcgMjE3LjVsMSA1cS02MSA3NiAtNjEgMTc4cTAgMjIgMyA0M3EtMzMgNTcgLTM3IDExOWgtMTY5cS0xMDUgMCAtMTgwLjUgNzZ0LTc1LjUgMTgxcTAgMTAzIDc2IDE3OXQxODAgNzZoMzc0cS0yMiA2MCAtMjIgMTI4cTAgMTIyIDgxLjUgMTg5dDIwNi41IDY3CnEzOCAwIDY5LjUgLTE3LjV0NTUgLTQ5LjV0NDAuNSAtNjN0MzcgLTcydDMzIC02MnEzNSAtNTUgMTAwIC0xMjlxMiAtMyAxNCAtMTd0MTkgLTIxLjV0MjAuNSAtMjEuNXQyNCAtMjIuNXQyMi41IC0xOHQyMy41IC0xNHQyMS41IC00LjVoMjg4cTUzIDAgOTAuNSAtMzcuNXQzNy41IC05MC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJoYW5kX3VwIiB1bmljb2RlPSImI3hmMGE2OyIgCmQ9Ik0xMjgwIC02NHEwIDI2IC0xOSA0NXQtNDUgMTl0LTQ1IC0xOXQtMTkgLTQ1dDE5IC00NXQ0NSAtMTl0NDUgMTl0MTkgNDV6TTE0MDggNzAwcTAgMTg5IC0xNjcgMTg5cS0yNiAwIC01NiAtNXEtMTYgMzAgLTUyLjUgNDcuNXQtNzMuNSAxNy41dC02OSAtMThxLTUwIDUzIC0xMTkgNTNxLTI1IDAgLTU1LjUgLTEwdC00Ny41IC0yNXYzMzFxMCA1MiAtMzggOTB0LTkwIDM4cS01MSAwIC04OS41IC0zOXQtMzguNSAtODl2LTU3NgpxLTIwIDAgLTQ4LjUgMTV0LTU1IDMzdC02OCAzM3QtODQuNSAxNXEtNjcgMCAtOTcuNSAtNDQuNXQtMzAuNSAtMTE1LjVxMCAtMjQgMTM5IC05MHE0NCAtMjQgNjUgLTM3cTY0IC00MCAxNDUgLTExMnE4MSAtNzEgMTA2IC0xMDFxNTcgLTY5IDU3IC0xNDB2LTMyaDY0MHYzMnEwIDcyIDMyIDE2N3Q2NCAxOTMuNXQzMiAxNzkuNXpNMTUzNiA3MDVxMCAtMTMzIC02OSAtMzIycS01OSAtMTY0IC01OSAtMjIzdi0yODhxMCAtNTMgLTM3LjUgLTkwLjUKdC05MC41IC0zNy41aC02NDBxLTUzIDAgLTkwLjUgMzcuNXQtMzcuNSA5MC41djI4OHEwIDEwIC00LjUgMjEuNXQtMTQgMjMuNXQtMTggMjIuNXQtMjIuNSAyNHQtMjEuNSAyMC41dC0yMS41IDE5dC0xNyAxNHEtNzQgNjUgLTEyOSAxMDBxLTIxIDEzIC02MiAzM3QtNzIgMzd0LTYzIDQwLjV0LTQ5LjUgNTV0LTE3LjUgNjkuNXEwIDEyNSA2NyAyMDYuNXQxODkgODEuNXE2OCAwIDEyOCAtMjJ2Mzc0cTAgMTA0IDc2IDE4MHQxNzkgNzYKcTEwNSAwIDE4MSAtNzUuNXQ3NiAtMTgwLjV2LTE2OXE2MiAtNCAxMTkgLTM3cTIxIDMgNDMgM3ExMDEgMCAxNzggLTYwcTEzOSAxIDIxOS41IC04NXQ4MC41IC0yMjd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImhhbmRfZG93biIgdW5pY29kZT0iJiN4ZjBhNzsiIApkPSJNMTQwOCA1NzZxMCA4NCAtMzIgMTgzdC02NCAxOTR0LTMyIDE2N3YzMmgtNjQwdi0zMnEwIC0zNSAtMTIgLTY3LjV0LTM3IC02Mi41dC00NiAtNTB0LTU0IC00OXEtOSAtOCAtMTQgLTEycS04MSAtNzIgLTE0NSAtMTEycS0yMiAtMTQgLTY4IC0zOHEtMyAtMSAtMjIuNSAtMTAuNXQtMzYgLTE4LjV0LTM1LjUgLTIwdC0zMC41IC0yMS41dC0xMS41IC0xOC41cTAgLTcxIDMwLjUgLTExNS41dDk3LjUgLTQ0LjVxNDMgMCA4NC41IDE1dDY4IDMzCnQ1NSAzM3Q0OC41IDE1di01NzZxMCAtNTAgMzguNSAtODl0ODkuNSAtMzlxNTIgMCA5MCAzOHQzOCA5MHYzMzFxNDYgLTM1IDEwMyAtMzVxNjkgMCAxMTkgNTNxMzIgLTE4IDY5IC0xOHQ3My41IDE3LjV0NTIuNSA0Ny41cTI0IC00IDU2IC00cTg1IDAgMTI2IDQ4LjV0NDEgMTM1LjV6TTEyODAgMTM0NHEwIDI2IC0xOSA0NXQtNDUgMTl0LTQ1IC0xOXQtMTkgLTQ1dDE5IC00NXQ0NSAtMTl0NDUgMTl0MTkgNDV6TTE1MzYgNTgwCnEwIC0xNDIgLTc3LjUgLTIzMHQtMjE3LjUgLTg3bC01IDFxLTc2IC02MSAtMTc4IC02MXEtMjIgMCAtNDMgM3EtNTQgLTMwIC0xMTkgLTM3di0xNjlxMCAtMTA1IC03NiAtMTgwLjV0LTE4MSAtNzUuNXEtMTAzIDAgLTE3OSA3NnQtNzYgMTgwdjM3NHEtNTQgLTIyIC0xMjggLTIycS0xMjEgMCAtMTg4LjUgODEuNXQtNjcuNSAyMDYuNXEwIDM4IDE3LjUgNjkuNXQ0OS41IDU1dDYzIDQwLjV0NzIgMzd0NjIgMzNxNTUgMzUgMTI5IDEwMApxMyAyIDE3IDE0dDIxLjUgMTl0MjEuNSAyMC41dDIyLjUgMjR0MTggMjIuNXQxNCAyMy41dDQuNSAyMS41djI4OHEwIDUzIDM3LjUgOTAuNXQ5MC41IDM3LjVoNjQwcTUzIDAgOTAuNSAtMzcuNXQzNy41IC05MC41di0yODhxMCAtNTkgNTkgLTIyM3E2OSAtMTkwIDY5IC0zMTd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNpcmNsZV9hcnJvd19sZWZ0IiB1bmljb2RlPSImI3hmMGE4OyIgCmQ9Ik0xMjgwIDU3NnYxMjhxMCAyNiAtMTkgNDV0LTQ1IDE5aC01MDJsMTg5IDE4OXExOSAxOSAxOSA0NXQtMTkgNDVsLTkxIDkxcS0xOCAxOCAtNDUgMTh0LTQ1IC0xOGwtMzYyIC0zNjJsLTkxIC05MXEtMTggLTE4IC0xOCAtNDV0MTggLTQ1bDkxIC05MWwzNjIgLTM2MnExOCAtMTggNDUgLTE4dDQ1IDE4bDkxIDkxcTE4IDE4IDE4IDQ1dC0xOCA0NWwtMTg5IDE4OWg1MDJxMjYgMCA0NSAxOXQxOSA0NXpNMTUzNiA2NDAKcTAgLTIwOSAtMTAzIC0zODUuNXQtMjc5LjUgLTI3OS41dC0zODUuNSAtMTAzdC0zODUuNSAxMDN0LTI3OS41IDI3OS41dC0xMDMgMzg1LjV0MTAzIDM4NS41dDI3OS41IDI3OS41dDM4NS41IDEwM3QzODUuNSAtMTAzdDI3OS41IC0yNzkuNXQxMDMgLTM4NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjaXJjbGVfYXJyb3dfcmlnaHQiIHVuaWNvZGU9IiYjeGYwYTk7IiAKZD0iTTEyODUgNjQwcTAgMjcgLTE4IDQ1bC05MSA5MWwtMzYyIDM2MnEtMTggMTggLTQ1IDE4dC00NSAtMThsLTkxIC05MXEtMTggLTE4IC0xOCAtNDV0MTggLTQ1bDE4OSAtMTg5aC01MDJxLTI2IDAgLTQ1IC0xOXQtMTkgLTQ1di0xMjhxMCAtMjYgMTkgLTQ1dDQ1IC0xOWg1MDJsLTE4OSAtMTg5cS0xOSAtMTkgLTE5IC00NXQxOSAtNDVsOTEgLTkxcTE4IC0xOCA0NSAtMTh0NDUgMThsMzYyIDM2Mmw5MSA5MXExOCAxOCAxOCA0NXpNMTUzNiA2NDAKcTAgLTIwOSAtMTAzIC0zODUuNXQtMjc5LjUgLTI3OS41dC0zODUuNSAtMTAzdC0zODUuNSAxMDN0LTI3OS41IDI3OS41dC0xMDMgMzg1LjV0MTAzIDM4NS41dDI3OS41IDI3OS41dDM4NS41IDEwM3QzODUuNSAtMTAzdDI3OS41IC0yNzkuNXQxMDMgLTM4NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjaXJjbGVfYXJyb3dfdXAiIHVuaWNvZGU9IiYjeGYwYWE7IiAKZD0iTTEyODQgNjQxcTAgMjcgLTE4IDQ1bC0zNjIgMzYybC05MSA5MXEtMTggMTggLTQ1IDE4dC00NSAtMThsLTkxIC05MWwtMzYyIC0zNjJxLTE4IC0xOCAtMTggLTQ1dDE4IC00NWw5MSAtOTFxMTggLTE4IDQ1IC0xOHQ0NSAxOGwxODkgMTg5di01MDJxMCAtMjYgMTkgLTQ1dDQ1IC0xOWgxMjhxMjYgMCA0NSAxOXQxOSA0NXY1MDJsMTg5IC0xODlxMTkgLTE5IDQ1IC0xOXQ0NSAxOWw5MSA5MXExOCAxOCAxOCA0NXpNMTUzNiA2NDAKcTAgLTIwOSAtMTAzIC0zODUuNXQtMjc5LjUgLTI3OS41dC0zODUuNSAtMTAzdC0zODUuNSAxMDN0LTI3OS41IDI3OS41dC0xMDMgMzg1LjV0MTAzIDM4NS41dDI3OS41IDI3OS41dDM4NS41IDEwM3QzODUuNSAtMTAzdDI3OS41IC0yNzkuNXQxMDMgLTM4NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjaXJjbGVfYXJyb3dfZG93biIgdW5pY29kZT0iJiN4ZjBhYjsiIApkPSJNMTI4NCA2MzlxMCAyNyAtMTggNDVsLTkxIDkxcS0xOCAxOCAtNDUgMTh0LTQ1IC0xOGwtMTg5IC0xODl2NTAycTAgMjYgLTE5IDQ1dC00NSAxOWgtMTI4cS0yNiAwIC00NSAtMTl0LTE5IC00NXYtNTAybC0xODkgMTg5cS0xOSAxOSAtNDUgMTl0LTQ1IC0xOWwtOTEgLTkxcS0xOCAtMTggLTE4IC00NXQxOCAtNDVsMzYyIC0zNjJsOTEgLTkxcTE4IC0xOCA0NSAtMTh0NDUgMThsOTEgOTFsMzYyIDM2MnExOCAxOCAxOCA0NXpNMTUzNiA2NDAKcTAgLTIwOSAtMTAzIC0zODUuNXQtMjc5LjUgLTI3OS41dC0zODUuNSAtMTAzdC0zODUuNSAxMDN0LTI3OS41IDI3OS41dC0xMDMgMzg1LjV0MTAzIDM4NS41dDI3OS41IDI3OS41dDM4NS41IDEwM3QzODUuNSAtMTAzdDI3OS41IC0yNzkuNXQxMDMgLTM4NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJnbG9iZSIgdW5pY29kZT0iJiN4ZjBhYzsiIApkPSJNNzY4IDE0MDhxMjA5IDAgMzg1LjUgLTEwM3QyNzkuNSAtMjc5LjV0MTAzIC0zODUuNXQtMTAzIC0zODUuNXQtMjc5LjUgLTI3OS41dC0zODUuNSAtMTAzdC0zODUuNSAxMDN0LTI3OS41IDI3OS41dC0xMDMgMzg1LjV0MTAzIDM4NS41dDI3OS41IDI3OS41dDM4NS41IDEwM3pNMTA0MiA4ODdxLTIgLTEgLTkuNSAtOS41dC0xMy41IC05LjVxMiAwIDQuNSA1dDUgMTF0My41IDdxNiA3IDIyIDE1cTE0IDYgNTIgMTJxMzQgOCA1MSAtMTEKcS0yIDIgOS41IDEzdDE0LjUgMTJxMyAyIDE1IDQuNXQxNSA3LjVsMiAyMnEtMTIgLTEgLTE3LjUgN3QtNi41IDIxcTAgLTIgLTYgLThxMCA3IC00LjUgOHQtMTEuNSAtMXQtOSAtMXEtMTAgMyAtMTUgNy41dC04IDE2LjV0LTQgMTVxLTIgNSAtOS41IDExdC05LjUgMTBxLTEgMiAtMi41IDUuNXQtMyA2LjV0LTQgNS41dC01LjUgMi41dC03IC01dC03LjUgLTEwdC00LjUgLTVxLTMgMiAtNiAxLjV0LTQuNSAtMXQtNC41IC0zdC01IC0zLjUKcS0zIC0yIC04LjUgLTN0LTguNSAtMnExNSA1IC0xIDExcS0xMCA0IC0xNiAzcTkgNCA3LjUgMTJ0LTguNSAxNGg1cS0xIDQgLTguNSA4LjV0LTE3LjUgOC41dC0xMyA2cS04IDUgLTM0IDkuNXQtMzMgMC41cS01IC02IC00LjUgLTEwLjV0NCAtMTR0My41IC0xMi41cTEgLTYgLTUuNSAtMTN0LTYuNSAtMTJxMCAtNyAxNCAtMTUuNXQxMCAtMjEuNXEtMyAtOCAtMTYgLTE2dC0xNiAtMTJxLTUgLTggLTEuNSAtMTguNXQxMC41IC0xNi41CnEyIC0yIDEuNSAtNHQtMy41IC00LjV0LTUuNSAtNHQtNi41IC0zLjVsLTMgLTJxLTExIC01IC0yMC41IDZ0LTEzLjUgMjZxLTcgMjUgLTE2IDMwcS0yMyA4IC0yOSAtMXEtNSAxMyAtNDEgMjZxLTI1IDkgLTU4IDRxNiAxIDAgMTVxLTcgMTUgLTE5IDEycTMgNiA0IDE3LjV0MSAxMy41cTMgMTMgMTIgMjNxMSAxIDcgOC41dDkuNSAxMy41dDAuNSA2cTM1IC00IDUwIDExcTUgNSAxMS41IDE3dDEwLjUgMTdxOSA2IDE0IDUuNXQxNC41IC01LjUKdDE0LjUgLTVxMTQgLTEgMTUuNSAxMXQtNy41IDIwcTEyIC0xIDMgMTdxLTQgNyAtOCA5cS0xMiA0IC0yNyAtNXEtOCAtNCAyIC04cS0xIDEgLTkuNSAtMTAuNXQtMTYuNSAtMTcuNXQtMTYgNXEtMSAxIC01LjUgMTMuNXQtOS41IDEzLjVxLTggMCAtMTYgLTE1cTMgOCAtMTEgMTV0LTI0IDhxMTkgMTIgLTggMjdxLTcgNCAtMjAuNSA1dC0xOS41IC00cS01IC03IC01LjUgLTExLjV0NSAtOHQxMC41IC01LjV0MTEuNSAtNHQ4LjUgLTMKcTE0IC0xMCA4IC0xNHEtMiAtMSAtOC41IC0zLjV0LTExLjUgLTQuNXQtNiAtNHEtMyAtNCAwIC0xNHQtMiAtMTRxLTUgNSAtOSAxNy41dC03IDE2LjVxNyAtOSAtMjUgLTZsLTEwIDFxLTQgMCAtMTYgLTJ0LTIwLjUgLTF0LTEzLjUgOHEtNCA4IDAgMjBxMSA0IDQgMnEtNCAzIC0xMSA5LjV0LTEwIDguNXEtNDYgLTE1IC05NCAtNDFxNiAtMSAxMiAxcTUgMiAxMyA2LjV0MTAgNS41cTM0IDE0IDQyIDdsNSA1cTE0IC0xNiAyMCAtMjUKcS03IDQgLTMwIDFxLTIwIC02IC0yMiAtMTJxNyAtMTIgNSAtMThxLTQgMyAtMTEuNSAxMHQtMTQuNSAxMXQtMTUgNXEtMTYgMCAtMjIgLTFxLTE0NiAtODAgLTIzNSAtMjIycTcgLTcgMTIgLThxNCAtMSA1IC05dDIuNSAtMTF0MTEuNSAzcTkgLTggMyAtMTlxMSAxIDQ0IC0yN3ExOSAtMTcgMjEgLTIxcTMgLTExIC0xMCAtMThxLTEgMiAtOSA5dC05IDRxLTMgLTUgMC41IC0xOC41dDEwLjUgLTEyLjVxLTcgMCAtOS41IC0xNnQtMi41IC0zNS41CnQtMSAtMjMuNWwyIC0xcS0zIC0xMiA1LjUgLTM0LjV0MjEuNSAtMTkuNXEtMTMgLTMgMjAgLTQzcTYgLTggOCAtOXEzIC0yIDEyIC03LjV0MTUgLTEwdDEwIC0xMC41cTQgLTUgMTAgLTIyLjV0MTQgLTIzLjVxLTIgLTYgOS41IC0yMHQxMC41IC0yM3EtMSAwIC0yLjUgLTF0LTIuNSAtMXEzIC03IDE1LjUgLTE0dDE1LjUgLTEzcTEgLTMgMiAtMTB0MyAtMTF0OCAtMnEyIDIwIC0yNCA2MnEtMTUgMjUgLTE3IDI5cS0zIDUgLTUuNSAxNS41CnQtNC41IDE0LjVxMiAwIDYgLTEuNXQ4LjUgLTMuNXQ3LjUgLTR0MiAtM3EtMyAtNyAyIC0xNy41dDEyIC0xOC41dDE3IC0xOXQxMiAtMTNxNiAtNiAxNCAtMTkuNXQwIC0xMy41cTkgMCAyMCAtMTAuNXQxNyAtMTkuNXE1IC04IDggLTI2dDUgLTI0cTIgLTcgOC41IC0xMy41dDEyLjUgLTkuNWwxNiAtOHQxMyAtN3E1IC0yIDE4LjUgLTEwLjV0MjEuNSAtMTEuNXExMCAtNCAxNiAtNHQxNC41IDIuNXQxMy41IDMuNXExNSAyIDI5IC0xNXQyMSAtMjEKcTM2IC0xOSA1NSAtMTFxLTIgLTEgMC41IC03LjV0OCAtMTUuNXQ5IC0xNC41dDUuNSAtOC41cTUgLTYgMTggLTE1dDE4IC0xNXE2IDQgNyA5cS0zIC04IDcgLTIwdDE4IC0xMHExNCAzIDE0IDMycS0zMSAtMTUgLTQ5IDE4cTAgMSAtMi41IDUuNXQtNCA4LjV0LTIuNSA4LjV0MCA3LjV0NSAzcTkgMCAxMCAzLjV0LTIgMTIuNXQtNCAxM3EtMSA4IC0xMSAyMHQtMTIgMTVxLTUgLTkgLTE2IC04dC0xNiA5cTAgLTEgLTEuNSAtNS41dC0xLjUgLTYuNQpxLTEzIDAgLTE1IDFxMSAzIDIuNSAxNy41dDMuNSAyMi41cTEgNCA1LjUgMTJ0Ny41IDE0LjV0NCAxMi41dC00LjUgOS41dC0xNy41IDIuNXEtMTkgLTEgLTI2IC0yMHEtMSAtMyAtMyAtMTAuNXQtNSAtMTEuNXQtOSAtN3EtNyAtMyAtMjQgLTJ0LTI0IDVxLTEzIDggLTIyLjUgMjl0LTkuNSAzN3EwIDEwIDIuNSAyNi41dDMgMjV0LTUuNSAyNC41cTMgMiA5IDkuNXQxMCAxMC41cTIgMSA0LjUgMS41dDQuNSAwdDQgMS41dDMgNnEtMSAxIC00IDMKcS0zIDMgLTQgM3E3IC0zIDI4LjUgMS41dDI3LjUgLTEuNXExNSAtMTEgMjIgMnEwIDEgLTIuNSA5LjV0LTAuNSAxMy41cTUgLTI3IDI5IC05cTMgLTMgMTUuNSAtNXQxNy41IC01cTMgLTIgNyAtNS41dDUuNSAtNC41dDUgMC41dDguNSA2LjVxMTAgLTE0IDEyIC0yNHExMSAtNDAgMTkgLTQ0cTcgLTMgMTEgLTJ0NC41IDkuNXQwIDE0dC0xLjUgMTIuNWwtMSA4djE4bC0xIDhxLTE1IDMgLTE4LjUgMTJ0MS41IDE4LjV0MTUgMTguNXExIDEgOCAzLjUKdDE1LjUgNi41dDEyLjUgOHEyMSAxOSAxNSAzNXE3IDAgMTEgOXEtMSAwIC01IDN0LTcuNSA1dC00LjUgMnE5IDUgMiAxNnE1IDMgNy41IDExdDcuNSAxMHE5IC0xMiAyMSAtMnE4IDggMSAxNnE1IDcgMjAuNSAxMC41dDE4LjUgOS41cTcgLTIgOCAydDEgMTJ0MyAxMnE0IDUgMTUgOXQxMyA1bDE3IDExcTMgNCAwIDRxMTggLTIgMzEgMTFxMTAgMTEgLTYgMjBxMyA2IC0zIDkuNXQtMTUgNS41cTMgMSAxMS41IDAuNXQxMC41IDEuNQpxMTUgMTAgLTcgMTZxLTE3IDUgLTQzIC0xMnpNODc5IDEwcTIwNiAzNiAzNTEgMTg5cS0zIDMgLTEyLjUgNC41dC0xMi41IDMuNXEtMTggNyAtMjQgOHExIDcgLTIuNSAxM3QtOCA5dC0xMi41IDh0LTExIDdxLTIgMiAtNyA2dC03IDUuNXQtNy41IDQuNXQtOC41IDJ0LTEwIC0xbC0zIC0xcS0zIC0xIC01LjUgLTIuNXQtNS41IC0zdC00IC0zdDAgLTIuNXEtMjEgMTcgLTM2IDIycS01IDEgLTExIDUuNXQtMTAuNSA3dC0xMCAxLjV0LTExLjUgLTcKcS01IC01IC02IC0xNXQtMiAtMTNxLTcgNSAwIDE3LjV0MiAxOC41cS0zIDYgLTEwLjUgNC41dC0xMiAtNC41dC0xMS41IC04LjV0LTkgLTYuNXQtOC41IC01LjV0LTguNSAtNy41cS0zIC00IC02IC0xMnQtNSAtMTFxLTIgNCAtMTEuNSA2LjV0LTkuNSA1LjVxMiAtMTAgNCAtMzV0NSAtMzhxNyAtMzEgLTEyIC00OHEtMjcgLTI1IC0yOSAtNDBxLTQgLTIyIDEyIC0yNnEwIC03IC04IC0yMC41dC03IC0yMS41cTAgLTYgMiAtMTZ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IndyZW5jaCIgdW5pY29kZT0iJiN4ZjBhZDsiIGhvcml6LWFkdi14PSIxNjY0IiAKZD0iTTM4NCA2NHEwIDI2IC0xOSA0NXQtNDUgMTl0LTQ1IC0xOXQtMTkgLTQ1dDE5IC00NXQ0NSAtMTl0NDUgMTl0MTkgNDV6TTEwMjggNDg0bC02ODIgLTY4MnEtMzcgLTM3IC05MCAtMzdxLTUyIDAgLTkxIDM3bC0xMDYgMTA4cS0zOCAzNiAtMzggOTBxMCA1MyAzOCA5MWw2ODEgNjgxcTM5IC05OCAxMTQuNSAtMTczLjV0MTczLjUgLTExNC41ek0xNjYyIDkxOXEwIC0zOSAtMjMgLTEwNnEtNDcgLTEzNCAtMTY0LjUgLTIxNy41CnQtMjU4LjUgLTgzLjVxLTE4NSAwIC0zMTYuNSAxMzEuNXQtMTMxLjUgMzE2LjV0MTMxLjUgMzE2LjV0MzE2LjUgMTMxLjVxNTggMCAxMjEuNSAtMTYuNXQxMDcuNSAtNDYuNXExNiAtMTEgMTYgLTI4dC0xNiAtMjhsLTI5MyAtMTY5di0yMjRsMTkzIC0xMDdxNSAzIDc5IDQ4LjV0MTM1LjUgODF0NzAuNSAzNS41cTE1IDAgMjMuNSAtMTB0OC41IC0yNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idGFza3MiIHVuaWNvZGU9IiYjeGYwYWU7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xMDI0IDEyOGg2NDB2MTI4aC02NDB2LTEyOHpNNjQwIDY0MGgxMDI0djEyOGgtMTAyNHYtMTI4ek0xMjgwIDExNTJoMzg0djEyOGgtMzg0di0xMjh6TTE3OTIgMzIwdi0yNTZxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0xNjY0cS0yNiAwIC00NSAxOXQtMTkgNDV2MjU2cTAgMjYgMTkgNDV0NDUgMTloMTY2NHEyNiAwIDQ1IC0xOXQxOSAtNDV6TTE3OTIgODMydi0yNTZxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0xNjY0cS0yNiAwIC00NSAxOQp0LTE5IDQ1djI1NnEwIDI2IDE5IDQ1dDQ1IDE5aDE2NjRxMjYgMCA0NSAtMTl0MTkgLTQ1ek0xNzkyIDEzNDR2LTI1NnEwIC0yNiAtMTkgLTQ1dC00NSAtMTloLTE2NjRxLTI2IDAgLTQ1IDE5dC0xOSA0NXYyNTZxMCAyNiAxOSA0NXQ0NSAxOWgxNjY0cTI2IDAgNDUgLTE5dDE5IC00NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZmlsdGVyIiB1bmljb2RlPSImI3hmMGIwOyIgaG9yaXotYWR2LXg9IjE0MDgiIApkPSJNMTQwMyAxMjQxcTE3IC00MSAtMTQgLTcwbC00OTMgLTQ5M3YtNzQycTAgLTQyIC0zOSAtNTlxLTEzIC01IC0yNSAtNXEtMjcgMCAtNDUgMTlsLTI1NiAyNTZxLTE5IDE5IC0xOSA0NXY0ODZsLTQ5MyA0OTNxLTMxIDI5IC0xNCA3MHExNyAzOSA1OSAzOWgxMjgwcTQyIDAgNTkgLTM5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJicmllZmNhc2UiIHVuaWNvZGU9IiYjeGYwYjE7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik02NDAgMTI4MGg1MTJ2MTI4aC01MTJ2LTEyOHpNMTc5MiA2NDB2LTQ4MHEwIC02NiAtNDcgLTExM3QtMTEzIC00N2gtMTQ3MnEtNjYgMCAtMTEzIDQ3dC00NyAxMTN2NDgwaDY3MnYtMTYwcTAgLTI2IDE5IC00NXQ0NSAtMTloMzIwcTI2IDAgNDUgMTl0MTkgNDV2MTYwaDY3MnpNMTAyNCA2NDB2LTEyOGgtMjU2djEyOGgyNTZ6TTE3OTIgMTEyMHYtMzg0aC0xNzkydjM4NHEwIDY2IDQ3IDExM3QxMTMgNDdoMzUydjE2MHEwIDQwIDI4IDY4CnQ2OCAyOGg1NzZxNDAgMCA2OCAtMjh0MjggLTY4di0xNjBoMzUycTY2IDAgMTEzIC00N3Q0NyAtMTEzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJmdWxsc2NyZWVuIiB1bmljb2RlPSImI3hmMGIyOyIgCmQ9Ik0xMjgzIDk5NWwtMzU1IC0zNTVsMzU1IC0zNTVsMTQ0IDE0NHEyOSAzMSA3MCAxNHEzOSAtMTcgMzkgLTU5di00NDhxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC00NDhxLTQyIDAgLTU5IDQwcS0xNyAzOSAxNCA2OWwxNDQgMTQ0bC0zNTUgMzU1bC0zNTUgLTM1NWwxNDQgLTE0NHEzMSAtMzAgMTQgLTY5cS0xNyAtNDAgLTU5IC00MGgtNDQ4cS0yNiAwIC00NSAxOXQtMTkgNDV2NDQ4cTAgNDIgNDAgNTlxMzkgMTcgNjkgLTE0bDE0NCAtMTQ0CmwzNTUgMzU1bC0zNTUgMzU1bC0xNDQgLTE0NHEtMTkgLTE5IC00NSAtMTlxLTEyIDAgLTI0IDVxLTQwIDE3IC00MCA1OXY0NDhxMCAyNiAxOSA0NXQ0NSAxOWg0NDhxNDIgMCA1OSAtNDBxMTcgLTM5IC0xNCAtNjlsLTE0NCAtMTQ0bDM1NSAtMzU1bDM1NSAzNTVsLTE0NCAxNDRxLTMxIDMwIC0xNCA2OXExNyA0MCA1OSA0MGg0NDhxMjYgMCA0NSAtMTl0MTkgLTQ1di00NDhxMCAtNDIgLTM5IC01OXEtMTMgLTUgLTI1IC01cS0yNiAwIC00NSAxOXoKIiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Imdyb3VwIiB1bmljb2RlPSImI3hmMGMwOyIgaG9yaXotYWR2LXg9IjE5MjAiIApkPSJNNTkzIDY0MHEtMTYyIC01IC0yNjUgLTEyOGgtMTM0cS04MiAwIC0xMzggNDAuNXQtNTYgMTE4LjVxMCAzNTMgMTI0IDM1M3E2IDAgNDMuNSAtMjF0OTcuNSAtNDIuNXQxMTkgLTIxLjVxNjcgMCAxMzMgMjNxLTUgLTM3IC01IC02NnEwIC0xMzkgODEgLTI1NnpNMTY2NCAzcTAgLTEyMCAtNzMgLTE4OS41dC0xOTQgLTY5LjVoLTg3NHEtMTIxIDAgLTE5NCA2OS41dC03MyAxODkuNXEwIDUzIDMuNSAxMDMuNXQxNCAxMDl0MjYuNSAxMDguNQp0NDMgOTcuNXQ2MiA4MXQ4NS41IDUzLjV0MTExLjUgMjBxMTAgMCA0MyAtMjEuNXQ3MyAtNDh0MTA3IC00OHQxMzUgLTIxLjV0MTM1IDIxLjV0MTA3IDQ4dDczIDQ4dDQzIDIxLjVxNjEgMCAxMTEuNSAtMjB0ODUuNSAtNTMuNXQ2MiAtODF0NDMgLTk3LjV0MjYuNSAtMTA4LjV0MTQgLTEwOXQzLjUgLTEwMy41ek02NDAgMTI4MHEwIC0xMDYgLTc1IC0xODF0LTE4MSAtNzV0LTE4MSA3NXQtNzUgMTgxdDc1IDE4MXQxODEgNzV0MTgxIC03NQp0NzUgLTE4MXpNMTM0NCA4OTZxMCAtMTU5IC0xMTIuNSAtMjcxLjV0LTI3MS41IC0xMTIuNXQtMjcxLjUgMTEyLjV0LTExMi41IDI3MS41dDExMi41IDI3MS41dDI3MS41IDExMi41dDI3MS41IC0xMTIuNXQxMTIuNSAtMjcxLjV6TTE5MjAgNjcxcTAgLTc4IC01NiAtMTE4LjV0LTEzOCAtNDAuNWgtMTM0cS0xMDMgMTIzIC0yNjUgMTI4cTgxIDExNyA4MSAyNTZxMCAyOSAtNSA2NnE2NiAtMjMgMTMzIC0yM3E1OSAwIDExOSAyMS41dDk3LjUgNDIuNQp0NDMuNSAyMXExMjQgMCAxMjQgLTM1M3pNMTc5MiAxMjgwcTAgLTEwNiAtNzUgLTE4MXQtMTgxIC03NXQtMTgxIDc1dC03NSAxODF0NzUgMTgxdDE4MSA3NXQxODEgLTc1dDc1IC0xODF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImxpbmsiIHVuaWNvZGU9IiYjeGYwYzE7IiBob3Jpei1hZHYteD0iMTY2NCIgCmQ9Ik0xNDU2IDMyMHEwIDQwIC0yOCA2OGwtMjA4IDIwOHEtMjggMjggLTY4IDI4cS00MiAwIC03MiAtMzJxMyAtMyAxOSAtMTguNXQyMS41IC0yMS41dDE1IC0xOXQxMyAtMjUuNXQzLjUgLTI3LjVxMCAtNDAgLTI4IC02OHQtNjggLTI4cS0xNSAwIC0yNy41IDMuNXQtMjUuNSAxM3QtMTkgMTV0LTIxLjUgMjEuNXQtMTguNSAxOXEtMzMgLTMxIC0zMyAtNzNxMCAtNDAgMjggLTY4bDIwNiAtMjA3cTI3IC0yNyA2OCAtMjdxNDAgMCA2OCAyNgpsMTQ3IDE0NnEyOCAyOCAyOCA2N3pNNzUzIDEwMjVxMCA0MCAtMjggNjhsLTIwNiAyMDdxLTI4IDI4IC02OCAyOHEtMzkgMCAtNjggLTI3bC0xNDcgLTE0NnEtMjggLTI4IC0yOCAtNjdxMCAtNDAgMjggLTY4bDIwOCAtMjA4cTI3IC0yNyA2OCAtMjdxNDIgMCA3MiAzMXEtMyAzIC0xOSAxOC41dC0yMS41IDIxLjV0LTE1IDE5dC0xMyAyNS41dC0zLjUgMjcuNXEwIDQwIDI4IDY4dDY4IDI4cTE1IDAgMjcuNSAtMy41dDI1LjUgLTEzdDE5IC0xNQp0MjEuNSAtMjEuNXQxOC41IC0xOXEzMyAzMSAzMyA3M3pNMTY0OCAzMjBxMCAtMTIwIC04NSAtMjAzbC0xNDcgLTE0NnEtODMgLTgzIC0yMDMgLTgzcS0xMjEgMCAtMjA0IDg1bC0yMDYgMjA3cS04MyA4MyAtODMgMjAzcTAgMTIzIDg4IDIwOWwtODggODhxLTg2IC04OCAtMjA4IC04OHEtMTIwIDAgLTIwNCA4NGwtMjA4IDIwOHEtODQgODQgLTg0IDIwNHQ4NSAyMDNsMTQ3IDE0NnE4MyA4MyAyMDMgODNxMTIxIDAgMjA0IC04NWwyMDYgLTIwNwpxODMgLTgzIDgzIC0yMDNxMCAtMTIzIC04OCAtMjA5bDg4IC04OHE4NiA4OCAyMDggODhxMTIwIDAgMjA0IC04NGwyMDggLTIwOHE4NCAtODQgODQgLTIwNHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY2xvdWQiIHVuaWNvZGU9IiYjeGYwYzI7IiBob3Jpei1hZHYteD0iMTkyMCIgCmQ9Ik0xOTIwIDM4NHEwIC0xNTkgLTExMi41IC0yNzEuNXQtMjcxLjUgLTExMi41aC0xMDg4cS0xODUgMCAtMzE2LjUgMTMxLjV0LTEzMS41IDMxNi41cTAgMTMyIDcxIDI0MS41dDE4NyAxNjMuNXEtMiAyOCAtMiA0M3EwIDIxMiAxNTAgMzYydDM2MiAxNTBxMTU4IDAgMjg2LjUgLTg4dDE4Ny41IC0yMzBxNzAgNjIgMTY2IDYycTEwNiAwIDE4MSAtNzV0NzUgLTE4MXEwIC03NSAtNDEgLTEzOHExMjkgLTMwIDIxMyAtMTM0LjV0ODQgLTIzOS41egoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYmVha2VyIiB1bmljb2RlPSImI3hmMGMzOyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNMTUyNyA4OHE1NiAtODkgMjEuNSAtMTUyLjV0LTE0MC41IC02My41aC0xMTUycS0xMDYgMCAtMTQwLjUgNjMuNXQyMS41IDE1Mi41bDUwMyA3OTN2Mzk5aC02NHEtMjYgMCAtNDUgMTl0LTE5IDQ1dDE5IDQ1dDQ1IDE5aDUxMnEyNiAwIDQ1IC0xOXQxOSAtNDV0LTE5IC00NXQtNDUgLTE5aC02NHYtMzk5ek03NDggODEzbC0yNzIgLTQyOWg3MTJsLTI3MiA0MjlsLTIwIDMxdjM3djM5OWgtMTI4di0zOTl2LTM3eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjdXQiIHVuaWNvZGU9IiYjeGYwYzQ7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik05NjAgNjQwcTI2IDAgNDUgLTE5dDE5IC00NXQtMTkgLTQ1dC00NSAtMTl0LTQ1IDE5dC0xOSA0NXQxOSA0NXQ0NSAxOXpNMTI2MCA1NzZsNTA3IC0zOThxMjggLTIwIDI1IC01NnEtNSAtMzUgLTM1IC01MWwtMTI4IC02NHEtMTMgLTcgLTI5IC03cS0xNyAwIC0zMSA4bC02OTAgMzg3bC0xMTAgLTY2cS04IC00IC0xMiAtNXExNCAtNDkgMTAgLTk3cS03IC03NyAtNTYgLTE0Ny41dC0xMzIgLTEyMy41cS0xMzIgLTg0IC0yNzcgLTg0CnEtMTM2IDAgLTIyMiA3OHEtOTAgODQgLTc5IDIwN3E3IDc2IDU2IDE0N3QxMzEgMTI0cTEzMiA4NCAyNzggODRxODMgMCAxNTEgLTMxcTkgMTMgMjIgMjJsMTIyIDczbC0xMjIgNzNxLTEzIDkgLTIyIDIycS02OCAtMzEgLTE1MSAtMzFxLTE0NiAwIC0yNzggODRxLTgyIDUzIC0xMzEgMTI0dC01NiAxNDdxLTUgNTkgMTUuNSAxMTN0NjMuNSA5M3E4NSA3OSAyMjIgNzlxMTQ1IDAgMjc3IC04NHE4MyAtNTIgMTMyIC0xMjN0NTYgLTE0OApxNCAtNDggLTEwIC05N3E0IC0xIDEyIC01bDExMCAtNjZsNjkwIDM4N3ExNCA4IDMxIDhxMTYgMCAyOSAtN2wxMjggLTY0cTMwIC0xNiAzNSAtNTFxMyAtMzYgLTI1IC01NnpNNTc5IDgzNnE0NiA0MiAyMSAxMDh0LTEwNiAxMTdxLTkyIDU5IC0xOTIgNTlxLTc0IDAgLTExMyAtMzZxLTQ2IC00MiAtMjEgLTEwOHQxMDYgLTExN3E5MiAtNTkgMTkyIC01OXE3NCAwIDExMyAzNnpNNDk0IDkxcTgxIDUxIDEwNiAxMTd0LTIxIDEwOApxLTM5IDM2IC0xMTMgMzZxLTEwMCAwIC0xOTIgLTU5cS04MSAtNTEgLTEwNiAtMTE3dDIxIC0xMDhxMzkgLTM2IDExMyAtMzZxMTAwIDAgMTkyIDU5ek02NzIgNzA0bDk2IC01OHYxMXEwIDM2IDMzIDU2bDE0IDhsLTc5IDQ3bC0yNiAtMjZxLTMgLTMgLTEwIC0xMXQtMTIgLTEycS0yIC0yIC00IC0zLjV0LTMgLTIuNXpNODk2IDQ4MGw5NiAtMzJsNzM2IDU3NmwtMTI4IDY0bC03NjggLTQzMXYtMTEzbC0xNjAgLTk2bDkgLThxMiAtMiA3IC02CnE0IC00IDExIC0xMnQxMSAtMTJsMjYgLTI2ek0xNjAwIDY0bDEyOCA2NGwtNTIwIDQwOGwtMTc3IC0xMzhxLTIgLTMgLTEzIC03eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjb3B5IiB1bmljb2RlPSImI3hmMGM1OyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTY5NiAxMTUycTQwIDAgNjggLTI4dDI4IC02OHYtMTIxNnEwIC00MCAtMjggLTY4dC02OCAtMjhoLTk2MHEtNDAgMCAtNjggMjh0LTI4IDY4djI4OGgtNTQ0cS00MCAwIC02OCAyOHQtMjggNjh2NjcycTAgNDAgMjAgODh0NDggNzZsNDA4IDQwOHEyOCAyOCA3NiA0OHQ4OCAyMGg0MTZxNDAgMCA2OCAtMjh0MjggLTY4di0zMjhxNjggNDAgMTI4IDQwaDQxNnpNMTE1MiA5MzlsLTI5OSAtMjk5aDI5OXYyOTl6TTUxMiAxMzIzbC0yOTkgLTI5OQpoMjk5djI5OXpNNzA4IDY3NmwzMTYgMzE2djQxNmgtMzg0di00MTZxMCAtNDAgLTI4IC02OHQtNjggLTI4aC00MTZ2LTY0MGg1MTJ2MjU2cTAgNDAgMjAgODh0NDggNzZ6TTE2NjQgLTEyOHYxMTUyaC0zODR2LTQxNnEwIC00MCAtMjggLTY4dC02OCAtMjhoLTQxNnYtNjQwaDg5NnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icGFwZXJfY2xpcCIgdW5pY29kZT0iJiN4ZjBjNjsiIGhvcml6LWFkdi14PSIxNDA4IiAKZD0iTTE0MDQgMTUxcTAgLTExNyAtNzkgLTE5NnQtMTk2IC03OXEtMTM1IDAgLTIzNSAxMDBsLTc3NyA3NzZxLTExMyAxMTUgLTExMyAyNzFxMCAxNTkgMTEwIDI3MHQyNjkgMTExcTE1OCAwIDI3MyAtMTEzbDYwNSAtNjA2cTEwIC0xMCAxMCAtMjJxMCAtMTYgLTMwLjUgLTQ2LjV0LTQ2LjUgLTMwLjVxLTEzIDAgLTIzIDEwbC02MDYgNjA3cS03OSA3NyAtMTgxIDc3cS0xMDYgMCAtMTc5IC03NXQtNzMgLTE4MXEwIC0xMDUgNzYgLTE4MQpsNzc2IC03NzdxNjMgLTYzIDE0NSAtNjNxNjQgMCAxMDYgNDJ0NDIgMTA2cTAgODIgLTYzIDE0NWwtNTgxIDU4MXEtMjYgMjQgLTYwIDI0cS0yOSAwIC00OCAtMTl0LTE5IC00OHEwIC0zMiAyNSAtNTlsNDEwIC00MTBxMTAgLTEwIDEwIC0yMnEwIC0xNiAtMzEgLTQ3dC00NyAtMzFxLTEyIDAgLTIyIDEwbC00MTAgNDEwcS02MyA2MSAtNjMgMTQ5cTAgODIgNTcgMTM5dDEzOSA1N3E4OCAwIDE0OSAtNjNsNTgxIC01ODFxMTAwIC05OCAxMDAgLTIzNQp6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InNhdmUiIHVuaWNvZGU9IiYjeGYwYzc7IiAKZD0iTTM4NCAwaDc2OHYzODRoLTc2OHYtMzg0ek0xMjgwIDBoMTI4djg5NnEwIDE0IC0xMCAzOC41dC0yMCAzNC41bC0yODEgMjgxcS0xMCAxMCAtMzQgMjB0LTM5IDEwdi00MTZxMCAtNDAgLTI4IC02OHQtNjggLTI4aC01NzZxLTQwIDAgLTY4IDI4dC0yOCA2OHY0MTZoLTEyOHYtMTI4MGgxMjh2NDE2cTAgNDAgMjggNjh0NjggMjhoODMycTQwIDAgNjggLTI4dDI4IC02OHYtNDE2ek04OTYgOTI4djMyMHEwIDEzIC05LjUgMjIuNXQtMjIuNSA5LjUKaC0xOTJxLTEzIDAgLTIyLjUgLTkuNXQtOS41IC0yMi41di0zMjBxMCAtMTMgOS41IC0yMi41dDIyLjUgLTkuNWgxOTJxMTMgMCAyMi41IDkuNXQ5LjUgMjIuNXpNMTUzNiA4OTZ2LTkyOHEwIC00MCAtMjggLTY4dC02OCAtMjhoLTEzNDRxLTQwIDAgLTY4IDI4dC0yOCA2OHYxMzQ0cTAgNDAgMjggNjh0NjggMjhoOTI4cTQwIDAgODggLTIwdDc2IC00OGwyODAgLTI4MHEyOCAtMjggNDggLTc2dDIwIC04OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ic2lnbl9ibGFuayIgdW5pY29kZT0iJiN4ZjBjODsiIApkPSJNMTUzNiAxMTIwdi05NjBxMCAtMTE5IC04NC41IC0yMDMuNXQtMjAzLjUgLTg0LjVoLTk2MHEtMTE5IDAgLTIwMy41IDg0LjV0LTg0LjUgMjAzLjV2OTYwcTAgMTE5IDg0LjUgMjAzLjV0MjAzLjUgODQuNWg5NjBxMTE5IDAgMjAzLjUgLTg0LjV0ODQuNSAtMjAzLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InJlb3JkZXIiIHVuaWNvZGU9IiYjeGYwYzk7IiAKZD0iTTE1MzYgMTkydi0xMjhxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0xNDA4cS0yNiAwIC00NSAxOXQtMTkgNDV2MTI4cTAgMjYgMTkgNDV0NDUgMTloMTQwOHEyNiAwIDQ1IC0xOXQxOSAtNDV6TTE1MzYgNzA0di0xMjhxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0xNDA4cS0yNiAwIC00NSAxOXQtMTkgNDV2MTI4cTAgMjYgMTkgNDV0NDUgMTloMTQwOHEyNiAwIDQ1IC0xOXQxOSAtNDV6TTE1MzYgMTIxNnYtMTI4cTAgLTI2IC0xOSAtNDUKdC00NSAtMTloLTE0MDhxLTI2IDAgLTQ1IDE5dC0xOSA0NXYxMjhxMCAyNiAxOSA0NXQ0NSAxOWgxNDA4cTI2IDAgNDUgLTE5dDE5IC00NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idWwiIHVuaWNvZGU9IiYjeGYwY2E7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0zODQgMTI4cTAgLTgwIC01NiAtMTM2dC0xMzYgLTU2dC0xMzYgNTZ0LTU2IDEzNnQ1NiAxMzZ0MTM2IDU2dDEzNiAtNTZ0NTYgLTEzNnpNMzg0IDY0MHEwIC04MCAtNTYgLTEzNnQtMTM2IC01NnQtMTM2IDU2dC01NiAxMzZ0NTYgMTM2dDEzNiA1NnQxMzYgLTU2dDU2IC0xMzZ6TTE3OTIgMjI0di0xOTJxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC0xMjE2cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2MTkycTAgMTMgOS41IDIyLjUKdDIyLjUgOS41aDEyMTZxMTMgMCAyMi41IC05LjV0OS41IC0yMi41ek0zODQgMTE1MnEwIC04MCAtNTYgLTEzNnQtMTM2IC01NnQtMTM2IDU2dC01NiAxMzZ0NTYgMTM2dDEzNiA1NnQxMzYgLTU2dDU2IC0xMzZ6TTE3OTIgNzM2di0xOTJxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC0xMjE2cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2MTkycTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoMTIxNnExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6Ck0xNzkyIDEyNDh2LTE5MnEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTEyMTZxLTEzIDAgLTIyLjUgOS41dC05LjUgMjIuNXYxOTJxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWgxMjE2cTEzIDAgMjIuNSAtOS41dDkuNSAtMjIuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ib2wiIHVuaWNvZGU9IiYjeGYwY2I7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0zODEgLTg0cTAgLTgwIC01NC41IC0xMjZ0LTEzNS41IC00NnEtMTA2IDAgLTE3MiA2Nmw1NyA4OHE0OSAtNDUgMTA2IC00NXEyOSAwIDUwLjUgMTQuNXQyMS41IDQyLjVxMCA2NCAtMTA1IDU2bC0yNiA1NnE4IDEwIDMyLjUgNDMuNXQ0Mi41IDU0dDM3IDM4LjV2MXEtMTYgMCAtNDguNSAtMXQtNDguNSAtMXYtNTNoLTEwNnYxNTJoMzMzdi04OGwtOTUgLTExNXE1MSAtMTIgODEgLTQ5dDMwIC04OHpNMzgzIDU0M3YtMTU5aC0zNjIKcS02IDM2IC02IDU0cTAgNTEgMjMuNSA5M3Q1Ni41IDY4dDY2IDQ3LjV0NTYuNSA0My41dDIzLjUgNDVxMCAyNSAtMTQuNSAzOC41dC0zOS41IDEzLjVxLTQ2IDAgLTgxIC01OGwtODUgNTlxMjQgNTEgNzEuNSA3OS41dDEwNS41IDI4LjVxNzMgMCAxMjMgLTQxLjV0NTAgLTExMi41cTAgLTUwIC0zNCAtOTEuNXQtNzUgLTY0LjV0LTc1LjUgLTUwLjV0LTM1LjUgLTUyLjVoMTI3djYwaDEwNXpNMTc5MiAyMjR2LTE5MnEwIC0xMyAtOS41IC0yMi41CnQtMjIuNSAtOS41aC0xMjE2cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2MTkycTAgMTQgOSAyM3QyMyA5aDEyMTZxMTMgMCAyMi41IC05LjV0OS41IC0yMi41ek0zODQgMTEyM3YtOTloLTMzNXY5OWgxMDdxMCA0MSAwLjUgMTIxLjV0MC41IDEyMS41djEyaC0ycS04IC0xNyAtNTAgLTU0bC03MSA3NmwxMzYgMTI3aDEwNnYtNDA0aDEwOHpNMTc5MiA3MzZ2LTE5MnEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTEyMTYKcS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2MTkycTAgMTQgOSAyM3QyMyA5aDEyMTZxMTMgMCAyMi41IC05LjV0OS41IC0yMi41ek0xNzkyIDEyNDh2LTE5MnEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTEyMTZxLTEzIDAgLTIyLjUgOS41dC05LjUgMjIuNXYxOTJxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWgxMjE2cTEzIDAgMjIuNSAtOS41dDkuNSAtMjIuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ic3RyaWtldGhyb3VnaCIgdW5pY29kZT0iJiN4ZjBjYzsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE3NjAgNjQwcTE0IDAgMjMgLTl0OSAtMjN2LTY0cTAgLTE0IC05IC0yM3QtMjMgLTloLTE3MjhxLTE0IDAgLTIzIDl0LTkgMjN2NjRxMCAxNCA5IDIzdDIzIDloMTcyOHpNNDgzIDcwNHEtMjggMzUgLTUxIDgwcS00OCA5OCAtNDggMTg4cTAgMTgxIDEzNCAzMDlxMTMzIDEyNyAzOTMgMTI3cTUwIDAgMTY3IC0xOXE2NiAtMTIgMTc3IC00OHExMCAtMzggMjEgLTExOHExNCAtMTIzIDE0IC0xODNxMCAtMTggLTUgLTQ1bC0xMiAtM2wtODQgNgpsLTE0IDJxLTUwIDE0OSAtMTAzIDIwNXEtODggOTEgLTIxMCA5MXEtMTE0IDAgLTE4MiAtNTlxLTY3IC01OCAtNjcgLTE0NnEwIC03MyA2NiAtMTQwdDI3OSAtMTI5cTY5IC0yMCAxNzMgLTY2cTU4IC0yOCA5NSAtNTJoLTc0M3pNOTkwIDQ0OGg0MTFxNyAtMzkgNyAtOTJxMCAtMTExIC00MSAtMjEycS0yMyAtNTYgLTcxIC0xMDRxLTM3IC0zNSAtMTA5IC04MXEtODAgLTQ4IC0xNTMgLTY2cS04MCAtMjEgLTIwMyAtMjFxLTExNCAwIC0xOTUgMjMKbC0xNDAgNDBxLTU3IDE2IC03MiAyOHEtOCA4IC04IDIydjEzcTAgMTA4IC0yIDE1NnEtMSAzMCAwIDY4bDIgMzd2NDRsMTAyIDJxMTUgLTM0IDMwIC03MXQyMi41IC01NnQxMi41IC0yN3EzNSAtNTcgODAgLTk0cTQzIC0zNiAxMDUgLTU3cTU5IC0yMiAxMzIgLTIycTY0IDAgMTM5IDI3cTc3IDI2IDEyMiA4NnE0NyA2MSA0NyAxMjlxMCA4NCAtODEgMTU3cS0zNCAyOSAtMTM3IDcxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmRlcmxpbmUiIHVuaWNvZGU9IiYjeGYwY2Q7IiAKZD0iTTQ4IDEzMTNxLTM3IDIgLTQ1IDRsLTMgODhxMTMgMSA0MCAxcTYwIDAgMTEyIC00cTEzMiAtNyAxNjYgLTdxODYgMCAxNjggM3ExMTYgNCAxNDYgNXE1NiAwIDg2IDJsLTEgLTE0bDIgLTY0di05cS02MCAtOSAtMTI0IC05cS02MCAwIC03OSAtMjVxLTEzIC0xNCAtMTMgLTEzMnEwIC0xMyAwLjUgLTMyLjV0MC41IC0yNS41bDEgLTIyOWwxNCAtMjgwcTYgLTEyNCA1MSAtMjAycTM1IC01OSA5NiAtOTJxODggLTQ3IDE3NyAtNDcKcTEwNCAwIDE5MSAyOHE1NiAxOCA5OSA1MXE0OCAzNiA2NSA2NHEzNiA1NiA1MyAxMTRxMjEgNzMgMjEgMjI5cTAgNzkgLTMuNSAxMjh0LTExIDEyMi41dC0xMy41IDE1OS41bC00IDU5cS01IDY3IC0yNCA4OHEtMzQgMzUgLTc3IDM0bC0xMDAgLTJsLTE0IDNsMiA4Nmg4NGwyMDUgLTEwcTc2IC0zIDE5NiAxMGwxOCAtMnE2IC0zOCA2IC01MXEwIC03IC00IC0zMXEtNDUgLTEyIC04NCAtMTNxLTczIC0xMSAtNzkgLTE3cS0xNSAtMTUgLTE1IC00MQpxMCAtNyAxLjUgLTI3dDEuNSAtMzFxOCAtMTkgMjIgLTM5NnE2IC0xOTUgLTE1IC0zMDRxLTE1IC03NiAtNDEgLTEyMnEtMzggLTY1IC0xMTIgLTEyM3EtNzUgLTU3IC0xODIgLTg5cS0xMDkgLTMzIC0yNTUgLTMzcS0xNjcgMCAtMjg0IDQ2cS0xMTkgNDcgLTE3OSAxMjJxLTYxIDc2IC04MyAxOTVxLTE2IDgwIC0xNiAyMzd2MzMzcTAgMTg4IC0xNyAyMTNxLTI1IDM2IC0xNDcgMzl6TTE1MzYgLTk2djY0cTAgMTQgLTkgMjN0LTIzIDloLTE0NzIKcS0xNCAwIC0yMyAtOXQtOSAtMjN2LTY0cTAgLTE0IDkgLTIzdDIzIC05aDE0NzJxMTQgMCAyMyA5dDkgMjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InRhYmxlIiB1bmljb2RlPSImI3hmMGNlOyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNNTEyIDE2MHYxOTJxMCAxNCAtOSAyM3QtMjMgOWgtMzIwcS0xNCAwIC0yMyAtOXQtOSAtMjN2LTE5MnEwIC0xNCA5IC0yM3QyMyAtOWgzMjBxMTQgMCAyMyA5dDkgMjN6TTUxMiA1NDR2MTkycTAgMTQgLTkgMjN0LTIzIDloLTMyMHEtMTQgMCAtMjMgLTl0LTkgLTIzdi0xOTJxMCAtMTQgOSAtMjN0MjMgLTloMzIwcTE0IDAgMjMgOXQ5IDIzek0xMDI0IDE2MHYxOTJxMCAxNCAtOSAyM3QtMjMgOWgtMzIwcS0xNCAwIC0yMyAtOXQtOSAtMjMKdi0xOTJxMCAtMTQgOSAtMjN0MjMgLTloMzIwcTE0IDAgMjMgOXQ5IDIzek01MTIgOTI4djE5MnEwIDE0IC05IDIzdC0yMyA5aC0zMjBxLTE0IDAgLTIzIC05dC05IC0yM3YtMTkycTAgLTE0IDkgLTIzdDIzIC05aDMyMHExNCAwIDIzIDl0OSAyM3pNMTAyNCA1NDR2MTkycTAgMTQgLTkgMjN0LTIzIDloLTMyMHEtMTQgMCAtMjMgLTl0LTkgLTIzdi0xOTJxMCAtMTQgOSAtMjN0MjMgLTloMzIwcTE0IDAgMjMgOXQ5IDIzek0xNTM2IDE2MHYxOTIKcTAgMTQgLTkgMjN0LTIzIDloLTMyMHEtMTQgMCAtMjMgLTl0LTkgLTIzdi0xOTJxMCAtMTQgOSAtMjN0MjMgLTloMzIwcTE0IDAgMjMgOXQ5IDIzek0xMDI0IDkyOHYxOTJxMCAxNCAtOSAyM3QtMjMgOWgtMzIwcS0xNCAwIC0yMyAtOXQtOSAtMjN2LTE5MnEwIC0xNCA5IC0yM3QyMyAtOWgzMjBxMTQgMCAyMyA5dDkgMjN6TTE1MzYgNTQ0djE5MnEwIDE0IC05IDIzdC0yMyA5aC0zMjBxLTE0IDAgLTIzIC05dC05IC0yM3YtMTkyCnEwIC0xNCA5IC0yM3QyMyAtOWgzMjBxMTQgMCAyMyA5dDkgMjN6TTE1MzYgOTI4djE5MnEwIDE0IC05IDIzdC0yMyA5aC0zMjBxLTE0IDAgLTIzIC05dC05IC0yM3YtMTkycTAgLTE0IDkgLTIzdDIzIC05aDMyMHExNCAwIDIzIDl0OSAyM3pNMTY2NCAxMjQ4di0xMDg4cTAgLTY2IC00NyAtMTEzdC0xMTMgLTQ3aC0xMzQ0cS02NiAwIC0xMTMgNDd0LTQ3IDExM3YxMDg4cTAgNjYgNDcgMTEzdDExMyA0N2gxMzQ0cTY2IDAgMTEzIC00N3Q0NyAtMTEzCnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibWFnaWMiIHVuaWNvZGU9IiYjeGYwZDA7IiBob3Jpei1hZHYteD0iMTY2NCIgCmQ9Ik0xMTkwIDk1NWwyOTMgMjkzbC0xMDcgMTA3bC0yOTMgLTI5M3pNMTYzNyAxMjQ4cTAgLTI3IC0xOCAtNDVsLTEyODYgLTEyODZxLTE4IC0xOCAtNDUgLTE4dC00NSAxOGwtMTk4IDE5OHEtMTggMTggLTE4IDQ1dDE4IDQ1bDEyODYgMTI4NnExOCAxOCA0NSAxOHQ0NSAtMThsMTk4IC0xOThxMTggLTE4IDE4IC00NXpNMjg2IDE0MzhsOTggLTMwbC05OCAtMzBsLTMwIC05OGwtMzAgOThsLTk4IDMwbDk4IDMwbDMwIDk4ek02MzYgMTI3NgpsMTk2IC02MGwtMTk2IC02MGwtNjAgLTE5NmwtNjAgMTk2bC0xOTYgNjBsMTk2IDYwbDYwIDE5NnpNMTU2NiA3OThsOTggLTMwbC05OCAtMzBsLTMwIC05OGwtMzAgOThsLTk4IDMwbDk4IDMwbDMwIDk4ek05MjYgMTQzOGw5OCAtMzBsLTk4IC0zMGwtMzAgLTk4bC0zMCA5OGwtOTggMzBsOTggMzBsMzAgOTh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InRydWNrIiB1bmljb2RlPSImI3hmMGQxOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNNjQwIDEyOHEwIDUyIC0zOCA5MHQtOTAgMzh0LTkwIC0zOHQtMzggLTkwdDM4IC05MHQ5MCAtMzh0OTAgMzh0MzggOTB6TTI1NiA2NDBoMzg0djI1NmgtMTU4cS0xMyAwIC0yMiAtOWwtMTk1IC0xOTVxLTkgLTkgLTkgLTIydi0zMHpNMTUzNiAxMjhxMCA1MiAtMzggOTB0LTkwIDM4dC05MCAtMzh0LTM4IC05MHQzOCAtOTB0OTAgLTM4dDkwIDM4dDM4IDkwek0xNzkyIDEyMTZ2LTEwMjRxMCAtMTUgLTQgLTI2LjV0LTEzLjUgLTE4LjUKdC0xNi41IC0xMS41dC0yMy41IC02dC0yMi41IC0ydC0yNS41IDB0LTIyLjUgMC41cTAgLTEwNiAtNzUgLTE4MXQtMTgxIC03NXQtMTgxIDc1dC03NSAxODFoLTM4NHEwIC0xMDYgLTc1IC0xODF0LTE4MSAtNzV0LTE4MSA3NXQtNzUgMTgxaC02NHEtMyAwIC0yMi41IC0wLjV0LTI1LjUgMHQtMjIuNSAydC0yMy41IDZ0LTE2LjUgMTEuNXQtMTMuNSAxOC41dC00IDI2LjVxMCAyNiAxOSA0NXQ0NSAxOXYzMjBxMCA4IC0wLjUgMzV0MCAzOAp0Mi41IDM0LjV0Ni41IDM3dDE0IDMwLjV0MjIuNSAzMGwxOTggMTk4cTE5IDE5IDUwLjUgMzJ0NTguNSAxM2gxNjB2MTkycTAgMjYgMTkgNDV0NDUgMTloMTAyNHEyNiAwIDQ1IC0xOXQxOSAtNDV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InBpbnRlcmVzdCIgdW5pY29kZT0iJiN4ZjBkMjsiIApkPSJNMTUzNiA2NDBxMCAtMjA5IC0xMDMgLTM4NS41dC0yNzkuNSAtMjc5LjV0LTM4NS41IC0xMDNxLTExMSAwIC0yMTggMzJxNTkgOTMgNzggMTY0cTkgMzQgNTQgMjExcTIwIC0zOSA3MyAtNjcuNXQxMTQgLTI4LjVxMTIxIDAgMjE2IDY4LjV0MTQ3IDE4OC41dDUyIDI3MHEwIDExNCAtNTkuNSAyMTR0LTE3Mi41IDE2M3QtMjU1IDYzcS0xMDUgMCAtMTk2IC0yOXQtMTU0LjUgLTc3dC0xMDkgLTExMC41dC02NyAtMTI5LjV0LTIxLjUgLTEzNApxMCAtMTA0IDQwIC0xODN0MTE3IC0xMTFxMzAgLTEyIDM4IDIwcTIgNyA4IDMxdDggMzBxNiAyMyAtMTEgNDNxLTUxIDYxIC01MSAxNTFxMCAxNTEgMTA0LjUgMjU5LjV0MjczLjUgMTA4LjVxMTUxIDAgMjM1LjUgLTgydDg0LjUgLTIxM3EwIC0xNzAgLTY4LjUgLTI4OXQtMTc1LjUgLTExOXEtNjEgMCAtOTggNDMuNXQtMjMgMTA0LjVxOCAzNSAyNi41IDkzLjV0MzAgMTAzdDExLjUgNzUuNXEwIDUwIC0yNyA4M3QtNzcgMzMKcS02MiAwIC0xMDUgLTU3dC00MyAtMTQycTAgLTczIDI1IC0xMjJsLTk5IC00MThxLTE3IC03MCAtMTMgLTE3N3EtMjA2IDkxIC0zMzMgMjgxdC0xMjcgNDIzcTAgMjA5IDEwMyAzODUuNXQyNzkuNSAyNzkuNXQzODUuNSAxMDN0Mzg1LjUgLTEwM3QyNzkuNSAtMjc5LjV0MTAzIC0zODUuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icGludGVyZXN0X3NpZ24iIHVuaWNvZGU9IiYjeGYwZDM7IiAKZD0iTTEyNDggMTQwOHExMTkgMCAyMDMuNSAtODQuNXQ4NC41IC0yMDMuNXYtOTYwcTAgLTExOSAtODQuNSAtMjAzLjV0LTIwMy41IC04NC41aC03MjVxODUgMTIyIDEwOCAyMTBxOSAzNCA1MyAyMDlxMjEgLTM5IDczLjUgLTY3dDExMi41IC0yOHExODEgMCAyOTUuNSAxNDcuNXQxMTQuNSAzNzMuNXEwIDg0IC0zNSAxNjIuNXQtOTYuNSAxMzl0LTE1Mi41IDk3dC0xOTcgMzYuNXEtMTA0IDAgLTE5NC41IC0yOC41dC0xNTMgLTc2LjUKdC0xMDcuNSAtMTA5LjV0LTY2LjUgLTEyOHQtMjEuNSAtMTMyLjVxMCAtMTAyIDM5LjUgLTE4MHQxMTYuNSAtMTEwcTEzIC01IDIzLjUgMHQxNC41IDE5cTEwIDQ0IDE1IDYxcTYgMjMgLTExIDQycS01MCA2MiAtNTAgMTUwcTAgMTUwIDEwMy41IDI1Ni41dDI3MC41IDEwNi41cTE0OSAwIDIzMi41IC04MXQ4My41IC0yMTBxMCAtMTY4IC02Ny41IC0yODZ0LTE3My41IC0xMThxLTYwIDAgLTk3IDQzLjV0LTIzIDEwMy41cTggMzQgMjYuNSA5Mi41CnQyOS41IDEwMnQxMSA3NC41cTAgNDkgLTI2LjUgODEuNXQtNzUuNSAzMi41cS02MSAwIC0xMDMuNSAtNTYuNXQtNDIuNSAtMTM5LjVxMCAtNzIgMjQgLTEyMWwtOTggLTQxNHEtMjQgLTEwMCAtNyAtMjU0aC0xODNxLTExOSAwIC0yMDMuNSA4NC41dC04NC41IDIwMy41djk2MHEwIDExOSA4NC41IDIwMy41dDIwMy41IDg0LjVoOTYweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJnb29nbGVfcGx1c19zaWduIiB1bmljb2RlPSImI3hmMGQ0OyIgCmQ9Ik05MTcgNjMxcTAgMjYgLTYgNjRoLTM2MnYtMTMyaDIxN3EtMyAtMjQgLTE2LjUgLTUwdC0zNy41IC01M3QtNjYuNSAtNDQuNXQtOTYuNSAtMTcuNXEtOTkgMCAtMTY5IDcxdC03MCAxNzF0NzAgMTcxdDE2OSA3MXE5MiAwIDE1MyAtNTlsMTA0IDEwMXEtMTA4IDEwMCAtMjU3IDEwMHEtMTYwIDAgLTI3MiAtMTEyLjV0LTExMiAtMjcxLjV0MTEyIC0yNzEuNXQyNzIgLTExMi41cTE2NSAwIDI2Ni41IDEwNXQxMDEuNSAyNzB6TTEyNjIgNTg1CmgxMDl2MTEwaC0xMDl2MTEwaC0xMTB2LTExMGgtMTEwdi0xMTBoMTEwdi0xMTBoMTEwdjExMHpNMTUzNiAxMTIwdi05NjBxMCAtMTE5IC04NC41IC0yMDMuNXQtMjAzLjUgLTg0LjVoLTk2MHEtMTE5IDAgLTIwMy41IDg0LjV0LTg0LjUgMjAzLjV2OTYwcTAgMTE5IDg0LjUgMjAzLjV0MjAzLjUgODQuNWg5NjBxMTE5IDAgMjAzLjUgLTg0LjV0ODQuNSAtMjAzLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Imdvb2dsZV9wbHVzIiB1bmljb2RlPSImI3hmMGQ1OyIgaG9yaXotYWR2LXg9IjIzMDQiIApkPSJNMTQzNyA2MjNxMCAtMjA4IC04NyAtMzcwLjV0LTI0OCAtMjU0dC0zNjkgLTkxLjVxLTE0OSAwIC0yODUgNTh0LTIzNCAxNTZ0LTE1NiAyMzR0LTU4IDI4NXQ1OCAyODV0MTU2IDIzNHQyMzQgMTU2dDI4NSA1OHEyODYgMCA0OTEgLTE5MmwtMTk5IC0xOTFxLTExNyAxMTMgLTI5MiAxMTNxLTEyMyAwIC0yMjcuNSAtNjJ0LTE2NS41IC0xNjguNXQtNjEgLTIzMi41dDYxIC0yMzIuNXQxNjUuNSAtMTY4LjV0MjI3LjUgLTYyCnE4MyAwIDE1Mi41IDIzdDExNC41IDU3LjV0NzguNSA3OC41dDQ5IDgzdDIxLjUgNzRoLTQxNnYyNTJoNjkycTEyIC02MyAxMiAtMTIyek0yMzA0IDc0NXYtMjEwaC0yMDl2LTIwOWgtMjEwdjIwOWgtMjA5djIxMGgyMDl2MjA5aDIxMHYtMjA5aDIwOXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibW9uZXkiIHVuaWNvZGU9IiYjeGYwZDY7IiBob3Jpei1hZHYteD0iMTkyMCIgCmQ9Ik03NjggMzg0aDM4NHY5NmgtMTI4djQ0OGgtMTE0bC0xNDggLTEzN2w3NyAtODBxNDIgMzcgNTUgNTdoMnYtMjg4aC0xMjh2LTk2ek0xMjgwIDY0MHEwIC03MCAtMjEgLTE0MnQtNTkuNSAtMTM0dC0xMDEuNSAtMTAxdC0xMzggLTM5dC0xMzggMzl0LTEwMS41IDEwMXQtNTkuNSAxMzR0LTIxIDE0MnQyMSAxNDJ0NTkuNSAxMzR0MTAxLjUgMTAxdDEzOCAzOXQxMzggLTM5dDEwMS41IC0xMDF0NTkuNSAtMTM0dDIxIC0xNDJ6TTE3OTIgMzg0CnY1MTJxLTEwNiAwIC0xODEgNzV0LTc1IDE4MWgtMTE1MnEwIC0xMDYgLTc1IC0xODF0LTE4MSAtNzV2LTUxMnExMDYgMCAxODEgLTc1dDc1IC0xODFoMTE1MnEwIDEwNiA3NSAxODF0MTgxIDc1ek0xOTIwIDEyMTZ2LTExNTJxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0xNzkycS0yNiAwIC00NSAxOXQtMTkgNDV2MTE1MnEwIDI2IDE5IDQ1dDQ1IDE5aDE3OTJxMjYgMCA0NSAtMTl0MTkgLTQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjYXJldF9kb3duIiB1bmljb2RlPSImI3hmMGQ3OyIgaG9yaXotYWR2LXg9IjEwMjQiIApkPSJNMTAyNCA4MzJxMCAtMjYgLTE5IC00NWwtNDQ4IC00NDhxLTE5IC0xOSAtNDUgLTE5dC00NSAxOWwtNDQ4IDQ0OHEtMTkgMTkgLTE5IDQ1dDE5IDQ1dDQ1IDE5aDg5NnEyNiAwIDQ1IC0xOXQxOSAtNDV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNhcmV0X3VwIiB1bmljb2RlPSImI3hmMGQ4OyIgaG9yaXotYWR2LXg9IjEwMjQiIApkPSJNMTAyNCAzMjBxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC04OTZxLTI2IDAgLTQ1IDE5dC0xOSA0NXQxOSA0NWw0NDggNDQ4cTE5IDE5IDQ1IDE5dDQ1IC0xOWw0NDggLTQ0OHExOSAtMTkgMTkgLTQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjYXJldF9sZWZ0IiB1bmljb2RlPSImI3hmMGQ5OyIgaG9yaXotYWR2LXg9IjY0MCIgCmQ9Ik02NDAgMTA4OHYtODk2cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOXQtNDUgMTlsLTQ0OCA0NDhxLTE5IDE5IC0xOSA0NXQxOSA0NWw0NDggNDQ4cTE5IDE5IDQ1IDE5dDQ1IC0xOXQxOSAtNDV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNhcmV0X3JpZ2h0IiB1bmljb2RlPSImI3hmMGRhOyIgaG9yaXotYWR2LXg9IjY0MCIgCmQ9Ik01NzYgNjQwcTAgLTI2IC0xOSAtNDVsLTQ0OCAtNDQ4cS0xOSAtMTkgLTQ1IC0xOXQtNDUgMTl0LTE5IDQ1djg5NnEwIDI2IDE5IDQ1dDQ1IDE5dDQ1IC0xOWw0NDggLTQ0OHExOSAtMTkgMTkgLTQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjb2x1bW5zIiB1bmljb2RlPSImI3hmMGRiOyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNMTYwIDBoNjA4djExNTJoLTY0MHYtMTEyMHEwIC0xMyA5LjUgLTIyLjV0MjIuNSAtOS41ek0xNTM2IDMydjExMjBoLTY0MHYtMTE1Mmg2MDhxMTMgMCAyMi41IDkuNXQ5LjUgMjIuNXpNMTY2NCAxMjQ4di0xMjE2cTAgLTY2IC00NyAtMTEzdC0xMTMgLTQ3aC0xMzQ0cS02NiAwIC0xMTMgNDd0LTQ3IDExM3YxMjE2cTAgNjYgNDcgMTEzdDExMyA0N2gxMzQ0cTY2IDAgMTEzIC00N3Q0NyAtMTEzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzb3J0IiB1bmljb2RlPSImI3hmMGRjOyIgaG9yaXotYWR2LXg9IjEwMjQiIApkPSJNMTAyNCA0NDhxMCAtMjYgLTE5IC00NWwtNDQ4IC00NDhxLTE5IC0xOSAtNDUgLTE5dC00NSAxOWwtNDQ4IDQ0OHEtMTkgMTkgLTE5IDQ1dDE5IDQ1dDQ1IDE5aDg5NnEyNiAwIDQ1IC0xOXQxOSAtNDV6TTEwMjQgODMycTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtODk2cS0yNiAwIC00NSAxOXQtMTkgNDV0MTkgNDVsNDQ4IDQ0OHExOSAxOSA0NSAxOXQ0NSAtMTlsNDQ4IC00NDhxMTkgLTE5IDE5IC00NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ic29ydF9kb3duIiB1bmljb2RlPSImI3hmMGRkOyIgaG9yaXotYWR2LXg9IjEwMjQiIApkPSJNMTAyNCA0NDhxMCAtMjYgLTE5IC00NWwtNDQ4IC00NDhxLTE5IC0xOSAtNDUgLTE5dC00NSAxOWwtNDQ4IDQ0OHEtMTkgMTkgLTE5IDQ1dDE5IDQ1dDQ1IDE5aDg5NnEyNiAwIDQ1IC0xOXQxOSAtNDV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InNvcnRfdXAiIHVuaWNvZGU9IiYjeGYwZGU7IiBob3Jpei1hZHYteD0iMTAyNCIgCmQ9Ik0xMDI0IDgzMnEwIC0yNiAtMTkgLTQ1dC00NSAtMTloLTg5NnEtMjYgMCAtNDUgMTl0LTE5IDQ1dDE5IDQ1bDQ0OCA0NDhxMTkgMTkgNDUgMTl0NDUgLTE5bDQ0OCAtNDQ4cTE5IC0xOSAxOSAtNDV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImVudmVsb3BlX2FsdCIgdW5pY29kZT0iJiN4ZjBlMDsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE3OTIgODI2di03OTRxMCAtNjYgLTQ3IC0xMTN0LTExMyAtNDdoLTE0NzJxLTY2IDAgLTExMyA0N3QtNDcgMTEzdjc5NHE0NCAtNDkgMTAxIC04N3EzNjIgLTI0NiA0OTcgLTM0NXE1NyAtNDIgOTIuNSAtNjUuNXQ5NC41IC00OHQxMTAgLTI0LjVoMWgxcTUxIDAgMTEwIDI0LjV0OTQuNSA0OHQ5Mi41IDY1LjVxMTcwIDEyMyA0OTggMzQ1cTU3IDM5IDEwMCA4N3pNMTc5MiAxMTIwcTAgLTc5IC00OSAtMTUxdC0xMjIgLTEyMwpxLTM3NiAtMjYxIC00NjggLTMyNXEtMTAgLTcgLTQyLjUgLTMwLjV0LTU0IC0zOHQtNTIgLTMyLjV0LTU3LjUgLTI3dC01MCAtOWgtMWgtMXEtMjMgMCAtNTAgOXQtNTcuNSAyN3QtNTIgMzIuNXQtNTQgMzh0LTQyLjUgMzAuNXEtOTEgNjQgLTI2MiAxODIuNXQtMjA1IDE0Mi41cS02MiA0MiAtMTE3IDExNS41dC01NSAxMzYuNXEwIDc4IDQxLjUgMTMwdDExOC41IDUyaDE0NzJxNjUgMCAxMTIuNSAtNDd0NDcuNSAtMTEzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJsaW5rZWRpbiIgdW5pY29kZT0iJiN4ZjBlMTsiIApkPSJNMzQ5IDkxMXYtOTkxaC0zMzB2OTkxaDMzMHpNMzcwIDEyMTdxMSAtNzMgLTUwLjUgLTEyMnQtMTM1LjUgLTQ5aC0ycS04MiAwIC0xMzIgNDl0LTUwIDEyMnEwIDc0IDUxLjUgMTIyLjV0MTM0LjUgNDguNXQxMzMgLTQ4LjV0NTEgLTEyMi41ek0xNTM2IDQ4OHYtNTY4aC0zMjl2NTMwcTAgMTA1IC00MC41IDE2NC41dC0xMjYuNSA1OS41cS02MyAwIC0xMDUuNSAtMzQuNXQtNjMuNSAtODUuNXEtMTEgLTMwIC0xMSAtODF2LTU1M2gtMzI5CnEyIDM5OSAyIDY0N3QtMSAyOTZsLTEgNDhoMzI5di0xNDRoLTJxMjAgMzIgNDEgNTZ0NTYuNSA1MnQ4NyA0My41dDExNC41IDE1LjVxMTcxIDAgMjc1IC0xMTMuNXQxMDQgLTMzMi41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmRvIiB1bmljb2RlPSImI3hmMGUyOyIgCmQ9Ik0xNTM2IDY0MHEwIC0xNTYgLTYxIC0yOTh0LTE2NCAtMjQ1dC0yNDUgLTE2NHQtMjk4IC02MXEtMTcyIDAgLTMyNyA3Mi41dC0yNjQgMjA0LjVxLTcgMTAgLTYuNSAyMi41dDguNSAyMC41bDEzNyAxMzhxMTAgOSAyNSA5cTE2IC0yIDIzIC0xMnE3MyAtOTUgMTc5IC0xNDd0MjI1IC01MnExMDQgMCAxOTguNSA0MC41dDE2My41IDEwOS41dDEwOS41IDE2My41dDQwLjUgMTk4LjV0LTQwLjUgMTk4LjV0LTEwOS41IDE2My41CnQtMTYzLjUgMTA5LjV0LTE5OC41IDQwLjVxLTk4IDAgLTE4OCAtMzUuNXQtMTYwIC0xMDEuNWwxMzcgLTEzOHEzMSAtMzAgMTQgLTY5cS0xNyAtNDAgLTU5IC00MGgtNDQ4cS0yNiAwIC00NSAxOXQtMTkgNDV2NDQ4cTAgNDIgNDAgNTlxMzkgMTcgNjkgLTE0bDEzMCAtMTI5cTEwNyAxMDEgMjQ0LjUgMTU2LjV0Mjg0LjUgNTUuNXExNTYgMCAyOTggLTYxdDI0NSAtMTY0dDE2NCAtMjQ1dDYxIC0yOTh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImxlZ2FsIiB1bmljb2RlPSImI3hmMGUzOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTc3MSAwcTAgLTUzIC0zNyAtOTBsLTEwNyAtMTA4cS0zOSAtMzcgLTkxIC0zN3EtNTMgMCAtOTAgMzdsLTM2MyAzNjRxLTM4IDM2IC0zOCA5MHEwIDUzIDQzIDk2bC0yNTYgMjU2bC0xMjYgLTEyNnEtMTQgLTE0IC0zNCAtMTR0LTM0IDE0cTIgLTIgMTIuNSAtMTJ0MTIuNSAtMTN0MTAgLTExLjV0MTAgLTEzLjV0NiAtMTMuNXQ1LjUgLTE2LjV0MS41IC0xOHEwIC0zOCAtMjggLTY4cS0zIC0zIC0xNi41IC0xOHQtMTkgLTIwLjUKdC0xOC41IC0xNi41dC0yMiAtMTUuNXQtMjIgLTl0LTI2IC00LjVxLTQwIDAgLTY4IDI4bC00MDggNDA4cS0yOCAyOCAtMjggNjhxMCAxMyA0LjUgMjZ0OSAyMnQxNS41IDIydDE2LjUgMTguNXQyMC41IDE5dDE4IDE2LjVxMzAgMjggNjggMjhxMTAgMCAxOCAtMS41dDE2LjUgLTUuNXQxMy41IC02dDEzLjUgLTEwdDExLjUgLTEwdDEzIC0xMi41dDEyIC0xMi41cS0xNCAxNCAtMTQgMzR0MTQgMzRsMzQ4IDM0OHExNCAxNCAzNCAxNHQzNCAtMTQKcS0yIDIgLTEyLjUgMTJ0LTEyLjUgMTN0LTEwIDExLjV0LTEwIDEzLjV0LTYgMTMuNXQtNS41IDE2LjV0LTEuNSAxOHEwIDM4IDI4IDY4cTMgMyAxNi41IDE4dDE5IDIwLjV0MTguNSAxNi41dDIyIDE1LjV0MjIgOXQyNiA0LjVxNDAgMCA2OCAtMjhsNDA4IC00MDhxMjggLTI4IDI4IC02OHEwIC0xMyAtNC41IC0yNnQtOSAtMjJ0LTE1LjUgLTIydC0xNi41IC0xOC41dC0yMC41IC0xOXQtMTggLTE2LjVxLTMwIC0yOCAtNjggLTI4CnEtMTAgMCAtMTggMS41dC0xNi41IDUuNXQtMTMuNSA2dC0xMy41IDEwdC0xMS41IDEwdC0xMyAxMi41dC0xMiAxMi41cTE0IC0xNCAxNCAtMzR0LTE0IC0zNGwtMTI2IC0xMjZsMjU2IC0yNTZxNDMgNDMgOTYgNDNxNTIgMCA5MSAtMzdsMzYzIC0zNjNxMzcgLTM5IDM3IC05MXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZGFzaGJvYXJkIiB1bmljb2RlPSImI3hmMGU0OyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMzg0IDM4NHEwIDUzIC0zNy41IDkwLjV0LTkwLjUgMzcuNXQtOTAuNSAtMzcuNXQtMzcuNSAtOTAuNXQzNy41IC05MC41dDkwLjUgLTM3LjV0OTAuNSAzNy41dDM3LjUgOTAuNXpNNTc2IDgzMnEwIDUzIC0zNy41IDkwLjV0LTkwLjUgMzcuNXQtOTAuNSAtMzcuNXQtMzcuNSAtOTAuNXQzNy41IC05MC41dDkwLjUgLTM3LjV0OTAuNSAzNy41dDM3LjUgOTAuNXpNMTAwNCAzNTFsMTAxIDM4MnE2IDI2IC03LjUgNDguNXQtMzguNSAyOS41CnQtNDggLTYuNXQtMzAgLTM5LjVsLTEwMSAtMzgycS02MCAtNSAtMTA3IC00My41dC02MyAtOTguNXEtMjAgLTc3IDIwIC0xNDZ0MTE3IC04OXQxNDYgMjB0ODkgMTE3cTE2IDYwIC02IDExN3QtNzIgOTF6TTE2NjQgMzg0cTAgNTMgLTM3LjUgOTAuNXQtOTAuNSAzNy41dC05MC41IC0zNy41dC0zNy41IC05MC41dDM3LjUgLTkwLjV0OTAuNSAtMzcuNXQ5MC41IDM3LjV0MzcuNSA5MC41ek0xMDI0IDEwMjRxMCA1MyAtMzcuNSA5MC41CnQtOTAuNSAzNy41dC05MC41IC0zNy41dC0zNy41IC05MC41dDM3LjUgLTkwLjV0OTAuNSAtMzcuNXQ5MC41IDM3LjV0MzcuNSA5MC41ek0xNDcyIDgzMnEwIDUzIC0zNy41IDkwLjV0LTkwLjUgMzcuNXQtOTAuNSAtMzcuNXQtMzcuNSAtOTAuNXQzNy41IC05MC41dDkwLjUgLTM3LjV0OTAuNSAzNy41dDM3LjUgOTAuNXpNMTc5MiAzODRxMCAtMjYxIC0xNDEgLTQ4M3EtMTkgLTI5IC01NCAtMjloLTE0MDJxLTM1IDAgLTU0IDI5CnEtMTQxIDIyMSAtMTQxIDQ4M3EwIDE4MiA3MSAzNDh0MTkxIDI4NnQyODYgMTkxdDM0OCA3MXQzNDggLTcxdDI4NiAtMTkxdDE5MSAtMjg2dDcxIC0zNDh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNvbW1lbnRfYWx0IiB1bmljb2RlPSImI3hmMGU1OyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNODk2IDExNTJxLTIwNCAwIC0zODEuNSAtNjkuNXQtMjgyIC0xODcuNXQtMTA0LjUgLTI1NXEwIC0xMTIgNzEuNSAtMjEzLjV0MjAxLjUgLTE3NS41bDg3IC01MGwtMjcgLTk2cS0yNCAtOTEgLTcwIC0xNzJxMTUyIDYzIDI3NSAxNzFsNDMgMzhsNTcgLTZxNjkgLTggMTMwIC04cTIwNCAwIDM4MS41IDY5LjV0MjgyIDE4Ny41dDEwNC41IDI1NXQtMTA0LjUgMjU1dC0yODIgMTg3LjV0LTM4MS41IDY5LjV6TTE3OTIgNjQwCnEwIC0xNzQgLTEyMCAtMzIxLjV0LTMyNiAtMjMzdC00NTAgLTg1LjVxLTcwIDAgLTE0NSA4cS0xOTggLTE3NSAtNDYwIC0yNDJxLTQ5IC0xNCAtMTE0IC0yMmgtNXEtMTUgMCAtMjcgMTAuNXQtMTYgMjcuNXYxcS0zIDQgLTAuNSAxMnQyIDEwdDQuNSA5LjVsNiA5dDcgOC41dDggOXE3IDggMzEgMzQuNXQzNC41IDM4dDMxIDM5LjV0MzIuNSA1MXQyNyA1OXQyNiA3NnEtMTU3IDg5IC0yNDcuNSAyMjB0LTkwLjUgMjgxcTAgMTc0IDEyMCAzMjEuNQp0MzI2IDIzM3Q0NTAgODUuNXQ0NTAgLTg1LjV0MzI2IC0yMzN0MTIwIC0zMjEuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY29tbWVudHNfYWx0IiB1bmljb2RlPSImI3hmMGU2OyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNNzA0IDExNTJxLTE1MyAwIC0yODYgLTUydC0yMTEuNSAtMTQxdC03OC41IC0xOTFxMCAtODIgNTMgLTE1OHQxNDkgLTEzMmw5NyAtNTZsLTM1IC04NHEzNCAyMCA2MiAzOWw0NCAzMWw1MyAtMTBxNzggLTE0IDE1MyAtMTRxMTUzIDAgMjg2IDUydDIxMS41IDE0MXQ3OC41IDE5MXQtNzguNSAxOTF0LTIxMS41IDE0MXQtMjg2IDUyek03MDQgMTI4MHExOTEgMCAzNTMuNSAtNjguNXQyNTYuNSAtMTg2LjV0OTQgLTI1N3QtOTQgLTI1Nwp0LTI1Ni41IC0xODYuNXQtMzUzLjUgLTY4LjVxLTg2IDAgLTE3NiAxNnEtMTI0IC04OCAtMjc4IC0xMjhxLTM2IC05IC04NiAtMTZoLTNxLTExIDAgLTIwLjUgOHQtMTEuNSAyMXEtMSAzIC0xIDYuNXQwLjUgNi41dDIgNmwyLjUgNXQzLjUgNS41dDQgNXQ0LjUgNXQ0IDQuNXE1IDYgMjMgMjV0MjYgMjkuNXQyMi41IDI5dDI1IDM4LjV0MjAuNSA0NHEtMTI0IDcyIC0xOTUgMTc3dC03MSAyMjRxMCAxMzkgOTQgMjU3dDI1Ni41IDE4Ni41CnQzNTMuNSA2OC41ek0xNTI2IDExMXExMCAtMjQgMjAuNSAtNDR0MjUgLTM4LjV0MjIuNSAtMjl0MjYgLTI5LjV0MjMgLTI1cTEgLTEgNCAtNC41dDQuNSAtNXQ0IC01dDMuNSAtNS41bDIuNSAtNXQyIC02dDAuNSAtNi41dC0xIC02LjVxLTMgLTE0IC0xMyAtMjJ0LTIyIC03cS01MCA3IC04NiAxNnEtMTU0IDQwIC0yNzggMTI4cS05MCAtMTYgLTE3NiAtMTZxLTI3MSAwIC00NzIgMTMycTU4IC00IDg4IC00cTE2MSAwIDMwOSA0NXQyNjQgMTI5CnExMjUgOTIgMTkyIDIxMnQ2NyAyNTRxMCA3NyAtMjMgMTUycTEyOSAtNzEgMjA0IC0xNzh0NzUgLTIzMHEwIC0xMjAgLTcxIC0yMjQuNXQtMTk1IC0xNzYuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYm9sdCIgdW5pY29kZT0iJiN4ZjBlNzsiIGhvcml6LWFkdi14PSI4OTYiIApkPSJNODg1IDk3MHExOCAtMjAgNyAtNDRsLTU0MCAtMTE1N3EtMTMgLTI1IC00MiAtMjVxLTQgMCAtMTQgMnEtMTcgNSAtMjUuNSAxOXQtNC41IDMwbDE5NyA4MDhsLTQwNiAtMTAxcS00IC0xIC0xMiAtMXEtMTggMCAtMzEgMTFxLTE4IDE1IC0xMyAzOWwyMDEgODI1cTQgMTQgMTYgMjN0MjggOWgzMjhxMTkgMCAzMiAtMTIuNXQxMyAtMjkuNXEwIC04IC01IC0xOGwtMTcxIC00NjNsMzk2IDk4cTggMiAxMiAycTE5IDAgMzQgLTE1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzaXRlbWFwIiB1bmljb2RlPSImI3hmMGU4OyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTc5MiAyODh2LTMyMHEwIC00MCAtMjggLTY4dC02OCAtMjhoLTMyMHEtNDAgMCAtNjggMjh0LTI4IDY4djMyMHEwIDQwIDI4IDY4dDY4IDI4aDk2djE5MmgtNTEydi0xOTJoOTZxNDAgMCA2OCAtMjh0MjggLTY4di0zMjBxMCAtNDAgLTI4IC02OHQtNjggLTI4aC0zMjBxLTQwIDAgLTY4IDI4dC0yOCA2OHYzMjBxMCA0MCAyOCA2OHQ2OCAyOGg5NnYxOTJoLTUxMnYtMTkyaDk2cTQwIDAgNjggLTI4dDI4IC02OHYtMzIwCnEwIC00MCAtMjggLTY4dC02OCAtMjhoLTMyMHEtNDAgMCAtNjggMjh0LTI4IDY4djMyMHEwIDQwIDI4IDY4dDY4IDI4aDk2djE5MnEwIDUyIDM4IDkwdDkwIDM4aDUxMnYxOTJoLTk2cS00MCAwIC02OCAyOHQtMjggNjh2MzIwcTAgNDAgMjggNjh0NjggMjhoMzIwcTQwIDAgNjggLTI4dDI4IC02OHYtMzIwcTAgLTQwIC0yOCAtNjh0LTY4IC0yOGgtOTZ2LTE5Mmg1MTJxNTIgMCA5MCAtMzh0MzggLTkwdi0xOTJoOTZxNDAgMCA2OCAtMjh0MjggLTY4CnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW1icmVsbGEiIHVuaWNvZGU9IiYjeGYwZTk7IiBob3Jpei1hZHYteD0iMTY2NCIgCmQ9Ik04OTYgNzA4di01ODBxMCAtMTA0IC03NiAtMTgwdC0xODAgLTc2dC0xODAgNzZ0LTc2IDE4MHEwIDI2IDE5IDQ1dDQ1IDE5dDQ1IC0xOXQxOSAtNDVxMCAtNTAgMzkgLTg5dDg5IC0zOXQ4OSAzOXQzOSA4OXY1ODBxMzMgMTEgNjQgMTF0NjQgLTExek0xNjY0IDY4MXEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVxLTExIDAgLTIzIDEwcS00OSA0NiAtOTMgNjl0LTEwMiAyM3EtNjggMCAtMTI4IC0zN3QtMTAzIC05NwpxLTcgLTEwIC0xNy41IC0yOHQtMTQuNSAtMjRxLTExIC0xNyAtMjggLTE3cS0xOCAwIC0yOSAxN3EtNCA2IC0xNC41IDI0dC0xNy41IDI4cS00MyA2MCAtMTAyLjUgOTd0LTEyNy41IDM3dC0xMjcuNSAtMzd0LTEwMi41IC05N3EtNyAtMTAgLTE3LjUgLTI4dC0xNC41IC0yNHEtMTEgLTE3IC0yOSAtMTdxLTE3IDAgLTI4IDE3cS00IDYgLTE0LjUgMjR0LTE3LjUgMjhxLTQzIDYwIC0xMDMgOTd0LTEyOCAzN3EtNTggMCAtMTAyIC0yM3QtOTMgLTY5CnEtMTIgLTEwIC0yMyAtMTBxLTEzIDAgLTIyLjUgOS41dC05LjUgMjIuNXEwIDUgMSA3cTQ1IDE4MyAxNzIuNSAzMTkuNXQyOTggMjA0LjV0MzYwLjUgNjhxMTQwIDAgMjc0LjUgLTQwdDI0Ni41IC0xMTMuNXQxOTQuNSAtMTg3dDExNS41IC0yNTEuNXExIC0yIDEgLTd6TTg5NiAxNDA4di05OHEtNDIgMiAtNjQgMnQtNjQgLTJ2OThxMCAyNiAxOSA0NXQ0NSAxOXQ0NSAtMTl0MTkgLTQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJwYXN0ZSIgdW5pY29kZT0iJiN4ZjBlYTsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTc2OCAtMTI4aDg5NnY2NDBoLTQxNnEtNDAgMCAtNjggMjh0LTI4IDY4djQxNmgtMzg0di0xMTUyek0xMDI0IDEzMTJ2NjRxMCAxMyAtOS41IDIyLjV0LTIyLjUgOS41aC03MDRxLTEzIDAgLTIyLjUgLTkuNXQtOS41IC0yMi41di02NHEwIC0xMyA5LjUgLTIyLjV0MjIuNSAtOS41aDcwNHExMyAwIDIyLjUgOS41dDkuNSAyMi41ek0xMjgwIDY0MGgyOTlsLTI5OSAyOTl2LTI5OXpNMTc5MiA1MTJ2LTY3MnEwIC00MCAtMjggLTY4dC02OCAtMjgKaC05NjBxLTQwIDAgLTY4IDI4dC0yOCA2OHYxNjBoLTU0NHEtNDAgMCAtNjggMjh0LTI4IDY4djEzNDRxMCA0MCAyOCA2OHQ2OCAyOGgxMDg4cTQwIDAgNjggLTI4dDI4IC02OHYtMzI4cTIxIC0xMyAzNiAtMjhsNDA4IC00MDhxMjggLTI4IDQ4IC03NnQyMCAtODh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImxpZ2h0X2J1bGIiIHVuaWNvZGU9IiYjeGYwZWI7IiBob3Jpei1hZHYteD0iMTAyNCIgCmQ9Ik03MzYgOTYwcTAgLTEzIC05LjUgLTIyLjV0LTIyLjUgLTkuNXQtMjIuNSA5LjV0LTkuNSAyMi41cTAgNDYgLTU0IDcxdC0xMDYgMjVxLTEzIDAgLTIyLjUgOS41dC05LjUgMjIuNXQ5LjUgMjIuNXQyMi41IDkuNXE1MCAwIDk5LjUgLTE2dDg3IC01NHQzNy41IC05MHpNODk2IDk2MHEwIDcyIC0zNC41IDEzNHQtOTAgMTAxLjV0LTEyMyA2MnQtMTM2LjUgMjIuNXQtMTM2LjUgLTIyLjV0LTEyMyAtNjJ0LTkwIC0xMDEuNXQtMzQuNSAtMTM0CnEwIC0xMDEgNjggLTE4MHExMCAtMTEgMzAuNSAtMzN0MzAuNSAtMzNxMTI4IC0xNTMgMTQxIC0yOThoMjI4cTEzIDE0NSAxNDEgMjk4cTEwIDExIDMwLjUgMzN0MzAuNSAzM3E2OCA3OSA2OCAxODB6TTEwMjQgOTYwcTAgLTE1NSAtMTAzIC0yNjhxLTQ1IC00OSAtNzQuNSAtODd0LTU5LjUgLTk1LjV0LTM0IC0xMDcuNXE0NyAtMjggNDcgLTgycTAgLTM3IC0yNSAtNjRxMjUgLTI3IDI1IC02NHEwIC01MiAtNDUgLTgxcTEzIC0yMyAxMyAtNDcKcTAgLTQ2IC0zMS41IC03MXQtNzcuNSAtMjVxLTIwIC00NCAtNjAgLTcwdC04NyAtMjZ0LTg3IDI2dC02MCA3MHEtNDYgMCAtNzcuNSAyNXQtMzEuNSA3MXEwIDI0IDEzIDQ3cS00NSAyOSAtNDUgODFxMCAzNyAyNSA2NHEtMjUgMjcgLTI1IDY0cTAgNTQgNDcgODJxLTQgNTAgLTM0IDEwNy41dC01OS41IDk1LjV0LTc0LjUgODdxLTEwMyAxMTMgLTEwMyAyNjhxMCA5OSA0NC41IDE4NC41dDExNyAxNDJ0MTY0IDg5dDE4Ni41IDMyLjUKdDE4Ni41IC0zMi41dDE2NCAtODl0MTE3IC0xNDJ0NDQuNSAtMTg0LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImV4Y2hhbmdlIiB1bmljb2RlPSImI3hmMGVjOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTc5MiAzNTJ2LTE5MnEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTEzNzZ2LTE5MnEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVxLTEyIDAgLTI0IDEwbC0zMTkgMzIwcS05IDkgLTkgMjJxMCAxNCA5IDIzbDMyMCAzMjBxOSA5IDIzIDlxMTMgMCAyMi41IC05LjV0OS41IC0yMi41di0xOTJoMTM3NnExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6TTE3OTIgODk2cTAgLTE0IC05IC0yM2wtMzIwIC0zMjBxLTkgLTkgLTIzIC05CnEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djE5MmgtMTM3NnEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djE5MnEwIDEzIDkuNSAyMi41dDIyLjUgOS41aDEzNzZ2MTkycTAgMTQgOSAyM3QyMyA5cTEyIDAgMjQgLTEwbDMxOSAtMzE5cTkgLTkgOSAtMjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNsb3VkX2Rvd25sb2FkIiB1bmljb2RlPSImI3hmMGVkOyIgaG9yaXotYWR2LXg9IjE5MjAiIApkPSJNMTI4MCA2MDhxMCAxNCAtOSAyM3QtMjMgOWgtMjI0djM1MnEwIDEzIC05LjUgMjIuNXQtMjIuNSA5LjVoLTE5MnEtMTMgMCAtMjIuNSAtOS41dC05LjUgLTIyLjV2LTM1MmgtMjI0cS0xMyAwIC0yMi41IC05LjV0LTkuNSAtMjIuNXEwIC0xNCA5IC0yM2wzNTIgLTM1MnE5IC05IDIzIC05dDIzIDlsMzUxIDM1MXExMCAxMiAxMCAyNHpNMTkyMCAzODRxMCAtMTU5IC0xMTIuNSAtMjcxLjV0LTI3MS41IC0xMTIuNWgtMTA4OApxLTE4NSAwIC0zMTYuNSAxMzEuNXQtMTMxLjUgMzE2LjVxMCAxMzAgNzAgMjQwdDE4OCAxNjVxLTIgMzAgLTIgNDNxMCAyMTIgMTUwIDM2MnQzNjIgMTUwcTE1NiAwIDI4NS41IC04N3QxODguNSAtMjMxcTcxIDYyIDE2NiA2MnExMDYgMCAxODEgLTc1dDc1IC0xODFxMCAtNzYgLTQxIC0xMzhxMTMwIC0zMSAyMTMuNSAtMTM1LjV0ODMuNSAtMjM4LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNsb3VkX3VwbG9hZCIgdW5pY29kZT0iJiN4ZjBlZTsiIGhvcml6LWFkdi14PSIxOTIwIiAKZD0iTTEyODAgNjcycTAgMTQgLTkgMjNsLTM1MiAzNTJxLTkgOSAtMjMgOXQtMjMgLTlsLTM1MSAtMzUxcS0xMCAtMTIgLTEwIC0yNHEwIC0xNCA5IC0yM3QyMyAtOWgyMjR2LTM1MnEwIC0xMyA5LjUgLTIyLjV0MjIuNSAtOS41aDE5MnExMyAwIDIyLjUgOS41dDkuNSAyMi41djM1MmgyMjRxMTMgMCAyMi41IDkuNXQ5LjUgMjIuNXpNMTkyMCAzODRxMCAtMTU5IC0xMTIuNSAtMjcxLjV0LTI3MS41IC0xMTIuNWgtMTA4OApxLTE4NSAwIC0zMTYuNSAxMzEuNXQtMTMxLjUgMzE2LjVxMCAxMzAgNzAgMjQwdDE4OCAxNjVxLTIgMzAgLTIgNDNxMCAyMTIgMTUwIDM2MnQzNjIgMTUwcTE1NiAwIDI4NS41IC04N3QxODguNSAtMjMxcTcxIDYyIDE2NiA2MnExMDYgMCAxODEgLTc1dDc1IC0xODFxMCAtNzYgLTQxIC0xMzhxMTMwIC0zMSAyMTMuNSAtMTM1LjV0ODMuNSAtMjM4LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVzZXJfbWQiIHVuaWNvZGU9IiYjeGYwZjA7IiBob3Jpei1hZHYteD0iMTQwOCIgCmQ9Ik0zODQgMTkycTAgLTI2IC0xOSAtNDV0LTQ1IC0xOXQtNDUgMTl0LTE5IDQ1dDE5IDQ1dDQ1IDE5dDQ1IC0xOXQxOSAtNDV6TTE0MDggMTMxcTAgLTEyMSAtNzMgLTE5MHQtMTk0IC02OWgtODc0cS0xMjEgMCAtMTk0IDY5dC03MyAxOTBxMCA2OCA1LjUgMTMxdDI0IDEzOHQ0Ny41IDEzMi41dDgxIDEwM3QxMjAgNjAuNXEtMjIgLTUyIC0yMiAtMTIwdi0yMDNxLTU4IC0yMCAtOTMgLTcwdC0zNSAtMTExcTAgLTgwIDU2IC0xMzZ0MTM2IC01Ngp0MTM2IDU2dDU2IDEzNnEwIDYxIC0zNS41IDExMXQtOTIuNSA3MHYyMDNxMCA2MiAyNSA5M3ExMzIgLTEwNCAyOTUgLTEwNHQyOTUgMTA0cTI1IC0zMSAyNSAtOTN2LTY0cS0xMDYgMCAtMTgxIC03NXQtNzUgLTE4MXYtODlxLTMyIC0yOSAtMzIgLTcxcTAgLTQwIDI4IC02OHQ2OCAtMjh0NjggMjh0MjggNjhxMCA0MiAtMzIgNzF2ODlxMCA1MiAzOCA5MHQ5MCAzOHQ5MCAtMzh0MzggLTkwdi04OXEtMzIgLTI5IC0zMiAtNzFxMCAtNDAgMjggLTY4CnQ2OCAtMjh0NjggMjh0MjggNjhxMCA0MiAtMzIgNzF2ODlxMCA2OCAtMzQuNSAxMjcuNXQtOTMuNSA5My41cTAgMTAgMC41IDQyLjV0MCA0OHQtMi41IDQxLjV0LTcgNDd0LTEzIDQwcTY4IC0xNSAxMjAgLTYwLjV0ODEgLTEwM3Q0Ny41IC0xMzIuNXQyNCAtMTM4dDUuNSAtMTMxek0xMDg4IDEwMjRxMCAtMTU5IC0xMTIuNSAtMjcxLjV0LTI3MS41IC0xMTIuNXQtMjcxLjUgMTEyLjV0LTExMi41IDI3MS41dDExMi41IDI3MS41dDI3MS41IDExMi41CnQyNzEuNSAtMTEyLjV0MTEyLjUgLTI3MS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzdGV0aG9zY29wZSIgdW5pY29kZT0iJiN4ZjBmMTsiIGhvcml6LWFkdi14PSIxNDA4IiAKZD0iTTEyODAgODMycTAgMjYgLTE5IDQ1dC00NSAxOXQtNDUgLTE5dC0xOSAtNDV0MTkgLTQ1dDQ1IC0xOXQ0NSAxOXQxOSA0NXpNMTQwOCA4MzJxMCAtNjIgLTM1LjUgLTExMXQtOTIuNSAtNzB2LTM5NXEwIC0xNTkgLTEzMS41IC0yNzEuNXQtMzE2LjUgLTExMi41dC0zMTYuNSAxMTIuNXQtMTMxLjUgMjcxLjV2MTMycS0xNjQgMjAgLTI3NCAxMjh0LTExMCAyNTJ2NTEycTAgMjYgMTkgNDV0NDUgMTlxNiAwIDE2IC0ycTE3IDMwIDQ3IDQ4CnQ2NSAxOHE1MyAwIDkwLjUgLTM3LjV0MzcuNSAtOTAuNXQtMzcuNSAtOTAuNXQtOTAuNSAtMzcuNXEtMzMgMCAtNjQgMTh2LTQwMnEwIC0xMDYgOTQgLTE4MXQyMjYgLTc1dDIyNiA3NXQ5NCAxODF2NDAycS0zMSAtMTggLTY0IC0xOHEtNTMgMCAtOTAuNSAzNy41dC0zNy41IDkwLjV0MzcuNSA5MC41dDkwLjUgMzcuNXEzNSAwIDY1IC0xOHQ0NyAtNDhxMTAgMiAxNiAycTI2IDAgNDUgLTE5dDE5IC00NXYtNTEycTAgLTE0NCAtMTEwIC0yNTIKdC0yNzQgLTEyOHYtMTMycTAgLTEwNiA5NCAtMTgxdDIyNiAtNzV0MjI2IDc1dDk0IDE4MXYzOTVxLTU3IDIxIC05Mi41IDcwdC0zNS41IDExMXEwIDgwIDU2IDEzNnQxMzYgNTZ0MTM2IC01NnQ1NiAtMTM2eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzdWl0Y2FzZSIgdW5pY29kZT0iJiN4ZjBmMjsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTY0MCAxMTUyaDUxMnYxMjhoLTUxMnYtMTI4ek0yODggMTE1MnYtMTI4MGgtNjRxLTkyIDAgLTE1OCA2NnQtNjYgMTU4djgzMnEwIDkyIDY2IDE1OHQxNTggNjZoNjR6TTE0MDggMTE1MnYtMTI4MGgtMTAyNHYxMjgwaDEyOHYxNjBxMCA0MCAyOCA2OHQ2OCAyOGg1NzZxNDAgMCA2OCAtMjh0MjggLTY4di0xNjBoMTI4ek0xNzkyIDkyOHYtODMycTAgLTkyIC02NiAtMTU4dC0xNTggLTY2aC02NHYxMjgwaDY0cTkyIDAgMTU4IC02Ngp0NjYgLTE1OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYmVsbF9hbHQiIHVuaWNvZGU9IiYjeGYwZjM7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik05MTIgLTE2MHEwIDE2IC0xNiAxNnEtNTkgMCAtMTAxLjUgNDIuNXQtNDIuNSAxMDEuNXEwIDE2IC0xNiAxNnQtMTYgLTE2cTAgLTczIDUxLjUgLTEyNC41dDEyNC41IC01MS41cTE2IDAgMTYgMTZ6TTE3MjggMTI4cTAgLTUyIC0zOCAtOTB0LTkwIC0zOGgtNDQ4cTAgLTEwNiAtNzUgLTE4MXQtMTgxIC03NXQtMTgxIDc1dC03NSAxODFoLTQ0OHEtNTIgMCAtOTAgMzh0LTM4IDkwcTUwIDQyIDkxIDg4dDg1IDExOS41dDc0LjUgMTU4LjUKdDUwIDIwNnQxOS41IDI2MHEwIDE1MiAxMTcgMjgyLjV0MzA3IDE1OC41cS04IDE5IC04IDM5cTAgNDAgMjggNjh0NjggMjh0NjggLTI4dDI4IC02OHEwIC0yMCAtOCAtMzlxMTkwIC0yOCAzMDcgLTE1OC41dDExNyAtMjgyLjVxMCAtMTM5IDE5LjUgLTI2MHQ1MCAtMjA2dDc0LjUgLTE1OC41dDg1IC0xMTkuNXQ5MSAtODh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNvZmZlZSIgdW5pY29kZT0iJiN4ZjBmNDsiIGhvcml6LWFkdi14PSIxOTIwIiAKZD0iTTE2NjQgODk2cTAgODAgLTU2IDEzNnQtMTM2IDU2aC02NHYtMzg0aDY0cTgwIDAgMTM2IDU2dDU2IDEzNnpNMCAxMjhoMTc5MnEwIC0xMDYgLTc1IC0xODF0LTE4MSAtNzVoLTEyODBxLTEwNiAwIC0xODEgNzV0LTc1IDE4MXpNMTg1NiA4OTZxMCAtMTU5IC0xMTIuNSAtMjcxLjV0LTI3MS41IC0xMTIuNWgtNjR2LTMycTAgLTkyIC02NiAtMTU4dC0xNTggLTY2aC03MDRxLTkyIDAgLTE1OCA2NnQtNjYgMTU4djczNnEwIDI2IDE5IDQ1CnQ0NSAxOWgxMTUycTE1OSAwIDI3MS41IC0xMTIuNXQxMTIuNSAtMjcxLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImZvb2QiIHVuaWNvZGU9IiYjeGYwZjU7IiBob3Jpei1hZHYteD0iMTQwOCIgCmQ9Ik02NDAgMTQ3MnYtNjQwcTAgLTYxIC0zNS41IC0xMTF0LTkyLjUgLTcwdi03NzlxMCAtNTIgLTM4IC05MHQtOTAgLTM4aC0xMjhxLTUyIDAgLTkwIDM4dC0zOCA5MHY3NzlxLTU3IDIwIC05Mi41IDcwdC0zNS41IDExMXY2NDBxMCAyNiAxOSA0NXQ0NSAxOXQ0NSAtMTl0MTkgLTQ1di00MTZxMCAtMjYgMTkgLTQ1dDQ1IC0xOXQ0NSAxOXQxOSA0NXY0MTZxMCAyNiAxOSA0NXQ0NSAxOXQ0NSAtMTl0MTkgLTQ1di00MTZxMCAtMjYgMTkgLTQ1CnQ0NSAtMTl0NDUgMTl0MTkgNDV2NDE2cTAgMjYgMTkgNDV0NDUgMTl0NDUgLTE5dDE5IC00NXpNMTQwOCAxNDcydi0xNjAwcTAgLTUyIC0zOCAtOTB0LTkwIC0zOGgtMTI4cS01MiAwIC05MCAzOHQtMzggOTB2NTEyaC0yMjRxLTEzIDAgLTIyLjUgOS41dC05LjUgMjIuNXY4MDBxMCAxMzIgOTQgMjI2dDIyNiA5NGgyNTZxMjYgMCA0NSAtMTl0MTkgLTQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJmaWxlX3RleHRfYWx0IiB1bmljb2RlPSImI3hmMGY2OyIgCmQ9Ik0xNDY4IDExNTZxMjggLTI4IDQ4IC03NnQyMCAtODh2LTExNTJxMCAtNDAgLTI4IC02OHQtNjggLTI4aC0xMzQ0cS00MCAwIC02OCAyOHQtMjggNjh2MTYwMHEwIDQwIDI4IDY4dDY4IDI4aDg5NnE0MCAwIDg4IC0yMHQ3NiAtNDh6TTEwMjQgMTQwMHYtMzc2aDM3NnEtMTAgMjkgLTIyIDQxbC0zMTMgMzEzcS0xMiAxMiAtNDEgMjJ6TTE0MDggLTEyOHYxMDI0aC00MTZxLTQwIDAgLTY4IDI4dC0yOCA2OHY0MTZoLTc2OHYtMTUzNmgxMjgwegpNMzg0IDczNnEwIDE0IDkgMjN0MjMgOWg3MDRxMTQgMCAyMyAtOXQ5IC0yM3YtNjRxMCAtMTQgLTkgLTIzdC0yMyAtOWgtNzA0cS0xNCAwIC0yMyA5dC05IDIzdjY0ek0xMTIwIDUxMnExNCAwIDIzIC05dDkgLTIzdi02NHEwIC0xNCAtOSAtMjN0LTIzIC05aC03MDRxLTE0IDAgLTIzIDl0LTkgMjN2NjRxMCAxNCA5IDIzdDIzIDloNzA0ek0xMTIwIDI1NnExNCAwIDIzIC05dDkgLTIzdi02NHEwIC0xNCAtOSAtMjN0LTIzIC05aC03MDQKcS0xNCAwIC0yMyA5dC05IDIzdjY0cTAgMTQgOSAyM3QyMyA5aDcwNHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYnVpbGRpbmciIHVuaWNvZGU9IiYjeGYwZjc7IiBob3Jpei1hZHYteD0iMTQwOCIgCmQ9Ik0zODQgMjI0di02NHEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTY0cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2NjRxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWg2NHExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6TTM4NCA0ODB2LTY0cTAgLTEzIC05LjUgLTIyLjV0LTIyLjUgLTkuNWgtNjRxLTEzIDAgLTIyLjUgOS41dC05LjUgMjIuNXY2NHEwIDEzIDkuNSAyMi41dDIyLjUgOS41aDY0cTEzIDAgMjIuNSAtOS41dDkuNSAtMjIuNXoKTTY0MCA0ODB2LTY0cTAgLTEzIC05LjUgLTIyLjV0LTIyLjUgLTkuNWgtNjRxLTEzIDAgLTIyLjUgOS41dC05LjUgMjIuNXY2NHEwIDEzIDkuNSAyMi41dDIyLjUgOS41aDY0cTEzIDAgMjIuNSAtOS41dDkuNSAtMjIuNXpNMzg0IDczNnYtNjRxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC02NHEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djY0cTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoNjRxMTMgMCAyMi41IC05LjV0OS41IC0yMi41egpNMTE1MiAyMjR2LTY0cTAgLTEzIC05LjUgLTIyLjV0LTIyLjUgLTkuNWgtNjRxLTEzIDAgLTIyLjUgOS41dC05LjUgMjIuNXY2NHEwIDEzIDkuNSAyMi41dDIyLjUgOS41aDY0cTEzIDAgMjIuNSAtOS41dDkuNSAtMjIuNXpNODk2IDQ4MHYtNjRxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC02NHEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djY0cTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoNjRxMTMgMCAyMi41IC05LjV0OS41IC0yMi41egpNNjQwIDczNnYtNjRxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC02NHEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djY0cTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoNjRxMTMgMCAyMi41IC05LjV0OS41IC0yMi41ek0zODQgOTkydi02NHEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTY0cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2NjRxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWg2NHExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6Ck0xMTUyIDQ4MHYtNjRxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC02NHEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djY0cTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoNjRxMTMgMCAyMi41IC05LjV0OS41IC0yMi41ek04OTYgNzM2di02NHEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTY0cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2NjRxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWg2NHExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6Ck02NDAgOTkydi02NHEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTY0cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2NjRxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWg2NHExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6TTM4NCAxMjQ4di02NHEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTY0cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2NjRxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWg2NHExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6Ck0xMTUyIDczNnYtNjRxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC02NHEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djY0cTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoNjRxMTMgMCAyMi41IC05LjV0OS41IC0yMi41ek04OTYgOTkydi02NHEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTY0cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2NjRxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWg2NHExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6Ck02NDAgMTI0OHYtNjRxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC02NHEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djY0cTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoNjRxMTMgMCAyMi41IC05LjV0OS41IC0yMi41ek0xMTUyIDk5MnYtNjRxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC02NHEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djY0cTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoNjRxMTMgMCAyMi41IC05LjV0OS41IC0yMi41egpNODk2IDEyNDh2LTY0cTAgLTEzIC05LjUgLTIyLjV0LTIyLjUgLTkuNWgtNjRxLTEzIDAgLTIyLjUgOS41dC05LjUgMjIuNXY2NHEwIDEzIDkuNSAyMi41dDIyLjUgOS41aDY0cTEzIDAgMjIuNSAtOS41dDkuNSAtMjIuNXpNMTE1MiAxMjQ4di02NHEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTY0cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2NjRxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWg2NHExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6Ck04OTYgLTEyOGgzODR2MTUzNmgtMTE1MnYtMTUzNmgzODR2MjI0cTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoMzIwcTEzIDAgMjIuNSAtOS41dDkuNSAtMjIuNXYtMjI0ek0xNDA4IDE0NzJ2LTE2NjRxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0xMjgwcS0yNiAwIC00NSAxOXQtMTkgNDV2MTY2NHEwIDI2IDE5IDQ1dDQ1IDE5aDEyODBxMjYgMCA0NSAtMTl0MTkgLTQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJob3NwaXRhbCIgdW5pY29kZT0iJiN4ZjBmODsiIGhvcml6LWFkdi14PSIxNDA4IiAKZD0iTTM4NCAyMjR2LTY0cTAgLTEzIC05LjUgLTIyLjV0LTIyLjUgLTkuNWgtNjRxLTEzIDAgLTIyLjUgOS41dC05LjUgMjIuNXY2NHEwIDEzIDkuNSAyMi41dDIyLjUgOS41aDY0cTEzIDAgMjIuNSAtOS41dDkuNSAtMjIuNXpNMzg0IDQ4MHYtNjRxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC02NHEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djY0cTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoNjRxMTMgMCAyMi41IC05LjV0OS41IC0yMi41egpNNjQwIDQ4MHYtNjRxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC02NHEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djY0cTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoNjRxMTMgMCAyMi41IC05LjV0OS41IC0yMi41ek0zODQgNzM2di02NHEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTY0cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2NjRxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWg2NHExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6Ck0xMTUyIDIyNHYtNjRxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC02NHEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djY0cTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoNjRxMTMgMCAyMi41IC05LjV0OS41IC0yMi41ek04OTYgNDgwdi02NHEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTY0cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2NjRxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWg2NHExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6Ck02NDAgNzM2di02NHEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTY0cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2NjRxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWg2NHExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6TTExNTIgNDgwdi02NHEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTY0cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2NjRxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWg2NHExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6Ck04OTYgNzM2di02NHEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTY0cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2NjRxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWg2NHExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6TTExNTIgNzM2di02NHEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTY0cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2NjRxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWg2NHExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6Ck04OTYgLTEyOGgzODR2MTE1MmgtMjU2di0zMnEwIC00MCAtMjggLTY4dC02OCAtMjhoLTQ0OHEtNDAgMCAtNjggMjh0LTI4IDY4djMyaC0yNTZ2LTExNTJoMzg0djIyNHEwIDEzIDkuNSAyMi41dDIyLjUgOS41aDMyMHExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV2LTIyNHpNODk2IDEwNTZ2MzIwcTAgMTMgLTkuNSAyMi41dC0yMi41IDkuNWgtNjRxLTEzIDAgLTIyLjUgLTkuNXQtOS41IC0yMi41di05NmgtMTI4djk2cTAgMTMgLTkuNSAyMi41CnQtMjIuNSA5LjVoLTY0cS0xMyAwIC0yMi41IC05LjV0LTkuNSAtMjIuNXYtMzIwcTAgLTEzIDkuNSAtMjIuNXQyMi41IC05LjVoNjRxMTMgMCAyMi41IDkuNXQ5LjUgMjIuNXY5NmgxMjh2LTk2cTAgLTEzIDkuNSAtMjIuNXQyMi41IC05LjVoNjRxMTMgMCAyMi41IDkuNXQ5LjUgMjIuNXpNMTQwOCAxMDg4di0xMjgwcTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtMTI4MHEtMjYgMCAtNDUgMTl0LTE5IDQ1djEyODBxMCAyNiAxOSA0NXQ0NSAxOWgzMjAKdjI4OHEwIDQwIDI4IDY4dDY4IDI4aDQ0OHE0MCAwIDY4IC0yOHQyOCAtNjh2LTI4OGgzMjBxMjYgMCA0NSAtMTl0MTkgLTQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhbWJ1bGFuY2UiIHVuaWNvZGU9IiYjeGYwZjk7IiBob3Jpei1hZHYteD0iMTkyMCIgCmQ9Ik02NDAgMTI4cTAgNTMgLTM3LjUgOTAuNXQtOTAuNSAzNy41dC05MC41IC0zNy41dC0zNy41IC05MC41dDM3LjUgLTkwLjV0OTAuNSAtMzcuNXQ5MC41IDM3LjV0MzcuNSA5MC41ek0yNTYgNjQwaDM4NHYyNTZoLTE1OHEtMTQgLTIgLTIyIC05bC0xOTUgLTE5NXEtNyAtMTIgLTkgLTIydi0zMHpNMTUzNiAxMjhxMCA1MyAtMzcuNSA5MC41dC05MC41IDM3LjV0LTkwLjUgLTM3LjV0LTM3LjUgLTkwLjV0MzcuNSAtOTAuNXQ5MC41IC0zNy41CnQ5MC41IDM3LjV0MzcuNSA5MC41ek0xNjY0IDgwMHYxOTJxMCAxNCAtOSAyM3QtMjMgOWgtMjI0djIyNHEwIDE0IC05IDIzdC0yMyA5aC0xOTJxLTE0IDAgLTIzIC05dC05IC0yM3YtMjI0aC0yMjRxLTE0IDAgLTIzIC05dC05IC0yM3YtMTkycTAgLTE0IDkgLTIzdDIzIC05aDIyNHYtMjI0cTAgLTE0IDkgLTIzdDIzIC05aDE5MnExNCAwIDIzIDl0OSAyM3YyMjRoMjI0cTE0IDAgMjMgOXQ5IDIzek0xOTIwIDEzNDR2LTExNTIKcTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtMTkycTAgLTEwNiAtNzUgLTE4MXQtMTgxIC03NXQtMTgxIDc1dC03NSAxODFoLTM4NHEwIC0xMDYgLTc1IC0xODF0LTE4MSAtNzV0LTE4MSA3NXQtNzUgMTgxaC0xMjhxLTI2IDAgLTQ1IDE5dC0xOSA0NXQxOSA0NXQ0NSAxOXY0MTZxMCAyNiAxMyA1OHQzMiA1MWwxOTggMTk4cTE5IDE5IDUxIDMydDU4IDEzaDE2MHYzMjBxMCAyNiAxOSA0NXQ0NSAxOWgxMTUycTI2IDAgNDUgLTE5dDE5IC00NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibWVka2l0IiB1bmljb2RlPSImI3hmMGZhOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTI4MCA0MTZ2MTkycTAgMTQgLTkgMjN0LTIzIDloLTIyNHYyMjRxMCAxNCAtOSAyM3QtMjMgOWgtMTkycS0xNCAwIC0yMyAtOXQtOSAtMjN2LTIyNGgtMjI0cS0xNCAwIC0yMyAtOXQtOSAtMjN2LTE5MnEwIC0xNCA5IC0yM3QyMyAtOWgyMjR2LTIyNHEwIC0xNCA5IC0yM3QyMyAtOWgxOTJxMTQgMCAyMyA5dDkgMjN2MjI0aDIyNHExNCAwIDIzIDl0OSAyM3pNNjQwIDExNTJoNTEydjEyOGgtNTEydi0xMjh6TTI1NiAxMTUydi0xMjgwaC0zMgpxLTkyIDAgLTE1OCA2NnQtNjYgMTU4djgzMnEwIDkyIDY2IDE1OHQxNTggNjZoMzJ6TTE0NDAgMTE1MnYtMTI4MGgtMTA4OHYxMjgwaDE2MHYxNjBxMCA0MCAyOCA2OHQ2OCAyOGg1NzZxNDAgMCA2OCAtMjh0MjggLTY4di0xNjBoMTYwek0xNzkyIDkyOHYtODMycTAgLTkyIC02NiAtMTU4dC0xNTggLTY2aC0zMnYxMjgwaDMycTkyIDAgMTU4IC02NnQ2NiAtMTU4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJmaWdodGVyX2pldCIgdW5pY29kZT0iJiN4ZjBmYjsiIGhvcml6LWFkdi14PSIxOTIwIiAKZD0iTTE5MjAgNTc2cS0xIC0zMiAtMjg4IC05NmwtMzUyIC0zMmwtMjI0IC02NGgtNjRsLTI5MyAtMzUyaDY5cTI2IDAgNDUgLTQuNXQxOSAtMTEuNXQtMTkgLTExLjV0LTQ1IC00LjVoLTk2aC0xNjBoLTY0djMyaDY0djQxNmgtMTYwbC0xOTIgLTIyNGgtOTZsLTMyIDMydjE5MmgzMnYzMmgxMjh2OGwtMTkyIDI0djEyOGwxOTIgMjR2OGgtMTI4djMyaC0zMnYxOTJsMzIgMzJoOTZsMTkyIC0yMjRoMTYwdjQxNmgtNjR2MzJoNjRoMTYwaDk2CnEyNiAwIDQ1IC00LjV0MTkgLTExLjV0LTE5IC0xMS41dC00NSAtNC41aC02OWwyOTMgLTM1Mmg2NGwyMjQgLTY0bDM1MiAtMzJxMTI4IC0yOCAyMDAgLTUydDgwIC0zNHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYmVlciIgdW5pY29kZT0iJiN4ZjBmYzsiIGhvcml6LWFkdi14PSIxNjY0IiAKZD0iTTY0MCA2NDB2Mzg0aC0yNTZ2LTI1NnEwIC01MyAzNy41IC05MC41dDkwLjUgLTM3LjVoMTI4ek0xNjY0IDE5MnYtMTkyaC0xMTUydjE5MmwxMjggMTkyaC0xMjhxLTE1OSAwIC0yNzEuNSAxMTIuNXQtMTEyLjUgMjcxLjV2MzIwbC02NCA2NGwzMiAxMjhoNDgwbDMyIDEyOGg5NjBsMzIgLTE5MmwtNjQgLTMydi04MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Imhfc2lnbiIgdW5pY29kZT0iJiN4ZjBmZDsiIApkPSJNMTI4MCAxOTJ2ODk2cTAgMjYgLTE5IDQ1dC00NSAxOWgtMTI4cS0yNiAwIC00NSAtMTl0LTE5IC00NXYtMzIwaC01MTJ2MzIwcTAgMjYgLTE5IDQ1dC00NSAxOWgtMTI4cS0yNiAwIC00NSAtMTl0LTE5IC00NXYtODk2cTAgLTI2IDE5IC00NXQ0NSAtMTloMTI4cTI2IDAgNDUgMTl0MTkgNDV2MzIwaDUxMnYtMzIwcTAgLTI2IDE5IC00NXQ0NSAtMTloMTI4cTI2IDAgNDUgMTl0MTkgNDV6TTE1MzYgMTEyMHYtOTYwCnEwIC0xMTkgLTg0LjUgLTIwMy41dC0yMDMuNSAtODQuNWgtOTYwcS0xMTkgMCAtMjAzLjUgODQuNXQtODQuNSAyMDMuNXY5NjBxMCAxMTkgODQuNSAyMDMuNXQyMDMuNSA4NC41aDk2MHExMTkgMCAyMDMuNSAtODQuNXQ4NC41IC0yMDMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZjBmZSIgdW5pY29kZT0iJiN4ZjBmZTsiIApkPSJNMTI4MCA1NzZ2MTI4cTAgMjYgLTE5IDQ1dC00NSAxOWgtMzIwdjMyMHEwIDI2IC0xOSA0NXQtNDUgMTloLTEyOHEtMjYgMCAtNDUgLTE5dC0xOSAtNDV2LTMyMGgtMzIwcS0yNiAwIC00NSAtMTl0LTE5IC00NXYtMTI4cTAgLTI2IDE5IC00NXQ0NSAtMTloMzIwdi0zMjBxMCAtMjYgMTkgLTQ1dDQ1IC0xOWgxMjhxMjYgMCA0NSAxOXQxOSA0NXYzMjBoMzIwcTI2IDAgNDUgMTl0MTkgNDV6TTE1MzYgMTEyMHYtOTYwCnEwIC0xMTkgLTg0LjUgLTIwMy41dC0yMDMuNSAtODQuNWgtOTYwcS0xMTkgMCAtMjAzLjUgODQuNXQtODQuNSAyMDMuNXY5NjBxMCAxMTkgODQuNSAyMDMuNXQyMDMuNSA4NC41aDk2MHExMTkgMCAyMDMuNSAtODQuNXQ4NC41IC0yMDMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZG91YmxlX2FuZ2xlX2xlZnQiIHVuaWNvZGU9IiYjeGYxMDA7IiBob3Jpei1hZHYteD0iMTAyNCIgCmQ9Ik02MjcgMTYwcTAgLTEzIC0xMCAtMjNsLTUwIC01MHEtMTAgLTEwIC0yMyAtMTB0LTIzIDEwbC00NjYgNDY2cS0xMCAxMCAtMTAgMjN0MTAgMjNsNDY2IDQ2NnExMCAxMCAyMyAxMHQyMyAtMTBsNTAgLTUwcTEwIC0xMCAxMCAtMjN0LTEwIC0yM2wtMzkzIC0zOTNsMzkzIC0zOTNxMTAgLTEwIDEwIC0yM3pNMTAxMSAxNjBxMCAtMTMgLTEwIC0yM2wtNTAgLTUwcS0xMCAtMTAgLTIzIC0xMHQtMjMgMTBsLTQ2NiA0NjZxLTEwIDEwIC0xMCAyMwp0MTAgMjNsNDY2IDQ2NnExMCAxMCAyMyAxMHQyMyAtMTBsNTAgLTUwcTEwIC0xMCAxMCAtMjN0LTEwIC0yM2wtMzkzIC0zOTNsMzkzIC0zOTNxMTAgLTEwIDEwIC0yM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZG91YmxlX2FuZ2xlX3JpZ2h0IiB1bmljb2RlPSImI3hmMTAxOyIgaG9yaXotYWR2LXg9IjEwMjQiIApkPSJNNTk1IDU3NnEwIC0xMyAtMTAgLTIzbC00NjYgLTQ2NnEtMTAgLTEwIC0yMyAtMTB0LTIzIDEwbC01MCA1MHEtMTAgMTAgLTEwIDIzdDEwIDIzbDM5MyAzOTNsLTM5MyAzOTNxLTEwIDEwIC0xMCAyM3QxMCAyM2w1MCA1MHExMCAxMCAyMyAxMHQyMyAtMTBsNDY2IC00NjZxMTAgLTEwIDEwIC0yM3pNOTc5IDU3NnEwIC0xMyAtMTAgLTIzbC00NjYgLTQ2NnEtMTAgLTEwIC0yMyAtMTB0LTIzIDEwbC01MCA1MHEtMTAgMTAgLTEwIDIzdDEwIDIzCmwzOTMgMzkzbC0zOTMgMzkzcS0xMCAxMCAtMTAgMjN0MTAgMjNsNTAgNTBxMTAgMTAgMjMgMTB0MjMgLTEwbDQ2NiAtNDY2cTEwIC0xMCAxMCAtMjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImRvdWJsZV9hbmdsZV91cCIgdW5pY29kZT0iJiN4ZjEwMjsiIGhvcml6LWFkdi14PSIxMTUyIiAKZD0iTTEwNzUgMjI0cTAgLTEzIC0xMCAtMjNsLTUwIC01MHEtMTAgLTEwIC0yMyAtMTB0LTIzIDEwbC0zOTMgMzkzbC0zOTMgLTM5M3EtMTAgLTEwIC0yMyAtMTB0LTIzIDEwbC01MCA1MHEtMTAgMTAgLTEwIDIzdDEwIDIzbDQ2NiA0NjZxMTAgMTAgMjMgMTB0MjMgLTEwbDQ2NiAtNDY2cTEwIC0xMCAxMCAtMjN6TTEwNzUgNjA4cTAgLTEzIC0xMCAtMjNsLTUwIC01MHEtMTAgLTEwIC0yMyAtMTB0LTIzIDEwbC0zOTMgMzkzbC0zOTMgLTM5MwpxLTEwIC0xMCAtMjMgLTEwdC0yMyAxMGwtNTAgNTBxLTEwIDEwIC0xMCAyM3QxMCAyM2w0NjYgNDY2cTEwIDEwIDIzIDEwdDIzIC0xMGw0NjYgLTQ2NnExMCAtMTAgMTAgLTIzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkb3VibGVfYW5nbGVfZG93biIgdW5pY29kZT0iJiN4ZjEwMzsiIGhvcml6LWFkdi14PSIxMTUyIiAKZD0iTTEwNzUgNjcycTAgLTEzIC0xMCAtMjNsLTQ2NiAtNDY2cS0xMCAtMTAgLTIzIC0xMHQtMjMgMTBsLTQ2NiA0NjZxLTEwIDEwIC0xMCAyM3QxMCAyM2w1MCA1MHExMCAxMCAyMyAxMHQyMyAtMTBsMzkzIC0zOTNsMzkzIDM5M3ExMCAxMCAyMyAxMHQyMyAtMTBsNTAgLTUwcTEwIC0xMCAxMCAtMjN6TTEwNzUgMTA1NnEwIC0xMyAtMTAgLTIzbC00NjYgLTQ2NnEtMTAgLTEwIC0yMyAtMTB0LTIzIDEwbC00NjYgNDY2cS0xMCAxMCAtMTAgMjMKdDEwIDIzbDUwIDUwcTEwIDEwIDIzIDEwdDIzIC0xMGwzOTMgLTM5M2wzOTMgMzkzcTEwIDEwIDIzIDEwdDIzIC0xMGw1MCAtNTBxMTAgLTEwIDEwIC0yM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYW5nbGVfbGVmdCIgdW5pY29kZT0iJiN4ZjEwNDsiIGhvcml6LWFkdi14PSI2NDAiIApkPSJNNjI3IDk5MnEwIC0xMyAtMTAgLTIzbC0zOTMgLTM5M2wzOTMgLTM5M3ExMCAtMTAgMTAgLTIzdC0xMCAtMjNsLTUwIC01MHEtMTAgLTEwIC0yMyAtMTB0LTIzIDEwbC00NjYgNDY2cS0xMCAxMCAtMTAgMjN0MTAgMjNsNDY2IDQ2NnExMCAxMCAyMyAxMHQyMyAtMTBsNTAgLTUwcTEwIC0xMCAxMCAtMjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImFuZ2xlX3JpZ2h0IiB1bmljb2RlPSImI3hmMTA1OyIgaG9yaXotYWR2LXg9IjY0MCIgCmQ9Ik01OTUgNTc2cTAgLTEzIC0xMCAtMjNsLTQ2NiAtNDY2cS0xMCAtMTAgLTIzIC0xMHQtMjMgMTBsLTUwIDUwcS0xMCAxMCAtMTAgMjN0MTAgMjNsMzkzIDM5M2wtMzkzIDM5M3EtMTAgMTAgLTEwIDIzdDEwIDIzbDUwIDUwcTEwIDEwIDIzIDEwdDIzIC0xMGw0NjYgLTQ2NnExMCAtMTAgMTAgLTIzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhbmdsZV91cCIgdW5pY29kZT0iJiN4ZjEwNjsiIGhvcml6LWFkdi14PSIxMTUyIiAKZD0iTTEwNzUgMzUycTAgLTEzIC0xMCAtMjNsLTUwIC01MHEtMTAgLTEwIC0yMyAtMTB0LTIzIDEwbC0zOTMgMzkzbC0zOTMgLTM5M3EtMTAgLTEwIC0yMyAtMTB0LTIzIDEwbC01MCA1MHEtMTAgMTAgLTEwIDIzdDEwIDIzbDQ2NiA0NjZxMTAgMTAgMjMgMTB0MjMgLTEwbDQ2NiAtNDY2cTEwIC0xMCAxMCAtMjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImFuZ2xlX2Rvd24iIHVuaWNvZGU9IiYjeGYxMDc7IiBob3Jpei1hZHYteD0iMTE1MiIgCmQ9Ik0xMDc1IDgwMHEwIC0xMyAtMTAgLTIzbC00NjYgLTQ2NnEtMTAgLTEwIC0yMyAtMTB0LTIzIDEwbC00NjYgNDY2cS0xMCAxMCAtMTAgMjN0MTAgMjNsNTAgNTBxMTAgMTAgMjMgMTB0MjMgLTEwbDM5MyAtMzkzbDM5MyAzOTNxMTAgMTAgMjMgMTB0MjMgLTEwbDUwIC01MHExMCAtMTAgMTAgLTIzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkZXNrdG9wIiB1bmljb2RlPSImI3hmMTA4OyIgaG9yaXotYWR2LXg9IjE5MjAiIApkPSJNMTc5MiA1NDR2ODMycTAgMTMgLTkuNSAyMi41dC0yMi41IDkuNWgtMTYwMHEtMTMgMCAtMjIuNSAtOS41dC05LjUgLTIyLjV2LTgzMnEwIC0xMyA5LjUgLTIyLjV0MjIuNSAtOS41aDE2MDBxMTMgMCAyMi41IDkuNXQ5LjUgMjIuNXpNMTkyMCAxMzc2di0xMDg4cTAgLTY2IC00NyAtMTEzdC0xMTMgLTQ3aC01NDRxMCAtMzcgMTYgLTc3LjV0MzIgLTcxdDE2IC00My41cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtNTEycS0yNiAwIC00NSAxOQp0LTE5IDQ1cTAgMTQgMTYgNDR0MzIgNzB0MTYgNzhoLTU0NHEtNjYgMCAtMTEzIDQ3dC00NyAxMTN2MTA4OHEwIDY2IDQ3IDExM3QxMTMgNDdoMTYwMHE2NiAwIDExMyAtNDd0NDcgLTExM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibGFwdG9wIiB1bmljb2RlPSImI3hmMTA5OyIgaG9yaXotYWR2LXg9IjE5MjAiIApkPSJNNDE2IDI1NnEtNjYgMCAtMTEzIDQ3dC00NyAxMTN2NzA0cTAgNjYgNDcgMTEzdDExMyA0N2gxMDg4cTY2IDAgMTEzIC00N3Q0NyAtMTEzdi03MDRxMCAtNjYgLTQ3IC0xMTN0LTExMyAtNDdoLTEwODh6TTM4NCAxMTIwdi03MDRxMCAtMTMgOS41IC0yMi41dDIyLjUgLTkuNWgxMDg4cTEzIDAgMjIuNSA5LjV0OS41IDIyLjV2NzA0cTAgMTMgLTkuNSAyMi41dC0yMi41IDkuNWgtMTA4OHEtMTMgMCAtMjIuNSAtOS41dC05LjUgLTIyLjV6Ck0xNzYwIDE5MmgxNjB2LTk2cTAgLTQwIC00NyAtNjh0LTExMyAtMjhoLTE2MDBxLTY2IDAgLTExMyAyOHQtNDcgNjh2OTZoMTYwaDE2MDB6TTEwNDAgOTZxMTYgMCAxNiAxNnQtMTYgMTZoLTE2MHEtMTYgMCAtMTYgLTE2dDE2IC0xNmgxNjB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InRhYmxldCIgdW5pY29kZT0iJiN4ZjEwYTsiIGhvcml6LWFkdi14PSIxMTUyIiAKZD0iTTY0MCAxMjhxMCAyNiAtMTkgNDV0LTQ1IDE5dC00NSAtMTl0LTE5IC00NXQxOSAtNDV0NDUgLTE5dDQ1IDE5dDE5IDQ1ek0xMDI0IDI4OHY5NjBxMCAxMyAtOS41IDIyLjV0LTIyLjUgOS41aC04MzJxLTEzIDAgLTIyLjUgLTkuNXQtOS41IC0yMi41di05NjBxMCAtMTMgOS41IC0yMi41dDIyLjUgLTkuNWg4MzJxMTMgMCAyMi41IDkuNXQ5LjUgMjIuNXpNMTE1MiAxMjQ4di0xMDg4cTAgLTY2IC00NyAtMTEzdC0xMTMgLTQ3aC04MzIKcS02NiAwIC0xMTMgNDd0LTQ3IDExM3YxMDg4cTAgNjYgNDcgMTEzdDExMyA0N2g4MzJxNjYgMCAxMTMgLTQ3dDQ3IC0xMTN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im1vYmlsZV9waG9uZSIgdW5pY29kZT0iJiN4ZjEwYjsiIGhvcml6LWFkdi14PSI3NjgiIApkPSJNNDY0IDEyOHEwIDMzIC0yMy41IDU2LjV0LTU2LjUgMjMuNXQtNTYuNSAtMjMuNXQtMjMuNSAtNTYuNXQyMy41IC01Ni41dDU2LjUgLTIzLjV0NTYuNSAyMy41dDIzLjUgNTYuNXpNNjcyIDI4OHY3MDRxMCAxMyAtOS41IDIyLjV0LTIyLjUgOS41aC01MTJxLTEzIDAgLTIyLjUgLTkuNXQtOS41IC0yMi41di03MDRxMCAtMTMgOS41IC0yMi41dDIyLjUgLTkuNWg1MTJxMTMgMCAyMi41IDkuNXQ5LjUgMjIuNXpNNDgwIDExMzYKcTAgMTYgLTE2IDE2aC0xNjBxLTE2IDAgLTE2IC0xNnQxNiAtMTZoMTYwcTE2IDAgMTYgMTZ6TTc2OCAxMTUydi0xMDI0cTAgLTUyIC0zOCAtOTB0LTkwIC0zOGgtNTEycS01MiAwIC05MCAzOHQtMzggOTB2MTAyNHEwIDUyIDM4IDkwdDkwIDM4aDUxMnE1MiAwIDkwIC0zOHQzOCAtOTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNpcmNsZV9ibGFuayIgdW5pY29kZT0iJiN4ZjEwYzsiIApkPSJNNzY4IDExODRxLTE0OCAwIC0yNzMgLTczdC0xOTggLTE5OHQtNzMgLTI3M3Q3MyAtMjczdDE5OCAtMTk4dDI3MyAtNzN0MjczIDczdDE5OCAxOTh0NzMgMjczdC03MyAyNzN0LTE5OCAxOTh0LTI3MyA3M3pNMTUzNiA2NDBxMCAtMjA5IC0xMDMgLTM4NS41dC0yNzkuNSAtMjc5LjV0LTM4NS41IC0xMDN0LTM4NS41IDEwM3QtMjc5LjUgMjc5LjV0LTEwMyAzODUuNXQxMDMgMzg1LjV0Mjc5LjUgMjc5LjV0Mzg1LjUgMTAzdDM4NS41IC0xMDMKdDI3OS41IC0yNzkuNXQxMDMgLTM4NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJxdW90ZV9sZWZ0IiB1bmljb2RlPSImI3hmMTBkOyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNNzY4IDU3NnYtMzg0cTAgLTgwIC01NiAtMTM2dC0xMzYgLTU2aC0zODRxLTgwIDAgLTEzNiA1NnQtNTYgMTM2djcwNHEwIDEwNCA0MC41IDE5OC41dDEwOS41IDE2My41dDE2My41IDEwOS41dDE5OC41IDQwLjVoNjRxMjYgMCA0NSAtMTl0MTkgLTQ1di0xMjhxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC02NHEtMTA2IDAgLTE4MSAtNzV0LTc1IC0xODF2LTMycTAgLTQwIDI4IC02OHQ2OCAtMjhoMjI0cTgwIDAgMTM2IC01NnQ1NiAtMTM2egpNMTY2NCA1NzZ2LTM4NHEwIC04MCAtNTYgLTEzNnQtMTM2IC01NmgtMzg0cS04MCAwIC0xMzYgNTZ0LTU2IDEzNnY3MDRxMCAxMDQgNDAuNSAxOTguNXQxMDkuNSAxNjMuNXQxNjMuNSAxMDkuNXQxOTguNSA0MC41aDY0cTI2IDAgNDUgLTE5dDE5IC00NXYtMTI4cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtNjRxLTEwNiAwIC0xODEgLTc1dC03NSAtMTgxdi0zMnEwIC00MCAyOCAtNjh0NjggLTI4aDIyNHE4MCAwIDEzNiAtNTZ0NTYgLTEzNnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icXVvdGVfcmlnaHQiIHVuaWNvZGU9IiYjeGYxMGU7IiBob3Jpei1hZHYteD0iMTY2NCIgCmQ9Ik03NjggMTIxNnYtNzA0cTAgLTEwNCAtNDAuNSAtMTk4LjV0LTEwOS41IC0xNjMuNXQtMTYzLjUgLTEwOS41dC0xOTguNSAtNDAuNWgtNjRxLTI2IDAgLTQ1IDE5dC0xOSA0NXYxMjhxMCAyNiAxOSA0NXQ0NSAxOWg2NHExMDYgMCAxODEgNzV0NzUgMTgxdjMycTAgNDAgLTI4IDY4dC02OCAyOGgtMjI0cS04MCAwIC0xMzYgNTZ0LTU2IDEzNnYzODRxMCA4MCA1NiAxMzZ0MTM2IDU2aDM4NHE4MCAwIDEzNiAtNTZ0NTYgLTEzNnpNMTY2NCAxMjE2CnYtNzA0cTAgLTEwNCAtNDAuNSAtMTk4LjV0LTEwOS41IC0xNjMuNXQtMTYzLjUgLTEwOS41dC0xOTguNSAtNDAuNWgtNjRxLTI2IDAgLTQ1IDE5dC0xOSA0NXYxMjhxMCAyNiAxOSA0NXQ0NSAxOWg2NHExMDYgMCAxODEgNzV0NzUgMTgxdjMycTAgNDAgLTI4IDY4dC02OCAyOGgtMjI0cS04MCAwIC0xMzYgNTZ0LTU2IDEzNnYzODRxMCA4MCA1NiAxMzZ0MTM2IDU2aDM4NHE4MCAwIDEzNiAtNTZ0NTYgLTEzNnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ic3Bpbm5lciIgdW5pY29kZT0iJiN4ZjExMDsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTUyNiAxNDJxMCAtNTMgLTM3LjUgLTkwLjV0LTkwLjUgLTM3LjVxLTUyIDAgLTkwIDM4dC0zOCA5MHEwIDUzIDM3LjUgOTAuNXQ5MC41IDM3LjV0OTAuNSAtMzcuNXQzNy41IC05MC41ek0xMDI0IC02NHEwIC01MyAtMzcuNSAtOTAuNXQtOTAuNSAtMzcuNXQtOTAuNSAzNy41dC0zNy41IDkwLjV0MzcuNSA5MC41dDkwLjUgMzcuNXQ5MC41IC0zNy41dDM3LjUgLTkwLjV6TTMyMCA2NDBxMCAtNTMgLTM3LjUgLTkwLjV0LTkwLjUgLTM3LjUKdC05MC41IDM3LjV0LTM3LjUgOTAuNXQzNy41IDkwLjV0OTAuNSAzNy41dDkwLjUgLTM3LjV0MzcuNSAtOTAuNXpNMTUyMiAxNDJxMCAtNTIgLTM4IC05MHQtOTAgLTM4cS01MyAwIC05MC41IDM3LjV0LTM3LjUgOTAuNXQzNy41IDkwLjV0OTAuNSAzNy41dDkwLjUgLTM3LjV0MzcuNSAtOTAuNXpNNTU4IDExMzhxMCAtNjYgLTQ3IC0xMTN0LTExMyAtNDd0LTExMyA0N3QtNDcgMTEzdDQ3IDExM3QxMTMgNDd0MTEzIC00N3Q0NyAtMTEzegpNMTcyOCA2NDBxMCAtNTMgLTM3LjUgLTkwLjV0LTkwLjUgLTM3LjV0LTkwLjUgMzcuNXQtMzcuNSA5MC41dDM3LjUgOTAuNXQ5MC41IDM3LjV0OTAuNSAtMzcuNXQzNy41IC05MC41ek0xMDg4IDEzNDRxMCAtODAgLTU2IC0xMzZ0LTEzNiAtNTZ0LTEzNiA1NnQtNTYgMTM2dDU2IDEzNnQxMzYgNTZ0MTM2IC01NnQ1NiAtMTM2ek0xNjE4IDExMzhxMCAtOTMgLTY2IC0xNTguNXQtMTU4IC02NS41cS05MyAwIC0xNTguNSA2NS41dC02NS41IDE1OC41CnEwIDkyIDY1LjUgMTU4dDE1OC41IDY2cTkyIDAgMTU4IC02NnQ2NiAtMTU4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjaXJjbGUiIHVuaWNvZGU9IiYjeGYxMTE7IiAKZD0iTTE1MzYgNjQwcTAgLTIwOSAtMTAzIC0zODUuNXQtMjc5LjUgLTI3OS41dC0zODUuNSAtMTAzdC0zODUuNSAxMDN0LTI3OS41IDI3OS41dC0xMDMgMzg1LjV0MTAzIDM4NS41dDI3OS41IDI3OS41dDM4NS41IDEwM3QzODUuNSAtMTAzdDI3OS41IC0yNzkuNXQxMDMgLTM4NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJyZXBseSIgdW5pY29kZT0iJiN4ZjExMjsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE3OTIgNDE2cTAgLTE2NiAtMTI3IC00NTFxLTMgLTcgLTEwLjUgLTI0dC0xMy41IC0zMHQtMTMgLTIycS0xMiAtMTcgLTI4IC0xN3EtMTUgMCAtMjMuNSAxMHQtOC41IDI1cTAgOSAyLjUgMjYuNXQyLjUgMjMuNXE1IDY4IDUgMTIzcTAgMTAxIC0xNy41IDE4MXQtNDguNSAxMzguNXQtODAgMTAxdC0xMDUuNSA2OS41dC0xMzMgNDIuNXQtMTU0IDIxLjV0LTE3NS41IDZoLTIyNHYtMjU2cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOXQtNDUgMTkKbC01MTIgNTEycS0xOSAxOSAtMTkgNDV0MTkgNDVsNTEyIDUxMnExOSAxOSA0NSAxOXQ0NSAtMTl0MTkgLTQ1di0yNTZoMjI0cTcxMyAwIDg3NSAtNDAzcTUzIC0xMzQgNTMgLTMzM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZ2l0aHViX2FsdCIgdW5pY29kZT0iJiN4ZjExMzsiIGhvcml6LWFkdi14PSIxNjY0IiAKZD0iTTY0MCAzMjBxMCAtNDAgLTEyLjUgLTgydC00MyAtNzZ0LTcyLjUgLTM0dC03Mi41IDM0dC00MyA3NnQtMTIuNSA4MnQxMi41IDgydDQzIDc2dDcyLjUgMzR0NzIuNSAtMzR0NDMgLTc2dDEyLjUgLTgyek0xMjgwIDMyMHEwIC00MCAtMTIuNSAtODJ0LTQzIC03NnQtNzIuNSAtMzR0LTcyLjUgMzR0LTQzIDc2dC0xMi41IDgydDEyLjUgODJ0NDMgNzZ0NzIuNSAzNHQ3Mi41IC0zNHQ0MyAtNzZ0MTIuNSAtODJ6TTE0NDAgMzIwCnEwIDEyMCAtNjkgMjA0dC0xODcgODRxLTQxIDAgLTE5NSAtMjFxLTcxIC0xMSAtMTU3IC0xMXQtMTU3IDExcS0xNTIgMjEgLTE5NSAyMXEtMTE4IDAgLTE4NyAtODR0LTY5IC0yMDRxMCAtODggMzIgLTE1My41dDgxIC0xMDN0MTIyIC02MHQxNDAgLTI5LjV0MTQ5IC03aDE2OHE4MiAwIDE0OSA3dDE0MCAyOS41dDEyMiA2MHQ4MSAxMDN0MzIgMTUzLjV6TTE2NjQgNDk2cTAgLTIwNyAtNjEgLTMzMXEtMzggLTc3IC0xMDUuNSAtMTMzdC0xNDEgLTg2CnQtMTcwIC00Ny41dC0xNzEuNSAtMjJ0LTE2NyAtNC41cS03OCAwIC0xNDIgM3QtMTQ3LjUgMTIuNXQtMTUyLjUgMzB0LTEzNyA1MS41dC0xMjEgODF0LTg2IDExNXEtNjIgMTIzIC02MiAzMzFxMCAyMzcgMTM2IDM5NnEtMjcgODIgLTI3IDE3MHEwIDExNiA1MSAyMThxMTA4IDAgMTkwIC0zOS41dDE4OSAtMTIzLjVxMTQ3IDM1IDMwOSAzNXExNDggMCAyODAgLTMycTEwNSA4MiAxODcgMTIxdDE4OSAzOXE1MSAtMTAyIDUxIC0yMTgKcTAgLTg3IC0yNyAtMTY4cTEzNiAtMTYwIDEzNiAtMzk4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJmb2xkZXJfY2xvc2VfYWx0IiB1bmljb2RlPSImI3hmMTE0OyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNMTUzNiAyMjR2NzA0cTAgNDAgLTI4IDY4dC02OCAyOGgtNzA0cS00MCAwIC02OCAyOHQtMjggNjh2NjRxMCA0MCAtMjggNjh0LTY4IDI4aC0zMjBxLTQwIDAgLTY4IC0yOHQtMjggLTY4di05NjBxMCAtNDAgMjggLTY4dDY4IC0yOGgxMjE2cTQwIDAgNjggMjh0MjggNjh6TTE2NjQgOTI4di03MDRxMCAtOTIgLTY2IC0xNTh0LTE1OCAtNjZoLTEyMTZxLTkyIDAgLTE1OCA2NnQtNjYgMTU4djk2MHEwIDkyIDY2IDE1OHQxNTggNjZoMzIwCnE5MiAwIDE1OCAtNjZ0NjYgLTE1OHYtMzJoNjcycTkyIDAgMTU4IC02NnQ2NiAtMTU4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJmb2xkZXJfb3Blbl9hbHQiIHVuaWNvZGU9IiYjeGYxMTU7IiBob3Jpei1hZHYteD0iMTkyMCIgCmQ9Ik0xNzgxIDYwNXEwIDM1IC01MyAzNWgtMTA4OHEtNDAgMCAtODUuNSAtMjEuNXQtNzEuNSAtNTIuNWwtMjk0IC0zNjNxLTE4IC0yNCAtMTggLTQwcTAgLTM1IDUzIC0zNWgxMDg4cTQwIDAgODYgMjJ0NzEgNTNsMjk0IDM2M3ExOCAyMiAxOCAzOXpNNjQwIDc2OGg3Njh2MTYwcTAgNDAgLTI4IDY4dC02OCAyOGgtNTc2cS00MCAwIC02OCAyOHQtMjggNjh2NjRxMCA0MCAtMjggNjh0LTY4IDI4aC0zMjBxLTQwIDAgLTY4IC0yOHQtMjggLTY4CnYtODUzbDI1NiAzMTVxNDQgNTMgMTE2IDg3LjV0MTQwIDM0LjV6TTE5MDkgNjA1cTAgLTYyIC00NiAtMTIwbC0yOTUgLTM2M3EtNDMgLTUzIC0xMTYgLTg3LjV0LTE0MCAtMzQuNWgtMTA4OHEtOTIgMCAtMTU4IDY2dC02NiAxNTh2OTYwcTAgOTIgNjYgMTU4dDE1OCA2NmgzMjBxOTIgMCAxNTggLTY2dDY2IC0xNTh2LTMyaDU0NHE5MiAwIDE1OCAtNjZ0NjYgLTE1OHYtMTYwaDE5MnE1NCAwIDk5IC0yNC41dDY3IC03MC41cTE1IC0zMiAxNSAtNjh6CiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJleHBhbmRfYWx0IiB1bmljb2RlPSImI3hmMTE2OyIgaG9yaXotYWR2LXg9IjE3OTIiIAogLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjb2xsYXBzZV9hbHQiIHVuaWNvZGU9IiYjeGYxMTc7IiBob3Jpei1hZHYteD0iMTc5MiIgCiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InNtaWxlIiB1bmljb2RlPSImI3hmMTE4OyIgCmQ9Ik0xMTM0IDQ2MXEtMzcgLTEyMSAtMTM4IC0xOTV0LTIyOCAtNzR0LTIyOCA3NHQtMTM4IDE5NXEtOCAyNSA0IDQ4LjV0MzggMzEuNXEyNSA4IDQ4LjUgLTR0MzEuNSAtMzhxMjUgLTgwIDkyLjUgLTEyOS41dDE1MS41IC00OS41dDE1MS41IDQ5LjV0OTIuNSAxMjkuNXE4IDI2IDMyIDM4dDQ5IDR0MzcgLTMxLjV0NCAtNDguNXpNNjQwIDg5NnEwIC01MyAtMzcuNSAtOTAuNXQtOTAuNSAtMzcuNXQtOTAuNSAzNy41dC0zNy41IDkwLjUKdDM3LjUgOTAuNXQ5MC41IDM3LjV0OTAuNSAtMzcuNXQzNy41IC05MC41ek0xMTUyIDg5NnEwIC01MyAtMzcuNSAtOTAuNXQtOTAuNSAtMzcuNXQtOTAuNSAzNy41dC0zNy41IDkwLjV0MzcuNSA5MC41dDkwLjUgMzcuNXQ5MC41IC0zNy41dDM3LjUgLTkwLjV6TTE0MDggNjQwcTAgMTMwIC01MSAyNDguNXQtMTM2LjUgMjA0dC0yMDQgMTM2LjV0LTI0OC41IDUxdC0yNDguNSAtNTF0LTIwNCAtMTM2LjV0LTEzNi41IC0yMDR0LTUxIC0yNDguNQp0NTEgLTI0OC41dDEzNi41IC0yMDR0MjA0IC0xMzYuNXQyNDguNSAtNTF0MjQ4LjUgNTF0MjA0IDEzNi41dDEzNi41IDIwNHQ1MSAyNDguNXpNMTUzNiA2NDBxMCAtMjA5IC0xMDMgLTM4NS41dC0yNzkuNSAtMjc5LjV0LTM4NS41IC0xMDN0LTM4NS41IDEwM3QtMjc5LjUgMjc5LjV0LTEwMyAzODUuNXQxMDMgMzg1LjV0Mjc5LjUgMjc5LjV0Mzg1LjUgMTAzdDM4NS41IC0xMDN0Mjc5LjUgLTI3OS41dDEwMyAtMzg1LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImZyb3duIiB1bmljb2RlPSImI3hmMTE5OyIgCmQ9Ik0xMTM0IDMwN3E4IC0yNSAtNCAtNDguNXQtMzcgLTMxLjV0LTQ5IDR0LTMyIDM4cS0yNSA4MCAtOTIuNSAxMjkuNXQtMTUxLjUgNDkuNXQtMTUxLjUgLTQ5LjV0LTkyLjUgLTEyOS41cS04IC0yNiAtMzEuNSAtMzh0LTQ4LjUgLTRxLTI2IDggLTM4IDMxLjV0LTQgNDguNXEzNyAxMjEgMTM4IDE5NXQyMjggNzR0MjI4IC03NHQxMzggLTE5NXpNNjQwIDg5NnEwIC01MyAtMzcuNSAtOTAuNXQtOTAuNSAtMzcuNXQtOTAuNSAzNy41CnQtMzcuNSA5MC41dDM3LjUgOTAuNXQ5MC41IDM3LjV0OTAuNSAtMzcuNXQzNy41IC05MC41ek0xMTUyIDg5NnEwIC01MyAtMzcuNSAtOTAuNXQtOTAuNSAtMzcuNXQtOTAuNSAzNy41dC0zNy41IDkwLjV0MzcuNSA5MC41dDkwLjUgMzcuNXQ5MC41IC0zNy41dDM3LjUgLTkwLjV6TTE0MDggNjQwcTAgMTMwIC01MSAyNDguNXQtMTM2LjUgMjA0dC0yMDQgMTM2LjV0LTI0OC41IDUxdC0yNDguNSAtNTF0LTIwNCAtMTM2LjV0LTEzNi41IC0yMDQKdC01MSAtMjQ4LjV0NTEgLTI0OC41dDEzNi41IC0yMDR0MjA0IC0xMzYuNXQyNDguNSAtNTF0MjQ4LjUgNTF0MjA0IDEzNi41dDEzNi41IDIwNHQ1MSAyNDguNXpNMTUzNiA2NDBxMCAtMjA5IC0xMDMgLTM4NS41dC0yNzkuNSAtMjc5LjV0LTM4NS41IC0xMDN0LTM4NS41IDEwM3QtMjc5LjUgMjc5LjV0LTEwMyAzODUuNXQxMDMgMzg1LjV0Mjc5LjUgMjc5LjV0Mzg1LjUgMTAzdDM4NS41IC0xMDN0Mjc5LjUgLTI3OS41dDEwMyAtMzg1LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im1laCIgdW5pY29kZT0iJiN4ZjExYTsiIApkPSJNMTE1MiA0NDhxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC02NDBxLTI2IDAgLTQ1IDE5dC0xOSA0NXQxOSA0NXQ0NSAxOWg2NDBxMjYgMCA0NSAtMTl0MTkgLTQ1ek02NDAgODk2cTAgLTUzIC0zNy41IC05MC41dC05MC41IC0zNy41dC05MC41IDM3LjV0LTM3LjUgOTAuNXQzNy41IDkwLjV0OTAuNSAzNy41dDkwLjUgLTM3LjV0MzcuNSAtOTAuNXpNMTE1MiA4OTZxMCAtNTMgLTM3LjUgLTkwLjV0LTkwLjUgLTM3LjV0LTkwLjUgMzcuNQp0LTM3LjUgOTAuNXQzNy41IDkwLjV0OTAuNSAzNy41dDkwLjUgLTM3LjV0MzcuNSAtOTAuNXpNMTQwOCA2NDBxMCAxMzAgLTUxIDI0OC41dC0xMzYuNSAyMDR0LTIwNCAxMzYuNXQtMjQ4LjUgNTF0LTI0OC41IC01MXQtMjA0IC0xMzYuNXQtMTM2LjUgLTIwNHQtNTEgLTI0OC41dDUxIC0yNDguNXQxMzYuNSAtMjA0dDIwNCAtMTM2LjV0MjQ4LjUgLTUxdDI0OC41IDUxdDIwNCAxMzYuNXQxMzYuNSAyMDR0NTEgMjQ4LjV6TTE1MzYgNjQwCnEwIC0yMDkgLTEwMyAtMzg1LjV0LTI3OS41IC0yNzkuNXQtMzg1LjUgLTEwM3QtMzg1LjUgMTAzdC0yNzkuNSAyNzkuNXQtMTAzIDM4NS41dDEwMyAzODUuNXQyNzkuNSAyNzkuNXQzODUuNSAxMDN0Mzg1LjUgLTEwM3QyNzkuNSAtMjc5LjV0MTAzIC0zODUuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZ2FtZXBhZCIgdW5pY29kZT0iJiN4ZjExYjsiIGhvcml6LWFkdi14PSIxOTIwIiAKZD0iTTgzMiA0NDh2MTI4cTAgMTQgLTkgMjN0LTIzIDloLTE5MnYxOTJxMCAxNCAtOSAyM3QtMjMgOWgtMTI4cS0xNCAwIC0yMyAtOXQtOSAtMjN2LTE5MmgtMTkycS0xNCAwIC0yMyAtOXQtOSAtMjN2LTEyOHEwIC0xNCA5IC0yM3QyMyAtOWgxOTJ2LTE5MnEwIC0xNCA5IC0yM3QyMyAtOWgxMjhxMTQgMCAyMyA5dDkgMjN2MTkyaDE5MnExNCAwIDIzIDl0OSAyM3pNMTQwOCAzODRxMCA1MyAtMzcuNSA5MC41dC05MC41IDM3LjV0LTkwLjUgLTM3LjUKdC0zNy41IC05MC41dDM3LjUgLTkwLjV0OTAuNSAtMzcuNXQ5MC41IDM3LjV0MzcuNSA5MC41ek0xNjY0IDY0MHEwIDUzIC0zNy41IDkwLjV0LTkwLjUgMzcuNXQtOTAuNSAtMzcuNXQtMzcuNSAtOTAuNXQzNy41IC05MC41dDkwLjUgLTM3LjV0OTAuNSAzNy41dDM3LjUgOTAuNXpNMTkyMCA1MTJxMCAtMjEyIC0xNTAgLTM2MnQtMzYyIC0xNTBxLTE5MiAwIC0zMzggMTI4aC0yMjBxLTE0NiAtMTI4IC0zMzggLTEyOHEtMjEyIDAgLTM2MiAxNTAKdC0xNTAgMzYydDE1MCAzNjJ0MzYyIDE1MGg4OTZxMjEyIDAgMzYyIC0xNTB0MTUwIC0zNjJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImtleWJvYXJkIiB1bmljb2RlPSImI3hmMTFjOyIgaG9yaXotYWR2LXg9IjE5MjAiIApkPSJNMzg0IDM2OHYtOTZxMCAtMTYgLTE2IC0xNmgtOTZxLTE2IDAgLTE2IDE2djk2cTAgMTYgMTYgMTZoOTZxMTYgMCAxNiAtMTZ6TTUxMiA2MjR2LTk2cTAgLTE2IC0xNiAtMTZoLTIyNHEtMTYgMCAtMTYgMTZ2OTZxMCAxNiAxNiAxNmgyMjRxMTYgMCAxNiAtMTZ6TTM4NCA4ODB2LTk2cTAgLTE2IC0xNiAtMTZoLTk2cS0xNiAwIC0xNiAxNnY5NnEwIDE2IDE2IDE2aDk2cTE2IDAgMTYgLTE2ek0xNDA4IDM2OHYtOTZxMCAtMTYgLTE2IC0xNgpoLTg2NHEtMTYgMCAtMTYgMTZ2OTZxMCAxNiAxNiAxNmg4NjRxMTYgMCAxNiAtMTZ6TTc2OCA2MjR2LTk2cTAgLTE2IC0xNiAtMTZoLTk2cS0xNiAwIC0xNiAxNnY5NnEwIDE2IDE2IDE2aDk2cTE2IDAgMTYgLTE2ek02NDAgODgwdi05NnEwIC0xNiAtMTYgLTE2aC05NnEtMTYgMCAtMTYgMTZ2OTZxMCAxNiAxNiAxNmg5NnExNiAwIDE2IC0xNnpNMTAyNCA2MjR2LTk2cTAgLTE2IC0xNiAtMTZoLTk2cS0xNiAwIC0xNiAxNnY5NnEwIDE2IDE2IDE2Cmg5NnExNiAwIDE2IC0xNnpNODk2IDg4MHYtOTZxMCAtMTYgLTE2IC0xNmgtOTZxLTE2IDAgLTE2IDE2djk2cTAgMTYgMTYgMTZoOTZxMTYgMCAxNiAtMTZ6TTEyODAgNjI0di05NnEwIC0xNiAtMTYgLTE2aC05NnEtMTYgMCAtMTYgMTZ2OTZxMCAxNiAxNiAxNmg5NnExNiAwIDE2IC0xNnpNMTY2NCAzNjh2LTk2cTAgLTE2IC0xNiAtMTZoLTk2cS0xNiAwIC0xNiAxNnY5NnEwIDE2IDE2IDE2aDk2cTE2IDAgMTYgLTE2ek0xMTUyIDg4MHYtOTYKcTAgLTE2IC0xNiAtMTZoLTk2cS0xNiAwIC0xNiAxNnY5NnEwIDE2IDE2IDE2aDk2cTE2IDAgMTYgLTE2ek0xNDA4IDg4MHYtOTZxMCAtMTYgLTE2IC0xNmgtOTZxLTE2IDAgLTE2IDE2djk2cTAgMTYgMTYgMTZoOTZxMTYgMCAxNiAtMTZ6TTE2NjQgODgwdi0zNTJxMCAtMTYgLTE2IC0xNmgtMjI0cS0xNiAwIC0xNiAxNnY5NnEwIDE2IDE2IDE2aDExMnYyNDBxMCAxNiAxNiAxNmg5NnExNiAwIDE2IC0xNnpNMTc5MiAxMjh2ODk2aC0xNjY0di04OTYKaDE2NjR6TTE5MjAgMTAyNHYtODk2cTAgLTUzIC0zNy41IC05MC41dC05MC41IC0zNy41aC0xNjY0cS01MyAwIC05MC41IDM3LjV0LTM3LjUgOTAuNXY4OTZxMCA1MyAzNy41IDkwLjV0OTAuNSAzNy41aDE2NjRxNTMgMCA5MC41IC0zNy41dDM3LjUgLTkwLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImZsYWdfYWx0IiB1bmljb2RlPSImI3hmMTFkOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTY2NCA0OTF2NjE2cS0xNjkgLTkxIC0zMDYgLTkxcS04MiAwIC0xNDUgMzJxLTEwMCA0OSAtMTg0IDc2LjV0LTE3OCAyNy41cS0xNzMgMCAtNDAzIC0xMjd2LTU5OXEyNDUgMTEzIDQzMyAxMTNxNTUgMCAxMDMuNSAtNy41dDk4IC0yNnQ3NyAtMzF0ODIuNSAtMzkuNWwyOCAtMTRxNDQgLTIyIDEwMSAtMjJxMTIwIDAgMjkzIDkyek0zMjAgMTI4MHEwIC0zNSAtMTcuNSAtNjR0LTQ2LjUgLTQ2di0xMjY2cTAgLTE0IC05IC0yM3QtMjMgLTkKaC02NHEtMTQgMCAtMjMgOXQtOSAyM3YxMjY2cS0yOSAxNyAtNDYuNSA0NnQtMTcuNSA2NHEwIDUzIDM3LjUgOTAuNXQ5MC41IDM3LjV0OTAuNSAtMzcuNXQzNy41IC05MC41ek0xNzkyIDEyMTZ2LTc2M3EwIC0zOSAtMzUgLTU3cS0xMCAtNSAtMTcgLTlxLTIxOCAtMTE2IC0zNjkgLTExNnEtODggMCAtMTU4IDM1bC0yOCAxNHEtNjQgMzMgLTk5IDQ4dC05MSAyOXQtMTE0IDE0cS0xMDIgMCAtMjM1LjUgLTQ0dC0yMjguNSAtMTAyCnEtMTUgLTkgLTMzIC05cS0xNiAwIC0zMiA4cS0zMiAxOSAtMzIgNTZ2NzQycTAgMzUgMzEgNTVxMzUgMjEgNzguNSA0Mi41dDExNCA1MnQxNTIuNSA0OS41dDE1NSAxOXExMTIgMCAyMDkgLTMxdDIwOSAtODZxMzggLTE5IDg5IC0xOXExMjIgMCAzMTAgMTEycTIyIDEyIDMxIDE3cTMxIDE2IDYyIC0ycTMxIC0yMCAzMSAtNTV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImZsYWdfY2hlY2tlcmVkIiB1bmljb2RlPSImI3hmMTFlOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNODMyIDUzNnYxOTJxLTE4MSAtMTYgLTM4NCAtMTE3di0xODVxMjA1IDk2IDM4NCAxMTB6TTgzMiA5NTR2MTk3cS0xNzIgLTggLTM4NCAtMTI2di0xODlxMjE1IDExMSAzODQgMTE4ek0xNjY0IDQ5MXYxODRxLTIzNSAtMTE2IC0zODQgLTcxdjIyNHEtMjAgNiAtMzkgMTVxLTUgMyAtMzMgMTd0LTM0LjUgMTd0LTMxLjUgMTV0LTM0LjUgMTUuNXQtMzIuNSAxM3QtMzYgMTIuNXQtMzUgOC41dC0zOS41IDcuNXQtMzkuNSA0dC00NCAyCnEtMjMgMCAtNDkgLTN2LTIyMmgxOXExMDIgMCAxOTIuNSAtMjl0MTk3LjUgLTgycTE5IC05IDM5IC0xNXYtMTg4cTQyIC0xNyA5MSAtMTdxMTIwIDAgMjkzIDkyek0xNjY0IDkxOHYxODlxLTE2OSAtOTEgLTMwNiAtOTFxLTQ1IDAgLTc4IDh2LTE5NnExNDggLTQyIDM4NCA5MHpNMzIwIDEyODBxMCAtMzUgLTE3LjUgLTY0dC00Ni41IC00NnYtMTI2NnEwIC0xNCAtOSAtMjN0LTIzIC05aC02NHEtMTQgMCAtMjMgOXQtOSAyM3YxMjY2CnEtMjkgMTcgLTQ2LjUgNDZ0LTE3LjUgNjRxMCA1MyAzNy41IDkwLjV0OTAuNSAzNy41dDkwLjUgLTM3LjV0MzcuNSAtOTAuNXpNMTc5MiAxMjE2di03NjNxMCAtMzkgLTM1IC01N3EtMTAgLTUgLTE3IC05cS0yMTggLTExNiAtMzY5IC0xMTZxLTg4IDAgLTE1OCAzNWwtMjggMTRxLTY0IDMzIC05OSA0OHQtOTEgMjl0LTExNCAxNHEtMTAyIDAgLTIzNS41IC00NHQtMjI4LjUgLTEwMnEtMTUgLTkgLTMzIC05cS0xNiAwIC0zMiA4CnEtMzIgMTkgLTMyIDU2djc0MnEwIDM1IDMxIDU1cTM1IDIxIDc4LjUgNDIuNXQxMTQgNTJ0MTUyLjUgNDkuNXQxNTUgMTlxMTEyIDAgMjA5IC0zMXQyMDkgLTg2cTM4IC0xOSA4OSAtMTlxMTIyIDAgMzEwIDExMnEyMiAxMiAzMSAxN3EzMSAxNiA2MiAtMnEzMSAtMjAgMzEgLTU1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ0ZXJtaW5hbCIgdW5pY29kZT0iJiN4ZjEyMDsiIGhvcml6LWFkdi14PSIxNjY0IiAKZD0iTTU4NSA1NTNsLTQ2NiAtNDY2cS0xMCAtMTAgLTIzIC0xMHQtMjMgMTBsLTUwIDUwcS0xMCAxMCAtMTAgMjN0MTAgMjNsMzkzIDM5M2wtMzkzIDM5M3EtMTAgMTAgLTEwIDIzdDEwIDIzbDUwIDUwcTEwIDEwIDIzIDEwdDIzIC0xMGw0NjYgLTQ2NnExMCAtMTAgMTAgLTIzdC0xMCAtMjN6TTE2NjQgOTZ2LTY0cTAgLTE0IC05IC0yM3QtMjMgLTloLTk2MHEtMTQgMCAtMjMgOXQtOSAyM3Y2NHEwIDE0IDkgMjN0MjMgOWg5NjBxMTQgMCAyMyAtOQp0OSAtMjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNvZGUiIHVuaWNvZGU9IiYjeGYxMjE7IiBob3Jpei1hZHYteD0iMTkyMCIgCmQ9Ik02MTcgMTM3bC01MCAtNTBxLTEwIC0xMCAtMjMgLTEwdC0yMyAxMGwtNDY2IDQ2NnEtMTAgMTAgLTEwIDIzdDEwIDIzbDQ2NiA0NjZxMTAgMTAgMjMgMTB0MjMgLTEwbDUwIC01MHExMCAtMTAgMTAgLTIzdC0xMCAtMjNsLTM5MyAtMzkzbDM5MyAtMzkzcTEwIC0xMCAxMCAtMjN0LTEwIC0yM3pNMTIwOCAxMjA0bC0zNzMgLTEyOTFxLTQgLTEzIC0xNS41IC0xOS41dC0yMy41IC0yLjVsLTYyIDE3cS0xMyA0IC0xOS41IDE1LjV0LTIuNSAyNC41CmwzNzMgMTI5MXE0IDEzIDE1LjUgMTkuNXQyMy41IDIuNWw2MiAtMTdxMTMgLTQgMTkuNSAtMTUuNXQyLjUgLTI0LjV6TTE4NjUgNTUzbC00NjYgLTQ2NnEtMTAgLTEwIC0yMyAtMTB0LTIzIDEwbC01MCA1MHEtMTAgMTAgLTEwIDIzdDEwIDIzbDM5MyAzOTNsLTM5MyAzOTNxLTEwIDEwIC0xMCAyM3QxMCAyM2w1MCA1MHExMCAxMCAyMyAxMHQyMyAtMTBsNDY2IC00NjZxMTAgLTEwIDEwIC0yM3QtMTAgLTIzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJyZXBseV9hbGwiIHVuaWNvZGU9IiYjeGYxMjI7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik02NDAgNDU0di03MHEwIC00MiAtMzkgLTU5cS0xMyAtNSAtMjUgLTVxLTI3IDAgLTQ1IDE5bC01MTIgNTEycS0xOSAxOSAtMTkgNDV0MTkgNDVsNTEyIDUxMnEyOSAzMSA3MCAxNHEzOSAtMTcgMzkgLTU5di02OWwtMzk3IC0zOThxLTE5IC0xOSAtMTkgLTQ1dDE5IC00NXpNMTc5MiA0MTZxMCAtNTggLTE3IC0xMzMuNXQtMzguNSAtMTM4dC00OCAtMTI1dC00MC41IC05MC41bC0yMCAtNDBxLTggLTE3IC0yOCAtMTdxLTYgMCAtOSAxCnEtMjUgOCAtMjMgMzRxNDMgNDAwIC0xMDYgNTY1cS02NCA3MSAtMTcwLjUgMTEwLjV0LTI2Ny41IDUyLjV2LTI1MXEwIC00MiAtMzkgLTU5cS0xMyAtNSAtMjUgLTVxLTI3IDAgLTQ1IDE5bC01MTIgNTEycS0xOSAxOSAtMTkgNDV0MTkgNDVsNTEyIDUxMnEyOSAzMSA3MCAxNHEzOSAtMTcgMzkgLTU5di0yNjJxNDExIC0yOCA1OTkgLTIyMXExNjkgLTE3MyAxNjkgLTUwOXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ic3Rhcl9oYWxmX2VtcHR5IiB1bmljb2RlPSImI3hmMTIzOyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNMTE4NiA1NzlsMjU3IDI1MGwtMzU2IDUybC02NiAxMGwtMzAgNjBsLTE1OSAzMjJ2LTk2M2w1OSAtMzFsMzE4IC0xNjhsLTYwIDM1NWwtMTIgNjZ6TTE2MzggODQxbC0zNjMgLTM1NGw4NiAtNTAwcTUgLTMzIC02IC01MS41dC0zNCAtMTguNXEtMTcgMCAtNDAgMTJsLTQ0OSAyMzZsLTQ0OSAtMjM2cS0yMyAtMTIgLTQwIC0xMnEtMjMgMCAtMzQgMTguNXQtNiA1MS41bDg2IDUwMGwtMzY0IDM1NHEtMzIgMzIgLTIzIDU5LjV0NTQgMzQuNQpsNTAyIDczbDIyNSA0NTVxMjAgNDEgNDkgNDFxMjggMCA0OSAtNDFsMjI1IC00NTVsNTAyIC03M3E0NSAtNyA1NCAtMzQuNXQtMjQgLTU5LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImxvY2F0aW9uX2Fycm93IiB1bmljb2RlPSImI3hmMTI0OyIgaG9yaXotYWR2LXg9IjE0MDgiIApkPSJNMTQwMSAxMTg3bC02NDAgLTEyODBxLTE3IC0zNSAtNTcgLTM1cS01IDAgLTE1IDJxLTIyIDUgLTM1LjUgMjIuNXQtMTMuNSAzOS41djU3NmgtNTc2cS0yMiAwIC0zOS41IDEzLjV0LTIyLjUgMzUuNXQ0IDQydDI5IDMwbDEyODAgNjQwcTEzIDcgMjkgN3EyNyAwIDQ1IC0xOXExNSAtMTQgMTguNSAtMzQuNXQtNi41IC0zOS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjcm9wIiB1bmljb2RlPSImI3hmMTI1OyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNNTU3IDI1Nmg1OTV2NTk1ek01MTIgMzAxbDU5NSA1OTVoLTU5NXYtNTk1ek0xNjY0IDIyNHYtMTkycTAgLTE0IC05IC0yM3QtMjMgLTloLTIyNHYtMjI0cTAgLTE0IC05IC0yM3QtMjMgLTloLTE5MnEtMTQgMCAtMjMgOXQtOSAyM3YyMjRoLTg2NHEtMTQgMCAtMjMgOXQtOSAyM3Y4NjRoLTIyNHEtMTQgMCAtMjMgOXQtOSAyM3YxOTJxMCAxNCA5IDIzdDIzIDloMjI0djIyNHEwIDE0IDkgMjN0MjMgOWgxOTJxMTQgMCAyMyAtOXQ5IC0yMwp2LTIyNGg4NTFsMjQ2IDI0N3ExMCA5IDIzIDl0MjMgLTlxOSAtMTAgOSAtMjN0LTkgLTIzbC0yNDcgLTI0NnYtODUxaDIyNHExNCAwIDIzIC05dDkgLTIzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjb2RlX2ZvcmsiIHVuaWNvZGU9IiYjeGYxMjY7IiBob3Jpei1hZHYteD0iMTAyNCIgCmQ9Ik0yODggNjRxMCA0MCAtMjggNjh0LTY4IDI4dC02OCAtMjh0LTI4IC02OHQyOCAtNjh0NjggLTI4dDY4IDI4dDI4IDY4ek0yODggMTIxNnEwIDQwIC0yOCA2OHQtNjggMjh0LTY4IC0yOHQtMjggLTY4dDI4IC02OHQ2OCAtMjh0NjggMjh0MjggNjh6TTkyOCAxMDg4cTAgNDAgLTI4IDY4dC02OCAyOHQtNjggLTI4dC0yOCAtNjh0MjggLTY4dDY4IC0yOHQ2OCAyOHQyOCA2OHpNMTAyNCAxMDg4cTAgLTUyIC0yNiAtOTYuNXQtNzAgLTY5LjUKcS0yIC0yODcgLTIyNiAtNDE0cS02NyAtMzggLTIwMyAtODFxLTEyOCAtNDAgLTE2OS41IC03MXQtNDEuNSAtMTAwdi0yNnE0NCAtMjUgNzAgLTY5LjV0MjYgLTk2LjVxMCAtODAgLTU2IC0xMzZ0LTEzNiAtNTZ0LTEzNiA1NnQtNTYgMTM2cTAgNTIgMjYgOTYuNXQ3MCA2OS41djgyMHEtNDQgMjUgLTcwIDY5LjV0LTI2IDk2LjVxMCA4MCA1NiAxMzZ0MTM2IDU2dDEzNiAtNTZ0NTYgLTEzNnEwIC01MiAtMjYgLTk2LjV0LTcwIC02OS41di00OTcKcTU0IDI2IDE1NCA1N3E1NSAxNyA4Ny41IDI5LjV0NzAuNSAzMXQ1OSAzOS41dDQwLjUgNTF0MjggNjkuNXQ4LjUgOTEuNXEtNDQgMjUgLTcwIDY5LjV0LTI2IDk2LjVxMCA4MCA1NiAxMzZ0MTM2IDU2dDEzNiAtNTZ0NTYgLTEzNnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5saW5rIiB1bmljb2RlPSImI3hmMTI3OyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNNDM5IDI2NWwtMjU2IC0yNTZxLTExIC05IC0yMyAtOXQtMjMgOXEtOSAxMCAtOSAyM3Q5IDIzbDI1NiAyNTZxMTAgOSAyMyA5dDIzIC05cTkgLTEwIDkgLTIzdC05IC0yM3pNNjA4IDIyNHYtMzIwcTAgLTE0IC05IC0yM3QtMjMgLTl0LTIzIDl0LTkgMjN2MzIwcTAgMTQgOSAyM3QyMyA5dDIzIC05dDkgLTIzek0zODQgNDQ4cTAgLTE0IC05IC0yM3QtMjMgLTloLTMyMHEtMTQgMCAtMjMgOXQtOSAyM3Q5IDIzdDIzIDloMzIwCnExNCAwIDIzIC05dDkgLTIzek0xNjQ4IDMyMHEwIC0xMjAgLTg1IC0yMDNsLTE0NyAtMTQ2cS04MyAtODMgLTIwMyAtODNxLTEyMSAwIC0yMDQgODVsLTMzNCAzMzVxLTIxIDIxIC00MiA1NmwyMzkgMThsMjczIC0yNzRxMjcgLTI3IDY4IC0yNy41dDY4IDI2LjVsMTQ3IDE0NnEyOCAyOCAyOCA2N3EwIDQwIC0yOCA2OGwtMjc0IDI3NWwxOCAyMzlxMzUgLTIxIDU2IC00MmwzMzYgLTMzNnE4NCAtODYgODQgLTIwNHpNMTAzMSAxMDQ0bC0yMzkgLTE4CmwtMjczIDI3NHEtMjggMjggLTY4IDI4cS0zOSAwIC02OCAtMjdsLTE0NyAtMTQ2cS0yOCAtMjggLTI4IC02N3EwIC00MCAyOCAtNjhsMjc0IC0yNzRsLTE4IC0yNDBxLTM1IDIxIC01NiA0MmwtMzM2IDMzNnEtODQgODYgLTg0IDIwNHEwIDEyMCA4NSAyMDNsMTQ3IDE0NnE4MyA4MyAyMDMgODNxMTIxIDAgMjA0IC04NWwzMzQgLTMzNXEyMSAtMjEgNDIgLTU2ek0xNjY0IDk2MHEwIC0xNCAtOSAtMjN0LTIzIC05aC0zMjBxLTE0IDAgLTIzIDkKdC05IDIzdDkgMjN0MjMgOWgzMjBxMTQgMCAyMyAtOXQ5IC0yM3pNMTEyMCAxNTA0di0zMjBxMCAtMTQgLTkgLTIzdC0yMyAtOXQtMjMgOXQtOSAyM3YzMjBxMCAxNCA5IDIzdDIzIDl0MjMgLTl0OSAtMjN6TTE1MjcgMTM1M2wtMjU2IC0yNTZxLTExIC05IC0yMyAtOXQtMjMgOXEtOSAxMCAtOSAyM3Q5IDIzbDI1NiAyNTZxMTAgOSAyMyA5dDIzIC05cTkgLTEwIDkgLTIzdC05IC0yM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icXVlc3Rpb24iIHVuaWNvZGU9IiYjeGYxMjg7IiBob3Jpei1hZHYteD0iMTAyNCIgCmQ9Ik03MDQgMjgwdi0yNDBxMCAtMTYgLTEyIC0yOHQtMjggLTEyaC0yNDBxLTE2IDAgLTI4IDEydC0xMiAyOHYyNDBxMCAxNiAxMiAyOHQyOCAxMmgyNDBxMTYgMCAyOCAtMTJ0MTIgLTI4ek0xMDIwIDg4MHEwIC01NCAtMTUuNSAtMTAxdC0zNSAtNzYuNXQtNTUgLTU5LjV0LTU3LjUgLTQzLjV0LTYxIC0zNS41cS00MSAtMjMgLTY4LjUgLTY1dC0yNy41IC02N3EwIC0xNyAtMTIgLTMyLjV0LTI4IC0xNS41aC0yNDBxLTE1IDAgLTI1LjUgMTguNQp0LTEwLjUgMzcuNXY0NXEwIDgzIDY1IDE1Ni41dDE0MyAxMDguNXE1OSAyNyA4NCA1NnQyNSA3NnEwIDQyIC00Ni41IDc0dC0xMDcuNSAzMnEtNjUgMCAtMTA4IC0yOXEtMzUgLTI1IC0xMDcgLTExNXEtMTMgLTE2IC0zMSAtMTZxLTEyIDAgLTI1IDhsLTE2NCAxMjVxLTEzIDEwIC0xNS41IDI1dDUuNSAyOHExNjAgMjY2IDQ2NCAyNjZxODAgMCAxNjEgLTMxdDE0NiAtODN0MTA2IC0xMjcuNXQ0MSAtMTU4LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il8yNzkiIHVuaWNvZGU9IiYjeGYxMjk7IiBob3Jpei1hZHYteD0iNjQwIiAKZD0iTTY0MCAxOTJ2LTEyOHEwIC0yNiAtMTkgLTQ1dC00NSAtMTloLTUxMnEtMjYgMCAtNDUgMTl0LTE5IDQ1djEyOHEwIDI2IDE5IDQ1dDQ1IDE5aDY0djM4NGgtNjRxLTI2IDAgLTQ1IDE5dC0xOSA0NXYxMjhxMCAyNiAxOSA0NXQ0NSAxOWgzODRxMjYgMCA0NSAtMTl0MTkgLTQ1di01NzZoNjRxMjYgMCA0NSAtMTl0MTkgLTQ1ek01MTIgMTM0NHYtMTkycTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtMjU2cS0yNiAwIC00NSAxOXQtMTkgNDV2MTkyCnEwIDI2IDE5IDQ1dDQ1IDE5aDI1NnEyNiAwIDQ1IC0xOXQxOSAtNDV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImV4Y2xhbWF0aW9uIiB1bmljb2RlPSImI3hmMTJhOyIgaG9yaXotYWR2LXg9IjY0MCIgCmQ9Ik01MTIgMjg4di0yMjRxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0yNTZxLTI2IDAgLTQ1IDE5dC0xOSA0NXYyMjRxMCAyNiAxOSA0NXQ0NSAxOWgyNTZxMjYgMCA0NSAtMTl0MTkgLTQ1ek01NDIgMTM0NGwtMjggLTc2OHEtMSAtMjYgLTIwLjUgLTQ1dC00NS41IC0xOWgtMjU2cS0yNiAwIC00NS41IDE5dC0yMC41IDQ1bC0yOCA3NjhxLTEgMjYgMTcuNSA0NXQ0NC41IDE5aDMyMHEyNiAwIDQ0LjUgLTE5dDE3LjUgLTQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzdXBlcnNjcmlwdCIgdW5pY29kZT0iJiN4ZjEyYjsiIApkPSJNODk3IDE2N3YtMTY3aC0yNDhsLTE1OSAyNTJsLTI0IDQycS04IDkgLTExIDIxaC0zcS0xIC0zIC0yLjUgLTYuNXQtMy41IC04dC0zIC02LjVxLTEwIC0yMCAtMjUgLTQ0bC0xNTUgLTI1MGgtMjU4djE2N2gxMjhsMTk3IDI5MWwtMTg1IDI3MmgtMTM3djE2OGgyNzZsMTM5IC0yMjhxMiAtNCAyMyAtNDJxOCAtOSAxMSAtMjFoM3EzIDkgMTEgMjFsMjUgNDJsMTQwIDIyOGgyNTd2LTE2OGgtMTI1bC0xODQgLTI2N2wyMDQgLTI5NmgxMDl6Ck0xNTM0IDg0NnYtMjA2aC01MTRsLTMgMjdxLTQgMjggLTQgNDZxMCA2NCAyNiAxMTd0NjUgODYuNXQ4NCA2NXQ4NCA1NC41dDY1IDU0dDI2IDY0cTAgMzggLTI5LjUgNjIuNXQtNzAuNSAyNC41cS01MSAwIC05NyAtMzlxLTE0IC0xMSAtMzYgLTM4bC0xMDUgOTJxMjYgMzcgNjMgNjZxODMgNjUgMTg4IDY1cTExMCAwIDE3OCAtNTkuNXQ2OCAtMTU4LjVxMCAtNTYgLTI0LjUgLTEwM3QtNjIgLTc2LjV0LTgxLjUgLTU4LjV0LTgyIC01MC41CnQtNjUuNSAtNTEuNXQtMzAuNSAtNjNoMjMydjgwaDEyNnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ic3Vic2NyaXB0IiB1bmljb2RlPSImI3hmMTJjOyIgCmQ9Ik04OTcgMTY3di0xNjdoLTI0OGwtMTU5IDI1MmwtMjQgNDJxLTggOSAtMTEgMjFoLTNxLTEgLTMgLTIuNSAtNi41dC0zLjUgLTh0LTMgLTYuNXEtMTAgLTIwIC0yNSAtNDRsLTE1NSAtMjUwaC0yNTh2MTY3aDEyOGwxOTcgMjkxbC0xODUgMjcyaC0xMzd2MTY4aDI3NmwxMzkgLTIyOHEyIC00IDIzIC00MnE4IC05IDExIC0yMWgzcTMgOSAxMSAyMWwyNSA0MmwxNDAgMjI4aDI1N3YtMTY4aC0xMjVsLTE4NCAtMjY3bDIwNCAtMjk2aDEwOXoKTTE1MzYgLTUwdi0yMDZoLTUxNGwtNCAyN3EtMyA0NSAtMyA0NnEwIDY0IDI2IDExN3Q2NSA4Ni41dDg0IDY1dDg0IDU0LjV0NjUgNTR0MjYgNjRxMCAzOCAtMjkuNSA2Mi41dC03MC41IDI0LjVxLTUxIDAgLTk3IC0zOXEtMTQgLTExIC0zNiAtMzhsLTEwNSA5MnEyNiAzNyA2MyA2NnE4MCA2NSAxODggNjVxMTEwIDAgMTc4IC01OS41dDY4IC0xNTguNXEwIC02NiAtMzQuNSAtMTE4LjV0LTg0IC04NnQtOTkuNSAtNjIuNXQtODcgLTYzdC00MSAtNzMKaDIzMnY4MGgxMjZ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il8yODMiIHVuaWNvZGU9IiYjeGYxMmQ7IiBob3Jpei1hZHYteD0iMTkyMCIgCmQ9Ik04OTYgMTI4bDMzNiAzODRoLTc2OGwtMzM2IC0zODRoNzY4ek0xOTA5IDEyMDVxMTUgLTM0IDkuNSAtNzEuNXQtMzAuNSAtNjUuNWwtODk2IC0xMDI0cS0zOCAtNDQgLTk2IC00NGgtNzY4cS0zOCAwIC02OS41IDIwLjV0LTQ3LjUgNTQuNXEtMTUgMzQgLTkuNSA3MS41dDMwLjUgNjUuNWw4OTYgMTAyNHEzOCA0NCA5NiA0NGg3NjhxMzggMCA2OS41IC0yMC41dDQ3LjUgLTU0LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InB1enpsZV9waWVjZSIgdW5pY29kZT0iJiN4ZjEyZTsiIGhvcml6LWFkdi14PSIxNjY0IiAKZD0iTTE2NjQgNDM4cTAgLTgxIC00NC41IC0xMzV0LTEyMy41IC01NHEtNDEgMCAtNzcuNSAxNy41dC01OSAzOHQtNTYuNSAzOHQtNzEgMTcuNXEtMTEwIDAgLTExMCAtMTI0cTAgLTM5IDE2IC0xMTV0MTUgLTExNXYtNXEtMjIgMCAtMzMgLTFxLTM0IC0zIC05Ny41IC0xMS41dC0xMTUuNSAtMTMuNXQtOTggLTVxLTYxIDAgLTEwMyAyNi41dC00MiA4My41cTAgMzcgMTcuNSA3MXQzOCA1Ni41dDM4IDU5dDE3LjUgNzcuNXEwIDc5IC01NCAxMjMuNQp0LTEzNSA0NC41cS04NCAwIC0xNDMgLTQ1LjV0LTU5IC0xMjcuNXEwIC00MyAxNSAtODN0MzMuNSAtNjQuNXQzMy41IC01M3QxNSAtNTAuNXEwIC00NSAtNDYgLTg5cS0zNyAtMzUgLTExNyAtMzVxLTk1IDAgLTI0NSAyNHEtOSAyIC0yNy41IDR0LTI3LjUgNGwtMTMgMnEtMSAwIC0zIDFxLTIgMCAtMiAxdjEwMjRxMiAtMSAxNy41IC0zLjV0MzQgLTV0MjEuNSAtMy41cTE1MCAtMjQgMjQ1IC0yNHE4MCAwIDExNyAzNXE0NiA0NCA0NiA4OQpxMCAyMiAtMTUgNTAuNXQtMzMuNSA1M3QtMzMuNSA2NC41dC0xNSA4M3EwIDgyIDU5IDEyNy41dDE0NCA0NS41cTgwIDAgMTM0IC00NC41dDU0IC0xMjMuNXEwIC00MSAtMTcuNSAtNzcuNXQtMzggLTU5dC0zOCAtNTYuNXQtMTcuNSAtNzFxMCAtNTcgNDIgLTgzLjV0MTAzIC0yNi41cTY0IDAgMTgwIDE1dDE2MyAxN3YtMnEtMSAtMiAtMy41IC0xNy41dC01IC0zNHQtMy41IC0yMS41cS0yNCAtMTUwIC0yNCAtMjQ1cTAgLTgwIDM1IC0xMTcKcTQ0IC00NiA4OSAtNDZxMjIgMCA1MC41IDE1dDUzIDMzLjV0NjQuNSAzMy41dDgzIDE1cTgyIDAgMTI3LjUgLTU5dDQ1LjUgLTE0M3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibWljcm9waG9uZSIgdW5pY29kZT0iJiN4ZjEzMDsiIGhvcml6LWFkdi14PSIxMTUyIiAKZD0iTTExNTIgODMydi0xMjhxMCAtMjIxIC0xNDcuNSAtMzg0LjV0LTM2NC41IC0xODcuNXYtMTMyaDI1NnEyNiAwIDQ1IC0xOXQxOSAtNDV0LTE5IC00NXQtNDUgLTE5aC02NDBxLTI2IDAgLTQ1IDE5dC0xOSA0NXQxOSA0NXQ0NSAxOWgyNTZ2MTMycS0yMTcgMjQgLTM2NC41IDE4Ny41dC0xNDcuNSAzODQuNXYxMjhxMCAyNiAxOSA0NXQ0NSAxOXQ0NSAtMTl0MTkgLTQ1di0xMjhxMCAtMTg1IDEzMS41IC0zMTYuNXQzMTYuNSAtMTMxLjUKdDMxNi41IDEzMS41dDEzMS41IDMxNi41djEyOHEwIDI2IDE5IDQ1dDQ1IDE5dDQ1IC0xOXQxOSAtNDV6TTg5NiAxMjE2di01MTJxMCAtMTMyIC05NCAtMjI2dC0yMjYgLTk0dC0yMjYgOTR0LTk0IDIyNnY1MTJxMCAxMzIgOTQgMjI2dDIyNiA5NHQyMjYgLTk0dDk0IC0yMjZ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Im1pY3JvcGhvbmVfb2ZmIiB1bmljb2RlPSImI3hmMTMxOyIgaG9yaXotYWR2LXg9IjE0MDgiIApkPSJNMjcxIDU5MWwtMTAxIC0xMDFxLTQyIDEwMyAtNDIgMjE0djEyOHEwIDI2IDE5IDQ1dDQ1IDE5dDQ1IC0xOXQxOSAtNDV2LTEyOHEwIC01MyAxNSAtMTEzek0xMzg1IDExOTNsLTM2MSAtMzYxdi0xMjhxMCAtMTMyIC05NCAtMjI2dC0yMjYgLTk0cS01NSAwIC0xMDkgMTlsLTk2IC05NnE5NyAtNTEgMjA1IC01MXExODUgMCAzMTYuNSAxMzEuNXQxMzEuNSAzMTYuNXYxMjhxMCAyNiAxOSA0NXQ0NSAxOXQ0NSAtMTl0MTkgLTQ1di0xMjgKcTAgLTIyMSAtMTQ3LjUgLTM4NC41dC0zNjQuNSAtMTg3LjV2LTEzMmgyNTZxMjYgMCA0NSAtMTl0MTkgLTQ1dC0xOSAtNDV0LTQ1IC0xOWgtNjQwcS0yNiAwIC00NSAxOXQtMTkgNDV0MTkgNDV0NDUgMTloMjU2djEzMnEtMTI1IDEzIC0yMzUgODFsLTI1NCAtMjU0cS0xMCAtMTAgLTIzIC0xMHQtMjMgMTBsLTgyIDgycS0xMCAxMCAtMTAgMjN0MTAgMjNsMTIzNCAxMjM0cTEwIDEwIDIzIDEwdDIzIC0xMGw4MiAtODJxMTAgLTEwIDEwIC0yMwp0LTEwIC0yM3pNMTAwNSAxMzI1bC02MjEgLTYyMXY1MTJxMCAxMzIgOTQgMjI2dDIyNiA5NHExMDIgMCAxODQuNSAtNTl0MTE2LjUgLTE1MnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ic2hpZWxkIiB1bmljb2RlPSImI3hmMTMyOyIgaG9yaXotYWR2LXg9IjEyODAiIApkPSJNMTA4OCA1NzZ2NjQwaC00NDh2LTExMzdxMTE5IDYzIDIxMyAxMzdxMjM1IDE4NCAyMzUgMzYwek0xMjgwIDEzNDR2LTc2OHEwIC04NiAtMzMuNSAtMTcwLjV0LTgzIC0xNTB0LTExOCAtMTI3LjV0LTEyNi41IC0xMDN0LTEyMSAtNzcuNXQtODkuNSAtNDkuNXQtNDIuNSAtMjBxLTEyIC02IC0yNiAtNnQtMjYgNnEtMTYgNyAtNDIuNSAyMHQtODkuNSA0OS41dC0xMjEgNzcuNXQtMTI2LjUgMTAzdC0xMTggMTI3LjV0LTgzIDE1MAp0LTMzLjUgMTcwLjV2NzY4cTAgMjYgMTkgNDV0NDUgMTloMTE1MnEyNiAwIDQ1IC0xOXQxOSAtNDV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNhbGVuZGFyX2VtcHR5IiB1bmljb2RlPSImI3hmMTMzOyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNMTI4IC0xMjhoMTQwOHYxMDI0aC0xNDA4di0xMDI0ek01MTIgMTA4OHYyODhxMCAxNCAtOSAyM3QtMjMgOWgtNjRxLTE0IDAgLTIzIC05dC05IC0yM3YtMjg4cTAgLTE0IDkgLTIzdDIzIC05aDY0cTE0IDAgMjMgOXQ5IDIzek0xMjgwIDEwODh2Mjg4cTAgMTQgLTkgMjN0LTIzIDloLTY0cS0xNCAwIC0yMyAtOXQtOSAtMjN2LTI4OHEwIC0xNCA5IC0yM3QyMyAtOWg2NHExNCAwIDIzIDl0OSAyM3pNMTY2NCAxMTUydi0xMjgwCnEwIC01MiAtMzggLTkwdC05MCAtMzhoLTE0MDhxLTUyIDAgLTkwIDM4dC0zOCA5MHYxMjgwcTAgNTIgMzggOTB0OTAgMzhoMTI4djk2cTAgNjYgNDcgMTEzdDExMyA0N2g2NHE2NiAwIDExMyAtNDd0NDcgLTExM3YtOTZoMzg0djk2cTAgNjYgNDcgMTEzdDExMyA0N2g2NHE2NiAwIDExMyAtNDd0NDcgLTExM3YtOTZoMTI4cTUyIDAgOTAgLTM4dDM4IC05MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZmlyZV9leHRpbmd1aXNoZXIiIHVuaWNvZGU9IiYjeGYxMzQ7IiBob3Jpei1hZHYteD0iMTQwOCIgCmQ9Ik01MTIgMTM0NHEwIDI2IC0xOSA0NXQtNDUgMTl0LTQ1IC0xOXQtMTkgLTQ1dDE5IC00NXQ0NSAtMTl0NDUgMTl0MTkgNDV6TTE0MDggMTM3NnYtMzIwcTAgLTE2IC0xMiAtMjVxLTggLTcgLTIwIC03cS00IDAgLTcgMWwtNDQ4IDk2cS0xMSAyIC0xOCAxMXQtNyAyMGgtMjU2di0xMDJxMTExIC0yMyAxODMuNSAtMTExdDcyLjUgLTIwM3YtODAwcTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtNTEycS0yNiAwIC00NSAxOXQtMTkgNDV2ODAwCnEwIDEwNiA2Mi41IDE5MC41dDE2MS41IDExNC41djExMWgtMzJxLTU5IDAgLTExNSAtMjMuNXQtOTEuNSAtNTN0LTY2IC02Ni41dC00MC41IC01My41dC0xNCAtMjQuNXEtMTcgLTM1IC01NyAtMzVxLTE2IDAgLTI5IDdxLTIzIDEyIC0zMS41IDM3dDMuNSA0OXE1IDEwIDE0LjUgMjZ0MzcuNSA1My41dDYwLjUgNzB0ODUgNjd0MTA4LjUgNTIuNXEtMjUgNDIgLTI1IDg2cTAgNjYgNDcgMTEzdDExMyA0N3QxMTMgLTQ3dDQ3IC0xMTMKcTAgLTMzIC0xNCAtNjRoMzAycTAgMTEgNyAyMHQxOCAxMWw0NDggOTZxMyAxIDcgMXExMiAwIDIwIC03cTEyIC05IDEyIC0yNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0icm9ja2V0IiB1bmljb2RlPSImI3hmMTM1OyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNMTQ0MCAxMDg4cTAgNDAgLTI4IDY4dC02OCAyOHQtNjggLTI4dC0yOCAtNjh0MjggLTY4dDY4IC0yOHQ2OCAyOHQyOCA2OHpNMTY2NCAxMzc2cTAgLTI0OSAtNzUuNSAtNDMwLjV0LTI1My41IC0zNjAuNXEtODEgLTgwIC0xOTUgLTE3NmwtMjAgLTM3OXEtMiAtMTYgLTE2IC0yNmwtMzg0IC0yMjRxLTcgLTQgLTE2IC00cS0xMiAwIC0yMyA5bC02NCA2NHEtMTMgMTQgLTggMzJsODUgMjc2bC0yODEgMjgxbC0yNzYgLTg1cS0zIC0xIC05IC0xCnEtMTQgMCAtMjMgOWwtNjQgNjRxLTE3IDE5IC01IDM5bDIyNCAzODRxMTAgMTQgMjYgMTZsMzc5IDIwcTk2IDExNCAxNzYgMTk1cTE4OCAxODcgMzU4IDI1OHQ0MzEgNzFxMTQgMCAyNCAtOS41dDEwIC0yMi41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJtYXhjZG4iIHVuaWNvZGU9IiYjeGYxMzY7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xNzQ1IDc2M2wtMTY0IC03NjNoLTMzNGwxNzggODMycTEzIDU2IC0xNSA4OHEtMjcgMzMgLTgzIDMzaC0xNjlsLTIwNCAtOTUzaC0zMzRsMjA0IDk1M2gtMjg2bC0yMDQgLTk1M2gtMzM0bDIwNCA5NTNsLTE1MyAzMjdoMTI3NnExMDEgMCAxODkuNSAtNDAuNXQxNDcuNSAtMTEzLjVxNjAgLTczIDgxIC0xNjguNXQwIC0xOTQuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY2hldnJvbl9zaWduX2xlZnQiIHVuaWNvZGU9IiYjeGYxMzc7IiAKZD0iTTkwOSAxNDFsMTAyIDEwMnExOSAxOSAxOSA0NXQtMTkgNDVsLTMwNyAzMDdsMzA3IDMwN3ExOSAxOSAxOSA0NXQtMTkgNDVsLTEwMiAxMDJxLTE5IDE5IC00NSAxOXQtNDUgLTE5bC00NTQgLTQ1NHEtMTkgLTE5IC0xOSAtNDV0MTkgLTQ1bDQ1NCAtNDU0cTE5IC0xOSA0NSAtMTl0NDUgMTl6TTE1MzYgNjQwcTAgLTIwOSAtMTAzIC0zODUuNXQtMjc5LjUgLTI3OS41dC0zODUuNSAtMTAzdC0zODUuNSAxMDN0LTI3OS41IDI3OS41CnQtMTAzIDM4NS41dDEwMyAzODUuNXQyNzkuNSAyNzkuNXQzODUuNSAxMDN0Mzg1LjUgLTEwM3QyNzkuNSAtMjc5LjV0MTAzIC0zODUuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iY2hldnJvbl9zaWduX3JpZ2h0IiB1bmljb2RlPSImI3hmMTM4OyIgCmQ9Ik03MTcgMTQxbDQ1NCA0NTRxMTkgMTkgMTkgNDV0LTE5IDQ1bC00NTQgNDU0cS0xOSAxOSAtNDUgMTl0LTQ1IC0xOWwtMTAyIC0xMDJxLTE5IC0xOSAtMTkgLTQ1dDE5IC00NWwzMDcgLTMwN2wtMzA3IC0zMDdxLTE5IC0xOSAtMTkgLTQ1dDE5IC00NWwxMDIgLTEwMnExOSAtMTkgNDUgLTE5dDQ1IDE5ek0xNTM2IDY0MHEwIC0yMDkgLTEwMyAtMzg1LjV0LTI3OS41IC0yNzkuNXQtMzg1LjUgLTEwM3QtMzg1LjUgMTAzdC0yNzkuNSAyNzkuNQp0LTEwMyAzODUuNXQxMDMgMzg1LjV0Mjc5LjUgMjc5LjV0Mzg1LjUgMTAzdDM4NS41IC0xMDN0Mjc5LjUgLTI3OS41dDEwMyAtMzg1LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNoZXZyb25fc2lnbl91cCIgdW5pY29kZT0iJiN4ZjEzOTsiIApkPSJNMTE2NSAzOTdsMTAyIDEwMnExOSAxOSAxOSA0NXQtMTkgNDVsLTQ1NCA0NTRxLTE5IDE5IC00NSAxOXQtNDUgLTE5bC00NTQgLTQ1NHEtMTkgLTE5IC0xOSAtNDV0MTkgLTQ1bDEwMiAtMTAycTE5IC0xOSA0NSAtMTl0NDUgMTlsMzA3IDMwN2wzMDcgLTMwN3ExOSAtMTkgNDUgLTE5dDQ1IDE5ek0xNTM2IDY0MHEwIC0yMDkgLTEwMyAtMzg1LjV0LTI3OS41IC0yNzkuNXQtMzg1LjUgLTEwM3QtMzg1LjUgMTAzdC0yNzkuNSAyNzkuNQp0LTEwMyAzODUuNXQxMDMgMzg1LjV0Mjc5LjUgMjc5LjV0Mzg1LjUgMTAzdDM4NS41IC0xMDN0Mjc5LjUgLTI3OS41dDEwMyAtMzg1LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNoZXZyb25fc2lnbl9kb3duIiB1bmljb2RlPSImI3hmMTNhOyIgCmQ9Ik04MTMgMjM3bDQ1NCA0NTRxMTkgMTkgMTkgNDV0LTE5IDQ1bC0xMDIgMTAycS0xOSAxOSAtNDUgMTl0LTQ1IC0xOWwtMzA3IC0zMDdsLTMwNyAzMDdxLTE5IDE5IC00NSAxOXQtNDUgLTE5bC0xMDIgLTEwMnEtMTkgLTE5IC0xOSAtNDV0MTkgLTQ1bDQ1NCAtNDU0cTE5IC0xOSA0NSAtMTl0NDUgMTl6TTE1MzYgNjQwcTAgLTIwOSAtMTAzIC0zODUuNXQtMjc5LjUgLTI3OS41dC0zODUuNSAtMTAzdC0zODUuNSAxMDN0LTI3OS41IDI3OS41CnQtMTAzIDM4NS41dDEwMyAzODUuNXQyNzkuNSAyNzkuNXQzODUuNSAxMDN0Mzg1LjUgLTEwM3QyNzkuNSAtMjc5LjV0MTAzIC0zODUuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iaHRtbDUiIHVuaWNvZGU9IiYjeGYxM2I7IiBob3Jpei1hZHYteD0iMTQwOCIgCmQ9Ik0xMTMwIDkzOWwxNiAxNzVoLTg4NGw0NyAtNTM0aDYxMmwtMjIgLTIyOGwtMTk3IC01M2wtMTk2IDUzbC0xMyAxNDBoLTE3NWwyMiAtMjc4bDM2MiAtMTAwaDR2MWwzNTkgOTlsNTAgNTQ0aC02NDRsLTE1IDE4MWg2NzR6TTAgMTQwOGgxNDA4bC0xMjggLTE0MzhsLTU3OCAtMTYybC01NzQgMTYyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjc3MzIiB1bmljb2RlPSImI3hmMTNjOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMjc1IDE0MDhoMTUwNWwtMjY2IC0xMzMzbC04MDQgLTI2N2wtNjk4IDI2N2w3MSAzNTZoMjk3bC0yOSAtMTQ3bDQyMiAtMTYxbDQ4NiAxNjFsNjggMzM5aC0xMjA4bDU4IDI5N2gxMjA5bDM4IDE5MWgtMTIwOHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYW5jaG9yIiB1bmljb2RlPSImI3hmMTNkOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNOTYwIDEyODBxMCAyNiAtMTkgNDV0LTQ1IDE5dC00NSAtMTl0LTE5IC00NXQxOSAtNDV0NDUgLTE5dDQ1IDE5dDE5IDQ1ek0xNzkyIDM1MnYtMzUycTAgLTIyIC0yMCAtMzBxLTggLTIgLTEyIC0ycS0xMiAwIC0yMyA5bC05MyA5M3EtMTE5IC0xNDMgLTMxOC41IC0yMjYuNXQtNDI5LjUgLTgzLjV0LTQyOS41IDgzLjV0LTMxOC41IDIyNi41bC05MyAtOTNxLTkgLTkgLTIzIC05cS00IDAgLTEyIDJxLTIwIDggLTIwIDMwdjM1MgpxMCAxNCA5IDIzdDIzIDloMzUycTIyIDAgMzAgLTIwcTggLTE5IC03IC0zNWwtMTAwIC0xMDBxNjcgLTkxIDE4OS41IC0xNTMuNXQyNzEuNSAtODIuNXY2NDdoLTE5MnEtMjYgMCAtNDUgMTl0LTE5IDQ1djEyOHEwIDI2IDE5IDQ1dDQ1IDE5aDE5MnYxNjNxLTU4IDM0IC05MyA5Mi41dC0zNSAxMjguNXEwIDEwNiA3NSAxODF0MTgxIDc1dDE4MSAtNzV0NzUgLTE4MXEwIC03MCAtMzUgLTEyOC41dC05MyAtOTIuNXYtMTYzaDE5MnEyNiAwIDQ1IC0xOQp0MTkgLTQ1di0xMjhxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0xOTJ2LTY0N3ExNDkgMjAgMjcxLjUgODIuNXQxODkuNSAxNTMuNWwtMTAwIDEwMHEtMTUgMTYgLTcgMzVxOCAyMCAzMCAyMGgzNTJxMTQgMCAyMyAtOXQ5IC0yM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5sb2NrX2FsdCIgdW5pY29kZT0iJiN4ZjEzZTsiIGhvcml6LWFkdi14PSIxMTUyIiAKZD0iTTEwNTYgNzY4cTQwIDAgNjggLTI4dDI4IC02OHYtNTc2cTAgLTQwIC0yOCAtNjh0LTY4IC0yOGgtOTYwcS00MCAwIC02OCAyOHQtMjggNjh2NTc2cTAgNDAgMjggNjh0NjggMjhoMzJ2MzIwcTAgMTg1IDEzMS41IDMxNi41dDMxNi41IDEzMS41dDMxNi41IC0xMzEuNXQxMzEuNSAtMzE2LjVxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC02NHEtMjYgMCAtNDUgMTl0LTE5IDQ1cTAgMTA2IC03NSAxODF0LTE4MSA3NXQtMTgxIC03NXQtNzUgLTE4MQp2LTMyMGg3MzZ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImJ1bGxzZXllIiB1bmljb2RlPSImI3hmMTQwOyIgCmQ9Ik0xMDI0IDY0MHEwIC0xMDYgLTc1IC0xODF0LTE4MSAtNzV0LTE4MSA3NXQtNzUgMTgxdDc1IDE4MXQxODEgNzV0MTgxIC03NXQ3NSAtMTgxek0xMTUyIDY0MHEwIDE1OSAtMTEyLjUgMjcxLjV0LTI3MS41IDExMi41dC0yNzEuNSAtMTEyLjV0LTExMi41IC0yNzEuNXQxMTIuNSAtMjcxLjV0MjcxLjUgLTExMi41dDI3MS41IDExMi41dDExMi41IDI3MS41ek0xMjgwIDY0MHEwIC0yMTIgLTE1MCAtMzYydC0zNjIgLTE1MHQtMzYyIDE1MAp0LTE1MCAzNjJ0MTUwIDM2MnQzNjIgMTUwdDM2MiAtMTUwdDE1MCAtMzYyek0xNDA4IDY0MHEwIDEzMCAtNTEgMjQ4LjV0LTEzNi41IDIwNHQtMjA0IDEzNi41dC0yNDguNSA1MXQtMjQ4LjUgLTUxdC0yMDQgLTEzNi41dC0xMzYuNSAtMjA0dC01MSAtMjQ4LjV0NTEgLTI0OC41dDEzNi41IC0yMDR0MjA0IC0xMzYuNXQyNDguNSAtNTF0MjQ4LjUgNTF0MjA0IDEzNi41dDEzNi41IDIwNHQ1MSAyNDguNXpNMTUzNiA2NDAKcTAgLTIwOSAtMTAzIC0zODUuNXQtMjc5LjUgLTI3OS41dC0zODUuNSAtMTAzdC0zODUuNSAxMDN0LTI3OS41IDI3OS41dC0xMDMgMzg1LjV0MTAzIDM4NS41dDI3OS41IDI3OS41dDM4NS41IDEwM3QzODUuNSAtMTAzdDI3OS41IC0yNzkuNXQxMDMgLTM4NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJlbGxpcHNpc19ob3Jpem9udGFsIiB1bmljb2RlPSImI3hmMTQxOyIgaG9yaXotYWR2LXg9IjE0MDgiIApkPSJNMzg0IDgwMHYtMTkycTAgLTQwIC0yOCAtNjh0LTY4IC0yOGgtMTkycS00MCAwIC02OCAyOHQtMjggNjh2MTkycTAgNDAgMjggNjh0NjggMjhoMTkycTQwIDAgNjggLTI4dDI4IC02OHpNODk2IDgwMHYtMTkycTAgLTQwIC0yOCAtNjh0LTY4IC0yOGgtMTkycS00MCAwIC02OCAyOHQtMjggNjh2MTkycTAgNDAgMjggNjh0NjggMjhoMTkycTQwIDAgNjggLTI4dDI4IC02OHpNMTQwOCA4MDB2LTE5MnEwIC00MCAtMjggLTY4dC02OCAtMjhoLTE5MgpxLTQwIDAgLTY4IDI4dC0yOCA2OHYxOTJxMCA0MCAyOCA2OHQ2OCAyOGgxOTJxNDAgMCA2OCAtMjh0MjggLTY4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJlbGxpcHNpc192ZXJ0aWNhbCIgdW5pY29kZT0iJiN4ZjE0MjsiIGhvcml6LWFkdi14PSIzODQiIApkPSJNMzg0IDI4OHYtMTkycTAgLTQwIC0yOCAtNjh0LTY4IC0yOGgtMTkycS00MCAwIC02OCAyOHQtMjggNjh2MTkycTAgNDAgMjggNjh0NjggMjhoMTkycTQwIDAgNjggLTI4dDI4IC02OHpNMzg0IDgwMHYtMTkycTAgLTQwIC0yOCAtNjh0LTY4IC0yOGgtMTkycS00MCAwIC02OCAyOHQtMjggNjh2MTkycTAgNDAgMjggNjh0NjggMjhoMTkycTQwIDAgNjggLTI4dDI4IC02OHpNMzg0IDEzMTJ2LTE5MnEwIC00MCAtMjggLTY4dC02OCAtMjhoLTE5MgpxLTQwIDAgLTY4IDI4dC0yOCA2OHYxOTJxMCA0MCAyOCA2OHQ2OCAyOGgxOTJxNDAgMCA2OCAtMjh0MjggLTY4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfMzAzIiB1bmljb2RlPSImI3hmMTQzOyIgCmQ9Ik01MTIgMjU2cTAgNTMgLTM3LjUgOTAuNXQtOTAuNSAzNy41dC05MC41IC0zNy41dC0zNy41IC05MC41dDM3LjUgLTkwLjV0OTAuNSAtMzcuNXQ5MC41IDM3LjV0MzcuNSA5MC41ek04NjMgMTYycS0xMyAyMzMgLTE3Ni41IDM5Ni41dC0zOTYuNSAxNzYuNXEtMTQgMSAtMjQgLTl0LTEwIC0yM3YtMTI4cTAgLTEzIDguNSAtMjJ0MjEuNSAtMTBxMTU0IC0xMSAyNjQgLTEyMXQxMjEgLTI2NHExIC0xMyAxMCAtMjEuNXQyMiAtOC41aDEyOApxMTMgMCAyMyAxMHQ5IDI0ek0xMjQ3IDE2MXEtNSAxNTQgLTU2IDI5Ny41dC0xMzkuNSAyNjB0LTIwNSAyMDV0LTI2MCAxMzkuNXQtMjk3LjUgNTZxLTE0IDEgLTIzIC05cS0xMCAtMTAgLTEwIC0yM3YtMTI4cTAgLTEzIDkgLTIydDIyIC0xMHEyMDQgLTcgMzc4IC0xMTEuNXQyNzguNSAtMjc4LjV0MTExLjUgLTM3OHExIC0xMyAxMCAtMjJ0MjIgLTloMTI4cTEzIDAgMjMgMTBxMTEgOSA5IDIzek0xNTM2IDExMjB2LTk2MApxMCAtMTE5IC04NC41IC0yMDMuNXQtMjAzLjUgLTg0LjVoLTk2MHEtMTE5IDAgLTIwMy41IDg0LjV0LTg0LjUgMjAzLjV2OTYwcTAgMTE5IDg0LjUgMjAzLjV0MjAzLjUgODQuNWg5NjBxMTE5IDAgMjAzLjUgLTg0LjV0ODQuNSAtMjAzLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InBsYXlfc2lnbiIgdW5pY29kZT0iJiN4ZjE0NDsiIApkPSJNNzY4IDE0MDhxMjA5IDAgMzg1LjUgLTEwM3QyNzkuNSAtMjc5LjV0MTAzIC0zODUuNXQtMTAzIC0zODUuNXQtMjc5LjUgLTI3OS41dC0zODUuNSAtMTAzdC0zODUuNSAxMDN0LTI3OS41IDI3OS41dC0xMDMgMzg1LjV0MTAzIDM4NS41dDI3OS41IDI3OS41dDM4NS41IDEwM3pNMTE1MiA1ODVxMzIgMTggMzIgNTV0LTMyIDU1bC01NDQgMzIwcS0zMSAxOSAtNjQgMXEtMzIgLTE5IC0zMiAtNTZ2LTY0MHEwIC0zNyAzMiAtNTYKcTE2IC04IDMyIC04cTE3IDAgMzIgOXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idGlja2V0IiB1bmljb2RlPSImI3hmMTQ1OyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTAyNCAxMDg0bDMxNiAtMzE2bC01NzIgLTU3MmwtMzE2IDMxNnpNODEzIDEwNWw2MTggNjE4cTE5IDE5IDE5IDQ1dC0xOSA0NWwtMzYyIDM2MnEtMTggMTggLTQ1IDE4dC00NSAtMThsLTYxOCAtNjE4cS0xOSAtMTkgLTE5IC00NXQxOSAtNDVsMzYyIC0zNjJxMTggLTE4IDQ1IC0xOHQ0NSAxOHpNMTcwMiA3NDJsLTkwNyAtOTA4cS0zNyAtMzcgLTkwLjUgLTM3dC05MC41IDM3bC0xMjYgMTI2cTU2IDU2IDU2IDEzNnQtNTYgMTM2CnQtMTM2IDU2dC0xMzYgLTU2bC0xMjUgMTI2cS0zNyAzNyAtMzcgOTAuNXQzNyA5MC41bDkwNyA5MDZxMzcgMzcgOTAuNSAzN3Q5MC41IC0zN2wxMjUgLTEyNXEtNTYgLTU2IC01NiAtMTM2dDU2IC0xMzZ0MTM2IC01NnQxMzYgNTZsMTI2IC0xMjVxMzcgLTM3IDM3IC05MC41dC0zNyAtOTAuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibWludXNfc2lnbl9hbHQiIHVuaWNvZGU9IiYjeGYxNDY7IiAKZD0iTTEyODAgNTc2djEyOHEwIDI2IC0xOSA0NXQtNDUgMTloLTg5NnEtMjYgMCAtNDUgLTE5dC0xOSAtNDV2LTEyOHEwIC0yNiAxOSAtNDV0NDUgLTE5aDg5NnEyNiAwIDQ1IDE5dDE5IDQ1ek0xNTM2IDExMjB2LTk2MHEwIC0xMTkgLTg0LjUgLTIwMy41dC0yMDMuNSAtODQuNWgtOTYwcS0xMTkgMCAtMjAzLjUgODQuNXQtODQuNSAyMDMuNXY5NjBxMCAxMTkgODQuNSAyMDMuNXQyMDMuNSA4NC41aDk2MHExMTkgMCAyMDMuNSAtODQuNQp0ODQuNSAtMjAzLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNoZWNrX21pbnVzIiB1bmljb2RlPSImI3hmMTQ3OyIgaG9yaXotYWR2LXg9IjE0MDgiIApkPSJNMTE1MiA3MzZ2LTY0cTAgLTE0IC05IC0yM3QtMjMgLTloLTgzMnEtMTQgMCAtMjMgOXQtOSAyM3Y2NHEwIDE0IDkgMjN0MjMgOWg4MzJxMTQgMCAyMyAtOXQ5IC0yM3pNMTI4MCAyODh2ODMycTAgNjYgLTQ3IDExM3QtMTEzIDQ3aC04MzJxLTY2IDAgLTExMyAtNDd0LTQ3IC0xMTN2LTgzMnEwIC02NiA0NyAtMTEzdDExMyAtNDdoODMycTY2IDAgMTEzIDQ3dDQ3IDExM3pNMTQwOCAxMTIwdi04MzJxMCAtMTE5IC04NC41IC0yMDMuNQp0LTIwMy41IC04NC41aC04MzJxLTExOSAwIC0yMDMuNSA4NC41dC04NC41IDIwMy41djgzMnEwIDExOSA4NC41IDIwMy41dDIwMy41IDg0LjVoODMycTExOSAwIDIwMy41IC04NC41dDg0LjUgLTIwMy41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJsZXZlbF91cCIgdW5pY29kZT0iJiN4ZjE0ODsiIGhvcml6LWFkdi14PSIxMDI0IiAKZD0iTTEwMTggOTMzcS0xOCAtMzcgLTU4IC0zN2gtMTkydi04NjRxMCAtMTQgLTkgLTIzdC0yMyAtOWgtNzA0cS0yMSAwIC0yOSAxOHEtOCAyMCA0IDM1bDE2MCAxOTJxOSAxMSAyNSAxMWgzMjB2NjQwaC0xOTJxLTQwIDAgLTU4IDM3cS0xNyAzNyA5IDY4bDMyMCAzODRxMTggMjIgNDkgMjJ0NDkgLTIybDMyMCAtMzg0cTI3IC0zMiA5IC02OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibGV2ZWxfZG93biIgdW5pY29kZT0iJiN4ZjE0OTsiIGhvcml6LWFkdi14PSIxMDI0IiAKZD0iTTMyIDEyODBoNzA0cTEzIDAgMjIuNSAtOS41dDkuNSAtMjMuNXYtODYzaDE5MnE0MCAwIDU4IC0zN3QtOSAtNjlsLTMyMCAtMzg0cS0xOCAtMjIgLTQ5IC0yMnQtNDkgMjJsLTMyMCAzODRxLTI2IDMxIC05IDY5cTE4IDM3IDU4IDM3aDE5MnY2NDBoLTMyMHEtMTQgMCAtMjUgMTFsLTE2MCAxOTJxLTEzIDE0IC00IDM0cTkgMTkgMjkgMTl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNoZWNrX3NpZ24iIHVuaWNvZGU9IiYjeGYxNGE7IiAKZD0iTTY4NSAyMzdsNjE0IDYxNHExOSAxOSAxOSA0NXQtMTkgNDVsLTEwMiAxMDJxLTE5IDE5IC00NSAxOXQtNDUgLTE5bC00NjcgLTQ2N2wtMjExIDIxMXEtMTkgMTkgLTQ1IDE5dC00NSAtMTlsLTEwMiAtMTAycS0xOSAtMTkgLTE5IC00NXQxOSAtNDVsMzU4IC0zNThxMTkgLTE5IDQ1IC0xOXQ0NSAxOXpNMTUzNiAxMTIwdi05NjBxMCAtMTE5IC04NC41IC0yMDMuNXQtMjAzLjUgLTg0LjVoLTk2MHEtMTE5IDAgLTIwMy41IDg0LjUKdC04NC41IDIwMy41djk2MHEwIDExOSA4NC41IDIwMy41dDIwMy41IDg0LjVoOTYwcTExOSAwIDIwMy41IC04NC41dDg0LjUgLTIwMy41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJlZGl0X3NpZ24iIHVuaWNvZGU9IiYjeGYxNGI7IiAKZD0iTTQwNCA0MjhsMTUyIC0xNTJsLTUyIC01MmgtNTZ2OTZoLTk2djU2ek04MTggODE4cTE0IC0xMyAtMyAtMzBsLTI5MSAtMjkxcS0xNyAtMTcgLTMwIC0zcS0xNCAxMyAzIDMwbDI5MSAyOTFxMTcgMTcgMzAgM3pNNTQ0IDEyOGw1NDQgNTQ0bC0yODggMjg4bC01NDQgLTU0NHYtMjg4aDI4OHpNMTE1MiA3MzZsOTIgOTJxMjggMjggMjggNjh0LTI4IDY4bC0xNTIgMTUycS0yOCAyOCAtNjggMjh0LTY4IC0yOGwtOTIgLTkyek0xNTM2IDExMjAKdi05NjBxMCAtMTE5IC04NC41IC0yMDMuNXQtMjAzLjUgLTg0LjVoLTk2MHEtMTE5IDAgLTIwMy41IDg0LjV0LTg0LjUgMjAzLjV2OTYwcTAgMTE5IDg0LjUgMjAzLjV0MjAzLjUgODQuNWg5NjBxMTE5IDAgMjAzLjUgLTg0LjV0ODQuNSAtMjAzLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il8zMTIiIHVuaWNvZGU9IiYjeGYxNGM7IiAKZD0iTTEyODAgNjA4djQ4MHEwIDI2IC0xOSA0NXQtNDUgMTloLTQ4MHEtNDIgMCAtNTkgLTM5cS0xNyAtNDEgMTQgLTcwbDE0NCAtMTQ0bC01MzQgLTUzNHEtMTkgLTE5IC0xOSAtNDV0MTkgLTQ1bDEwMiAtMTAycTE5IC0xOSA0NSAtMTl0NDUgMTlsNTM0IDUzNGwxNDQgLTE0NHExOCAtMTkgNDUgLTE5cTEyIDAgMjUgNXEzOSAxNyAzOSA1OXpNMTUzNiAxMTIwdi05NjBxMCAtMTE5IC04NC41IC0yMDMuNXQtMjAzLjUgLTg0LjVoLTk2MApxLTExOSAwIC0yMDMuNSA4NC41dC04NC41IDIwMy41djk2MHEwIDExOSA4NC41IDIwMy41dDIwMy41IDg0LjVoOTYwcTExOSAwIDIwMy41IC04NC41dDg0LjUgLTIwMy41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzaGFyZV9zaWduIiB1bmljb2RlPSImI3hmMTRkOyIgCmQ9Ik0xMDA1IDQzNWwzNTIgMzUycTE5IDE5IDE5IDQ1dC0xOSA0NWwtMzUyIDM1MnEtMzAgMzEgLTY5IDE0cS00MCAtMTcgLTQwIC01OXYtMTYwcS0xMTkgMCAtMjE2IC0xOS41dC0xNjIuNSAtNTF0LTExNCAtNzl0LTc2LjUgLTk1LjV0LTQ0LjUgLTEwOXQtMjEuNSAtMTExLjV0LTUgLTExMC41cTAgLTE4MSAxNjcgLTQwNHExMSAtMTIgMjUgLTEycTcgMCAxMyAzcTIyIDkgMTkgMzNxLTQ0IDM1NCA2MiA0NzNxNDYgNTIgMTMwIDc1LjUKdDIyNCAyMy41di0xNjBxMCAtNDIgNDAgLTU5cTEyIC01IDI0IC01cTI2IDAgNDUgMTl6TTE1MzYgMTEyMHYtOTYwcTAgLTExOSAtODQuNSAtMjAzLjV0LTIwMy41IC04NC41aC05NjBxLTExOSAwIC0yMDMuNSA4NC41dC04NC41IDIwMy41djk2MHEwIDExOSA4NC41IDIwMy41dDIwMy41IDg0LjVoOTYwcTExOSAwIDIwMy41IC04NC41dDg0LjUgLTIwMy41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJjb21wYXNzIiB1bmljb2RlPSImI3hmMTRlOyIgCmQ9Ik02NDAgNDQ4bDI1NiAxMjhsLTI1NiAxMjh2LTI1NnpNMTAyNCAxMDM5di01NDJsLTUxMiAtMjU2djU0MnpNMTMxMiA2NDBxMCAxNDggLTczIDI3M3QtMTk4IDE5OHQtMjczIDczdC0yNzMgLTczdC0xOTggLTE5OHQtNzMgLTI3M3Q3MyAtMjczdDE5OCAtMTk4dDI3MyAtNzN0MjczIDczdDE5OCAxOTh0NzMgMjczek0xNTM2IDY0MHEwIC0yMDkgLTEwMyAtMzg1LjV0LTI3OS41IC0yNzkuNXQtMzg1LjUgLTEwM3QtMzg1LjUgMTAzCnQtMjc5LjUgMjc5LjV0LTEwMyAzODUuNXQxMDMgMzg1LjV0Mjc5LjUgMjc5LjV0Mzg1LjUgMTAzdDM4NS41IC0xMDN0Mjc5LjUgLTI3OS41dDEwMyAtMzg1LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNvbGxhcHNlIiB1bmljb2RlPSImI3hmMTUwOyIgCmQ9Ik0xMTQ1IDg2MXExOCAtMzUgLTUgLTY2bC0zMjAgLTQ0OHEtMTkgLTI3IC01MiAtMjd0LTUyIDI3bC0zMjAgNDQ4cS0yMyAzMSAtNSA2NnExNyAzNSA1NyAzNWg2NDBxNDAgMCA1NyAtMzV6TTEyODAgMTYwdjk2MHEwIDEzIC05LjUgMjIuNXQtMjIuNSA5LjVoLTk2MHEtMTMgMCAtMjIuNSAtOS41dC05LjUgLTIyLjV2LTk2MHEwIC0xMyA5LjUgLTIyLjV0MjIuNSAtOS41aDk2MHExMyAwIDIyLjUgOS41dDkuNSAyMi41ek0xNTM2IDExMjAKdi05NjBxMCAtMTE5IC04NC41IC0yMDMuNXQtMjAzLjUgLTg0LjVoLTk2MHEtMTE5IDAgLTIwMy41IDg0LjV0LTg0LjUgMjAzLjV2OTYwcTAgMTE5IDg0LjUgMjAzLjV0MjAzLjUgODQuNWg5NjBxMTE5IDAgMjAzLjUgLTg0LjV0ODQuNSAtMjAzLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImNvbGxhcHNlX3RvcCIgdW5pY29kZT0iJiN4ZjE1MTsiIApkPSJNMTE0NSA0MTlxLTE3IC0zNSAtNTcgLTM1aC02NDBxLTQwIDAgLTU3IDM1cS0xOCAzNSA1IDY2bDMyMCA0NDhxMTkgMjcgNTIgMjd0NTIgLTI3bDMyMCAtNDQ4cTIzIC0zMSA1IC02NnpNMTI4MCAxNjB2OTYwcTAgMTMgLTkuNSAyMi41dC0yMi41IDkuNWgtOTYwcS0xMyAwIC0yMi41IC05LjV0LTkuNSAtMjIuNXYtOTYwcTAgLTEzIDkuNSAtMjIuNXQyMi41IC05LjVoOTYwcTEzIDAgMjIuNSA5LjV0OS41IDIyLjV6TTE1MzYgMTEyMHYtOTYwCnEwIC0xMTkgLTg0LjUgLTIwMy41dC0yMDMuNSAtODQuNWgtOTYwcS0xMTkgMCAtMjAzLjUgODQuNXQtODQuNSAyMDMuNXY5NjBxMCAxMTkgODQuNSAyMDMuNXQyMDMuNSA4NC41aDk2MHExMTkgMCAyMDMuNSAtODQuNXQ4NC41IC0yMDMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzMxNyIgdW5pY29kZT0iJiN4ZjE1MjsiIApkPSJNMTA4OCA2NDBxMCAtMzMgLTI3IC01MmwtNDQ4IC0zMjBxLTMxIC0yMyAtNjYgLTVxLTM1IDE3IC0zNSA1N3Y2NDBxMCA0MCAzNSA1N3EzNSAxOCA2NiAtNWw0NDggLTMyMHEyNyAtMTkgMjcgLTUyek0xMjgwIDE2MHY5NjBxMCAxNCAtOSAyM3QtMjMgOWgtOTYwcS0xNCAwIC0yMyAtOXQtOSAtMjN2LTk2MHEwIC0xNCA5IC0yM3QyMyAtOWg5NjBxMTQgMCAyMyA5dDkgMjN6TTE1MzYgMTEyMHYtOTYwcTAgLTExOSAtODQuNSAtMjAzLjUKdC0yMDMuNSAtODQuNWgtOTYwcS0xMTkgMCAtMjAzLjUgODQuNXQtODQuNSAyMDMuNXY5NjBxMCAxMTkgODQuNSAyMDMuNXQyMDMuNSA4NC41aDk2MHExMTkgMCAyMDMuNSAtODQuNXQ4NC41IC0yMDMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZXVyIiB1bmljb2RlPSImI3hmMTUzOyIgaG9yaXotYWR2LXg9IjEwMjQiIApkPSJNOTc2IDIyOWwzNSAtMTU5cTMgLTEyIC0zIC0yMi41dC0xNyAtMTQuNWwtNSAtMXEtNCAtMiAtMTAuNSAtMy41dC0xNiAtNC41dC0yMS41IC01LjV0LTI1LjUgLTV0LTMwIC01dC0zMy41IC00LjV0LTM2LjUgLTN0LTM4LjUgLTFxLTIzNCAwIC00MDkgMTMwLjV0LTIzOCAzNTEuNWgtOTVxLTEzIDAgLTIyLjUgOS41dC05LjUgMjIuNXYxMTNxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWg2NnEtMiA1NyAxIDEwNWgtNjdxLTE0IDAgLTIzIDkKdC05IDIzdjExNHEwIDE0IDkgMjN0MjMgOWg5OHE2NyAyMTAgMjQzLjUgMzM4dDQwMC41IDEyOHExMDIgMCAxOTQgLTIzcTExIC0zIDIwIC0xNXE2IC0xMSAzIC0yNGwtNDMgLTE1OXEtMyAtMTMgLTE0IC0xOS41dC0yNCAtMi41bC00IDFxLTQgMSAtMTEuNSAyLjVsLTE3LjUgMy41dC0yMi41IDMuNXQtMjYgM3QtMjkgMi41dC0yOS41IDFxLTEyNiAwIC0yMjYgLTY0dC0xNTAgLTE3Nmg0NjhxMTYgMCAyNSAtMTJxMTAgLTEyIDcgLTI2CmwtMjQgLTExNHEtNSAtMjYgLTMyIC0yNmgtNDg4cS0zIC0zNyAwIC0xMDVoNDU5cTE1IDAgMjUgLTEycTkgLTEyIDYgLTI3bC0yNCAtMTEycS0yIC0xMSAtMTEgLTE4LjV0LTIwIC03LjVoLTM4N3E0OCAtMTE3IDE0OS41IC0xODUuNXQyMjguNSAtNjguNXExOCAwIDM2IDEuNXQzMy41IDMuNXQyOS41IDQuNXQyNC41IDV0MTguNSA0LjVsMTIgM2w1IDJxMTMgNSAyNiAtMnExMiAtNyAxNSAtMjF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImdicCIgdW5pY29kZT0iJiN4ZjE1NDsiIGhvcml6LWFkdi14PSIxMDI0IiAKZD0iTTEwMjAgMzk5di0zNjdxMCAtMTQgLTkgLTIzdC0yMyAtOWgtOTU2cS0xNCAwIC0yMyA5dC05IDIzdjE1MHEwIDEzIDkuNSAyMi41dDIyLjUgOS41aDk3djM4M2gtOTVxLTE0IDAgLTIzIDkuNXQtOSAyMi41djEzMXEwIDE0IDkgMjN0MjMgOWg5NXYyMjNxMCAxNzEgMTIzLjUgMjgydDMxNC41IDExMXExODUgMCAzMzUgLTEyNXE5IC04IDEwIC0yMC41dC03IC0yMi41bC0xMDMgLTEyN3EtOSAtMTEgLTIyIC0xMnEtMTMgLTIgLTIzIDcKcS01IDUgLTI2IDE5dC02OSAzMnQtOTMgMThxLTg1IDAgLTEzNyAtNDd0LTUyIC0xMjN2LTIxNWgzMDVxMTMgMCAyMi41IC05dDkuNSAtMjN2LTEzMXEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTMwNXYtMzc5aDQxNHYxODFxMCAxMyA5IDIyLjV0MjMgOS41aDE2MnExNCAwIDIzIC05LjV0OSAtMjIuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idXNkIiB1bmljb2RlPSImI3hmMTU1OyIgaG9yaXotYWR2LXg9IjEwMjQiIApkPSJNOTc4IDM1MXEwIC0xNTMgLTk5LjUgLTI2My41dC0yNTguNSAtMTM2LjV2LTE3NXEwIC0xNCAtOSAtMjN0LTIzIC05aC0xMzVxLTEzIDAgLTIyLjUgOS41dC05LjUgMjIuNXYxNzVxLTY2IDkgLTEyNy41IDMxdC0xMDEuNSA0NC41dC03NCA0OHQtNDYuNSAzNy41dC0xNy41IDE4cS0xNyAyMSAtMiA0MWwxMDMgMTM1cTcgMTAgMjMgMTJxMTUgMiAyNCAtOWwyIC0ycTExMyAtOTkgMjQzIC0xMjVxMzcgLTggNzQgLThxODEgMCAxNDIuNSA0Mwp0NjEuNSAxMjJxMCAyOCAtMTUgNTN0LTMzLjUgNDJ0LTU4LjUgMzcuNXQtNjYgMzJ0LTgwIDMyLjVxLTM5IDE2IC02MS41IDI1dC02MS41IDI2LjV0LTYyLjUgMzF0LTU2LjUgMzUuNXQtNTMuNSA0Mi41dC00My41IDQ5dC0zNS41IDU4dC0yMSA2Ni41dC04LjUgNzhxMCAxMzggOTggMjQydDI1NSAxMzR2MTgwcTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoMTM1cTE0IDAgMjMgLTl0OSAtMjN2LTE3NnE1NyAtNiAxMTAuNSAtMjN0ODcgLTMzLjUKdDYzLjUgLTM3LjV0MzkgLTI5dDE1IC0xNHExNyAtMTggNSAtMzhsLTgxIC0xNDZxLTggLTE1IC0yMyAtMTZxLTE0IC0zIC0yNyA3cS0zIDMgLTE0LjUgMTJ0LTM5IDI2LjV0LTU4LjUgMzJ0LTc0LjUgMjZ0LTg1LjUgMTEuNXEtOTUgMCAtMTU1IC00M3QtNjAgLTExMXEwIC0yNiA4LjUgLTQ4dDI5LjUgLTQxLjV0MzkuNSAtMzN0NTYgLTMxdDYwLjUgLTI3dDcwIC0yNy41cTUzIC0yMCA4MSAtMzEuNXQ3NiAtMzV0NzUuNSAtNDIuNXQ2MiAtNTAKdDUzIC02My41dDMxLjUgLTc2LjV0MTMgLTk0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJpbnIiIHVuaWNvZGU9IiYjeGYxNTY7IiBob3Jpei1hZHYteD0iODk4IiAKZD0iTTg5OCAxMDY2di0xMDJxMCAtMTQgLTkgLTIzdC0yMyAtOWgtMTY4cS0yMyAtMTQ0IC0xMjkgLTIzNHQtMjc2IC0xMTBxMTY3IC0xNzggNDU5IC01MzZxMTQgLTE2IDQgLTM0cS04IC0xOCAtMjkgLTE4aC0xOTVxLTE2IDAgLTI1IDEycS0zMDYgMzY3IC00OTggNTcxcS05IDkgLTkgMjJ2MTI3cTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoMTEycTEzMiAwIDIxMi41IDQzdDEwMi41IDEyNWgtNDI3cS0xNCAwIC0yMyA5dC05IDIzdjEwMgpxMCAxNCA5IDIzdDIzIDloNDEzcS01NyAxMTMgLTI2OCAxMTNoLTE0NXEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djEzM3EwIDE0IDkgMjN0MjMgOWg4MzJxMTQgMCAyMyAtOXQ5IC0yM3YtMTAycTAgLTE0IC05IC0yM3QtMjMgLTloLTIzM3E0NyAtNjEgNjQgLTE0NGgxNzFxMTQgMCAyMyAtOXQ5IC0yM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ianB5IiB1bmljb2RlPSImI3hmMTU3OyIgaG9yaXotYWR2LXg9IjEwMjciIApkPSJNNjAzIDBoLTE3MnEtMTMgMCAtMjIuNSA5dC05LjUgMjN2MzMwaC0yODhxLTEzIDAgLTIyLjUgOXQtOS41IDIzdjEwM3EwIDEzIDkuNSAyMi41dDIyLjUgOS41aDI4OHY4NWgtMjg4cS0xMyAwIC0yMi41IDl0LTkuNSAyM3YxMDRxMCAxMyA5LjUgMjIuNXQyMi41IDkuNWgyMTRsLTMyMSA1NzhxLTggMTYgMCAzMnExMCAxNiAyOCAxNmgxOTRxMTkgMCAyOSAtMThsMjE1IC00MjVxMTkgLTM4IDU2IC0xMjVxMTAgMjQgMzAuNSA2OHQyNy41IDYxCmwxOTEgNDIwcTggMTkgMjkgMTloMTkxcTE3IDAgMjcgLTE2cTkgLTE0IDEgLTMxbC0zMTMgLTU3OWgyMTVxMTMgMCAyMi41IC05LjV0OS41IC0yMi41di0xMDRxMCAtMTQgLTkuNSAtMjN0LTIyLjUgLTloLTI5MHYtODVoMjkwcTEzIDAgMjIuNSAtOS41dDkuNSAtMjIuNXYtMTAzcTAgLTE0IC05LjUgLTIzdC0yMi41IC05aC0yOTB2LTMzMHEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InJ1YiIgdW5pY29kZT0iJiN4ZjE1ODsiIGhvcml6LWFkdi14PSIxMjgwIiAKZD0iTTEwNDMgOTcxcTAgMTAwIC02NSAxNjJ0LTE3MSA2MmgtMzIwdi00NDhoMzIwcTEwNiAwIDE3MSA2MnQ2NSAxNjJ6TTEyODAgOTcxcTAgLTE5MyAtMTI2LjUgLTMxNXQtMzI2LjUgLTEyMmgtMzQwdi0xMThoNTA1cTE0IDAgMjMgLTl0OSAtMjN2LTEyOHEwIC0xNCAtOSAtMjN0LTIzIC05aC01MDV2LTE5MnEwIC0xNCAtOS41IC0yM3QtMjIuNSAtOWgtMTY3cS0xNCAwIC0yMyA5dC05IDIzdjE5MmgtMjI0cS0xNCAwIC0yMyA5dC05IDIzdjEyOApxMCAxNCA5IDIzdDIzIDloMjI0djExOGgtMjI0cS0xNCAwIC0yMyA5dC05IDIzdjE0OXEwIDEzIDkgMjIuNXQyMyA5LjVoMjI0djYyOXEwIDE0IDkgMjN0MjMgOWg1MzlxMjAwIDAgMzI2LjUgLTEyMnQxMjYuNSAtMzE1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJrcnciIHVuaWNvZGU9IiYjeGYxNTk7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik01MTQgMzQxbDgxIDI5OWgtMTU5bDc1IC0zMDBxMSAtMSAxIC0zdDEgLTNxMCAxIDAuNSAzLjV0MC41IDMuNXpNNjMwIDc2OGwzNSAxMjhoLTI5MmwzMiAtMTI4aDIyNXpNODIyIDc2OGgxMzlsLTM1IDEyOGgtNzB6TTEyNzEgMzQwbDc4IDMwMGgtMTYybDgxIC0yOTlxMCAtMSAwLjUgLTMuNXQxLjUgLTMuNXEwIDEgMC41IDN0MC41IDN6TTEzODIgNzY4bDMzIDEyOGgtMjk3bDM0IC0xMjhoMjMwek0xNzkyIDczNnYtNjRxMCAtMTQgLTkgLTIzCnQtMjMgLTloLTIxM2wtMTY0IC02MTZxLTcgLTI0IC0zMSAtMjRoLTE1OXEtMjQgMCAtMzEgMjRsLTE2NiA2MTZoLTIwOWwtMTY3IC02MTZxLTcgLTI0IC0zMSAtMjRoLTE1OXEtMTEgMCAtMTkuNSA3dC0xMC41IDE3bC0xNjAgNjE2aC0yMDhxLTE0IDAgLTIzIDl0LTkgMjN2NjRxMCAxNCA5IDIzdDIzIDloMTc1bC0zMyAxMjhoLTE0MnEtMTQgMCAtMjMgOXQtOSAyM3Y2NHEwIDE0IDkgMjN0MjMgOWgxMDlsLTg5IDM0NHEtNSAxNSA1IDI4CnExMCAxMiAyNiAxMmgxMzdxMjYgMCAzMSAtMjRsOTAgLTM2MGgzNTlsOTcgMzYwcTcgMjQgMzEgMjRoMTI2cTI0IDAgMzEgLTI0bDk4IC0zNjBoMzY1bDkzIDM2MHE1IDI0IDMxIDI0aDEzN3ExNiAwIDI2IC0xMnExMCAtMTMgNSAtMjhsLTkxIC0zNDRoMTExcTE0IDAgMjMgLTl0OSAtMjN2LTY0cTAgLTE0IC05IC0yM3QtMjMgLTloLTE0NWwtMzQgLTEyOGgxNzlxMTQgMCAyMyAtOXQ5IC0yM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYnRjIiB1bmljb2RlPSImI3hmMTVhOyIgaG9yaXotYWR2LXg9IjEyODAiIApkPSJNMTE2NyA4OTZxMTggLTE4MiAtMTMxIC0yNThxMTE3IC0yOCAxNzUgLTEwM3Q0NSAtMjE0cS03IC03MSAtMzIuNSAtMTI1dC02NC41IC04OXQtOTcgLTU4LjV0LTEyMS41IC0zNC41dC0xNDUuNSAtMTV2LTI1NWgtMTU0djI1MXEtODAgMCAtMTIyIDF2LTI1MmgtMTU0djI1NXEtMTggMCAtNTQgMC41dC01NSAwLjVoLTIwMGwzMSAxODNoMTExcTUwIDAgNTggNTF2NDAyaDE2cS02IDEgLTE2IDF2Mjg3cS0xMyA2OCAtODkgNjhoLTExMXYxNjQKbDIxMiAtMXE2NCAwIDk3IDF2MjUyaDE1NHYtMjQ3cTgyIDIgMTIyIDJ2MjQ1aDE1NHYtMjUycTc5IC03IDE0MCAtMjIuNXQxMTMgLTQ1dDgyLjUgLTc4dDM2LjUgLTExNC41ek05NTIgMzUxcTAgMzYgLTE1IDY0dC0zNyA0NnQtNTcuNSAzMC41dC02NS41IDE4LjV0LTc0IDl0LTY5IDN0LTY0LjUgLTF0LTQ3LjUgLTF2LTMzOHE4IDAgMzcgLTAuNXQ0OCAtMC41dDUzIDEuNXQ1OC41IDR0NTcgOC41dDU1LjUgMTR0NDcuNSAyMXQzOS41IDMwCnQyNC41IDQwdDkuNSA1MXpNODgxIDgyN3EwIDMzIC0xMi41IDU4LjV0LTMwLjUgNDJ0LTQ4IDI4dC01NSAxNi41dC02MS41IDh0LTU4IDIuNXQtNTQgLTF0LTM5LjUgLTAuNXYtMzA3cTUgMCAzNC41IC0wLjV0NDYuNSAwdDUwIDJ0NTUgNS41dDUxLjUgMTF0NDguNSAxOC41dDM3IDI3dDI3IDM4LjV0OSA1MXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZmlsZSIgdW5pY29kZT0iJiN4ZjE1YjsiIApkPSJNMTAyNCAxMDI0djQ3MnEyMiAtMTQgMzYgLTI4bDQwOCAtNDA4cTE0IC0xNCAyOCAtMzZoLTQ3MnpNODk2IDk5MnEwIC00MCAyOCAtNjh0NjggLTI4aDU0NHYtMTA1NnEwIC00MCAtMjggLTY4dC02OCAtMjhoLTEzNDRxLTQwIDAgLTY4IDI4dC0yOCA2OHYxNjAwcTAgNDAgMjggNjh0NjggMjhoODAwdi01NDR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImZpbGVfdGV4dCIgdW5pY29kZT0iJiN4ZjE1YzsiIApkPSJNMTQ2OCAxMDYwcTE0IC0xNCAyOCAtMzZoLTQ3MnY0NzJxMjIgLTE0IDM2IC0yOHpNOTkyIDg5Nmg1NDR2LTEwNTZxMCAtNDAgLTI4IC02OHQtNjggLTI4aC0xMzQ0cS00MCAwIC02OCAyOHQtMjggNjh2MTYwMHEwIDQwIDI4IDY4dDY4IDI4aDgwMHYtNTQ0cTAgLTQwIDI4IC02OHQ2OCAtMjh6TTExNTIgMTYwdjY0cTAgMTQgLTkgMjN0LTIzIDloLTcwNHEtMTQgMCAtMjMgLTl0LTkgLTIzdi02NHEwIC0xNCA5IC0yM3QyMyAtOWg3MDQKcTE0IDAgMjMgOXQ5IDIzek0xMTUyIDQxNnY2NHEwIDE0IC05IDIzdC0yMyA5aC03MDRxLTE0IDAgLTIzIC05dC05IC0yM3YtNjRxMCAtMTQgOSAtMjN0MjMgLTloNzA0cTE0IDAgMjMgOXQ5IDIzek0xMTUyIDY3MnY2NHEwIDE0IC05IDIzdC0yMyA5aC03MDRxLTE0IDAgLTIzIC05dC05IC0yM3YtNjRxMCAtMTQgOSAtMjN0MjMgLTloNzA0cTE0IDAgMjMgOXQ5IDIzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzb3J0X2J5X2FscGhhYmV0IiB1bmljb2RlPSImI3hmMTVkOyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNMTE5MSAxMTI4aDE3N2wtNzIgMjE4bC0xMiA0N3EtMiAxNiAtMiAyMGgtNGwtMyAtMjBxMCAtMSAtMy41IC0xOHQtNy41IC0yOXpNNzM2IDk2cTAgLTEyIC0xMCAtMjRsLTMxOSAtMzE5cS0xMCAtOSAtMjMgLTlxLTEyIDAgLTIzIDlsLTMyMCAzMjBxLTE1IDE2IC03IDM1cTggMjAgMzAgMjBoMTkydjEzNzZxMCAxNCA5IDIzdDIzIDloMTkycTE0IDAgMjMgLTl0OSAtMjN2LTEzNzZoMTkycTE0IDAgMjMgLTl0OSAtMjN6TTE1NzIgLTIzCnYtMjMzaC01ODR2OTBsMzY5IDUyOXExMiAxOCAyMSAyN2wxMSA5djNxLTIgMCAtNi41IC0wLjV0LTcuNSAtMC41cS0xMiAtMyAtMzAgLTNoLTIzMnYtMTE1aC0xMjB2MjI5aDU2N3YtODlsLTM2OSAtNTMwcS02IC04IC0yMSAtMjZsLTExIC0xMXYtMmwxNCAycTkgMiAzMCAyaDI0OHYxMTloMTIxek0xNjYxIDg3NHYtMTA2aC0yODh2MTA2aDc1bC00NyAxNDRoLTI0M2wtNDcgLTE0NGg3NXYtMTA2aC0yODd2MTA2aDcwbDIzMCA2NjJoMTYyCmwyMzAgLTY2Mmg3MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzMyOSIgdW5pY29kZT0iJiN4ZjE1ZTsiIGhvcml6LWFkdi14PSIxNjY0IiAKZD0iTTExOTEgMTA0aDE3N2wtNzIgMjE4bC0xMiA0N3EtMiAxNiAtMiAyMGgtNGwtMyAtMjBxMCAtMSAtMy41IC0xOHQtNy41IC0yOXpNNzM2IDk2cTAgLTEyIC0xMCAtMjRsLTMxOSAtMzE5cS0xMCAtOSAtMjMgLTlxLTEyIDAgLTIzIDlsLTMyMCAzMjBxLTE1IDE2IC03IDM1cTggMjAgMzAgMjBoMTkydjEzNzZxMCAxNCA5IDIzdDIzIDloMTkycTE0IDAgMjMgLTl0OSAtMjN2LTEzNzZoMTkycTE0IDAgMjMgLTl0OSAtMjN6TTE2NjEgLTE1MAp2LTEwNmgtMjg4djEwNmg3NWwtNDcgMTQ0aC0yNDNsLTQ3IC0xNDRoNzV2LTEwNmgtMjg3djEwNmg3MGwyMzAgNjYyaDE2MmwyMzAgLTY2Mmg3MHpNMTU3MiAxMDAxdi0yMzNoLTU4NHY5MGwzNjkgNTI5cTEyIDE4IDIxIDI3bDExIDl2M3EtMiAwIC02LjUgLTAuNXQtNy41IC0wLjVxLTEyIC0zIC0zMCAtM2gtMjMydi0xMTVoLTEyMHYyMjloNTY3di04OWwtMzY5IC01MzBxLTYgLTggLTIxIC0yNmwtMTEgLTEwdi0zbDE0IDNxOSAxIDMwIDFoMjQ4CnYxMTloMTIxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzb3J0X2J5X2F0dHJpYnV0ZXMiIHVuaWNvZGU9IiYjeGYxNjA7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik03MzYgOTZxMCAtMTIgLTEwIC0yNGwtMzE5IC0zMTlxLTEwIC05IC0yMyAtOXEtMTIgMCAtMjMgOWwtMzIwIDMyMHEtMTUgMTYgLTcgMzVxOCAyMCAzMCAyMGgxOTJ2MTM3NnEwIDE0IDkgMjN0MjMgOWgxOTJxMTQgMCAyMyAtOXQ5IC0yM3YtMTM3NmgxOTJxMTQgMCAyMyAtOXQ5IC0yM3pNMTc5MiAtMzJ2LTE5MnEwIC0xNCAtOSAtMjN0LTIzIC05aC04MzJxLTE0IDAgLTIzIDl0LTkgMjN2MTkycTAgMTQgOSAyM3QyMyA5aDgzMgpxMTQgMCAyMyAtOXQ5IC0yM3pNMTYwMCA0ODB2LTE5MnEwIC0xNCAtOSAtMjN0LTIzIC05aC02NDBxLTE0IDAgLTIzIDl0LTkgMjN2MTkycTAgMTQgOSAyM3QyMyA5aDY0MHExNCAwIDIzIC05dDkgLTIzek0xNDA4IDk5MnYtMTkycTAgLTE0IC05IC0yM3QtMjMgLTloLTQ0OHEtMTQgMCAtMjMgOXQtOSAyM3YxOTJxMCAxNCA5IDIzdDIzIDloNDQ4cTE0IDAgMjMgLTl0OSAtMjN6TTEyMTYgMTUwNHYtMTkycTAgLTE0IC05IC0yM3QtMjMgLTloLTI1NgpxLTE0IDAgLTIzIDl0LTkgMjN2MTkycTAgMTQgOSAyM3QyMyA5aDI1NnExNCAwIDIzIC05dDkgLTIzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzb3J0X2J5X2F0dHJpYnV0ZXNfYWx0IiB1bmljb2RlPSImI3hmMTYxOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTIxNiAtMzJ2LTE5MnEwIC0xNCAtOSAtMjN0LTIzIC05aC0yNTZxLTE0IDAgLTIzIDl0LTkgMjN2MTkycTAgMTQgOSAyM3QyMyA5aDI1NnExNCAwIDIzIC05dDkgLTIzek03MzYgOTZxMCAtMTIgLTEwIC0yNGwtMzE5IC0zMTlxLTEwIC05IC0yMyAtOXEtMTIgMCAtMjMgOWwtMzIwIDMyMHEtMTUgMTYgLTcgMzVxOCAyMCAzMCAyMGgxOTJ2MTM3NnEwIDE0IDkgMjN0MjMgOWgxOTJxMTQgMCAyMyAtOXQ5IC0yM3YtMTM3NmgxOTIKcTE0IDAgMjMgLTl0OSAtMjN6TTE0MDggNDgwdi0xOTJxMCAtMTQgLTkgLTIzdC0yMyAtOWgtNDQ4cS0xNCAwIC0yMyA5dC05IDIzdjE5MnEwIDE0IDkgMjN0MjMgOWg0NDhxMTQgMCAyMyAtOXQ5IC0yM3pNMTYwMCA5OTJ2LTE5MnEwIC0xNCAtOSAtMjN0LTIzIC05aC02NDBxLTE0IDAgLTIzIDl0LTkgMjN2MTkycTAgMTQgOSAyM3QyMyA5aDY0MHExNCAwIDIzIC05dDkgLTIzek0xNzkyIDE1MDR2LTE5MnEwIC0xNCAtOSAtMjN0LTIzIC05aC04MzIKcS0xNCAwIC0yMyA5dC05IDIzdjE5MnEwIDE0IDkgMjN0MjMgOWg4MzJxMTQgMCAyMyAtOXQ5IC0yM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ic29ydF9ieV9vcmRlciIgdW5pY29kZT0iJiN4ZjE2MjsiIApkPSJNMTM0NiAyMjNxMCA2MyAtNDQgMTE2dC0xMDMgNTNxLTUyIDAgLTgzIC0zN3QtMzEgLTk0dDM2LjUgLTk1dDEwNC41IC0zOHE1MCAwIDg1IDI3dDM1IDY4ek03MzYgOTZxMCAtMTIgLTEwIC0yNGwtMzE5IC0zMTlxLTEwIC05IC0yMyAtOXEtMTIgMCAtMjMgOWwtMzIwIDMyMHEtMTUgMTYgLTcgMzVxOCAyMCAzMCAyMGgxOTJ2MTM3NnEwIDE0IDkgMjN0MjMgOWgxOTJxMTQgMCAyMyAtOXQ5IC0yM3YtMTM3NmgxOTJxMTQgMCAyMyAtOXQ5IC0yMwp6TTE0ODYgMTY1cTAgLTYyIC0xMyAtMTIxLjV0LTQxIC0xMTR0LTY4IC05NS41dC05OC41IC02NS41dC0xMjcuNSAtMjQuNXEtNjIgMCAtMTA4IDE2cS0yNCA4IC00MiAxNWwzOSAxMTNxMTUgLTcgMzEgLTExcTM3IC0xMyA3NSAtMTNxODQgMCAxMzQuNSA1OC41dDY2LjUgMTQ1LjVoLTJxLTIxIC0yMyAtNjEuNSAtMzd0LTg0LjUgLTE0cS0xMDYgMCAtMTczIDcxLjV0LTY3IDE3Mi41cTAgMTA1IDcyIDE3OHQxODEgNzNxMTIzIDAgMjA1IC05NC41CnQ4MiAtMjUyLjV6TTE0NTYgODgydi0xMTRoLTQ2OXYxMTRoMTY3djQzMnEwIDcgMC41IDE5dDAuNSAxN3YxNmgtMmwtNyAtMTJxLTggLTEzIC0yNiAtMzFsLTYyIC01OGwtODIgODZsMTkyIDE4NWgxMjN2LTY1NGgxNjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InNvcnRfYnlfb3JkZXJfYWx0IiB1bmljb2RlPSImI3hmMTYzOyIgCmQ9Ik0xMzQ2IDEyNDdxMCA2MyAtNDQgMTE2dC0xMDMgNTNxLTUyIDAgLTgzIC0zN3QtMzEgLTk0dDM2LjUgLTk1dDEwNC41IC0zOHE1MCAwIDg1IDI3dDM1IDY4ek03MzYgOTZxMCAtMTIgLTEwIC0yNGwtMzE5IC0zMTlxLTEwIC05IC0yMyAtOXEtMTIgMCAtMjMgOWwtMzIwIDMyMHEtMTUgMTYgLTcgMzVxOCAyMCAzMCAyMGgxOTJ2MTM3NnEwIDE0IDkgMjN0MjMgOWgxOTJxMTQgMCAyMyAtOXQ5IC0yM3YtMTM3NmgxOTJxMTQgMCAyMyAtOQp0OSAtMjN6TTE0NTYgLTE0MnYtMTE0aC00Njl2MTE0aDE2N3Y0MzJxMCA3IDAuNSAxOXQwLjUgMTd2MTZoLTJsLTcgLTEycS04IC0xMyAtMjYgLTMxbC02MiAtNThsLTgyIDg2bDE5MiAxODVoMTIzdi02NTRoMTY1ek0xNDg2IDExODlxMCAtNjIgLTEzIC0xMjEuNXQtNDEgLTExNHQtNjggLTk1LjV0LTk4LjUgLTY1LjV0LTEyNy41IC0yNC41cS02MiAwIC0xMDggMTZxLTI0IDggLTQyIDE1bDM5IDExM3ExNSAtNyAzMSAtMTFxMzcgLTEzIDc1IC0xMwpxODQgMCAxMzQuNSA1OC41dDY2LjUgMTQ1LjVoLTJxLTIxIC0yMyAtNjEuNSAtMzd0LTg0LjUgLTE0cS0xMDYgMCAtMTczIDcxLjV0LTY3IDE3Mi41cTAgMTA1IDcyIDE3OHQxODEgNzNxMTIzIDAgMjA1IC05NC41dDgyIC0yNTIuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzMzNCIgdW5pY29kZT0iJiN4ZjE2NDsiIGhvcml6LWFkdi14PSIxNjY0IiAKZD0iTTI1NiAxOTJxMCAyNiAtMTkgNDV0LTQ1IDE5cS0yNyAwIC00NS41IC0xOXQtMTguNSAtNDVxMCAtMjcgMTguNSAtNDUuNXQ0NS41IC0xOC41cTI2IDAgNDUgMTguNXQxOSA0NS41ek00MTYgNzA0di02NDBxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0yODhxLTI2IDAgLTQ1IDE5dC0xOSA0NXY2NDBxMCAyNiAxOSA0NXQ0NSAxOWgyODhxMjYgMCA0NSAtMTl0MTkgLTQ1ek0xNjAwIDcwNHEwIC04NiAtNTUgLTE0OXExNSAtNDQgMTUgLTc2CnEzIC03NiAtNDMgLTEzN3ExNyAtNTYgMCAtMTE3cS0xNSAtNTcgLTU0IC05NHE5IC0xMTIgLTQ5IC0xODFxLTY0IC03NiAtMTk3IC03OGgtMzZoLTc2aC0xN3EtNjYgMCAtMTQ0IDE1LjV0LTEyMS41IDI5dC0xMjAuNSAzOS41cS0xMjMgNDMgLTE1OCA0NHEtMjYgMSAtNDUgMTkuNXQtMTkgNDQuNXY2NDFxMCAyNSAxOCA0My41dDQzIDIwLjVxMjQgMiA3NiA1OXQxMDEgMTIxcTY4IDg3IDEwMSAxMjBxMTggMTggMzEgNDh0MTcuNSA0OC41CnQxMy41IDYwLjVxNyAzOSAxMi41IDYxdDE5LjUgNTJ0MzQgNTBxMTkgMTkgNDUgMTlxNDYgMCA4Mi41IC0xMC41dDYwIC0yNnQ0MCAtNDAuNXQyNCAtNDV0MTIgLTUwdDUgLTQ1dDAuNSAtMzlxMCAtMzggLTkuNSAtNzZ0LTE5IC02MHQtMjcuNSAtNTZxLTMgLTYgLTEwIC0xOHQtMTEgLTIydC04IC0yNGgyNzdxNzggMCAxMzUgLTU3dDU3IC0xMzV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il8zMzUiIHVuaWNvZGU9IiYjeGYxNjU7IiBob3Jpei1hZHYteD0iMTY2NCIgCmQ9Ik0yNTYgOTYwcTAgLTI2IC0xOSAtNDV0LTQ1IC0xOXEtMjcgMCAtNDUuNSAxOXQtMTguNSA0NXEwIDI3IDE4LjUgNDUuNXQ0NS41IDE4LjVxMjYgMCA0NSAtMTguNXQxOSAtNDUuNXpNNDE2IDQ0OHY2NDBxMCAyNiAtMTkgNDV0LTQ1IDE5aC0yODhxLTI2IDAgLTQ1IC0xOXQtMTkgLTQ1di02NDBxMCAtMjYgMTkgLTQ1dDQ1IC0xOWgyODhxMjYgMCA0NSAxOXQxOSA0NXpNMTU0NSA1OTdxNTUgLTYxIDU1IC0xNDlxLTEgLTc4IC01Ny41IC0xMzUKdC0xMzQuNSAtNTdoLTI3N3E0IC0xNCA4IC0yNHQxMSAtMjJ0MTAgLTE4cTE4IC0zNyAyNyAtNTd0MTkgLTU4LjV0MTAgLTc2LjVxMCAtMjQgLTAuNSAtMzl0LTUgLTQ1dC0xMiAtNTB0LTI0IC00NXQtNDAgLTQwLjV0LTYwIC0yNnQtODIuNSAtMTAuNXEtMjYgMCAtNDUgMTlxLTIwIDIwIC0zNCA1MHQtMTkuNSA1MnQtMTIuNSA2MXEtOSA0MiAtMTMuNSA2MC41dC0xNy41IDQ4LjV0LTMxIDQ4cS0zMyAzMyAtMTAxIDEyMHEtNDkgNjQgLTEwMSAxMjEKdC03NiA1OXEtMjUgMiAtNDMgMjAuNXQtMTggNDMuNXY2NDFxMCAyNiAxOSA0NC41dDQ1IDE5LjVxMzUgMSAxNTggNDRxNzcgMjYgMTIwLjUgMzkuNXQxMjEuNSAyOXQxNDQgMTUuNWgxN2g3NmgzNnExMzMgLTIgMTk3IC03OHE1OCAtNjkgNDkgLTE4MXEzOSAtMzcgNTQgLTk0cTE3IC02MSAwIC0xMTdxNDYgLTYxIDQzIC0xMzdxMCAtMzIgLTE1IC03NnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ieW91dHViZV9zaWduIiB1bmljb2RlPSImI3hmMTY2OyIgCmQ9Ik05MTkgMjMzdjE1N3EwIDUwIC0yOSA1MHEtMTcgMCAtMzMgLTE2di0yMjRxMTYgLTE2IDMzIC0xNnEyOSAwIDI5IDQ5ek0xMTAzIDM1NWg2NnYzNHEwIDUxIC0zMyA1MXQtMzMgLTUxdi0zNHpNNTMyIDYyMXYtNzBoLTgwdi00MjNoLTc0djQyM2gtNzh2NzBoMjMyek03MzMgNDk1di0zNjdoLTY3djQwcS0zOSAtNDUgLTc2IC00NXEtMzMgMCAtNDIgMjhxLTYgMTcgLTYgNTR2MjkwaDY2di0yNzBxMCAtMjQgMSAtMjZxMSAtMTUgMTUgLTE1CnEyMCAwIDQyIDMxdjI4MGg2N3pNOTg1IDM4NHYtMTQ2cTAgLTUyIC03IC03M3EtMTIgLTQyIC01MyAtNDJxLTM1IDAgLTY4IDQxdi0zNmgtNjd2NDkzaDY3di0xNjFxMzIgNDAgNjggNDBxNDEgMCA1MyAtNDJxNyAtMjEgNyAtNzR6TTEyMzYgMjU1di05cTAgLTI5IC0yIC00M3EtMyAtMjIgLTE1IC00MHEtMjcgLTQwIC04MCAtNDBxLTUyIDAgLTgxIDM4cS0yMSAyNyAtMjEgODZ2MTI5cTAgNTkgMjAgODZxMjkgMzggODAgMzh0NzggLTM4CnEyMSAtMjkgMjEgLTg2di03NmgtMTMzdi02NXEwIC01MSAzNCAtNTFxMjQgMCAzMCAyNnEwIDEgMC41IDd0MC41IDE2LjV2MjEuNWg2OHpNNzg1IDEwNzl2LTE1NnEwIC01MSAtMzIgLTUxdC0zMiA1MXYxNTZxMCA1MiAzMiA1MnQzMiAtNTJ6TTEzMTggMzY2cTAgMTc3IC0xOSAyNjBxLTEwIDQ0IC00MyA3My41dC03NiAzNC41cS0xMzYgMTUgLTQxMiAxNXEtMjc1IDAgLTQxMSAtMTVxLTQ0IC01IC03Ni41IC0zNC41dC00Mi41IC03My41CnEtMjAgLTg3IC0yMCAtMjYwcTAgLTE3NiAyMCAtMjYwcTEwIC00MyA0Mi41IC03M3Q3NS41IC0zNXExMzcgLTE1IDQxMiAtMTV0NDEyIDE1cTQzIDUgNzUuNSAzNXQ0Mi41IDczcTIwIDg0IDIwIDI2MHpNNTYzIDEwMTdsOTAgMjk2aC03NWwtNTEgLTE5NWwtNTMgMTk1aC03OHE3IC0yMyAyMyAtNjlsMjQgLTY5cTM1IC0xMDMgNDYgLTE1OHYtMjAxaDc0djIwMXpNODUyIDkzNnYxMzBxMCA1OCAtMjEgODdxLTI5IDM4IC03OCAzOApxLTUxIDAgLTc4IC0zOHEtMjEgLTI5IC0yMSAtODd2LTEzMHEwIC01OCAyMSAtODdxMjcgLTM4IDc4IC0zOHE0OSAwIDc4IDM4cTIxIDI3IDIxIDg3ek0xMDMzIDgxNmg2N3YzNzBoLTY3di0yODNxLTIyIC0zMSAtNDIgLTMxcS0xNSAwIC0xNiAxNnEtMSAyIC0xIDI2djI3MmgtNjd2LTI5M3EwIC0zNyA2IC01NXExMSAtMjcgNDMgLTI3cTM2IDAgNzcgNDV2LTQwek0xNTM2IDExMjB2LTk2MHEwIC0xMTkgLTg0LjUgLTIwMy41dC0yMDMuNSAtODQuNQpoLTk2MHEtMTE5IDAgLTIwMy41IDg0LjV0LTg0LjUgMjAzLjV2OTYwcTAgMTE5IDg0LjUgMjAzLjV0MjAzLjUgODQuNWg5NjBxMTE5IDAgMjAzLjUgLTg0LjV0ODQuNSAtMjAzLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InlvdXR1YmUiIHVuaWNvZGU9IiYjeGYxNjc7IiAKZD0iTTk3MSAyOTJ2LTIxMXEwIC02NyAtMzkgLTY3cS0yMyAwIC00NSAyMnYzMDFxMjIgMjIgNDUgMjJxMzkgMCAzOSAtNjd6TTEzMDkgMjkxdi00NmgtOTB2NDZxMCA2OCA0NSA2OHQ0NSAtNjh6TTM0MyA1MDloMTA3djk0aC0zMTJ2LTk0aDEwNXYtNTY5aDEwMHY1Njl6TTYzMSAtNjBoODl2NDk0aC04OXYtMzc4cS0zMCAtNDIgLTU3IC00MnEtMTggMCAtMjEgMjFxLTEgMyAtMSAzNXYzNjRoLTg5di0zOTFxMCAtNDkgOCAtNzMKcTEyIC0zNyA1OCAtMzdxNDggMCAxMDIgNjF2LTU0ek0xMDYwIDg4djE5N3EwIDczIC05IDk5cS0xNyA1NiAtNzEgNTZxLTUwIDAgLTkzIC01NHYyMTdoLTg5di02NjNoODl2NDhxNDUgLTU1IDkzIC01NXE1NCAwIDcxIDU1cTkgMjcgOSAxMDB6TTEzOTggOTh2MTNoLTkxcTAgLTUxIC0yIC02MXEtNyAtMzYgLTQwIC0zNnEtNDYgMCAtNDYgNjl2ODdoMTc5djEwM3EwIDc5IC0yNyAxMTZxLTM5IDUxIC0xMDYgNTFxLTY4IDAgLTEwNyAtNTEKcS0yOCAtMzcgLTI4IC0xMTZ2LTE3M3EwIC03OSAyOSAtMTE2cTM5IC01MSAxMDggLTUxcTcyIDAgMTA4IDUzcTE4IDI3IDIxIDU0cTIgOSAyIDU4ek03OTAgMTAxMXYyMTBxMCA2OSAtNDMgNjl0LTQzIC02OXYtMjEwcTAgLTcwIDQzIC03MHQ0MyA3MHpNMTUwOSAyNjBxMCAtMjM0IC0yNiAtMzUwcS0xNCAtNTkgLTU4IC05OXQtMTAyIC00NnEtMTg0IC0yMSAtNTU1IC0yMXQtNTU1IDIxcS01OCA2IC0xMDIuNSA0NnQtNTcuNSA5OQpxLTI2IDExMiAtMjYgMzUwcTAgMjM0IDI2IDM1MHExNCA1OSA1OCA5OXQxMDMgNDdxMTgzIDIwIDU1NCAyMHQ1NTUgLTIwcTU4IC03IDEwMi41IC00N3Q1Ny41IC05OXEyNiAtMTEyIDI2IC0zNTB6TTUxMSAxNTM2aDEwMmwtMTIxIC0zOTl2LTI3MWgtMTAwdjI3MXEtMTQgNzQgLTYxIDIxMnEtMzcgMTAzIC02NSAxODdoMTA2bDcxIC0yNjN6TTg4MSAxMjAzdi0xNzVxMCAtODEgLTI4IC0xMThxLTM4IC01MSAtMTA2IC01MXEtNjcgMCAtMTA1IDUxCnEtMjggMzggLTI4IDExOHYxNzVxMCA4MCAyOCAxMTdxMzggNTEgMTA1IDUxcTY4IDAgMTA2IC01MXEyOCAtMzcgMjggLTExN3pNMTIxNiAxMzY1di00OTloLTkxdjU1cS01MyAtNjIgLTEwMyAtNjJxLTQ2IDAgLTU5IDM3cS04IDI0IC04IDc1djM5NGg5MXYtMzY3cTAgLTMzIDEgLTM1cTMgLTIyIDIxIC0yMnEyNyAwIDU3IDQzdjM4MWg5MXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ieGluZyIgdW5pY29kZT0iJiN4ZjE2ODsiIGhvcml6LWFkdi14PSIxNDA4IiAKZD0iTTU5NyA4NjlxLTEwIC0xOCAtMjU3IC00NTZxLTI3IC00NiAtNjUgLTQ2aC0yMzlxLTIxIDAgLTMxIDE3dDAgMzZsMjUzIDQ0OHExIDAgMCAxbC0xNjEgMjc5cS0xMiAyMiAtMSAzN3E5IDE1IDMyIDE1aDIzOXE0MCAwIDY2IC00NXpNMTQwMyAxNTExcTExIC0xNiAwIC0zN2wtNTI4IC05MzR2LTFsMzM2IC02MTVxMTEgLTIwIDEgLTM3cS0xMCAtMTUgLTMyIC0xNWgtMjM5cS00MiAwIC02NiA0NWwtMzM5IDYyMnExOCAzMiA1MzEgOTQyCnEyNSA0NSA2NCA0NWgyNDFxMjIgMCAzMSAtMTV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Inhpbmdfc2lnbiIgdW5pY29kZT0iJiN4ZjE2OTsiIApkPSJNNjg1IDc3MXEwIDEgLTEyNiAyMjJxLTIxIDM0IC01MiAzNGgtMTg0cS0xOCAwIC0yNiAtMTFxLTcgLTEyIDEgLTI5bDEyNSAtMjE2di0xbC0xOTYgLTM0NnEtOSAtMTQgMCAtMjhxOCAtMTMgMjQgLTEzaDE4NXEzMSAwIDUwIDM2ek0xMzA5IDEyNjhxLTcgMTIgLTI0IDEyaC0xODdxLTMwIDAgLTQ5IC0zNWwtNDExIC03MjlxMSAtMiAyNjIgLTQ4MXEyMCAtMzUgNTIgLTM1aDE4NHExOCAwIDI1IDEycTggMTMgLTEgMjhsLTI2MCA0NzZ2MQpsNDA5IDcyM3E4IDE2IDAgMjh6TTE1MzYgMTEyMHYtOTYwcTAgLTExOSAtODQuNSAtMjAzLjV0LTIwMy41IC04NC41aC05NjBxLTExOSAwIC0yMDMuNSA4NC41dC04NC41IDIwMy41djk2MHEwIDExOSA4NC41IDIwMy41dDIwMy41IDg0LjVoOTYwcTExOSAwIDIwMy41IC04NC41dDg0LjUgLTIwMy41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ5b3V0dWJlX3BsYXkiIHVuaWNvZGU9IiYjeGYxNmE7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik03MTEgNDA4bDQ4NCAyNTBsLTQ4NCAyNTN2LTUwM3pNODk2IDEyNzBxMTY4IDAgMzI0LjUgLTQuNXQyMjkuNSAtOS41bDczIC00cTEgMCAxNyAtMS41dDIzIC0zdDIzLjUgLTQuNXQyOC41IC04dDI4IC0xM3QzMSAtMTkuNXQyOSAtMjYuNXE2IC02IDE1LjUgLTE4LjV0MjkgLTU4LjV0MjYuNSAtMTAxcTggLTY0IDEyLjUgLTEzNi41dDUuNSAtMTEzLjV2LTQwdi0xMzZxMSAtMTQ1IC0xOCAtMjkwcS03IC01NSAtMjUgLTk5LjV0LTMyIC02MS41CmwtMTQgLTE3cS0xNCAtMTUgLTI5IC0yNi41dC0zMSAtMTl0LTI4IC0xMi41dC0yOC41IC04dC0yNCAtNC41dC0yMyAtM3QtMTYuNSAtMS41cS0yNTEgLTE5IC02MjcgLTE5cS0yMDcgMiAtMzU5LjUgNi41dC0yMDAuNSA3LjVsLTQ5IDRsLTM2IDRxLTM2IDUgLTU0LjUgMTB0LTUxIDIxdC01Ni41IDQxcS02IDYgLTE1LjUgMTguNXQtMjkgNTguNXQtMjYuNSAxMDFxLTggNjQgLTEyLjUgMTM2LjV0LTUuNSAxMTMuNXY0MHYxMzYKcS0xIDE0NSAxOCAyOTBxNyA1NSAyNSA5OS41dDMyIDYxLjVsMTQgMTdxMTQgMTUgMjkgMjYuNXQzMSAxOS41dDI4IDEzdDI4LjUgOHQyMy41IDQuNXQyMyAzdDE3IDEuNXEyNTEgMTggNjI3IDE4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkcm9wYm94IiB1bmljb2RlPSImI3hmMTZiOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNNDAyIDgyOWw0OTQgLTMwNWwtMzQyIC0yODVsLTQ5MCAzMTl6TTEzODggMjc0di0xMDhsLTQ5MCAtMjkzdi0xbC0xIDFsLTEgLTF2MWwtNDg5IDI5M3YxMDhsMTQ3IC05NmwzNDIgMjg0djJsMSAtMWwxIDF2LTJsMzQzIC0yODR6TTU1NCAxNDE4bDM0MiAtMjg1bC00OTQgLTMwNGwtMzM4IDI3MHpNMTM5MCA4MjlsMzM4IC0yNzFsLTQ4OSAtMzE5bC0zNDMgMjg1ek0xMjM5IDE0MThsNDg5IC0zMTlsLTMzOCAtMjcwbC00OTQgMzA0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzdGFja2V4Y2hhbmdlIiB1bmljb2RlPSImI3hmMTZjOyIgCmQ9Ik0xMjg5IC05NmgtMTExOHY0ODBoLTE2MHYtNjQwaDE0Mzh2NjQwaC0xNjB2LTQ4MHpNMzQ3IDQyOGwzMyAxNTdsNzgzIC0xNjVsLTMzIC0xNTZ6TTQ1MCA4MDJsNjcgMTQ2bDcyNSAtMzM5bC02NyAtMTQ1ek02NTEgMTE1OGwxMDIgMTIzbDYxNCAtNTEzbC0xMDIgLTEyM3pNMTA0OCAxNTM2bDQ3NyAtNjQxbC0xMjggLTk2bC00NzcgNjQxek0zMzAgNjV2MTU5aDgwMHYtMTU5aC04MDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Imluc3RhZ3JhbSIgdW5pY29kZT0iJiN4ZjE2ZDsiIApkPSJNMTAyNCA2NDBxMCAxMDYgLTc1IDE4MXQtMTgxIDc1dC0xODEgLTc1dC03NSAtMTgxdDc1IC0xODF0MTgxIC03NXQxODEgNzV0NzUgMTgxek0xMTYyIDY0MHEwIC0xNjQgLTExNSAtMjc5dC0yNzkgLTExNXQtMjc5IDExNXQtMTE1IDI3OXQxMTUgMjc5dDI3OSAxMTV0Mjc5IC0xMTV0MTE1IC0yNzl6TTEyNzAgMTA1MHEwIC0zOCAtMjcgLTY1dC02NSAtMjd0LTY1IDI3dC0yNyA2NXQyNyA2NXQ2NSAyN3Q2NSAtMjd0MjcgLTY1ek03NjggMTI3MApxLTcgMCAtNzYuNSAwLjV0LTEwNS41IDB0LTk2LjUgLTN0LTEwMyAtMTB0LTcxLjUgLTE4LjVxLTUwIC0yMCAtODggLTU4dC01OCAtODhxLTExIC0yOSAtMTguNSAtNzEuNXQtMTAgLTEwM3QtMyAtOTYuNXQwIC0xMDUuNXQwLjUgLTc2LjV0LTAuNSAtNzYuNXQwIC0xMDUuNXQzIC05Ni41dDEwIC0xMDN0MTguNSAtNzEuNXEyMCAtNTAgNTggLTg4dDg4IC01OHEyOSAtMTEgNzEuNSAtMTguNXQxMDMgLTEwdDk2LjUgLTN0MTA1LjUgMHQ3Ni41IDAuNQp0NzYuNSAtMC41dDEwNS41IDB0OTYuNSAzdDEwMyAxMHQ3MS41IDE4LjVxNTAgMjAgODggNTh0NTggODhxMTEgMjkgMTguNSA3MS41dDEwIDEwM3QzIDk2LjV0MCAxMDUuNXQtMC41IDc2LjV0MC41IDc2LjV0MCAxMDUuNXQtMyA5Ni41dC0xMCAxMDN0LTE4LjUgNzEuNXEtMjAgNTAgLTU4IDg4dC04OCA1OHEtMjkgMTEgLTcxLjUgMTguNXQtMTAzIDEwdC05Ni41IDN0LTEwNS41IDB0LTc2LjUgLTAuNXpNMTUzNiA2NDBxMCAtMjI5IC01IC0zMTcKcS0xMCAtMjA4IC0xMjQgLTMyMnQtMzIyIC0xMjRxLTg4IC01IC0zMTcgLTV0LTMxNyA1cS0yMDggMTAgLTMyMiAxMjR0LTEyNCAzMjJxLTUgODggLTUgMzE3dDUgMzE3cTEwIDIwOCAxMjQgMzIydDMyMiAxMjRxODggNSAzMTcgNXQzMTcgLTVxMjA4IC0xMCAzMjIgLTEyNHQxMjQgLTMyMnE1IC04OCA1IC0zMTd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImZsaWNrciIgdW5pY29kZT0iJiN4ZjE2ZTsiIApkPSJNMTI0OCAxNDA4cTExOSAwIDIwMy41IC04NC41dDg0LjUgLTIwMy41di05NjBxMCAtMTE5IC04NC41IC0yMDMuNXQtMjAzLjUgLTg0LjVoLTk2MHEtMTE5IDAgLTIwMy41IDg0LjV0LTg0LjUgMjAzLjV2OTYwcTAgMTE5IDg0LjUgMjAzLjV0MjAzLjUgODQuNWg5NjB6TTY5OCA2NDBxMCA4OCAtNjIgMTUwdC0xNTAgNjJ0LTE1MCAtNjJ0LTYyIC0xNTB0NjIgLTE1MHQxNTAgLTYydDE1MCA2MnQ2MiAxNTB6TTEyNjIgNjQwcTAgODggLTYyIDE1MAp0LTE1MCA2MnQtMTUwIC02MnQtNjIgLTE1MHQ2MiAtMTUwdDE1MCAtNjJ0MTUwIDYydDYyIDE1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYWRuIiB1bmljb2RlPSImI3hmMTcwOyIgCmQ9Ik03NjggOTE0bDIwMSAtMzA2aC00MDJ6TTExMzMgMzg0aDk0bC00NTkgNjkxbC00NTkgLTY5MWg5NGwxMDQgMTYwaDUyMnpNMTUzNiA2NDBxMCAtMjA5IC0xMDMgLTM4NS41dC0yNzkuNSAtMjc5LjV0LTM4NS41IC0xMDN0LTM4NS41IDEwM3QtMjc5LjUgMjc5LjV0LTEwMyAzODUuNXQxMDMgMzg1LjV0Mjc5LjUgMjc5LjV0Mzg1LjUgMTAzdDM4NS41IC0xMDN0Mjc5LjUgLTI3OS41dDEwMyAtMzg1LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImYxNzEiIHVuaWNvZGU9IiYjeGYxNzE7IiBob3Jpei1hZHYteD0iMTQwOCIgCmQ9Ik04MTUgNjc3cTggLTYzIC01MC41IC0xMDF0LTExMS41IC02cS0zOSAxNyAtNTMuNSA1OHQtMC41IDgydDUyIDU4cTM2IDE4IDcyLjUgMTJ0NjQgLTM1LjV0MjcuNSAtNjcuNXpNOTI2IDY5OHEtMTQgMTA3IC0xMTMgMTY0dC0xOTcgMTNxLTYzIC0yOCAtMTAwLjUgLTg4LjV0LTM0LjUgLTEyOS41cTQgLTkxIDc3LjUgLTE1NXQxNjUuNSAtNTZxOTEgOCAxNTIgODR0NTAgMTY4ek0xMTY1IDEyNDBxLTIwIDI3IC01NiA0NC41dC01OCAyMgp0LTcxIDEyLjVxLTI5MSA0NyAtNTY2IC0ycS00MyAtNyAtNjYgLTEydC01NSAtMjJ0LTUwIC00M3EzMCAtMjggNzYgLTQ1LjV0NzMuNSAtMjJ0ODcuNSAtMTEuNXEyMjggLTI5IDQ0OCAtMXE2MyA4IDg5LjUgMTJ0NzIuNSAyMS41dDc1IDQ2LjV6TTEyMjIgMjA1cS04IC0yNiAtMTUuNSAtNzYuNXQtMTQgLTg0dC0yOC41IC03MHQtNTggLTU2LjVxLTg2IC00OCAtMTg5LjUgLTcxLjV0LTIwMiAtMjJ0LTIwMS41IDE4LjVxLTQ2IDggLTgxLjUgMTgKdC03Ni41IDI3dC03MyA0My41dC01MiA2MS41cS0yNSA5NiAtNTcgMjkybDYgMTZsMTggOXEyMjMgLTE0OCA1MDYuNSAtMTQ4dDUwNy41IDE0OHEyMSAtNiAyNCAtMjN0LTUgLTQ1dC04IC0zN3pNMTQwMyAxMTY2cS0yNiAtMTY3IC0xMTEgLTY1NXEtNSAtMzAgLTI3IC01NnQtNDMuNSAtNDB0LTU0LjUgLTMxcS0yNTIgLTEyNiAtNjEwIC04OHEtMjQ4IDI3IC0zOTQgMTM5cS0xNSAxMiAtMjUuNSAyNi41dC0xNyAzNXQtOSAzNHQtNiAzOS41CnQtNS41IDM1cS05IDUwIC0yNi41IDE1MHQtMjggMTYxLjV0LTIzLjUgMTQ3LjV0LTIyIDE1OHEzIDI2IDE3LjUgNDguNXQzMS41IDM3LjV0NDUgMzB0NDYgMjIuNXQ0OCAxOC41cTEyNSA0NiAzMTMgNjRxMzc5IDM3IDY3NiAtNTBxMTU1IC00NiAyMTUgLTEyMnExNiAtMjAgMTYuNSAtNTF0LTUuNSAtNTR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImJpdGJ1Y2tldF9zaWduIiB1bmljb2RlPSImI3hmMTcyOyIgCmQ9Ik04NDggNjY2cTAgNDMgLTQxIDY2dC03NyAxcS00MyAtMjAgLTQyLjUgLTcyLjV0NDMuNSAtNzAuNXEzOSAtMjMgODEgNHQzNiA3MnpNOTI4IDY4MnE4IC02NiAtMzYgLTEyMXQtMTEwIC02MXQtMTE5IDQwdC01NiAxMTNxLTIgNDkgMjUuNSA5M3Q3Mi41IDY0cTcwIDMxIDE0MS41IC0xMHQ4MS41IC0xMTh6TTExMDAgMTA3M3EtMjAgLTIxIC01My41IC0zNHQtNTMgLTE2dC02My41IC04cS0xNTUgLTIwIC0zMjQgMHEtNDQgNiAtNjMgOS41CnQtNTIuNSAxNnQtNTQuNSAzMi41cTEzIDE5IDM2IDMxdDQwIDE1LjV0NDcgOC41cTE5OCAzNSA0MDggMXEzMyAtNSA1MSAtOC41dDQzIC0xNnQzOSAtMzEuNXpNMTE0MiAzMjdxMCA3IDUuNSAyNi41dDMgMzJ0LTE3LjUgMTYuNXEtMTYxIC0xMDYgLTM2NSAtMTA2dC0zNjYgMTA2bC0xMiAtNmwtNSAtMTJxMjYgLTE1NCA0MSAtMjEwcTQ3IC04MSAyMDQgLTEwOHEyNDkgLTQ2IDQyOCA1M3EzNCAxOSA0OSA1MS41dDIyLjUgODUuNXQxMi41IDcxegpNMTI3MiAxMDIwcTkgNTMgLTggNzVxLTQzIDU1IC0xNTUgODhxLTIxNiA2MyAtNDg3IDM2cS0xMzIgLTEyIC0yMjYgLTQ2cS0zOCAtMTUgLTU5LjUgLTI1dC00NyAtMzR0LTI5LjUgLTU0cTggLTY4IDE5IC0xMzh0MjkgLTE3MXQyNCAtMTM3cTEgLTUgNSAtMzF0NyAtMzZ0MTIgLTI3dDIyIC0yOHExMDUgLTgwIDI4NCAtMTAwcTI1OSAtMjggNDQwIDYzcTI0IDEzIDM5LjUgMjN0MzEgMjl0MTkuNSA0MHE0OCAyNjcgODAgNDczek0xNTM2IDExMjAKdi05NjBxMCAtMTE5IC04NC41IC0yMDMuNXQtMjAzLjUgLTg0LjVoLTk2MHEtMTE5IDAgLTIwMy41IDg0LjV0LTg0LjUgMjAzLjV2OTYwcTAgMTE5IDg0LjUgMjAzLjV0MjAzLjUgODQuNWg5NjBxMTE5IDAgMjAzLjUgLTg0LjV0ODQuNSAtMjAzLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InR1bWJsciIgdW5pY29kZT0iJiN4ZjE3MzsiIGhvcml6LWFkdi14PSIxMDI0IiAKZD0iTTk0NCAyMDdsODAgLTIzN3EtMjMgLTM1IC0xMTEgLTY2dC0xNzcgLTMycS0xMDQgLTIgLTE5MC41IDI2dC0xNDIuNSA3NHQtOTUgMTA2dC01NS41IDEyMHQtMTYuNSAxMTh2NTQ0aC0xNjh2MjE1cTcyIDI2IDEyOSA2OS41dDkxIDkwdDU4IDEwMnQzNCA5OXQxNSA4OC41cTEgNSA0LjUgOC41dDcuNSAzLjVoMjQ0di00MjRoMzMzdi0yNTJoLTMzNHYtNTE4cTAgLTMwIDYuNSAtNTZ0MjIuNSAtNTIuNXQ0OS41IC00MS41dDgxLjUgLTE0CnE3OCAyIDEzNCAyOXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idHVtYmxyX3NpZ24iIHVuaWNvZGU9IiYjeGYxNzQ7IiAKZD0iTTExMzYgNzVsLTYyIDE4M3EtNDQgLTIyIC0xMDMgLTIycS0zNiAtMSAtNjIgMTAuNXQtMzguNSAzMS41dC0xNy41IDQwLjV0LTUgNDMuNXYzOThoMjU3djE5NGgtMjU2djMyNmgtMTg4cS04IDAgLTkgLTEwcS01IC00NCAtMTcuNSAtODd0LTM5IC05NXQtNzcgLTk1dC0xMTguNSAtNjh2LTE2NWgxMzB2LTQxOHEwIC01NyAyMS41IC0xMTV0NjUgLTExMXQxMjEgLTg1LjV0MTc2LjUgLTMwLjVxNjkgMSAxMzYuNSAyNXQ4NS41IDUwegpNMTUzNiAxMTIwdi05NjBxMCAtMTE5IC04NC41IC0yMDMuNXQtMjAzLjUgLTg0LjVoLTk2MHEtMTE5IDAgLTIwMy41IDg0LjV0LTg0LjUgMjAzLjV2OTYwcTAgMTE5IDg0LjUgMjAzLjV0MjAzLjUgODQuNWg5NjBxMTE5IDAgMjAzLjUgLTg0LjV0ODQuNSAtMjAzLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImxvbmdfYXJyb3dfZG93biIgdW5pY29kZT0iJiN4ZjE3NTsiIGhvcml6LWFkdi14PSI3NjgiIApkPSJNNzY1IDIzN3E4IC0xOSAtNSAtMzVsLTM1MCAtMzg0cS0xMCAtMTAgLTIzIC0xMHEtMTQgMCAtMjQgMTBsLTM1NSAzODRxLTEzIDE2IC01IDM1cTkgMTkgMjkgMTloMjI0djEyNDhxMCAxNCA5IDIzdDIzIDloMTkycTE0IDAgMjMgLTl0OSAtMjN2LTEyNDhoMjI0cTIxIDAgMjkgLTE5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJsb25nX2Fycm93X3VwIiB1bmljb2RlPSImI3hmMTc2OyIgaG9yaXotYWR2LXg9Ijc2OCIgCmQ9Ik03NjUgMTA0M3EtOSAtMTkgLTI5IC0xOWgtMjI0di0xMjQ4cTAgLTE0IC05IC0yM3QtMjMgLTloLTE5MnEtMTQgMCAtMjMgOXQtOSAyM3YxMjQ4aC0yMjRxLTIxIDAgLTI5IDE5dDUgMzVsMzUwIDM4NHExMCAxMCAyMyAxMHExNCAwIDI0IC0xMGwzNTUgLTM4NHExMyAtMTYgNSAtMzV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImxvbmdfYXJyb3dfbGVmdCIgdW5pY29kZT0iJiN4ZjE3NzsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE3OTIgNzM2di0xOTJxMCAtMTQgLTkgLTIzdC0yMyAtOWgtMTI0OHYtMjI0cTAgLTIxIC0xOSAtMjl0LTM1IDVsLTM4NCAzNTBxLTEwIDEwIC0xMCAyM3EwIDE0IDEwIDI0bDM4NCAzNTRxMTYgMTQgMzUgNnExOSAtOSAxOSAtMjl2LTIyNGgxMjQ4cTE0IDAgMjMgLTl0OSAtMjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImxvbmdfYXJyb3dfcmlnaHQiIHVuaWNvZGU9IiYjeGYxNzg7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xNzI4IDY0M3EwIC0xNCAtMTAgLTI0bC0zODQgLTM1NHEtMTYgLTE0IC0zNSAtNnEtMTkgOSAtMTkgMjl2MjI0aC0xMjQ4cS0xNCAwIC0yMyA5dC05IDIzdjE5MnEwIDE0IDkgMjN0MjMgOWgxMjQ4djIyNHEwIDIxIDE5IDI5dDM1IC01bDM4NCAtMzUwcTEwIC0xMCAxMCAtMjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImFwcGxlIiB1bmljb2RlPSImI3hmMTc5OyIgaG9yaXotYWR2LXg9IjE0MDgiIApkPSJNMTM5MyAzMjFxLTM5IC0xMjUgLTEyMyAtMjUwcS0xMjkgLTE5NiAtMjU3IC0xOTZxLTQ5IDAgLTE0MCAzMnEtODYgMzIgLTE1MSAzMnEtNjEgMCAtMTQyIC0zM3EtODEgLTM0IC0xMzIgLTM0cS0xNTIgMCAtMzAxIDI1OXEtMTQ3IDI2MSAtMTQ3IDUwM3EwIDIyOCAxMTMgMzc0cTExMyAxNDQgMjg0IDE0NHE3MiAwIDE3NyAtMzBxMTA0IC0zMCAxMzggLTMwcTQ1IDAgMTQzIDM0cTEwMiAzNCAxNzMgMzRxMTE5IDAgMjEzIC02NQpxNTIgLTM2IDEwNCAtMTAwcS03OSAtNjcgLTExNCAtMTE4cS02NSAtOTQgLTY1IC0yMDdxMCAtMTI0IDY5IC0yMjN0MTU4IC0xMjZ6TTEwMTcgMTQ5NHEwIC02MSAtMjkgLTEzNnEtMzAgLTc1IC05MyAtMTM4cS01NCAtNTQgLTEwOCAtNzJxLTM3IC0xMSAtMTA0IC0xN3EzIDE0OSA3OCAyNTdxNzQgMTA3IDI1MCAxNDhxMSAtMyAyLjUgLTExdDIuNSAtMTFxMCAtNCAwLjUgLTEwdDAuNSAtMTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9IndpbmRvd3MiIHVuaWNvZGU9IiYjeGYxN2E7IiBob3Jpei1hZHYteD0iMTY2NCIgCmQ9Ik02ODIgNTMwdi02NTFsLTY4MiA5NHY1NTdoNjgyek02ODIgMTI3M3YtNjU5aC02ODJ2NTY1ek0xNjY0IDUzMHYtNzg2bC05MDcgMTI1djY2MWg5MDd6TTE2NjQgMTQwOHYtNzk0aC05MDd2NjY5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJhbmRyb2lkIiB1bmljb2RlPSImI3hmMTdiOyIgaG9yaXotYWR2LXg9IjE0MDgiIApkPSJNNDkzIDEwNTNxMTYgMCAyNy41IDExLjV0MTEuNSAyNy41dC0xMS41IDI3LjV0LTI3LjUgMTEuNXQtMjcgLTExLjV0LTExIC0yNy41dDExIC0yNy41dDI3IC0xMS41ek05MTUgMTA1M3ExNiAwIDI3IDExLjV0MTEgMjcuNXQtMTEgMjcuNXQtMjcgMTEuNXQtMjcuNSAtMTEuNXQtMTEuNSAtMjcuNXQxMS41IC0yNy41dDI3LjUgLTExLjV6TTEwMyA4NjlxNDIgMCA3MiAtMzB0MzAgLTcydi00MzBxMCAtNDMgLTI5LjUgLTczdC03Mi41IC0zMAp0LTczIDMwdC0zMCA3M3Y0MzBxMCA0MiAzMCA3MnQ3MyAzMHpNMTE2MyA4NTB2LTY2NnEwIC00NiAtMzIgLTc4dC03NyAtMzJoLTc1di0yMjdxMCAtNDMgLTMwIC03M3QtNzMgLTMwdC03MyAzMHQtMzAgNzN2MjI3aC0xMzh2LTIyN3EwIC00MyAtMzAgLTczdC03MyAtMzBxLTQyIDAgLTcyIDMwdC0zMCA3M2wtMSAyMjdoLTc0cS00NiAwIC03OCAzMnQtMzIgNzh2NjY2aDkxOHpNOTMxIDEyNTVxMTA3IC01NSAxNzEgLTE1My41dDY0IC0yMTUuNQpoLTkyNXEwIDExNyA2NCAyMTUuNXQxNzIgMTUzLjVsLTcxIDEzMXEtNyAxMyA1IDIwcTEzIDYgMjAgLTZsNzIgLTEzMnE5NSA0MiAyMDEgNDJ0MjAxIC00Mmw3MiAxMzJxNyAxMiAyMCA2cTEyIC03IDUgLTIwek0xNDA4IDc2N3YtNDMwcTAgLTQzIC0zMCAtNzN0LTczIC0zMHEtNDIgMCAtNzIgMzB0LTMwIDczdjQzMHEwIDQzIDMwIDcyLjV0NzIgMjkuNXE0MyAwIDczIC0yOS41dDMwIC03Mi41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJsaW51eCIgdW5pY29kZT0iJiN4ZjE3YzsiIApkPSJNNjYzIDExMjVxLTExIC0xIC0xNS41IC0xMC41dC04LjUgLTkuNXEtNSAtMSAtNSA1cTAgMTIgMTkgMTVoMTB6TTc1MCAxMTExcS00IC0xIC0xMS41IDYuNXQtMTcuNSA0LjVxMjQgMTEgMzIgLTJxMyAtNiAtMyAtOXpNMzk5IDY4NHEtNCAxIC02IC0zdC00LjUgLTEyLjV0LTUuNSAtMTMuNXQtMTAgLTEzcS0xMCAtMTEgLTEgLTEycTQgLTEgMTIuNSA3dDEyLjUgMThxMSAzIDIgN3QyIDZ0MS41IDQuNXQwLjUgNHYzdC0xIDIuNXQtMyAyegpNMTI1NCAzMjVxMCAxOCAtNTUgNDJxNCAxNSA3LjUgMjcuNXQ1IDI2dDMgMjEuNXQwLjUgMjIuNXQtMSAxOS41dC0zLjUgMjJ0LTQgMjAuNXQtNSAyNXQtNS41IDI2LjVxLTEwIDQ4IC00NyAxMDN0LTcyIDc1cTI0IC0yMCA1NyAtODNxODcgLTE2MiA1NCAtMjc4cS0xMSAtNDAgLTUwIC00MnEtMzEgLTQgLTM4LjUgMTguNXQtOCA4My41dC0xMS41IDEwN3EtOSAzOSAtMTkuNSA2OXQtMTkuNSA0NS41dC0xNS41IDI0LjV0LTEzIDE1dC03LjUgNwpxLTE0IDYyIC0zMSAxMDN0LTI5LjUgNTZ0LTIzLjUgMzN0LTE1IDQwcS00IDIxIDYgNTMuNXQ0LjUgNDkuNXQtNDQuNSAyNXEtMTUgMyAtNDQuNSAxOHQtMzUuNSAxNnEtOCAxIC0xMSAyNnQ4IDUxdDM2IDI3cTM3IDMgNTEgLTMwdDQgLTU4cS0xMSAtMTkgLTIgLTI2LjV0MzAgLTAuNXExMyA0IDEzIDM2djM3cS01IDMwIC0xMy41IDUwdC0yMSAzMC41dC0yMy41IDE1dC0yNyA3LjVxLTEwNyAtOCAtODkgLTEzNHEwIC0xNSAtMSAtMTUKcS05IDkgLTI5LjUgMTAuNXQtMzMgLTAuNXQtMTUuNSA1cTEgNTcgLTE2IDkwdC00NSAzNHEtMjcgMSAtNDEuNSAtMjcuNXQtMTYuNSAtNTkuNXEtMSAtMTUgMy41IC0zN3QxMyAtMzcuNXQxNS41IC0xMy41cTEwIDMgMTYgMTRxNCA5IC03IDhxLTcgMCAtMTUuNSAxNC41dC05LjUgMzMuNXEtMSAyMiA5IDM3dDM0IDE0cTE3IDAgMjcgLTIxdDkuNSAtMzl0LTEuNSAtMjJxLTIyIC0xNSAtMzEgLTI5cS04IC0xMiAtMjcuNSAtMjMuNQp0LTIwLjUgLTEyLjVxLTEzIC0xNCAtMTUuNSAtMjd0Ny41IC0xOHExNCAtOCAyNSAtMTkuNXQxNiAtMTl0MTguNSAtMTN0MzUuNSAtNi41cTQ3IC0yIDEwMiAxNXEyIDEgMjMgN3QzNC41IDEwLjV0MjkuNSAxM3QyMSAxNy41cTkgMTQgMjAgOHE1IC0zIDYuNSAtOC41dC0zIC0xMnQtMTYuNSAtOS41cS0yMCAtNiAtNTYuNSAtMjEuNXQtNDUuNSAtMTkuNXEtNDQgLTE5IC03MCAtMjNxLTI1IC01IC03OSAycS0xMCAyIC05IC0ydDE3IC0xOQpxMjUgLTIzIDY3IC0yMnExNyAxIDM2IDd0MzYgMTR0MzMuNSAxNy41dDMwIDE3dDI0LjUgMTJ0MTcuNSAyLjV0OC41IC0xMXEwIC0yIC0xIC00LjV0LTQgLTV0LTYgLTQuNXQtOC41IC01dC05IC00LjV0LTEwIC01dC05LjUgLTQuNXEtMjggLTE0IC02Ny41IC00NHQtNjYuNSAtNDN0LTQ5IC0xcS0yMSAxMSAtNjMgNzNxLTIyIDMxIC0yNSAyMnEtMSAtMyAtMSAtMTBxMCAtMjUgLTE1IC01Ni41dC0yOS41IC01NS41dC0yMSAtNTh0MTEuNSAtNjMKcS0yMyAtNiAtNjIuNSAtOTB0LTQ3LjUgLTE0MXEtMiAtMTggLTEuNSAtNjl0LTUuNSAtNTlxLTggLTI0IC0yOSAtM3EtMzIgMzEgLTM2IDk0cS0yIDI4IDQgNTZxNCAxOSAtMSAxOHEtMiAtMSAtNCAtNXEtMzYgLTY1IDEwIC0xNjZxNSAtMTIgMjUgLTI4dDI0IC0yMHEyMCAtMjMgMTA0IC05MC41dDkzIC03Ni41cTE2IC0xNSAxNy41IC0zOHQtMTQgLTQzdC00NS41IC0yM3E4IC0xNSAyOSAtNDQuNXQyOCAtNTR0NyAtNzAuNXE0NiAyNCA3IDkyCnEtNCA4IC0xMC41IDE2dC05LjUgMTJ0LTIgNnEzIDUgMTMgOS41dDIwIC0yLjVxNDYgLTUyIDE2NiAtMzZxMTMzIDE1IDE3NyA4N3EyMyAzOCAzNCAzMHExMiAtNiAxMCAtNTJxLTEgLTI1IC0yMyAtOTJxLTkgLTIzIC02IC0zNy41dDI0IC0xNS41cTMgMTkgMTQuNSA3N3QxMy41IDkwcTIgMjEgLTYuNSA3My41dC03LjUgOTd0MjMgNzAuNXExNSAxOCA1MSAxOHExIDM3IDM0LjUgNTN0NzIuNSAxMC41dDYwIC0yMi41ek02MjYgMTE1MgpxMyAxNyAtMi41IDMwdC0xMS41IDE1cS05IDIgLTkgLTdxMiAtNSA1IC02cTEwIDAgNyAtMTVxLTMgLTIwIDggLTIwcTMgMCAzIDN6TTEwNDUgOTU1cS0yIDggLTYuNSAxMS41dC0xMyA1dC0xNC41IDUuNXEtNSAzIC05LjUgOHQtNyA4dC01LjUgNi41dC00IDR0LTQgLTEuNXEtMTQgLTE2IDcgLTQzLjV0MzkgLTMxLjVxOSAtMSAxNC41IDh0My41IDIwek04NjcgMTE2OHEwIDExIC01IDE5LjV0LTExIDEyLjV0LTkgM3EtNiAwIC04IC0ydDAgLTQKdDUgLTNxMTQgLTQgMTggLTMxcTAgLTMgOCAycTIgMiAyIDN6TTkyMSAxNDAxcTAgMiAtMi41IDV0LTkgN3QtOS41IDZxLTE1IDE1IC0yNCAxNXEtOSAtMSAtMTEuNSAtNy41dC0xIC0xM3QtMC41IC0xMi41cS0xIC00IC02IC0xMC41dC02IC05dDMgLTguNXE0IC0zIDggMHQxMSA5dDE1IDlxMSAxIDkgMXQxNSAydDkgN3pNMTQ4NiA2MHEyMCAtMTIgMzEgLTI0LjV0MTIgLTI0dC0yLjUgLTIyLjV0LTE1LjUgLTIydC0yMy41IC0xOS41CnQtMzAgLTE4LjV0LTMxLjUgLTE2LjV0LTMyIC0xNS41dC0yNyAtMTNxLTM4IC0xOSAtODUuNSAtNTZ0LTc1LjUgLTY0cS0xNyAtMTYgLTY4IC0xOS41dC04OSAxNC41cS0xOCA5IC0yOS41IDIzLjV0LTE2LjUgMjUuNXQtMjIgMTkuNXQtNDcgOS41cS00NCAxIC0xMzAgMXEtMTkgMCAtNTcgLTEuNXQtNTggLTIuNXEtNDQgLTEgLTc5LjUgLTE1dC01My41IC0zMHQtNDMuNSAtMjguNXQtNTMuNSAtMTEuNXEtMjkgMSAtMTExIDMxdC0xNDYgNDMKcS0xOSA0IC01MSA5LjV0LTUwIDl0LTM5LjUgOS41dC0zMy41IDE0LjV0LTE3IDE5LjVxLTEwIDIzIDcgNjYuNXQxOCA1NC41cTEgMTYgLTQgNDB0LTEwIDQyLjV0LTQuNSAzNi41dDEwLjUgMjdxMTQgMTIgNTcgMTR0NjAgMTJxMzAgMTggNDIgMzV0MTIgNTFxMjEgLTczIC0zMiAtMTA2cS0zMiAtMjAgLTgzIC0xNXEtMzQgMyAtNDMgLTEwcS0xMyAtMTUgNSAtNTdxMiAtNiA4IC0xOHQ4LjUgLTE4dDQuNSAtMTd0MSAtMjJxMCAtMTUgLTE3IC00OQp0LTE0IC00OHEzIC0xNyAzNyAtMjZxMjAgLTYgODQuNSAtMTguNXQ5OS41IC0yMC41cTI0IC02IDc0IC0yMnQ4Mi41IC0yM3Q1NS41IC00cTQzIDYgNjQuNSAyOHQyMyA0OHQtNy41IDU4LjV0LTE5IDUydC0yMCAzNi41cS0xMjEgMTkwIC0xNjkgMjQycS02OCA3NCAtMTEzIDQwcS0xMSAtOSAtMTUgMTVxLTMgMTYgLTIgMzhxMSAyOSAxMCA1MnQyNCA0N3QyMiA0MnE4IDIxIDI2LjUgNzJ0MjkuNSA3OHQzMCA2MXQzOSA1NApxMTEwIDE0MyAxMjQgMTk1cS0xMiAxMTIgLTE2IDMxMHEtMiA5MCAyNCAxNTEuNXQxMDYgMTA0LjVxMzkgMjEgMTA0IDIxcTUzIDEgMTA2IC0xMy41dDg5IC00MS41cTU3IC00MiA5MS41IC0xMjEuNXQyOS41IC0xNDcuNXEtNSAtOTUgMzAgLTIxNHEzNCAtMTEzIDEzMyAtMjE4cTU1IC01OSA5OS41IC0xNjN0NTkuNSAtMTkxcTggLTQ5IDUgLTg0LjV0LTEyIC01NS41dC0yMCAtMjJxLTEwIC0yIC0yMy41IC0xOXQtMjcgLTM1LjUKdC00MC41IC0zMy41dC02MSAtMTRxLTE4IDEgLTMxLjUgNXQtMjIuNSAxMy41dC0xMy41IDE1LjV0LTExLjUgMjAuNXQtOSAxOS41cS0yMiAzNyAtNDEgMzB0LTI4IC00OXQ3IC05N3EyMCAtNzAgMSAtMTk1cS0xMCAtNjUgMTggLTEwMC41dDczIC0zM3Q4NSAzNS41cTU5IDQ5IDg5LjUgNjYuNXQxMDMuNSA0Mi41cTUzIDE4IDc3IDM2LjV0MTguNSAzNC41dC0yNSAyOC41dC01MS41IDIzLjVxLTMzIDExIC00OS41IDQ4dC0xNSA3Mi41CnQxNS41IDQ3LjVxMSAtMzEgOCAtNTYuNXQxNC41IC00MC41dDIwLjUgLTI4LjV0MjEgLTE5dDIxLjUgLTEzdDE2LjUgLTkuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZHJpYmJsZSIgdW5pY29kZT0iJiN4ZjE3ZDsiIApkPSJNMTAyNCAzNnEtNDIgMjQxIC0xNDAgNDk4aC0ybC0yIC0xcS0xNiAtNiAtNDMgLTE2LjV0LTEwMSAtNDl0LTEzNyAtODJ0LTEzMSAtMTE0LjV0LTEwMyAtMTQ4bC0xNSAxMXExODQgLTE1MCA0MTggLTE1MHExMzIgMCAyNTYgNTJ6TTgzOSA2NDNxLTIxIDQ5IC01MyAxMTFxLTMxMSAtOTMgLTY3MyAtOTNxLTEgLTcgLTEgLTIxcTAgLTEyNCA0NCAtMjM2LjV0MTI0IC0yMDEuNXE1MCA4OSAxMjMuNSAxNjYuNXQxNDIuNSAxMjQuNXQxMzAuNSA4MQp0OTkuNSA0OGwzNyAxM3E0IDEgMTMgMy41dDEzIDQuNXpNNzMyIDg1NXEtMTIwIDIxMyAtMjQ0IDM3OHEtMTM4IC02NSAtMjM0IC0xODZ0LTEyOCAtMjcycTMwMiAwIDYwNiA4MHpNMTQxNiA1MzZxLTIxMCA2MCAtNDA5IDI5cTg3IC0yMzkgMTI4IC00NjlxMTExIDc1IDE4NSAxODkuNXQ5NiAyNTAuNXpNNjExIDEyNzdxLTEgMCAtMiAtMXExIDEgMiAxek0xMjAxIDExMzJxLTE4NSAxNjQgLTQzMyAxNjRxLTc2IDAgLTE1NSAtMTkKcTEzMSAtMTcwIDI0NiAtMzgycTY5IDI2IDEzMCA2MC41dDk2LjUgNjEuNXQ2NS41IDU3dDM3LjUgNDAuNXpNMTQyNCA2NDdxLTMgMjMyIC0xNDkgNDEwbC0xIC0xcS05IC0xMiAtMTkgLTI0LjV0LTQzLjUgLTQ0LjV0LTcxIC02MC41dC0xMDAgLTY1dC0xMzEuNSAtNjQuNXEyNSAtNTMgNDQgLTk1cTIgLTUgNi41IC0xN3Q3LjUgLTE3cTM2IDUgNzQuNSA3dDczLjUgMnQ2OSAtMS41dDY0IC00dDU2LjUgLTUuNXQ0OCAtNi41dDM2LjUgLTYKdDI1IC00LjV6TTE1MzYgNjQwcTAgLTIwOSAtMTAzIC0zODUuNXQtMjc5LjUgLTI3OS41dC0zODUuNSAtMTAzdC0zODUuNSAxMDN0LTI3OS41IDI3OS41dC0xMDMgMzg1LjV0MTAzIDM4NS41dDI3OS41IDI3OS41dDM4NS41IDEwM3QzODUuNSAtMTAzdDI3OS41IC0yNzkuNXQxMDMgLTM4NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJza3lwZSIgdW5pY29kZT0iJiN4ZjE3ZTsiIApkPSJNMTE3MyA0NzNxMCA1MCAtMTkuNSA5MS41dC00OC41IDY4LjV0LTczIDQ5dC04Mi41IDM0dC04Ny41IDIzbC0xMDQgMjRxLTMwIDcgLTQ0IDEwLjV0LTM1IDExLjV0LTMwIDE2dC0xNi41IDIxdC03LjUgMzBxMCA3NyAxNDQgNzdxNDMgMCA3NyAtMTJ0NTQgLTI4LjV0MzggLTMzLjV0NDAgLTI5dDQ4IC0xMnE0NyAwIDc1LjUgMzJ0MjguNSA3N3EwIDU1IC01NiA5OS41dC0xNDIgNjcuNXQtMTgyIDIzcS02OCAwIC0xMzIgLTE1LjUKdC0xMTkuNSAtNDd0LTg5IC04N3QtMzMuNSAtMTI4LjVxMCAtNjEgMTkgLTEwNi41dDU2IC03NS41dDgwIC00OC41dDEwMyAtMzIuNWwxNDYgLTM2cTkwIC0yMiAxMTIgLTM2cTMyIC0yMCAzMiAtNjBxMCAtMzkgLTQwIC02NC41dC0xMDUgLTI1LjVxLTUxIDAgLTkxLjUgMTZ0LTY1IDM4LjV0LTQ1LjUgNDV0LTQ2IDM4LjV0LTU0IDE2cS01MCAwIC03NS41IC0zMHQtMjUuNSAtNzVxMCAtOTIgMTIyIC0xNTcuNXQyOTEgLTY1LjUKcTczIDAgMTQwIDE4LjV0MTIyLjUgNTMuNXQ4OC41IDkzLjV0MzMgMTMxLjV6TTE1MzYgMjU2cTAgLTE1OSAtMTEyLjUgLTI3MS41dC0yNzEuNSAtMTEyLjVxLTEzMCAwIC0yMzQgODBxLTc3IC0xNiAtMTUwIC0xNnEtMTQzIDAgLTI3My41IDU1LjV0LTIyNSAxNTB0LTE1MCAyMjV0LTU1LjUgMjczLjVxMCA3MyAxNiAxNTBxLTgwIDEwNCAtODAgMjM0cTAgMTU5IDExMi41IDI3MS41dDI3MS41IDExMi41cTEzMCAwIDIzNCAtODAKcTc3IDE2IDE1MCAxNnExNDMgMCAyNzMuNSAtNTUuNXQyMjUgLTE1MHQxNTAgLTIyNXQ1NS41IC0yNzMuNXEwIC03MyAtMTYgLTE1MHE4MCAtMTA0IDgwIC0yMzR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImZvdXJzcXVhcmUiIHVuaWNvZGU9IiYjeGYxODA7IiBob3Jpei1hZHYteD0iMTI4MCIgCmQ9Ik0xMDAwIDExMDJsMzcgMTk0cTUgMjMgLTkgNDB0LTM1IDE3aC03MTJxLTIzIDAgLTM4LjUgLTE3dC0xNS41IC0zN3YtMTEwMXEwIC03IDYgLTFsMjkxIDM1MnEyMyAyNiAzOCAzMy41dDQ4IDcuNWgyMzlxMjIgMCAzNyAxNC41dDE4IDI5LjVxMjQgMTMwIDM3IDE5MXE0IDIxIC0xMS41IDQwdC0zNi41IDE5aC0yOTRxLTI5IDAgLTQ4IDE5dC0xOSA0OHY0MnEwIDI5IDE5IDQ3LjV0NDggMTguNWgzNDZxMTggMCAzNSAxMy41dDIwIDI5LjV6Ck0xMjI3IDEzMjRxLTE1IC03MyAtNTMuNSAtMjY2LjV0LTY5LjUgLTM1MHQtMzUgLTE3My41cS02IC0yMiAtOSAtMzIuNXQtMTQgLTMyLjV0LTI0LjUgLTMzdC0zOC41IC0yMXQtNTggLTEwaC0yNzFxLTEzIDAgLTIyIC0xMHEtOCAtOSAtNDI2IC00OTRxLTIyIC0yNSAtNTguNSAtMjguNXQtNDguNSA1LjVxLTU1IDIyIC01NSA5OHYxNDEwcTAgNTUgMzggMTAyLjV0MTIwIDQ3LjVoODg4cTk1IDAgMTI3IC01M3QxMCAtMTU5ek0xMjI3IDEzMjQKbC0xNTggLTc5MHE0IDE3IDM1IDE3My41dDY5LjUgMzUwdDUzLjUgMjY2LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InRyZWxsbyIgdW5pY29kZT0iJiN4ZjE4MTsiIApkPSJNNzA0IDE5MnYxMDI0cTAgMTQgLTkgMjN0LTIzIDloLTQ4MHEtMTQgMCAtMjMgLTl0LTkgLTIzdi0xMDI0cTAgLTE0IDkgLTIzdDIzIC05aDQ4MHExNCAwIDIzIDl0OSAyM3pNMTM3NiA1NzZ2NjQwcTAgMTQgLTkgMjN0LTIzIDloLTQ4MHEtMTQgMCAtMjMgLTl0LTkgLTIzdi02NDBxMCAtMTQgOSAtMjN0MjMgLTloNDgwcTE0IDAgMjMgOXQ5IDIzek0xNTM2IDEzNDR2LTE0MDhxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0xNDA4CnEtMjYgMCAtNDUgMTl0LTE5IDQ1djE0MDhxMCAyNiAxOSA0NXQ0NSAxOWgxNDA4cTI2IDAgNDUgLTE5dDE5IC00NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZmVtYWxlIiB1bmljb2RlPSImI3hmMTgyOyIgaG9yaXotYWR2LXg9IjEyODAiIApkPSJNMTI4MCA0ODBxMCAtNDAgLTI4IC02OHQtNjggLTI4cS01MSAwIC04MCA0M2wtMjI3IDM0MWgtNDV2LTEzMmwyNDcgLTQxMXE5IC0xNSA5IC0zM3EwIC0yNiAtMTkgLTQ1dC00NSAtMTloLTE5MnYtMjcycTAgLTQ2IC0zMyAtNzl0LTc5IC0zM2gtMTYwcS00NiAwIC03OSAzM3QtMzMgNzl2MjcyaC0xOTJxLTI2IDAgLTQ1IDE5dC0xOSA0NXEwIDE4IDkgMzNsMjQ3IDQxMXYxMzJoLTQ1bC0yMjcgLTM0MXEtMjkgLTQzIC04MCAtNDMKcS00MCAwIC02OCAyOHQtMjggNjhxMCAyOSAxNiA1M2wyNTYgMzg0cTczIDEwNyAxNzYgMTA3aDM4NHExMDMgMCAxNzYgLTEwN2wyNTYgLTM4NHExNiAtMjQgMTYgLTUzek04NjQgMTI4MHEwIC05MyAtNjUuNSAtMTU4LjV0LTE1OC41IC02NS41dC0xNTguNSA2NS41dC02NS41IDE1OC41dDY1LjUgMTU4LjV0MTU4LjUgNjUuNXQxNTguNSAtNjUuNXQ2NS41IC0xNTguNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ibWFsZSIgdW5pY29kZT0iJiN4ZjE4MzsiIGhvcml6LWFkdi14PSIxMDI0IiAKZD0iTTEwMjQgODMydi00MTZxMCAtNDAgLTI4IC02OHQtNjggLTI4dC02OCAyOHQtMjggNjh2MzUyaC02NHYtOTEycTAgLTQ2IC0zMyAtNzl0LTc5IC0zM3QtNzkgMzN0LTMzIDc5djQ2NGgtNjR2LTQ2NHEwIC00NiAtMzMgLTc5dC03OSAtMzN0LTc5IDMzdC0zMyA3OXY5MTJoLTY0di0zNTJxMCAtNDAgLTI4IC02OHQtNjggLTI4dC02OCAyOHQtMjggNjh2NDE2cTAgODAgNTYgMTM2dDEzNiA1Nmg2NDBxODAgMCAxMzYgLTU2dDU2IC0xMzZ6Ck03MzYgMTI4MHEwIC05MyAtNjUuNSAtMTU4LjV0LTE1OC41IC02NS41dC0xNTguNSA2NS41dC02NS41IDE1OC41dDY1LjUgMTU4LjV0MTU4LjUgNjUuNXQxNTguNSAtNjUuNXQ2NS41IC0xNTguNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZ2l0dGlwIiB1bmljb2RlPSImI3hmMTg0OyIgCmQ9Ik03NzMgMjM0bDM1MCA0NzNxMTYgMjIgMjQuNSA1OXQtNiA4NXQtNjEuNSA3OXEtNDAgMjYgLTgzIDI1LjV0LTczLjUgLTE3LjV0LTU0LjUgLTQ1cS0zNiAtNDAgLTk2IC00MHEtNTkgMCAtOTUgNDBxLTI0IDI4IC01NC41IDQ1dC03My41IDE3LjV0LTg0IC0yNS41cS00NiAtMzEgLTYwLjUgLTc5dC02IC04NXQyNC41IC01OXpNMTUzNiA2NDBxMCAtMjA5IC0xMDMgLTM4NS41dC0yNzkuNSAtMjc5LjV0LTM4NS41IC0xMDN0LTM4NS41IDEwMwp0LTI3OS41IDI3OS41dC0xMDMgMzg1LjV0MTAzIDM4NS41dDI3OS41IDI3OS41dDM4NS41IDEwM3QzODUuNSAtMTAzdDI3OS41IC0yNzkuNXQxMDMgLTM4NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJzdW4iIHVuaWNvZGU9IiYjeGYxODU7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xNDcyIDY0MHEwIDExNyAtNDUuNSAyMjMuNXQtMTIzIDE4NHQtMTg0IDEyM3QtMjIzLjUgNDUuNXQtMjIzLjUgLTQ1LjV0LTE4NCAtMTIzdC0xMjMgLTE4NHQtNDUuNSAtMjIzLjV0NDUuNSAtMjIzLjV0MTIzIC0xODR0MTg0IC0xMjN0MjIzLjUgLTQ1LjV0MjIzLjUgNDUuNXQxODQgMTIzdDEyMyAxODR0NDUuNSAyMjMuNXpNMTc0OCAzNjNxLTQgLTE1IC0yMCAtMjBsLTI5MiAtOTZ2LTMwNnEwIC0xNiAtMTMgLTI2cS0xNSAtMTAgLTI5IC00CmwtMjkyIDk0bC0xODAgLTI0OHEtMTAgLTEzIC0yNiAtMTN0LTI2IDEzbC0xODAgMjQ4bC0yOTIgLTk0cS0xNCAtNiAtMjkgNHEtMTMgMTAgLTEzIDI2djMwNmwtMjkyIDk2cS0xNiA1IC0yMCAyMHEtNSAxNyA0IDI5bDE4MCAyNDhsLTE4MCAyNDhxLTkgMTMgLTQgMjlxNCAxNSAyMCAyMGwyOTIgOTZ2MzA2cTAgMTYgMTMgMjZxMTUgMTAgMjkgNGwyOTIgLTk0bDE4MCAyNDhxOSAxMiAyNiAxMnQyNiAtMTJsMTgwIC0yNDhsMjkyIDk0CnExNCA2IDI5IC00cTEzIC0xMCAxMyAtMjZ2LTMwNmwyOTIgLTk2cTE2IC01IDIwIC0yMHE1IC0xNiAtNCAtMjlsLTE4MCAtMjQ4bDE4MCAtMjQ4cTkgLTEyIDQgLTI5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfMzY2IiB1bmljb2RlPSImI3hmMTg2OyIgCmQ9Ik0xMjYyIDIzM3EtNTQgLTkgLTExMCAtOXEtMTgyIDAgLTMzNyA5MHQtMjQ1IDI0NXQtOTAgMzM3cTAgMTkyIDEwNCAzNTdxLTIwMSAtNjAgLTMyOC41IC0yMjl0LTEyNy41IC0zODRxMCAtMTMwIDUxIC0yNDguNXQxMzYuNSAtMjA0dDIwNCAtMTM2LjV0MjQ4LjUgLTUxcTE0NCAwIDI3My41IDYxLjV0MjIwLjUgMTcxLjV6TTE0NjUgMzE4cS05NCAtMjAzIC0yODMuNSAtMzI0LjV0LTQxMy41IC0xMjEuNXEtMTU2IDAgLTI5OCA2MQp0LTI0NSAxNjR0LTE2NCAyNDV0LTYxIDI5OHEwIDE1MyA1Ny41IDI5Mi41dDE1NiAyNDEuNXQyMzUuNSAxNjQuNXQyOTAgNjguNXE0NCAyIDYxIC0zOXExOCAtNDEgLTE1IC03MnEtODYgLTc4IC0xMzEuNSAtMTgxLjV0LTQ1LjUgLTIxOC41cTAgLTE0OCA3MyAtMjczdDE5OCAtMTk4dDI3MyAtNzNxMTE4IDAgMjI4IDUxcTQxIDE4IDcyIC0xM3ExNCAtMTQgMTcuNSAtMzR0LTQuNSAtMzh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImFyY2hpdmUiIHVuaWNvZGU9IiYjeGYxODc7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xMDg4IDcwNHEwIDI2IC0xOSA0NXQtNDUgMTloLTI1NnEtMjYgMCAtNDUgLTE5dC0xOSAtNDV0MTkgLTQ1dDQ1IC0xOWgyNTZxMjYgMCA0NSAxOXQxOSA0NXpNMTY2NCA4OTZ2LTk2MHEwIC0yNiAtMTkgLTQ1dC00NSAtMTloLTE0MDhxLTI2IDAgLTQ1IDE5dC0xOSA0NXY5NjBxMCAyNiAxOSA0NXQ0NSAxOWgxNDA4cTI2IDAgNDUgLTE5dDE5IC00NXpNMTcyOCAxMzQ0di0yNTZxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0xNTM2CnEtMjYgMCAtNDUgMTl0LTE5IDQ1djI1NnEwIDI2IDE5IDQ1dDQ1IDE5aDE1MzZxMjYgMCA0NSAtMTl0MTkgLTQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJidWciIHVuaWNvZGU9IiYjeGYxODg7IiBob3Jpei1hZHYteD0iMTY2NCIgCmQ9Ik0xNjMyIDU3NnEwIC0yNiAtMTkgLTQ1dC00NSAtMTloLTIyNHEwIC0xNzEgLTY3IC0yOTBsMjA4IC0yMDlxMTkgLTE5IDE5IC00NXQtMTkgLTQ1cS0xOCAtMTkgLTQ1IC0xOXQtNDUgMTlsLTE5OCAxOTdxLTUgLTUgLTE1IC0xM3QtNDIgLTI4LjV0LTY1IC0zNi41dC04MiAtMjl0LTk3IC0xM3Y4OTZoLTEyOHYtODk2cS01MSAwIC0xMDEuNSAxMy41dC04NyAzM3QtNjYgMzl0LTQzLjUgMzIuNWwtMTUgMTRsLTE4MyAtMjA3CnEtMjAgLTIxIC00OCAtMjFxLTI0IDAgLTQzIDE2cS0xOSAxOCAtMjAuNSA0NC41dDE1LjUgNDYuNWwyMDIgMjI3cS01OCAxMTQgLTU4IDI3NGgtMjI0cS0yNiAwIC00NSAxOXQtMTkgNDV0MTkgNDV0NDUgMTloMjI0djI5NGwtMTczIDE3M3EtMTkgMTkgLTE5IDQ1dDE5IDQ1dDQ1IDE5dDQ1IC0xOWwxNzMgLTE3M2g4NDRsMTczIDE3M3ExOSAxOSA0NSAxOXQ0NSAtMTl0MTkgLTQ1dC0xOSAtNDVsLTE3MyAtMTczdi0yOTRoMjI0cTI2IDAgNDUgLTE5CnQxOSAtNDV6TTExNTIgMTE1MmgtNjQwcTAgMTMzIDkzLjUgMjI2LjV0MjI2LjUgOTMuNXQyMjYuNSAtOTMuNXQ5My41IC0yMjYuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idmsiIHVuaWNvZGU9IiYjeGYxODk7IiBob3Jpei1hZHYteD0iMTkyMCIgCmQ9Ik0xOTE3IDEwMTZxMjMgLTY0IC0xNTAgLTI5NHEtMjQgLTMyIC02NSAtODVxLTQwIC01MSAtNTUgLTcydC0zMC41IC00OS41dC0xMiAtNDJ0MTMgLTM0LjV0MzIuNSAtNDN0NTcgLTUzcTQgLTIgNSAtNHExNDEgLTEzMSAxOTEgLTIyMXEzIC01IDYuNSAtMTIuNXQ3IC0yNi41dC0wLjUgLTM0dC0yNSAtMjcuNXQtNTkgLTEyLjVsLTI1NiAtNHEtMjQgLTUgLTU2IDV0LTUyIDIybC0yMCAxMnEtMzAgMjEgLTcwIDY0dC02OC41IDc3LjV0LTYxIDU4CnQtNTYuNSAxNS41cS0zIC0xIC04IC0zLjV0LTE3IC0xNC41dC0yMS41IC0yOS41dC0xNyAtNTJ0LTYuNSAtNzcuNXEwIC0xNSAtMy41IC0yNy41dC03LjUgLTE4LjVsLTQgLTVxLTE4IC0xOSAtNTMgLTIyaC0xMTVxLTcxIC00IC0xNDYgMTYuNXQtMTMxLjUgNTN0LTEwMyA2NnQtNzAuNSA1Ny41bC0yNSAyNHEtMTAgMTAgLTI3LjUgMzB0LTcxLjUgOTF0LTEwNiAxNTF0LTEyMi41IDIxMXQtMTMwLjUgMjcycS02IDE2IC02IDI3dDMgMTZsNCA2CnExNSAxOSA1NyAxOWwyNzQgMnExMiAtMiAyMyAtNi41dDE2IC04LjVsNSAtM3ExNiAtMTEgMjQgLTMycTIwIC01MCA0NiAtMTAzLjV0NDEgLTgxLjVsMTYgLTI5cTI5IC02MCA1NiAtMTA0dDQ4LjUgLTY4LjV0NDEuNSAtMzguNXQzNCAtMTR0MjcgNXEyIDEgNSA1dDEyIDIydDEzLjUgNDd0OS41IDgxdDAgMTI1cS0yIDQwIC05IDczdC0xNCA0NmwtNiAxMnEtMjUgMzQgLTg1IDQzcS0xMyAyIDUgMjRxMTYgMTkgMzggMzBxNTMgMjYgMjM5IDI0CnE4MiAtMSAxMzUgLTEzcTIwIC01IDMzLjUgLTEzLjV0MjAuNSAtMjR0MTAuNSAtMzJ0My41IC00NS41dC0xIC01NXQtMi41IC03MC41dC0xLjUgLTgyLjVxMCAtMTEgLTEgLTQydC0wLjUgLTQ4dDMuNSAtNDAuNXQxMS41IC0zOXQyMi41IC0yNC41cTggLTIgMTcgLTR0MjYgMTF0MzggMzQuNXQ1MiA2N3Q2OCAxMDcuNXE2MCAxMDQgMTA3IDIyNXE0IDEwIDEwIDE3LjV0MTEgMTAuNWw0IDNsNSAyLjV0MTMgM3QyMCAwLjVsMjg4IDIKcTM5IDUgNjQgLTIuNXQzMSAtMTYuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0id2VpYm8iIHVuaWNvZGU9IiYjeGYxOGE7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik02NzUgMjUycTIxIDM0IDExIDY5dC00NSA1MHEtMzQgMTQgLTczIDF0LTYwIC00NnEtMjIgLTM0IC0xMyAtNjguNXQ0MyAtNTAuNXQ3NC41IC0yLjV0NjIuNSA0Ny41ek03NjkgMzczcTggMTMgMy41IDI2LjV0LTE3LjUgMTguNXEtMTQgNSAtMjguNSAtMC41dC0yMS41IC0xOC41cS0xNyAtMzEgMTMgLTQ1cTE0IC01IDI5IDAuNXQyMiAxOC41ek05NDMgMjY2cS00NSAtMTAyIC0xNTggLTE1MHQtMjI0IC0xMgpxLTEwNyAzNCAtMTQ3LjUgMTI2LjV0Ni41IDE4Ny41cTQ3IDkzIDE1MS41IDEzOXQyMTAuNSAxOXExMTEgLTI5IDE1OC41IC0xMTkuNXQyLjUgLTE5MC41ek0xMjU1IDQyNnEtOSA5NiAtODkgMTcwdC0yMDguNSAxMDl0LTI3NC41IDIxcS0yMjMgLTIzIC0zNjkuNSAtMTQxLjV0LTEzMi41IC0yNjQuNXE5IC05NiA4OSAtMTcwdDIwOC41IC0xMDl0Mjc0LjUgLTIxcTIyMyAyMyAzNjkuNSAxNDEuNXQxMzIuNSAyNjQuNXpNMTU2MyA0MjIKcTAgLTY4IC0zNyAtMTM5LjV0LTEwOSAtMTM3dC0xNjguNSAtMTE3LjV0LTIyNiAtODN0LTI3MC41IC0zMXQtMjc1IDMzLjV0LTI0MC41IDkzdC0xNzEuNSAxNTF0LTY1IDE5OS41cTAgMTE1IDY5LjUgMjQ1dDE5Ny41IDI1OHExNjkgMTY5IDM0MS41IDIzNnQyNDYuNSAtN3E2NSAtNjQgMjAgLTIwOXEtNCAtMTQgLTEgLTIwdDEwIC03dDE0LjUgMC41dDEzLjUgMy41bDYgMnExMzkgNTkgMjQ2IDU5dDE1MyAtNjFxNDUgLTYzIDAgLTE3OApxLTIgLTEzIC00LjUgLTIwdDQuNSAtMTIuNXQxMiAtNy41dDE3IC02cTU3IC0xOCAxMDMgLTQ3dDgwIC04MS41dDM0IC0xMTYuNXpNMTQ4OSAxMDQ2cTQyIC00NyA1NC41IC0xMDguNXQtNi41IC0xMTcuNXEtOCAtMjMgLTI5LjUgLTM0dC00NC41IC00cS0yMyA4IC0zNCAyOS41dC00IDQ0LjVxMjAgNjMgLTI0IDExMXQtMTA3IDM1cS0yNCAtNSAtNDUgOHQtMjUgMzdxLTUgMjQgOCA0NC41dDM3IDI1LjVxNjAgMTMgMTE5IC01LjV0MTAxIC02NS41egpNMTY3MCAxMjA5cTg3IC05NiAxMTIuNSAtMjIyLjV0LTEzLjUgLTI0MS41cS05IC0yNyAtMzQgLTQwdC01MiAtNHQtNDAgMzR0LTUgNTJxMjggODIgMTAgMTcydC04MCAxNThxLTYyIDY5IC0xNDggOTUuNXQtMTczIDguNXEtMjggLTYgLTUyIDkuNXQtMzAgNDMuNXQ5LjUgNTEuNXQ0My41IDI5LjVxMTIzIDI2IDI0NCAtMTEuNXQyMDggLTEzNC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJyZW5yZW4iIHVuaWNvZGU9IiYjeGYxOGI7IiAKZD0iTTExMzMgLTM0cS0xNzEgLTk0IC0zNjggLTk0cS0xOTYgMCAtMzY3IDk0cTEzOCA4NyAyMzUuNSAyMTF0MTMxLjUgMjY4cTM1IC0xNDQgMTMyLjUgLTI2OHQyMzUuNSAtMjExek02MzggMTM5NHYtNDg1cTAgLTI1MiAtMTI2LjUgLTQ1OS41dC0zMzAuNSAtMzA2LjVxLTE4MSAyMTUgLTE4MSA0OTVxMCAxODcgODMuNSAzNDkuNXQyMjkuNSAyNjkuNXQzMjUgMTM3ek0xNTM2IDYzOHEwIC0yODAgLTE4MSAtNDk1CnEtMjA0IDk5IC0zMzAuNSAzMDYuNXQtMTI2LjUgNDU5LjV2NDg1cTE3OSAtMzAgMzI1IC0xMzd0MjI5LjUgLTI2OS41dDgzLjUgLTM0OS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfMzcyIiB1bmljb2RlPSImI3hmMThjOyIgaG9yaXotYWR2LXg9IjE0MDgiIApkPSJNMTQwMiA0MzNxLTMyIC04MCAtNzYgLTEzOHQtOTEgLTg4LjV0LTk5IC00Ni41dC0xMDEuNSAtMTQuNXQtOTYuNSA4LjV0LTg2LjUgMjJ0LTY5LjUgMjcuNXQtNDYgMjIuNWwtMTcgMTBxLTExMyAtMjI4IC0yODkuNSAtMzU5LjV0LTM4NC41IC0xMzIuNXEtMTkgMCAtMzIgMTN0LTEzIDMydDEzIDMxLjV0MzIgMTIuNXExNzMgMSAzMjIuNSAxMDcuNXQyNTEuNSAyOTQuNXEtMzYgLTE0IC03MiAtMjN0LTgzIC0xM3QtOTEgMi41dC05MyAyOC41CnQtOTIgNTl0LTg0LjUgMTAwdC03NC41IDE0NnExMTQgNDcgMjE0IDU3dDE2Ny41IC03LjV0MTI0LjUgLTU2LjV0ODguNSAtNzd0NTYuNSAtODJxNTMgMTMxIDc5IDI5MXEtNyAtMSAtMTggLTIuNXQtNDYuNSAtMi41dC02OS41IDAuNXQtODEuNSAxMHQtODguNSAyM3QtODQgNDIuNXQtNzUgNjV0LTU0LjUgOTQuNXQtMjguNSAxMjcuNXE3MCAyOCAxMzMuNSAzNi41dDExMi41IC0xdDkyIC0zMHQ3My41IC01MHQ1NiAtNjF0NDIgLTYzdDI3LjUgLTU2CnQxNiAtMzkuNWw0IC0xNnExMiAxMjIgMTIgMTk1cS04IDYgLTIxLjUgMTZ0LTQ5IDQ0LjV0LTYzLjUgNzEuNXQtNTQgOTN0LTMzIDExMi41dDEyIDEyN3Q3MCAxMzguNXE3MyAtMjUgMTI3LjUgLTYxLjV0ODQuNSAtNzYuNXQ0OCAtODV0MjAuNSAtODl0LTAuNSAtODUuNXQtMTMgLTc2LjV0LTE5IC02MnQtMTcgLTQybC03IC0xNXExIC00IDEgLTUwdC0xIC03MnEzIDcgMTAgMTguNXQzMC41IDQzdDUwLjUgNTh0NzEgNTUuNXQ5MS41IDQ0LjUKdDExMiAxNC41dDEzMi41IC0yNHEtMiAtNzggLTIxLjUgLTE0MS41dC01MCAtMTA0LjV0LTY5LjUgLTcxLjV0LTgxLjUgLTQ1LjV0LTg0LjUgLTI0dC04MCAtOS41dC02Ny41IDF0LTQ2LjUgNC41bC0xNyAzcS0yMyAtMTQ3IC03MyAtMjgzcTYgNyAxOCAxOC41dDQ5LjUgNDF0NzcuNSA1Mi41dDk5LjUgNDJ0MTE3LjUgMjB0MTI5IC0yMy41dDEzNyAtNzcuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0ic3RhY2tfZXhjaGFuZ2UiIHVuaWNvZGU9IiYjeGYxOGQ7IiBob3Jpei1hZHYteD0iMTI4MCIgCmQ9Ik0xMjU5IDI4M3YtNjZxMCAtODUgLTU3LjUgLTE0NC41dC0xMzguNSAtNTkuNWgtNTdsLTI2MCAtMjY5djI2OWgtNTI5cS04MSAwIC0xMzguNSA1OS41dC01Ny41IDE0NC41djY2aDEyMzh6TTEyNTkgNjA5di0yNTVoLTEyMzh2MjU1aDEyMzh6TTEyNTkgOTM3di0yNTVoLTEyMzh2MjU1aDEyMzh6TTEyNTkgMTA3N3YtNjdoLTEyMzh2NjdxMCA4NCA1Ny41IDE0My41dDEzOC41IDU5LjVoODQ2cTgxIDAgMTM4LjUgLTU5LjV0NTcuNSAtMTQzLjV6CiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfMzc0IiB1bmljb2RlPSImI3hmMThlOyIgCmQ9Ik0xMTUyIDY0MHEwIC0xNCAtOSAtMjNsLTMyMCAtMzIwcS05IC05IC0yMyAtOXEtMTMgMCAtMjIuNSA5LjV0LTkuNSAyMi41djE5MmgtMzUycS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2MTkycTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoMzUydjE5MnEwIDE0IDkgMjN0MjMgOXExMiAwIDI0IC0xMGwzMTkgLTMxOXE5IC05IDkgLTIzek0xMzEyIDY0MHEwIDE0OCAtNzMgMjczdC0xOTggMTk4dC0yNzMgNzN0LTI3MyAtNzN0LTE5OCAtMTk4CnQtNzMgLTI3M3Q3MyAtMjczdDE5OCAtMTk4dDI3MyAtNzN0MjczIDczdDE5OCAxOTh0NzMgMjczek0xNTM2IDY0MHEwIC0yMDkgLTEwMyAtMzg1LjV0LTI3OS41IC0yNzkuNXQtMzg1LjUgLTEwM3QtMzg1LjUgMTAzdC0yNzkuNSAyNzkuNXQtMTAzIDM4NS41dDEwMyAzODUuNXQyNzkuNSAyNzkuNXQzODUuNSAxMDN0Mzg1LjUgLTEwM3QyNzkuNSAtMjc5LjV0MTAzIC0zODUuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iYXJyb3dfY2lyY2xlX2FsdF9sZWZ0IiB1bmljb2RlPSImI3hmMTkwOyIgCmQ9Ik0xMTUyIDczNnYtMTkycTAgLTEzIC05LjUgLTIyLjV0LTIyLjUgLTkuNWgtMzUydi0xOTJxMCAtMTQgLTkgLTIzdC0yMyAtOXEtMTIgMCAtMjQgMTBsLTMxOSAzMTlxLTkgOSAtOSAyM3Q5IDIzbDMyMCAzMjBxOSA5IDIzIDlxMTMgMCAyMi41IC05LjV0OS41IC0yMi41di0xOTJoMzUycTEzIDAgMjIuNSAtOS41dDkuNSAtMjIuNXpNMTMxMiA2NDBxMCAxNDggLTczIDI3M3QtMTk4IDE5OHQtMjczIDczdC0yNzMgLTczdC0xOTggLTE5OAp0LTczIC0yNzN0NzMgLTI3M3QxOTggLTE5OHQyNzMgLTczdDI3MyA3M3QxOTggMTk4dDczIDI3M3pNMTUzNiA2NDBxMCAtMjA5IC0xMDMgLTM4NS41dC0yNzkuNSAtMjc5LjV0LTM4NS41IC0xMDN0LTM4NS41IDEwM3QtMjc5LjUgMjc5LjV0LTEwMyAzODUuNXQxMDMgMzg1LjV0Mjc5LjUgMjc5LjV0Mzg1LjUgMTAzdDM4NS41IC0xMDN0Mjc5LjUgLTI3OS41dDEwMyAtMzg1LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il8zNzYiIHVuaWNvZGU9IiYjeGYxOTE7IiAKZD0iTTEwMjQgOTYwdi02NDBxMCAtMjYgLTE5IC00NXQtNDUgLTE5cS0yMCAwIC0zNyAxMmwtNDQ4IDMyMHEtMjcgMTkgLTI3IDUydDI3IDUybDQ0OCAzMjBxMTcgMTIgMzcgMTJxMjYgMCA0NSAtMTl0MTkgLTQ1ek0xMjgwIDE2MHY5NjBxMCAxMyAtOS41IDIyLjV0LTIyLjUgOS41aC05NjBxLTEzIDAgLTIyLjUgLTkuNXQtOS41IC0yMi41di05NjBxMCAtMTMgOS41IC0yMi41dDIyLjUgLTkuNWg5NjBxMTMgMCAyMi41IDkuNXQ5LjUgMjIuNXoKTTE1MzYgMTEyMHYtOTYwcTAgLTExOSAtODQuNSAtMjAzLjV0LTIwMy41IC04NC41aC05NjBxLTExOSAwIC0yMDMuNSA4NC41dC04NC41IDIwMy41djk2MHEwIDExOSA4NC41IDIwMy41dDIwMy41IDg0LjVoOTYwcTExOSAwIDIwMy41IC04NC41dDg0LjUgLTIwMy41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJkb3RfY2lyY2xlX2FsdCIgdW5pY29kZT0iJiN4ZjE5MjsiIApkPSJNMTAyNCA2NDBxMCAtMTA2IC03NSAtMTgxdC0xODEgLTc1dC0xODEgNzV0LTc1IDE4MXQ3NSAxODF0MTgxIDc1dDE4MSAtNzV0NzUgLTE4MXpNNzY4IDExODRxLTE0OCAwIC0yNzMgLTczdC0xOTggLTE5OHQtNzMgLTI3M3Q3MyAtMjczdDE5OCAtMTk4dDI3MyAtNzN0MjczIDczdDE5OCAxOTh0NzMgMjczdC03MyAyNzN0LTE5OCAxOTh0LTI3MyA3M3pNMTUzNiA2NDBxMCAtMjA5IC0xMDMgLTM4NS41dC0yNzkuNSAtMjc5LjUKdC0zODUuNSAtMTAzdC0zODUuNSAxMDN0LTI3OS41IDI3OS41dC0xMDMgMzg1LjV0MTAzIDM4NS41dDI3OS41IDI3OS41dDM4NS41IDEwM3QzODUuNSAtMTAzdDI3OS41IC0yNzkuNXQxMDMgLTM4NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfMzc4IiB1bmljb2RlPSImI3hmMTkzOyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNMTAyMyAzNDlsMTAyIC0yMDRxLTU4IC0xNzkgLTIxMCAtMjkwdC0zMzkgLTExMXEtMTU2IDAgLTI4OC41IDc3LjV0LTIxMCAyMTB0LTc3LjUgMjg4LjVxMCAxODEgMTA0LjUgMzMwdDI3NC41IDIxMWwxNyAtMTMxcS0xMjIgLTU0IC0xOTUgLTE2NS41dC03MyAtMjQ0LjVxMCAtMTg1IDEzMS41IC0zMTYuNXQzMTYuNSAtMTMxLjVxMTI2IDAgMjMyLjUgNjV0MTY1IDE3NS41dDQ5LjUgMjM2LjV6TTE1NzEgMjQ5bDU4IC0xMTRsLTI1NiAtMTI4CnEtMTMgLTcgLTI5IC03cS00MCAwIC01NyAzNWwtMjM5IDQ3N2gtNDcycS0yNCAwIC00Mi41IDE2LjV0LTIxLjUgNDAuNWwtOTYgNzc5cS0yIDE3IDYgNDJxMTQgNTEgNTcgODIuNXQ5NyAzMS41cTY2IDAgMTEzIC00N3Q0NyAtMTEzcTAgLTY5IC01MiAtMTE3LjV0LTEyMCAtNDEuNWwzNyAtMjg5aDQyM3YtMTI4aC00MDdsMTYgLTEyOGg0NTVxNDAgMCA1NyAtMzVsMjI4IC00NTV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InZpbWVvX3NxdWFyZSIgdW5pY29kZT0iJiN4ZjE5NDsiIApkPSJNMTI5MiA4OThxMTAgMjE2IC0xNjEgMjIycS0yMzEgOCAtMzEyIC0yNjFxNDQgMTkgODIgMTlxODUgMCA3NCAtOTZxLTQgLTU3IC03NCAtMTY3dC0xMDUgLTExMHEtNDMgMCAtODIgMTY5cS0xMyA1NCAtNDUgMjU1cS0zMCAxODkgLTE2MCAxNzdxLTU5IC03IC0xNjQgLTEwMGwtODEgLTcybC04MSAtNzJsNTIgLTY3cTc2IDUyIDg3IDUycTU3IDAgMTA3IC0xNzlxMTUgLTU1IDQ1IC0xNjQuNXQ0NSAtMTY0LjVxNjggLTE3OSAxNjQgLTE3OQpxMTU3IDAgMzgzIDI5NHEyMjAgMjgzIDIyNiA0NDR6TTE1MzYgMTEyMHYtOTYwcTAgLTExOSAtODQuNSAtMjAzLjV0LTIwMy41IC04NC41aC05NjBxLTExOSAwIC0yMDMuNSA4NC41dC04NC41IDIwMy41djk2MHEwIDExOSA4NC41IDIwMy41dDIwMy41IDg0LjVoOTYwcTExOSAwIDIwMy41IC04NC41dDg0LjUgLTIwMy41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfMzgwIiB1bmljb2RlPSImI3hmMTk1OyIgaG9yaXotYWR2LXg9IjExNTIiIApkPSJNMTE1MiA3MDRxMCAtMTkxIC05NC41IC0zNTN0LTI1Ni41IC0yNTYuNXQtMzUzIC05NC41aC0xNjBxLTE0IDAgLTIzIDl0LTkgMjN2NjExbC0yMTUgLTY2cS0zIC0xIC05IC0xcS0xMCAwIC0xOSA2cS0xMyAxMCAtMTMgMjZ2MTI4cTAgMjMgMjMgMzFsMjMzIDcxdjkzbC0yMTUgLTY2cS0zIC0xIC05IC0xcS0xMCAwIC0xOSA2cS0xMyAxMCAtMTMgMjZ2MTI4cTAgMjMgMjMgMzFsMjMzIDcxdjI1MHEwIDE0IDkgMjN0MjMgOWgxNjAKcTE0IDAgMjMgLTl0OSAtMjN2LTE4MWwzNzUgMTE2cTE1IDUgMjggLTV0MTMgLTI2di0xMjhxMCAtMjMgLTIzIC0zMWwtMzkzIC0xMjF2LTkzbDM3NSAxMTZxMTUgNSAyOCAtNXQxMyAtMjZ2LTEyOHEwIC0yMyAtMjMgLTMxbC0zOTMgLTEyMXYtNDg3cTE4OCAxMyAzMTggMTUxdDEzMCAzMjhxMCAxNCA5IDIzdDIzIDloMTYwcTE0IDAgMjMgLTl0OSAtMjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InBsdXNfc3F1YXJlX28iIHVuaWNvZGU9IiYjeGYxOTY7IiBob3Jpei1hZHYteD0iMTQwOCIgCmQ9Ik0xMTUyIDczNnYtNjRxMCAtMTQgLTkgLTIzdC0yMyAtOWgtMzUydi0zNTJxMCAtMTQgLTkgLTIzdC0yMyAtOWgtNjRxLTE0IDAgLTIzIDl0LTkgMjN2MzUyaC0zNTJxLTE0IDAgLTIzIDl0LTkgMjN2NjRxMCAxNCA5IDIzdDIzIDloMzUydjM1MnEwIDE0IDkgMjN0MjMgOWg2NHExNCAwIDIzIC05dDkgLTIzdi0zNTJoMzUycTE0IDAgMjMgLTl0OSAtMjN6TTEyODAgMjg4djgzMnEwIDY2IC00NyAxMTN0LTExMyA0N2gtODMyCnEtNjYgMCAtMTEzIC00N3QtNDcgLTExM3YtODMycTAgLTY2IDQ3IC0xMTN0MTEzIC00N2g4MzJxNjYgMCAxMTMgNDd0NDcgMTEzek0xNDA4IDExMjB2LTgzMnEwIC0xMTkgLTg0LjUgLTIwMy41dC0yMDMuNSAtODQuNWgtODMycS0xMTkgMCAtMjAzLjUgODQuNXQtODQuNSAyMDMuNXY4MzJxMCAxMTkgODQuNSAyMDMuNXQyMDMuNSA4NC41aDgzMnExMTkgMCAyMDMuNSAtODQuNXQ4NC41IC0yMDMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzM4MiIgdW5pY29kZT0iJiN4ZjE5NzsiIGhvcml6LWFkdi14PSIyMTc2IiAKZD0iTTYyMCA0MTZxLTExMCAtNjQgLTI2OCAtNjRoLTEyOHY2NGgtNjRxLTEzIDAgLTIyLjUgMjMuNXQtOS41IDU2LjVxMCAyNCA3IDQ5cS01OCAyIC05Ni41IDEwLjV0LTM4LjUgMjAuNXQzOC41IDIwLjV0OTYuNSAxMC41cS03IDI1IC03IDQ5cTAgMzMgOS41IDU2LjV0MjIuNSAyMy41aDY0djY0aDEyOHExNTggMCAyNjggLTY0aDExMTNxNDIgLTcgMTA2LjUgLTE4dDgwLjUgLTE0cTg5IC0xNSAxNTAgLTQwLjV0ODMuNSAtNDcuNXQyMi41IC00MAp0LTIyLjUgLTQwdC04My41IC00Ny41dC0xNTAgLTQwLjVxLTE2IC0zIC04MC41IC0xNHQtMTA2LjUgLTE4aC0xMTEzek0xNzM5IDY2OHE1MyAtMzYgNTMgLTkydC01MyAtOTJsODEgLTMwcTY4IDQ4IDY4IDEyMnQtNjggMTIyek02MjUgNDAwaDEwMTVxLTIxNyAtMzggLTQ1NiAtODBxLTU3IDAgLTExMyAtMjR0LTgzIC00OGwtMjggLTI0bC0yODggLTI4OHEtMjYgLTI2IC03MC41IC00NXQtODkuNSAtMTloLTk2bC05MyA0NjRoMjkKcTE1NyAwIDI3MyA2NHpNMzUyIDgxNmgtMjlsOTMgNDY0aDk2cTQ2IDAgOTAgLTE5dDcwIC00NWwyODggLTI4OHE0IC00IDExIC0xMC41dDMwLjUgLTIzdDQ4LjUgLTI5dDYxLjUgLTIzdDcyLjUgLTEwLjVsNDU2IC04MGgtMTAxNXEtMTE2IDY0IC0yNzMgNjR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il8zODMiIHVuaWNvZGU9IiYjeGYxOTg7IiBob3Jpei1hZHYteD0iMTY2NCIgCmQ9Ik0xNTE5IDc2MHE2MiAwIDEwMy41IC00MC41dDQxLjUgLTEwMS41cTAgLTk3IC05MyAtMTMwbC0xNzIgLTU5bDU2IC0xNjdxNyAtMjEgNyAtNDdxMCAtNTkgLTQyIC0xMDJ0LTEwMSAtNDNxLTQ3IDAgLTg1LjUgMjd0LTUzLjUgNzJsLTU1IDE2NWwtMzEwIC0xMDZsNTUgLTE2NHE4IC0yNCA4IC00N3EwIC01OSAtNDIgLTEwMnQtMTAyIC00M3EtNDcgMCAtODUgMjd0LTUzIDcybC01NSAxNjNsLTE1MyAtNTNxLTI5IC05IC01MCAtOQpxLTYxIDAgLTEwMS41IDQwdC00MC41IDEwMXEwIDQ3IDI3LjUgODV0NzEuNSA1M2wxNTYgNTNsLTEwNSAzMTNsLTE1NiAtNTRxLTI2IC04IC00OCAtOHEtNjAgMCAtMTAxIDQwLjV0LTQxIDEwMC41cTAgNDcgMjcuNSA4NXQ3MS41IDUzbDE1NyA1M2wtNTMgMTU5cS04IDI0IC04IDQ3cTAgNjAgNDIgMTAyLjV0MTAyIDQyLjVxNDcgMCA4NSAtMjd0NTMgLTcybDU0IC0xNjBsMzEwIDEwNWwtNTQgMTYwcS04IDI0IC04IDQ3cTAgNTkgNDIuNSAxMDIKdDEwMS41IDQzcTQ3IDAgODUuNSAtMjcuNXQ1My41IC03MS41bDUzIC0xNjFsMTYyIDU1cTIxIDYgNDMgNnE2MCAwIDEwMi41IC0zOS41dDQyLjUgLTk4LjVxMCAtNDUgLTMwIC04MS41dC03NCAtNTEuNWwtMTU3IC01NGwxMDUgLTMxNmwxNjQgNTZxMjQgOCA0NiA4ek03MjUgNDk4bDMxMCAxMDVsLTEwNSAzMTVsLTMxMCAtMTA3eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfMzg0IiB1bmljb2RlPSImI3hmMTk5OyIgCmQ9Ik0xMjQ4IDE0MDhxMTE5IDAgMjAzLjUgLTg0LjV0ODQuNSAtMjAzLjV2LTk2MHEwIC0xMTkgLTg0LjUgLTIwMy41dC0yMDMuNSAtODQuNWgtOTYwcS0xMTkgMCAtMjAzLjUgODQuNXQtODQuNSAyMDMuNXY5NjBxMCAxMTkgODQuNSAyMDMuNXQyMDMuNSA4NC41aDk2MHpNMTI4MCAzNTJ2NDM2cS0zMSAtMzUgLTY0IC01NXEtMzQgLTIyIC0xMzIuNSAtODV0LTE1MS41IC05OXEtOTggLTY5IC0xNjQgLTY5djB2MHEtNjYgMCAtMTY0IDY5CnEtNDcgMzIgLTE0MiA5Mi41dC0xNDIgOTIuNXEtMTIgOCAtMzMgMjd0LTMxIDI3di00MzZxMCAtNDAgMjggLTY4dDY4IC0yOGg4MzJxNDAgMCA2OCAyOHQyOCA2OHpNMTI4MCA5MjVxMCA0MSAtMjcuNSA3MHQtNjguNSAyOWgtODMycS00MCAwIC02OCAtMjh0LTI4IC02OHEwIC0zNyAzMC41IC03Ni41dDY3LjUgLTY0LjVxNDcgLTMyIDEzNy41IC04OXQxMjkuNSAtODNxMyAtMiAxNyAtMTEuNXQyMSAtMTR0MjEgLTEzdDIzLjUgLTEzCnQyMS41IC05LjV0MjIuNSAtNy41dDIwLjUgLTIuNXQyMC41IDIuNXQyMi41IDcuNXQyMS41IDkuNXQyMy41IDEzdDIxIDEzdDIxIDE0dDE3IDExLjVsMjY3IDE3NHEzNSAyMyA2Ni41IDYyLjV0MzEuNSA3My41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfMzg1IiB1bmljb2RlPSImI3hmMTlhOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTI3IDY0MHEwIDE2MyA2NyAzMTNsMzY3IC0xMDA1cS0xOTYgOTUgLTMxNSAyODF0LTExOSA0MTF6TTE0MTUgNjc5cTAgLTE5IC0yLjUgLTM4LjV0LTEwIC00OS41dC0xMS41IC00NHQtMTcuNSAtNTl0LTE3LjUgLTU4bC03NiAtMjU2bC0yNzggODI2cTQ2IDMgODggOHExOSAyIDI2IDE4LjV0LTIuNSAzMXQtMjguNSAxMy41bC0yMDUgLTEwcS03NSAxIC0yMDIgMTBxLTEyIDEgLTIwLjUgLTV0LTExLjUgLTE1dC0xLjUgLTE4LjV0OSAtMTYuNQp0MTkuNSAtOGw4MCAtOGwxMjAgLTMyOGwtMTY4IC01MDRsLTI4MCA4MzJxNDYgMyA4OCA4cTE5IDIgMjYgMTguNXQtMi41IDMxdC0yOC41IDEzLjVsLTIwNSAtMTBxLTcgMCAtMjMgMC41dC0yNiAwLjVxMTA1IDE2MCAyNzQuNSAyNTMuNXQzNjcuNSA5My41cTE0NyAwIDI4MC41IC01M3QyMzguNSAtMTQ5aC0xMHEtNTUgMCAtOTIgLTQwLjV0LTM3IC05NS41cTAgLTEyIDIgLTI0dDQgLTIxLjV0OCAtMjN0OSAtMjF0MTIgLTIyLjV0MTIuNSAtMjEKdDE0LjUgLTI0dDE0IC0yM3E2MyAtMTA3IDYzIC0yMTJ6TTkwOSA1NzNsMjM3IC02NDdxMSAtNiA1IC0xMXEtMTI2IC00NCAtMjU1IC00NHEtMTEyIDAgLTIxNyAzMnpNMTU3MCAxMDA5cTk1IC0xNzQgOTUgLTM2OXEwIC0yMDkgLTEwNCAtMzg1LjV0LTI3OSAtMjc4LjVsMjM1IDY3OHE1OSAxNjkgNTkgMjc2cTAgNDIgLTYgNzl6TTg5NiAxNTM2cTE4MiAwIDM0OCAtNzF0Mjg2IC0xOTF0MTkxIC0yODZ0NzEgLTM0OHQtNzEgLTM0OHQtMTkxIC0yODYKdC0yODYgLTE5MXQtMzQ4IC03MXQtMzQ4IDcxdC0yODYgMTkxdC0xOTEgMjg2dC03MSAzNDh0NzEgMzQ4dDE5MSAyODZ0Mjg2IDE5MXQzNDggNzF6TTg5NiAtMjE1cTE3MyAwIDMzMS41IDY4dDI3MyAxODIuNXQxODIuNSAyNzN0NjggMzMxLjV0LTY4IDMzMS41dC0xODIuNSAyNzN0LTI3MyAxODIuNXQtMzMxLjUgNjh0LTMzMS41IC02OHQtMjczIC0xODIuNXQtMTgyLjUgLTI3M3QtNjggLTMzMS41dDY4IC0zMzEuNXQxODIuNSAtMjczCnQyNzMgLTE4Mi41dDMzMS41IC02OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzM4NiIgdW5pY29kZT0iJiN4ZjE5YjsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTEwODYgMTUzNnYtMTUzNmwtMjcyIC0xMjhxLTIyOCAyMCAtNDE0IDEwMnQtMjkzIDIwOC41dC0xMDcgMjcyLjVxMCAxNDAgMTAwLjUgMjYzLjV0Mjc1IDIwNS41dDM5MS41IDEwOHYtMTcycS0yMTcgLTM4IC0zNTYuNSAtMTUwdC0xMzkuNSAtMjU1cTAgLTE1MiAxNTQuNSAtMjY3dDM4OC41IC0xNDV2MTM2MHpNMTc1NSA5NTRsMzcgLTM5MGwtNTI1IDExNGwxNDcgODNxLTExOSA3MCAtMjgwIDk5djE3MnEyNzcgLTMzIDQ4MSAtMTU3eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfMzg3IiB1bmljb2RlPSImI3hmMTljOyIgaG9yaXotYWR2LXg9IjIwNDgiIApkPSJNOTYwIDE1MzZsOTYwIC0zODR2LTEyOGgtMTI4cTAgLTI2IC0yMC41IC00NXQtNDguNSAtMTloLTE1MjZxLTI4IDAgLTQ4LjUgMTl0LTIwLjUgNDVoLTEyOHYxMjh6TTI1NiA4OTZoMjU2di03NjhoMTI4djc2OGgyNTZ2LTc2OGgxMjh2NzY4aDI1NnYtNzY4aDEyOHY3NjhoMjU2di03NjhoNTlxMjggMCA0OC41IC0xOXQyMC41IC00NXYtNjRoLTE2NjR2NjRxMCAyNiAyMC41IDQ1dDQ4LjUgMTloNTl2NzY4ek0xODUxIC02NApxMjggMCA0OC41IC0xOXQyMC41IC00NXYtMTI4aC0xOTIwdjEyOHEwIDI2IDIwLjUgNDV0NDguNSAxOWgxNzgyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfMzg4IiB1bmljb2RlPSImI3hmMTlkOyIgaG9yaXotYWR2LXg9IjIzMDQiIApkPSJNMTc3NCA3MDBsMTggLTMxNnE0IC02OSAtODIgLTEyOHQtMjM1IC05My41dC0zMjMgLTM0LjV0LTMyMyAzNC41dC0yMzUgOTMuNXQtODIgMTI4bDE4IDMxNmw1NzQgLTE4MXEyMiAtNyA0OCAtN3Q0OCA3ek0yMzA0IDEwMjRxMCAtMjMgLTIyIC0zMWwtMTEyMCAtMzUycS00IC0xIC0xMCAtMXQtMTAgMWwtNjUyIDIwNnEtNDMgLTM0IC03MSAtMTExLjV0LTM0IC0xNzguNXE2MyAtMzYgNjMgLTEwOXEwIC02OSAtNTggLTEwN2w1OCAtNDMzCnEyIC0xNCAtOCAtMjVxLTkgLTExIC0yNCAtMTFoLTE5MnEtMTUgMCAtMjQgMTFxLTEwIDExIC04IDI1bDU4IDQzM3EtNTggMzggLTU4IDEwN3EwIDczIDY1IDExMXExMSAyMDcgOTggMzMwbC0zMzMgMTA0cS0yMiA4IC0yMiAzMXQyMiAzMWwxMTIwIDM1MnE0IDEgMTAgMXQxMCAtMWwxMTIwIC0zNTJxMjIgLTggMjIgLTMxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfMzg5IiB1bmljb2RlPSImI3hmMTllOyIgCmQ9Ik04NTkgNTc5bDEzIC03MDdxLTYyIDExIC0xMDUgMTFxLTQxIDAgLTEwNSAtMTFsMTMgNzA3cS00MCA2OSAtMTY4LjUgMjk1LjV0LTIxNi41IDM3NC41dC0xODEgMjg3cTU4IC0xNSAxMDggLTE1cTQ0IDAgMTExIDE1cTYzIC0xMTEgMTMzLjUgLTIyOS41dDE2NyAtMjc2LjV0MTM4LjUgLTIyN3EzNyA2MSAxMDkuNSAxNzcuNXQxMTcuNSAxOTB0MTA1IDE3NnQxMDcgMTg5LjVxNTQgLTE0IDEwNyAtMTRxNTYgMCAxMTQgMTR2MApxLTI4IC0zOSAtNjAgLTg4LjV0LTQ5LjUgLTc4LjV0LTU2LjUgLTk2dC00OSAtODRxLTE0NiAtMjQ4IC0zNTMgLTYxMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjFBMCIgdW5pY29kZT0iJiN4ZjFhMDsiIApkPSJNNzY4IDc1MGg3MjVxMTIgLTY3IDEyIC0xMjhxMCAtMjE3IC05MSAtMzg3LjV0LTI1OS41IC0yNjYuNXQtMzg2LjUgLTk2cS0xNTcgMCAtMjk5IDYwLjV0LTI0NSAxNjMuNXQtMTYzLjUgMjQ1dC02MC41IDI5OXQ2MC41IDI5OXQxNjMuNSAyNDV0MjQ1IDE2My41dDI5OSA2MC41cTMwMCAwIDUxNSAtMjAxbC0yMDkgLTIwMXEtMTIzIDExOSAtMzA2IDExOXEtMTI5IDAgLTIzOC41IC02NXQtMTczLjUgLTE3Ni41dC02NCAtMjQzLjUKdDY0IC0yNDMuNXQxNzMuNSAtMTc2LjV0MjM4LjUgLTY1cTg3IDAgMTYwIDI0dDEyMCA2MHQ4MiA4MnQ1MS41IDg3dDIyLjUgNzhoLTQzNnYyNjR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImYxYTEiIHVuaWNvZGU9IiYjeGYxYTE7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xMDk1IDM2OXExNiAtMTYgMCAtMzFxLTYyIC02MiAtMTk5IC02MnQtMTk5IDYycS0xNiAxNSAwIDMxcTYgNiAxNSA2dDE1IC02cTQ4IC00OSAxNjkgLTQ5cTEyMCAwIDE2OSA0OXE2IDYgMTUgNnQxNSAtNnpNNzg4IDU1MHEwIC0zNyAtMjYgLTYzdC02MyAtMjZ0LTYzLjUgMjZ0LTI2LjUgNjNxMCAzOCAyNi41IDY0dDYzLjUgMjZ0NjMgLTI2LjV0MjYgLTYzLjV6TTExODMgNTUwcTAgLTM3IC0yNi41IC02M3QtNjMuNSAtMjZ0LTYzIDI2CnQtMjYgNjN0MjYgNjMuNXQ2MyAyNi41dDYzLjUgLTI2dDI2LjUgLTY0ek0xNDM0IDY3MHEwIDQ5IC0zNSA4NHQtODUgMzV0LTg2IC0zNnEtMTMwIDkwIC0zMTEgOTZsNjMgMjgzbDIwMCAtNDVxMCAtMzcgMjYgLTYzdDYzIC0yNnQ2My41IDI2LjV0MjYuNSA2My41dC0yNi41IDYzLjV0LTYzLjUgMjYuNXEtNTQgMCAtODAgLTUwbC0yMjEgNDlxLTE5IDUgLTI1IC0xNmwtNjkgLTMxMnEtMTgwIC03IC0zMDkgLTk3cS0zNSAzNyAtODcgMzcKcS01MCAwIC04NSAtMzV0LTM1IC04NHEwIC0zNSAxOC41IC02NHQ0OS41IC00NHEtNiAtMjcgLTYgLTU2cTAgLTE0MiAxNDAgLTI0M3QzMzcgLTEwMXExOTggMCAzMzggMTAxdDE0MCAyNDNxMCAzMiAtNyA1N3EzMCAxNSA0OCA0My41dDE4IDYzLjV6TTE3OTIgNjQwcTAgLTE4MiAtNzEgLTM0OHQtMTkxIC0yODZ0LTI4NiAtMTkxdC0zNDggLTcxdC0zNDggNzF0LTI4NiAxOTF0LTE5MSAyODZ0LTcxIDM0OHQ3MSAzNDh0MTkxIDI4NnQyODYgMTkxCnQzNDggNzF0MzQ4IC03MXQyODYgLTE5MXQxOTEgLTI4NnQ3MSAtMzQ4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfMzkyIiB1bmljb2RlPSImI3hmMWEyOyIgCmQ9Ik05MzkgNDA3cTEzIC0xMyAwIC0yNnEtNTMgLTUzIC0xNzEgLTUzdC0xNzEgNTNxLTEzIDEzIDAgMjZxNSA2IDEzIDZ0MTMgLTZxNDIgLTQyIDE0NSAtNDJ0MTQ1IDQycTUgNiAxMyA2dDEzIC02ek02NzYgNTYzcTAgLTMxIC0yMyAtNTR0LTU0IC0yM3QtNTQgMjN0LTIzIDU0cTAgMzIgMjIuNSA1NC41dDU0LjUgMjIuNXQ1NC41IC0yMi41dDIyLjUgLTU0LjV6TTEwMTQgNTYzcTAgLTMxIC0yMyAtNTR0LTU0IC0yM3QtNTQgMjN0LTIzIDU0CnEwIDMyIDIyLjUgNTQuNXQ1NC41IDIyLjV0NTQuNSAtMjIuNXQyMi41IC01NC41ek0xMjI5IDY2NnEwIDQyIC0zMCA3MnQtNzMgMzBxLTQyIDAgLTczIC0zMXEtMTEzIDc4IC0yNjcgODJsNTQgMjQzbDE3MSAtMzlxMSAtMzIgMjMuNSAtNTR0NTMuNSAtMjJxMzIgMCA1NC41IDIyLjV0MjIuNSA1NC41dC0yMi41IDU0LjV0LTU0LjUgMjIuNXEtNDggMCAtNjkgLTQzbC0xODkgNDJxLTE3IDUgLTIxIC0xM2wtNjAgLTI2OHEtMTU0IC02IC0yNjUgLTgzCnEtMzAgMzIgLTc0IDMycS00MyAwIC03MyAtMzB0LTMwIC03MnEwIC0zMCAxNiAtNTV0NDIgLTM4cS01IC0yNSAtNSAtNDhxMCAtMTIyIDEyMCAtMjA4LjV0Mjg5IC04Ni41cTE3MCAwIDI5MCA4Ni41dDEyMCAyMDguNXEwIDI1IC02IDQ5cTI1IDEzIDQwLjUgMzcuNXQxNS41IDU0LjV6TTE1MzYgMTEyMHYtOTYwcTAgLTExOSAtODQuNSAtMjAzLjV0LTIwMy41IC04NC41aC05NjBxLTExOSAwIC0yMDMuNSA4NC41dC04NC41IDIwMy41djk2MApxMCAxMTkgODQuNSAyMDMuNXQyMDMuNSA4NC41aDk2MHExMTkgMCAyMDMuNSAtODQuNXQ4NC41IC0yMDMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzM5MyIgdW5pY29kZT0iJiN4ZjFhMzsiIApkPSJNODY2IDY5N2w5MCAyN3Y2MnEwIDc5IC01OCAxMzV0LTEzOCA1NnQtMTM4IC01NS41dC01OCAtMTM0LjV2LTI4M3EwIC0yMCAtMTQgLTMzLjV0LTMzIC0xMy41dC0zMi41IDEzLjV0LTEzLjUgMzMuNXYxMjBoLTE1MXYtMTIycTAgLTgyIDU3LjUgLTEzOXQxMzkuNSAtNTdxODEgMCAxMzguNSA1Ni41dDU3LjUgMTM2LjV2MjgwcTAgMTkgMTMuNSAzM3QzMy41IDE0cTE5IDAgMzIuNSAtMTR0MTMuNSAtMzN2LTU0ek0xMTk5IDUwMnYxMjJoLTE1MAp2LTEyNnEwIC0yMCAtMTMuNSAtMzMuNXQtMzMuNSAtMTMuNXEtMTkgMCAtMzIuNSAxNHQtMTMuNSAzM3YxMjNsLTkwIC0yNmwtNjAgMjh2LTEyM3EwIC04MCA1OCAtMTM3dDEzOSAtNTd0MTM4LjUgNTd0NTcuNSAxMzl6TTE1MzYgNjQwcTAgLTIwOSAtMTAzIC0zODUuNXQtMjc5LjUgLTI3OS41dC0zODUuNSAtMTAzdC0zODUuNSAxMDN0LTI3OS41IDI3OS41dC0xMDMgMzg1LjV0MTAzIDM4NS41dDI3OS41IDI3OS41dDM4NS41IDEwMwp0Mzg1LjUgLTEwM3QyNzkuNSAtMjc5LjV0MTAzIC0zODUuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZjFhNCIgdW5pY29kZT0iJiN4ZjFhNDsiIGhvcml6LWFkdi14PSIxOTIwIiAKZD0iTTEwNjIgODI0djExOHEwIDQyIC0zMCA3MnQtNzIgMzB0LTcyIC0zMHQtMzAgLTcydi02MTJxMCAtMTc1IC0xMjYgLTI5OXQtMzAzIC0xMjRxLTE3OCAwIC0zMDMuNSAxMjUuNXQtMTI1LjUgMzAzLjV2MjY2aDMyOHYtMjYycTAgLTQzIDMwIC03Mi41dDcyIC0yOS41dDcyIDI5LjV0MzAgNzIuNXY2MjBxMCAxNzEgMTI2LjUgMjkydDMwMS41IDEyMXExNzYgMCAzMDIgLTEyMnQxMjYgLTI5NHYtMTM2bC0xOTUgLTU4ek0xNTkyIDYwMmgzMjgKdi0yNjZxMCAtMTc4IC0xMjUuNSAtMzAzLjV0LTMwMy41IC0xMjUuNXEtMTc3IDAgLTMwMyAxMjQuNXQtMTI2IDMwMC41djI2OGwxMzEgLTYxbDE5NSA1OHYtMjcwcTAgLTQyIDMwIC03MS41dDcyIC0yOS41dDcyIDI5LjV0MzAgNzEuNXYyNzV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il8zOTUiIHVuaWNvZGU9IiYjeGYxYTU7IiAKZD0iTTE0NzIgMTYwdjQ4MGgtNzA0djcwNGgtNDgwcS05MyAwIC0xNTguNSAtNjUuNXQtNjUuNSAtMTU4LjV2LTQ4MGg3MDR2LTcwNGg0ODBxOTMgMCAxNTguNSA2NS41dDY1LjUgMTU4LjV6TTE1MzYgMTEyMHYtOTYwcTAgLTExOSAtODQuNSAtMjAzLjV0LTIwMy41IC04NC41aC05NjBxLTExOSAwIC0yMDMuNSA4NC41dC04NC41IDIwMy41djk2MHEwIDExOSA4NC41IDIwMy41dDIwMy41IDg0LjVoOTYwcTExOSAwIDIwMy41IC04NC41CnQ4NC41IC0yMDMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzM5NiIgdW5pY29kZT0iJiN4ZjFhNjsiIGhvcml6LWFkdi14PSIyMDQ4IiAKZD0iTTMyOCAxMjU0aDIwNHYtOTgzaC01MzJ2Njk3aDMyOHYyODZ6TTMyOCA0MzV2MzY5aC0xMjN2LTM2OWgxMjN6TTYxNCA5Njh2LTY5N2gyMDV2Njk3aC0yMDV6TTYxNCAxMjU0di0yMDRoMjA1djIwNGgtMjA1ek05MDEgOTY4aDUzM3YtOTQyaC01MzN2MTYzaDMyOHY4MmgtMzI4djY5N3pNMTIyOSA0MzV2MzY5aC0xMjN2LTM2OWgxMjN6TTE1MTYgOTY4aDUzMnYtOTQyaC01MzJ2MTYzaDMyN3Y4MmgtMzI3djY5N3pNMTg0MyA0MzV2MzY5aC0xMjMKdi0zNjloMTIzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfMzk3IiB1bmljb2RlPSImI3hmMWE3OyIgCmQ9Ik0xMDQ2IDUxNnEwIC02NCAtMzggLTEwOXQtOTEgLTQ1cS00MyAwIC03MCAxNXYyNzdxMjggMTcgNzAgMTdxNTMgMCA5MSAtNDUuNXQzOCAtMTA5LjV6TTcwMyA5NDRxMCAtNjQgLTM4IC0xMDkuNXQtOTEgLTQ1LjVxLTQzIDAgLTcwIDE1djI3N3EyOCAxNyA3MCAxN3E1MyAwIDkxIC00NXQzOCAtMTA5ek0xMjY1IDUxM3EwIDEzNCAtODggMjI5dC0yMTMgOTVxLTIwIDAgLTM5IC0zcS0yMyAtNzggLTc4IC0xMzZxLTg3IC05NSAtMjExIC0xMDEKdi02MzZsMjExIDQxdjIwNnE1MSAtMTkgMTE3IC0xOXExMjUgMCAyMTMgOTV0ODggMjI5ek05MjIgOTQwcTAgMTM0IC04OC41IDIyOXQtMjEzLjUgOTVxLTc0IDAgLTE0MSAtMzZoLTE4NnYtODQwbDIxMSA0MXYyMDZxNTUgLTE5IDExNiAtMTlxMTI1IDAgMjEzLjUgOTV0ODguNSAyMjl6TTE1MzYgMTEyMHYtOTYwcTAgLTExOSAtODQuNSAtMjAzLjV0LTIwMy41IC04NC41aC05NjBxLTExOSAwIC0yMDMuNSA4NC41dC04NC41IDIwMy41djk2MApxMCAxMTkgODQuNSAyMDMuNXQyMDMuNSA4NC41aDk2MHExMTkgMCAyMDMuNSAtODQuNXQ4NC41IC0yMDMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzM5OCIgdW5pY29kZT0iJiN4ZjFhODsiIGhvcml6LWFkdi14PSIyMDM4IiAKZD0iTTEyMjIgNjA3cTc1IDMgMTQzLjUgLTIwLjV0MTE4IC01OC41dDEwMSAtOTQuNXQ4NCAtMTA4dDc1LjUgLTEyMC41cTMzIC01NiA3OC41IC0xMDl0NzUuNSAtODAuNXQ5OSAtODguNXEtNDggLTMwIC0xMDguNSAtNTcuNXQtMTM4LjUgLTU5dC0xMTQgLTQ3LjVxLTQ0IDM3IC03NCAxMTV0LTQzLjUgMTY0LjV0LTMzIDE4MC41dC00Mi41IDE2OC41dC03Mi41IDEyM3QtMTIyLjUgNDguNWwtMTAgLTJsLTYgLTRxNCAtNSAxMyAtMTQKcTYgLTUgMjggLTIzLjV0MjUuNSAtMjJ0MTkgLTE4dDE4IC0yMC41dDExLjUgLTIxdDEwLjUgLTI3LjV0NC41IC0zMXQ0IC00MC41bDEgLTMzcTEgLTI2IC0yLjUgLTU3LjV0LTcuNSAtNTJ0LTEyLjUgLTU4LjV0LTExLjUgLTUzcS0zNSAxIC0xMDEgLTkuNXQtOTggLTEwLjVxLTM5IDAgLTcyIDEwcS0yIDE2IC0yIDQ3cTAgNzQgMyA5NnEyIDEzIDMxLjUgNDEuNXQ1NyA1OXQyNi41IDUxLjVxLTI0IDIgLTQzIC0yNApxLTM2IC01MyAtMTExLjUgLTk5LjV0LTEzNi41IC00Ni41cS0yNSAwIC03NS41IDYzdC0xMDYuNSAxMzkuNXQtODQgOTYuNXEtNiA0IC0yNyAzMHEtNDgyIC0xMTIgLTUxMyAtMTEycS0xNiAwIC0yOCAxMXQtMTIgMjdxMCAxNSA4LjUgMjYuNXQyMi41IDE0LjVsNDg2IDEwNnEtOCAxNCAtOCAyNXQ1LjUgMTcuNXQxNiAxMS41dDIwIDd0MjMgNC41dDE4LjUgNC41cTQgMSAxNS41IDcuNXQxNy41IDYuNXExNSAwIDI4IC0xNnQyMCAtMzMKcTE2MyAzNyAxNzIgMzdxMTcgMCAyOS41IC0xMXQxMi41IC0yOHEwIC0xNSAtOC41IC0yNnQtMjMuNSAtMTRsLTE4MiAtNDBsLTEgLTE2cS0xIC0yNiA4MS41IC0xMTcuNXQxMDQuNSAtOTEuNXE0NyAwIDExOSA4MHQ3MiAxMjlxMCAzNiAtMjMuNSA1M3QtNTEgMTguNXQtNTEgMTEuNXQtMjMuNSAzNHEwIDE2IDEwIDM0bC02OCAxOXE0MyA0NCA0MyAxMTdxMCAyNiAtNSA1OHE4MiAxNiAxNDQgMTZxNDQgMCA3MS41IC0xLjV0NDguNSAtOC41CnQzMSAtMTMuNXQyMC41IC0yNC41dDE1LjUgLTMzLjV0MTcgLTQ3LjV0MjQgLTYwbDUwIDI1cS0zIC00MCAtMjMgLTYwdC00Mi41IC0yMXQtNDAgLTYuNXQtMTYuNSAtMjAuNXpNMTI4MiA4NDJxLTUgNSAtMTMuNSAxNS41dC0xMiAxNC41dC0xMC41IDExLjV0LTEwIDEwLjVsLTggOHQtOC41IDcuNXQtOCA1dC04LjUgNC41cS03IDMgLTE0LjUgNXQtMjAuNSAyLjV0LTIyIDAuNWgtMzIuNWgtMzcuNXEtMTI2IDAgLTIxNyAtNDMKcTE2IDMwIDM2IDQ2LjV0NTQgMjkuNXQ2NS41IDM2dDQ2IDM2LjV0NTAgNTV0NDMuNSA1MC41cTEyIC05IDI4IC0zMS41dDMyIC0zNi41dDM4IC0xM2wxMiAxdi03NmwyMiAtMXEyNDcgOTUgMzcxIDE5MHEyOCAyMSA1MCAzOXQ0Mi41IDM3LjV0MzMgMzF0MjkuNSAzNHQyNCAzMXQyNC41IDM3dDIzIDM4dDI3IDQ3LjV0MjkuNSA1M2w3IDlxLTIgLTUzIC00MyAtMTM5cS03OSAtMTY1IC0yMDUgLTI2NHQtMzA2IC0xNDJxLTE0IC0zIC00MiAtNy41CnQtNTAgLTkuNXQtMzkgLTE0cTMgLTE5IDI0LjUgLTQ2dDIxLjUgLTM0cTAgLTExIC0yNiAtMzB6TTEwNjEgLTc5cTM5IDI2IDEzMS41IDQ3LjV0MTQ2LjUgMjEuNXE5IDAgMjIuNSAtMTUuNXQyOCAtNDIuNXQyNiAtNTB0MjQgLTUxdDE0LjUgLTMzcS0xMjEgLTQ1IC0yNDQgLTQ1cS02MSAwIC0xMjUgMTF6TTgyMiA1NjhsNDggMTJsMTA5IC0xNzdsLTczIC00OHpNMTMyMyA1MXEzIC0xNSAzIC0xNnEwIC03IC0xNy41IC0xNC41dC00NiAtMTMKdC01NCAtOS41dC01My41IC03LjV0LTMyIC00LjVsLTcgNDNxMjEgMiA2MC41IDguNXQ3MiAxMHQ2MC41IDMuNWgxNHpNODY2IDY3OWwtOTYgLTIwbC02IDE3cTEwIDEgMzIuNSA3dDM0LjUgNnExOSAwIDM1IC0xMHpNMTA2MSA0NWgzMWwxMCAtODNsLTQxIC0xMnY5NXpNMTk1MCAxNTM1djF2LTF6TTE5NTAgMTUzNWwtMSAtNWwtMiAtMmwxIDN6TTE5NTAgMTUzNWwxIDF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il8zOTkiIHVuaWNvZGU9IiYjeGYxYTk7IiAKZD0iTTExNjcgLTUwcS01IDE5IC0yNCA1cS0zMCAtMjIgLTg3IC0zOXQtMTMxIC0xN3EtMTI5IDAgLTE5MyA0OXEtNSA0IC0xMyA0cS0xMSAwIC0yNiAtMTJxLTcgLTYgLTcuNSAtMTZ0Ny41IC0yMHEzNCAtMzIgODcuNSAtNDZ0MTAyLjUgLTEyLjV0OTkgNC41cTQxIDQgODQuNSAyMC41dDY1IDMwdDI4LjUgMjAuNXExMiAxMiA3IDI5ek0xMTI4IDY1cS0xOSA0NyAtMzkgNjFxLTIzIDE1IC03NiAxNXEtNDcgMCAtNzEgLTEwCnEtMjkgLTEyIC03OCAtNTZxLTI2IC0yNCAtMTIgLTQ0cTkgLTggMTcuNSAtNC41dDMxLjUgMjMuNXEzIDIgMTAuNSA4LjV0MTAuNSA4LjV0MTAgN3QxMS41IDd0MTIuNSA1dDE1IDQuNXQxNi41IDIuNXQyMC41IDFxMjcgMCA0NC41IC03LjV0MjMgLTE0LjV0MTMuNSAtMjJxMTAgLTE3IDEyLjUgLTIwdDEyLjUgMXEyMyAxMiAxNCAzNHpNMTQ4MyAzNDZxMCAyMiAtNSA0NC41dC0xNi41IDQ1dC0zNCAzNi41dC01Mi41IDE0CnEtMzMgMCAtOTcgLTQxLjV0LTEyOSAtODMuNXQtMTAxIC00MnEtMjcgLTEgLTYzLjUgMTl0LTc2IDQ5dC04My41IDU4dC0xMDAgNDl0LTExMSAxOXEtMTE1IC0xIC0xOTcgLTc4LjV0LTg0IC0xNzguNXEtMiAtMTEyIDc0IC0xNjRxMjkgLTIwIDYyLjUgLTI4LjV0MTAzLjUgLTguNXE1NyAwIDEzMiAzMi41dDEzNCA3MXQxMjAgNzAuNXQ5MyAzMXEyNiAtMSA2NSAtMzEuNXQ3MS41IC02N3Q2OCAtNjcuNXQ1NS41IC0zMnEzNSAtMyA1OC41IDE0CnQ1NS41IDYzcTI4IDQxIDQyLjUgMTAxdDE0LjUgMTA2ek0xNTM2IDUwNnEwIC0xNjQgLTYyIC0zMDQuNXQtMTY2IC0yMzZ0LTI0Mi41IC0xNDkuNXQtMjkwLjUgLTU0dC0yOTMgNTcuNXQtMjQ3LjUgMTU3dC0xNzAuNSAyNDEuNXQtNjQgMzAycTAgODkgMTkuNSAxNzIuNXQ0OSAxNDUuNXQ3MC41IDExOC41dDc4LjUgOTR0NzguNSA2OS41dDY0LjUgNDYuNXQ0Mi41IDI0LjVxMTQgOCA1MSAyNi41dDU0LjUgMjguNXQ0OCAzMHQ2MC41IDQ0CnEzNiAyOCA1OCA3Mi41dDMwIDEyNS41cTEyOSAtMTU1IDE4NiAtMTkzcTQ0IC0yOSAxMzAgLTY4dDEyOSAtNjZxMjEgLTEzIDM5IC0yNXQ2MC41IC00Ni41dDc2IC03MC41dDc1IC05NXQ2OSAtMTIydDQ3IC0xNDguNXQxOS41IC0xNzcuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQwMCIgdW5pY29kZT0iJiN4ZjFhYTsiIApkPSJNMTA3MCA0NjNsLTE2MCAtMTYwbC0xNTEgLTE1MmwtMzAgLTMwcS02NSAtNjQgLTE1MS41IC04N3QtMTcxLjUgLTJxLTE2IC03MCAtNzIgLTExNXQtMTI5IC00NXEtODUgMCAtMTQ1IDYwLjV0LTYwIDE0NS41cTAgNzIgNDQuNSAxMjh0MTEzLjUgNzJxLTIyIDg2IDEgMTczdDg4IDE1MmwxMiAxMmwxNTEgLTE1MmwtMTEgLTExcS0zNyAtMzcgLTM3IC04OXQzNyAtOTBxMzcgLTM3IDg5IC0zN3Q4OSAzN2wzMCAzMGwxNTEgMTUybDE2MSAxNjB6Ck03MjkgMTE0NWwxMiAtMTJsLTE1MiAtMTUybC0xMiAxMnEtMzcgMzcgLTg5IDM3dC04OSAtMzd0LTM3IC04OS41dDM3IC04OS41bDI5IC0yOWwxNTIgLTE1MmwxNjAgLTE2MGwtMTUxIC0xNTJsLTE2MSAxNjBsLTE1MSAxNTJsLTMwIDMwcS02OCA2NyAtOTAgMTU5LjV0NSAxNzkuNXEtNzAgMTUgLTExNSA3MXQtNDUgMTI5cTAgODUgNjAgMTQ1LjV0MTQ1IDYwLjVxNzYgMCAxMzMuNSAtNDl0NjkuNSAtMTIzcTg0IDIwIDE2OS41IC0zLjUKdDE0OS41IC04Ny41ek0xNTM2IDc4cTAgLTg1IC02MCAtMTQ1LjV0LTE0NSAtNjAuNXEtNzQgMCAtMTMxIDQ3dC03MSAxMThxLTg2IC0yOCAtMTc5LjUgLTZ0LTE2MS41IDkwbC0xMSAxMmwxNTEgMTUybDEyIC0xMnEzNyAtMzcgODkgLTM3dDg5IDM3dDM3IDg5dC0zNyA4OWwtMzAgMzBsLTE1MiAxNTJsLTE2MCAxNjBsMTUyIDE1MmwxNjAgLTE2MGwxNTIgLTE1MmwyOSAtMzBxNjQgLTY0IDg3LjUgLTE1MC41dDIuNSAtMTcxLjUKcTc2IC0xMSAxMjYuNSAtNjguNXQ1MC41IC0xMzQuNXpNMTUzNCAxMjAycTAgLTc3IC01MSAtMTM1dC0xMjcgLTY5cTI2IC04NSAzIC0xNzYuNXQtOTAgLTE1OC41bC0xMiAtMTJsLTE1MSAxNTJsMTIgMTJxMzcgMzcgMzcgODl0LTM3IDg5dC04OSAzN3QtODkgLTM3bC0zMCAtMzBsLTE1MiAtMTUybC0xNjAgLTE2MGwtMTUyIDE1MmwxNjEgMTYwbDE1MiAxNTJsMjkgMzBxNjcgNjcgMTU5IDg5LjV0MTc4IC0zLjVxMTEgNzUgNjguNSAxMjYKdDEzNS41IDUxcTg1IDAgMTQ1IC02MC41dDYwIC0xNDUuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZjFhYiIgdW5pY29kZT0iJiN4ZjFhYjsiIApkPSJNNjU0IDQ1OHEtMSAtMyAtMTIuNSAwLjV0LTMxLjUgMTEuNWwtMjAgOXEtNDQgMjAgLTg3IDQ5cS03IDUgLTQxIDMxLjV0LTM4IDI4LjVxLTY3IC0xMDMgLTEzNCAtMTgxcS04MSAtOTUgLTEwNSAtMTEwcS00IC0yIC0xOS41IC00dC0xOC41IDBxNiA0IDgyIDkycTIxIDI0IDg1LjUgMTE1dDc4LjUgMTE4cTE3IDMwIDUxIDk4LjV0MzYgNzcuNXEtOCAxIC0xMTAgLTMzcS04IC0yIC0yNy41IC03LjV0LTM0LjUgLTkuNXQtMTcgLTUKcS0yIC0yIC0yIC0xMC41dC0xIC05LjVxLTUgLTEwIC0zMSAtMTVxLTIzIC03IC00NyAwcS0xOCA0IC0yOCAyMXEtNCA2IC01IDIzcTYgMiAyNC41IDV0MjkuNSA2cTU4IDE2IDEwNSAzMnExMDAgMzUgMTAyIDM1cTEwIDIgNDMgMTkuNXQ0NCAyMS41cTkgMyAyMS41IDh0MTQuNSA1LjV0NiAtMC41cTIgLTEyIC0xIC0zM3EwIC0yIC0xMi41IC0yN3QtMjYuNSAtNTMuNXQtMTcgLTMzLjVxLTI1IC01MCAtNzcgLTEzMWw2NCAtMjgKcTEyIC02IDc0LjUgLTMydDY3LjUgLTI4cTQgLTEgMTAuNSAtMjUuNXQ0LjUgLTMwLjV6TTQ0OSA5NDRxMyAtMTUgLTQgLTI4cS0xMiAtMjMgLTUwIC0zOHEtMzAgLTEyIC02MCAtMTJxLTI2IDMgLTQ5IDI2cS0xNCAxNSAtMTggNDFsMSAzcTMgLTMgMTkuNSAtNXQyNi41IDB0NTggMTZxMzYgMTIgNTUgMTRxMTcgMCAyMSAtMTd6TTExNDcgODE1bDYzIC0yMjdsLTEzOSA0MnpNMzkgMTVsNjk0IDIzMnYxMDMybC02OTQgLTIzM3YtMTAzMXoKTTEyODAgMzMybDEwMiAtMzFsLTE4MSA2NTdsLTEwMCAzMWwtMjE2IC01MzZsMTAyIC0zMWw0NSAxMTBsMjExIC02NXpNNzc3IDEyOTRsNTczIC0xODR2Mzgwek0xMDg4IC0yOWwxNTggLTEzbC01NCAtMTYwbC00MCA2NnEtMTMwIC04MyAtMjc2IC0xMDhxLTU4IC0xMiAtOTEgLTEyaC04NHEtNzkgMCAtMTk5LjUgMzl0LTE4My41IDg1cS04IDcgLTggMTZxMCA4IDUgMTMuNXQxMyA1LjVxNCAwIDE4IC03LjV0MzAuNSAtMTYuNXQyMC41IC0xMQpxNzMgLTM3IDE1OS41IC02MS41dDE1Ny41IC0yNC41cTk1IDAgMTY3IDE0LjV0MTU3IDUwLjVxMTUgNyAzMC41IDE1LjV0MzQgMTl0MjguNSAxNi41ek0xNTM2IDEwNTB2LTEwNzlsLTc3NCAyNDZxLTE0IC02IC0zNzUgLTEyNy41dC0zNjggLTEyMS41cS0xMyAwIC0xOCAxM3EwIDEgLTEgM3YxMDc4cTMgOSA0IDEwcTUgNiAyMCAxMXExMDcgMzYgMTQ5IDUwdjM4NGw1NTggLTE5OHEyIDAgMTYwLjUgNTV0MzE2IDEwOC41dDE2MS41IDUzLjUKcTIwIDAgMjAgLTIxdi00MTh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80MDIiIHVuaWNvZGU9IiYjeGYxYWM7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0yODggMTE1MnE2NiAwIDExMyAtNDd0NDcgLTExM3YtMTA4OHEwIC02NiAtNDcgLTExM3QtMTEzIC00N2gtMTI4cS02NiAwIC0xMTMgNDd0LTQ3IDExM3YxMDg4cTAgNjYgNDcgMTEzdDExMyA0N2gxMjh6TTE2NjQgOTg5cTU4IC0zNCA5MyAtOTN0MzUgLTEyOHYtNzY4cTAgLTEwNiAtNzUgLTE4MXQtMTgxIC03NWgtODY0cS02NiAwIC0xMTMgNDd0LTQ3IDExM3YxNTM2cTAgNDAgMjggNjh0NjggMjhoNjcycTQwIDAgODggLTIwdDc2IC00OApsMTUyIC0xNTJxMjggLTI4IDQ4IC03NnQyMCAtODh2LTE2M3pNOTI4IDB2MTI4cTAgMTQgLTkgMjN0LTIzIDloLTEyOHEtMTQgMCAtMjMgLTl0LTkgLTIzdi0xMjhxMCAtMTQgOSAtMjN0MjMgLTloMTI4cTE0IDAgMjMgOXQ5IDIzek05MjggMjU2djEyOHEwIDE0IC05IDIzdC0yMyA5aC0xMjhxLTE0IDAgLTIzIC05dC05IC0yM3YtMTI4cTAgLTE0IDkgLTIzdDIzIC05aDEyOHExNCAwIDIzIDl0OSAyM3pNOTI4IDUxMnYxMjhxMCAxNCAtOSAyMwp0LTIzIDloLTEyOHEtMTQgMCAtMjMgLTl0LTkgLTIzdi0xMjhxMCAtMTQgOSAtMjN0MjMgLTloMTI4cTE0IDAgMjMgOXQ5IDIzek0xMTg0IDB2MTI4cTAgMTQgLTkgMjN0LTIzIDloLTEyOHEtMTQgMCAtMjMgLTl0LTkgLTIzdi0xMjhxMCAtMTQgOSAtMjN0MjMgLTloMTI4cTE0IDAgMjMgOXQ5IDIzek0xMTg0IDI1NnYxMjhxMCAxNCAtOSAyM3QtMjMgOWgtMTI4cS0xNCAwIC0yMyAtOXQtOSAtMjN2LTEyOHEwIC0xNCA5IC0yM3QyMyAtOWgxMjgKcTE0IDAgMjMgOXQ5IDIzek0xMTg0IDUxMnYxMjhxMCAxNCAtOSAyM3QtMjMgOWgtMTI4cS0xNCAwIC0yMyAtOXQtOSAtMjN2LTEyOHEwIC0xNCA5IC0yM3QyMyAtOWgxMjhxMTQgMCAyMyA5dDkgMjN6TTE0NDAgMHYxMjhxMCAxNCAtOSAyM3QtMjMgOWgtMTI4cS0xNCAwIC0yMyAtOXQtOSAtMjN2LTEyOHEwIC0xNCA5IC0yM3QyMyAtOWgxMjhxMTQgMCAyMyA5dDkgMjN6TTE0NDAgMjU2djEyOHEwIDE0IC05IDIzdC0yMyA5aC0xMjgKcS0xNCAwIC0yMyAtOXQtOSAtMjN2LTEyOHEwIC0xNCA5IC0yM3QyMyAtOWgxMjhxMTQgMCAyMyA5dDkgMjN6TTE0NDAgNTEydjEyOHEwIDE0IC05IDIzdC0yMyA5aC0xMjhxLTE0IDAgLTIzIC05dC05IC0yM3YtMTI4cTAgLTE0IDkgLTIzdDIzIC05aDEyOHExNCAwIDIzIDl0OSAyM3pNMTUzNiA4OTZ2MjU2aC0xNjBxLTQwIDAgLTY4IDI4dC0yOCA2OHYxNjBoLTY0MHYtNTEyaDg5NnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQwMyIgdW5pY29kZT0iJiN4ZjFhZDsiIApkPSJNMTM0NCAxNTM2cTI2IDAgNDUgLTE5dDE5IC00NXYtMTY2NHEwIC0yNiAtMTkgLTQ1dC00NSAtMTloLTEyODBxLTI2IDAgLTQ1IDE5dC0xOSA0NXYxNjY0cTAgMjYgMTkgNDV0NDUgMTloMTI4MHpNNTEyIDEyNDh2LTY0cTAgLTE0IDkgLTIzdDIzIC05aDY0cTE0IDAgMjMgOXQ5IDIzdjY0cTAgMTQgLTkgMjN0LTIzIDloLTY0cS0xNCAwIC0yMyAtOXQtOSAtMjN6TTUxMiA5OTJ2LTY0cTAgLTE0IDkgLTIzdDIzIC05aDY0cTE0IDAgMjMgOQp0OSAyM3Y2NHEwIDE0IC05IDIzdC0yMyA5aC02NHEtMTQgMCAtMjMgLTl0LTkgLTIzek01MTIgNzM2di02NHEwIC0xNCA5IC0yM3QyMyAtOWg2NHExNCAwIDIzIDl0OSAyM3Y2NHEwIDE0IC05IDIzdC0yMyA5aC02NHEtMTQgMCAtMjMgLTl0LTkgLTIzek01MTIgNDgwdi02NHEwIC0xNCA5IC0yM3QyMyAtOWg2NHExNCAwIDIzIDl0OSAyM3Y2NHEwIDE0IC05IDIzdC0yMyA5aC02NHEtMTQgMCAtMjMgLTl0LTkgLTIzek0zODQgMTYwdjY0CnEwIDE0IC05IDIzdC0yMyA5aC02NHEtMTQgMCAtMjMgLTl0LTkgLTIzdi02NHEwIC0xNCA5IC0yM3QyMyAtOWg2NHExNCAwIDIzIDl0OSAyM3pNMzg0IDQxNnY2NHEwIDE0IC05IDIzdC0yMyA5aC02NHEtMTQgMCAtMjMgLTl0LTkgLTIzdi02NHEwIC0xNCA5IC0yM3QyMyAtOWg2NHExNCAwIDIzIDl0OSAyM3pNMzg0IDY3MnY2NHEwIDE0IC05IDIzdC0yMyA5aC02NHEtMTQgMCAtMjMgLTl0LTkgLTIzdi02NHEwIC0xNCA5IC0yM3QyMyAtOWg2NApxMTQgMCAyMyA5dDkgMjN6TTM4NCA5Mjh2NjRxMCAxNCAtOSAyM3QtMjMgOWgtNjRxLTE0IDAgLTIzIC05dC05IC0yM3YtNjRxMCAtMTQgOSAtMjN0MjMgLTloNjRxMTQgMCAyMyA5dDkgMjN6TTM4NCAxMTg0djY0cTAgMTQgLTkgMjN0LTIzIDloLTY0cS0xNCAwIC0yMyAtOXQtOSAtMjN2LTY0cTAgLTE0IDkgLTIzdDIzIC05aDY0cTE0IDAgMjMgOXQ5IDIzek04OTYgLTk2djE5MnEwIDE0IC05IDIzdC0yMyA5aC0zMjBxLTE0IDAgLTIzIC05CnQtOSAtMjN2LTE5MnEwIC0xNCA5IC0yM3QyMyAtOWgzMjBxMTQgMCAyMyA5dDkgMjN6TTg5NiA0MTZ2NjRxMCAxNCAtOSAyM3QtMjMgOWgtNjRxLTE0IDAgLTIzIC05dC05IC0yM3YtNjRxMCAtMTQgOSAtMjN0MjMgLTloNjRxMTQgMCAyMyA5dDkgMjN6TTg5NiA2NzJ2NjRxMCAxNCAtOSAyM3QtMjMgOWgtNjRxLTE0IDAgLTIzIC05dC05IC0yM3YtNjRxMCAtMTQgOSAtMjN0MjMgLTloNjRxMTQgMCAyMyA5dDkgMjN6TTg5NiA5Mjh2NjQKcTAgMTQgLTkgMjN0LTIzIDloLTY0cS0xNCAwIC0yMyAtOXQtOSAtMjN2LTY0cTAgLTE0IDkgLTIzdDIzIC05aDY0cTE0IDAgMjMgOXQ5IDIzek04OTYgMTE4NHY2NHEwIDE0IC05IDIzdC0yMyA5aC02NHEtMTQgMCAtMjMgLTl0LTkgLTIzdi02NHEwIC0xNCA5IC0yM3QyMyAtOWg2NHExNCAwIDIzIDl0OSAyM3pNMTE1MiAxNjB2NjRxMCAxNCAtOSAyM3QtMjMgOWgtNjRxLTE0IDAgLTIzIC05dC05IC0yM3YtNjRxMCAtMTQgOSAtMjN0MjMgLTloNjQKcTE0IDAgMjMgOXQ5IDIzek0xMTUyIDQxNnY2NHEwIDE0IC05IDIzdC0yMyA5aC02NHEtMTQgMCAtMjMgLTl0LTkgLTIzdi02NHEwIC0xNCA5IC0yM3QyMyAtOWg2NHExNCAwIDIzIDl0OSAyM3pNMTE1MiA2NzJ2NjRxMCAxNCAtOSAyM3QtMjMgOWgtNjRxLTE0IDAgLTIzIC05dC05IC0yM3YtNjRxMCAtMTQgOSAtMjN0MjMgLTloNjRxMTQgMCAyMyA5dDkgMjN6TTExNTIgOTI4djY0cTAgMTQgLTkgMjN0LTIzIDloLTY0cS0xNCAwIC0yMyAtOQp0LTkgLTIzdi02NHEwIC0xNCA5IC0yM3QyMyAtOWg2NHExNCAwIDIzIDl0OSAyM3pNMTE1MiAxMTg0djY0cTAgMTQgLTkgMjN0LTIzIDloLTY0cS0xNCAwIC0yMyAtOXQtOSAtMjN2LTY0cTAgLTE0IDkgLTIzdDIzIC05aDY0cTE0IDAgMjMgOXQ5IDIzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDA0IiB1bmljb2RlPSImI3hmMWFlOyIgaG9yaXotYWR2LXg9IjEyODAiIApkPSJNMTE4OCA5ODhsLTI5MiAtMjkydi04MjRxMCAtNDYgLTMzIC03OXQtNzkgLTMzdC03OSAzM3QtMzMgNzl2Mzg0aC02NHYtMzg0cTAgLTQ2IC0zMyAtNzl0LTc5IC0zM3QtNzkgMzN0LTMzIDc5djgyNGwtMjkyIDI5MnEtMjggMjggLTI4IDY4dDI4IDY4cTI5IDI4IDY4LjUgMjh0NjcuNSAtMjhsMjI4IC0yMjhoMzY4bDIyOCAyMjhxMjggMjggNjggMjh0NjggLTI4cTI4IC0yOSAyOCAtNjguNXQtMjggLTY3LjV6TTg2NCAxMTUyCnEwIC05MyAtNjUuNSAtMTU4LjV0LTE1OC41IC02NS41dC0xNTguNSA2NS41dC02NS41IDE1OC41dDY1LjUgMTU4LjV0MTU4LjUgNjUuNXQxNTguNSAtNjUuNXQ2NS41IC0xNTguNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjFCMSIgdW5pY29kZT0iJiN4ZjFiMDsiIGhvcml6LWFkdi14PSIxNjY0IiAKZD0iTTc4MCAxMDY0cTAgLTYwIC0xOSAtMTEzLjV0LTYzIC05Mi41dC0xMDUgLTM5cS03NiAwIC0xMzggNTcuNXQtOTIgMTM1LjV0LTMwIDE1MXEwIDYwIDE5IDExMy41dDYzIDkyLjV0MTA1IDM5cTc3IDAgMTM4LjUgLTU3LjV0OTEuNSAtMTM1dDMwIC0xNTEuNXpNNDM4IDU4MXEwIC04MCAtNDIgLTEzOXQtMTE5IC01OXEtNzYgMCAtMTQxLjUgNTUuNXQtMTAwLjUgMTMzLjV0LTM1IDE1MnEwIDgwIDQyIDEzOS41dDExOSA1OS41CnE3NiAwIDE0MS41IC01NS41dDEwMC41IC0xMzR0MzUgLTE1Mi41ek04MzIgNjA4cTExOCAwIDI1NSAtOTcuNXQyMjkgLTIzN3Q5MiAtMjU0LjVxMCAtNDYgLTE3IC03Ni41dC00OC41IC00NXQtNjQuNSAtMjB0LTc2IC01LjVxLTY4IDAgLTE4Ny41IDQ1dC0xODIuNSA0NXEtNjYgMCAtMTkyLjUgLTQ0LjV0LTIwMC41IC00NC41cS0xODMgMCAtMTgzIDE0NnEwIDg2IDU2IDE5MS41dDEzOS41IDE5Mi41dDE4Ny41IDE0NnQxOTMgNTl6TTEwNzEgODE5CnEtNjEgMCAtMTA1IDM5dC02MyA5Mi41dC0xOSAxMTMuNXEwIDc0IDMwIDE1MS41dDkxLjUgMTM1dDEzOC41IDU3LjVxNjEgMCAxMDUgLTM5dDYzIC05Mi41dDE5IC0xMTMuNXEwIC03MyAtMzAgLTE1MXQtOTIgLTEzNS41dC0xMzggLTU3LjV6TTE1MDMgOTIzcTc3IDAgMTE5IC01OS41dDQyIC0xMzkuNXEwIC03NCAtMzUgLTE1MnQtMTAwLjUgLTEzMy41dC0xNDEuNSAtNTUuNXEtNzcgMCAtMTE5IDU5dC00MiAxMzlxMCA3NCAzNSAxNTIuNQp0MTAwLjUgMTM0dDE0MS41IDU1LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80MDYiIHVuaWNvZGU9IiYjeGYxYjE7IiBob3Jpei1hZHYteD0iNzY4IiAKZD0iTTcwNCAxMDA4cTAgLTE0NSAtNTcgLTI0My41dC0xNTIgLTEzNS41bDQ1IC04MjFxMiAtMjYgLTE2IC00NXQtNDQgLTE5aC0xOTJxLTI2IDAgLTQ0IDE5dC0xNiA0NWw0NSA4MjFxLTk1IDM3IC0xNTIgMTM1LjV0LTU3IDI0My41cTAgMTI4IDQyLjUgMjQ5LjV0MTE3LjUgMjAwdDE2MCA3OC41dDE2MCAtNzguNXQxMTcuNSAtMjAwdDQyLjUgLTI0OS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDA3IiB1bmljb2RlPSImI3hmMWIyOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNODk2IC05M2w2NDAgMzQ5djYzNmwtNjQwIC0yMzN2LTc1MnpNODMyIDc3Mmw2OTggMjU0bC02OTggMjU0bC02OTggLTI1NHpNMTY2NCAxMDI0di03NjhxMCAtMzUgLTE4IC02NXQtNDkgLTQ3bC03MDQgLTM4NHEtMjggLTE2IC02MSAtMTZ0LTYxIDE2bC03MDQgMzg0cS0zMSAxNyAtNDkgNDd0LTE4IDY1djc2OHEwIDQwIDIzIDczdDYxIDQ3bDcwNCAyNTZxMjIgOCA0NCA4dDQ0IC04bDcwNCAtMjU2cTM4IC0xNCA2MSAtNDd0MjMgLTczegoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQwOCIgdW5pY29kZT0iJiN4ZjFiMzsiIGhvcml6LWFkdi14PSIyMzA0IiAKZD0iTTY0MCAtOTZsMzg0IDE5MnYzMTRsLTM4NCAtMTY0di0zNDJ6TTU3NiAzNThsNDA0IDE3M2wtNDA0IDE3M2wtNDA0IC0xNzN6TTE2NjQgLTk2bDM4NCAxOTJ2MzE0bC0zODQgLTE2NHYtMzQyek0xNjAwIDM1OGw0MDQgMTczbC00MDQgMTczbC00MDQgLTE3M3pNMTE1MiA2NTFsMzg0IDE2NXYyNjZsLTM4NCAtMTY0di0yNjd6TTEwODggMTAzMGw0NDEgMTg5bC00NDEgMTg5bC00NDEgLTE4OXpNMjE3NiA1MTJ2LTQxNnEwIC0zNiAtMTkgLTY3CnQtNTIgLTQ3bC00NDggLTIyNHEtMjUgLTE0IC01NyAtMTR0LTU3IDE0bC00NDggMjI0cS00IDIgLTcgNHEtMiAtMiAtNyAtNGwtNDQ4IC0yMjRxLTI1IC0xNCAtNTcgLTE0dC01NyAxNGwtNDQ4IDIyNHEtMzMgMTYgLTUyIDQ3dC0xOSA2N3Y0MTZxMCAzOCAyMS41IDcwdDU2LjUgNDhsNDM0IDE4NnY0MDBxMCAzOCAyMS41IDcwdDU2LjUgNDhsNDQ4IDE5MnEyMyAxMCA1MCAxMHQ1MCAtMTBsNDQ4IC0xOTJxMzUgLTE2IDU2LjUgLTQ4dDIxLjUgLTcwCnYtNDAwbDQzNCAtMTg2cTM2IC0xNiA1NyAtNDh0MjEgLTcweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDA5IiB1bmljb2RlPSImI3hmMWI0OyIgaG9yaXotYWR2LXg9IjIwNDgiIApkPSJNMTg0OCAxMTk3aC01MTF2LTEyNGg1MTF2MTI0ek0xNTk2IDc3MXEtOTAgMCAtMTQ2IC01Mi41dC02MiAtMTQyLjVoNDA4cS0xOCAxOTUgLTIwMCAxOTV6TTE2MTIgMTg2cTYzIDAgMTIyIDMydDc2IDg3aDIyMXEtMTAwIC0zMDcgLTQyNyAtMzA3cS0yMTQgMCAtMzQwLjUgMTMydC0xMjYuNSAzNDdxMCAyMDggMTMwLjUgMzQ1LjV0MzM2LjUgMTM3LjVxMTM4IDAgMjQwLjUgLTY4dDE1MyAtMTc5dDUwLjUgLTI0OHEwIC0xNyAtMiAtNDdoLTY1OApxMCAtMTExIDU3LjUgLTE3MS41dDE2Ni41IC02MC41ek0yNzcgMjM2aDI5NnEyMDUgMCAyMDUgMTY3cTAgMTgwIC0xOTkgMTgwaC0zMDJ2LTM0N3pNMjc3IDc3M2gyODFxNzggMCAxMjMuNSAzNi41dDQ1LjUgMTEzLjVxMCAxNDQgLTE5MCAxNDRoLTI2MHYtMjk0ek0wIDEyODJoNTk0cTg3IDAgMTU1IC0xNHQxMjYuNSAtNDcuNXQ5MCAtOTYuNXQzMS41IC0xNTRxMCAtMTgxIC0xNzIgLTI2M3ExMTQgLTMyIDE3MiAtMTE1dDU4IC0yMDQKcTAgLTc1IC0yNC41IC0xMzYuNXQtNjYgLTEwMy41dC05OC41IC03MXQtMTIxIC00MnQtMTM0IC0xM2gtNjExdjEyNjB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80MTAiIHVuaWNvZGU9IiYjeGYxYjU7IiAKZD0iTTEyNDggMTQwOHExMTkgMCAyMDMuNSAtODQuNXQ4NC41IC0yMDMuNXYtOTYwcTAgLTExOSAtODQuNSAtMjAzLjV0LTIwMy41IC04NC41aC05NjBxLTExOSAwIC0yMDMuNSA4NC41dC04NC41IDIwMy41djk2MHEwIDExOSA4NC41IDIwMy41dDIwMy41IDg0LjVoOTYwek00OTkgMTA0MWgtMzcxdi03ODdoMzgycTExNyAwIDE5NyA1Ny41dDgwIDE3MC41cTAgMTU4IC0xNDMgMjAwcTEwNyA1MiAxMDcgMTY0cTAgNTcgLTE5LjUgOTYuNQp0LTU2LjUgNjAuNXQtNzkgMjkuNXQtOTcgOC41ek00NzcgNzIzaC0xNzZ2MTg0aDE2M3ExMTkgMCAxMTkgLTkwcTAgLTk0IC0xMDYgLTk0ek00ODYgMzg4aC0xODV2MjE3aDE4OXExMjQgMCAxMjQgLTExM3EwIC0xMDQgLTEyOCAtMTA0ek0xMTM2IDM1NnEtNjggMCAtMTA0IDM4dC0zNiAxMDdoNDExcTEgMTAgMSAzMHEwIDEzMiAtNzQuNSAyMjAuNXQtMjAzLjUgODguNXEtMTI4IDAgLTIxMCAtODZ0LTgyIC0yMTZxMCAtMTM1IDc5IC0yMTcKdDIxMyAtODJxMjA1IDAgMjY3IDE5MWgtMTM4cS0xMSAtMzQgLTQ3LjUgLTU0dC03NS41IC0yMHpNMTEyNiA3MjJxMTEzIDAgMTI0IC0xMjJoLTI1NHE0IDU2IDM5IDg5dDkxIDMzek05NjQgOTg4aDMxOXYtNzdoLTMxOXY3N3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQxMSIgdW5pY29kZT0iJiN4ZjFiNjsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE1ODIgOTU0cTAgLTEwMSAtNzEuNSAtMTcyLjV0LTE3Mi41IC03MS41dC0xNzIuNSA3MS41dC03MS41IDE3Mi41dDcxLjUgMTcyLjV0MTcyLjUgNzEuNXQxNzIuNSAtNzEuNXQ3MS41IC0xNzIuNXpNODEyIDIxMnEwIDEwNCAtNzMgMTc3dC0xNzcgNzNxLTI3IDAgLTU0IC02bDEwNCAtNDJxNzcgLTMxIDEwOS41IC0xMDYuNXQxLjUgLTE1MS41cS0zMSAtNzcgLTEwNyAtMTA5dC0xNTIgLTFxLTIxIDggLTYyIDI0LjV0LTYxIDI0LjUKcTMyIC02MCA5MSAtOTYuNXQxMzAgLTM2LjVxMTA0IDAgMTc3IDczdDczIDE3N3pNMTY0MiA5NTNxMCAxMjYgLTg5LjUgMjE1LjV0LTIxNS41IDg5LjVxLTEyNyAwIC0yMTYuNSAtODkuNXQtODkuNSAtMjE1LjVxMCAtMTI3IDg5LjUgLTIxNnQyMTYuNSAtODlxMTI2IDAgMjE1LjUgODl0ODkuNSAyMTZ6TTE3OTIgOTUzcTAgLTE4OSAtMTMzLjUgLTMyMnQtMzIxLjUgLTEzM2wtNDM3IC0zMTlxLTEyIC0xMjkgLTEwOSAtMjE4dC0yMjkgLTg5CnEtMTIxIDAgLTIxNCA3NnQtMTE4IDE5MmwtMjMwIDkydjQyOWwzODkgLTE1N3E3OSA0OCAxNzMgNDhxMTMgMCAzNSAtMmwyODQgNDA3cTIgMTg3IDEzNS41IDMxOXQzMjAuNSAxMzJxMTg4IDAgMzIxLjUgLTEzMy41dDEzMy41IC0zMjEuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQxMiIgdW5pY29kZT0iJiN4ZjFiNzsiIApkPSJNMTI0MiA4ODlxMCA4MCAtNTcgMTM2LjV0LTEzNyA1Ni41dC0xMzYuNSAtNTd0LTU2LjUgLTEzNnEwIC04MCA1Ni41IC0xMzYuNXQxMzYuNSAtNTYuNXQxMzcgNTYuNXQ1NyAxMzYuNXpNNjMyIDMwMXEwIC04MyAtNTggLTE0MC41dC0xNDAgLTU3LjVxLTU2IDAgLTEwMyAyOXQtNzIgNzdxNTIgLTIwIDk4IC00MHE2MCAtMjQgMTIwIDEuNXQ4NSA4Ni41cTI0IDYwIC0xLjUgMTIwdC04Ni41IDg0bC04MiAzM3EyMiA1IDQyIDUKcTgyIDAgMTQwIC01Ny41dDU4IC0xNDAuNXpNMTUzNiAxMTIwdi05NjBxMCAtMTE5IC04NC41IC0yMDMuNXQtMjAzLjUgLTg0LjVoLTk2MHEtMTE5IDAgLTIwMy41IDg0LjV0LTg0LjUgMjAzLjV2MTUzbDE3MiAtNjlxMjAgLTkyIDkzLjUgLTE1MnQxNjguNSAtNjBxMTA0IDAgMTgxIDcwdDg3IDE3M2wzNDUgMjUycTE1MCAwIDI1NS41IDEwNS41dDEwNS41IDI1NC41cTAgMTUwIC0xMDUuNSAyNTUuNXQtMjU1LjUgMTA1LjUKcS0xNDggMCAtMjUzIC0xMDQuNXQtMTA3IC0yNTIuNWwtMjI1IC0zMjJxLTkgMSAtMjggMXEtNzUgMCAtMTM3IC0zN2wtMjk3IDExOXY0NjhxMCAxMTkgODQuNSAyMDMuNXQyMDMuNSA4NC41aDk2MHExMTkgMCAyMDMuNSAtODQuNXQ4NC41IC0yMDMuNXpNMTI4OSA4ODdxMCAtMTAwIC03MSAtMTcwLjV0LTE3MSAtNzAuNXQtMTcwLjUgNzAuNXQtNzAuNSAxNzAuNXQ3MC41IDE3MXQxNzAuNSA3MXExMDEgMCAxNzEuNSAtNzAuNXQ3MC41IC0xNzEuNXoKIiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80MTMiIHVuaWNvZGU9IiYjeGYxYjg7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik04MzYgMzY3bC0xNSAtMzY4bC0yIC0yMmwtNDIwIDI5cS0zNiAzIC02NyAzMS41dC00NyA2NS41cS0xMSAyNyAtMTQuNSA1NXQ0IDY1dDEyIDU1dDIxLjUgNjR0MTkgNTNxNzggLTEyIDUwOSAtMjh6TTQ0OSA5NTNsMTgwIC0zNzlsLTE0NyA5MnEtNjMgLTcyIC0xMTEuNSAtMTQ0LjV0LTcyLjUgLTEyNXQtMzkuNSAtOTQuNXQtMTguNSAtNjNsLTQgLTIxbC0xOTAgMzU3cS0xNyAyNiAtMTggNTZ0NiA0N2w4IDE4cTM1IDYzIDExNCAxODgKbC0xNDAgODZ6TTE2ODAgNDM2bC0xODggLTM1OXEtMTIgLTI5IC0zNi41IC00Ni41dC00My41IC0yMC41bC0xOCAtNHEtNzEgLTcgLTIxOSAtMTJsOCAtMTY0bC0yMzAgMzY3bDIxMSAzNjJsNyAtMTczcTE3MCAtMTYgMjgzIC01dDE3MCAzM3pNODk1IDEzNjBxLTQ3IC02MyAtMjY1IC00MzVsLTMxNyAxODdsLTE5IDEybDIyNSAzNTZxMjAgMzEgNjAgNDV0ODAgMTBxMjQgLTIgNDguNSAtMTJ0NDIgLTIxdDQxLjUgLTMzdDM2IC0zNC41CnQzNiAtMzkuNXQzMiAtMzV6TTE1NTAgMTA1M2wyMTIgLTM2M3ExOCAtMzcgMTIuNSAtNzZ0LTI3LjUgLTc0cS0xMyAtMjAgLTMzIC0zN3QtMzggLTI4dC00OC41IC0yMnQtNDcgLTE2dC01MS41IC0xNHQtNDYgLTEycS0zNCA3MiAtMjY1IDQzNmwzMTMgMTk1ek0xNDA3IDEyNzlsMTQyIDgzbC0yMjAgLTM3M2wtNDE5IDIwbDE1MSA4NnEtMzQgODkgLTc1IDE2NnQtNzUuNSAxMjMuNXQtNjQuNSA4MHQtNDcgNDYuNWwtMTcgMTNsNDA1IC0xCnEzMSAzIDU4IC0xMC41dDM5IC0yOC41bDExIC0xNXEzOSAtNjEgMTEyIC0xOTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80MTQiIHVuaWNvZGU9IiYjeGYxYjk7IiBob3Jpei1hZHYteD0iMjA0OCIgCmQ9Ik00ODAgNDQ4cTAgNjYgLTQ3IDExM3QtMTEzIDQ3dC0xMTMgLTQ3dC00NyAtMTEzdDQ3IC0xMTN0MTEzIC00N3QxMTMgNDd0NDcgMTEzek01MTYgNzY4aDEwMTZsLTg5IDM1N3EtMiA4IC0xNCAxNy41dC0yMSA5LjVoLTc2OHEtOSAwIC0yMSAtOS41dC0xNCAtMTcuNXpNMTg4OCA0NDhxMCA2NiAtNDcgMTEzdC0xMTMgNDd0LTExMyAtNDd0LTQ3IC0xMTN0NDcgLTExM3QxMTMgLTQ3dDExMyA0N3Q0NyAxMTN6TTIwNDggNTQ0di0zODQKcTAgLTE0IC05IC0yM3QtMjMgLTloLTk2di0xMjhxMCAtODAgLTU2IC0xMzZ0LTEzNiAtNTZ0LTEzNiA1NnQtNTYgMTM2djEyOGgtMTAyNHYtMTI4cTAgLTgwIC01NiAtMTM2dC0xMzYgLTU2dC0xMzYgNTZ0LTU2IDEzNnYxMjhoLTk2cS0xNCAwIC0yMyA5dC05IDIzdjM4NHEwIDkzIDY1LjUgMTU4LjV0MTU4LjUgNjUuNWgyOGwxMDUgNDE5cTIzIDk0IDEwNCAxNTcuNXQxNzkgNjMuNWg3NjhxOTggMCAxNzkgLTYzLjV0MTA0IC0xNTcuNQpsMTA1IC00MTloMjhxOTMgMCAxNTguNSAtNjUuNXQ2NS41IC0xNTguNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQxNSIgdW5pY29kZT0iJiN4ZjFiYTsiIGhvcml6LWFkdi14PSIyMDQ4IiAKZD0iTTE4MjQgNjQwcTkzIDAgMTU4LjUgLTY1LjV0NjUuNSAtMTU4LjV2LTM4NHEwIC0xNCAtOSAtMjN0LTIzIC05aC05NnYtNjRxMCAtODAgLTU2IC0xMzZ0LTEzNiAtNTZ0LTEzNiA1NnQtNTYgMTM2djY0aC0xMDI0di02NHEwIC04MCAtNTYgLTEzNnQtMTM2IC01NnQtMTM2IDU2dC01NiAxMzZ2NjRoLTk2cS0xNCAwIC0yMyA5dC05IDIzdjM4NHEwIDkzIDY1LjUgMTU4LjV0MTU4LjUgNjUuNWgyOGwxMDUgNDE5cTIzIDk0IDEwNCAxNTcuNQp0MTc5IDYzLjVoMTI4djIyNHEwIDE0IDkgMjN0MjMgOWg0NDhxMTQgMCAyMyAtOXQ5IC0yM3YtMjI0aDEyOHE5OCAwIDE3OSAtNjMuNXQxMDQgLTE1Ny41bDEwNSAtNDE5aDI4ek0zMjAgMTYwcTY2IDAgMTEzIDQ3dDQ3IDExM3QtNDcgMTEzdC0xMTMgNDd0LTExMyAtNDd0LTQ3IC0xMTN0NDcgLTExM3QxMTMgLTQ3ek01MTYgNjQwaDEwMTZsLTg5IDM1N3EtMiA4IC0xNCAxNy41dC0yMSA5LjVoLTc2OHEtOSAwIC0yMSAtOS41dC0xNCAtMTcuNXoKTTE3MjggMTYwcTY2IDAgMTEzIDQ3dDQ3IDExM3QtNDcgMTEzdC0xMTMgNDd0LTExMyAtNDd0LTQ3IC0xMTN0NDcgLTExM3QxMTMgLTQ3eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDE2IiB1bmljb2RlPSImI3hmMWJiOyIgCmQ9Ik0xNTA0IDY0cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtNDYycTEgLTE3IDYgLTg3LjV0NSAtMTA4LjVxMCAtMjUgLTE4IC00Mi41dC00MyAtMTcuNWgtMzIwcS0yNSAwIC00MyAxNy41dC0xOCA0Mi41cTAgMzggNSAxMDguNXQ2IDg3LjVoLTQ2MnEtMjYgMCAtNDUgMTl0LTE5IDQ1dDE5IDQ1bDQwMiA0MDNoLTIyOXEtMjYgMCAtNDUgMTl0LTE5IDQ1dDE5IDQ1bDQwMiA0MDNoLTE5N3EtMjYgMCAtNDUgMTl0LTE5IDQ1dDE5IDQ1bDM4NCAzODQKcTE5IDE5IDQ1IDE5dDQ1IC0xOWwzODQgLTM4NHExOSAtMTkgMTkgLTQ1dC0xOSAtNDV0LTQ1IC0xOWgtMTk3bDQwMiAtNDAzcTE5IC0xOSAxOSAtNDV0LTE5IC00NXQtNDUgLTE5aC0yMjlsNDAyIC00MDNxMTkgLTE5IDE5IC00NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQxNyIgdW5pY29kZT0iJiN4ZjFiYzsiIApkPSJNMTEyNyAzMjZxMCAzMiAtMzAgNTFxLTE5MyAxMTUgLTQ0NyAxMTVxLTEzMyAwIC0yODcgLTM0cS00MiAtOSAtNDIgLTUycTAgLTIwIDEzLjUgLTM0LjV0MzUuNSAtMTQuNXE1IDAgMzcgOHExMzIgMjcgMjQzIDI3cTIyNiAwIDM5NyAtMTAzcTE5IC0xMSAzMyAtMTFxMTkgMCAzMyAxMy41dDE0IDM0LjV6TTEyMjMgNTQxcTAgNDAgLTM1IDYxcS0yMzcgMTQxIC01NDggMTQxcS0xNTMgMCAtMzAzIC00MnEtNDggLTEzIC00OCAtNjQKcTAgLTI1IDE3LjUgLTQyLjV0NDIuNSAtMTcuNXE3IDAgMzcgOHExMjIgMzMgMjUxIDMzcTI3OSAwIDQ4OCAtMTI0cTI0IC0xMyAzOCAtMTNxMjUgMCA0Mi41IDE3LjV0MTcuNSA0Mi41ek0xMzMxIDc4OXEwIDQ3IC00MCA3MHEtMTI2IDczIC0yOTMgMTEwLjV0LTM0MyAzNy41cS0yMDQgMCAtMzY0IC00N3EtMjMgLTcgLTM4LjUgLTI1LjV0LTE1LjUgLTQ4LjVxMCAtMzEgMjAuNSAtNTJ0NTEuNSAtMjFxMTEgMCA0MCA4cTEzMyAzNyAzMDcgMzcKcTE1OSAwIDMwOS41IC0zNHQyNTMuNSAtOTVxMjEgLTEyIDQwIC0xMnEyOSAwIDUwLjUgMjAuNXQyMS41IDUxLjV6TTE1MzYgNjQwcTAgLTIwOSAtMTAzIC0zODUuNXQtMjc5LjUgLTI3OS41dC0zODUuNSAtMTAzdC0zODUuNSAxMDN0LTI3OS41IDI3OS41dC0xMDMgMzg1LjV0MTAzIDM4NS41dDI3OS41IDI3OS41dDM4NS41IDEwM3QzODUuNSAtMTAzdDI3OS41IC0yNzkuNXQxMDMgLTM4NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDE4IiB1bmljb2RlPSImI3hmMWJkOyIgaG9yaXotYWR2LXg9IjEwMjQiIApkPSJNMTAyNCAxMjMzbC0zMDMgLTU4MmwyNCAtMzFoMjc5di00MTVoLTUwN2wtNDQgLTMwbC0xNDIgLTI3M2wtMzAgLTMwaC0zMDF2MzAzbDMwMyA1ODNsLTI0IDMwaC0yNzl2NDE1aDUwN2w0NCAzMGwxNDIgMjczbDMwIDMwaDMwMXYtMzAzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDE5IiB1bmljb2RlPSImI3hmMWJlOyIgaG9yaXotYWR2LXg9IjIzMDQiIApkPSJNNzg0IDE2NGwxNiAyNDFsLTE2IDUyM3EtMSAxMCAtNy41IDE3dC0xNi41IDdxLTkgMCAtMTYgLTd0LTcgLTE3bC0xNCAtNTIzbDE0IC0yNDFxMSAtMTAgNy41IC0xNi41dDE1LjUgLTYuNXEyMiAwIDI0IDIzek0xMDgwIDE5M2wxMSAyMTFsLTEyIDU4NnEwIDE2IC0xMyAyNHEtOCA1IC0xNiA1dC0xNiAtNXEtMTMgLTggLTEzIC0yNGwtMSAtNmwtMTAgLTU3OXEwIC0xIDExIC0yMzZ2LTFxMCAtMTAgNiAtMTdxOSAtMTEgMjMgLTExCnExMSAwIDIwIDlxOSA3IDkgMjB6TTM1IDUzM2wyMCAtMTI4bC0yMCAtMTI2cS0yIC05IC05IC05dC05IDlsLTE3IDEyNmwxNyAxMjhxMiA5IDkgOXQ5IC05ek0xMjEgNjEybDI2IC0yMDdsLTI2IC0yMDNxLTIgLTkgLTEwIC05cS05IDAgLTkgMTBsLTIzIDIwMmwyMyAyMDdxMCA5IDkgOXE4IDAgMTAgLTl6TTQwMSAxNTl6TTIxMyA2NTBsMjUgLTI0NWwtMjUgLTIzN3EwIC0xMSAtMTEgLTExcS0xMCAwIC0xMiAxMWwtMjEgMjM3bDIxIDI0NQpxMiAxMiAxMiAxMnExMSAwIDExIC0xMnpNMzA3IDY1N2wyMyAtMjUybC0yMyAtMjQ0cS0yIC0xMyAtMTQgLTEzcS0xMyAwIC0xMyAxM2wtMjEgMjQ0bDIxIDI1MnEwIDEzIDEzIDEzcTEyIDAgMTQgLTEzek00MDEgNjM5bDIxIC0yMzRsLTIxIC0yNDZxLTIgLTE2IC0xNiAtMTZxLTYgMCAtMTAuNSA0LjV0LTQuNSAxMS41bC0yMCAyNDZsMjAgMjM0cTAgNiA0LjUgMTAuNXQxMC41IDQuNXExNCAwIDE2IC0xNXpNNzg0IDE2NHpNNDk1IDc4NQpsMjEgLTM4MGwtMjEgLTI0NnEwIC03IC01IC0xMi41dC0xMiAtNS41cS0xNiAwIC0xOCAxOGwtMTggMjQ2bDE4IDM4MHEyIDE4IDE4IDE4cTcgMCAxMiAtNS41dDUgLTEyLjV6TTU4OSA4NzFsMTkgLTQ2OGwtMTkgLTI0NHEwIC04IC01LjUgLTEzLjV0LTEzLjUgLTUuNXEtMTggMCAtMjAgMTlsLTE2IDI0NGwxNiA0NjhxMiAxOSAyMCAxOXE4IDAgMTMuNSAtNS41dDUuNSAtMTMuNXpNNjg3IDkxMWwxOCAtNTA2bC0xOCAtMjQyCnEtMiAtMjEgLTIyIC0yMXEtMTkgMCAtMjEgMjFsLTE2IDI0MmwxNiA1MDZxMCA5IDYuNSAxNS41dDE0LjUgNi41cTkgMCAxNSAtNi41dDcgLTE1LjV6TTEwNzkgMTY5djB2MHYwek04ODEgOTE1bDE1IC01MTBsLTE1IC0yMzlxMCAtMTAgLTcuNSAtMTcuNXQtMTcuNSAtNy41dC0xNyA3dC04IDE4bC0xNCAyMzlsMTQgNTEwcTAgMTEgNy41IDE4dDE3LjUgN3QxNy41IC03dDcuNSAtMTh6TTk4MCA4OTZsMTQgLTQ5MmwtMTQgLTIzNgpxMCAtMTEgLTggLTE5dC0xOSAtOHQtMTkgOHQtOSAxOWwtMTIgMjM2bDEyIDQ5MnExIDEyIDkgMjB0MTkgOHQxOC41IC04dDguNSAtMjB6TTExOTIgNDA0bC0xNCAtMjMxdjBxMCAtMTMgLTkgLTIydC0yMiAtOXQtMjIgOXQtMTAgMjJsLTYgMTE0bC02IDExN2wxMiA2MzZ2M3EyIDE1IDEyIDI0cTkgNyAyMCA3cTggMCAxNSAtNXExNCAtOCAxNiAtMjZ6TTIzMDQgNDIzcTAgLTExNyAtODMgLTE5OS41dC0yMDAgLTgyLjVoLTc4NgpxLTEzIDIgLTIyIDExdC05IDIydjg5OXEwIDIzIDI4IDMzcTg1IDM0IDE4MSAzNHExOTUgMCAzMzggLTEzMS41dDE2MCAtMzIzLjVxNTMgMjIgMTEwIDIycTExNyAwIDIwMCAtODN0ODMgLTIwMXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjFDMCIgdW5pY29kZT0iJiN4ZjFjMDsiIApkPSJNNzY4IDc2OHEyMzcgMCA0NDMgNDN0MzI1IDEyN3YtMTcwcTAgLTY5IC0xMDMgLTEyOHQtMjgwIC05My41dC0zODUgLTM0LjV0LTM4NSAzNC41dC0yODAgOTMuNXQtMTAzIDEyOHYxNzBxMTE5IC04NCAzMjUgLTEyN3Q0NDMgLTQzek03NjggMHEyMzcgMCA0NDMgNDN0MzI1IDEyN3YtMTcwcTAgLTY5IC0xMDMgLTEyOHQtMjgwIC05My41dC0zODUgLTM0LjV0LTM4NSAzNC41dC0yODAgOTMuNXQtMTAzIDEyOHYxNzBxMTE5IC04NCAzMjUgLTEyNwp0NDQzIC00M3pNNzY4IDM4NHEyMzcgMCA0NDMgNDN0MzI1IDEyN3YtMTcwcTAgLTY5IC0xMDMgLTEyOHQtMjgwIC05My41dC0zODUgLTM0LjV0LTM4NSAzNC41dC0yODAgOTMuNXQtMTAzIDEyOHYxNzBxMTE5IC04NCAzMjUgLTEyN3Q0NDMgLTQzek03NjggMTUzNnEyMDggMCAzODUgLTM0LjV0MjgwIC05My41dDEwMyAtMTI4di0xMjhxMCAtNjkgLTEwMyAtMTI4dC0yODAgLTkzLjV0LTM4NSAtMzQuNXQtMzg1IDM0LjV0LTI4MCA5My41CnQtMTAzIDEyOHYxMjhxMCA2OSAxMDMgMTI4dDI4MCA5My41dDM4NSAzNC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmlGMUMxIiB1bmljb2RlPSImI3hmMWMxOyIgCmQ9Ik0xNDY4IDExNTZxMjggLTI4IDQ4IC03NnQyMCAtODh2LTExNTJxMCAtNDAgLTI4IC02OHQtNjggLTI4aC0xMzQ0cS00MCAwIC02OCAyOHQtMjggNjh2MTYwMHEwIDQwIDI4IDY4dDY4IDI4aDg5NnE0MCAwIDg4IC0yMHQ3NiAtNDh6TTEwMjQgMTQwMHYtMzc2aDM3NnEtMTAgMjkgLTIyIDQxbC0zMTMgMzEzcS0xMiAxMiAtNDEgMjJ6TTE0MDggLTEyOHYxMDI0aC00MTZxLTQwIDAgLTY4IDI4dC0yOCA2OHY0MTZoLTc2OHYtMTUzNmgxMjgwegpNODk0IDQ2NXEzMyAtMjYgODQgLTU2cTU5IDcgMTE3IDdxMTQ3IDAgMTc3IC00OXExNiAtMjIgMiAtNTJxMCAtMSAtMSAtMmwtMiAtMnYtMXEtNiAtMzggLTcxIC0zOHEtNDggMCAtMTE1IDIwdC0xMzAgNTNxLTIyMSAtMjQgLTM5MiAtODNxLTE1MyAtMjYyIC0yNDIgLTI2MnEtMTUgMCAtMjggN2wtMjQgMTJxLTEgMSAtNiA1cS0xMCAxMCAtNiAzNnE5IDQwIDU2IDkxLjV0MTMyIDk2LjVxMTQgOSAyMyAtNnEyIC0yIDIgLTRxNTIgODUgMTA3IDE5NwpxNjggMTM2IDEwNCAyNjJxLTI0IDgyIC0zMC41IDE1OS41dDYuNSAxMjcuNXExMSA0MCA0MiA0MGgyMWgxcTIzIDAgMzUgLTE1cTE4IC0yMSA5IC02OHEtMiAtNiAtNCAtOHExIC0zIDEgLTh2LTMwcS0yIC0xMjMgLTE0IC0xOTJxNTUgLTE2NCAxNDYgLTIzOHpNMzE4IDU0cTUyIDI0IDEzNyAxNThxLTUxIC00MCAtODcuNSAtODR0LTQ5LjUgLTc0ek03MTYgOTc0cS0xNSAtNDIgLTIgLTEzMnExIDcgNyA0NHEwIDMgNyA0M3ExIDQgNCA4CnEtMSAxIC0xIDJxLTEgMiAtMSAzcS0xIDIyIC0xMyAzNnEwIC0xIC0xIC0ydi0yek01OTIgMzEzcTEzNSA1NCAyODQgODFxLTIgMSAtMTMgOS41dC0xNiAxMy41cS03NiA2NyAtMTI3IDE3NnEtMjcgLTg2IC04MyAtMTk3cS0zMCAtNTYgLTQ1IC04M3pNMTIzOCAzMjlxLTI0IDI0IC0xNDAgMjRxNzYgLTI4IDEyNCAtMjhxMTQgMCAxOCAxcTAgMSAtMiAzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDIyIiB1bmljb2RlPSImI3hmMWMyOyIgCmQ9Ik0xNDY4IDExNTZxMjggLTI4IDQ4IC03NnQyMCAtODh2LTExNTJxMCAtNDAgLTI4IC02OHQtNjggLTI4aC0xMzQ0cS00MCAwIC02OCAyOHQtMjggNjh2MTYwMHEwIDQwIDI4IDY4dDY4IDI4aDg5NnE0MCAwIDg4IC0yMHQ3NiAtNDh6TTEwMjQgMTQwMHYtMzc2aDM3NnEtMTAgMjkgLTIyIDQxbC0zMTMgMzEzcS0xMiAxMiAtNDEgMjJ6TTE0MDggLTEyOHYxMDI0aC00MTZxLTQwIDAgLTY4IDI4dC0yOCA2OHY0MTZoLTc2OHYtMTUzNmgxMjgwegpNMjMzIDc2OHYtMTA3aDcwbDE2NCAtNjYxaDE1OWwxMjggNDg1cTcgMjAgMTAgNDZxMiAxNiAyIDI0aDRsMyAtMjRxMSAtMyAzLjUgLTIwdDUuNSAtMjZsMTI4IC00ODVoMTU5bDE2NCA2NjFoNzB2MTA3aC0zMDB2LTEwN2g5MGwtOTkgLTQzOHEtNSAtMjAgLTcgLTQ2bC0yIC0yMWgtNHEwIDMgLTAuNSA2LjV0LTEuNSA4dC0xIDYuNXEtMSA1IC00IDIxdC01IDI1bC0xNDQgNTQ1aC0xMTRsLTE0NCAtNTQ1cS0yIC05IC00LjUgLTI0LjUKdC0zLjUgLTIxLjVsLTQgLTIxaC00bC0yIDIxcS0yIDI2IC03IDQ2bC05OSA0MzhoOTB2MTA3aC0zMDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80MjMiIHVuaWNvZGU9IiYjeGYxYzM7IiAKZD0iTTE0NjggMTE1NnEyOCAtMjggNDggLTc2dDIwIC04OHYtMTE1MnEwIC00MCAtMjggLTY4dC02OCAtMjhoLTEzNDRxLTQwIDAgLTY4IDI4dC0yOCA2OHYxNjAwcTAgNDAgMjggNjh0NjggMjhoODk2cTQwIDAgODggLTIwdDc2IC00OHpNMTAyNCAxNDAwdi0zNzZoMzc2cS0xMCAyOSAtMjIgNDFsLTMxMyAzMTNxLTEyIDEyIC00MSAyMnpNMTQwOCAtMTI4djEwMjRoLTQxNnEtNDAgMCAtNjggMjh0LTI4IDY4djQxNmgtNzY4di0xNTM2aDEyODB6Ck00MjkgMTA2di0xMDZoMjgxdjEwNmgtNzVsMTAzIDE2MXE1IDcgMTAgMTYuNXQ3LjUgMTMuNXQzLjUgNGgycTEgLTQgNSAtMTBxMiAtNCA0LjUgLTcuNXQ2IC04dDYuNSAtOC41bDEwNyAtMTYxaC03NnYtMTA2aDI5MXYxMDZoLTY4bC0xOTIgMjczbDE5NSAyODJoNjd2MTA3aC0yNzl2LTEwN2g3NGwtMTAzIC0xNTlxLTQgLTcgLTEwIC0xNi41dC05IC0xMy41bC0yIC0zaC0ycS0xIDQgLTUgMTBxLTYgMTEgLTE3IDIzbC0xMDYgMTU5aDc2djEwNwpoLTI5MHYtMTA3aDY4bDE4OSAtMjcybC0xOTQgLTI4M2gtNjh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80MjQiIHVuaWNvZGU9IiYjeGYxYzQ7IiAKZD0iTTE0NjggMTE1NnEyOCAtMjggNDggLTc2dDIwIC04OHYtMTE1MnEwIC00MCAtMjggLTY4dC02OCAtMjhoLTEzNDRxLTQwIDAgLTY4IDI4dC0yOCA2OHYxNjAwcTAgNDAgMjggNjh0NjggMjhoODk2cTQwIDAgODggLTIwdDc2IC00OHpNMTAyNCAxNDAwdi0zNzZoMzc2cS0xMCAyOSAtMjIgNDFsLTMxMyAzMTNxLTEyIDEyIC00MSAyMnpNMTQwOCAtMTI4djEwMjRoLTQxNnEtNDAgMCAtNjggMjh0LTI4IDY4djQxNmgtNzY4di0xNTM2aDEyODB6Ck00MTYgMTA2di0xMDZoMzI3djEwNmgtOTN2MTY3aDEzN3E3NiAwIDExOCAxNXE2NyAyMyAxMDYuNSA4N3QzOS41IDE0NnEwIDgxIC0zNyAxNDF0LTEwMCA4N3EtNDggMTkgLTEzMCAxOWgtMzY4di0xMDdoOTJ2LTU1NWgtOTJ6TTc2OSAzODZoLTExOXYyNjhoMTIwcTUyIDAgODMgLTE4cTU2IC0zMyA1NiAtMTE1cTAgLTg5IC02MiAtMTIwcS0zMSAtMTUgLTc4IC0xNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQyNSIgdW5pY29kZT0iJiN4ZjFjNTsiIApkPSJNMTQ2OCAxMTU2cTI4IC0yOCA0OCAtNzZ0MjAgLTg4di0xMTUycTAgLTQwIC0yOCAtNjh0LTY4IC0yOGgtMTM0NHEtNDAgMCAtNjggMjh0LTI4IDY4djE2MDBxMCA0MCAyOCA2OHQ2OCAyOGg4OTZxNDAgMCA4OCAtMjB0NzYgLTQ4ek0xMDI0IDE0MDB2LTM3NmgzNzZxLTEwIDI5IC0yMiA0MWwtMzEzIDMxM3EtMTIgMTIgLTQxIDIyek0xNDA4IC0xMjh2MTAyNGgtNDE2cS00MCAwIC02OCAyOHQtMjggNjh2NDE2aC03Njh2LTE1MzZoMTI4MHoKTTEyODAgMzIwdi0zMjBoLTEwMjR2MTkybDE5MiAxOTJsMTI4IC0xMjhsMzg0IDM4NHpNNDQ4IDUxMnEtODAgMCAtMTM2IDU2dC01NiAxMzZ0NTYgMTM2dDEzNiA1NnQxMzYgLTU2dDU2IC0xMzZ0LTU2IC0xMzZ0LTEzNiAtNTZ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80MjYiIHVuaWNvZGU9IiYjeGYxYzY7IiAKZD0iTTY0MCAxMTUydjEyOGgtMTI4di0xMjhoMTI4ek03NjggMTAyNHYxMjhoLTEyOHYtMTI4aDEyOHpNNjQwIDg5NnYxMjhoLTEyOHYtMTI4aDEyOHpNNzY4IDc2OHYxMjhoLTEyOHYtMTI4aDEyOHpNMTQ2OCAxMTU2cTI4IC0yOCA0OCAtNzZ0MjAgLTg4di0xMTUycTAgLTQwIC0yOCAtNjh0LTY4IC0yOGgtMTM0NHEtNDAgMCAtNjggMjh0LTI4IDY4djE2MDBxMCA0MCAyOCA2OHQ2OCAyOGg4OTZxNDAgMCA4OCAtMjB0NzYgLTQ4ek0xMDI0IDE0MDAKdi0zNzZoMzc2cS0xMCAyOSAtMjIgNDFsLTMxMyAzMTNxLTEyIDEyIC00MSAyMnpNMTQwOCAtMTI4djEwMjRoLTQxNnEtNDAgMCAtNjggMjh0LTI4IDY4djQxNmgtMTI4di0xMjhoLTEyOHYxMjhoLTUxMnYtMTUzNmgxMjgwek03ODEgNTkzbDEwNyAtMzQ5cTggLTI3IDggLTUycTAgLTgzIC03Mi41IC0xMzcuNXQtMTgzLjUgLTU0LjV0LTE4My41IDU0LjV0LTcyLjUgMTM3LjVxMCAyNSA4IDUycTIxIDYzIDEyMCAzOTZ2MTI4aDEyOHYtMTI4aDc5CnEyMiAwIDM5IC0xM3QyMyAtMzR6TTY0MCAxMjhxNTMgMCA5MC41IDE5dDM3LjUgNDV0LTM3LjUgNDV0LTkwLjUgMTl0LTkwLjUgLTE5dC0zNy41IC00NXQzNy41IC00NXQ5MC41IC0xOXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQyNyIgdW5pY29kZT0iJiN4ZjFjNzsiIApkPSJNMTQ2OCAxMTU2cTI4IC0yOCA0OCAtNzZ0MjAgLTg4di0xMTUycTAgLTQwIC0yOCAtNjh0LTY4IC0yOGgtMTM0NHEtNDAgMCAtNjggMjh0LTI4IDY4djE2MDBxMCA0MCAyOCA2OHQ2OCAyOGg4OTZxNDAgMCA4OCAtMjB0NzYgLTQ4ek0xMDI0IDE0MDB2LTM3NmgzNzZxLTEwIDI5IC0yMiA0MWwtMzEzIDMxM3EtMTIgMTIgLTQxIDIyek0xNDA4IC0xMjh2MTAyNGgtNDE2cS00MCAwIC02OCAyOHQtMjggNjh2NDE2aC03Njh2LTE1MzZoMTI4MHoKTTYyMCA2ODZxMjAgLTggMjAgLTMwdi01NDRxMCAtMjIgLTIwIC0zMHEtOCAtMiAtMTIgLTJxLTEyIDAgLTIzIDlsLTE2NiAxNjdoLTEzMXEtMTQgMCAtMjMgOXQtOSAyM3YxOTJxMCAxNCA5IDIzdDIzIDloMTMxbDE2NiAxNjdxMTYgMTUgMzUgN3pNMTAzNyAtM3EzMSAwIDUwIDI0cTEyOSAxNTkgMTI5IDM2M3QtMTI5IDM2M3EtMTYgMjEgLTQzIDI0dC00NyAtMTRxLTIxIC0xNyAtMjMuNSAtNDMuNXQxNC41IC00Ny41CnExMDAgLTEyMyAxMDAgLTI4MnQtMTAwIC0yODJxLTE3IC0yMSAtMTQuNSAtNDcuNXQyMy41IC00Mi41cTE4IC0xNSA0MCAtMTV6TTgyNiAxNDVxMjcgMCA0NyAyMHE4NyA5MyA4NyAyMTl0LTg3IDIxOXEtMTggMTkgLTQ1IDIwdC00NiAtMTd0LTIwIC00NC41dDE4IC00Ni41cTUyIC01NyA1MiAtMTMxdC01MiAtMTMxcS0xOSAtMjAgLTE4IC00Ni41dDIwIC00NC41cTIwIC0xNyA0NCAtMTd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80MjgiIHVuaWNvZGU9IiYjeGYxYzg7IiAKZD0iTTE0NjggMTE1NnEyOCAtMjggNDggLTc2dDIwIC04OHYtMTE1MnEwIC00MCAtMjggLTY4dC02OCAtMjhoLTEzNDRxLTQwIDAgLTY4IDI4dC0yOCA2OHYxNjAwcTAgNDAgMjggNjh0NjggMjhoODk2cTQwIDAgODggLTIwdDc2IC00OHpNMTAyNCAxNDAwdi0zNzZoMzc2cS0xMCAyOSAtMjIgNDFsLTMxMyAzMTNxLTEyIDEyIC00MSAyMnpNMTQwOCAtMTI4djEwMjRoLTQxNnEtNDAgMCAtNjggMjh0LTI4IDY4djQxNmgtNzY4di0xNTM2aDEyODB6Ck03NjggNzY4cTUyIDAgOTAgLTM4dDM4IC05MHYtMzg0cTAgLTUyIC0zOCAtOTB0LTkwIC0zOGgtMzg0cS01MiAwIC05MCAzOHQtMzggOTB2Mzg0cTAgNTIgMzggOTB0OTAgMzhoMzg0ek0xMjYwIDc2NnEyMCAtOCAyMCAtMzB2LTU3NnEwIC0yMiAtMjAgLTMwcS04IC0yIC0xMiAtMnEtMTQgMCAtMjMgOWwtMjY1IDI2NnY5MGwyNjUgMjY2cTkgOSAyMyA5cTQgMCAxMiAtMnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQyOSIgdW5pY29kZT0iJiN4ZjFjOTsiIApkPSJNMTQ2OCAxMTU2cTI4IC0yOCA0OCAtNzZ0MjAgLTg4di0xMTUycTAgLTQwIC0yOCAtNjh0LTY4IC0yOGgtMTM0NHEtNDAgMCAtNjggMjh0LTI4IDY4djE2MDBxMCA0MCAyOCA2OHQ2OCAyOGg4OTZxNDAgMCA4OCAtMjB0NzYgLTQ4ek0xMDI0IDE0MDB2LTM3NmgzNzZxLTEwIDI5IC0yMiA0MWwtMzEzIDMxM3EtMTIgMTIgLTQxIDIyek0xNDA4IC0xMjh2MTAyNGgtNDE2cS00MCAwIC02OCAyOHQtMjggNjh2NDE2aC03Njh2LTE1MzZoMTI4MHoKTTQ4MCA3NjhxOCAxMSAyMSAxMi41dDI0IC02LjVsNTEgLTM4cTExIC04IDEyLjUgLTIxdC02LjUgLTI0bC0xODIgLTI0M2wxODIgLTI0M3E4IC0xMSA2LjUgLTI0dC0xMi41IC0yMWwtNTEgLTM4cS0xMSAtOCAtMjQgLTYuNXQtMjEgMTIuNWwtMjI2IDMwMXEtMTQgMTkgMCAzOHpNMTI4MiA0NjdxMTQgLTE5IDAgLTM4bC0yMjYgLTMwMXEtOCAtMTEgLTIxIC0xMi41dC0yNCA2LjVsLTUxIDM4cS0xMSA4IC0xMi41IDIxdDYuNSAyNGwxODIgMjQzCmwtMTgyIDI0M3EtOCAxMSAtNi41IDI0dDEyLjUgMjFsNTEgMzhxMTEgOCAyNCA2LjV0MjEgLTEyLjV6TTY2MiA2cS0xMyAyIC0yMC41IDEzdC01LjUgMjRsMTM4IDgzMXEyIDEzIDEzIDIwLjV0MjQgNS41bDYzIC0xMHExMyAtMiAyMC41IC0xM3Q1LjUgLTI0bC0xMzggLTgzMXEtMiAtMTMgLTEzIC0yMC41dC0yNCAtNS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDMwIiB1bmljb2RlPSImI3hmMWNhOyIgCmQ9Ik0xNDk3IDcwOXYtMTk4cS0xMDEgLTIzIC0xOTggLTIzcS02NSAtMTM2IC0xNjUuNSAtMjcxdC0xODEuNSAtMjE1LjV0LTEyOCAtMTA2LjVxLTgwIC00NSAtMTYyIDNxLTI4IDE3IC02MC41IDQzLjV0LTg1IDgzLjV0LTEwMi41IDEyOC41dC0xMDcuNSAxODR0LTEwNS41IDI0NHQtOTEuNSAzMTQuNXQtNzAuNSAzOTBoMjgzcTI2IC0yMTggNzAgLTM5OC41dDEwNC41IC0zMTd0MTIxLjUgLTIzNS41dDE0MCAtMTk1cTE2OSAxNjkgMjg3IDQwNgpxLTE0MiA3MiAtMjIzIDIyMHQtODEgMzMzcTAgMTkyIDEwNCAzMTQuNXQyODQgMTIyLjVxMTc4IDAgMjczIC0xMDUuNXQ5NSAtMjk3LjVxMCAtMTU5IC01OCAtMjg2cS03IC0xIC0xOS41IC0zdC00NiAtMnQtNjMgNnQtNjIgMjUuNXQtNTAuNSA1MS41cTMxIDEwMyAzMSAxODRxMCA4NyAtMjkgMTMydC03OSA0NXEtNTMgMCAtODUgLTQ5LjV0LTMyIC0xNDAuNXEwIC0xODYgMTA1IC0yOTMuNXQyNjcgLTEwNy41cTYyIDAgMTIxIDE0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDMxIiB1bmljb2RlPSImI3hmMWNiOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMjE2IDM2N2w2MDMgLTQwMnYzNTlsLTMzNCAyMjN6TTE1NCA1MTFsMTkzIDEyOWwtMTkzIDEyOXYtMjU4ek05NzMgLTM1bDYwMyA0MDJsLTI2OSAxODBsLTMzNCAtMjIzdi0zNTl6TTg5NiA0NThsMjcyIDE4MmwtMjcyIDE4MmwtMjcyIC0xODJ6TTQ4NSA3MzNsMzM0IDIyM3YzNTlsLTYwMyAtNDAyek0xNDQ1IDY0MGwxOTMgLTEyOXYyNTh6TTEzMDcgNzMzbDI2OSAxODBsLTYwMyA0MDJ2LTM1OXpNMTc5MiA5MTN2LTU0NgpxMCAtNDEgLTM0IC02NGwtODE5IC01NDZxLTIxIC0xMyAtNDMgLTEzdC00MyAxM2wtODE5IDU0NnEtMzQgMjMgLTM0IDY0djU0NnEwIDQxIDM0IDY0bDgxOSA1NDZxMjEgMTMgNDMgMTN0NDMgLTEzbDgxOSAtNTQ2cTM0IC0yMyAzNCAtNjR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80MzIiIHVuaWNvZGU9IiYjeGYxY2M7IiBob3Jpei1hZHYteD0iMjA0OCIgCmQ9Ik0xODAwIDc2NHExMTEgLTQ2IDE3OS41IC0xNDUuNXQ2OC41IC0yMjEuNXEwIC0xNjQgLTExOCAtMjgwLjV0LTI4NSAtMTE2LjVxLTQgMCAtMTEuNSAwLjV0LTEwLjUgMC41aC0xMjA5aC0xaC0yaC01cS0xNzAgMTAgLTI4OCAxMjUuNXQtMTE4IDI4MC41cTAgMTEwIDU1IDIwM3QxNDcgMTQ3cS0xMiAzOSAtMTIgODJxMCAxMTUgODIgMTk2dDE5OSA4MXE5NSAwIDE3MiAtNThxNzUgMTU0IDIyMi41IDI0OHQzMjYuNSA5NApxMTY2IDAgMzA2IC04MC41dDIyMS41IC0yMTguNXQ4MS41IC0zMDFxMCAtNiAtMC41IC0xOHQtMC41IC0xOHpNNDY4IDQ5OHEwIC0xMjIgODQgLTE5M3QyMDggLTcxcTEzNyAwIDI0MCA5OXEtMTYgMjAgLTQ3LjUgNTYuNXQtNDMuNSA1MC41cS02NyAtNjUgLTE0NCAtNjVxLTU1IDAgLTkzLjUgMzMuNXQtMzguNSA4Ny41cTAgNTMgMzguNSA4N3Q5MS41IDM0cTQ0IDAgODQuNSAtMjF0NzMgLTU1dDY1IC03NXQ2OSAtODJ0NzcgLTc1dDk3IC01NQp0MTIxLjUgLTIxcTEyMSAwIDIwNC41IDcxLjV0ODMuNSAxOTAuNXEwIDEyMSAtODQgMTkydC0yMDcgNzFxLTE0MyAwIC0yNDEgLTk3bDkzIC0xMDhxNjYgNjQgMTQyIDY0cTUyIDAgOTIgLTMzdDQwIC04NHEwIC01NyAtMzcgLTkxLjV0LTk0IC0zNC41cS00MyAwIC04Mi41IDIxdC03MiA1NXQtNjUuNSA3NXQtNjkuNSA4MnQtNzcuNSA3NXQtOTYuNSA1NXQtMTE4LjUgMjFxLTEyMiAwIC0yMDcgLTcwLjV0LTg1IC0xODkuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQzMyIgdW5pY29kZT0iJiN4ZjFjZDsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTg5NiAxNTM2cTE4MiAwIDM0OCAtNzF0Mjg2IC0xOTF0MTkxIC0yODZ0NzEgLTM0OHQtNzEgLTM0OHQtMTkxIC0yODZ0LTI4NiAtMTkxdC0zNDggLTcxdC0zNDggNzF0LTI4NiAxOTF0LTE5MSAyODZ0LTcxIDM0OHQ3MSAzNDh0MTkxIDI4NnQyODYgMTkxdDM0OCA3MXpNODk2IDE0MDhxLTE5MCAwIC0zNjEgLTkwbDE5NCAtMTk0cTgyIDI4IDE2NyAyOHQxNjcgLTI4bDE5NCAxOTRxLTE3MSA5MCAtMzYxIDkwek0yMTggMjc5bDE5NCAxOTQKcS0yOCA4MiAtMjggMTY3dDI4IDE2N2wtMTk0IDE5NHEtOTAgLTE3MSAtOTAgLTM2MXQ5MCAtMzYxek04OTYgLTEyOHExOTAgMCAzNjEgOTBsLTE5NCAxOTRxLTgyIC0yOCAtMTY3IC0yOHQtMTY3IDI4bC0xOTQgLTE5NHExNzEgLTkwIDM2MSAtOTB6TTg5NiAyNTZxMTU5IDAgMjcxLjUgMTEyLjV0MTEyLjUgMjcxLjV0LTExMi41IDI3MS41dC0yNzEuNSAxMTIuNXQtMjcxLjUgLTExMi41dC0xMTIuNSAtMjcxLjV0MTEyLjUgLTI3MS41CnQyNzEuNSAtMTEyLjV6TTEzODAgNDczbDE5NCAtMTk0cTkwIDE3MSA5MCAzNjF0LTkwIDM2MWwtMTk0IC0xOTRxMjggLTgyIDI4IC0xNjd0LTI4IC0xNjd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80MzQiIHVuaWNvZGU9IiYjeGYxY2U7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xNzYwIDY0MHEwIC0xNzYgLTY4LjUgLTMzNnQtMTg0IC0yNzUuNXQtMjc1LjUgLTE4NHQtMzM2IC02OC41dC0zMzYgNjguNXQtMjc1LjUgMTg0dC0xODQgMjc1LjV0LTY4LjUgMzM2cTAgMjEzIDk3IDM5OC41dDI2NSAzMDUuNXQzNzQgMTUxdi0yMjhxLTIyMSAtNDUgLTM2Ni41IC0yMjF0LTE0NS41IC00MDZxMCAtMTMwIDUxIC0yNDguNXQxMzYuNSAtMjA0dDIwNCAtMTM2LjV0MjQ4LjUgLTUxdDI0OC41IDUxdDIwNCAxMzYuNQp0MTM2LjUgMjA0dDUxIDI0OC41cTAgMjMwIC0xNDUuNSA0MDZ0LTM2Ni41IDIyMXYyMjhxMjA2IC0zMSAzNzQgLTE1MXQyNjUgLTMwNS41dDk3IC0zOTguNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjFEMCIgdW5pY29kZT0iJiN4ZjFkMDsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE5IDY2MnE4IDIxNyAxMTYgNDA2dDMwNSAzMThoNXEwIC0xIC0xIC0zcS04IC04IC0yOCAtMzMuNXQtNTIgLTc2LjV0LTYwIC0xMTAuNXQtNDQuNSAtMTM1LjV0LTE0IC0xNTAuNXQzOSAtMTU3LjV0MTA4LjUgLTE1NHE1MCAtNTAgMTAyIC02OS41dDkwLjUgLTExLjV0NjkuNSAyMy41dDQ3IDMyLjVsMTYgMTZxMzkgNTEgNTMgMTE2LjV0Ni41IDEyMi41dC0yMSAxMDd0LTI2LjUgODBsLTE0IDI5cS0xMCAyNSAtMzAuNSA0OS41dC00MyA0MQp0LTQzLjUgMjkuNXQtMzUgMTlsLTEzIDZsMTA0IDExNXEzOSAtMTcgNzggLTUydDU5IC02MWwxOSAtMjdxMSA0OCAtMTguNSAxMDMuNXQtNDAuNSA4Ny41bC0yMCAzMWwxNjEgMTgzbDE2MCAtMTgxcS0zMyAtNDYgLTUyLjUgLTEwMi41dC0yMi41IC05MC41bC00IC0zM3EyMiAzNyA2MS41IDcyLjV0NjcuNSA1Mi41bDI4IDE3bDEwMyAtMTE1cS00NCAtMTQgLTg1IC01MHQtNjAgLTY1bC0xOSAtMjlxLTMxIC01NiAtNDggLTEzMy41dC03IC0xNzAKdDU3IC0xNTYuNXEzMyAtNDUgNzcuNSAtNjAuNXQ4NSAtNS41dDc2IDI2LjV0NTcuNSAzMy41bDIxIDE2cTYwIDUzIDk2LjUgMTE1dDQ4LjUgMTIxLjV0MTAgMTIxLjV0LTE4IDExOHQtMzcgMTA3LjV0LTQ1LjUgOTN0LTQ1IDcydC0zNC41IDQ3LjVsLTEzIDE3cS0xNCAxMyAtNyAxM2wxMCAtM3E0MCAtMjkgNjIuNSAtNDZ0NjIgLTUwdDY0IC01OHQ1OC41IC02NXQ1NS41IC03N3Q0NS41IC04OHQzOCAtMTAzdDIzLjUgLTExN3QxMC41IC0xMzYKcTMgLTI1OSAtMTA4IC00NjV0LTMxMiAtMzIxdC00NTYgLTExNXEtMTg1IDAgLTM1MSA3NHQtMjgzLjUgMTk4dC0xODQgMjkzdC02MC41IDM1M3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjFEMSIgdW5pY29kZT0iJiN4ZjFkMTsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTg3NCAtMTAydi02NnEtMjA4IDYgLTM4NSAxMDkuNXQtMjgzIDI3NS41bDU4IDM0cTI5IC00OSA3MyAtOTlsNjUgNTdxMTQ4IC0xNjggMzY4IC0yMTJsLTE3IC04NnE2NSAtMTIgMTIxIC0xM3pNMjc2IDQyOGwtODMgLTI4cTIyIC02MCA0OSAtMTEybC01NyAtMzNxLTk4IDE4MCAtOTggMzg1dDk4IDM4NWw1NyAtMzNxLTMwIC01NiAtNDkgLTExMmw4MiAtMjhxLTM1IC0xMDAgLTM1IC0yMTJxMCAtMTA5IDM2IC0yMTJ6TTE1MjggMjUxCmw1OCAtMzRxLTEwNiAtMTcyIC0yODMgLTI3NS41dC0zODUgLTEwOS41djY2cTU2IDEgMTIxIDEzbC0xNyA4NnEyMjAgNDQgMzY4IDIxMmw2NSAtNTdxNDQgNTAgNzMgOTl6TTEzNzcgODA1bC0yMzMgLTgwcTE0IC00MiAxNCAtODV0LTE0IC04NWwyMzIgLTgwcS0zMSAtOTIgLTk4IC0xNjlsLTE4NSAxNjJxLTU3IC02NyAtMTQ3IC04NWw0OCAtMjQxcS01MiAtMTAgLTk4IC0xMHQtOTggMTBsNDggMjQxcS05MCAxOCAtMTQ3IDg1bC0xODUgLTE2MgpxLTY3IDc3IC05OCAxNjlsMjMyIDgwcS0xNCA0MiAtMTQgODV0MTQgODVsLTIzMyA4MHEzMyA5MyA5OSAxNjlsMTg1IC0xNjJxNTkgNjggMTQ3IDg2bC00OCAyNDBxNDQgMTAgOTggMTB0OTggLTEwbC00OCAtMjQwcTg4IC0xOCAxNDcgLTg2bDE4NSAxNjJxNjYgLTc2IDk5IC0xNjl6TTg3NCAxNDQ4di02NnEtNjUgLTIgLTEyMSAtMTNsMTcgLTg2cS0yMjAgLTQyIC0zNjggLTIxMWwtNjUgNTZxLTM4IC00MiAtNzMgLTk4bC01NyAzMwpxMTA2IDE3MiAyODIgMjc1LjV0Mzg1IDEwOS41ek0xNzA1IDY0MHEwIC0yMDUgLTk4IC0zODVsLTU3IDMzcTI3IDUyIDQ5IDExMmwtODMgMjhxMzYgMTAzIDM2IDIxMnEwIDExMiAtMzUgMjEybDgyIDI4cS0xOSA1NiAtNDkgMTEybDU3IDMzcTk4IC0xODAgOTggLTM4NXpNMTU4NSAxMDYzbC01NyAtMzNxLTM1IDU2IC03MyA5OGwtNjUgLTU2cS0xNDggMTY5IC0zNjggMjExbDE3IDg2cS01NiAxMSAtMTIxIDEzdjY2cTIwOSAtNiAzODUgLTEwOS41CnQyODIgLTI3NS41ek0xNzQ4IDY0MHEwIDE3MyAtNjcuNSAzMzF0LTE4MS41IDI3MnQtMjcyIDE4MS41dC0zMzEgNjcuNXQtMzMxIC02Ny41dC0yNzIgLTE4MS41dC0xODEuNSAtMjcydC02Ny41IC0zMzF0NjcuNSAtMzMxdDE4MS41IC0yNzJ0MjcyIC0xODEuNXQzMzEgLTY3LjV0MzMxIDY3LjV0MjcyIDE4MS41dDE4MS41IDI3MnQ2Ny41IDMzMXpNMTc5MiA2NDBxMCAtMTgyIC03MSAtMzQ4dC0xOTEgLTI4NnQtMjg2IC0xOTF0LTM0OCAtNzEKdC0zNDggNzF0LTI4NiAxOTF0LTE5MSAyODZ0LTcxIDM0OHQ3MSAzNDh0MTkxIDI4NnQyODYgMTkxdDM0OCA3MXQzNDggLTcxdDI4NiAtMTkxdDE5MSAtMjg2dDcxIC0zNDh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYxRDIiIHVuaWNvZGU9IiYjeGYxZDI7IiAKZD0iTTU4MiAyMjhxMCAtNjYgLTkzIC02NnEtMTA3IDAgLTEwNyA2M3EwIDY0IDk4IDY0cTEwMiAwIDEwMiAtNjF6TTU0NiA2OTRxMCAtODUgLTc0IC04NXEtNzcgMCAtNzcgODRxMCA5MCA3NyA5MHEzNiAwIDU1IC0yNS41dDE5IC02My41ek03MTIgNzY5djEyNXEtNzggLTI5IC0xMzUgLTI5cS01MCAyOSAtMTEwIDI5cS04NiAwIC0xNDUgLTU3dC01OSAtMTQzcTAgLTUwIDI5LjUgLTEwMnQ3My41IC02N3YtM3EtMzggLTE3IC0zOCAtODUKcTAgLTUzIDQxIC03N3YtM3EtMTEzIC0zNyAtMTEzIC0xMzlxMCAtNDUgMjAgLTc4LjV0NTQgLTUxdDcyIC0yNS41dDgxIC04cTIyNCAwIDIyNCAxODhxMCA2NyAtNDggOTl0LTEyNiA0NnEtMjcgNSAtNTEuNSAyMC41dC0yNC41IDM5LjVxMCA0NCA0OSA1MnE3NyAxNSAxMjIgNzB0NDUgMTM0cTAgMjQgLTEwIDUycTM3IDkgNDkgMTN6TTc3MSAzNTBoMTM3cS0yIDI3IC0yIDgydjM4N3EwIDQ2IDIgNjloLTEzN3EzIC0yMyAzIC03MXYtMzkyCnEwIC01MCAtMyAtNzV6TTEyODAgMzY2djEyMXEtMzAgLTIxIC02OCAtMjFxLTUzIDAgLTUzIDgydjIyNWg1MnE5IDAgMjYuNSAtMXQyNi41IC0xdjExN2gtMTA1cTAgODIgMyAxMDJoLTE0MHE0IC0yNCA0IC01NXYtNDdoLTYwdi0xMTdxMzYgMyAzNyAzcTMgMCAxMSAtMC41dDEyIC0wLjV2LTJoLTJ2LTIxN3EwIC0zNyAyLjUgLTY0dDExLjUgLTU2LjV0MjQuNSAtNDguNXQ0My41IC0zMXQ2NiAtMTJxNjQgMCAxMDggMjR6TTkyNCAxMDcyCnEwIDM2IC0yNCA2My41dC02MCAyNy41dC02MC41IC0yN3QtMjQuNSAtNjRxMCAtMzYgMjUgLTYyLjV0NjAgLTI2LjV0NTkuNSAyN3QyNC41IDYyek0xNTM2IDExMjB2LTk2MHEwIC0xMTkgLTg0LjUgLTIwMy41dC0yMDMuNSAtODQuNWgtOTYwcS0xMTkgMCAtMjAzLjUgODQuNXQtODQuNSAyMDMuNXY5NjBxMCAxMTkgODQuNSAyMDMuNXQyMDMuNSA4NC41aDk2MHExMTkgMCAyMDMuNSAtODQuNXQ4NC41IC0yMDMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQzOCIgdW5pY29kZT0iJiN4ZjFkMzsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTU5NSAyMnEwIDEwMCAtMTY1IDEwMHEtMTU4IDAgLTE1OCAtMTA0cTAgLTEwMSAxNzIgLTEwMXExNTEgMCAxNTEgMTA1ek01MzYgNzc3cTAgNjEgLTMwIDEwMnQtODkgNDFxLTEyNCAwIC0xMjQgLTE0NXEwIC0xMzUgMTI0IC0xMzVxMTE5IDAgMTE5IDEzN3pNODA1IDExMDF2LTIwMnEtMzYgLTEyIC03OSAtMjJxMTYgLTQzIDE2IC04NHEwIC0xMjcgLTczIC0yMTYuNXQtMTk3IC0xMTIuNXEtNDAgLTggLTU5LjUgLTI3dC0xOS41IC01OApxMCAtMzEgMjIuNSAtNTEuNXQ1OCAtMzJ0NzguNSAtMjJ0ODYgLTI1LjV0NzguNSAtMzcuNXQ1OCAtNjR0MjIuNSAtOTguNXEwIC0zMDQgLTM2MyAtMzA0cS02OSAwIC0xMzAgMTIuNXQtMTE2IDQxdC04Ny41IDgydC0zMi41IDEyNy41cTAgMTY1IDE4MiAyMjV2NHEtNjcgNDEgLTY3IDEyNnEwIDEwOSA2MyAxMzd2NHEtNzIgMjQgLTExOS41IDEwOC41dC00Ny41IDE2NS41cTAgMTM5IDk1IDIzMS41dDIzNSA5Mi41cTk2IDAgMTc4IC00NwpxOTggMCAyMTggNDd6TTExMjMgMjIwaC0yMjJxNCA0NSA0IDEzNHY2MDlxMCA5NCAtNCAxMjhoMjIycS00IC0zMyAtNCAtMTI0di02MTNxMCAtODkgNCAtMTM0ek0xNzI0IDQ0MnYtMTk2cS03MSAtMzkgLTE3NCAtMzlxLTYyIDAgLTEwNyAyMHQtNzAgNTB0LTM5LjUgNzh0LTE4LjUgOTJ0LTQgMTAzdjM1MWgydjRxLTcgMCAtMTkgMXQtMTggMXEtMjEgMCAtNTkgLTZ2MTkwaDk2djc2cTAgNTQgLTYgODloMjI3cS02IC00MSAtNiAtMTY1aDE3MQp2LTE5MHEtMTUgMCAtNDMuNSAydC00Mi41IDJoLTg1di0zNjVxMCAtMTMxIDg3IC0xMzFxNjEgMCAxMDkgMzN6TTExNDggMTM4OXEwIC01OCAtMzkgLTEwMS41dC05NiAtNDMuNXEtNTggMCAtOTggNDMuNXQtNDAgMTAxLjVxMCA1OSAzOS41IDEwM3Q5OC41IDQ0cTU4IDAgOTYuNSAtNDQuNXQzOC41IC0xMDIuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQzOSIgdW5pY29kZT0iJiN4ZjFkNDsiIApkPSJNODA5IDUzMmwyNjYgNDk5aC0xMTJsLTE1NyAtMzEycS0yNCAtNDggLTQ0IC05MmwtNDIgOTJsLTE1NSAzMTJoLTEyMGwyNjMgLTQ5M3YtMzI0aDEwMXYzMTh6TTE1MzYgMTEyMHYtOTYwcTAgLTExOSAtODQuNSAtMjAzLjV0LTIwMy41IC04NC41aC05NjBxLTExOSAwIC0yMDMuNSA4NC41dC04NC41IDIwMy41djk2MHEwIDExOSA4NC41IDIwMy41dDIwMy41IDg0LjVoOTYwcTExOSAwIDIwMy41IC04NC41dDg0LjUgLTIwMy41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmlGMUQ1IiB1bmljb2RlPSImI3hmMWQ1OyIgaG9yaXotYWR2LXg9IjEyODAiIApkPSJNODQyIDk2NHEwIC04MCAtNTcgLTEzNi41dC0xMzYgLTU2LjVxLTYwIDAgLTExMSAzNXEtNjIgLTY3IC0xMTUgLTE0NnEtMjQ3IC0zNzEgLTIwMiAtODU5cTEgLTIyIC0xMi41IC0zOC41dC0zNC41IC0xOC41aC01cS0yMCAwIC0zNSAxMy41dC0xNyAzMy41cS0xNCAxMjYgLTMuNSAyNDcuNXQyOS41IDIxN3Q1NCAxODZ0NjkgMTU1LjV0NzQgMTI1cTYxIDkwIDEzMiAxNjVxLTE2IDM1IC0xNiA3N3EwIDgwIDU2LjUgMTM2LjV0MTM2LjUgNTYuNQp0MTM2LjUgLTU2LjV0NTYuNSAtMTM2LjV6TTEyMjMgOTUzcTAgLTE1OCAtNzggLTI5MnQtMjEyLjUgLTIxMnQtMjkyLjUgLTc4cS02NCAwIC0xMzEgMTRxLTIxIDUgLTMyLjUgMjMuNXQtNi41IDM5LjVxNSAyMCAyMyAzMS41dDM5IDcuNXE1MSAtMTMgMTA4IC0xM3E5NyAwIDE4NiAzOHQxNTMgMTAydDEwMiAxNTN0MzggMTg2dC0zOCAxODZ0LTEwMiAxNTN0LTE1MyAxMDJ0LTE4NiAzOHQtMTg2IC0zOHQtMTUzIC0xMDJ0LTEwMiAtMTUzCnQtMzggLTE4NnEwIC0xMTQgNTIgLTIxOHExMCAtMjAgMy41IC00MHQtMjUuNSAtMzB0LTM5LjUgLTN0LTMwLjUgMjZxLTY0IDEyMyAtNjQgMjY1cTAgMTE5IDQ2LjUgMjI3dDEyNC41IDE4NnQxODYgMTI0dDIyNiA0NnExNTggMCAyOTIuNSAtNzh0MjEyLjUgLTIxMi41dDc4IC0yOTIuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjFENiIgdW5pY29kZT0iJiN4ZjFkNjsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTI3MCA3MzBxLTggMTkgLTggNTJxMCAyMCAxMSA0OXQyNCA0NXEtMSAyMiA3LjUgNTN0MjIuNSA0M3EwIDEzOSA5Mi41IDI4OC41dDIxNy41IDIwOS41cTEzOSA2NiAzMjQgNjZxMTMzIDAgMjY2IC01NXE0OSAtMjEgOTAgLTQ4dDcxIC01NnQ1NSAtNjh0NDIgLTc0dDMyLjUgLTg0LjV0MjUuNSAtODkuNXQyMiAtOThsMSAtNXE1NSAtODMgNTUgLTE1MHEwIC0xNCAtOSAtNDB0LTkgLTM4cTAgLTEgMS41IC0zLjV0My41IC01dDIgLTMuNQpxNzcgLTExNCAxMjAuNSAtMjE0LjV0NDMuNSAtMjA4LjVxMCAtNDMgLTE5LjUgLTEwMHQtNTUuNSAtNTdxLTkgMCAtMTkuNSA3LjV0LTE5IDE3LjV0LTE5IDI2dC0xNiAyNi41dC0xMy41IDI2dC05IDE3LjVxLTEgMSAtMyAxbC01IC00cS01OSAtMTU0IC0xMzIgLTIyM3EyMCAtMjAgNjEuNSAtMzguNXQ2OSAtNDEuNXQzNS41IC02NXEtMiAtNCAtNCAtMTZ0LTcgLTE4cS02NCAtOTcgLTMwMiAtOTdxLTUzIDAgLTExMC41IDl0LTk4IDIwCnQtMTA0LjUgMzBxLTE1IDUgLTIzIDdxLTE0IDQgLTQ2IDQuNXQtNDAgMS41cS00MSAtNDUgLTEyNy41IC02NXQtMTY4LjUgLTIwcS0zNSAwIC02OSAxLjV0LTkzIDl0LTEwMSAyMC41dC03NC41IDQwdC0zMi41IDY0cTAgNDAgMTAgNTkuNXQ0MSA0OC41cTExIDIgNDAuNSAxM3Q0OS41IDEycTQgMCAxNCAycTIgMiAyIDRsLTIgM3EtNDggMTEgLTEwOCAxMDUuNXQtNzMgMTU2LjVsLTUgM3EtNCAwIC0xMiAtMjBxLTE4IC00MSAtNTQuNSAtNzQuNQp0LTc3LjUgLTM3LjVoLTFxLTQgMCAtNiA0LjV0LTUgNS41cS0yMyA1NCAtMjMgMTAwcTAgMjc1IDI1MiA0NjZ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYxRDciIHVuaWNvZGU9IiYjeGYxZDc7IiBob3Jpei1hZHYteD0iMjA0OCIgCmQ9Ik01ODAgMTA3NXEwIDQxIC0yNSA2NnQtNjYgMjVxLTQzIDAgLTc2IC0yNS41dC0zMyAtNjUuNXEwIC0zOSAzMyAtNjQuNXQ3NiAtMjUuNXE0MSAwIDY2IDI0LjV0MjUgNjUuNXpNMTMyMyA1NjhxMCAyOCAtMjUuNSA1MHQtNjUuNSAyMnEtMjcgMCAtNDkuNSAtMjIuNXQtMjIuNSAtNDkuNXEwIC0yOCAyMi41IC01MC41dDQ5LjUgLTIyLjVxNDAgMCA2NS41IDIydDI1LjUgNTF6TTEwODcgMTA3NXEwIDQxIC0yNC41IDY2dC02NS41IDI1CnEtNDMgMCAtNzYgLTI1LjV0LTMzIC02NS41cTAgLTM5IDMzIC02NC41dDc2IC0yNS41cTQxIDAgNjUuNSAyNC41dDI0LjUgNjUuNXpNMTcyMiA1NjhxMCAyOCAtMjYgNTB0LTY1IDIycS0yNyAwIC00OS41IC0yMi41dC0yMi41IC00OS41cTAgLTI4IDIyLjUgLTUwLjV0NDkuNSAtMjIuNXEzOSAwIDY1IDIydDI2IDUxek0xNDU2IDk2NXEtMzEgNCAtNzAgNHEtMTY5IDAgLTMxMSAtNzd0LTIyMy41IC0yMDguNXQtODEuNSAtMjg3LjUKcTAgLTc4IDIzIC0xNTJxLTM1IC0zIC02OCAtM3EtMjYgMCAtNTAgMS41dC01NSA2LjV0LTQ0LjUgN3QtNTQuNSAxMC41dC01MCAxMC41bC0yNTMgLTEyN2w3MiAyMThxLTI5MCAyMDMgLTI5MCA0OTBxMCAxNjkgOTcuNSAzMTF0MjY0IDIyMy41dDM2My41IDgxLjVxMTc2IDAgMzMyLjUgLTY2dDI2MiAtMTgyLjV0MTM2LjUgLTI2MC41ek0yMDQ4IDQwNHEwIC0xMTcgLTY4LjUgLTIyMy41dC0xODUuNSAtMTkzLjVsNTUgLTE4MWwtMTk5IDEwOQpxLTE1MCAtMzcgLTIxOCAtMzdxLTE2OSAwIC0zMTEgNzAuNXQtMjIzLjUgMTkxLjV0LTgxLjUgMjY0dDgxLjUgMjY0dDIyMy41IDE5MS41dDMxMSA3MC41cTE2MSAwIDMwMyAtNzAuNXQyMjcuNSAtMTkydDg1LjUgLTI2My41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDQzIiB1bmljb2RlPSImI3hmMWQ4OyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTc2NCAxNTI1cTMzIC0yNCAyNyAtNjRsLTI1NiAtMTUzNnEtNSAtMjkgLTMyIC00NXEtMTQgLTggLTMxIC04cS0xMSAwIC0yNCA1bC00NTMgMTg1bC0yNDIgLTI5NXEtMTggLTIzIC00OSAtMjNxLTEzIDAgLTIyIDRxLTE5IDcgLTMwLjUgMjMuNXQtMTEuNSAzNi41djM0OWw4NjQgMTA1OWwtMTA2OSAtOTI1bC0zOTUgMTYycS0zNyAxNCAtNDAgNTVxLTIgNDAgMzIgNTlsMTY2NCA5NjBxMTUgOSAzMiA5cTIwIDAgMzYgLTExeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDQ0IiB1bmljb2RlPSImI3hmMWQ5OyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTc2NCAxNTI1cTMzIC0yNCAyNyAtNjRsLTI1NiAtMTUzNnEtNSAtMjkgLTMyIC00NXEtMTQgLTggLTMxIC04cS0xMSAwIC0yNCA1bC01MjcgMjE1bC0yOTggLTMyN3EtMTggLTIxIC00NyAtMjFxLTE0IDAgLTIzIDRxLTE5IDcgLTMwIDIzLjV0LTExIDM2LjV2NDUybC00NzIgMTkzcS0zNyAxNCAtNDAgNTVxLTMgMzkgMzIgNTlsMTY2NCA5NjBxMzUgMjEgNjggLTJ6TTE0MjIgMjZsMjIxIDEzMjNsLTE0MzQgLTgyN2wzMzYgLTEzNwpsODYzIDYzOWwtNDc4IC03OTd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80NDUiIHVuaWNvZGU9IiYjeGYxZGE7IiAKZD0iTTE1MzYgNjQwcTAgLTE1NiAtNjEgLTI5OHQtMTY0IC0yNDV0LTI0NSAtMTY0dC0yOTggLTYxcS0xNzIgMCAtMzI3IDcyLjV0LTI2NCAyMDQuNXEtNyAxMCAtNi41IDIyLjV0OC41IDIwLjVsMTM3IDEzOHExMCA5IDI1IDlxMTYgLTIgMjMgLTEycTczIC05NSAxNzkgLTE0N3QyMjUgLTUycTEwNCAwIDE5OC41IDQwLjV0MTYzLjUgMTA5LjV0MTA5LjUgMTYzLjV0NDAuNSAxOTguNXQtNDAuNSAxOTguNXQtMTA5LjUgMTYzLjUKdC0xNjMuNSAxMDkuNXQtMTk4LjUgNDAuNXEtOTggMCAtMTg4IC0zNS41dC0xNjAgLTEwMS41bDEzNyAtMTM4cTMxIC0zMCAxNCAtNjlxLTE3IC00MCAtNTkgLTQwaC00NDhxLTI2IDAgLTQ1IDE5dC0xOSA0NXY0NDhxMCA0MiA0MCA1OXEzOSAxNyA2OSAtMTRsMTMwIC0xMjlxMTA3IDEwMSAyNDQuNSAxNTYuNXQyODQuNSA1NS41cTE1NiAwIDI5OCAtNjF0MjQ1IC0xNjR0MTY0IC0yNDV0NjEgLTI5OHpNODk2IDkyOHYtNDQ4cTAgLTE0IC05IC0yMwp0LTIzIC05aC0zMjBxLTE0IDAgLTIzIDl0LTkgMjN2NjRxMCAxNCA5IDIzdDIzIDloMjI0djM1MnEwIDE0IDkgMjN0MjMgOWg2NHExNCAwIDIzIC05dDkgLTIzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDQ2IiB1bmljb2RlPSImI3hmMWRiOyIgCmQ9Ik03NjggMTI4MHEtMTMwIDAgLTI0OC41IC01MXQtMjA0IC0xMzYuNXQtMTM2LjUgLTIwNHQtNTEgLTI0OC41dDUxIC0yNDguNXQxMzYuNSAtMjA0dDIwNCAtMTM2LjV0MjQ4LjUgLTUxdDI0OC41IDUxdDIwNCAxMzYuNXQxMzYuNSAyMDR0NTEgMjQ4LjV0LTUxIDI0OC41dC0xMzYuNSAyMDR0LTIwNCAxMzYuNXQtMjQ4LjUgNTF6TTE1MzYgNjQwcTAgLTIwOSAtMTAzIC0zODUuNXQtMjc5LjUgLTI3OS41dC0zODUuNSAtMTAzdC0zODUuNSAxMDMKdC0yNzkuNSAyNzkuNXQtMTAzIDM4NS41dDEwMyAzODUuNXQyNzkuNSAyNzkuNXQzODUuNSAxMDN0Mzg1LjUgLTEwM3QyNzkuNSAtMjc5LjV0MTAzIC0zODUuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQ0NyIgdW5pY29kZT0iJiN4ZjFkYzsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE2ODIgLTEyOHEtNDQgMCAtMTMyLjUgMy41dC0xMzMuNSAzLjVxLTQ0IDAgLTEzMiAtMy41dC0xMzIgLTMuNXEtMjQgMCAtMzcgMjAuNXQtMTMgNDUuNXEwIDMxIDE3IDQ2dDM5IDE3dDUxIDd0NDUgMTVxMzMgMjEgMzMgMTQwbC0xIDM5MXEwIDIxIC0xIDMxcS0xMyA0IC01MCA0aC02NzVxLTM4IDAgLTUxIC00cS0xIC0xMCAtMSAtMzFsLTEgLTM3MXEwIC0xNDIgMzcgLTE2NHExNiAtMTAgNDggLTEzdDU3IC0zLjV0NDUgLTE1CnQyMCAtNDUuNXEwIC0yNiAtMTIuNSAtNDh0LTM2LjUgLTIycS00NyAwIC0xMzkuNSAzLjV0LTEzOC41IDMuNXEtNDMgMCAtMTI4IC0zLjV0LTEyNyAtMy41cS0yMyAwIC0zNS41IDIxdC0xMi41IDQ1cTAgMzAgMTUuNSA0NXQzNiAxNy41dDQ3LjUgNy41dDQyIDE1cTMzIDIzIDMzIDE0M2wtMSA1N3Y4MTNxMCAzIDAuNSAyNnQwIDM2LjV0LTEuNSAzOC41dC0zLjUgNDJ0LTYuNSAzNi41dC0xMSAzMS41dC0xNiAxOHEtMTUgMTAgLTQ1IDEydC01MyAyCnQtNDEgMTR0LTE4IDQ1cTAgMjYgMTIgNDh0MzYgMjJxNDYgMCAxMzguNSAtMy41dDEzOC41IC0zLjVxNDIgMCAxMjYuNSAzLjV0MTI2LjUgMy41cTI1IDAgMzcuNSAtMjJ0MTIuNSAtNDhxMCAtMzAgLTE3IC00My41dC0zOC41IC0xNC41dC00OS41IC00dC00MyAtMTNxLTM1IC0yMSAtMzUgLTE2MGwxIC0zMjBxMCAtMjEgMSAtMzJxMTMgLTMgMzkgLTNoNjk5cTI1IDAgMzggM3ExIDExIDEgMzJsMSAzMjBxMCAxMzkgLTM1IDE2MApxLTE4IDExIC01OC41IDEyLjV0LTY2IDEzdC0yNS41IDQ5LjVxMCAyNiAxMi41IDQ4dDM3LjUgMjJxNDQgMCAxMzIgLTMuNXQxMzIgLTMuNXE0MyAwIDEyOSAzLjV0MTI5IDMuNXEyNSAwIDM3LjUgLTIydDEyLjUgLTQ4cTAgLTMwIC0xNy41IC00NHQtNDAgLTE0LjV0LTUxLjUgLTN0LTQ0IC0xMi41cS0zNSAtMjMgLTM1IC0xNjFsMSAtOTQzcTAgLTExOSAzNCAtMTQwcTE2IC0xMCA0NiAtMTMuNXQ1My41IC00LjV0NDEuNSAtMTUuNXQxOCAtNDQuNQpxMCAtMjYgLTEyIC00OHQtMzYgLTIyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDQ4IiB1bmljb2RlPSImI3hmMWRkOyIgaG9yaXotYWR2LXg9IjEyODAiIApkPSJNMTI3OCAxMzQ3di03M3EwIC0yOSAtMTguNSAtNjF0LTQyLjUgLTMycS01MCAwIC01NCAtMXEtMjYgLTYgLTMyIC0zMXEtMyAtMTEgLTMgLTY0di0xMTUycTAgLTI1IC0xOCAtNDN0LTQzIC0xOGgtMTA4cS0yNSAwIC00MyAxOHQtMTggNDN2MTIxOGgtMTQzdi0xMjE4cTAgLTI1IC0xNy41IC00M3QtNDMuNSAtMThoLTEwOHEtMjYgMCAtNDMuNSAxOHQtMTcuNSA0M3Y0OTZxLTE0NyAxMiAtMjQ1IDU5cS0xMjYgNTggLTE5MiAxNzkKcS02NCAxMTcgLTY0IDI1OXEwIDE2NiA4OCAyODZxODggMTE4IDIwOSAxNTlxMTExIDM3IDQxNyAzN2g0NzlxMjUgMCA0MyAtMTh0MTggLTQzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDQ5IiB1bmljb2RlPSImI3hmMWRlOyIgCmQ9Ik0zNTIgMTI4di0xMjhoLTM1MnYxMjhoMzUyek03MDQgMjU2cTI2IDAgNDUgLTE5dDE5IC00NXYtMjU2cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtMjU2cS0yNiAwIC00NSAxOXQtMTkgNDV2MjU2cTAgMjYgMTkgNDV0NDUgMTloMjU2ek04NjQgNjQwdi0xMjhoLTg2NHYxMjhoODY0ek0yMjQgMTE1MnYtMTI4aC0yMjR2MTI4aDIyNHpNMTUzNiAxMjh2LTEyOGgtNzM2djEyOGg3MzZ6TTU3NiAxMjgwcTI2IDAgNDUgLTE5dDE5IC00NXYtMjU2CnEwIC0yNiAtMTkgLTQ1dC00NSAtMTloLTI1NnEtMjYgMCAtNDUgMTl0LTE5IDQ1djI1NnEwIDI2IDE5IDQ1dDQ1IDE5aDI1NnpNMTIxNiA3NjhxMjYgMCA0NSAtMTl0MTkgLTQ1di0yNTZxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0yNTZxLTI2IDAgLTQ1IDE5dC0xOSA0NXYyNTZxMCAyNiAxOSA0NXQ0NSAxOWgyNTZ6TTE1MzYgNjQwdi0xMjhoLTIyNHYxMjhoMjI0ek0xNTM2IDExNTJ2LTEyOGgtODY0djEyOGg4NjR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYxRTAiIHVuaWNvZGU9IiYjeGYxZTA7IiAKZD0iTTEyMTYgNTEycTEzMyAwIDIyNi41IC05My41dDkzLjUgLTIyNi41dC05My41IC0yMjYuNXQtMjI2LjUgLTkzLjV0LTIyNi41IDkzLjV0LTkzLjUgMjI2LjVxMCAxMiAyIDM0bC0zNjAgMTgwcS05MiAtODYgLTIxOCAtODZxLTEzMyAwIC0yMjYuNSA5My41dC05My41IDIyNi41dDkzLjUgMjI2LjV0MjI2LjUgOTMuNXExMjYgMCAyMTggLTg2bDM2MCAxODBxLTIgMjIgLTIgMzRxMCAxMzMgOTMuNSAyMjYuNXQyMjYuNSA5My41CnQyMjYuNSAtOTMuNXQ5My41IC0yMjYuNXQtOTMuNSAtMjI2LjV0LTIyNi41IC05My41cS0xMjYgMCAtMjE4IDg2bC0zNjAgLTE4MHEyIC0yMiAyIC0zNHQtMiAtMzRsMzYwIC0xODBxOTIgODYgMjE4IDg2eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDUxIiB1bmljb2RlPSImI3hmMWUxOyIgCmQ9Ik0xMjgwIDM0MXEwIDg4IC02Mi41IDE1MXQtMTUwLjUgNjNxLTg0IDAgLTE0NSAtNThsLTI0MSAxMjBxMiAxNiAyIDIzdC0yIDIzbDI0MSAxMjBxNjEgLTU4IDE0NSAtNThxODggMCAxNTAuNSA2M3Q2Mi41IDE1MXQtNjIuNSAxNTAuNXQtMTUwLjUgNjIuNXQtMTUxIC02Mi41dC02MyAtMTUwLjVxMCAtNyAyIC0yM2wtMjQxIC0xMjBxLTYyIDU3IC0xNDUgNTdxLTg4IDAgLTE1MC41IC02Mi41dC02Mi41IC0xNTAuNXQ2Mi41IC0xNTAuNQp0MTUwLjUgLTYyLjVxODMgMCAxNDUgNTdsMjQxIC0xMjBxLTIgLTE2IC0yIC0yM3EwIC04OCA2MyAtMTUwLjV0MTUxIC02Mi41dDE1MC41IDYyLjV0NjIuNSAxNTAuNXpNMTUzNiAxMTIwdi05NjBxMCAtMTE5IC04NC41IC0yMDMuNXQtMjAzLjUgLTg0LjVoLTk2MHEtMTE5IDAgLTIwMy41IDg0LjV0LTg0LjUgMjAzLjV2OTYwcTAgMTE5IDg0LjUgMjAzLjV0MjAzLjUgODQuNWg5NjBxMTE5IDAgMjAzLjUgLTg0LjV0ODQuNSAtMjAzLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80NTIiIHVuaWNvZGU9IiYjeGYxZTI7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik01NzEgOTQ3cS0xMCAyNSAtMzQgMzV0LTQ5IDBxLTEwOCAtNDQgLTE5MSAtMTI3dC0xMjcgLTE5MXEtMTAgLTI1IDAgLTQ5dDM1IC0zNHExMyAtNSAyNCAtNXE0MiAwIDYwIDQwcTM0IDg0IDk4LjUgMTQ4LjV0MTQ4LjUgOTguNXEyNSAxMSAzNSAzNXQwIDQ5ek0xNTEzIDEzMDNsNDYgLTQ2bC0yNDQgLTI0M2w2OCAtNjhxMTkgLTE5IDE5IC00NS41dC0xOSAtNDUuNWwtNjQgLTY0cTg5IC0xNjEgODkgLTM0M3EwIC0xNDMgLTU1LjUgLTI3My41CnQtMTUwIC0yMjV0LTIyNSAtMTUwdC0yNzMuNSAtNTUuNXQtMjczLjUgNTUuNXQtMjI1IDE1MHQtMTUwIDIyNXQtNTUuNSAyNzMuNXQ1NS41IDI3My41dDE1MCAyMjV0MjI1IDE1MHQyNzMuNSA1NS41cTE4MiAwIDM0MyAtODlsNjQgNjRxMTkgMTkgNDUuNSAxOXQ0NS41IC0xOWw2OCAtNjh6TTE1MjEgMTM1OXEtMTAgLTEwIC0yMiAtMTBxLTEzIDAgLTIzIDEwbC05MSA5MHEtOSAxMCAtOSAyM3Q5IDIzcTEwIDkgMjMgOXQyMyAtOWw5MCAtOTEKcTEwIC05IDEwIC0yMi41dC0xMCAtMjIuNXpNMTc1MSAxMTI5cS0xMSAtOSAtMjMgLTl0LTIzIDlsLTkwIDkxcS0xMCA5IC0xMCAyMi41dDEwIDIyLjVxOSAxMCAyMi41IDEwdDIyLjUgLTEwbDkxIC05MHE5IC0xMCA5IC0yM3QtOSAtMjN6TTE3OTIgMTMxMnEwIC0xNCAtOSAtMjN0LTIzIC05aC05NnEtMTQgMCAtMjMgOXQtOSAyM3Q5IDIzdDIzIDloOTZxMTQgMCAyMyAtOXQ5IC0yM3pNMTYwMCAxNTA0di05NnEwIC0xNCAtOSAtMjN0LTIzIC05CnQtMjMgOXQtOSAyM3Y5NnEwIDE0IDkgMjN0MjMgOXQyMyAtOXQ5IC0yM3pNMTc1MSAxNDQ5bC05MSAtOTBxLTEwIC0xMCAtMjIgLTEwcS0xMyAwIC0yMyAxMHEtMTAgOSAtMTAgMjIuNXQxMCAyMi41bDkwIDkxcTEwIDkgMjMgOXQyMyAtOXE5IC0xMCA5IC0yM3QtOSAtMjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80NTMiIHVuaWNvZGU9IiYjeGYxZTM7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik02MDkgNzIwbDI4NyAyMDhsMjg3IC0yMDhsLTEwOSAtMzM2aC0zNTV6TTg5NiAxNTM2cTE4MiAwIDM0OCAtNzF0Mjg2IC0xOTF0MTkxIC0yODZ0NzEgLTM0OHQtNzEgLTM0OHQtMTkxIC0yODZ0LTI4NiAtMTkxdC0zNDggLTcxdC0zNDggNzF0LTI4NiAxOTF0LTE5MSAyODZ0LTcxIDM0OHQ3MSAzNDh0MTkxIDI4NnQyODYgMTkxdDM0OCA3MXpNMTUxNSAxODZxMTQ5IDIwMyAxNDkgNDU0djNsLTEwMiAtODlsLTI0MCAyMjRsNjMgMzIzCmwxMzQgLTEycS0xNTAgMjA2IC0zODkgMjgybDUzIC0xMjRsLTI4NyAtMTU5bC0yODcgMTU5bDUzIDEyNHEtMjM5IC03NiAtMzg5IC0yODJsMTM1IDEybDYyIC0zMjNsLTI0MCAtMjI0bC0xMDIgODl2LTNxMCAtMjUxIDE0OSAtNDU0bDMwIDEzMmwzMjYgLTQwbDEzOSAtMjk4bC0xMTYgLTY5cTExNyAtMzkgMjQwIC0zOXQyNDAgMzlsLTExNiA2OWwxMzkgMjk4bDMyNiA0MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQ1NCIgdW5pY29kZT0iJiN4ZjFlNDsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTQ0OCAyMjR2LTE5MnEwIC0xNCAtOSAtMjN0LTIzIC05aC0xOTJxLTE0IDAgLTIzIDl0LTkgMjN2MTkycTAgMTQgOSAyM3QyMyA5aDE5MnExNCAwIDIzIC05dDkgLTIzek0yNTYgNjA4di0xOTJxMCAtMTQgLTkgLTIzdC0yMyAtOWgtMTkycS0xNCAwIC0yMyA5dC05IDIzdjE5MnEwIDE0IDkgMjN0MjMgOWgxOTJxMTQgMCAyMyAtOXQ5IC0yM3pNODMyIDIyNHYtMTkycTAgLTE0IC05IC0yM3QtMjMgLTloLTE5MnEtMTQgMCAtMjMgOXQtOSAyMwp2MTkycTAgMTQgOSAyM3QyMyA5aDE5MnExNCAwIDIzIC05dDkgLTIzek02NDAgNjA4di0xOTJxMCAtMTQgLTkgLTIzdC0yMyAtOWgtMTkycS0xNCAwIC0yMyA5dC05IDIzdjE5MnEwIDE0IDkgMjN0MjMgOWgxOTJxMTQgMCAyMyAtOXQ5IC0yM3pNNjYgNzY4cS0yOCAwIC00NyAxOXQtMTkgNDZ2MTI5aDUxNHYtMTI5cTAgLTI3IC0xOSAtNDZ0LTQ2IC0xOWgtMzgzek0xMjE2IDIyNHYtMTkycTAgLTE0IC05IC0yM3QtMjMgLTloLTE5MgpxLTE0IDAgLTIzIDl0LTkgMjN2MTkycTAgMTQgOSAyM3QyMyA5aDE5MnExNCAwIDIzIC05dDkgLTIzek0xMDI0IDYwOHYtMTkycTAgLTE0IC05IC0yM3QtMjMgLTloLTE5MnEtMTQgMCAtMjMgOXQtOSAyM3YxOTJxMCAxNCA5IDIzdDIzIDloMTkycTE0IDAgMjMgLTl0OSAtMjN6TTE2MDAgMjI0di0xOTJxMCAtMTQgLTkgLTIzdC0yMyAtOWgtMTkycS0xNCAwIC0yMyA5dC05IDIzdjE5MnEwIDE0IDkgMjN0MjMgOWgxOTJxMTQgMCAyMyAtOXQ5IC0yMwp6TTE0MDggNjA4di0xOTJxMCAtMTQgLTkgLTIzdC0yMyAtOWgtMTkycS0xNCAwIC0yMyA5dC05IDIzdjE5MnEwIDE0IDkgMjN0MjMgOWgxOTJxMTQgMCAyMyAtOXQ5IC0yM3pNMTc5MiAxMDE2di0xM2gtNTE0djEwcTAgMTA0IC0zODIgMTAycS0zODIgLTEgLTM4MiAtMTAydi0xMGgtNTE0djEzcTAgMTcgOC41IDQzdDM0IDY0dDY1LjUgNzUuNXQxMTAuNSA3NnQxNjAgNjcuNXQyMjQgNDcuNXQyOTMuNSAxOC41dDI5MyAtMTguNXQyMjQgLTQ3LjUKdDE2MC41IC02Ny41dDExMC41IC03NnQ2NS41IC03NS41dDM0IC02NHQ4LjUgLTQzek0xNzkyIDYwOHYtMTkycTAgLTE0IC05IC0yM3QtMjMgLTloLTE5MnEtMTQgMCAtMjMgOXQtOSAyM3YxOTJxMCAxNCA5IDIzdDIzIDloMTkycTE0IDAgMjMgLTl0OSAtMjN6TTE3OTIgOTYydi0xMjlxMCAtMjcgLTE5IC00NnQtNDYgLTE5aC0zODRxLTI3IDAgLTQ2IDE5dC0xOSA0NnYxMjloNTE0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDU1IiB1bmljb2RlPSImI3hmMWU1OyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNNzA0IDEyMTZ2LTc2OHEwIC0yNiAtMTkgLTQ1dC00NSAtMTl2LTU3NnEwIC0yNiAtMTkgLTQ1dC00NSAtMTloLTUxMnEtMjYgMCAtNDUgMTl0LTE5IDQ1djUxMmwyNDkgODczcTcgMjMgMzEgMjNoNDI0ek0xMDI0IDEyMTZ2LTcwNGgtMjU2djcwNGgyNTZ6TTE3OTIgMzIwdi01MTJxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC01MTJxLTI2IDAgLTQ1IDE5dC0xOSA0NXY1NzZxLTI2IDAgLTQ1IDE5dC0xOSA0NXY3NjhoNDI0cTI0IDAgMzEgLTIzegpNNzM2IDE1MDR2LTIyNGgtMzUydjIyNHEwIDE0IDkgMjN0MjMgOWgyODhxMTQgMCAyMyAtOXQ5IC0yM3pNMTQwOCAxNTA0di0yMjRoLTM1MnYyMjRxMCAxNCA5IDIzdDIzIDloMjg4cTE0IDAgMjMgLTl0OSAtMjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80NTYiIHVuaWNvZGU9IiYjeGYxZTY7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xNzU1IDEwODNxMzcgLTM4IDM3IC05MC41dC0zNyAtOTAuNWwtNDAxIC00MDBsMTUwIC0xNTBsLTE2MCAtMTYwcS0xNjMgLTE2MyAtMzg5LjUgLTE4Ni41dC00MTEuNSAxMDAuNWwtMzYyIC0zNjJoLTE4MXYxODFsMzYyIDM2MnEtMTI0IDE4NSAtMTAwLjUgNDExLjV0MTg2LjUgMzg5LjVsMTYwIDE2MGwxNTAgLTE1MGw0MDAgNDAxcTM4IDM3IDkxIDM3dDkwIC0zN3QzNyAtOTAuNXQtMzcgLTkwLjVsLTQwMCAtNDAxbDIzNCAtMjM0Cmw0MDEgNDAwcTM4IDM3IDkxIDM3dDkwIC0zN3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQ1NyIgdW5pY29kZT0iJiN4ZjFlNzsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTg3MyA3OTZxMCAtODMgLTYzLjUgLTE0Mi41dC0xNTIuNSAtNTkuNXQtMTUyLjUgNTkuNXQtNjMuNSAxNDIuNXEwIDg0IDYzLjUgMTQzdDE1Mi41IDU5dDE1Mi41IC01OXQ2My41IC0xNDN6TTEzNzUgNzk2cTAgLTgzIC02MyAtMTQyLjV0LTE1MyAtNTkuNXEtODkgMCAtMTUyLjUgNTkuNXQtNjMuNSAxNDIuNXEwIDg0IDYzLjUgMTQzdDE1Mi41IDU5cTkwIDAgMTUzIC01OXQ2MyAtMTQzek0xNjAwIDYxNnY2NjdxMCA4NyAtMzIgMTIzLjUKdC0xMTEgMzYuNWgtMTExMnEtODMgMCAtMTEyLjUgLTM0dC0yOS41IC0xMjZ2LTY3M3E0MyAtMjMgODguNSAtNDB0ODEgLTI4dDgxIC0xOC41dDcxIC0xMXQ3MCAtNHQ1OC41IC0wLjV0NTYuNSAydDQ0LjUgMnE2OCAxIDk1IC0yN3E2IC02IDEwIC05cTI2IC0yNSA2MSAtNTFxNyA5MSAxMTggODdxNSAwIDM2LjUgLTEuNXQ0MyAtMnQ0NS41IC0xdDUzIDF0NTQuNSA0LjV0NjEgOC41dDYyIDEzLjV0NjcgMTkuNXQ2Ny41IDI3dDcyIDM0LjV6Ck0xNzYzIDYyMXEtMTIxIC0xNDkgLTM3MiAtMjUycTg0IC0yODUgLTIzIC00NjVxLTY2IC0xMTMgLTE4MyAtMTQ4cS0xMDQgLTMyIC0xODIgMTVxLTg2IDUxIC04MiAxNjRsLTEgMzI2djFxLTggMiAtMjQuNSA2dC0yMy41IDVsLTEgLTMzOHE0IC0xMTQgLTgzIC0xNjRxLTc5IC00NyAtMTgzIC0xNXEtMTE3IDM2IC0xODIgMTUwcS0xMDUgMTgwIC0yMiA0NjNxLTI1MSAxMDMgLTM3MiAyNTJxLTI1IDM3IC00IDYzdDYwIC0xcTQgLTIgMTEuNSAtNwp0MTAuNSAtOHY2OTRxMCA3MiA0NyAxMjN0MTE0IDUxaDEyNTdxNjcgMCAxMTQgLTUxdDQ3IC0xMjN2LTY5NGwyMSAxNXEzOSAyNyA2MCAxdC00IC02M3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQ1OCIgdW5pY29kZT0iJiN4ZjFlODsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTg5NiAxMTAydi00MzRoLTE0NXY0MzRoMTQ1ek0xMjk0IDExMDJ2LTQzNGgtMTQ1djQzNGgxNDV6TTEyOTQgMzQybDI1MyAyNTR2Nzk1aC0xMTk0di0xMDQ5aDMyNnYtMjE3bDIxNyAyMTdoMzk4ek0xNjkyIDE1MzZ2LTEwMTNsLTQzNCAtNDM0aC0zMjZsLTIxNyAtMjE3aC0yMTd2MjE3aC0zOTh2MTE1OGwxMDkgMjg5aDE0ODN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80NTkiIHVuaWNvZGU9IiYjeGYxZTk7IiAKZD0iTTc3MyAyMTd2LTEyN3EtMSAtMjkyIC02IC0zMDVxLTEyIC0zMiAtNTEgLTQwcS01NCAtOSAtMTgxLjUgMzh0LTE2Mi41IDg5cS0xMyAxNSAtMTcgMzZxLTEgMTIgNCAyNnE0IDEwIDM0IDQ3dDE4MSAyMTZxMSAwIDYwIDcwcTE1IDE5IDM5LjUgMjQuNXQ0OS41IC0zLjVxMjQgLTEwIDM3LjUgLTI5dDEyLjUgLTQyek02MjQgNDY4cS0zIC01NSAtNTIgLTcwbC0xMjAgLTM5cS0yNzUgLTg4IC0yOTIgLTg4cS0zNSAyIC01NCAzNgpxLTEyIDI1IC0xNyA3NXEtOCA3NiAxIDE2Ni41dDMwIDEyNC41dDU2IDMycTEzIDAgMjAyIC03N3E3MSAtMjkgMTE1IC00N2w4NCAtMzRxMjMgLTkgMzUuNSAtMzAuNXQxMS41IC00OC41ek0xNDUwIDE3MXEtNyAtNTQgLTkxLjUgLTE2MXQtMTM1LjUgLTEyN3EtMzcgLTE0IC02MyA3cS0xNCAxMCAtMTg0IDI4N2wtNDcgNzdxLTE0IDIxIC0xMS41IDQ2dDE5LjUgNDZxMzUgNDMgODMgMjZxMSAtMSAxMTkgLTQwcTIwMyAtNjYgMjQyIC03OS41CnQ0NyAtMjAuNXEyOCAtMjIgMjIgLTYxek03NzggODAzcTUgLTEwMiAtNTQgLTEyMnEtNTggLTE3IC0xMTQgNzFsLTM3OCA1OThxLTggMzUgMTkgNjJxNDEgNDMgMjA3LjUgODkuNXQyMjQuNSAzMS41cTQwIC0xMCA0OSAtNDVxMyAtMTggMjIgLTMwNS41dDI0IC0zNzkuNXpNMTQ0MCA2OTVxMyAtMzkgLTI2IC01OXEtMTUgLTEwIC0zMjkgLTg2cS02NyAtMTUgLTkxIC0yM2wxIDJxLTIzIC02IC00NiA0dC0zNyAzMnEtMzAgNDcgMCA4NwpxMSAxIDc1IDEwMnExMjUgMTcxIDE1MCAyMDR0MzQgMzlxMjggMTkgNjUgMnE0OCAtMjMgMTIzIC0xMzMuNXQ4MSAtMTY3LjV2LTN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80NjAiIHVuaWNvZGU9IiYjeGYxZWE7IiBob3Jpei1hZHYteD0iMjA0OCIgCmQ9Ik0xMDI0IDEwMjRoLTM4NHYtMzg0aDM4NHYzODR6TTExNTIgMzg0di0xMjhoLTY0MHYxMjhoNjQwek0xMTUyIDExNTJ2LTY0MGgtNjQwdjY0MGg2NDB6TTE3OTIgMzg0di0xMjhoLTUxMnYxMjhoNTEyek0xNzkyIDY0MHYtMTI4aC01MTJ2MTI4aDUxMnpNMTc5MiA4OTZ2LTEyOGgtNTEydjEyOGg1MTJ6TTE3OTIgMTE1MnYtMTI4aC01MTJ2MTI4aDUxMnpNMjU2IDE5MnY5NjBoLTEyOHYtOTYwcTAgLTI2IDE5IC00NXQ0NSAtMTl0NDUgMTkKdDE5IDQ1ek0xOTIwIDE5MnYxMDg4aC0xNTM2di0xMDg4cTAgLTMzIC0xMSAtNjRoMTQ4M3EyNiAwIDQ1IDE5dDE5IDQ1ek0yMDQ4IDE0MDh2LTEyMTZxMCAtODAgLTU2IC0xMzZ0LTEzNiAtNTZoLTE2NjRxLTgwIDAgLTEzNiA1NnQtNTYgMTM2djEwODhoMjU2djEyOGgxNzkyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDYxIiB1bmljb2RlPSImI3hmMWViOyIgaG9yaXotYWR2LXg9IjIwNDgiIApkPSJNMTAyNCAxM3EtMjAgMCAtOTMgNzMuNXQtNzMgOTMuNXEwIDMyIDYyLjUgNTR0MTAzLjUgMjJ0MTAzLjUgLTIydDYyLjUgLTU0cTAgLTIwIC03MyAtOTMuNXQtOTMgLTczLjV6TTEyOTQgMjg0cS0yIDAgLTQwIDI1dC0xMDEuNSA1MHQtMTI4LjUgMjV0LTEyOC41IC0yNXQtMTAxIC01MHQtNDAuNSAtMjVxLTE4IDAgLTkzLjUgNzV0LTc1LjUgOTNxMCAxMyAxMCAyM3E3OCA3NyAxOTYgMTIxdDIzMyA0NHQyMzMgLTQ0dDE5NiAtMTIxCnExMCAtMTAgMTAgLTIzcTAgLTE4IC03NS41IC05M3QtOTMuNSAtNzV6TTE1NjcgNTU2cS0xMSAwIC0yMyA4cS0xMzYgMTA1IC0yNTIgMTU0LjV0LTI2OCA0OS41cS04NSAwIC0xNzAuNSAtMjJ0LTE0OSAtNTN0LTExMy41IC02MnQtNzkgLTUzdC0zMSAtMjJxLTE3IDAgLTkyIDc1dC03NSA5M3EwIDEyIDEwIDIycTEzMiAxMzIgMzIwIDIwNXQzODAgNzN0MzgwIC03M3QzMjAgLTIwNXExMCAtMTAgMTAgLTIycTAgLTE4IC03NSAtOTN0LTkyIC03NXoKTTE4MzggODI3cS0xMSAwIC0yMiA5cS0xNzkgMTU3IC0zNzEuNSAyMzYuNXQtNDIwLjUgNzkuNXQtNDIwLjUgLTc5LjV0LTM3MS41IC0yMzYuNXEtMTEgLTkgLTIyIC05cS0xNyAwIC05Mi41IDc1dC03NS41IDkzcTAgMTMgMTAgMjNxMTg3IDE4NiA0NDUgMjg4dDUyNyAxMDJ0NTI3IC0xMDJ0NDQ1IC0yODhxMTAgLTEwIDEwIC0yM3EwIC0xOCAtNzUuNSAtOTN0LTkyLjUgLTc1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDYyIiB1bmljb2RlPSImI3hmMWVjOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMzg0IDBxMCA1MyAtMzcuNSA5MC41dC05MC41IDM3LjV0LTkwLjUgLTM3LjV0LTM3LjUgLTkwLjV0MzcuNSAtOTAuNXQ5MC41IC0zNy41dDkwLjUgMzcuNXQzNy41IDkwLjV6TTc2OCAwcTAgNTMgLTM3LjUgOTAuNXQtOTAuNSAzNy41dC05MC41IC0zNy41dC0zNy41IC05MC41dDM3LjUgLTkwLjV0OTAuNSAtMzcuNXQ5MC41IDM3LjV0MzcuNSA5MC41ek0zODQgMzg0cTAgNTMgLTM3LjUgOTAuNXQtOTAuNSAzNy41dC05MC41IC0zNy41CnQtMzcuNSAtOTAuNXQzNy41IC05MC41dDkwLjUgLTM3LjV0OTAuNSAzNy41dDM3LjUgOTAuNXpNMTE1MiAwcTAgNTMgLTM3LjUgOTAuNXQtOTAuNSAzNy41dC05MC41IC0zNy41dC0zNy41IC05MC41dDM3LjUgLTkwLjV0OTAuNSAtMzcuNXQ5MC41IDM3LjV0MzcuNSA5MC41ek03NjggMzg0cTAgNTMgLTM3LjUgOTAuNXQtOTAuNSAzNy41dC05MC41IC0zNy41dC0zNy41IC05MC41dDM3LjUgLTkwLjV0OTAuNSAtMzcuNXQ5MC41IDM3LjUKdDM3LjUgOTAuNXpNMzg0IDc2OHEwIDUzIC0zNy41IDkwLjV0LTkwLjUgMzcuNXQtOTAuNSAtMzcuNXQtMzcuNSAtOTAuNXQzNy41IC05MC41dDkwLjUgLTM3LjV0OTAuNSAzNy41dDM3LjUgOTAuNXpNMTE1MiAzODRxMCA1MyAtMzcuNSA5MC41dC05MC41IDM3LjV0LTkwLjUgLTM3LjV0LTM3LjUgLTkwLjV0MzcuNSAtOTAuNXQ5MC41IC0zNy41dDkwLjUgMzcuNXQzNy41IDkwLjV6TTc2OCA3NjhxMCA1MyAtMzcuNSA5MC41dC05MC41IDM3LjUKdC05MC41IC0zNy41dC0zNy41IC05MC41dDM3LjUgLTkwLjV0OTAuNSAtMzcuNXQ5MC41IDM3LjV0MzcuNSA5MC41ek0xNTM2IDB2Mzg0cTAgNTIgLTM4IDkwdC05MCAzOHQtOTAgLTM4dC0zOCAtOTB2LTM4NHEwIC01MiAzOCAtOTB0OTAgLTM4dDkwIDM4dDM4IDkwek0xMTUyIDc2OHEwIDUzIC0zNy41IDkwLjV0LTkwLjUgMzcuNXQtOTAuNSAtMzcuNXQtMzcuNSAtOTAuNXQzNy41IC05MC41dDkwLjUgLTM3LjV0OTAuNSAzNy41dDM3LjUgOTAuNXoKTTE1MzYgMTA4OHYyNTZxMCAyNiAtMTkgNDV0LTQ1IDE5aC0xMjgwcS0yNiAwIC00NSAtMTl0LTE5IC00NXYtMjU2cTAgLTI2IDE5IC00NXQ0NSAtMTloMTI4MHEyNiAwIDQ1IDE5dDE5IDQ1ek0xNTM2IDc2OHEwIDUzIC0zNy41IDkwLjV0LTkwLjUgMzcuNXQtOTAuNSAtMzcuNXQtMzcuNSAtOTAuNXQzNy41IC05MC41dDkwLjUgLTM3LjV0OTAuNSAzNy41dDM3LjUgOTAuNXpNMTY2NCAxNDA4di0xNTM2cTAgLTUyIC0zOCAtOTB0LTkwIC0zOApoLTE0MDhxLTUyIDAgLTkwIDM4dC0zOCA5MHYxNTM2cTAgNTIgMzggOTB0OTAgMzhoMTQwOHE1MiAwIDkwIC0zOHQzOCAtOTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80NjMiIHVuaWNvZGU9IiYjeGYxZWQ7IiAKZD0iTTE1MTkgODkwcTE4IC04NCAtNCAtMjA0cS04NyAtNDQ0IC01NjUgLTQ0NGgtNDRxLTI1IDAgLTQ0IC0xNi41dC0yNCAtNDIuNWwtNCAtMTlsLTU1IC0zNDZsLTIgLTE1cS01IC0yNiAtMjQuNSAtNDIuNXQtNDQuNSAtMTYuNWgtMjUxcS0yMSAwIC0zMyAxNXQtOSAzNnE5IDU2IDI2LjUgMTY4dDI2LjUgMTY4dDI3IDE2Ny41dDI3IDE2Ny41cTUgMzcgNDMgMzdoMTMxcTEzMyAtMiAyMzYgMjFxMTc1IDM5IDI4NyAxNDRxMTAyIDk1IDE1NSAyNDYKcTI0IDcwIDM1IDEzM3ExIDYgMi41IDcuNXQzLjUgMXQ2IC0zLjVxNzkgLTU5IDk4IC0xNjJ6TTEzNDcgMTE3MnEwIC0xMDcgLTQ2IC0yMzZxLTgwIC0yMzMgLTMwMiAtMzE1cS0xMTMgLTQwIC0yNTIgLTQycTAgLTEgLTkwIC0xbC05MCAxcS0xMDAgMCAtMTE4IC05NnEtMiAtOCAtODUgLTUzMHEtMSAtMTAgLTEyIC0xMGgtMjk1cS0yMiAwIC0zNi41IDE2LjV0LTExLjUgMzguNWwyMzIgMTQ3MXE1IDI5IDI3LjUgNDh0NTEuNSAxOWg1OTgKcTM0IDAgOTcuNSAtMTN0MTExLjUgLTMycTEwNyAtNDEgMTYzLjUgLTEyM3Q1Ni41IC0xOTZ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80NjQiIHVuaWNvZGU9IiYjeGYxZWU7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik00NDEgODY0cTMzIDAgNTIgLTI2cTI2NiAtMzY0IDM2MiAtNzc0aC00NDZxLTEyNyA0NDEgLTM2NyA3NDlxLTEyIDE2IC0zIDMzLjV0MjkgMTcuNWgzNzN6TTEwMDAgNTA3cS00OSAtMTk5IC0xMjUgLTM5M3EtNzkgMzEwIC0yNTYgNTk0cTQwIDIyMSA0NCA0NDlxMjExIC0zNDAgMzM3IC02NTB6TTEwOTkgMTIxNnEyMzUgLTMyNCAzODQuNSAtNjk4LjV0MTg0LjUgLTc3My41aC00NTFxLTQxIDY2NSAtNTUzIDE0NzJoNDM1ek0xNzkyIDY0MApxMCAtNDI0IC0xMDEgLTgxMnEtNjcgNTYwIC0zNTkgMTA4M3EtMjUgMzAxIC0xMDYgNTg0cS00IDE2IDUuNSAyOC41dDI1LjUgMTIuNWgzNTlxMjEgMCAzOC41IC0xM3QyMi41IC0zM3ExMTUgLTQwOSAxMTUgLTg1MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjFGMCIgdW5pY29kZT0iJiN4ZjFmMDsiIGhvcml6LWFkdi14PSIyMzA0IiAKZD0iTTE5NzUgNTQ2aC0xMzhxMTQgMzcgNjYgMTc5bDMgOXE0IDEwIDEwIDI2dDkgMjZsMTIgLTU1ek01MzEgNjExbC01OCAyOTVxLTExIDU0IC03NSA1NGgtMjY4bC0yIC0xM3EzMTEgLTc5IDQwMyAtMzM2ek03MTAgOTYwbC0xNjIgLTQzOGwtMTcgODlxLTI2IDcwIC04NSAxMjkuNXQtMTMxIDg4LjVsMTM1IC01MTBoMTc1bDI2MSA2NDFoLTE3NnpNODQ5IDMxOGgxNjZsMTA0IDY0MmgtMTY2ek0xNjE3IDk0NHEtNjkgMjcgLTE0OSAyNwpxLTEyMyAwIC0yMDEgLTU5dC03OSAtMTUzcS0xIC0xMDIgMTQ1IC0xNzRxNDggLTIzIDY3IC00MXQxOSAtMzlxMCAtMzAgLTMwIC00NnQtNjkgLTE2cS04NiAwIC0xNTYgMzNsLTIyIDExbC0yMyAtMTQ0cTc0IC0zNCAxODUgLTM0cTEzMCAtMSAyMDguNSA1OXQ4MC41IDE2MHEwIDEwNiAtMTQwIDE3NHEtNDkgMjUgLTcxIDQydC0yMiAzOHEwIDIyIDI0LjUgMzguNXQ3MC41IDE2LjVxNzAgMSAxMjQgLTI0bDE1IC04ek0yMDQyIDk2MGgtMTI4CnEtNjUgMCAtODcgLTU0bC0yNDYgLTU4OGgxNzRsMzUgOTZoMjEycTUgLTIyIDIwIC05NmgxNTR6TTIzMDQgMTI4MHYtMTI4MHEwIC01MiAtMzggLTkwdC05MCAtMzhoLTIwNDhxLTUyIDAgLTkwIDM4dC0zOCA5MHYxMjgwcTAgNTIgMzggOTB0OTAgMzhoMjA0OHE1MiAwIDkwIC0zOHQzOCAtOTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80NjYiIHVuaWNvZGU9IiYjeGYxZjE7IiBob3Jpei1hZHYteD0iMjMwNCIgCmQ9Ik0xMTE5IDExOTVxLTEyOCA4NSAtMjgxIDg1cS0xMDMgMCAtMTk3LjUgLTQwLjV0LTE2Mi41IC0xMDguNXQtMTA4LjUgLTE2MnQtNDAuNSAtMTk3cTAgLTEwNCA0MC41IC0xOTh0MTA4LjUgLTE2MnQxNjIgLTEwOC41dDE5OCAtNDAuNXExNTMgMCAyODEgODVxLTEzMSAxMDcgLTE3OCAyNjUuNXQwLjUgMzE2LjV0MTc3LjUgMjY1ek0xMTUyIDExNzFxLTEyNiAtOTkgLTE3MiAtMjQ5LjV0LTAuNSAtMzAwLjV0MTcyLjUgLTI0OQpxMTI3IDk5IDE3Mi41IDI0OXQtMC41IDMwMC41dC0xNzIgMjQ5LjV6TTExODUgMTE5NXExMzAgLTEwNyAxNzcuNSAtMjY1LjV0MC41IC0zMTd0LTE3OCAtMjY0LjVxMTI4IC04NSAyODEgLTg1cTEwNCAwIDE5OCA0MC41dDE2MiAxMDguNXQxMDguNSAxNjJ0NDAuNSAxOThxMCAxMDMgLTQwLjUgMTk3dC0xMDguNSAxNjJ0LTE2Mi41IDEwOC41dC0xOTcuNSA0MC41cS0xNTMgMCAtMjgxIC04NXpNMTkyNiA0NzNoN3YzaC0xN3YtM2g3di0xN2gzdjE3egpNMTk1NSA0NTZoNHYyMGgtNWwtNiAtMTNsLTYgMTNoLTV2LTIwaDN2MTVsNiAtMTNoNGw1IDEzdi0xNXpNMTk0NyAxNnYtMmgtMmgtM3YzaDNoMnYtMXpNMTk0NyA3aDNsLTQgNWgybDEgMXExIDEgMSAzdC0xIDNsLTEgMWgtM2gtNnYtMTNoM3Y1aDF6TTY4NSA3NXEwIDE5IDExIDMxdDMwIDEycTE4IDAgMjkgLTEyLjV0MTEgLTMwLjVxMCAtMTkgLTExIC0zMXQtMjkgLTEycS0xOSAwIC0zMCAxMnQtMTEgMzF6TTExNTggMTE5cTMwIDAgMzUgLTMyCmgtNzBxNSAzMiAzNSAzMnpNMTUxNCA3NXEwIDE5IDExIDMxdDI5IDEydDI5LjUgLTEyLjV0MTEuNSAtMzAuNXEwIC0xOSAtMTEgLTMxdC0zMCAtMTJxLTE4IDAgLTI5IDEydC0xMSAzMXpNMTc4NiA3NXEwIDE4IDExLjUgMzAuNXQyOS41IDEyLjV0MjkuNSAtMTIuNXQxMS41IC0zMC41cTAgLTE5IC0xMS41IC0zMXQtMjkuNSAtMTJ0LTI5LjUgMTIuNXQtMTEuNSAzMC41ek0xOTQ0IDNxLTIgMCAtNCAxcS0xIDAgLTMgMnQtMiAzcS0xIDIgLTEgNApxMCAzIDEgNHEwIDIgMiA0bDEgMXEyIDAgMiAxcTIgMSA0IDFxMyAwIDQgLTFsNCAtMmwyIC00di0xcTEgLTIgMSAtM2wtMSAtMXYtM3QtMSAtMWwtMSAtMnEtMiAtMiAtNCAtMnEtMSAtMSAtNCAtMXpNNTk5IDdoMzB2ODVxMCAyNCAtMTQuNSAzOC41dC0zOS41IDE1LjVxLTMyIDAgLTQ3IC0yNHEtMTQgMjQgLTQ1IDI0cS0yNCAwIC0zOSAtMjB2MTZoLTMwdi0xMzVoMzB2NzVxMCAzNiAzMyAzNnEzMCAwIDMwIC0zNnYtNzVoMjl2NzUKcTAgMzYgMzMgMzZxMzAgMCAzMCAtMzZ2LTc1ek03NjUgN2gyOXY2OHY2N2gtMjl2LTE2cS0xNyAyMCAtNDMgMjBxLTI5IDAgLTQ4IC0yMHQtMTkgLTUxdDE5IC01MXQ0OCAtMjBxMjggMCA0MyAyMHYtMTd6TTk0MyA0OHEwIDM0IC00NyA0MGwtMTQgMnEtMjMgNCAtMjMgMTRxMCAxNSAyNSAxNXEyMyAwIDQzIC0xMWwxMiAyNHEtMjIgMTQgLTU1IDE0cS0yNiAwIC00MSAtMTJ0LTE1IC0zMnEwIC0zMyA0NyAtMzlsMTMgLTJxMjQgLTQgMjQgLTE0CnEwIC0xNyAtMzEgLTE3cS0yNSAwIC00NSAxNGwtMTMgLTIzcTI1IC0xNyA1OCAtMTdxMjkgMCA0NS41IDEydDE2LjUgMzJ6TTEwNzMgMTRsLTggMjVxLTEzIC03IC0yNiAtN3EtMTkgMCAtMTkgMjJ2NjFoNDh2MjdoLTQ4djQxaC0zMHYtNDFoLTI4di0yN2gyOHYtNjFxMCAtNTAgNDcgLTUwcTIxIDAgMzYgMTB6TTExNTkgMTQ2cS0yOSAwIC00OCAtMjB0LTE5IC01MXEwIC0zMiAxOS41IC01MS41dDQ5LjUgLTE5LjVxMzMgMCA1NSAxOWwtMTQgMjIKcS0xOCAtMTUgLTM5IC0xNXEtMzQgMCAtNDEgMzNoMTAxdjEycTAgMzIgLTE4IDUxLjV0LTQ2IDE5LjV6TTEzMTggMTQ2cS0yMyAwIC0zNSAtMjB2MTZoLTMwdi0xMzVoMzB2NzZxMCAzNSAyOSAzNXExMCAwIDE4IC00bDkgMjhxLTkgNCAtMjEgNHpNMTM0OCA3NXEwIC0zMSAxOS41IC01MXQ1Mi41IC0yMHEyOSAwIDQ4IDE2bC0xNCAyNHEtMTggLTEzIC0zNSAtMTJxLTE4IDAgLTI5LjUgMTJ0LTExLjUgMzF0MTEuNSAzMXQyOS41IDEyCnExOSAwIDM1IC0xMmwxNCAyNHEtMjAgMTYgLTQ4IDE2cS0zMyAwIC01Mi41IC0yMHQtMTkuNSAtNTF6TTE1OTMgN2gzMHY2OHY2N2gtMzB2LTE2cS0xNSAyMCAtNDIgMjBxLTI5IDAgLTQ4LjUgLTIwdC0xOS41IC01MXQxOS41IC01MXQ0OC41IC0yMHEyOCAwIDQyIDIwdi0xN3pNMTcyNiAxNDZxLTIzIDAgLTM1IC0yMHYxNmgtMjl2LTEzNWgyOXY3NnEwIDM1IDI5IDM1cTEwIDAgMTggLTRsOSAyOHEtOCA0IC0yMSA0ek0xODY2IDdoMjl2Njh2MTIyCmgtMjl2LTcxcS0xNSAyMCAtNDMgMjB0LTQ3LjUgLTIwLjV0LTE5LjUgLTUwLjV0MTkuNSAtNTAuNXQ0Ny41IC0yMC41cTI5IDAgNDMgMjB2LTE3ek0xOTQ0IDI3bC0yIC0xaC0zcS0yIC0xIC00IC0zcS0zIC0xIC0zIC00cS0xIC0yIC0xIC02cTAgLTMgMSAtNXEwIC0yIDMgLTRxMiAtMiA0IC0zdDUgLTFxNCAwIDYgMXEwIDEgMiAybDIgMXExIDEgMyA0cTEgMiAxIDVxMCA0IC0xIDZxLTEgMSAtMyA0cTAgMSAtMiAybC0yIDFxLTEgMCAtMyAwLjUKdC0zIDAuNXpNMjMwNCAxMjgwdi0xMjgwcTAgLTUyIC0zOCAtOTB0LTkwIC0zOGgtMjA0OHEtNTIgMCAtOTAgMzh0LTM4IDkwdjEyODBxMCA1MiAzOCA5MHQ5MCAzOGgyMDQ4cTUyIDAgOTAgLTM4dDM4IC05MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQ2NyIgdW5pY29kZT0iJiN4ZjFmMjsiIGhvcml6LWFkdi14PSIyMzA0IiAKZD0iTTMxMyA3NTlxMCAtNTEgLTM2IC04NHEtMjkgLTI2IC04OSAtMjZoLTE3djIyMGgxN3E2MSAwIDg5IC0yN3EzNiAtMzEgMzYgLTgzek0yMDg5IDgyNHEwIC01MiAtNjQgLTUyaC0xOXYxMDFoMjBxNjMgMCA2MyAtNDl6TTM4MCA3NTlxMCA3NCAtNTAgMTIwLjV0LTEyOSA0Ni41aC05NXYtMzMzaDk1cTc0IDAgMTE5IDM4cTYwIDUxIDYwIDEyOHpNNDEwIDU5M2g2NXYzMzNoLTY1di0zMzN6TTczMCA2OTRxMCA0MCAtMjAuNSA2MnQtNzUuNSA0MgpxLTI5IDEwIC0zOS41IDE5dC0xMC41IDIzcTAgMTYgMTMuNSAyNi41dDM0LjUgMTAuNXEyOSAwIDUzIC0yN2wzNCA0NHEtNDEgMzcgLTk4IDM3cS00NCAwIC03NCAtMjcuNXQtMzAgLTY3LjVxMCAtMzUgMTggLTU1LjV0NjQgLTM2LjVxMzcgLTEzIDQ1IC0xOXExOSAtMTIgMTkgLTM0cTAgLTIwIC0xNCAtMzMuNXQtMzYgLTEzLjVxLTQ4IDAgLTcxIDQ0bC00MiAtNDBxNDQgLTY0IDExNSAtNjRxNTEgMCA4MyAzMC41dDMyIDc5LjV6TTEwMDggNjA0CnY3N3EtMzcgLTM3IC03OCAtMzdxLTQ5IDAgLTgwLjUgMzIuNXQtMzEuNSA4Mi41cTAgNDggMzEuNSA4MS41dDc3LjUgMzMuNXE0MyAwIDgxIC0zOHY3N3EtNDAgMjAgLTgwIDIwcS03NCAwIC0xMjUuNSAtNTAuNXQtNTEuNSAtMTIzLjV0NTEgLTEyMy41dDEyNSAtNTAuNXE0MiAwIDgxIDE5ek0yMjQwIDB2NTI3cS02NSAtNDAgLTE0NC41IC04NHQtMjM3LjUgLTExN3QtMzI5LjUgLTEzNy41dC00MTcuNSAtMTM0LjV0LTUwNCAtMTE4aDE1NjkKcTI2IDAgNDUgMTl0MTkgNDV6TTEzODkgNzU3cTAgNzUgLTUzIDEyOHQtMTI4IDUzdC0xMjggLTUzdC01MyAtMTI4dDUzIC0xMjh0MTI4IC01M3QxMjggNTN0NTMgMTI4ek0xNTQxIDU4NGwxNDQgMzQyaC03MWwtOTAgLTIyNGwtODkgMjI0aC03MWwxNDIgLTM0MmgzNXpNMTcxNCA1OTNoMTg0djU2aC0xMTl2OTBoMTE1djU2aC0xMTV2NzRoMTE5djU3aC0xODR2LTMzM3pNMjEwNSA1OTNoODBsLTEwNSAxNDBxNzYgMTYgNzYgOTRxMCA0NyAtMzEgNzMKdC04NyAyNmgtOTd2LTMzM2g2NXYxMzNoOXpNMjMwNCAxMjc0di0xMjY4cTAgLTU2IC0zOC41IC05NXQtOTMuNSAtMzloLTIwNDBxLTU1IDAgLTkzLjUgMzl0LTM4LjUgOTV2MTI2OHEwIDU2IDM4LjUgOTV0OTMuNSAzOWgyMDQwcTU1IDAgOTMuNSAtMzl0MzguNSAtOTV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImYxZjMiIHVuaWNvZGU9IiYjeGYxZjM7IiBob3Jpei1hZHYteD0iMjMwNCIgCmQ9Ik0xMTkgODU0aDg5bC00NSAxMDh6TTc0MCAzMjhsNzQgNzlsLTcwIDc5aC0xNjN2LTQ5aDE0MnYtNTVoLTE0MnYtNTRoMTU5ek04OTggNDA2bDk5IC0xMTB2MjE3ek0xMTg2IDQ1M3EwIDMzIC00MCAzM2gtODR2LTY5aDgzcTQxIDAgNDEgMzZ6TTE0NzUgNDU3cTAgMjkgLTQyIDI5aC04MnYtNjFoODFxNDMgMCA0MyAzMnpNMTE5NyA5MjNxMCAyOSAtNDIgMjloLTgydi02MGg4MXE0MyAwIDQzIDMxek0xNjU2IDg1NGg4OWwtNDQgMTA4egpNNjk5IDEwMDl2LTI3MWgtNjZ2MjEybC05NCAtMjEyaC01N2wtOTQgMjEydi0yMTJoLTEzMmwtMjUgNjBoLTEzNWwtMjUgLTYwaC03MGwxMTYgMjcxaDk2bDExMCAtMjU3djI1N2gxMDZsODUgLTE4NGw3NyAxODRoMTA4ek0xMjU1IDQ1M3EwIC0yMCAtNS41IC0zNXQtMTQgLTI1dC0yMi41IC0xNi41dC0yNiAtMTB0LTMxLjUgLTQuNXQtMzEuNSAtMXQtMzIuNSAwLjV0LTI5LjUgMC41di05MWgtMTI2bC04MCA5MGwtODMgLTkwaC0yNTZ2MjcxaDI2MApsODAgLTg5bDgyIDg5aDIwN3ExMDkgMCAxMDkgLTg5ek05NjQgNzk0di01NmgtMjE3djI3MWgyMTd2LTU3aC0xNTJ2LTQ5aDE0OHYtNTVoLTE0OHYtNTRoMTUyek0yMzA0IDIzNXYtMjI5cTAgLTU1IC0zOC41IC05NC41dC05My41IC0zOS41aC0yMDQwcS01NSAwIC05My41IDM5LjV0LTM4LjUgOTQuNXY2NzhoMTExbDI1IDYxaDU1bDI1IC02MWgyMTh2NDZsMTkgLTQ2aDExM2wyMCA0N3YtNDdoNTQxdjk5bDEwIDFxMTAgMCAxMCAtMTR2LTg2aDI3OQp2MjNxMjMgLTEyIDU1IC0xOHQ1Mi41IC02LjV0NjMgMC41dDUxLjUgMWwyNSA2MWg1NmwyNSAtNjFoMjI3djU4bDM0IC01OGgxODJ2Mzc4aC0xODB2LTQ0bC0yNSA0NGgtMTg1di00NGwtMjMgNDRoLTI0OXEtNjkgMCAtMTA5IC0yMnYyMmgtMTcydi0yMnEtMjQgMjIgLTczIDIyaC02MjhsLTQzIC05N2wtNDMgOTdoLTE5OHYtNDRsLTIyIDQ0aC0xNjlsLTc4IC0xNzl2MzkxcTAgNTUgMzguNSA5NC41dDkzLjUgMzkuNWgyMDQwCnE1NSAwIDkzLjUgLTM5LjV0MzguNSAtOTQuNXYtNjc4aC0xMjBxLTUxIDAgLTgxIC0yMnYyMmgtMTc3cS01NSAwIC03OCAtMjJ2MjJoLTMxNnYtMjJxLTMxIDIyIC04NyAyMmgtMjA5di0yMnEtMjMgMjIgLTkxIDIyaC0yMzRsLTU0IC01OGwtNTAgNThoLTM0OXYtMzc4aDM0M2w1NSA1OWw1MiAtNTloMjExdjg5aDIxcTU5IDAgOTAgMTN2LTEwMmgxNzR2OTloOHE4IDAgMTAgLTJ0MiAtMTB2LTg3aDUyOXE1NyAwIDg4IDI0di0yNGgxNjgKcTYwIDAgOTUgMTd6TTE1NDYgNDY5cTAgLTIzIC0xMiAtNDN0LTM0IC0yOXEyNSAtOSAzNCAtMjZ0OSAtNDZ2LTU0aC02NXY0NXEwIDMzIC0xMiA0My41dC00NiAxMC41aC02OXYtOTloLTY1djI3MWgxNTRxNDggMCA3NyAtMTV0MjkgLTU4ek0xMjY5IDkzNnEwIC0yNCAtMTIuNSAtNDR0LTMzLjUgLTI5cTI2IC05IDM0LjUgLTI1LjV0OC41IC00Ni41di01M2gtNjVxMCA5IDAuNSAyNi41dDAgMjV0LTMgMTguNXQtOC41IDE2dC0xNy41IDguNQp0LTI5LjUgMy41aC03MHYtOThoLTY0djI3MWwxNTMgLTFxNDkgMCA3OCAtMTQuNXQyOSAtNTcuNXpNMTc5OCAzMjd2LTU2aC0yMTZ2MjcxaDIxNnYtNTZoLTE1MXYtNDloMTQ4di01NWgtMTQ4di01NHpNMTM3MiAxMDA5di0yNzFoLTY2djI3MWg2NnpNMjA2NSAzNTdxMCAtODYgLTEwMiAtODZoLTEyNnY1OGgxMjZxMzQgMCAzNCAyNXEwIDE2IC0xNyAyMXQtNDEuNSA1dC00OS41IDMuNXQtNDIgMjIuNXQtMTcgNTVxMCAzOSAyNiA2MHQ2NiAyMQpoMTMwdi01N2gtMTE5cS0zNiAwIC0zNiAtMjVxMCAtMTYgMTcuNSAtMjAuNXQ0MiAtNHQ0OSAtMi41dDQyIC0yMS41dDE3LjUgLTU0LjV6TTIzMDQgNDA3di0xMDFxLTI0IC0zNSAtODggLTM1aC0xMjV2NThoMTI1cTMzIDAgMzMgMjVxMCAxMyAtMTIuNSAxOXQtMzEgNS41dC00MCAydC00MCA4dC0zMSAyNHQtMTIuNSA0OC41cTAgMzkgMjYuNSA2MHQ2Ni41IDIxaDEyOXYtNTdoLTExOHEtMzYgMCAtMzYgLTI1cTAgLTIwIDI5IC0yMnQ2OC41IC01CnQ1Ni41IC0yNnpNMjEzOSAxMDA4di0yNzBoLTkybC0xMjIgMjAzdi0yMDNoLTEzMmwtMjYgNjBoLTEzNGwtMjUgLTYwaC03NXEtMTI5IDAgLTEyOSAxMzNxMCAxMzggMTMzIDEzOGg2M3YtNTlxLTcgMCAtMjggMXQtMjguNSAwLjV0LTIzIC0ydC0yMS41IC02LjV0LTE0LjUgLTEzLjV0LTExLjUgLTIzdC0zIC0zMy41cTAgLTM4IDEzLjUgLTU4dDQ5LjUgLTIwaDI5bDkyIDIxM2g5N2wxMDkgLTI1NnYyNTZoOTlsMTE0IC0xODh2MTg4aDY2eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDY5IiB1bmljb2RlPSImI3hmMWY0OyIgaG9yaXotYWR2LXg9IjIzMDQiIApkPSJNNzQ1IDYzMHEwIC0zNyAtMjUuNSAtNjEuNXQtNjIuNSAtMjQuNXEtMjkgMCAtNDYuNSAxNnQtMTcuNSA0NHEwIDM3IDI1IDYyLjV0NjIgMjUuNXEyOCAwIDQ2LjUgLTE2LjV0MTguNSAtNDUuNXpNMTUzMCA3NzlxMCAtNDIgLTIyIC01N3QtNjYgLTE1bC0zMiAtMWwxNyAxMDdxMiAxMSAxMyAxMWgxOHEyMiAwIDM1IC0ydDI1IC0xMi41dDEyIC0zMC41ek0xODgxIDYzMHEwIC0zNiAtMjUuNSAtNjF0LTYxLjUgLTI1cS0yOSAwIC00NyAxNgp0LTE4IDQ0cTAgMzcgMjUgNjIuNXQ2MiAyNS41cTI4IDAgNDYuNSAtMTYuNXQxOC41IC00NS41ek01MTMgODAxcTAgNTkgLTM4LjUgODUuNXQtMTAwLjUgMjYuNWgtMTYwcS0xOSAwIC0yMSAtMTlsLTY1IC00MDhxLTEgLTYgMyAtMTF0MTAgLTVoNzZxMjAgMCAyMiAxOWwxOCAxMTBxMSA4IDcgMTN0MTUgNi41dDE3IDEuNXQxOSAtMXQxNCAtMXE4NiAwIDEzNSA0OC41dDQ5IDEzNC41ek04MjIgNDg5bDQxIDI2MXExIDYgLTMgMTF0LTEwIDVoLTc2CnEtMTQgMCAtMTcgLTMzcS0yNyA0MCAtOTUgNDBxLTcyIDAgLTEyMi41IC01NHQtNTAuNSAtMTI3cTAgLTU5IDM0LjUgLTk0dDkyLjUgLTM1cTI4IDAgNTggMTJ0NDggMzJxLTQgLTEyIC00IC0yMXEwIC0xNiAxMyAtMTZoNjlxMTkgMCAyMiAxOXpNMTI2OSA3NTJxMCA1IC00IDkuNXQtOSA0LjVoLTc3cS0xMSAwIC0xOCAtMTBsLTEwNiAtMTU2bC00NCAxNTBxLTUgMTYgLTIyIDE2aC03NXEtNSAwIC05IC00LjV0LTQgLTkuNXEwIC0yIDE5LjUgLTU5CnQ0MiAtMTIzdDIzLjUgLTcwcS04MiAtMTEyIC04MiAtMTIwcTAgLTEzIDEzIC0xM2g3N3ExMSAwIDE4IDEwbDI1NSAzNjhxMiAyIDIgN3pNMTY0OSA4MDFxMCA1OSAtMzguNSA4NS41dC0xMDAuNSAyNi41aC0xNTlxLTIwIDAgLTIyIC0xOWwtNjUgLTQwOHEtMSAtNiAzIC0xMXQxMCAtNWg4MnExMiAwIDE2IDEzbDE4IDExNnExIDggNyAxM3QxNSA2LjV0MTcgMS41dDE5IC0xdDE0IC0xcTg2IDAgMTM1IDQ4LjV0NDkgMTM0LjV6TTE5NTggNDg5Cmw0MSAyNjFxMSA2IC0zIDExdC0xMCA1aC03NnEtMTQgMCAtMTcgLTMzcS0yNiA0MCAtOTUgNDBxLTcyIDAgLTEyMi41IC01NHQtNTAuNSAtMTI3cTAgLTU5IDM0LjUgLTk0dDkyLjUgLTM1cTI5IDAgNTkgMTJ0NDcgMzJxMCAtMSAtMiAtOXQtMiAtMTJxMCAtMTYgMTMgLTE2aDY5cTE5IDAgMjIgMTl6TTIxNzYgODk4djFxMCAxNCAtMTMgMTRoLTc0cS0xMSAwIC0xMyAtMTFsLTY1IC00MTZsLTEgLTJxMCAtNSA0IC05LjV0MTAgLTQuNWg2NgpxMTkgMCAyMSAxOXpNMzkyIDc2NHEtNSAtMzUgLTI2IC00NnQtNjAgLTExbC0zMyAtMWwxNyAxMDdxMiAxMSAxMyAxMWgxOXE0MCAwIDU4IC0xMS41dDEyIC00OC41ek0yMzA0IDEyODB2LTEyODBxMCAtNTIgLTM4IC05MHQtOTAgLTM4aC0yMDQ4cS01MiAwIC05MCAzOHQtMzggOTB2MTI4MHEwIDUyIDM4IDkwdDkwIDM4aDIwNDhxNTIgMCA5MCAtMzh0MzggLTkweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDcwIiB1bmljb2RlPSImI3hmMWY1OyIgaG9yaXotYWR2LXg9IjIzMDQiIApkPSJNMTU5NyA2MzNxMCAtNjkgLTIxIC0xMDZxLTE5IC0zNSAtNTIgLTM1cS0yMyAwIC00MSA5djIyNHEyOSAzMCA1NyAzMHE1NyAwIDU3IC0xMjJ6TTIwMzUgNjY5aC0xMTBxNiA5OCA1NiA5OHE1MSAwIDU0IC05OHpNNDc2IDUzNHEwIDU5IC0zMyA5MS41dC0xMDEgNTcuNXEtMzYgMTMgLTUyIDI0dC0xNiAyNXEwIDI2IDM4IDI2cTU4IDAgMTI0IC0zM2wxOCAxMTJxLTY3IDMyIC0xNDkgMzJxLTc3IDAgLTEyMyAtMzhxLTQ4IC0zOSAtNDggLTEwOQpxMCAtNTggMzIuNSAtOTAuNXQ5OS41IC01Ni41cTM5IC0xNCA1NC41IC0yNS41dDE1LjUgLTI3LjVxMCAtMzEgLTQ4IC0zMXEtMjkgMCAtNzAgMTIuNXQtNzIgMzAuNWwtMTggLTExM3E3MiAtNDEgMTY4IC00MXE4MSAwIDEyOSAzN3E1MSA0MSA1MSAxMTd6TTc3MSA3NDlsMTkgMTExaC05NnYxMzVsLTEyOSAtMjFsLTE4IC0xMTRsLTQ2IC04bC0xNyAtMTAzaDYydi0yMTlxMCAtODQgNDQgLTEyMHEzOCAtMzAgMTExIC0zMHEzMiAwIDc5IDExdjExOApxLTMyIC03IC00NCAtN3EtNDIgMCAtNDIgNTB2MTk3aDc3ek0xMDg3IDcyNHYxMzlxLTE1IDMgLTI4IDNxLTMyIDAgLTU1LjUgLTE2dC0zMy41IC00NmwtMTAgNTZoLTEzMXYtNDcxaDE1MHYzMDZxMjYgMzEgODIgMzFxMTYgMCAyNiAtMnpNMTEyNCAzODloMTUwdjQ3MWgtMTUwdi00NzF6TTE3NDYgNjM4cTAgMTIyIC00NSAxNzlxLTQwIDUyIC0xMTEgNTJxLTY0IDAgLTExNyAtNTZsLTggNDdoLTEzMnYtNjQ1bDE1MCAyNXYxNTEKcTM2IC0xMSA2OCAtMTFxODMgMCAxMzQgNTZxNjEgNjUgNjEgMjAyek0xMjc4IDk4NnEwIDMzIC0yMyA1NnQtNTYgMjN0LTU2IC0yM3QtMjMgLTU2dDIzIC01Ni41dDU2IC0yMy41dDU2IDIzLjV0MjMgNTYuNXpNMjE3NiA2MjlxMCAxMTMgLTQ4IDE3NnEtNTAgNjQgLTE0NCA2NHEtOTYgMCAtMTUxLjUgLTY2dC01NS41IC0xODBxMCAtMTI4IDYzIC0xODhxNTUgLTU1IDE2MSAtNTVxMTAxIDAgMTYwIDQwbC0xNiAxMDNxLTU3IC0zMSAtMTI4IC0zMQpxLTQzIDAgLTYzIDE5cS0yMyAxOSAtMjggNjZoMjQ4cTIgMTQgMiA1MnpNMjMwNCAxMjgwdi0xMjgwcTAgLTUyIC0zOCAtOTB0LTkwIC0zOGgtMjA0OHEtNTIgMCAtOTAgMzh0LTM4IDkwdjEyODBxMCA1MiAzOCA5MHQ5MCAzOGgyMDQ4cTUyIDAgOTAgLTM4dDM4IC05MHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQ3MSIgdW5pY29kZT0iJiN4ZjFmNjsiIGhvcml6LWFkdi14PSIyMDQ4IiAKZD0iTTE1NTggNjg0cTYxIC0zNTYgMjk4IC01NTZxMCAtNTIgLTM4IC05MHQtOTAgLTM4aC00NDhxMCAtMTA2IC03NSAtMTgxdC0xODEgLTc1dC0xODAuNSA3NC41dC03NS41IDE4MC41ek0xMDI0IC0xNzZxMTYgMCAxNiAxNnQtMTYgMTZxLTU5IDAgLTEwMS41IDQyLjV0LTQyLjUgMTAxLjVxMCAxNiAtMTYgMTZ0LTE2IC0xNnEwIC03MyA1MS41IC0xMjQuNXQxMjQuNSAtNTEuNXpNMjAyNiAxNDI0cTggLTEwIDcuNSAtMjMuNXQtMTAuNSAtMjIuNQpsLTE4NzIgLTE2MjJxLTEwIC04IC0yMy41IC03dC0yMS41IDExbC04NCA5NnEtOCAxMCAtNy41IDIzLjV0MTAuNSAyMS41bDE4NiAxNjFxLTE5IDMyIC0xOSA2NnE1MCA0MiA5MSA4OHQ4NSAxMTkuNXQ3NC41IDE1OC41dDUwIDIwNnQxOS41IDI2MHEwIDE1MiAxMTcgMjgyLjV0MzA3IDE1OC41cS04IDE5IC04IDM5cTAgNDAgMjggNjh0NjggMjh0NjggLTI4dDI4IC02OHEwIC0yMCAtOCAtMzlxMTI0IC0xOCAyMTkgLTgyLjV0MTQ4IC0xNTcuNQpsNDE4IDM2M3ExMCA4IDIzLjUgN3QyMS41IC0xMXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQ3MiIgdW5pY29kZT0iJiN4ZjFmNzsiIGhvcml6LWFkdi14PSIyMDQ4IiAKZD0iTTEwNDAgLTE2MHEwIDE2IC0xNiAxNnEtNTkgMCAtMTAxLjUgNDIuNXQtNDIuNSAxMDEuNXEwIDE2IC0xNiAxNnQtMTYgLTE2cTAgLTczIDUxLjUgLTEyNC41dDEyNC41IC01MS41cTE2IDAgMTYgMTZ6TTUwMyAzMTVsODc3IDc2MHEtNDIgODggLTEzMi41IDE0Ni41dC0yMjMuNSA1OC41cS05MyAwIC0xNjkuNSAtMzEuNXQtMTIxLjUgLTgwLjV0LTY5IC0xMDN0LTI0IC0xMDVxMCAtMzg0IC0xMzcgLTY0NXpNMTg1NiAxMjgKcTAgLTUyIC0zOCAtOTB0LTkwIC0zOGgtNDQ4cTAgLTEwNiAtNzUgLTE4MXQtMTgxIC03NXQtMTgwLjUgNzQuNXQtNzUuNSAxODAuNWwxNDkgMTI5aDc1N3EtMTY2IDE4NyAtMjI3IDQ1OWwxMTEgOTdxNjEgLTM1NiAyOTggLTU1NnpNMTk0MiAxNTIwbDg0IC05NnE4IC0xMCA3LjUgLTIzLjV0LTEwLjUgLTIyLjVsLTE4NzIgLTE2MjJxLTEwIC04IC0yMy41IC03dC0yMS41IDExbC04NCA5NnEtOCAxMCAtNy41IDIzLjV0MTAuNSAyMS41bDE4NiAxNjEKcS0xOSAzMiAtMTkgNjZxNTAgNDIgOTEgODh0ODUgMTE5LjV0NzQuNSAxNTguNXQ1MCAyMDZ0MTkuNSAyNjBxMCAxNTIgMTE3IDI4Mi41dDMwNyAxNTguNXEtOCAxOSAtOCAzOXEwIDQwIDI4IDY4dDY4IDI4dDY4IC0yOHQyOCAtNjhxMCAtMjAgLTggLTM5cTEyNCAtMTggMjE5IC04Mi41dDE0OCAtMTU3LjVsNDE4IDM2M3ExMCA4IDIzLjUgN3QyMS41IC0xMXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQ3MyIgdW5pY29kZT0iJiN4ZjFmODsiIGhvcml6LWFkdi14PSIxNDA4IiAKZD0iTTUxMiAxNjB2NzA0cTAgMTQgLTkgMjN0LTIzIDloLTY0cS0xNCAwIC0yMyAtOXQtOSAtMjN2LTcwNHEwIC0xNCA5IC0yM3QyMyAtOWg2NHExNCAwIDIzIDl0OSAyM3pNNzY4IDE2MHY3MDRxMCAxNCAtOSAyM3QtMjMgOWgtNjRxLTE0IDAgLTIzIC05dC05IC0yM3YtNzA0cTAgLTE0IDkgLTIzdDIzIC05aDY0cTE0IDAgMjMgOXQ5IDIzek0xMDI0IDE2MHY3MDRxMCAxNCAtOSAyM3QtMjMgOWgtNjRxLTE0IDAgLTIzIC05dC05IC0yM3YtNzA0CnEwIC0xNCA5IC0yM3QyMyAtOWg2NHExNCAwIDIzIDl0OSAyM3pNNDgwIDExNTJoNDQ4bC00OCAxMTdxLTcgOSAtMTcgMTFoLTMxN3EtMTAgLTIgLTE3IC0xMXpNMTQwOCAxMTIwdi02NHEwIC0xNCAtOSAtMjN0LTIzIC05aC05NnYtOTQ4cTAgLTgzIC00NyAtMTQzLjV0LTExMyAtNjAuNWgtODMycS02NiAwIC0xMTMgNTguNXQtNDcgMTQxLjV2OTUyaC05NnEtMTQgMCAtMjMgOXQtOSAyM3Y2NHEwIDE0IDkgMjN0MjMgOWgzMDlsNzAgMTY3CnExNSAzNyA1NCA2M3Q3OSAyNmgzMjBxNDAgMCA3OSAtMjZ0NTQgLTYzbDcwIC0xNjdoMzA5cTE0IDAgMjMgLTl0OSAtMjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80NzQiIHVuaWNvZGU9IiYjeGYxZjk7IiAKZD0iTTExNTAgNDYydi0xMDlxMCAtNTAgLTM2LjUgLTg5dC05NCAtNjAuNXQtMTE4IC0zMi41dC0xMTcuNSAtMTFxLTIwNSAwIC0zNDIuNSAxMzl0LTEzNy41IDM0NnEwIDIwMyAxMzYgMzM5dDMzOSAxMzZxMzQgMCA3NS41IC00LjV0OTMgLTE4dDkyLjUgLTM0dDY5IC01Ni41dDI4IC04MXYtMTA5cTAgLTE2IC0xNiAtMTZoLTExOHEtMTYgMCAtMTYgMTZ2NzBxMCA0MyAtNjUuNSA2Ny41dC0xMzcuNSAyNC41cS0xNDAgMCAtMjI4LjUgLTkxLjUKdC04OC41IC0yMzcuNXEwIC0xNTEgOTEuNSAtMjQ5LjV0MjMzLjUgLTk4LjVxNjggMCAxMzggMjR0NzAgNjZ2NzBxMCA3IDQuNSAxMS41dDEwLjUgNC41aDExOXE2IDAgMTEgLTQuNXQ1IC0xMS41ek03NjggMTI4MHEtMTMwIDAgLTI0OC41IC01MXQtMjA0IC0xMzYuNXQtMTM2LjUgLTIwNHQtNTEgLTI0OC41dDUxIC0yNDguNXQxMzYuNSAtMjA0dDIwNCAtMTM2LjV0MjQ4LjUgLTUxdDI0OC41IDUxdDIwNCAxMzYuNXQxMzYuNSAyMDR0NTEgMjQ4LjUKdC01MSAyNDguNXQtMTM2LjUgMjA0dC0yMDQgMTM2LjV0LTI0OC41IDUxek0xNTM2IDY0MHEwIC0yMDkgLTEwMyAtMzg1LjV0LTI3OS41IC0yNzkuNXQtMzg1LjUgLTEwM3QtMzg1LjUgMTAzdC0yNzkuNSAyNzkuNXQtMTAzIDM4NS41dDEwMyAzODUuNXQyNzkuNSAyNzkuNXQzODUuNSAxMDN0Mzg1LjUgLTEwM3QyNzkuNSAtMjc5LjV0MTAzIC0zODUuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQ3NSIgdW5pY29kZT0iJiN4ZjFmYTsiIApkPSJNOTcyIDc2MXEwIDEwOCAtNTMuNSAxNjl0LTE0Ny41IDYxcS02MyAwIC0xMjQgLTMwLjV0LTExMCAtODQuNXQtNzkuNSAtMTM3dC0zMC41IC0xODBxMCAtMTEyIDUzLjUgLTE3M3QxNTAuNSAtNjFxOTYgMCAxNzYgNjYuNXQxMjIuNSAxNjZ0NDIuNSAyMDMuNXpNMTUzNiA2NDBxMCAtMTExIC0zNyAtMTk3dC05OC41IC0xMzV0LTEzMS41IC03NC41dC0xNDUgLTI3LjVxLTYgMCAtMTUuNSAtMC41dC0xNi41IC0wLjVxLTk1IDAgLTE0MiA1MwpxLTI4IDMzIC0zMyA4M3EtNTIgLTY2IC0xMzEuNSAtMTEwdC0xNzMuNSAtNDRxLTE2MSAwIC0yNDkuNSA5NS41dC04OC41IDI2OS41cTAgMTU3IDY2IDI5MHQxNzkgMjEwLjV0MjQ2IDc3LjVxODcgMCAxNTUgLTM1LjV0MTA2IC05OS41bDIgMTlsMTEgNTZxMSA2IDUuNSAxMnQ5LjUgNmgxMThxNSAwIDEzIC0xMXE1IC01IDMgLTE2bC0xMjAgLTYxNHEtNSAtMjQgLTUgLTQ4cTAgLTM5IDEyLjUgLTUydDQ0LjUgLTEzcTI4IDEgNTcgNS41dDczIDI0CnQ3NyA1MHQ1NyA4OS41dDI0IDEzN3EwIDI5MiAtMTc0IDQ2NnQtNDY2IDE3NHEtMTMwIDAgLTI0OC41IC01MXQtMjA0IC0xMzYuNXQtMTM2LjUgLTIwNHQtNTEgLTI0OC41dDUxIC0yNDguNXQxMzYuNSAtMjA0dDIwNCAtMTM2LjV0MjQ4LjUgLTUxcTIyOCAwIDQwNSAxNDRxMTEgOSAyNCA4dDIxIC0xMmw0MSAtNDlxOCAtMTIgNyAtMjRxLTIgLTEzIC0xMiAtMjJxLTEwMiAtODMgLTIyNy41IC0xMjh0LTI1OC41IC00NXEtMTU2IDAgLTI5OCA2MQp0LTI0NSAxNjR0LTE2NCAyNDV0LTYxIDI5OHQ2MSAyOTh0MTY0IDI0NXQyNDUgMTY0dDI5OCA2MXEzNDQgMCA1NTYgLTIxMnQyMTIgLTU1NnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQ3NiIgdW5pY29kZT0iJiN4ZjFmYjsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE2OTggMTQ0MnE5NCAtOTQgOTQgLTIyNi41dC05NCAtMjI1LjVsLTIyNSAtMjIzbDEwNCAtMTA0cTEwIC0xMCAxMCAtMjN0LTEwIC0yM2wtMjEwIC0yMTBxLTEwIC0xMCAtMjMgLTEwdC0yMyAxMGwtMTA1IDEwNWwtNjAzIC02MDNxLTM3IC0zNyAtOTAgLTM3aC0yMDNsLTI1NiAtMTI4bC02NCA2NGwxMjggMjU2djIwM3EwIDUzIDM3IDkwbDYwMyA2MDNsLTEwNSAxMDVxLTEwIDEwIC0xMCAyM3QxMCAyM2wyMTAgMjEwcTEwIDEwIDIzIDEwCnQyMyAtMTBsMTA0IC0xMDRsMjIzIDIyNXE5MyA5NCAyMjUuNSA5NHQyMjYuNSAtOTR6TTUxMiA2NGw1NzYgNTc2bC0xOTIgMTkybC01NzYgLTU3NnYtMTkyaDE5MnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZjFmYyIgdW5pY29kZT0iJiN4ZjFmYzsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE2MTUgMTUzNnE3MCAwIDEyMi41IC00Ni41dDUyLjUgLTExNi41cTAgLTYzIC00NSAtMTUxcS0zMzIgLTYyOSAtNDY1IC03NTJxLTk3IC05MSAtMjE4IC05MXEtMTI2IDAgLTIxNi41IDkyLjV0LTkwLjUgMjE5LjVxMCAxMjggOTIgMjEybDYzOCA1NzlxNTkgNTQgMTMwIDU0ek03MDYgNTAycTM5IC03NiAxMDYuNSAtMTMwdDE1MC41IC03NmwxIC03MXE0IC0yMTMgLTEyOS41IC0zNDd0LTM0OC41IC0xMzRxLTEyMyAwIC0yMTggNDYuNQp0LTE1Mi41IDEyNy41dC04Ni41IDE4M3QtMjkgMjIwcTcgLTUgNDEgLTMwdDYyIC00NC41dDU5IC0zNi41dDQ2IC0xN3E0MSAwIDU1IDM3cTI1IDY2IDU3LjUgMTEyLjV0NjkuNSA3NnQ4OCA0Ny41dDEwMyAyNS41dDEyNSAxMC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDc4IiB1bmljb2RlPSImI3hmMWZkOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTc5MiAxMjh2LTM4NGgtMTc5MnYzODRxNDUgMCA4NSAxNHQ1OSAyNy41dDQ3IDM3LjVxMzAgMjcgNTEuNSAzOHQ1Ni41IDExcTI0IDAgNDQgLTd0MzEgLTE1dDMzIC0yN3EyOSAtMjUgNDcgLTM4dDU4IC0yN3Q4NiAtMTRxNDUgMCA4NSAxNC41dDU4IDI3dDQ4IDM3LjVxMjEgMTkgMzIuNSAyN3QzMSAxNXQ0My41IDdxMzUgMCA1Ni41IC0xMXQ1MS41IC0zOHEyOCAtMjQgNDcgLTM3LjV0NTkgLTI3LjV0ODUgLTE0dDg1IDE0dDU5IDI3LjUKdDQ3IDM3LjVxMzAgMjcgNTEuNSAzOHQ1Ni41IDExcTM0IDAgNTUuNSAtMTF0NTEuNSAtMzhxMjggLTI0IDQ3IC0zNy41dDU5IC0yNy41dDg1IC0xNHpNMTc5MiA0NDh2LTE5MnEtMjQgMCAtNDQgN3QtMzEgMTV0LTMzIDI3cS0yOSAyNSAtNDcgMzh0LTU4IDI3dC04NSAxNHEtNDYgMCAtODYgLTE0dC01OCAtMjd0LTQ3IC0zOHEtMjIgLTE5IC0zMyAtMjd0LTMxIC0xNXQtNDQgLTdxLTM1IDAgLTU2LjUgMTF0LTUxLjUgMzhxLTI5IDI1IC00NyAzOAp0LTU4IDI3dC04NiAxNHEtNDUgMCAtODUgLTE0LjV0LTU4IC0yN3QtNDggLTM3LjVxLTIxIC0xOSAtMzIuNSAtMjd0LTMxIC0xNXQtNDMuNSAtN3EtMzUgMCAtNTYuNSAxMXQtNTEuNSAzOHEtMjggMjQgLTQ3IDM3LjV0LTU5IDI3LjV0LTg1IDE0cS00NiAwIC04NiAtMTR0LTU4IC0yN3QtNDcgLTM4cS0zMCAtMjcgLTUxLjUgLTM4dC01Ni41IC0xMXYxOTJxMCA4MCA1NiAxMzZ0MTM2IDU2aDY0djQ0OGgyNTZ2LTQ0OGgyNTZ2NDQ4aDI1NnYtNDQ4CmgyNTZ2NDQ4aDI1NnYtNDQ4aDY0cTgwIDAgMTM2IC01NnQ1NiAtMTM2ek01MTIgMTMxMnEwIC03NyAtMzYgLTExOC41dC05MiAtNDEuNXEtNTMgMCAtOTAuNSAzNy41dC0zNy41IDkwLjVxMCAyOSA5LjUgNTF0MjMuNSAzNHQzMSAyOHQzMSAzMS41dDIzLjUgNDQuNXQ5LjUgNjdxMzggMCA4MyAtNzR0NDUgLTE1MHpNMTAyNCAxMzEycTAgLTc3IC0zNiAtMTE4LjV0LTkyIC00MS41cS01MyAwIC05MC41IDM3LjV0LTM3LjUgOTAuNQpxMCAyOSA5LjUgNTF0MjMuNSAzNHQzMSAyOHQzMSAzMS41dDIzLjUgNDQuNXQ5LjUgNjdxMzggMCA4MyAtNzR0NDUgLTE1MHpNMTUzNiAxMzEycTAgLTc3IC0zNiAtMTE4LjV0LTkyIC00MS41cS01MyAwIC05MC41IDM3LjV0LTM3LjUgOTAuNXEwIDI5IDkuNSA1MXQyMy41IDM0dDMxIDI4dDMxIDMxLjV0MjMuNSA0NC41dDkuNSA2N3EzOCAwIDgzIC03NHQ0NSAtMTUweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDc5IiB1bmljb2RlPSImI3hmMWZlOyIgaG9yaXotYWR2LXg9IjIwNDgiIApkPSJNMjA0OCAwdi0xMjhoLTIwNDh2MTUzNmgxMjh2LTE0MDhoMTkyMHpNMTY2NCAxMDI0bDI1NiAtODk2aC0xNjY0djU3Nmw0NDggNTc2bDU3NiAtNTc2eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDgwIiB1bmljb2RlPSImI3hmMjAwOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNNzY4IDY0Nmw1NDYgLTU0NnEtMTA2IC0xMDggLTI0Ny41IC0xNjh0LTI5OC41IC02MHEtMjA5IDAgLTM4NS41IDEwM3QtMjc5LjUgMjc5LjV0LTEwMyAzODUuNXQxMDMgMzg1LjV0Mjc5LjUgMjc5LjV0Mzg1LjUgMTAzdi03NjJ6TTk1NSA2NDBoNzczcTAgLTE1NyAtNjAgLTI5OC41dC0xNjggLTI0Ny41ek0xNjY0IDc2OGgtNzY4djc2OHEyMDkgMCAzODUuNSAtMTAzdDI3OS41IC0yNzkuNXQxMDMgLTM4NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDgxIiB1bmljb2RlPSImI3hmMjAxOyIgaG9yaXotYWR2LXg9IjIwNDgiIApkPSJNMjA0OCAwdi0xMjhoLTIwNDh2MTUzNmgxMjh2LTE0MDhoMTkyMHpNMTkyMCAxMjQ4di00MzVxMCAtMjEgLTE5LjUgLTI5LjV0LTM1LjUgNy41bC0xMjEgMTIxbC02MzMgLTYzM3EtMTAgLTEwIC0yMyAtMTB0LTIzIDEwbC0yMzMgMjMzbC00MTYgLTQxNmwtMTkyIDE5Mmw1ODUgNTg1cTEwIDEwIDIzIDEwdDIzIC0xMGwyMzMgLTIzM2w0NjQgNDY0bC0xMjEgMTIxcS0xNiAxNiAtNy41IDM1LjV0MjkuNSAxOS41aDQzNXExNCAwIDIzIC05CnQ5IC0yM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQ4MiIgdW5pY29kZT0iJiN4ZjIwMjsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTEyOTIgODMycTAgLTYgMTAgLTQxcTEwIC0yOSAyNSAtNDkuNXQ0MSAtMzR0NDQgLTIwdDU1IC0xNi41cTMyNSAtOTEgMzI1IC0zMzJxMCAtMTQ2IC0xMDUuNSAtMjQyLjV0LTI1NC41IC05Ni41cS01OSAwIC0xMTEuNSAxOC41dC05MS41IDQ1LjV0LTc3IDc0LjV0LTYzIDg3LjV0LTUzLjUgMTAzLjV0LTQzLjUgMTAzdC0zOS41IDEwNi41dC0zNS41IDk1cS0zMiA4MSAtNjEuNSAxMzMuNXQtNzMuNSA5Ni41dC0xMDQgNjR0LTE0MiAyMApxLTk2IDAgLTE4MyAtNTUuNXQtMTM4IC0xNDQuNXQtNTEgLTE4NXEwIC0xNjAgMTA2LjUgLTI3OS41dDI2My41IC0xMTkuNXExNzcgMCAyNTggOTVxNTYgNjMgODMgMTE2bDg0IC0xNTJxLTE1IC0zNCAtNDQgLTcwbDEgLTFxLTEzMSAtMTUyIC0zODggLTE1MnEtMTQ3IDAgLTI2OS41IDc5dC0xOTAuNSAyMDcuNXQtNjggMjc0LjVxMCAxMDUgNDMuNSAyMDZ0MTE2IDE3Ni41dDE3MiAxMjEuNXQyMDQuNSA0NnE4NyAwIDE1OSAtMTl0MTIzLjUgLTUwCnQ5NSAtODB0NzIuNSAtOTl0NTguNSAtMTE3dDUwLjUgLTEyNC41dDUwIC0xMzAuNXQ1NSAtMTI3cTk2IC0yMDAgMjMzIC0yMDBxODEgMCAxMzguNSA0OC41dDU3LjUgMTI4LjVxMCA0MiAtMTkgNzJ0LTUwLjUgNDZ0LTcyLjUgMzEuNXQtODQuNSAyN3QtODcuNSAzNHQtODEgNTJ0LTY1IDgydC0zOSAxMjIuNXEtMyAxNiAtMyAzM3EwIDExMCA4Ny41IDE5MnQxOTguNSA3OHE3OCAtMyAxMjAuNSAtMTQuNXQ5MC41IC01My41aC0xCnExMiAtMTEgMjMgLTI0LjV0MjYgLTM2dDE5IC0yNy41bC0xMjkgLTk5cS0yNiA0OSAtNTQgNzB2MXEtMjMgMjEgLTk3IDIxcS00OSAwIC04NCAtMzN0LTM1IC04M3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQ4MyIgdW5pY29kZT0iJiN4ZjIwMzsiIApkPSJNMTQzMiA0ODRxMCAxNzMgLTIzNCAyMzlxLTM1IDEwIC01MyAxNi41dC0zOCAyNXQtMjkgNDYuNXEwIDIgLTIgOC41dC0zIDEydC0xIDcuNXEwIDM2IDI0LjUgNTkuNXQ2MC41IDIzLjVxNTQgMCA3MSAtMTVoLTFxMjAgLTE1IDM5IC01MWw5MyA3MXEtMzkgNTQgLTQ5IDY0cS0zMyAyOSAtNjcuNSAzOXQtODUuNSAxMHEtODAgMCAtMTQyIC01Ny41dC02MiAtMTM3LjVxMCAtNyAyIC0yM3ExNiAtOTYgNjQuNSAtMTQwdDE0OC41IC03MwpxMjkgLTggNDkgLTE1LjV0NDUgLTIxLjV0MzguNSAtMzQuNXQxMy41IC00Ni41di01cTEgLTU4IC00MC41IC05M3QtMTAwLjUgLTM1cS05NyAwIC0xNjcgMTQ0cS0yMyA0NyAtNTEuNSAxMjEuNXQtNDggMTI1LjV0LTU0IDExMC41dC03NCA5NS41dC0xMDMuNSA2MC41dC0xNDcgMjQuNXEtMTAxIDAgLTE5MiAtNTZ0LTE0NCAtMTQ4dC01MCAtMTkydi0xcTQgLTEwOCA1MC41IC0xOTl0MTMzLjUgLTE0Ny41dDE5NiAtNTYuNXExODYgMCAyNzkgMTEwCnEyMCAyNyAzMSA1MWwtNjAgMTA5cS00MiAtODAgLTk5IC0xMTZ0LTE0NiAtMzZxLTExNSAwIC0xOTEgODd0LTc2IDIwNHEwIDEwNSA4MiAxODl0MTg2IDg0cTExMiAwIDE3MCAtNTMuNXQxMDQgLTE3Mi41cTggLTIxIDI1LjUgLTY4LjV0MjguNSAtNzYuNXQzMS41IC03NC41dDM4LjUgLTc0dDQ1LjUgLTYyLjV0NTUuNSAtNTMuNXQ2NiAtMzN0ODAgLTEzLjVxMTA3IDAgMTgzIDY5LjV0NzYgMTc0LjV6TTE1MzYgMTEyMHYtOTYwCnEwIC0xMTkgLTg0LjUgLTIwMy41dC0yMDMuNSAtODQuNWgtOTYwcS0xMTkgMCAtMjAzLjUgODQuNXQtODQuNSAyMDMuNXY5NjBxMCAxMTkgODQuNSAyMDMuNXQyMDMuNSA4NC41aDk2MHExMTkgMCAyMDMuNSAtODQuNXQ4NC41IC0yMDMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQ4NCIgdW5pY29kZT0iJiN4ZjIwNDsiIGhvcml6LWFkdi14PSIyMDQ4IiAKZD0iTTExNTIgNjQwcTAgMTA0IC00MC41IDE5OC41dC0xMDkuNSAxNjMuNXQtMTYzLjUgMTA5LjV0LTE5OC41IDQwLjV0LTE5OC41IC00MC41dC0xNjMuNSAtMTA5LjV0LTEwOS41IC0xNjMuNXQtNDAuNSAtMTk4LjV0NDAuNSAtMTk4LjV0MTA5LjUgLTE2My41dDE2My41IC0xMDkuNXQxOTguNSAtNDAuNXQxOTguNSA0MC41dDE2My41IDEwOS41dDEwOS41IDE2My41dDQwLjUgMTk4LjV6TTE5MjAgNjQwcTAgMTA0IC00MC41IDE5OC41CnQtMTA5LjUgMTYzLjV0LTE2My41IDEwOS41dC0xOTguNSA0MC41aC0zODZxMTE5IC05MCAxODguNSAtMjI0dDY5LjUgLTI4OHQtNjkuNSAtMjg4dC0xODguNSAtMjI0aDM4NnExMDQgMCAxOTguNSA0MC41dDE2My41IDEwOS41dDEwOS41IDE2My41dDQwLjUgMTk4LjV6TTIwNDggNjQwcTAgLTEzMCAtNTEgLTI0OC41dC0xMzYuNSAtMjA0dC0yMDQgLTEzNi41dC0yNDguNSAtNTFoLTc2OHEtMTMwIDAgLTI0OC41IDUxdC0yMDQgMTM2LjUKdC0xMzYuNSAyMDR0LTUxIDI0OC41dDUxIDI0OC41dDEzNi41IDIwNHQyMDQgMTM2LjV0MjQ4LjUgNTFoNzY4cTEzMCAwIDI0OC41IC01MXQyMDQgLTEzNi41dDEzNi41IC0yMDR0NTEgLTI0OC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDg1IiB1bmljb2RlPSImI3hmMjA1OyIgaG9yaXotYWR2LXg9IjIwNDgiIApkPSJNMCA2NDBxMCAxMzAgNTEgMjQ4LjV0MTM2LjUgMjA0dDIwNCAxMzYuNXQyNDguNSA1MWg3NjhxMTMwIDAgMjQ4LjUgLTUxdDIwNCAtMTM2LjV0MTM2LjUgLTIwNHQ1MSAtMjQ4LjV0LTUxIC0yNDguNXQtMTM2LjUgLTIwNHQtMjA0IC0xMzYuNXQtMjQ4LjUgLTUxaC03NjhxLTEzMCAwIC0yNDguNSA1MXQtMjA0IDEzNi41dC0xMzYuNSAyMDR0LTUxIDI0OC41ek0xNDA4IDEyOHExMDQgMCAxOTguNSA0MC41dDE2My41IDEwOS41CnQxMDkuNSAxNjMuNXQ0MC41IDE5OC41dC00MC41IDE5OC41dC0xMDkuNSAxNjMuNXQtMTYzLjUgMTA5LjV0LTE5OC41IDQwLjV0LTE5OC41IC00MC41dC0xNjMuNSAtMTA5LjV0LTEwOS41IC0xNjMuNXQtNDAuNSAtMTk4LjV0NDAuNSAtMTk4LjV0MTA5LjUgLTE2My41dDE2My41IC0xMDkuNXQxOTguNSAtNDAuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQ4NiIgdW5pY29kZT0iJiN4ZjIwNjsiIGhvcml6LWFkdi14PSIyMzA0IiAKZD0iTTc2MiAzODRoLTMxNHEtNDAgMCAtNTcuNSAzNXQ2LjUgNjdsMTg4IDI1MXEtNjUgMzEgLTEzNyAzMXEtMTMyIDAgLTIyNiAtOTR0LTk0IC0yMjZ0OTQgLTIyNnQyMjYgLTk0cTExNSAwIDIwMyA3Mi41dDExMSAxODMuNXpNNTc2IDUxMmgxODZxLTE4IDg1IC03NSAxNDh6TTEwNTYgNTEybDI4OCAzODRoLTQ4MGwtOTkgLTEzMnExMDUgLTEwMyAxMjYgLTI1MmgxNjV6TTIxNzYgNDQ4cTAgMTMyIC05NCAyMjZ0LTIyNiA5NApxLTYwIDAgLTEyMSAtMjRsMTc0IC0yNjBxMTUgLTIzIDEwIC00OXQtMjcgLTQwcS0xNSAtMTEgLTM2IC0xMXEtMzUgMCAtNTMgMjlsLTE3NCAyNjBxLTkzIC05NSAtOTMgLTIyNXEwIC0xMzIgOTQgLTIyNnQyMjYgLTk0dDIyNiA5NHQ5NCAyMjZ6TTIzMDQgNDQ4cTAgLTE4NSAtMTMxLjUgLTMxNi41dC0zMTYuNSAtMTMxLjV0LTMxNi41IDEzMS41dC0xMzEuNSAzMTYuNXEwIDk3IDM5LjUgMTgzLjV0MTA5LjUgMTQ5LjVsLTY1IDk4bC0zNTMgLTQ2OQpxLTE4IC0yNiAtNTEgLTI2aC0xOTdxLTIzIC0xNjQgLTE0OSAtMjc0dC0yOTQgLTExMHEtMTg1IDAgLTMxNi41IDEzMS41dC0xMzEuNSAzMTYuNXQxMzEuNSAzMTYuNXQzMTYuNSAxMzEuNXExMTQgMCAyMTUgLTU1bDEzNyAxODNoLTIyNHEtMjYgMCAtNDUgMTl0LTE5IDQ1dDE5IDQ1dDQ1IDE5aDM4NHYtMTI4aDQzNWwtODUgMTI4aC0yMjJxLTI2IDAgLTQ1IDE5dC0xOSA0NXQxOSA0NXQ0NSAxOWgyNTZxMzMgMCA1MyAtMjhsMjY3IC00MDAKcTkxIDQ0IDE5MiA0NHExODUgMCAzMTYuNSAtMTMxLjV0MTMxLjUgLTMxNi41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDg3IiB1bmljb2RlPSImI3hmMjA3OyIgCmQ9Ik0zODQgMzIwcTAgNTMgLTM3LjUgOTAuNXQtOTAuNSAzNy41dC05MC41IC0zNy41dC0zNy41IC05MC41dDM3LjUgLTkwLjV0OTAuNSAtMzcuNXQ5MC41IDM3LjV0MzcuNSA5MC41ek0xNDA4IDMyMHEwIDUzIC0zNy41IDkwLjV0LTkwLjUgMzcuNXQtOTAuNSAtMzcuNXQtMzcuNSAtOTAuNXQzNy41IC05MC41dDkwLjUgLTM3LjV0OTAuNSAzNy41dDM3LjUgOTAuNXpNMTM2MiA3MTZsLTcyIDM4NHEtNSAyMyAtMjIuNSAzNy41dC00MC41IDE0LjUKaC05MThxLTIzIDAgLTQwLjUgLTE0LjV0LTIyLjUgLTM3LjVsLTcyIC0zODRxLTUgLTMwIDE0IC01M3Q0OSAtMjNoMTA2MnEzMCAwIDQ5IDIzdDE0IDUzek0xMTM2IDEzMjhxMCAyMCAtMTQgMzR0LTM0IDE0aC02NDBxLTIwIDAgLTM0IC0xNHQtMTQgLTM0dDE0IC0zNHQzNCAtMTRoNjQwcTIwIDAgMzQgMTR0MTQgMzR6TTE1MzYgNjAzdi02MDNoLTEyOHYtMTI4cTAgLTUzIC0zNy41IC05MC41dC05MC41IC0zNy41dC05MC41IDM3LjUKdC0zNy41IDkwLjV2MTI4aC03Njh2LTEyOHEwIC01MyAtMzcuNSAtOTAuNXQtOTAuNSAtMzcuNXQtOTAuNSAzNy41dC0zNy41IDkwLjV2MTI4aC0xMjh2NjAzcTAgMTEyIDI1IDIyM2wxMDMgNDU0cTkgNzggOTcuNSAxMzd0MjMwIDg5dDMxMi41IDMwdDMxMi41IC0zMHQyMzAgLTg5dDk3LjUgLTEzN2wxMDUgLTQ1NHEyMyAtMTAyIDIzIC0yMjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80ODgiIHVuaWNvZGU9IiYjeGYyMDg7IiBob3Jpei1hZHYteD0iMjA0OCIgCmQ9Ik0xNDYzIDcwNHEwIC0zNSAtMjUgLTYwLjV0LTYxIC0yNS41aC03MDJxLTM2IDAgLTYxIDI1LjV0LTI1IDYwLjV0MjUgNjAuNXQ2MSAyNS41aDcwMnEzNiAwIDYxIC0yNS41dDI1IC02MC41ek0xNjc3IDcwNHEwIDg2IC0yMyAxNzBoLTk4MnEtMzYgMCAtNjEgMjV0LTI1IDYwcTAgMzYgMjUgNjF0NjEgMjVoOTA4cS04OCAxNDMgLTIzNSAyMjd0LTMyMCA4NHEtMTc3IDAgLTMyNy41IC04Ny41dC0yMzggLTIzNy41dC04Ny41IC0zMjcKcTAgLTg2IDIzIC0xNzBoOTgycTM2IDAgNjEgLTI1dDI1IC02MHEwIC0zNiAtMjUgLTYxdC02MSAtMjVoLTkwOHE4OCAtMTQzIDIzNS41IC0yMjd0MzIwLjUgLTg0cTEzMiAwIDI1MyA1MS41dDIwOCAxMzl0MTM5IDIwOHQ1MiAyNTMuNXpNMjA0OCA5NTlxMCAtMzUgLTI1IC02MHQtNjEgLTI1aC0xMzFxMTcgLTg1IDE3IC0xNzBxMCAtMTY3IC02NS41IC0zMTkuNXQtMTc1LjUgLTI2M3QtMjYyLjUgLTE3NnQtMzE5LjUgLTY1LjUKcS0yNDYgMCAtNDQ4LjUgMTMzdC0zMDEuNSAzNTBoLTE4OXEtMzYgMCAtNjEgMjV0LTI1IDYxcTAgMzUgMjUgNjB0NjEgMjVoMTMycS0xNyA4NSAtMTcgMTcwcTAgMTY3IDY1LjUgMzE5LjV0MTc1LjUgMjYzdDI2Mi41IDE3NnQzMjAuNSA2NS41cTI0NSAwIDQ0Ny41IC0xMzN0MzAxLjUgLTM1MGgxODhxMzYgMCA2MSAtMjV0MjUgLTYxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDg5IiB1bmljb2RlPSImI3hmMjA5OyIgaG9yaXotYWR2LXg9IjEyODAiIApkPSJNOTUzIDExNThsLTExNCAtMzI4bDExNyAtMjFxMTY1IDQ1MSAxNjUgNTE4cTAgNTYgLTM4IDU2cS01NyAwIC0xMzAgLTIyNXpNNjU0IDQ3MWwzMyAtODhxMzcgNDIgNzEgNjdsLTMzIDUuNXQtMzguNSA3dC0zMi41IDguNXpNMzYyIDEzNjdxMCAtOTggMTU5IC01MjFxMTcgMTAgNDkgMTBxMTUgMCA3NSAtNWwtMTIxIDM1MXEtNzUgMjIwIC0xMjMgMjIwcS0xOSAwIC0yOSAtMTcuNXQtMTAgLTM3LjV6TTI4MyA2MDhxMCAtMzYgNTEuNSAtMTE5CnQxMTcuNSAtMTUzdDEwMCAtNzBxMTQgMCAyNS41IDEzdDExLjUgMjdxMCAyNCAtMzIgMTAycS0xMyAzMiAtMzIgNzJ0LTQ3LjUgODl0LTYxLjUgODF0LTYyIDMycS0yMCAwIC00NS41IC0yN3QtMjUuNSAtNDd6TTEyNSAyNzNxMCAtNDEgMjUgLTEwNHE1OSAtMTQ1IDE4My41IC0yMjd0MjgxLjUgLTgycTIyNyAwIDM4MiAxNzBxMTUyIDE2OSAxNTIgNDI3cTAgNDMgLTEgNjd0LTExLjUgNjJ0LTMwLjUgNTZxLTU2IDQ5IC0yMTEuNSA3NS41CnQtMjcwLjUgMjYuNXEtMzcgMCAtNDkgLTExcS0xMiAtNSAtMTIgLTM1cTAgLTM0IDIxLjUgLTYwdDU1LjUgLTQwdDc3LjUgLTIzLjV0ODcuNSAtMTEuNXQ4NSAtNHQ3MCAwaDIzcTI0IDAgNDAgLTE5cTE1IC0xOSAxOSAtNTVxLTI4IC0yOCAtOTYgLTU0cS02MSAtMjIgLTkzIC00NnEtNjQgLTQ2IC0xMDguNSAtMTE0dC00NC41IC0xMzdxMCAtMzEgMTguNSAtODguNXQxOC41IC04Ny41bC0zIC0xMnEtNCAtMTIgLTQgLTE0CnEtMTM3IDEwIC0xNDYgMjE2cS04IC0yIC00MSAtMnEyIC03IDIgLTIxcTAgLTUzIC00MC41IC04OS41dC05NC41IC0zNi41cS04MiAwIC0xNjYuNSA3OHQtODQuNSAxNTlxMCAzNCAzMyA2N3E1MiAtNjQgNjAgLTc2cTc3IC0xMDQgMTMzIC0xMDRxMTIgMCAyNi41IDguNXQxNC41IDIwLjVxMCAzNCAtODcuNSAxNDV0LTExNi41IDExMXEtNDMgMCAtNzAgLTQ0LjV0LTI3IC05MC41ek0xMSAyNjRxMCAxMDEgNDIuNSAxNjN0MTM2LjUgODgKcS0yOCA3NCAtMjggMTA0cTAgNjIgNjEgMTIzdDEyMiA2MXEyOSAwIDcwIC0xNXEtMTYzIDQ2MiAtMTYzIDU2N3EwIDgwIDQxIDEzMC41dDExOSA1MC41cTEzMSAwIDMyNSAtNTgxcTYgLTE3IDggLTIzcTYgMTYgMjkgNzkuNXQ0My41IDExOC41dDU0IDEyNy41dDY0LjUgMTIzdDcwLjUgODYuNXQ3Ni41IDM2cTcxIDAgMTEyIC00OXQ0MSAtMTIycTAgLTEwOCAtMTU5IC01NTBxNjEgLTE1IDEwMC41IC00NnQ1OC41IC03OHQyNiAtOTMuNQp0NyAtMTEwLjVxMCAtMTUwIC00NyAtMjgwdC0xMzIgLTIyNXQtMjExIC0xNTB0LTI3OCAtNTVxLTExMSAwIC0yMjMgNDJxLTE0OSA1NyAtMjU4IDE5MS41dC0xMDkgMjg2LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80OTAiIHVuaWNvZGU9IiYjeGYyMGE7IiBob3Jpei1hZHYteD0iMjA0OCIgCmQ9Ik03ODUgNTI4aDIwN3EtMTQgLTE1OCAtOTguNSAtMjQ4LjV0LTIxNC41IC05MC41cS0xNjIgMCAtMjU0LjUgMTE2dC05Mi41IDMxNnEwIDE5NCA5MyAzMTEuNXQyMzMgMTE3LjVxMTQ4IDAgMjMyIC04N3Q5NyAtMjQ3aC0yMDNxLTUgNjQgLTM1LjUgOTl0LTgxLjUgMzVxLTU3IDAgLTg4LjUgLTYwLjV0LTMxLjUgLTE3Ny41cTAgLTQ4IDUgLTg0dDE4IC02OS41dDQwIC01MS41dDY2IC0xOHE5NSAwIDEwOSAxMzl6TTE0OTcgNTI4aDIwNgpxLTE0IC0xNTggLTk4IC0yNDguNXQtMjE0IC05MC41cS0xNjIgMCAtMjU0LjUgMTE2dC05Mi41IDMxNnEwIDE5NCA5MyAzMTEuNXQyMzMgMTE3LjVxMTQ4IDAgMjMyIC04N3Q5NyAtMjQ3aC0yMDRxLTQgNjQgLTM1IDk5dC04MSAzNXEtNTcgMCAtODguNSAtNjAuNXQtMzEuNSAtMTc3LjVxMCAtNDggNSAtODR0MTggLTY5LjV0MzkuNSAtNTEuNXQ2NS41IC0xOHE0OSAwIDc2LjUgMzh0MzMuNSAxMDF6TTE4NTYgNjQ3cTAgMjA3IC0xNS41IDMwNwp0LTYwLjUgMTYxcS02IDggLTEzLjUgMTR0LTIxLjUgMTV0LTE2IDExcS04NiA2MyAtNjk3IDYzcS02MjUgMCAtNzEwIC02M3EtNSAtNCAtMTcuNSAtMTEuNXQtMjEgLTE0dC0xNC41IC0xNC41cS00NSAtNjAgLTYwIC0xNTkuNXQtMTUgLTMwOC41cTAgLTIwOCAxNSAtMzA3LjV0NjAgLTE2MC41cTYgLTggMTUgLTE1dDIwLjUgLTE0dDE3LjUgLTEycTQ0IC0zMyAyMzkuNSAtNDl0NDcwLjUgLTE2cTYxMCAwIDY5NyA2NXE1IDQgMTcgMTF0MjAuNSAxNAp0MTMuNSAxNnE0NiA2MCA2MSAxNTl0MTUgMzA5ek0yMDQ4IDE0MDh2LTE1MzZoLTIwNDh2MTUzNmgyMDQ4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDkxIiB1bmljb2RlPSImI3hmMjBiOyIgCmQ9Ik05OTIgOTEydi00OTZxMCAtMTQgLTkgLTIzdC0yMyAtOWgtMTYwcS0xNCAwIC0yMyA5dC05IDIzdjQ5NnEwIDExMiAtODAgMTkydC0xOTIgODBoLTI3MnYtMTE1MnEwIC0xNCAtOSAtMjN0LTIzIC05aC0xNjBxLTE0IDAgLTIzIDl0LTkgMjN2MTM0NHEwIDE0IDkgMjN0MjMgOWg0NjRxMTM1IDAgMjQ5IC02Ni41dDE4MC41IC0xODAuNXQ2Ni41IC0yNDl6TTEzNzYgMTM3NnYtODgwcTAgLTEzNSAtNjYuNSAtMjQ5dC0xODAuNSAtMTgwLjUKdC0yNDkgLTY2LjVoLTQ2NHEtMTQgMCAtMjMgOXQtOSAyM3Y5NjBxMCAxNCA5IDIzdDIzIDloMTYwcTE0IDAgMjMgLTl0OSAtMjN2LTc2OGgyNzJxMTEyIDAgMTkyIDgwdDgwIDE5MnY4ODBxMCAxNCA5IDIzdDIzIDloMTYwcTE0IDAgMjMgLTl0OSAtMjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80OTIiIHVuaWNvZGU9IiYjeGYyMGM7IiAKZD0iTTEzMTEgNjk0di0xMTRxMCAtMjQgLTEzLjUgLTM4dC0zNy41IC0xNGgtMjAycS0yNCAwIC0zOCAxNHQtMTQgMzh2MTE0cTAgMjQgMTQgMzh0MzggMTRoMjAycTI0IDAgMzcuNSAtMTR0MTMuNSAtMzh6TTgyMSA0NjR2MjUwcTAgNTMgLTMyLjUgODUuNXQtODUuNSAzMi41aC0xMzNxLTY4IDAgLTk2IC01MnEtMjggNTIgLTk2IDUyaC0xMzBxLTUzIDAgLTg1LjUgLTMyLjV0LTMyLjUgLTg1LjV2LTI1MHEwIC0yMiAyMSAtMjJoNTUKcTIyIDAgMjIgMjJ2MjMwcTAgMjQgMTMuNSAzOHQzOC41IDE0aDk0cTI0IDAgMzggLTE0dDE0IC0zOHYtMjMwcTAgLTIyIDIxIC0yMmg1NHEyMiAwIDIyIDIydjIzMHEwIDI0IDE0IDM4dDM4IDE0aDk3cTI0IDAgMzcuNSAtMTR0MTMuNSAtMzh2LTIzMHEwIC0yMiAyMiAtMjJoNTVxMjEgMCAyMSAyMnpNMTQxMCA1NjB2MTU0cTAgNTMgLTMzIDg1LjV0LTg2IDMyLjVoLTI2NHEtNTMgMCAtODYgLTMyLjV0LTMzIC04NS41di00MTAKcTAgLTIxIDIyIC0yMWg1NXEyMSAwIDIxIDIxdjE4MHEzMSAtNDIgOTQgLTQyaDE5MXE1MyAwIDg2IDMyLjV0MzMgODUuNXpNMTUzNiAxMTc2di0xMDcycTAgLTk2IC02OCAtMTY0dC0xNjQgLTY4aC0xMDcycS05NiAwIC0xNjQgNjh0LTY4IDE2NHYxMDcycTAgOTYgNjggMTY0dDE2NCA2OGgxMDcycTk2IDAgMTY0IC02OHQ2OCAtMTY0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDkzIiB1bmljb2RlPSImI3hmMjBkOyIgCmQ9Ik05MTUgNDUwaC0yOTRsMTQ3IDU1MXpNMTAwMSAxMjhoMzExbC0zMjQgMTAyNGgtNDQwbC0zMjQgLTEwMjRoMzExbDM4MyAzMTR6TTE1MzYgMTEyMHYtOTYwcTAgLTExOCAtODUgLTIwM3QtMjAzIC04NWgtOTYwcS0xMTggMCAtMjAzIDg1dC04NSAyMDN2OTYwcTAgMTE4IDg1IDIwM3QyMDMgODVoOTYwcTExOCAwIDIwMyAtODV0ODUgLTIwM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzQ5NCIgdW5pY29kZT0iJiN4ZjIwZTsiIGhvcml6LWFkdi14PSIyMDQ4IiAKZD0iTTIwNDggNjQxcTAgLTIxIC0xMyAtMzYuNXQtMzMgLTE5LjVsLTIwNSAtMzU2cTMgLTkgMyAtMThxMCAtMjAgLTEyLjUgLTM1LjV0LTMyLjUgLTE5LjVsLTE5MyAtMzM3cTMgLTggMyAtMTZxMCAtMjMgLTE2LjUgLTQwdC00MC41IC0xN3EtMjUgMCAtNDEgMThoLTQwMHEtMTcgLTIwIC00MyAtMjB0LTQzIDIwaC0zOTlxLTE3IC0yMCAtNDMgLTIwcS0yMyAwIC00MCAxNi41dC0xNyA0MC41cTAgOCA0IDIwbC0xOTMgMzM1CnEtMjAgNCAtMzIuNSAxOS41dC0xMi41IDM1LjVxMCA5IDMgMThsLTIwNiAzNTZxLTIwIDUgLTMyLjUgMjAuNXQtMTIuNSAzNS41cTAgMjEgMTMuNSAzNi41dDMzLjUgMTkuNWwxOTkgMzQ0cTAgMSAtMC41IDN0LTAuNSAzcTAgMzYgMzQgNTFsMjA5IDM2M3EtNCAxMCAtNCAxOHEwIDI0IDE3IDQwLjV0NDAgMTYuNXEyNiAwIDQ0IC0yMWgzOTZxMTYgMjEgNDMgMjF0NDMgLTIxaDM5OHExOCAyMSA0NCAyMXEyMyAwIDQwIC0xNi41dDE3IC00MC41CnEwIC02IC00IC0xOGwyMDcgLTM1OHEyMyAtMSAzOSAtMTcuNXQxNiAtMzguNXEwIC0xMyAtNyAtMjdsMTg3IC0zMjRxMTkgLTQgMzEuNSAtMTkuNXQxMi41IC0zNS41ek0xMDYzIC0xNThoMzg5bC0zNDIgMzU0aC0xNDNsLTM0MiAtMzU0aDM2MHExOCAxNiAzOSAxNnQzOSAtMTZ6TTExMiA2NTRxMSAtNCAxIC0xM3EwIC0xMCAtMiAtMTVsMjA4IC0zNjBsMTUgLTZsMTg4IDE5OXYzNDdsLTE4NyAxOTRxLTEzIC04IC0yOSAtMTB6TTk4NiAxNDM4CmgtMzg4bDE5MCAtMjAwbDU1NCAyMDBoLTI4MHEtMTYgLTE2IC0zOCAtMTZ0LTM4IDE2ek0xNjg5IDIyNnExIDYgNSAxMWwtNjQgNjhsLTE3IC03OWg3NnpNMTU4MyAyMjZsMjIgMTA1bC0yNTIgMjY2bC0yOTYgLTMwN2w2MyAtNjRoNDYzek0xNDk1IC0xNDJsMTYgMjhsNjUgMzEwaC00MjdsMzMzIC0zNDNxOCA0IDEzIDV6TTU3OCAtMTU4aDVsMzQyIDM1NGgtMzczdi0zMzVsNCAtNnExNCAtNSAyMiAtMTN6TTU1MiAyMjZoNDAybDY0IDY2CmwtMzA5IDMyMWwtMTU3IC0xNjZ2LTIyMXpNMzU5IDIyNmgxNjN2MTg5bC0xNjggLTE3N3E0IC04IDUgLTEyek0zNTggMTA1MXEwIC0xIDAuNSAtMnQwLjUgLTJxMCAtMTYgLTggLTI5bDE3MSAtMTc3djI2OXpNNTUyIDExMjF2LTMxMWwxNTMgLTE1N2wyOTcgMzE0bC0yMjMgMjM2ek01NTYgMTQyNWwtNCAtOHYtMjY0bDIwNSA3NGwtMTkxIDIwMXEtNiAtMiAtMTAgLTN6TTE0NDcgMTQzOGgtMTZsLTYyMSAtMjI0bDIxMyAtMjI1ek0xMDIzIDk0NgpsLTI5NyAtMzE1bDMxMSAtMzE5bDI5NiAzMDd6TTY4OCA2MzRsLTEzNiAxNDF2LTI4NHpNMTAzOCAyNzBsLTQyIC00NGg4NXpNMTM3NCA2MThsMjM4IC0yNTFsMTMyIDYyNGwtMyA1bC0xIDF6TTE3MTggMTAxOHEtOCAxMyAtOCAyOXYybC0yMTYgMzc2cS01IDEgLTEzIDVsLTQzNyAtNDYzbDMxMCAtMzI3ek01MjIgMTE0MnYyMjNsLTE2MyAtMjgyek01MjIgMTk2aC0xNjNsMTYzIC0yODN2Mjgzek0xNjA3IDE5NmwtNDggLTIyN2wxMzAgMjI3aC04Mgp6TTE3MjkgMjY2bDIwNyAzNjFxLTIgMTAgLTIgMTRxMCAxIDMgMTZsLTE3MSAyOTZsLTEyOSAtNjEybDc3IC04MnE1IDMgMTUgN3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iZjIxMCIgdW5pY29kZT0iJiN4ZjIxMDsiIApkPSJNMCA4NTZxMCAxMzEgOTEuNSAyMjYuNXQyMjIuNSA5NS41aDc0MmwzNTIgMzU4di0xNDcwcTAgLTEzMiAtOTEuNSAtMjI3dC0yMjIuNSAtOTVoLTc4MHEtMTMxIDAgLTIyMi41IDk1dC05MS41IDIyN3Y3OTB6TTEyMzIgMTAybC0xNzYgMTgwdjQyNXEwIDQ2IC0zMiA3OXQtNzggMzNoLTQ4NHEtNDYgMCAtNzggLTMzdC0zMiAtNzl2LTQ5MnEwIC00NiAzMi41IC03OS41dDc3LjUgLTMzLjVoNzcweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNDk2IiB1bmljb2RlPSImI3hmMjExOyIgCmQ9Ik05MzQgMTM4NnEtMzE3IC0xMjEgLTU1NiAtMzYyLjV0LTM1OCAtNTYwLjVxLTIwIDg5IC0yMCAxNzZxMCAyMDggMTAyLjUgMzg0LjV0Mjc4LjUgMjc5dDM4NCAxMDIuNXE4MiAwIDE2OSAtMTl6TTEyMDMgMTI2N3E5MyAtNjUgMTY0IC0xNTVxLTM4OSAtMTEzIC02NzQuNSAtNDAwLjV0LTM5Ni41IC02NzYuNXEtOTMgNzIgLTE1NSAxNjJxMTEyIDM4NiAzOTUgNjcxdDY2NyAzOTl6TTQ3MCAtNjdxMTE1IDM1NiAzNzkuNSA2MjJ0NjE5LjUgMzg0CnE0MCAtOTIgNTQgLTE5NXEtMjkyIC0xMjAgLTUxNiAtMzQ1dC0zNDMgLTUxOHEtMTAzIDE0IC0xOTQgNTJ6TTE1MzYgLTEyNXEtMTkzIDUwIC0zNjcgMTE1cS0xMzUgLTg0IC0yOTAgLTEwN3ExMDkgMjA1IDI3NCAzNzAuNXQzNjkgMjc1LjVxLTIxIC0xNTIgLTEwMSAtMjg0cTY1IC0xNzUgMTE1IC0zNzB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImYyMTIiIHVuaWNvZGU9IiYjeGYyMTI7IiBob3Jpei1hZHYteD0iMjA0OCIgCmQ9Ik0xODkzIDExNDRsMTU1IC0xMjcycS0xMzEgMCAtMjU3IDU3cS0yMDAgOTEgLTM5MyA5MXEtMjI2IDAgLTM3NCAtMTQ4cS0xNDggMTQ4IC0zNzQgMTQ4cS0xOTMgMCAtMzkzIC05MXEtMTI4IC01NyAtMjUyIC01N2gtNWwxNTUgMTI3MnEyMjQgMTI3IDQ4MiAxMjdxMjMzIDAgMzg3IC0xMDZxMTU0IDEwNiAzODcgMTA2cTI1OCAwIDQ4MiAtMTI3ek0xMzk4IDE1N3ExMjkgMCAyMzIgLTI4LjV0MjYwIC05My41bC0xMjQgMTAyMQpxLTE3MSA3OCAtMzY4IDc4cS0yMjQgMCAtMzc0IC0xNDFxLTE1MCAxNDEgLTM3NCAxNDFxLTE5NyAwIC0zNjggLTc4bC0xMjQgLTEwMjFxMTA1IDQzIDE2NS41IDY1dDE0OC41IDM5LjV0MTc4IDE3LjVxMjAyIDAgMzc0IC0xMDhxMTcyIDEwOCAzNzQgMTA4ek0xNDM4IDE5MWwtNTUgOTA3cS0yMTEgLTQgLTM1OSAtMTU1cS0xNTIgMTU1IC0zNzQgMTU1cS0xNzYgMCAtMzM2IC02NmwtMTE0IC05NDFxMTI0IDUxIDIyOC41IDc2dDIyMS41IDI1CnEyMDkgMCAzNzQgLTEwMnExNzIgMTA3IDM3NCAxMDJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80OTgiIHVuaWNvZGU9IiYjeGYyMTM7IiBob3Jpei1hZHYteD0iMjA0OCIgCmQ9Ik0xNTAwIDE2NXY3MzNxMCAyMSAtMTUgMzZ0LTM1IDE1aC05M3EtMjAgMCAtMzUgLTE1dC0xNSAtMzZ2LTczM3EwIC0yMCAxNSAtMzV0MzUgLTE1aDkzcTIwIDAgMzUgMTV0MTUgMzV6TTEyMTYgMTY1djUzMXEwIDIwIC0xNSAzNXQtMzUgMTVoLTEwMXEtMjAgMCAtMzUgLTE1dC0xNSAtMzV2LTUzMXEwIC0yMCAxNSAtMzV0MzUgLTE1aDEwMXEyMCAwIDM1IDE1dDE1IDM1ek05MjQgMTY1djQyOXEwIDIwIC0xNSAzNXQtMzUgMTVoLTEwMQpxLTIwIDAgLTM1IC0xNXQtMTUgLTM1di00MjlxMCAtMjAgMTUgLTM1dDM1IC0xNWgxMDFxMjAgMCAzNSAxNXQxNSAzNXpNNjMyIDE2NXYzNjJxMCAyMCAtMTUgMzV0LTM1IDE1aC0xMDFxLTIwIDAgLTM1IC0xNXQtMTUgLTM1di0zNjJxMCAtMjAgMTUgLTM1dDM1IC0xNWgxMDFxMjAgMCAzNSAxNXQxNSAzNXpNMjA0OCAzMTFxMCAtMTY2IC0xMTggLTI4NHQtMjg0IC0xMThoLTEyNDRxLTE2NiAwIC0yODQgMTE4dC0xMTggMjg0CnEwIDExNiA2MyAyMTQuNXQxNjggMTQ4LjVxLTEwIDM0IC0xMCA3M3EwIDExMyA4MC41IDE5My41dDE5My41IDgwLjVxMTAyIDAgMTgwIC02N3E0NSAxODMgMTk0IDMwMHQzMzggMTE3cTE0OSAwIDI3NSAtNzMuNXQxOTkuNSAtMTk5LjV0NzMuNSAtMjc1cTAgLTY2IC0xNCAtMTIycTEzNSAtMzMgMjIxIC0xNDIuNXQ4NiAtMjQ3LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il80OTkiIHVuaWNvZGU9IiYjeGYyMTQ7IiAKZD0iTTAgMTUzNmgxNTM2di0xMzkybC03NzYgLTMzOGwtNzYwIDMzOHYxMzkyek0xNDM2IDIwOXY5MjZoLTEzMzZ2LTkyNmw2NjEgLTI5NHpNMTQzNiAxMjM1djIwMWgtMTMzNnYtMjAxaDEzMzZ6TTE4MSA5Mzd2LTExNWgtMzd2MTE1aDM3ek0xODEgNzg5di0xMTVoLTM3djExNWgzN3pNMTgxIDY0MXYtMTE1aC0zN3YxMTVoMzd6TTE4MSA0OTN2LTExNWgtMzd2MTE1aDM3ek0xODEgMzQ1di0xMTVoLTM3djExNWgzN3pNMjA3IDIwMmwxNSAzNApsMTA1IC00N2wtMTUgLTMzek0zNDMgMTQybDE1IDM0bDEwNSAtNDZsLTE1IC0zNHpNNDc4IDgybDE1IDM0bDEwNSAtNDZsLTE1IC0zNHpNNjE0IDIzbDE1IDMzbDEwNCAtNDZsLTE1IC0zNHpNNzk3IDEwbDEwNSA0NmwxNSAtMzNsLTEwNSAtNDd6TTkzMiA3MGwxMDUgNDZsMTUgLTM0bC0xMDUgLTQ2ek0xMDY4IDEzMGwxMDUgNDZsMTUgLTM0bC0xMDUgLTQ2ek0xMjAzIDE4OWwxMDUgNDdsMTUgLTM0bC0xMDUgLTQ2ek0yNTkgMTM4OXYtMzZoLTExNAp2MzZoMTE0ek00MjEgMTM4OXYtMzZoLTExNXYzNmgxMTV6TTU4MyAxMzg5di0zNmgtMTE1djM2aDExNXpNNzQ0IDEzODl2LTM2aC0xMTR2MzZoMTE0ek05MDYgMTM4OXYtMzZoLTExNHYzNmgxMTR6TTEwNjggMTM4OXYtMzZoLTExNXYzNmgxMTV6TTEyMzAgMTM4OXYtMzZoLTExNXYzNmgxMTV6TTEzOTEgMTM4OXYtMzZoLTExNHYzNmgxMTR6TTE4MSAxMDQ5di03OWgtMzd2MTE1aDExNXYtMzZoLTc4ek00MjEgMTA4NXYtMzZoLTExNXYzNmgxMTV6Ck01ODMgMTA4NXYtMzZoLTExNXYzNmgxMTV6TTc0NCAxMDg1di0zNmgtMTE0djM2aDExNHpNOTA2IDEwODV2LTM2aC0xMTR2MzZoMTE0ek0xMDY4IDEwODV2LTM2aC0xMTV2MzZoMTE1ek0xMjMwIDEwODV2LTM2aC0xMTV2MzZoMTE1ek0xMzU1IDk3MHY3OWgtNzh2MzZoMTE1di0xMTVoLTM3ek0xMzU1IDgyMnYxMTVoMzd2LTExNWgtMzd6TTEzNTUgNjc0djExNWgzN3YtMTE1aC0zN3pNMTM1NSA1MjZ2MTE1aDM3di0xMTVoLTM3ek0xMzU1IDM3OAp2MTE1aDM3di0xMTVoLTM3ek0xMzU1IDIzMHYxMTVoMzd2LTExNWgtMzd6TTc2MCAyNjVxLTEyOSAwIC0yMjEgOTEuNXQtOTIgMjIxLjVxMCAxMjkgOTIgMjIxdDIyMSA5MnExMzAgMCAyMjEuNSAtOTJ0OTEuNSAtMjIxcTAgLTEzMCAtOTEuNSAtMjIxLjV0LTIyMS41IC05MS41ek01OTUgNjQ2cTAgLTM2IDE5LjUgLTU2LjV0NDkuNSAtMjV0NjQgLTd0NjQgLTJ0NDkuNSAtOXQxOS41IC0zMC41cTAgLTQ5IC0xMTIgLTQ5cS05NyAwIC0xMjMgNTEKaC0zbC0zMSAtNjNxNjcgLTQyIDE2MiAtNDJxMjkgMCA1Ni41IDV0NTUuNSAxNnQ0NS41IDMzdDE3LjUgNTNxMCA0NiAtMjcuNSA2OS41dC02Ny41IDI3dC03OS41IDN0LTY3IDV0LTI3LjUgMjUuNXEwIDIxIDIwLjUgMzN0NDAuNSAxNXQ0MSAzcTM0IDAgNzAuNSAtMTF0NTEuNSAtMzRoM2wzMCA1OHEtMyAxIC0yMSA4LjV0LTIyLjUgOXQtMTkuNSA3dC0yMiA3dC0yMCA0LjV0LTI0IDR0LTIzIDFxLTI5IDAgLTU2LjUgLTV0LTU0IC0xNi41CnQtNDMgLTM0dC0xNi41IC01My41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTAwIiB1bmljb2RlPSImI3hmMjE1OyIgaG9yaXotYWR2LXg9IjIwNDgiIApkPSJNODYzIDUwNHEwIDExMiAtNzkuNSAxOTEuNXQtMTkxLjUgNzkuNXQtMTkxIC03OS41dC03OSAtMTkxLjV0NzkgLTE5MXQxOTEgLTc5dDE5MS41IDc5dDc5LjUgMTkxek0xNzI2IDUwNXEwIDExMiAtNzkgMTkxdC0xOTEgNzl0LTE5MS41IC03OXQtNzkuNSAtMTkxcTAgLTExMyA3OS41IC0xOTJ0MTkxLjUgLTc5dDE5MSA3OS41dDc5IDE5MS41ek0yMDQ4IDEzMTR2LTEzNDhxMCAtNDQgLTMxLjUgLTc1LjV0LTc2LjUgLTMxLjVoLTE4MzIKcS00NSAwIC03Ni41IDMxLjV0LTMxLjUgNzUuNXYxMzQ4cTAgNDQgMzEuNSA3NS41dDc2LjUgMzEuNWg0MzFxNDQgMCA3NiAtMzEuNXQzMiAtNzUuNXYtMTYxaDc1NHYxNjFxMCA0NCAzMiA3NS41dDc2IDMxLjVoNDMxcTQ1IDAgNzYuNSAtMzEuNXQzMS41IC03NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTAxIiB1bmljb2RlPSImI3hmMjE2OyIgaG9yaXotYWR2LXg9IjIwNDgiIApkPSJNMTQzMCA5NTN6TTE2OTAgNzQ5cTE0OCAwIDI1MyAtOTguNXQxMDUgLTI0NC41cTAgLTE1NyAtMTA5IC0yNjEuNXQtMjY3IC0xMDQuNXEtODUgMCAtMTYyIDI3LjV0LTEzOCA3My41dC0xMTggMTA2dC0xMDkgMTI2dC0xMDMuNSAxMzIuNXQtMTA4LjUgMTI2LjV0LTExNyAxMDZ0LTEzNiA3My41dC0xNTkgMjcuNXEtMTU0IDAgLTI1MS41IC05MS41dC05Ny41IC0yNDQuNXEwIC0xNTcgMTA0IC0yNTB0MjYzIC05M3ExMDAgMCAyMDggMzcuNQp0MTkzIDk4LjVxNSA0IDIxIDE4LjV0MzAgMjR0MjIgOS41cTE0IDAgMjQuNSAtMTAuNXQxMC41IC0yNC41cTAgLTI0IC02MCAtNzdxLTEwMSAtODggLTIzNC41IC0xNDJ0LTI2MC41IC01NHEtMTMzIDAgLTI0NS41IDU4dC0xODAgMTY1dC02Ny41IDI0MXEwIDIwNSAxNDEuNSAzNDF0MzQ3LjUgMTM2cTEyMCAwIDIyNi41IC00My41dDE4NS41IC0xMTN0MTUxLjUgLTE1M3QxMzkgLTE2Ny41dDEzMy41IC0xNTMuNXQxNDkuNSAtMTEzCnQxNzIuNSAtNDMuNXExMDIgMCAxNjguNSA2MS41dDY2LjUgMTYyLjVxMCA5NSAtNjQuNSAxNTl0LTE1OS41IDY0cS0zMCAwIC04MS41IC0xOC41dC02OC41IC0xOC41cS0yMCAwIC0zNS41IDE1dC0xNS41IDM1cTAgMTggOC41IDU3dDguNSA1OXEwIDE1OSAtMTA3LjUgMjYzdC0yNjYuNSAxMDRxLTU4IDAgLTExMS41IC0xOC41dC04NCAtNDAuNXQtNTUuNSAtNDAuNXQtMzMgLTE4LjVxLTE1IDAgLTI1LjUgMTAuNXQtMTAuNSAyNS41CnEwIDE5IDI1IDQ2cTU5IDY3IDE0NyAxMDMuNXQxODIgMzYuNXExOTEgMCAzMTggLTEyNS41dDEyNyAtMzE1LjVxMCAtMzcgLTQgLTY2cTU3IDE1IDExNSAxNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzUwMiIgdW5pY29kZT0iJiN4ZjIxNzsiIGhvcml6LWFkdi14PSIxNjY0IiAKZD0iTTEyMTYgODMycTAgMjYgLTE5IDQ1dC00NSAxOWgtMTI4djEyOHEwIDI2IC0xOSA0NXQtNDUgMTl0LTQ1IC0xOXQtMTkgLTQ1di0xMjhoLTEyOHEtMjYgMCAtNDUgLTE5dC0xOSAtNDV0MTkgLTQ1dDQ1IC0xOWgxMjh2LTEyOHEwIC0yNiAxOSAtNDV0NDUgLTE5dDQ1IDE5dDE5IDQ1djEyOGgxMjhxMjYgMCA0NSAxOXQxOSA0NXpNNjQwIDBxMCAtNTMgLTM3LjUgLTkwLjV0LTkwLjUgLTM3LjV0LTkwLjUgMzcuNXQtMzcuNSA5MC41CnQzNy41IDkwLjV0OTAuNSAzNy41dDkwLjUgLTM3LjV0MzcuNSAtOTAuNXpNMTUzNiAwcTAgLTUzIC0zNy41IC05MC41dC05MC41IC0zNy41dC05MC41IDM3LjV0LTM3LjUgOTAuNXQzNy41IDkwLjV0OTAuNSAzNy41dDkwLjUgLTM3LjV0MzcuNSAtOTAuNXpNMTY2NCAxMDg4di01MTJxMCAtMjQgLTE2IC00Mi41dC00MSAtMjEuNWwtMTA0NCAtMTIycTEgLTcgNC41IC0yMS41dDYgLTI2LjV0Mi41IC0yMnEwIC0xNiAtMjQgLTY0aDkyMApxMjYgMCA0NSAtMTl0MTkgLTQ1dC0xOSAtNDV0LTQ1IC0xOWgtMTAyNHEtMjYgMCAtNDUgMTl0LTE5IDQ1cTAgMTQgMTEgMzkuNXQyOS41IDU5LjV0MjAuNSAzOGwtMTc3IDgyM2gtMjA0cS0yNiAwIC00NSAxOXQtMTkgNDV0MTkgNDV0NDUgMTloMjU2cTE2IDAgMjguNSAtNi41dDIwIC0xNS41dDEzIC0yNC41dDcuNSAtMjYuNXQ1LjUgLTI5LjV0NC41IC0yNS41aDEyMDFxMjYgMCA0NSAtMTl0MTkgLTQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTAzIiB1bmljb2RlPSImI3hmMjE4OyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNMTI4MCA4MzJxMCAyNiAtMTkgNDV0LTQ1IDE5dC00NSAtMTlsLTE0NyAtMTQ2djI5M3EwIDI2IC0xOSA0NXQtNDUgMTl0LTQ1IC0xOXQtMTkgLTQ1di0yOTNsLTE0NyAxNDZxLTE5IDE5IC00NSAxOXQtNDUgLTE5dC0xOSAtNDV0MTkgLTQ1bDI1NiAtMjU2cTE5IC0xOSA0NSAtMTl0NDUgMTlsMjU2IDI1NnExOSAxOSAxOSA0NXpNNjQwIDBxMCAtNTMgLTM3LjUgLTkwLjV0LTkwLjUgLTM3LjV0LTkwLjUgMzcuNXQtMzcuNSA5MC41CnQzNy41IDkwLjV0OTAuNSAzNy41dDkwLjUgLTM3LjV0MzcuNSAtOTAuNXpNMTUzNiAwcTAgLTUzIC0zNy41IC05MC41dC05MC41IC0zNy41dC05MC41IDM3LjV0LTM3LjUgOTAuNXQzNy41IDkwLjV0OTAuNSAzNy41dDkwLjUgLTM3LjV0MzcuNSAtOTAuNXpNMTY2NCAxMDg4di01MTJxMCAtMjQgLTE2IC00Mi41dC00MSAtMjEuNWwtMTA0NCAtMTIycTEgLTcgNC41IC0yMS41dDYgLTI2LjV0Mi41IC0yMnEwIC0xNiAtMjQgLTY0aDkyMApxMjYgMCA0NSAtMTl0MTkgLTQ1dC0xOSAtNDV0LTQ1IC0xOWgtMTAyNHEtMjYgMCAtNDUgMTl0LTE5IDQ1cTAgMTQgMTEgMzkuNXQyOS41IDU5LjV0MjAuNSAzOGwtMTc3IDgyM2gtMjA0cS0yNiAwIC00NSAxOXQtMTkgNDV0MTkgNDV0NDUgMTloMjU2cTE2IDAgMjguNSAtNi41dDIwIC0xNS41dDEzIC0yNC41dDcuNSAtMjYuNXQ1LjUgLTI5LjV0NC41IC0yNS41aDEyMDFxMjYgMCA0NSAtMTl0MTkgLTQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTA0IiB1bmljb2RlPSImI3hmMjE5OyIgaG9yaXotYWR2LXg9IjIwNDgiIApkPSJNMjEyIDc2OGw2MjMgLTY2NWwtMzAwIDY2NWgtMzIzek0xMDI0IC00bDM0OSA3NzJoLTY5OHpNNTM4IDg5NmwyMDQgMzg0aC0yNjJsLTI4OCAtMzg0aDM0NnpNMTIxMyAxMDNsNjIzIDY2NWgtMzIzek02ODMgODk2aDY4MmwtMjA0IDM4NGgtMjc0ek0xNTEwIDg5NmgzNDZsLTI4OCAzODRoLTI2MnpNMTY1MSAxMzgybDM4NCAtNTEycTE0IC0xOCAxMyAtNDEuNXQtMTcgLTQwLjVsLTk2MCAtMTAyNHEtMTggLTIwIC00NyAtMjB0LTQ3IDIwCmwtOTYwIDEwMjRxLTE2IDE3IC0xNyA0MC41dDEzIDQxLjVsMzg0IDUxMnExOCAyNiA1MSAyNmgxMTUycTMzIDAgNTEgLTI2eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTA1IiB1bmljb2RlPSImI3hmMjFhOyIgaG9yaXotYWR2LXg9IjIwNDgiIApkPSJNMTgxMSAtMTlxMTkgMTkgNDUgMTl0NDUgLTE5bDEyOCAtMTI4bC05MCAtOTBsLTgzIDgzbC04MyAtODNxLTE4IC0xOSAtNDUgLTE5dC00NSAxOWwtODMgODNsLTgzIC04M3EtMTkgLTE5IC00NSAtMTl0LTQ1IDE5bC04MyA4M2wtODMgLTgzcS0xOSAtMTkgLTQ1IC0xOXQtNDUgMTlsLTgzIDgzbC04MyAtODNxLTE5IC0xOSAtNDUgLTE5dC00NSAxOWwtODMgODNsLTgzIC04M3EtMTkgLTE5IC00NSAtMTl0LTQ1IDE5bC04MyA4M2wtODMgLTgzCnEtMTkgLTE5IC00NSAtMTl0LTQ1IDE5bC04MyA4M2wtODMgLTgzcS0xOSAtMTkgLTQ1IC0xOXQtNDUgMTlsLTEyOCAxMjhsOTAgOTBsODMgLTgzbDgzIDgzcTE5IDE5IDQ1IDE5dDQ1IC0xOWw4MyAtODNsODMgODNxMTkgMTkgNDUgMTl0NDUgLTE5bDgzIC04M2w4MyA4M3ExOSAxOSA0NSAxOXQ0NSAtMTlsODMgLTgzbDgzIDgzcTE5IDE5IDQ1IDE5dDQ1IC0xOWw4MyAtODNsODMgODNxMTkgMTkgNDUgMTl0NDUgLTE5bDgzIC04M2w4MyA4MwpxMTkgMTkgNDUgMTl0NDUgLTE5bDgzIC04M3pNMjM3IDE5cS0xOSAtMTkgLTQ1IC0xOXQtNDUgMTlsLTEyOCAxMjhsOTAgOTBsODMgLTgybDgzIDgycTE5IDE5IDQ1IDE5dDQ1IC0xOWw4MyAtODJsNjQgNjR2MjkzbC0yMTAgMzE0cS0xNyAyNiAtNyA1Ni41dDQwIDQwLjVsMTc3IDU4djI5OWgxMjh2MTI4aDI1NnYxMjhoMjU2di0xMjhoMjU2di0xMjhoMTI4di0yOTlsMTc3IC01OHEzMCAtMTAgNDAgLTQwLjV0LTcgLTU2LjVsLTIxMCAtMzE0CnYtMjkzbDE5IDE4cTE5IDE5IDQ1IDE5dDQ1IC0xOWw4MyAtODJsODMgODJxMTkgMTkgNDUgMTl0NDUgLTE5bDEyOCAtMTI4bC05MCAtOTBsLTgzIDgzbC04MyAtODNxLTE4IC0xOSAtNDUgLTE5dC00NSAxOWwtODMgODNsLTgzIC04M3EtMTkgLTE5IC00NSAtMTl0LTQ1IDE5bC04MyA4M2wtODMgLTgzcS0xOSAtMTkgLTQ1IC0xOXQtNDUgMTlsLTgzIDgzbC04MyAtODNxLTE5IC0xOSAtNDUgLTE5dC00NSAxOWwtODMgODNsLTgzIC04MwpxLTE5IC0xOSAtNDUgLTE5dC00NSAxOWwtODMgODNsLTgzIC04M3EtMTkgLTE5IC00NSAtMTl0LTQ1IDE5bC04MyA4M3pNNjQwIDExNTJ2LTEyOGwzODQgMTI4bDM4NCAtMTI4djEyOGgtMTI4djEyOGgtNTEydi0xMjhoLTEyOHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzUwNiIgdW5pY29kZT0iJiN4ZjIxYjsiIApkPSJNNTc2IDBsOTYgNDQ4bC05NiAxMjhsLTEyOCA2NHpNODMyIDBsMTI4IDY0MGwtMTI4IC02NGwtOTYgLTEyOHpNOTkyIDEwMTBxLTIgNCAtNCA2cS0xMCA4IC05NiA4cS03MCAwIC0xNjcgLTE5cS03IC0yIC0yMSAtMnQtMjEgMnEtOTcgMTkgLTE2NyAxOXEtODYgMCAtOTYgLThxLTIgLTIgLTQgLTZxMiAtMTggNCAtMjdxMiAtMyA3LjUgLTYuNXQ3LjUgLTEwLjVxMiAtNCA3LjUgLTIwLjV0NyAtMjAuNXQ3LjUgLTE3dDguNSAtMTd0OSAtMTQKdDEyIC0xMy41dDE0IC05LjV0MTcuNSAtOHQyMC41IC00dDI0LjUgLTJxMzYgMCA1OSAxMi41dDMyLjUgMzB0MTQuNSAzNC41dDExLjUgMjkuNXQxNy41IDEyLjVoMTJxMTEgMCAxNy41IC0xMi41dDExLjUgLTI5LjV0MTQuNSAtMzQuNXQzMi41IC0zMHQ1OSAtMTIuNXExMyAwIDI0LjUgMnQyMC41IDR0MTcuNSA4dDE0IDkuNXQxMiAxMy41dDkgMTR0OC41IDE3dDcuNSAxN3Q3IDIwLjV0Ny41IDIwLjVxMiA3IDcuNSAxMC41dDcuNSA2LjUKcTIgOSA0IDI3ek0xNDA4IDEzMXEwIC0xMjEgLTczIC0xOTB0LTE5NCAtNjloLTg3NHEtMTIxIDAgLTE5NCA2OXQtNzMgMTkwcTAgNjEgNC41IDExOHQxOSAxMjUuNXQzNy41IDEyMy41dDYzLjUgMTAzLjV0OTMuNSA3NC41bC05MCAyMjBoMjE0cS0yMiA2NCAtMjIgMTI4cTAgMTIgMiAzMnEtMTk0IDQwIC0xOTQgOTZxMCA1NyAyMTAgOTlxMTcgNjIgNTEuNSAxMzR0NzAuNSAxMTRxMzIgMzcgNzYgMzdxMzAgMCA4NCAtMzF0ODQgLTMxdDg0IDMxCnQ4NCAzMXE0NCAwIDc2IC0zN3EzNiAtNDIgNzAuNSAtMTE0dDUxLjUgLTEzNHEyMTAgLTQyIDIxMCAtOTlxMCAtNTYgLTE5NCAtOTZxNyAtODEgLTIwIC0xNjBoMjE0bC04MiAtMjI1cTYzIC0zMyAxMDcuNSAtOTYuNXQ2NS41IC0xNDMuNXQyOSAtMTUxLjV0OCAtMTQ4LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81MDciIHVuaWNvZGU9IiYjeGYyMWM7IiBob3Jpei1hZHYteD0iMjMwNCIgCmQ9Ik0yMzAxIDUwMHExMiAtMTAzIC0yMiAtMTk4LjV0LTk5IC0xNjMuNXQtMTU4LjUgLTEwNnQtMTk2LjUgLTMxcS0xNjEgMTEgLTI3OS41IDEyNXQtMTM0LjUgMjc0cS0xMiAxMTEgMjcuNSAyMTAuNXQxMTguNSAxNzAuNWwtNzEgMTA3cS05NiAtODAgLTE1MSAtMTk0dC01NSAtMjQ0cTAgLTI3IC0xOC41IC00Ni41dC00NS41IC0xOS41aC0yNTZoLTY5cS0yMyAtMTY0IC0xNDkgLTI3NHQtMjk0IC0xMTBxLTE4NSAwIC0zMTYuNSAxMzEuNQp0LTEzMS41IDMxNi41dDEzMS41IDMxNi41dDMxNi41IDEzMS41cTc2IDAgMTUyIC0yN2wyNCA0NXEtMTIzIDExMCAtMzA0IDExMGgtNjRxLTI2IDAgLTQ1IDE5dC0xOSA0NXQxOSA0NXQ0NSAxOWgxMjhxNzggMCAxNDUgLTEzLjV0MTE2LjUgLTM4LjV0NzEuNSAtMzkuNXQ1MSAtMzYuNWg1MTJoMTE1bC04NSAxMjhoLTIyMnEtMzAgMCAtNDkgMjIuNXQtMTQgNTIuNXE0IDIzIDIzIDM4dDQzIDE1aDI1M3EzMyAwIDUzIC0yOGw3MCAtMTA1CmwxMTQgMTE0cTE5IDE5IDQ2IDE5aDEwMXEyNiAwIDQ1IC0xOXQxOSAtNDV2LTEyOHEwIC0yNiAtMTkgLTQ1dC00NSAtMTloLTE3OWwxMTUgLTE3MnExMzEgNjMgMjc1IDM2cTE0MyAtMjYgMjQ0IC0xMzQuNXQxMTggLTI1My41ek00NDggMTI4cTExNSAwIDIwMyA3Mi41dDExMSAxODMuNWgtMzE0cS0zNSAwIC01NSAzMXEtMTggMzIgLTEgNjNsMTQ3IDI3N3EtNDcgMTMgLTkxIDEzcS0xMzIgMCAtMjI2IC05NHQtOTQgLTIyNnQ5NCAtMjI2CnQyMjYgLTk0ek0xODU2IDEyOHExMzIgMCAyMjYgOTR0OTQgMjI2dC05NCAyMjZ0LTIyNiA5NHEtNjAgMCAtMTIxIC0yNGwxNzQgLTI2MHExNSAtMjMgMTAgLTQ5dC0yNyAtNDBxLTE1IC0xMSAtMzYgLTExcS0zNSAwIC01MyAyOWwtMTc0IDI2MHEtOTMgLTk1IC05MyAtMjI1cTAgLTEzMiA5NCAtMjI2dDIyNiAtOTR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81MDgiIHVuaWNvZGU9IiYjeGYyMWQ7IiAKZD0iTTE0MDggMHEwIC02MyAtNjEuNSAtMTEzLjV0LTE2NCAtODF0LTIyNSAtNDZ0LTI1My41IC0xNS41dC0yNTMuNSAxNS41dC0yMjUgNDZ0LTE2NCA4MXQtNjEuNSAxMTMuNXEwIDQ5IDMzIDg4LjV0OTEgNjYuNXQxMTggNDQuNXQxMzEgMjkuNXEyNiA1IDQ4IC0xMC41dDI2IC00MS41cTUgLTI2IC0xMC41IC00OHQtNDEuNSAtMjZxLTU4IC0xMCAtMTA2IC0yMy41dC03Ni41IC0yNS41dC00OC41IC0yMy41dC0yNy41IC0xOS41dC04LjUgLTEyCnEzIC0xMSAyNyAtMjYuNXQ3MyAtMzN0MTE0IC0zMi41dDE2MC41IC0yNXQyMDEuNSAtMTB0MjAxLjUgMTB0MTYwLjUgMjV0MTE0IDMzdDczIDMzLjV0MjcgMjcuNXEtMSA0IC04LjUgMTF0LTI3LjUgMTl0LTQ4LjUgMjMuNXQtNzYuNSAyNXQtMTA2IDIzLjVxLTI2IDQgLTQxLjUgMjZ0LTEwLjUgNDhxNCAyNiAyNiA0MS41dDQ4IDEwLjVxNzEgLTEyIDEzMSAtMjkuNXQxMTggLTQ0LjV0OTEgLTY2LjV0MzMgLTg4LjV6TTEwMjQgODk2di0zODQKcTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtNjR2LTM4NHEwIC0yNiAtMTkgLTQ1dC00NSAtMTloLTI1NnEtMjYgMCAtNDUgMTl0LTE5IDQ1djM4NGgtNjRxLTI2IDAgLTQ1IDE5dC0xOSA0NXYzODRxMCA1MyAzNy41IDkwLjV0OTAuNSAzNy41aDM4NHE1MyAwIDkwLjUgLTM3LjV0MzcuNSAtOTAuNXpNOTI4IDEyODBxMCAtOTMgLTY1LjUgLTE1OC41dC0xNTguNSAtNjUuNXQtMTU4LjUgNjUuNXQtNjUuNSAxNTguNXQ2NS41IDE1OC41dDE1OC41IDY1LjUKdDE1OC41IC02NS41dDY1LjUgLTE1OC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTA5IiB1bmljb2RlPSImI3hmMjFlOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTI4MCA1MTJoMzA1cS01IC02IC0xMCAtMTAuNXQtOSAtNy41bC0zIC00bC02MjMgLTYwMHEtMTggLTE4IC00NCAtMTh0LTQ0IDE4bC02MjQgNjAycS01IDIgLTIxIDIwaDM2OXEyMiAwIDM5LjUgMTMuNXQyMi41IDM0LjVsNzAgMjgxbDE5MCAtNjY3cTYgLTIwIDIzIC0zM3QzOSAtMTNxMjEgMCAzOCAxM3QyMyAzM2wxNDYgNDg1bDU2IC0xMTJxMTggLTM1IDU3IC0zNXpNMTc5MiA5NDBxMCAtMTQ1IC0xMDMgLTMwMGgtMzY5bC0xMTEgMjIxCnEtOCAxNyAtMjUuNSAyN3QtMzYuNSA4cS00NSAtNSAtNTYgLTQ2bC0xMjkgLTQzMGwtMTk2IDY4NnEtNiAyMCAtMjMuNSAzM3QtMzkuNSAxM3QtMzkgLTEzLjV0LTIyIC0zNC41bC0xMTYgLTQ2NGgtNDIzcS0xMDMgMTU1IC0xMDMgMzAwcTAgMjIwIDEyNyAzNDR0MzUxIDEyNHE2MiAwIDEyNi41IC0yMS41dDEyMCAtNTh0OTUuNSAtNjguNXQ3NiAtNjhxMzYgMzYgNzYgNjh0OTUuNSA2OC41dDEyMCA1OHQxMjYuNSAyMS41cTIyNCAwIDM1MSAtMTI0CnQxMjcgLTM0NHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idmVudXMiIHVuaWNvZGU9IiYjeGYyMjE7IiBob3Jpei1hZHYteD0iMTI4MCIgCmQ9Ik0xMTUyIDk2MHEwIC0yMjEgLTE0Ny41IC0zODQuNXQtMzY0LjUgLTE4Ny41di0yNjBoMjI0cTE0IDAgMjMgLTl0OSAtMjN2LTY0cTAgLTE0IC05IC0yM3QtMjMgLTloLTIyNHYtMjI0cTAgLTE0IC05IC0yM3QtMjMgLTloLTY0cS0xNCAwIC0yMyA5dC05IDIzdjIyNGgtMjI0cS0xNCAwIC0yMyA5dC05IDIzdjY0cTAgMTQgOSAyM3QyMyA5aDIyNHYyNjBxLTE1MCAxNiAtMjcxLjUgMTAzdC0xODYgMjI0dC01Mi41IDI5MgpxMTEgMTM0IDgwLjUgMjQ5dDE4MiAxODh0MjQ1LjUgODhxMTcwIDE5IDMxOSAtNTR0MjM2IC0yMTJ0ODcgLTMwNnpNMTI4IDk2MHEwIC0xODUgMTMxLjUgLTMxNi41dDMxNi41IC0xMzEuNXQzMTYuNSAxMzEuNXQxMzEuNSAzMTYuNXQtMTMxLjUgMzE2LjV0LTMxNi41IDEzMS41dC0zMTYuNSAtMTMxLjV0LTEzMS41IC0zMTYuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzUxMSIgdW5pY29kZT0iJiN4ZjIyMjsiIApkPSJNMTQ3MiAxNDA4cTI2IDAgNDUgLTE5dDE5IC00NXYtNDE2cTAgLTE0IC05IC0yM3QtMjMgLTloLTY0cS0xNCAwIC0yMyA5dC05IDIzdjI2MmwtMzgyIC0zODNxMTI2IC0xNTYgMTI2IC0zNTlxMCAtMTE3IC00NS41IC0yMjMuNXQtMTIzIC0xODR0LTE4NCAtMTIzdC0yMjMuNSAtNDUuNXQtMjIzLjUgNDUuNXQtMTg0IDEyM3QtMTIzIDE4NHQtNDUuNSAyMjMuNXQ0NS41IDIyMy41dDEyMyAxODR0MTg0IDEyM3QyMjMuNSA0NS41CnEyMDMgMCAzNTkgLTEyNmwzODIgMzgyaC0yNjFxLTE0IDAgLTIzIDl0LTkgMjN2NjRxMCAxNCA5IDIzdDIzIDloNDE2ek01NzYgMHExODUgMCAzMTYuNSAxMzEuNXQxMzEuNSAzMTYuNXQtMTMxLjUgMzE2LjV0LTMxNi41IDEzMS41dC0zMTYuNSAtMTMxLjV0LTEzMS41IC0zMTYuNXQxMzEuNSAtMzE2LjV0MzE2LjUgLTEzMS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTEyIiB1bmljb2RlPSImI3hmMjIzOyIgaG9yaXotYWR2LXg9IjEyODAiIApkPSJNODMwIDEyMjBxMTQ1IC03MiAyMzMuNSAtMjEwLjV0ODguNSAtMzA1LjVxMCAtMjIxIC0xNDcuNSAtMzg0LjV0LTM2NC41IC0xODcuNXYtMTMyaDk2cTE0IDAgMjMgLTl0OSAtMjN2LTY0cTAgLTE0IC05IC0yM3QtMjMgLTloLTk2di05NnEwIC0xNCAtOSAtMjN0LTIzIC05aC02NHEtMTQgMCAtMjMgOXQtOSAyM3Y5NmgtOTZxLTE0IDAgLTIzIDl0LTkgMjN2NjRxMCAxNCA5IDIzdDIzIDloOTZ2MTMycS0yMTcgMjQgLTM2NC41IDE4Ny41CnQtMTQ3LjUgMzg0LjVxMCAxNjcgODguNSAzMDUuNXQyMzMuNSAyMTAuNXEtMTY1IDk2IC0yMjggMjczcS02IDE2IDMuNSAyOS41dDI2LjUgMTMuNWg2OXEyMSAwIDI5IC0yMHE0NCAtMTA2IDE0MCAtMTcxdDIxNCAtNjV0MjE0IDY1dDE0MCAxNzFxOCAyMCAzNyAyMGg2MXExNyAwIDI2LjUgLTEzLjV0My41IC0yOS41cS02MyAtMTc3IC0yMjggLTI3M3pNNTc2IDI1NnExODUgMCAzMTYuNSAxMzEuNXQxMzEuNSAzMTYuNXQtMTMxLjUgMzE2LjUKdC0zMTYuNSAxMzEuNXQtMzE2LjUgLTEzMS41dC0xMzEuNSAtMzE2LjV0MTMxLjUgLTMxNi41dDMxNi41IC0xMzEuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzUxMyIgdW5pY29kZT0iJiN4ZjIyNDsiIApkPSJNMTAyNCAxNTA0cTAgMTQgOSAyM3QyMyA5aDI4OHEyNiAwIDQ1IC0xOXQxOSAtNDV2LTI4OHEwIC0xNCAtOSAtMjN0LTIzIC05aC02NHEtMTQgMCAtMjMgOXQtOSAyM3YxMzRsLTI1NCAtMjU1cTEyNiAtMTU4IDEyNiAtMzU5cTAgLTIyMSAtMTQ3LjUgLTM4NC41dC0zNjQuNSAtMTg3LjV2LTEzMmg5NnExNCAwIDIzIC05dDkgLTIzdi02NHEwIC0xNCAtOSAtMjN0LTIzIC05aC05NnYtOTZxMCAtMTQgLTkgLTIzdC0yMyAtOWgtNjQKcS0xNCAwIC0yMyA5dC05IDIzdjk2aC05NnEtMTQgMCAtMjMgOXQtOSAyM3Y2NHEwIDE0IDkgMjN0MjMgOWg5NnYxMzJxLTE0OSAxNiAtMjcwLjUgMTAzdC0xODYuNSAyMjMuNXQtNTMgMjkxLjVxMTYgMjA0IDE2MCAzNTMuNXQzNDcgMTcyLjVxMTE4IDE0IDIyOCAtMTl0MTk4IC0xMDNsMjU1IDI1NGgtMTM0cS0xNCAwIC0yMyA5dC05IDIzdjY0ek01NzYgMjU2cTE4NSAwIDMxNi41IDEzMS41dDEzMS41IDMxNi41dC0xMzEuNSAzMTYuNQp0LTMxNi41IDEzMS41dC0zMTYuNSAtMTMxLjV0LTEzMS41IC0zMTYuNXQxMzEuNSAtMzE2LjV0MzE2LjUgLTEzMS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTE0IiB1bmljb2RlPSImI3hmMjI1OyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTI4MCAxNTA0cTAgMTQgOSAyM3QyMyA5aDI4OHEyNiAwIDQ1IC0xOXQxOSAtNDV2LTI4OHEwIC0xNCAtOSAtMjN0LTIzIC05aC02NHEtMTQgMCAtMjMgOXQtOSAyM3YxMzRsLTI1NCAtMjU1cTEyNiAtMTU4IDEyNiAtMzU5cTAgLTIyMSAtMTQ3LjUgLTM4NC41dC0zNjQuNSAtMTg3LjV2LTEzMmg5NnExNCAwIDIzIC05dDkgLTIzdi02NHEwIC0xNCAtOSAtMjN0LTIzIC05aC05NnYtOTZxMCAtMTQgLTkgLTIzdC0yMyAtOWgtNjQKcS0xNCAwIC0yMyA5dC05IDIzdjk2aC05NnEtMTQgMCAtMjMgOXQtOSAyM3Y2NHEwIDE0IDkgMjN0MjMgOWg5NnYxMzJxLTIxNyAyNCAtMzY0LjUgMTg3LjV0LTE0Ny41IDM4NC41cTAgMjAxIDEyNiAzNTlsLTUyIDUzbC0xMDEgLTExMXEtOSAtMTAgLTIyIC0xMC41dC0yMyA3LjVsLTQ4IDQ0cS0xMCA4IC0xMC41IDIxLjV0OC41IDIzLjVsMTA1IDExNWwtMTExIDExMnYtMTM0cTAgLTE0IC05IC0yM3QtMjMgLTloLTY0cS0xNCAwIC0yMyA5CnQtOSAyM3YyODhxMCAyNiAxOSA0NXQ0NSAxOWgyODhxMTQgMCAyMyAtOXQ5IC0yM3YtNjRxMCAtMTQgLTkgLTIzdC0yMyAtOWgtMTMzbDEwNiAtMTA3bDg2IDk0cTkgMTAgMjIgMTAuNXQyMyAtNy41bDQ4IC00NHExMCAtOCAxMC41IC0yMS41dC04LjUgLTIzLjVsLTkwIC05OWw1NyAtNTZxMTU4IDEyNiAzNTkgMTI2dDM1OSAtMTI2bDI1NSAyNTRoLTEzNHEtMTQgMCAtMjMgOXQtOSAyM3Y2NHpNODMyIDI1NnExODUgMCAzMTYuNSAxMzEuNQp0MTMxLjUgMzE2LjV0LTEzMS41IDMxNi41dC0zMTYuNSAxMzEuNXQtMzE2LjUgLTEzMS41dC0xMzEuNSAtMzE2LjV0MTMxLjUgLTMxNi41dDMxNi41IC0xMzEuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzUxNSIgdW5pY29kZT0iJiN4ZjIyNjsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE3OTAgMTAwN3ExMiAtMTU1IC01Mi41IC0yOTJ0LTE4NiAtMjI0dC0yNzEuNSAtMTAzdi0yNjBoMjI0cTE0IDAgMjMgLTl0OSAtMjN2LTY0cTAgLTE0IC05IC0yM3QtMjMgLTloLTIyNHYtMjI0cTAgLTE0IC05IC0yM3QtMjMgLTloLTY0cS0xNCAwIC0yMyA5dC05IDIzdjIyNGgtNTEydi0yMjRxMCAtMTQgLTkgLTIzdC0yMyAtOWgtNjRxLTE0IDAgLTIzIDl0LTkgMjN2MjI0aC0yMjRxLTE0IDAgLTIzIDl0LTkgMjN2NjRxMCAxNCA5IDIzCnQyMyA5aDIyNHYyNjBxLTE1MCAxNiAtMjcxLjUgMTAzdC0xODYgMjI0dC01Mi41IDI5MnExNyAyMDYgMTY0LjUgMzU2LjV0MzUyLjUgMTY5LjVxMjA2IDIxIDM3NyAtOTRxMTcxIDExNSAzNzcgOTRxMjA1IC0xOSAzNTIuNSAtMTY5LjV0MTY0LjUgLTM1Ni41ek04OTYgNjQ3cTEyOCAxMzEgMTI4IDMxM3QtMTI4IDMxM3EtMTI4IC0xMzEgLTEyOCAtMzEzdDEyOCAtMzEzek01NzYgNTEycTExNSAwIDIxOCA1N3EtMTU0IDE2NSAtMTU0IDM5MQpxMCAyMjQgMTU0IDM5MXEtMTAzIDU3IC0yMTggNTdxLTE4NSAwIC0zMTYuNSAtMTMxLjV0LTEzMS41IC0zMTYuNXQxMzEuNSAtMzE2LjV0MzE2LjUgLTEzMS41ek0xMTUyIDEyOHYyNjBxLTEzNyAxNSAtMjU2IDk0cS0xMTkgLTc5IC0yNTYgLTk0di0yNjBoNTEyek0xMjE2IDUxMnExODUgMCAzMTYuNSAxMzEuNXQxMzEuNSAzMTYuNXQtMTMxLjUgMzE2LjV0LTMxNi41IDEzMS41cS0xMTUgMCAtMjE4IC01N3ExNTQgLTE2NyAxNTQgLTM5MQpxMCAtMjI2IC0xNTQgLTM5MXExMDMgLTU3IDIxOCAtNTd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81MTYiIHVuaWNvZGU9IiYjeGYyMjc7IiBob3Jpei1hZHYteD0iMTkyMCIgCmQ9Ik0xNTM2IDExMjBxMCAxNCA5IDIzdDIzIDloMjg4cTI2IDAgNDUgLTE5dDE5IC00NXYtMjg4cTAgLTE0IC05IC0yM3QtMjMgLTloLTY0cS0xNCAwIC0yMyA5dC05IDIzdjEzNGwtMjU0IC0yNTVxNzYgLTk1IDEwNy41IC0yMTR0OS41IC0yNDdxLTMxIC0xODIgLTE2NiAtMzEydC0zMTggLTE1NnEtMjEwIC0yOSAtMzg0LjUgODB0LTI0MS41IDMwMHEtMTE3IDYgLTIyMSA1Ny41dC0xNzcuNSAxMzN0LTExMy41IDE5Mi41dC0zMiAyMzAKcTkgMTM1IDc4IDI1MnQxODIgMTkxLjV0MjQ4IDg5LjVxMTE4IDE0IDIyNy41IC0xOXQxOTguNSAtMTAzbDI1NSAyNTRoLTEzNHEtMTQgMCAtMjMgOXQtOSAyM3Y2NHEwIDE0IDkgMjN0MjMgOWgyODhxMjYgMCA0NSAtMTl0MTkgLTQ1di0yODhxMCAtMTQgLTkgLTIzdC0yMyAtOWgtNjRxLTE0IDAgLTIzIDl0LTkgMjN2MTM0bC0yNTQgLTI1NXE1OSAtNzQgOTMgLTE2OXExODIgLTkgMzI4IC0xMjRsMjU1IDI1NGgtMTM0cS0xNCAwIC0yMyA5CnQtOSAyM3Y2NHpNMTAyNCA3MDRxMCAyMCAtNCA1OHEtMTYyIC0yNSAtMjcxIC0xNTB0LTEwOSAtMjkycTAgLTIwIDQgLTU4cTE2MiAyNSAyNzEgMTUwdDEwOSAyOTJ6TTEyOCA3MDRxMCAtMTY4IDExMSAtMjk0dDI3NiAtMTQ5cS0zIDI5IC0zIDU5cTAgMjEwIDEzNSAzNjkuNXQzMzggMTk2LjVxLTUzIDEyMCAtMTYzLjUgMTkzdC0yNDUuNSA3M3EtMTg1IDAgLTMxNi41IC0xMzEuNXQtMTMxLjUgLTMxNi41ek0xMDg4IC0xMjgKcTE4NSAwIDMxNi41IDEzMS41dDEzMS41IDMxNi41cTAgMTY4IC0xMTEgMjk0dC0yNzYgMTQ5cTMgLTI4IDMgLTU5cTAgLTIxMCAtMTM1IC0zNjkuNXQtMzM4IC0xOTYuNXE1MyAtMTIwIDE2My41IC0xOTN0MjQ1LjUgLTczeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTE3IiB1bmljb2RlPSImI3hmMjI4OyIgaG9yaXotYWR2LXg9IjIwNDgiIApkPSJNMTY2NCAxNTA0cTAgMTQgOSAyM3QyMyA5aDI4OHEyNiAwIDQ1IC0xOXQxOSAtNDV2LTI4OHEwIC0xNCAtOSAtMjN0LTIzIC05aC02NHEtMTQgMCAtMjMgOXQtOSAyM3YxMzRsLTI1NCAtMjU1cTc2IC05NSAxMDcuNSAtMjE0dDkuNSAtMjQ3cS0zMiAtMTgwIC0xNjQuNSAtMzEwdC0zMTMuNSAtMTU3cS0yMjMgLTM0IC00MDkgOTBxLTExNyAtNzggLTI1NiAtOTN2LTEzMmg5NnExNCAwIDIzIC05dDkgLTIzdi02NHEwIC0xNCAtOSAtMjMKdC0yMyAtOWgtOTZ2LTk2cTAgLTE0IC05IC0yM3QtMjMgLTloLTY0cS0xNCAwIC0yMyA5dC05IDIzdjk2aC05NnEtMTQgMCAtMjMgOXQtOSAyM3Y2NHEwIDE0IDkgMjN0MjMgOWg5NnYxMzJxLTE1NSAxNyAtMjc5LjUgMTA5LjV0LTE4NyAyMzcuNXQtMzkuNSAzMDdxMjUgMTg3IDE1OS41IDMyMi41dDMyMC41IDE2NC41cTIyNCAzNCA0MTAgLTkwcTE0NiA5NyAzMjAgOTdxMjAxIDAgMzU5IC0xMjZsMjU1IDI1NGgtMTM0cS0xNCAwIC0yMyA5CnQtOSAyM3Y2NHpNODk2IDM5MXExMjggMTMxIDEyOCAzMTN0LTEyOCAzMTNxLTEyOCAtMTMxIC0xMjggLTMxM3QxMjggLTMxM3pNMTI4IDcwNHEwIC0xODUgMTMxLjUgLTMxNi41dDMxNi41IC0xMzEuNXExMTcgMCAyMTggNTdxLTE1NCAxNjcgLTE1NCAzOTF0MTU0IDM5MXEtMTAxIDU3IC0yMTggNTdxLTE4NSAwIC0zMTYuNSAtMTMxLjV0LTEzMS41IC0zMTYuNXpNMTIxNiAyNTZxMTg1IDAgMzE2LjUgMTMxLjV0MTMxLjUgMzE2LjUKdC0xMzEuNSAzMTYuNXQtMzE2LjUgMTMxLjVxLTExNyAwIC0yMTggLTU3cTE1NCAtMTY3IDE1NCAtMzkxdC0xNTQgLTM5MXExMDEgLTU3IDIxOCAtNTd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81MTgiIHVuaWNvZGU9IiYjeGYyMjk7IiAKZD0iTTE0NzIgMTQwOHEyNiAwIDQ1IC0xOXQxOSAtNDV2LTQxNnEwIC0xNCAtOSAtMjN0LTIzIC05aC02NHEtMTQgMCAtMjMgOXQtOSAyM3YyNjJsLTIxMyAtMjE0bDE0MCAtMTQwcTkgLTEwIDkgLTIzdC05IC0yMmwtNDYgLTQ2cS05IC05IC0yMiAtOXQtMjMgOWwtMTQwIDE0MWwtNzggLTc5cTEyNiAtMTU2IDEyNiAtMzU5cTAgLTExNyAtNDUuNSAtMjIzLjV0LTEyMyAtMTg0dC0xODQgLTEyM3QtMjIzLjUgLTQ1LjV0LTIyMy41IDQ1LjUKdC0xODQgMTIzdC0xMjMgMTg0dC00NS41IDIyMy41dDQ1LjUgMjIzLjV0MTIzIDE4NHQxODQgMTIzdDIyMy41IDQ1LjVxMjAzIDAgMzU5IC0xMjZsNzggNzhsLTE3MiAxNzJxLTkgMTAgLTkgMjN0OSAyMmw0NiA0NnE5IDkgMjIgOXQyMyAtOWwxNzIgLTE3MmwyMTMgMjEzaC0yNjFxLTE0IDAgLTIzIDl0LTkgMjN2NjRxMCAxNCA5IDIzdDIzIDloNDE2ek01NzYgMHExODUgMCAzMTYuNSAxMzEuNXQxMzEuNSAzMTYuNXQtMTMxLjUgMzE2LjUKdC0zMTYuNSAxMzEuNXQtMzE2LjUgLTEzMS41dC0xMzEuNSAtMzE2LjV0MTMxLjUgLTMxNi41dDMxNi41IC0xMzEuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzUxOSIgdW5pY29kZT0iJiN4ZjIyYTsiIGhvcml6LWFkdi14PSIxMjgwIiAKZD0iTTY0MCA4OTJxMjE3IC0yNCAzNjQuNSAtMTg3LjV0MTQ3LjUgLTM4NC41cTAgLTE2NyAtODcgLTMwNnQtMjM2IC0yMTJ0LTMxOSAtNTRxLTEzMyAxNSAtMjQ1LjUgODh0LTE4MiAxODh0LTgwLjUgMjQ5cS0xMiAxNTUgNTIuNSAyOTJ0MTg2IDIyNHQyNzEuNSAxMDN2MTMyaC0xNjBxLTE0IDAgLTIzIDl0LTkgMjN2NjRxMCAxNCA5IDIzdDIzIDloMTYwdjE2NWwtOTIgLTkycS0xMCAtOSAtMjMgLTl0LTIyIDlsLTQ2IDQ2cS05IDkgLTkgMjIKdDkgMjNsMjAyIDIwMXExOSAxOSA0NSAxOXQ0NSAtMTlsMjAyIC0yMDFxOSAtMTAgOSAtMjN0LTkgLTIybC00NiAtNDZxLTkgLTkgLTIyIC05dC0yMyA5bC05MiA5MnYtMTY1aDE2MHExNCAwIDIzIC05dDkgLTIzdi02NHEwIC0xNCAtOSAtMjN0LTIzIC05aC0xNjB2LTEzMnpNNTc2IC0xMjhxMTg1IDAgMzE2LjUgMTMxLjV0MTMxLjUgMzE2LjV0LTEzMS41IDMxNi41dC0zMTYuNSAxMzEuNXQtMzE2LjUgLTEzMS41dC0xMzEuNSAtMzE2LjUKdDEzMS41IC0zMTYuNXQzMTYuNSAtMTMxLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81MjAiIHVuaWNvZGU9IiYjeGYyMmI7IiBob3Jpei1hZHYteD0iMjA0OCIgCmQ9Ik0xOTAxIDYyMXExOSAtMTkgMTkgLTQ1dC0xOSAtNDVsLTI5NCAtMjk0cS05IC0xMCAtMjIuNSAtMTB0LTIyLjUgMTBsLTQ1IDQ1cS0xMCA5IC0xMCAyMi41dDEwIDIyLjVsMTg1IDE4NWgtMjk0di0yMjRxMCAtMTQgLTkgLTIzdC0yMyAtOWgtNjRxLTE0IDAgLTIzIDl0LTkgMjN2MjI0aC0xMzJxLTI0IC0yMTcgLTE4Ny41IC0zNjQuNXQtMzg0LjUgLTE0Ny41cS0xNjcgMCAtMzA2IDg3dC0yMTIgMjM2dC01NCAzMTlxMTUgMTMzIDg4IDI0NS41CnQxODggMTgydDI0OSA4MC41cTE1NSAxMiAyOTIgLTUyLjV0MjI0IC0xODZ0MTAzIC0yNzEuNWgxMzJ2MjI0cTAgMTQgOSAyM3QyMyA5aDY0cTE0IDAgMjMgLTl0OSAtMjN2LTIyNGgyOTRsLTE4NSAxODVxLTEwIDkgLTEwIDIyLjV0MTAgMjIuNWw0NSA0NXE5IDEwIDIyLjUgMTB0MjIuNSAtMTB6TTU3NiAxMjhxMTg1IDAgMzE2LjUgMTMxLjV0MTMxLjUgMzE2LjV0LTEzMS41IDMxNi41dC0zMTYuNSAxMzEuNXQtMzE2LjUgLTEzMS41CnQtMTMxLjUgLTMxNi41dDEzMS41IC0zMTYuNXQzMTYuNSAtMTMxLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81MjEiIHVuaWNvZGU9IiYjeGYyMmM7IiBob3Jpei1hZHYteD0iMTI4MCIgCmQ9Ik0xMTUyIDk2MHEwIC0yMjEgLTE0Ny41IC0zODQuNXQtMzY0LjUgLTE4Ny41di02MTJxMCAtMTQgLTkgLTIzdC0yMyAtOWgtNjRxLTE0IDAgLTIzIDl0LTkgMjN2NjEycS0yMTcgMjQgLTM2NC41IDE4Ny41dC0xNDcuNSAzODQuNXEwIDExNyA0NS41IDIyMy41dDEyMyAxODR0MTg0IDEyM3QyMjMuNSA0NS41dDIyMy41IC00NS41dDE4NCAtMTIzdDEyMyAtMTg0dDQ1LjUgLTIyMy41ek01NzYgNTEycTE4NSAwIDMxNi41IDEzMS41CnQxMzEuNSAzMTYuNXQtMTMxLjUgMzE2LjV0LTMxNi41IDEzMS41dC0zMTYuNSAtMTMxLjV0LTEzMS41IC0zMTYuNXQxMzEuNSAtMzE2LjV0MzE2LjUgLTEzMS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTIyIiB1bmljb2RlPSImI3hmMjJkOyIgaG9yaXotYWR2LXg9IjEyODAiIApkPSJNMTAyNCA1NzZxMCAxODUgLTEzMS41IDMxNi41dC0zMTYuNSAxMzEuNXQtMzE2LjUgLTEzMS41dC0xMzEuNSAtMzE2LjV0MTMxLjUgLTMxNi41dDMxNi41IC0xMzEuNXQzMTYuNSAxMzEuNXQxMzEuNSAzMTYuNXpNMTE1MiA1NzZxMCAtMTE3IC00NS41IC0yMjMuNXQtMTIzIC0xODR0LTE4NCAtMTIzdC0yMjMuNSAtNDUuNXQtMjIzLjUgNDUuNXQtMTg0IDEyM3QtMTIzIDE4NHQtNDUuNSAyMjMuNXQ0NS41IDIyMy41dDEyMyAxODR0MTg0IDEyMwp0MjIzLjUgNDUuNXQyMjMuNSAtNDUuNXQxODQgLTEyM3QxMjMgLTE4NHQ0NS41IC0yMjMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzUyMyIgdW5pY29kZT0iJiN4ZjIyZTsiIGhvcml6LWFkdi14PSIxNzkyIiAKIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzUyNCIgdW5pY29kZT0iJiN4ZjIyZjsiIGhvcml6LWFkdi14PSIxNzkyIiAKIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzUyNSIgdW5pY29kZT0iJiN4ZjIzMDsiIApkPSJNMTQ1MSAxNDA4cTM1IDAgNjAgLTI1dDI1IC02MHYtMTM2NnEwIC0zNSAtMjUgLTYwdC02MCAtMjVoLTM5MXY1OTVoMTk5bDMwIDIzMmgtMjI5djE0OHEwIDU2IDIzLjUgODR0OTEuNSAyOGwxMjIgMXYyMDdxLTYzIDkgLTE3OCA5cS0xMzYgMCAtMjE3LjUgLTgwdC04MS41IC0yMjZ2LTE3MWgtMjAwdi0yMzJoMjAwdi01OTVoLTczNXEtMzUgMCAtNjAgMjV0LTI1IDYwdjEzNjZxMCAzNSAyNSA2MHQ2MCAyNWgxMzY2eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTI2IiB1bmljb2RlPSImI3hmMjMxOyIgaG9yaXotYWR2LXg9IjEyODAiIApkPSJNMCA5MzlxMCAxMDggMzcuNSAyMDMuNXQxMDMuNSAxNjYuNXQxNTIgMTIzdDE4NSA3OHQyMDIgMjZxMTU4IDAgMjk0IC02Ni41dDIyMSAtMTkzLjV0ODUgLTI4N3EwIC05NiAtMTkgLTE4OHQtNjAgLTE3N3QtMTAwIC0xNDkuNXQtMTQ1IC0xMDN0LTE4OSAtMzguNXEtNjggMCAtMTM1IDMydC05NiA4OHEtMTAgLTM5IC0yOCAtMTEyLjV0LTIzLjUgLTk1dC0yMC41IC03MXQtMjYgLTcxdC0zMiAtNjIuNXQtNDYgLTc3LjV0LTYyIC04Ni41CmwtMTQgLTVsLTkgMTBxLTE1IDE1NyAtMTUgMTg4cTAgOTIgMjEuNSAyMDYuNXQ2Ni41IDI4Ny41dDUyIDIwM3EtMzIgNjUgLTMyIDE2OXEwIDgzIDUyIDE1NnQxMzIgNzNxNjEgMCA5NSAtNDAuNXQzNCAtMTAyLjVxMCAtNjYgLTQ0IC0xOTF0LTQ0IC0xODdxMCAtNjMgNDUgLTEwNC41dDEwOSAtNDEuNXE1NSAwIDEwMiAyNXQ3OC41IDY4dDU2IDk1dDM4IDExMC41dDIwIDExMXQ2LjUgOTkuNXEwIDE3MyAtMTA5LjUgMjY5LjV0LTI4NS41IDk2LjUKcS0yMDAgMCAtMzM0IC0xMjkuNXQtMTM0IC0zMjguNXEwIC00NCAxMi41IC04NXQyNyAtNjV0MjcgLTQ1LjV0MTIuNSAtMzAuNXEwIC0yOCAtMTUgLTczdC0zNyAtNDVxLTIgMCAtMTcgM3EtNTEgMTUgLTkwLjUgNTZ0LTYxIDk0LjV0LTMyLjUgMTA4dC0xMSAxMDYuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzUyNyIgdW5pY29kZT0iJiN4ZjIzMjsiIApkPSJNOTg1IDU2MnExMyAwIDk3LjUgLTQ0dDg5LjUgLTUzcTIgLTUgMiAtMTVxMCAtMzMgLTE3IC03NnEtMTYgLTM5IC03MSAtNjUuNXQtMTAyIC0yNi41cS01NyAwIC0xOTAgNjJxLTk4IDQ1IC0xNzAgMTE4dC0xNDggMTg1cS03MiAxMDcgLTcxIDE5NHY4cTMgOTEgNzQgMTU4cTI0IDIyIDUyIDIycTYgMCAxOCAtMS41dDE5IC0xLjVxMTkgMCAyNi41IC02LjV0MTUuNSAtMjcuNXE4IC0yMCAzMyAtODh0MjUgLTc1cTAgLTIxIC0zNC41IC01Ny41CnQtMzQuNSAtNDYuNXEwIC03IDUgLTE1cTM0IC03MyAxMDIgLTEzN3E1NiAtNTMgMTUxIC0xMDFxMTIgLTcgMjIgLTdxMTUgMCA1NCA0OC41dDUyIDQ4LjV6TTc4MiAzMnExMjcgMCAyNDMuNSA1MHQyMDAuNSAxMzR0MTM0IDIwMC41dDUwIDI0My41dC01MCAyNDMuNXQtMTM0IDIwMC41dC0yMDAuNSAxMzR0LTI0My41IDUwdC0yNDMuNSAtNTB0LTIwMC41IC0xMzR0LTEzNCAtMjAwLjV0LTUwIC0yNDMuNXEwIC0yMDMgMTIwIC0zNjhsLTc5IC0yMzMKbDI0MiA3N3ExNTggLTEwNCAzNDUgLTEwNHpNNzgyIDE0MTRxMTUzIDAgMjkyLjUgLTYwdDI0MC41IC0xNjF0MTYxIC0yNDAuNXQ2MCAtMjkyLjV0LTYwIC0yOTIuNXQtMTYxIC0yNDAuNXQtMjQwLjUgLTE2MXQtMjkyLjUgLTYwcS0xOTUgMCAtMzY1IDk0bC00MTcgLTEzNGwxMzYgNDA1cS0xMDggMTc4IC0xMDggMzg5cTAgMTUzIDYwIDI5Mi41dDE2MSAyNDAuNXQyNDAuNSAxNjF0MjkyLjUgNjB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81MjgiIHVuaWNvZGU9IiYjeGYyMzM7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xMjggMTI4aDEwMjR2MTI4aC0xMDI0di0xMjh6TTEyOCA2NDBoMTAyNHYxMjhoLTEwMjR2LTEyOHpNMTY5NiAxOTJxMCA0MCAtMjggNjh0LTY4IDI4dC02OCAtMjh0LTI4IC02OHQyOCAtNjh0NjggLTI4dDY4IDI4dDI4IDY4ek0xMjggMTE1MmgxMDI0djEyOGgtMTAyNHYtMTI4ek0xNjk2IDcwNHEwIDQwIC0yOCA2OHQtNjggMjh0LTY4IC0yOHQtMjggLTY4dDI4IC02OHQ2OCAtMjh0NjggMjh0MjggNjh6TTE2OTYgMTIxNgpxMCA0MCAtMjggNjh0LTY4IDI4dC02OCAtMjh0LTI4IC02OHQyOCAtNjh0NjggLTI4dDY4IDI4dDI4IDY4ek0xNzkyIDM4NHYtMzg0aC0xNzkydjM4NGgxNzkyek0xNzkyIDg5NnYtMzg0aC0xNzkydjM4NGgxNzkyek0xNzkyIDE0MDh2LTM4NGgtMTc5MnYzODRoMTc5MnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzUyOSIgdW5pY29kZT0iJiN4ZjIzNDsiIGhvcml6LWFkdi14PSIyMDQ4IiAKZD0iTTcwNCA2NDBxLTE1OSAwIC0yNzEuNSAxMTIuNXQtMTEyLjUgMjcxLjV0MTEyLjUgMjcxLjV0MjcxLjUgMTEyLjV0MjcxLjUgLTExMi41dDExMi41IC0yNzEuNXQtMTEyLjUgLTI3MS41dC0yNzEuNSAtMTEyLjV6TTE2NjQgNTEyaDM1MnExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV2LTE5MnEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVoLTM1MnYtMzUycTAgLTEzIC05LjUgLTIyLjV0LTIyLjUgLTkuNWgtMTkycS0xMyAwIC0yMi41IDkuNQp0LTkuNSAyMi41djM1MmgtMzUycS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2MTkycTAgMTMgOS41IDIyLjV0MjIuNSA5LjVoMzUydjM1MnEwIDEzIDkuNSAyMi41dDIyLjUgOS41aDE5MnExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV2LTM1MnpNOTI4IDI4OHEwIC01MiAzOCAtOTB0OTAgLTM4aDI1NnYtMjM4cS02OCAtNTAgLTE3MSAtNTBoLTg3NHEtMTIxIDAgLTE5NCA2OXQtNzMgMTkwcTAgNTMgMy41IDEwMy41dDE0IDEwOXQyNi41IDEwOC41CnQ0MyA5Ny41dDYyIDgxdDg1LjUgNTMuNXQxMTEuNSAyMHExOSAwIDM5IC0xN3E3OSAtNjEgMTU0LjUgLTkxLjV0MTY0LjUgLTMwLjV0MTY0LjUgMzAuNXQxNTQuNSA5MS41cTIwIDE3IDM5IDE3cTEzMiAwIDIxNyAtOTZoLTIyM3EtNTIgMCAtOTAgLTM4dC0zOCAtOTB2LTE5MnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzUzMCIgdW5pY29kZT0iJiN4ZjIzNTsiIGhvcml6LWFkdi14PSIyMDQ4IiAKZD0iTTcwNCA2NDBxLTE1OSAwIC0yNzEuNSAxMTIuNXQtMTEyLjUgMjcxLjV0MTEyLjUgMjcxLjV0MjcxLjUgMTEyLjV0MjcxLjUgLTExMi41dDExMi41IC0yNzEuNXQtMTEyLjUgLTI3MS41dC0yNzEuNSAtMTEyLjV6TTE3ODEgMzIwbDI0OSAtMjQ5cTkgLTkgOSAtMjNxMCAtMTMgLTkgLTIybC0xMzYgLTEzNnEtOSAtOSAtMjIgLTlxLTE0IDAgLTIzIDlsLTI0OSAyNDlsLTI0OSAtMjQ5cS05IC05IC0yMyAtOXEtMTMgMCAtMjIgOWwtMTM2IDEzNgpxLTkgOSAtOSAyMnEwIDE0IDkgMjNsMjQ5IDI0OWwtMjQ5IDI0OXEtOSA5IC05IDIzcTAgMTMgOSAyMmwxMzYgMTM2cTkgOSAyMiA5cTE0IDAgMjMgLTlsMjQ5IC0yNDlsMjQ5IDI0OXE5IDkgMjMgOXExMyAwIDIyIC05bDEzNiAtMTM2cTkgLTkgOSAtMjJxMCAtMTQgLTkgLTIzek0xMjgzIDMyMGwtMTgxIC0xODFxLTM3IC0zNyAtMzcgLTkxcTAgLTUzIDM3IC05MGw4MyAtODNxLTIxIC0zIC00NCAtM2gtODc0cS0xMjEgMCAtMTk0IDY5CnQtNzMgMTkwcTAgNTMgMy41IDEwMy41dDE0IDEwOXQyNi41IDEwOC41dDQzIDk3LjV0NjIgODF0ODUuNSA1My41dDExMS41IDIwcTE5IDAgMzkgLTE3cTE1NCAtMTIyIDMxOSAtMTIydDMxOSAxMjJxMjAgMTcgMzkgMTdxMjggMCA1NyAtNnEtMjggLTI3IC00MSAtNTB0LTEzIC01NnEwIC01NCAzNyAtOTF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81MzEiIHVuaWNvZGU9IiYjeGYyMzY7IiBob3Jpei1hZHYteD0iMjA0OCIgCmQ9Ik0yNTYgNTEyaDE3MjhxMjYgMCA0NSAtMTl0MTkgLTQ1di00NDhoLTI1NnYyNTZoLTE1MzZ2LTI1NmgtMjU2djEyMTZxMCAyNiAxOSA0NXQ0NSAxOWgxMjhxMjYgMCA0NSAtMTl0MTkgLTQ1di03MDR6TTgzMiA4MzJxMCAxMDYgLTc1IDE4MXQtMTgxIDc1dC0xODEgLTc1dC03NSAtMTgxdDc1IC0xODF0MTgxIC03NXQxODEgNzV0NzUgMTgxek0yMDQ4IDU3NnY2NHEwIDE1OSAtMTEyLjUgMjcxLjV0LTI3MS41IDExMi41aC03MDQKcS0yNiAwIC00NSAtMTl0LTE5IC00NXYtMzg0aDExNTJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81MzIiIHVuaWNvZGU9IiYjeGYyMzc7IiAKZD0iTTE1MzYgMTUzNmwtMTkyIC00NDhoMTkydi0xOTJoLTI3NGwtNTUgLTEyOGgzMjl2LTE5MmgtNDExbC0zNTcgLTgzMmwtMzU3IDgzMmgtNDExdjE5MmgzMjlsLTU1IDEyOGgtMjc0djE5MmgxOTJsLTE5MiA0NDhoMjU2bDMyMyAtNzY4aDM3OGwzMjMgNzY4aDI1NnpNNzY4IDMyMGwxMDggMjU2aC0yMTZ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81MzMiIHVuaWNvZGU9IiYjeGYyMzg7IiAKZD0iTTEwODggMTUzNnExODUgMCAzMTYuNSAtOTMuNXQxMzEuNSAtMjI2LjV2LTg5NnEwIC0xMzAgLTEyNS41IC0yMjJ0LTMwNS41IC05N2wyMTMgLTIwMnExNiAtMTUgOCAtMzV0LTMwIC0yMGgtMTA1NnEtMjIgMCAtMzAgMjB0OCAzNWwyMTMgMjAycS0xODAgNSAtMzA1LjUgOTd0LTEyNS41IDIyMnY4OTZxMCAxMzMgMTMxLjUgMjI2LjV0MzE2LjUgOTMuNWg2NDB6TTc2OCAxOTJxODAgMCAxMzYgNTZ0NTYgMTM2dC01NiAxMzZ0LTEzNiA1Ngp0LTEzNiAtNTZ0LTU2IC0xMzZ0NTYgLTEzNnQxMzYgLTU2ek0xMzQ0IDc2OHY1MTJoLTExNTJ2LTUxMmgxMTUyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTM0IiB1bmljb2RlPSImI3hmMjM5OyIgCmQ9Ik0xMDg4IDE1MzZxMTg1IDAgMzE2LjUgLTkzLjV0MTMxLjUgLTIyNi41di04OTZxMCAtMTMwIC0xMjUuNSAtMjIydC0zMDUuNSAtOTdsMjEzIC0yMDJxMTYgLTE1IDggLTM1dC0zMCAtMjBoLTEwNTZxLTIyIDAgLTMwIDIwdDggMzVsMjEzIDIwMnEtMTgwIDUgLTMwNS41IDk3dC0xMjUuNSAyMjJ2ODk2cTAgMTMzIDEzMS41IDIyNi41dDMxNi41IDkzLjVoNjQwek0yODggMjI0cTY2IDAgMTEzIDQ3dDQ3IDExM3QtNDcgMTEzdC0xMTMgNDcKdC0xMTMgLTQ3dC00NyAtMTEzdDQ3IC0xMTN0MTEzIC00N3pNNzA0IDc2OHY1MTJoLTU0NHYtNTEyaDU0NHpNMTI0OCAyMjRxNjYgMCAxMTMgNDd0NDcgMTEzdC00NyAxMTN0LTExMyA0N3QtMTEzIC00N3QtNDcgLTExM3Q0NyAtMTEzdDExMyAtNDd6TTE0MDggNzY4djUxMmgtNTc2di01MTJoNTc2eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTM1IiB1bmljb2RlPSImI3hmMjNhOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNNTk3IDExMTV2LTExNzNxMCAtMjUgLTEyLjUgLTQyLjV0LTM2LjUgLTE3LjVxLTE3IDAgLTMzIDhsLTQ2NSAyMzNxLTIxIDEwIC0zNS41IDMzLjV0LTE0LjUgNDYuNXYxMTQwcTAgMjAgMTAgMzR0MjkgMTRxMTQgMCA0NCAtMTVsNTExIC0yNTZxMyAtMyAzIC01ek02NjEgMTAxNGw1MzQgLTg2NmwtNTM0IDI2NnY2MDB6TTE3OTIgOTk2di0xMDU0cTAgLTI1IC0xNCAtNDAuNXQtMzggLTE1LjV0LTQ3IDEzbC00NDEgMjIwek0xNzg5IDExMTYKcTAgLTMgLTI1Ni41IC00MTkuNXQtMzAwLjUgLTQ4Ny41bC0zOTAgNjM0bDMyNCA1MjdxMTcgMjggNTIgMjhxMTQgMCAyNiAtNmw1NDEgLTI3MHE0IC0yIDQgLTZ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81MzYiIHVuaWNvZGU9IiYjeGYyM2I7IiAKZD0iTTgwOSA1MzJsMjY2IDQ5OWgtMTEybC0xNTcgLTMxMnEtMjQgLTQ4IC00NCAtOTJsLTQyIDkybC0xNTUgMzEyaC0xMjBsMjYzIC00OTN2LTMyNGgxMDF2MzE4ek0xNTM2IDE0MDh2LTE1MzZoLTE1MzZ2MTUzNmgxNTM2eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTM3IiB1bmljb2RlPSImI3hmMjNjOyIgaG9yaXotYWR2LXg9IjIyOTYiIApkPSJNNDc4IC0xMzlxLTggLTE2IC0yNyAtMzQuNXQtMzcgLTI1LjVxLTI1IC05IC01MS41IDMuNXQtMjguNSAzMS41cS0xIDIyIDQwIDU1dDY4IDM4cTIzIDQgMzQgLTIxLjV0MiAtNDYuNXpNMTgxOSAtMTM5cTcgLTE2IDI2IC0zNC41dDM4IC0yNS41cTI1IC05IDUxLjUgMy41dDI3LjUgMzEuNXEyIDIyIC0zOS41IDU1dC02OC41IDM4cS0yMiA0IC0zMyAtMjEuNXQtMiAtNDYuNXpNMTg2NyAtMzBxMTMgLTI3IDU2LjUgLTU5LjV0NzcuNSAtNDEuNQpxNDUgLTEzIDgyIDQuNXQzNyA1MC41cTAgNDYgLTY3LjUgMTAwLjV0LTExNS41IDU5LjVxLTQwIDUgLTYzLjUgLTM3LjV0LTYuNSAtNzYuNXpNNDI4IC0zMHEtMTMgLTI3IC01NiAtNTkuNXQtNzcgLTQxLjVxLTQ1IC0xMyAtODIgNC41dC0zNyA1MC41cTAgNDYgNjcuNSAxMDAuNXQxMTUuNSA1OS41cTQwIDUgNjMgLTM3LjV0NiAtNzYuNXpNMTE1OCAxMDk0aDFxLTQxIDAgLTc2IC0xNXEyNyAtOCA0NCAtMzAuNXQxNyAtNDkuNQpxMCAtMzUgLTI3IC02MHQtNjUgLTI1cS01MiAwIC04MCA0M3EtNSAtMjMgLTUgLTQycTAgLTc0IDU2IC0xMjYuNXQxMzUgLTUyLjVxODAgMCAxMzYgNTIuNXQ1NiAxMjYuNXQtNTYgMTI2LjV0LTEzNiA1Mi41ek0xNDYyIDEzMTJxLTk5IDEwOSAtMjIwLjUgMTMxLjV0LTI0NS41IC00NC41cTI3IDYwIDgyLjUgOTYuNXQxMTggMzkuNXQxMjEuNSAtMTd0OTkuNSAtNzQuNXQ0NC41IC0xMzEuNXpNMjIxMiA3M3E4IC0xMSAtMTEgLTQyCnE3IC0yMyA3IC00MHExIC01NiAtNDQuNSAtMTEyLjV0LTEwOS41IC05MS41dC0xMTggLTM3cS00OCAtMiAtOTIgMjEuNXQtNjYgNjUuNXEtNjg3IC0yNSAtMTI1OSAwcS0yMyAtNDEgLTY2LjUgLTY1dC05Mi41IC0yMnEtODYgMyAtMTc5LjUgODAuNXQtOTIuNSAxNjAuNXEyIDIyIDcgNDBxLTE5IDMxIC0xMSA0MnE2IDEwIDMxIDFxMTQgMjIgNDEgNTFxLTcgMjkgMiAzOHExMSAxMCAzOSAtNHEyOSAyMCA1OSAzNHEwIDI5IDEzIDM3CnEyMyAxMiA1MSAtMTZxMzUgNSA2MSAtMnExOCAtNCAzOCAtMTl2NzNxLTExIDAgLTE4IDJxLTUzIDEwIC05NyA0NC41dC01NSA4Ny41cS05IDM4IDAgODFxMTUgNjIgOTMgOTVxMiAxNyAxOSAzNS41dDM2IDIzLjV0MzMgLTcuNXQxOSAtMzAuNWgxM3E0NiAtNSA2MCAtMjNxMyAtMyA1IC03cTEwIDEgMzAuNSAzLjV0MzAuNSAzLjVxLTE1IDExIC0zMCAxN3EtMjMgNDAgLTkxIDQzcTAgNiAxIDEwcS02MiAyIC0xMTguNSAxOC41dC04NC41IDQ3LjUKcS0zMiAzNiAtNDIuNSA5MnQtMi41IDExMnExNiAxMjYgOTAgMTc5cTIzIDE2IDUyIDQuNXQzMiAtNDAuNXEwIC0xIDEuNSAtMTR0Mi41IC0yMXQzIC0yMHQ1LjUgLTE5dDguNSAtMTBxMjcgLTE0IDc2IC0xMnE0OCA0NiA5OCA3NHEtNDAgNCAtMTYyIC0xNGw0NyA0NnE2MSA1OCAxNjMgMTExcTE0NSA3MyAyODIgODZxLTIwIDggLTQxIDE1LjV0LTQ3IDE0dC00Mi41IDEwLjV0LTQ3LjUgMTF0LTQzIDEwcTU5NSAxMjYgOTA0IC0xMzkKcTk4IC04NCAxNTggLTIyMnE4NSAtMTAgMTIxIDloMXE1IDMgOC41IDEwdDUuNSAxOXQzIDE5LjV0MyAyMS41bDEgMTRxMyAyOCAzMiA0MHQ1MiAtNXE3MyAtNTIgOTEgLTE3OHE3IC01NyAtMy41IC0xMTN0LTQyLjUgLTkxcS0yOCAtMzIgLTgzLjUgLTQ4LjV0LTExNS41IC0xOC41di0xMHEtNzEgLTIgLTk1IC00M3EtMTQgLTUgLTMxIC0xN3ExMSAtMSAzMiAtMy41dDMwIC0zLjVxMSA1IDUgOHExNiAxOCA2MCAyM2gxM3E1IDE4IDE5IDMwdDMzIDgKdDM2IC0yM3QxOSAtMzZxNzkgLTMyIDkzIC05NXE5IC00MCAxIC04MXEtMTIgLTUzIC01NiAtODh0LTk3IC00NHEtMTAgLTIgLTE3IC0ycTAgLTQ5IC0xIC03M3EyMCAxNSAzOCAxOXEyNiA3IDYxIDJxMjggMjggNTEgMTZxMTQgLTkgMTQgLTM3cTMzIC0xNiA1OSAtMzRxMjcgMTMgMzggNHExMCAtMTAgMiAtMzhxMjggLTMwIDQxIC01MXEyMyA4IDMxIC0xek0xOTM3IDEwMjVxMCAtMjkgLTkgLTU0cTgyIC0zMiAxMTIgLTEzMgpxNCAzNyAtOS41IDk4LjV0LTQxLjUgOTAuNXEtMjAgMTkgLTM2IDE3dC0xNiAtMjB6TTE4NTkgOTI1cTM1IC00MiA0Ny41IC0xMDguNXQtMC41IC0xMjQuNXE2NyAxMyA5NyA0NXExMyAxNCAxOCAyOHEtMyA2NCAtMzEgMTE0LjV0LTc5IDY2LjVxLTE1IC0xNSAtNTIgLTIxek0xODIyIDkyMXEtMzAgMCAtNDQgMXE0MiAtMTE1IDUzIC0yMzlxMjEgMCA0MyAzcTE2IDY4IDEgMTM1dC01MyAxMDB6TTI1OCA4MzlxMzAgMTAwIDExMiAxMzIKcS05IDI1IC05IDU0cTAgMTggLTE2LjUgMjB0LTM1LjUgLTE3cS0yOCAtMjkgLTQxLjUgLTkwLjV0LTkuNSAtOTguNXpNMjk0IDczN3EyOSAtMzEgOTcgLTQ1cS0xMyA1OCAtMC41IDEyNC41dDQ3LjUgMTA4LjV2MHEtMzcgNiAtNTIgMjFxLTUxIC0xNiAtNzguNSAtNjZ0LTMxLjUgLTExNXE5IC0xNyAxOCAtMjh6TTQ3MSA2ODNxMTQgMTI0IDczIDIzNXEtMTkgLTQgLTU1IC0xOGwtNDUgLTE5djFxLTQ2IC04OSAtMjAgLTE5NnEyNSAtMyA0NyAtM3oKTTE0MzQgNjQ0cTggLTM4IDE2LjUgLTEwOC41dDExLjUgLTg5LjVxMyAtMTggOS41IC0yMS41dDIzLjUgNC41cTQwIDIwIDYyIDg1LjV0MjMgMTI1LjVxLTI0IDIgLTE0NiA0ek0xMTUyIDEyODVxLTExNiAwIC0xOTkgLTgyLjV0LTgzIC0xOTguNXEwIC0xMTcgODMgLTE5OS41dDE5OSAtODIuNXQxOTkgODIuNXQ4MyAxOTkuNXEwIDExNiAtODMgMTk4LjV0LTE5OSA4Mi41ek0xMzgwIDY0NnEtMTA1IDIgLTIxMSAwdjFxLTEgLTI3IDIuNSAtODYKdDEzLjUgLTY2cTI5IC0xNCA5My41IC0xNC41dDk1LjUgMTAuNXE5IDMgMTEgMzl0LTAuNSA2OS41dC00LjUgNDYuNXpNMTExMiA0NDdxOCA0IDkuNSA0OHQtMC41IDg4dC00IDYzdjFxLTIxMiAtMyAtMjE0IC0zcS00IC0yMCAtNyAtNjJ0MCAtODN0MTQgLTQ2cTM0IC0xNSAxMDEgLTE2dDEwMSAxMHpNNzE4IDYzNnEtMTYgLTU5IDQuNSAtMTE4LjV0NzcuNSAtODQuNXExNSAtOCAyNCAtNXQxMiAyMXEzIDE2IDggOTB0MTAgMTAzCnEtNjkgLTIgLTEzNiAtNnpNNTkxIDUxMHEzIC0yMyAtMzQgLTM2cTEzMiAtMTQxIDI3MS41IC0yNDB0MzA1LjUgLTE1NHExNzIgNDkgMzEwLjUgMTQ2dDI5My41IDI1MHEtMzMgMTMgLTMwIDM0cTAgMiAwLjUgMy41dDEuNSAzdDEgMi41djF2LTFxLTE3IDIgLTUwIDUuNXQtNDggNC41cS0yNiAtOTAgLTgyIC0xMzJxLTUxIC0zOCAtODIgMXEtNSA2IC05IDE0cS03IDEzIC0xNyA2MnEtMiAtNSAtNSAtOXQtNy41IC03dC04IC01LjV0LTkuNSAtNApsLTEwIC0yLjV0LTEyIC0ybC0xMiAtMS41dC0xMy41IC0xdC0xMy41IC0wLjVxLTEwNiAtOSAtMTYzIDExcS00IC0xNyAtMTAgLTI2LjV0LTIxIC0xNXQtMjMgLTd0LTM2IC0zLjVxLTYgLTEgLTkgLTFxLTE3OSAtMTcgLTIwMyA0MHEtMiAtNjMgLTU2IC01NHEtNDcgOCAtOTEgNTRxLTEyIDEzIC0yMCAyNnEtMTcgMjkgLTI2IDY1cS01OCAtNiAtODcgLTEwcTEgLTIgNCAtMTB6TTUwNyAtMTE4cTMgMTQgMyAzMHEtMTcgNzEgLTUxIDEzMAp0LTczIDcwcS00MSAxMiAtMTAxLjUgLTE0LjV0LTEwNC41IC04MHQtMzkgLTEwNy41cTM1IC01MyAxMDAgLTkzdDExOSAtNDJxNTEgLTIgOTQgMjh0NTMgNzl6TTUxMCA1M3EyMyAtNjMgMjcgLTExOXExOTUgMTEzIDM5MiAxNzRxLTk4IDUyIC0xODAuNSAxMjB0LTE3OS41IDE2NXEtNiAtNCAtMjkgLTEzcTAgLTEgLTEgLTR0LTEgLTVxMzEgLTE4IDIyIC0zN3EtMTIgLTIzIC01NiAtMzRxLTEwIC0xMyAtMjkgLTI0aC0xcS0yIC04MyAxIC0xNTAKcTE5IC0zNCAzNSAtNzN6TTU3OSAtMTEzcTUzMiAtMjEgMTE0NSAwcS0yNTQgMTQ3IC00MjggMTk2cS03NiAtMzUgLTE1NiAtNTdxLTggLTMgLTE2IDBxLTY1IDIxIC0xMjkgNDlxLTIwOCAtNjAgLTQxNiAtMTg4aC0xdi0xcTEgMCAxIDF6TTE3NjMgLTY3cTQgNTQgMjggMTIwcTE0IDM4IDMzIDcxbC0xIC0xcTMgNzcgMyAxNTNxLTE1IDggLTMwIDI1cS00MiA5IC01NiAzM3EtOSAyMCAyMiAzOHEtMiA0IC0yIDlxLTE2IDQgLTI4IDEyCnEtMjA0IC0xOTAgLTM4MyAtMjg0cTE5OCAtNTkgNDE0IC0xNzZ6TTIxNTUgLTkwcTUgNTQgLTM5IDEwNy41dC0xMDQgODB0LTEwMiAxNC41cS0zOCAtMTEgLTcyLjUgLTcwLjV0LTUxLjUgLTEyOS41cTAgLTE2IDMgLTMwcTEwIC00OSA1MyAtNzl0OTQgLTI4cTU0IDIgMTE5IDQydDEwMCA5M3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzUzOCIgdW5pY29kZT0iJiN4ZjIzZDsiIGhvcml6LWFkdi14PSIyMzA0IiAKZD0iTTE1MjQgLTI1cTAgLTY4IC00OCAtMTE2dC0xMTYgLTQ4dC0xMTYuNSA0OHQtNDguNSAxMTZ0NDguNSAxMTYuNXQxMTYuNSA0OC41dDExNiAtNDguNXQ0OCAtMTE2LjV6TTc3NSAtMjVxMCAtNjggLTQ4LjUgLTExNnQtMTE2LjUgLTQ4dC0xMTYgNDh0LTQ4IDExNnQ0OCAxMTYuNXQxMTYgNDguNXQxMTYuNSAtNDguNXQ0OC41IC0xMTYuNXpNMCAxNDY5cTU3IC02MCAxMTAuNSAtMTA0LjV0MTIxIC04MnQxMzYgLTYzdDE2NiAtNDUuNQp0MjAwIC0zMS41dDI1MCAtMTguNXQzMDQgLTkuNXQzNzIuNSAtMi41cTEzOSAwIDI0NC41IC01dDE4MSAtMTYuNXQxMjQgLTI3LjV0NzEgLTM5LjV0MjQgLTUxLjV0LTE5LjUgLTY0dC01Ni41IC03Ni41dC04OS41IC05MXQtMTE2IC0xMDQuNXQtMTM5IC0xMTlxLTE4NSAtMTU3IC0yODYgLTI0N3EyOSA1MSA3Ni41IDEwOXQ5NCAxMDUuNXQ5NC41IDk4LjV0ODMgOTEuNXQ1NCA4MC41dDEzIDcwdC00NS41IDU1LjV0LTExNi41IDQxdC0yMDQgMjMuNQp0LTMwNCA1cS0xNjggLTIgLTMxNCA2dC0yNTYgMjN0LTIwNC41IDQxdC0xNTkuNSA1MS41dC0xMjIuNSA2Mi41dC05MS41IDY2LjV0LTY4IDcxLjV0LTUwLjUgNjkuNXQtNDAgNjh0LTM2LjUgNTkuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzUzOSIgdW5pY29kZT0iJiN4ZjIzZTsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTg5NiAxNDcycS0xNjkgMCAtMzIzIC02NnQtMjY1LjUgLTE3Ny41dC0xNzcuNSAtMjY1LjV0LTY2IC0zMjN0NjYgLTMyM3QxNzcuNSAtMjY1LjV0MjY1LjUgLTE3Ny41dDMyMyAtNjZ0MzIzIDY2dDI2NS41IDE3Ny41dDE3Ny41IDI2NS41dDY2IDMyM3QtNjYgMzIzdC0xNzcuNSAyNjUuNXQtMjY1LjUgMTc3LjV0LTMyMyA2NnpNODk2IDE1MzZxMTgyIDAgMzQ4IC03MXQyODYgLTE5MXQxOTEgLTI4NnQ3MSAtMzQ4dC03MSAtMzQ4CnQtMTkxIC0yODZ0LTI4NiAtMTkxdC0zNDggLTcxdC0zNDggNzF0LTI4NiAxOTF0LTE5MSAyODZ0LTcxIDM0OHQ3MSAzNDh0MTkxIDI4NnQyODYgMTkxdDM0OCA3MXpNNDk2IDcwNHExNiAwIDE2IC0xNnYtNDgwcTAgLTE2IC0xNiAtMTZoLTMycS0xNiAwIC0xNiAxNnY0ODBxMCAxNiAxNiAxNmgzMnpNODk2IDY0MHE1MyAwIDkwLjUgLTM3LjV0MzcuNSAtOTAuNXEwIC0zNSAtMTcuNSAtNjR0LTQ2LjUgLTQ2di0xMTRxMCAtMTQgLTkgLTIzCnQtMjMgLTloLTY0cS0xNCAwIC0yMyA5dC05IDIzdjExNHEtMjkgMTcgLTQ2LjUgNDZ0LTE3LjUgNjRxMCA1MyAzNy41IDkwLjV0OTAuNSAzNy41ek04OTYgMTQwOHEyMDkgMCAzODUuNSAtMTAzdDI3OS41IC0yNzkuNXQxMDMgLTM4NS41dC0xMDMgLTM4NS41dC0yNzkuNSAtMjc5LjV0LTM4NS41IC0xMDN0LTM4NS41IDEwM3QtMjc5LjUgMjc5LjV0LTEwMyAzODUuNXQxMDMgMzg1LjV0Mjc5LjUgMjc5LjV0Mzg1LjUgMTAzek01NDQgOTI4di05NgpxMCAtMTQgOSAtMjN0MjMgLTloNjRxMTQgMCAyMyA5dDkgMjN2OTZxMCA5MyA2NS41IDE1OC41dDE1OC41IDY1LjV0MTU4LjUgLTY1LjV0NjUuNSAtMTU4LjV2LTk2cTAgLTE0IDkgLTIzdDIzIC05aDY0cTE0IDAgMjMgOXQ5IDIzdjk2cTAgMTQ2IC0xMDMgMjQ5dC0yNDkgMTAzdC0yNDkgLTEwM3QtMTAzIC0yNDl6TTE0MDggMTkydjUxMnEwIDI2IC0xOSA0NXQtNDUgMTloLTg5NnEtMjYgMCAtNDUgLTE5dC0xOSAtNDV2LTUxMgpxMCAtMjYgMTkgLTQ1dDQ1IC0xOWg4OTZxMjYgMCA0NSAxOXQxOSA0NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzU0MCIgdW5pY29kZT0iJiN4ZjI0MDsiIGhvcml6LWFkdi14PSIyMzA0IiAKZD0iTTE5MjAgMTAyNHYtNzY4aC0xNjY0djc2OGgxNjY0ek0yMDQ4IDQ0OGgxMjh2Mzg0aC0xMjh2Mjg4cTAgMTQgLTkgMjN0LTIzIDloLTE4NTZxLTE0IDAgLTIzIC05dC05IC0yM3YtOTYwcTAgLTE0IDkgLTIzdDIzIC05aDE4NTZxMTQgMCAyMyA5dDkgMjN2Mjg4ek0yMzA0IDgzMnYtMzg0cTAgLTUzIC0zNy41IC05MC41dC05MC41IC0zNy41di0xNjBxMCAtNjYgLTQ3IC0xMTN0LTExMyAtNDdoLTE4NTZxLTY2IDAgLTExMyA0N3QtNDcgMTEzCnY5NjBxMCA2NiA0NyAxMTN0MTEzIDQ3aDE4NTZxNjYgMCAxMTMgLTQ3dDQ3IC0xMTN2LTE2MHE1MyAwIDkwLjUgLTM3LjV0MzcuNSAtOTAuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzU0MSIgdW5pY29kZT0iJiN4ZjI0MTsiIGhvcml6LWFkdi14PSIyMzA0IiAKZD0iTTI1NiAyNTZ2NzY4aDEyODB2LTc2OGgtMTI4MHpNMjE3NiA5NjBxNTMgMCA5MC41IC0zNy41dDM3LjUgLTkwLjV2LTM4NHEwIC01MyAtMzcuNSAtOTAuNXQtOTAuNSAtMzcuNXYtMTYwcTAgLTY2IC00NyAtMTEzdC0xMTMgLTQ3aC0xODU2cS02NiAwIC0xMTMgNDd0LTQ3IDExM3Y5NjBxMCA2NiA0NyAxMTN0MTEzIDQ3aDE4NTZxNjYgMCAxMTMgLTQ3dDQ3IC0xMTN2LTE2MHpNMjE3NiA0NDh2Mzg0aC0xMjh2Mjg4cTAgMTQgLTkgMjN0LTIzIDkKaC0xODU2cS0xNCAwIC0yMyAtOXQtOSAtMjN2LTk2MHEwIC0xNCA5IC0yM3QyMyAtOWgxODU2cTE0IDAgMjMgOXQ5IDIzdjI4OGgxMjh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81NDIiIHVuaWNvZGU9IiYjeGYyNDI7IiBob3Jpei1hZHYteD0iMjMwNCIgCmQ9Ik0yNTYgMjU2djc2OGg4OTZ2LTc2OGgtODk2ek0yMTc2IDk2MHE1MyAwIDkwLjUgLTM3LjV0MzcuNSAtOTAuNXYtMzg0cTAgLTUzIC0zNy41IC05MC41dC05MC41IC0zNy41di0xNjBxMCAtNjYgLTQ3IC0xMTN0LTExMyAtNDdoLTE4NTZxLTY2IDAgLTExMyA0N3QtNDcgMTEzdjk2MHEwIDY2IDQ3IDExM3QxMTMgNDdoMTg1NnE2NiAwIDExMyAtNDd0NDcgLTExM3YtMTYwek0yMTc2IDQ0OHYzODRoLTEyOHYyODhxMCAxNCAtOSAyM3QtMjMgOQpoLTE4NTZxLTE0IDAgLTIzIC05dC05IC0yM3YtOTYwcTAgLTE0IDkgLTIzdDIzIC05aDE4NTZxMTQgMCAyMyA5dDkgMjN2Mjg4aDEyOHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzU0MyIgdW5pY29kZT0iJiN4ZjI0MzsiIGhvcml6LWFkdi14PSIyMzA0IiAKZD0iTTI1NiAyNTZ2NzY4aDUxMnYtNzY4aC01MTJ6TTIxNzYgOTYwcTUzIDAgOTAuNSAtMzcuNXQzNy41IC05MC41di0zODRxMCAtNTMgLTM3LjUgLTkwLjV0LTkwLjUgLTM3LjV2LTE2MHEwIC02NiAtNDcgLTExM3QtMTEzIC00N2gtMTg1NnEtNjYgMCAtMTEzIDQ3dC00NyAxMTN2OTYwcTAgNjYgNDcgMTEzdDExMyA0N2gxODU2cTY2IDAgMTEzIC00N3Q0NyAtMTEzdi0xNjB6TTIxNzYgNDQ4djM4NGgtMTI4djI4OHEwIDE0IC05IDIzdC0yMyA5CmgtMTg1NnEtMTQgMCAtMjMgLTl0LTkgLTIzdi05NjBxMCAtMTQgOSAtMjN0MjMgLTloMTg1NnExNCAwIDIzIDl0OSAyM3YyODhoMTI4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTQ0IiB1bmljb2RlPSImI3hmMjQ0OyIgaG9yaXotYWR2LXg9IjIzMDQiIApkPSJNMjE3NiA5NjBxNTMgMCA5MC41IC0zNy41dDM3LjUgLTkwLjV2LTM4NHEwIC01MyAtMzcuNSAtOTAuNXQtOTAuNSAtMzcuNXYtMTYwcTAgLTY2IC00NyAtMTEzdC0xMTMgLTQ3aC0xODU2cS02NiAwIC0xMTMgNDd0LTQ3IDExM3Y5NjBxMCA2NiA0NyAxMTN0MTEzIDQ3aDE4NTZxNjYgMCAxMTMgLTQ3dDQ3IC0xMTN2LTE2MHpNMjE3NiA0NDh2Mzg0aC0xMjh2Mjg4cTAgMTQgLTkgMjN0LTIzIDloLTE4NTZxLTE0IDAgLTIzIC05dC05IC0yMwp2LTk2MHEwIC0xNCA5IC0yM3QyMyAtOWgxODU2cTE0IDAgMjMgOXQ5IDIzdjI4OGgxMjh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81NDUiIHVuaWNvZGU9IiYjeGYyNDU7IiBob3Jpei1hZHYteD0iMTI4MCIgCmQ9Ik0xMTMzIDQ5M3EzMSAtMzAgMTQgLTY5cS0xNyAtNDAgLTU5IC00MGgtMzgybDIwMSAtNDc2cTEwIC0yNSAwIC00OXQtMzQgLTM1bC0xNzcgLTc1cS0yNSAtMTAgLTQ5IDB0LTM1IDM0bC0xOTEgNDUybC0zMTIgLTMxMnEtMTkgLTE5IC00NSAtMTlxLTEyIDAgLTI0IDVxLTQwIDE3IC00MCA1OXYxNTA0cTAgNDIgNDAgNTlxMTIgNSAyNCA1cTI3IDAgNDUgLTE5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTQ2IiB1bmljb2RlPSImI3hmMjQ2OyIgaG9yaXotYWR2LXg9IjEwMjQiIApkPSJNODMyIDE0MDhxLTMyMCAwIC0zMjAgLTIyNHYtNDE2aDEyOHYtMTI4aC0xMjh2LTU0NHEwIC0yMjQgMzIwIC0yMjRoNjR2LTEyOGgtNjRxLTI3MiAwIC0zODQgMTQ2cS0xMTIgLTE0NiAtMzg0IC0xNDZoLTY0djEyOGg2NHEzMjAgMCAzMjAgMjI0djU0NGgtMTI4djEyOGgxMjh2NDE2cTAgMjI0IC0zMjAgMjI0aC02NHYxMjhoNjRxMjcyIDAgMzg0IC0xNDZxMTEyIDE0NiAzODQgMTQ2aDY0di0xMjhoLTY0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTQ3IiB1bmljb2RlPSImI3hmMjQ3OyIgaG9yaXotYWR2LXg9IjIwNDgiIApkPSJNMjA0OCAxMTUyaC0xMjh2LTEwMjRoMTI4di0zODRoLTM4NHYxMjhoLTEyODB2LTEyOGgtMzg0djM4NGgxMjh2MTAyNGgtMTI4djM4NGgzODR2LTEyOGgxMjgwdjEyOGgzODR2LTM4NHpNMTc5MiAxNDA4di0xMjhoMTI4djEyOGgtMTI4ek0xMjggMTQwOHYtMTI4aDEyOHYxMjhoLTEyOHpNMjU2IC0xMjh2MTI4aC0xMjh2LTEyOGgxMjh6TTE2NjQgMHYxMjhoMTI4djEwMjRoLTEyOHYxMjhoLTEyODB2LTEyOGgtMTI4di0xMDI0aDEyOHYtMTI4CmgxMjgwek0xOTIwIC0xMjh2MTI4aC0xMjh2LTEyOGgxMjh6TTEyODAgODk2aDM4NHYtNzY4aC04OTZ2MjU2aC0zODR2NzY4aDg5NnYtMjU2ek01MTIgNTEyaDY0MHY1MTJoLTY0MHYtNTEyek0xNTM2IDI1NnY1MTJoLTI1NnYtMzg0aC0zODR2LTEyOGg2NDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81NDgiIHVuaWNvZGU9IiYjeGYyNDg7IiBob3Jpei1hZHYteD0iMjMwNCIgCmQ9Ik0yMzA0IDc2OGgtMTI4di02NDBoMTI4di0zODRoLTM4NHYxMjhoLTg5NnYtMTI4aC0zODR2Mzg0aDEyOHYxMjhoLTM4NHYtMTI4aC0zODR2Mzg0aDEyOHY2NDBoLTEyOHYzODRoMzg0di0xMjhoODk2djEyOGgzODR2LTM4NGgtMTI4di0xMjhoMzg0djEyOGgzODR2LTM4NHpNMjA0OCAxMDI0di0xMjhoMTI4djEyOGgtMTI4ek0xNDA4IDE0MDh2LTEyOGgxMjh2MTI4aC0xMjh6TTEyOCAxNDA4di0xMjhoMTI4djEyOGgtMTI4ek0yNTYgMjU2CnYxMjhoLTEyOHYtMTI4aDEyOHpNMTUzNiAzODRoLTEyOHYtMTI4aDEyOHYxMjh6TTM4NCAzODRoODk2djEyOGgxMjh2NjQwaC0xMjh2MTI4aC04OTZ2LTEyOGgtMTI4di02NDBoMTI4di0xMjh6TTg5NiAtMTI4djEyOGgtMTI4di0xMjhoMTI4ek0yMTc2IC0xMjh2MTI4aC0xMjh2LTEyOGgxMjh6TTIwNDggMTI4djY0MGgtMTI4djEyOGgtMzg0di0zODRoMTI4di0zODRoLTM4NHYxMjhoLTM4NHYtMTI4aDEyOHYtMTI4aDg5NnYxMjhoMTI4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTQ5IiB1bmljb2RlPSImI3hmMjQ5OyIgCmQ9Ik0xMDI0IDI4OHYtNDE2aC05MjhxLTQwIDAgLTY4IDI4dC0yOCA2OHYxMzQ0cTAgNDAgMjggNjh0NjggMjhoMTM0NHE0MCAwIDY4IC0yOHQyOCAtNjh2LTkyOGgtNDE2cS00MCAwIC02OCAtMjh0LTI4IC02OHpNMTE1MiAyNTZoMzgxcS0xNSAtODIgLTY1IC0xMzJsLTE4NCAtMTg0cS01MCAtNTAgLTEzMiAtNjV2MzgxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTUwIiB1bmljb2RlPSImI3hmMjRhOyIgCmQ9Ik0xNDAwIDI1NmgtMjQ4di0yNDhxMjkgMTAgNDEgMjJsMTg1IDE4NXExMiAxMiAyMiA0MXpNMTEyMCAzODRoMjg4djg5NmgtMTI4MHYtMTI4MGg4OTZ2Mjg4cTAgNDAgMjggNjh0NjggMjh6TTE1MzYgMTMxMnYtMTAyNHEwIC00MCAtMjAgLTg4dC00OCAtNzZsLTE4NCAtMTg0cS0yOCAtMjggLTc2IC00OHQtODggLTIwaC0xMDI0cS00MCAwIC02OCAyOHQtMjggNjh2MTM0NHEwIDQwIDI4IDY4dDY4IDI4aDEzNDRxNDAgMCA2OCAtMjh0MjggLTY4CnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzU1MSIgdW5pY29kZT0iJiN4ZjI0YjsiIGhvcml6LWFkdi14PSIyMzA0IiAKZD0iTTE5NTEgNTM4cTAgLTI2IC0xNS41IC00NC41dC0zOC41IC0yMy41cS04IC0yIC0xOCAtMmgtMTUzdjE0MGgxNTNxMTAgMCAxOCAtMnEyMyAtNSAzOC41IC0yMy41dDE1LjUgLTQ0LjV6TTE5MzMgNzUxcTAgLTI1IC0xNSAtNDJ0LTM4IC0yMXEtMyAtMSAtMTUgLTFoLTEzOXYxMjloMTM5cTMgMCA4LjUgLTAuNXQ2LjUgLTAuNXEyMyAtNCAzOCAtMjEuNXQxNSAtNDIuNXpNNzI4IDU4N3YzMDhoLTIyOHYtMzA4cTAgLTU4IC0zOCAtOTQuNQp0LTEwNSAtMzYuNXEtMTA4IDAgLTIyOSA1OXYtMTEycTUzIC0xNSAxMjEgLTIzdDEwOSAtOWw0MiAtMXEzMjggMCAzMjggMjE3ek0xNDQyIDQwM3YxMTNxLTk5IC01MiAtMjAwIC01OXEtMTA4IC04IC0xNjkgNDF0LTYxIDE0MnQ2MSAxNDJ0MTY5IDQxcTEwMSAtNyAyMDAgLTU4djExMnEtNDggMTIgLTEwMCAxOS41dC04MCA5LjVsLTI4IDJxLTEyNyA2IC0yMTguNSAtMTR0LTE0MC41IC02MHQtNzEgLTg4dC0yMiAtMTA2dDIyIC0xMDZ0NzEgLTg4CnQxNDAuNSAtNjB0MjE4LjUgLTE0cTEwMSA0IDIwOCAzMXpNMjE3NiA1MThxMCA1NCAtNDMgODguNXQtMTA5IDM5LjV2M3E1NyA4IDg5IDQxLjV0MzIgNzkuNXEwIDU1IC00MSA4OHQtMTA3IDM2cS0zIDAgLTEyIDAuNXQtMTQgMC41aC00NTV2LTUxMGg0OTFxNzQgMCAxMjEuNSAzNi41dDQ3LjUgOTYuNXpNMjMwNCAxMjgwdi0xMjgwcTAgLTUyIC0zOCAtOTB0LTkwIC0zOGgtMjA0OHEtNTIgMCAtOTAgMzh0LTM4IDkwdjEyODBxMCA1MiAzOCA5MAp0OTAgMzhoMjA0OHE1MiAwIDkwIC0zOHQzOCAtOTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81NTIiIHVuaWNvZGU9IiYjeGYyNGM7IiBob3Jpei1hZHYteD0iMjMwNCIgCmQ9Ik04NTggMjk1djY5M3EtMTA2IC00MSAtMTcyIC0xMzUuNXQtNjYgLTIxMS41dDY2IC0yMTEuNXQxNzIgLTEzNC41ek0xMzYyIDY0MXEwIDExNyAtNjYgMjExLjV0LTE3MiAxMzUuNXYtNjk0cTEwNiA0MSAxNzIgMTM1LjV0NjYgMjExLjV6TTE1NzcgNjQxcTAgLTE1OSAtNzguNSAtMjk0dC0yMTMuNSAtMjEzLjV0LTI5NCAtNzguNXEtMTE5IDAgLTIyNy41IDQ2LjV0LTE4NyAxMjV0LTEyNSAxODd0LTQ2LjUgMjI3LjVxMCAxNTkgNzguNSAyOTQKdDIxMy41IDIxMy41dDI5NCA3OC41dDI5NCAtNzguNXQyMTMuNSAtMjEzLjV0NzguNSAtMjk0ek0xOTYwIDYzNHEwIDEzOSAtNTUuNSAyNjEuNXQtMTQ3LjUgMjA1LjV0LTIxMy41IDEzMXQtMjUyLjUgNDhoLTMwMXEtMTc2IDAgLTMyMy41IC04MXQtMjM1IC0yMzB0LTg3LjUgLTMzNXEwIC0xNzEgODcgLTMxNy41dDIzNiAtMjMxLjV0MzIzIC04NWgzMDFxMTI5IDAgMjUxLjUgNTAuNXQyMTQuNSAxMzV0MTQ3LjUgMjAyLjV0NTUuNSAyNDZ6Ck0yMzA0IDEyODB2LTEyODBxMCAtNTIgLTM4IC05MHQtOTAgLTM4aC0yMDQ4cS01MiAwIC05MCAzOHQtMzggOTB2MTI4MHEwIDUyIDM4IDkwdDkwIDM4aDIwNDhxNTIgMCA5MCAtMzh0MzggLTkweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTUzIiB1bmljb2RlPSImI3hmMjRkOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTY2NCAtOTZ2MTA4OHEwIDEzIC05LjUgMjIuNXQtMjIuNSA5LjVoLTEwODhxLTEzIDAgLTIyLjUgLTkuNXQtOS41IC0yMi41di0xMDg4cTAgLTEzIDkuNSAtMjIuNXQyMi41IC05LjVoMTA4OHExMyAwIDIyLjUgOS41dDkuNSAyMi41ek0xNzkyIDk5MnYtMTA4OHEwIC02NiAtNDcgLTExM3QtMTEzIC00N2gtMTA4OHEtNjYgMCAtMTEzIDQ3dC00NyAxMTN2MTA4OHEwIDY2IDQ3IDExM3QxMTMgNDdoMTA4OHE2NiAwIDExMyAtNDd0NDcgLTExMwp6TTE0MDggMTM3NnYtMTYwaC0xMjh2MTYwcTAgMTMgLTkuNSAyMi41dC0yMi41IDkuNWgtMTA4OHEtMTMgMCAtMjIuNSAtOS41dC05LjUgLTIyLjV2LTEwODhxMCAtMTMgOS41IC0yMi41dDIyLjUgLTkuNWgxNjB2LTEyOGgtMTYwcS02NiAwIC0xMTMgNDd0LTQ3IDExM3YxMDg4cTAgNjYgNDcgMTEzdDExMyA0N2gxMDg4cTY2IDAgMTEzIC00N3Q0NyAtMTEzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTU0IiB1bmljb2RlPSImI3hmMjRlOyIgaG9yaXotYWR2LXg9IjIzMDQiIApkPSJNMTcyOCAxMDg4bC0zODQgLTcwNGg3Njh6TTQ0OCAxMDg4bC0zODQgLTcwNGg3Njh6TTEyNjkgMTI4MHEtMTQgLTQwIC00NS41IC03MS41dC03MS41IC00NS41di0xMjkxaDYwOHExNCAwIDIzIC05dDkgLTIzdi02NHEwIC0xNCAtOSAtMjN0LTIzIC05aC0xMzQ0cS0xNCAwIC0yMyA5dC05IDIzdjY0cTAgMTQgOSAyM3QyMyA5aDYwOHYxMjkxcS00MCAxNCAtNzEuNSA0NS41dC00NS41IDcxLjVoLTQ5MXEtMTQgMCAtMjMgOXQtOSAyM3Y2NApxMCAxNCA5IDIzdDIzIDloNDkxcTIxIDU3IDcwIDkyLjV0MTExIDM1LjV0MTExIC0zNS41dDcwIC05Mi41aDQ5MXExNCAwIDIzIC05dDkgLTIzdi02NHEwIC0xNCAtOSAtMjN0LTIzIC05aC00OTF6TTEwODggMTI2NHEzMyAwIDU2LjUgMjMuNXQyMy41IDU2LjV0LTIzLjUgNTYuNXQtNTYuNSAyMy41dC01Ni41IC0yMy41dC0yMy41IC01Ni41dDIzLjUgLTU2LjV0NTYuNSAtMjMuNXpNMjE3NiAzODRxMCAtNzMgLTQ2LjUgLTEzMXQtMTE3LjUgLTkxCnQtMTQ0LjUgLTQ5LjV0LTEzOS41IC0xNi41dC0xMzkuNSAxNi41dC0xNDQuNSA0OS41dC0xMTcuNSA5MXQtNDYuNSAxMzFxMCAxMSAzNSA4MXQ5MiAxNzQuNXQxMDcgMTk1LjV0MTAyIDE4NHQ1NiAxMDBxMTggMzMgNTYgMzN0NTYgLTMzcTQgLTcgNTYgLTEwMHQxMDIgLTE4NHQxMDcgLTE5NS41dDkyIC0xNzQuNXQzNSAtODF6TTg5NiAzODRxMCAtNzMgLTQ2LjUgLTEzMXQtMTE3LjUgLTkxdC0xNDQuNSAtNDkuNXQtMTM5LjUgLTE2LjUKdC0xMzkuNSAxNi41dC0xNDQuNSA0OS41dC0xMTcuNSA5MXQtNDYuNSAxMzFxMCAxMSAzNSA4MXQ5MiAxNzQuNXQxMDcgMTk1LjV0MTAyIDE4NHQ1NiAxMDBxMTggMzMgNTYgMzN0NTYgLTMzcTQgLTcgNTYgLTEwMHQxMDIgLTE4NHQxMDcgLTE5NS41dDkyIC0xNzQuNXQzNSAtODF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81NTUiIHVuaWNvZGU9IiYjeGYyNTA7IiAKZD0iTTE0MDggMTQwOHEwIC0yNjEgLTEwNi41IC00NjEuNXQtMjY2LjUgLTMwNi41cTE2MCAtMTA2IDI2Ni41IC0zMDYuNXQxMDYuNSAtNDYxLjVoOTZxMTQgMCAyMyAtOXQ5IC0yM3YtNjRxMCAtMTQgLTkgLTIzdC0yMyAtOWgtMTQ3MnEtMTQgMCAtMjMgOXQtOSAyM3Y2NHEwIDE0IDkgMjN0MjMgOWg5NnEwIDI2MSAxMDYuNSA0NjEuNXQyNjYuNSAzMDYuNXEtMTYwIDEwNiAtMjY2LjUgMzA2LjV0LTEwNi41IDQ2MS41aC05NnEtMTQgMCAtMjMgOQp0LTkgMjN2NjRxMCAxNCA5IDIzdDIzIDloMTQ3MnExNCAwIDIzIC05dDkgLTIzdi02NHEwIC0xNCAtOSAtMjN0LTIzIC05aC05NnpNODc0IDcwMHE3NyAyOSAxNDkgOTIuNXQxMjkuNSAxNTIuNXQ5Mi41IDIxMHQzNSAyNTNoLTEwMjRxMCAtMTMyIDM1IC0yNTN0OTIuNSAtMjEwdDEyOS41IC0xNTIuNXQxNDkgLTkyLjVxMTkgLTcgMzAuNSAtMjMuNXQxMS41IC0zNi41dC0xMS41IC0zNi41dC0zMC41IC0yMy41cS03NyAtMjkgLTE0OSAtOTIuNQp0LTEyOS41IC0xNTIuNXQtOTIuNSAtMjEwdC0zNSAtMjUzaDEwMjRxMCAxMzIgLTM1IDI1M3QtOTIuNSAyMTB0LTEyOS41IDE1Mi41dC0xNDkgOTIuNXEtMTkgNyAtMzAuNSAyMy41dC0xMS41IDM2LjV0MTEuNSAzNi41dDMwLjUgMjMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzU1NiIgdW5pY29kZT0iJiN4ZjI1MTsiIApkPSJNMTQwOCAxNDA4cTAgLTI2MSAtMTA2LjUgLTQ2MS41dC0yNjYuNSAtMzA2LjVxMTYwIC0xMDYgMjY2LjUgLTMwNi41dDEwNi41IC00NjEuNWg5NnExNCAwIDIzIC05dDkgLTIzdi02NHEwIC0xNCAtOSAtMjN0LTIzIC05aC0xNDcycS0xNCAwIC0yMyA5dC05IDIzdjY0cTAgMTQgOSAyM3QyMyA5aDk2cTAgMjYxIDEwNi41IDQ2MS41dDI2Ni41IDMwNi41cS0xNjAgMTA2IC0yNjYuNSAzMDYuNXQtMTA2LjUgNDYxLjVoLTk2cS0xNCAwIC0yMyA5CnQtOSAyM3Y2NHEwIDE0IDkgMjN0MjMgOWgxNDcycTE0IDAgMjMgLTl0OSAtMjN2LTY0cTAgLTE0IC05IC0yM3QtMjMgLTloLTk2ek0xMjgwIDE0MDhoLTEwMjRxMCAtNjYgOSAtMTI4aDEwMDZxOSA2MSA5IDEyOHpNMTI4MCAtMTI4cTAgMTMwIC0zNCAyNDkuNXQtOTAuNSAyMDh0LTEyNi41IDE1MnQtMTQ2IDk0LjVoLTIzMHEtNzYgLTMxIC0xNDYgLTk0LjV0LTEyNi41IC0xNTJ0LTkwLjUgLTIwOHQtMzQgLTI0OS41aDEwMjR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81NTciIHVuaWNvZGU9IiYjeGYyNTI7IiAKZD0iTTE0MDggMTQwOHEwIC0yNjEgLTEwNi41IC00NjEuNXQtMjY2LjUgLTMwNi41cTE2MCAtMTA2IDI2Ni41IC0zMDYuNXQxMDYuNSAtNDYxLjVoOTZxMTQgMCAyMyAtOXQ5IC0yM3YtNjRxMCAtMTQgLTkgLTIzdC0yMyAtOWgtMTQ3MnEtMTQgMCAtMjMgOXQtOSAyM3Y2NHEwIDE0IDkgMjN0MjMgOWg5NnEwIDI2MSAxMDYuNSA0NjEuNXQyNjYuNSAzMDYuNXEtMTYwIDEwNiAtMjY2LjUgMzA2LjV0LTEwNi41IDQ2MS41aC05NnEtMTQgMCAtMjMgOQp0LTkgMjN2NjRxMCAxNCA5IDIzdDIzIDloMTQ3MnExNCAwIDIzIC05dDkgLTIzdi02NHEwIC0xNCAtOSAtMjN0LTIzIC05aC05NnpNMTI4MCAxNDA4aC0xMDI0cTAgLTIwNiA4NSAtMzg0aDg1NHE4NSAxNzggODUgMzg0ek0xMjIzIDE5MnEtNTQgMTQxIC0xNDUuNSAyNDEuNXQtMTk0LjUgMTQyLjVoLTIzMHEtMTAzIC00MiAtMTk0LjUgLTE0Mi41dC0xNDUuNSAtMjQxLjVoOTEweiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTU4IiB1bmljb2RlPSImI3hmMjUzOyIgCmQ9Ik0xNDA4IDE0MDhxMCAtMjYxIC0xMDYuNSAtNDYxLjV0LTI2Ni41IC0zMDYuNXExNjAgLTEwNiAyNjYuNSAtMzA2LjV0MTA2LjUgLTQ2MS41aDk2cTE0IDAgMjMgLTl0OSAtMjN2LTY0cTAgLTE0IC05IC0yM3QtMjMgLTloLTE0NzJxLTE0IDAgLTIzIDl0LTkgMjN2NjRxMCAxNCA5IDIzdDIzIDloOTZxMCAyNjEgMTA2LjUgNDYxLjV0MjY2LjUgMzA2LjVxLTE2MCAxMDYgLTI2Ni41IDMwNi41dC0xMDYuNSA0NjEuNWgtOTZxLTE0IDAgLTIzIDkKdC05IDIzdjY0cTAgMTQgOSAyM3QyMyA5aDE0NzJxMTQgMCAyMyAtOXQ5IC0yM3YtNjRxMCAtMTQgLTkgLTIzdC0yMyAtOWgtOTZ6TTg3NCA3MDBxNzcgMjkgMTQ5IDkyLjV0MTI5LjUgMTUyLjV0OTIuNSAyMTB0MzUgMjUzaC0xMDI0cTAgLTEzMiAzNSAtMjUzdDkyLjUgLTIxMHQxMjkuNSAtMTUyLjV0MTQ5IC05Mi41cTE5IC03IDMwLjUgLTIzLjV0MTEuNSAtMzYuNXQtMTEuNSAtMzYuNXQtMzAuNSAtMjMuNXEtMTM3IC01MSAtMjQ0IC0xOTYKaDcwMHEtMTA3IDE0NSAtMjQ0IDE5NnEtMTkgNyAtMzAuNSAyMy41dC0xMS41IDM2LjV0MTEuNSAzNi41dDMwLjUgMjMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzU1OSIgdW5pY29kZT0iJiN4ZjI1NDsiIApkPSJNMTUwNCAtNjRxMTQgMCAyMyAtOXQ5IC0yM3YtMTI4cTAgLTE0IC05IC0yM3QtMjMgLTloLTE0NzJxLTE0IDAgLTIzIDl0LTkgMjN2MTI4cTAgMTQgOSAyM3QyMyA5aDE0NzJ6TTEzMCAwcTMgNTUgMTYgMTA3dDMwIDk1dDQ2IDg3dDUzLjUgNzZ0NjQuNSA2OS41dDY2IDYwdDcwLjUgNTV0NjYuNSA0Ny41dDY1IDQzcS00MyAyOCAtNjUgNDN0LTY2LjUgNDcuNXQtNzAuNSA1NXQtNjYgNjB0LTY0LjUgNjkuNXQtNTMuNSA3NnQtNDYgODcKdC0zMCA5NXQtMTYgMTA3aDEyNzZxLTMgLTU1IC0xNiAtMTA3dC0zMCAtOTV0LTQ2IC04N3QtNTMuNSAtNzZ0LTY0LjUgLTY5LjV0LTY2IC02MHQtNzAuNSAtNTV0LTY2LjUgLTQ3LjV0LTY1IC00M3E0MyAtMjggNjUgLTQzdDY2LjUgLTQ3LjV0NzAuNSAtNTV0NjYgLTYwdDY0LjUgLTY5LjV0NTMuNSAtNzZ0NDYgLTg3dDMwIC05NXQxNiAtMTA3aC0xMjc2ek0xNTA0IDE1MzZxMTQgMCAyMyAtOXQ5IC0yM3YtMTI4cTAgLTE0IC05IC0yM3QtMjMgLTkKaC0xNDcycS0xNCAwIC0yMyA5dC05IDIzdjEyOHEwIDE0IDkgMjN0MjMgOWgxNDcyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTYwIiB1bmljb2RlPSImI3hmMjU1OyIgCmQ9Ik03NjggMTE1MnEtNTMgMCAtOTAuNSAtMzcuNXQtMzcuNSAtOTAuNXYtMTI4aC0zMnY5M3EwIDQ4IC0zMiA4MS41dC04MCAzMy41cS00NiAwIC03OSAtMzN0LTMzIC03OXYtNDI5bC0zMiAzMHYxNzJxMCA0OCAtMzIgODEuNXQtODAgMzMuNXEtNDYgMCAtNzkgLTMzdC0zMyAtNzl2LTIyNHEwIC00NyAzNSAtODJsMzEwIC0yOTZxMzkgLTM5IDM5IC0xMDJxMCAtMjYgMTkgLTQ1dDQ1IC0xOWg2NDBxMjYgMCA0NSAxOXQxOSA0NXYyNQpxMCA0MSAxMCA3N2wxMDggNDM2cTEwIDM2IDEwIDc3djI0NnEwIDQ4IC0zMiA4MS41dC04MCAzMy41cS00NiAwIC03OSAtMzN0LTMzIC03OXYtMzJoLTMydjEyNXEwIDQwIC0yNSA3Mi41dC02NCA0MC41cS0xNCAyIC0yMyAycS00NiAwIC03OSAtMzN0LTMzIC03OXYtMTI4aC0zMnYxMjJxMCA1MSAtMzIuNSA4OS41dC04Mi41IDQzLjVxLTUgMSAtMTMgMXpNNzY4IDEyODBxODQgMCAxNDkgLTUwcTU3IDM0IDEyMyAzNHE1OSAwIDExMSAtMjcKdDg2IC03NnEyNyA3IDU5IDdxMTAwIDAgMTcwIC03MS41dDcwIC0xNzEuNXYtMjQ2cTAgLTUxIC0xMyAtMTA4bC0xMDkgLTQzNnEtNiAtMjQgLTYgLTcxcTAgLTgwIC01NiAtMTM2dC0xMzYgLTU2aC02NDBxLTg0IDAgLTEzOCA1OC41dC01NCAxNDIuNWwtMzA4IDI5NnEtNzYgNzMgLTc2IDE3NXYyMjRxMCA5OSA3MC41IDE2OS41dDE2OS41IDcwLjVxMTEgMCAxNiAtMXE2IDk1IDc1LjUgMTYwdDE2NC41IDY1cTUyIDAgOTggLTIxCnE3MiA2OSAxNzQgNjl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81NjEiIHVuaWNvZGU9IiYjeGYyNTY7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik04ODAgMTQwOHEtNDYgMCAtNzkgLTMzdC0zMyAtNzl2LTY1NmgtMzJ2NTI4cTAgNDYgLTMzIDc5dC03OSAzM3QtNzkgLTMzdC0zMyAtNzl2LTUyOHYtMjU2bC0xNTQgMjA1cS0zOCA1MSAtMTAyIDUxcS01MyAwIC05MC41IC0zNy41dC0zNy41IC05MC41cTAgLTQzIDI2IC03N2wzODQgLTUxMnEzOCAtNTEgMTAyIC01MWg2ODhxMzQgMCA2MSAyMnQzNCA1Nmw3NiA0MDVxNSAzMiA1IDU5djQ5OHEwIDQ2IC0zMyA3OXQtNzkgMzN0LTc5IC0zMwp0LTMzIC03OXYtMjcyaC0zMnY1MjhxMCA0NiAtMzMgNzl0LTc5IDMzdC03OSAtMzN0LTMzIC03OXYtNTI4aC0zMnY2NTZxMCA0NiAtMzMgNzl0LTc5IDMzek04ODAgMTUzNnE2OCAwIDEyNS41IC0zNS41dDg4LjUgLTk2LjVxMTkgNCA0MiA0cTk5IDAgMTY5LjUgLTcwLjV0NzAuNSAtMTY5LjV2LTE3cTEwNSA2IDE4MC41IC02NHQ3NS41IC0xNzV2LTQ5OHEwIC00MCAtOCAtODNsLTc2IC00MDRxLTE0IC03OSAtNzYuNSAtMTMxdC0xNDMuNSAtNTIKaC02ODhxLTYwIDAgLTExNC41IDI3LjV0LTkwLjUgNzQuNWwtMzg0IDUxMnEtNTEgNjggLTUxIDE1NHEwIDEwNiA3NSAxODF0MTgxIDc1cTc4IDAgMTI4IC0zNHY0MzRxMCA5OSA3MC41IDE2OS41dDE2OS41IDcwLjVxMjMgMCA0MiAtNHEzMSA2MSA4OC41IDk2LjV0MTI1LjUgMzUuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzU2MiIgdW5pY29kZT0iJiN4ZjI1NzsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTEwNzMgLTEyOGgtMTc3cS0xNjMgMCAtMjI2IDE0MXEtMjMgNDkgLTIzIDEwMnY1cS02MiAzMCAtOTguNSA4OC41dC0zNi41IDEyNy41cTAgMzggNSA0OGgtMjYxcS0xMDYgMCAtMTgxIDc1dC03NSAxODF0NzUgMTgxdDE4MSA3NWgxMTNsLTQ0IDE3cS03NCAyOCAtMTE5LjUgOTMuNXQtNDUuNSAxNDUuNXEwIDEwNiA3NSAxODF0MTgxIDc1cTQ2IDAgOTEgLTE3bDYyOCAtMjM5aDQwMXExMDYgMCAxODEgLTc1dDc1IC0xODF2LTY2OApxMCAtODggLTU0IC0xNTcuNXQtMTQwIC05MC41bC0zMzkgLTg1cS05MiAtMjMgLTE4NiAtMjN6TTEwMjQgNTgzbC0xNTUgLTcxbC0xNjMgLTc0cS0zMCAtMTQgLTQ4IC00MS41dC0xOCAtNjAuNXEwIC00NiAzMyAtNzl0NzkgLTMzcTI2IDAgNDYgMTBsMzM4IDE1NHEtNDkgMTAgLTgwLjUgNTB0LTMxLjUgOTB2NTV6TTEzNDQgMjcycTAgNDYgLTMzIDc5dC03OSAzM3EtMjYgMCAtNDYgLTEwbC0yOTAgLTEzMnEtMjggLTEzIC0zNyAtMTcKdC0zMC41IC0xN3QtMjkuNSAtMjMuNXQtMTYgLTI5dC04IC00MC41cTAgLTUwIDMxLjUgLTgydDgxLjUgLTMycTIwIDAgMzggOWwzNTIgMTYwcTMwIDE0IDQ4IDQxLjV0MTggNjAuNXpNMTExMiAxMDI0bC02NTAgMjQ4cS0yNCA4IC00NiA4cS01MyAwIC05MC41IC0zNy41dC0zNy41IC05MC41cTAgLTQwIDIyLjUgLTczdDU5LjUgLTQ3bDUyNiAtMjAwdi02NGgtNjQwcS01MyAwIC05MC41IC0zNy41dC0zNy41IC05MC41dDM3LjUgLTkwLjUKdDkwLjUgLTM3LjVoNTM1bDIzMyAxMDZ2MTk4cTAgNjMgNDYgMTA2bDExMSAxMDJoLTY5ek0xMDczIDBxODIgMCAxNTUgMTlsMzM5IDg1cTQzIDExIDcwIDQ1LjV0MjcgNzguNXY2NjhxMCA1MyAtMzcuNSA5MC41dC05MC41IDM3LjVoLTMwOGwtMTM2IC0xMjZxLTM2IC0zMyAtMzYgLTgydi0yOTZxMCAtNDYgMzMgLTc3dDc5IC0zMXQ3OSAzNXQzMyA4MXYyMDhoMzJ2LTIwOHEwIC03MCAtNTcgLTExNHE1MiAtOCA4Ni41IC00OC41dDM0LjUgLTkzLjUKcTAgLTQyIC0yMyAtNzh0LTYxIC01M2wtMzEwIC0xNDFoOTF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81NjMiIHVuaWNvZGU9IiYjeGYyNTg7IiBob3Jpei1hZHYteD0iMjA0OCIgCmQ9Ik0xMTUxIDE1MzZxNjEgMCAxMTYgLTI4dDkxIC03N2w1NzIgLTc4MXExMTggLTE1OSAxMTggLTM1OXYtMzU1cTAgLTgwIC01NiAtMTM2dC0xMzYgLTU2aC0zODRxLTgwIDAgLTEzNiA1NnQtNTYgMTM2djE3N2wtMjg2IDE0M2gtNTQ2cS04MCAwIC0xMzYgNTZ0LTU2IDEzNnYzMnEwIDExOSA4NC41IDIwMy41dDIwMy41IDg0LjVoNDIwbDQyIDEyOGgtNjg2cS0xMDAgMCAtMTczLjUgNjcuNXQtODEuNSAxNjYuNXEtNjUgNzkgLTY1IDE4MnYzMgpxMCA4MCA1NiAxMzZ0MTM2IDU2aDk1OXpNMTkyMCAtNjR2MzU1cTAgMTU3IC05MyAyODRsLTU3MyA3ODFxLTM5IDUyIC0xMDMgNTJoLTk1OXEtMjYgMCAtNDUgLTE5dC0xOSAtNDVxMCAtMzIgMS41IC00OS41dDkuNSAtNDAuNXQyNSAtNDNxMTAgMzEgMzUuNSA1MHQ1Ni41IDE5aDgzMnYtMzJoLTgzMnEtMjYgMCAtNDUgLTE5dC0xOSAtNDVxMCAtNDQgMyAtNThxOCAtNDQgNDQgLTczdDgxIC0yOWg2NDBoOTFxNDAgMCA2OCAtMjh0MjggLTY4CnEwIC0xNSAtNSAtMzBsLTY0IC0xOTJxLTEwIC0yOSAtMzUgLTQ3LjV0LTU2IC0xOC41aC00NDNxLTY2IDAgLTExMyAtNDd0LTQ3IC0xMTN2LTMycTAgLTI2IDE5IC00NXQ0NSAtMTloNTYxcTE2IDAgMjkgLTdsMzE3IC0xNThxMjQgLTEzIDM4LjUgLTM2dDE0LjUgLTUwdi0xOTdxMCAtMjYgMTkgLTQ1dDQ1IC0xOWgzODRxMjYgMCA0NSAxOXQxOSA0NXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzU2NCIgdW5pY29kZT0iJiN4ZjI1OTsiIGhvcml6LWFkdi14PSIyMDQ4IiAKZD0iTTQ1OSAtMjU2cS03NyAwIC0xMzcuNSA0Ny41dC03OS41IDEyMi41bC0xMDEgNDAxcS0xMyA1NyAtMTMgMTA4cTAgNDUgLTUgNjdsLTExNiA0NzdxLTcgMjcgLTcgNTdxMCA5MyA2MiAxNjF0MTU1IDc4cTE3IDg1IDgyLjUgMTM5dDE1Mi41IDU0cTgzIDAgMTQ4IC01MS41dDg1IC0xMzIuNWw4MyAtMzQ4bDEwMyA0MjhxMjAgODEgODUgMTMyLjV0MTQ4IDUxLjVxODkgMCAxNTUuNSAtNTcuNXQ4MC41IC0xNDQuNXE5MiAtMTAgMTUyIC03OQp0NjAgLTE2MnEwIC0yNCAtNyAtNTlsLTEyMyAtNTEycTEwIDcgMzcuNSAyOC41dDM4LjUgMjkuNXQzNSAyM3Q0MSAyMC41dDQxLjUgMTF0NDkuNSA1LjVxMTA1IDAgMTgwIC03NHQ3NSAtMTc5cTAgLTYyIC0yOC41IC0xMTh0LTc4LjUgLTk0bC01MDcgLTM4MHEtNjggLTUxIC0xNTMgLTUxaC02OTR6TTExMDQgMTQwOHEtMzggMCAtNjguNSAtMjR0LTM5LjUgLTYybC0xNjQgLTY4MmgtMTI3bC0xNDUgNjAycS05IDM4IC0zOS41IDYydC02OC41IDI0CnEtNDggMCAtODAgLTMzdC0zMiAtODBxMCAtMTUgMyAtMjhsMTMyIC01NDdoLTI2bC05OSA0MDhxLTkgMzcgLTQwIDYyLjV0LTY5IDI1LjVxLTQ3IDAgLTgwIC0zM3QtMzMgLTc5cTAgLTE0IDMgLTI2bDExNiAtNDc4cTcgLTI4IDkgLTg2dDEwIC04OGwxMDAgLTQwMXE4IC0zMiAzNCAtNTIuNXQ1OSAtMjAuNWg2OTRxNDIgMCA3NiAyNmw1MDcgMzc5cTU2IDQzIDU2IDExMHEwIDUyIC0zNy41IDg4LjV0LTg5LjUgMzYuNXEtNDMgMCAtNzcgLTI2CmwtMzA3IC0yMzB2MjI3cTAgNCAzMiAxMzh0NjggMjgydDM5IDE2MXE0IDE4IDQgMjlxMCA0NyAtMzIgODF0LTc5IDM0cS0zOSAwIC02OS41IC0yNHQtMzkuNSAtNjJsLTExNiAtNDgyaC0yNmwxNTAgNjI0cTMgMTQgMyAyOHEwIDQ4IC0zMS41IDgydC03OS41IDM0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTY1IiB1bmljb2RlPSImI3hmMjVhOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNNjQwIDE0MDhxLTUzIDAgLTkwLjUgLTM3LjV0LTM3LjUgLTkwLjV2LTUxMnYtMzg0bC0xNTEgMjAycS00MSA1NCAtMTA3IDU0cS01MiAwIC04OSAtMzh0LTM3IC05MHEwIC00MyAyNiAtNzdsMzg0IC01MTJxMzggLTUxIDEwMiAtNTFoNzE4cTIyIDAgMzkuNSAxMy41dDIyLjUgMzQuNWw5MiAzNjhxMjQgOTYgMjQgMTk0djIxN3EwIDQxIC0yOCA3MXQtNjggMzB0LTY4IC0yOHQtMjggLTY4aC0zMnY2MXEwIDQ4IC0zMiA4MS41dC04MCAzMy41CnEtNDYgMCAtNzkgLTMzdC0zMyAtNzl2LTY0aC0zMnY5MHEwIDU1IC0zNyA5NC41dC05MSAzOS41cS01MyAwIC05MC41IC0zNy41dC0zNy41IC05MC41di05NmgtMzJ2NTcwcTAgNTUgLTM3IDk0LjV0LTkxIDM5LjV6TTY0MCAxNTM2cTEwNyAwIDE4MS41IC03Ny41dDc0LjUgLTE4NC41di0yMjBxMjIgMiAzMiAycTk5IDAgMTczIC02OXE0NyAyMSA5OSAyMXExMTMgMCAxODQgLTg3cTI3IDcgNTYgN3E5NCAwIDE1OSAtNjcuNXQ2NSAtMTYxLjUKdi0yMTdxMCAtMTE2IC0yOCAtMjI1bC05MiAtMzY4cS0xNiAtNjQgLTY4IC0xMDQuNXQtMTE4IC00MC41aC03MThxLTYwIDAgLTExNC41IDI3LjV0LTkwLjUgNzQuNWwtMzg0IDUxMnEtNTEgNjggLTUxIDE1NHEwIDEwNSA3NC41IDE4MC41dDE3OS41IDc1LjVxNzEgMCAxMzAgLTM1djU0N3EwIDEwNiA3NSAxODF0MTgxIDc1ek03NjggMTI4djM4NGgtMzJ2LTM4NGgzMnpNMTAyNCAxMjh2Mzg0aC0zMnYtMzg0aDMyek0xMjgwIDEyOHYzODRoLTMyCnYtMzg0aDMyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTY2IiB1bmljb2RlPSImI3hmMjViOyIgCmQ9Ik0xMjg4IDg4OXE2MCAwIDEwNyAtMjNxMTQxIC02MyAxNDEgLTIyNnYtMTc3cTAgLTk0IC0yMyAtMTg2bC04NSAtMzM5cS0yMSAtODYgLTkwLjUgLTE0MHQtMTU3LjUgLTU0aC02NjhxLTEwNiAwIC0xODEgNzV0LTc1IDE4MXY0MDFsLTIzOSA2MjhxLTE3IDQ1IC0xNyA5MXEwIDEwNiA3NSAxODF0MTgxIDc1cTgwIDAgMTQ1LjUgLTQ1LjV0OTMuNSAtMTE5LjVsMTcgLTQ0djExM3EwIDEwNiA3NSAxODF0MTgxIDc1dDE4MSAtNzV0NzUgLTE4MQp2LTI2MXEyNyA1IDQ4IDVxNjkgMCAxMjcuNSAtMzYuNXQ4OC41IC05OC41ek0xMDcyIDg5NnEtMzMgMCAtNjAuNSAtMTh0LTQxLjUgLTQ4bC03NCAtMTYzbC03MSAtMTU1aDU1cTUwIDAgOTAgLTMxLjV0NTAgLTgwLjVsMTU0IDMzOHExMCAyMCAxMCA0NnEwIDQ2IC0zMyA3OXQtNzkgMzN6TTEyOTMgNzYxcS0yMiAwIC00MC41IC04dC0yOSAtMTZ0LTIzLjUgLTI5LjV0LTE3IC0zMC41dC0xNyAtMzdsLTEzMiAtMjkwcS0xMCAtMjAgLTEwIC00NgpxMCAtNDYgMzMgLTc5dDc5IC0zM3EzMyAwIDYwLjUgMTh0NDEuNSA0OGwxNjAgMzUycTkgMTggOSAzOHEwIDUwIC0zMiA4MS41dC04MiAzMS41ek0xMjggMTEyMHEwIC0yMiA4IC00NmwyNDggLTY1MHYtNjlsMTAyIDExMXE0MyA0NiAxMDYgNDZoMTk4bDEwNiAyMzN2NTM1cTAgNTMgLTM3LjUgOTAuNXQtOTAuNSAzNy41dC05MC41IC0zNy41dC0zNy41IC05MC41di02NDBoLTY0bC0yMDAgNTI2cS0xNCAzNyAtNDcgNTkuNXQtNzMgMjIuNQpxLTUzIDAgLTkwLjUgLTM3LjV0LTM3LjUgLTkwLjV6TTExODAgLTEyOHE0NCAwIDc4LjUgMjd0NDUuNSA3MGw4NSAzMzlxMTkgNzMgMTkgMTU1djkxbC0xNDEgLTMxMHEtMTcgLTM4IC01MyAtNjF0LTc4IC0yM3EtNTMgMCAtOTMuNSAzNC41dC00OC41IDg2LjVxLTQ0IC01NyAtMTE0IC01N2gtMjA4djMyaDIwOHE0NiAwIDgxIDMzdDM1IDc5dC0zMSA3OXQtNzcgMzNoLTI5NnEtNDkgMCAtODIgLTM2bC0xMjYgLTEzNnYtMzA4CnEwIC01MyAzNy41IC05MC41dDkwLjUgLTM3LjVoNjY4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTY3IiB1bmljb2RlPSImI3hmMjVjOyIgaG9yaXotYWR2LXg9IjE5NzMiIApkPSJNODU3IDk5MnYtMTE3cTAgLTEzIC05LjUgLTIydC0yMi41IC05aC0yOTh2LTgxMnEwIC0xMyAtOSAtMjIuNXQtMjIgLTkuNWgtMTM1cS0xMyAwIC0yMi41IDl0LTkuNSAyM3Y4MTJoLTI5N3EtMTMgMCAtMjIuNSA5dC05LjUgMjJ2MTE3cTAgMTQgOSAyM3QyMyA5aDc5M3ExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV6TTE4OTUgOTk1bDc3IC05NjFxMSAtMTMgLTggLTI0cS0xMCAtMTAgLTIzIC0xMGgtMTM0cS0xMiAwIC0yMSA4LjUKdC0xMCAyMC41bC00NiA1ODhsLTE4OSAtNDI1cS04IC0xOSAtMjkgLTE5aC0xMjBxLTIwIDAgLTI5IDE5bC0xODggNDI3bC00NSAtNTkwcS0xIC0xMiAtMTAgLTIwLjV0LTIxIC04LjVoLTEzNXEtMTMgMCAtMjMgMTBxLTkgMTAgLTkgMjRsNzggOTYxcTEgMTIgMTAgMjAuNXQyMSA4LjVoMTQycTIwIDAgMjkgLTE5bDIyMCAtNTIwcTEwIC0yNCAyMCAtNTFxMyA3IDkuNSAyNC41dDEwLjUgMjYuNWwyMjEgNTIwcTkgMTkgMjkgMTloMTQxCnExMyAwIDIyIC04LjV0MTAgLTIwLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81NjgiIHVuaWNvZGU9IiYjeGYyNWQ7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xMDQyIDgzM3EwIDg4IC02MCAxMjFxLTMzIDE4IC0xMTcgMThoLTEyM3YtMjgxaDE2MnE2NiAwIDEwMiAzN3QzNiAxMDV6TTEwOTQgNTQ4bDIwNSAtMzczcTggLTE3IC0xIC0zMXEtOCAtMTYgLTI3IC0xNmgtMTUycS0yMCAwIC0yOCAxN2wtMTk0IDM2NWgtMTU1di0zNTBxMCAtMTQgLTkgLTIzdC0yMyAtOWgtMTM0cS0xNCAwIC0yMyA5dC05IDIzdjk2MHEwIDE0IDkgMjN0MjMgOWgyOTRxMTI4IDAgMTkwIC0yNHE4NSAtMzEgMTM0IC0xMDkKdDQ5IC0xODBxMCAtOTIgLTQyLjUgLTE2NS41dC0xMTUuNSAtMTA5LjVxNiAtMTAgOSAtMTZ6TTg5NiAxMzc2cS0xNTAgMCAtMjg2IC01OC41dC0yMzQuNSAtMTU3dC0xNTcgLTIzNC41dC01OC41IC0yODZ0NTguNSAtMjg2dDE1NyAtMjM0LjV0MjM0LjUgLTE1N3QyODYgLTU4LjV0Mjg2IDU4LjV0MjM0LjUgMTU3dDE1NyAyMzQuNXQ1OC41IDI4NnQtNTguNSAyODZ0LTE1NyAyMzQuNXQtMjM0LjUgMTU3dC0yODYgNTguNXpNMTc5MiA2NDAKcTAgLTE4MiAtNzEgLTM0OHQtMTkxIC0yODZ0LTI4NiAtMTkxdC0zNDggLTcxdC0zNDggNzF0LTI4NiAxOTF0LTE5MSAyODZ0LTcxIDM0OHQ3MSAzNDh0MTkxIDI4NnQyODYgMTkxdDM0OCA3MXQzNDggLTcxdDI4NiAtMTkxdDE5MSAtMjg2dDcxIC0zNDh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81NjkiIHVuaWNvZGU9IiYjeGYyNWU7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik02MDUgMzAzcTE1MyAwIDI1NyAxMDRxMTQgMTggMyAzNmwtNDUgODJxLTYgMTMgLTI0IDE3cS0xNiAyIC0yNyAtMTFsLTQgLTNxLTQgLTQgLTExLjUgLTEwdC0xNy41IC0xMy41dC0yMy41IC0xNC41dC0yOC41IC0xM3QtMzMuNSAtOS41dC0zNy41IC0zLjVxLTc2IDAgLTEyNSA1MHQtNDkgMTI3cTAgNzYgNDggMTI1LjV0MTIyIDQ5LjVxMzcgMCA3MS41IC0xNHQ1MC41IC0yOGwxNiAtMTRxMTEgLTExIDI2IC0xMHExNiAyIDI0IDE0bDUzIDc4CnExMyAyMCAtMiAzOXEtMyA0IC0xMSAxMnQtMzAgMjMuNXQtNDguNSAyOHQtNjcuNSAyMi41dC04NiAxMHEtMTQ4IDAgLTI0NiAtOTYuNXQtOTggLTI0MC41cTAgLTE0NiA5NyAtMjQxLjV0MjQ3IC05NS41ek0xMjM1IDMwM3ExNTMgMCAyNTcgMTA0cTE0IDE4IDQgMzZsLTQ1IDgycS04IDE0IC0yNSAxN3EtMTYgMiAtMjcgLTExbC00IC0zcS00IC00IC0xMS41IC0xMHQtMTcuNSAtMTMuNXQtMjMuNSAtMTQuNXQtMjguNSAtMTN0LTMzLjUgLTkuNQp0LTM3LjUgLTMuNXEtNzYgMCAtMTI1IDUwdC00OSAxMjdxMCA3NiA0OCAxMjUuNXQxMjIgNDkuNXEzNyAwIDcxLjUgLTE0dDUwLjUgLTI4bDE2IC0xNHExMSAtMTEgMjYgLTEwcTE2IDIgMjQgMTRsNTMgNzhxMTMgMjAgLTIgMzlxLTMgNCAtMTEgMTJ0LTMwIDIzLjV0LTQ4LjUgMjh0LTY3LjUgMjIuNXQtODYgMTBxLTE0NyAwIC0yNDUuNSAtOTYuNXQtOTguNSAtMjQwLjVxMCAtMTQ2IDk3IC0yNDEuNXQyNDcgLTk1LjV6TTg5NiAxMzc2CnEtMTUwIDAgLTI4NiAtNTguNXQtMjM0LjUgLTE1N3QtMTU3IC0yMzQuNXQtNTguNSAtMjg2dDU4LjUgLTI4NnQxNTcgLTIzNC41dDIzNC41IC0xNTd0Mjg2IC01OC41dDI4NiA1OC41dDIzNC41IDE1N3QxNTcgMjM0LjV0NTguNSAyODZ0LTU4LjUgMjg2dC0xNTcgMjM0LjV0LTIzNC41IDE1N3QtMjg2IDU4LjV6TTg5NiAxNTM2cTE4MiAwIDM0OCAtNzF0Mjg2IC0xOTF0MTkxIC0yODZ0NzEgLTM0OHQtNzEgLTM0OHQtMTkxIC0yODZ0LTI4NiAtMTkxCnQtMzQ4IC03MXQtMzQ4IDcxdC0yODYgMTkxdC0xOTEgMjg2dC03MSAzNDh0NzEgMzQ4dDE5MSAyODZ0Mjg2IDE5MXQzNDggNzF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImYyNjAiIHVuaWNvZGU9IiYjeGYyNjA7IiBob3Jpei1hZHYteD0iMjA0OCIgCmQ9Ik03MzYgNzM2bDM4NCAtMzg0bC0zODQgLTM4NGwtNjcyIDY3Mmw2NzIgNjcybDE2OCAtMTY4bC05NiAtOTZsLTcyIDcybC00ODAgLTQ4MGw0ODAgLTQ4MGwxOTMgMTkzbC0yODkgMjg3ek0xMzEyIDEzMTJsNjcyIC02NzJsLTY3MiAtNjcybC0xNjggMTY4bDk2IDk2bDcyIC03Mmw0ODAgNDgwbC00ODAgNDgwbC0xOTMgLTE5M2wyODkgLTI4N2wtOTYgLTk2bC0zODQgMzg0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJmMjYxIiB1bmljb2RlPSImI3hmMjYxOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNNzE3IDE4MmwyNzEgMjcxbC0yNzkgMjc5bC04OCAtODhsMTkyIC0xOTFsLTk2IC05NmwtMjc5IDI3OWwyNzkgMjc5bDQwIC00MGw4NyA4N2wtMTI3IDEyOGwtNDU0IC00NTR6TTEwNzUgMTkwbDQ1NCA0NTRsLTQ1NCA0NTRsLTI3MSAtMjcxbDI3OSAtMjc5bDg4IDg4bC0xOTIgMTkxbDk2IDk2bDI3OSAtMjc5bC0yNzkgLTI3OWwtNDAgNDBsLTg3IC04OHpNMTc5MiA2NDBxMCAtMTgyIC03MSAtMzQ4dC0xOTEgLTI4NnQtMjg2IC0xOTEKdC0zNDggLTcxdC0zNDggNzF0LTI4NiAxOTF0LTE5MSAyODZ0LTcxIDM0OHQ3MSAzNDh0MTkxIDI4NnQyODYgMTkxdDM0OCA3MXQzNDggLTcxdDI4NiAtMTkxdDE5MSAtMjg2dDcxIC0zNDh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81NzIiIHVuaWNvZGU9IiYjeGYyNjI7IiBob3Jpei1hZHYteD0iMjMwNCIgCmQ9Ik02NTEgNTM5cTAgLTM5IC0yNy41IC02Ni41dC02NS41IC0yNy41cS0zOSAwIC02Ni41IDI3LjV0LTI3LjUgNjYuNXEwIDM4IDI3LjUgNjUuNXQ2Ni41IDI3LjVxMzggMCA2NS41IC0yNy41dDI3LjUgLTY1LjV6TTE4MDUgNTQwcTAgLTM5IC0yNy41IC02Ni41dC02Ni41IC0yNy41dC02Ni41IDI3LjV0LTI3LjUgNjYuNXQyNy41IDY2dDY2LjUgMjd0NjYuNSAtMjd0MjcuNSAtNjZ6TTc2NSA1MzlxMCA3OSAtNTYuNSAxMzZ0LTEzNi41IDU3CnQtMTM2LjUgLTU2LjV0LTU2LjUgLTEzNi41dDU2LjUgLTEzNi41dDEzNi41IC01Ni41dDEzNi41IDU2LjV0NTYuNSAxMzYuNXpNMTkxOCA1NDBxMCA4MCAtNTYuNSAxMzYuNXQtMTM2LjUgNTYuNXEtNzkgMCAtMTM2IC01Ni41dC01NyAtMTM2LjV0NTYuNSAtMTM2LjV0MTM2LjUgLTU2LjV0MTM2LjUgNTYuNXQ1Ni41IDEzNi41ek04NTAgNTM5cTAgLTExNiAtODEuNSAtMTk3LjV0LTE5Ni41IC04MS41cS0xMTYgMCAtMTk3LjUgODJ0LTgxLjUgMTk3CnQ4MiAxOTYuNXQxOTcgODEuNXQxOTYuNSAtODEuNXQ4MS41IC0xOTYuNXpNMjAwNCA1NDBxMCAtMTE1IC04MS41IC0xOTYuNXQtMTk3LjUgLTgxLjVxLTExNSAwIC0xOTYuNSA4MS41dC04MS41IDE5Ni41dDgxLjUgMTk2LjV0MTk2LjUgODEuNXExMTYgMCAxOTcuNSAtODEuNXQ4MS41IC0xOTYuNXpNMTA0MCA1MzdxMCAxOTEgLTEzNS41IDMyNi41dC0zMjYuNSAxMzUuNXEtMTI1IDAgLTIzMSAtNjJ0LTE2OCAtMTY4LjV0LTYyIC0yMzEuNQp0NjIgLTIzMS41dDE2OCAtMTY4LjV0MjMxIC02MnExOTEgMCAzMjYuNSAxMzUuNXQxMzUuNSAzMjYuNXpNMTcwOCAxMTEwcS0yNTQgMTExIC01NTYgMTExcS0zMTkgMCAtNTczIC0xMTBxMTE3IDAgMjIzIC00NS41dDE4Mi41IC0xMjIuNXQxMjIgLTE4M3Q0NS41IC0yMjNxMCAxMTUgNDMuNSAyMTkuNXQxMTggMTgwLjV0MTc3LjUgMTIzdDIxNyA1MHpNMjE4NyA1MzdxMCAxOTEgLTEzNSAzMjYuNXQtMzI2IDEzNS41dC0zMjYuNSAtMTM1LjUKdC0xMzUuNSAtMzI2LjV0MTM1LjUgLTMyNi41dDMyNi41IC0xMzUuNXQzMjYgMTM1LjV0MTM1IDMyNi41ek0xOTIxIDExMDNoMzgzcS00NCAtNTEgLTc1IC0xMTQuNXQtNDAgLTExNC41cTExMCAtMTUxIDExMCAtMzM3cTAgLTE1NiAtNzcgLTI4OHQtMjA5IC0yMDguNXQtMjg3IC03Ni41cS0xMzMgMCAtMjQ5IDU2dC0xOTYgMTU1cS00NyAtNTYgLTEyOSAtMTc5cS0xMSAyMiAtNTMuNSA4Mi41dC03NC41IDk3LjUKcS04MCAtOTkgLTE5Ni41IC0xNTUuNXQtMjQ5LjUgLTU2LjVxLTE1NSAwIC0yODcgNzYuNXQtMjA5IDIwOC41dC03NyAyODhxMCAxODYgMTEwIDMzN3EtOSA1MSAtNDAgMTE0LjV0LTc1IDExNC41aDM2NXExNDkgMTAwIDM1NSAxNTYuNXQ0MzIgNTYuNXEyMjQgMCA0MjEgLTU2dDM0OCAtMTU3eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJmMjYzIiB1bmljb2RlPSImI3hmMjYzOyIgaG9yaXotYWR2LXg9IjEyODAiIApkPSJNNjQwIDYyOXEtMTg4IDAgLTMyMSAxMzN0LTEzMyAzMjBxMCAxODggMTMzIDMyMXQzMjEgMTMzdDMyMSAtMTMzdDEzMyAtMzIxcTAgLTE4NyAtMTMzIC0zMjB0LTMyMSAtMTMzek02NDAgMTMwNnEtOTIgMCAtMTU3LjUgLTY1LjV0LTY1LjUgLTE1OC41cTAgLTkyIDY1LjUgLTE1Ny41dDE1Ny41IC02NS41dDE1Ny41IDY1LjV0NjUuNSAxNTcuNXEwIDkzIC02NS41IDE1OC41dC0xNTcuNSA2NS41ek0xMTYzIDU3NHExMyAtMjcgMTUgLTQ5LjUKdC00LjUgLTQwLjV0LTI2LjUgLTM4LjV0LTQyLjUgLTM3dC02MS41IC00MS41cS0xMTUgLTczIC0zMTUgLTk0bDczIC03MmwyNjcgLTI2N3EzMCAtMzEgMzAgLTc0dC0zMCAtNzNsLTEyIC0xM3EtMzEgLTMwIC03NCAtMzB0LTc0IDMwcS02NyA2OCAtMjY3IDI2OGwtMjY3IC0yNjhxLTMxIC0zMCAtNzQgLTMwdC03MyAzMGwtMTIgMTNxLTMxIDMwIC0zMSA3M3QzMSA3NGwyNjcgMjY3bDcyIDcycS0yMDMgMjEgLTMxNyA5NApxLTM5IDI1IC02MS41IDQxLjV0LTQyLjUgMzd0LTI2LjUgMzguNXQtNC41IDQwLjV0MTUgNDkuNXExMCAyMCAyOCAzNXQ0MiAyMnQ1NiAtMnQ2NSAtMzVxNSAtNCAxNSAtMTF0NDMgLTI0LjV0NjkgLTMwLjV0OTIgLTI0dDExMyAtMTFxOTEgMCAxNzQgMjUuNXQxMjAgNTAuNWwzOCAyNXEzMyAyNiA2NSAzNXQ1NiAydDQyIC0yMnQyOCAtMzV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81NzQiIHVuaWNvZGU9IiYjeGYyNjQ7IiAKZD0iTTkyNyA5NTZxMCAtNjYgLTQ2LjUgLTExMi41dC0xMTIuNSAtNDYuNXQtMTEyLjUgNDYuNXQtNDYuNSAxMTIuNXQ0Ni41IDExMi41dDExMi41IDQ2LjV0MTEyLjUgLTQ2LjV0NDYuNSAtMTEyLjV6TTExNDEgNTkzcS0xMCAyMCAtMjggMzJ0LTQ3LjUgOS41dC02MC41IC0yNy41cS0xMCAtOCAtMjkgLTIwdC04MSAtMzJ0LTEyNyAtMjB0LTEyNCAxOHQtODYgMzZsLTI3IDE4cS0zMSAyNSAtNjAuNSAyNy41dC00Ny41IC05LjV0LTI4IC0zMgpxLTIyIC00NSAtMiAtNzQuNXQ4NyAtNzMuNXE4MyAtNTMgMjI2IC02N2wtNTEgLTUycS0xNDIgLTE0MiAtMTkxIC0xOTBxLTIyIC0yMiAtMjIgLTUyLjV0MjIgLTUyLjVsOSAtOXEyMiAtMjIgNTIuNSAtMjJ0NTIuNSAyMmwxOTEgMTkxcTExNCAtMTE1IDE5MSAtMTkxcTIyIC0yMiA1Mi41IC0yMnQ1Mi41IDIybDkgOXEyMiAyMiAyMiA1Mi41dC0yMiA1Mi41bC0xOTEgMTkwbC01MiA1MnExNDEgMTQgMjI1IDY3cTY3IDQ0IDg3IDczLjV0LTIgNzQuNQp6TTEwOTIgOTU2cTAgMTM0IC05NSAyMjl0LTIyOSA5NXQtMjI5IC05NXQtOTUgLTIyOXQ5NSAtMjI5dDIyOSAtOTV0MjI5IDk1dDk1IDIyOXpNMTUzNiAxMTIwdi05NjBxMCAtMTE5IC04NC41IC0yMDMuNXQtMjAzLjUgLTg0LjVoLTk2MHEtMTE5IDAgLTIwMy41IDg0LjV0LTg0LjUgMjAzLjV2OTYwcTAgMTE5IDg0LjUgMjAzLjV0MjAzLjUgODQuNWg5NjBxMTE5IDAgMjAzLjUgLTg0LjV0ODQuNSAtMjAzLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81NzUiIHVuaWNvZGU9IiYjeGYyNjU7IiBob3Jpei1hZHYteD0iMTcyMCIgCmQ9Ik0xNTY1IDE0MDhxNjUgMCAxMTAgLTQ1LjV0NDUgLTExMC41di01MTlxMCAtMTc2IC02OCAtMzM2dC0xODIuNSAtMjc1dC0yNzQgLTE4Mi41dC0zMzQuNSAtNjcuNXEtMTc2IDAgLTMzNS41IDY3LjV0LTI3NC41IDE4Mi41dC0xODMgMjc1dC02OCAzMzZ2NTE5cTAgNjQgNDYgMTEwdDExMCA0NmgxNDA5ek04NjEgMzQ0cTQ3IDAgODIgMzNsNDA0IDM4OHEzNyAzNSAzNyA4NXEwIDQ5IC0zNC41IDgzLjV0LTgzLjUgMzQuNXEtNDcgMCAtODIgLTMzCmwtMzIzIC0zMTBsLTMyMyAzMTBxLTM1IDMzIC04MSAzM3EtNDkgMCAtODMuNSAtMzQuNXQtMzQuNSAtODMuNXEwIC01MSAzNiAtODVsNDA1IC0zODhxMzMgLTMzIDgxIC0zM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzU3NiIgdW5pY29kZT0iJiN4ZjI2NjsiIGhvcml6LWFkdi14PSIyMzA0IiAKZD0iTTE0OTQgLTEwM2wtMjk1IDY5NXEtMjUgLTQ5IC0xNTguNSAtMzA1LjV0LTE5OC41IC0zODkuNXEtMSAtMSAtMjcuNSAtMC41dC0yNi41IDEuNXEtODIgMTkzIC0yNTUuNSA1ODd0LTI1OS41IDU5NnEtMjEgNTAgLTY2LjUgMTA3LjV0LTEwMy41IDEwMC41dC0xMDIgNDNxMCA1IC0wLjUgMjR0LTAuNSAyN2g1ODN2LTUwcS0zOSAtMiAtNzkuNSAtMTZ0LTY2LjUgLTQzdC0xMCAtNjRxMjYgLTU5IDIxNi41IC00OTl0MjM1LjUgLTU0MApxMzEgNjEgMTQwIDI2Ni41dDEzMSAyNDcuNXEtMTkgMzkgLTEyNiAyODF0LTEzNiAyOTVxLTM4IDY5IC0yMDEgNzF2NTBsNTEzIC0xdi00N3EtNjAgLTIgLTkzLjUgLTI1dC0xMi41IC02OXEzMyAtNzAgODcgLTE4OS41dDg2IC0xODcuNXExMTAgMjE0IDE3MyAzNjNxMjQgNTUgLTEwIDc5LjV0LTEyOSAyNi41cTEgNyAxIDI1djI0cTY0IDAgMTcwLjUgMC41dDE4MCAxdDkyLjUgMC41di00OXEtNjIgLTIgLTExOSAtMzN0LTkwIC04MQpsLTIxMyAtNDQycTEzIC0zMyAxMjcuNSAtMjkwdDEyMS41IC0yNzRsNDQxIDEwMTdxLTE0IDM4IC00OS41IDYyLjV0LTY1IDMxLjV0LTU1LjUgOHY1MGw0NjAgLTRsMSAtMmwtMSAtNDRxLTEzOSAtNCAtMjAxIC0xNDVxLTUyNiAtMTIxNiAtNTU5IC0xMjkxaC00OXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzU3NyIgdW5pY29kZT0iJiN4ZjI2NzsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTk0OSA2NDNxMCAtMjYgLTE2LjUgLTQ1dC00MS41IC0xOXEtMjYgMCAtNDUgMTYuNXQtMTkgNDEuNXEwIDI2IDE3IDQ1dDQyIDE5dDQ0IC0xNi41dDE5IC00MS41ek05NjQgNTg1bDM1MCA1ODFxLTkgLTggLTY3LjUgLTYyLjV0LTEyNS41IC0xMTYuNXQtMTM2LjUgLTEyN3QtMTE3IC0xMTAuNXQtNTAuNSAtNTEuNWwtMzQ5IC01ODBxNyA3IDY3IDYydDEyNiAxMTYuNXQxMzYgMTI3dDExNyAxMTF0NTAgNTAuNXpNMTYxMSA2NDAKcTAgLTIwMSAtMTA0IC0zNzFxLTMgMiAtMTcgMTF0LTI2LjUgMTYuNXQtMTYuNSA3LjVxLTEzIDAgLTEzIC0xM3EwIC0xMCA1OSAtNDRxLTc0IC0xMTIgLTE4NC41IC0xOTAuNXQtMjQxLjUgLTExMC41bC0xNiA2N3EtMSAxMCAtMTUgMTBxLTUgMCAtOCAtNS41dC0yIC05LjVsMTYgLTY4cS03MiAtMTUgLTE0NiAtMTVxLTE5OSAwIC0zNzIgMTA1cTEgMiAxMyAyMC41dDIxLjUgMzMuNXQ5LjUgMTlxMCAxMyAtMTMgMTNxLTYgMCAtMTcgLTE0LjUKdC0yMi41IC0zNC41dC0xMy41IC0yM3EtMTEzIDc1IC0xOTIgMTg3LjV0LTExMCAyNDQuNWw2OSAxNXExMCAzIDEwIDE1cTAgNSAtNS41IDh0LTEwLjUgMmwtNjggLTE1cS0xNCA3MiAtMTQgMTM5cTAgMjA2IDEwOSAzNzlxMiAtMSAxOC41IC0xMnQzMCAtMTl0MTcuNSAtOHExMyAwIDEzIDEycTAgNiAtMTIuNSAxNS41dC0zMi41IDIxLjVsLTIwIDEycTc3IDExMiAxODkgMTg5dDI0NCAxMDdsMTUgLTY3cTIgLTEwIDE1IC0xMHE1IDAgOCA1LjUKdDIgMTAuNWwtMTUgNjZxNzEgMTMgMTM0IDEzcTIwNCAwIDM3OSAtMTA5cS0zOSAtNTYgLTM5IC02NXEwIC0xMyAxMiAtMTNxMTEgMCA0OCA2NHExMTEgLTc1IDE4Ny41IC0xODZ0MTA3LjUgLTI0MWwtNTYgLTEycS0xMCAtMiAtMTAgLTE2cTAgLTUgNS41IC04dDkuNSAtMmw1NyAxM3ExNCAtNzIgMTQgLTE0MHpNMTY5NiA2NDBxMCAxNjMgLTYzLjUgMzExdC0xNzAuNSAyNTV0LTI1NSAxNzAuNXQtMzExIDYzLjV0LTMxMSAtNjMuNQp0LTI1NSAtMTcwLjV0LTE3MC41IC0yNTV0LTYzLjUgLTMxMXQ2My41IC0zMTF0MTcwLjUgLTI1NXQyNTUgLTE3MC41dDMxMSAtNjMuNXQzMTEgNjMuNXQyNTUgMTcwLjV0MTcwLjUgMjU1dDYzLjUgMzExek0xNzkyIDY0MHEwIC0xODIgLTcxIC0zNDh0LTE5MSAtMjg2dC0yODYgLTE5MXQtMzQ4IC03MXQtMzQ4IDcxdC0yODYgMTkxdC0xOTEgMjg2dC03MSAzNDh0NzEgMzQ4dDE5MSAyODZ0Mjg2IDE5MXQzNDggNzF0MzQ4IC03MXQyODYgLTE5MQp0MTkxIC0yODZ0NzEgLTM0OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzU3OCIgdW5pY29kZT0iJiN4ZjI2ODsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTg5MyAxNTM2cTI0MCAyIDQ1MSAtMTIwcTIzMiAtMTM0IDM1MiAtMzcybC03NDIgMzlxLTE2MCA5IC0yOTQgLTc0LjV0LTE4NSAtMjI5LjVsLTI3NiA0MjRxMTI4IDE1OSAzMTEgMjQ1LjV0MzgzIDg3LjV6TTE0NiAxMTMxbDMzNyAtNjYzcTcyIC0xNDMgMjExIC0yMTd0MjkzIC00NWwtMjMwIC00NTFxLTIxMiAzMyAtMzg1IDE1Ny41dC0yNzIuNSAzMTZ0LTk5LjUgNDExLjVxMCAyNjcgMTQ2IDQ5MXpNMTczMiA5NjIKcTU4IC0xNTAgNTkuNSAtMzEwLjV0LTQ4LjUgLTMwNnQtMTUzIC0yNzJ0LTI0NiAtMjA5LjVxLTIzMCAtMTMzIC00OTggLTExOWw0MDUgNjIzcTg4IDEzMSA4Mi41IDI5MC41dC0xMDYuNSAyNzcuNXpNODk2IDk0MnExMjUgMCAyMTMuNSAtODguNXQ4OC41IC0yMTMuNXQtODguNSAtMjEzLjV0LTIxMy41IC04OC41dC0yMTMuNSA4OC41dC04OC41IDIxMy41dDg4LjUgMjEzLjV0MjEzLjUgODguNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzU3OSIgdW5pY29kZT0iJiN4ZjI2OTsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTkwMyAtMjU2cS0yODMgMCAtNTA0LjUgMTUwLjV0LTMyOS41IDM5OC41cS01OCAxMzEgLTY3IDMwMXQyNiAzMzIuNXQxMTEgMzEydDE3OSAyNDIuNWwtMTEgLTI4MXExMSAxNCA2OCAxNS41dDcwIC0xNS41cTQyIDgxIDE2MC41IDEzOHQyMzQuNSA1OXEtNTQgLTQ1IC0xMTkuNSAtMTQ4LjV0LTU4LjUgLTE2My41cTI1IC04IDYyLjUgLTEzLjV0NjMgLTcuNXQ2OCAtNHQ1MC41IC0zcTE1IC01IDkuNSAtNDUuNXQtMzAuNSAtNzUuNQpxLTUgLTcgLTE2LjUgLTE4LjV0LTU2LjUgLTM1LjV0LTEwMSAtMzRsMTUgLTE4OWwtMTM5IDY3cS0xOCAtNDMgLTcuNSAtODEuNXQzNiAtNjYuNXQ2NS41IC00MS41dDgxIC02LjVxNTEgOSA5OCAzNC41dDgzLjUgNDV0NzMuNSAxNy41cTYxIC00IDg5LjUgLTMzdDE5LjUgLTY1cS0xIC0yIC0yLjUgLTUuNXQtOC41IC0xMi41dC0xOCAtMTUuNXQtMzEuNSAtMTAuNXQtNDYuNSAtMXEtNjAgLTk1IC0xNDQuNSAtMTM1LjV0LTIwOS41IC0yOS41CnE3NCAtNjEgMTYyLjUgLTgyLjV0MTY4LjUgLTZ0MTU0LjUgNTJ0MTI4IDg3LjV0ODAuNSAxMDRxNDMgOTEgMzkgMTkyLjV0LTM3LjUgMTg4LjV0LTc4LjUgMTI1cTg3IC0zOCAxMzcgLTc5LjV0NzcgLTExMi41cTE1IDE3MCAtNTcuNSAzNDN0LTIwOS41IDI4NHEyNjUgLTc3IDQxMiAtMjc5LjV0MTUxIC01MTcuNXEyIC0xMjcgLTQwLjUgLTI1NXQtMTIzLjUgLTIzOHQtMTg5IC0xOTZ0LTI0Ny41IC0xMzUuNXQtMjg4LjUgLTQ5LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81ODAiIHVuaWNvZGU9IiYjeGYyNmE7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xNDkzIDEzMDhxLTE2NSAxMTAgLTM1OSAxMTBxLTE1NSAwIC0yOTMgLTczdC0yNDAgLTIwMHEtNzUgLTkzIC0xMTkuNSAtMjE4dC00OC41IC0yNjZ2LTQycTQgLTE0MSA0OC41IC0yNjZ0MTE5LjUgLTIxOHExMDIgLTEyNyAyNDAgLTIwMHQyOTMgLTczcTE5NCAwIDM1OSAxMTBxLTEyMSAtMTA4IC0yNzQuNSAtMTY4dC0zMjIuNSAtNjBxLTI5IDAgLTQzIDFxLTE3NSA4IC0zMzMgODJ0LTI3MiAxOTN0LTE4MSAyODF0LTY3IDMzOQpxMCAxODIgNzEgMzQ4dDE5MSAyODZ0Mjg2IDE5MXQzNDggNzFoM3ExNjggLTEgMzIwLjUgLTYwLjV0MjczLjUgLTE2Ny41ek0xNzkyIDY0MHEwIC0xOTIgLTc3IC0zNjIuNXQtMjEzIC0yOTYuNXEtMTA0IC02MyAtMjIyIC02M3EtMTM3IDAgLTI1NSA4NHExNTQgNTYgMjUzLjUgMjMzdDk5LjUgNDA1cTAgMjI3IC05OSA0MDR0LTI1MyAyMzRxMTE5IDgzIDI1NCA4M3ExMTkgMCAyMjYgLTY1cTEzNSAtMTI1IDIxMC41IC0yOTV0NzUuNSAtMzYxegoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzU4MSIgdW5pY29kZT0iJiN4ZjI2YjsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE3OTIgNTk5cTAgLTU2IC03IC0xMDRoLTExNTFxMCAtMTQ2IDEwOS41IC0yNDQuNXQyNTcuNSAtOTguNXE5OSAwIDE4NS41IDQ2LjV0MTM2LjUgMTMwLjVoNDIzcS01NiAtMTU5IC0xNzAuNSAtMjgxdC0yNjcuNSAtMTg4LjV0LTMyMSAtNjYuNXEtMTg3IDAgLTM1NiA4M3EtMjI4IC0xMTYgLTM5NCAtMTE2cS0yMzcgMCAtMjM3IDI2M3EwIDExNSA0NSAyNzVxMTcgNjAgMTA5IDIyOXExOTkgMzYwIDQ3NSA2MDYKcS0xODQgLTc5IC00MjcgLTM1NHE2MyAyNzQgMjgzLjUgNDQ5LjV0NTAxLjUgMTc1LjVxMzAgMCA0NSAtMXEyNTUgMTE3IDQzMyAxMTdxNjQgMCAxMTYgLTEzdDk0LjUgLTQwLjV0NjYuNSAtNzYuNXQyNCAtMTE1cTAgLTExNiAtNzUgLTI4NnExMDEgLTE4MiAxMDEgLTM5MHpNMTcyMiAxMjM5cTAgODMgLTUzIDEzMnQtMTM3IDQ5cS0xMDggMCAtMjU0IC03MHExMjEgLTQ3IDIyMi41IC0xMzEuNXQxNzAuNSAtMTk1LjVxNTEgMTM1IDUxIDIxNnoKTTEyOCAycTAgLTg2IDQ4LjUgLTEzMi41dDEzNC41IC00Ni41cTExNSAwIDI2NiA4M3EtMTIyIDcyIC0yMTMuNSAxODN0LTEzNy41IDI0NXEtOTggLTIwNSAtOTggLTMzMnpNNjMyIDcxNWg3MjhxLTUgMTQyIC0xMTMgMjM3dC0yNTEgOTVxLTE0NCAwIC0yNTEuNSAtOTV0LTExMi41IC0yMzd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81ODIiIHVuaWNvZGU9IiYjeGYyNmM7IiBob3Jpei1hZHYteD0iMjA0OCIgCmQ9Ik0xNzkyIDI4OHY5NjBxMCAxMyAtOS41IDIyLjV0LTIyLjUgOS41aC0xNjAwcS0xMyAwIC0yMi41IC05LjV0LTkuNSAtMjIuNXYtOTYwcTAgLTEzIDkuNSAtMjIuNXQyMi41IC05LjVoMTYwMHExMyAwIDIyLjUgOS41dDkuNSAyMi41ek0xOTIwIDEyNDh2LTk2MHEwIC02NiAtNDcgLTExM3QtMTEzIC00N2gtNzM2di0xMjhoMzUycTE0IDAgMjMgLTl0OSAtMjN2LTY0cTAgLTE0IC05IC0yM3QtMjMgLTloLTgzMnEtMTQgMCAtMjMgOXQtOSAyMwp2NjRxMCAxNCA5IDIzdDIzIDloMzUydjEyOGgtNzM2cS02NiAwIC0xMTMgNDd0LTQ3IDExM3Y5NjBxMCA2NiA0NyAxMTN0MTEzIDQ3aDE2MDBxNjYgMCAxMTMgLTQ3dDQ3IC0xMTN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81ODMiIHVuaWNvZGU9IiYjeGYyNmQ7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xMzggMTQwOGgxOTdxLTcwIC02NCAtMTI2IC0xNDlxLTM2IC01NiAtNTkgLTExNXQtMzAgLTEyNS41dC04LjUgLTEyMHQxMC41IC0xMzJ0MjEgLTEyNnQyOCAtMTM2LjVxNCAtMTkgNiAtMjhxNTEgLTIzOCA4MSAtMzI5cTU3IC0xNzEgMTUyIC0yNzVoLTI3MnEtNDggMCAtODIgMzR0LTM0IDgydjEzMDRxMCA0OCAzNCA4MnQ4MiAzNHpNMTM0NiAxNDA4aDMwOHE0OCAwIDgyIC0zNHQzNCAtODJ2LTEzMDRxMCAtNDggLTM0IC04MnQtODIgLTM0CmgtMTc4cTIxMiAyMTAgMTk2IDU2NWwtNDY5IC0xMDFxLTIgLTQ1IC0xMiAtODJ0LTMxIC03MnQtNTkuNSAtNTkuNXQtOTMuNSAtMzYuNXEtMTIzIC0yNiAtMTk5IDQwcS0zMiAyNyAtNTMgNjF0LTUxLjUgMTI5dC02NC41IDI1OHEtMzUgMTYzIC00NS41IDI2M3QtNS41IDEzOXQyMyA3N3EyMCA0MSA2Mi41IDczdDEwMi41IDQ1cTQ1IDEyIDgzLjUgNi41dDY3IC0xN3Q1NCAtMzV0NDMgLTQ4dDM0LjUgLTU2LjVsNDY4IDEwMApxLTY4IDE3NSAtMTgwIDI4N3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzU4NCIgdW5pY29kZT0iJiN4ZjI2ZTsiIApkPSJNMTQwMSAtMTFsLTYgLTZxLTExMyAtMTEzIC0yNTkgLTE3NXEtMTU0IC02NCAtMzE3IC02NHEtMTY1IDAgLTMxNyA2NHEtMTQ4IDYzIC0yNTkgMTc1cS0xMTMgMTEyIC0xNzUgMjU4cS00MiAxMDMgLTU0IDE4OXEtNCAyOCA0OCAzNnE1MSA4IDU2IC0yMHExIC0xIDEgLTRxMTggLTkwIDQ2IC0xNTlxNTAgLTEyNCAxNTIgLTIyNnE5OCAtOTggMjI2IC0xNTJxMTMyIC01NiAyNzYgLTU2cTE0MyAwIDI3NiA1NnExMjggNTUgMjI1IDE1Mmw2IDYKcTEwIDEwIDI1IDZxMTIgLTMgMzMgLTIycTM2IC0zNyAxNyAtNTh6TTkyOSA2MDRsLTY2IC02Nmw2MyAtNjNxMjEgLTIxIC03IC00OXEtMTcgLTE3IC0zMiAtMTdxLTEwIDAgLTE5IDEwbC02MiA2MWwtNjYgLTY2cS01IC01IC0xNSAtNXEtMTUgMCAtMzEgMTZsLTIgMnEtMTggMTUgLTE4IDI5cTAgNyA4IDE3bDY2IDY1bC02NiA2NnEtMTYgMTYgMTQgNDVxMTggMTggMzEgMThxNiAwIDEzIC01bDY1IC02Nmw2NSA2NXExOCAxNyA0OCAtMTMKcTI3IC0yNyAxMSAtNDR6TTE0MDAgNTQ3cTAgLTExOCAtNDYgLTIyOHEtNDUgLTEwNSAtMTI2IC0xODZxLTgwIC04MCAtMTg3IC0xMjZ0LTIyOCAtNDZ0LTIyOCA0NnQtMTg3IDEyNnEtODIgODIgLTEyNSAxODZxLTE1IDMzIC0xNSA0MGgtMXEtOSAyNyA0MyA0NHE1MCAxNiA2MCAtMTJxMzcgLTk5IDk3IC0xNjdoMXYzMzl2MnEzIDEzNiAxMDIgMjMycTEwNSAxMDMgMjUzIDEwM3ExNDcgMCAyNTEgLTEwM3QxMDQgLTI0OQpxMCAtMTQ3IC0xMDQuNSAtMjUxdC0yNTAuNSAtMTA0cS01OCAwIC0xMTIgMTZxLTI4IDExIC0xMyA2MXExNiA1MSA0NCA0M2wxNCAtM3ExNCAtMyAzMyAtNnQzMCAtM3ExMDQgMCAxNzYgNzEuNXQ3MiAxNzQuNXEwIDEwMSAtNzIgMTcxcS03MSA3MSAtMTc1IDcxcS0xMDcgMCAtMTc4IC04MHEtNjQgLTcyIC02NCAtMTYwdi00MTNxMTEwIC02NyAyNDIgLTY3cTk2IDAgMTg1IDM2LjV0MTU2IDEwMy41dDEwMy41IDE1NXQzNi41IDE4MwpxMCAxOTggLTE0MSAzMzlxLTE0MCAxNDAgLTMzOSAxNDBxLTIwMCAwIC0zNDAgLTE0MHEtNTMgLTUzIC03NyAtODdsLTIgLTJxLTggLTExIC0xMyAtMTUuNXQtMjEuNSAtOS41dC0zOC41IDNxLTIxIDUgLTM2LjUgMTYuNXQtMTUuNSAyNi41djY4MHEwIDE1IDEwLjUgMjYuNXQyNy41IDExLjVoODc3cTMwIDAgMzAgLTU1dC0zMCAtNTVoLTgxMXYtNDgzaDFxNDAgNDIgMTAyIDg0dDEwOCA2MXExMDkgNDYgMjMxIDQ2cTEyMSAwIDIyOCAtNDYKdDE4NyAtMTI2cTgxIC04MSAxMjYgLTE4NnE0NiAtMTEyIDQ2IC0yMjl6TTEzNjkgMTEyOHE5IC04IDkgLTE4dC01LjUgLTE4dC0xNi41IC0yMXEtMjYgLTI2IC0zOSAtMjZxLTkgMCAtMTYgN3EtMTA2IDkxIC0yMDcgMTMzcS0xMjggNTYgLTI3NiA1NnEtMTMzIDAgLTI2MiAtNDlxLTI3IC0xMCAtNDUgMzdxLTkgMjUgLTggMzhxMyAxNiAxNiAyMHExMzAgNTcgMjk5IDU3cTE2NCAwIDMxNiAtNjRxMTM3IC01OCAyMzUgLTE1MnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzU4NSIgdW5pY29kZT0iJiN4ZjI3MDsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE1NTEgNjBxMTUgNiAyNiAzdDExIC0xNy41dC0xNSAtMzMuNXEtMTMgLTE2IC00NCAtNDMuNXQtOTUuNSAtNjh0LTE0MSAtNzR0LTE4OCAtNTh0LTIyOS41IC0yNC41cS0xMTkgMCAtMjM4IDMxdC0yMDkgNzYuNXQtMTcyLjUgMTA0dC0xMzIuNSAxMDV0LTg0IDg3LjVxLTggOSAtMTAgMTYuNXQxIDEydDggN3QxMS41IDJ0MTEuNSAtNC41cTE5MiAtMTE3IDMwMCAtMTY2cTM4OSAtMTc2IDc5OSAtOTBxMTkwIDQwIDM5MSAxMzV6Ck0xNzU4IDE3NXExMSAtMTYgMi41IC02OS41dC0yOC41IC0xMDIuNXEtMzQgLTgzIC04NSAtMTI0cS0xNyAtMTQgLTI2IC05dDAgMjRxMjEgNDUgNDQuNSAxMjEuNXQ2LjUgOTguNXEtNSA3IC0xNS41IDExLjV0LTI3IDZ0LTI5LjUgMi41dC0zNSAwdC0zMS41IC0ydC0zMSAtM3QtMjIuNSAtMnEtNiAtMSAtMTMgLTEuNXQtMTEgLTF0LTguNSAtMXQtNyAtMC41aC01LjVoLTQuNXQtMyAwLjV0LTIgMS41bC0xLjUgM3EtNiAxNiA0NyA0MHQxMDMgMzAKcTQ2IDcgMTA4IDF0NzYgLTI0ek0xMzY0IDYxOHEwIC0zMSAxMy41IC02NHQzMiAtNTh0MzcuNSAtNDZ0MzMgLTMybDEzIC0xMWwtMjI3IC0yMjRxLTQwIDM3IC03OSA3NS41dC01OCA1OC41bC0xOSAyMHEtMTEgMTEgLTI1IDMzcS0zOCAtNTkgLTk3LjUgLTEwMi41dC0xMjcuNSAtNjMuNXQtMTQwIC0yM3QtMTM3LjUgMjF0LTExNy41IDY1LjV0LTgzIDExM3QtMzEgMTYyLjVxMCA4NCAyOCAxNTR0NzIgMTE2LjV0MTA2LjUgODN0MTIyLjUgNTcKdDEzMCAzNC41dDExOS41IDE4LjV0OTkuNSA2LjV2MTI3cTAgNjUgLTIxIDk3cS0zNCA1MyAtMTIxIDUzcS02IDAgLTE2LjUgLTF0LTQwLjUgLTEydC01NiAtMjkuNXQtNTYgLTU5LjV0LTQ4IC05NmwtMjk0IDI3cTAgNjAgMjIgMTE5dDY3IDExM3QxMDggOTV0MTUxLjUgNjUuNXQxOTAuNSAyNC41cTEwMCAwIDE4MSAtMjV0MTI5LjUgLTYxLjV0ODEgLTgzdDQ1IC04NnQxMi41IC03My41di01ODl6TTY5MiA1OTdxMCAtODYgNzAgLTEzMwpxNjYgLTQ0IDEzOSAtMjJxODQgMjUgMTE0IDEyM3ExNCA0NSAxNCAxMDF2MTYycS01OSAtMiAtMTExIC0xMnQtMTA2LjUgLTMzLjV0LTg3IC03MXQtMzIuNSAtMTE0LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81ODYiIHVuaWNvZGU9IiYjeGYyNzE7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xNTM2IDEyODBxNTIgMCA5MCAtMzh0MzggLTkwdi0xMjgwcTAgLTUyIC0zOCAtOTB0LTkwIC0zOGgtMTQwOHEtNTIgMCAtOTAgMzh0LTM4IDkwdjEyODBxMCA1MiAzOCA5MHQ5MCAzOGgxMjh2OTZxMCA2NiA0NyAxMTN0MTEzIDQ3aDY0cTY2IDAgMTEzIC00N3Q0NyAtMTEzdi05NmgzODR2OTZxMCA2NiA0NyAxMTN0MTEzIDQ3aDY0cTY2IDAgMTEzIC00N3Q0NyAtMTEzdi05NmgxMjh6TTExNTIgMTM3NnYtMjg4cTAgLTE0IDkgLTIzdDIzIC05Cmg2NHExNCAwIDIzIDl0OSAyM3YyODhxMCAxNCAtOSAyM3QtMjMgOWgtNjRxLTE0IDAgLTIzIC05dC05IC0yM3pNMzg0IDEzNzZ2LTI4OHEwIC0xNCA5IC0yM3QyMyAtOWg2NHExNCAwIDIzIDl0OSAyM3YyODhxMCAxNCAtOSAyM3QtMjMgOWgtNjRxLTE0IDAgLTIzIC05dC05IC0yM3pNMTUzNiAtMTI4djEwMjRoLTE0MDh2LTEwMjRoMTQwOHpNODk2IDQ0OGgyMjRxMTQgMCAyMyAtOXQ5IC0yM3YtNjRxMCAtMTQgLTkgLTIzdC0yMyAtOWgtMjI0CnYtMjI0cTAgLTE0IC05IC0yM3QtMjMgLTloLTY0cS0xNCAwIC0yMyA5dC05IDIzdjIyNGgtMjI0cS0xNCAwIC0yMyA5dC05IDIzdjY0cTAgMTQgOSAyM3QyMyA5aDIyNHYyMjRxMCAxNCA5IDIzdDIzIDloNjRxMTQgMCAyMyAtOXQ5IC0yM3YtMjI0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTg3IiB1bmljb2RlPSImI3hmMjcyOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTE1MiA0MTZ2LTY0cTAgLTE0IC05IC0yM3QtMjMgLTloLTU3NnEtMTQgMCAtMjMgOXQtOSAyM3Y2NHEwIDE0IDkgMjN0MjMgOWg1NzZxMTQgMCAyMyAtOXQ5IC0yM3pNMTI4IC0xMjhoMTQwOHYxMDI0aC0xNDA4di0xMDI0ek01MTIgMTA4OHYyODhxMCAxNCAtOSAyM3QtMjMgOWgtNjRxLTE0IDAgLTIzIC05dC05IC0yM3YtMjg4cTAgLTE0IDkgLTIzdDIzIC05aDY0cTE0IDAgMjMgOXQ5IDIzek0xMjgwIDEwODh2Mjg4cTAgMTQgLTkgMjMKdC0yMyA5aC02NHEtMTQgMCAtMjMgLTl0LTkgLTIzdi0yODhxMCAtMTQgOSAtMjN0MjMgLTloNjRxMTQgMCAyMyA5dDkgMjN6TTE2NjQgMTE1MnYtMTI4MHEwIC01MiAtMzggLTkwdC05MCAtMzhoLTE0MDhxLTUyIDAgLTkwIDM4dC0zOCA5MHYxMjgwcTAgNTIgMzggOTB0OTAgMzhoMTI4djk2cTAgNjYgNDcgMTEzdDExMyA0N2g2NHE2NiAwIDExMyAtNDd0NDcgLTExM3YtOTZoMzg0djk2cTAgNjYgNDcgMTEzdDExMyA0N2g2NHE2NiAwIDExMyAtNDcKdDQ3IC0xMTN2LTk2aDEyOHE1MiAwIDkwIC0zOHQzOCAtOTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81ODgiIHVuaWNvZGU9IiYjeGYyNzM7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xMTExIDE1MWwtNDYgLTQ2cS05IC05IC0yMiAtOXQtMjMgOWwtMTg4IDE4OWwtMTg4IC0xODlxLTEwIC05IC0yMyAtOXQtMjIgOWwtNDYgNDZxLTkgOSAtOSAyMnQ5IDIzbDE4OSAxODhsLTE4OSAxODhxLTkgMTAgLTkgMjN0OSAyMmw0NiA0NnE5IDkgMjIgOXQyMyAtOWwxODggLTE4OGwxODggMTg4cTEwIDkgMjMgOXQyMiAtOWw0NiAtNDZxOSAtOSA5IC0yMnQtOSAtMjNsLTE4OCAtMTg4bDE4OCAtMTg4cTkgLTEwIDkgLTIzdC05IC0yMnoKTTEyOCAtMTI4aDE0MDh2MTAyNGgtMTQwOHYtMTAyNHpNNTEyIDEwODh2Mjg4cTAgMTQgLTkgMjN0LTIzIDloLTY0cS0xNCAwIC0yMyAtOXQtOSAtMjN2LTI4OHEwIC0xNCA5IC0yM3QyMyAtOWg2NHExNCAwIDIzIDl0OSAyM3pNMTI4MCAxMDg4djI4OHEwIDE0IC05IDIzdC0yMyA5aC02NHEtMTQgMCAtMjMgLTl0LTkgLTIzdi0yODhxMCAtMTQgOSAtMjN0MjMgLTloNjRxMTQgMCAyMyA5dDkgMjN6TTE2NjQgMTE1MnYtMTI4MApxMCAtNTIgLTM4IC05MHQtOTAgLTM4aC0xNDA4cS01MiAwIC05MCAzOHQtMzggOTB2MTI4MHEwIDUyIDM4IDkwdDkwIDM4aDEyOHY5NnEwIDY2IDQ3IDExM3QxMTMgNDdoNjRxNjYgMCAxMTMgLTQ3dDQ3IC0xMTN2LTk2aDM4NHY5NnEwIDY2IDQ3IDExM3QxMTMgNDdoNjRxNjYgMCAxMTMgLTQ3dDQ3IC0xMTN2LTk2aDEyOHE1MiAwIDkwIC0zOHQzOCAtOTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81ODkiIHVuaWNvZGU9IiYjeGYyNzQ7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xMzAzIDU3MmwtNTEyIC01MTJxLTEwIC05IC0yMyAtOXQtMjMgOWwtMjg4IDI4OHEtOSAxMCAtOSAyM3Q5IDIybDQ2IDQ2cTkgOSAyMiA5dDIzIC05bDIyMCAtMjIwbDQ0NCA0NDRxMTAgOSAyMyA5dDIyIC05bDQ2IC00NnE5IC05IDkgLTIydC05IC0yM3pNMTI4IC0xMjhoMTQwOHYxMDI0aC0xNDA4di0xMDI0ek01MTIgMTA4OHYyODhxMCAxNCAtOSAyM3QtMjMgOWgtNjRxLTE0IDAgLTIzIC05dC05IC0yM3YtMjg4cTAgLTE0IDkgLTIzCnQyMyAtOWg2NHExNCAwIDIzIDl0OSAyM3pNMTI4MCAxMDg4djI4OHEwIDE0IC05IDIzdC0yMyA5aC02NHEtMTQgMCAtMjMgLTl0LTkgLTIzdi0yODhxMCAtMTQgOSAtMjN0MjMgLTloNjRxMTQgMCAyMyA5dDkgMjN6TTE2NjQgMTE1MnYtMTI4MHEwIC01MiAtMzggLTkwdC05MCAtMzhoLTE0MDhxLTUyIDAgLTkwIDM4dC0zOCA5MHYxMjgwcTAgNTIgMzggOTB0OTAgMzhoMTI4djk2cTAgNjYgNDcgMTEzdDExMyA0N2g2NHE2NiAwIDExMyAtNDcKdDQ3IC0xMTN2LTk2aDM4NHY5NnEwIDY2IDQ3IDExM3QxMTMgNDdoNjRxNjYgMCAxMTMgLTQ3dDQ3IC0xMTN2LTk2aDEyOHE1MiAwIDkwIC0zOHQzOCAtOTB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81OTAiIHVuaWNvZGU9IiYjeGYyNzU7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik00NDggMTUzNnEyNiAwIDQ1IC0xOXQxOSAtNDV2LTg5MWw1MzYgNDI5cTE3IDE0IDQwIDE0cTI2IDAgNDUgLTE5dDE5IC00NXYtMzc5bDUzNiA0MjlxMTcgMTQgNDAgMTRxMjYgMCA0NSAtMTl0MTkgLTQ1di0xMTUycTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtMTY2NHEtMjYgMCAtNDUgMTl0LTE5IDQ1djE2NjRxMCAyNiAxOSA0NXQ0NSAxOWgzODR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81OTEiIHVuaWNvZGU9IiYjeGYyNzY7IiBob3Jpei1hZHYteD0iMTAyNCIgCmQ9Ik01MTIgNDQ4cTY2IDAgMTI4IDE1di02NTVxMCAtMjYgLTE5IC00NXQtNDUgLTE5aC0xMjhxLTI2IDAgLTQ1IDE5dC0xOSA0NXY2NTVxNjIgLTE1IDEyOCAtMTV6TTUxMiAxNTM2cTIxMiAwIDM2MiAtMTUwdDE1MCAtMzYydC0xNTAgLTM2MnQtMzYyIC0xNTB0LTM2MiAxNTB0LTE1MCAzNjJ0MTUwIDM2MnQzNjIgMTUwek01MTIgMTMxMnExNCAwIDIzIDl0OSAyM3QtOSAyM3QtMjMgOXEtMTQ2IDAgLTI0OSAtMTAzdC0xMDMgLTI0OQpxMCAtMTQgOSAtMjN0MjMgLTl0MjMgOXQ5IDIzcTAgMTE5IDg0LjUgMjAzLjV0MjAzLjUgODQuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzU5MiIgdW5pY29kZT0iJiN4ZjI3NzsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE3NDUgMTIzOXExMCAtMTAgMTAgLTIzdC0xMCAtMjNsLTE0MSAtMTQxcS0yOCAtMjggLTY4IC0yOGgtMTM0NHEtMjYgMCAtNDUgMTl0LTE5IDQ1djI1NnEwIDI2IDE5IDQ1dDQ1IDE5aDU3NnY2NHEwIDI2IDE5IDQ1dDQ1IDE5aDEyOHEyNiAwIDQ1IC0xOXQxOSAtNDV2LTY0aDUxMnE0MCAwIDY4IC0yOHpNNzY4IDMyMGgyNTZ2LTUxMnEwIC0yNiAtMTkgLTQ1dC00NSAtMTloLTEyOHEtMjYgMCAtNDUgMTl0LTE5IDQ1djUxMnpNMTYwMCA3NjgKcTI2IDAgNDUgLTE5dDE5IC00NXYtMjU2cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtMTM0NHEtNDAgMCAtNjggMjhsLTE0MSAxNDFxLTEwIDEwIC0xMCAyM3QxMCAyM2wxNDEgMTQxcTI4IDI4IDY4IDI4aDUxMnYxOTJoMjU2di0xOTJoNTc2eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNTkzIiB1bmljb2RlPSImI3hmMjc4OyIgaG9yaXotYWR2LXg9IjIwNDgiIApkPSJNMjAyMCAxNTI1cTI4IC0yMCAyOCAtNTN2LTE0MDhxMCAtMjAgLTExIC0zNnQtMjkgLTIzbC02NDAgLTI1NnEtMjQgLTExIC00OCAwbC02MTYgMjQ2bC02MTYgLTI0NnEtMTAgLTUgLTI0IC01cS0xOSAwIC0zNiAxMXEtMjggMjAgLTI4IDUzdjE0MDhxMCAyMCAxMSAzNnQyOSAyM2w2NDAgMjU2cTI0IDExIDQ4IDBsNjE2IC0yNDZsNjE2IDI0NnEzMiAxMyA2MCAtNnpNNzM2IDEzOTB2LTEyNzBsNTc2IC0yMzB2MTI3MHpNMTI4IDExNzMKdi0xMjcwbDU0NCAyMTd2MTI3MHpNMTkyMCAxMDd2MTI3MGwtNTQ0IC0yMTd2LTEyNzB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81OTQiIHVuaWNvZGU9IiYjeGYyNzk7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik01MTIgMTUzNnExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV2LTE0NzJxMCAtMjAgLTE3IC0yOGwtNDgwIC0yNTZxLTcgLTQgLTE1IC00cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2MTQ3MnEwIDIwIDE3IDI4bDQ4MCAyNTZxNyA0IDE1IDR6TTE3NjAgMTUzNnExMyAwIDIyLjUgLTkuNXQ5LjUgLTIyLjV2LTE0NzJxMCAtMjAgLTE3IC0yOGwtNDgwIC0yNTZxLTcgLTQgLTE1IC00cS0xMyAwIC0yMi41IDkuNXQtOS41IDIyLjV2MTQ3MgpxMCAyMCAxNyAyOGw0ODAgMjU2cTcgNCAxNSA0ek02NDAgMTUzNnE4IDAgMTQgLTNsNTEyIC0yNTZxMTggLTEwIDE4IC0yOXYtMTQ3MnEwIC0xMyAtOS41IC0yMi41dC0yMi41IC05LjVxLTggMCAtMTQgM2wtNTEyIDI1NnEtMTggMTAgLTE4IDI5djE0NzJxMCAxMyA5LjUgMjIuNXQyMi41IDkuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzU5NSIgdW5pY29kZT0iJiN4ZjI3YTsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTY0MCA2NDBxMCA1MyAtMzcuNSA5MC41dC05MC41IDM3LjV0LTkwLjUgLTM3LjV0LTM3LjUgLTkwLjV0MzcuNSAtOTAuNXQ5MC41IC0zNy41dDkwLjUgMzcuNXQzNy41IDkwLjV6TTEwMjQgNjQwcTAgNTMgLTM3LjUgOTAuNXQtOTAuNSAzNy41dC05MC41IC0zNy41dC0zNy41IC05MC41dDM3LjUgLTkwLjV0OTAuNSAtMzcuNXQ5MC41IDM3LjV0MzcuNSA5MC41ek0xNDA4IDY0MHEwIDUzIC0zNy41IDkwLjV0LTkwLjUgMzcuNQp0LTkwLjUgLTM3LjV0LTM3LjUgLTkwLjV0MzcuNSAtOTAuNXQ5MC41IC0zNy41dDkwLjUgMzcuNXQzNy41IDkwLjV6TTE3OTIgNjQwcTAgLTE3NCAtMTIwIC0zMjEuNXQtMzI2IC0yMzN0LTQ1MCAtODUuNXEtMTEwIDAgLTIxMSAxOHEtMTczIC0xNzMgLTQzNSAtMjI5cS01MiAtMTAgLTg2IC0xM3EtMTIgLTEgLTIyIDZ0LTEzIDE4cS00IDE1IDIwIDM3cTUgNSAyMy41IDIxLjV0MjUuNSAyMy41dDIzLjUgMjUuNXQyNCAzMS41dDIwLjUgMzcKdDIwIDQ4dDE0LjUgNTcuNXQxMi41IDcyLjVxLTE0NiA5MCAtMjI5LjUgMjE2LjV0LTgzLjUgMjY5LjVxMCAxNzQgMTIwIDMyMS41dDMyNiAyMzN0NDUwIDg1LjV0NDUwIC04NS41dDMyNiAtMjMzdDEyMCAtMzIxLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81OTYiIHVuaWNvZGU9IiYjeGYyN2I7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik02NDAgNjQwcTAgLTUzIC0zNy41IC05MC41dC05MC41IC0zNy41dC05MC41IDM3LjV0LTM3LjUgOTAuNXQzNy41IDkwLjV0OTAuNSAzNy41dDkwLjUgLTM3LjV0MzcuNSAtOTAuNXpNMTAyNCA2NDBxMCAtNTMgLTM3LjUgLTkwLjV0LTkwLjUgLTM3LjV0LTkwLjUgMzcuNXQtMzcuNSA5MC41dDM3LjUgOTAuNXQ5MC41IDM3LjV0OTAuNSAtMzcuNXQzNy41IC05MC41ek0xNDA4IDY0MHEwIC01MyAtMzcuNSAtOTAuNXQtOTAuNSAtMzcuNQp0LTkwLjUgMzcuNXQtMzcuNSA5MC41dDM3LjUgOTAuNXQ5MC41IDM3LjV0OTAuNSAtMzcuNXQzNy41IC05MC41ek04OTYgMTE1MnEtMjA0IDAgLTM4MS41IC02OS41dC0yODIgLTE4Ny41dC0xMDQuNSAtMjU1cTAgLTExMiA3MS41IC0yMTMuNXQyMDEuNSAtMTc1LjVsODcgLTUwbC0yNyAtOTZxLTI0IC05MSAtNzAgLTE3MnExNTIgNjMgMjc1IDE3MWw0MyAzOGw1NyAtNnE2OSAtOCAxMzAgLThxMjA0IDAgMzgxLjUgNjkuNXQyODIgMTg3LjUKdDEwNC41IDI1NXQtMTA0LjUgMjU1dC0yODIgMTg3LjV0LTM4MS41IDY5LjV6TTE3OTIgNjQwcTAgLTE3NCAtMTIwIC0zMjEuNXQtMzI2IC0yMzN0LTQ1MCAtODUuNXEtNzAgMCAtMTQ1IDhxLTE5OCAtMTc1IC00NjAgLTI0MnEtNDkgLTE0IC0xMTQgLTIyaC01cS0xNSAwIC0yNyAxMC41dC0xNiAyNy41djFxLTMgNCAtMC41IDEydDIgMTB0NC41IDkuNWw2IDl0NyA4LjV0OCA5cTcgOCAzMSAzNC41dDM0LjUgMzh0MzEgMzkuNXQzMi41IDUxCnQyNyA1OXQyNiA3NnEtMTU3IDg5IC0yNDcuNSAyMjB0LTkwLjUgMjgxcTAgMTMwIDcxIDI0OC41dDE5MSAyMDQuNXQyODYgMTM2LjV0MzQ4IDUwLjV0MzQ4IC01MC41dDI4NiAtMTM2LjV0MTkxIC0yMDQuNXQ3MSAtMjQ4LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81OTciIHVuaWNvZGU9IiYjeGYyN2M7IiBob3Jpei1hZHYteD0iMTAyNCIgCmQ9Ik01MTIgMzQ1bDUxMiAyOTV2LTU5MWwtNTEyIC0yOTZ2NTkyek0wIDY0MHYtNTkxbDUxMiAyOTZ6TTUxMiAxNTI3di01OTFsLTUxMiAtMjk2djU5MXpNNTEyIDkzNmw1MTIgMjk1di01OTF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il81OTgiIHVuaWNvZGU9IiYjeGYyN2Q7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xNzA5IDEwMThxLTEwIC0yMzYgLTMzMiAtNjUxcS0zMzMgLTQzMSAtNTYyIC00MzFxLTE0MiAwIC0yNDAgMjYzcS00NCAxNjAgLTEzMiA0ODJxLTcyIDI2MiAtMTU3IDI2MnEtMTggMCAtMTI3IC03NmwtNzcgOThxMjQgMjEgMTA4IDk2LjV0MTMwIDExNS41cTE1NiAxMzggMjQxIDE0NnE5NSA5IDE1MyAtNTUuNXQ4MSAtMjAzLjVxNDQgLTI4NyA2NiAtMzczcTU1IC0yNDkgMTIwIC0yNDlxNTEgMCAxNTQgMTYxcTEwMSAxNjEgMTA5IDI0NgpxMTMgMTM5IC0xMDkgMTM5cS01NyAwIC0xMjEgLTI2cTEyMCAzOTMgNDU5IDM4MnEyNTEgLTggMjM2IC0zMjZ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9ImYyN2UiIHVuaWNvZGU9IiYjeGYyN2U7IiAKZD0iTTAgMTQwOGgxNTM2di0xNTM2aC0xNTM2djE1MzZ6TTEwODUgMjkzbC0yMjEgNjMxbDIyMSAyOTdoLTYzNGwyMjEgLTI5N2wtMjIxIC02MzFsMzE3IC0zMDR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyODAiIHVuaWNvZGU9IiYjeGYyODA7IiAKZD0iTTAgMTQwOGgxNTM2di0xNTM2aC0xNTM2djE1MzZ6TTkwOCAxMDg4bC0xMiAtMzNsNzUgLTgzbC0zMSAtMTE0bDI1IC0yNWwxMDcgNTdsMTA3IC01N2wyNSAyNWwtMzEgMTE0bDc1IDgzbC0xMiAzM2gtOTVsLTUzIDk2aC0zMmwtNTMgLTk2aC05NXpNNjQxIDkyNXEzMiAwIDQ0LjUgLTE2dDExLjUgLTYzbDE3NCAyMXEwIDU1IC0xNy41IDkyLjV0LTUwLjUgNTZ0LTY5IDI1LjV0LTg1IDdxLTEzMyAwIC0xOTkgLTU3LjV0LTY2IC0xODIuNXYtNzIKaC05NnYtMTI4aDc2cTIwIDAgMjAgLTh2LTM4MnEwIC0xNCAtNSAtMjB0LTE4IC03bC03MyAtN3YtODhoNDQ4djg2bC0xNDkgMTRxLTYgMSAtOC41IDEuNXQtMy41IDIuNXQtMC41IDR0MSA3dDAuNSAxMHYzODdoMTkxbDM4IDEyOGgtMjMxcS02IDAgLTIgNnQ0IDl2ODBxMCAyNyAxLjUgNDAuNXQ3LjUgMjh0MTkuNSAyMHQzNi41IDUuNXpNMTI0OCA5NnY4NmwtNTQgOXEtNyAxIC05LjUgMi41dC0yLjUgM3QxIDcuNXQxIDEydjUyMGgtMjc1CmwtMjMgLTEwMWw4MyAtMjJxMjMgLTcgMjMgLTI3di0zNzBxMCAtMTQgLTYgLTE4LjV0LTIwIC02LjVsLTcwIC05di04NmgzNTJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyODEiIHVuaWNvZGU9IiYjeGYyODE7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xNzkyIDY5MHEwIC01OCAtMjkuNSAtMTA1LjV0LTc5LjUgLTcyLjVxMTIgLTQ2IDEyIC05NnEwIC0xNTUgLTEwNi41IC0yODd0LTI5MC41IC0yMDguNXQtNDAwIC03Ni41dC0zOTkuNSA3Ni41dC0yOTAgMjA4LjV0LTEwNi41IDI4N3EwIDQ3IDExIDk0cS01MSAyNSAtODIgNzMuNXQtMzEgMTA2LjVxMCA4MiA1OCAxNDAuNXQxNDEgNTguNXE4NSAwIDE0NSAtNjNxMjE4IDE1MiA1MTUgMTYybDExNiA1MjFxMyAxMyAxNSAyMXQyNiA1CmwzNjkgLTgxcTE4IDM3IDU0IDU5LjV0NzkgMjIuNXE2MiAwIDEwNiAtNDMuNXQ0NCAtMTA1LjV0LTQ0IC0xMDZ0LTEwNiAtNDR0LTEwNS41IDQzLjV0LTQzLjUgMTA1LjVsLTMzNCA3NGwtMTA0IC00NzJxMzAwIC05IDUxOSAtMTYwcTU4IDYxIDE0MyA2MXE4MyAwIDE0MSAtNTguNXQ1OCAtMTQwLjV6TTQxOCA0OTFxMCAtNjIgNDMuNSAtMTA2dDEwNS41IC00NHQxMDYgNDR0NDQgMTA2dC00NCAxMDUuNXQtMTA2IDQzLjVxLTYxIDAgLTEwNSAtNDQKdC00NCAtMTA1ek0xMjI4IDEzNnExMSAxMSAxMSAyNnQtMTEgMjZxLTEwIDEwIC0yNSAxMHQtMjYgLTEwcS00MSAtNDIgLTEyMSAtNjJ0LTE2MCAtMjB0LTE2MCAyMHQtMTIxIDYycS0xMSAxMCAtMjYgMTB0LTI1IC0xMHEtMTEgLTEwIC0xMSAtMjUuNXQxMSAtMjYuNXE0MyAtNDMgMTE4LjUgLTY4dDEyMi41IC0yOS41dDkxIC00LjV0OTEgNC41dDEyMi41IDI5LjV0MTE4LjUgNjh6TTEyMjUgMzQxcTYyIDAgMTA1LjUgNDR0NDMuNSAxMDYKcTAgNjEgLTQ0IDEwNXQtMTA1IDQ0cS02MiAwIC0xMDYgLTQzLjV0LTQ0IC0xMDUuNXQ0NCAtMTA2dDEwNiAtNDR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il82MDIiIHVuaWNvZGU9IiYjeGYyODI7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik02OSA3NDFoMXExNiAxMjYgNTguNSAyNDEuNXQxMTUgMjE3dDE2Ny41IDE3NnQyMjMuNSAxMTcuNXQyNzYuNSA0M3EyMzEgMCA0MTQgLTEwNS41dDI5NCAtMzAzLjVxMTA0IC0xODcgMTA0IC00NDJ2LTE4OGgtMTEyNXExIC0xMTEgNTMuNSAtMTkyLjV0MTM2LjUgLTEyMi41dDE4OS41IC01N3QyMTMgLTN0MjA4IDQ2LjV0MTczLjUgODQuNXYtMzc3cS05MiAtNTUgLTIyOS41IC05MnQtMzEyLjUgLTM4dC0zMTYgNTMKcS0xODkgNzMgLTMxMS41IDI0OXQtMTI0LjUgMzcycS0zIDI0MiAxMTEgNDEydDMyNSAyNjhxLTQ4IC02MCAtNzggLTEyNS41dC00NiAtMTU5LjVoNjM1cTggNzcgLTggMTQwdC00NyAxMDEuNXQtNzAuNSA2Ni41dC04MC41IDQxdC03NSAyMC41dC01NiA4LjVsLTIyIDFxLTEzNSAtNSAtMjU5LjUgLTQ0LjV0LTIyMy41IC0xMDQuNXQtMTc2IC0xNDAuNXQtMTM4IC0xNjMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzYwMyIgdW5pY29kZT0iJiN4ZjI4MzsiIGhvcml6LWFkdi14PSIyMzA0IiAKZD0iTTAgMzJ2NjA4aDIzMDR2LTYwOHEwIC02NiAtNDcgLTExM3QtMTEzIC00N2gtMTk4NHEtNjYgMCAtMTEzIDQ3dC00NyAxMTN6TTY0MCAyNTZ2LTEyOGgzODR2MTI4aC0zODR6TTI1NiAyNTZ2LTEyOGgyNTZ2MTI4aC0yNTZ6TTIxNDQgMTQwOHE2NiAwIDExMyAtNDd0NDcgLTExM3YtMjI0aC0yMzA0djIyNHEwIDY2IDQ3IDExM3QxMTMgNDdoMTk4NHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzYwNCIgdW5pY29kZT0iJiN4ZjI4NDsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE1ODQgMjQ2bC0yMTggMTExcS03NCAtMTIwIC0xOTYuNSAtMTg5dC0yNjMuNSAtNjlxLTE0NyAwIC0yNzEgNzJ0LTE5NiAxOTZ0LTcyIDI3MHEwIDExMCA0Mi41IDIwOS41dDExNSAxNzJ0MTcyIDExNXQyMDkuNSA0Mi41cTEzMSAwIDI0Ny41IC02MC41dDE5Mi41IC0xNjguNWwyMTUgMTI1cS0xMTAgMTY5IC0yODYuNSAyNjV0LTM3OC41IDk2cS0xNjEgMCAtMzA4IC02M3QtMjUzIC0xNjl0LTE2OSAtMjUzdC02MyAtMzA4dDYzIC0zMDgKdDE2OSAtMjUzdDI1MyAtMTY5dDMwOCAtNjNxMjEzIDAgMzk3LjUgMTA3dDI5MC41IDI5MnpNMTAzMCA2NDNsNjkzIC0zNTJxLTExNiAtMjUzIC0zMzQuNSAtNDAwdC00OTIuNSAtMTQ3cS0xODIgMCAtMzQ4IDcxdC0yODYgMTkxdC0xOTEgMjg2dC03MSAzNDh0NzEgMzQ4dDE5MSAyODZ0Mjg2IDE5MXQzNDggNzFxMjYwIDAgNDcwLjUgLTEzMy41dDMzNS41IC0zNjYuNXpNMTU0MyA2NDBoLTM5di0xNjBoLTk2djM1MmgxMzZxMzIgMCA1NC41IC0yMAp0MjguNSAtNDh0MSAtNTZ0LTI3LjUgLTQ4dC01Ny41IC0yMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjI4NSIgdW5pY29kZT0iJiN4ZjI4NTsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE0MjcgODI3bC02MTQgMzg2bDkyIDE1MWg4NTV6TTQwNSA1NjJsLTE4NCAxMTZ2ODU4bDExODMgLTc0M3pNMTQyNCA2OTdsMTQ3IC05NXYtODU4bC01MzIgMzM1ek0xMzg3IDcxOGwtNTAwIC04MDJoLTg1NWwzNTYgNTcxeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmlGMjg2IiB1bmljb2RlPSImI3hmMjg2OyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNNjQwIDUyOHYyMjRxMCAxNiAtMTYgMTZoLTk2cS0xNiAwIC0xNiAtMTZ2LTIyNHEwIC0xNiAxNiAtMTZoOTZxMTYgMCAxNiAxNnpNMTE1MiA1Mjh2MjI0cTAgMTYgLTE2IDE2aC05NnEtMTYgMCAtMTYgLTE2di0yMjRxMCAtMTYgMTYgLTE2aDk2cTE2IDAgMTYgMTZ6TTE2NjQgNDk2di03NTJoLTY0MHYzMjBxMCA4MCAtNTYgMTM2dC0xMzYgNTZ0LTEzNiAtNTZ0LTU2IC0xMzZ2LTMyMGgtNjQwdjc1MnEwIDE2IDE2IDE2aDk2CnExNiAwIDE2IC0xNnYtMTEyaDEyOHY2MjRxMCAxNiAxNiAxNmg5NnExNiAwIDE2IC0xNnYtMTEyaDEyOHYxMTJxMCAxNiAxNiAxNmg5NnExNiAwIDE2IC0xNnYtMTEyaDEyOHYxMTJxMCA2IDIuNSA5LjV0OC41IDV0OS41IDJ0MTEuNSAwdDkgLTAuNXYzOTFxLTMyIDE1IC0zMiA1MHEwIDIzIDE2LjUgMzl0MzguNSAxNnQzOC41IC0xNnQxNi41IC0zOXEwIC0zNSAtMzIgLTUwdi0xN3E0NSAxMCA4MyAxMHEyMSAwIDU5LjUgLTcuNXQ1NC41IC03LjUKcTE3IDAgNDcgNy41dDM3IDcuNXExNiAwIDE2IC0xNnYtMjEwcTAgLTE1IC0zNSAtMjEuNXQtNjIgLTYuNXEtMTggMCAtNTQuNSA3LjV0LTU1LjUgNy41cS00MCAwIC05MCAtMTJ2LTEzM3ExIDAgOSAwLjV0MTEuNSAwdDkuNSAtMnQ4LjUgLTV0Mi41IC05LjV2LTExMmgxMjh2MTEycTAgMTYgMTYgMTZoOTZxMTYgMCAxNiAtMTZ2LTExMmgxMjh2MTEycTAgMTYgMTYgMTZoOTZxMTYgMCAxNiAtMTZ2LTYyNGgxMjh2MTEycTAgMTYgMTYgMTZoOTYKcTE2IDAgMTYgLTE2eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNjA3IiB1bmljb2RlPSImI3hmMjg3OyIgaG9yaXotYWR2LXg9IjIzMDQiIApkPSJNMjI4OCA3MzFxMTYgLTggMTYgLTI3dC0xNiAtMjdsLTMyMCAtMTkycS04IC01IC0xNiAtNXEtOSAwIC0xNiA0cS0xNiAxMCAtMTYgMjh2MTI4aC04NThxMzcgLTU4IDgzIC0xNjVxMTYgLTM3IDI0LjUgLTU1dDI0IC00OXQyNyAtNDd0MjcgLTM0dDMxLjUgLTI2dDMzIC04aDk2djk2cTAgMTQgOSAyM3QyMyA5aDMyMHExNCAwIDIzIC05dDkgLTIzdi0zMjBxMCAtMTQgLTkgLTIzdC0yMyAtOWgtMzIwcS0xNCAwIC0yMyA5dC05IDIzdjk2aC05NgpxLTMyIDAgLTYxIDEwdC01MSAyMy41dC00NSA0MC41dC0zNyA0NnQtMzMuNSA1N3QtMjguNSA1Ny41dC0yOCA2MC41cS0yMyA1MyAtMzcgODEuNXQtMzYgNjV0LTQ0LjUgNTMuNXQtNDYuNSAxN2gtMzYwcS0yMiAtODQgLTkxIC0xMzh0LTE1NyAtNTRxLTEwNiAwIC0xODEgNzV0LTc1IDE4MXQ3NSAxODF0MTgxIDc1cTg4IDAgMTU3IC01NHQ5MSAtMTM4aDEwNHEyNCAwIDQ2LjUgMTd0NDQuNSA1My41dDM2IDY1dDM3IDgxLjVxMTkgNDEgMjggNjAuNQp0MjguNSA1Ny41dDMzLjUgNTd0MzcgNDZ0NDUgNDAuNXQ1MSAyMy41dDYxIDEwaDEwN3EyMSA1NyA3MCA5Mi41dDExMSAzNS41cTgwIDAgMTM2IC01NnQ1NiAtMTM2dC01NiAtMTM2dC0xMzYgLTU2cS02MiAwIC0xMTEgMzUuNXQtNzAgOTIuNWgtMTA3cS0xNyAwIC0zMyAtOHQtMzEuNSAtMjZ0LTI3IC0zNHQtMjcgLTQ3dC0yNCAtNDl0LTI0LjUgLTU1cS00NiAtMTA3IC04MyAtMTY1aDExMTR2MTI4cTAgMTggMTYgMjh0MzIgLTF6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il82MDgiIHVuaWNvZGU9IiYjeGYyODg7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xMTUwIDc3NHEwIC01NiAtMzkuNSAtOTV0LTk1LjUgLTM5aC0yNTN2MjY5aDI1M3E1NiAwIDk1LjUgLTM5LjV0MzkuNSAtOTUuNXpNMTMyOSA3NzRxMCAxMzAgLTkxLjUgMjIydC0yMjIuNSA5MmgtNDMzdi04OTZoMTgwdjI2OWgyNTNxMTMwIDAgMjIyIDkxLjV0OTIgMjIxLjV6TTE3OTIgNjQwcTAgLTE4MiAtNzEgLTM0OHQtMTkxIC0yODZ0LTI4NiAtMTkxdC0zNDggLTcxdC0zNDggNzF0LTI4NiAxOTF0LTE5MSAyODZ0LTcxIDM0OAp0NzEgMzQ4dDE5MSAyODZ0Mjg2IDE5MXQzNDggNzF0MzQ4IC03MXQyODYgLTE5MXQxOTEgLTI4NnQ3MSAtMzQ4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNjA5IiB1bmljb2RlPSImI3hmMjg5OyIgaG9yaXotYWR2LXg9IjIzMDQiIApkPSJNMTY0NSA0MzhxMCA1OSAtMzQgMTA2LjV0LTg3IDY4LjVxLTcgLTQ1IC0yMyAtOTJxLTcgLTI0IC0yNy41IC0zOHQtNDQuNSAtMTRxLTEyIDAgLTI0IDNxLTMxIDEwIC00NSAzOC41dC00IDU4LjVxMjMgNzEgMjMgMTQzcTAgMTIzIC02MSAyMjcuNXQtMTY2IDE2NS41dC0yMjggNjFxLTEzNCAwIC0yNDcgLTczdC0xNjcgLTE5NHExMDggLTI4IDE4OCAtMTA2cTIyIC0yMyAyMiAtNTV0LTIyIC01NHQtNTQgLTIydC01NSAyMgpxLTc1IDc1IC0xODAgNzVxLTEwNiAwIC0xODEgLTc0LjV0LTc1IC0xODAuNXQ3NSAtMTgwLjV0MTgxIC03NC41aDEwNDZxNzkgMCAxMzQuNSA1NS41dDU1LjUgMTMzLjV6TTE3OTggNDM4cTAgLTE0MiAtMTAwLjUgLTI0MnQtMjQyLjUgLTEwMGgtMTA0NnEtMTY5IDAgLTI4OSAxMTkuNXQtMTIwIDI4OC41cTAgMTUzIDEwMCAyNjd0MjQ5IDEzNnE2MiAxODQgMjIxIDI5OHQzNTQgMTE0cTIzNSAwIDQwOC41IC0xNTguNXQxOTYuNSAtMzg5LjUKcTExNiAtMjUgMTkyLjUgLTExOC41dDc2LjUgLTIxNC41ek0yMDQ4IDQzOHEwIC0xNzUgLTk3IC0zMTlxLTIzIC0zMyAtNjQgLTMzcS0yNCAwIC00MyAxM3EtMjYgMTcgLTMyIDQ4LjV0MTIgNTcuNXE3MSAxMDQgNzEgMjMzdC03MSAyMzNxLTE4IDI2IC0xMiA1N3QzMiA0OXQ1Ny41IDExLjV0NDkuNSAtMzIuNXE5NyAtMTQyIDk3IC0zMTh6TTIzMDQgNDM4cTAgLTI0NCAtMTM0IC00NDNxLTIzIC0zNCAtNjQgLTM0cS0yMyAwIC00MiAxMwpxLTI2IDE4IC0zMi41IDQ5dDExLjUgNTdxMTA4IDE2NCAxMDggMzU4cTAgMTk1IC0xMDggMzU3cS0xOCAyNiAtMTEuNSA1Ny41dDMyLjUgNDguNXEyNiAxOCA1NyAxMnQ0OSAtMzNxMTM0IC0xOTggMTM0IC00NDJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il82MTAiIHVuaWNvZGU9IiYjeGYyOGE7IiAKZD0iTTE1MDAgLTEzcTAgLTg5IC02MyAtMTUyLjV0LTE1MyAtNjMuNXQtMTUzLjUgNjMuNXQtNjMuNSAxNTIuNXEwIDkwIDYzLjUgMTUzLjV0MTUzLjUgNjMuNXQxNTMgLTYzLjV0NjMgLTE1My41ek0xMjY3IDI2OHEtMTE1IC0xNSAtMTkyLjUgLTEwMi41dC03Ny41IC0yMDUuNXEwIC03NCAzMyAtMTM4cS0xNDYgLTc4IC0zNzkgLTc4cS0xMDkgMCAtMjAxIDIxdC0xNTMuNSA1NC41dC0xMTAuNSA3Ni41dC03NiA4NXQtNDQuNSA4Mwp0LTIzLjUgNjYuNXQtNiAzOS41cTAgMTkgNC41IDQyLjV0MTguNSA1NnQzNi41IDU4dDY0IDQzLjV0OTQuNSAxOHQ5NCAtMTcuNXQ2MyAtNDF0MzUuNSAtNTN0MTcuNSAtNDl0NCAtMzMuNXEwIC0zNCAtMjMgLTgxcTI4IC0yNyA4MiAtNDJ0OTMgLTE3bDQwIC0xcTExNSAwIDE5MCA1MXQ3NSAxMzNxMCAyNiAtOSA0OC41dC0zMS41IDQ0LjV0LTQ5LjUgNDF0LTc0IDQ0dC05My41IDQ3LjV0LTExOS41IDU2LjVxLTI4IDEzIC00MyAyMApxLTExNiA1NSAtMTg3IDEwMHQtMTIyLjUgMTAydC03MiAxMjUuNXQtMjAuNSAxNjIuNXEwIDc4IDIwLjUgMTUwdDY2IDEzNy41dDExMi41IDExNHQxNjYuNSA3N3QyMjEuNSAyOC41cTEyMCAwIDIyMCAtMjZ0MTY0LjUgLTY3dDEwOS41IC05NHQ2NCAtMTA1LjV0MTkgLTEwMy41cTAgLTQ2IC0xNSAtODIuNXQtMzYuNSAtNTh0LTQ4LjUgLTM2dC00OSAtMTkuNXQtMzkgLTVoLThoLTMydC0zOSA1dC00NCAxNHQtNDEgMjh0LTM3IDQ2dC0yNCA3MC41CnQtMTAgOTcuNXEtMTUgMTYgLTU5IDI1LjV0LTgxIDEwLjVsLTM3IDFxLTY4IDAgLTExNy41IC0zMXQtNzAuNSAtNzB0LTIxIC03NnEwIC0yNCA1IC00M3QyNCAtNDZ0NTMgLTUxdDk3IC01My41dDE1MCAtNTguNXE3NiAtMjUgMTM4LjUgLTUzLjV0MTA5IC01NS41dDgzIC01OXQ2MC41IC01OS41dDQxIC02Mi41dDI2LjUgLTYydDE0LjUgLTYzLjV0NiAtNjJ0MSAtNjIuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzYxMSIgdW5pY29kZT0iJiN4ZjI4YjsiIApkPSJNNzA0IDM1MnY1NzZxMCAxNCAtOSAyM3QtMjMgOWgtMjU2cS0xNCAwIC0yMyAtOXQtOSAtMjN2LTU3NnEwIC0xNCA5IC0yM3QyMyAtOWgyNTZxMTQgMCAyMyA5dDkgMjN6TTExNTIgMzUydjU3NnEwIDE0IC05IDIzdC0yMyA5aC0yNTZxLTE0IDAgLTIzIC05dC05IC0yM3YtNTc2cTAgLTE0IDkgLTIzdDIzIC05aDI1NnExNCAwIDIzIDl0OSAyM3pNMTUzNiA2NDBxMCAtMjA5IC0xMDMgLTM4NS41dC0yNzkuNSAtMjc5LjV0LTM4NS41IC0xMDMKdC0zODUuNSAxMDN0LTI3OS41IDI3OS41dC0xMDMgMzg1LjV0MTAzIDM4NS41dDI3OS41IDI3OS41dDM4NS41IDEwM3QzODUuNSAtMTAzdDI3OS41IC0yNzkuNXQxMDMgLTM4NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNjEyIiB1bmljb2RlPSImI3hmMjhjOyIgCmQ9Ik03NjggMTQwOHEyMDkgMCAzODUuNSAtMTAzdDI3OS41IC0yNzkuNXQxMDMgLTM4NS41dC0xMDMgLTM4NS41dC0yNzkuNSAtMjc5LjV0LTM4NS41IC0xMDN0LTM4NS41IDEwM3QtMjc5LjUgMjc5LjV0LTEwMyAzODUuNXQxMDMgMzg1LjV0Mjc5LjUgMjc5LjV0Mzg1LjUgMTAzek03NjggOTZxMTQ4IDAgMjczIDczdDE5OCAxOTh0NzMgMjczdC03MyAyNzN0LTE5OCAxOTh0LTI3MyA3M3QtMjczIC03M3QtMTk4IC0xOTh0LTczIC0yNzMKdDczIC0yNzN0MTk4IC0xOTh0MjczIC03M3pNODY0IDMyMHEtMTQgMCAtMjMgOXQtOSAyM3Y1NzZxMCAxNCA5IDIzdDIzIDloMTkycTE0IDAgMjMgLTl0OSAtMjN2LTU3NnEwIC0xNCAtOSAtMjN0LTIzIC05aC0xOTJ6TTQ4MCAzMjBxLTE0IDAgLTIzIDl0LTkgMjN2NTc2cTAgMTQgOSAyM3QyMyA5aDE5MnExNCAwIDIzIC05dDkgLTIzdi01NzZxMCAtMTQgLTkgLTIzdC0yMyAtOWgtMTkyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNjEzIiB1bmljb2RlPSImI3hmMjhkOyIgCmQ9Ik0xMDg4IDM1MnY1NzZxMCAxNCAtOSAyM3QtMjMgOWgtNTc2cS0xNCAwIC0yMyAtOXQtOSAtMjN2LTU3NnEwIC0xNCA5IC0yM3QyMyAtOWg1NzZxMTQgMCAyMyA5dDkgMjN6TTE1MzYgNjQwcTAgLTIwOSAtMTAzIC0zODUuNXQtMjc5LjUgLTI3OS41dC0zODUuNSAtMTAzdC0zODUuNSAxMDN0LTI3OS41IDI3OS41dC0xMDMgMzg1LjV0MTAzIDM4NS41dDI3OS41IDI3OS41dDM4NS41IDEwM3QzODUuNSAtMTAzdDI3OS41IC0yNzkuNQp0MTAzIC0zODUuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzYxNCIgdW5pY29kZT0iJiN4ZjI4ZTsiIApkPSJNNzY4IDE0MDhxMjA5IDAgMzg1LjUgLTEwM3QyNzkuNSAtMjc5LjV0MTAzIC0zODUuNXQtMTAzIC0zODUuNXQtMjc5LjUgLTI3OS41dC0zODUuNSAtMTAzdC0zODUuNSAxMDN0LTI3OS41IDI3OS41dC0xMDMgMzg1LjV0MTAzIDM4NS41dDI3OS41IDI3OS41dDM4NS41IDEwM3pNNzY4IDk2cTE0OCAwIDI3MyA3M3QxOTggMTk4dDczIDI3M3QtNzMgMjczdC0xOTggMTk4dC0yNzMgNzN0LTI3MyAtNzN0LTE5OCAtMTk4dC03MyAtMjczCnQ3MyAtMjczdDE5OCAtMTk4dDI3MyAtNzN6TTQ4MCAzMjBxLTE0IDAgLTIzIDl0LTkgMjN2NTc2cTAgMTQgOSAyM3QyMyA5aDU3NnExNCAwIDIzIC05dDkgLTIzdi01NzZxMCAtMTQgLTkgLTIzdC0yMyAtOWgtNTc2eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNjE1IiB1bmljb2RlPSImI3hmMjkwOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTc1NyAxMjhsMzUgLTMxM3EzIC0yOCAtMTYgLTUwcS0xOSAtMjEgLTQ4IC0yMWgtMTY2NHEtMjkgMCAtNDggMjFxLTE5IDIyIC0xNiA1MGwzNSAzMTNoMTcyMnpNMTY2NCA5NjdsODYgLTc3NWgtMTcwOGw4NiA3NzVxMyAyNCAyMSA0MC41dDQzIDE2LjVoMjU2di0xMjhxMCAtNTMgMzcuNSAtOTAuNXQ5MC41IC0zNy41dDkwLjUgMzcuNXQzNy41IDkwLjV2MTI4aDM4NHYtMTI4cTAgLTUzIDM3LjUgLTkwLjV0OTAuNSAtMzcuNQp0OTAuNSAzNy41dDM3LjUgOTAuNXYxMjhoMjU2cTI1IDAgNDMgLTE2LjV0MjEgLTQwLjV6TTEyODAgMTE1MnYtMjU2cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOXQtNDUgMTl0LTE5IDQ1djI1NnEwIDEwNiAtNzUgMTgxdC0xODEgNzV0LTE4MSAtNzV0LTc1IC0xODF2LTI1NnEwIC0yNiAtMTkgLTQ1dC00NSAtMTl0LTQ1IDE5dC0xOSA0NXYyNTZxMCAxNTkgMTEyLjUgMjcxLjV0MjcxLjUgMTEyLjV0MjcxLjUgLTExMi41dDExMi41IC0yNzEuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzYxNiIgdW5pY29kZT0iJiN4ZjI5MTsiIGhvcml6LWFkdi14PSIyMDQ4IiAKZD0iTTE5MjAgNzY4cTUzIDAgOTAuNSAtMzcuNXQzNy41IC05MC41dC0zNy41IC05MC41dC05MC41IC0zNy41aC0xNWwtMTE1IC02NjJxLTggLTQ2IC00NCAtNzZ0LTgyIC0zMGgtMTI4MHEtNDYgMCAtODIgMzB0LTQ0IDc2bC0xMTUgNjYyaC0xNXEtNTMgMCAtOTAuNSAzNy41dC0zNy41IDkwLjV0MzcuNSA5MC41dDkwLjUgMzcuNWgxNzkyek00ODUgLTMycTI2IDIgNDMuNSAyMi41dDE1LjUgNDYuNWwtMzIgNDE2cS0yIDI2IC0yMi41IDQzLjUKdC00Ni41IDE1LjV0LTQzLjUgLTIyLjV0LTE1LjUgLTQ2LjVsMzIgLTQxNnEyIC0yNSAyMC41IC00MnQ0My41IC0xN2g1ek04OTYgMzJ2NDE2cTAgMjYgLTE5IDQ1dC00NSAxOXQtNDUgLTE5dC0xOSAtNDV2LTQxNnEwIC0yNiAxOSAtNDV0NDUgLTE5dDQ1IDE5dDE5IDQ1ek0xMjgwIDMydjQxNnEwIDI2IC0xOSA0NXQtNDUgMTl0LTQ1IC0xOXQtMTkgLTQ1di00MTZxMCAtMjYgMTkgLTQ1dDQ1IC0xOXQ0NSAxOXQxOSA0NXpNMTYzMiAyN2wzMiA0MTYKcTIgMjYgLTE1LjUgNDYuNXQtNDMuNSAyMi41dC00Ni41IC0xNS41dC0yMi41IC00My41bC0zMiAtNDE2cS0yIC0yNiAxNS41IC00Ni41dDQzLjUgLTIyLjVoNXEyNSAwIDQzLjUgMTd0MjAuNSA0MnpNNDc2IDEyNDRsLTkzIC00MTJoLTEzMmwxMDEgNDQxcTE5IDg4IDg5IDE0My41dDE2MCA1NS41aDE2N3EwIDI2IDE5IDQ1dDQ1IDE5aDM4NHEyNiAwIDQ1IC0xOXQxOSAtNDVoMTY3cTkwIDAgMTYwIC01NS41dDg5IC0xNDMuNWwxMDEgLTQ0MQpoLTEzMmwtOTMgNDEycS0xMSA0NCAtNDUuNSA3MnQtNzkuNSAyOGgtMTY3cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtMzg0cS0yNiAwIC00NSAxOXQtMTkgNDVoLTE2N3EtNDUgMCAtNzkuNSAtMjh0LTQ1LjUgLTcyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNjE3IiB1bmljb2RlPSImI3hmMjkyOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNOTkxIDUxMmw2NCAyNTZoLTI1NGwtNjQgLTI1NmgyNTR6TTE3NTkgMTAxNmwtNTYgLTIyNHEtNyAtMjQgLTMxIC0yNGgtMzI3bC02NCAtMjU2aDMxMXExNSAwIDI1IC0xMnExMCAtMTQgNiAtMjhsLTU2IC0yMjRxLTUgLTI0IC0zMSAtMjRoLTMyN2wtODEgLTMyOHEtNyAtMjQgLTMxIC0yNGgtMjI0cS0xNiAwIC0yNiAxMnEtOSAxMiAtNiAyOGw3OCAzMTJoLTI1NGwtODEgLTMyOHEtNyAtMjQgLTMxIC0yNGgtMjI1cS0xNSAwIC0yNSAxMgpxLTkgMTIgLTYgMjhsNzggMzEyaC0zMTFxLTE1IDAgLTI1IDEycS05IDEyIC02IDI4bDU2IDIyNHE3IDI0IDMxIDI0aDMyN2w2NCAyNTZoLTMxMXEtMTUgMCAtMjUgMTJxLTEwIDE0IC02IDI4bDU2IDIyNHE1IDI0IDMxIDI0aDMyN2w4MSAzMjhxNyAyNCAzMiAyNGgyMjRxMTUgMCAyNSAtMTJxOSAtMTIgNiAtMjhsLTc4IC0zMTJoMjU0bDgxIDMyOHE3IDI0IDMyIDI0aDIyNHExNSAwIDI1IC0xMnE5IC0xMiA2IC0yOGwtNzggLTMxMmgzMTEKcTE1IDAgMjUgLTEycTkgLTEyIDYgLTI4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNjE4IiB1bmljb2RlPSImI3hmMjkzOyIgCmQ9Ik04NDEgNDgzbDE0OCAtMTQ4bC0xNDkgLTE0OXpNODQwIDEwOTRsMTQ5IC0xNDlsLTE0OCAtMTQ4ek03MTAgLTEzMGw0NjQgNDY0bC0zMDYgMzA2bDMwNiAzMDZsLTQ2NCA0NjR2LTYxMWwtMjU1IDI1NWwtOTMgLTkzbDMyMCAtMzIxbC0zMjAgLTMyMWw5MyAtOTNsMjU1IDI1NXYtNjExek0xNDI5IDY0MHEwIC0yMDkgLTMyIC0zNjUuNXQtODcuNSAtMjU3dC0xNDAuNSAtMTYyLjV0LTE4MS41IC04Ni41dC0yMTkuNSAtMjQuNQp0LTIxOS41IDI0LjV0LTE4MS41IDg2LjV0LTE0MC41IDE2Mi41dC04Ny41IDI1N3QtMzIgMzY1LjV0MzIgMzY1LjV0ODcuNSAyNTd0MTQwLjUgMTYyLjV0MTgxLjUgODYuNXQyMTkuNSAyNC41dDIxOS41IC0yNC41dDE4MS41IC04Ni41dDE0MC41IC0xNjIuNXQ4Ny41IC0yNTd0MzIgLTM2NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNjE5IiB1bmljb2RlPSImI3hmMjk0OyIgaG9yaXotYWR2LXg9IjEwMjQiIApkPSJNNTk2IDExM2wxNzMgMTcybC0xNzMgMTcydi0zNDR6TTU5NiA4MjNsMTczIDE3MmwtMTczIDE3MnYtMzQ0ek02MjggNjQwbDM1NiAtMzU2bC01MzkgLTU0MHY3MTFsLTI5NyAtMjk2bC0xMDggMTA4bDM3MiAzNzNsLTM3MiAzNzNsMTA4IDEwOGwyOTcgLTI5NnY3MTFsNTM5IC01NDB6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il82MjAiIHVuaWNvZGU9IiYjeGYyOTU7IiAKZD0iTTEyODAgMjU2cTAgNTIgLTM4IDkwdC05MCAzOHQtOTAgLTM4dC0zOCAtOTB0MzggLTkwdDkwIC0zOHQ5MCAzOHQzOCA5MHpNNTEyIDEwMjRxMCA1MiAtMzggOTB0LTkwIDM4dC05MCAtMzh0LTM4IC05MHQzOCAtOTB0OTAgLTM4dDkwIDM4dDM4IDkwek0xNTM2IDI1NnEwIC0xNTkgLTExMi41IC0yNzEuNXQtMjcxLjUgLTExMi41dC0yNzEuNSAxMTIuNXQtMTEyLjUgMjcxLjV0MTEyLjUgMjcxLjV0MjcxLjUgMTEyLjV0MjcxLjUgLTExMi41CnQxMTIuNSAtMjcxLjV6TTE0NDAgMTM0NHEwIC0yMCAtMTMgLTM4bC0xMDU2IC0xNDA4cS0xOSAtMjYgLTUxIC0yNmgtMTYwcS0yNiAwIC00NSAxOXQtMTkgNDVxMCAyMCAxMyAzOGwxMDU2IDE0MDhxMTkgMjYgNTEgMjZoMTYwcTI2IDAgNDUgLTE5dDE5IC00NXpNNzY4IDEwMjRxMCAtMTU5IC0xMTIuNSAtMjcxLjV0LTI3MS41IC0xMTIuNXQtMjcxLjUgMTEyLjV0LTExMi41IDI3MS41dDExMi41IDI3MS41dDI3MS41IDExMi41CnQyNzEuNSAtMTEyLjV0MTEyLjUgLTI3MS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNjIxIiB1bmljb2RlPSImI3hmMjk2OyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTA0IDgzMGw3OTIgLTEwMTVsLTg2OCA2MzBxLTE4IDEzIC0yNSAzNC41dDAgNDIuNWwxMDEgMzA4djB6TTU2NiA4MzBoNjYwbC0zMzAgLTEwMTV2MHpNMzY4IDE0NDJsMTk4IC02MTJoLTQ2MmwxOTggNjEycTggMjMgMzMgMjN0MzMgLTIzek0xNjg4IDgzMGwxMDEgLTMwOHE3IC0yMSAwIC00Mi41dC0yNSAtMzQuNWwtODY4IC02MzBsNzkyIDEwMTV2MHpNMTY4OCA4MzBoLTQ2MmwxOTggNjEycTggMjMgMzMgMjN0MzMgLTIzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNjIyIiB1bmljb2RlPSImI3hmMjk3OyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMzg0IDcwNGgxNjB2MjI0aC0xNjB2LTIyNHpNMTIyMSAzNzJ2OTJxLTEwNCAtMzYgLTI0MyAtMzhxLTEzNSAtMSAtMjU5LjUgNDYuNXQtMjIwLjUgMTIyLjVsMSAtOTZxODggLTgwIDIxMiAtMTI4LjV0MjcyIC00Ny41cTEyOSAwIDIzOCA0OXpNNjQwIDcwNGg2NDB2MjI0aC02NDB2LTIyNHpNMTc5MiA3MzZxMCAtMTg3IC05OSAtMzUycTg5IC0xMDIgODkgLTIyOXEwIC0xNTcgLTEyOS41IC0yNjh0LTMxMy41IC0xMTEKcS0xMjIgMCAtMjI1IDUyLjV0LTE2MSAxNDAuNXEtMTkgLTEgLTU3IC0xdC01NyAxcS01OCAtODggLTE2MSAtMTQwLjV0LTIyNSAtNTIuNXEtMTg0IDAgLTMxMy41IDExMXQtMTI5LjUgMjY4cTAgMTI3IDg5IDIyOXEtOTkgMTY1IC05OSAzNTJxMCAyMDkgMTIwIDM4NS41dDMyNi41IDI3OS41dDQ0OS41IDEwM3Q0NDkuNSAtMTAzdDMyNi41IC0yNzkuNXQxMjAgLTM4NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNjIzIiB1bmljb2RlPSImI3hmMjk4OyIgCmQ9Ik01MTUgNjI1di0xMjhoLTI1MnYxMjhoMjUyek01MTUgODgwdi0xMjdoLTI1MnYxMjdoMjUyek0xMjczIDM2OXYtMTI4aC0zNDF2MTI4aDM0MXpNMTI3MyA2MjV2LTEyOGgtNjcydjEyOGg2NzJ6TTEyNzMgODgwdi0xMjdoLTY3MnYxMjdoNjcyek0xNDA4IDIwdjEyNDBxMCA4IC02IDE0dC0xNCA2aC0zMmwtMzc4IC0yNTZsLTIxMCAxNzFsLTIxMCAtMTcxbC0zNzggMjU2aC0zMnEtOCAwIC0xNCAtNnQtNiAtMTR2LTEyNDBxMCAtOCA2IC0xNAp0MTQgLTZoMTI0MHE4IDAgMTQgNnQ2IDE0ek01NTMgMTEzMGwxODUgMTUwaC00MDZ6TTk4MyAxMTMwbDIyMSAxNTBoLTQwNnpNMTUzNiAxMjYwdi0xMjQwcTAgLTYyIC00MyAtMTA1dC0xMDUgLTQzaC0xMjQwcS02MiAwIC0xMDUgNDN0LTQzIDEwNXYxMjQwcTAgNjIgNDMgMTA1dDEwNSA0M2gxMjQwcTYyIDAgMTA1IC00M3Q0MyAtMTA1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNjI0IiB1bmljb2RlPSImI3hmMjk5OyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNODk2IDcyMHEtMTA0IDE5NiAtMTYwIDI3OHEtMTM5IDIwMiAtMzQ3IDMxOHEtMzQgMTkgLTcwIDM2cS04OSA0MCAtOTQgMzJ0MzQgLTM4bDM5IC0zMXE2MiAtNDMgMTEyLjUgLTkzLjV0OTQuNSAtMTE2LjV0NzAuNSAtMTEzdDcwLjUgLTEzMXE5IC0xNyAxMyAtMjVxNDQgLTg0IDg0IC0xNTN0OTggLTE1NHQxMTUuNSAtMTUwdDEzMSAtMTIzLjV0MTQ4LjUgLTkwLjVxMTUzIC02NiAxNTQgLTYwcTEgMyAtNDkgMzdxLTUzIDM2IC04MSA1NwpxLTc3IDU4IC0xNzkgMjExdC0xODUgMzEwek01NDkgMTc3cS03NiA2MCAtMTMyLjUgMTI1dC05OCAxNDMuNXQtNzEgMTU0LjV0LTU4LjUgMTg2dC01MiAyMDl0LTYwLjUgMjUydC03Ni41IDI4OXEyNzMgMCA0OTcuNSAtMzZ0Mzc5IC05MnQyNzEgLTE0NC41dDE4NS41IC0xNzIuNXQxMTAgLTE5OC41dDU2IC0xOTkuNXQxMi41IC0xOTguNXQtOS41IC0xNzN0LTIwIC0xNDMuNXQtMTMgLTEwN2wzMjMgLTMyN2gtMTA0bC0yODEgMjg1CnEtMjIgLTIgLTkxLjUgLTE0dC0xMjEuNSAtMTl0LTEzOCAtNnQtMTYwLjUgMTd0LTE2Ny41IDU5dC0xNzkgMTExeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNjI1IiB1bmljb2RlPSImI3hmMjlhOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTM3NCA4NzlxLTYgMjYgLTI4LjUgMzkuNXQtNDguNSA3LjVxLTI2MSAtNjIgLTQwMSAtNjJ0LTQwMSA2MnEtMjYgNiAtNDguNSAtNy41dC0yOC41IC0zOS41dDcuNSAtNDguNXQzOS41IC0yOC41cTE5NCAtNDYgMzAzIC01OHEtMiAtMTU4IC0xNS41IC0yNjl0LTI2LjUgLTE1NS41dC00MSAtMTE1LjVsLTkgLTIxcS0xMCAtMjUgMSAtNDl0MzYgLTM0cTkgLTQgMjMgLTRxNDQgMCA2MCA0MWw4IDIwcTU0IDEzOSA3MSAyNTloNDIKcTE3IC0xMjAgNzEgLTI1OWw4IC0yMHExNiAtNDEgNjAgLTQxcTE0IDAgMjMgNHEyNSAxMCAzNiAzNHQxIDQ5bC05IDIxcS0yOCA3MSAtNDEgMTE1LjV0LTI2LjUgMTU1LjV0LTE1LjUgMjY5cTEwOSAxMiAzMDMgNThxMjYgNiAzOS41IDI4LjV0Ny41IDQ4LjV6TTEwMjQgMTAyNHEwIDUzIC0zNy41IDkwLjV0LTkwLjUgMzcuNXQtOTAuNSAtMzcuNXQtMzcuNSAtOTAuNXQzNy41IC05MC41dDkwLjUgLTM3LjV0OTAuNSAzNy41dDM3LjUgOTAuNXoKTTE2MDAgNjQwcTAgLTE0MyAtNTUuNSAtMjczLjV0LTE1MCAtMjI1dC0yMjUgLTE1MHQtMjczLjUgLTU1LjV0LTI3My41IDU1LjV0LTIyNSAxNTB0LTE1MCAyMjV0LTU1LjUgMjczLjV0NTUuNSAyNzMuNXQxNTAgMjI1dDIyNSAxNTB0MjczLjUgNTUuNXQyNzMuNSAtNTUuNXQyMjUgLTE1MHQxNTAgLTIyNXQ1NS41IC0yNzMuNXpNODk2IDE0MDhxLTE1NiAwIC0yOTggLTYxdC0yNDUgLTE2NHQtMTY0IC0yNDV0LTYxIC0yOTh0NjEgLTI5OAp0MTY0IC0yNDV0MjQ1IC0xNjR0Mjk4IC02MXQyOTggNjF0MjQ1IDE2NHQxNjQgMjQ1dDYxIDI5OHQtNjEgMjk4dC0xNjQgMjQ1dC0yNDUgMTY0dC0yOTggNjF6TTE3OTIgNjQwcTAgLTE4MiAtNzEgLTM0OHQtMTkxIC0yODZ0LTI4NiAtMTkxdC0zNDggLTcxdC0zNDggNzF0LTI4NiAxOTF0LTE5MSAyODZ0LTcxIDM0OHQ3MSAzNDh0MTkxIDI4NnQyODYgMTkxdDM0OCA3MXQzNDggLTcxdDI4NiAtMTkxdDE5MSAtMjg2dDcxIC0zNDh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il82MjYiIHVuaWNvZGU9IiYjeGYyOWI7IiAKZD0iTTE0MzggNzIzcTM0IC0zNSAyOSAtODJsLTQ0IC01NTFxLTQgLTQyIC0zNC41IC03MHQtNzEuNSAtMjhxLTYgMCAtOSAxcS00NCAzIC03Mi41IDM2LjV0LTI1LjUgNzcuNWwzNSA0MjlsLTE0MyAtOHE1NSAtMTEzIDU1IC0yNDBxMCAtMjE2IC0xNDggLTM3MmwtMTM3IDEzN3E5MSAxMDEgOTEgMjM1cTAgMTQ1IC0xMDIuNSAyNDh0LTI0Ny41IDEwM3EtMTM0IDAgLTIzNiAtOTJsLTEzNyAxMzhxMTIwIDExNCAyODQgMTQxbDI2NCAzMDAKbC0xNDkgODdsLTE4MSAtMTYxcS0zMyAtMzAgLTc3IC0yNy41dC03MyAzNS41dC0yNi41IDc3dDM0LjUgNzNsMjM5IDIxM3EyNiAyMyA2MCAyNi41dDY0IC0xNC41bDQ4OCAtMjgzcTM2IC0yMSA0OCAtNjhxMTcgLTY3IC0yNiAtMTE3bC0yMDUgLTIzMmwzNzEgMjBxNDkgMyA4MyAtMzJ6TTEyNDAgMTE4MHEtNzQgMCAtMTI2IDUydC01MiAxMjZ0NTIgMTI2dDEyNiA1MnQxMjYuNSAtNTJ0NTIuNSAtMTI2dC01Mi41IC0xMjZ0LTEyNi41IC01MnoKTTYxMyAtNjJxMTA2IDAgMTk2IDYxbDEzOSAtMTM5cS0xNDYgLTExNiAtMzM1IC0xMTZxLTE0OCAwIC0yNzMuNSA3M3QtMTk4LjUgMTk4dC03MyAyNzNxMCAxODggMTE2IDMzNmwxMzkgLTEzOXEtNjAgLTg4IC02MCAtMTk3cTAgLTE0NSAxMDIuNSAtMjQ3LjV0MjQ3LjUgLTEwMi41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJfNjI3IiB1bmljb2RlPSImI3hmMjljOyIgCmQ9Ik04ODAgMzM2di0xNjBxMCAtMTQgLTkgLTIzdC0yMyAtOWgtMTYwcS0xNCAwIC0yMyA5dC05IDIzdjE2MHEwIDE0IDkgMjN0MjMgOWgxNjBxMTQgMCAyMyAtOXQ5IC0yM3pNMTEzNiA4MzJxMCAtNTAgLTE1IC05MHQtNDUuNSAtNjl0LTUyIC00NHQtNTkuNSAtMzZxLTMyIC0xOCAtNDYuNSAtMjh0LTI2IC0yNHQtMTEuNSAtMjl2LTMycTAgLTE0IC05IC0yM3QtMjMgLTloLTE2MHEtMTQgMCAtMjMgOXQtOSAyM3Y2OHEwIDM1IDEwLjUgNjQuNQp0MjQgNDcuNXQzOSAzNS41dDQxIDI1LjV0NDQuNSAyMXE1MyAyNSA3NSA0M3QyMiA0OXEwIDQyIC00My41IDcxLjV0LTk1LjUgMjkuNXEtNTYgMCAtOTUgLTI3cS0yOSAtMjAgLTgwIC04M3EtOSAtMTIgLTI1IC0xMnEtMTEgMCAtMTkgNmwtMTA4IDgycS0xMCA3IC0xMiAyMHQ1IDIzcTEyMiAxOTIgMzQ5IDE5MnExMjkgMCAyMzguNSAtODkuNXQxMDkuNSAtMjE0LjV6TTc2OCAxMjgwcS0xMzAgMCAtMjQ4LjUgLTUxdC0yMDQgLTEzNi41CnQtMTM2LjUgLTIwNHQtNTEgLTI0OC41dDUxIC0yNDguNXQxMzYuNSAtMjA0dDIwNCAtMTM2LjV0MjQ4LjUgLTUxdDI0OC41IDUxdDIwNCAxMzYuNXQxMzYuNSAyMDR0NTEgMjQ4LjV0LTUxIDI0OC41dC0xMzYuNSAyMDR0LTIwNCAxMzYuNXQtMjQ4LjUgNTF6TTE1MzYgNjQwcTAgLTIwOSAtMTAzIC0zODUuNXQtMjc5LjUgLTI3OS41dC0zODUuNSAtMTAzdC0zODUuNSAxMDN0LTI3OS41IDI3OS41dC0xMDMgMzg1LjV0MTAzIDM4NS41CnQyNzkuNSAyNzkuNXQzODUuNSAxMDN0Mzg1LjUgLTEwM3QyNzkuNSAtMjc5LjV0MTAzIC0zODUuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0iXzYyOCIgdW5pY29kZT0iJiN4ZjI5ZDsiIGhvcml6LWFkdi14PSIxNDA4IiAKZD0iTTM2NiAxMjI1cS02NCAwIC0xMTAgNDUuNXQtNDYgMTEwLjVxMCA2NCA0NiAxMDkuNXQxMTAgNDUuNXQxMDkuNSAtNDUuNXQ0NS41IC0xMDkuNXEwIC02NSAtNDUuNSAtMTEwLjV0LTEwOS41IC00NS41ek05MTcgNTgzcTAgLTUwIC0zMCAtNjcuNXQtNjMuNSAtNi41dC00Ny41IDM0bC0zNjcgNDM4cS03IDEyIC0xNCAxNS41dC0xMSAxLjVsLTMgLTNxLTcgLTggNCAtMjFsMTIyIC0xMzlsMSAtMzU0bC0xNjEgLTQ1NwpxLTY3IC0xOTIgLTkyIC0yMzRxLTE1IC0yNiAtMjggLTMycS01MCAtMjYgLTEwMyAtMXEtMjkgMTMgLTQxLjUgNDN0LTkuNSA1N3EyIDE3IDE5NyA2MThsNSA0MTZsLTg1IC0xNjRsMzUgLTIyMnE0IC0yNCAtMSAtNDJ0LTE0IC0yNy41dC0xOSAtMTZ0LTE3IC03LjVsLTcgLTJxLTE5IC0zIC0zNC41IDN0LTI0IDE2dC0xNCAyMnQtNy41IDE5LjV0LTIgOS41bC00NiAyOTlsMjExIDM4MXEyMyAzNCAxMTMgMzRxNzUgMCAxMDcgLTQwbDQyNCAtNTIxCnE3IC01IDE0IC0xN2wzIC0zbC0xIC0xcTcgLTEzIDcgLTI5ek01MTQgNDMzcTQzIC0xMTMgODguNSAtMjI1dDY5LjUgLTE2OGwyNCAtNTVxMzYgLTkzIDQyIC0xMjVxMTEgLTcwIC0zNiAtOTdxLTM1IC0yMiAtNjYgLTE2dC01MSAyMnQtMjkgMzVoLTFxLTYgMTYgLTggMjVsLTEyNCAzNTF6TTEzMzggLTE1OXEzMSAtNDkgMzEgLTU3cTAgLTUgLTMgLTdxLTkgLTUgLTE0LjUgMC41dC0xNS41IDI2dC0xNiAzMC41cS0xMTQgMTcyIC00MjMgNjYxCnEzIC0xIDcgMXQ3IDRsMyAycTExIDkgMTEgMTd6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il82MjkiIHVuaWNvZGU9IiYjeGYyOWU7IiBob3Jpei1hZHYteD0iMjMwNCIgCmQ9Ik01MDQgNTQyaDE3MWwtMSAyNjV6TTE1MzAgNjQxcTAgODcgLTUwLjUgMTQwdC0xNDYuNSA1M2gtNTR2LTM4OGg1MnE5MSAwIDE0NSA1N3Q1NCAxMzh6TTk1NiAxMDE4bDEgLTc1NnEwIC0xNCAtOS41IC0yNHQtMjMuNSAtMTBoLTIxNnEtMTQgMCAtMjMuNSAxMHQtOS41IDI0djYyaC0yOTFsLTU1IC04MXEtMTAgLTE1IC0yOCAtMTVoLTI2N3EtMjEgMCAtMzAuNSAxOHQzLjUgMzVsNTU2IDc1N3E5IDE0IDI3IDE0aDMzMnExNCAwIDI0IC0xMAp0MTAgLTI0ek0xNzgzIDY0MXEwIC0xOTMgLTEyNS41IC0zMDN0LTMyNC41IC0xMTBoLTI3MHEtMTQgMCAtMjQgMTB0LTEwIDI0djc1NnEwIDE0IDEwIDI0dDI0IDEwaDI2OHEyMDAgMCAzMjYgLTEwOXQxMjYgLTMwMnpNMTkzOSA2NDBxMCAtMTEgLTAuNSAtMjl0LTggLTcxLjV0LTIxLjUgLTEwMnQtNDQuNSAtMTA4dC03My41IC0xMDIuNWgtNTFxMzggNDUgNjYuNSAxMDQuNXQ0MS41IDExMnQyMSA5OHQ5IDcyLjVsMSAyN3EwIDggLTAuNSAyMi41CnQtNy41IDYwdC0yMCA5MS41dC00MSAxMTEuNXQtNjYgMTI0LjVoNDNxNDEgLTQ3IDcyIC0xMDd0NDUuNSAtMTExLjV0MjMgLTk2dDEwLjUgLTcwLjV6TTIxMjMgNjQwcTAgLTExIC0wLjUgLTI5dC04IC03MS41dC0yMS41IC0xMDJ0LTQ1IC0xMDh0LTc0IC0xMDIuNWgtNTFxMzggNDUgNjYuNSAxMDQuNXQ0MS41IDExMnQyMSA5OHQ5IDcyLjVsMSAyN3EwIDggLTAuNSAyMi41dC03LjUgNjB0LTE5LjUgOTEuNXQtNDAuNSAxMTEuNXQtNjYgMTI0LjUKaDQzcTQxIC00NyA3MiAtMTA3dDQ1LjUgLTExMS41dDIzIC05NnQxMC41IC03MC41ek0yMzA0IDY0MHEwIC0xMSAtMC41IC0yOXQtOCAtNzEuNXQtMjEuNSAtMTAydC00NC41IC0xMDh0LTczLjUgLTEwMi41aC01MXEzOCA0NSA2NiAxMDQuNXQ0MSAxMTJ0MjEgOTh0OSA3Mi41bDEgMjdxMCA4IC0wLjUgMjIuNXQtNy41IDYwdC0xOS41IDkxLjV0LTQwLjUgMTExLjV0LTY2IDEyNC41aDQzcTQxIC00NyA3MiAtMTA3dDQ1LjUgLTExMS41dDIzIC05Ngp0OS41IC03MC41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmlGMkEwIiB1bmljb2RlPSImI3hmMmEwOyIgaG9yaXotYWR2LXg9IjE0MDgiIApkPSJNNjE3IC0xNTNxMCAxMSAtMTMgNTh0LTMxIDEwN3QtMjAgNjlxLTEgNCAtNSAyNi41dC04LjUgMzZ0LTEzLjUgMjEuNXEtMTUgMTQgLTUxIDE0cS0yMyAwIC03MCAtNS41dC03MSAtNS41cS0zNCAwIC00NyAxMXEtNiA1IC0xMSAxNS41dC03LjUgMjB0LTYuNSAyNHQtNSAxOC41cS0zNyAxMjggLTM3IDI1NXQzNyAyNTVxMSA0IDUgMTguNXQ2LjUgMjR0Ny41IDIwdDExIDE1LjVxMTMgMTEgNDcgMTFxMjQgMCA3MSAtNS41dDcwIC01LjUKcTM2IDAgNTEgMTRxOSA4IDEzLjUgMjEuNXQ4LjUgMzZ0NSAyNi41cTIgOSAyMCA2OXQzMSAxMDd0MTMgNThxMCAyMiAtNDMuNSA1Mi41dC03NS41IDQyLjVxLTIwIDggLTQ1IDhxLTM0IDAgLTk4IC0xOHEtNTcgLTE3IC05Ni41IC00MC41dC03MSAtNjZ0LTQ2IC03MHQtNDUuNSAtOTQuNXEtNiAtMTIgLTkgLTE5cS00OSAtMTA3IC02OCAtMjE2dC0xOSAtMjQ0dDE5IC0yNDR0NjggLTIxNnE1NiAtMTIyIDgzIC0xNjFxNjMgLTkxIDE3OSAtMTI3Cmw2IC0ycTY0IC0xOCA5OCAtMThxMjUgMCA0NSA4cTMyIDEyIDc1LjUgNDIuNXQ0My41IDUyLjV6TTc3NiA3NjBxLTI2IDAgLTQ1IDE5dC0xOSA0NS41dDE5IDQ1LjVxMzcgMzcgMzcgOTBxMCA1MiAtMzcgOTFxLTE5IDE5IC0xOSA0NXQxOSA0NXQ0NSAxOXQ0NSAtMTlxNzUgLTc1IDc1IC0xODF0LTc1IC0xODFxLTIxIC0xOSAtNDUgLTE5ek05NTcgNTc5cS0yNyAwIC00NSAxOXEtMTkgMTkgLTE5IDQ1dDE5IDQ1cTExMiAxMTQgMTEyIDI3Mgp0LTExMiAyNzJxLTE5IDE5IC0xOSA0NXQxOSA0NXQ0NSAxOXQ0NSAtMTlxMTUwIC0xNTAgMTUwIC0zNjJ0LTE1MCAtMzYycS0xOCAtMTkgLTQ1IC0xOXpNMTEzOCAzOThxLTI3IDAgLTQ1IDE5cS0xOSAxOSAtMTkgNDV0MTkgNDVxOTAgOTEgMTM4LjUgMjA4dDQ4LjUgMjQ1dC00OC41IDI0NXQtMTM4LjUgMjA4cS0xOSAxOSAtMTkgNDV0MTkgNDV0NDUgMTl0NDUgLTE5cTEwOSAtMTA5IDE2NyAtMjQ5dDU4IC0yOTR0LTU4IC0yOTR0LTE2NyAtMjQ5CnEtMTggLTE5IC00NSAtMTl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyQTEiIHVuaWNvZGU9IiYjeGYyYTE7IiBob3Jpei1hZHYteD0iMjE3NiIgCmQ9Ik0xOTIgMzUycS02NiAwIC0xMTMgLTQ3dC00NyAtMTEzdDQ3IC0xMTN0MTEzIC00N3QxMTMgNDd0NDcgMTEzdC00NyAxMTN0LTExMyA0N3pNNzA0IDM1MnEtNjYgMCAtMTEzIC00N3QtNDcgLTExM3Q0NyAtMTEzdDExMyAtNDd0MTEzIDQ3dDQ3IDExM3QtNDcgMTEzdC0xMTMgNDd6TTcwNCA4NjRxLTY2IDAgLTExMyAtNDd0LTQ3IC0xMTN0NDcgLTExM3QxMTMgLTQ3dDExMyA0N3Q0NyAxMTN0LTQ3IDExM3QtMTEzIDQ3ek0xNDcyIDM1MgpxLTY2IDAgLTExMyAtNDd0LTQ3IC0xMTN0NDcgLTExM3QxMTMgLTQ3dDExMyA0N3Q0NyAxMTN0LTQ3IDExM3QtMTEzIDQ3ek0xOTg0IDM1MnEtNjYgMCAtMTEzIC00N3QtNDcgLTExM3Q0NyAtMTEzdDExMyAtNDd0MTEzIDQ3dDQ3IDExM3QtNDcgMTEzdC0xMTMgNDd6TTE0NzIgODY0cS02NiAwIC0xMTMgLTQ3dC00NyAtMTEzdDQ3IC0xMTN0MTEzIC00N3QxMTMgNDd0NDcgMTEzdC00NyAxMTN0LTExMyA0N3pNMTk4NCA4NjQKcS02NiAwIC0xMTMgLTQ3dC00NyAtMTEzdDQ3IC0xMTN0MTEzIC00N3QxMTMgNDd0NDcgMTEzdC00NyAxMTN0LTExMyA0N3pNMTk4NCAxMzc2cS02NiAwIC0xMTMgLTQ3dC00NyAtMTEzdDQ3IC0xMTN0MTEzIC00N3QxMTMgNDd0NDcgMTEzdC00NyAxMTN0LTExMyA0N3pNMzg0IDE5MnEwIC04MCAtNTYgLTEzNnQtMTM2IC01NnQtMTM2IDU2dC01NiAxMzZ0NTYgMTM2dDEzNiA1NnQxMzYgLTU2dDU2IC0xMzZ6TTg5NiAxOTJxMCAtODAgLTU2IC0xMzYKdC0xMzYgLTU2dC0xMzYgNTZ0LTU2IDEzNnQ1NiAxMzZ0MTM2IDU2dDEzNiAtNTZ0NTYgLTEzNnpNMzg0IDcwNHEwIC04MCAtNTYgLTEzNnQtMTM2IC01NnQtMTM2IDU2dC01NiAxMzZ0NTYgMTM2dDEzNiA1NnQxMzYgLTU2dDU2IC0xMzZ6TTg5NiA3MDRxMCAtODAgLTU2IC0xMzZ0LTEzNiAtNTZ0LTEzNiA1NnQtNTYgMTM2dDU2IDEzNnQxMzYgNTZ0MTM2IC01NnQ1NiAtMTM2ek0zODQgMTIxNnEwIC04MCAtNTYgLTEzNnQtMTM2IC01Ngp0LTEzNiA1NnQtNTYgMTM2dDU2IDEzNnQxMzYgNTZ0MTM2IC01NnQ1NiAtMTM2ek0xNjY0IDE5MnEwIC04MCAtNTYgLTEzNnQtMTM2IC01NnQtMTM2IDU2dC01NiAxMzZ0NTYgMTM2dDEzNiA1NnQxMzYgLTU2dDU2IC0xMzZ6TTg5NiAxMjE2cTAgLTgwIC01NiAtMTM2dC0xMzYgLTU2dC0xMzYgNTZ0LTU2IDEzNnQ1NiAxMzZ0MTM2IDU2dDEzNiAtNTZ0NTYgLTEzNnpNMjE3NiAxOTJxMCAtODAgLTU2IC0xMzZ0LTEzNiAtNTZ0LTEzNiA1Ngp0LTU2IDEzNnQ1NiAxMzZ0MTM2IDU2dDEzNiAtNTZ0NTYgLTEzNnpNMTY2NCA3MDRxMCAtODAgLTU2IC0xMzZ0LTEzNiAtNTZ0LTEzNiA1NnQtNTYgMTM2dDU2IDEzNnQxMzYgNTZ0MTM2IC01NnQ1NiAtMTM2ek0yMTc2IDcwNHEwIC04MCAtNTYgLTEzNnQtMTM2IC01NnQtMTM2IDU2dC01NiAxMzZ0NTYgMTM2dDEzNiA1NnQxMzYgLTU2dDU2IC0xMzZ6TTE2NjQgMTIxNnEwIC04MCAtNTYgLTEzNnQtMTM2IC01NnQtMTM2IDU2dC01NiAxMzYKdDU2IDEzNnQxMzYgNTZ0MTM2IC01NnQ1NiAtMTM2ek0yMTc2IDEyMTZxMCAtODAgLTU2IC0xMzZ0LTEzNiAtNTZ0LTEzNiA1NnQtNTYgMTM2dDU2IDEzNnQxMzYgNTZ0MTM2IC01NnQ1NiAtMTM2eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmlGMkEyIiB1bmljb2RlPSImI3hmMmEyOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTI4IC0xOTJxMCAtMjYgLTE5IC00NXQtNDUgLTE5dC00NSAxOXQtMTkgNDV0MTkgNDV0NDUgMTl0NDUgLTE5dDE5IC00NXpNMzIwIDBxMCAtMjYgLTE5IC00NXQtNDUgLTE5dC00NSAxOXQtMTkgNDV0MTkgNDV0NDUgMTl0NDUgLTE5dDE5IC00NXpNMzY1IDM2NWwyNTYgLTI1NmwtOTAgLTkwbC0yNTYgMjU2ek03MDQgMzg0cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOXQtNDUgMTl0LTE5IDQ1dDE5IDQ1dDQ1IDE5dDQ1IC0xOXQxOSAtNDV6Ck0xNDExIDcwNHEwIC01OSAtMTEuNSAtMTA4LjV0LTM3LjUgLTkzLjV0LTQ0IC02Ny41dC01MyAtNjQuNXEtMzEgLTM1IC00NS41IC01NHQtMzMuNSAtNTB0LTI2LjUgLTY0dC03LjUgLTc0cTAgLTE1OSAtMTEyLjUgLTI3MS41dC0yNzEuNSAtMTEyLjVxLTI2IDAgLTQ1IDE5dC0xOSA0NXQxOSA0NXQ0NSAxOXExMDYgMCAxODEgNzV0NzUgMTgxcTAgNTcgMTEuNSAxMDUuNXQzNyA5MXQ0My41IDY2LjV0NTIgNjNxNDAgNDYgNTkuNSA3Mgp0MzcuNSA3NC41dDE4IDEwMy41cTAgMTg1IC0xMzEuNSAzMTYuNXQtMzE2LjUgMTMxLjV0LTMxNi41IC0xMzEuNXQtMTMxLjUgLTMxNi41cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOXQtNDUgMTl0LTE5IDQ1cTAgMTE3IDQ1LjUgMjIzLjV0MTIzIDE4NHQxODQgMTIzdDIyMy41IDQ1LjV0MjIzLjUgLTQ1LjV0MTg0IC0xMjN0MTIzIC0xODR0NDUuNSAtMjIzLjV6TTg5NiA1NzZxMCAtMjYgLTE5IC00NXQtNDUgLTE5dC00NSAxOXQtMTkgNDV0MTkgNDUKdDQ1IDE5dDQ1IC0xOXQxOSAtNDV6TTExODQgNzA0cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOXQtNDUgMTl0LTE5IDQ1cTAgOTMgLTY1LjUgMTU4LjV0LTE1OC41IDY1LjVxLTkyIDAgLTE1OCAtNjUuNXQtNjYgLTE1OC41cTAgLTI2IC0xOSAtNDV0LTQ1IC0xOXQtNDUgMTl0LTE5IDQ1cTAgMTQ2IDEwMyAyNDl0MjQ5IDEwM3QyNDkgLTEwM3QxMDMgLTI0OXpNMTU3OCA5OTNxMTAgLTI1IC0xIC00OXQtMzYgLTM0cS05IC00IC0yMyAtNApxLTE5IDAgLTM1LjUgMTF0LTIzLjUgMzBxLTY4IDE3OCAtMjI0IDI5NXEtMjEgMTYgLTI1IDQydDEyIDQ3cTE3IDIxIDQzIDI1dDQ3IC0xMnExODMgLTEzNyAyNjYgLTM1MXpNMTc4OCAxMDc0cTkgLTI1IC0xLjUgLTQ5dC0zNS41IC0zNHEtMTEgLTQgLTIzIC00cS00NCAwIC02MCA0MXEtOTIgMjM4IC0yOTcgMzkzcS0yMiAxNiAtMjUuNSA0MnQxMi41IDQ3cTE2IDIyIDQyIDI1LjV0NDcgLTEyLjVxMjM1IC0xNzUgMzQxIC00NDl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyQTMiIHVuaWNvZGU9IiYjeGYyYTM7IiBob3Jpei1hZHYteD0iMjMwNCIgCmQ9Ik0xMDMyIDU3NnEtNTkgMiAtODQgNTVxLTE3IDM0IC00OCA1My41dC02OCAxOS41cS01MyAwIC05MC41IC0zNy41dC0zNy41IC05MC41cTAgLTU2IDM2IC04OWwxMCAtOHEzNCAtMzEgODIgLTMxcTM3IDAgNjggMTkuNXQ0OCA1My41cTI1IDUzIDg0IDU1ek0xNjAwIDcwNHEwIDU2IC0zNiA4OWwtMTAgOHEtMzQgMzEgLTgyIDMxcS0zNyAwIC02OCAtMTkuNXQtNDggLTUzLjVxLTI1IC01MyAtODQgLTU1cTU5IC0yIDg0IC01NQpxMTcgLTM0IDQ4IC01My41dDY4IC0xOS41cTUzIDAgOTAuNSAzNy41dDM3LjUgOTAuNXpNMTE3NCA5MjVxLTE3IC0zNSAtNTUgLTQ4dC03MyA0cS02MiAzMSAtMTM0IDMxcS01MSAwIC05OSAtMTdxMyAwIDkuNSAwLjV0OS41IDAuNXE5MiAwIDE3MC41IC01MHQxMTguNSAtMTMzcTE3IC0zNiAzLjUgLTczLjV0LTQ5LjUgLTU0LjVxLTE4IC05IC0zOSAtOXEyMSAwIDM5IC05cTM2IC0xNyA0OS41IC01NC41dC0zLjUgLTczLjUKcS00MCAtODMgLTExOC41IC0xMzN0LTE3MC41IC01MGgtNnEtMTYgMiAtNDQgNGwtMjkwIDI3bC0yMzkgLTEyMHEtMTQgLTcgLTI5IC03cS00MCAwIC01NyAzNWwtMTYwIDMyMHEtMTEgMjMgLTQgNDcuNXQyOSAzNy41bDIwOSAxMTlsMTQ4IDI2N3ExNyAxNTUgOTEuNSAyOTEuNXQxOTUuNSAyMzYuNXEzMSAyNSA3MC41IDIxLjV0NjQuNSAtMzQuNXQyMS41IC03MHQtMzQuNSAtNjVxLTcwIC01OSAtMTE3IC0xMjhxMTIzIDg0IDI2NyAxMDEKcTQwIDUgNzEuNSAtMTl0MzUuNSAtNjRxNSAtNDAgLTE5IC03MS41dC02NCAtMzUuNXEtODQgLTEwIC0xNTkgLTU1cTQ2IDEwIDk5IDEwcTExNSAwIDIxOCAtNTBxMzYgLTE4IDQ5IC01NS41dC01IC03My41ek0yMTM3IDEwODVsMTYwIC0zMjBxMTEgLTIzIDQgLTQ3LjV0LTI5IC0zNy41bC0yMDkgLTExOWwtMTQ4IC0yNjdxLTE3IC0xNTUgLTkxLjUgLTI5MS41dC0xOTUuNSAtMjM2LjVxLTI2IC0yMiAtNjEgLTIycS00NSAwIC03NCAzNQpxLTI1IDMxIC0yMS41IDcwdDM0LjUgNjVxNzAgNTkgMTE3IDEyOHEtMTIzIC04NCAtMjY3IC0xMDFxLTQgLTEgLTEyIC0xcS0zNiAwIC02My41IDI0dC0zMS41IDYwcS01IDQwIDE5IDcxLjV0NjQgMzUuNXE4NCAxMCAxNTkgNTVxLTQ2IC0xMCAtOTkgLTEwcS0xMTUgMCAtMjE4IDUwcS0zNiAxOCAtNDkgNTUuNXQ1IDczLjVxMTcgMzUgNTUgNDh0NzMgLTRxNjIgLTMxIDEzNCAtMzFxNTEgMCA5OSAxN3EtMyAwIC05LjUgLTAuNXQtOS41IC0wLjUKcS05MiAwIC0xNzAuNSA1MHQtMTE4LjUgMTMzcS0xNyAzNiAtMy41IDczLjV0NDkuNSA1NC41cTE4IDkgMzkgOXEtMjEgMCAtMzkgOXEtMzYgMTcgLTQ5LjUgNTQuNXQzLjUgNzMuNXE0MCA4MyAxMTguNSAxMzN0MTcwLjUgNTBoNmgxcTE0IC0yIDQyIC00bDI5MSAtMjdsMjM5IDEyMHExNCA3IDI5IDdxNDAgMCA1NyAtMzV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyQTQiIHVuaWNvZGU9IiYjeGYyYTQ7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xMDU2IDcwNHEwIC0yNiAxOSAtNDV0NDUgLTE5dDQ1IDE5dDE5IDQ1cTAgMTQ2IC0xMDMgMjQ5dC0yNDkgMTAzdC0yNDkgLTEwM3QtMTAzIC0yNDlxMCAtMjYgMTkgLTQ1dDQ1IC0xOXQ0NSAxOXQxOSA0NXEwIDkzIDY2IDE1OC41dDE1OCA2NS41dDE1OCAtNjUuNXQ2NiAtMTU4LjV6TTgzNSAxMjgwcS0xMTcgMCAtMjIzLjUgLTQ1LjV0LTE4NCAtMTIzdC0xMjMgLTE4NHQtNDUuNSAtMjIzLjVxMCAtMjYgMTkgLTQ1dDQ1IC0xOXQ0NSAxOQp0MTkgNDVxMCAxODUgMTMxLjUgMzE2LjV0MzE2LjUgMTMxLjV0MzE2LjUgLTEzMS41dDEzMS41IC0zMTYuNXEwIC01NSAtMTggLTEwMy41dC0zNy41IC03NC41dC01OS41IC03MnEtMzQgLTM5IC01MiAtNjN0LTQzLjUgLTY2LjV0LTM3IC05MXQtMTEuNSAtMTA1LjVxMCAtMTA2IC03NSAtMTgxdC0xODEgLTc1cS0yNiAwIC00NSAtMTl0LTE5IC00NXQxOSAtNDV0NDUgLTE5cTE1OSAwIDI3MS41IDExMi41dDExMi41IDI3MS41cTAgNDEgNy41IDc0CnQyNi41IDY0dDMzLjUgNTB0NDUuNSA1NHEzNSA0MSA1MyA2NC41dDQ0IDY3LjV0MzcuNSA5My41dDExLjUgMTA4LjVxMCAxMTcgLTQ1LjUgMjIzLjV0LTEyMyAxODR0LTE4NCAxMjN0LTIyMy41IDQ1LjV6TTU5MSA1NjFsMjI2IC0yMjZsLTU3OSAtNTc5cS0xMiAtMTIgLTI5IC0xMnQtMjkgMTJsLTE2OCAxNjhxLTEyIDEyIC0xMiAyOXQxMiAyOXpNMTYxMiAxNTI0bDE2OCAtMTY4cTEyIC0xMiAxMiAtMjl0LTEyIC0zMGwtMjMzIC0yMzMKbC0yNiAtMjVsLTcxIC03MXEtNjYgMTUzIC0xOTUgMjU4bDkxIDkxbDIwNyAyMDdxMTMgMTIgMzAgMTJ0MjkgLTEyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmlGMkE1IiB1bmljb2RlPSImI3hmMmE1OyIgCmQ9Ik04NjYgMTAyMXEwIC0yNyAtMTMgLTk0cS0xMSAtNTAgLTMxLjUgLTE1MHQtMzAuNSAtMTUwcS0yIC0xMSAtNC41IC0xMi41dC0xMy41IC0yLjVxLTIwIC0yIC0zMSAtMnEtNTggMCAtODQgNDkuNXQtMjYgMTEzLjVxMCA4OCAzNSAxNzR0MTAzIDEyNHEyOCAxNCA1MSAxNHEyOCAwIDM2LjUgLTE2LjV0OC41IC00Ny41ek0xMzUyIDU5N3EwIDE0IC0zOSA3NS41dC01MiA2Ni41cS0yMSA4IC0zNCA4cS05MSAwIC0yMjYgLTc3bC0yIDIKcTMgMjIgMjcuNSAxMzV0MjQuNSAxNzhxMCAyMzMgLTI0MiAyMzNxLTI0IDAgLTY4IC02cS05NCAtMTcgLTE2OC41IC04OS41dC0xMTEuNSAtMTY2LjV0LTM3IC0xODlxMCAtMTQ2IDgwLjUgLTIyNXQyMjcuNSAtNzlxMjUgMCAyNSAtM3QtMSAtNXEtNCAtMzQgLTI2IC0xMTdxLTE0IC01MiAtNTEuNSAtMTAxdC04Mi41IC00OXEtNDIgMCAtNDIgNDdxMCAyNCAxMC41IDQ3LjV0MjUgMzkuNXQyOS41IDI4LjV0MjYgMjB0MTEgOC41cTAgMyAtNyAxMApxLTI0IDIyIC01OC41IDM2LjV0LTY1LjUgMTQuNXEtMzUgMCAtNjMuNSAtMzR0LTQxIC03NXQtMTIuNSAtNzVxMCAtODggNTEuNSAtMTQydDEzOC41IC01NHE4MiAwIDE1NSA1M3QxMTcuNSAxMjZ0NjUuNSAxNTNxNiAyMiAxNS41IDY2LjV0MTQuNSA2Ni41cTMgMTIgMTQgMThxMTE4IDYwIDIyNyA2MHE0OCAwIDEyNyAtMThxMSAtMSA0IC0xcTUgMCA5LjUgNC41dDQuNSA4LjV6TTE1MzYgMTEyMHYtOTYwcTAgLTExOSAtODQuNSAtMjAzLjUKdC0yMDMuNSAtODQuNWgtOTYwcS0xMTkgMCAtMjAzLjUgODQuNXQtODQuNSAyMDMuNXY5NjBxMCAxMTkgODQuNSAyMDMuNXQyMDMuNSA4NC41aDk2MHExMTkgMCAyMDMuNSAtODQuNXQ4NC41IC0yMDMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjJBNiIgdW5pY29kZT0iJiN4ZjJhNjsiIGhvcml6LWFkdi14PSIxNTM1IiAKZD0iTTc0NCAxMjMxcTAgMjQgLTIgMzguNXQtOC41IDMwdC0yMSAyM3QtMzcuNSA3LjVxLTM5IDAgLTc4IC0yM3EtMTA1IC01OCAtMTU5IC0xOTAuNXQtNTQgLTI2OS41cTAgLTQ0IDguNSAtODUuNXQyNi41IC04MC41dDUyLjUgLTYyLjV0ODEuNSAtMjMuNXE0IDAgMTggLTAuNXQyMCAwdDE2IDN0MTUgOC41dDcgMTZxMTYgNzcgNDggMjMxLjV0NDggMjMxLjVxMTkgOTEgMTkgMTQ2ek0xNDk4IDU3NXEwIC03IC03LjUgLTEzLjV0LTE1LjUgLTYuNQpsLTYgMXEtMjIgMyAtNjIgMTF0LTcyIDEyLjV0LTYzIDQuNXEtMTY3IDAgLTM1MSAtOTNxLTE1IC04IC0yMSAtMjdxLTEwIC0zNiAtMjQuNSAtMTA1LjV0LTIyLjUgLTEwMC41cS0yMyAtOTEgLTcwIC0xNzkuNXQtMTEyLjUgLTE2NC41dC0xNTQuNSAtMTIzdC0xODUgLTQ3cS0xMzUgMCAtMjE0LjUgODMuNXQtNzkuNSAyMTkuNXEwIDUzIDE5LjUgMTE3dDYzIDExNi41dDk3LjUgNTIuNXEzOCAwIDEyMCAtMzMuNXQ4MyAtNjEuNQpxMCAtMSAtMTYuNSAtMTIuNXQtMzkuNSAtMzF0LTQ2IC00NC41dC0zOSAtNjF0LTE2IC03NHEwIC0zMyAxNi41IC01M3Q0OC41IC0yMHE0NSAwIDg1IDMxLjV0NjYuNSA3OHQ0OCAxMDUuNXQzMi41IDEwN3QxNiA5MHY5cTAgMiAtMy41IDMuNXQtOC41IDEuNWgtMTB0LTEwIC0wLjV0LTYgLTAuNXEtMjI3IDAgLTM1MiAxMjIuNXQtMTI1IDM0OC41cTAgMTA4IDM0LjUgMjIxdDk2IDIxMHQxNTYgMTY3LjV0MjA0LjUgODkuNXE1MiA5IDEwNiA5CnEzNzQgMCAzNzQgLTM2MHEwIC05OCAtMzggLTI3M3QtNDMgLTIxMWwzIC0zcTEwMSA1NyAxODIuNSA4OHQxNjcuNSAzMXEyMiAwIDUzIC0xM3ExOSAtNyA4MCAtMTAyLjV0NjEgLTExNi41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmlGMkE3IiB1bmljb2RlPSImI3hmMmE3OyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNODMxIDg2M3EzMiAwIDU5IC0xOGwyMjIgLTE0OHE2MSAtNDAgMTEwIC05N2wxNDYgLTE3MHE0MCAtNDYgMjkgLTEwNmwtNzIgLTQxM3EtNiAtMzIgLTI5LjUgLTUzLjV0LTU1LjUgLTI1LjVsLTUyNyAtNTZsLTM1MiAtMzJoLTlxLTM5IDAgLTY3LjUgMjh0LTI4LjUgNjhxMCAzNyAyNyA2NHQ2NSAzMmwyNjAgMzJoLTQ0OHEtNDEgMCAtNjkuNSAzMHQtMjYuNSA3MXEyIDM5IDMyIDY1dDY5IDI2bDQ0MiAxbC01MjEgNjRxLTQxIDUgLTY2IDM3CnQtMTkgNzNxNiAzNSAzNC41IDU3LjV0NjUuNSAyMi41aDEwbDQ4MSAtNjBsLTM1MSA5NHEtMzggMTAgLTYyIDQxLjV0LTE4IDY4LjVxNiAzNiAzMyA1OC41dDYyIDIyLjVxNiAwIDIwIC0ybDQ0OCAtOTZsMjE3IC0zN3ExIDAgMyAtMC41dDMgLTAuNXEyMyAwIDMwLjUgMjN0LTEyLjUgMzZsLTE4NiAxMjVxLTM1IDIzIC00MiA2My41dDE4IDczLjVxMjcgMzggNzYgMzh6TTc2MSA2NjFsMTg2IC0xMjVsLTIxOCAzN2wtNSAybC0zNiAzOApsLTIzOCAyNjJxLTEgMSAtMi41IDMuNXQtMi41IDMuNXEtMjQgMzEgLTE4LjUgNzB0MzcuNSA2NHEzMSAyMyA2OCAxNy41dDY0IC0zMy41bDE0MiAtMTQ3cS0yIC0xIC01IC0zLjV0LTQgLTQuNXEtMzIgLTQ1IC0yMyAtOTl0NTUgLTg1ek0xNjQ4IDExMTVsMTUgLTI2NnE0IC03MyAtMTEgLTE0N2wtNDggLTIxOXEtMTIgLTU5IC02NyAtODdsLTEwNiAtNTRxMiA2MiAtMzkgMTA5bC0xNDYgMTcwcS01MyA2MSAtMTE3IDEwM2wtMjIyIDE0OApxLTM0IDIzIC03NiAyM3EtNTEgMCAtODggLTM3bC0yMzUgMzEycS0yNSAzMyAtMTggNzMuNXQ0MSA2My41cTMzIDIyIDcxLjUgMTR0NjIuNSAtNDBsMjY2IC0zNTJsLTI2MiA0NTVxLTIxIDM1IC0xMC41IDc1dDQ3LjUgNTlxMzUgMTggNzIuNSA2dDU3LjUgLTQ2bDI0MSAtNDIwbC0xMzYgMzM3cS0xNSAzNSAtNC41IDc0dDQ0LjUgNTZxMzcgMTkgNzYgNnQ1NiAtNTFsMTkzIC00MTVsMTAxIC0xOTZxOCAtMTUgMjMgLTE3LjV0MjcgNy41dDExIDI2CmwtMTIgMjI0cS0yIDQxIDI2IDcxdDY5IDMxcTM5IDAgNjcgLTI4LjV0MzAgLTY3LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyQTgiIHVuaWNvZGU9IiYjeGYyYTg7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0zMzUgMTgwcS0yIDAgLTYgMnEtODYgNTcgLTE2OC41IDE0NXQtMTM5LjUgMTgwcS0yMSAzMCAtMjEgNjlxMCA5IDIgMTl0NCAxOHQ3IDE4dDguNSAxNnQxMC41IDE3dDEwIDE1dDEyIDE1LjV0MTEgMTQuNXExODQgMjUxIDQ1MiAzNjVxLTExMCAxOTggLTExMCAyMTFxMCAxOSAxNyAyOXExMTYgNjQgMTI4IDY0cTE4IDAgMjggLTE2bDEyNCAtMjI5cTkyIDE5IDE5MiAxOXEyNjYgMCA0OTcuNSAtMTM3LjV0Mzc4LjUgLTM2OS41CnEyMCAtMzEgMjAgLTY5dC0yMCAtNjlxLTkxIC0xNDIgLTIxOC41IC0yNTMuNXQtMjc4LjUgLTE3NS41cTExMCAtMTk4IDExMCAtMjExcTAgLTIwIC0xNyAtMjlxLTExNiAtNjQgLTEyNyAtNjRxLTE5IDAgLTI5IDE2bC0xMjQgMjI5bC02NCAxMTlsLTQ0NCA4MjBsNyA3cS01OCAtMjQgLTk5IC00N3EzIC01IDEyNyAtMjM0dDI0MyAtNDQ5dDExOSAtMjIzcTAgLTcgLTkgLTlxLTEzIC0zIC03MiAtM3EtNTcgMCAtNjAgN2wtNDU2IDg0MQpxLTM5IC0yOCAtODIgLTY4cTI0IC00MyAyMTQgLTM5My41dDE5MCAtMzU0LjVxMCAtMTAgLTExIC0xMHEtMTQgMCAtODIuNSAyMnQtNzIuNSAyOGwtMTA2IDE5N2wtMjI0IDQxM3EtNDQgLTUzIC03OCAtMTA2cTIgLTMgMTggLTI1dDIzIC0zNGwxNzYgLTMyN3EwIC0xMCAtMTAgLTEwek0xMTY1IDI4Mmw0OSAtOTFxMjczIDExMSA0NTAgMzg1cS0xODAgMjc3IC00NTkgMzg5cTY3IC02NCAxMDMgLTE0OC41dDM2IC0xNzYuNQpxMCAtMTA2IC00NyAtMjAwLjV0LTEzMiAtMTU3LjV6TTg0OCA4OTZxMCAtMjAgMTQgLTM0dDM0IC0xNHE4NiAwIDE0NyAtNjF0NjEgLTE0N3EwIC0yMCAxNCAtMzR0MzQgLTE0dDM0IDE0dDE0IDM0cTAgMTI2IC04OSAyMTV0LTIxNSA4OXEtMjAgMCAtMzQgLTE0dC0xNCAtMzR6TTEyMTQgOTYxbC05IDRsNyAtN3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjJBOSIgdW5pY29kZT0iJiN4ZjJhOTsiIGhvcml6LWFkdi14PSIxMjgwIiAKZD0iTTEwNTAgNDMwcTAgLTIxNSAtMTQ3IC0zNzRxLTE0OCAtMTYxIC0zNzggLTE2MXEtMjMyIDAgLTM3OCAxNjFxLTE0NyAxNTkgLTE0NyAzNzRxMCAxNDcgNjggMjcwLjV0MTg5IDE5Ni41dDI2OCA3M3E5NiAwIDE4MiAtMzFxLTMyIC02MiAtMzkgLTEyNnEtNjYgMjggLTE0MyAyOHEtMTY3IDAgLTI4MC41IC0xMjN0LTExMy41IC0yOTFxMCAtMTcwIDExMi41IC0yODguNXQyODEuNSAtMTE4LjV0MjgxIDExOC41dDExMiAyODguNQpxMCA4OSAtMzIgMTY2cTY2IDEzIDEyMyA0OXE0MSAtOTggNDEgLTIxMnpNODQ2IDYxOXEwIC0xOTIgLTc5LjUgLTM0NXQtMjM4LjUgLTI1M2wtMTQgLTFxLTI5IDAgLTYyIDVxODMgMzIgMTQ2LjUgMTAyLjV0OTkuNSAxNTQuNXQ1OC41IDE4OXQzMCAxOTIuNXQ3LjUgMTc4LjVxMCA2OSAtMyAxMDNxNTUgLTE2MCA1NSAtMzI2ek03OTEgOTQ3di0ycS03MyAyMTQgLTIwNiA0NDBxODggLTU5IDE0Mi41IC0xODYuNXQ2My41IC0yNTEuNXoKTTEwMzUgNzQ0cS04MyAwIC0xNjAgNzVxMjE4IDEyMCAyOTAgMjQ3cTE5IDM3IDIxIDU2cS00MiAtOTQgLTEzOS41IC0xNjYuNXQtMjA0LjUgLTk3LjVxLTM1IDU0IC0zNSAxMTNxMCAzNyAxNyA3OXQ0MyA2OHE0NiA0NCAxNTcgNzRxNTkgMTYgMTA2IDU4LjV0NzQgMTAwLjVxNzQgLTEwNSA3NCAtMjUzcTAgLTEwOSAtMjQgLTE3MHEtMzIgLTc3IC04OC41IC0xMzAuNXQtMTMwLjUgLTUzLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyQUEiIHVuaWNvZGU9IiYjeGYyYWE7IiAKZD0iTTEwNTAgNDk1cTAgNzggLTI4IDE0N3EtNDEgLTI1IC04NSAtMzRxMjIgLTUwIDIyIC0xMTRxMCAtMTE3IC03NyAtMTk4LjV0LTE5MyAtODEuNXQtMTkzLjUgODEuNXQtNzcuNSAxOTguNXEwIDExNSA3OCAxOTkuNXQxOTMgODQuNXE1MyAwIDk4IC0xOXE0IDQzIDI3IDg3cS02MCAyMSAtMTI1IDIxcS0xNTQgMCAtMjU3LjUgLTEwOC41dC0xMDMuNSAtMjYzLjV0MTAzLjUgLTI2MXQyNTcuNSAtMTA2dDI1Ny41IDEwNi41dDEwMy41IDI2MC41egpNODcyIDg1MHEyIC0yNCAyIC03MXEwIC02MyAtNSAtMTIzdC0yMC41IC0xMzIuNXQtNDAuNSAtMTMwdC02OC41IC0xMDZ0LTEwMC41IC03MC41cTIxIC0zIDQyIC0zaDEwcTIxOSAxMzkgMjE5IDQxMXEwIDExNiAtMzggMjI1ek04NzIgODUwcS00IDgwIC00NCAxNzEuNXQtOTggMTMwLjVxOTIgLTE1NiAxNDIgLTMwMnpNMTIwNyA5NTVxMCAxMDIgLTUxIDE3NHEtNDEgLTg2IC0xMjQgLTEwOXEtNjkgLTE5IC0xMDkgLTUzLjV0LTQwIC05OS41CnEwIC00MCAyNCAtNzdxNzQgMTcgMTQwLjUgNjd0OTUuNSAxMTVxLTQgLTUyIC03NC41IC0xMTEuNXQtMTM4LjUgLTk3LjVxNTIgLTUyIDExMCAtNTJxNTEgMCA5MCAzN3Q2MCA5MHExNyA0MiAxNyAxMTd6TTE1MzYgMTEyMHYtOTYwcTAgLTExOSAtODQuNSAtMjAzLjV0LTIwMy41IC04NC41aC05NjBxLTExOSAwIC0yMDMuNSA4NC41dC04NC41IDIwMy41djk2MHEwIDExOSA4NC41IDIwMy41dDIwMy41IDg0LjVoOTYwcTExOSAwIDIwMy41IC04NC41CnQ4NC41IC0yMDMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjJBQiIgdW5pY29kZT0iJiN4ZjJhYjsiIApkPSJNMTI3OSAzODhxMCAyMiAtMjIgMjdxLTY3IDE1IC0xMTggNTl0LTgwIDEwOHEtNyAxOSAtNyAyNXEwIDE1IDE5LjUgMjZ0NDMgMTd0NDMgMjAuNXQxOS41IDM2LjVxMCAxOSAtMTguNSAzMS41dC0zOC41IDEyLjVxLTEyIDAgLTMyIC04dC0zMSAtOHEtNCAwIC0xMiAycTUgOTUgNSAxMTRxMCA3OSAtMTcgMTE0cS0zNiA3OCAtMTAzIDEyMS41dC0xNTIgNDMuNXEtMTk5IDAgLTI3NSAtMTY1cS0xNyAtMzUgLTE3IC0xMTRxMCAtMTkgNSAtMTE0CnEtNCAtMiAtMTQgLTJxLTEyIDAgLTMyIDcuNXQtMzAgNy41cS0yMSAwIC0zOC41IC0xMnQtMTcuNSAtMzJxMCAtMjEgMTkuNSAtMzUuNXQ0MyAtMjAuNXQ0MyAtMTd0MTkuNSAtMjZxMCAtNiAtNyAtMjVxLTY0IC0xMzggLTE5OCAtMTY3cS0yMiAtNSAtMjIgLTI3cTAgLTQ2IDEzNyAtNjhxMiAtNSA2IC0yNnQxMS41IC0zMC41dDIzLjUgLTkuNXExMiAwIDM3LjUgNC41dDM5LjUgNC41cTM1IDAgNjcgLTE1dDU0IC0zMi41dDU3LjUgLTMyLjUKdDc2LjUgLTE1cTQzIDAgNzkgMTV0NTcuNSAzMi41dDUzLjUgMzIuNXQ2NyAxNXExNCAwIDM5LjUgLTR0MzguNSAtNHExNiAwIDIzIDEwdDExIDMwdDYgMjVxMTM3IDIyIDEzNyA2OHpNMTUzNiA2NDBxMCAtMjA5IC0xMDMgLTM4NS41dC0yNzkuNSAtMjc5LjV0LTM4NS41IC0xMDN0LTM4NS41IDEwM3QtMjc5LjUgMjc5LjV0LTEwMyAzODUuNXQxMDMgMzg1LjV0Mjc5LjUgMjc5LjV0Mzg1LjUgMTAzdDM4NS41IC0xMDN0Mjc5LjUgLTI3OS41CnQxMDMgLTM4NS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmlGMkFDIiB1bmljb2RlPSImI3hmMmFjOyIgaG9yaXotYWR2LXg9IjE2NjQiIApkPSJNODQ4IDE0MDhxMTM0IDEgMjQwLjUgLTY4LjV0MTYzLjUgLTE5Mi41cTI3IC01OCAyNyAtMTc5cTAgLTQ3IC05IC0xOTFxMTQgLTcgMjggLTdxMTggMCA1MSAxMy41dDUxIDEzLjVxMjkgMCA1NiAtMTh0MjcgLTQ2cTAgLTMyIC0zMS41IC01NHQtNjkgLTMxLjV0LTY5IC0yOXQtMzEuNSAtNDcuNXEwIC0xNSAxMiAtNDNxMzcgLTgyIDEwMi41IC0xNTB0MTQ0LjUgLTEwMXEyOCAtMTIgODAgLTIzcTI4IC02IDI4IC0zNQpxMCAtNzAgLTIxOSAtMTAzcS03IC0xMSAtMTEgLTM5dC0xNCAtNDYuNXQtMzMgLTE4LjVxLTIwIDAgLTYyIDYuNXQtNjQgNi41cS0zNyAwIC02MiAtNXEtMzIgLTUgLTYzIC0yMi41dC01OCAtMzh0LTU4IC00MC41dC03NiAtMzMuNXQtOTkgLTEzLjVxLTUyIDAgLTk2LjUgMTMuNXQtNzUgMzMuNXQtNTcuNSA0MC41dC01OCAzOHQtNjIgMjIuNXEtMjYgNSAtNjMgNXEtMjQgMCAtNjUuNSAtNy41dC01OC41IC03LjVxLTI1IDAgLTM1IDE4LjUKdC0xNCA0Ny41dC0xMSA0MHEtMjE5IDMzIC0yMTkgMTAzcTAgMjkgMjggMzVxNTIgMTEgODAgMjNxNzggMzIgMTQ0LjUgMTAxdDEwMi41IDE1MHExMiAyOCAxMiA0M3EwIDI4IC0zMS41IDQ3LjV0LTY5LjUgMjkuNXQtNjkuNSAzMS41dC0zMS41IDUyLjVxMCAyNyAyNiA0NS41dDU1IDE4LjVxMTUgMCA0OCAtMTN0NTMgLTEzcTE4IDAgMzIgN3EtOSAxNDIgLTkgMTkwcTAgMTIyIDI3IDE4MHE2NCAxMzcgMTcyIDE5OHQyNjQgNjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyQUQiIHVuaWNvZGU9IiYjeGYyYWQ7IiAKZD0iTTEyODAgMzg4cTAgMjIgLTIyIDI3cS02NyAxNCAtMTE4IDU4dC04MCAxMDlxLTcgMTQgLTcgMjVxMCAxNSAxOS41IDI2dDQyLjUgMTd0NDIuNSAyMC41dDE5LjUgMzYuNXEwIDE5IC0xOC41IDMxLjV0LTM4LjUgMTIuNXEtMTEgMCAtMzEgLTh0LTMyIC04cS00IDAgLTEyIDJxNSA2MyA1IDExNXEwIDc4IC0xNyAxMTRxLTM2IDc4IC0xMDIuNSAxMjEuNXQtMTUyLjUgNDMuNXEtMTk4IDAgLTI3NSAtMTY1cS0xOCAtMzggLTE4IC0xMTUKcTAgLTM4IDYgLTExNHEtMTAgLTIgLTE1IC0ycS0xMSAwIC0zMS41IDh0LTMwLjUgOHEtMjAgMCAtMzcuNSAtMTIuNXQtMTcuNSAtMzIuNXEwIC0yMSAxOS41IC0zNS41dDQyLjUgLTIwLjV0NDIuNSAtMTd0MTkuNSAtMjZxMCAtMTEgLTcgLTI1cS02NCAtMTM4IC0xOTggLTE2N3EtMjIgLTUgLTIyIC0yN3EwIC00NyAxMzggLTY5cTIgLTUgNiAtMjZ0MTEgLTMwLjV0MjMgLTkuNXExMyAwIDM4LjUgNXQzOC41IDVxMzUgMCA2Ny41IC0xNQp0NTQuNSAtMzIuNXQ1Ny41IC0zMi41dDc2LjUgLTE1cTQzIDAgNzkgMTV0NTcuNSAzMi41dDU0IDMyLjV0NjcuNSAxNXExMyAwIDM5IC00LjV0MzkgLTQuNXExNSAwIDIyLjUgOS41dDExLjUgMzF0NSAyNC41cTEzOCAyMiAxMzggNjl6TTE1MzYgMTEyMHYtOTYwcTAgLTExOSAtODQuNSAtMjAzLjV0LTIwMy41IC04NC41aC05NjBxLTExOSAwIC0yMDMuNSA4NC41dC04NC41IDIwMy41djk2MHEwIDExOSA4NC41IDIwMy41dDIwMy41IDg0LjVoOTYwCnExMTkgMCAyMDMuNSAtODQuNXQ4NC41IC0yMDMuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjJBRSIgdW5pY29kZT0iJiN4ZjJhZTsiIGhvcml6LWFkdi14PSIyMzA0IiAKZD0iTTIzMDQgMTUzNnEtNjkgLTQ2IC0xMjUgLTkydC04OSAtODF0LTU5LjUgLTcxLjV0LTM3LjUgLTU3LjV0LTIyIC00NC41dC0xNCAtMjkuNXEtMTAgLTE4IC0zNS41IC0xMzYuNXQtNDguNSAtMTY0LjVxLTE1IC0yOSAtNTAgLTYwLjV0LTY3LjUgLTUwLjV0LTcyLjUgLTQxdC00OCAtMjhxLTQ3IC0zMSAtMTUxIC0yMzFxLTM0MSAxNCAtNjMwIC0xNThxLTkyIC01MyAtMzAzIC0xNzlxNDcgMTYgODYgMzF0NTUgMjJsMTUgNwpxNzEgMjcgMTYzIDY0LjV0MTMzLjUgNTMuNXQxMDggMzQuNXQxNDIuNSAzMS41cTE4NiAzMSA0NjUgLTdxMSAwIDEwIC0zcTExIC02IDE0IC0xN3QtMyAtMjJsLTE5NCAtMzQ1cS0xNSAtMjkgLTQ3IC0yMnEtMTI4IDI0IC0zNTQgMjRxLTE0NiAwIC00MDIgLTQ0LjV0LTM5MiAtNDYuNXEtODIgLTEgLTE0OSAxM3QtMTA3IDM3dC02MSA0MHQtMzMgMzRsLTEgMXYycTAgNiA2IDZxMTM4IDAgMzcxIDU1cTE5MiAzNjYgMzc0LjUgNTI0dDM4My41IDE1OApxNSAwIDE0LjUgLTAuNXQzOCAtNXQ1NSAtMTJ0NjEuNSAtMjQuNXQ2MyAtMzkuNXQ1NCAtNTl0NDAgLTgyLjVsMTAyIDE3N3EyIDQgMjEgNDIuNXQ0NC41IDg2LjV0NjEgMTA5LjV0ODQgMTMzLjV0MTAwLjUgMTM3cTY2IDgyIDEyOCAxNDEuNXQxMjEuNSA5Ni41dDkyLjUgNTMuNXQ4OCAzOS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmlGMkIwIiB1bmljb2RlPSImI3hmMmIwOyIgCmQ9Ik0xMzIyIDY0MHEwIC00NSAtNSAtNzZsLTIzNiAxNGwyMjQgLTc4cS0xOSAtNzMgLTU4IC0xNDFsLTIxNCAxMDNsMTc3IC0xNThxLTQ0IC02MSAtMTA3IC0xMDhsLTE1NyAxNzhsMTAzIC0yMTVxLTYxIC0zNyAtMTQwIC01OWwtNzkgMjI4bDE0IC0yNDBxLTM4IC02IC03NiAtNnQtNzYgNmwxNCAyMzhsLTc4IC0yMjZxLTc0IDE5IC0xNDAgNTlsMTAzIDIxNWwtMTU3IC0xNzhxLTU5IDQzIC0xMDggMTA4bDE3OCAxNThsLTIxNCAtMTA0CnEtMzkgNjkgLTU4IDE0MWwyMjQgNzlsLTIzNyAtMTRxLTUgNDIgLTUgNzZxMCAzNSA1IDc3bDIzOCAtMTRsLTIyNSA3OXExOSA3MyA1OCAxNDBsMjE0IC0xMDRsLTE3NyAxNTlxNDYgNjEgMTA3IDEwOGwxNTggLTE3OGwtMTAzIDIxNXE2NyAzOSAxNDAgNThsNzcgLTIyNGwtMTMgMjM2cTM2IDYgNzUgNnEzOCAwIDc2IC02bC0xNCAtMjM3bDc4IDIyNXE3NCAtMTkgMTQwIC01OWwtMTAzIC0yMTRsMTU4IDE3OHE2MSAtNDcgMTA3IC0xMDgKbC0xNzcgLTE1OWwyMTMgMTA0cTM3IC02MiA1OCAtMTQxbC0yMjQgLTc4bDIzNyAxNHE1IC0zMSA1IC03N3pNMTM1MiA2NDBxMCAxNjAgLTc4LjUgMjk1LjV0LTIxMyAyMTR0LTI5Mi41IDc4LjVxLTExOSAwIC0yMjcgLTQ2LjV0LTE4Ni41IC0xMjV0LTEyNC41IC0xODcuNXQtNDYgLTIyOXEwIC0xMTkgNDYgLTIyOHQxMjQuNSAtMTg3LjV0MTg2LjUgLTEyNXQyMjcgLTQ2LjVxMTU4IDAgMjkyLjUgNzguNXQyMTMgMjE0dDc4LjUgMjk0LjV6Ck0xNDI1IDEwMjN2LTc2NmwtNjU3IC0zODNsLTY1NyAzODN2NzY2bDY1NyAzODN6TTc2OCAtMTgzbDcwOCA0MTJ2ODIzbC03MDggNDExbC03MDggLTQxMXYtODIzek0xNTM2IDEwODh2LTg5NmwtNzY4IC00NDhsLTc2OCA0NDh2ODk2bDc2OCA0NDh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyQjEiIHVuaWNvZGU9IiYjeGYyYjE7IiBob3Jpei1hZHYteD0iMTY2NCIgCmQ9Ik0zMzkgMTMxOGg2OTFsLTI2IC03MmgtNjY1cS0xMTAgMCAtMTg4LjUgLTc5dC03OC41IC0xODl2LTc3MXEwIC05NSA2MC41IC0xNjkuNXQxNTMuNSAtOTMuNXEyMyAtNSA5OCAtNXYtNzJoLTQ1cS0xNDAgMCAtMjM5LjUgMTAwdC05OS41IDI0MHY3NzFxMCAxNDAgOTkuNSAyNDB0MjM5LjUgMTAwek0xMTkwIDE1MzZoMjQ3bC00ODIgLTEyOTRxLTIzIC02MSAtNDAuNSAtMTAzLjV0LTQ1IC05OHQtNTQgLTkzLjV0LTY0LjUgLTc4LjUKdC03OS41IC02NXQtOTUuNSAtNDF0LTExNiAtMTguNXYxOTVxMTYzIDI2IDIyMCAxODJxMjAgNTIgMjAgMTA1cTAgNTQgLTIwIDEwNmwtMjg1IDczM2gyMjhsMTg3IC01ODV6TTE2NjQgOTc4di0xMTExaC03OTVxMzcgNTUgNDUgNzNoNjc4djEwMzhxMCA4NSAtNDkuNSAxNTV0LTEyOS41IDk5bDI1IDY3cTEwMSAtMzQgMTYzLjUgLTEyMy41dDYyLjUgLTE5Ny41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmlGMkIyIiB1bmljb2RlPSImI3hmMmIyOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNODUyIDEyMjdxMCAtMjkgLTE3IC01Mi41dC00NSAtMjMuNXQtNDUgMjMuNXQtMTcgNTIuNXQxNyA1Mi41dDQ1IDIzLjV0NDUgLTIzLjV0MTcgLTUyLjV6TTY4OCAtMTQ5djExNHEwIDMwIC0yMC41IDUxLjV0LTUwLjUgMjEuNXQtNTAgLTIxLjV0LTIwIC01MS41di0xMTRxMCAtMzAgMjAuNSAtNTJ0NDkuNSAtMjJxMzAgMCA1MC41IDIydDIwLjUgNTJ6TTg2MCAtMTQ5djExNHEwIDMwIC0yMCA1MS41dC01MCAyMS41dC01MC41IC0yMS41CnQtMjAuNSAtNTEuNXYtMTE0cTAgLTMwIDIwLjUgLTUydDUwLjUgLTIycTI5IDAgNDkuNSAyMnQyMC41IDUyek0xMDM0IC0xNDl2MTE0cTAgMzAgLTIwLjUgNTEuNXQtNTAuNSAyMS41dC01MC41IC0yMS41dC0yMC41IC01MS41di0xMTRxMCAtMzAgMjAuNSAtNTJ0NTAuNSAtMjJ0NTAuNSAyMnQyMC41IDUyek0xMjA4IC0xNDl2MTE0cTAgMzAgLTIwLjUgNTEuNXQtNTAuNSAyMS41dC01MC41IC0yMS41dC0yMC41IC01MS41di0xMTQKcTAgLTMwIDIwLjUgLTUydDUwLjUgLTIydDUwLjUgMjJ0MjAuNSA1MnpNMTQ3NiA1MzVxLTg0IC0xNjAgLTIzMiAtMjU5LjV0LTMyMyAtOTkuNXEtMTIzIDAgLTIyOS41IDUxLjV0LTE3OC41IDEzN3QtMTEzIDE5Ny41dC00MSAyMzJxMCA4OCAyMSAxNzRxLTEwNCAtMTc1IC0xMDQgLTM5MHEwIC0xNjIgNjUgLTMxMnQxODUgLTI1MXEzMCA1NyA5MSA1N3E1NiAwIDg2IC01MHEzMiA1MCA4NyA1MHE1NiAwIDg2IC01MHEzMiA1MCA4NyA1MHQ4NyAtNTAKcTMwIDUwIDg2IDUwcTI4IDAgNTIuNSAtMTUuNXQzNy41IC00MC41cTExMiA5NCAxNzcgMjMxLjV0NzMgMjg3LjV6TTEzMjYgNTY0cTAgNzUgLTcyIDc1cS0xNyAwIC00NyAtNnEtOTUgLTE5IC0xNDkgLTE5cS0yMjYgMCAtMjI2IDI0M3EwIDg2IDMwIDIwNHEtODMgLTEyNyAtODMgLTI3NXEwIC0xNTAgODkgLTI2MC41dDIzNSAtMTEwLjVxMTExIDAgMjEwIDcwcTEzIDQ4IDEzIDc5ek04ODQgMTIyM3EwIDUwIC0zMiA4OS41dC04MSAzOS41CnQtODEgLTM5LjV0LTMyIC04OS41cTAgLTUxIDMxLjUgLTkwLjV0ODEuNSAtMzkuNXQ4MS41IDM5LjV0MzEuNSA5MC41ek0xNTEzIDg4NHEwIDk2IC0zNy41IDE3OXQtMTEzIDEzN3QtMTczLjUgNTRxLTc3IDAgLTE0OSAtMzV0LTEyNyAtOTRxLTQ4IC0xNTkgLTQ4IC0yNjhxMCAtMTA0IDQ1LjUgLTE1N3QxNDcuNSAtNTNxNTMgMCAxNDIgMTlxMzYgNiA1MyA2cTUxIDAgNzcuNSAtMjh0MjYuNSAtODBxMCAtMjYgLTQgLTQ2CnE3NSA2OCAxMTcuNSAxNjUuNXQ0Mi41IDIwMC41ek0xNzkyIDY2N3EwIC0xMTEgLTMzLjUgLTI0OS41dC05My41IC0yMDQuNXEtNTggLTY0IC0xOTUgLTE0Mi41dC0yMjggLTEwNC41bC00IC0xdi0xMTRxMCAtNDMgLTI5LjUgLTc1dC03Mi41IC0zMnEtNTYgMCAtODYgNTBxLTMyIC01MCAtODcgLTUwdC04NyA1MHEtMzAgLTUwIC04NiAtNTBxLTU1IDAgLTg3IDUwcS0zMCAtNTAgLTg2IC01MHEtNDcgMCAtNzUgMzMuNXQtMjggODEuNQpxLTkwIC02OCAtMTk4IC02OHEtMTE4IDAgLTIxMSA4MHE1NCAxIDEwNiAyMHEtMTEzIDMxIC0xODIgMTI3cTMyIC03IDcxIC03cTg5IDAgMTY0IDQ2cS0xOTIgMTkyIC0yNDAgMzA2cS0yNCA1NiAtMjQgMTYwcTAgNTcgOSAxMjUuNXQzMS41IDE0Ni41dDU1IDE0MXQ4Ni41IDEwNXQxMjAgNDJxNTkgMCA4MSAtNTJxMTkgMjkgNDIgNTRxMiAzIDEyIDEzdDEzIDE2cTEwIDE1IDIzIDM4dDI1IDQydDI4IDM5cTg3IDExMSAyMTEuNSAxNzcKdDI2MC41IDY2cTM1IDAgNjIgLTRxNTkgNjQgMTQ2IDY0cTgzIDAgMTQwIC01N3E1IC01IDUgLTEycTAgLTUgLTYgLTEzLjV0LTEyLjUgLTE2dC0xNiAtMTdsLTEwLjUgLTEwLjVxMTcgLTYgMzYgLTE4dDE5IC0yNHEwIC02IC0xNiAtMjVxMTU3IC0xMzggMTk3IC0zNzhxMjUgMzAgNjAgMzBxNDUgMCAxMDAgLTQ5cTkwIC04MCA5MCAtMjc5eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmlGMkIzIiB1bmljb2RlPSImI3hmMmIzOyIgCmQ9Ik05MTcgNjMxcTAgMzMgLTYgNjRoLTM2MnYtMTMyaDIxN3EtMTIgLTc2IC03NC41IC0xMjAuNXQtMTQyLjUgLTQ0LjVxLTk5IDAgLTE2OSA3MS41dC03MCAxNzAuNXQ3MCAxNzAuNXQxNjkgNzEuNXE5MyAwIDE1MyAtNTlsMTA0IDEwMXEtMTA4IDEwMCAtMjU3IDEwMHEtMTYwIDAgLTI3MiAtMTEyLjV0LTExMiAtMjcxLjV0MTEyIC0yNzEuNXQyNzIgLTExMi41cTE2NSAwIDI2Ni41IDEwNXQxMDEuNSAyNzB6TTEyNjIgNTg1aDEwOXYxMTAKaC0xMDl2MTEwaC0xMTB2LTExMGgtMTEwdi0xMTBoMTEwdi0xMTBoMTEwdjExMHpNMTUzNiA2NDBxMCAtMjA5IC0xMDMgLTM4NS41dC0yNzkuNSAtMjc5LjV0LTM4NS41IC0xMDN0LTM4NS41IDEwM3QtMjc5LjUgMjc5LjV0LTEwMyAzODUuNXQxMDMgMzg1LjV0Mjc5LjUgMjc5LjV0Mzg1LjUgMTAzdDM4NS41IC0xMDN0Mjc5LjUgLTI3OS41dDEwMyAtMzg1LjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyQjQiIHVuaWNvZGU9IiYjeGYyYjQ7IiAKZD0iTTE1MzYgMTAyNHYtODM5cTAgLTQ4IC00OSAtNjJxLTE3NCAtNTIgLTMzOCAtNTJxLTczIDAgLTIxNS41IDI5LjV0LTIyNy41IDI5LjVxLTE2NCAwIC0zNzAgLTQ4di0zMzhoLTE2MHYxMzY4cS02MyAyNSAtMTAxIDgxdC0zOCAxMjRxMCA5MSA2NCAxNTV0MTU1IDY0dDE1NSAtNjR0NjQgLTE1NXEwIC02OCAtMzggLTEyNHQtMTAxIC04MXYtNjhxMTkwIDQ0IDM0MyA0NHE5OSAwIDE5OCAtMTVxMTQgLTIgMTExLjUgLTIyLjV0MTQ5LjUgLTIwLjUKcTc3IDAgMTY1IDE4cTExIDIgODAgMjF0ODkgMTlxMjYgMCA0NSAtMTl0MTkgLTQ1eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmlGMkI1IiB1bmljb2RlPSImI3hmMmI1OyIgaG9yaXotYWR2LXg9IjIzMDQiIApkPSJNMTkyIDM4NHE0MCAwIDU2IDMydDAgNjR0LTU2IDMydC01NiAtMzJ0MCAtNjR0NTYgLTMyek0xNjY1IDQ0MnEtMTAgMTMgLTM4LjUgNTB0LTQxLjUgNTR0LTM4IDQ5dC00Mi41IDUzdC00MC41IDQ3dC00NSA0OWwtMTI1IC0xNDBxLTgzIC05NCAtMjA4LjUgLTkydC0yMDUuNSA5OHEtNTcgNjkgLTU2LjUgMTU4dDU4LjUgMTU3bDE3NyAyMDZxLTIyIDExIC01MSAxNi41dC00Ny41IDZ0LTU2LjUgLTAuNXQtNDkgLTFxLTkyIDAgLTE1OCAtNjYKbC0xNTggLTE1OGgtMTU1di01NDRxNSAwIDIxIDAuNXQyMiAwdDE5LjUgLTJ0MjAuNSAtNC41dDE3LjUgLTguNXQxOC41IC0xMy41bDI5NyAtMjkycTExNSAtMTExIDIyNyAtMTExcTc4IDAgMTI1IDQ3cTU3IC0yMCAxMTIuNSA4dDcyLjUgODVxNzQgLTYgMTI3IDQ0cTIwIDE4IDM2IDQ1LjV0MTQgNTAuNXExMCAtMTAgNDMgLTEwcTQzIDAgNzcgMjF0NDkuNSA1M3QxMiA3MS41dC0zMC41IDczLjV6TTE4MjQgMzg0aDk2djUxMmgtOTNsLTE1NyAxODAKcS02NiA3NiAtMTY5IDc2aC0xNjdxLTg5IDAgLTE0NiAtNjdsLTIwOSAtMjQzcS0yOCAtMzMgLTI4IC03NXQyNyAtNzVxNDMgLTUxIDExMCAtNTJ0MTExIDQ5bDE5MyAyMThxMjUgMjMgNTMuNSAyMS41dDQ3IC0yN3Q4LjUgLTU2LjVxMTYgLTE5IDU2IC02M3Q2MCAtNjhxMjkgLTM2IDgyLjUgLTEwNS41dDY0LjUgLTg0LjVxNTIgLTY2IDYwIC0xNDB6TTIxMTIgMzg0cTQwIDAgNTYgMzJ0MCA2NHQtNTYgMzJ0LTU2IC0zMnQwIC02NHQ1NiAtMzJ6Ck0yMzA0IDk2MHYtNjQwcTAgLTI2IC0xOSAtNDV0LTQ1IC0xOWgtNDM0cS0yNyAtNjUgLTgyIC0xMDYuNXQtMTI1IC01MS41cS0zMyAtNDggLTgwLjUgLTgxLjV0LTEwMi41IC00NS41cS00MiAtNTMgLTEwNC41IC04MS41dC0xMjguNSAtMjQuNXEtNjAgLTM0IC0xMjYgLTM5LjV0LTEyNy41IDE0dC0xMTcgNTMuNXQtMTAzLjUgODFsLTI4NyAyODJoLTM1OHEtMjYgMCAtNDUgMTl0LTE5IDQ1djY3MnEwIDI2IDE5IDQ1dDQ1IDE5aDQyMQpxMTQgMTQgNDcgNDh0NDcuNSA0OHQ0NCA0MHQ1MC41IDM3LjV0NTEgMjUuNXQ2MiAxOS41dDY4IDUuNWgxMTdxOTkgMCAxODEgLTU2cTgyIDU2IDE4MSA1NmgxNjdxMzUgMCA2NyAtNnQ1Ni41IC0xNC41dDUxLjUgLTI2LjV0NDQuNSAtMzF0NDMgLTM5LjV0MzkgLTQydDQxIC00OHQ0MS41IC00OC41aDM1NXEyNiAwIDQ1IC0xOXQxOSAtNDV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyQjYiIHVuaWNvZGU9IiYjeGYyYjY7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xNzkyIDg4MnYtOTc4cTAgLTY2IC00NyAtMTEzdC0xMTMgLTQ3aC0xNDcycS02NiAwIC0xMTMgNDd0LTQ3IDExM3Y5NzhxMCAxNSAxMSAyNHE4IDcgMzkgMzQuNXQ0MS41IDM2dDQ1LjUgMzcuNXQ3MCA1NS41dDk2IDczdDE0My41IDEwN3QxOTIuNSAxNDAuNXE1IDQgNTIuNSA0MHQ3MS41IDUyLjV0NjQgMzV0NjkgMTguNXQ2OSAtMTguNXQ2NSAtMzUuNXQ3MSAtNTJ0NTIgLTQwcTExMCAtODAgMTkyLjUgLTE0MC41dDE0My41IC0xMDcKdDk2IC03M3Q3MCAtNTUuNXQ0NS41IC0zNy41dDQxLjUgLTM2dDM5IC0zNC41cTExIC05IDExIC0yNHpNMTIyOCAyOTdxMjYzIDE5MSAzNDUgMjUycTExIDggMTIuNSAyMC41dC02LjUgMjMuNWwtMzggNTJxLTggMTEgLTIxIDEyLjV0LTI0IC02LjVxLTIzMSAtMTY5IC0zNDMgLTI1MHEtNSAtMyAtNTIgLTM5dC03MS41IC01Mi41dC02NC41IC0zNXQtNjkgLTE4LjV0LTY5IDE4LjV0LTY0LjUgMzV0LTcxLjUgNTIuNXQtNTIgMzkKcS0xODYgMTM0IC0zNDMgMjUwcS0xMSA4IC0yNCA2LjV0LTIxIC0xMi41bC0zOCAtNTJxLTggLTExIC02LjUgLTIzLjV0MTIuNSAtMjAuNXE4MiAtNjEgMzQ1IC0yNTJxMTAgLTggNTAgLTM4dDY1IC00N3Q2NCAtMzkuNXQ3Ny41IC0zMy41dDc1LjUgLTExdDc1LjUgMTF0NzkgMzQuNXQ2NC41IDM5LjV0NjUgNDcuNXQ0OCAzNi41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmlGMkI3IiB1bmljb2RlPSImI3hmMmI3OyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTQ3NCA2MjNsMzkgLTUxcTggLTExIDYuNSAtMjMuNXQtMTEuNSAtMjAuNXEtNDMgLTM0IC0xMjYuNSAtOTguNXQtMTQ2LjUgLTExM3QtNjcgLTUxLjVxLTM5IC0zMiAtNjAgLTQ4dC02MC41IC00MXQtNzYuNSAtMzYuNXQtNzQgLTExLjVoLTFoLTFxLTM3IDAgLTc0IDExLjV0LTc2IDM2LjV0LTYxIDQxLjV0LTYwIDQ3LjVxLTUgNCAtNjUgNTAuNXQtMTQzLjUgMTExdC0xMjIuNSA5NC41cS0xMSA4IC0xMi41IDIwLjV0Ni41IDIzLjUKbDM3IDUycTggMTEgMjEuNSAxM3QyNC41IC03cTk0IC03MyAzMDYgLTIzNnE1IC00IDQzLjUgLTM1dDYwLjUgLTQ2LjV0NTYuNSAtMzIuNXQ1OC41IC0xN2gxaDFxMjQgMCA1OC41IDE3dDU2LjUgMzIuNXQ2MC41IDQ2LjV0NDMuNSAzNXEyNTggMTk4IDMxMyAyNDJxMTEgOCAyNCA2LjV0MjEgLTEyLjV6TTE2NjQgLTk2djkyOHEtOTAgODMgLTE1OSAxMzlxLTkxIDc0IC0zODkgMzA0cS0zIDIgLTQzIDM1dC02MSA0OHQtNTYgMzIuNXQtNTkgMTcuNQpoLTFoLTFxLTI0IDAgLTU5IC0xNy41dC01NiAtMzIuNXQtNjEgLTQ4dC00MyAtMzVxLTIxNSAtMTY2IC0zMTUuNSAtMjQ1LjV0LTEyOS41IC0xMDR0LTgyIC03NC41cS0xNCAtMTIgLTIxIC0xOXYtOTI4cTAgLTEzIDkuNSAtMjIuNXQyMi41IC05LjVoMTQ3MnExMyAwIDIyLjUgOS41dDkuNSAyMi41ek0xNzkyIDgzMnYtOTI4cTAgLTY2IC00NyAtMTEzdC0xMTMgLTQ3aC0xNDcycS02NiAwIC0xMTMgNDd0LTQ3IDExM3Y5MjhxMCA1NiA0MSA5NApxMTIzIDExNCAzNTAgMjkwLjV0MjMzIDE4MS41cTM2IDMwIDU5IDQ3LjV0NjEuNSA0MnQ3NiAzNi41dDc0LjUgMTJoMWgxcTM3IDAgNzQuNSAtMTJ0NzYgLTM2LjV0NjEuNSAtNDJ0NTkgLTQ3LjVxNDMgLTM2IDE1NiAtMTIydDIyNiAtMTc3dDIwMSAtMTczcTQxIC0zOCA0MSAtOTR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyQjgiIHVuaWNvZGU9IiYjeGYyYjg7IiAKZD0iTTMzMCAxbDIwMiAtMjE0bC0zNCAyMzZsLTIxNiAyMTN6TTU1NiAtMjI1bDI3NCAyMThsLTExIDI0NWwtMzAwIC0yMTV6TTI0NSA0MTNsMjI3IC0yMTNsLTQ4IDMyN2wtMjQ1IDIwNHpNNDk1IDE4OWwzMTcgMjE0bC0xNCAzMjRsLTM1MiAtMjAwek04NDMgMTc4bDk1IC04MGwtMiAyMzlsLTEwMyA3OXEwIC0xIDEgLTguNXQwIC0xMnQtNSAtNy41bC03OCAtNTJsODUgLTcwcTcgLTYgNyAtODh6TTEzOCA5MzBsMjU2IC0yMDBsLTY4IDQ2NQpsLTI3OSAxNzN6TTExNzMgMjY3bDE1IDIzNGwtMjMwIC0xNjRsMiAtMjQwek00MTcgNzIybDM3MyAxOTRsLTE5IDQ0MWwtNDIzIC0xNjN6TTEyNzAgMzU3bDIwIDIzM2wtMjI2IDE0MmwtMiAtMTA1bDE0NCAtOTVxNiAtNCA0IC05bC03IC0xMTl6TTE0NjEgNDk2bDMwIDIyMmwtMTc5IC0xMjhsLTIwIC0yMjh6TTEyNzMgMzI5bC03MSA0OWwtOCAtMTE3cTAgLTUgLTQgLThsLTIzNCAtMTg3cS03IC01IC0xNCAwbC05OCA4M2w3IC0xNjEKcTAgLTUgLTQgLThsLTI5MyAtMjM0cS00IC0yIC02IC0ycS04IDIgLTggM2wtMjI4IDI0MnEtNCA0IC01OSAyNzdxLTIgNyA1IDExbDYxIDM3cS05NCA4NiAtOTUgOTJsLTcyIDM1MXEtMiA3IDYgMTJsOTQgNDVxLTEzMyAxMDAgLTEzNSAxMDhsLTk2IDQ2NnEtMiAxMCA3IDEzbDQzMyAxMzVxNSAwIDggLTFsMzE3IC0xNTNxNiAtNCA2IC05bDIwIC00NjNxMCAtNyAtNiAtMTBsLTExOCAtNjFsMTI2IC04NXE1IC0yIDUgLThsNSAtMTIzbDEyMSA3NApxNSA0IDExIDBsODQgLTU2bDMgMTEwcTAgNiA1IDlsMjA2IDEyNnE2IDMgMTEgMGwyNDUgLTEzNXE0IC00IDUgLTd0LTYuNSAtNjB0LTE3LjUgLTEyNC41dC0xMCAtNzAuNXEwIC01IC00IC03bC0xOTEgLTE1M3EtNiAtNSAtMTMgMHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjJCOSIgdW5pY29kZT0iJiN4ZjJiOTsiIGhvcml6LWFkdi14PSIxNjY0IiAKZD0iTTEyMDEgMjk4cTAgNTcgLTUuNSAxMDd0LTIxIDEwMC41dC0zOS41IDg2dC02NCA1OHQtOTEgMjIuNXEtNiAtNCAtMzMuNSAtMjAuNXQtNDIuNSAtMjQuNXQtNDAuNSAtMjB0LTQ5IC0xN3QtNDYuNSAtNXQtNDYuNSA1dC00OSAxN3QtNDAuNSAyMHQtNDIuNSAyNC41dC0zMy41IDIwLjVxLTUxIDAgLTkxIC0yMi41dC02NCAtNTh0LTM5LjUgLTg2dC0yMSAtMTAwLjV0LTUuNSAtMTA3cTAgLTczIDQyIC0xMjEuNXQxMDMgLTQ4LjVoNTc2CnE2MSAwIDEwMyA0OC41dDQyIDEyMS41ek0xMDI4IDg5MnEwIDEwOCAtNzYuNSAxODR0LTE4My41IDc2dC0xODMuNSAtNzZ0LTc2LjUgLTE4NHEwIC0xMDcgNzYuNSAtMTgzdDE4My41IC03NnQxODMuNSA3NnQ3Ni41IDE4M3pNMTY2NCAzNTJ2LTE5MnEwIC0xNCAtOSAtMjN0LTIzIC05aC05NnYtMjI0cTAgLTY2IC00NyAtMTEzdC0xMTMgLTQ3aC0xMjE2cS02NiAwIC0xMTMgNDd0LTQ3IDExM3YxNDcycTAgNjYgNDcgMTEzdDExMyA0N2gxMjE2CnE2NiAwIDExMyAtNDd0NDcgLTExM3YtMjI0aDk2cTE0IDAgMjMgLTl0OSAtMjN2LTE5MnEwIC0xNCAtOSAtMjN0LTIzIC05aC05NnYtMTI4aDk2cTE0IDAgMjMgLTl0OSAtMjN2LTE5MnEwIC0xNCAtOSAtMjN0LTIzIC05aC05NnYtMTI4aDk2cTE0IDAgMjMgLTl0OSAtMjN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyQkEiIHVuaWNvZGU9IiYjeGYyYmE7IiBob3Jpei1hZHYteD0iMTY2NCIgCmQ9Ik0xMDI4IDg5MnEwIC0xMDcgLTc2LjUgLTE4M3QtMTgzLjUgLTc2dC0xODMuNSA3NnQtNzYuNSAxODNxMCAxMDggNzYuNSAxODR0MTgzLjUgNzZ0MTgzLjUgLTc2dDc2LjUgLTE4NHpNOTgwIDY3MnE0NiAwIDgyLjUgLTE3dDYwIC00Ny41dDM5LjUgLTY3dDI0IC04MXQxMS41IC04Mi41dDMuNSAtNzlxMCAtNjcgLTM5LjUgLTExOC41dC0xMDUuNSAtNTEuNWgtNTc2cS02NiAwIC0xMDUuNSA1MS41dC0zOS41IDExOC41cTAgNDggNC41IDkzLjUKdDE4LjUgOTguNXQzNi41IDkxLjV0NjMgNjQuNXQ5My41IDI2aDVxNyAtNCAzMiAtMTkuNXQzNS41IC0yMXQzMyAtMTd0MzcgLTE2dDM1IC05dDM5LjUgLTQuNXQzOS41IDQuNXQzNSA5dDM3IDE2dDMzIDE3dDM1LjUgMjF0MzIgMTkuNXpNMTY2NCA5MjhxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC05NnYtMTI4aDk2cTEzIDAgMjIuNSAtOS41dDkuNSAtMjIuNXYtMTkycTAgLTEzIC05LjUgLTIyLjV0LTIyLjUgLTkuNWgtOTZ2LTEyOGg5NgpxMTMgMCAyMi41IC05LjV0OS41IC0yMi41di0xOTJxMCAtMTMgLTkuNSAtMjIuNXQtMjIuNSAtOS41aC05NnYtMjI0cTAgLTY2IC00NyAtMTEzdC0xMTMgLTQ3aC0xMjE2cS02NiAwIC0xMTMgNDd0LTQ3IDExM3YxNDcycTAgNjYgNDcgMTEzdDExMyA0N2gxMjE2cTY2IDAgMTEzIC00N3Q0NyAtMTEzdi0yMjRoOTZxMTMgMCAyMi41IC05LjV0OS41IC0yMi41di0xOTJ6TTE0MDggLTk2djE0NzJxMCAxMyAtOS41IDIyLjV0LTIyLjUgOS41aC0xMjE2CnEtMTMgMCAtMjIuNSAtOS41dC05LjUgLTIyLjV2LTE0NzJxMCAtMTMgOS41IC0yMi41dDIyLjUgLTkuNWgxMjE2cTEzIDAgMjIuNSA5LjV0OS41IDIyLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyQkIiIHVuaWNvZGU9IiYjeGYyYmI7IiBob3Jpei1hZHYteD0iMjA0OCIgCmQ9Ik0xMDI0IDQwNXEwIDY0IC05IDExNy41dC0yOS41IDEwM3QtNjAuNSA3OHQtOTcgMjguNXEtNiAtNCAtMzAgLTE4dC0zNy41IC0yMS41dC0zNS41IC0xNy41dC00MyAtMTQuNXQtNDIgLTQuNXQtNDIgNC41dC00MyAxNC41dC0zNS41IDE3LjV0LTM3LjUgMjEuNXQtMzAgMThxLTU3IDAgLTk3IC0yOC41dC02MC41IC03OHQtMjkuNSAtMTAzdC05IC0xMTcuNXQzNyAtMTA2LjV0OTEgLTQyLjVoNTEycTU0IDAgOTEgNDIuNXQzNyAxMDYuNXoKTTg2NyA5MjVxMCA5NCAtNjYuNSAxNjAuNXQtMTYwLjUgNjYuNXQtMTYwLjUgLTY2LjV0LTY2LjUgLTE2MC41dDY2LjUgLTE2MC41dDE2MC41IC02Ni41dDE2MC41IDY2LjV0NjYuNSAxNjAuNXpNMTc5MiA0MTZ2NjRxMCAxNCAtOSAyM3QtMjMgOWgtNTc2cS0xNCAwIC0yMyAtOXQtOSAtMjN2LTY0cTAgLTE0IDkgLTIzdDIzIC05aDU3NnExNCAwIDIzIDl0OSAyM3pNMTc5MiA2NzZ2NTZxMCAxNSAtMTAuNSAyNS41dC0yNS41IDEwLjVoLTU2OApxLTE1IDAgLTI1LjUgLTEwLjV0LTEwLjUgLTI1LjV2LTU2cTAgLTE1IDEwLjUgLTI1LjV0MjUuNSAtMTAuNWg1NjhxMTUgMCAyNS41IDEwLjV0MTAuNSAyNS41ek0xNzkyIDkyOHY2NHEwIDE0IC05IDIzdC0yMyA5aC01NzZxLTE0IDAgLTIzIC05dC05IC0yM3YtNjRxMCAtMTQgOSAtMjN0MjMgLTloNTc2cTE0IDAgMjMgOXQ5IDIzek0yMDQ4IDEyNDh2LTEyMTZxMCAtNjYgLTQ3IC0xMTN0LTExMyAtNDdoLTM1MnY5NnEwIDE0IC05IDIzdC0yMyA5CmgtNjRxLTE0IDAgLTIzIC05dC05IC0yM3YtOTZoLTc2OHY5NnEwIDE0IC05IDIzdC0yMyA5aC02NHEtMTQgMCAtMjMgLTl0LTkgLTIzdi05NmgtMzUycS02NiAwIC0xMTMgNDd0LTQ3IDExM3YxMjE2cTAgNjYgNDcgMTEzdDExMyA0N2gxNzI4cTY2IDAgMTEzIC00N3Q0NyAtMTEzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmlGMkJDIiB1bmljb2RlPSImI3hmMmJjOyIgaG9yaXotYWR2LXg9IjIwNDgiIApkPSJNMTAyNCA0MDVxMCAtNjQgLTM3IC0xMDYuNXQtOTEgLTQyLjVoLTUxMnEtNTQgMCAtOTEgNDIuNXQtMzcgMTA2LjV0OSAxMTcuNXQyOS41IDEwM3Q2MC41IDc4dDk3IDI4LjVxNiAtNCAzMCAtMTh0MzcuNSAtMjEuNXQzNS41IC0xNy41dDQzIC0xNC41dDQyIC00LjV0NDIgNC41dDQzIDE0LjV0MzUuNSAxNy41dDM3LjUgMjEuNXQzMCAxOHE1NyAwIDk3IC0yOC41dDYwLjUgLTc4dDI5LjUgLTEwM3Q5IC0xMTcuNXpNODY3IDkyNQpxMCAtOTQgLTY2LjUgLTE2MC41dC0xNjAuNSAtNjYuNXQtMTYwLjUgNjYuNXQtNjYuNSAxNjAuNXQ2Ni41IDE2MC41dDE2MC41IDY2LjV0MTYwLjUgLTY2LjV0NjYuNSAtMTYwLjV6TTE3OTIgNDgwdi02NHEwIC0xNCAtOSAtMjN0LTIzIC05aC01NzZxLTE0IDAgLTIzIDl0LTkgMjN2NjRxMCAxNCA5IDIzdDIzIDloNTc2cTE0IDAgMjMgLTl0OSAtMjN6TTE3OTIgNzMydi01NnEwIC0xNSAtMTAuNSAtMjUuNXQtMjUuNSAtMTAuNWgtNTY4CnEtMTUgMCAtMjUuNSAxMC41dC0xMC41IDI1LjV2NTZxMCAxNSAxMC41IDI1LjV0MjUuNSAxMC41aDU2OHExNSAwIDI1LjUgLTEwLjV0MTAuNSAtMjUuNXpNMTc5MiA5OTJ2LTY0cTAgLTE0IC05IC0yM3QtMjMgLTloLTU3NnEtMTQgMCAtMjMgOXQtOSAyM3Y2NHEwIDE0IDkgMjN0MjMgOWg1NzZxMTQgMCAyMyAtOXQ5IC0yM3pNMTkyMCAzMnYxMjE2cTAgMTMgLTkuNSAyMi41dC0yMi41IDkuNWgtMTcyOHEtMTMgMCAtMjIuNSAtOS41CnQtOS41IC0yMi41di0xMjE2cTAgLTEzIDkuNSAtMjIuNXQyMi41IC05LjVoMzUydjk2cTAgMTQgOSAyM3QyMyA5aDY0cTE0IDAgMjMgLTl0OSAtMjN2LTk2aDc2OHY5NnEwIDE0IDkgMjN0MjMgOWg2NHExNCAwIDIzIC05dDkgLTIzdi05NmgzNTJxMTMgMCAyMi41IDkuNXQ5LjUgMjIuNXpNMjA0OCAxMjQ4di0xMjE2cTAgLTY2IC00NyAtMTEzdC0xMTMgLTQ3aC0xNzI4cS02NiAwIC0xMTMgNDd0LTQ3IDExM3YxMjE2cTAgNjYgNDcgMTEzCnQxMTMgNDdoMTcyOHE2NiAwIDExMyAtNDd0NDcgLTExM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjJCRCIgdW5pY29kZT0iJiN4ZjJiZDsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE1MjMgMTk3cS0yMiAxNTUgLTg3LjUgMjU3LjV0LTE4NC41IDExOC41cS02NyAtNzQgLTE1OS41IC0xMTUuNXQtMTk1LjUgLTQxLjV0LTE5NS41IDQxLjV0LTE1OS41IDExNS41cS0xMTkgLTE2IC0xODQuNSAtMTE4LjV0LTg3LjUgLTI1Ny41cTEwNiAtMTUwIDI3MSAtMjM3LjV0MzU2IC04Ny41dDM1NiA4Ny41dDI3MSAyMzcuNXpNMTI4MCA4OTZxMCAxNTkgLTExMi41IDI3MS41dC0yNzEuNSAxMTIuNXQtMjcxLjUgLTExMi41CnQtMTEyLjUgLTI3MS41dDExMi41IC0yNzEuNXQyNzEuNSAtMTEyLjV0MjcxLjUgMTEyLjV0MTEyLjUgMjcxLjV6TTE3OTIgNjQwcTAgLTE4MiAtNzEgLTM0Ny41dC0xOTAuNSAtMjg2dC0yODUuNSAtMTkxLjV0LTM0OSAtNzFxLTE4MiAwIC0zNDggNzF0LTI4NiAxOTF0LTE5MSAyODZ0LTcxIDM0OHQ3MSAzNDh0MTkxIDI4NnQyODYgMTkxdDM0OCA3MXQzNDggLTcxdDI4NiAtMTkxdDE5MSAtMjg2dDcxIC0zNDh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyQkUiIHVuaWNvZGU9IiYjeGYyYmU7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik04OTYgMTUzNnExODIgMCAzNDggLTcxdDI4NiAtMTkxdDE5MSAtMjg2dDcxIC0zNDhxMCAtMTgxIC03MC41IC0zNDd0LTE5MC41IC0yODZ0LTI4NiAtMTkxLjV0LTM0OSAtNzEuNXQtMzQ5IDcxdC0yODUuNSAxOTEuNXQtMTkwLjUgMjg2dC03MSAzNDcuNXQ3MSAzNDh0MTkxIDI4NnQyODYgMTkxdDM0OCA3MXpNMTUxNSAxODVxMTQ5IDIwNSAxNDkgNDU1cTAgMTU2IC02MSAyOTh0LTE2NCAyNDV0LTI0NSAxNjR0LTI5OCA2MXQtMjk4IC02MQp0LTI0NSAtMTY0dC0xNjQgLTI0NXQtNjEgLTI5OHEwIC0yNTAgMTQ5IC00NTVxNjYgMzI3IDMwNiAzMjdxMTMxIC0xMjggMzEzIC0xMjh0MzEzIDEyOHEyNDAgMCAzMDYgLTMyN3pNMTI4MCA4MzJxMCAxNTkgLTExMi41IDI3MS41dC0yNzEuNSAxMTIuNXQtMjcxLjUgLTExMi41dC0xMTIuNSAtMjcxLjV0MTEyLjUgLTI3MS41dDI3MS41IC0xMTIuNXQyNzEuNSAxMTIuNXQxMTIuNSAyNzEuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjJDMCIgdW5pY29kZT0iJiN4ZjJjMDsiIApkPSJNMTIwMSA3NTJxNDcgLTE0IDg5LjUgLTM4dDg5IC03M3Q3OS41IC0xMTUuNXQ1NSAtMTcydDIyIC0yMzYuNXEwIC0xNTQgLTEwMCAtMjYzLjV0LTI0MSAtMTA5LjVoLTg1NHEtMTQxIDAgLTI0MSAxMDkuNXQtMTAwIDI2My41cTAgMTMxIDIyIDIzNi41dDU1IDE3MnQ3OS41IDExNS41dDg5IDczdDg5LjUgMzhxLTc5IDEyNSAtNzkgMjcycTAgMTA0IDQwLjUgMTk4LjV0MTA5LjUgMTYzLjV0MTYzLjUgMTA5LjV0MTk4LjUgNDAuNQp0MTk4LjUgLTQwLjV0MTYzLjUgLTEwOS41dDEwOS41IC0xNjMuNXQ0MC41IC0xOTguNXEwIC0xNDcgLTc5IC0yNzJ6TTc2OCAxNDA4cS0xNTkgMCAtMjcxLjUgLTExMi41dC0xMTIuNSAtMjcxLjV0MTEyLjUgLTI3MS41dDI3MS41IC0xMTIuNXQyNzEuNSAxMTIuNXQxMTIuNSAyNzEuNXQtMTEyLjUgMjcxLjV0LTI3MS41IDExMi41ek0xMTk1IC0xMjhxODggMCAxNTAuNSA3MS41dDYyLjUgMTczLjVxMCAyMzkgLTc4LjUgMzc3dC0yMjUuNSAxNDUKcS0xNDUgLTEyNyAtMzM2IC0xMjd0LTMzNiAxMjdxLTE0NyAtNyAtMjI1LjUgLTE0NXQtNzguNSAtMzc3cTAgLTEwMiA2Mi41IC0xNzMuNXQxNTAuNSAtNzEuNWg4NTR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyQzEiIHVuaWNvZGU9IiYjeGYyYzE7IiBob3Jpei1hZHYteD0iMTI4MCIgCmQ9Ik0xMDI0IDI3OHEwIC02NCAtMzcgLTEwN3QtOTEgLTQzaC01MTJxLTU0IDAgLTkxIDQzdC0zNyAxMDd0OSAxMTh0MjkuNSAxMDR0NjEgNzguNXQ5Ni41IDI4LjVxODAgLTc1IDE4OCAtNzV0MTg4IDc1cTU2IDAgOTYuNSAtMjguNXQ2MSAtNzguNXQyOS41IC0xMDR0OSAtMTE4ek04NzAgNzk3cTAgLTk0IC02Ny41IC0xNjAuNXQtMTYyLjUgLTY2LjV0LTE2Mi41IDY2LjV0LTY3LjUgMTYwLjV0NjcuNSAxNjAuNXQxNjIuNSA2Ni41CnQxNjIuNSAtNjYuNXQ2Ny41IC0xNjAuNXpNMTE1MiAtOTZ2MTM3NmgtMTAyNHYtMTM3NnEwIC0xMyA5LjUgLTIyLjV0MjIuNSAtOS41aDk2MHExMyAwIDIyLjUgOS41dDkuNSAyMi41ek0xMjgwIDEzNzZ2LTE0NzJxMCAtNjYgLTQ3IC0xMTN0LTExMyAtNDdoLTk2MHEtNjYgMCAtMTEzIDQ3dC00NyAxMTN2MTQ3MnEwIDY2IDQ3IDExM3QxMTMgNDdoMzUydi05NnEwIC0xNCA5IC0yM3QyMyAtOWgxOTJxMTQgMCAyMyA5dDkgMjN2OTZoMzUyCnE2NiAwIDExMyAtNDd0NDcgLTExM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjJDMiIgdW5pY29kZT0iJiN4ZjJjMjsiIGhvcml6LWFkdi14PSIyMDQ4IiAKZD0iTTg5NiAzMjRxMCA1NCAtNy41IDEwMC41dC0yNC41IDkwdC01MSA2OC41dC04MSAyNXEtNjQgLTY0IC0xNTYgLTY0dC0xNTYgNjRxLTQ3IDAgLTgxIC0yNXQtNTEgLTY4LjV0LTI0LjUgLTkwdC03LjUgLTEwMC41cTAgLTU1IDMxLjUgLTkzLjV0NzUuNSAtMzguNWg0MjZxNDQgMCA3NS41IDM4LjV0MzEuNSA5My41ek03NjggNzY4cTAgODAgLTU2IDEzNnQtMTM2IDU2dC0xMzYgLTU2dC01NiAtMTM2dDU2IC0xMzZ0MTM2IC01NnQxMzYgNTYKdDU2IDEzNnpNMTc5MiAyODh2NjRxMCAxNCAtOSAyM3QtMjMgOWgtNzA0cS0xNCAwIC0yMyAtOXQtOSAtMjN2LTY0cTAgLTE0IDkgLTIzdDIzIC05aDcwNHExNCAwIDIzIDl0OSAyM3pNMTQwOCA1NDR2NjRxMCAxNCAtOSAyM3QtMjMgOWgtMzIwcS0xNCAwIC0yMyAtOXQtOSAtMjN2LTY0cTAgLTE0IDkgLTIzdDIzIC05aDMyMHExNCAwIDIzIDl0OSAyM3pNMTc5MiA1NDR2NjRxMCAxNCAtOSAyM3QtMjMgOWgtMTkycS0xNCAwIC0yMyAtOXQtOSAtMjMKdi02NHEwIC0xNCA5IC0yM3QyMyAtOWgxOTJxMTQgMCAyMyA5dDkgMjN6TTE3OTIgODAwdjY0cTAgMTQgLTkgMjN0LTIzIDloLTcwNHEtMTQgMCAtMjMgLTl0LTkgLTIzdi02NHEwIC0xNCA5IC0yM3QyMyAtOWg3MDRxMTQgMCAyMyA5dDkgMjN6TTEyOCAxMTUyaDE3OTJ2OTZxMCAxNCAtOSAyM3QtMjMgOWgtMTcyOHEtMTQgMCAtMjMgLTl0LTkgLTIzdi05NnpNMjA0OCAxMjQ4di0xMjE2cTAgLTY2IC00NyAtMTEzdC0xMTMgLTQ3aC0xNzI4CnEtNjYgMCAtMTEzIDQ3dC00NyAxMTN2MTIxNnEwIDY2IDQ3IDExM3QxMTMgNDdoMTcyOHE2NiAwIDExMyAtNDd0NDcgLTExM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjJDMyIgdW5pY29kZT0iJiN4ZjJjMzsiIGhvcml6LWFkdi14PSIyMDQ4IiAKZD0iTTg5NiAzMjRxMCAtNTUgLTMxLjUgLTkzLjV0LTc1LjUgLTM4LjVoLTQyNnEtNDQgMCAtNzUuNSAzOC41dC0zMS41IDkzLjVxMCA1NCA3LjUgMTAwLjV0MjQuNSA5MHQ1MSA2OC41dDgxIDI1cTY0IC02NCAxNTYgLTY0dDE1NiA2NHE0NyAwIDgxIC0yNXQ1MSAtNjguNXQyNC41IC05MHQ3LjUgLTEwMC41ek03NjggNzY4cTAgLTgwIC01NiAtMTM2dC0xMzYgLTU2dC0xMzYgNTZ0LTU2IDEzNnQ1NiAxMzZ0MTM2IDU2dDEzNiAtNTZ0NTYgLTEzNnoKTTE3OTIgMzUydi02NHEwIC0xNCAtOSAtMjN0LTIzIC05aC03MDRxLTE0IDAgLTIzIDl0LTkgMjN2NjRxMCAxNCA5IDIzdDIzIDloNzA0cTE0IDAgMjMgLTl0OSAtMjN6TTE0MDggNjA4di02NHEwIC0xNCAtOSAtMjN0LTIzIC05aC0zMjBxLTE0IDAgLTIzIDl0LTkgMjN2NjRxMCAxNCA5IDIzdDIzIDloMzIwcTE0IDAgMjMgLTl0OSAtMjN6TTE3OTIgNjA4di02NHEwIC0xNCAtOSAtMjN0LTIzIC05aC0xOTJxLTE0IDAgLTIzIDl0LTkgMjN2NjQKcTAgMTQgOSAyM3QyMyA5aDE5MnExNCAwIDIzIC05dDkgLTIzek0xNzkyIDg2NHYtNjRxMCAtMTQgLTkgLTIzdC0yMyAtOWgtNzA0cS0xNCAwIC0yMyA5dC05IDIzdjY0cTAgMTQgOSAyM3QyMyA5aDcwNHExNCAwIDIzIC05dDkgLTIzek0xOTIwIDMydjExMjBoLTE3OTJ2LTExMjBxMCAtMTMgOS41IC0yMi41dDIyLjUgLTkuNWgxNzI4cTEzIDAgMjIuNSA5LjV0OS41IDIyLjV6TTIwNDggMTI0OHYtMTIxNnEwIC02NiAtNDcgLTExM3QtMTEzIC00NwpoLTE3MjhxLTY2IDAgLTExMyA0N3QtNDcgMTEzdjEyMTZxMCA2NiA0NyAxMTN0MTEzIDQ3aDE3MjhxNjYgMCAxMTMgLTQ3dDQ3IC0xMTN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyQzQiIHVuaWNvZGU9IiYjeGYyYzQ7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xMjU1IDc0OXEwIDMxOCAtMTA1IDQ3NC41dC0zMzAgMTU2LjVxLTIyMiAwIC0zMjYgLTE1N3QtMTA0IC00NzRxMCAtMzE2IDEwNCAtNDcxLjV0MzI2IC0xNTUuNXE3NCAwIDEzMSAxN3EtMjIgNDMgLTM5IDczdC00NCA2NXQtNTMuNSA1Ni41dC02MyAzNnQtNzcuNSAxNC41cS00NiAwIC03OSAtMTZsLTQ5IDk3cTEwNSA5MSAyNzYgOTFxMTMyIDAgMjE1LjUgLTU0dDE1MC41IC0xNTVxNjcgMTQ5IDY3IDQwMnpNMTY0NSAxMTdoMTE3CnEzIC0yNyAtMiAtNjd0LTI2LjUgLTk1dC01OCAtMTAwLjV0LTEwNyAtNzh0LTE2Mi41IC0zMi41cS03MSAwIC0xMzAuNSAxOXQtMTA1LjUgNTZ0LTc5IDc4dC02NiA5NnEtOTcgLTI3IC0yMDUgLTI3cS0xNTAgMCAtMjkyLjUgNTh0LTI1MyAxNTguNXQtMTc4IDI0OXQtNjcuNSAzMTcuNXEwIDE3MCA2Ny41IDMxOS41dDE3OC41IDI1MC41dDI1My41IDE1OXQyOTEuNSA1OHExMjEgMCAyMzguNSAtMzZ0MjE3IC0xMDZ0MTc2IC0xNjQuNQp0MTE5LjUgLTIxOXQ0MyAtMjYxLjVxMCAtMTkwIC04MC41IC0zNDcuNXQtMjE4LjUgLTI2NC41cTQ3IC03MCA5My41IC0xMDYuNXQxMDQuNSAtMzYuNXE2MSAwIDk0IDM3LjV0MzggODUuNXoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjJDNSIgdW5pY29kZT0iJiN4ZjJjNTsiIGhvcml6LWFkdi14PSIyMzA0IiAKZD0iTTQ1MyAtMTAxcTAgLTIxIC0xNiAtMzcuNXQtMzcgLTE2LjVxLTEgMCAtMTMgM3EtNjMgMTUgLTE2MiAxNDBxLTIyNSAyODQgLTIyNSA2NzZxMCAzNDEgMjEzIDYxNHEzOSA1MSA5NSAxMDMuNXQ5NCA1Mi41cTE5IDAgMzUgLTEzLjV0MTYgLTMyLjVxMCAtMjcgLTYzIC05MHEtOTggLTEwMiAtMTQ3IC0xODRxLTExOSAtMTk5IC0xMTkgLTQ0OXEwIC0yODEgMTIzIC00OTFxNTAgLTg1IDEzNiAtMTczcTIgLTMgMTQuNSAtMTZ0MTkuNSAtMjEKdDE3IC0yMC41dDE0LjUgLTIzLjV0NC41IC0yMXpNMTc5NiAzM3EwIC0yOSAtMTcuNSAtNDguNXQtNDYuNSAtMTkuNWgtMTA4MXEtMjYgMCAtNDUgMTl0LTE5IDQ1cTAgMjkgMTcuNSA0OC41dDQ2LjUgMTkuNWgxMDgxcTI2IDAgNDUgLTE5dDE5IC00NXpNMTU4MSA2NDRxMCAtMTM0IC02NyAtMjMzcS0yNSAtMzggLTY5LjUgLTc4LjV0LTgzLjUgLTYwLjVxLTE2IC0xMCAtMjcgLTEwcS03IDAgLTE1IDZ0LTggMTJxMCA5IDE5IDMwdDQyIDQ2CnQ0MiA2Ny41dDE5IDg4LjVxMCA3NiAtMzUgMTMwcS0yOSA0MiAtNDYgNDJxLTMgMCAtMyAtNXEwIC0xMiA3LjUgLTM1LjV0Ny41IC0zNi41cTAgLTIyIC0yMS41IC0zNXQtNDQuNSAtMTNxLTY2IDAgLTY2IDc2cTAgMTUgMS41IDQ0dDEuNSA0NHEwIDI1IC0xMCA0NnEtMTMgMjUgLTQyIDUzLjV0LTUxIDI4LjVxLTUgMCAtNyAtMC41dC0zLjUgLTIuNXQtMS41IC02cTAgLTIgMTYgLTI2dDE2IC01NHEwIC0zNyAtMTkgLTY4dC00NiAtNTQKdC01My41IC00NnQtNDUuNSAtNTR0LTE5IC02OHEwIC05OCA0MiAtMTYwcTI5IC00MyA3OSAtNjNxMTYgLTUgMTcgLTEwcTEgLTIgMSAtNXEwIC0xNiAtMTggLTE2cS02IDAgLTMzIDExcS0xMTkgNDMgLTE5NSAxMzkuNXQtNzYgMjE4LjVxMCA1NSAyNC41IDExNS41dDYwIDExNXQ3MC41IDEwOC41dDU5LjUgMTEzLjV0MjQuNSAxMTEuNXEwIDUzIC0yNSA5NHEtMjkgNDggLTU2IDY0cS0xOSA5IC0xOSAyMXEwIDIwIDQxIDIwcTUwIDAgMTEwIC0yOQpxNDEgLTE5IDcxIC00NC41dDQ5LjUgLTUxdDMzLjUgLTYyLjV0MjIgLTY5dDE2IC04MHEwIC0xIDMgLTE3LjV0NC41IC0yNXQ1LjUgLTI1dDkgLTI3dDExIC0yMS41dDE0LjUgLTE2LjV0MTguNSAtNS41cTIzIDAgMzcgMTR0MTQgMzdxMCAyNSAtMjAgNjd0LTIwIDUydDEwIDEwcTI3IDAgOTMgLTcwcTcyIC03NiAxMDIuNSAtMTU2dDMwLjUgLTE4NnpNMjMwNCA2MTVxMCAtMjc0IC0xMzggLTUwM3EtMTkgLTMyIC00OCAtNzJ0LTY4IC04Ni41CnQtODEgLTc3dC03NCAtMzAuNXEtMTYgMCAtMzEgMTUuNXQtMTUgMzEuNXEwIDE1IDI5IDUwLjV0NjguNSA3N3Q0OC41IDUyLjVxMTgzIDIzMCAxODMgNTMxcTAgMTMxIC0yMC41IDIzNXQtNzIuNSAyMTFxLTU4IDExOSAtMTYzIDIyOHEtMiAzIC0xMyAxMy41dC0xNi41IDE2LjV0LTE1IDE3LjV0LTE1IDIwdC05LjUgMTguNXQtNCAxOXEwIDE5IDE2IDM1LjV0MzUgMTYuNXE3MCAwIDE5NiAtMTY5cTk4IC0xMzEgMTQ2IC0yNzN0NjAgLTMxNApxMiAtNDIgMiAtNjR6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyQzYiIHVuaWNvZGU9IiYjeGYyYzY7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xMTg5IDIyOWwxNDcgNjkzcTkgNDQgLTEwLjUgNjN0LTUxLjUgN2wtODY0IC0zMzNxLTI5IC0xMSAtMzkuNSAtMjV0LTIuNSAtMjYuNXQzMiAtMTkuNWwyMjEgLTY5bDUxMyAzMjNxMjEgMTQgMzIgNnE3IC01IC00IC0xNWwtNDE1IC0zNzV2MHYwbC0xNiAtMjI4cTIzIDAgNDUgMjJsMTA4IDEwNGwyMjQgLTE2NXE2NCAtMzYgODEgMzh6TTE3OTIgNjQwcTAgLTE4MiAtNzEgLTM0OHQtMTkxIC0yODZ0LTI4NiAtMTkxdC0zNDggLTcxCnQtMzQ4IDcxdC0yODYgMTkxdC0xOTEgMjg2dC03MSAzNDh0NzEgMzQ4dDE5MSAyODZ0Mjg2IDE5MXQzNDggNzF0MzQ4IC03MXQyODYgLTE5MXQxOTEgLTI4NnQ3MSAtMzQ4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmlGMkM3IiB1bmljb2RlPSImI3hmMmM3OyIgaG9yaXotYWR2LXg9IjEwMjQiIApkPSJNNjQwIDE5MnEwIC04MCAtNTYgLTEzNnQtMTM2IC01NnQtMTM2IDU2dC01NiAxMzZxMCA2MCAzNSAxMTB0OTMgNzF2OTA3aDEyOHYtOTA3cTU4IC0yMSA5MyAtNzF0MzUgLTExMHpNNzY4IDE5MnEwIDc3IC0zNCAxNDR0LTk0IDExMnY3NjhxMCA4MCAtNTYgMTM2dC0xMzYgNTZ0LTEzNiAtNTZ0LTU2IC0xMzZ2LTc2OHEtNjAgLTQ1IC05NCAtMTEydC0zNCAtMTQ0cTAgLTEzMyA5My41IC0yMjYuNXQyMjYuNSAtOTMuNXQyMjYuNSA5My41CnQ5My41IDIyNi41ek04OTYgMTkycTAgLTE4NSAtMTMxLjUgLTMxNi41dC0zMTYuNSAtMTMxLjV0LTMxNi41IDEzMS41dC0xMzEuNSAzMTYuNXEwIDE4MiAxMjggMzEzdjcxMXEwIDEzMyA5My41IDIyNi41dDIyNi41IDkzLjV0MjI2LjUgLTkzLjV0OTMuNSAtMjI2LjV2LTcxMXExMjggLTEzMSAxMjggLTMxM3pNMTAyNCA3Njh2LTEyOGgtMTkydjEyOGgxOTJ6TTEwMjQgMTAyNHYtMTI4aC0xOTJ2MTI4aDE5MnpNMTAyNCAxMjgwdi0xMjhoLTE5Mgp2MTI4aDE5MnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjJDOCIgdW5pY29kZT0iJiN4ZjJjODsiIGhvcml6LWFkdi14PSIxMDI0IiAKZD0iTTY0MCAxOTJxMCAtODAgLTU2IC0xMzZ0LTEzNiAtNTZ0LTEzNiA1NnQtNTYgMTM2cTAgNjAgMzUgMTEwdDkzIDcxdjY1MWgxMjh2LTY1MXE1OCAtMjEgOTMgLTcxdDM1IC0xMTB6TTc2OCAxOTJxMCA3NyAtMzQgMTQ0dC05NCAxMTJ2NzY4cTAgODAgLTU2IDEzNnQtMTM2IDU2dC0xMzYgLTU2dC01NiAtMTM2di03NjhxLTYwIC00NSAtOTQgLTExMnQtMzQgLTE0NHEwIC0xMzMgOTMuNSAtMjI2LjV0MjI2LjUgLTkzLjV0MjI2LjUgOTMuNQp0OTMuNSAyMjYuNXpNODk2IDE5MnEwIC0xODUgLTEzMS41IC0zMTYuNXQtMzE2LjUgLTEzMS41dC0zMTYuNSAxMzEuNXQtMTMxLjUgMzE2LjVxMCAxODIgMTI4IDMxM3Y3MTFxMCAxMzMgOTMuNSAyMjYuNXQyMjYuNSA5My41dDIyNi41IC05My41dDkzLjUgLTIyNi41di03MTFxMTI4IC0xMzEgMTI4IC0zMTN6TTEwMjQgNzY4di0xMjhoLTE5MnYxMjhoMTkyek0xMDI0IDEwMjR2LTEyOGgtMTkydjEyOGgxOTJ6TTEwMjQgMTI4MHYtMTI4aC0xOTIKdjEyOGgxOTJ6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyQzkiIHVuaWNvZGU9IiYjeGYyYzk7IiBob3Jpei1hZHYteD0iMTAyNCIgCmQ9Ik02NDAgMTkycTAgLTgwIC01NiAtMTM2dC0xMzYgLTU2dC0xMzYgNTZ0LTU2IDEzNnEwIDYwIDM1IDExMHQ5MyA3MXYzOTVoMTI4di0zOTVxNTggLTIxIDkzIC03MXQzNSAtMTEwek03NjggMTkycTAgNzcgLTM0IDE0NHQtOTQgMTEydjc2OHEwIDgwIC01NiAxMzZ0LTEzNiA1NnQtMTM2IC01NnQtNTYgLTEzNnYtNzY4cS02MCAtNDUgLTk0IC0xMTJ0LTM0IC0xNDRxMCAtMTMzIDkzLjUgLTIyNi41dDIyNi41IC05My41dDIyNi41IDkzLjUKdDkzLjUgMjI2LjV6TTg5NiAxOTJxMCAtMTg1IC0xMzEuNSAtMzE2LjV0LTMxNi41IC0xMzEuNXQtMzE2LjUgMTMxLjV0LTEzMS41IDMxNi41cTAgMTgyIDEyOCAzMTN2NzExcTAgMTMzIDkzLjUgMjI2LjV0MjI2LjUgOTMuNXQyMjYuNSAtOTMuNXQ5My41IC0yMjYuNXYtNzExcTEyOCAtMTMxIDEyOCAtMzEzek0xMDI0IDc2OHYtMTI4aC0xOTJ2MTI4aDE5MnpNMTAyNCAxMDI0di0xMjhoLTE5MnYxMjhoMTkyek0xMDI0IDEyODB2LTEyOGgtMTkyCnYxMjhoMTkyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmlGMkNBIiB1bmljb2RlPSImI3hmMmNhOyIgaG9yaXotYWR2LXg9IjEwMjQiIApkPSJNNjQwIDE5MnEwIC04MCAtNTYgLTEzNnQtMTM2IC01NnQtMTM2IDU2dC01NiAxMzZxMCA2MCAzNSAxMTB0OTMgNzF2MTM5aDEyOHYtMTM5cTU4IC0yMSA5MyAtNzF0MzUgLTExMHpNNzY4IDE5MnEwIDc3IC0zNCAxNDR0LTk0IDExMnY3NjhxMCA4MCAtNTYgMTM2dC0xMzYgNTZ0LTEzNiAtNTZ0LTU2IC0xMzZ2LTc2OHEtNjAgLTQ1IC05NCAtMTEydC0zNCAtMTQ0cTAgLTEzMyA5My41IC0yMjYuNXQyMjYuNSAtOTMuNXQyMjYuNSA5My41CnQ5My41IDIyNi41ek04OTYgMTkycTAgLTE4NSAtMTMxLjUgLTMxNi41dC0zMTYuNSAtMTMxLjV0LTMxNi41IDEzMS41dC0xMzEuNSAzMTYuNXEwIDE4MiAxMjggMzEzdjcxMXEwIDEzMyA5My41IDIyNi41dDIyNi41IDkzLjV0MjI2LjUgLTkzLjV0OTMuNSAtMjI2LjV2LTcxMXExMjggLTEzMSAxMjggLTMxM3pNMTAyNCA3Njh2LTEyOGgtMTkydjEyOGgxOTJ6TTEwMjQgMTAyNHYtMTI4aC0xOTJ2MTI4aDE5MnpNMTAyNCAxMjgwdi0xMjhoLTE5Mgp2MTI4aDE5MnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjJDQiIgdW5pY29kZT0iJiN4ZjJjYjsiIGhvcml6LWFkdi14PSIxMDI0IiAKZD0iTTY0MCAxOTJxMCAtODAgLTU2IC0xMzZ0LTEzNiAtNTZ0LTEzNiA1NnQtNTYgMTM2cTAgNzkgNTYgMTM1LjV0MTM2IDU2LjV0MTM2IC01Ni41dDU2IC0xMzUuNXpNNzY4IDE5MnEwIDc3IC0zNCAxNDR0LTk0IDExMnY3NjhxMCA4MCAtNTYgMTM2dC0xMzYgNTZ0LTEzNiAtNTZ0LTU2IC0xMzZ2LTc2OHEtNjAgLTQ1IC05NCAtMTEydC0zNCAtMTQ0cTAgLTEzMyA5My41IC0yMjYuNXQyMjYuNSAtOTMuNXQyMjYuNSA5My41dDkzLjUgMjI2LjV6Ck04OTYgMTkycTAgLTE4NSAtMTMxLjUgLTMxNi41dC0zMTYuNSAtMTMxLjV0LTMxNi41IDEzMS41dC0xMzEuNSAzMTYuNXEwIDE4MiAxMjggMzEzdjcxMXEwIDEzMyA5My41IDIyNi41dDIyNi41IDkzLjV0MjI2LjUgLTkzLjV0OTMuNSAtMjI2LjV2LTcxMXExMjggLTEzMSAxMjggLTMxM3pNMTAyNCA3Njh2LTEyOGgtMTkydjEyOGgxOTJ6TTEwMjQgMTAyNHYtMTI4aC0xOTJ2MTI4aDE5MnpNMTAyNCAxMjgwdi0xMjhoLTE5MnYxMjhoMTkyeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmlGMkNDIiB1bmljb2RlPSImI3hmMmNjOyIgaG9yaXotYWR2LXg9IjE5MjAiIApkPSJNMTQzMyAxMjg3cTEwIC0xMCAxMCAtMjN0LTEwIC0yM2wtNjI2IC02MjZxLTEwIC0xMCAtMjMgLTEwdC0yMyAxMGwtODIgODJxLTEwIDEwIC0xMCAyM3QxMCAyM2w0NCA0NHEtNzIgOTEgLTgxLjUgMjA3dDQ2LjUgMjE1cS03NCA3MSAtMTc2IDcxcS0xMDYgMCAtMTgxIC03NXQtNzUgLTE4MXYtMTI4MGgtMjU2djEyODBxMCAxMDQgNDAuNSAxOTguNXQxMDkuNSAxNjMuNXQxNjMuNSAxMDkuNXQxOTguNSA0MC41cTEwNiAwIDIwMSAtNDEKdDE2NiAtMTE1cTk0IDM5IDE5NyAyNC41dDE4NSAtNzkuNWw0NCA0NHExMCAxMCAyMyAxMHQyMyAtMTB6TTEzNDQgMTAyNHEyNiAwIDQ1IC0xOXQxOSAtNDV0LTE5IC00NXQtNDUgLTE5dC00NSAxOXQtMTkgNDV0MTkgNDV0NDUgMTl6TTE2MDAgODk2cS0yNiAwIC00NSAxOXQtMTkgNDV0MTkgNDV0NDUgMTl0NDUgLTE5dDE5IC00NXQtMTkgLTQ1dC00NSAtMTl6TTE4NTYgMTAyNHEyNiAwIDQ1IC0xOXQxOSAtNDV0LTE5IC00NXQtNDUgLTE5CnQtNDUgMTl0LTE5IDQ1dDE5IDQ1dDQ1IDE5ek0xMjE2IDg5NnEyNiAwIDQ1IC0xOXQxOSAtNDV0LTE5IC00NXQtNDUgLTE5dC00NSAxOXQtMTkgNDV0MTkgNDV0NDUgMTl6TTE0MDggODMycTAgMjYgMTkgNDV0NDUgMTl0NDUgLTE5dDE5IC00NXQtMTkgLTQ1dC00NSAtMTl0LTQ1IDE5dC0xOSA0NXpNMTcyOCA4OTZxMjYgMCA0NSAtMTl0MTkgLTQ1dC0xOSAtNDV0LTQ1IC0xOXQtNDUgMTl0LTE5IDQ1dDE5IDQ1dDQ1IDE5ek0xMDg4IDc2OApxMjYgMCA0NSAtMTl0MTkgLTQ1dC0xOSAtNDV0LTQ1IC0xOXQtNDUgMTl0LTE5IDQ1dDE5IDQ1dDQ1IDE5ek0xMzQ0IDY0MHEtMjYgMCAtNDUgMTl0LTE5IDQ1dDE5IDQ1dDQ1IDE5dDQ1IC0xOXQxOSAtNDV0LTE5IC00NXQtNDUgLTE5ek0xNjAwIDc2OHEyNiAwIDQ1IC0xOXQxOSAtNDV0LTE5IC00NXQtNDUgLTE5dC00NSAxOXQtMTkgNDV0MTkgNDV0NDUgMTl6TTEyMTYgNTEycS0yNiAwIC00NSAxOXQtMTkgNDV0MTkgNDV0NDUgMTl0NDUgLTE5CnQxOSAtNDV0LTE5IC00NXQtNDUgLTE5ek0xNDcyIDY0MHEyNiAwIDQ1IC0xOXQxOSAtNDV0LTE5IC00NXQtNDUgLTE5dC00NSAxOXQtMTkgNDV0MTkgNDV0NDUgMTl6TTEwODggNTEycTI2IDAgNDUgLTE5dDE5IC00NXQtMTkgLTQ1dC00NSAtMTl0LTQ1IDE5dC0xOSA0NXQxOSA0NXQ0NSAxOXpNMTM0NCA1MTJxMjYgMCA0NSAtMTl0MTkgLTQ1dC0xOSAtNDV0LTQ1IC0xOXQtNDUgMTl0LTE5IDQ1dDE5IDQ1dDQ1IDE5ek0xMjE2IDM4NApxMjYgMCA0NSAtMTl0MTkgLTQ1dC0xOSAtNDV0LTQ1IC0xOXQtNDUgMTl0LTE5IDQ1dDE5IDQ1dDQ1IDE5ek0xMDg4IDI1NnEyNiAwIDQ1IC0xOXQxOSAtNDV0LTE5IC00NXQtNDUgLTE5dC00NSAxOXQtMTkgNDV0MTkgNDV0NDUgMTl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyQ0QiIHVuaWNvZGU9IiYjeGYyY2Q7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xNjY0IDQ0OHYtMTkycTAgLTE2OSAtMTI4IC0yODZ2LTE5NHEwIC0xNCAtOSAtMjN0LTIzIC05aC02NHEtMTQgMCAtMjMgOXQtOSAyM3YxMThxLTYzIC0yMiAtMTI4IC0yMmgtNzY4cS02NSAwIC0xMjggMjJ2LTExMHEwIC0xNyAtOS41IC0yOC41dC0yMi41IC0xMS41aC02NHEtMTMgMCAtMjIuNSAxMS41dC05LjUgMjguNXYxODZxLTEyOCAxMTcgLTEyOCAyODZ2MTkyaDE1MzZ6TTcwNCA4NjRxMCAtMTQgLTkgLTIzdC0yMyAtOXQtMjMgOQp0LTkgMjN0OSAyM3QyMyA5dDIzIC05dDkgLTIzek03NjggOTI4cTAgLTE0IC05IC0yM3QtMjMgLTl0LTIzIDl0LTkgMjN0OSAyM3QyMyA5dDIzIC05dDkgLTIzek03MDQgOTkycTAgLTE0IC05IC0yM3QtMjMgLTl0LTIzIDl0LTkgMjN0OSAyM3QyMyA5dDIzIC05dDkgLTIzek04MzIgOTkycTAgLTE0IC05IC0yM3QtMjMgLTl0LTIzIDl0LTkgMjN0OSAyM3QyMyA5dDIzIC05dDkgLTIzek03NjggMTA1NnEwIC0xNCAtOSAtMjN0LTIzIC05dC0yMyA5CnQtOSAyM3Q5IDIzdDIzIDl0MjMgLTl0OSAtMjN6TTcwNCAxMTIwcTAgLTE0IC05IC0yM3QtMjMgLTl0LTIzIDl0LTkgMjN0OSAyM3QyMyA5dDIzIC05dDkgLTIzek0xNzkyIDYwOHYtNjRxMCAtMTQgLTkgLTIzdC0yMyAtOWgtMTcyOHEtMTQgMCAtMjMgOXQtOSAyM3Y2NHEwIDE0IDkgMjN0MjMgOWg5NnY2NDBxMCAxMDYgNzUgMTgxdDE4MSA3NXExMDggMCAxODQgLTc4cTQ2IDE5IDk4IDEydDkzIC0zOWwyMiAyMnExMSAxMSAyMiAwbDQyIC00MgpxMTEgLTExIDAgLTIybC0zMTQgLTMxNHEtMTEgLTExIC0yMiAwbC00MiA0MnEtMTEgMTEgMCAyMmwyMiAyMnEtMzYgNDYgLTQwLjUgMTA0dDIzLjUgMTA4cS0zNyAzNSAtODggMzVxLTUzIDAgLTkwLjUgLTM3LjV0LTM3LjUgLTkwLjV2LTY0MGgxNTA0cTE0IDAgMjMgLTl0OSAtMjN6TTg5NiAxMDU2cTAgLTE0IC05IC0yM3QtMjMgLTl0LTIzIDl0LTkgMjN0OSAyM3QyMyA5dDIzIC05dDkgLTIzek04MzIgMTEyMHEwIC0xNCAtOSAtMjN0LTIzIC05CnQtMjMgOXQtOSAyM3Q5IDIzdDIzIDl0MjMgLTl0OSAtMjN6TTc2OCAxMTg0cTAgLTE0IC05IC0yM3QtMjMgLTl0LTIzIDl0LTkgMjN0OSAyM3QyMyA5dDIzIC05dDkgLTIzek05NjAgMTEyMHEwIC0xNCAtOSAtMjN0LTIzIC05dC0yMyA5dC05IDIzdDkgMjN0MjMgOXQyMyAtOXQ5IC0yM3pNODk2IDExODRxMCAtMTQgLTkgLTIzdC0yMyAtOXQtMjMgOXQtOSAyM3Q5IDIzdDIzIDl0MjMgLTl0OSAtMjN6TTgzMiAxMjQ4cTAgLTE0IC05IC0yMwp0LTIzIC05dC0yMyA5dC05IDIzdDkgMjN0MjMgOXQyMyAtOXQ5IC0yM3pNMTAyNCAxMTg0cTAgLTE0IC05IC0yM3QtMjMgLTl0LTIzIDl0LTkgMjN0OSAyM3QyMyA5dDIzIC05dDkgLTIzek05NjAgMTI0OHEwIC0xNCAtOSAtMjN0LTIzIC05dC0yMyA5dC05IDIzdDkgMjN0MjMgOXQyMyAtOXQ5IC0yM3pNMTA4OCAxMjQ4cTAgLTE0IC05IC0yM3QtMjMgLTl0LTIzIDl0LTkgMjN0OSAyM3QyMyA5dDIzIC05dDkgLTIzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmlGMkNFIiB1bmljb2RlPSImI3hmMmNlOyIgCmQ9Ik05OTQgMzQ0cTAgLTg2IC0xNyAtMTk3cS0zMSAtMjE1IC01NSAtMzEzcS0yMiAtOTAgLTE1MiAtOTB0LTE1MiA5MHEtMjQgOTggLTU1IDMxM3EtMTcgMTEwIC0xNyAxOTdxMCAxNjggMjI0IDE2OHQyMjQgLTE2OHpNMTUzNiA3NjhxMCAtMjQwIC0xMzQgLTQzNHQtMzUwIC0yODBxLTggLTMgLTE1IDN0LTYgMTVxNyA0OCAxMCA2NnE0IDMyIDYgNDdxMSA5IDkgMTJxMTU5IDgxIDI1NS41IDIzNHQ5Ni41IDMzN3EwIDE4MCAtOTEgMzMwLjUKdC0yNDcgMjM0LjV0LTMzNyA3NHEtMTI0IC03IC0yMzcgLTYxdC0xOTMuNSAtMTQwLjV0LTEyOCAtMjAydC00Ni41IC0yNDAuNXExIC0xODQgOTkgLTMzNi41dDI1NyAtMjMxLjVxNyAtMyA5IC0xMnEzIC0yMSA2IC00NXExIC05IDUgLTMyLjV0NiAtMzUuNXExIC05IC02LjUgLTE1dC0xNS41IC0ycS0xNDggNTggLTI2MSAxNjkuNXQtMTczLjUgMjY0dC01Mi41IDMxOS41cTcgMTQzIDY2IDI3My41dDE1NC41IDIyN3QyMjUgMTU3LjV0MjcyLjUgNzAKcTE2NCAxMCAzMTUuNSAtNDYuNXQyNjEgLTE2MC41dDE3NSAtMjUwLjV0NjUuNSAtMzA4LjV6TTk5NCA4MDBxMCAtOTMgLTY1LjUgLTE1OC41dC0xNTguNSAtNjUuNXQtMTU4LjUgNjUuNXQtNjUuNSAxNTguNXQ2NS41IDE1OC41dDE1OC41IDY1LjV0MTU4LjUgLTY1LjV0NjUuNSAtMTU4LjV6TTEyODIgNzY4cTAgLTEyMiAtNTMuNSAtMjI4LjV0LTE0Ni41IC0xNzcuNXEtOCAtNiAtMTYgLTJ0LTEwIDE0cS02IDUyIC0yOSA5MnEtNyAxMCAzIDIwCnE1OCA1NCA5MSAxMjd0MzMgMTU1cTAgMTExIC01OC41IDIwNHQtMTU3LjUgMTQxLjV0LTIxMiAzNi41cS0xMzMgLTE1IC0yMjkgLTExM3QtMTA5IC0yMzFxLTEwIC05MiAyMy41IC0xNzZ0OTguNSAtMTQ0cTEwIC0xMCAzIC0yMHEtMjQgLTQxIC0yOSAtOTNxLTIgLTkgLTEwIC0xM3QtMTYgMnEtOTUgNzQgLTE0OC41IDE4M3QtNTEuNSAyMzRxMyAxMzEgNjkgMjQ0dDE3NyAxODEuNXQyNDEgNzQuNXExNDQgNyAyNjggLTYwdDE5Ni41IC0xODcuNQp0NzIuNSAtMjYzLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyRDAiIHVuaWNvZGU9IiYjeGYyZDA7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0yNTYgMTI4aDEyODB2NzY4aC0xMjgwdi03Njh6TTE3OTIgMTI0OHYtMTIxNnEwIC02NiAtNDcgLTExM3QtMTEzIC00N2gtMTQ3MnEtNjYgMCAtMTEzIDQ3dC00NyAxMTN2MTIxNnEwIDY2IDQ3IDExM3QxMTMgNDdoMTQ3MnE2NiAwIDExMyAtNDd0NDcgLTExM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjJEMSIgdW5pY29kZT0iJiN4ZjJkMTsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTE3OTIgMjI0di0xOTJxMCAtNjYgLTQ3IC0xMTN0LTExMyAtNDdoLTE0NzJxLTY2IDAgLTExMyA0N3QtNDcgMTEzdjE5MnEwIDY2IDQ3IDExM3QxMTMgNDdoMTQ3MnE2NiAwIDExMyAtNDd0NDcgLTExM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjJEMiIgdW5pY29kZT0iJiN4ZjJkMjsiIGhvcml6LWFkdi14PSIyMDQ4IiAKZD0iTTI1NiAwaDc2OHY1MTJoLTc2OHYtNTEyek0xMjgwIDUxMmg1MTJ2NzY4aC03Njh2LTI1Nmg5NnE2NiAwIDExMyAtNDd0NDcgLTExM3YtMzUyek0yMDQ4IDEzNzZ2LTk2MHEwIC02NiAtNDcgLTExM3QtMTEzIC00N2gtNjA4di0zNTJxMCAtNjYgLTQ3IC0xMTN0LTExMyAtNDdoLTk2MHEtNjYgMCAtMTEzIDQ3dC00NyAxMTN2OTYwcTAgNjYgNDcgMTEzdDExMyA0N2g2MDh2MzUycTAgNjYgNDcgMTEzdDExMyA0N2g5NjBxNjYgMCAxMTMgLTQ3CnQ0NyAtMTEzeiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmlGMkQzIiB1bmljb2RlPSImI3hmMmQzOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTE3NSAyMTVsMTQ2IDE0NnExMCAxMCAxMCAyM3QtMTAgMjNsLTIzMyAyMzNsMjMzIDIzM3ExMCAxMCAxMCAyM3QtMTAgMjNsLTE0NiAxNDZxLTEwIDEwIC0yMyAxMHQtMjMgLTEwbC0yMzMgLTIzM2wtMjMzIDIzM3EtMTAgMTAgLTIzIDEwdC0yMyAtMTBsLTE0NiAtMTQ2cS0xMCAtMTAgLTEwIC0yM3QxMCAtMjNsMjMzIC0yMzNsLTIzMyAtMjMzcS0xMCAtMTAgLTEwIC0yM3QxMCAtMjNsMTQ2IC0xNDZxMTAgLTEwIDIzIC0xMHQyMyAxMApsMjMzIDIzM2wyMzMgLTIzM3ExMCAtMTAgMjMgLTEwdDIzIDEwek0xNzkyIDEyNDh2LTEyMTZxMCAtNjYgLTQ3IC0xMTN0LTExMyAtNDdoLTE0NzJxLTY2IDAgLTExMyA0N3QtNDcgMTEzdjEyMTZxMCA2NiA0NyAxMTN0MTEzIDQ3aDE0NzJxNjYgMCAxMTMgLTQ3dDQ3IC0xMTN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyRDQiIHVuaWNvZGU9IiYjeGYyZDQ7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xMjU3IDQyNWwtMTQ2IC0xNDZxLTEwIC0xMCAtMjMgLTEwdC0yMyAxMGwtMTY5IDE2OWwtMTY5IC0xNjlxLTEwIC0xMCAtMjMgLTEwdC0yMyAxMGwtMTQ2IDE0NnEtMTAgMTAgLTEwIDIzdDEwIDIzbDE2OSAxNjlsLTE2OSAxNjlxLTEwIDEwIC0xMCAyM3QxMCAyM2wxNDYgMTQ2cTEwIDEwIDIzIDEwdDIzIC0xMGwxNjkgLTE2OWwxNjkgMTY5cTEwIDEwIDIzIDEwdDIzIC0xMGwxNDYgLTE0NnExMCAtMTAgMTAgLTIzdC0xMCAtMjMKbC0xNjkgLTE2OWwxNjkgLTE2OXExMCAtMTAgMTAgLTIzdC0xMCAtMjN6TTI1NiAxMjhoMTI4MHYxMDI0aC0xMjgwdi0xMDI0ek0xNzkyIDEyNDh2LTEyMTZxMCAtNjYgLTQ3IC0xMTN0LTExMyAtNDdoLTE0NzJxLTY2IDAgLTExMyA0N3QtNDcgMTEzdjEyMTZxMCA2NiA0NyAxMTN0MTEzIDQ3aDE0NzJxNjYgMCAxMTMgLTQ3dDQ3IC0xMTN6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyRDUiIHVuaWNvZGU9IiYjeGYyZDU7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xMDcwIDM1OGwzMDYgNTY0aC02NTRsLTMwNiAtNTY0aDY1NHpNMTc5MiA2NDBxMCAtMTgyIC03MSAtMzQ4dC0xOTEgLTI4NnQtMjg2IC0xOTF0LTM0OCAtNzF0LTM0OCA3MXQtMjg2IDE5MXQtMTkxIDI4NnQtNzEgMzQ4dDcxIDM0OHQxOTEgMjg2dDI4NiAxOTF0MzQ4IDcxdDM0OCAtNzF0Mjg2IC0xOTF0MTkxIC0yODZ0NzEgLTM0OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjJENiIgdW5pY29kZT0iJiN4ZjJkNjsiIGhvcml6LWFkdi14PSIxNzk0IiAKZD0iTTEyOTEgMTA2MHEtMTUgMTcgLTM1IDguNXQtMjYgLTI4LjV0NSAtMzhxMTQgLTE3IDQwIC0xNC41dDM0IDIwLjV0LTE4IDUyek04OTUgODE0cS04IC04IC0xOS41IC04dC0xOC41IDhxLTggOCAtOCAxOXQ4IDE4cTcgOCAxOC41IDh0MTkuNSAtOHE3IC03IDcgLTE4dC03IC0xOXpNMTA2MCA3NDBsLTM1IC0zNXEtMTIgLTEzIC0yOS41IC0xM3QtMzAuNSAxM2wtMzggMzhxLTEyIDEzIC0xMiAzMHQxMiAzMGwzNSAzNXExMiAxMiAyOS41IDEyCnQzMC41IC0xMmwzOCAtMzlxMTIgLTEyIDEyIC0yOS41dC0xMiAtMjkuNXpNOTUxIDg3MHEtNyAtOCAtMTguNSAtOHQtMTkuNSA4cS03IDggLTcgMTl0NyAxOXE4IDggMTkgOHQxOSAtOHQ4IC0xOXQtOCAtMTl6TTEzNTQgOTY4cS0zNCAtNjQgLTEwNy41IC04NS41dC0xMjcuNSAxNi41cS0zOCAyOCAtNjEgNjYuNXQtMjEgODcuNXQzOSA5MnQ3NS41IDUzdDcwLjUgLTV0NzAgLTUxcTIgLTIgMTMgLTEyLjV0MTQuNSAtMTMuNXQxMyAtMTMuNQp0MTIuNSAtMTUuNXQxMCAtMTUuNXQ4LjUgLTE4dDQgLTE4LjV0MSAtMjF0LTUgLTIydC05LjUgLTI0ek0xNTU1IDQ4NnEzIDIwIC04LjUgMzQuNXQtMjcuNSAyMS41dC0zMyAxN3QtMjMgMjBxLTQwIDcxIC04NCA5OC41dC0xMTMgMTEuNXExOSAxMyA0MCAxOC41dDMzIDQuNWwxMiAtMXEyIDQ1IC0zNCA5MHE2IDIwIDYuNSA0MC41dC0yLjUgMzAuNWwtMyAxMHE0MyAyNCA3MSA2NXQzNCA5MXExMCA4NCAtNDMgMTUwLjV0LTEzNyA3Ni41CnEtNjAgNyAtMTE0IC0xOC41dC04MiAtNzQuNXEtMzAgLTUxIC0zMy41IC0xMDF0MTQuNSAtODd0NDMuNSAtNjR0NTYuNSAtNDJxLTQ1IDQgLTg4IDM2dC01NyA4OHEtMjggMTA4IDMyIDIyMnEtMTYgMjEgLTI5IDMycS01MCAwIC04OSAtMTlxMTkgMjQgNDIgMzd0MzYgMTRsMTMgMXEwIDUwIC0xMyA3OHEtMTAgMjEgLTMyLjUgMjguNXQtNDcgLTMuNXQtMzcuNSAtNDBxMiA0IDQgN3EtNyAtMjggLTYuNSAtNzUuNXQxOSAtMTE3dDQ4LjUgLTEyMi41CnEtMjUgLTE0IC00NyAtMzZxLTM1IC0xNiAtODUuNSAtNzAuNXQtODQuNSAtMTAxLjVsLTMzIC00NnEtOTAgLTM0IC0xODEgLTEyNS41dC03NSAtMTYyLjVxMSAtMTYgMTEgLTI3cS0xNSAtMTIgLTMwIC0zMHEtMjEgLTI1IC0yMSAtNTR0MjEuNSAtNDB0NjMuNSA2cTQxIDE5IDc3IDQ5LjV0NTUgNjAuNXEtMiAyIC02LjUgNXQtMjAuNSA3LjV0LTMzIDMuNXEyMyA1IDUxIDEyLjV0NDAgMTB0MjcuNSA2dDI2IDR0MjMuNSAwLjVxMTQgLTcgMjIgMzQKcTcgMzcgNyA5MHEwIDEwMiAtNDAgMTUwcTEwNiAtMTAzIDEwMSAtMjE5cS0xIC0yOSAtMTUgLTUwdC0yNyAtMjdsLTEzIC02cS00IC03IC0xOSAtMzJ0LTI2IC00NS41dC0yNi41IC01MnQtMjUgLTYxdC0xNyAtNjN0LTYuNSAtNjYuNXQxMCAtNjNxLTM1IDU0IC0zNyA4MHEtMjIgLTI0IC0zNC41IC0zOXQtMzMuNSAtNDJ0LTMwLjUgLTQ2dC0xNi41IC00MXQtMC41IC0zOHQyNS41IC0yN3E0NSAtMjUgMTQ0IDY0dDE5MC41IDIyMS41CnQxMjIuNSAyMjguNXE4NiA1MiAxNDUgMTE1LjV0ODYgMTE5LjVxNDcgLTkzIDE1NCAtMTc4cTEwNCAtODMgMTY3IC04MHEzOSAyIDQ2IDQzek0xNzk0IDY0MHEwIC0xODIgLTcxIC0zNDh0LTE5MSAtMjg2dC0yODYuNSAtMTkxdC0zNDguNSAtNzF0LTM0OC41IDcxdC0yODYuNSAxOTF0LTE5MSAyODZ0LTcxIDM0OHQ3MSAzNDh0MTkxIDI4NnQyODYuNSAxOTF0MzQ4LjUgNzF0MzQ4LjUgLTcxdDI4Ni41IC0xOTF0MTkxIC0yODZ0NzEgLTM0OHoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjJENyIgdW5pY29kZT0iJiN4ZjJkNzsiIApkPSJNNTE4IDEzNTN2LTY1NXExMDMgLTEgMTkxLjUgMS41dDEyNS41IDUuNWwzNyAzcTY4IDIgOTAuNSAyNC41dDM5LjUgOTQuNWwzMyAxNDJoMTAzbC0xNCAtMzIybDcgLTMxOWgtMTAzbC0yOSAxMjdxLTE1IDY4IC00NSA5M3QtODQgMjZxLTg3IDggLTM1MiA4di01NTZxMCAtNzggNDMuNSAtMTE1LjV0MTMzLjUgLTM3LjVoMzU3cTM1IDAgNTkuNSAydDU1IDcuNXQ1NCAxOHQ0OC41IDMydDQ2IDUwLjV0MzkgNzNsOTMgMjE2aDg5CnEtNiAtMzcgLTMxLjUgLTI1MnQtMzAuNSAtMjc2cS0xNDYgNSAtMjYzLjUgOHQtMTYyLjUgNGgtNDRoLTYyOGwtMzc2IC0xMnYxMDJsMTI3IDI1cTY3IDEzIDkxLjUgMzd0MjUuNSA3OWw4IDY0M3EzIDQwMiAtOCA2NDVxLTIgNjEgLTI1LjUgODR0LTkxLjUgMzZsLTEyNyAyNHYxMDJsMzc2IC0xMmg3MDJxMTM5IDAgMzc0IDI3cS02IC02OCAtMTQgLTE5NC41dC0xMiAtMjE5LjVsLTUgLTkyaC05M2wtMzIgMTI0cS0zMSAxMjEgLTc0IDE3OS41CnQtMTEzIDU4LjVoLTU0OHEtMjggMCAtMzUuNSAtOC41dC03LjUgLTMwLjV6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyRDgiIHVuaWNvZGU9IiYjeGYyZDg7IiAKZD0iTTkyMiA3Mzl2LTE4MnEwIC00IDAuNSAtMTV0MCAtMTVsLTEuNSAtMTJ0LTMuNSAtMTEuNXQtNi41IC03LjV0LTExIC01LjV0LTE2IC0xLjV2MzA5cTkgMCAxNiAtMXQxMSAtNXQ2LjUgLTUuNXQzLjUgLTkuNXQxIC0xMC41di0xMy41di0xNHpNMTIzOCA2NDN2LTEyMXEwIC0xIDAuNSAtMTIuNXQwIC0xNS41dC0yLjUgLTExLjV0LTcuNSAtMTAuNXQtMTMuNSAtM3EtOSAwIC0xNCA5cS00IDEwIC00IDE2NXY3djguNXY5dDEuNSA4LjVsMy41IDcKdDUgNS41dDggMS41cTYgMCAxMCAtMS41dDYuNSAtNC41dDQgLTZ0MiAtOC41dDAuNSAtOHYtOS41di05ek0xODAgNDA3aDEyMnY0NzJoLTEyMnYtNDcyek02MTQgNDA3aDEwNnY0NzJoLTE1OWwtMjggLTIyMXEtMjAgMTQ4IC0zMiAyMjFoLTE1OHYtNDcyaDEwN3YzMTJsNDUgLTMxMmg3Nmw0MyAzMTl2LTMxOXpNMTAzOSA3MTJxMCA2NyAtNSA5MHEtMyAxNiAtMTEgMjguNXQtMTcgMjAuNXQtMjUgMTR0LTI2LjUgOC41dC0zMSA0dC0yOSAxLjUKaC0yOS41aC0xMmgtOTF2LTQ3Mmg1NnExNjkgLTEgMTk3IDI0LjV0MjUgMTgwLjVxLTEgNjIgLTEgMTAwek0xMzU2IDUxNXYxMzNxMCAyOSAtMiA0NXQtOS41IDMzLjV0LTI0LjUgMjV0LTQ2IDcuNXEtNDYgMCAtNzcgLTM0djE1NGgtMTE3di00NzJoMTEwbDcgMzBxMzAgLTM2IDc3IC0zNnE1MCAwIDY2IDMwLjV0MTYgODMuNXpNMTUzNiAxMjQ4di0xMjE2cTAgLTY2IC00NyAtMTEzdC0xMTMgLTQ3aC0xMjE2cS02NiAwIC0xMTMgNDd0LTQ3IDExMwp2MTIxNnEwIDY2IDQ3IDExM3QxMTMgNDdoMTIxNnE2NiAwIDExMyAtNDd0NDcgLTExM3oiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjJEOSIgdW5pY29kZT0iJiN4ZjJkOTsiIGhvcml6LWFkdi14PSIyMTc2IiAKZD0iTTExNDMgLTE5N3EtNiAxIC0xMSA0cS0xMyA4IC0zNiAyM3QtODYgNjV0LTExNi41IDEwNC41dC0xMTIgMTQwdC04OS41IDE3Mi41cS0xNyAzIC0xNzUgMzdxNjYgLTIxMyAyMzUgLTM2MnQzOTEgLTE4NHpNNTAyIDQwOWwxNjggLTI4cS0yNSA3NiAtNDEgMTY3LjV0LTE5IDE0NS41bC00IDUzcS04NCAtODIgLTEyMSAtMjI0cTUgLTY1IDE3IC0xMTR6TTYxMiAxMDE4cS00MyAtNjQgLTc3IC0xNDhxNDQgNDYgNzQgNjh6TTIwNDkgNTg0CnEwIDE2MSAtNjIgMzA3dC0xNjcuNSAyNTJ0LTI1MC41IDE2OC41dC0zMDQgNjIuNXEtMTQ3IDAgLTI4MSAtNTIuNXQtMjQwIC0xNDguNXEtMzAgLTU4IC00NSAtMTYwcTYwIDUxIDE0MyA4My41dDE1OC41IDQzdDE0MyAxMy41dDEwOC41IC0xbDQwIC0zcTMzIC0xIDUzIC0xNS41dDI0LjUgLTMzdDYuNSAtMzd0LTEgLTI4LjVxLTEyNiAxMSAtMjI3LjUgMC41dC0xODMgLTQzLjV0LTE0Mi41IC03MS41dC0xMzEgLTk4LjUKcTQgLTM2IDExLjUgLTkyLjV0MzUuNSAtMTc4dDYyIC0xNzkuNXExMjMgLTYgMjQ3LjUgMTQuNXQyMTQuNSA1My41dDE2Mi41IDY3dDEwOS41IDU5bDM3IDI0cTIyIDE2IDM5LjUgMjAuNXQzMC41IC01dDE3IC0zNC41cTE0IC05NyAtMzkgLTEyMXEtMjA4IC05NyAtNDY3IC0xMzRxLTEzNSAtMjAgLTMxNyAtMTZxNDEgLTk2IDExMCAtMTc2LjV0MTM3IC0xMjd0MTMwLjUgLTc5dDEwMS41IC00My41bDM5IC0xMnExNDMgLTIzIDI2MyAxNQpxMTk1IDk5IDMxNCAyODl0MTE5IDQxOHpNMjEyMyA2MjFxLTE0IC0xMzUgLTQwIC0yMTJxLTcwIC0yMDggLTE4MS41IC0zNDYuNXQtMzE4LjUgLTI1My41cS00OCAtMzMgLTgyIC00NHEtNzIgLTI2IC0xNjMgLTE2cS0zNiAtMyAtNzMgLTNxLTI4MyAwIC01MDQuNSAxNzN0LTI5NS41IDQ0MnEtMSAwIC00IDAuNXQtNSAwLjVxLTYgLTUwIDIuNSAtMTEyLjV0MjYgLTExNXQzNiAtOTh0MzEuNSAtNzEuNWwxNCAtMjZxOCAtMTIgNTQgLTgyCnEtNzEgMzggLTEyNC41IDEwNi41dC03OC41IDE0MHQtMzkuNSAxMzd0LTE3LjUgMTA3LjVsLTIgNDJxLTUgMiAtMzMuNSAxMi41dC00OC41IDE4dC01MyAyMC41dC01Ny41IDI1dC01MCAyNS41dC00Mi41IDI3dC0yNSAyNS41cTE5IC0xMCA1MC41IC0yNS41dDExMyAtNDUuNXQxNDUuNSAtMzhsMiAzMnExMSAxNDkgOTQgMjkwcTQxIDIwMiAxNzYgMzY1cTI4IDExNSA4MSAyMTRxMTUgMjggMzIgNDV0NDkgMzJxMTU4IDc0IDMwMy41IDEwNAp0MzAyIDExdDMwNi41IC05N3EyMjAgLTExNSAzMzMgLTMzNnQ4NyAtNDc0eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmlGMkRBIiB1bmljb2RlPSImI3hmMmRhOyIgaG9yaXotYWR2LXg9IjE3OTIiIApkPSJNMTM0MSA3NTJxMjkgNDQgLTYuNSAxMjkuNXQtMTIxLjUgMTQyLjVxLTU4IDM5IC0xMjUuNSA1My41dC0xMTggNC41dC02OC41IC0zN3EtMTIgLTIzIC00LjUgLTI4dDQyLjUgLTEwcTIzIC0zIDM4LjUgLTV0NDQuNSAtOS41dDU2IC0xNy41cTM2IC0xMyA2Ny41IC0zMS41dDUzIC0zN3Q0MCAtMzguNXQzMC41IC0zOHQyMiAtMzQuNXQxNi41IC0yOC41dDEyIC0xOC41dDEwLjUgLTZ0MTEgOS41ek0xNzA0IDE3OApxLTUyIC0xMjcgLTE0OC41IC0yMjB0LTIxNC41IC0xNDEuNXQtMjUzIC02MC41dC0yNjYgMTMuNXQtMjUxIDkxdC0yMTAgMTYxLjV0LTE0MS41IDIzNS41dC00Ni41IDMwMy41cTEgNDEgOC41IDg0LjV0MTIuNSA2NHQyNCA4MC41dDIzIDczcS01MSAtMjA4IDEgLTM5N3QxNzMgLTMxOHQyOTEgLTIwNnQzNDYgLTgzdDM0OSA3NC41dDI4OSAyNDQuNXEyMCAyNyAxOCAxNHEwIC00IC00IC0xNHpNMTQ2NSA2MjdxMCAtMTA0IC00MC41IC0xOTkKdC0xMDguNSAtMTY0dC0xNjIgLTEwOS41dC0xOTggLTQwLjV0LTE5OCA0MC41dC0xNjIgMTA5LjV0LTEwOC41IDE2NHQtNDAuNSAxOTl0NDAuNSAxOTl0MTA4LjUgMTY0dDE2MiAxMDkuNXQxOTggNDAuNXQxOTggLTQwLjV0MTYyIC0xMDkuNXQxMDguNSAtMTY0dDQwLjUgLTE5OXpNMTc1MiA5MTVxLTY1IDE0NyAtMTgwLjUgMjUxdC0yNTMgMTUzLjV0LTI5MiA1My41dC0zMDEgLTM2LjV0LTI3NS41IC0xMjl0LTIyMCAtMjExLjV0LTEzMSAtMjk3CnQtMTAgLTM3M3EtNDkgMTYxIC01MS41IDMxMS41dDM1LjUgMjcyLjV0MTA5IDIyN3QxNjUuNSAxODAuNXQyMDcgMTI2dDIzMiA3MXQyNDIuNSA5dDIzNiAtNTR0MjE2IC0xMjQuNXQxNzggLTE5N3EzMyAtNTAgNjIgLTEyMXQzMSAtMTEyek0xNjkwIDU3M3ExMiAyNDQgLTEzNi41IDQxNnQtMzk2LjUgMjQwcS04IDAgLTEwIDV0MjQgOHExMjUgLTQgMjMwIC01MHQxNzMgLTEyMHQxMTYgLTE2OC41dDU4LjUgLTE5OXQtMSAtMjA4CnQtNjEuNSAtMTk3LjV0LTEyMi41IC0xNjd0LTE4NSAtMTE3LjV0LTI0OC41IC00Ni41cTEwOCAzMCAyMDEuNSA4MHQxNzQgMTIzdDEyOS41IDE3Ni41dDU1IDIyNS41eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmlGMkRCIiB1bmljb2RlPSImI3hmMmRiOyIgCmQ9Ik0xOTIgMjU2di0xMjhoLTExMnEtMTYgMCAtMTYgMTZ2MTZoLTQ4cS0xNiAwIC0xNiAxNnYzMnEwIDE2IDE2IDE2aDQ4djE2cTAgMTYgMTYgMTZoMTEyek0xOTIgNTEydi0xMjhoLTExMnEtMTYgMCAtMTYgMTZ2MTZoLTQ4cS0xNiAwIC0xNiAxNnYzMnEwIDE2IDE2IDE2aDQ4djE2cTAgMTYgMTYgMTZoMTEyek0xOTIgNzY4di0xMjhoLTExMnEtMTYgMCAtMTYgMTZ2MTZoLTQ4cS0xNiAwIC0xNiAxNnYzMnEwIDE2IDE2IDE2aDQ4djE2CnEwIDE2IDE2IDE2aDExMnpNMTkyIDEwMjR2LTEyOGgtMTEycS0xNiAwIC0xNiAxNnYxNmgtNDhxLTE2IDAgLTE2IDE2djMycTAgMTYgMTYgMTZoNDh2MTZxMCAxNiAxNiAxNmgxMTJ6TTE5MiAxMjgwdi0xMjhoLTExMnEtMTYgMCAtMTYgMTZ2MTZoLTQ4cS0xNiAwIC0xNiAxNnYzMnEwIDE2IDE2IDE2aDQ4djE2cTAgMTYgMTYgMTZoMTEyek0xMjgwIDE0NDB2LTE0NzJxMCAtNDAgLTI4IC02OHQtNjggLTI4aC04MzJxLTQwIDAgLTY4IDI4CnQtMjggNjh2MTQ3MnEwIDQwIDI4IDY4dDY4IDI4aDgzMnE0MCAwIDY4IC0yOHQyOCAtNjh6TTE1MzYgMjA4di0zMnEwIC0xNiAtMTYgLTE2aC00OHYtMTZxMCAtMTYgLTE2IC0xNmgtMTEydjEyOGgxMTJxMTYgMCAxNiAtMTZ2LTE2aDQ4cTE2IDAgMTYgLTE2ek0xNTM2IDQ2NHYtMzJxMCAtMTYgLTE2IC0xNmgtNDh2LTE2cTAgLTE2IC0xNiAtMTZoLTExMnYxMjhoMTEycTE2IDAgMTYgLTE2di0xNmg0OHExNiAwIDE2IC0xNnpNMTUzNiA3MjB2LTMyCnEwIC0xNiAtMTYgLTE2aC00OHYtMTZxMCAtMTYgLTE2IC0xNmgtMTEydjEyOGgxMTJxMTYgMCAxNiAtMTZ2LTE2aDQ4cTE2IDAgMTYgLTE2ek0xNTM2IDk3NnYtMzJxMCAtMTYgLTE2IC0xNmgtNDh2LTE2cTAgLTE2IC0xNiAtMTZoLTExMnYxMjhoMTEycTE2IDAgMTYgLTE2di0xNmg0OHExNiAwIDE2IC0xNnpNMTUzNiAxMjMydi0zMnEwIC0xNiAtMTYgLTE2aC00OHYtMTZxMCAtMTYgLTE2IC0xNmgtMTEydjEyOGgxMTJxMTYgMCAxNiAtMTZ2LTE2Cmg0OHExNiAwIDE2IC0xNnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjJEQyIgdW5pY29kZT0iJiN4ZjJkYzsiIGhvcml6LWFkdi14PSIxNjY0IiAKZD0iTTE1NjYgNDE5bC0xNjcgLTMzbDE4NiAtMTA3cTIzIC0xMyAyOS41IC0zOC41dC02LjUgLTQ4LjVxLTE0IC0yMyAtMzkgLTI5LjV0LTQ4IDYuNWwtMTg2IDEwNmw1NSAtMTYwcTEzIC0zOCAtMTIgLTYzLjV0LTYwLjUgLTIwLjV0LTQ4LjUgNDJsLTEwMiAzMDBsLTI3MSAxNTZ2LTMxM2wyMDggLTIzOHExNiAtMTggMTcgLTM5dC0xMSAtMzYuNXQtMjguNSAtMjV0LTM3IC01LjV0LTM2LjUgMjJsLTExMiAxMjh2LTIxNHEwIC0yNiAtMTkgLTQ1CnQtNDUgLTE5dC00NSAxOXQtMTkgNDV2MjE0bC0xMTIgLTEyOHEtMTYgLTE4IC0zNi41IC0yMnQtMzcgNS41dC0yOC41IDI1dC0xMSAzNi41dDE3IDM5bDIwOCAyMzh2MzEzbC0yNzEgLTE1NmwtMTAyIC0zMDBxLTEzIC0zNyAtNDguNSAtNDJ0LTYwLjUgMjAuNXQtMTIgNjMuNWw1NSAxNjBsLTE4NiAtMTA2cS0yMyAtMTMgLTQ4IC02LjV0LTM5IDI5LjVxLTEzIDIzIC02LjUgNDguNXQyOS41IDM4LjVsMTg2IDEwN2wtMTY3IDMzCnEtMjkgNiAtNDIgMjl0LTguNSA0Ni41dDI1LjUgNDB0NTAgMTAuNWwzMTAgLTYybDI3MSAxNTdsLTI3MSAxNTdsLTMxMCAtNjJxLTQgLTEgLTEzIC0xcS0yNyAwIC00NCAxOHQtMTkgNDB0MTEgNDN0NDAgMjZsMTY3IDMzbC0xODYgMTA3cS0yMyAxMyAtMjkuNSAzOC41dDYuNSA0OC41dDM5IDMwdDQ4IC03bDE4NiAtMTA2bC01NSAxNjBxLTEzIDM4IDEyIDYzLjV0NjAuNSAyMC41dDQ4LjUgLTQybDEwMiAtMzAwbDI3MSAtMTU2djMxMwpsLTIwOCAyMzhxLTE2IDE4IC0xNyAzOXQxMSAzNi41dDI4LjUgMjV0MzcgNS41dDM2LjUgLTIybDExMiAtMTI4djIxNHEwIDI2IDE5IDQ1dDQ1IDE5dDQ1IC0xOXQxOSAtNDV2LTIxNGwxMTIgMTI4cTE2IDE4IDM2LjUgMjJ0MzcgLTUuNXQyOC41IC0yNXQxMSAtMzYuNXQtMTcgLTM5bC0yMDggLTIzOHYtMzEzbDI3MSAxNTZsMTAyIDMwMHExMyAzNyA0OC41IDQydDYwLjUgLTIwLjV0MTIgLTYzLjVsLTU1IC0xNjBsMTg2IDEwNgpxMjMgMTMgNDggNi41dDM5IC0yOS41cTEzIC0yMyA2LjUgLTQ4LjV0LTI5LjUgLTM4LjVsLTE4NiAtMTA3bDE2NyAtMzNxMjcgLTUgNDAgLTI2dDExIC00M3QtMTkgLTQwdC00NCAtMThxLTkgMCAtMTMgMWwtMzEwIDYybC0yNzEgLTE1N2wyNzEgLTE1N2wzMTAgNjJxMjkgNiA1MCAtMTAuNXQyNS41IC00MHQtOC41IC00Ni41dC00MiAtMjl6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyREQiIHVuaWNvZGU9IiYjeGYyZGQ7IiBob3Jpei1hZHYteD0iMTc5MiIgCmQ9Ik0xNDczIDYwN3E3IDExOCAtMzMgMjI2LjV0LTExMyAxODl0LTE3NyAxMzF0LTIyMSA1Ny41cS0xMTYgNyAtMjI1LjUgLTMydC0xOTIgLTExMC41dC0xMzUgLTE3NXQtNTkuNSAtMjIwLjVxLTcgLTExOCAzMyAtMjI2LjV0MTEzIC0xODl0MTc3LjUgLTEzMXQyMjEuNSAtNTcuNXExNTUgLTkgMjkzIDU5dDIyNCAxOTUuNXQ5NCAyODMuNXpNMTc5MiAxNTM2bC0zNDkgLTM0OHExMjAgLTExNyAxODAuNSAtMjcydDUwLjUgLTMyMQpxLTExIC0xODMgLTEwMiAtMzM5dC0yNDEgLTI1NS41dC0zMzIgLTEyNC41bC05OTkgLTEzMmwzNDcgMzQ3cS0xMjAgMTE2IC0xODAuNSAyNzEuNXQtNTAuNSAzMjEuNXExMSAxODQgMTAyIDM0MHQyNDEuNSAyNTUuNXQzMzIuNSAxMjQuNXExNjcgMjIgNTAwIDY2dDUwMCA2NnoiIC8+CiAgICA8Z2x5cGggZ2x5cGgtbmFtZT0idW5pRjJERSIgdW5pY29kZT0iJiN4ZjJkZTsiIGhvcml6LWFkdi14PSIxNzkyIiAKZD0iTTk0OCA1MDhsMTYzIC0zMjloLTUxbC0xNzUgMzUwbC0xNzEgLTM1MGgtNDlsMTc5IDM3NGwtNzggMzNsMjEgNDlsMjQwIC0xMDJsLTIxIC01MHpNNTYzIDExMDBsMzA0IC0xMzBsLTEzMCAtMzA0bC0zMDQgMTMwek05MDcgOTE1bDI0MCAtMTAzbC0xMDMgLTIzOWwtMjM5IDEwMnpNMTE4OCA3NjVsMTkxIC04MWwtODIgLTE5MGwtMTkwIDgxek0xNjgwIDY0MHEwIDE1OSAtNjIgMzA0dC0xNjcuNSAyNTAuNXQtMjUwLjUgMTY3LjV0LTMwNCA2Mgp0LTMwNCAtNjJ0LTI1MC41IC0xNjcuNXQtMTY3LjUgLTI1MC41dC02MiAtMzA0dDYyIC0zMDR0MTY3LjUgLTI1MC41dDI1MC41IC0xNjcuNXQzMDQgLTYydDMwNCA2MnQyNTAuNSAxNjcuNXQxNjcuNSAyNTAuNXQ2MiAzMDR6TTE3OTIgNjQwcTAgLTE4MiAtNzEgLTM0OHQtMTkxIC0yODZ0LTI4NiAtMTkxdC0zNDggLTcxdC0zNDggNzF0LTI4NiAxOTF0LTE5MSAyODZ0LTcxIDM0OHQ3MSAzNDh0MTkxIDI4NnQyODYgMTkxdDM0OCA3MXQzNDggLTcxCnQyODYgLTE5MXQxOTEgLTI4NnQ3MSAtMzQ4eiIgLz4KICAgIDxnbHlwaCBnbHlwaC1uYW1lPSJ1bmlGMkUwIiB1bmljb2RlPSImI3hmMmUwOyIgaG9yaXotYWR2LXg9IjE5MjAiIApkPSJNMTMzNCAzMDJxLTQgMjQgLTI3LjUgMzR0LTQ5LjUgMTAuNXQtNDguNSAxMi41dC0yNS41IDM4cS01IDQ3IDMzIDEzOS41dDc1IDE4MXQzMiAxMjcuNXEtMTQgMTAxIC0xMTcgMTAzcS00NSAxIC03NSAtMTZsLTMgLTJsLTUgLTIuNXQtNC41IC0ydC01IC0ydC01IC0wLjV0LTYgMS41dC02IDMuNXQtNi41IDVxLTMgMiAtOSA4LjV0LTkgOXQtOC41IDcuNXQtOS41IDcuNXQtOS41IDUuNXQtMTEgNC41dC0xMS41IDIuNXEtMzAgNSAtNDggLTMKdC00NSAtMzFxLTEgLTEgLTkgLTguNXQtMTIuNSAtMTF0LTE1IC0xMHQtMTYuNSAtNS41dC0xNyAzcS01NCAyNyAtODQgNDBxLTQxIDE4IC05NCAtNXQtNzYgLTY1cS0xNiAtMjggLTQxIC05OC41dC00My41IC0xMzIuNXQtNDAgLTEzNHQtMjEuNSAtNzNxLTIyIC02OSAxOC41IC0xMTl0MTEwLjUgLTQ2cTMwIDIgNTAuNSAxNXQzOC41IDQ2cTcgMTMgNzkgMTk5LjV0NzcgMTk0LjVxNiAxMSAyMS41IDE4dDI5LjUgMHEyNyAtMTUgMjEgLTUzCnEtMiAtMTggLTUxIC0xMzkuNXQtNTAgLTEzMi41cS02IC0zOCAxOS41IC01Ni41dDYwLjUgLTd0NTUgNDkuNXE0IDggNDUuNSA5MnQ4MS41IDE2My41dDQ2IDg4LjVxMjAgMjkgNDEgMjhxMjkgMCAyNSAtMzhxLTIgLTE2IC02NS41IC0xNDcuNXQtNzAuNSAtMTU5LjVxLTEyIC01MyAxMyAtMTAzdDc0IC03NHExNyAtOSA1MSAtMTUuNXQ3MS41IC04dDYyLjUgMTR0MjAgNDguNXpNMzgzIDg2cTMgLTE1IC01IC0yNy41dC0yMyAtMTUuNQpxLTE0IC0zIC0yNi41IDV0LTE1LjUgMjNxLTMgMTQgNSAyN3QyMiAxNnQyNyAtNXQxNiAtMjN6TTk1MyAtMTc3cTEyIC0xNyA4LjUgLTM3LjV0LTIwLjUgLTMyLjV0LTM3LjUgLTh0LTMyLjUgMjFxLTExIDE3IC03LjUgMzcuNXQyMC41IDMyLjV0MzcuNSA4dDMxLjUgLTIxek0xNzcgNjM1cS0xOCAtMjcgLTQ5LjUgLTMzdC01Ny41IDEzcS0yNiAxOCAtMzIgNTB0MTIgNThxMTggMjcgNDkuNSAzM3Q1Ny41IC0xMnEyNiAtMTkgMzIgLTUwLjUKdC0xMiAtNTguNXpNMTQ2NyAtNDJxMTkgLTI4IDEzIC02MS41dC0zNCAtNTIuNXQtNjAuNSAtMTN0LTUxLjUgMzR0LTEzIDYxdDMzIDUzcTI4IDE5IDYwLjUgMTN0NTIuNSAtMzR6TTE1NzkgNTYycTY5IC0xMTMgNDIuNSAtMjQ0LjV0LTEzNC41IC0yMDcuNXEtOTAgLTYzIC0xOTkgLTYwcS0yMCAtODAgLTg0LjUgLTEyN3QtMTQzLjUgLTQ0LjV0LTE0MCA1Ny41cS0xMiAtOSAtMTMgLTEwcS0xMDMgLTcxIC0yMjUgLTQ4LjV0LTE5MyAxMjYuNQpxLTUwIDczIC01MyAxNjRxLTgzIDE0IC0xNDIuNSA3MC41dC04MC41IDEyOHQtMiAxNTJ0ODEgMTM4LjVxLTM2IDYwIC0zOCAxMjh0MjQuNSAxMjV0NzkuNSA5OC41dDEyMSA1MC41cTMyIDg1IDk5IDE0OHQxNDYuNSA5MS41dDE2OCAxN3QxNTkuNSAtNjYuNXE3MiAyMSAxNDAgMTcuNXQxMjguNSAtMzZ0MTA0LjUgLTgwdDY3LjUgLTExNXQxNy41IC0xNDAuNXE1MiAtMTYgODcgLTU3dDQ1LjUgLTg5dC01LjUgLTk5LjV0LTU4IC04Ny41egpNNDU1IDEyMjJxMTQgLTIwIDkuNSAtNDQuNXQtMjQuNSAtMzguNXEtMTkgLTE0IC00My41IC05LjV0LTM3LjUgMjQuNXEtMTQgMjAgLTkuNSA0NC41dDI0LjUgMzguNXExOSAxNCA0My41IDkuNXQzNy41IC0yNC41ek02MTQgMTUwM3E0IC0xNiAtNSAtMzAuNXQtMjYgLTE4LjV0LTMxIDUuNXQtMTggMjYuNXEtMyAxNyA2LjUgMzF0MjUuNSAxOHExNyA0IDMxIC01LjV0MTcgLTI2LjV6TTE4MDAgNTU1cTQgLTIwIC02LjUgLTM3dC0zMC41IC0yMQpxLTE5IC00IC0zNiA2LjV0LTIxIDMwLjV0Ni41IDM3dDMwLjUgMjJxMjAgNCAzNi41IC03LjV0MjAuNSAtMzAuNXpNMTEzNiAxNDQ4cTE2IC0yNyA4LjUgLTU4LjV0LTM1LjUgLTQ3LjVxLTI3IC0xNiAtNTcuNSAtOC41dC00Ni41IDM0LjVxLTE2IDI4IC04LjUgNTl0MzQuNSA0OHQ1OCA5dDQ3IC0zNnpNMTg4MiA3OTJxNCAtMTUgLTQgLTI3LjV0LTIzIC0xNi41cS0xNSAtMyAtMjcuNSA1LjV0LTE1LjUgMjIuNXEtMyAxNSA1IDI4dDIzIDE2CnExNCAzIDI2LjUgLTV0MTUuNSAtMjN6TTE2OTEgMTAzM3ExNSAtMjIgMTAuNSAtNDl0LTI2LjUgLTQzcS0yMiAtMTUgLTQ5IC0xMHQtNDIgMjd0LTEwIDQ5dDI3IDQzdDQ4LjUgMTF0NDEuNSAtMjh6IiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyRTEiIHVuaWNvZGU9IiYjeGYyZTE7IiBob3Jpei1hZHYteD0iMTc5MiIgCiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyRTIiIHVuaWNvZGU9IiYjeGYyZTI7IiBob3Jpei1hZHYteD0iMTc5MiIgCiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyRTMiIHVuaWNvZGU9IiYjeGYyZTM7IiBob3Jpei1hZHYteD0iMTc5MiIgCiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyRTQiIHVuaWNvZGU9IiYjeGYyZTQ7IiBob3Jpei1hZHYteD0iMTc5MiIgCiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyRTUiIHVuaWNvZGU9IiYjeGYyZTU7IiBob3Jpei1hZHYteD0iMTc5MiIgCiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyRTYiIHVuaWNvZGU9IiYjeGYyZTY7IiBob3Jpei1hZHYteD0iMTc5MiIgCiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyRTciIHVuaWNvZGU9IiYjeGYyZTc7IiBob3Jpei1hZHYteD0iMTc5MiIgCiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Il82OTgiIHVuaWNvZGU9IiYjeGYyZTg7IiBob3Jpei1hZHYteD0iMTc5MiIgCiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyRTkiIHVuaWNvZGU9IiYjeGYyZTk7IiBob3Jpei1hZHYteD0iMTc5MiIgCiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyRUEiIHVuaWNvZGU9IiYjeGYyZWE7IiBob3Jpei1hZHYteD0iMTc5MiIgCiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyRUIiIHVuaWNvZGU9IiYjeGYyZWI7IiBob3Jpei1hZHYteD0iMTc5MiIgCiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyRUMiIHVuaWNvZGU9IiYjeGYyZWM7IiBob3Jpei1hZHYteD0iMTc5MiIgCiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyRUQiIHVuaWNvZGU9IiYjeGYyZWQ7IiBob3Jpei1hZHYteD0iMTc5MiIgCiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9InVuaUYyRUUiIHVuaWNvZGU9IiYjeGYyZWU7IiBob3Jpei1hZHYteD0iMTc5MiIgCiAvPgogICAgPGdseXBoIGdseXBoLW5hbWU9Imxlc3NlcXVhbCIgdW5pY29kZT0iJiN4ZjUwMDsiIGhvcml6LWFkdi14PSIxNzkyIiAKIC8+CiAgPC9mb250Pgo8L2RlZnM+PC9zdmc+Cg==)format("svg");font-weight:normal;font-style:normal}.fa{display:inline-block;font:normal normal normal 14px/1 FontAwesome;font-size:inherit;text-rendering:auto;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.fa-lg{font-size:1.33333333em;line-height:.75em;vertical-align:-15%}.fa-2x{font-size:2em}.fa-3x{font-size:3em}.fa-4x{font-size:4em}.fa-5x{font-size:5em}.fa-fw{width:1.28571429em;text-align:center}.fa-ul{padding-left:0;margin-left:2.14285714em;list-style-type:none}.fa-ul>li{position:relative}.fa-li{position:absolute;left:-2.14285714em;width:2.14285714em;top:.14285714em;text-align:center}.fa-li.fa-lg{left:-1.85714286em}.fa-border{padding:.2em .25em .15em;border:solid .08em #eee;border-radius:.1em}.fa-pull-left{float:left}.fa-pull-right{float:right}.fa.fa-pull-left{margin-right:.3em}.fa.fa-pull-right{margin-left:.3em}.pull-right{float:right}.pull-left{float:left}.fa.pull-left{margin-right:.3em}.fa.pull-right{margin-left:.3em}.fa-spin{-webkit-animation:fa-spin 2s infinite linear;animation:fa-spin 2s infinite linear}.fa-pulse{-webkit-animation:fa-spin 1s infinite steps(8);animation:fa-spin 1s infinite steps(8)}@-webkit-keyframes fa-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}@keyframes fa-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}.fa-rotate-90{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);transform:rotate(90deg)}.fa-rotate-180{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";-webkit-transform:rotate(180deg);-ms-transform:rotate(180deg);transform:rotate(180deg)}.fa-rotate-270{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";-webkit-transform:rotate(270deg);-ms-transform:rotate(270deg);transform:rotate(270deg)}.fa-flip-horizontal{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";-webkit-transform:scale(-1,1);-ms-transform:scale(-1,1);transform:scale(-1,1)}.fa-flip-vertical{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";-webkit-transform:scale(1,-1);-ms-transform:scale(1,-1);transform:scale(1,-1)}:root .fa-rotate-90,:root .fa-rotate-180,:root .fa-rotate-270,:root .fa-flip-horizontal,:root .fa-flip-vertical{filter:none}.fa-stack{position:relative;display:inline-block;width:2em;height:2em;line-height:2em;vertical-align:middle}.fa-stack-1x,.fa-stack-2x{position:absolute;left:0;width:100%;text-align:center}.fa-stack-1x{line-height:inherit}.fa-stack-2x{font-size:2em}.fa-inverse{color:#fff}.fa-glass:before{content:"ï"}.fa-music:before{content:"ï"}.fa-search:before{content:"ï"}.fa-envelope-o:before{content:"ï"}.fa-heart:before{content:"ï"}.fa-star:before{content:"ï"}.fa-star-o:before{content:"ï"}.fa-user:before{content:"ï"}.fa-film:before{content:"ï"}.fa-th-large:before{content:"ï"}.fa-th:before{content:"ï"}.fa-th-list:before{content:"ï"}.fa-check:before{content:"ï"}.fa-remove:before,.fa-close:before,.fa-times:before{content:"ï"}.fa-search-plus:before{content:"ï"}.fa-search-minus:before{content:"ï"}.fa-power-off:before{content:"ï"}.fa-signal:before{content:"ï"}.fa-gear:before,.fa-cog:before{content:"ï"}.fa-trash-o:before{content:"ï"}.fa-home:before{content:"ï"}.fa-file-o:before{content:"ï"}.fa-clock-o:before{content:"ï"}.fa-road:before{content:"ï"}.fa-download:before{content:"ï"}.fa-arrow-circle-o-down:before{content:"ï"}.fa-arrow-circle-o-up:before{content:"ï"}.fa-inbox:before{content:"ï"}.fa-play-circle-o:before{content:"ï"}.fa-rotate-right:before,.fa-repeat:before{content:"ï"}.fa-refresh:before{content:"ï¡"}.fa-list-alt:before{content:"ï¢"}.fa-lock:before{content:"ï£"}.fa-flag:before{content:"ï¤"}.fa-headphones:before{content:"ï¥"}.fa-volume-off:before{content:"ï¦"}.fa-volume-down:before{content:"ï§"}.fa-volume-up:before{content:"ï¨"}.fa-qrcode:before{content:"ï©"}.fa-barcode:before{content:"ïª"}.fa-tag:before{content:"ï«"}.fa-tags:before{content:"ï¬"}.fa-book:before{content:"ï­"}.fa-bookmark:before{content:"ï®"}.fa-print:before{content:"ï¯"}.fa-camera:before{content:"ï°"}.fa-font:before{content:"ï±"}.fa-bold:before{content:"ï²"}.fa-italic:before{content:"ï³"}.fa-text-height:before{content:"ï´"}.fa-text-width:before{content:"ïµ"}.fa-align-left:before{content:"ï¶"}.fa-align-center:before{content:"ï·"}.fa-align-right:before{content:"ï¸"}.fa-align-justify:before{content:"ï¹"}.fa-list:before{content:"ïº"}.fa-dedent:before,.fa-outdent:before{content:"ï»"}.fa-indent:before{content:"ï¼"}.fa-video-camera:before{content:"ï½"}.fa-photo:before,.fa-image:before,.fa-picture-o:before{content:"ï¾"}.fa-pencil:before{content:"ï"}.fa-map-marker:before{content:"ï"}.fa-adjust:before{content:"ï"}.fa-tint:before{content:"ï"}.fa-edit:before,.fa-pencil-square-o:before{content:"ï"}.fa-share-square-o:before{content:"ï"}.fa-check-square-o:before{content:"ï"}.fa-arrows:before{content:"ï"}.fa-step-backward:before{content:"ï"}.fa-fast-backward:before{content:"ï"}.fa-backward:before{content:"ï"}.fa-play:before{content:"ï"}.fa-pause:before{content:"ï"}.fa-stop:before{content:"ï"}.fa-forward:before{content:"ï"}.fa-fast-forward:before{content:"ï"}.fa-step-forward:before{content:"ï"}.fa-eject:before{content:"ï"}.fa-chevron-left:before{content:"ï"}.fa-chevron-right:before{content:"ï"}.fa-plus-circle:before{content:"ï"}.fa-minus-circle:before{content:"ï"}.fa-times-circle:before{content:"ï"}.fa-check-circle:before{content:"ï"}.fa-question-circle:before{content:"ï"}.fa-info-circle:before{content:"ï"}.fa-crosshairs:before{content:"ï"}.fa-times-circle-o:before{content:"ï"}.fa-check-circle-o:before{content:"ï"}.fa-ban:before{content:"ï"}.fa-arrow-left:before{content:"ï "}.fa-arrow-right:before{content:"ï¡"}.fa-arrow-up:before{content:"ï¢"}.fa-arrow-down:before{content:"ï£"}.fa-mail-forward:before,.fa-share:before{content:"ï¤"}.fa-expand:before{content:"ï¥"}.fa-compress:before{content:"ï¦"}.fa-plus:before{content:"ï§"}.fa-minus:before{content:"ï¨"}.fa-asterisk:before{content:"ï©"}.fa-exclamation-circle:before{content:"ïª"}.fa-gift:before{content:"ï«"}.fa-leaf:before{content:"ï¬"}.fa-fire:before{content:"ï­"}.fa-eye:before{content:"ï®"}.fa-eye-slash:before{content:"ï°"}.fa-warning:before,.fa-exclamation-triangle:before{content:"ï±"}.fa-plane:before{content:"ï²"}.fa-calendar:before{content:"ï³"}.fa-random:before{content:"ï´"}.fa-comment:before{content:"ïµ"}.fa-magnet:before{content:"ï¶"}.fa-chevron-up:before{content:"ï·"}.fa-chevron-down:before{content:"ï¸"}.fa-retweet:before{content:"ï¹"}.fa-shopping-cart:before{content:"ïº"}.fa-folder:before{content:"ï»"}.fa-folder-open:before{content:"ï¼"}.fa-arrows-v:before{content:"ï½"}.fa-arrows-h:before{content:"ï¾"}.fa-bar-chart-o:before,.fa-bar-chart:before{content:"ï"}.fa-twitter-square:before{content:"ï"}.fa-facebook-square:before{content:"ï"}.fa-camera-retro:before{content:"ï"}.fa-key:before{content:"ï"}.fa-gears:before,.fa-cogs:before{content:"ï"}.fa-comments:before{content:"ï"}.fa-thumbs-o-up:before{content:"ï"}.fa-thumbs-o-down:before{content:"ï"}.fa-star-half:before{content:"ï"}.fa-heart-o:before{content:"ï"}.fa-sign-out:before{content:"ï"}.fa-linkedin-square:before{content:"ï"}.fa-thumb-tack:before{content:"ï"}.fa-external-link:before{content:"ï"}.fa-sign-in:before{content:"ï"}.fa-trophy:before{content:"ï"}.fa-github-square:before{content:"ï"}.fa-upload:before{content:"ï"}.fa-lemon-o:before{content:"ï"}.fa-phone:before{content:"ï"}.fa-square-o:before{content:"ï"}.fa-bookmark-o:before{content:"ï"}.fa-phone-square:before{content:"ï"}.fa-twitter:before{content:"ï"}.fa-facebook-f:before,.fa-facebook:before{content:"ï"}.fa-github:before{content:"ï"}.fa-unlock:before{content:"ï"}.fa-credit-card:before{content:"ï"}.fa-feed:before,.fa-rss:before{content:"ï"}.fa-hdd-o:before{content:"ï "}.fa-bullhorn:before{content:"ï¡"}.fa-bell:before{content:"ï³"}.fa-certificate:before{content:"ï£"}.fa-hand-o-right:before{content:"ï¤"}.fa-hand-o-left:before{content:"ï¥"}.fa-hand-o-up:before{content:"ï¦"}.fa-hand-o-down:before{content:"ï§"}.fa-arrow-circle-left:before{content:"ï¨"}.fa-arrow-circle-right:before{content:"ï©"}.fa-arrow-circle-up:before{content:"ïª"}.fa-arrow-circle-down:before{content:"ï«"}.fa-globe:before{content:"ï¬"}.fa-wrench:before{content:"ï­"}.fa-tasks:before{content:"ï®"}.fa-filter:before{content:"ï°"}.fa-briefcase:before{content:"ï±"}.fa-arrows-alt:before{content:"ï²"}.fa-group:before,.fa-users:before{content:"ï"}.fa-chain:before,.fa-link:before{content:"ï"}.fa-cloud:before{content:"ï"}.fa-flask:before{content:"ï"}.fa-cut:before,.fa-scissors:before{content:"ï"}.fa-copy:before,.fa-files-o:before{content:"ï"}.fa-paperclip:before{content:"ï"}.fa-save:before,.fa-floppy-o:before{content:"ï"}.fa-square:before{content:"ï"}.fa-navicon:before,.fa-reorder:before,.fa-bars:before{content:"ï"}.fa-list-ul:before{content:"ï"}.fa-list-ol:before{content:"ï"}.fa-strikethrough:before{content:"ï"}.fa-underline:before{content:"ï"}.fa-table:before{content:"ï"}.fa-magic:before{content:"ï"}.fa-truck:before{content:"ï"}.fa-pinterest:before{content:"ï"}.fa-pinterest-square:before{content:"ï"}.fa-google-plus-square:before{content:"ï"}.fa-google-plus:before{content:"ï"}.fa-money:before{content:"ï"}.fa-caret-down:before{content:"ï"}.fa-caret-up:before{content:"ï"}.fa-caret-left:before{content:"ï"}.fa-caret-right:before{content:"ï"}.fa-columns:before{content:"ï"}.fa-unsorted:before,.fa-sort:before{content:"ï"}.fa-sort-down:before,.fa-sort-desc:before{content:"ï"}.fa-sort-up:before,.fa-sort-asc:before{content:"ï"}.fa-envelope:before{content:"ï "}.fa-linkedin:before{content:"ï¡"}.fa-rotate-left:before,.fa-undo:before{content:"ï¢"}.fa-legal:before,.fa-gavel:before{content:"ï£"}.fa-dashboard:before,.fa-tachometer:before{content:"ï¤"}.fa-comment-o:before{content:"ï¥"}.fa-comments-o:before{content:"ï¦"}.fa-flash:before,.fa-bolt:before{content:"ï§"}.fa-sitemap:before{content:"ï¨"}.fa-umbrella:before{content:"ï©"}.fa-paste:before,.fa-clipboard:before{content:"ïª"}.fa-lightbulb-o:before{content:"ï«"}.fa-exchange:before{content:"ï¬"}.fa-cloud-download:before{content:"ï­"}.fa-cloud-upload:before{content:"ï®"}.fa-user-md:before{content:"ï°"}.fa-stethoscope:before{content:"ï±"}.fa-suitcase:before{content:"ï²"}.fa-bell-o:before{content:"ï¢"}.fa-coffee:before{content:"ï´"}.fa-cutlery:before{content:"ïµ"}.fa-file-text-o:before{content:"ï¶"}.fa-building-o:before{content:"ï·"}.fa-hospital-o:before{content:"ï¸"}.fa-ambulance:before{content:"ï¹"}.fa-medkit:before{content:"ïº"}.fa-fighter-jet:before{content:"ï»"}.fa-beer:before{content:"ï¼"}.fa-h-square:before{content:"ï½"}.fa-plus-square:before{content:"ï¾"}.fa-angle-double-left:before{content:"ï"}.fa-angle-double-right:before{content:"ï"}.fa-angle-double-up:before{content:"ï"}.fa-angle-double-down:before{content:"ï"}.fa-angle-left:before{content:"ï"}.fa-angle-right:before{content:"ï"}.fa-angle-up:before{content:"ï"}.fa-angle-down:before{content:"ï"}.fa-desktop:before{content:"ï"}.fa-laptop:before{content:"ï"}.fa-tablet:before{content:"ï"}.fa-mobile-phone:before,.fa-mobile:before{content:"ï"}.fa-circle-o:before{content:"ï"}.fa-quote-left:before{content:"ï"}.fa-quote-right:before{content:"ï"}.fa-spinner:before{content:"ï"}.fa-circle:before{content:"ï"}.fa-mail-reply:before,.fa-reply:before{content:"ï"}.fa-github-alt:before{content:"ï"}.fa-folder-o:before{content:"ï"}.fa-folder-open-o:before{content:"ï"}.fa-smile-o:before{content:"ï"}.fa-frown-o:before{content:"ï"}.fa-meh-o:before{content:"ï"}.fa-gamepad:before{content:"ï"}.fa-keyboard-o:before{content:"ï"}.fa-flag-o:before{content:"ï"}.fa-flag-checkered:before{content:"ï"}.fa-terminal:before{content:"ï "}.fa-code:before{content:"ï¡"}.fa-mail-reply-all:before,.fa-reply-all:before{content:"ï¢"}.fa-star-half-empty:before,.fa-star-half-full:before,.fa-star-half-o:before{content:"ï£"}.fa-location-arrow:before{content:"ï¤"}.fa-crop:before{content:"ï¥"}.fa-code-fork:before{content:"ï¦"}.fa-unlink:before,.fa-chain-broken:before{content:"ï§"}.fa-question:before{content:"ï¨"}.fa-info:before{content:"ï©"}.fa-exclamation:before{content:"ïª"}.fa-superscript:before{content:"ï«"}.fa-subscript:before{content:"ï¬"}.fa-eraser:before{content:"ï­"}.fa-puzzle-piece:before{content:"ï®"}.fa-microphone:before{content:"ï°"}.fa-microphone-slash:before{content:"ï±"}.fa-shield:before{content:"ï²"}.fa-calendar-o:before{content:"ï³"}.fa-fire-extinguisher:before{content:"ï´"}.fa-rocket:before{content:"ïµ"}.fa-maxcdn:before{content:"ï¶"}.fa-chevron-circle-left:before{content:"ï·"}.fa-chevron-circle-right:before{content:"ï¸"}.fa-chevron-circle-up:before{content:"ï¹"}.fa-chevron-circle-down:before{content:"ïº"}.fa-html5:before{content:"ï»"}.fa-css3:before{content:"ï¼"}.fa-anchor:before{content:"ï½"}.fa-unlock-alt:before{content:"ï¾"}.fa-bullseye:before{content:"ï"}.fa-ellipsis-h:before{content:"ï"}.fa-ellipsis-v:before{content:"ï"}.fa-rss-square:before{content:"ï"}.fa-play-circle:before{content:"ï"}.fa-ticket:before{content:"ï"}.fa-minus-square:before{content:"ï"}.fa-minus-square-o:before{content:"ï"}.fa-level-up:before{content:"ï"}.fa-level-down:before{content:"ï"}.fa-check-square:before{content:"ï"}.fa-pencil-square:before{content:"ï"}.fa-external-link-square:before{content:"ï"}.fa-share-square:before{content:"ï"}.fa-compass:before{content:"ï"}.fa-toggle-down:before,.fa-caret-square-o-down:before{content:"ï"}.fa-toggle-up:before,.fa-caret-square-o-up:before{content:"ï"}.fa-toggle-right:before,.fa-caret-square-o-right:before{content:"ï"}.fa-euro:before,.fa-eur:before{content:"ï"}.fa-gbp:before{content:"ï"}.fa-dollar:before,.fa-usd:before{content:"ï"}.fa-rupee:before,.fa-inr:before{content:"ï"}.fa-cny:before,.fa-rmb:before,.fa-yen:before,.fa-jpy:before{content:"ï"}.fa-ruble:before,.fa-rouble:before,.fa-rub:before{content:"ï"}.fa-won:before,.fa-krw:before{content:"ï"}.fa-bitcoin:before,.fa-btc:before{content:"ï"}.fa-file:before{content:"ï"}.fa-file-text:before{content:"ï"}.fa-sort-alpha-asc:before{content:"ï"}.fa-sort-alpha-desc:before{content:"ï"}.fa-sort-amount-asc:before{content:"ï "}.fa-sort-amount-desc:before{content:"ï¡"}.fa-sort-numeric-asc:before{content:"ï¢"}.fa-sort-numeric-desc:before{content:"ï£"}.fa-thumbs-up:before{content:"ï¤"}.fa-thumbs-down:before{content:"ï¥"}.fa-youtube-square:before{content:"ï¦"}.fa-youtube:before{content:"ï§"}.fa-xing:before{content:"ï¨"}.fa-xing-square:before{content:"ï©"}.fa-youtube-play:before{content:"ïª"}.fa-dropbox:before{content:"ï«"}.fa-stack-overflow:before{content:"ï¬"}.fa-instagram:before{content:"ï­"}.fa-flickr:before{content:"ï®"}.fa-adn:before{content:"ï°"}.fa-bitbucket:before{content:"ï±"}.fa-bitbucket-square:before{content:"ï²"}.fa-tumblr:before{content:"ï³"}.fa-tumblr-square:before{content:"ï´"}.fa-long-arrow-down:before{content:"ïµ"}.fa-long-arrow-up:before{content:"ï¶"}.fa-long-arrow-left:before{content:"ï·"}.fa-long-arrow-right:before{content:"ï¸"}.fa-apple:before{content:"ï¹"}.fa-windows:before{content:"ïº"}.fa-android:before{content:"ï»"}.fa-linux:before{content:"ï¼"}.fa-dribbble:before{content:"ï½"}.fa-skype:before{content:"ï¾"}.fa-foursquare:before{content:"ï"}.fa-trello:before{content:"ï"}.fa-female:before{content:"ï"}.fa-male:before{content:"ï"}.fa-gittip:before,.fa-gratipay:before{content:"ï"}.fa-sun-o:before{content:"ï"}.fa-moon-o:before{content:"ï"}.fa-archive:before{content:"ï"}.fa-bug:before{content:"ï"}.fa-vk:before{content:"ï"}.fa-weibo:before{content:"ï"}.fa-renren:before{content:"ï"}.fa-pagelines:before{content:"ï"}.fa-stack-exchange:before{content:"ï"}.fa-arrow-circle-o-right:before{content:"ï"}.fa-arrow-circle-o-left:before{content:"ï"}.fa-toggle-left:before,.fa-caret-square-o-left:before{content:"ï"}.fa-dot-circle-o:before{content:"ï"}.fa-wheelchair:before{content:"ï"}.fa-vimeo-square:before{content:"ï"}.fa-turkish-lira:before,.fa-try:before{content:"ï"}.fa-plus-square-o:before{content:"ï"}.fa-space-shuttle:before{content:"ï"}.fa-slack:before{content:"ï"}.fa-envelope-square:before{content:"ï"}.fa-wordpress:before{content:"ï"}.fa-openid:before{content:"ï"}.fa-institution:before,.fa-bank:before,.fa-university:before{content:"ï"}.fa-mortar-board:before,.fa-graduation-cap:before{content:"ï"}.fa-yahoo:before{content:"ï"}.fa-google:before{content:"ï "}.fa-reddit:before{content:"ï¡"}.fa-reddit-square:before{content:"ï¢"}.fa-stumbleupon-circle:before{content:"ï£"}.fa-stumbleupon:before{content:"ï¤"}.fa-delicious:before{content:"ï¥"}.fa-digg:before{content:"ï¦"}.fa-pied-piper-pp:before{content:"ï§"}.fa-pied-piper-alt:before{content:"ï¨"}.fa-drupal:before{content:"ï©"}.fa-joomla:before{content:"ïª"}.fa-language:before{content:"ï«"}.fa-fax:before{content:"ï¬"}.fa-building:before{content:"ï­"}.fa-child:before{content:"ï®"}.fa-paw:before{content:"ï°"}.fa-spoon:before{content:"ï±"}.fa-cube:before{content:"ï²"}.fa-cubes:before{content:"ï³"}.fa-behance:before{content:"ï´"}.fa-behance-square:before{content:"ïµ"}.fa-steam:before{content:"ï¶"}.fa-steam-square:before{content:"ï·"}.fa-recycle:before{content:"ï¸"}.fa-automobile:before,.fa-car:before{content:"ï¹"}.fa-cab:before,.fa-taxi:before{content:"ïº"}.fa-tree:before{content:"ï»"}.fa-spotify:before{content:"ï¼"}.fa-deviantart:before{content:"ï½"}.fa-soundcloud:before{content:"ï¾"}.fa-database:before{content:"ï"}.fa-file-pdf-o:before{content:"ï"}.fa-file-word-o:before{content:"ï"}.fa-file-excel-o:before{content:"ï"}.fa-file-powerpoint-o:before{content:"ï"}.fa-file-photo-o:before,.fa-file-picture-o:before,.fa-file-image-o:before{content:"ï"}.fa-file-zip-o:before,.fa-file-archive-o:before{content:"ï"}.fa-file-sound-o:before,.fa-file-audio-o:before{content:"ï"}.fa-file-movie-o:before,.fa-file-video-o:before{content:"ï"}.fa-file-code-o:before{content:"ï"}.fa-vine:before{content:"ï"}.fa-codepen:before{content:"ï"}.fa-jsfiddle:before{content:"ï"}.fa-life-bouy:before,.fa-life-buoy:before,.fa-life-saver:before,.fa-support:before,.fa-life-ring:before{content:"ï"}.fa-circle-o-notch:before{content:"ï"}.fa-ra:before,.fa-resistance:before,.fa-rebel:before{content:"ï"}.fa-ge:before,.fa-empire:before{content:"ï"}.fa-git-square:before{content:"ï"}.fa-git:before{content:"ï"}.fa-y-combinator-square:before,.fa-yc-square:before,.fa-hacker-news:before{content:"ï"}.fa-tencent-weibo:before{content:"ï"}.fa-qq:before{content:"ï"}.fa-wechat:before,.fa-weixin:before{content:"ï"}.fa-send:before,.fa-paper-plane:before{content:"ï"}.fa-send-o:before,.fa-paper-plane-o:before{content:"ï"}.fa-history:before{content:"ï"}.fa-circle-thin:before{content:"ï"}.fa-header:before{content:"ï"}.fa-paragraph:before{content:"ï"}.fa-sliders:before{content:"ï"}.fa-share-alt:before{content:"ï "}.fa-share-alt-square:before{content:"ï¡"}.fa-bomb:before{content:"ï¢"}.fa-soccer-ball-o:before,.fa-futbol-o:before{content:"ï£"}.fa-tty:before{content:"ï¤"}.fa-binoculars:before{content:"ï¥"}.fa-plug:before{content:"ï¦"}.fa-slideshare:before{content:"ï§"}.fa-twitch:before{content:"ï¨"}.fa-yelp:before{content:"ï©"}.fa-newspaper-o:before{content:"ïª"}.fa-wifi:before{content:"ï«"}.fa-calculator:before{content:"ï¬"}.fa-paypal:before{content:"ï­"}.fa-google-wallet:before{content:"ï®"}.fa-cc-visa:before{content:"ï°"}.fa-cc-mastercard:before{content:"ï±"}.fa-cc-discover:before{content:"ï²"}.fa-cc-amex:before{content:"ï³"}.fa-cc-paypal:before{content:"ï´"}.fa-cc-stripe:before{content:"ïµ"}.fa-bell-slash:before{content:"ï¶"}.fa-bell-slash-o:before{content:"ï·"}.fa-trash:before{content:"ï¸"}.fa-copyright:before{content:"ï¹"}.fa-at:before{content:"ïº"}.fa-eyedropper:before{content:"ï»"}.fa-paint-brush:before{content:"ï¼"}.fa-birthday-cake:before{content:"ï½"}.fa-area-chart:before{content:"ï¾"}.fa-pie-chart:before{content:"ï"}.fa-line-chart:before{content:"ï"}.fa-lastfm:before{content:"ï"}.fa-lastfm-square:before{content:"ï"}.fa-toggle-off:before{content:"ï"}.fa-toggle-on:before{content:"ï"}.fa-bicycle:before{content:"ï"}.fa-bus:before{content:"ï"}.fa-ioxhost:before{content:"ï"}.fa-angellist:before{content:"ï"}.fa-cc:before{content:"ï"}.fa-shekel:before,.fa-sheqel:before,.fa-ils:before{content:"ï"}.fa-meanpath:before{content:"ï"}.fa-buysellads:before{content:"ï"}.fa-connectdevelop:before{content:"ï"}.fa-dashcube:before{content:"ï"}.fa-forumbee:before{content:"ï"}.fa-leanpub:before{content:"ï"}.fa-sellsy:before{content:"ï"}.fa-shirtsinbulk:before{content:"ï"}.fa-simplybuilt:before{content:"ï"}.fa-skyatlas:before{content:"ï"}.fa-cart-plus:before{content:"ï"}.fa-cart-arrow-down:before{content:"ï"}.fa-diamond:before{content:"ï"}.fa-ship:before{content:"ï"}.fa-user-secret:before{content:"ï"}.fa-motorcycle:before{content:"ï"}.fa-street-view:before{content:"ï"}.fa-heartbeat:before{content:"ï"}.fa-venus:before{content:"ï¡"}.fa-mars:before{content:"ï¢"}.fa-mercury:before{content:"ï£"}.fa-intersex:before,.fa-transgender:before{content:"ï¤"}.fa-transgender-alt:before{content:"ï¥"}.fa-venus-double:before{content:"ï¦"}.fa-mars-double:before{content:"ï§"}.fa-venus-mars:before{content:"ï¨"}.fa-mars-stroke:before{content:"ï©"}.fa-mars-stroke-v:before{content:"ïª"}.fa-mars-stroke-h:before{content:"ï«"}.fa-neuter:before{content:"ï¬"}.fa-genderless:before{content:"ï­"}.fa-facebook-official:before{content:"ï°"}.fa-pinterest-p:before{content:"ï±"}.fa-whatsapp:before{content:"ï²"}.fa-server:before{content:"ï³"}.fa-user-plus:before{content:"ï´"}.fa-user-times:before{content:"ïµ"}.fa-hotel:before,.fa-bed:before{content:"ï¶"}.fa-viacoin:before{content:"ï·"}.fa-train:before{content:"ï¸"}.fa-subway:before{content:"ï¹"}.fa-medium:before{content:"ïº"}.fa-yc:before,.fa-y-combinator:before{content:"ï»"}.fa-optin-monster:before{content:"ï¼"}.fa-opencart:before{content:"ï½"}.fa-expeditedssl:before{content:"ï¾"}.fa-battery-4:before,.fa-battery:before,.fa-battery-full:before{content:"ï"}.fa-battery-3:before,.fa-battery-three-quarters:before{content:"ï"}.fa-battery-2:before,.fa-battery-half:before{content:"ï"}.fa-battery-1:before,.fa-battery-quarter:before{content:"ï"}.fa-battery-0:before,.fa-battery-empty:before{content:"ï"}.fa-mouse-pointer:before{content:"ï"}.fa-i-cursor:before{content:"ï"}.fa-object-group:before{content:"ï"}.fa-object-ungroup:before{content:"ï"}.fa-sticky-note:before{content:"ï"}.fa-sticky-note-o:before{content:"ï"}.fa-cc-jcb:before{content:"ï"}.fa-cc-diners-club:before{content:"ï"}.fa-clone:before{content:"ï"}.fa-balance-scale:before{content:"ï"}.fa-hourglass-o:before{content:"ï"}.fa-hourglass-1:before,.fa-hourglass-start:before{content:"ï"}.fa-hourglass-2:before,.fa-hourglass-half:before{content:"ï"}.fa-hourglass-3:before,.fa-hourglass-end:before{content:"ï"}.fa-hourglass:before{content:"ï"}.fa-hand-grab-o:before,.fa-hand-rock-o:before{content:"ï"}.fa-hand-stop-o:before,.fa-hand-paper-o:before{content:"ï"}.fa-hand-scissors-o:before{content:"ï"}.fa-hand-lizard-o:before{content:"ï"}.fa-hand-spock-o:before{content:"ï"}.fa-hand-pointer-o:before{content:"ï"}.fa-hand-peace-o:before{content:"ï"}.fa-trademark:before{content:"ï"}.fa-registered:before{content:"ï"}.fa-creative-commons:before{content:"ï"}.fa-gg:before{content:"ï "}.fa-gg-circle:before{content:"ï¡"}.fa-tripadvisor:before{content:"ï¢"}.fa-odnoklassniki:before{content:"ï£"}.fa-odnoklassniki-square:before{content:"ï¤"}.fa-get-pocket:before{content:"ï¥"}.fa-wikipedia-w:before{content:"ï¦"}.fa-safari:before{content:"ï§"}.fa-chrome:before{content:"ï¨"}.fa-firefox:before{content:"ï©"}.fa-opera:before{content:"ïª"}.fa-internet-explorer:before{content:"ï«"}.fa-tv:before,.fa-television:before{content:"ï¬"}.fa-contao:before{content:"ï­"}.fa-500px:before{content:"ï®"}.fa-amazon:before{content:"ï°"}.fa-calendar-plus-o:before{content:"ï±"}.fa-calendar-minus-o:before{content:"ï²"}.fa-calendar-times-o:before{content:"ï³"}.fa-calendar-check-o:before{content:"ï´"}.fa-industry:before{content:"ïµ"}.fa-map-pin:before{content:"ï¶"}.fa-map-signs:before{content:"ï·"}.fa-map-o:before{content:"ï¸"}.fa-map:before{content:"ï¹"}.fa-commenting:before{content:"ïº"}.fa-commenting-o:before{content:"ï»"}.fa-houzz:before{content:"ï¼"}.fa-vimeo:before{content:"ï½"}.fa-black-tie:before{content:"ï¾"}.fa-fonticons:before{content:"ï"}.fa-reddit-alien:before{content:"ï"}.fa-edge:before{content:"ï"}.fa-credit-card-alt:before{content:"ï"}.fa-codiepie:before{content:"ï"}.fa-modx:before{content:"ï"}.fa-fort-awesome:before{content:"ï"}.fa-usb:before{content:"ï"}.fa-product-hunt:before{content:"ï"}.fa-mixcloud:before{content:"ï"}.fa-scribd:before{content:"ï"}.fa-pause-circle:before{content:"ï"}.fa-pause-circle-o:before{content:"ï"}.fa-stop-circle:before{content:"ï"}.fa-stop-circle-o:before{content:"ï"}.fa-shopping-bag:before{content:"ï"}.fa-shopping-basket:before{content:"ï"}.fa-hashtag:before{content:"ï"}.fa-bluetooth:before{content:"ï"}.fa-bluetooth-b:before{content:"ï"}.fa-percent:before{content:"ï"}.fa-gitlab:before{content:"ï"}.fa-wpbeginner:before{content:"ï"}.fa-wpforms:before{content:"ï"}.fa-envira:before{content:"ï"}.fa-universal-access:before{content:"ï"}.fa-wheelchair-alt:before{content:"ï"}.fa-question-circle-o:before{content:"ï"}.fa-blind:before{content:"ï"}.fa-audio-description:before{content:"ï"}.fa-volume-control-phone:before{content:"ï "}.fa-braille:before{content:"ï¡"}.fa-assistive-listening-systems:before{content:"ï¢"}.fa-asl-interpreting:before,.fa-american-sign-language-interpreting:before{content:"ï£"}.fa-deafness:before,.fa-hard-of-hearing:before,.fa-deaf:before{content:"ï¤"}.fa-glide:before{content:"ï¥"}.fa-glide-g:before{content:"ï¦"}.fa-signing:before,.fa-sign-language:before{content:"ï§"}.fa-low-vision:before{content:"ï¨"}.fa-viadeo:before{content:"ï©"}.fa-viadeo-square:before{content:"ïª"}.fa-snapchat:before{content:"ï«"}.fa-snapchat-ghost:before{content:"ï¬"}.fa-snapchat-square:before{content:"ï­"}.fa-pied-piper:before{content:"ï®"}.fa-first-order:before{content:"ï°"}.fa-yoast:before{content:"ï±"}.fa-themeisle:before{content:"ï²"}.fa-google-plus-circle:before,.fa-google-plus-official:before{content:"ï³"}.fa-fa:before,.fa-font-awesome:before{content:"ï´"}.fa-handshake-o:before{content:"ïµ"}.fa-envelope-open:before{content:"ï¶"}.fa-envelope-open-o:before{content:"ï·"}.fa-linode:before{content:"ï¸"}.fa-address-book:before{content:"ï¹"}.fa-address-book-o:before{content:"ïº"}.fa-vcard:before,.fa-address-card:before{content:"ï»"}.fa-vcard-o:before,.fa-address-card-o:before{content:"ï¼"}.fa-user-circle:before{content:"ï½"}.fa-user-circle-o:before{content:"ï¾"}.fa-user-o:before{content:"ï"}.fa-id-badge:before{content:"ï"}.fa-drivers-license:before,.fa-id-card:before{content:"ï"}.fa-drivers-license-o:before,.fa-id-card-o:before{content:"ï"}.fa-quora:before{content:"ï"}.fa-free-code-camp:before{content:"ï"}.fa-telegram:before{content:"ï"}.fa-thermometer-4:before,.fa-thermometer:before,.fa-thermometer-full:before{content:"ï"}.fa-thermometer-3:before,.fa-thermometer-three-quarters:before{content:"ï"}.fa-thermometer-2:before,.fa-thermometer-half:before{content:"ï"}.fa-thermometer-1:before,.fa-thermometer-quarter:before{content:"ï"}.fa-thermometer-0:before,.fa-thermometer-empty:before{content:"ï"}.fa-shower:before{content:"ï"}.fa-bathtub:before,.fa-s15:before,.fa-bath:before{content:"ï"}.fa-podcast:before{content:"ï"}.fa-window-maximize:before{content:"ï"}.fa-window-minimize:before{content:"ï"}.fa-window-restore:before{content:"ï"}.fa-times-rectangle:before,.fa-window-close:before{content:"ï"}.fa-times-rectangle-o:before,.fa-window-close-o:before{content:"ï"}.fa-bandcamp:before{content:"ï"}.fa-grav:before{content:"ï"}.fa-etsy:before{content:"ï"}.fa-imdb:before{content:"ï"}.fa-ravelry:before{content:"ï"}.fa-eercast:before{content:"ï"}.fa-microchip:before{content:"ï"}.fa-snowflake-o:before{content:"ï"}.fa-superpowers:before{content:"ï"}.fa-wpexplorer:before{content:"ï"}.fa-meetup:before{content:"ï "}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}</style>
        <style>@font-face{font-family:"Open Sans";font-style:normal;font-weight:300;src:local("Open Sans Light"),local("OpenSans-Light"),url(data:font/woff2;base64,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)format("woff2")}@font-face{font-family:"Open Sans";font-style:italic;font-weight:300;src:local("Open Sans Light Italic"),local("OpenSans-LightItalic"),url(data:font/woff2;base64,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)format("woff2")}@font-face{font-family:"Open Sans";font-style:normal;font-weight:400;src:local("Open Sans Regular"),local("OpenSans-Regular"),url(data:font/woff2;base64,d09GMgABAAAAAKjkABEAAAABbtQAAKiBAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGi4bEByBVgZgAIcICIEiCY80ERAKhNUYhIhfC44OAAE2AiQDnAoEIAWDWge6NQyCCVtcQHEGa7ddyiWPzttG41NTT9i7gN3K426lQ0E41YqO4LBxgBno3lT4////NySLMebda/cgimmmItZqtUGWC0EcI7qAlDwiOfoBUcGRArISxpiSpAixWMbVjWm+Lfe8bkimZM4yJVNqMXLcUS7vmGck6uM0dek+IbU2qb2jUqE1ZKxxQ6pnQix0PkyN1i7bc+PaQm6wz7y1P/OZyY30hPO44KejiBdVj5yxlaFAV+u0NmspEAmjuyzxriZuKL8RkX6pQ6DFOF7IPBVb+HCF2yd0GaVi14fFKwtSw4N1IzkJG6nx0qMO8sZVpiSxoIfISWFzW6LHC0+4Cos9kcg/Tl/cIsRKtBvhiQNqKGO4wkXv93fvhqHizx5NyZStNl99sT7BCtWt9wUFO5rSv722vAyMXQYlosVYJ17499vv+/+ZZCW1HyCrO54i0oioWHgGRYgfu0+Vz8O76d/3eDyJJZZQMgi1QBKWC3HEGGJRQMERozhmPRHdFQ3B9621fGutGcumWduYZRcn31JPaofZfL/fY8b2ELOsXdMMBVY0aAvD6ZtsplYdgG2KjehMtAkVDDAoq2htxAazEBUzMXJWzGTWNhPn5lIXzk9XLiLdpot6E3gUPP0/NSt/oYACfDkABWcabckGhxjXe3fTvQ6c5nCXcpRfnZwPUm0uGwXnXCY3d35kXZAoVqh399w7wwZIWcAJpzFFc/wx1t2fq+f9r9u/4VEHqqP5LqJjIxV1xqVi83en/yY30nMKTmQO2l7bpIN1OI0xWIkXzDdanJj7T9LHnrcEQxjsJpJ7GQDOrFdLt7sprR3z3NOaQ216o6n/UDRCnoOu9MdlUAiDkkiwGYBtin5ezPxm9LZvxgqjFgxRb8asWLjNjKmAjQWIWEiJxZQyCkWsQt3QtfObLgthGwjrfI2Ci7UD97mSRufMhOxKNEBS9k5+mJv3ucSIxsYAi0Uf9wbO+RR7W4uO8CmyqHhF+on+a4fngYeWGPyaBUAqbrCHAAJujHHMQgeep7VUL9P8BbzjuRAZ+5K2wqkYWXgexuWJI/8ReEMoDtWpLLf5n6oKplUqky5I+bg/Ir1SBF3oTuUOcCXlRmVqfaywt+HB7lvWLFtdbbaUTNFYEiwYut2vlySfVw7NsiygqgAUfAON7h6zs7uznuRzeffO8OWGP3wjBYmCUEF+YaZUoSKlqY7/OfufoajMnCMS76utH8BIdk03iVu6wPygeVU3r/YKmHJL+/l5tmn4EiRgDD8Ma3nosLd1eStdPK0Oh2i+mJoyQLiSlvJwrRkwvdcULCbOBWFz0SQIBlsWyx/iCkBgcm3om6U00TZPVK4/7qkyfa8zr/9L+tCz4G1Kt1NxKk47u6bXw6VeM/P1/nt6SOILkGxWYO9YFi5yywi5ybDlv/fEjpBxqCnd2bRGWpe+zI4Qy46QXGSxBbOtVbZ1NvXU6/nUyzWH2ynHXDPx+VTt/XaGAJ5BP8kpVStnOcSikeyi9endlIM7MwBmAFBEoJYEqQQ+aRXfEbmJm2yCkn0ovfU5lJzkmH5I1XcnySnu7s+56H7n3/6mqX/RFt9KU22BW0Dhn6/4zsqVY1OoYwl3qkoJxPltAifO+EnH0OXcwa5CYuuiM0/sJ+vbveYlWRqG0mXTpB+GsGayVAnSyeK735ktVRPKr4Y3tHPgLAmkQQvCMtd/EUiCvNMYETFeaDW/nX726LbbQadaMZMNxjJTASEUEDI7BDs4e/b4elxe3ZNsVsMdWbWKA10oqVA0SGkETQ6o/A/httjcGNr/iEUt6Aky8ZF0CYu6WyT1CNWamNmlEWbEEU48JUJW1u/E/96Z2ff+u/+IGKsqKiqqalxRcUUFcWX3b+bF/yQFXLh5UzgoFAqFQCCwsBA40T/+R8MAFuWpcrCptgyCVLgBFQa7W8HysOpZ9dEhoU0LR22AjHn3vE4tRN2hjfXggAe5fOc0Cebt5rVcggUXG8m4ULBAqGaK/n3WHVtVCon+HqlldZBL8WSCdqGDhhLmOWsfAIq1Kuw221QhQBFC0zQHc4RCTCWw2JgcG1wIeJUFKN0TFsyk+3LjyNSoh6xwGRem+yJLavzuzLAodz7ABnJvRVKpWNxYMaLSfptI8iWaZrEpkqTuI3/5JpL9AWBDAAu2YxowE3P8pcVdcO9Pm1f+miAOuRaROd1gh8VYZrWikGK98+fWc3gXGkmYSUZB0YatTAx+Cl9/dTN/31aLM0F5P8UQ3fX91arXpduQCZM2rRCnRJ537MKqik/s2s2U6a2olNDjzW8X+m+/KVIhj2TgkdyIXdwSlYTkpShN4lIuFVPmd0tOSD6WsnWWaeO2abt22e7bX9AldUt3Cd2lu6yrul33UnelbgXyv7+p6eGb8vlwrEkyKRzmfwA/YxvCo0ii2U+NKX+eOa8o/sPrTGgreK7QWrNwuG8hEeEYhRRedUKS43r7YCaoj5uPBrvYYL8rdvcNaCM5Fdk8Ljmex4+Mb0q4H5vzRFrOg3sRh+9hqMbTMeAn5gSML1aA+k9sxnxGF5nDARi/+ta8vJf7kiZwmOMzHrIGYeqC74+pc1NnfY9nA1Pf+q7PvnnpLxVmGx5o6lqYvZh6PpX/+Tl9dmpyuvfz/ZG5BD78KZMIvvnk/x5V5X8fROAj9NFDGyUUkUEaX3jCFb7gQxZN8OXc/7//9MGK9CNUEMMeEqAEoPtf95d3vH97bwb34OJeE4TOSRDYeLSP83h7mrzbafKdiIaDx8NZ5O5GgtHE436LJ93MeL/Nd93CRL9zCQCXgv3ZA21LOvNBtubD/e5uy7Zsz47szK5V4EX2JOP7/R0ZlbvUuax6X+RI9/D0EjCX9HRLjpleQ0R4/hZDwFYwfiSEnC4wtIR7ZX77fOgd87afqrzl5/V+mtwJx9DraWMUu+lkC3tYR5u9jD2IgTDwPdsyDV1TFVkSBZ5jGXA+HQ/7XblULORz2Uw6FYtGwiE7L9ar5bDou7ZOQs5o4LuObf24Q1SPB6BhYJPUyCo2XPUeu8k063Q4puGshKgI8+069/Y6lHNFXGnSvVztQyTP43vQcSZ7RTHdE/cOGZYJP8O0hTejtuA+7ugIv9q+3a7LfKBCqQaJJWBfQuTZeFP7epl+fKPg81a5NX8IZojg9U1Mh7E+tvlZwO0HkbQ8bZs7geBA+gmQudtUcxi9PEwqlXKf+X0IaqmjHaqHuDucVbhs1M2lz/Amwv5Py6uw6JT6yBzPVZMWNvNWaG+r+9cnK6Kxw6lyfPifG04zj/1xtcEezVb5WNyAPIULJIJDxkz+D2jwzjaCyTnFDozUAVWBE6s0njLjrPSv0kGZj25za62u0H3Mfun3vz6akgAjC7R6+UIOjeVrhMs6One18MzGcsRGJzZKKFRRXVUMadmHrG5J1fBp0oizl4CrCmfFbUrVZe7SisViPBNqbDc5oSJXgC9qBzJsM75zEk8yFA7nKFkln7yw3rLLvqhuuuAlE2oBUT09UuUcy0j/KfbRBt2+6HwLCTZb+d1n4dDhxCkFyGHX1cQfdkZCaf1mdrNxgm7zQF8kXTdsSrD/Td2EWpDRQUtPjK2ZBaejBlctXDPh+GJDXJWPtJse3Q/DET9DnJN2I82u6RY2hAxzM+ItgDErMR+Y82yXjDfSlEDsM/3UbThbQ7hGcvVMXAOXeu9LtixsOv/1ruYWUCrlHES5QFYqsAOaju28w07F7J3f0ASud35A2+YF56Pj9lZiUEX4z2aXJizDUIL9cEi45YHq2q7cbreq4pmYslGTk3sdM4mLKadmOjGR2ZdtvyLKiSZ2fg/WycynfjCXo2jHydVo9eIDoW2krNKWyhWD817tWo4oEadBHyhzrdeR2Bg7xktItkRjdXMWDJDleXZcFzmP2EJRL151WR7eAdm5o21Ylk+AXcBGty3J8rbQ0H5YNZqeRFslQNoC9JN3a3nho0Us9wuQ7AOc0F2+1ZDXBszwF3FWvSymrPBLfjS7k/pO0KbWN6dYg76HxvUl/yw/xN4fFXnUbSfZYCBIghZ9H7c0o+epf4TtsBDieWZXCKlaJi5smqxGhMEVgoThigC2GoOKe9XJbd41VMUeOHP3dgvB5Sm3jWBSGI5s6KxKybTXGE3tpttQXJMEqOFPe3TIwQf4IB+hAOUCOqgVPPcLQXgUrPoxgEtEGWOrK1TLw1AiqMrYZTA2T6U5H7dXKHC9f92rJP3nz5lmzfldJjc0N3H6PrnaG272bUHSIjkYiIDaAwGKPyUgOf2WV5tP4NMSt8pD82HFSVwM42R0zVdYVEeAU+LyCas4hjj5K+Gd1tWvdb/rw0E+NnnW/+kc+GMm/Hz/4xeAWKO3G/fP7Kdh4/8B2y8GLD8BsHg5OHYRkK9kXNdigR2PJ0CNNEohYvkL2CAtFumpOoGcWKKMJBUILDYMj0cwgpmGvL3vf2QiNSu+xacxCgTMtAU8id3WIFQM/CMTxgBsTcNRbH4IoqrY5nEAAZrJjNkw7IZjPAsonIR8RIewns1HmbE8GEMYMLMLtE+5GTGQHtljQOIhNCbFLjohwOQs/spsrZuy+PsJChmGMG2TJmA/XDBRXWYXJBRuAMkk8NtHAzon+UpjT1ATIm5QUDtLXjr81JS2zkM0pY1EfMYUxLTISOo4jOegwoTwgQvj+mL6iLEVQHgNupYxKurnddFvctZ5/pL2HGQDyAk32K+dn7eaNlHGva5zBxA3QMgSbXQ5sAFAMBfk/Qil4lcl7PJgZe2eOzB5GDVMxJv9Z4RH1a4Ks8FjKBEwGuD0VpJdoEZImMxiC3p2heuzM53gEOmmOlTncrztFTua2emYyG7Hhk70BaCH0JV5UB8COcw3pgdkCzAfNpCzKCJOP58sb5agDnbH6gqd5D2Wo9oTHHZ3GcXArBYYRxoBhMkYo8BQ6AmHiMQtqscFztLyibvLCuZwPX61iEuP0mZzuT4c86pJC7z6IT0GWzoKglOrZGXN8DLZUXTwQ7r2NlaIJB6QEZxYEqM+tflhaZLENFFPK/ufosFYgoVlppzuutV7gpRdAkASJ1n9wALSBtRpKgN5Z4xpCWeOCdyc7RhgbNrYkKDiaMWbtloBHRs6tiPh60ia5PIKDC5chovfl79vKcX/AIgdc+tAL3Vq7WN8rqP/9vs0F7jDODo/wnlJlVmrTz5JluDm6P22tRbGXMriXQhl2GN/hH0GfCwBEpp6n3K+5Au+5ive96m2Zrcx5jlz5WUxJiWri7nG893NeXMs877Uem+MFzEyTV7cRkpucgG4juTNkgRZJ/a99pByTicBJAQolazQaT8+mPQ0qB4luahzuVcB6bREtp0GCFMcEVaSR63QMUaGKjQLPgvEalVmogcXnwsZ2iUI3sXwY1HCGi28WZnIzK6OuDpqdytPSeRUtHDdzOZiu+z5sOCv22lcxxZjaJqt/83U+XC4TFGZzf7Bvou51PU3NyHVdjz9Z6OFQ7cRV0Z6G+Hqsun3omQ9XuuLBmWRrVDbvHGPEnlLnKCGOCJigN2/1VRTWjscw6RTw3B2WErtizcRX54w0ZC7HRouMmAzgmxHm03wa6eqvJGq+vW0H6Hgb+GhIf9VhCyy2yjcYGVPBJVHdmSeQUpKHIBmhMl/moEP7d7ixn6jwaCm1D2mZ0WjXovC63d/pa2DAeSIAk6i6sGdhtbSbqxGJUiqwTHI5a2LGTB8xiVUBuhzDHm07YNdyEfqhtWbPhGSV9eF0w53SY4CaSbMHKVYJcn0cAKNbJ4PGRucBfT6MygY1aLEKHbDHhRj+UvY2ynTQ9hKQ0BJVdvh7tDIjlI7uZJQndvtt3sknO31a576eqIPMuhO/TYL66RTUb8lcRzoVpuV1rdicuLsfQczdTwtlZ577Kq3Xytp8UETdCwAOcuHtuNrAtT5StFOGYgByIl+AlsJuR2HhJ3A5d7sHB6Ne42zArp0zdiujfkKVwZ8CHKqiJlDic7uHqDmRFAq9Ex4+6P2QU02Eg5QzbcUpj1SpEqcc0vvesu7TWSaNB93+8XT2yOH7HTb3tylvfXX9SKlikP4P4giSOwwSLT5YbrMF1HYBVlpFKY9g5MbMXbHFE4p54xXhVB+68w9S9rH/Xh+l/Z2aLTHuyPeGavt1CE3T6xE2rGTBxdVwq5mWrKmO0MtCnWmBslp+WVZBwOhWr0QuZIvCKKlHS9ihMkDdg9wfY5IJjnWZG6sPzVi6wcYErYKygsW4pCTszNHOe/eZ5i/KqqWhbBYFiqp4B7GUWRzRlqiiV1cJbsG0K4U1Mu8+suMP1GiGtQkjHE/suMN0ALmG7Ee7ILCSBIFjkfw0/fu3nvHVdElTqlVz7PAhRJwU2Sd2Pov1+RxfzLLSCAzlH+XI44tnW1NP98+wuh3Ysibu7RnLBJuFFQPF0SL95x7HOpabLbkeDDU69eUaYm5OkaHTFYpweuze59URKcYD39grzwP+OflQuzUhdDqKmbOhoxPnjQGaLGjF6OQR0iVXv+8+Sd8GIwClc+EccygQTmFFMeMDeYWRc8m65xPfe/kz7kBp93T37WadIWM6pFp45MG/aufwu892uOtIe/s0vYmyWvlc0EJz/8DtkUcRDHxm/5GsXwR1DWOiSJaoL4M+SihCgoVRLMej+zjOJdQU/VMaoCR6vGoTF+PtMd3Hb8JfhyvatB0VQpcDKQcwxX6ThHOqlc4hIdxTfaoKA2K/h4nACVceETI9gQHExHFoR2ZvGIqEqqjXTE4G9fCpTigUOdlTYVqds7CDbLGJHRRBbh+DavCc5T4LugDKl6uvaL81CfT1XASoeMbPTXZUQw//h08fwcf2fXHZEcQfStlfhwX5rZysTgpCQ2JJidxfGRkeWnWejHkbHDfYBhubpntDelWccju4DjZzl0rwCxTnyxq6paP7NcbS9iVUghQduBnb2NcF7DRWaPFSiKxhyuCl746+tdv8juMGcry9TScRq6D8lgBET6ptPln6vty5HNQkIMtimngD1KliNlUngtdsTIufGv8DPz7ZDMabsdbqx/1GLqovWxGFKpgPf918SxSgsakbRdZLyN2c+1Swdx2CdktmsVbFouDpDa/K/aB0IgZAnkoSgKRxcV9ngqPZ/MpkzqfYfPfZvFBlhYnTur6J+KkXYN/AJmpJLfYKTLkmawSo5QdIHQEab/mKAKepeLB5FETCZaD4Vo1Og6wu9V8NYrrQVCtPjG9ZYOWgm8fYABcrB13e6DQ27jJ3Y8FGxFlPuE76mpCkvB4cB+AIhVtMGa9fSzno6T2DuQfBRkYqJWXlNSiYCDnHX+wR5hhByi8S8iIj8dACdFSGuh24JXIJ7JNFDfZ2QhXLR8kDo1D7pBaVl6WPnRUl+S1N/kMBpK/fBxvFgvf9Uw6tRqCP4Qgl3d1vPqTXzDhQK+N5eHr+SuwqxDg3X0OuQrPz89nAI55XhYQeHgmEq8Y1947QpEWTFN7/HMCyvhuQTPikG7H8qfof5d/HO7ek//h4xi+DoaWA/C/mTBmBX+Fj9LwZTAZJ3lOAKW0PGLUst3ex/E3ZAj0XyvqFYilFoMp/G9WtFSa/ky3+TO9x1Txv9NS5B1CSy+GRYDTYDrIVbA1kHZ75v5kKKg66X/QKP0r3Zu/Ll9NG8/wSd+IgJoAzWUoHZH2eELgVlKHttcC+VDiNO9Svk2VEqYN5gEoZNBBKbHQT+8yjvYwALlodyeAfAaoHI8LAUJCBiUt88qoIaKyt7oCsjtk3oStn3mTG1PwXcG5VGYd4Sq0UacAjdyybm30DO8Oo/PHaaJa1YgvqVgc5zJD7wXYDUcbEXRT6d7sIDBAO6UQXLLhCnj4vnuRJi6uMtKPYc3w8bVkTd7m1XPc1heLoyTg9THQdSa24JQYlV1AEhn6UN55uCrmzihVR4K6f5v4++HbS8yj09KybjNpHxmhnZ5/bEXAo4riELqTJEJOegJvroXZd3qto/v3l9MVj09V8gG8cPbqtkPZpoSngASQa8L7nnKRoA9Hwpe5zPdraHjMmW/sAsgpEqFG9RkMPMP1uqCRDj9lVOgLpgBwRAoh0To+UONvyQZVcdMk+EDUhHzLxsImK4zP6ms2s9MSPxZXEra8aN9e2yHCEmBvuUGAKFgvjSU2zhcoDtpcHnG6rOEkY63YIelb8YZN+Lc4WyyhjjBfteiWL70ZytrMRlxWYF8keuWKqIVuWEQSrERsok7TRYLY0p7i5llqfGgfta0iBflDtUhzdfjPMmJB1vv2k8R3uDHEjNRtt5+f6bs8FPo+g2RDCEQIokNlSvwOjI448Qr1k2dkdyxy+eR/4mesPFX+M+NrfNXtbr/LVbrmkHuFzkUgy8UOekaLMtQEJ9SdU3TKflffosyhLqP1FrckwdriOEB355x9ZzUvVgpPV+WJDtlLu+h0yWVqN/g7scuSj+SfNN9LCUrQCmttP484NYmzhV4F82OXLfg+EWqxow+Z4tYMpSLVGSLk5u/rJmmjX9eMmfbVFk/VJ9RZjHdolEb9hd4ZuW4E5hutC6577hDhrbQEc7yhCac/awd+hLzy+Kmxdz+Qevrgqlm+pc3ryRw70z7Pz8hu+w4o8Rtwd5NKbYSdUaOzvueQ25yfPfCcz7p6pOXfFT0UFMfcf1+L3DhOIRJ1d3rsBNRUh3o934JfOFGq++c31Gh1tfl4s/Ns1bwR79mtYsu3uWXclqfJC+yg3TxfpjCQojQW2bUY245ttqom85KwWUK2f7uxwPArPG745J+LVXiXKxYe7x2im9zKV4hGj264WPZ2xnpusb2mQj8DtSf9ej3OyOOU4Wu2lB205IZjXRQh9IK/AHiWV5rkbztdWd+y/mvbSFVVWnus3Bp3WIakvm+3yFbb3ZdtW83qqINrNk9MiRMHj/SuGv/aQcuE2zfUprpRu4Cv9Uax+CC29PDINrNrn7J4p9mpLKpas12x2SrniJdC25yQC7LLUQBwUahyuedCfqVU/HwME6lg1ji6lxVf4YXj2tVrvj/wcWQ9I1nFtT73Ni5vwPoyJZVhcoFiyZ4ZDRjXI8IvO5+S3JfffIj0Len0RWP7A1BuYDcpoMhVjbtBkxpauOuE7MF4nvtcwWgXmpddP0GZ493AFZMm560MZBUyh98mDiT+/a5f1NC+P0A0qK+Hjaq3T8j3xVhmJw3MiHce1uey1cLjs/DcEuY6AGfmn++HvOQ1+Q6UQOlx3rEKKZMP/iyLFaStl1sb/oTXr6API3K36OLqaQq5lZwa/DirMa2cbeAGGDzA63Ba/3ENCxjY/10Fu5ZM9a0gMTdSdCyRus/Gn6GmsYEnce2NBvB3KSxJSVN/r/4kHe3v8mwZJccuKGRpABZVfwrlhPqUXOXAx1jpBcBNO51jC8D8y7JmFMldMt8JlyjJkOXK+nxs/4En5WH61cJhqGO2n4RGg+pv96LBiHelYrqza4DXKqzsXYvj7xn74NNgaCszH/Q/kW/D/Qk/h29ima3pNMTg7X8XIFQ4Yodg/f0/est3N7IizjwT/0HmvAe/NtGgzJ/ifTT0yY/+MjD8rfXjgv7A9gYjhT4W0aIHKi6sXPsPDVYCRE33Nk/hX4IG89cUo3WMN7jc1kAgqC3C1J79WqRVj9VGDUuK5jMZ2ezq9LmjqSj2Ki0Ugs6qHrTcwztDaz8Zzr1DXZJwTzd6GwlARbHoOdsCbQjT/jslS/MsfEBDkkisZDEmnyDqtuW7mCFdiwM3qLTvU5IEPdfX1Dlre2aZYX2mFdn4xC3+5k4QlPWZshcYYFqfHcXNVxTGAqQQ96j8XOpPtkg8cZ8Yv+jkSVdqbX0iwCi+/uArAKoMW0772Z9wgeseaydMZRaUYNZSg9KHL0C1U50pHO+BnzVoMtaAQVfzgppccvemTfijoJ86lxKS00/nItSccIdkqAXySf8UstFWz/lWLdjflQ//6ZEV9GHfw6TP/68aR2GtX8d6U3iGdEujvOop247H46TiDZqbYdTYjkcZvCUdSm9IyWsqm9Xb7/GFstSIX0cOubTjRctzHdmkqWSw31029Uh6uv5Qt1406i4Y1f/gY3XfEqKk40uSkD4ORgtsWj/5MvUtJ1CECFTmCBbZ7jZm7a0G76Oq/Pu47+EH0w0vDO5j8Rlni8M9Fc2CEEiFKNUguOUSxU80Mvq4JWr+Rvy/g7cOZLBQ6ux61QEW1SrPd1Csv/TnHV6J5wdh0sOiO3R7YUaK7gRW8hDADjU6LzJBXYoj6B0tK62kv4fU47PgUXuwwCHqv/ruyVF7cSV5Jdw8iodLg2ISzC/B9j6Ss69Xn+rbaeiNtvzbrvjFS3/riYgb4+2BUkuhzacnfHvqgbULpz/ns84fUBntVH2q0OwzN29/fGRDjy2dBhDcsgcgnBB7rzm+6T+rZpx+MqokNq+5VAqKC8+//fSr6L6oxozDgTxMFdb2AXsE//AVco209rM4i8tOCTvmQf8mAUMRlTUwY88yz0k4KybwdXw/imTNCIH396lwFgX9ivMO2dFRT7s1niFEKmqFlyP0vGwm7K2Z9fPl4z2UfejdvD/V/SG97Q6yGR/IUWP9wM/A4fkfQvLl+1+GMKi5av6wKZ+cwvbEvckcqKWPOW4MrfvPX3pYqXok6+CY/ErfBURjWM/vWsJMzi/erQoPFVF6Q50L0GJyN4uErOR8k55+KNRczx6ytfME8131QmuY4+u8QolNPEIzqYuzwdhoEJfhKd4GIq0KT/4SWjzwsQXH+eHoUy32EVEhodvCDuZBI77SDwzt8fpeeC/afdMRaMO0PC6wIsoyvG+w/fGMOnFzaUWJ9AiwetVedDW5ztkiz78jGo1pz4Le1Vild0HYsXrrlWFbNpQ6XnB9XK6V1yBeHIhthiFfybrComF0Le96NmGXtmEnRG1fj29BfdEjLt/umPvzoxbdAVXlwYLT7Joo8e3rrKkGN5QGACdY2KjCET4jKnu9op/xQTWKURcuHeKei0FjDLMxjHysp9lukBfECiDJnHl93no5wv1FbKLn8HiwW8Qx4LENNw/EvyzJG/gq07tUALQKE6D215U7OXy3VBz9F7A5/H42gG6NUAJIYrSdi2TLiu2FGHAaWhwusS48WzHcINMwfkMJAiICK74norC8erTUA8BTgQIF8JrdaQZB9QOhHwkaiIYecNC5fN2vlQ+2CJVdalGLtjV7RYIMiLmK+4QdTnjxcmKSwB4/EUgR9vv3Kpls52+TBOt+UE9uHUs6DY9r4DadKWUY7Osz8e3euvF1UHPzCcYRT7LbGTwUtgJWZAsf8Nnaoqa4xbqUq2XsYQgEfhc916vmBt6sjHUr0bGfrFMtIuggQE5UGwUDjcvPPsQP3k/PbwIGhbKpJjl63eAluTbgrD6k/aWPtGo8O4KcwlyaslwFNCW7GQVP6VkwXv505/7nUve4Tucu7kyrUi/OLEJAPGyvM+2FFMltGbg5v/QwlaURV/n7T+P4KqShXD01v5iJXv5dDWr3ZyjUQG//CGqzoreufsFQJZNCL5czdT2X9cmdFfFWo1V4lqVNHd3QHM4iWjXhDHhxD/3ROAppjbejIs8xgmdF8hQ83yXa7NGRuV/5WepybQoOgYifM6xiyNfTPIOajPzyJKTH65Q9kBp3YgZ6/u0Xzy5OTraKwYUIJ3lPj+OlOap+NMBwOfeOccgFJKgD362UZoySJBO7/nhuX8ca3rxYyHpWdKIiq45pMP9sU1SbmoVXd1JwdyL/3QgewflZUpWHgvKc/pnx5H/nu7BaEeYxwxjfxCxXkVTwHPFado408hFIkLiBtv/ZXpitXOo9KFOXV3tzo6idjhBavKN+TKL0LjtB9cFGB9WN0q+O+r7EHlTb4FcIR9hvc1PU+XhXSIYzvfL8ZZxvM/WLurbChctmA7fcSkTsWWB+ckWbhxey1bIPsYJGerqAgPCQVRG6ANhqoOLicl+mKVH2J4gR9LbkVNyrc2wcKEQnR6o1geSAVt4TGsgnGMqjkYsPCbNnljsztUrxzEM1LroZ41C1yyHJUhiJqVKMZszXOT2WOV/1iwBYjJ31NXNmmnU7nRmDzfbQlV+X7iYs61yE9vkgbpv6Hf3PDj8FK5ghEuSEpX2MI5NkfFmbRTdors+0N9QlbyKaHhhYjK68fUwHL+UexOIYlkfKx7Bj5RGiky4TzFFfn1Gmy8F18jPUy5pSzMHu05rnyKqGA/Vw5JTLuK+vl+BQh0vhWi1fl9FLlKd8h3LUwU6Yctz/srpw3KKwOhyjr2g8b71CK/APKHGNLmJ6xIb7B3HCpBeiPg909xFvkliB6BjnzJ5q8M+yWu79SN9Quwi9BOuOVWJ3K4tQG89fwAZ2VGURBaqR4yRIdesJ3RdHe5MSvrI6br1edWvgQIEZGOmey1WdrRWjlfMfd1rXEYPNSDJ68qgERqrnXBWxGTFQPfN21xTt40crsgu9cPS4KhhV23BTY7EA+p0yFXIk4UDCkZDPlByo9mLVTVQtxvC6GrYWSymhYBAYaolRyIcXauERQEJaoWacE1aWpci8jXqFkutMINmRrW2cyCRnZ4o1nuigbrIo1FERCsL/zFYmXhNkHCZ9fr9XlF704fbHj99KsZ85ju26o4IaA1vbNoRgtFbLcGNYvkwqg2x/fconrQxVj0CeacrN7+691WnZxMxsqM5mDdtGeQZw14mHC/srtJIGme0tWxBwB+3wPLS0r7fiGPCIysQ8cln7kQzvtI4/eiDU9CYmJN8INNxcgezg1hXF788tCp/AJ1OYqUHUt67526/GL4GHvO+4NnlfqDoZ9aCHv5X6okJsHmgWNnARbqV7vXAP+PzCUy2hf99LPQcpxlu4yJmz7Y1m2WED2n4WFlO30A4IYbqqDY97xHOSnuak1OSuHvXuC0LGWjZl6uPkk4O5Z1/FbzwT833LLcfSyFVV7VX+7S6BpdQ4r9n90WQI8gXkWPflQv0YLAxRuTG9z8Jfr5xFQmZ9249lCP/efvD/j/9WfmDrapyzF7gH3g6K8oJzBJX1te0l6RG9HWPgGsfKHoWRuMKG7Gh2ZvmAfaNtVg07pjnLg8ikBnfxSMpNXhqxO7uGIJyshc+if/rZp3tLz35LXWnfQaUg3plV9DLwlRX46oAul4BiagJjdn+kc0cXHucn5/NN9IkwE/yRn2IfysaOokts/mKnKIhU7kftJk8yMBxdSSojuGYYbqHTnTxOxFVjPlOhIrN9xbA27AUq8P0WmbSOCCY/nZrhE1vGyfdqR4RjbKpWwjZHVgc6HPQ5bpGFKdF+TmlhOrOGV4s/uqyTyu6U+7xryovxz4wDeQMN/NsiYjvG53rmXv0+Te5QJ6uob6vSKgPSblL7q2UU9s/uOjAPeT8xtaeZXXviVXjKYzepuTFKfLu9ZAdw07NP6OQ0xP63uiUH2idOU/Yr23//SvjiFej9K1Q95EqT7t5KT+zEmpaXboFKmGH61Jq5ZLuwUVfs0Ep+JQmhCnK3Qq4B7338DRohqy/0J1TlH0k+/T1VDzs7B0PC6DnHXfCL+M+qTmowWauf3avnaztBj0jB/ISnJA+HpdsvOjxoLWPO+n5lb+JgRWntAAlPe6XlzgdCoTpa35u3TExRhj/Maqs166zkB9eFalbaZEyOHkAqoZ2hOMLZf58vZOh9QuLc02qjn9O9AxZe/c/zsm8/58GQQdtrGsKx6l3NOmdpFowdwOSM8EywBCZvinIm8TIlocEtVGWPqNjsNKseABo/ObJ0bP+iIqer2NpvG+t1azzHdNS6czfalT2a3jAJBeC+7hutjfSggGtXCIQQhP8S62qVOgGEUeRwzB3AWezHDaD8rQVb1AF42nTtPFBzHwJKO2DKeiq4FtZiRwqtjY8JqybbRjTRr4Yc/4P7/PU7FmXwDfPl6x+cIbVC9qHpoSbVkdONez5i93n3E15VS9VQGW/4LOupQO1xxrx9QMJ3bZcIUhchPSwc84+0FinA5S0d/Zj6Zl7oNUzLmz5ieUUVJefEA4idTuUZFf6OeB1xNAh5HR0zOZV7190uvJHRgt+gd11oIf+6cHWb7kJoXXCc4tffjXO3DK/wrsa8YFCPn62bBAi21Qnp3NJzaxfSvptAgEA47M/hSTaDOzHO4nKYTH2nc3SG1p5wXOucsE9JbM56WKdbb8h6UJPtDTiplHFd0Q5/Tkyl3KxP8dllkqqfcEE6g292QqVbU0g4rBCVu6CILzXrgZ9VKiNsyEVVLuh1nIHlV+T3Pf+xtjwYR0whLq7d17W7W7nN1Cgvtpw2g2bwj2k5fqg0qeh6231q2M9ODTSHtA6gf603aAMkHuloyYwJdcyFAh0JoTJu0cFS5vwvKbiJvpZeTxTkeg/q7mvnl6rmQ7YD5Tg5LOIOxw4/eypbZQN2OW1hQcEH3gtkxA7T80aOEhuclOSXJcilnLy8mmkPXJE3+jQ2dG2wc/T1O17vDBkdPiZ5TvJwckZwcggN9Tx489BAWm4HdTOpx9OWIatbnw2gwYK8YqloYMbIBoJSO763h56ioGt3ljdqly9HKn8UR8gqA9F7Xv0653GlMaXaOM/JS638ZniFRWuKlb71YKtYuuAF/1BfRv4TeuNRcss+SU8x95MCgMH8iKzJLuaC7n7PFAWJebK4gl6/mK38Vd1ASlrc8v7mG+mHCR/ETx/lknqpDm0ByD649OqLe9gOqU77/jqCpdGzCypcAZfjOGFp3RYRwNNFVYRByaFBBbU0NWsSmJ5wSYWG5tKG7o2MmhITLP1MXFDBZ2nDtRV03ZPqt143ISOKWzI09lt5mds5BpGNfHUTDyYv3Bqf8r6sDN0DBLWz6q9OZ8YHpZC7LtzOSpIYscsozeR9ff/9W2ZhIWfgXFFaeVknbmDDOrMvTcEtrxQQxnMhmLc+Pbw0e8ZbQBfMG1nzUIbtVlYdhqgsPdS7MBL/sjLJk+4b8EewQ5ahhYB+GjMx0wGREVnnBla2E3n5IgVJPaMAg0etLaXSLfwpY6lGegM85bfKsnpbe1kRgpFdnd3XzF63JdD5mu1AU6/JoEQRz2Ugxm85KvvY0eGVWXDSs6hNrA2v2jjvpcC081xzLzQF6yJl9xl/bH0KzxA5JCuD+vhSGkvASlw7+KCtjbS9ukzabG9rXzfqVO6L9GXC/FcJABP4qu1Ax6AJL87d18el5HZQcs+ekWpZQpeQkySh8ubnM/PN27bOWYLO3iPXkC96eeQu/7paRG1mIm4cHJfY98lk40kqWVqtvRxggmA7QpyyL11ARpHZLr2q3SQ5QuUKv8VJQK9RugS0S5zKQFli0d3P2he20y73eBosmPiW1bn7OXGCB+27rEp8HZLcqu5ghntJV22qRi9VZWW7OBtfjrrQQDhLhTWdV+QZM2SziqfjFVAOXvX9rn1kypuQ3w6lDpVRIQkE8BqdWy49bmDdTl+jtl96Qxb8eBenhpbnzzZritPn3sFdnkmRgKM89w1j2swvXXWzi2Un8FeABochoZu5o/J99MMJfZwjUq7AccwC+CKvbzXxwpQyD4jXbT/5gCq/SzdewhSonoCPwEaOZ6o2Y1Zwx82Pr+gAEPS5Twn/bcsHA8/6fH6RT4PwHl9hHsPAnFwUKpPIU/RTdr2IFK00ZJQ/tvRVnt4zahD6rkwsj8UVqT8htDWBMY4vDMxpKBXKYIXjem910Euei5wx4D80kHyozzfWeAkuA4x4g6q0Ax8RDcaeitQdXelEm0VkBpeKNOQVBsabdf9HGRKq54hksGKN0lOyucrGjIvnsol+nVHJzWSuViDSWStC08yi2DGwIyalkV4Ip8FcYUFqiLtTsWIEnTFZBG5+rp0tFX+lO9Cs8RRHtN3MTrz5fomLlQszmqMK3//U2U/z8VDRBrgkpq7CLGV6aGVrDTdDLCuzcECNrQ+TPewqup2a8gvy6w0ExYIHEXZ8F7RWj0TDf6c/PjqfM2VFezQHYVxLd0isqgtiVVVE08uKY+jVFcGsyhoHbla5S2xZVQCruiKSWlwVRa+qCGBV8B0SS/K5fQcSef0Dt9MPDN3h9Y1o0R6mb3Spi4lKFttP2hfby47K2hXbTdoVA4TzonP+k3a8BjZ8bZBuQADnjfz9qj0QLgZMjl/uJmIyGKcdrk8oi9Cv0nTnZdg42eUxuy2WSe0d8cGMehfDLu/99fuote0cuzYPxBlj96p6R5rpzyTrdFQDvjLIOa0lwqM8XmAnWu2VytyfetSKpOQbRVL2SyN4IPVTCLhwfaRTAXasQXLIIx/U8oZeVtUhDCl7qNy7wLjga7QW9ezi29tXH346VZJka52ZhLNooV/kBgWtz0wHcXlBM5NjfkFbS4tBC+N+Mec6O/81np7uOn7osNHM4c7jhodnsB9npeqQdNSYrPD6ME5kbGx3/KgET8ygsi0iDocKS7OsLIPF5K51D0Rw1/tMI8RSxWKtLBn6fh1ZZHgIPDSL6tdRqx7QwSNDQ6ChPGpAhxGxVU2+phJUq3XtZ7J3uI+Tm59TSOIs39U3zx3yoZa0EFoc2ZYvIejJu6hoO/D4Q5xiwbLFsopSu61lff35+f19BZ6MxhYP33eI+3fKfHhpDO90rvstzeX6MNPTdOpd2PHvnvt6McLhbhZkL7IjIQJJxjoHlHG6KpB5Cd6BHfvhnXimrgHhlbdbLEn1iOlwCaOchLprmb+flH+9tWovKT47LtKTbO9FIhFTUenkoPcl50Kr+5Kt1du+/OUcgTldUjrpdOjEh1RlvwLJf1MDg2t2BHq1xn4QR/CizocFkmYOOgkAJgjMqSLi6QB6ZhtAz2Tgr/puznz7LX7n72sTw85rF63JVjZOZKKOfoRXm4dHdCV04C8mci1dvA0s0J6EZIWAWY5F+rw+QgUpbLpeSWJJBPmxq0KJYXD081T8JL0OSWK1tBH76lH4fqGhvODc+ARWbl4+KzMhjpWJtCmTDejgUaGh0BAeOeD7KdEThJ60lLTHFD7PtTWcmZNg56rubhVdzs3zbkdGmNlUrV2bGuazKGDdeMfAQEZodIBTRghsHsXPtbUnE52cqZZ4iqMzEAgEguIVAB+vCj+90nNyTMirv3zrWB1Ek+x6ZmW4P9mzeqmvdpx0ZQ2mDlNPc8vPWmA5Wb8Sz+/I/3YyMgDI0NdmretaZFhESJisFRHKCo2OzJYIi4oOj9QwOcvfteZ16rM9k7pnJ2+YjHvaVWxQeFW2V0LrKd79OIWUbpTYQjpj5ut3rH0LSjK62+j6kVj6+Nc/uD5FANJaFZ6ZHsCYjmbxURnw11DaxISpjj/lleNrh+Azc+ft277wG+8EUCyJOvAJqpUHri40pi9m8Azl/mAcuedlw2n6LbqjT2IKpYgRlufrSE6gElytHIPMvfm+xeBHCwQa7QF7Z+ERlkNHeFCI6dD3ub9SSxLk0oy87OZhD3yRi+F5QljZqLdhKCFgMoxzek/8YdKQVK0Nq0+Xqd/mh2yDx+gUvHbNXostGmGSO+uuJQYGthwkYcL7JZelRpJtr+HSasfE+6X6ig9GdAnKDnqqLl5D3OT7Q1XJpy//lrj/NDw1w2r7v2HpHnrS63sB9iEYMq+XHuP6Ae6YuJlc34gvI6q0zpOxbvEHD9Nbu5unoV/jsoyrrx1DuKnZTVsQBmysj+AJm7vPZLxeoNpzi8zkpXmElJXUA0yDPavnrhszi+cWXlHUScD8nCLEXCmEEtJHxtbrVvFmUVfywbi0kfFtR9YHUaV8wT5wwjPx1puTErI7xjcfpjXLYqXcHTcEgAEIrp0VCaJpjncyhC4aGQwexjO3qpdsWogHK5IyGS8kkI9L5em8USaBic3DPtAc24wAorVl205+nfwhqmouNkyb2lSqpusNVxlZb4Tf+OIGNv/LoKuRta5GuIfN6TtGYI/ljHE89TivFbwfEAi8PLKoAoG4XepW42N2+HrMlyoufw48pyWQ4ZoBgVJS63/ibYhpU9HQyWNGh4g5Sdc4hRhrlajw6hBa6pXSMYJnCo3Cnc+CCyxH6rJrKQ1z5bpmJiTkphLEN4DyUgNI1+vyMwfc1/bYugmg8dXRWZAZ4713DH/epn46TY8rBsIz5gM4G1ML7mLqyKB5+T2NwwWgUmbTwqsT41mVTrFBqnKdHrcM6ww0PWzX+r8BMAZGANx3rj880x/CDAoHIwveWt+9kgx/JIEBSkug35XPJVunWaeeyilaPwA+TdgSrXYNHdT1128L0O+EeXyxvt65TWxDrS0LMGvthBr+5YTbOZUjEv3wgfI2r6msgSqb7bha1+JbiwaL4clW8wZHVZ7ffPHfBHmUFftfQ2kZwBBbHGBSarL7wB01gXpSOSiBf+I/1r6C6PAoBKrCH+ISEZiXB6G9u/K+jqJoH+Yek3Z5x1FgWbLa0kv3ykaFgZ1iYHaRXvEF7ZqlqutHG7suW1R2FEZb6pDvdHVXho01d2mTb8WeqY7JTYuKLuCJzF/q7Yafbn5kXMTv6RCrqBSPaUvYkP11cNDeOPWauLWzLR7vbGttuWJt/icCknVHdishJVRcljYSX0xS0L/jWhWoy89fAcuycivDBXgqzKKIidrCRV6dJuLQHLOPzMuKjcnJiIrMSY+Jyc8yYlg52eHxznZWVivWhD9xk/BVW2Ftp4gfUxwvCEquKChVyw6wqCgrLnTHZ6grnNe5m+YSn15a6m+TreFMamo95S+Ijyks4qsrbUf61gQqIqPvlDbAgGXx3ny6hl9MmKM0MV66UNCgCkKm2Rs1yrjtub4VZvMi+WguaSzno6aTHXT2Q3AwKjnFSdFuawXsV0Uj5JCcycnqWPK9k24IT2M6QheHvh8pmZNezTL1Q3gY0xBw7K8PUZI53GqEHO+LY8oylHxMxXNytSk0Wh1Dip7prvxSDNGCrX3TpBGeyjCOqim6JL83cYxWhktUOo1DK08owok5c8bez/8i2OsbiZniwvX0MfNYzI6WelBX1rFSiC4ECCLzzwQIFI/PbM+0n3EELPRGP/G7B5CZMeqbyZe9X1jH60LFkUHv3ypB8FrqRcWCYbq2hHBWXRZPf1W3J6InXtdZYknmdwlQZ71PA7wGpk8KdPlrkqTn2vD45tqJig00/prIBvxRjGeXucniBrUPPPWLX/HlgKBGWLR05viT6cenekTKW/4aGij68rt26hJo9bja+sPtCdb8Msti2lp4ZZUxKdicUXUtnxw+NfMvt+nb6LOu3cGF6bV/IiajIdc3Jwee9jxur/gsmnfExAGnYv7xJ+AvTjvNlxdCu5I7Mg+EbJwPDbOxjQi23ur368hO6nKtFBaSnB/+/CFivZb+LyFZr6yJ9vFtmRedU2TjmRvI1XuIjQMjSaWvhk9ym5nmTFk1Fr9U0Vlrj7eU7guRzr5j7xborei3z8ZP4E0zsoDd/7G1ZGCFA+YYpV4VffzxRhPUEwkRAEx48mfvWR0O29GewsYMIvynpmsbG4faehMa2b1DSHhGb4WT8ruFEEckKk0bbDf96WrQW/kooIdhA6rkzXWqhq+JWT5BT0dXebzOOWMgquxMPT56xbjQgVaVaj+AZviFexJpiRxB8NU7PTuj72Sk3j+T+X5t9vGR8PqSdGG9w+Wzw7ebK3sp1a2dLMtLJWU1F1aDkRH7fcf0o0zbqqEPVt6Ot4WllJUayURoJRaxKx81jobi4VHGDhUhRqVaXr+Gp609ZCT4DW9Lb97XJNbABZE2mQX0KUQblJ/Mai8aEWQOJllx7Bo1LukN3B2/Y7GVOj797N2dbBmM9ZP3vU70v58wjMkjsh1fa37t/NjfUP+Rv7v7sw36HIbvNZHA8cXM2vGgTKOhdg1p9UqQeifUBfyc/nc8PToAGS0rKH4fI4sbbCaSJWBykDZL6yGIL5ZC1MPa1FdeUnBk5dgGlJp3qs7vwvfraUnnfrd39XHT9umd9/ikdE1aKyPgyi8XPH36rrMa0efDL+DMYdygmyBp88fjx+yj5pFf5mbWestdsRGhdlV6TMUG7aqUYGfzNmJkH4HqvJ9gmW7XqH5BZ+pCT2njco6B7G3HrUxEf7tpsUwGueFYwZmyRy7ZTWEZgqQjkw60K0kGn8sPet77dfUBm8AWQMtJ7o3bHKiBBVUXKf//7M18Sgiw4IY+CQb6BX1774fpwyFc3cKye1rM0oH6xZ2NitXzGtJ8m/JGlwM6rbCyxGCieScxtM+cQmzFGZqmIMMVNxDjf+9BFcx/ePXDAwj1pWbpMxNbp8Eif/rzdp6XYl6Jwv45eH9tBM4KzipKn51YammicOjSh5btH3IXTcwJ9MaZuEfzxqGygkJTjiJmcYJMyTFybSUZpyu/evUNFCjwPt04jiY2H/wo03qkUyzQbdLarrcRQSPL3m3/BZLRlTfc/FMWFMjzfpRZEqebfHxsqLZvS+/7HP/I96ZR0btqNQbL+XejHDyy0zlz8ufe2UsgPC08UPbB6NRmrn34guaq+IlnxmkMF0eTC6XDlhn1mTYD7fmxnXPHxMhTx/UjKV5o5GQp4GUuUAJIdB6XvvRyLlXtLYIosJHfBWtj5eXvjm6LAqV1FGAC5Or8FkMSINFt/1VZeMnwd58FgNQ1fanX6l//mRR+fHB8Y6HlkGVJQl1IUvatsfrzYuS+absWK8n+P5eM6Pcv9Us7LdpvqAmB7HbA4X4dkayYuHxueUl+Qn3hC+F2svXuXKofai2dfzhMqxieWAEDCUj8U9mfkJ3rHXwxRZD2z+GL52sHQU/dg8pTwnKaPT/0+lBbx92s0rGTm/IPxGkANizFaokp7fWrNieJ8qNJwxHjZI+KtfhJOuH0hJCQZzM/VzhFR5QiRjLuR13NdJ7clLkn4TJTDmV7lnOmubnWswdZHOZawkczH0RB4auFlZc3B/olJ78VFXDrywfdy7fOPzZAoPdpwEhhT+FZj7bpkwoziaFdpWwLb0lMP1MM7VzYejr2LjDjEGZo+s0wNa+2vDvl3qK151DhcOEP+PWjltYteveFBK4FIO3lqHIPxc+XBbD9S16fbCZPglbX8BzziZO2q4x3a5Rnz/HPLz/jWtm3hTcL7zerAIXqK/NV86bP1P4MjwfCTB5io8/P1JYVPYLvblcszz9C3osfKq7hzGJ5Lsy0aNdf7vwnv9dIkovCplNP9i0C8eQ1NkDCQf11hYfSeN8N9lngi822Z88/Sx0OcmKiaPLU1tC/ptyDvrHbYbM7O7NEXMeb/GzNPf3tbrJ9LZeUTBDKqUyIgI0K51REO9fqtTmvaIk5ljwEajHHVDPMFyAEVeaxKjLpP5T3aQxVZajQk2t7A+7CZGAb4Zx+3NbO0P0rk9jcooymiBntcYtLk6eymwFfAOprAlF55TQ2eGCmVRq8TH898rTacKEtI21yU/jez+UvltQv7q6E4n+Y3pc/F8cRpbCurI1H1tQqEj5Z5q2aPUk3f1+cKC2F09IvPnC4c3gi6tu6DU3OSj/8/er2aKMno36NcPvxyetq/GPZm9I4iDl+esiR1jTl8X4L1D105UFqfKv/swZQuw94SidKXhkuJb/VNa/0TE7Epij9QZhnI8bElwPyjVxsgxutauHtAcP7NVNFwgw/4PfevjY9gXpr8vLNG5OreRFFEevo7EFcyyaOI31NGUnhn5BhZ54yhrIa9fIfWCc3x19HPjc9ZncHqdESbN2m0wxv3pO8LmvPXL0Wf+mxyGsRCfjbVyIRv29iCzNU3OsdeHHfpMaUbImt5kl5HI6SdJ1SSWFq9+P2zaeQx6j8X0FV3n0mCVgYtNs7j1hoba7RU+jmQiAd+8gmQNog1NL8ofx/+YMg/8rF+n1hdfRyv7XFN9kHzVPxlSQUmdqtvKZEX5d/izv95MTJbvRj1Mgns2kl+ll5q5KSC9PDPz0KtWKMbKomHNeHtjBFzDkQsBCRUR3XtTt++yAX3CX0Ot6MDAs5ZdnV4AxeozMkFw2RyoItSMOAcLl4KVJsdAtyFojbpQtvy/6xOPsVhRbQBSomT8bZDppRYUNdY8nnf+f7aWfwX+gclp56fUCDjco0vHYdXF1jbt2luVinvkSoVHataQNvaNBRKeYq0fSNqFkCRPAx6pAAsfYX0Lvo40ehetb4Y9HHBOyQxkSEbyTyp6b+X/D90YdflGAmuz+hyH/KKwOD31UhaCJ35/SRrRE536MKws0LPRdzruv7nFA6fMfJ+WoGIZ9PFyyDlwWsBjMwgt58+kFAu2U8cZsAEezE0+Zs0kaXO6qxpxwUml6ySBDWDmCbe242fSEUg8BoBI7nsuAAalbyPB9YS+My68c30Q2EHeLDB+zgRnHEqnhIvk8/PsFa2d6vDH31IgbTvkZa5EIIRIIyxFA43wQN4DI7l9nqaPv4jJoP3+1YPWSx9uvCqaIuIIRV4tuG81M+mGnVKizRZR1eYYkdRTcYyU+NN7VEd5ib1iWM6HoDZiDA++BG5Cgcch8A/Xj7G2jfN9hHAUSwoa3w7PevrfuAcKyO5PWW7RZczdrWShW/paWK77Y3brFQ9E/VYHrHekf/SwhBqCTtcRIsk27yxR6E+/zeC1TTeqF00j3+sBA7sKpGcmeftCqn5dCHYqvJUcAc5R/7dBWUlYx++/TDqjH1jWYpoxOtMuNGDWjgiYk+YmmdRWuGFRlkK1q+e/0SBvPfYi9b2EBi4UwHaFEcHbw1VsVZBb4Dr2IPlJycxKnnALcvoTD/zQ0efv44DZ5e/74+5pawA15mFzO7XYFAs2KqYAm6JACn5QpwFjFCk+HztaZ7RD0C6cIhlwD5aE8wcP04UC3GbVRgl6J0JJ0GxNqEJ1vuJT71as20RZln+pWCImQsc/Kd/yK+KSn7CV+EtYdJHkUbdktJak+I+OX8M984JFlLLXpbXi3qzPMLG7mi+ZB0G7hsuBG58WlugMG6mn+YtGVuoUaUM16WrQm3an11TUMMLLnmfdygk24QzOAahg6DkKxehmuMh2tj8s47jyDt8SAoiss1gxb0QRBM/siMcMh4+P6lmTnyLi2hMDkhIz8/O70kMSmtTFluTXTSZyJkwddnIcTn4Hvyi+YX2NrWg10eCDX6JmbbrF9YE26lJ8T+TfmMh7ACBYc6fEdZIT6j7ykvWp431LQeCngX6gSvnHIfdLjW2NR79O1ota0HOzxQkADg9pU0tWWgwOU0DfeEVpnCpnB4UEas6uB9Paje6cHxeWxed/i+AJBrdIvor2n9pdqzpQSQADRT2nNSsTNJjdxJdkNLrK83utiWdYJb8wqrStn4PDzBydqAfRjxhsvGH/Qulk4TIKFF2u5cgufjJB2/fSOFJzgpJXzEott/crA/GXldkCdgOeMZql87nynug5wcxwASSgL+yqFyhItHK1urOsoY7uHYRXNHz/3/SmXVnbS3Skf05i9xKFiUfUeL3dQHLUkTgKAUpWYs4tVVijcQ19P7sI4PodaOeaUx9oST6lbZjT8wnv1CKSEzG3EERk0ZmfV/wyGt5/BVD+3cXUF/TwtpgNYRE6ALj/WGej8+fPUwzA8e44GgFHAOK94IEx3r6i2va+ojfwjTDVNJ8wCnIb/UtuOKk6oGEax54y4XrXhGHug5erz4kr1f8uL/1aULx0+SN4DysGTHToCEZ0/gzwP37dbSusxWXdoGGdUlLexm1vT98SHA3vHODGF58jIyPFNZbEaq36NiwC+M+zwj+mqcZuJ1n6iLp4ESJYdTrg5MnJ4x7buag5eoBl4zdsnR7d/ZX3Gkfwr++2tdO+p9Q5XwmG20+BjFp1wY411CM4zouZ2BrFUCDzsHHsrlqRFkZGRkSEyBpOCSwstDVPb0KLnY7NVgfWgLG+UqFtSu6dCE3jnwEqPneo2voP/c5tpYU4qoSrt6eHGSd8xoecTPkqzoUmf9OO09TwFExTuWqgvetXtskKpAEr0q8oO0bnQ1bQcgtU9ccZPZgsBk9dw+xRtm9Oln4JOdOr0ReHHkagalyxR2POwocfYVK2bILfC1305pIU/UHPW5tlhAYOYGdSU4ZdjGdXEDyw9Sy4uItIL+tLsZG6zCli4QlkJMDjaPwoYns+nuUfEBzPCEwZyFYiyLCFx4SggtvURfv+h4vMFNsMupGhGHma8ACdjMKLsNOsyftKBXpp6o7fW/RZFjdUd8ShspVSsA4Q4PVjcxL3YO7IxO7iZxtB9ZdMjhEdNuXUwityckd1AyYAwdsnaoBtayxFm/Iyqlh5IJ84QzdXzVuAWnleC+RfLXaxSqoAVWyS9U4P4l8rdqVMo0Cyyo0tKch2NPIRNPJ3YgoY+t5MX1URmOqLjDIpeLjfQB44IZaXGRAaCIfpn+2RrV+G+fIeptLwwMBNLe40rDAcdNKcHK3KlTZsvRU33E6fP2qRl8A/5HGPUmKN+PHAaylWXEAeOMsdBQv9EpiteI/iOfMfqBxLPC9b0STFri+ve0TpLAhZeqZpCRncQ6fKHcapWIq1vW/YfNxE924Ir4liPlGfUTGAK0FlpVfrsOaRGW4hPkmRwQa+2m8Gpc68CnmCzlF/dOCreuitz9d89VOh3LbGhHiY0BL3Et/ApbW7Obx9rK0NTlS2GMSHaUV0Cwv19qkG1QQr7FkEvI9ws871BVMTltVcqFzLrM+LJWxyMuA2mj1QgkLodHoWf4mriYWLHJsX2FhG47Jt0/mEm3c2R7emst03QozKmPl6G21mYkqje8zjzC2sPW0WiNKn3n3w2mNE8sBAymgHQz8M7lXVUFMBIehurmXfVnhIYGMHxDA3zTfR0iYtPsJMgnMWapp8cCH43dMsGknEn4+59Z6tnRG66PAbbV8RvGSymKKbAUuRSFl/9S5VLdMgOLDRNNkU8hvZi8IZtiLyJIlUs1FndNVUjNTlVM9Su/yrVzU+VTU5+ibB+qgktLVUNOsYpWhSzC5BTxu0uRk8XFkxz3l/mjEGpKKpGJNXFeAl42uWTOSA4M3UoPJZpi4bp9ZrbPeqBYV6RrcIgEYTn2oIa///7CxrD4yB+OL8EWq5MWqxMWIxM2M7/NcGgnJ0wsg14YyD+GbndZtqQaMWYPuAQ73jE7h3GlmTNJNqmutppKjlQalUinOzjR6CQ6mWYKpER52jtHwFrEagKt5fPkctXMcHCN0NdaST76YYFsdoieXJl8uc3Wm5QER9uHIhbxB44XVPa3kpb+XBsZNpWCSrSuCf/kB4WHujUodcda/ZerU2/hnsQys8EU8ds1DQ/6Deb/jn6n4QmZNoNc57ONDJWPnX/xdqdKEuLaQArhArb84v3+vXPhJUtwqR9IWlRW3nQocBaJO5x0MDMkqbFwZXgwPbElJDN5/NBvzkcnIFCawIgoyPZDirBUTExhZko4/KqxOiJCtcT5lAWt3BNgQ4+sKaCnWubIeytIjqE5+KnX/lFoiCWRBGWdFYSFNdqQQqsT48MrSZS5m/+YEzVjEoTbRzFl1Gj9sCP0WVHUT+zu1z0M2mA3xahtU7tshwP+Dqz0tLWTRiRn4aVGQ87hGCS1hoBZvt643dmN3V5dwfG7Oxv4Vm7twqn6K/bQVM7itlb/FKNGNUMUqgKURUP/5g/t9OzEFHN0dJB5BrxGncwmiG1DyGWAXIp75l5oso4Ml0r5JhcUxTMWfFM3uBt19rLq9q3Sdm1pboLMEb99Hlg0mmjo4rAXHUQBvLb22XoMZdhubdlhiBIoAnu/OoMpZnYhhpvkqkKvjueAJmaG5sD/yR3GPjigF3bcJAkwvyeb+S/7OTrDi9KyGWhk1zpqBDLZ9Bioi3Rbp/AiHRuPz0NNZEYNKLi0dbTZXP62qiJ9ek8IY5usABEuww26Uzdosq0ixk29wOklFM1dkHj2693n9MwgOMtQhPfLUXNac7itVWsdi70CvCPRFesInd9eH+2DVSJYaXfpTpoV9MD6QFvHRbymPRi7g69KX+0SziRgYcvsKmYfLXAP/0zsJ3TnVMeEqAIQ8r3nTFLd0g8d/VOlmKFuXNIQHNfDTGR7MYDWEmXWh3SlccHvZKRB33Xn1C5rq7yV3XvEQMMCsfU1ZjEjgjaZCfUGTeDx8T487I8qEYjWFKsg67LJGgqWUqs1MWdQKcQZZAqXTpAc3RmbFyogUWoRjiMEVAUdAqZPb768vV+/f3fuJTXfLfBr8qgkyxqdBGktlnmgz0xTD6an+uiRY9pHhlgdqCciKQP6McKV4yN0h0yClt9JJaJuHJUcTdd+TqdsHdw+RB3eXDqgDizarP+WDubMRd8BtsBCA29Levi0CwvbD5NEumlRtdiRCk4XbFrnJiksGhmkdXJyWJ0Vqe8UCuNUXWQVc07jIhvaIJmSPR8LLR93f8477whZoCcwwvwlOWZ0L0x8TyP1nouOvzWVqeUOAnWDZNwYGsX6IVWMyTKXArN4umcK1l/KMywBB6h3Rzh4ZmzTC1vfZUt00aKbjHv5HBJ8WiOaEhlvEKa+Mj2oFhpl4BwKT6q6SCsaOr+Ue/jD07lV/7LQSqH7W97F0HAwPYERESDJwdA9zOJ7GvrTs581xU/LFQTsAYLcmJocJKswzzSbht+xcBznXCKevMKt2SruE+yCPzYoIlsyW4LaS9UXeOEGyfHi8eIJ80uZlUW3c/eAG1ILNWWSp30rv0ISj1mkkP3SDqad0LJy5uWIaeWzbMr4Aellfk64v2m5aGMOw4w6q3p6paJ0mEFWAy6rXZqtXFJf0wDWiFdaVJhVeuI3uWlGZrGel9P+qauJP3oNBPxOvVTz7uBjYbZIsupPY6wrKsg/V/yweGFsE5GpZjknXirObh5I5vJOFMyLeoidjOgNOtBWlmJxj3Rt1AnQuyLkWxTKsXixEVr5rvi6ap+USt/ytMgbotHXlRefFWRltmVBPxTlKhYefRdR+v8679dXMVqG1W/O73MDbQyxk53A5QOD4mKBff1USUGr9MHBDgdPFUtbj1irBXCF1jkdfeGCkt4k7bxOOayJ8rBFxOYkszPFKQjlqdSQAe/QiKYffhwRLqMUBVTNZIDCCIhcal4w3tfkTjHXwNiaqcWSL9eBgkB+xAch4GaEEbE2PpbIN9YjNxGx4UYPcVt3H5qcNLpnunn30SnwjvPMHs9jUyESOOXz61lZzzHfx5f7jzdmI3kQQ3mxuoFxvyJHiD4wPV0vhdbgZBcoc2QMTWsssKgKebRyUkGuSpIM2rje4zN6dx0zaChPR1pwoH4rhuuYjzO1TQf1oQGcNIxXf93Yzf0L8s0jrVlE4R8r60v8Gd1nyOfuhKO5qJdyxxz0q3pd/7GeJeDJbOZVmMby7Lk4NZdKaP7V7hAx+/WtM+dOHYdpFFxx9Te4kCvn26CXjYrRQ5vN4xUKteMyUrg2qXpZ6Ao9TxM+NXDSeTOGQgtZuep8SmbUoNUuFHWY0pLD6JGn8fJg/WLxEwZuZq7GAhRHXLsv0w/APMfUxcevkMNBKLu2UQNZs6tuRpLxw++tINmG5uAnmH1tB7YVkeRHnAG3hTixnJqefNOVU9s0YDtkwXKsagNxNF7y9karaX6q152b+iST4Zs31u9eDcRZ1eZkwRyOXzZSlvmGlFAdy1HwbdTLNorWQyfFKhbCotM5XBsuIhNVhvCUvz90YA3JMrACX8FsakE7j8IOXBLX8pqCY2OPYWJ1BuUrpkmc3oq1CNhtu0DDTUpVvlf389/ZzExInxhvyszNTNoDM2XKFdc+kO4HYF7UZamHemZX3YadS5FIfFTLyqqDabQwt5hRLcYUFBu7gomFYYKYuoJ6TWlprt4zCJ5I2DbOgvocw0ngnK73Mr9wWHYkVOL3YI7q+tJo0dSqesqmomN4ecrjLi/a0u0Dsge1ZdLZhKf8TwyqBFZA/fYa0fmGqW8wi5+dnBM8pHA7znkp1OwnbBoLWS3a5RAXnaFjzunwg/+Fa40RedrjqFUmccmxKCelWyfjjdBjB53SzdR5O+wWDL7U3LzL4kxItxn+NB60ZAFVoETmtNu0WTNSMzjRsELF2ER0jF4OqkHPVyFXG7J31IpItmK7a912XAafzzJw/WCrarx3dOjAFpplYAG+6rip5cS2IpLVqbtbbgMUT3VPN9CZc0EJ0ZJs8W9yr6yheGBUfBw7PUaC9VXF/RjZU9XJXTwoGm+bfRV5bUnK9+qN9BJ55TbgYeDlBjpzHsrjJKot4ABUG3egsUpIXL1DCs6Uk3qeEYT7CrliC12d8lT6BQ27CPw9xTzdN3fB8hfodtCI+2dzFVxKbO86y56keOo9XWObiEkYUf9EAFGdTJpJyQ7ARiXBegLHHbAjOuqBCKOOLCRS8s45hlmMqInok4POBFykPMkb9zgr2y5sMc6SvizmA8STzzMBgh5tVDzXmzmIPKL0TRrP22DrWaCPHSwXG+kVS2J7cBIi2UD2gMzAQrUfeI1eVy3GhyLXhNWTKzpdkNM7iBONQ+oJLkNeVbpMEf6OCWLy4qKCpMMKB6KL6O6fnmMUtneHP/y0K/aaAl++JbYHTNoWZKhVLOWs852VYmAGpQZaTo820A34XbJgF4fNw34SwDWQNStnHnCjtckWp1+MB2X3RTHbTkVqVmcFOWvkwTd5veQEAW7SSfVJjLoj2bS5lrGymWlIfmteq65GfcS4V8pp9xE23+mN8io7BFaTvJ7n2g/jupz+BK+SiYjYn7fal7zsKoXo2t/jHSQ4JQ8qYSuC3sp7X//i4BeE57icgedIK0xjdJBMed++LnLpPnAkSDrXydfHxhYSLMYsAFO0uvIwNcX/9v7nTNlribZtz3DIr+Tz+Lu9i/1XXBTuCSA9jR9dGDK2CpKaBjLPkPYhjaXv+PSpDReGhjVmOZ8g0yHlnm+NnQEO54Y++fdUt8lj45FPZ2FllyNtp8fD31as6v6BUluQeMnsg3PiB/J9geIFNp8OZibWS/pBJiKk8DpmctYxXV/P9uJ8ALbQ6r/Z5BxCHO5K1/LLUlDh6nb8/0JnURYPSi1E98R75ig0Qb0AWbNN5mDZlFvrKrSdTOmhiVCC+47h2VnFheqiwfpANQuX4tSKCwMrm4nc/L8KEnpGH2CdRSSEf+6106pZV+Z0Dz4ExMdctI0uqnIXzEMo/4dwdg+FHl0JNmfs9AyrDBfunZDJcPUirDqgILcDsu7KM3YP4g1gQ6ZnAM3uBKj/4zhfpD5sRVC0udxpWV6BMf9kUjhAkinEeQdYWWsGifblYboqTYrz/n15If4alS3JozHSvpWH27YnOyTvDD1qX6ReooFvjTO1jwogqXegUsRvEoYaslcQV1llgn742Qw/Z0iw5zl0KmuuNTxGr9kitNo/h15jU8zSNW1magVfDtP6h31nseUXxdIa3D0nfWRxVOyIyGzsRlBw7MWe0sC/Pr4xxPR/3h/ehZIGn1866dPPeVcMcS2I6WvNcwozyG9/gkj7O6r83ewZy0kFUePj1de8tLdAXsbr031qWx93Ekfra7CDvVmJV4JsrUnEfTUp3pA9yFY3tHurYDIjTePUW1dC6uPrI03Gsa8E5jvCS/Vn7tR3Ee4P5EOA8BrKwusIasV6fE+D0xbdhYZ50SZdJvi9DWeYBbMkSZCkWgrWXKNTMfj58qV2JMw/Fzz0iESjCwnTi6KG2sUF+ZSk6bnmYY8xlAtm9y/k1W3cfa/gbazqxszJsvVYLJq6JGBggYLc6mP29d6O7tyeIZWhwoBYY8vQQqesOnFBfkd4Ya4l7/8Ne4NqdlVmD7vQv1J22HYr+Fh32vegU4kCttCVXoRjXBGTbD2uWkVgbOLXZXFwpsaP7LfKzUvkWixUtl1ICfyfxVncGe4FT2JzijKbkpZ12rAbk8Y9DWNbvg2YLJfrBIjgSyh52T595ASxHmMsdp3vMNZiaheXpuuqbeROVTMyyEujIPZJiSt8j1nXKEX1penfh+TbsKOU3Bp7kmy+6F39JC7/gyN96ReDMAj+qgyR+C0t9oCS12BjG5eo4qOz/vPR0uJb4NOEjxLnpsY7IwdgEUZ7KMYAiT2rqmuT6r+44J1sALIi2oggJUxjT1Jmj7Z/xPqteJJA/PxcX16UITfETkKvKYg82n6D3ahYnECcQie26QsEhuTVh0LZQdJvPcAm5tM7WlwiyFgbfZaMT74yRbsrF9N1nCv5+TX4J9F3lD4q+VRi6eLjP/i3lsxsyu+N8kJYsG3L7Xh9Gr9zc3qVvTDszlIjejT3MMuVz/VmRltnWtvvNCmpW6/gqKNWXEhv50iyzXKxn3Za9W3tT6XWjJ0OB40ACZ9cJXdIRx6GX/9FT8z0aH9tr4Jt3c6xiy3MPLc4FBHi8YmYJSnJbmpfvfT+9hytVD7XnymYlqCuR/EIjH6A208OmHyBkjWsNnx27o5r/dwg7fkCUHuExXqH1wLJIslTZkT2DdaAVbWPNipf6M+cPHxP6t5OrzJ6WA+xw4jtieY04xuO8Zkjq1Gl+bMnjrh05FVYkRunMSY0qNHc9x3YWEFacp8sYe7aV1n5b7nAjd/2sFH2nipaAihqcffKe5knCR/FN+bYhLBReKhha6DBkI70yItCNF6i176/vs0S9CAybNVRGah37cyC2Z6qUKz9Ph9g4y7wUJWDXFp2IKChi0vspjZr/n6Rlr0O2zGU+/QWfqVH6HWxhTPUjF8nz6TdWfuV3WiV79R7iBorFpVtF9p2txdIg3omMuLU/fWvT8q0JE1AIKmvvvjqiJVEchJ5qSnUrou6cvyI1mrowwNgW16WktsVOVTP+YpqHjRubwVTjdxTty0bWdOdh09xp/avwn4JmRuYlnvsnbGM8qb+gtmts86KT18vLW0dF+hWcSdd3r+ISM3jvKS87FqYZyYPMHBB3AnDU51rY4g6SZ3i+iwu1etxSnJiebX5OOkilzOU1+iP4gJduUeDS6/sGUnKvjRdTMS5O/jKKkilap0UJA4mV9OGW5gLunut060aczcRy26dU7yKsdE15L3r3UUlcTMWsWRmGpu251V28+PqwbJeeoMaMAInYSrSnlRUkJ2aw79M4k8tTw3NLC4JXRBp/6/SkQzPfiBpLSBdYo9z0mXcxSPrA9rqy27pTA+/d6vSc9exqvI1GNaLP3oNU8QcAQEjlfNyxROA19xA2L7KZ4gnWy582iPF/ISz5jHOzLRwl78eFfd/rh4sHaS3qgKX1M/O1QhPbywHnuuNf7nmdQ1J1tM+FV7Z3e1X7KoGHTZG1tDF9BmQRCEitTq2rx8oyG13dTqnyYR+Qrm5Hfe5mhcZnWuSBPYvOs5SxOX1+c5PpnBOTgaXO7xkxuZmBznc2UkLq8/lNdFl2dvittj7Pzw4MzFrbbm6l0yz8YqorLnBrEsCf4Q7PzLBnZk6s7VeuTtmkjGwbddZwgQ8tiJ7m1v/RRxlz03y7rp+JEA8LCJ3CP5heE9LSnJz+Auah+/C29TXJu76zq1ByG0THxkdGwgEZPd94VaexazDP5KCqJKhvoIcEaVz47CLTdlBB8HlZ4KVxdmdSXJXU6O3jYgEpNuu+yoKnpyX/howPM4fXZkbmpqbn2g2t1I+FmxZk1yWdeuIs4B0aXB8dHR6hmPrWx9oIb3GJkudeyJ8pSkoO560gI+pH0hPL7mCnN4qW9/ZK0OU80oZ+1MBuMNOErKIe+fqF0YGlIAT6vOzV9cOeqAF4koaxkbjA6/dCTGfWf9P6dhK2CEMKUo9PP/QBa89PnBQpRt3gm+5RganRYc7hWq4pebh3WecQzrGXM5A/M1Tp1V8UrLDwg2V2rZEW3x1khAWTwlVQy9CclNh2SHMVJVpfJJrOIrxgBLT44q0Jby9pcuq3xjoV6NN270rLVcJxyzMkVQIEfFB26j5aoBkQjTXDUkvC/QeaH3CM/6guMj0EFY/BswChdz1isNET6v4pWWxw+3FwHJisUCam1VipJ9TcQIou61OT3fvQagp2nCg7RE0753a33KjP1eEQB/poGpnGBJZY4w09wxwON32b1PXaYgFnnVejz/wLHFRXPd3EhuZdt+Pzr5l8vBDNKIqoz+7ghUTG+UMS/5pgTTT5HbriD+3YtTnW4dGY9S5jaqVhxRSHVE+HdaWXNDiAk9OMMhui9aJ8/aFZqO9g939G+I5hSx9ncgoBNPO1cQQojwVqleC9QoaU45LPsrguOyfJ1QpVEzW3pNTMfv5+3NIGjzgcgIAGikCs0YKlyLbgfV5ewDwI0MCMvuCxS6djv/q9nBE+nw5jf8DiJO9BrkU15KzyHwg6MdZszyxHYaOrUQ8Cx0T1ApqiDlN1hOJpU3JFevNTgKinIglq4TOKIfjNzgAfAkPxzZoxvU0mzVj/hwbvVaDvVaD6xIzFkkmpmTYxoiTgg92i/ZZaLThIQ39TVizzCYOEf/BrOmpfaj5aoFI/E9K1FZaUjJNyR6iitnJI/uPVNQsnCZWG+sMZs0MeMC3/aC4WNOXUsastDgyv9G/Y80yezlE/OKV6U8fh1ZJeV7ZM1Qxp3rI0vDDtBaKvmGWxvWah8iZ6Hck6PpG/y+nayC4Mnyj2EiKwxDM0jtFnhVwUuIcgx15CxHPxw4R/05tdFHgMcvgejyBgTFFwt+iYOT3k3CAVIbsFRqbi8Crgm9MtLBV5jzuMsxtGK3BotmUbP+wOBxiouuViH2+TJiABAnSgAmTnL3kdA2GyvBab0Mot8kQx6BKeqAyAzBmgQzaUYInY6ekmNfFVpPROVOvbuDq+yEx5FelPkkRSUsC/31hFtOclpCc96pl5AZmHKIUOmfJerVcUag2kbCixChIunlJk6gTwxAtSOkjr/fvMOYEUmmQMbKdXaV/H1V3qKmjsce8fmYl4fsI0mTQuRIeF0MmI+7l5JPEcZNxcw1ggxHX/rr+zw84dHN6LjUl/Ua/tNM1MNBlWNw1m6Aw7ydRFYdmZLfMJwhR6ULJVoRfJGp2iFK22Y4sUaL9kWFy4k//+ehnb7FIxN/GBxGKlGNOcb0Z4yaM50XCHWlxXFop5VrxMolH4H7KPUE6TGIaAg3hYH1j+o/T1bO1S7+Sa2Bjl2FpN5H9XYnruGbGKvMxvWtIJc/EnylWV2nZqQAtA6LRluOxLlL04K6fh1AzPsuy04DeFKsfGEuE0YzBHMOL6zphfAjK6aq01r/0tHSU91sHVOyIQs4/b5EUfTpUKcfKHjvsbyd3+H/novHWZaVVXihMzW6/TEEwO7F3njuaHfH6JK2B9lnCNreX3HJ+Xk7pm4c4LrpPsoKcV0KJZQhGKNQIhwYRWAytWvqpevrUGlfbxeTVMAyPXjBZtIXkbODsGq5jhVOnXKbxS0j8132dyYNbUNNvjKFmsyZuk9eSgkUbpOppBZ6mR5FiZH67oQsv04gORYiMOmPXEB06QMoxfr7FisjxHjL8HMagzoI3+C1RqjGTb7MiKv19GKLJX59VdNpqG55gQSKKdGHTffrTGDqxAOZP5Hw99aJzmUYax0ehaW3EYNPLx7YHjxRvCXqbGzpNdrqzZszF5jcirt0aK1+sYVi0fRdtUkQ9TSXxR3z59A57DuaWnJr1GBswy5WsWlQCU/BXRPZZiZRzgSIGrhA19PhU3PH13FNkeITP5l2668wGU2XeC43GMUj7azdZ1KbZJEppSXUDKrHY+8UOmdRUojnWXKq7G1B608SXE/pE5PjPZkStcH5/smWFeX7IBW6JTLXogCku+eLrZY8g0zoN5szu+mSen6XNpdP940X9/y8tMHMV/xKmOcV3ELo9tGFzmuqmdw8e2c956D8piOqWWLsscW+zrLrZOyTNjOUzIfNSkRg6a0N0iPWm5dszxOkgL11mEkfWfmz8cBo8bzdNwXxrTg/p3iAji70MbzP4wbkFNcRt0/97SlwbFI/6WSV4xqQXrXyLtnX8yuCneNOosT5+SLoWD5WovnqEMXSzDDcq9XbsbFzg5JHyNXoeeqvmPQ0j/J7RX63CqX6abOjLrU+e88Kp15GRLc2HD+YW3WQPkbpDEd1lD4nW2UP2iIdrZnNhlp2l2o5dpRVkUR1EdpsutF6X/OU6tpn9+qIvsGxnpqXOS5EPofCyzc+lqJMu0UQjjWxsKD5LIp3Dt0EWq87TBJt58x7VuXrByI6LS6wyPWbk2+CWa3RzuVuh226F9u9WBjANtsbGBuGCw+917Nptfh9rxtZV+pHNfO/E09UJYM53i5M1Aflh1LV6yMh2z3qYkQi16M83+5/1jfQBgNArym1jQExm3nfm6lyNMHLPq6BrGs8r0xu9FGQAgeXTMYHlHAKLSwwsXyOwdCFw3ofJyqBfvj4VkNZkXPRnmlioDEdKXb0Ma9KYZbaaTEbS+Ayzs9isJbstLrHK0snL55ewuXxzuVuRLZsr6spsZuCC0VTZigGbaYb04rveVr09FX91y050unrWVvp3eHEGo7leIkwcDjsQ/8WsUrV4fA6JuaaUijzbF6ZTdkUerifGMiU/Gx861zJQaHzoCcvASuuDu5aBVuNDwzKQZn1w2mi5GlIRDuTB+Wu0pXpskdT6hPOCs6aIruv/3/MuEui9BGi3Lk+y+PUROptLF4aRvoWpXtCYNTNQ/N0gPy66Nf3KuKmPkKvv52tDPxs+U5xfAOecEaHhCFM0hPh21Aad6OF1RdPuEXMcVvCc8mxGW2cRIM7ynQGXtKK5r+O/6D/5F9+Uzzf+9N/x0KHx0+d7oTvx3I1PVrDw7/vuWuY5pEt+FcGvOZLVO0qoAxz+nXYPbhTgEISf38CmL/r1/Zx8l49mfeveeYFH38NuL52nUQ1BqbQqFeRIuYWZ3iXze0qa6zA/H17LgGVmIS+QhLOD26pBX8UxeR+CKrJzUtfMcI73+fV2GFjqF8s4o4QcDBEnVktIydcRQy2l6RqNrmKwg6ODV3eKYcTinw4mdu6ZO8DKeuUU8Ih4zIfm0Pe+eLe5ujLmKPtWDsEunKpuaOzB7HCFnF42SQFnct2NWlgntNJ0sySP36zra1auMPccUIU485Lh6/h6YmNLydScLK9MjyCtMJ9mZVsLUHfM6U6zUb2awkiabjHWC0tAHtmP3k633SMaYsumQ8SKMy5vUnRBWNNyOl9YWPLI7rZTuSFjE7FI45LWM83gb+VoerM8IiPHf3+BJflCdNenrby6OnjJ6Z2Vr3hVtLu35YH1KmlfrO2NcnkFUmCgh+chbVrma/kFvICAV+cXXAuHbcNNTyLmUzoRNv0cPztZxXyFADQo8i91E6uwAQ7rsekQOqY03AjFWnSLrGRBqJSt91TtG0XW8ccNB+wOTtiDYJyuYnmQ37UFp5s4q45XUmzghIjX/WYLyhmZ5Tp8wNO1EEWyZRm9gHlruiqtDKJjd6KdQuYLToXMiEBLy8xcUAtlDYjSeHZLhsXObwNx2BC2iT01vbI9/mXVVidpOXIZrWqnK9Bk2Rq2opwXgbDb02z9Lhw3kjPl/7ian/vPaRRpVzpeDSrSf8Mzvq17/dJcSWvr63JToGyWuRJxhZ2lmKc0MVX2xdTlJ60hmVSLdBy4FgfFobbTTpssR5uX2kGhq7F2xtXBkYOTMUUKbXv15rQjElV2wvNXqJgZQ1N11TGXPB9RH5P9XfuAyBN0ooSNVK+nHm9UxPZjS/QIn2GowSrLqaTjfYiz5EpTquatJPUgjp2THniNskcQaoqvv2It7trQEGa2BNpC5C2lzKktcygz8xKGxlLxnJCuDatML6NuYKcEpQ8EoTVuzZ9Kc/N9GNuUnZ7X8/9oFrt9P112dH2SsPEzhP0p2esLd49n+anf0RHH828Ae7kgxZHCxRkg/8whpvE+/8CXUBSH7bGrRdFaBURfWLiDtw4EerVghMvrlAY8K4wzMeY1acza1RpsY3Y9Zb/E0G/3R0VeqSE/u65yIufOmc86tz/3aOlspu23054Xbgyx0TzJPHgtItJzTGxp/l4Xbw5+/OaDapoJbMWh7auf/MGUTjzRucGYeLdO6qTD1EE2euUh5JtV/10JtZ7e5rauGepRDdkrRI1MldtrO6vkxbJgVP5ZVZbQMsyUOVOlbCoaZaxqha8tyog2EDzdZNFVGDIPizWU49EyiYu1PiS2Gk4qQpuLnhFaabrJrKtDedvqAbq0z+wHCkXaoX+8ajZvqTtzOPX57tl6meFM6lEKoqjSdGIKXD/Q/urO1JuKtxOHM8PDeWEGpO7oiX6rs3L1mhKq1Q5CZYl0csXS3PoBEglklxc21TKmWjo9KT/MAJmB05e2QiOuv+mC/sMi+87cQWssaoKpFvnuqqGNYKe4WnlDZtAUygdeGju5dgLrh9/UZM2aQvjTzYFSkJZ99qQ7HZi8dnynRT4YwzDHnJOwjZFXMtVKS5+yyjjEKiBBrCJMgliBRpX3xocT2taY1WSqk3zgz0hKAMartMMZ2f4vHjyxoh9YT3QTqQoQ504OAWvM6jTVSY2GvaZbSsB41fkdiBoQdS/r1hqLOtlUo8/39XPU1RbUmJ3nY/ib6EeGgLCrtgXvC/6y2uOC7TXgWb6kIcfUzLarHl9nUqt3Xqms/nq5nZiucvsSWGvT4Hla99GJHmF7IONVgDlc30PBe6z2bO9K+Y3p64Np/a/9E4tNUiw/oMGN1+OExmmcHl2djrBta7pOGUKe5pF7vFjDcDzuuIBDMnKBDnyaeK0DL7YCNnWsWzbRTHyQT29wzlMH/t9mZdVFpIc29zxb0MDVHSnDuKxMnSgdQaonhkFC4rQ4Uzhxkqa1dM/3PqRAfg2Msw9JI35vRff7yOc+N5TEjgHjdJzE4TCOHz3yadpx+HXSKNgoBQ46SBQUDmXX18o/7KOrU2rFh1Lp+jb0jRYgNbht7MfBJ/4HYLIItsEd5XZXhEW5prYhET1GbMA4/gT29fUOQ08PHkQhLXCT1Qof+uoEZjjxuui6/dq5YuR6wn6980U3V4/IVZIOqSlNOE7OcowEAmJs1ND9NipjKEm/3e13l32wTMvYfvps8s5Mkq4ugytjxOkSb7fNKBr7lkaH4w6SoziM6iBAHNMieM9zqa/fkFi3z/xGkTbUbAuegHIJL5aao4GgWoS8BQ/PziO97OEKmZRNXoKUqnuVdIzJWzIuA3x9rROxC9SFtY1AJ2GOCa2z/wGKUw7eP6op7rP6X30gngHeGZsOM0UEJlDCFPpkGYCYBP+dLMG6y2y7XxeIEXVLHPT3GjXwDJhdYo9XiMXyV7irWqPd+Hx9AeVUiHRQxCoxagN1nSIO20CIM9uQ7SADRfucOX9VrdruUIrwGWsq4wGkaQGXzjevG7zGKn7FujpPQ6WdT9ZPLPu00KkmDRIh96BqhmgdLAIy9hBxM/5Gim0CW4N8iSkJNiQlJSm4C61ZYTrmwF8BYEaU3DGMiXkww4RgMSyHPXfvWwAz4efBC/nmA0LOM57VK+Yddn+HFi/wwMfY2FiKGTRah/pv0MA3FBUocW4rfQ4v8I0taKaQmvcrMm0aIb483t48iHvvjDvoZTtgS2aUcexU+wPvHA9AE35eBacPCHOQ9Rwmr5ittmUQPf5KcVCRaourBQT4dmFRQb8nV5RhxOTzqQeVEovM0q33hIpYyoTlDQJWZB0uWsckCJVYTaBBHDE7SMF3RlFKoX0PW+QRUnZ7Vhoe2eB13NwXOZhdQhHQyxrgkS2qex4X5lxV2ijlbgP6h/3T4PfmnAO8hcFn48+7/ea5/kdrcsUSu/oaP++oFTJco4mMjCBdpXNwigHBIlmqNOurwDkTI1AjMykmjbvClJva3PUbp+zSwJPNdN9ZZaPbLaVkyDvtzA0Utw0YbLo8NDHm2c64JgLOGgVzFfrxg5OiZhIgaNJI3zFSlu1RS3pPMd4rglSMYjJyZRxas3ZqVD50ULU08SgNgMJTTwZ9APOw76LIbO00nQ8WHUvIqQgAxzg5I/EaOshdd7RClAJHxMApOvT1nGNvULELTBMpbtDfnXGCc7kIAl/B+VeY7c2Jahfr4NWXaBhHSAoaw0UAMlatcgVNLQQJ547ZhJyTSXOE/IRNsJjB/AVAo0iYVYmY9y6VAhYm4aItDpU1hTaZZG7uzBF3nVCPr/TMJoOBHjr0nffG2qZflUXjHv636HbMqjoLAKEPh5NNuzOJbP+YLJV9CxB3WVPqv44ymcF7K5oWZSdI8F1KGnGcQQx6c35FNIJScJLeEG7SoKeld8JLnJ9ZCGW7HBBSryEgVohOLBJeEfIw84IZoYKKvFW2C24Rn9DijSbrhbMUxeAQCLERBMFYKHfW3zmHLAoyy8YdVBIkCeDcWyckw8GDQZKGxiUwZZc8Ys0WxQMri6wVrzpK5hRasKTIBya3KqNyyUfGYw9GEShwwhqNelkaPUjl/tEP3d5FUOKFBwL7ggkxyY4JaB1rIA1gIoFxH/cUKW1BY3fya1fw5icF79kbXZ+3TGcrnKo0FRY+LZEOpxt0CDAiejGqsZ/hBSI4FsdUe78qWuINjnjX+hCH4M5EwOxnzAKhbA01LEqmLPgxVcIUxGHjpkhqKawggi+sGHd3Q1YI8kSmphURBVAqosj+o5eKu4BMzVB2y+asbio6OXjMlbvIugIxswlCwCAxCOJtZi92TVtkHLFTLjwotqxd3RbcN6l2UaQ2gJAtDgf3x8f0+eDdfsr4QaJu6A9dUQ+p8893LL+kv5xxv7/Bn60P1BW3bLfaNx/K6/GG1xrvb1gOJhrNNBA3isOm7JIzjSJH5wQWe1FJIE3oF606ADJiCb4ovQHk2IEHIKUq9+1fJF3U5hr/jRBYy7S7ITm3y2L2kuXPRgG+AKhBspm7qqqB9yE4Q+xoEh5AZZZDGwYuyWQaofS4FekWIrtQKZKMwUw/GMPgXFgCD3br8eNQxFEkUj3t/IvbHZNUoO3SQEg07vghGae2ozqH0EolM86NPKkMuTrhgqIzRAffgt2nzuL0vuIqIEnc1067c8ladyus1vV6gFLGTKl2cQco4gvpJIMAD1LxWsZ4n6UsDZnlit5UVex3aTp9rz48lmkRph6SiPd6Em5J4EeQdLW1OHQ3pTVtb2J0bi6vhPB6VzQ+xl3VMLSDNEybcjqTN+Q/V7HwFGyL7A1DoJjsWXUzRt+dEXspVWumAZiyuPgiYWqQyQcRTOVjYlEFjhYm9bWL5VBWKg4SUiK3F3YBN4gdWwbN9A4sG1DcSr2/yoWhq4LvQFk3uCg9QWoz6WDBTuB1oaRjPPeNK9y3CY31SXZZ5q4Axc4YbcCbSnaVmHuiW5uhO9U3wAMA4ocoGYZvQttBWQZ5Z+CpjlYEFwS3UNpDAZYtFd5/wEaNgf9g4H0HLHl9fr23X0RNhCKlAmC87ngqKj73VS1WQvQElekOj2Vq6O4kLZahYGkHXbyBGEL6NnHepJ3SPuZaWKRxqr0tTT5EdqkEye7oGxh/bXnIzg7JQ+kcoQsgv27qKBpMeJ+mMePt86cW2BCqx6IF4xwMc02cnG0xTWDoEe211Eqn3VODxA2OlymTg3ZKwm4EQvraGLTWCSFpGCCwCOGsgZh/BEk+VM/TtPIMPJA/HSP8+6fFJbm371c33A+7yhYCGw6u+L7hzhkWG4gkpThseD9TGkbLi8Llva5Du6zGr5+TCI3GW09DY0KLzWv5rpdTrsPXKyK8OWOae6/k4Ci1pHb3d23h+JbGgCvWmFp9qeqf/v7GgHERCBKL0PikKYhQMpRLZKfg1Iy+IzWtSBnL9B+46gjYVdCf291eFHAudHmva19iU+TXz73KAHIPmtVpq4UGnUmtSSHXB6DiW/SOVdPMO7kJOp/2ypjzvw3P3Tr7gXOjBbYrpHIHfZ86tS6sd/wpY907+sIM2CrHPA7io+i/Iv23VqHnUuvS2re17+4NNrD8n4oAn3peP7oP9JMkVrL3roKUoTUnigw6575mcKtNewHHO6O0DiGxAuCAlVuOsbC6AGw0wo5oGoAUUf4dggeg7O1PQQDI1yenMZi4hRXGH+hAg7vRXQ2IPs7DOwInugO68LnPasJoGhDYUho2OcNu4/Vf257eIKQBrfZiYgVLql+e1hI4PnnyJdlnQ6n9OCxPvZurHh3psQ/1ty2UKOJNyZfL5p7nyt2r6YEktv70v/+8QUt5yoxn2D3RQtK47K35yrRHkMKT08HnPCFwUVWDhzHbnfQzFVWWT6el+uoog9xQrtAhztl3O2oyoQRkCCMXX9RCVJrp31x0P9z1FEUWJYCuG9rSkFhzNRX71fxv+7fsZXZAa0mk3iJIo21HWycYERuiy6aYfhZaYWltLSH87PQZVlCJisnBbnRltMNSq0o/hoUzAzTqQOiva1y1qX9/pjSLCatPuDtj8J/ijn4rVIfzKMMCMFQnp5B/tjZ7pH0xVLQinlOdhNlMQGBRPn0nQ81PksQ0sdgLtFq0f/3b1rjpQXkRbvjW+OFaiO1+v5z5DNtIWCHBwTgVQpGTt+Ty/nPZ1Iv+WH73CL7pXg+m0+0DLPjV8zTVvxySpL5ygf/wqfxydTmz+0H/4YbfPK64Tvm8ip9Y2V3MuUK9D+tZeE5J9SwgOWikUAgL68Y47RexkoshasHnBHSyvDN6H9vfk3gsALY0DibJiLys7duZgAtPg8KzLbiGCB+FHFxphVAxyO5wbUbF5eyz0Akra7da3WeVU744vuqaVJXgLSWyKamzPkMnWQWwN2YGeboCfb/qIgydYwxusptvX/H9PNGL9pAXc7n6zPVQyv/Ac2t+XcsdOYSMcTItegE89xYb5TQjC15nsAmlt4azviL6qH6KIu3k9R7JtFc35NHk0wiDX6OFTtchNtvTv2QP8PXJ6fGJtABOVZTGKSP0usmihHF2wyhTzUeOBSdud+h0tefxHkC1j8lFHKNnABAQqNGqsifJeW9FkQVlmW33IwrvGPLq3DyK58Sa2Uqj9e90WHEpUEM9RhtcqELfUhVcLb7JC66KrkRnKFZhKOQKxv+B4YZcukc40je9hMxySeBUCTvQbaPiTH97hxi+qZFTOd49NJb24j7Gklthl1CHkSeyUxloUhxO2fys1aVW9VmZdME2yiVf+1ORgrUOlWbHuejEhhxIoeYlUNSLkjKB2n2NlgJsNAwtZsxcS50NgSAKIJUsljwq47TTDhgh+HswU+KeoiOkI6LAVHidXAQt6IxRVrjYA48Ik7EgIUbdlPBKLCsWOeyzphiyU139lN0cKqVl3OfCyYNibp5aEojF4HvETks1D7lW8an2xXReJeO0Rp4FwKqoafqBkBvFrJwg1hSxfERAhfxJpO2200ZKlyX4U0n4rqXtTCkQQr4KCMfyh+kN5MSCMrYPGxLD/HhrZb3EwxhFxWDRj9Nu7b7OfF5mNOfweW9Mbk064zwDvKgPsxDS5B0uWWvdAyFy+1xX5LMX9sIkTMKVcKWV079ENq9SgEgSs+bKnVzyd7YUjI1o1C4LEQ7agOAdqEJ+o8g895weqeWzuamCRcY37H3w36whmOkUFQOEgQFEl6SNFn+wfLYJkZw8F4QciX9UA1SAW4jc7smwvqoGec1E3jEVVMZCd0ITBcoFTnsuRNpo9ScXlEomk1wQTLVgx9HPBZHKuK8qz7XC8prvu9KJ/mIfYwUWxxaVFjjbFYbFA+RuMmgjs0lo3QNsXBfkHGpwg+XLuAw+abKRK5mDrQu2JDhjd9QdXF06ijawfYJrujUFZptksQz+48/EOw9/uNpEkfu4IF/gaSnMv3wR+np4/za5cWxuiCOid006c1fpk/n1jp2hw7sHGMxtx2vNIx6S0iSTS9UgvD/l0ihH0rSOhUoD/ZRtYjnDAUBiMtY9Wf2ErtGTPQpiQFzTHpFkloMtrrMfWL4WNl8VBd5j/9MaidaOTQZNisV42k0QSoKVaxbeAw+G9dpJysGIICzD7pN/kMGAe+VrZ+42zZGfAvq7mVdkx4LgXcXu4iIjz7ETuu8Sz4kqPIkW2AnhVtV8SQGKoBH7O9ciD1/Tz/rqNGWwiVTXRSIwlnUAAtgdCKiExboaa8ycRffBOg1uYVOEKLhFcLhTc+jKchADOUHlYqLGUa6m8Ra1cSbFdvSefND7pttHR4i8a9WBgshfoTiDI3WkVzWZ2nkPooNBDZyydeSYB3phTY9CpLi9hJmW0sc0OJk2z/jTpVezLdvecn5MFrJKb0wAeAD5epS6gJJQRAp2lbcTQFYjSZDFU13ihFdTSmqhLlrV1jTJTYmAUxAb041MZJyaPjl31zIIaNffx0ScXO3GVlq/QSaPolJgbeZjLoxyVa5NwWLI+EXCo5SXSKebrqT48SKhL+t17DVhgv/OGjzwlY9RKRHeZBootBesGy11hU+WQz4z48OO5X03kx+CBxfCYSYEdAQwBiTAY6q6790vpJh66IiozEUdfP84X6Y/7VPB8G0c24BH4+MFgw7vyG49s1vCQExoDRWH7Z5qr0pXdcXI8yoctCftojzVgxbwafD3WTuzr76F0JEFTo+Crnlud5WUQUbY6fcd7ysMCi4UKEfMNVY4AZZmeOILgXdG5guBxloWxshKCxjY5zGTsb3/+V/AJcYifUYURuOeZJseBI/kqmzzxGgJ9GXwNcT7WDk18CPAQyJntqWqa3CD2ZytYECYQ5oNVpTF4LLFexk8LQ/bDx5woK+60O6yLgvpxVcIWK23+eNUXKEv6JsvX9hyMyyHmWdgfdjWrwyHfjQ+2M5wdxMvStippItSwjAgviiV4NiTUYeowxa/BwduKoI5T7MbWZ0DXgVkxm3iyLKFEZkHfG71JhJ3q2DOVt2HySC7jFrMEFgbIdAh81Z7dU4pNLFA1KhG+AwLSJn0OdImeeTsJTIEj/VBMVwQO8GO15jSGRQJosauExk83SWJBzspwSR6WLBieXmQcuepmL3NqhbIA4sAp4mdvnXZOh5JZZ5Va2zW0M2a86aa6UBKAEoo4CHU+eFcuLZlkSjnHSXvS8eHIgNzpmrH0plUY9qPRz8d01Men6VkadMwjK+bJedQkLL4kC4e3j3w2leiNHmRvMt94oQFLne3Qs0/IoG36PMS5OIOeaiVyTjVsc8+y0JbxAXPshpKzofQ8QzFHCTt4hgnZXCKPZ70XYaNEezMcwjaOVMWbkLOXIExj92e5/otACV8HJL+zLa5S0yuFgz1ltD0g8fPf0fCPFuKKqUJjxYActNhJqk/1SUE42QV1/RGd8VHlYOIpAS8mAxz8wvNkaSVXjmHS0Gq2KQUJmR9kJ9GE2JzGeS+xNAoAMgYkzfIOQx2brEjeZrJxAcl1jawcyaygJuylzMixGRwdpK/YxJiJO5mdXJUWDx6yzxHTq3nUfFZeuYblTVxHDCtBCUn4jcpYfbiVIbJbJJGMQigcvAzTFIIMEIISljSoMGUHpMXfdfeM29bvCnhc8u2Oc/LWrufyddbPwk98TxrXYyIK65yg2KiJKURQLFqnkpEfBNNgZYN6Sm1iATiiUL0VltynHfSeGpZFRsCaA7OkcALv5hL37mOGisaeV6bpYXWJEguwWTjKiE6ApJwW44FUGuYfhs4AmHgO9DR8GlwE1LgYI6MvFvDqtl6EZmyZRyGjVSLU4FVsUT7UaToynhDw/uiECy5kFMKBFR5cLZvVQabqoWXBpZOirkZSlKiCYAMLk47Cqw1nJ2kpNJiCFDsCMOZPT+NBO5OsXtBCOElABgx0+QxF14anwwEPTTbqVrWEiOhQCSnUAJK+CiyZaFIh0LFZ1flcbzkjN0A2S4TisQI0ELUu292AEbwtmGFjlkR7a2PEsWjNLwkXEl9IRcL5kDU4cXQiDYYaI0hvO2KCoAWKdMFY74XO5l0pNqLxr0BmoYfey+U40woZRgjmRmLoeBrlhAaTehjGLorUGsBA737oB9lIWeORzfGw0wsgV7KMDImfV2NgNaQ8qWUeIM+uX+ihrvJKNxlUsaNnRaZHEPsc0m2C+461jknhFK8TaMAzNQ+6HSS0i/31kYeFqxru9YVnuuu5tzFTsaFY3EIHjdfbYVb1n0MiNHEktFHSiUOc+gFvvaC8hRDSebkBZPDG5OKK20pBu3ZCa7QJX9QVQVYfAFsnKK29gna+I1d0EASLtAYbrRUo8aRmSEHnKip0VTi9qiGbIXSZ9ZdiXj2KSp38a6+Iq2Ux1CMH+QKRhM4VACISZETbV21LnxHsx7toU4hz3Ky0PCFWSKkfrbhS7OPlGh4vANgwdvGh0PsLTMl1iIi4/uKZjGMIPQ3y03svTBovQLwiDE5Kn6eNRFJUg/jvagJZoQS59156G2jXGBfiFwNogBcgFZrUyQ1d2naQFSjQFJkjaEkhcjaF4Io8UKG2UvjNR1NEISwEpHzOGLgMwAuBL/Oy13rOu4GCrK6eqDuhdAtXBNvACVZnuScUP2+UC0IIVi0swSHlNu6YgMKloGOOUeRLXGaBnrdWQm3rg6YspgFJDi4VeR8Dn4UqtzMVVFKqRe2gLK1oMjg5sxFYurH/Y3u5AafWbH2tER+ndEuJeVcn3ElqFFQBATTP73c5IqWmZlPQ6pVYbxuqrJ1L/ZNihvWnuZyQY4SC960UrYlrhEA5wAUBGz7HeDQ0linuTSBZeOY9jltImDeLdUBXVa7icmQKxVxVhmpTGCTGfLcXHSyc0CnGrLpdcY5tNE1lziBjC3Mwz/NXGD4m/dQQoiqS2YtBrsYX6hb/IUqxU3SUJrkJg9DGWu8Op4b8zAFKR/YuaDcaQpnoosoRRdqpY3nqBIAZoNGnDVkUBw7yLdkkY2BWFacIVLf1NNsSNi3GrHBb6G3Lt0e7TuosP4IbAuOVr3dV0/iXUL0F7o8WQTCSjk2Ol3DgkZWck3eX8NwAnQoCtXXf+0hZ7KVjG+NkohD3KTmZJOSMHPAwrgDDkEJzqSYcpfP1Xw141s793XA/jnTX+J//v+2Cq88S20XTLvd/InRidYOvVKWgNCQTgSYgzHWgSLyFhsc999Vikm0mDiGRfL+8RLtYDoVzzMHjDmI6UgZtrQo5Jy2aAzI7IYp6F5sdk5WzOECnIpg+OLkMIwwdrrhbQCBzY8iaL4cgNvwL+88/CHd1cOw+2T0jrky69s7/nxaH1OczofD5XuOcMxGyG62w3CwiFhofCSUfBHSJI1GG2dZwTbpwy5HMNsBXXzx1+9pSh+3ogVtFgIwVLNnqZdbsP0ttHijQQlI2NccMKwTqsaWmzy8xv0jtMvTHS67zN6nrBNveIOjB5Ad5Un99JVk4jjWVZlLI41mRaPM5YoVZfEhfuk1baPV7Ja2dXts7226eBPjB6JAhXeofEEDKdBgnEDdp5LpiqJcKhaGvq0JW7kl2V3k3SuYTOuNc5cFAXNzbJRVtX1FRcqEwAc7xCTcpAg8sO6EE/FdvuxSKVUdx5mrmWa24LqTKbJauypRH2IlRlmVH6JVtKqrscI2Tqqkkl0Hd3SmDO6Q6egUjrJ+yJttH0NdB2er5eTisq+IMJPYXyW+AIukMoF5JZWCH9V8v2/7LKN2GePY9vRh2VM/dQxPap7mkVoCEReQIhGVhheW2JGWW4vvQxF3jO3WMZjk4rKWQ+quJU4tmcp0ba03t6xFcNyFTE8Hf/kz19PyQCWgEmOawlBK3yjkXaZi2/spyGQp16mWm31FuMdy0+vDiFUaQ3+vKG/vzNu8OPTdBxHnsT7W2m3NC2s69ivpmW08/3wbLhrWuxSOjidfYSJkruCfXtvDp/7ZvKUFYDbxbeueb8gUwqZvfGZDOoCH/jlQMSJhT0w5GVYsLncZOm5MptzBI2iTxUV0XjXQQfftrbQiCE57o4FiCrq0kmukkZxas7G3FKfuGO8dziMDBWZ2IgX47HCGZWL5rfcR4Cn16PPYFQUn0ukrcG0GyQxnUZDJmohou6Y1H0fMXJ4CpRHu+fVaDrggLLOqquRH4Bv3aXvaPZYlhyHMYxal65a8k37a2ym/uRg0JhqBW52PfjVkCXtjjIBM57bK/3mBGLMBmFlVN4jPBB25OfLZ8H/wrhglaLJWOre1SVlaXhsAgD+1/0ckNt4BsA0/6unkODAI6INYzXocyW/5sY2AJXv6yQYo0aG1srRbAiPslFL0xlMvPxHYR3T6IkzepGK71zjfF9DevLpGsIiiQR9UiY2Ypcx1qM0hzvYW3xXAT0IqW1QUu/XBR2WvGabbSgKYQ1L5JiOWnAkz64NofQMhnhaVO4BWqmlZ3KLWwlsbT1QUm9nqHJ2t0XiCgSnuUukX/1nu8NG0yFX65vNo1KZx3/KNRoukzn0PtbcNfAgrweRalz1vHACe8MOiDHwIM823gc4Z17C28J5FQIG8d9/1fGcnezv9O0FeAiDr6xlIz0rihufFVVZdIRsZIhFgkLSaWpWkkq1WcVy4lbqlWRLBmK4Hg2uLKXrKatTWiQNQxGBGFZvHNnKmOkRnZiZT7MsK/d2SspL0cUisyj4AUcTZgW2fvA+LE0uSZScnJSWzawKjy4uySBMpqHd4/uRx25hERzBODxS3xng/OCwDJqHsUHSw1ziBwHb0goTh90UPGnMcIXCvRn9cNehVzbG9u1hXYdBVQVB1WAMYx0Eo97gbkzUOrlMuN5X7eNjX9U671AbXFOTZ8zC4Adp9e8NuT/f1XrNxuA/3xnr9aGaNjDL6w1aPTFXsccSFKUJfoUBuTwjDucXQHTSltZ9GgkXbVivf8StMjO1O1vVQDNZwjTMuWeePOeQzNU4B/oTxAiJcAW9RLkM+lyUaSBIBJxY8+wgX8XWzoIvdZluvBTde4fX/T4+Tl4WUiRcAs2vo3IcuityeKZKHCzAJI0t4lodczSpECTA8S8k78tD7uzmzeTLeO6x+MrpscrZWhZm7U1k4Kh+MhvMa8Gj8rSOqEEuvV0e/lB6a1vdCVnUUOy3Gs+9u6E4P1ZaFB3hACie+Jb6juq2ZU3IA3a16grq02SCOz/rqF4BRHQylXTfmeV7Yek17PMfb1WgLveSx8eMEdVqfqa9rSXb6p0EOvtQgMj8XlGgemeRW8DPzqc4jH5pDtARcqAB+NuvRzRk2q6MmUFncYArQoTAn4GcI3P4MOHBFQ2m3lOw7mm6MiT7PBF3SsJhWh0T7HKecLqipehQqBCV0CBR9XnrcxkAoDeu6kyHZSo83HpL7LoezA5mmxBlcVRjhWcSxrMcrwjyQMC+9pKmDedoqtUmw4XPv9/ifaqoLXSxFbm29VOcbW8yIJlIgEVY78LIflUYbMXmeJeLIV9XFaB0G1BbxPnrCQxeiZuOjSajMmWK6i+5iCi8sH4rRfpinvYWxNLYIz5YN9lAYSiYi8rx5OYfqYTcxDABKfpSoTZsdhfvJj2HUjmyuz3afWxTDqGu0DTnyI9cmHnRaijc6D8b8sQkf4fsabnsbRFlbVSXTkEkWfYXaum7PBKIUt3RaWSY1ZlYyNjnTRK5ghHn6W0RZVx+bK8Z9N4dFjbqm6WZ4ICpxQ69VVdJQGk/Exg+eVFuW1bKnTFsNyEQr1uV9UtmbdY8Wy8XyjAiKtjiz0tq2WuAaJ8yqJtLvjnCLk5DXzfxcM7bHtt0RtKYElxt2neYIZHtM57ZzfPZucVtcrqV7NzrHt5zl4fGjjSfUuMc23m9PjbIQouUoS3aUxHZxy1Z37DMOY/gM60MnMEEVQjbGID5OZTgDs4T9d9jpjw6vcWvpGDZWm6funrHGxYH14vpU3Lg33fdevK0wbgD69u3bkbfVNn67vMxm+nImmK6n65llP039EjcvXjyfsV6wppMXN8h1VjY5o5Ad826Qpn96W14/pVwHcWWV8GcrNlFRymfl48p1pJ/Lyrm5MQYmHArFZ8paKy3gqrD3825XITWAdG++WaTicGsizwY9LShH0sBdemqlm99uSNXY1al4XRHqN2S5Z36DOM3RNGj3qwSIeb8atrc8HcqiwHcJPTEB7yOlhCvS2M3Os2+nrsPHGuBorg6/bRfd0n8+puOd8Jgpc3W3oKDCUDllpUuXqIXPYzavyMd8iPADAN7ldjSfx/Wwox9nRqO1qXL7MGMQm3ZUgNi+HH43U+92aDkPfuTlJ71nzsM60jTTZN6PVV++1Z3yp97PrN/Si/hxfGb/WM2hv99f9i+a929cxhnm6SakWazXF92p5d/Wn5rO/fT6rePl5dO7unO6ZQ5IbVKqXB8m+izSo9agpyhLaqholrD/uX8D1+oNrqsvyeTV4vD0hVJIPN14C/PtenC5ujxTPXvWrgzb9k9G+tJqYvd0tNI/MbXTmawdhVf2PzjcG7SJ6oeiHgrnAp0o73OvmR8v1lFwG+NJtLPgIRd02rYxaUJ9J5JjET+cglsq4axTNOZBu84hktV1XnCN7QXjLlM58J0ppDKi8cB0pB0amExf/eblPEIJeCKFq5m8xKAaHN8g9pCqgfGV1DDCkHTGcScvy7YohBwQmF0aqDNLQ5keIgOWihPLPxgQqDaKAbx+VE8faVjS+/T6vbvuhZeZ4Y+lf2949Rt7v/8O5lsvu2/fv//ei7v1r/zKz//2r3/6Z3+vurgYprFb46dMmffD3/696alST6ffe7q7Ny3bD518eXQ2wAOg/ZcpfqA/Mg59z3FFamhevGWgzUVdXD+xfXY8FXbm/iklbRqVfFzRxyngeKKYglv9PCcfbc7SNT2HSWN7fuxDQXgSRgvAnInUvHNNN7QVkZlXseB/9Ju/GjqBiGK6iBXr8lbIeOtRqcqikli+b3CunObC9VYj+1zQgUYq9AJfO5AnU45Fv3TTCDXDY9L3ubVjrBUaOjFArJWG4CjFqsHXcawEc8i81XI6ZjoUeg8uzCUrERMJd5zAmz8t4tAv/aKd1lYdHzYAYlzIkKHrb6pYFsw73nLYcFGDUSREfQjqUiIx9QT79eY/C3brixBRHA6qW/SW/7AburShu5kYAs1KhzMMxmkk45/egdTbdAWtjQ7YecrF+OCvMASXkr5K6AbIToOXGI2pjQkWyIo6i5dvtPc2RpUk0GE7kDgHQaRdkO2s07Hk6sx0dEFuFUJukpIVUj4gkg63C1mlFN1S/aaI3XC9k1Ym4yvXUuJt/gRFk93MxHHzY3TSAA1zUSISkuUmuYoq/shlpX9OUIJU0S0RNYZ4/1ed0gjEOeLcJDcXFdHIugkXodM8RQvcgEjYsbISjIS5jQKsJ2qdixGunEaDnDxKMyDrB0XUqLm2ZjG5VQyz0oFK1Wxdb4glDAtDcU0llK5vymiNfuJmC2LD1EPLG6iCYCAs2A5BEbld2Vp7NmF2Gvup7DkaoSb5HErFw3gRYnZUGZrcHE/wWQSb2Q/0xKDgMk4AOk3C1t/CeDiSbbtF23tHS4xWwcikUkIqoVO6iswdpEG+XuAWRsAAuhQNYMRiZUoMElpHZh94vGIbcoFycRpsaBghXQEejpLI2FhlSzijJwOaVNQPXCBeJq6Yx68+NTEndoFDDTA5qAOcv3yjw2zGrhGvwmvv2VnLGStH3RAVdYt0QKU8lpKHwxd+WLSRgUi9N3dZKOKpYqhBW8yFu0q8zV2noUM9jMVbiAi7qBCids6SjddWTUX53tWgiyPzAnEIDYqZbBDHTOwA1OqnhphONYvernp09oNrxWYnAltYYLrdTiLyU7b7TMtNv6lU8FpXISVLBm6dm8ho2jTK1A4HPvYbsACXpufmL58uL26JPy6XwRymYJ9p0qbnfLLqW7HXx2+CHe7jOpwkLMmnxxdjslhK81fPNtY3nIVvG/pLF7v7Q6IWyEVa2YV5ncoEJyjh3LisYOqEZp8NpRXRGr4mI7MowKbcBW7AULUhKkRRPQYUFWIuziabfmDX44gAmaAEijZF+ztVtZFQeBJmiEEZb6fEKKqgpCCKiaVarqMJKaOr1MjyHHkhcLEFiOmbiYeW7QPkKIlaWvFZEsnhnYvzvCKG8Il0aA0sL8IGE6hyRY0ObCBRVNFu85Od8xk0OPAYeAS/r9PIkFDr5Nly5QEG6+yVQ4gcMzPp4wuZgcMytcU5hJDAgsCmxXIxOmilAcwfgiSleLmRAQbqEjVH3FJhX7VmLD4Ony5GJFo3EmrYJscQ8sBrgtsMYrYLzXKRh1cwBmzC6zAia/EnzlisXasOwVLgkd1iibgF4yQClN8IBCcRYiNwqIVQv/FkxRjCFOMtpR33GYMTJsIJR1lptCUaQjnhTE9c2M61UOrpSjedpAnAtMjTH1HjYiBca12zqgO8nB5qdWcSAUVBvbgt2zHCI+fWaWAsqUB/3fDKPJ15tNrqg3cIzxy6d38mkq+cunEhglv3BV78xygqfWR+Wcc44sVDtNHCxJuZqUJqxrHp41KP1yDmWakA77tVHFcdnD6/6xqpjj45npMTLmiiP5tyFOxvAXorQFggjOh57ulcddcuo6mlxc3btu3qmH3hKbNbqdERKin2imqF7TSFkVezD7L4WeebSi/MNnU1fJevK7tr6ClmXdgmUh03Gk51jFV8UwXzTD7oxxvsfoasVayLGhTR+uJwLinFmW2xeTwgK05txYZSKBEYCKhK534tLKHesFumqeMidtuCXLobAEzBRQl/RS9CZ4ZLO3lRd0QIVe3yhasFXWqrLor6jDBLzLrCio6t/klzBA1pB0QyJs34MI61F2M8QxPxn+FpaUvUOAwGQOHGo8l4TkP3e2IKWjU6MTmLROnGe1c8O2kwfpMzT7kTKlMQu6Clm5jZ0LMWdLd6cNUb7zyHYAJhAqgf1pBqemjxJ1n9jHeZ20BQHHQulhY8YNILafo/cWIFOhCf+aj9Hf0/IOqf2jWocWzLLn4bXXfI66OJXR87gQ4bygV1yc7ezlHk7ILS2Y3mvQEztMtE1jlfmfbOqu4HdJ4MqsBVMv+k+00CpwFklFLEnYwt3udpnFLfC7RbAMyKTfzOiCz2LhjELJtIsPnZfJOOyq18bOoBURwY13JyR7r2Af2iB1XkfeaV4QnYMvwl84v2i/L/M6xpd5mfyj4yyfxQ9lYl8033uo6nnMRYZQV9ELqSZp4BuyRU846szV00g7uMW3A2TdnPhqf7lMSpL3pC1SdvxYTYheNBKWZTIQAdAwyrLP8gEFTEpDXWDTcmqkQqqUuzgIUResM90bFrt6iOGXhSbhzjCW+Otw+0iR7j40AO1PtmKqlgYbyD5pYBMnKMPDSBBxkki198+3yS3l1TZkvUm2eJVSvwaxbrVON4a5C7oGf92S3Y76pIGBJj5hG3EM9q+jqtuy5OJUrm44XSlNB/p+/O2IENxZmnzuzvqt7ACh3Es7bKedSYH6sm2MjzqqXZ6y8Kgj11YvYpPVQLLtxCe0B2WdW3TRNnvV7J45AZxPQd84PsqzMPre2kV7buBJqwKSdkW1oVeR5VAidzV0c6EoZGI5zoKZ05jaLbllauorGbuc/Ksrfxcchzswm0T8q5ejbGV3ln++eHjFDxxhkCdi4v+LYiZi4KNnMsuAvTG8IcF9IeVqBGFiGkXTre5zE/s9jF7EmIu/BQjCrUhkg0HGqG4XR3klpi5XcFLdBwdNWCCive6Box65xMkjJdEcMUgy6tg6bL0aKbCorTt7V9EnYRpZmbpuPOpH1uhpnhQCiIA2XpQyAmpRQa7k5K2EEfsRsqqtZV7Too0MDb5d94umpdzWPHJnGqGjW502AJlzpNvF8bSV+MIY0/idF48NgbB95DQ17WPW1QrLvc4JtEO286FpZxJjIxtFUKMmMzjVE+TqviZ/1fJPi2zWMvurMGUV5+gGo9syqfevcrqs6eRx1R/u7kEgxLO62K7Tiwsww7Pt4s3gs2RjkJqqgnXXg6nk1ycY/Gdfd2Y/dcb2FpZZf+ouKq1GCpVGt0BhVfRsx1HHo5WXQnCAAiSj520Xkh0nlL8KTaMBEQzhUmTiSm8r+QbABPBxEfUk0JcxyQAG0AqImK4BLBbazjGZMgc0xIHAQtdohwhJNWzRvhcJGQRyKty6Sy7Sha5VVXpdwGw+vA86DD0V9oxKyQG13BXp+htB9z19QdR4gYn/Tc+TiwWn1n/427oXm5yVOnn5QJHlsAho/DsCgal+l6kuThxy35sQQHWx/G1xOI2C88zrrll4bnVVUSneKMNvt423b/N+7mGv6GRtE0ofiV2otoBsPQHMy4b+G8JAzGeBkdIOC9hfBJOAxS+OLqar9dLtcOFNzgMaz35Mnj3aMFvhwvN2PfrwsntHbHu9Iw3Bg+NePE3mQjG+U4AZ/DP9C57J5uw0AY/vMdJqdlRH55ReDm6dQYejUyUUuP/NOfKpZHokzLsB4LEACg9D+lWv9JmP/J/xO14MHMd6OxfwhP8M/B/23/xszW9c/6ZQWADdrb5yEA64//nwT2Z9BOIfTyceIfpdEXrRoyYLYE2uEvu5DdEU1HBhOpVu21U3XeZLcLOrwEy7UVp0Ry159cbX+j81bZLmW3/4pgUZWh/bScltBg2hExT1qta9+dRDrXTfiXiAZEDUtz8kCq8YgLZ17noSNKGnqVjPfUwhF+JhaiqB+xxOZ0T4tTI0h+v4Pl1MoG/8Vf7ozOQatGpAEcqgVoK4t3Oe6/MpdHj5Q/muiYP9TBrD8OSjTOFcMcZiLOx3S3QEWi0Bsup9HltK/lRD4YdrNjlur6u3YtXBhGXDGi1q8SX79mt0igYpkrLAoBQbK+ZgnPxCneftbmEG4GZ6ivRXW0RYtf4iPNTzuY6BpX7tclxTMsC8iAyXsJvmcsG62tSzQKpNf6/8SVcdjDr9kI2XZOWgDbxzMy6lKppWE78yOVyAQHWVEvxnQWJCn5hi5RZxhpyA9EitLg1v+Qh89wRT/Q7RrlfozT1pz23YWeUvM8+14X2DOMNEQBIkVpwJAMiKvYH+m4jjOHctSJ5IiBweN8jE5DySjqUI7Kcc8Jxa7AJX3NAWzffwmiyyvERRcF1AgOKNKWDCycPTqKVoGYqXbuVxPoauMPzdkcaRvpgHggI0KOHHazFm09OzXULt1aqd/jBwKHctAEj5GOSpDqo+JgDVowmMsbxEbi9/FOLh10ToLUKBu1uRe9o+3+cKF1OqHWMvLsTU8abBvZnOFQB41DCy2qBrx69Pu4Vk7tts3z7MANd88byWKqkm+jMJxDbpzgGZevgmIFbZhnvDI1kpesl4KbRVmpFewBugRb6cngtOOIIYUy9budlFf3RCV3SYg/1c0+r8doOBfSjzdezVbS+EL9yZVcEEMIspaRCN05Hnf1K8KDv2Hn11p/C92h0V3qRT1jhgUgJlwFhuZfryswiItab7oNoB2ekhcFJxHdRShb426s16iJgEs9gKSOSykhg4CFTF3BZEQvFljCsOGaZr9f6dQz6e0xvpna8Ot6VbItf8RNsW7PJVKcwQuatJkrbCq0jcouzYco1ihj8nFZVYqdrXj55ClcTVp2ohv9VKLkfezCxym6Do7a38S4WmhnZSdVGZH+WfErsSXI7ci2QT2NlJl2lCj7ot8Tv65P4zU1UwK4WvxEHoNnwaXg4UgaPhJN8B6RMv4QxQjRbGDml90O+zeTOFokuDRIdFcSuxc6qLz3jxwyOrwBizeQEQ/tNv/pc7cCW6n1yY0lYq/66KrLZqlomhR4HI2s1t4/qaw4TI0k2K7V8e+grcg3KYM0qX9QObIc1RR8uDsL1fDWPRrUL7A94K58LRDrofaZtnWJggqolqpoLI2ctVAAMLloew9123JjNQ8qJXtP8up/WtF7DOwi2KX6hT/VAdWHXyN677bip5alPyJ7MBHJ7sYQCI9c9jjl5SgZZ9JCN5jPgtlMU6HioLUDlaMG1PUI01w6ajNkJXNTDnNbcF71kCv3Q+38/Upm1dJ3v0CQenD9BsmFe3SSLh4Q6gCmOALSt5KAuADWF/p4sydnvTZjp95u09Vqyr1KToBuGuOsB2vFMMiDJlWNt3/sTlA1Qc3gxAnsqLVC0PFgvEyq7vBTr0dOt0k6DoozJ6VSNlLM1QuM+LPU0kOQ5Xh6T5U/NOi4qi1APK0n/LFDEynublc2eOxQ+goJ4OCfcKhcFHVrp3lB1uiR1/7sxBj64R5+ylW94pJKJEIcsE/Y7Z+iw13HQdvwUmD1M/7fthWLVU471J4d9S14TfE6f+tNjJqpRLnrxYnVk3yCqAaU4LrX22PiDHpBEGgnNSije9YVAupNWJXJOd3LoSwoNID+PvNX2pWvN42rLfhdtaRXLRkJW+o/RbsNNYw3aeA50nEVN0v/p3hpgoon+tLNvSAkCI7DRiH0EVLS0O+Kf6NJKfMZTqNF1gOx/cEmlQ7Eu2FO/VKQBg1zLDfNHBLJ7gBzj4F5O+be6nz1eDPMVKebpiL8kEwhsIIp/qzW3BYPlE3+k40Lj+qYUl8hr6rktr5UySl/PI/eM7DdCYb/6fbQBwHEGhuYQy5skOChphhYACbBAgEwoRKKqRnx5aeBNxDgs/oNJALw/htYiOLDN1BYwMU3sDGP795AQ2KAiwKQbRKM1FAVaOPst6mgHMmLS2n8XhLKaGAVzaxG0eqWhFMwE0E4migUYlGF1JRpWzUcvbiOCmUI+WpW6Tm5qsm26gljxVtVwJaELEq55cBSzlTBULezGg1hsZQ2zCSQhUESeMoxoeCgGMdJ1FYuFTJysKpJaD8yKjRANR60lqIWRpMKq6pVSpXVVUWOjFkDVasaA/jKEZQjfO80kjGQSDpZJFZPhcWUhKY5KtEBANPkVhgJEqy5Zfp/OsDBDPjjJXAxEwF4GTxmwecVBMxmDnOZh5D5iHiVQF5DjAQpC1jIImTIUaBERRDBhBKGmnA0RBBJFNEsJoYlxLIULcuI43V0xJOAHgNGEknChJlkUkgljeWks4IMMrGQRTamv59/QGBQMIsdEhoWHjFtRIVKJ3R4rUqjOv0mjMbbhvhq1+qLrxp0qrbqoc8GTNqz65thh6y74LDIqGbRG2IuuuSN2OuuuOqIuB0tbrphW/w7H9RITEhKSeYMSk3jpmdk8rKy38rJy80vLDhqSHFRiVLvfXQsfsO0bKcp/3JcjzcfIn0Axw9CMIJiOEFSdF/9zGV5fIFQJJZIZfL4mStVao1WpzcYTWaLtSeeZWl3OF1uj9fn4OjkDGCaMRsAhycQSWQKldZvfzz3ImsGk8XmcHl8gVAklkhloFyhVKk7nqwW0vXSq2wSpGSEEZPZYu22J+66574HHrvjUbaoi6ubu4enl7ePrx8QBIZAYXAEEoXGYJcTaGgpgf4vAgaTxeYoq6iqqWtoamnr6Orp15uBoZGxiamZuYWllbWNrZ29g6OTs4urm4enl7ePLwKJQmOwODyBSCJTqDQ6g8lic7g8vgBAoUgskcrkCqVKrdHq9AAiTCjjQiptrP+ohKJqumFatuN6QvpBN4ziJM3yojRnOVAT2npVFqy9lXngG/qUnpOuo1bGfOfReDKdqVcdXyxXa116LKafMRJHF0+h2s9sd/vD8XS+XG/3x/P1/nx/h+PpDBiW4wVRkhVV0w3Tsh3X84MwipM0g3lRVnXToq4fRkymeVk3erne7o/n6/35/kAIRlAMJ0iKZliOF0RJVlRNN0zLdsqVaq3eaLbanW6vPxiOxpPpbL5Yrtab7W5/OJ6Wzsv1dn88X+/PlyApmmE5XhAlWVE13TAt23E9PwAMozhJs7woq7ppux6QWNQ8snpWf9cQkWRF1XTDtGzH9QAuCMEIiuEESdEMy+MLhCKxRCqTK5QqtUar0xuMJrPFarM7nC63x+tzcHRyBjBYHJ5AJJEpVBqdwWSxOVweXyAUiSVSGShXKFVqjRbS6Q1GGDGZLVYb6uLq5u7hGYwXsTj8zvT28Q2/KKXKlKtQqQpftU8D3E06jkRx9/l005FLtR/Fsld0GLnYl5mgcQkP+a9YnCCUnLomc29FBiGcDKdfa8L9VUwnQmHqNadyOU3xKfBccNig3HVyhut8EohqVSYwqtiDO8zCr3tQq0acGzIVs2IgKIJqcDKwic1tKixtFiP7m0WI4JOxGZ4MHNHctofLeTdt/0FEWzeWFaH0Q1QeE327Ql0QQs7pTkQxiaP9MF8cK/nfH1gtUIKP7lnhMHgiSn7jg8hANMAYEiMVSocMFTITz1PmYVMxsB/2sTBXLBtY20oD3GhYakhtlUVM1SCrSW2vA3bru1zTyNeZCJyhwclc5hnzFtMwlgxNHGOdDGZd567zrCMbvmkZW2KsFlY2w86QHsnIztKipm3QV4G9dAlQ/clkZzyPNsiekhGdDXPd8evOuG+ac88wKNx4TPhg2j/voWFFtPLDH7iJgxbgSIcOwPg0rG4M6jry0Zosgk7MM62V05GNrX5lKlG1Bh6AA78ypXyj7uB7eL3FNzuOYLL9Eflmx4JNSKM6x7/SbjLa+76vZlWz23x07/tlSgO0WdTT64CF08SXofV/6TdtbIJFpSEHq/X6U4pwXRklOOUlK5kqhSoPUTJ/CqUhbbQLmKiZWFvwosSaWmur6qR8bSoolzp3c3X5XfVw/CdilbNVaZcNFybfVygvNwNW8koTwDyLNahSKg9aVbaWQeRr9MYgeH6f01CYqhsikmNdL93zcW1/4ciTbhalEy3IlACp+5FY8eNuaZ+IpGPz6EKQPw7WXWdaQSIBVI0JUCHXqk445GC1kxIX45DmMaGMJxUhAIEGkDEBAIBSSimllNLLMTjn/BkkEKCMC7lWTcIEaApSSqmUUkop9RW4N9BiQpgAZVzIFPBLAdXoR365zaP/rKPr4N29f5QrToupe8Yvplcoi3zP4L7HSXE27eUfxavnu+5qcSoXFk3OWVq2ipY3LYxW+Gw8Xe/zuD9vLaZ4SdmEuJml/DWjn9c1LDQtt8sZS38KaDrrGkx+F0GtmxK8XuG0dFesIrJU3/jMa/QJitVTkzKukOvBADZ+D/kr7o/96bRf3quLpCSvBUlLD80Nv/QYN2ya2+rHBT1ZF4uw5o5RF8ub5g0jMRds5Cv6SUHJ0tvl6XpBXonRBcyxtG/S2AUwAcq4kEpPZw0+hDsOCya3Al66yrkLhsnkN/jwsiWa+bs6pL/FbzmPb8f1p54dGRD/9VNtr4/LlCizPdEH9Uaxi/jAx/znejyG+yKw7dsvRW3GzDAz43UmQBkXUmnHNV72DAKYAGVcSKUd13jZJmEClHGptOMaL9sSoIwLqbTjGi/bJkyAMi6k0o5rvGwPYQKUcSGVdlzjZXuZAGVcSKUd1+R1CBOgjAuptOMaL9tHmABlXEilHdd42S5hApRxIZV2XOPNuxgRJkAZF1JpxzVetkyYvHFfOBsAEIIRFMMJkmZYjk/oASAEIyiGEyTNsByf0AtACEZQDCcZluMTOgCEYATFcIKkGZbjE/oACMEIiuEESTMsxyd0AYigGE5gkM9L8rr/ZaD9/8LClfLvyjfsgmdjDuZ0eE4ZdRA+FHEQVA+eAtsb9YIGJZBk0toLVWueXeGOBetbaB9mk/3W5dS5VXZmdlTXGfoct36sYr2qL/XJNpRF/Acsk88i/tOjxW/wQsp/sNATaLLgvxvw3jAWTHBvLkEFMs4GQUTT6q9V2r6UB0HVw+1LtRqICtHqWH3+tA8Gy/puMNWv2kO9fMweXNPi4Vz+UKzusgwu/94z+XMYOYkHLcIPmqmNw6niI/48xjfttP5fKvZT93A15Q8nU/Swj+jD3uRD7NL7Xa2mf5uqjPvhAUA0BA/KCR7e4Q8Un/8dGKCPYwz0DfRnApezQut8y7U2cnhGE8BnSxa7bh4dh5Pih/n4hA2In9dfPj6gcjrHaWEhTrvI38UMnw5JkbiXL7WefvnqtdY4XumXkQDSqK05DQAA)format("woff2")}@font-face{font-family:"Open Sans";font-style:italic;font-weight:400;src:local("Open Sans Italic"),local("OpenSans-Italic"),url(data:font/woff2;base64,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)format("woff2")}@font-face{font-family:"Open Sans";font-style:normal;font-weight:600;src:local("Open Sans SemiBold"),local("OpenSans-SemiBold"),url(data:font/woff2;base64,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)format("woff2")}@font-face{font-family:"Open Sans";font-style:italic;font-weight:600;src:local("Open Sans SemiBold Italic"),local("OpenSans-SemiBoldItalic"),url(data:font/woff2;base64,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)format("woff2")}@font-face{font-family:"Open Sans";font-style:normal;font-weight:700;src:local("Open Sans Bold"),local("OpenSans-Bold"),url(data:font/woff2;base64,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)format("woff2")}@font-face{font-family:"Open Sans";font-style:italic;font-weight:700;src:local("Open Sans Bold Italic"),local("OpenSans-BoldItalic"),url(data:font/woff2;base64,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)format("woff2")}@font-face{font-family:"Open Sans";font-style:normal;font-weight:800;src:local("Open Sans ExtraBold"),local("OpenSans-ExtraBold"),url(data:font/woff2;base64,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)format("woff2")}@font-face{font-family:"Open Sans";font-style:italic;font-weight:800;src:local("Open Sans ExtraBold Italic"),local("OpenSans-ExtraBoldItalic"),url(data:font/woff2;base64,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)format("woff2")}@font-face{font-family:"Source Code Pro";font-style:normal;font-weight:500;src:url(data:font/woff2;base64,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)format("woff2")}</style>
        <!-- Highlight.js Stylesheets -->
        <style>.hljs-comment,.hljs-quote{color:#575757}.hljs-variable,.hljs-template-variable,.hljs-attribute,.hljs-tag,.hljs-name,.hljs-regexp,.hljs-link,.hljs-name,.hljs-selector-id,.hljs-selector-class{color:#d70025}.hljs-number,.hljs-meta,.hljs-built_in,.hljs-builtin-name,.hljs-literal,.hljs-type,.hljs-params{color:#b21e00}.hljs-string,.hljs-symbol,.hljs-bullet{color:#008200}.hljs-title,.hljs-section{color:#0030f2}.hljs-keyword,.hljs-selector-tag{color:#9d00ec}.hljs{display:block;overflow-x:auto;background:#f6f7f6;color:#000;padding:0.5em}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:bold}.hljs-addition{color:#22863a;background-color:#f0fff4}.hljs-deletion{color:#b31d28;background-color:#ffeef0}</style>

        <!-- Custom theme stylesheets -->
        <style>code.info:before{content:"ï";font-family:"FontAwesome";font-style:normal;font-size:12pt;margin-left:-30px;display:block;position:absolute;color:#718c00}code.info{font-style:italic}code.error:before{content:"ï±";font-family:"FontAwesome";font-style:normal;font-size:12pt;margin-left:-30px;display:block;position:absolute;color:#ff0000}code.error{color:#ff0000}code.warning:before{content:"ïª";font-family:"FontAwesome";font-style:normal;font-size:12pt;margin-left:-30px;display:block;position:absolute;color:#ffcc00}.equational{width:80%;margin:auto}.equational pre{margin:0}.equational div.term,.equational div.explanation{display:block}.equational .explanation code{font-style:normal}.equational .explanation{padding-left:1.5em!important}</style>
        <style>td.linenos .normal{color:inherit;background-color:transparent;padding-left:5px;padding-right:5px}span.linenos{color:inherit;background-color:transparent;padding-left:5px;padding-right:5px}td.linenos .special{color:#000000;background-color:#ffffc0;padding-left:5px;padding-right:5px}span.linenos.special{color:#000000;background-color:#ffffc0;padding-left:5px;padding-right:5px}.highlight .hll,.code .hll{background-color:#ffffcc}.highlight .c,.code .c{color:#555753;font-style:italic}.highlight .err,.code .err{color:#a40000;border:1px solid #cc0000}.highlight .g,.code .g{color:#000000}.highlight .k,.code .k{color:#8f5902}.highlight .l,.code .l{color:#2e3436}.highlight .n,.code .n{color:#000000}.highlight .o,.code .o{color:#000000}.highlight .x,.code .x{color:#2e3436}.highlight .p,.code .p{color:#000000}.highlight .ch,.code .ch{color:#555753;font-weight:bold;font-style:italic}.highlight .cm,.code .cm{color:#555753;font-style:italic}.highlight .cp,.code .cp{color:#3465a4;font-style:italic}.highlight .cpf,.code .cpf{color:#555753;font-style:italic}.highlight .c1,.code .c1{color:#555753;font-style:italic}.highlight .cs,.code .cs{color:#3465a4;font-weight:bold;font-style:italic}.highlight .gd,.code .gd{color:#a40000}.highlight .ge,.code .ge{color:#000000;font-style:italic}.highlight .gr,.code .gr{color:#a40000}.highlight .gh,.code .gh{color:#a40000;font-weight:bold}.highlight .gi,.code .gi{color:#4e9a06}.highlight .go,.code .go{color:#000000;font-style:italic}.highlight .gp,.code .gp{color:#8f5902}.highlight .gs,.code .gs{color:#000000;font-weight:bold}.highlight .gu,.code .gu{color:#000000;font-weight:bold}.highlight .gt,.code .gt{color:#000000;font-style:italic}.highlight .kc,.code .kc{color:#204a87;font-weight:bold}.highlight .kd,.code .kd{color:#4e9a06;font-weight:bold}.highlight .kn,.code .kn{color:#4e9a06;font-weight:bold}.highlight .kp,.code .kp{color:#204a87}.highlight .kr,.code .kr{color:#8f5902}.highlight .kt,.code .kt{color:#204a87}.highlight .ld,.code .ld{color:#2e3436}.highlight .m,.code .m{color:#2e3436}.highlight .s,.code .s{color:#ad7fa8}.highlight .na,.code .na{color:#c4a000}.highlight .nb,.code .nb{color:#75507b}.highlight .nc,.code .nc{color:#204a87}.highlight .no,.code .no{color:#ce5c00}.highlight .nd,.code .nd{color:#3465a4;font-weight:bold}.highlight .ni,.code .ni{color:#c4a000;text-decoration:underline}.highlight .ne,.code .ne{color:#cc0000}.highlight .nf,.code .nf{color:#a40000}.highlight .nl,.code .nl{color:#3465a4;font-weight:bold}.highlight .nn,.code .nn{color:#000000}.highlight .nx,.code .nx{color:#000000}.highlight .py,.code .py{color:#000000}.highlight .nt,.code .nt{color:#a40000}.highlight .nv,.code .nv{color:#ce5c00}.highlight .ow,.code .ow{color:#8f5902}.highlight .w,.code .w{color:#d3d7cf;text-decoration:underline}.highlight .mb,.code .mb{color:#2e3436}.highlight .mf,.code .mf{color:#2e3436}.highlight .mh,.code .mh{color:#2e3436}.highlight .mi,.code .mi{color:#2e3436}.highlight .mo,.code .mo{color:#2e3436}.highlight .sa,.code .sa{color:#ad7fa8}.highlight .sb,.code .sb{color:#ad7fa8}.highlight .sc,.code .sc{color:#ad7fa8;font-weight:bold}.highlight .dl,.code .dl{color:#ad7fa8}.highlight .sd,.code .sd{color:#ad7fa8}.highlight .s2,.code .s2{color:#ad7fa8}.highlight .se,.code .se{color:#ad7fa8;font-weight:bold}.highlight .sh,.code .sh{color:#ad7fa8;text-decoration:underline}.highlight .si,.code .si{color:#ce5c00}.highlight .sx,.code .sx{color:#ad7fa8}.highlight .sr,.code .sr{color:#ad7fa8}.highlight .s1,.code .s1{color:#ad7fa8}.highlight .ss,.code .ss{color:#8f5902}.highlight .bp,.code .bp{color:#5c35cc}.highlight .fm,.code .fm{color:#a40000}.highlight .vc,.code .vc{color:#ce5c00}.highlight .vg,.code .vg{color:#ce5c00;text-decoration:underline}.highlight .vi,.code .vi{color:#ce5c00}.highlight .vm,.code .vm{color:#ce5c00}.highlight .il,.code .il{color:#2e3436}.hljs-doctag{color:green}.hljs-comment{color:green}</style>
        <!-- MathJax -->
        
    <style type="text/css">.MathJax_Hover_Frame{border-radius:.25em;-webkit-border-radius:.25em;-moz-border-radius:.25em;-khtml-border-radius:.25em;box-shadow:0px 0px 15px #83A;-webkit-box-shadow:0px 0px 15px #83A;-moz-box-shadow:0px 0px 15px #83A;-khtml-box-shadow:0px 0px 15px #83A;border:1px solid #A6D!important;display:inline-block;position:absolute}.MathJax_Menu_Button .MathJax_Hover_Arrow{position:absolute;cursor:pointer;display:inline-block;border:2px solid #AAA;border-radius:4px;-webkit-border-radius:4px;-moz-border-radius:4px;-khtml-border-radius:4px;font-family:"Courier New",Courier;font-size:9px;color:#F0F0F0}.MathJax_Menu_Button .MathJax_Hover_Arrow span{display:block;background-color:#AAA;border:1px solid;border-radius:3px;line-height:0;padding:4px}.MathJax_Hover_Arrow:hover{color:white!important;border:2px solid #CCC!important}.MathJax_Hover_Arrow:hover span{background-color:#CCC!important}</style><style type="text/css">#MathJax_About{position:fixed;left:50%;width:auto;text-align:center;border:3px outset;padding:1em 2em;background-color:#DDDDDD;color:black;cursor:default;font-family:message-box;font-size:120%;font-style:normal;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;border-radius:15px;-webkit-border-radius:15px;-moz-border-radius:15px;-khtml-border-radius:15px;box-shadow:0px 10px 20px #808080;-webkit-box-shadow:0px 10px 20px #808080;-moz-box-shadow:0px 10px 20px #808080;-khtml-box-shadow:0px 10px 20px #808080;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}#MathJax_About.MathJax_MousePost{outline:none}.MathJax_Menu{position:absolute;background-color:white;color:black;width:auto;padding:5px 0px;border:1px solid #CCCCCC;margin:0;cursor:default;font:menu;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;border-radius:5px;-webkit-border-radius:5px;-moz-border-radius:5px;-khtml-border-radius:5px;box-shadow:0px 10px 20px #808080;-webkit-box-shadow:0px 10px 20px #808080;-moz-box-shadow:0px 10px 20px #808080;-khtml-box-shadow:0px 10px 20px #808080;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_MenuItem{padding:1px 2em;background:transparent}.MathJax_MenuArrow{position:absolute;right:.5em;padding-top:.25em;color:#666666;font-size:.75em}.MathJax_MenuActive .MathJax_MenuArrow{color:white}.MathJax_MenuArrow.RTL{left:.5em;right:auto}.MathJax_MenuCheck{position:absolute;left:.7em}.MathJax_MenuCheck.RTL{right:.7em;left:auto}.MathJax_MenuRadioCheck{position:absolute;left:.7em}.MathJax_MenuRadioCheck.RTL{right:.7em;left:auto}.MathJax_MenuLabel{padding:1px 2em 3px 1.33em;font-style:italic}.MathJax_MenuRule{border-top:1px solid #DDDDDD;margin:4px 3px}.MathJax_MenuDisabled{color:GrayText}.MathJax_MenuActive{background-color:#606872;color:white}.MathJax_MenuDisabled:focus,.MathJax_MenuLabel:focus{background-color:#E8E8E8}.MathJax_ContextMenu:focus{outline:none}.MathJax_ContextMenu .MathJax_MenuItem:focus{outline:none}#MathJax_AboutClose{top:.2em;right:.2em}.MathJax_Menu .MathJax_MenuClose{top:-10px;left:-10px}.MathJax_MenuClose{position:absolute;cursor:pointer;display:inline-block;border:2px solid #AAA;border-radius:18px;-webkit-border-radius:18px;-moz-border-radius:18px;-khtml-border-radius:18px;font-family:"Courier New",Courier;font-size:24px;color:#F0F0F0}.MathJax_MenuClose span{display:block;background-color:#AAA;border:1.5px solid;border-radius:18px;-webkit-border-radius:18px;-moz-border-radius:18px;-khtml-border-radius:18px;line-height:0;padding:8px 0 6px}.MathJax_MenuClose:hover{color:white!important;border:2px solid #CCC!important}.MathJax_MenuClose:hover span{background-color:#CCC!important}.MathJax_MenuClose:hover:focus{outline:none}</style><style type="text/css">.MathJax_Preview .MJXf-math{color:inherit!important}</style><style type="text/css">.MJX_Assistive_MathML{position:absolute!important;top:0;left:0;clip:rect(1px,1px,1px,1px);padding:1px 0 0 0!important;border:0!important;height:1px!important;width:1px!important;overflow:hidden!important;display:block!important;-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.MJX_Assistive_MathML.MJX_Assistive_MathML_Block{width:100%!important}</style><style type="text/css">#MathJax_Zoom{position:absolute;background-color:#F0F0F0;overflow:auto;display:block;z-index:301;padding:.5em;border:1px solid black;margin:0;font-weight:normal;font-style:normal;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;box-shadow:5px 5px 15px #AAAAAA;-webkit-box-shadow:5px 5px 15px #AAAAAA;-moz-box-shadow:5px 5px 15px #AAAAAA;-khtml-box-shadow:5px 5px 15px #AAAAAA;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}#MathJax_ZoomOverlay{position:absolute;left:0;top:0;z-index:300;display:inline-block;width:100%;height:100%;border:0;padding:0;margin:0;background-color:white;opacity:0;filter:alpha(opacity=0)}#MathJax_ZoomFrame{position:relative;display:inline-block;height:0;width:0}#MathJax_ZoomEventTrap{position:absolute;left:0;top:0;z-index:302;display:inline-block;border:0;padding:0;margin:0;background-color:white;opacity:0;filter:alpha(opacity=0)}</style><style type="text/css">.MathJax_Preview{color:#888}#MathJax_Message{position:fixed;left:1em;bottom:1.5em;background-color:#E6E6E6;border:1px solid #959595;margin:0px;padding:2px 8px;z-index:102;color:black;font-size:80%;width:auto;white-space:nowrap}#MathJax_MSIE_Frame{position:absolute;top:0;left:0;width:0px;z-index:101;border:0px;margin:0px;padding:0px}.MathJax_Error{color:#CC0000;font-style:italic}</style><style type="text/css">.MJXp-script{font-size:.8em}.MJXp-right{-webkit-transform-origin:right;-moz-transform-origin:right;-ms-transform-origin:right;-o-transform-origin:right;transform-origin:right}.MJXp-bold{font-weight:bold}.MJXp-italic{font-style:italic}.MJXp-scr{font-family:MathJax_Script,"Times New Roman",Times,STIXGeneral,serif}.MJXp-frak{font-family:MathJax_Fraktur,"Times New Roman",Times,STIXGeneral,serif}.MJXp-sf{font-family:MathJax_SansSerif,"Times New Roman",Times,STIXGeneral,serif}.MJXp-cal{font-family:MathJax_Caligraphic,"Times New Roman",Times,STIXGeneral,serif}.MJXp-mono{font-family:MathJax_Typewriter,"Times New Roman",Times,STIXGeneral,serif}.MJXp-largeop{font-size:150%}.MJXp-largeop.MJXp-int{vertical-align:-.2em}.MJXp-math{display:inline-block;line-height:1.2;text-indent:0;font-family:"Times New Roman",Times,STIXGeneral,serif;white-space:nowrap;border-collapse:collapse}.MJXp-display{display:block;text-align:center;margin:1em 0}.MJXp-math span{display:inline-block}.MJXp-box{display:block!important;text-align:center}.MJXp-box:after{content:" "}.MJXp-rule{display:block!important;margin-top:.1em}.MJXp-char{display:block!important}.MJXp-mo{margin:0 .15em}.MJXp-mfrac{margin:0 .125em;vertical-align:.25em}.MJXp-denom{display:inline-table!important;width:100%}.MJXp-denom>*{display:table-row!important}.MJXp-surd{vertical-align:top}.MJXp-surd>*{display:block!important}.MJXp-script-box>*{display:table!important;height:50%}.MJXp-script-box>*>*{display:table-cell!important;vertical-align:top}.MJXp-script-box>*:last-child>*{vertical-align:bottom}.MJXp-script-box>*>*>*{display:block!important}.MJXp-mphantom{visibility:hidden}.MJXp-munderover{display:inline-table!important}.MJXp-over{display:inline-block!important;text-align:center}.MJXp-over>*{display:block!important}.MJXp-munderover>*{display:table-row!important}.MJXp-mtable{vertical-align:.25em;margin:0 .125em}.MJXp-mtable>*{display:inline-table!important;vertical-align:middle}.MJXp-mtr{display:table-row!important}.MJXp-mtd{display:table-cell!important;text-align:center;padding:.5em 0 0 .5em}.MJXp-mtr>.MJXp-mtd:first-child{padding-left:0}.MJXp-mtr:first-child>.MJXp-mtd{padding-top:0}.MJXp-mlabeledtr{display:table-row!important}.MJXp-mlabeledtr>.MJXp-mtd:first-child{padding-left:0}.MJXp-mlabeledtr:first-child>.MJXp-mtd{padding-top:0}.MJXp-merror{background-color:#FFFF88;color:#CC0000;border:1px solid #CC0000;padding:1px 3px;font-style:normal;font-size:90%}.MJXp-scale0{-webkit-transform:scaleX(.0);-moz-transform:scaleX(.0);-ms-transform:scaleX(.0);-o-transform:scaleX(.0);transform:scaleX(.0)}.MJXp-scale1{-webkit-transform:scaleX(.1);-moz-transform:scaleX(.1);-ms-transform:scaleX(.1);-o-transform:scaleX(.1);transform:scaleX(.1)}.MJXp-scale2{-webkit-transform:scaleX(.2);-moz-transform:scaleX(.2);-ms-transform:scaleX(.2);-o-transform:scaleX(.2);transform:scaleX(.2)}.MJXp-scale3{-webkit-transform:scaleX(.3);-moz-transform:scaleX(.3);-ms-transform:scaleX(.3);-o-transform:scaleX(.3);transform:scaleX(.3)}.MJXp-scale4{-webkit-transform:scaleX(.4);-moz-transform:scaleX(.4);-ms-transform:scaleX(.4);-o-transform:scaleX(.4);transform:scaleX(.4)}.MJXp-scale5{-webkit-transform:scaleX(.5);-moz-transform:scaleX(.5);-ms-transform:scaleX(.5);-o-transform:scaleX(.5);transform:scaleX(.5)}.MJXp-scale6{-webkit-transform:scaleX(.6);-moz-transform:scaleX(.6);-ms-transform:scaleX(.6);-o-transform:scaleX(.6);transform:scaleX(.6)}.MJXp-scale7{-webkit-transform:scaleX(.7);-moz-transform:scaleX(.7);-ms-transform:scaleX(.7);-o-transform:scaleX(.7);transform:scaleX(.7)}.MJXp-scale8{-webkit-transform:scaleX(.8);-moz-transform:scaleX(.8);-ms-transform:scaleX(.8);-o-transform:scaleX(.8);transform:scaleX(.8)}.MJXp-scale9{-webkit-transform:scaleX(.9);-moz-transform:scaleX(.9);-ms-transform:scaleX(.9);-o-transform:scaleX(.9);transform:scaleX(.9)}.MathJax_PHTML .noError{vertical-align:;font-size:90%;text-align:left;color:black;padding:1px 3px;border:1px solid}</style><style type="text/css">.MathJax_Display{text-align:center;margin:1em 0em;position:relative;display:block!important;text-indent:0;max-width:none;max-height:none;min-width:0;min-height:0;width:100%}.MathJax .merror{background-color:#FFFF88;color:#CC0000;border:1px solid #CC0000;padding:1px 3px;font-style:normal;font-size:90%}.MathJax .MJX-monospace{font-family:monospace}.MathJax .MJX-sans-serif{font-family:sans-serif}#MathJax_Tooltip{background-color:InfoBackground;color:InfoText;border:1px solid black;box-shadow:2px 2px 5px #AAAAAA;-webkit-box-shadow:2px 2px 5px #AAAAAA;-moz-box-shadow:2px 2px 5px #AAAAAA;-khtml-box-shadow:2px 2px 5px #AAAAAA;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true');padding:3px 4px;z-index:401;position:absolute;left:0;top:0;width:auto;height:auto;display:none}.MathJax{display:inline;font-style:normal;font-weight:normal;line-height:normal;font-size:100%;font-size-adjust:none;text-indent:0;text-align:left;text-transform:none;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;direction:ltr;max-width:none;max-height:none;min-width:0;min-height:0;border:0;padding:0;margin:0}.MathJax:focus,body :focus .MathJax{display:inline-table}.MathJax.MathJax_FullWidth{text-align:center;display:table-cell!important;width:10000em!important}.MathJax img,.MathJax nobr,.MathJax a{border:0;padding:0;margin:0;max-width:none;max-height:none;min-width:0;min-height:0;vertical-align:0;line-height:normal;text-decoration:none}img.MathJax_strut{border:0!important;padding:0!important;margin:0!important;vertical-align:0!important}.MathJax span{display:inline;position:static;border:0;padding:0;margin:0;vertical-align:0;line-height:normal;text-decoration:none}.MathJax nobr{white-space:nowrap!important}.MathJax img{display:inline!important;float:none!important}.MathJax *{transition:none;-webkit-transition:none;-moz-transition:none;-ms-transition:none;-o-transition:none}.MathJax_Processing{visibility:hidden;position:fixed;width:0;height:0;overflow:hidden}.MathJax_Processed{display:none!important}.MathJax_ExBox{display:block!important;overflow:hidden;width:1px;height:60ex;min-height:0;max-height:none}.MathJax .MathJax_EmBox{display:block!important;overflow:hidden;width:1px;height:60em;min-height:0;max-height:none}.MathJax_LineBox{display:table!important}.MathJax_LineBox span{display:table-cell!important;width:10000em!important;min-width:0;max-width:none;padding:0;border:0;margin:0}.MathJax .MathJax_HitBox{cursor:text;background:white;opacity:0;filter:alpha(opacity=0)}.MathJax .MathJax_HitBox *{filter:none;opacity:1;background:transparent}#MathJax_Tooltip *{filter:none;opacity:1;background:transparent}@font-face{font-family:MathJax_Blank;src:url(about:blank)}.MathJax .noError{vertical-align:;font-size:90%;text-align:left;color:black;padding:1px 3px;border:1px solid}</style><meta name="referrer" content="no-referrer"><link rel="shortcut icon" href="data:image/png;base64,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"><link rel="canonical" href="https://leanprover.github.io/functional_programming_in_lean/print.html"><style>img[src="data:,"],source[src="data:,"]{display:none!important}</style><link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>
    <body>
<div id="book-container">
    <div style="visibility:hidden;overflow:hidden;position:absolute;top:0px;height:1px;width:auto;padding:0px;border:0px;margin:0px;text-align:left;text-indent:0px;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal"><div id="MathJax_Hidden"></div></div><div id="MathJax_Message" style="display:none"></div>
        <!-- Provide site root to javascript -->
        

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        

        <!-- Set the theme before any content is loaded, prevents flash -->
        

        <!-- Hide / unhide sidebar before it is displayed -->
        

        <nav id="sidebar" aria-label="Table of contents" aria-hidden="false">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="https://leanprover.github.io/functional_programming_in_lean/title.html" tabindex="0">Functional Programming in Lean</a></li><li class="chapter-item expanded affix "><a href="https://leanprover.github.io/functional_programming_in_lean/introduction.html" tabindex="0">Introduction</a></li><li class="chapter-item expanded affix "><a href="https://leanprover.github.io/functional_programming_in_lean/acknowledgments.html" tabindex="0">Acknowledgments</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know.html" tabindex="0"><strong aria-hidden="true">1.</strong> Getting to Know Lean</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/evaluating.html" tabindex="0"><strong aria-hidden="true">1.1.</strong> Evaluating Expressions</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/types.html" tabindex="0"><strong aria-hidden="true">1.2.</strong> Types</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/functions-and-definitions.html" tabindex="0"><strong aria-hidden="true">1.3.</strong> Functions and Definitions</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/structures.html" tabindex="0"><strong aria-hidden="true">1.4.</strong> Structures</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/datatypes-and-patterns.html" tabindex="0"><strong aria-hidden="true">1.5.</strong> Datatypes, Patterns and Recursion</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/polymorphism.html" tabindex="0"><strong aria-hidden="true">1.6.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/conveniences.html" tabindex="0"><strong aria-hidden="true">1.7.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/summary.html" tabindex="0"><strong aria-hidden="true">1.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/hello-world.html" tabindex="0"><strong aria-hidden="true">2.</strong> Hello, World!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/hello-world/running-a-program.html" tabindex="0"><strong aria-hidden="true">2.1.</strong> Running a Program</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/hello-world/step-by-step.html" tabindex="0"><strong aria-hidden="true">2.2.</strong> Step By Step</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/hello-world/starting-a-project.html" tabindex="0"><strong aria-hidden="true">2.3.</strong> Starting a Project</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/hello-world/cat.html" tabindex="0"><strong aria-hidden="true">2.4.</strong> Worked Example: cat</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/hello-world/conveniences.html" tabindex="0"><strong aria-hidden="true">2.5.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/hello-world/summary.html" tabindex="0"><strong aria-hidden="true">2.6.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/props-proofs-indexing.html" tabindex="0"><strong aria-hidden="true">3.</strong> Interlude: Propositions, Proofs, and Indexing</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/type-classes.html" tabindex="0"><strong aria-hidden="true">4.</strong> Overloading and Type Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/type-classes/pos.html" tabindex="0"><strong aria-hidden="true">4.1.</strong> Positive Numbers</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/type-classes/polymorphism.html" tabindex="0"><strong aria-hidden="true">4.2.</strong> Type Classes and Polymorphism</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/type-classes/out-params.html" tabindex="0"><strong aria-hidden="true">4.3.</strong> Controlling Instance Search</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/type-classes/indexing.html" tabindex="0"><strong aria-hidden="true">4.4.</strong> Arrays and Indexing</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/type-classes/standard-classes.html" tabindex="0"><strong aria-hidden="true">4.5.</strong> Standard Classes</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/type-classes/coercion.html" tabindex="0"><strong aria-hidden="true">4.6.</strong> Coercions</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/type-classes/conveniences.html" tabindex="0"><strong aria-hidden="true">4.7.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/type-classes/summary.html" tabindex="0"><strong aria-hidden="true">4.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/monads.html" tabindex="0"><strong aria-hidden="true">5.</strong> Monads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/monads/class.html" tabindex="0"><strong aria-hidden="true">5.1.</strong> The Monad Type Class</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/monads/arithmetic.html" tabindex="0"><strong aria-hidden="true">5.2.</strong> Example: Arithmetic in Monads</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/monads/do.html" tabindex="0"><strong aria-hidden="true">5.3.</strong> do-Notation for Monads</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/monads/io.html" tabindex="0"><strong aria-hidden="true">5.4.</strong> The IO Monad</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/monads/conveniences.html" tabindex="0"><strong aria-hidden="true">5.5.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/monads/summary.html" tabindex="0"><strong aria-hidden="true">5.6.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/functor-applicative-monad.html" tabindex="0"><strong aria-hidden="true">6.</strong> Functors, Applicative Functors, and Monads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/functor-applicative-monad/inheritance.html" tabindex="0"><strong aria-hidden="true">6.1.</strong> Structures and Inheritance</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/functor-applicative-monad/applicative.html" tabindex="0"><strong aria-hidden="true">6.2.</strong> Applicative Functors</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/functor-applicative-monad/applicative-contract.html" tabindex="0"><strong aria-hidden="true">6.3.</strong> The Applicative Contract</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/functor-applicative-monad/alternative.html" tabindex="0"><strong aria-hidden="true">6.4.</strong> Alternatives</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/functor-applicative-monad/universes.html" tabindex="0"><strong aria-hidden="true">6.5.</strong> Universes</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/functor-applicative-monad/complete.html" tabindex="0"><strong aria-hidden="true">6.6.</strong> The Complete Definitions</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/functor-applicative-monad/summary.html" tabindex="0"><strong aria-hidden="true">6.7.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/monad-transformers.html" tabindex="0"><strong aria-hidden="true">7.</strong> Monad Transformers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/monad-transformers/reader-io.html" tabindex="0"><strong aria-hidden="true">7.1.</strong> Combining IO and Reader</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/monad-transformers/transformers.html" tabindex="0"><strong aria-hidden="true">7.2.</strong> A Monad Construction Kit</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/monad-transformers/order.html" tabindex="0"><strong aria-hidden="true">7.3.</strong> Ordering Monad Transformers</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/monad-transformers/do.html" tabindex="0"><strong aria-hidden="true">7.4.</strong> More do Features</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/monad-transformers/conveniences.html" tabindex="0"><strong aria-hidden="true">7.5.</strong> Additional Conveniences</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/monad-transformers/summary.html" tabindex="0"><strong aria-hidden="true">7.6.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/dependent-types.html" tabindex="0"><strong aria-hidden="true">8.</strong> Programming with Dependent Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/dependent-types/indexed-families.html" tabindex="0"><strong aria-hidden="true">8.1.</strong> Indexed Families</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/dependent-types/universe-pattern.html" tabindex="0"><strong aria-hidden="true">8.2.</strong> The Universe Design Pattern</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/dependent-types/typed-queries.html" tabindex="0"><strong aria-hidden="true">8.3.</strong> Worked Example: Typed Queries</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/dependent-types/indices-parameters-universes.html" tabindex="0"><strong aria-hidden="true">8.4.</strong> Indices, Parameters, and Universe Levels</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/dependent-types/pitfalls.html" tabindex="0"><strong aria-hidden="true">8.5.</strong> Pitfalls of Programming with Dependent Types</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/dependent-types/summary.html" tabindex="0"><strong aria-hidden="true">8.6.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/tactics-induction-proofs.html" tabindex="0"><strong aria-hidden="true">9.</strong> Interlude: Tactics, Induction, and Proofs</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/programs-proofs.html" tabindex="0"><strong aria-hidden="true">10.</strong> Programming, Proving, and Performance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/programs-proofs/tail-recursion.html" tabindex="0"><strong aria-hidden="true">10.1.</strong> Tail Recursion</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/programs-proofs/tail-recursion-proofs.html" tabindex="0"><strong aria-hidden="true">10.2.</strong> Proving Equivalence</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/programs-proofs/arrays-termination.html" tabindex="0"><strong aria-hidden="true">10.3.</strong> Arrays and Termination</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/programs-proofs/inequalities.html" tabindex="0"><strong aria-hidden="true">10.4.</strong> More Inequalities</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/programs-proofs/fin.html" tabindex="0"><strong aria-hidden="true">10.5.</strong> Safe Array Indices</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/programs-proofs/insertion-sort.html" tabindex="0"><strong aria-hidden="true">10.6.</strong> Insertion Sort and Array Mutation</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/programs-proofs/special-types.html" tabindex="0"><strong aria-hidden="true">10.7.</strong> Special Types</a></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/programs-proofs/summary.html" tabindex="0"><strong aria-hidden="true">10.8.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="https://leanprover.github.io/functional_programming_in_lean/next-steps.html" tabindex="0">Next Steps</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper">

            <div>
                
                

                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                

                <div id="content">
                    <main>
                        <h1 id="functional-programming-in-lean"><a class="header" href="#functional-programming-in-lean">Functional Programming in Lean</a></h1>
<p><em>by David Thrane Christiansen</em></p>
<p><em>Copyright Microsoft Corporation 2023</em></p>
<p>This is a free book on using Lean 4 as a programming language. All code samples are tested with Lean 4 release <code class="hljs">4.1.0</code>.</p>
<h2 id="release-history"><a class="header" href="#release-history">Release history</a></h2>
<h3 id="january-2024"><a class="header" href="#january-2024">January, 2024</a></h3>
<p>This is a minor bugfix release that fixes a regression in an example program.</p>
<h3 id="october-2023"><a class="header" href="#october-2023">October, 2023</a></h3>
<p>In this first maintenance release, a number of smaller issues were fixed and the text was brought up to date with the latest release of Lean.</p>
<h3 id="may-2023"><a class="header" href="#may-2023">May, 2023</a></h3>
<p>The book is now complete! Compared to the April pre-release, many small details have been improved and minor mistakes have been fixed.</p>
<h3 id="april-2023"><a class="header" href="#april-2023">April, 2023</a></h3>
<p>This release adds an interlude on writing proofs with tactics as well as a final chapter that combines discussion of performance and cost models with proofs of termination and program equivalence.
This is the last release prior to the final release.</p>
<h3 id="march-2023"><a class="header" href="#march-2023">March, 2023</a></h3>
<p>This release adds a chapter on programming with dependent types and indexed families.</p>
<h3 id="january-2023"><a class="header" href="#january-2023">January, 2023</a></h3>
<p>This release adds a chapter on monad transformers that includes a description of the imperative features that are available in <code class="hljs">do</code>-notation.</p>
<h3 id="december-2022"><a class="header" href="#december-2022">December, 2022</a></h3>
<p>This release adds a chapter on applicative functors that additionally describes structures and type classes in more detail.
This is accompanied with improvements to the description of monads.
The December 2022 release was delayed until January 2023 due to winter holidays.</p>
<h3 id="november-2022"><a class="header" href="#november-2022">November, 2022</a></h3>
<p>This release adds a chapter on programming with monads. Additionally, the example of using JSON in the coercions section has been updated to include the complete code.</p>
<h3 id="october-2022"><a class="header" href="#october-2022">October, 2022</a></h3>
<p>This release completes the chapter on type classes. In addition, a short interlude introducing propositions, proofs, and tactics has been added just before the chapter on type classes, because a small amount of familiarity with the concepts helps to understand some of the standard library type classes.</p>
<h3 id="september-2022"><a class="header" href="#september-2022">September, 2022</a></h3>
<p>This release adds the first half of a chapter on type classes, which are Lean's mechanism for overloading operators and an important means of organizing code and structuring libraries. Additionally, the second chapter has been updated to account for changes in Lean's stream API.</p>
<h3 id="august-2022"><a class="header" href="#august-2022">August, 2022</a></h3>
<p>This third public release adds a second chapter, which describes compiling and running programs along with Lean's model for side effects.</p>
<h3 id="july-2022"><a class="header" href="#july-2022">July, 2022</a></h3>
<p>The second public release completes the first chapter.</p>
<h3 id="june-2022"><a class="header" href="#june-2022">June, 2022</a></h3>
<p>This was the first public release, consisting of an introduction and part of the first chapter.</p>
<h2 id="about-the-author"><a class="header" href="#about-the-author">About the Author</a></h2>
<p>David Thrane Christiansen has been using functional languages for twenty years, and dependent types for ten.
Together with Daniel P. Friedman, he wrote <a href="https://thelittletyper.com/"><em>The Little Typer</em></a>, an introduction to the key ideas of dependent type theory.
He has a Ph.D. from the IT University of Copenhagen.
During his studies, he was a major contributor to the first version of the Idris language.
Since leaving academia, he has worked as a software developer at Galois in Portland, Oregon and Deon Digital in Copenhagen, Denmark, and he was the Executive Director of the Haskell Foundation.
At the time of writing, he is employed at the <a href="https://lean-fro.org/">Lean Focused Research Organization</a> working full-time on Lean.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p><a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFgAAAAfCAMAAABUFvrSAAAAAXNSR0IB2cksfwAAAARnQU1BAACxjnz7UZMAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAW5QTFRFAAAAAAAA////////////7+/v39/f1tXV09bS0tXS0tXR0dTR0dTQ0NTQ0NPPz9PPztLOztHNzdHNzdHMz8/PzdDMzNDMzNDLzM/Ly8/Ly8/Ky87Kys3Jyc3Jyc3IyMzIyMzHx8vHxsrGxsrFxcnFxcnExMnExMjDw8jDxMfDw8fCwsfCwcXAwMXAwMW/wMS/v8S+v8O+vsO+vsK9vcK9vcK8v7+/vMG8vMG7vMC8u8C7u8C6ur+6ur+5ub65ub64uL23t7y2tru1tbq0tLqztLmzs7iysrixsrexsbewsbawsLavsLWvr7Wur7SusLOvrrStrrOtr7KvrbOsrLKrr6+vq7Gqn6OenqCdn5+flpmWk5iTkZSRkZORj4+PiYyJhIaEhIWEgoWCgICAfX98fH98eXx5cHJvcHBwYGBgXV5dUFFQUFBQQ0RDQEBAPj8+NTY1MjMxMDAwKSkpKCkoICAgGxsbEBAQDg4ODQ4N2y3MbAAAAAR0Uk5T/wAKDnDBpeYAAALVSURBVHjatZX9V9JgFMdvNQh1Tme2zU1othSl5WsQZoqIrxmmqaUpqS2JKczibfLfd5+hHCYybB6/B859ftg+5+57Xx54Ag+iR/hPxGPRSXVYkf2SwHGC2C8rQXUiOhdPLK992tze3vn6/wKLOxseCykBkWXoNp+vrYNh+wJKaDQ8S8jJze0dl2TkvgkOSCx9kqsAqpI7prtFeUh9i+SV9eRWY8rpAqAKaWdwDLkyz6TKUFP5kOECg2p4Lr60ut6Q8kERwMhkDIDigRM4OhaUOfocT6auRSKabuLxfORZYGg0GltAM26k/O0Ssl4K5c3C5YEDeDI0wBOuqXmoqvYRXRzh5NDEzHwCU7aDi6DjMwDkQSg6gFVFYpCb91I1efKYMyMqahhT/rhh8yIN2adVMCoL6ebg4RdsCrmYrp182B0Ijs/EF1eTW/XgAtRl4IVCc7Ai0mUweymbPCaU6T5FfRdLrNi9AINC6QA6iQY0B8s9JwCanUvsg2NWDk3Nohd2cIZCAYrEjAPY35UDE42IZA1Dq4Yf+IoJOaafeLG0tuEOLNEV0BEIRMauFXTysZUOcXD0/fziWtKdFUI7AKaYh5I3UtrPY3vslvYtL9oERY1iwyG4oXgALYvH+wAiFGX5XAvWF/i4l41gbDfKod3cgu0DksEBuYsVnt6ShlaQ0GCF00g7F++qaleBZFOhpcbiEXIRIK9n8q2WkL/rHEyq1m67hhWoErabPzj+odpubtam3JNCL24fkNdTcwvLZPLcLPpX1kh7HUbaJRiX0N5tSyjFBoYncPDIEnIFhlOJOUNy3RryWmtT+gn31G+hs37RezQT4A/Nn8K99YvrPLtxNdHPv0MzVeeDHFqTBWav/jJNMXxzLlBXP+oubkgsnbq+/g9pVnLy4Xptwl3094vY00W3+3ztNMP2fb4AB9mMaK2Lo2lJ4HlBmj4iWLcZP7wePwz20T8rQcP0CuFIbQAAAABJRU5ErkJggg=="></a><br>This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</p>
<div style="break-before:page;page-break-before:always"></div><p>Lean is an interactive theorem prover developed at Microsoft Research, based on dependent type theory.
Dependent type theory unites the worlds of programs and proofs; thus, Lean is also a programming language.
Lean takes its dual nature seriously, and it is designed to be suitable for use as a general-purpose programming languageâLean is even implemented in itself.
This book is about writing programs in Lean.</p>
<p>When viewed as a programming language, Lean is a strict pure functional language with dependent types.
A large part of learning to program with Lean consists of learning how each of these attributes affects the way programs are written, and how to think like a functional programmer.
<em>Strictness</em> means that function calls in Lean work similarly to the way they do in most languages: the arguments are fully computed before the function's body begins running.
<em>Purity</em> means that Lean programs cannot have side effects such as modifying locations in memory, sending emails, or deleting files without the program's type saying so.
Lean is a <em>functional</em> language in the sense that functions are first-class values like any other and that the execution model is inspired by the evaluation of mathematical expressions.
<em>Dependent types</em>, which are the most unusual feature of Lean, make types into a first-class part of the language, allowing types to contain programs and programs to compute types.</p>
<p>This book is intended for programmers who want to learn Lean, but who have not necessarily used a functional programming language before.
Familiarity with functional languages such as Haskell, OCaml, or F# is not required.
On the other hand, this book does assume knowledge of concepts like loops, functions, and data structures that are common to most programming languages.
While this book is intended to be a good first book on functional programming, it is not a good first book on programming in general.</p>
<p>Mathematicians who are using Lean as a proof assistant will likely need to write custom proof automation tools at some point.
This book is also for them.
As these tools become more sophisticated, they begin to resemble programs in functional languages, but most working mathematicians are trained in languages like Python and Mathematica.
This book can help bridge the gap, empowering more mathematicians to write maintainable and understandable proof automation tools.</p>
<p>This book is intended to be read linearly, from the beginning to the end.
Concepts are introduced one at a time, and later sections assume familiarity with earlier sections.
Sometimes, later chapters will go into depth on a topic that was only briefly addressed earlier on.
Some sections of the book contain exercises.
These are worth doing, in order to cement your understanding of the section.
It is also useful to explore Lean as you read the book, finding creative new ways to use what you have learned.</p>
<h1 id="getting-lean"><a class="header" href="#getting-lean">Getting Lean</a></h1>
<p>Before writing and running programs written in Lean, you'll need to set up Lean on your own computer.
The Lean tooling consists of the following:</p>
<ul>
<li><code class="hljs">elan</code> manages the Lean compiler toolchains, similarly to <code class="hljs">rustup</code> or <code class="hljs">ghcup</code>.</li>
<li><code class="hljs">lake</code> builds Lean packages and their dependencies, similarly to <code class="hljs">cargo</code>, <code class="hljs">make</code>, or Gradle.</li>
<li><code class="hljs">lean</code> type checks and compiles individual Lean files as well as providing information to programmer tools about files that are currently being written.
Normally, <code class="hljs">lean</code> is invoked by other tools rather than directly by users.</li>
<li>Plugins for editors, such as Visual Studio Code or Emacs, that communicate with <code class="hljs">lean</code> and present its information conveniently.</li>
</ul>
<p>Please refer to the <a href="https://lean-lang.org/lean4/doc/quickstart.html">Lean manual</a> for up-to-date instructions for installing Lean.</p>
<h1 id="typographical-conventions"><a class="header" href="#typographical-conventions">Typographical Conventions</a></h1>
<p>Code examples that are provided to Lean as <em>input</em> are formatted like this:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">d1</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span> Nat := n + <span class="hljs-number">1</span>

<span class="hljs-keyword">#eval</span> add1 <span class="hljs-number">7</span>
</code></pre>
<p>The last line above (beginning with <code class="hljs">#eval</code>) is a command that instructs Lean to calculate an answer.
Lean's replies are formatted like this:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">8
</code></pre>
<p>Error messages returned by Lean are formatted like this:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">application type mismatch
  add1 "seven"
argument
  "seven"
has type
  String : Type
but is expected to have type
  Nat : Type
</code></pre>
<p>Warnings are formatted like this:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output warning hljs">declaration uses 'sorry'
</code></pre>
<h1 id="unicode"><a class="header" href="#unicode">Unicode</a></h1>
<p>Idiomatic Lean code makes use of a variety of Unicode characters that are not part of ASCII.
For instance, Greek letters like <code class="hljs">Î±</code> and <code class="hljs">Î²</code> and the arrow <code class="hljs">â</code> both occur in the first chapter of this book.
This allows Lean code to more closely resemble ordinary mathematical notation.</p>
<p>With the default Lean settings, both Visual Studio Code and Emacs allow these characters to be typed with a backslash (<code class="hljs">\</code>) followed by a name.
For example, to enter <code class="hljs">Î±</code>, type <code class="hljs">\alpha</code>.
To find out how to type a character in Visual Studio Code, point the mouse at it and look at the tooltip.
In Emacs, use <code class="hljs">C-c C-k</code> with point on the character in question.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="acknowledgments"><a class="header" href="#acknowledgments">Acknowledgments</a></h1>
<p>This free online book was made possible by the generous support of Microsoft Research, who paid for it to be written and given away.
During the process of writing, they made the expertise of the Lean development team available to both answer my questions and make Lean easier to use.
In particular, Leonardo de Moura initiated the project and helped me get started, Chris Lovett set up the CI and deployment automation and provided great feedback as a test reader, Gabriel Ebner provided technical reviews, Sarah Smith kept the administrative side working well, and Vanessa Rodriguez helped me diagnose a tricky interaction between the source-code highlighting library and certain versions of Safari on iOS.</p>
<p>Writing this book has taken up many hours outside of normal working hours.
My wife Ellie Thrane Christiansen has taken on a larger than usual share of running the family, and this book could not exist if she had not done so.
An extra day of work each week has not been easy for my familyâthank you for your patience and support while I was writing.</p>
<p>The online community surrounding Lean provided enthusiastic support for the project, both technical and emotional.
In particular, Sebastian Ullrich provided key help when I was learning Lean's metaprogramming system in order to write the supporting code that allowed the text of error messages to be both checked in CI and easily included in the book itself.
Within hours of posting a new revision, excited readers would be finding mistakes, providing suggestions, and showering me with kindness.
In particular, I'd like to thank Arien Malec, Asta HalkjÃ¦r From, Bulhwi Cha, Craig Stuntz, Daniel Fabian, Evgenia Karunus, eyelash, Floris van Doorn, FrantiÅ¡ek SilvÃ¡Å¡i, Henrik BÃ¶ving, Ian Young, Jeremy Salwen, Jireh Loreaux, Kevin Buzzard, Lars Ericson, Liu Yuxi, Mac Malone, Malcolm Langfield, Mario Carneiro, Newell Jensen, Patrick Massot, Paul Chisholm, Pietro Monticone, Tomas Puverle, YaÃ«l Dillies, Zhiyuan Bao, and Zyad Hassan for their many suggestions, both stylistic and technical.</p>
<div style="break-before:page;page-break-before:always"></div><p>According to tradition, a programming language should be introduced by
compiling and running a program that displays <code class="hljs">"Hello, world!"</code> on the
console. This simple program ensures that the language tooling is
installed correctly and that the programmer is able to run the
compiled code.</p>
<p>Since the 1970s, however, programming has changed. Today, compilers
are typically integrated into text editors, and the programming
environment offers feedback as the program is written. Lean is no
exception: it implements an extended version of the Language Server
Protocol that allows it to communicate with a text editor and provide
feedback as the user types.</p>
<p>Languages as varied as Python, Haskell, and JavaScript offer a read-eval-print-loop (REPL), also known as an interactive toplevel or a browser console, in which expressions or statements can be entered.
The language then computes and displays the result of the user's input.
Lean, on the other hand, integrates these features into the interaction with the editor, providing commands that cause the text editor to display feedback integrated into the program text itself.
This chapter provides a short introduction to interacting with Lean in an editor, while <a href="https://leanprover.github.io/functional_programming_in_lean/print.html">Hello, World!</a> describes how to use Lean traditionally from the command line in batch mode.</p>
<p>It is best if you read this book with Lean open in your editor,
following along and typing in each example. Please play with the
examples, and see what happens!</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="evaluating-expressions"><a class="header" href="#evaluating-expressions">Evaluating Expressions</a></h1>
<p>The most important thing to understand as a programmer learning Lean
is how evaluation works. Evaluation is the process of finding the
value of an expression, just as one does in arithmetic. For instance,
the value of 15 - 6 is 9 and the value of 2 Ã (3 + 1) is 8.
To find the value of the latter expression, 3 + 1 is first replaced by 4, yielding 2 Ã 4, which itself can be reduced to 8.
Sometimes, mathematical expressions contain variables: the value of <em>x</em> + 1 cannot be computed until we know what the value of <em>x</em> is.
In Lean, programs are first and foremost expressions, and the primary way to think about computation is as evaluating expressions to find their values.</p>
<p>Most programming languages are <em>imperative</em>, where a program consists
of a series of statements that should be carried out in order to find
the program's result. Programs have access to mutable memory, so the
value referred to by a variable can change over time. In addition to mutable state, programs may have other side
effects, such as deleting files, making outgoing network connections,
throwing or catching exceptions, and reading data from a
database. "Side effects" is essentially a catch-all term for
describing things that may happen in a program that don't follow the
model of evaluating mathematical expressions.</p>
<p>In Lean, however, programs work the same way as mathematical
expressions. Once given a value, variables cannot be reassigned. Evaluating an expression cannot have side effects. If two
expressions have the same value, then replacing one with the other
will not cause the program to compute a different result. This does
not mean that Lean cannot be used to write <code class="hljs">Hello, world!</code> to the
console, but performing I/O is not a core part of the experience of
using Lean in the same way. Thus, this chapter focuses on how to
evaluate expressions interactively with Lean, while the next chapter
describes how to write, compile, and run the <code class="hljs">Hello, world!</code> program.</p>
<p>To ask Lean to evaluate an expression, write <code class="hljs">#eval</code> before it in your
editor, which will then report the result back. Typically, the result
is found by putting the cursor or mouse pointer over <code class="hljs">#eval</code>. For
instance,</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> <span class="hljs-number">1</span> + <span class="hljs-number">2</span>
</code></pre>
<p>yields the value <code class="hljs">3</code>.</p>
<p>Lean obeys the ordinary rules of precedence and associativity for
arithmetic operators. That is,</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> <span class="hljs-number">1</span> + <span class="hljs-number">2</span> * <span class="hljs-number">5</span>
</code></pre>
<p>yields the value <code class="hljs">11</code> rather than
<code class="hljs">15</code>.</p>
<p>While both ordinary mathematical notation and the majority of
programming languages use parentheses (e.g. <code class="hljs">f(x)</code>) to apply a function to its
arguments, Lean simply writes the function next to its
arguments (e.g. <code class="hljs">f x</code>). Function application is one of the most common operations,
so it pays to keep it concise. Rather than writing</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> String.append(<span class="hljs-string">"Hello, "</span>, <span class="hljs-string">"Lean!"</span>)
</code></pre>
<p>to compute <code class="hljs">"Hello, Lean!"</code>,
one would instead write</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-Lean hljs"><span class="hljs-keyword">#eval</span> String.append <span class="hljs-string">"Hello, "</span> <span class="hljs-string">"Lean!"</span>
</code></pre>
<p>where the function's two arguments are simply written next to
it with spaces.</p>
<p>Just as the order-of-operations rules for arithmetic demand
parentheses in the expression <code class="hljs">(1 + 2) * 5</code>, parentheses are also
necessary when a function's argument is to be computed via another
function call. For instance, parentheses are required in</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-Lean hljs"><span class="hljs-keyword">#eval</span> String.append <span class="hljs-string">"great "</span> (String.append <span class="hljs-string">"oak "</span> <span class="hljs-string">"tree"</span>)
</code></pre>
<p>because otherwise the second <code class="hljs">String.append</code> would be interpreted as
an argument to the first, rather than as a function being passed
<code class="hljs">"oak "</code> and <code class="hljs">"tree"</code> as arguments. The value of the inner <code class="hljs">String.append</code>
call must be found first, after which it can be appended to <code class="hljs">"great "</code>,
yielding the final value <code class="hljs">"great oak tree"</code>.</p>
<p>Imperative languages often have two kinds of conditional: a
conditional <em>statement</em> that determines which instructions to carry
out based on a Boolean value, and a conditional <em>expression</em> that
determines which of two expressions to evaluate based on a Boolean
value. For instance, in C and C++, the conditional statement is
written using <code class="hljs">if</code> and <code class="hljs">else</code>, while the conditional expression is
written with a ternary operator <code class="hljs">?</code> and <code class="hljs">:</code>. In Python, the
conditional statement begins with <code class="hljs">if</code>, while the conditional
expression puts <code class="hljs">if</code> in the middle.
Because Lean is an expression-oriented functional language, there are no conditional statements, only conditional expressions.
They are written using <code class="hljs">if</code>, <code class="hljs">then</code>, and <code class="hljs">else</code>. For
instance,</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-Lean hljs">String.append <span class="hljs-string">"it is "</span> (<span class="hljs-keyword">if</span> <span class="hljs-number">1</span> &gt; <span class="hljs-number">2</span> <span class="hljs-keyword">then</span> <span class="hljs-string">"yes"</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"no"</span>)
</code></pre>
<p>evaluates to</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-Lean hljs">String.append <span class="hljs-string">"it is "</span> (<span class="hljs-keyword">if</span> false <span class="hljs-keyword">then</span> <span class="hljs-string">"yes"</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"no"</span>)
</code></pre>
<p>which evaluates to</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">String.append <span class="hljs-string">"it is "</span> <span class="hljs-string">"no"</span>
</code></pre>
<p>which finally evaluates to <code class="hljs">"it is no"</code>.</p>
<p>For the sake of brevity, a series of evaluation steps like this will sometimes be written with arrows between them:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">String.append <span class="hljs-string">"it is "</span> (<span class="hljs-keyword">if</span> <span class="hljs-number">1</span> &gt; <span class="hljs-number">2</span> <span class="hljs-keyword">then</span> <span class="hljs-string">"yes"</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"no"</span>)
===&gt;
String.append <span class="hljs-string">"it is "</span> (<span class="hljs-keyword">if</span> false <span class="hljs-keyword">then</span> <span class="hljs-string">"yes"</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"no"</span>)
===&gt;
String.append <span class="hljs-string">"it is "</span> <span class="hljs-string">"no"</span>
===&gt;
<span class="hljs-string">"it is no"</span>
</code></pre>
<h2 id="messages-you-may-meet"><a class="header" href="#messages-you-may-meet">Messages You May Meet</a></h2>
<p>Asking Lean to evaluate a function application that is missing an argument will lead to an error message.
In particular, the example</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> String.append <span class="hljs-string">"it is "</span>
</code></pre>
<p>yields a quite long error message:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">expression
  String.append "it is "
has type
  String â String
but instance
  Lean.MetaEval (String â String)
failed to be synthesized, this instance instructs Lean on how to display the resulting value, recall that any type implementing the `Repr` class also implements the `Lean.MetaEval` class
</code></pre>
<p>This message occurs because Lean functions that are applied to only some of their arguments return new functions that are waiting for the rest of the arguments.
Lean cannot display functions to users, and thus returns an error when asked to do so.</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<p>What are the values of the following expressions? Work them out by hand,
then enter them into Lean to check your work.</p>
<ul>
<li><code class="hljs">42 + 19</code></li>
<li><code class="hljs">String.append "A" (String.append "B" "C")</code></li>
<li><code class="hljs">String.append (String.append "A" "B") "C"</code></li>
<li><code class="hljs">if 3 == 3 then 5 else 7</code></li>
<li><code class="hljs">if 3 == 4 then "equal" else "not equal"</code></li>
</ul>
<div style="break-before:page;page-break-before:always"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>Types classify programs based on the values that they can
compute. Types serve a number of roles in a program:</p>
<ol>
<li>
<p>They allow the compiler to make decisions about the in-memory
representation of a value.</p>
</li>
<li>
<p>They help programmers to communicate their intent to others,
serving as a lightweight specification for the inputs and outputs
of a function that the compiler can ensure the program adheres to.</p>
</li>
<li>
<p>They prevent various potential mistakes, such as adding a number
to a string, and thus reduce the number of tests that are
necessary for a program.</p>
</li>
<li>
<p>They help the Lean compiler automate the production of auxiliary code that can save boilerplate.</p>
</li>
</ol>
<p>Lean's type system is unusually expressive.
Types can encode strong specifications like "this sorting function returns a permutation of its input" and flexible specifications like "this function has different return types, depending on the value of its argument".
The type system can even be used as a full-blown logic for proving mathematical theorems.
This cutting-edge expressive power doesn't obviate the need for simpler types, however, and understanding these simpler types is a prerequisite for using the more advanced features.</p>
<p>Every program in Lean must have a type. In particular, every
expression must have a type before it can be evaluated. In the
examples so far, Lean has been able to discover a type on its own, but
it is sometimes necessary to provide one. This is done using the colon
operator:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (<span class="hljs-number">1</span> + <span class="hljs-number">2</span> : Nat)
</code></pre>
<p>Here, <code class="hljs">Nat</code> is the type of <em>natural numbers</em>, which are arbitrary-precision unsigned integers.
In Lean, <code class="hljs">Nat</code> is the default type for non-negative integer literals.
This default type is not always the best choice.
In C, unsigned integers underflow to the largest representable numbers when subtraction would otherwise yield a result less than zero.
<code class="hljs">Nat</code>, however, can represent arbitrarily-large unsigned numbers, so there is no largest number to underflow to.
Thus, subtraction on <code class="hljs">Nat</code> returns <code class="hljs">0</code> when the answer would have otherwise been negative.
For instance,</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> <span class="hljs-number">1</span> - <span class="hljs-number">2</span>
</code></pre>
<p>evaluates to <code class="hljs">0</code> rather
than <code class="hljs">-1</code>. To use a type that can represent the negative integers,
provide it directly:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (<span class="hljs-number">1</span> - <span class="hljs-number">2</span> : Int)
</code></pre>
<p>With this type, the result is <code class="hljs">-1</code>, as expected.</p>
<p>To check the type of an expression without evaluating it, use <code class="hljs">#check</code>
instead of <code class="hljs">#eval</code>. For instance:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> (<span class="hljs-number">1</span> - <span class="hljs-number">2</span> : Int)
</code></pre>
<p>reports <code class="hljs">1 - 2 : Int</code> without actually performing the subtraction.</p>
<p>When a program can't be given a type, an error is returned from both
<code class="hljs">#check</code> and <code class="hljs">#eval</code>. For instance:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> String.append <span class="hljs-string">"hello"</span> [<span class="hljs-string">" "</span>, <span class="hljs-string">"world"</span>]
</code></pre>
<p>outputs</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">application type mismatch
  String.append "hello" [" ", "world"]
argument
  [" ", "world"]
has type
  List String : Type
but is expected to have type
  String : Type
</code></pre>
<p>because the second argument to <code class="hljs">String.append</code> is expected to be a
string, but a list of strings was provided instead.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="functions-and-definitions"><a class="header" href="#functions-and-definitions">Functions and Definitions</a></h1>
<p>In Lean, definitions are introduced using the <code class="hljs">def</code> keyword. For instance, to define the name <code class="hljs">hello</code> to refer to the string <code class="hljs">"Hello"</code>, write:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">l</span><span class="hljs-title">o</span> <span class="hljs-symbol">:</span></span>= <span class="hljs-string">"Hello"</span>
</code></pre>
<p>In Lean, new names are defined using the colon-equal operator<code class="hljs">:=</code>
rather than <code class="hljs">=</code>. This is because <code class="hljs">=</code> is used to describe equalities
between existing expressions, and using two different operators helps
prevent confusion.</p>
<p>In the definition of <code class="hljs">hello</code>, the expression <code class="hljs">"Hello"</code> is simple enough that Lean is able to determine the definition's type automatically.
However, most definitions are not so simple, so it will usually be necessary to add a type.
This is done using a colon after the name being defined.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> String := <span class="hljs-string">"Lean"</span>
</code></pre>
<p>Now that the names have been defined, they can be used, so</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-Lean hljs"><span class="hljs-keyword">#eval</span> String.append hello (String.append <span class="hljs-string">" "</span> lean)
</code></pre>
<p>outputs</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-Lean info hljs"><span class="hljs-string">"Hello Lean"</span>
</code></pre>
<p>In Lean, defined names may only be used after their definitions.</p>
<p>In many languages, definitions of functions use a different syntax than definitions of other values.
For instance, Python function definitions begin with the <code class="hljs">def</code> keyword, while other definitions are defined with an equals sign.
In Lean, functions are defined using the same <code class="hljs">def</code> keyword as other values.
Nonetheless, definitions such as <code class="hljs">hello</code> introduce names that refer <em>directly</em> to their values, rather than to zero-argument functions that return equivalent results each time they are called.</p>
<h2 id="defining-functions"><a class="header" href="#defining-functions">Defining Functions</a></h2>
<p>There are a variety of ways to define functions in Lean. The simplest is to place the function's arguments before the definition's type, separated by spaces. For instance, a function that adds one to its argument can be written:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">d1</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span> Nat := n + <span class="hljs-number">1</span>
</code></pre>
<p>Testing this function with <code class="hljs">#eval</code> gives <code class="hljs">8</code>, as expected:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> add1 <span class="hljs-number">7</span>
</code></pre>
<p>Just as functions are applied to multiple arguments by writing spaces between each argument, functions that accept multiple arguments are defined with spaces between the arguments' names and types. The function <code class="hljs">maximum</code>, whose result is equal to the greatest of its two arguments, takes two <code class="hljs">Nat</code> arguments <code class="hljs">n</code> and <code class="hljs">k</code> and returns a <code class="hljs">Nat</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">x</span><span class="hljs-title">i</span><span class="hljs-title">m</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-params">(k : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  <span class="hljs-keyword">if</span> n &lt; k <span class="hljs-keyword">then</span>
    k
  <span class="hljs-keyword">else</span> n
</code></pre>
<p>When a defined function like <code class="hljs">maximum</code> has been provided with its arguments, the result is determined by first replacing the argument names with the provided values in the body, and then evaluating the resulting body. For example:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">maximum (<span class="hljs-number">5</span> + <span class="hljs-number">8</span>) (<span class="hljs-number">2</span> * <span class="hljs-number">7</span>)
===&gt;
maximum <span class="hljs-number">13</span> <span class="hljs-number">14</span>
===&gt;
<span class="hljs-keyword">if</span> <span class="hljs-number">13</span> &lt; <span class="hljs-number">14</span> <span class="hljs-keyword">then</span> <span class="hljs-number">14</span> <span class="hljs-keyword">else</span> <span class="hljs-number">13</span>
===&gt;
<span class="hljs-number">14</span>
</code></pre>
<p>Expressions that evaluate to natural numbers, integers, and strings have types that say this (<code class="hljs">Nat</code>, <code class="hljs">Int</code>, and <code class="hljs">String</code>, respectively).
This is also true of functions.
A function that accepts a <code class="hljs">Nat</code> and returns a <code class="hljs">Bool</code> has type <code class="hljs">Nat â Bool</code>, and a function that accepts two <code class="hljs">Nat</code>s and returns a <code class="hljs">Nat</code> has type <code class="hljs">Nat â Nat â Nat</code>.</p>
<p>As a special case, Lean returns a function's signature when its name is used directly with <code class="hljs">#check</code>.
Entering <code class="hljs">#check add1</code> yields <code class="hljs">add1 (n : Nat) : Nat</code>.
However, Lean can be "tricked" into showing the function's type by writing the function's name in parentheses, which causes the function to be treated as an ordinary expression, so <code class="hljs">#check (add1)</code> yields <code class="hljs">add1 : Nat â Nat</code> and <code class="hljs">#check (maximum)</code> yields <code class="hljs">maximum : Nat â Nat â Nat</code>.
This arrow can also be written with an ASCII alternative arrow <code class="hljs">-&gt;</code>, so the preceding function types can be written <code class="hljs">Nat -&gt; Nat</code> and <code class="hljs">Nat -&gt; Nat -&gt; Nat</code>, respectively.</p>
<p>Behind the scenes, all functions actually expect precisely one argument.
Functions like <code class="hljs">maximum</code> that seem to take more than one argument are in fact functions that take one argument and then return a new function.
This new function takes the next argument, and the process continues until no more arguments are expected.
This can be seen by providing one argument to a multiple-argument function: <code class="hljs">#check maximum 3</code> yields <code class="hljs">maximum 3 : Nat â Nat</code> and <code class="hljs">#check String.append "Hello "</code> yields <code class="hljs">String.append "Hello " : String â String</code>.
Using a function that returns a function to implement multiple-argument functions is called <em>currying</em> after the mathematician Haskell Curry.
Function arrows associate to the right, which means that <code class="hljs">Nat â Nat â Nat</code> should be parenthesized <code class="hljs">Nat â (Nat â Nat)</code>.</p>
<h3 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h3>
<ul>
<li>Define the function <code class="hljs">joinStringsWith</code> with type <code class="hljs">String -&gt; String -&gt; String -&gt; String</code> that creates a new string by placing its first argument between its second and third arguments. <code class="hljs">joinStringsWith ", " "one" "and another"</code> should evaluate to <code class="hljs">"one, and another"</code>.</li>
<li>What is the type of <code class="hljs">joinStringsWith ": "</code>? Check your answer with Lean.</li>
<li>Define a function <code class="hljs">volume</code> with type <code class="hljs">Nat â Nat â Nat â Nat</code> that computes the volume of a rectangular prism with the given height, width, and depth.</li>
</ul>
<h2 id="defining-types"><a class="header" href="#defining-types">Defining Types</a></h2>
<p>Most typed programming languages have some means of defining aliases for types, such as C's <code class="hljs">typedef</code>.
In Lean, however, types are a first-class part of the language - they are expressions like any other.
This means that definitions can refer to types just as well as they can refer to other values.</p>
<p>For instance, if <code class="hljs">String</code> is too much to type, a shorter abbreviation <code class="hljs">Str</code> can be defined:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">S</span><span class="hljs-title">t</span><span class="hljs-title">r</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> := String
</code></pre>
<p>It is then possible to use <code class="hljs">Str</code> as a definition's type instead of <code class="hljs">String</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">S</span><span class="hljs-title">t</span><span class="hljs-title">r</span> <span class="hljs-symbol">:</span></span> Str := <span class="hljs-string">"This is a string."</span>
</code></pre>
<p>The reason this works is that types follow the same rules as the rest of Lean.
Types are expressions, and in an expression, a defined name can be replaced with its definition.
Because <code class="hljs">Str</code> has been defined to mean <code class="hljs">String</code>, the definition of <code class="hljs">aStr</code> makes sense.</p>
<h3 id="messages-you-may-meet-1"><a class="header" href="#messages-you-may-meet-1">Messages You May Meet</a></h3>
<p>Experimenting with using definitions for types is made more complicated by the way that Lean supports overloaded integer literals.
If <code class="hljs">Nat</code> is too short, a longer name <code class="hljs">NaturalNumber</code> can be defined:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">N</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">b</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> := Nat
</code></pre>
<p>However, using <code class="hljs">NaturalNumber</code> as a definition's type instead of <code class="hljs">Nat</code> does not have the expected effect.
In particular, the definition:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">y</span><span class="hljs-title">E</span><span class="hljs-title">i</span><span class="hljs-title">g</span><span class="hljs-title">h</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> NaturalNumber := <span class="hljs-number">38</span>
</code></pre>
<p>results in the following error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to synthesize instance
  OfNat NaturalNumber 38
</code></pre>
<p>This error occurs because Lean allows number literals to be <em>overloaded</em>.
When it makes sense to do so, natural number literals can be used for new types, just as if those types were built in to the system.
This is part of Lean's mission of making it convenient to represent mathematics, and different branches of mathematics use number notation for very different purposes.
The specific feature that allows this overloading does not replace all defined names with their definitions before looking for overloading, which is what leads to the error message above.</p>
<p>One way to work around this limitation is by providing the type <code class="hljs">Nat</code> on the right-hand side of the definition, causing <code class="hljs">Nat</code>'s overloading rules to be used for <code class="hljs">38</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">y</span><span class="hljs-title">E</span><span class="hljs-title">i</span><span class="hljs-title">g</span><span class="hljs-title">h</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> NaturalNumber := (<span class="hljs-number">38</span> : Nat)
</code></pre>
<p>The definition is still type-correct because <code class="hljs">NaturalNumber</code> is the same type as <code class="hljs">Nat</code>âby definition!</p>
<p>Another solution is to define an overloading for <code class="hljs">NaturalNumber</code> that works equivalently to the one for <code class="hljs">Nat</code>.
This requires more advanced features of Lean, however.</p>
<p>Finally, defining the new name for <code class="hljs">Nat</code> using <code class="hljs">abbrev</code> instead of <code class="hljs">def</code> allows overloading resolution to replace the defined name with its definition.
Definitions written using <code class="hljs">abbrev</code> are always unfolded.
For instance,</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">abbrev</span> N : <span class="hljs-built_in">Type</span> := Nat
</code></pre>
<p>and</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">y</span><span class="hljs-title">N</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> N := <span class="hljs-number">39</span>
</code></pre>
<p>are accepted without issue.</p>
<p>Behind the scenes, some definitions are internally marked as being unfoldable during overload resolution, while others are not.
Definitions that are to be unfolded are called <em>reducible</em>.
Control over reducibility is essential to allow Lean to scale: fully unfolding all definitions can result in very large types that are slow for a machine to process and difficult for users to understand.
Definitions produced with <code class="hljs">abbrev</code> are marked as reducible.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="structures"><a class="header" href="#structures">Structures</a></h1>
<p>The first step in writing a program is usually to identify the problem domain's concepts, and then find suitable representations for them in code.
Sometimes, a domain concept is a collection of other, simpler, concepts.
In that case, it can be convenient to group these simpler components together into a single "package", which can then be given a meaningful name.
In Lean, this is done using <em>structures</em>, which are analogous to <code class="hljs">struct</code>s in C or Rust and <code class="hljs">record</code>s in C#.</p>
<p>Defining a structure introduces a completely new type to Lean that can't be reduced to any other type.
This is useful because multiple structures might represent different concepts that nonetheless contain the same data.
For instance, a point might be represented using either Cartesian or polar coordinates, each being a pair of floating-point numbers.
Defining separate structures prevents API clients from confusing one for another.</p>
<p>Lean's floating-point number type is called <code class="hljs">Float</code>, and floating-point numbers are written in the usual notation.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-number">1.2</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">1.2 : Float
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> -<span class="hljs-number">454.2123215</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">-454.2123215 : Float
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-number">0.0</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">0.0 : Float
</code></pre>
<p>When floating point numbers are written with the decimal point, Lean will infer the type <code class="hljs">Float</code>. If they are written without it, then a type annotation may be necessary.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-number">0</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">0 : Nat
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> (<span class="hljs-number">0</span> : Float)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">0 : Float
</code></pre>
<p>A Cartesian point is a structure with two <code class="hljs">Float</code> fields, called <code class="hljs">x</code> and <code class="hljs">y</code>.
This is declared using the <code class="hljs">structure</code> keyword.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">t</span></span> <span class="hljs-keyword">where</span>
  x : Float
  y : Float
<span class="hljs-keyword">deriving</span> Repr
</code></pre>
<p>After this declaration, <code class="hljs">Point</code> is a new structure type.
The final line, which says <code class="hljs">deriving Repr</code>, asks Lean to generate code to display values of type <code class="hljs">Point</code>.
This code is used by <code class="hljs">#eval</code> to render the result of evaluation for consumption by programmers, analogous to the <code class="hljs">repr</code> function in Python.
It is also possible to override the compiler's generated display code.</p>
<p>The typical way to create a value of a structure type is to provide values for all of its fields inside of curly braces.
The origin of a Cartesian plane is where <code class="hljs">x</code> and <code class="hljs">y</code> are both zero:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">g</span><span class="hljs-title">i</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> Point := { x := <span class="hljs-number">0.0</span>, y := <span class="hljs-number">0.0</span> }
</code></pre>
<p>If the <code class="hljs">deriving Repr</code> line in <code class="hljs">Point</code>'s definition were omitted, then attempting <code class="hljs">#eval origin</code> would yield an error similar to that which occurs when omitting a function's argument:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">expression
  origin
has type
  Point
but instance
  Lean.MetaEval Point
failed to be synthesized, this instance instructs Lean on how to display the resulting value, recall that any type implementing the `Repr` class also implements the `Lean.MetaEval` class
</code></pre>
<p>That message is saying that the evaluation machinery doesn't know how to communicate the result of evaluation back to the user.</p>
<p>Happily, with <code class="hljs">deriving Repr</code>, the result of <code class="hljs">#eval origin</code> looks very much like the definition of <code class="hljs">origin</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">{ x := 0.000000, y := 0.000000 }
</code></pre>
<p>Because structures exist to "bundle up" a collection of data, naming it and treating it as a single unit, it is also important to be able to extract the individual fields of a structure.
This is done using dot notation, as in C, Python, or Rust.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> origin.x
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">0.000000
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> origin.y
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">0.000000
</code></pre>
<p>This can be used to define functions that take structures as arguments.
For instance, addition of points is performed by adding the underlying coordinate values.
It should be the case that <code class="hljs">#eval addPoints { x := 1.5, y := 32 } { x := -8, y := 0.2 }</code> yields</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">{ x := -6.500000, y := 32.200000 }
</code></pre>
<p>The function itself takes two <code class="hljs">Points</code> as arguments, called <code class="hljs">p1</code> and <code class="hljs">p2</code>.
The resulting point is based on the <code class="hljs">x</code> and <code class="hljs">y</code> fields of both <code class="hljs">p1</code> and <code class="hljs">p2</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">d</span><span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">s</span> <span class="hljs-params">(p1 : Point)</span> <span class="hljs-params">(p2 : Point)</span> <span class="hljs-symbol">:</span></span> Point :=
  { x := p1.x + p2.x, y := p1.y + p2.y }
</code></pre>
<p>Similarly, the distance between two points, which is the square root of the sum of the squares of the differences in their <code class="hljs">x</code> and <code class="hljs">y</code> components, can be written:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">c</span><span class="hljs-title">e</span> <span class="hljs-params">(p1 : Point)</span> <span class="hljs-params">(p2 : Point)</span> <span class="hljs-symbol">:</span></span> Float :=
  Float.sqrt (((p2.x - p1.x) ^ <span class="hljs-number">2.0</span>) + ((p2.y - p1.y) ^ <span class="hljs-number">2.0</span>))
</code></pre>
<p>For example, the distance between (1, 2) and (5, -1) is 5:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> distance { x := <span class="hljs-number">1.0</span>, y := <span class="hljs-number">2.0</span> } { x := <span class="hljs-number">5.0</span>, y := -<span class="hljs-number">1.0</span> }
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">5.000000
</code></pre>
<p>Multiple structures may have fields with the same names.
For instance, a three-dimensional point datatype may share the fields <code class="hljs">x</code> and <code class="hljs">y</code>, and be instantiated with the same field names:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">t3</span><span class="hljs-title">D</span></span> <span class="hljs-keyword">where</span>
  x : Float
  y : Float
  z : Float
<span class="hljs-keyword">deriving</span> Repr

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">g</span><span class="hljs-title">i</span><span class="hljs-title">n3</span><span class="hljs-title">D</span> <span class="hljs-symbol">:</span></span> Point3D := { x := <span class="hljs-number">0.0</span>, y := <span class="hljs-number">0.0</span>, z := <span class="hljs-number">0.0</span> }
</code></pre>
<p>This means that the structure's expected type must be known in order to use the curly-brace syntax.
If the type is not known, Lean will not be able to instantiate the structure.
For instance,</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> { x := <span class="hljs-number">0.0</span>, y := <span class="hljs-number">0.0</span> }
</code></pre>
<p>leads to the error</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">invalid {...} notation, expected type is not known
</code></pre>
<p>As usual, the situation can be remedied by providing a type annotation.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> ({ x := <span class="hljs-number">0.0</span>, y := <span class="hljs-number">0.0</span> } : Point)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">{ x := 0.0, y := 0.0 } : Point
</code></pre>
<p>To make programs more concise, Lean also allows the structure type annotation inside the curly braces.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> { x := <span class="hljs-number">0.0</span>, y := <span class="hljs-number">0.0</span> : Point}
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">{ x := 0.0, y := 0.0 } : Point
</code></pre>
<h2 id="updating-structures"><a class="header" href="#updating-structures">Updating Structures</a></h2>
<p>Imagine a function <code class="hljs">zeroX</code> that replaces the <code class="hljs">x</code> field of a <code class="hljs">Point</code> with <code class="hljs">0.0</code>.
In most programming language communities, this sentence would mean that the memory location pointed to by <code class="hljs">x</code> was to be overwritten with a new value.
However, Lean does not have mutable state.
In functional programming communities, what is almost always meant by this kind of statement is that a fresh <code class="hljs">Point</code> is allocated with the <code class="hljs">x</code> field pointing to the new value, and all other fields pointing to the original values from the input.
One way to write <code class="hljs">zeroX</code> is to follow this description literally, filling out the new value for <code class="hljs">x</code> and manually transferring <code class="hljs">y</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">X</span> <span class="hljs-params">(p : Point)</span> <span class="hljs-symbol">:</span></span> Point :=
  { x := <span class="hljs-number">0</span>, y := p.y }
</code></pre>
<p>This style of programming has drawbacks, however.
First off, if a new field is added to a structure, then every site that updates any field at all must be updated, causing maintenance difficulties.
Secondly, if the structure contains multiple fields with the same type, then there is a real risk of copy-paste coding leading to field contents being duplicated or switched.
Finally, the program becomes long and bureaucratic.</p>
<p>Lean provides a convenient syntax for replacing some fields in a structure while leaving the others alone.
This is done by using the <code class="hljs">with</code> keyword in a structure initialization.
The source of unchanged fields occurs before the <code class="hljs">with</code>, and the new fields occur after.
For instance, <code class="hljs">zeroX</code> can be written with only the new <code class="hljs">x</code> value:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">X</span> <span class="hljs-params">(p : Point)</span> <span class="hljs-symbol">:</span></span> Point :=
  { p <span class="hljs-keyword">with</span> x := <span class="hljs-number">0</span> }
</code></pre>
<p>Remember that this structure update syntax does not modify existing valuesâit creates new values that share some fields with old values.
For instance, given the point <code class="hljs">fourAndThree</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">A</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Point :=
  { x := <span class="hljs-number">4.3</span>, y := <span class="hljs-number">3.4</span> }
</code></pre>
<p>evaluating it, then evaluating an update of it using <code class="hljs">zeroX</code>, then evaluating it again yields the original value:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> fourAndThree
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">{ x := 4.300000, y := 3.400000 }
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> zeroX fourAndThree
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">{ x := 0.000000, y := 3.400000 }
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> fourAndThree
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">{ x := 4.300000, y := 3.400000 }
</code></pre>
<p>One consequence of the fact that structure updates do not modify the original structure is that it becomes easier to reason about cases where the new value is computed from the old one.
All references to the old structure continue to refer to the same field values in all of the new values provided.</p>
<h2 id="behind-the-scenes"><a class="header" href="#behind-the-scenes">Behind the Scenes</a></h2>
<p>Every structure has a <em>constructor</em>.
Here, the term "constructor" may be a source of confusion.
Unlike constructors in languages such as Java or Python, constructors in Lean are not arbitrary code to be run when a datatype is initialized.
Instead, constructors simply gather the data to be stored in the newly-allocated data structure.
It is not possible to provide a custom constructor that pre-processes data or rejects invalid arguments.
This is really a case of the word "constructor" having different, but related, meanings in the two contexts.</p>
<p>By default, the constructor for a structure named <code class="hljs">S</code> is named <code class="hljs">S.mk</code>.
Here, <code class="hljs">S</code> is a namespace qualifier, and <code class="hljs">mk</code> is the name of the constructor itself.
Instead of using curly-brace initialization syntax, the constructor can also be applied directly.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> Point.mk <span class="hljs-number">1.5</span> <span class="hljs-number">2.8</span>
</code></pre>
<p>However, this is not generally considered to be good Lean style, and Lean even returns its feedback using the standard structure initializer syntax.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">{ x := 1.5, y := 2.8 } : Point
</code></pre>
<p>Constructors have function types, which means they can be used anywhere that a function is expected.
For instance, <code class="hljs">Point.mk</code> is a function that accepts two <code class="hljs">Float</code>s (respectively <code class="hljs">x</code> and <code class="hljs">y</code>) and returns a new <code class="hljs">Point</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> (Point.mk)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Point.mk : Float â Float â Point
</code></pre>
<p>To override a structure's constructor name, write it with two colons at the beginning.
For instance, to use <code class="hljs">Point.point</code> instead of <code class="hljs">Point.mk</code>, write:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">t</span></span> <span class="hljs-keyword">where</span>
  point ::
  x : Float
  y : Float
<span class="hljs-keyword">deriving</span> Repr
</code></pre>
<p>In addition to the constructor, an accessor function is defined for each field of a structure.
These have the same name as the field, in the structure's namespace.
For <code class="hljs">Point</code>, accessor functions <code class="hljs">Point.x</code> and <code class="hljs">Point.y</code> are generated.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> (Point.x)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Point.x : Point â Float
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> (Point.y)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Point.y : Point â Float
</code></pre>
<p>In fact, just as the curly-braced structure construction syntax is converted to a call to the structure's constructor behind the scenes, the syntax <code class="hljs">p1.x</code> in the prior definition of <code class="hljs">addPoints</code> is converted into a call to the <code class="hljs">Point.x</code> accessor.
That is, <code class="hljs">#eval origin.x</code> and <code class="hljs">#eval Point.x origin</code> both yield</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">0.000000
</code></pre>
<p>Accessor dot notation is usable with more than just structure fields.
It can also be used for functions that take any number of arguments.
More generally, accessor notation has the form <code class="hljs">TARGET.f ARG1 ARG2 ...</code>.
If <code class="hljs">TARGET</code> has type <code class="hljs">T</code>, the function named <code class="hljs">T.f</code> is called.
<code class="hljs">TARGET</code> becomes its leftmost argument of type <code class="hljs">T</code>, which is often but not always the first one, and <code class="hljs">ARG1 ARG2 ...</code> are provided in order as the remaining arguments.
For instance, <code class="hljs">String.append</code> can be invoked from a string with accessor notation, even though <code class="hljs">String</code> is not a structure with an <code class="hljs">append</code> field.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> <span class="hljs-string">"one string"</span>.append <span class="hljs-string">" and another"</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">"one string and another"
</code></pre>
<p>In that example, <code class="hljs">TARGET</code> represents <code class="hljs">"one string"</code> and <code class="hljs">ARG1</code> represents <code class="hljs">" and another"</code>.</p>
<p>The function <code class="hljs">Point.modifyBoth</code> (that is, <code class="hljs">modifyBoth</code> defined in the <code class="hljs">Point</code> namespace) applies a function to both fields in a <code class="hljs">Point</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">t</span>.<span class="hljs-title">m</span><span class="hljs-title">o</span><span class="hljs-title">d</span><span class="hljs-title">i</span><span class="hljs-title">f</span><span class="hljs-title">y</span><span class="hljs-title">B</span><span class="hljs-title">o</span><span class="hljs-title">t</span><span class="hljs-title">h</span> <span class="hljs-params">(f : Float â Float)</span> <span class="hljs-params">(p : Point)</span> <span class="hljs-symbol">:</span></span> Point :=
  { x := f p.x, y := f p.y }
</code></pre>
<p>Even though the <code class="hljs">Point</code> argument comes after the function argument, it can be used with dot notation as well:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> fourAndThree.modifyBoth Float.floor
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">{ x := 4.000000, y := 3.000000 }
</code></pre>
<p>In this case, <code class="hljs">TARGET</code> represents <code class="hljs">fourAndThree</code>, while <code class="hljs">ARG1</code> is <code class="hljs">Float.floor</code>.
This is because the target of the accessor notation is used as the first argument in which the type matches, not necessarily the first argument.</p>
<h2 id="exercises-2"><a class="header" href="#exercises-2">Exercises</a></h2>
<ul>
<li>Define a structure named <code class="hljs">RectangularPrism</code> that contains the height, width, and depth of a rectangular prism, each as a <code class="hljs">Float</code>.</li>
<li>Define a function named <code class="hljs">volume : RectangularPrism â Float</code> that computes the volume of a rectangular prism.</li>
<li>Define a structure named <code class="hljs">Segment</code> that represents a line segment by its endpoints, and define a function <code class="hljs">length : Segment â Float</code> that computes the length of a line segment. <code class="hljs">Segment</code> should have at most two fields.</li>
<li>Which names are introduced by the declaration of <code class="hljs">RectangularPrism</code>?</li>
<li>Which names are introduced by the following declarations of <code class="hljs">Hamster</code> and <code class="hljs">Book</code>? What are their types?</li>
</ul>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">H</span><span class="hljs-title">a</span><span class="hljs-title">m</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span></span> <span class="hljs-keyword">where</span>
  name : String
  fluffy : Bool
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">B</span><span class="hljs-title">o</span><span class="hljs-title">o</span><span class="hljs-title">k</span></span> <span class="hljs-keyword">where</span>
  makeBook ::
  title : String
  author : String
  price : Float
</code></pre>
<div style="break-before:page;page-break-before:always"></div><h1 id="datatypes-and-patterns"><a class="header" href="#datatypes-and-patterns">Datatypes and Patterns</a></h1>
<p>Structures enable multiple independent pieces of data to be combined into a coherent whole that is represented by a brand new type.
Types such as structures that group together a collection of values are called <em>product types</em>.
Many domain concepts, however, can't be naturally represented as structures.
For instance, an application might need to track user permissions, where some users are document owners, some may edit documents, and others may only read them.
A calculator has a number of binary operators, such as addition, subtraction, and multiplication.
Structures do not provide an easy way to encode multiple choices.</p>
<p>Similarly, while a structure is an excellent way to keep track of a fixed set of fields, many applications require data that may contain an arbitrary number of elements.
Most classic data structures, such as trees and lists, have a recursive structure, where the tail of a list is itself a list, or where the left and right branches of a binary tree are themselves binary trees.
In the aforementioned calculator, the structure of expressions themselves is recursive.
The summands in an addition expression may themselves be multiplication expressions, for instance.</p>
<p>Datatypes that allow choices are called <em>sum types</em> and datatypes that can include instances of themselves are called <em>recursive datatypes</em>.
Recursive sum types are called <em>inductive datatypes</em>, because mathematical induction may be used to prove statements about them.
When programming, inductive datatypes are consumed through pattern matching and recursive functions.</p>
<p>Many of the built-in types are actually inductive datatypes in the standard library.
For instance, <code class="hljs">Bool</code> is an inductive datatype:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Bool <span class="hljs-keyword">where</span>
  | false : Bool
  | true : Bool
</code></pre>
<p>This definition has two main parts.
The first line provides the name of the new type (<code class="hljs">Bool</code>), while the remaining lines each describe a constructor.
As with constructors of structures, constructors of inductive datatypes are mere inert receivers of and containers for other data, rather than places to insert arbitrary initialization and validation code.
Unlike structures, inductive datatypes may have multiple constructors.
Here, there are two constructors, <code class="hljs">true</code> and <code class="hljs">false</code>, and neither takes any arguments.
Just as a structure declaration places its names in a namespace named after the declared type, an inductive datatype places the names of its constructors in a namespace.
In the Lean standard library, <code class="hljs">true</code> and <code class="hljs">false</code> are re-exported from this namespace so that they can be written alone, rather than as <code class="hljs">Bool.true</code> and <code class="hljs">Bool.false</code>, respectively.</p>
<p>From a data modeling perspective, inductive datatypes are used in many of the same contexts where a sealed abstract class might be used in other languages.
In languages like C# or Java, one might write a similar definition of <code class="hljs">Bool</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-C# hljs">abstract <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bool</span> {</span>}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">True</span> :</span> Bool {}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">False</span> :</span> Bool {}
</code></pre>
<p>However, the specifics of these representations are fairly different. In particular, each non-abstract class creates both a new type and new ways of allocating data. In the object-oriented example, <code class="hljs">True</code> and <code class="hljs">False</code> are both types that are more specific than <code class="hljs">Bool</code>, while the Lean definition introduces only the new type <code class="hljs">Bool</code>.</p>
<p>The type <code class="hljs">Nat</code> of non-negative integers is an inductive datatype:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Nat <span class="hljs-keyword">where</span>
  | zero : Nat
  | succ (n : Nat) : Nat
</code></pre>
<p>Here, <code class="hljs">zero</code> represents 0, while <code class="hljs">succ</code> represents the successor of some other number.
The <code class="hljs">Nat</code> mentioned in <code class="hljs">succ</code>'s declaration is the very type <code class="hljs">Nat</code> that is in the process of being defined.
<em>Successor</em> means "one greater than", so the successor of five is six and the successor of 32,185 is 32,186.
Using this definition, <code class="hljs">4</code> is represented as <code class="hljs">Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))</code>.
This definition is almost like the definition of <code class="hljs">Bool</code> with slightly different names.
The only real difference is that <code class="hljs">succ</code> is followed by <code class="hljs">(n : Nat)</code>, which specifies that the constructor <code class="hljs">succ</code> takes an argument of type <code class="hljs">Nat</code> which happens to be named <code class="hljs">n</code>.
The names <code class="hljs">zero</code> and <code class="hljs">succ</code> are in a namespace named after their type, so they must be referred to as <code class="hljs">Nat.zero</code> and <code class="hljs">Nat.succ</code>, respectively.</p>
<p>Argument names, such as <code class="hljs">n</code>, may occur in Lean's error messages and in feedback provided when writing mathematical proofs.
Lean also has an optional syntax for providing arguments by name.
Generally, however, the choice of argument name is less important than the choice of a structure field name, as it does not form as large a part of the API.</p>
<p>In C# or Java, <code class="hljs">Nat</code> could be defined as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-C# hljs">abstract <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Nat</span> {</span>}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zero</span> :</span> Nat {}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Succ</span> :</span> Nat {
  <span class="hljs-keyword">public</span> Nat n;
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Succ</span><span class="hljs-params">(Nat pred)</span> </span>{
    n = pred;
  }
}
</code></pre>
<p>Just as in the <code class="hljs">Bool</code> example above, this defines more types than the Lean equivalent.
Additionally, this example highlights how Lean datatype constructors are much more like subclasses of an abstract class than they are like constructors in C# or Java, as the constructor shown here contains initialization code to be executed.</p>
<p>Sum types are also similar to using a string tag to encode discriminated unions in TypeScript.
In TypeScript, <code class="hljs">Nat</code> could be defined as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-typescript hljs"><span class="hljs-keyword">interface</span> Zero {
    <span class="hljs-attr">tag</span>: <span class="hljs-string">"zero"</span>;
}

<span class="hljs-keyword">interface</span> Succ {
    <span class="hljs-attr">tag</span>: <span class="hljs-string">"succ"</span>;
    predecessor: Nat;
}

<span class="hljs-keyword">type</span> Nat = Zero | Succ;
</code></pre>
<p>Just like C# and Java, this encoding ends up with more types than in Lean, because <code class="hljs">Zero</code> and <code class="hljs">Succ</code> are each a type on their own.
It also illustrates that Lean constructors correspond to objects in JavaScript or TypeScript that include a tag that identifies the contents.</p>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h2>
<p>In many languages, these kinds of data are consumed by first using an instance-of operator to check which subclass has been received and then reading the values of the fields that are available in the given subclass.
The instance-of check determines which code to run, ensuring that the data needed by this code is available, while the fields themselves provide the data.
In Lean, both of these purposes are simultaneously served by <em>pattern matching</em>.</p>
<p>An example of a function that uses pattern matching is <code class="hljs">isZero</code>, which is a function that returns <code class="hljs">true</code> when its argument is <code class="hljs">Nat.zero</code>, or false otherwise.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">Z</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">o</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span> Bool :=
  <span class="hljs-keyword">match</span> n <span class="hljs-keyword">with</span>
  | Nat.zero =&gt; true
  | Nat.succ k =&gt; false
</code></pre>
<p>The <code class="hljs">match</code> expression is provided the function's argument <code class="hljs">n</code> for destructuring.
If <code class="hljs">n</code> was constructed by <code class="hljs">Nat.zero</code>, then the first branch of the pattern match is taken, and the result is <code class="hljs">true</code>.
If <code class="hljs">n</code> was constructed by <code class="hljs">Nat.succ</code>, then the second branch is taken, and the result is <code class="hljs">false</code>.</p>
<p>Step-by-step, evaluation of <code class="hljs">isZero Nat.zero</code> proceeds as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">isZero Nat.zero
===&gt;
<span class="hljs-keyword">match</span> Nat.zero <span class="hljs-keyword">with</span>
| Nat.zero =&gt; true
| Nat.succ k =&gt; false
===&gt;
true
</code></pre>
<p>Evaluation of <code class="hljs">isZero 5</code> proceeds similarly:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">isZero <span class="hljs-number">5</span>
===&gt;
isZero (Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))))
===&gt;
<span class="hljs-keyword">match</span> Nat.succ (Nat.succ (Nat.succ (Nat.succ (Nat.succ Nat.zero)))) <span class="hljs-keyword">with</span>
| Nat.zero =&gt; true
| Nat.succ k =&gt; false
===&gt;
false
</code></pre>
<p>The <code class="hljs">k</code> in the second branch of the pattern in <code class="hljs">isZero</code> is not decorative.
It makes the <code class="hljs">Nat</code> that is the argument to <code class="hljs">succ</code> visible, with the provided name.
That smaller number can then be used to compute the final result of the expression.</p>
<p>Just as the successor of some number <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-1-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-1" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-2"><span class="mi" id="MathJax-Span-3" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span> is one greater than <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-2-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-4" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-5"><span class="mi" id="MathJax-Span-6" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span> (that is, <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-3-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>+</mo><mn>1</mn></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-7" style="width:2.946em;display:inline-block"><span style="display:inline-block;position:relative;width:2.381em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1002.3em,2.583em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-8"><span class="mi" id="MathJax-Span-9" style="font-family:MathJax_Math;font-style:italic">n</span><span class="mo" id="MathJax-Span-10" style="font-family:MathJax_Main;padding-left:0.244em">+</span><span class="mn" id="MathJax-Span-11" style="font-family:MathJax_Main;padding-left:0.244em">1</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.148em;border-left:0px solid;width:0px;height:1.052em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>+</mo><mn>1</mn></math></span></span>), the predecessor of a number is one less than it.
If <code class="hljs">pred</code> is a function that finds the predecessor of a <code class="hljs">Nat</code>, then it should be the case that the following examples find the expected result:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> pred <span class="hljs-number">5</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">4
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> pred <span class="hljs-number">839</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">838
</code></pre>
<p>Because <code class="hljs">Nat</code> cannot represent negative numbers, <code class="hljs">0</code> is a bit of a conundrum.
Usually, when working with <code class="hljs">Nat</code>, operators that would ordinarily produce a negative number are redefined to produce <code class="hljs">0</code> itself:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> pred <span class="hljs-number">0</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">0
</code></pre>
<p>To find the predecessor of a <code class="hljs">Nat</code>, the first step is to check which constructor was used to create it.
If it was <code class="hljs">Nat.zero</code>, then the result is <code class="hljs">Nat.zero</code>.
If it was <code class="hljs">Nat.succ</code>, then the name <code class="hljs">k</code> is used to refer to the <code class="hljs">Nat</code> underneath it.
And this <code class="hljs">Nat</code> is the desired predecessor, so the result of the <code class="hljs">Nat.succ</code> branch is <code class="hljs">k</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">d</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  <span class="hljs-keyword">match</span> n <span class="hljs-keyword">with</span>
  | Nat.zero =&gt; Nat.zero
  | Nat.succ k =&gt; k
</code></pre>
<p>Applying this function to <code class="hljs">5</code> yields the following steps:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">pred <span class="hljs-number">5</span>
===&gt;
pred (Nat.succ <span class="hljs-number">4</span>)
===&gt;
<span class="hljs-keyword">match</span> Nat.succ <span class="hljs-number">4</span> <span class="hljs-keyword">with</span>
| Nat.zero =&gt; Nat.zero
| Nat.succ k =&gt; k
===&gt;
<span class="hljs-number">4</span>
</code></pre>
<p>Pattern matching can be used with structures as well as with sum types.
For instance, a function that extracts the third dimension from a <code class="hljs">Point3D</code> can be written as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">h</span> <span class="hljs-params">(p : Point3D)</span> <span class="hljs-symbol">:</span></span> Float :=
  <span class="hljs-keyword">match</span> p <span class="hljs-keyword">with</span>
  | { x:= h, y := w, z := d } =&gt; d
</code></pre>
<p>In this case, it would have been much simpler to just use the <code class="hljs">z</code> accessor, but structure patterns are occasionally the simplest way to write a function.</p>
<h2 id="recursive-functions"><a class="header" href="#recursive-functions">Recursive Functions</a></h2>
<p>Definitions that refer to the name being defined are called <em>recursive definitions</em>.
Inductive datatypes are allowed to be recursive; indeed, <code class="hljs">Nat</code> is an example of such a datatype because <code class="hljs">succ</code> demands another <code class="hljs">Nat</code>.
Recursive datatypes can represent arbitrarily large data, limited only by technical factors like available memory.
Just as it would be impossible to write down one constructor for each natural number in the datatype definition, it is also impossible to write down a pattern match case for each possibility.</p>
<p>Recursive datatypes are nicely complemented by recursive functions.
A simple recursive function over <code class="hljs">Nat</code> checks whether its argument is even.
In this case, <code class="hljs">zero</code> is even.
Non-recursive branches of the code like this one are called <em>base cases</em>.
The successor of an odd number is even, and the successor of an even number is odd.
This means that a number built with <code class="hljs">succ</code> is even if and only if its argument is not even.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span> Bool :=
  <span class="hljs-keyword">match</span> n <span class="hljs-keyword">with</span>
  | Nat.zero =&gt; true
  | Nat.succ k =&gt; not (even k)
</code></pre>
<p>This pattern of thought is typical for writing recursive functions on <code class="hljs">Nat</code>.
First, identify what to do for <code class="hljs">zero</code>.
Then, determine how to transform a result for an arbitrary <code class="hljs">Nat</code> into a result for its successor, and apply this transformation to the result of the recursive call.
This pattern is called <em>structural recursion</em>.</p>
<p>Unlike many languages, Lean ensures by default that every recursive function will eventually reach a base case.
From a programming perspective, this rules out accidental infinite loops.
But this feature is especially important when proving theorems, where infinite loops cause major difficulties.
A consequence of this is that Lean will not accept a version of <code class="hljs">even</code> that attempts to invoke itself recursively on the original number:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">L</span><span class="hljs-title">o</span><span class="hljs-title">o</span><span class="hljs-title">p</span><span class="hljs-title">s</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span> Bool :=
  <span class="hljs-keyword">match</span> n <span class="hljs-keyword">with</span>
  | Nat.zero =&gt; true
  | Nat.succ k =&gt; not (evenLoops n)
</code></pre>
<p>The important part of the error message is that Lean could not determine that the recursive function always reaches a base case (because it doesn't).</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">fail to show termination for
  evenLoops
with errors
structural recursion cannot be used

well-founded recursion cannot be used, 'evenLoops' does not take any (non-fixed) arguments
</code></pre>
<p>Even though addition takes two arguments, only one of them needs to be inspected.
To add zero to a number <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-4-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-12" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-13"><span class="mi" id="MathJax-Span-14" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span>, just return <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-5-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-15" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-16"><span class="mi" id="MathJax-Span-17" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span>.
To add the successor of <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-6-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-18" style="width:0.647em;display:inline-block"><span style="display:inline-block;position:relative;width:0.526em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.53em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-19"><span class="mi" id="MathJax-Span-20" style="font-family:MathJax_Math;font-style:italic">k</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span> to <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-7-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-21" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-22"><span class="mi" id="MathJax-Span-23" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span>, take the successor of the result of adding <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-8-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-24" style="width:0.647em;display:inline-block"><span style="display:inline-block;position:relative;width:0.526em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.53em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-25"><span class="mi" id="MathJax-Span-26" style="font-family:MathJax_Math;font-style:italic">k</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span> to <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-9-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-27" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-28"><span class="mi" id="MathJax-Span-29" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-params">(k : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  <span class="hljs-keyword">match</span> k <span class="hljs-keyword">with</span>
  | Nat.zero =&gt; n
  | Nat.succ k' =&gt; Nat.succ (plus n k')
</code></pre>
<p>In the definition of <code class="hljs">plus</code>, the name <code class="hljs">k'</code> is chosen to indicate that it is connected to, but not identical with, the argument <code class="hljs">k</code>.
For instance, walking through the evaluation of <code class="hljs">plus 3 2</code> yields the following steps:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">plus <span class="hljs-number">3</span> <span class="hljs-number">2</span>
===&gt;
plus <span class="hljs-number">3</span> (Nat.succ (Nat.succ Nat.zero))
===&gt;
<span class="hljs-keyword">match</span> Nat.succ (Nat.succ Nat.zero) <span class="hljs-keyword">with</span>
| Nat.zero =&gt; <span class="hljs-number">3</span>
| Nat.succ k' =&gt; Nat.succ (plus <span class="hljs-number">3</span> k')
===&gt;
Nat.succ (plus <span class="hljs-number">3</span> (Nat.succ Nat.zero))
===&gt;
Nat.succ (<span class="hljs-keyword">match</span> Nat.succ Nat.zero <span class="hljs-keyword">with</span>
| Nat.zero =&gt; <span class="hljs-number">3</span>
| Nat.succ k' =&gt; Nat.succ (plus <span class="hljs-number">3</span> k'))
===&gt;
Nat.succ (Nat.succ (plus <span class="hljs-number">3</span> Nat.zero))
===&gt;
Nat.succ (Nat.succ (<span class="hljs-keyword">match</span> Nat.zero <span class="hljs-keyword">with</span>
| Nat.zero =&gt; <span class="hljs-number">3</span>
| Nat.succ k' =&gt; Nat.succ (plus <span class="hljs-number">3</span> k')))
===&gt;
Nat.succ (Nat.succ <span class="hljs-number">3</span>)
===&gt;
<span class="hljs-number">5</span>
</code></pre>
<p>One way to think about addition is that <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-10-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>+</mo><mi>k</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-30" style="width:2.946em;display:inline-block"><span style="display:inline-block;position:relative;width:2.381em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1002.38em,2.583em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-31"><span class="mi" id="MathJax-Span-32" style="font-family:MathJax_Math;font-style:italic">n</span><span class="mo" id="MathJax-Span-33" style="font-family:MathJax_Main;padding-left:0.244em">+</span><span class="mi" id="MathJax-Span-34" style="font-family:MathJax_Math;font-style:italic;padding-left:0.244em">k</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.148em;border-left:0px solid;width:0px;height:1.052em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>+</mo><mi>k</mi></math></span></span> applies <code class="hljs">Nat.succ</code> <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-11-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-35" style="width:0.647em;display:inline-block"><span style="display:inline-block;position:relative;width:0.526em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.53em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-36"><span class="mi" id="MathJax-Span-37" style="font-family:MathJax_Math;font-style:italic">k</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span> times to <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-12-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-38" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-39"><span class="mi" id="MathJax-Span-40" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span>.
Similarly, multiplication <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-13-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>&amp;#xD7;</mo><mi>k</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-41" style="width:2.946em;display:inline-block"><span style="display:inline-block;position:relative;width:2.381em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1002.38em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-42"><span class="mi" id="MathJax-Span-43" style="font-family:MathJax_Math;font-style:italic">n</span><span class="mo" id="MathJax-Span-44" style="font-family:MathJax_Main;padding-left:0.244em">Ã</span><span class="mi" id="MathJax-Span-45" style="font-family:MathJax_Math;font-style:italic;padding-left:0.244em">k</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>Ã</mo><mi>k</mi></math></span></span> adds <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-14-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-46" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-47"><span class="mi" id="MathJax-Span-48" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span> to itself <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-15-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-49" style="width:0.647em;display:inline-block"><span style="display:inline-block;position:relative;width:0.526em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.53em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-50"><span class="mi" id="MathJax-Span-51" style="font-family:MathJax_Math;font-style:italic">k</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span> times and subtraction <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-16-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>&amp;#x2212;</mo><mi>k</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-52" style="width:2.946em;display:inline-block"><span style="display:inline-block;position:relative;width:2.381em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1002.38em,2.583em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-53"><span class="mi" id="MathJax-Span-54" style="font-family:MathJax_Math;font-style:italic">n</span><span class="mo" id="MathJax-Span-55" style="font-family:MathJax_Main;padding-left:0.244em">â</span><span class="mi" id="MathJax-Span-56" style="font-family:MathJax_Math;font-style:italic;padding-left:0.244em">k</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.148em;border-left:0px solid;width:0px;height:1.052em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>â</mo><mi>k</mi></math></span></span> takes <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-17-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-57" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-58"><span class="mi" id="MathJax-Span-59" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span>'s predecessor <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-18-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-60" style="width:0.647em;display:inline-block"><span style="display:inline-block;position:relative;width:0.526em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.53em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-61"><span class="mi" id="MathJax-Span-62" style="font-family:MathJax_Math;font-style:italic">k</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span> times.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">s</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-params">(k : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  <span class="hljs-keyword">match</span> k <span class="hljs-keyword">with</span>
  | Nat.zero =&gt; Nat.zero
  | Nat.succ k' =&gt; plus n (times n k')

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">u</span><span class="hljs-title">s</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-params">(k : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  <span class="hljs-keyword">match</span> k <span class="hljs-keyword">with</span>
  | Nat.zero =&gt; n
  | Nat.succ k' =&gt; pred (minus n k')
</code></pre>
<p>Not every function can be easily written using structural recursion.
The understanding of addition as iterated <code class="hljs">Nat.succ</code>, multiplication as iterated addition, and subtraction as iterated predecessor suggests an implementation of division as iterated subtraction.
In this case, if the numerator is less than the divisor, the result is zero.
Otherwise, the result is the successor of dividing the numerator minus the divisor by the divisor.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">i</span><span class="hljs-title">v</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-params">(k : Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  <span class="hljs-keyword">if</span> n &lt; k <span class="hljs-keyword">then</span>
    <span class="hljs-number">0</span>
  <span class="hljs-keyword">else</span> Nat.succ (div (n - k) k)
</code></pre>
<p>As long as the second argument is not <code class="hljs">0</code>, this program terminates, as it always makes progress towards the base case.
However, it is not structurally recursive, because it doesn't follow the pattern of finding a result for zero and transforming a result for a smaller <code class="hljs">Nat</code> into a result for its successor.
In particular, the recursive invocation of the function is applied to the result of another function call, rather than to an input constructor's argument.
Thus, Lean rejects it with the following message:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">fail to show termination for
  div
with errors
argument #1 was not used for structural recursion
  failed to eliminate recursive application
    div (n - k) k

argument #2 was not used for structural recursion
  failed to eliminate recursive application
    div (n - k) k

structural recursion cannot be used

failed to prove termination, use `termination_by` to specify a well-founded relation
</code></pre>
<p>This message means that <code class="hljs">div</code> requires a manual proof of termination.
This topic is explored in <a href="https://leanprover.github.io/functional_programming_in_lean/programs-proofs/inequalities.html#division-as-iterated-subtraction">the final chapter</a>.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h1>
<p>Just as in most languages, types in Lean can take arguments.
For instance, the type <code class="hljs">List Nat</code> describes lists of natural numbers, <code class="hljs">List String</code> describes lists of strings, and <code class="hljs">List (List Point)</code> describes lists of lists of points.
This is very similar to <code class="hljs">List&lt;Nat&gt;</code>, <code class="hljs">List&lt;String&gt;</code>, or <code class="hljs">List&lt;List&lt;Point&gt;&gt;</code> in a language like C# or Java.
Just as Lean uses a space to pass an argument to a function, it uses a space to pass an argument to a type.</p>
<p>In functional programming, the term <em>polymorphism</em> typically refers to datatypes and definitions that take types as arguments.
This is different from the object-oriented programming community, where the term typically refers to subclasses that may override some behavior of their superclass.
In this book, "polymorphism" always refers to the first sense of the word.
These type arguments can be used in the datatype or definition, which allows the same datatype or definition to be used with any type that results from replacing the arguments' names with some other types.</p>
<p>The <code class="hljs">Point</code> structure requires that both the <code class="hljs">x</code> and <code class="hljs">y</code> fields are <code class="hljs">Float</code>s.
There is, however, nothing about points that require a specific representation for each coordinate.
A polymorphic version of <code class="hljs">Point</code>, called <code class="hljs">PPoint</code>, can take a type as an argument, and then use that type for both fields:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">P</span><span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span></span> <span class="hljs-keyword">where</span>
  x : Î±
  y : Î±
<span class="hljs-keyword">deriving</span> Repr
</code></pre>
<p>Just as a function definition's arguments are written immediately after the name being defined, a structure's arguments are written immediately after the structure's name.
It is customary to use Greek letters to name type arguments in Lean when no more specific name suggests itself.
<code class="hljs">Type</code> is a type that describes other types, so <code class="hljs">Nat</code>, <code class="hljs">List String</code>, and <code class="hljs">PPoint Int</code> all have type <code class="hljs">Type</code>.</p>
<p>Just like <code class="hljs">List</code>, <code class="hljs">PPoint</code> can be used by providing a specific type as its argument:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">n</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">O</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">g</span><span class="hljs-title">i</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> PPoint Nat :=
  { x := Nat.zero, y := Nat.zero }
</code></pre>
<p>In this example, both fields are expected to be <code class="hljs">Nat</code>s.
Just as a function is called by replacing its argument variables with its argument values, providing <code class="hljs">PPoint</code> with the type <code class="hljs">Nat</code> as an argument yields a structure in which the fields <code class="hljs">x</code> and <code class="hljs">y</code> have the type <code class="hljs">Nat</code>, because the argument name <code class="hljs">Î±</code> has been replaced by the argument type <code class="hljs">Nat</code>.
Types are ordinary expressions in Lean, so passing arguments to polymorphic types (like <code class="hljs">PPoint</code>) doesn't require any special syntax.</p>
<p>Definitions may also take types as arguments, which makes them polymorphic.
The function <code class="hljs">replaceX</code> replaces the <code class="hljs">x</code> field of a <code class="hljs">PPoint</code> with a new value.
In order to allow <code class="hljs">replaceX</code> to work with <em>any</em> polymorphic point, it must be polymorphic itself.
This is achieved by having its first argument be the type of the point's fields, with later arguments referring back to the first argument's name.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">a</span><span class="hljs-title">c</span><span class="hljs-title">e</span><span class="hljs-title">X</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(point : PPoint Î±)</span> <span class="hljs-params">(newX : Î±)</span> <span class="hljs-symbol">:</span></span> PPoint Î± :=
  { point <span class="hljs-keyword">with</span> x := newX }
</code></pre>
<p>In other words, when the types of the arguments <code class="hljs">point</code> and <code class="hljs">newX</code> mention <code class="hljs">Î±</code>, they are referring to <em>whichever type was provided as the first argument</em>.
This is similar to the way that function argument names refer to the values that were provided when they occur in the function's body.</p>
<p>This can be seen by asking Lean to check the type of <code class="hljs">replaceX</code>, and then asking it to check the type of <code class="hljs">replaceX Nat</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> (replaceX)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">replaceX : (Î± : Type) â PPoint Î± â Î± â PPoint Î±
</code></pre>
<p>This function type includes the <em>name</em> of the first argument, and later arguments in the type refer back to this name.
Just as the value of a function application is found by replacing the argument name with the provided argument value in the function's body, the type of a function application is found by replacing the argument's name with the provided value in the function's return type.
Providing the first argument, <code class="hljs">Nat</code>, causes all occurrences of <code class="hljs">Î±</code> in the remainder of the type to be replaced with <code class="hljs">Nat</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> replaceX Nat
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">replaceX Nat : PPoint Nat â Nat â PPoint Nat
</code></pre>
<p>Because the remaining arguments are not explicitly named, no further substitution occurs as more arguments are provided:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> replaceX Nat natOrigin
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">replaceX Nat natOrigin : Nat â PPoint Nat
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> replaceX Nat natOrigin <span class="hljs-number">5</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">replaceX Nat natOrigin 5 : PPoint Nat
</code></pre>
<p>The fact that the type of the whole function application expression was determined by passing a type as an argument has no bearing on the ability to evaluate it.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> replaceX Nat natOrigin <span class="hljs-number">5</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">{ x := 5, y := 0 }
</code></pre>
<p>Polymorphic functions work by taking a named type argument and having later types refer to the argument's name.
However, there's nothing special about type arguments that allows them to be named.
Given a datatype that represents positive or negative signs:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Sign <span class="hljs-keyword">where</span>
  | pos
  | neg
</code></pre>
<p>it is possible to write a function whose argument is a sign.
If the argument is positive, the function returns a <code class="hljs">Nat</code>, while if it's negative, it returns an <code class="hljs">Int</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-title">o</span><span class="hljs-title">s</span><span class="hljs-title">O</span><span class="hljs-title">r</span><span class="hljs-title">N</span><span class="hljs-title">e</span><span class="hljs-title">g</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span> <span class="hljs-params">(s : Sign)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-keyword">match</span> s <span class="hljs-keyword">with</span> | Sign.pos =&gt; Nat | Sign.neg =&gt; Int :=
  <span class="hljs-keyword">match</span> s <span class="hljs-keyword">with</span>
  | Sign.pos =&gt; (<span class="hljs-number">3</span> : Nat)
  | Sign.neg =&gt; (-<span class="hljs-number">3</span> : Int)
</code></pre>
<p>Because types are first class and can be computed using the ordinary rules of the Lean language, they can be computed by pattern-matching against a datatype.
When Lean is checking this function, it uses the fact that the <code class="hljs">match</code>-expression in the function's body corresponds to the <code class="hljs">match</code>-expression in the type to make <code class="hljs">Nat</code> be the expected type for the <code class="hljs">pos</code> case and to make <code class="hljs">Int</code> be the expected type for the <code class="hljs">neg</code> case.</p>
<p>Applying <code class="hljs">posOrNegThree</code> to <code class="hljs">Sign.pos</code> results in the argument name <code class="hljs">s</code> in both the body of the function and its return type being replaced by <code class="hljs">Sign.pos</code>.
Evaluation can occur both in the expression and its type:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">(posOrNegThree Sign.pos : <span class="hljs-keyword">match</span> Sign.pos <span class="hljs-keyword">with</span> | Sign.pos =&gt; Nat | Sign.neg =&gt; Int)
===&gt;
((<span class="hljs-keyword">match</span> Sign.pos <span class="hljs-keyword">with</span>
  | Sign.pos =&gt; (<span class="hljs-number">3</span> : Nat)
  | Sign.neg =&gt; (-<span class="hljs-number">3</span> : Int)) :
 <span class="hljs-keyword">match</span> Sign.pos <span class="hljs-keyword">with</span> | Sign.pos =&gt; Nat | Sign.neg =&gt; Int)
===&gt;
((<span class="hljs-number">3</span> : Nat) : Nat)
===&gt;
<span class="hljs-number">3</span>
</code></pre>
<h2 id="linked-lists"><a class="header" href="#linked-lists">Linked Lists</a></h2>
<p>Lean's standard library includes a canonical linked list datatype, called <code class="hljs">List</code>, and special syntax that makes it more convenient to use.
Lists are written in square brackets.
For instance, a list that contains the prime numbers less than 10 can be written:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">U</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r10</span> <span class="hljs-symbol">:</span></span> List Nat := [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>]
</code></pre>
<p>Behind the scenes, <code class="hljs">List</code> is an inductive datatype, defined like this:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> List (Î± : <span class="hljs-built_in">Type</span>) <span class="hljs-keyword">where</span>
  | nil : List Î±
  | cons : Î± â List Î± â List Î±
</code></pre>
<p>The actual definition in the standard library is slightly different, because it uses features that have not yet been presented, but it is substantially similar.
This definition says that <code class="hljs">List</code> takes a single type as its argument, just as <code class="hljs">PPoint</code> did.
This type is the type of the entries stored in the list.
According to the constructors, a <code class="hljs">List Î±</code> can be built with either <code class="hljs">nil</code> or <code class="hljs">cons</code>.
The constructor <code class="hljs">nil</code> represents empty lists and the constructor <code class="hljs">cons</code> is used for non-empty lists.
The first argument to <code class="hljs">cons</code> is the head of the list, and the second argument is its tail.
A list that contains <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-19-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-63" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-64"><span class="mi" id="MathJax-Span-65" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span> entries contains <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-20-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-66" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-67"><span class="mi" id="MathJax-Span-68" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span> <code class="hljs">cons</code> constructors, the last of which has <code class="hljs">nil</code> as its tail.</p>
<p>The <code class="hljs">primesUnder10</code> example can be written more explicitly by using <code class="hljs">List</code>'s constructors directly:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">x</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">U</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r10</span> <span class="hljs-symbol">:</span></span> List Nat :=
  List.cons <span class="hljs-number">2</span> (List.cons <span class="hljs-number">3</span> (List.cons <span class="hljs-number">5</span> (List.cons <span class="hljs-number">7</span> List.nil)))
</code></pre>
<p>These two definitions are completely equivalent, but <code class="hljs">primesUnder10</code> is much easier to read than <code class="hljs">explicitPrimesUnder10</code>.</p>
<p>Functions that consume <code class="hljs">List</code>s can be defined in much the same way as functions that consume <code class="hljs">Nat</code>s.
Indeed, one way to think of a linked list is as a <code class="hljs">Nat</code> that has an extra data field dangling off each <code class="hljs">succ</code> constructor.
From this point of view, computing the length of a list is the process of replacing each <code class="hljs">cons</code> with a <code class="hljs">succ</code> and the final <code class="hljs">nil</code> with a <code class="hljs">zero</code>.
Just as <code class="hljs">replaceX</code> took the type of the fields of the point as an argument, <code class="hljs">length</code> takes the type of the list's entries.
For example, if the list contains strings, then the first argument is <code class="hljs">String</code>: <code class="hljs">length String ["Sourdough", "bread"]</code>.
It should compute like this:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">length String ["Sourdough", "bread"]
===&gt;
length String (List.cons "Sourdough" (List.cons "bread" List.nil))
===&gt;
Nat.succ (length String (List.cons "bread" List.nil))
===&gt;
Nat.succ (Nat.succ (length String List.nil))
===&gt;
Nat.succ (Nat.succ Nat.zero)
===&gt;
2
</code></pre>
<p>The definition of <code class="hljs">length</code> is both polymorphic (because it takes the list entry type as an argument) and recursive (because it refers to itself).
Generally, functions follow the shape of the data: recursive datatypes lead to recursive functions, and polymorphic datatypes lead to polymorphic functions.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">g</span><span class="hljs-title">t</span><span class="hljs-title">h</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Nat :=
  <span class="hljs-keyword">match</span> xs <span class="hljs-keyword">with</span>
  | List.nil =&gt; Nat.zero
  | List.cons y ys =&gt; Nat.succ (length Î± ys)
</code></pre>
<p>Names such as <code class="hljs">xs</code> and <code class="hljs">ys</code> are conventionally used to stand for lists of unknown values.
The <code class="hljs">s</code> in the name indicates that they are plural, so they are pronounced "exes" and "whys" rather than "x s" and "y s".</p>
<p>To make it easier to read functions on lists, the bracket notation <code class="hljs">[]</code> can be used to pattern-match against <code class="hljs">nil</code>, and an infix <code class="hljs">::</code> can be used in place of <code class="hljs">cons</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">g</span><span class="hljs-title">t</span><span class="hljs-title">h</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Nat :=
  <span class="hljs-keyword">match</span> xs <span class="hljs-keyword">with</span>
  | [] =&gt; <span class="hljs-number">0</span>
  | y :: ys =&gt; Nat.succ (length Î± ys)
</code></pre>
<h2 id="implicit-arguments"><a class="header" href="#implicit-arguments">Implicit Arguments</a></h2>
<p>Both <code class="hljs">replaceX</code> and <code class="hljs">length</code> are somewhat bureaucratic to use, because the type argument is typically uniquely determined by the later values.
Indeed, in most languages, the compiler is perfectly capable of determining type arguments on its own, and only occasionally needs help from users.
This is also the case in Lean.
Arguments can be declared <em>implicit</em> by wrapping them in curly braces instead of parentheses when defining a function.
For instance, a version of <code class="hljs">replaceX</code> with an implicit type argument looks like this:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">a</span><span class="hljs-title">c</span><span class="hljs-title">e</span><span class="hljs-title">X</span> <span class="hljs-params">{Î± : <span class="hljs-built_in">Type</span>}</span> <span class="hljs-params">(point : PPoint Î±)</span> <span class="hljs-params">(newX : Î±)</span> <span class="hljs-symbol">:</span></span> PPoint Î± :=
  { point <span class="hljs-keyword">with</span> x := newX }
</code></pre>
<p>It can be used with <code class="hljs">natOrigin</code> without providing <code class="hljs">Nat</code> explicitly, because Lean can <em>infer</em> the value of <code class="hljs">Î±</code> from the later arguments:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> replaceX natOrigin <span class="hljs-number">5</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">{ x := 5, y := 0 }
</code></pre>
<p>Similarly, <code class="hljs">length</code> can be redefined to take the entry type implicitly:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">g</span><span class="hljs-title">t</span><span class="hljs-title">h</span> <span class="hljs-params">{Î± : <span class="hljs-built_in">Type</span>}</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Nat :=
  <span class="hljs-keyword">match</span> xs <span class="hljs-keyword">with</span>
  | [] =&gt; <span class="hljs-number">0</span>
  | y :: ys =&gt; Nat.succ (length ys)
</code></pre>
<p>This <code class="hljs">length</code> function can be applied directly to <code class="hljs">primesUnder10</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> length primesUnder10
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">4
</code></pre>
<p>In the standard library, Lean calls this function <code class="hljs">List.length</code>, which means that the dot syntax that is used for structure field access can also be used to find the length of a list:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> primesUnder10.length
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">4
</code></pre>
<p>Just as C# and Java require type arguments to be provided explicitly from time to time, Lean is not always capable of finding implicit arguments.
In these cases, they can be provided using their names.
For instance, a version of <code class="hljs">List.length</code> that only works for lists of integers can be specified by setting <code class="hljs">Î±</code> to <code class="hljs">Int</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> List.length (Î± := Int)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">List.length : List Int â Nat
</code></pre>
<h2 id="more-built-in-datatypes"><a class="header" href="#more-built-in-datatypes">More Built-In Datatypes</a></h2>
<p>In addition to lists, Lean's standard library contains a number of other structures and inductive datatypes that can be used in a variety of contexts.</p>
<h3 id="option"><a class="header" href="#option"><code>Option</code></a></h3>
<p>Not every list has a first entryâsome lists are empty.
Many operations on collections may fail to find what they are looking for.
For instance, a function that finds the first entry in a list may not find any such entry.
It must therefore have a way to signal that there was no first entry.</p>
<p>Many languages have a <code class="hljs">null</code> value that represents the absence of a value.
Instead of equipping existing types with a special <code class="hljs">null</code> value, Lean provides a datatype called <code class="hljs">Option</code> that equips some other type with an indicator for missing values.
For instance, a nullable <code class="hljs">Int</code> is represented by <code class="hljs">Option Int</code>, and a nullable list of strings is represented by the type <code class="hljs">Option (List String)</code>.
Introducing a new type to represent nullability means that the type system ensures that checks for <code class="hljs">null</code> cannot be forgotten, because an <code class="hljs">Option Int</code> can't be used in a context where an <code class="hljs">Int</code> is expected.</p>
<p><code class="hljs">Option</code> has two constructors, called <code class="hljs">some</code> and <code class="hljs">none</code>, that respectively represent the non-null and null versions of the underlying type.
The non-null constructor, <code class="hljs">some</code>, contains the underlying value, while <code class="hljs">none</code> takes no arguments:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Option (Î± : <span class="hljs-built_in">Type</span>) : <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  | none : Option Î±
  | some (val : Î±) : Option Î±
</code></pre>
<p>The <code class="hljs">Option</code> type is very similar to nullable types in languages like C# and Kotlin, but it is not identical.
In these languages, if a type (say, <code class="hljs">Boolean</code>) always refers to actual values of the type (<code class="hljs">true</code> and <code class="hljs">false</code>), the type <code class="hljs">Boolean?</code> or <code class="hljs">Nullable&lt;Boolean&gt;</code> additionally admits the <code class="hljs">null</code> value.
Tracking this in the type system is very useful: the type checker and other tooling can help programmers remember to check for null, and APIs that explicitly describe nullability through type signatures are more informative than ones that don't.
However, these nullable types differ from Lean's <code class="hljs">Option</code> in one very important way, which is that they don't allow multiple layers of optionality.
<code class="hljs">Option (Option Int)</code> can be constructed with <code class="hljs">none</code>, <code class="hljs">some none</code>, or <code class="hljs">some (some 360)</code>.
C#, on the other hand, forbids multiple layers of nullability by only allowing <code class="hljs">?</code> to be added to non-nullable types, while Kotlin treats <code class="hljs">T??</code> as being equivalent to <code class="hljs">T?</code>.
This subtle difference is rarely relevant in practice, but it can matter from time to time.</p>
<p>To find the first entry in a list, if it exists, use <code class="hljs">List.head?</code>.
The question mark is part of the name, and is not related to the use of question marks to indicate nullable types in C# or Kotlin.
In the definition of <code class="hljs">List.head?</code>, an underscore is used to represent the tail of the list.
In patterns, underscores match anything at all, but do not introduce variables to refer to the matched data.
Using underscores instead of names is a way to clearly communicate to readers that part of the input is ignored.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">d?</span> <span class="hljs-params">{Î± : <span class="hljs-built_in">Type</span>}</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Option Î± :=
  <span class="hljs-keyword">match</span> xs <span class="hljs-keyword">with</span>
  | [] =&gt; none
  | y :: _ =&gt; some y
</code></pre>
<p>A Lean naming convention is to define operations that might fail in groups using the suffixes <code class="hljs">?</code> for a version that returns an <code class="hljs">Option</code>, <code class="hljs">!</code> for a version that crashes when provided with invalid input, and <code class="hljs">D</code> for a version that returns a default value when the operation would otherwise fail.
For instance, <code class="hljs">head</code> requires the caller to provide mathematical evidence that the list is not empty, <code class="hljs">head?</code> returns an <code class="hljs">Option</code>, <code class="hljs">head!</code> crashes the program when passed an empty list, and <code class="hljs">headD</code> takes a default value to return in case the list is empty.
The question mark and exclamation mark are part of the name, not special syntax, as Lean's naming rules are more liberal than many languages.</p>
<p>Because <code class="hljs">head?</code> is defined in the <code class="hljs">List</code> namespace, it can be used with accessor notation:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> primesUnder10.head?
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">some 2
</code></pre>
<p>However, attempting to test it on the empty list leads to two errors:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> [].head?
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize implicit argument
  @List.nil ?m.20264
context:
â¢ Type ?u.20261

don't know how to synthesize implicit argument
  @_root_.List.head? ?m.20264 []
context:
â¢ Type ?u.20261
</code></pre>
<p>This is because Lean was unable to fully determine the expression's type.
In particular, it could neither find the implicit type argument to <code class="hljs">List.head?</code>, nor could it find the implicit type argument to <code class="hljs">List.nil</code>.
In Lean's output, <code class="hljs">?m.XYZ</code> represents a part of a program that could not be inferred.
These unknown parts are called <em>metavariables</em>, and they occur in some error messages.
In order to evaluate an expression, Lean needs to be able to find its type, and the type was unavailable because the empty list does not have any entries from which the type can be found.
Explicitly providing a type allows Lean to proceed:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> [].head? (Î± := Int)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">none
</code></pre>
<p>The type can also be provided with a type annotation:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> ([] : List Int).head?
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">none
</code></pre>
<p>The error messages provide a useful clue.
Both messages use the <em>same</em> metavariable to describe the missing implicit argument, which means that Lean has determined that the two missing pieces will share a solution, even though it was unable to determine the actual value of the solution.</p>
<h3 id="prod"><a class="header" href="#prod"><code>Prod</code></a></h3>
<p>The <code class="hljs">Prod</code> structure, short for "Product", is a generic way of joining two values together.
For instance, a <code class="hljs">Prod Nat String</code> contains a <code class="hljs">Nat</code> and a <code class="hljs">String</code>.
In other words, <code class="hljs">PPoint Nat</code> could be replaced by <code class="hljs">Prod Nat Nat</code>.
<code class="hljs">Prod</code> is very much like C#'s tuples, the <code class="hljs">Pair</code> and <code class="hljs">Triple</code> types in Kotlin, and <code class="hljs">tuple</code> in C++.
Many applications are best served by defining their own structures, even for simple cases like <code class="hljs">Point</code>, because using domain terminology can make it easier to read the code.
Additionally, defining structure types helps catch more errors by assigning different types to different domain concepts, preventing them from being mixed up.</p>
<p>On the other hand, there are some cases where it is not worth the overhead of defining a new type.
Additionally, some libraries are sufficiently generic that there is no more specific concept than "pair".
Finally, the standard library contains a variety of convenience functions that make it easier to work with the built-in pair type.</p>
<p>The standard pair structure is called <code class="hljs">Prod</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">d</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(Î² : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  fst : Î±
  snd : Î²
</code></pre>
<p>Lists are used so frequently that there is special syntax to make them more readable.
For the same reason, both the product type and its constructor have special syntax.
The type <code class="hljs">Prod Î± Î²</code> is typically written <code class="hljs">Î± Ã Î²</code>, mirroring the usual notation for a Cartesian product of sets.
Similarly, the usual mathematical notation for pairs is available for <code class="hljs">Prod</code>.
In other words, instead of writing:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> String Ã Int := { fst := <span class="hljs-string">"five"</span>, snd := <span class="hljs-number">5</span> }
</code></pre>
<p>it suffices to write:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> String Ã Int := (<span class="hljs-string">"five"</span>, <span class="hljs-number">5</span>)
</code></pre>
<p>Both notations are right-associative.
This means that the following definitions are equivalent:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> String Ã Int Ã Nat := (<span class="hljs-string">"VII"</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span> + <span class="hljs-number">3</span>)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> String Ã (Int Ã Nat) := (<span class="hljs-string">"VII"</span>, (<span class="hljs-number">7</span>, <span class="hljs-number">4</span> + <span class="hljs-number">3</span>))
</code></pre>
<p>In other words, all products of more than two types, and their corresponding constructors, are actually nested products and nested pairs behind the scenes.</p>
<h3 id="sum"><a class="header" href="#sum"><code>Sum</code></a></h3>
<p>The <code class="hljs">Sum</code> datatype is a generic way of allowing a choice between values of two different types.
For instance, a <code class="hljs">Sum String Int</code> is either a <code class="hljs">String</code> or an <code class="hljs">Int</code>.
Like <code class="hljs">Prod</code>, <code class="hljs">Sum</code> should be used either when writing very generic code, for a very small section of code where there is no sensible domain-specific type, or when the standard library contains useful functions.
In most situations, it is more readable and maintainable to use a custom inductive type.</p>
<p>Values of type <code class="hljs">Sum Î± Î²</code> are either the constructor <code class="hljs">inl</code> applied to a value of type <code class="hljs">Î±</code> or the constructor <code class="hljs">inr</code> applied to a value of type <code class="hljs">Î²</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Sum (Î± : <span class="hljs-built_in">Type</span>) (Î² : <span class="hljs-built_in">Type</span>) : <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  | inl : Î± â Sum Î± Î²
  | inr : Î² â Sum Î± Î²
</code></pre>
<p>These names are abbreviations for "left injection" and "right injection", respectively.
Just as the Cartesian product notation is used for <code class="hljs">Prod</code>, a "circled plus" notation is used for <code class="hljs">Sum</code>, so <code class="hljs">Î± â Î²</code> is another way to write <code class="hljs">Sum Î± Î²</code>.
There is no special syntax for <code class="hljs">Sum.inl</code> and <code class="hljs">Sum.inr</code>.</p>
<p>For instance, if pet names can either be dog names or cat names, then a type for them can be introduced as a sum of strings:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">P</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">m</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> := String â String
</code></pre>
<p>In a real program, it would usually be better to define a custom inductive datatype for this purpose with informative constructor names.
Here, <code class="hljs">Sum.inl</code> is to be used for dog names, and <code class="hljs">Sum.inr</code> is to be used for cat names.
These constructors can be used to write a list of animal names:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">i</span><span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> List PetName :=
  [Sum.inl <span class="hljs-string">"Spot"</span>, Sum.inr <span class="hljs-string">"Tiger"</span>, Sum.inl <span class="hljs-string">"Fifi"</span>, Sum.inl <span class="hljs-string">"Rex"</span>, Sum.inr <span class="hljs-string">"Floof"</span>]
</code></pre>
<p>Pattern matching can be used to distinguish between the two constructors.
For instance, a function that counts the number of dogs in a list of animal names (that is, the number of <code class="hljs">Sum.inl</code> constructors) looks like this:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">h</span><span class="hljs-title">ow</span><span class="hljs-title">M</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">y</span><span class="hljs-title">D</span><span class="hljs-title">o</span><span class="hljs-title">g</span><span class="hljs-title">s</span> <span class="hljs-params">(pets : List PetName)</span> <span class="hljs-symbol">:</span></span> Nat :=
  <span class="hljs-keyword">match</span> pets <span class="hljs-keyword">with</span>
  | [] =&gt; <span class="hljs-number">0</span>
  | Sum.inl _ :: morePets =&gt; howManyDogs morePets + <span class="hljs-number">1</span>
  | Sum.inr _ :: morePets =&gt; howManyDogs morePets
</code></pre>
<p>Function calls are evaluated before infix operators, so <code class="hljs">howManyDogs morePets + 1</code> is the same as <code class="hljs">(howManyDogs morePets) + 1</code>.
As expected, <code class="hljs">#eval howManyDogs animals</code> yields <code class="hljs">3</code>.</p>
<h3 id="unit"><a class="header" href="#unit"><code>Unit</code></a></h3>
<p><code class="hljs">Unit</code> is a type with just one argumentless constructor, called <code class="hljs">unit</code>.
In other words, it describes only a single value, which consists of said constructor applied to no arguments whatsoever.
<code class="hljs">Unit</code> is defined as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Unit : <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  | unit : Unit
</code></pre>
<p>On its own, <code class="hljs">Unit</code> is not particularly useful.
However, in polymorphic code, it can be used as a placeholder for data that is missing.
For instance, the following inductive datatype represents arithmetic expressions:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> ArithExpr (ann : <span class="hljs-built_in">Type</span>) : <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  | int : ann â Int â ArithExpr ann
  | plus : ann â ArithExpr ann â ArithExpr ann â ArithExpr ann
  | minus : ann â ArithExpr ann â ArithExpr ann â ArithExpr ann
  | times : ann â ArithExpr ann â ArithExpr ann â ArithExpr ann
</code></pre>
<p>The type argument <code class="hljs">ann</code> stands for annotations, and each constructor is annotated.
Expressions coming from a parser might be annotated with source locations, so a return type of <code class="hljs">ArithExpr SourcePos</code> ensures that the parser put a <code class="hljs">SourcePos</code> at each subexpression.
Expressions that don't come from the parser, however, will not have source locations, so their type can be <code class="hljs">ArithExpr Unit</code>.</p>
<p>Additionally, because all Lean functions have arguments, zero-argument functions in other languages can be represented as functions that take a <code class="hljs">Unit</code> argument.
In a return position, the <code class="hljs">Unit</code> type is similar to <code class="hljs">void</code> in languages derived from C.
In the C family, a function that returns <code class="hljs">void</code> will return control to its caller, but it will not return any interesting value.
By being an intentionally uninteresting value, <code class="hljs">Unit</code> allows this to be expressed without requiring a special-purpose <code class="hljs">void</code> feature in the type system.
Unit's constructor can be written as empty parentheses: <code class="hljs">() : Unit</code>.</p>
<h3 id="empty"><a class="header" href="#empty"><code>Empty</code></a></h3>
<p>The <code class="hljs">Empty</code> datatype has no constructors whatsoever.
Thus, it indicates unreachable code, because no series of calls can ever terminate with a value at type <code class="hljs">Empty</code>.</p>
<p><code class="hljs">Empty</code> is not used nearly as often as <code class="hljs">Unit</code>.
However, it is useful in some specialized contexts.
Many polymorphic datatypes do not use all of their type arguments in all of their constructors.
For instance, <code class="hljs">Sum.inl</code> and <code class="hljs">Sum.inr</code> each use only one of <code class="hljs">Sum</code>'s type arguments.
Using <code class="hljs">Empty</code> as one of the type arguments to <code class="hljs">Sum</code> can rule out one of the constructors at a particular point in a program.
This can allow generic code to be used in contexts that have additional restrictions.</p>
<h3 id="naming-sums-products-and-units"><a class="header" href="#naming-sums-products-and-units">Naming: Sums, Products, and Units</a></h3>
<p>Generally speaking, types that offer multiple constructors are called <em>sum types</em>, while types whose single constructor takes multiple arguments are called <em>product types</em>.
These terms are related to sums and products used in ordinary arithmetic.
The relationship is easiest to see when the types involved contain a finite number of values.
If <code class="hljs">Î±</code> and <code class="hljs">Î²</code> are types that contain <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-21-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-69" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-70"><span class="mi" id="MathJax-Span-71" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span> and <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-22-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-72" style="width:0.647em;display:inline-block"><span style="display:inline-block;position:relative;width:0.526em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.53em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-73"><span class="mi" id="MathJax-Span-74" style="font-family:MathJax_Math;font-style:italic">k</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span> distinct values, respectively, then <code class="hljs">Î± â Î²</code> contains <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-23-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>+</mo><mi>k</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-75" style="width:2.946em;display:inline-block"><span style="display:inline-block;position:relative;width:2.381em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1002.38em,2.583em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-76"><span class="mi" id="MathJax-Span-77" style="font-family:MathJax_Math;font-style:italic">n</span><span class="mo" id="MathJax-Span-78" style="font-family:MathJax_Main;padding-left:0.244em">+</span><span class="mi" id="MathJax-Span-79" style="font-family:MathJax_Math;font-style:italic;padding-left:0.244em">k</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.148em;border-left:0px solid;width:0px;height:1.052em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>+</mo><mi>k</mi></math></span></span> distinct values and <code class="hljs">Î± Ã Î²</code> contains <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-24-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>&amp;#x00D7;</mo><mi>k</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-80" style="width:2.946em;display:inline-block"><span style="display:inline-block;position:relative;width:2.381em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1002.38em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-81"><span class="mi" id="MathJax-Span-82" style="font-family:MathJax_Math;font-style:italic">n</span><span class="mo" id="MathJax-Span-83" style="font-family:MathJax_Main;padding-left:0.244em">Ã</span><span class="mi" id="MathJax-Span-84" style="font-family:MathJax_Math;font-style:italic;padding-left:0.244em">k</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>Ã</mo><mi>k</mi></math></span></span> distinct values.
For instance, <code class="hljs">Bool</code> has two values: <code class="hljs">true</code> and <code class="hljs">false</code>, and <code class="hljs">Unit</code> has one value: <code class="hljs">Unit.unit</code>.
The product <code class="hljs">Bool Ã Unit</code> has the two values <code class="hljs">(true, Unit.unit)</code> and <code class="hljs">(false, Unit.unit)</code>, and the sum <code class="hljs">Bool â Unit</code> has the three values <code class="hljs">Sum.inl true</code>, <code class="hljs">Sum.inl false</code>, and <code class="hljs">Sum.inr unit</code>.
Similarly, <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-25-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>2</mn><mo>&amp;#x00D7;</mo><mn>1</mn><mo>=</mo><mn>2</mn></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-85" style="width:5.123em;display:inline-block"><span style="display:inline-block;position:relative;width:4.115em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1004.08em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-86"><span class="mn" id="MathJax-Span-87" style="font-family:MathJax_Main">2</span><span class="mo" id="MathJax-Span-88" style="font-family:MathJax_Main;padding-left:0.244em">Ã</span><span class="mn" id="MathJax-Span-89" style="font-family:MathJax_Main;padding-left:0.244em">1</span><span class="mo" id="MathJax-Span-90" style="font-family:MathJax_Main;padding-left:0.284em">=</span><span class="mn" id="MathJax-Span-91" style="font-family:MathJax_Main;padding-left:0.284em">2</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>2</mn><mo>Ã</mo><mn>1</mn><mo>=</mo><mn>2</mn></math></span></span>, and <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-26-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>2</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-92" style="width:5.123em;display:inline-block"><span style="display:inline-block;position:relative;width:4.115em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1004.08em,2.583em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-93"><span class="mn" id="MathJax-Span-94" style="font-family:MathJax_Main">2</span><span class="mo" id="MathJax-Span-95" style="font-family:MathJax_Main;padding-left:0.244em">+</span><span class="mn" id="MathJax-Span-96" style="font-family:MathJax_Main;padding-left:0.244em">1</span><span class="mo" id="MathJax-Span-97" style="font-family:MathJax_Main;padding-left:0.284em">=</span><span class="mn" id="MathJax-Span-98" style="font-family:MathJax_Main;padding-left:0.284em">3</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.148em;border-left:0px solid;width:0px;height:1.052em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>2</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>3</mn></math></span></span>.</p>
<h2 id="messages-you-may-meet-2"><a class="header" href="#messages-you-may-meet-2">Messages You May Meet</a></h2>
<p>Not all definable structures or inductive types can have the type <code class="hljs">Type</code>.
In particular, if a constructor takes an arbitrary type as an argument, then the inductive type must have a different type.
These errors usually state something about "universe levels".
For example, for this inductive type:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> MyType : <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  | ctor : (Î± : <span class="hljs-built_in">Type</span>) â Î± â MyType
</code></pre>
<p>Lean gives the following error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">invalid universe level in constructor 'MyType.ctor', parameter 'Î±' has type
  Type
at universe level
  2
it must be smaller than or equal to the inductive datatype universe level
  1
</code></pre>
<p>A later chapter describes why this is the case, and how to modify definitions to make them work.
For now, try making the type an argument to the inductive type as a whole, rather than to the constructor.</p>
<p>Similarly, if a constructor's argument is a function that takes the datatype being defined as an argument, then the definition is rejected.
For example:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> MyType : <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  | ctor : (MyType â Int) â MyType
</code></pre>
<p>yields the message:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">(kernel) arg #1 of 'MyType.ctor' has a non positive occurrence of the datatypes being declared
</code></pre>
<p>For technical reasons, allowing these datatypes could make it possible to undermine Lean's internal logic, making it unsuitable for use as a theorem prover.</p>
<p>Forgetting an argument to an inductive type can also yield a confusing message.
For example, when the argument <code class="hljs">Î±</code> is not passed to <code class="hljs">MyType</code> in <code class="hljs">ctor</code>'s type:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> MyType (Î± : <span class="hljs-built_in">Type</span>) : <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  | ctor : Î± â MyType
</code></pre>
<p>Lean replies with the following error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">type expected, got
  (MyType : Type â Type)
</code></pre>
<p>The error message is saying that <code class="hljs">MyType</code>'s type, which is <code class="hljs">Type â Type</code>, does not itself describe types.
<code class="hljs">MyType</code> requires an argument to become an actual honest-to-goodness type.</p>
<p>The same message can appear when type arguments are omitted in other contexts, such as in a type signature for a definition:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> MyType (Î± : <span class="hljs-built_in">Type</span>) : <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  | ctor : Î± â MyType Î±

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">o</span><span class="hljs-title">f</span><span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> MyType := ctor <span class="hljs-number">5</span>
</code></pre>
<h2 id="exercises-3"><a class="header" href="#exercises-3">Exercises</a></h2>
<ul>
<li>Write a function to find the last entry in a list. It should return an <code class="hljs">Option</code>.</li>
<li>Write a function that finds the first entry in a list that satisfies a given predicate. Start the definition with <code class="hljs">def List.findFirst? {Î± : Type} (xs : List Î±) (predicate : Î± â Bool) : Option Î± :=</code></li>
<li>Write a function <code class="hljs">Prod.swap</code> that swaps the two fields in a pair. Start the definition with <code class="hljs">def Prod.swap {Î± Î² : Type} (pair : Î± Ã Î²) : Î² Ã Î± :=</code></li>
<li>Rewrite the <code class="hljs">PetName</code> example to use a custom datatype and compare it to the version that uses <code class="hljs">Sum</code>.</li>
<li>Write a function <code class="hljs">zip</code> that combines two lists into a list of pairs. The resulting list should be as long as the shortest input list. Start the definition with <code class="hljs">def zip {Î± Î² : Type} (xs : List Î±) (ys : List Î²) : List (Î± Ã Î²) :=</code>.</li>
<li>Write a polymorphic function <code class="hljs">take</code> that returns the first <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-27-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-99" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-100"><span class="mi" id="MathJax-Span-101" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span> entries in a list, where <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-28-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-102" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-103"><span class="mi" id="MathJax-Span-104" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span> is a <code class="hljs">Nat</code>. If the list contains fewer than <code class="hljs">n</code> entries, then the resulting list should be the input list. <code class="hljs">#eval take 3 ["bolete", "oyster"]</code> should yield <code class="hljs">["bolete", "oyster"]</code>, and <code class="hljs">#eval take 1 ["bolete", "oyster"]</code> should yield <code class="hljs">["bolete"]</code>.</li>
<li>Using the analogy between types and arithmetic, write a function that distributes products over sums. In other words, it should have type <code class="hljs">Î± Ã (Î² â Î³) â (Î± Ã Î²) â (Î± Ã Î³)</code>.</li>
<li>Using the analogy between types and arithmetic, write a function that turns multiplication by two into a sum. In other words, it should have type <code class="hljs">Bool Ã Î± â Î± â Î±</code>.</li>
</ul>
<div style="break-before:page;page-break-before:always"></div><h1 id="additional-conveniences"><a class="header" href="#additional-conveniences">Additional Conveniences</a></h1>
<p>Lean contains a number of convenience features that make programs much more concise.</p>
<h2 id="automatic-implicit-arguments"><a class="header" href="#automatic-implicit-arguments">Automatic Implicit Arguments</a></h2>
<p>When writing polymorphic functions in Lean, it is typically not necessary to list all the implicit arguments.
Instead, they can simply be mentioned.
If Lean can determine their type, then they are automatically inserted as implicit arguments.
In other words, the previous definition of <code class="hljs">length</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">g</span><span class="hljs-title">t</span><span class="hljs-title">h</span> <span class="hljs-params">{Î± : <span class="hljs-built_in">Type</span>}</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Nat :=
  <span class="hljs-keyword">match</span> xs <span class="hljs-keyword">with</span>
  | [] =&gt; <span class="hljs-number">0</span>
  | y :: ys =&gt; Nat.succ (length ys)
</code></pre>
<p>can be written without <code class="hljs">{Î± : Type}</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">g</span><span class="hljs-title">t</span><span class="hljs-title">h</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Nat :=
  <span class="hljs-keyword">match</span> xs <span class="hljs-keyword">with</span>
  | [] =&gt; <span class="hljs-number">0</span>
  | y :: ys =&gt; Nat.succ (length ys)
</code></pre>
<p>This can greatly simplify highly polymorphic definitions that take many implicit arguments.</p>
<h2 id="pattern-matching-definitions"><a class="header" href="#pattern-matching-definitions">Pattern-Matching Definitions</a></h2>
<p>When defining functions with <code class="hljs">def</code>, it is quite common to name an argument and then immediately use it with pattern matching.
For instance, in <code class="hljs">length</code>, the argument <code class="hljs">xs</code> is used only in <code class="hljs">match</code>.
In these situations, the cases of the <code class="hljs">match</code> expression can be written directly, without naming the argument at all.</p>
<p>The first step is to move the arguments' types to the right of the colon, so the return type is a function type.
For instance, the type of <code class="hljs">length</code> is <code class="hljs">List Î± â Nat</code>.
Then, replace the <code class="hljs">:=</code> with each case of the pattern match:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">g</span><span class="hljs-title">t</span><span class="hljs-title">h</span> <span class="hljs-symbol">:</span></span> List Î± â Nat
  | [] =&gt; <span class="hljs-number">0</span>
  | y :: ys =&gt; Nat.succ (length ys)
</code></pre>
<p>This syntax can also be used to define functions that take more than one argument.
In this case, their patterns are separated by commas.
For instance, <code class="hljs">drop</code> takes a number <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-29-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-105" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-106"><span class="mi" id="MathJax-Span-107" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span> and a list, and returns the list after removing the first <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-30-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-108" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-109"><span class="mi" id="MathJax-Span-110" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span> entries.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">p</span> <span class="hljs-symbol">:</span></span> Nat â List Î± â List Î±
  | Nat.zero, xs =&gt; xs
  | _, [] =&gt; []
  | Nat.succ n, x :: xs =&gt; drop n xs
</code></pre>
<p>Named arguments and patterns can also be used in the same definition.
For instance, a function that takes a default value and an optional value, and returns the default when the optional value is <code class="hljs">none</code>, can be written:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">O</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span> <span class="hljs-params">(default : Î±)</span> <span class="hljs-symbol">:</span></span> Option Î± â Î±
  | none =&gt; default
  | some x =&gt; x
</code></pre>
<p>This function is called <code class="hljs">Option.getD</code> in the standard library, and can be called with dot notation:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (some <span class="hljs-string">"salmonberry"</span>).getD <span class="hljs-string">""</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">"salmonberry"
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> none.getD <span class="hljs-string">""</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">""
</code></pre>
<h2 id="local-definitions"><a class="header" href="#local-definitions">Local Definitions</a></h2>
<p>It is often useful to name intermediate steps in a computation.
In many cases, intermediate values represent useful concepts all on their own, and naming them explicitly can make the program easier to read.
In other cases, the intermediate value is used more than once.
As in most other languages, writing down the same code twice in Lean causes it to be computed twice, while saving the result in a variable leads to the result of the computation being saved and re-used.</p>
<p>For instance, <code class="hljs">unzip</code> is a function that transforms a list of pairs into a pair of lists.
When the list of pairs is empty, then the result of <code class="hljs">unzip</code> is a pair of empty lists.
When the list of pairs has a pair at its head, then the two fields of the pair are added to the result of unzipping the rest of the list.
This definition of <code class="hljs">unzip</code> follows that description exactly:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">z</span><span class="hljs-title">i</span><span class="hljs-title">p</span> <span class="hljs-symbol">:</span></span> List (Î± Ã Î²) â List Î± Ã List Î²
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    (x :: (unzip xys).fst, y :: (unzip xys).snd)
</code></pre>
<p>Unfortunately, there is a problem: this code is slower than it needs to be.
Each entry in the list of pairs leads to two recursive calls, which makes this function take exponential time.
However, both recursive calls will have the same result, so there is no reason to make the recursive call twice.</p>
<p>In Lean, the result of the recursive call can be named, and thus saved, using <code class="hljs">let</code>.
Local definitions with <code class="hljs">let</code> resemble top-level definitions with <code class="hljs">def</code>: it takes a name to be locally defined, arguments if desired, a type signature, and then a body following <code class="hljs">:=</code>.
After the local definition, the expression in which the local definition is available (called the <em>body</em> of the <code class="hljs">let</code>-expression) must be on a new line, starting at a column in the file that is less than or equal to that of the <code class="hljs">let</code> keyword.
For instance, <code class="hljs">let</code> can be used in <code class="hljs">unzip</code> like this:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">z</span><span class="hljs-title">i</span><span class="hljs-title">p</span> <span class="hljs-symbol">:</span></span> List (Î± Ã Î²) â List Î± Ã List Î²
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    <span class="hljs-keyword">let</span> unzipped : List Î± Ã List Î² := unzip xys
    (x :: unzipped.fst, y :: unzipped.snd)
</code></pre>
<p>To use <code class="hljs">let</code> on a single line, separate the local definition from the body with a semicolon.</p>
<p>Local definitions with <code class="hljs">let</code> may also use pattern matching when one pattern is enough to match all cases of a datatype.
In the case of <code class="hljs">unzip</code>, the result of the recursive call is a pair.
Because pairs have only a single constructor, the name <code class="hljs">unzipped</code> can be replaced with a pair pattern:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">z</span><span class="hljs-title">i</span><span class="hljs-title">p</span> <span class="hljs-symbol">:</span></span> List (Î± Ã Î²) â List Î± Ã List Î²
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    <span class="hljs-keyword">let</span> (xs, ys) : List Î± Ã List Î² := unzip xys
    (x :: xs, y :: ys)
</code></pre>
<p>Judicious use of patterns with <code class="hljs">let</code> can make code easier to read, compared to writing the accessor calls by hand.</p>
<p>The biggest difference between <code class="hljs">let</code> and <code class="hljs">def</code> is that recursive <code class="hljs">let</code> definitions must be explicitly indicated by writing <code class="hljs">let rec</code>.
For instance, one way to reverse a list involves a recursive helper function, as in this definition:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> List Î± :=
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> helper : List Î± â List Î± â List Î±
    | [], soFar =&gt; soFar
    | y :: ys, soFar =&gt; helper ys (y :: soFar)
  helper xs []
</code></pre>
<p>The helper function walks down the input list, moving one entry at a time over to <code class="hljs">soFar</code>.
When it reaches the end of the input list, <code class="hljs">soFar</code> contains a reversed version of the input.</p>
<h2 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h2>
<p>In many situations, Lean can automatically determine an expression's type.
In these cases, explicit types may be omitted from both top-level definitions (with <code class="hljs">def</code>) and local definitions (with <code class="hljs">let</code>).
For instance, the recursive call to <code class="hljs">unzip</code> does not need an annotation:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">z</span><span class="hljs-title">i</span><span class="hljs-title">p</span> <span class="hljs-symbol">:</span></span> List (Î± Ã Î²) â List Î± Ã List Î²
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    <span class="hljs-keyword">let</span> unzipped := unzip xys
    (x :: unzipped.fst, y :: unzipped.snd)
</code></pre>
<p>As a rule of thumb, omitting the types of literal values (like strings and numbers) usually works, although Lean may pick a type for literal numbers that is more specific than the intended type.
Lean can usually determine a type for a function application, because it already knows the argument types and the return type.
Omitting return types for function definitions will often work, but function arguments typically require annotations.
Definitions that are not functions, like <code class="hljs">unzipped</code> in the example, do not need type annotations if their bodies do not need type annotations, and the body of this definition is a function application.</p>
<p>Omitting the return type for <code class="hljs">unzip</code> is possible when using an explicit <code class="hljs">match</code> expression:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">z</span><span class="hljs-title">i</span><span class="hljs-title">p</span> <span class="hljs-params">(pairs : List (Î± Ã Î²)</span>) <span class="hljs-symbol">:</span></span>=
  <span class="hljs-keyword">match</span> pairs <span class="hljs-keyword">with</span>
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    <span class="hljs-keyword">let</span> unzipped := unzip xys
    (x :: unzipped.fst, y :: unzipped.snd)
</code></pre>
<p>Generally speaking, it is a good idea to err on the side of too many, rather than too few, type annotations.
First off, explicit types communicate assumptions about the code to readers.
Even if Lean can determine the type on its own, it can still be easier to read code without having to repeatedly query Lean for type information.
Secondly, explicit types help localize errors.
The more explicit a program is about its types, the more informative the error messages can be.
This is especially important in a language like Lean that has a very expressive type system.
Thirdly, explicit types make it easier to write the program in the first place.
The type is a specification, and the compiler's feedback can be a helpful tool in writing a program that meets the specification.
Finally, Lean's type inference is a best-effort system.
Because Lean's type system is so expressive, there is no "best" or most general type to find for all expressions.
This means that even if you get a type, there's no guarantee that it's the <em>right</em> type for a given application.
For instance, <code class="hljs">14</code> can be a <code class="hljs">Nat</code> or an <code class="hljs">Int</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-number">14</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">14 : Nat
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> (<span class="hljs-number">14</span> : Int)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">14 : Int
</code></pre>
<p>Missing type annotations can give confusing error messages.
Omitting all types from the definition of <code class="hljs">unzip</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">z</span><span class="hljs-title">i</span><span class="hljs-title">p</span> <span class="hljs-title">p</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span>=
  <span class="hljs-keyword">match</span> pairs <span class="hljs-keyword">with</span>
  | [] =&gt; ([], [])
  | (x, y) :: xys =&gt;
    <span class="hljs-keyword">let</span> unzipped := unzip xys
    (x :: unzipped.fst, y :: unzipped.snd)
</code></pre>
<p>leads to a message about the <code class="hljs">match</code> expression:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">invalid match-expression, pattern contains metavariables
  []
</code></pre>
<p>This is because <code class="hljs">match</code> needs to know the type of the value being inspected, but that type was not available.
A "metavariable" is an unknown part of a program, written <code class="hljs">?m.XYZ</code> in error messagesâthey are described in the <a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/polymorphism.html">section on Polymorphism</a>.
In this program, the type annotation on the argument is required.</p>
<p>Even some very simple programs require type annotations.
For instance, the identity function just returns whatever argument it is passed.
With argument and type annotations, it looks like this:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">d</span> <span class="hljs-params">(x : Î±)</span> <span class="hljs-symbol">:</span></span> Î± := x
</code></pre>
<p>Lean is capable of determining the return type on its own:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">d</span> <span class="hljs-params">(x : Î±)</span> <span class="hljs-symbol">:</span></span>= x
</code></pre>
<p>Omitting the argument type, however, causes an error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">d</span> <span class="hljs-title">x</span> <span class="hljs-symbol">:</span></span>= x
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to infer binder type
</code></pre>
<p>In general, messages that say something like "failed to infer" or that mention metavariables are often a sign that more type annotations are necessary.
Especially while still learning Lean, it is useful to provide most types explicitly.</p>
<h2 id="simultaneous-matching"><a class="header" href="#simultaneous-matching">Simultaneous Matching</a></h2>
<p>Pattern-matching expressions, just like pattern-matching definitions, can match on multiple values at once.
Both the expressions to be inspected and the patterns that they match against are written with commas between them, similarly to the syntax used for definitions.
Here is a version of <code class="hljs">drop</code> that uses simultaneous matching:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">p</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> List Î± :=
  <span class="hljs-keyword">match</span> n, xs <span class="hljs-keyword">with</span>
  | Nat.zero, ys =&gt; ys
  | _, [] =&gt; []
  | Nat.succ n , y :: ys =&gt; drop n ys
</code></pre>
<h2 id="natural-number-patterns"><a class="header" href="#natural-number-patterns">Natural Number Patterns</a></h2>
<p>In the section on <a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/datatypes-and-patterns.html">datatypes and patterns</a>, <code class="hljs">even</code> was defined like this:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span> Bool :=
  <span class="hljs-keyword">match</span> n <span class="hljs-keyword">with</span>
  | Nat.zero =&gt; true
  | Nat.succ k =&gt; not (even k)
</code></pre>
<p>Just as there is special syntax to make list patterns more readable than using <code class="hljs">List.cons</code> and <code class="hljs">List.nil</code> directly, natural numbers can be matched using literal numbers and <code class="hljs">+</code>.
For instance, <code class="hljs">even</code> can also be defined like this:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> Nat â Bool
  | <span class="hljs-number">0</span> =&gt; true
  | n + <span class="hljs-number">1</span> =&gt; not (even n)
</code></pre>
<p>In this notation, the arguments to the <code class="hljs">+</code> pattern serve different roles.
Behind the scenes, the left argument (<code class="hljs">n</code> above) becomes an argument to some number of <code class="hljs">Nat.succ</code> patterns, and the right argument (<code class="hljs">1</code> above) determines how many <code class="hljs">Nat.succ</code>s to wrap around the pattern.
The explicit patterns in <code class="hljs">halve</code>, which divides a <code class="hljs">Nat</code> by two and drops the remainder:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Nat â Nat
  | Nat.zero =&gt; <span class="hljs-number">0</span>
  | Nat.succ Nat.zero =&gt; <span class="hljs-number">0</span>
  | Nat.succ (Nat.succ n) =&gt; halve n + <span class="hljs-number">1</span>
</code></pre>
<p>can be replaced by numeric literals and <code class="hljs">+</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Nat â Nat
  | <span class="hljs-number">0</span> =&gt; <span class="hljs-number">0</span>
  | <span class="hljs-number">1</span> =&gt; <span class="hljs-number">0</span>
  | n + <span class="hljs-number">2</span> =&gt; halve n + <span class="hljs-number">1</span>
</code></pre>
<p>Behind the scenes, both definitions are completely equivalent.
Remember: <code class="hljs">halve n + 1</code> is equivalent to <code class="hljs">(halve n) + 1</code>, not <code class="hljs">halve (n + 1)</code>.</p>
<p>When using this syntax, the second argument to <code class="hljs">+</code> should always be a literal <code class="hljs">Nat</code>.
Even though addition is commutative, flipping the arguments in a pattern can result in errors like the following:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Nat â Nat
  | <span class="hljs-number">0</span> =&gt; <span class="hljs-number">0</span>
  | <span class="hljs-number">1</span> =&gt; <span class="hljs-number">0</span>
  | <span class="hljs-number">2</span> + n =&gt; halve n + <span class="hljs-number">1</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">invalid patterns, `n` is an explicit pattern variable, but it only occurs in positions that are inaccessible to pattern matching
  .(Nat.add 2 n)
</code></pre>
<p>This restriction enables Lean to transform all uses of the <code class="hljs">+</code> notation in a pattern into uses of the underlying <code class="hljs">Nat.succ</code>, keeping the language simpler behind the scenes.</p>
<h2 id="anonymous-functions"><a class="header" href="#anonymous-functions">Anonymous Functions</a></h2>
<p>Functions in Lean need not be defined at the top level.
As expressions, functions are produced with the <code class="hljs">fun</code> syntax.
Function expressions begin with the keyword <code class="hljs">fun</code>, followed by one or more arguments, which are separated from the return expression using <code class="hljs">=&gt;</code>.
For instance, a function that adds one to a number can be written:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> x =&gt; x + <span class="hljs-number">1</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">fun x =&gt; x + 1 : Nat â Nat
</code></pre>
<p>Type annotations are written the same way as on <code class="hljs">def</code>, using parentheses and colons:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> (x : Int) =&gt; x + <span class="hljs-number">1</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">fun x =&gt; x + 1 : Int â Int
</code></pre>
<p>Similarly, implicit arguments may be written with curly braces:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span> {Î± : <span class="hljs-built_in">Type</span>} (x : Î±) =&gt; x
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">fun {Î±} x =&gt; x : {Î± : Type} â Î± â Î±
</code></pre>
<p>This style of anonymous function expression is often referred to as a <em>lambda expression</em>, because the typical notation used in mathematical descriptions of programming languages uses the Greek letter Î» (lambda) where Lean has the keyword <code class="hljs">fun</code>.
Even though Lean does permit <code class="hljs">Î»</code> to be used instead of <code class="hljs">fun</code>, it is most common to write <code class="hljs">fun</code>.</p>
<p>Anonymous functions also support the multiple-pattern style used in <code class="hljs">def</code>.
For instance, a function that returns the predecessor of a natural number if it exists can be written:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-keyword">fun</span>
  | <span class="hljs-number">0</span> =&gt; none
  | n + <span class="hljs-number">1</span> =&gt; some n
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">fun x =&gt;
  match x with
  | 0 =&gt; none
  | Nat.succ n =&gt; some n : Nat â Option Nat
</code></pre>
<p>Note that Lean's own description of the function has a named argument and a <code class="hljs">match</code> expression.
Many of Lean's convenient syntactic shorthands are expanded to simpler syntax behind the scenes, and the abstraction sometimes leaks.</p>
<p>Definitions using <code class="hljs">def</code> that take arguments may be rewritten as function expressions.
For instance, a function that doubles its argument can be written as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Nat â Nat := <span class="hljs-keyword">fun</span>
  | <span class="hljs-number">0</span> =&gt; <span class="hljs-number">0</span>
  | k + <span class="hljs-number">1</span> =&gt; double k + <span class="hljs-number">2</span>
</code></pre>
<p>When an anonymous function is very simple, like <code class="hljs">fun x =&gt; x + 1</code>, the syntax for creating the function can be fairly verbose.
In that particular example, six non-whitespace characters are used to introduce the function, and its body consists of only three non-whitespace characters.
For these simple cases, Lean provides a shorthand.
In an expression surrounded by parentheses, a centered dot character <code class="hljs">Â·</code> can stand for an argument, and the expression inside the parentheses becomes the function's body.
That particular function can also be written <code class="hljs">(Â· + 1)</code>.</p>
<p>The centered dot always creates a function out of the <em>closest</em> surrounding set of parentheses.
For instance, <code class="hljs">(Â· + 5, 3)</code> is a function that returns a pair of numbers, while <code class="hljs">((Â· + 5), 3)</code> is a pair of a function and a number.
If multiple dots are used, then they become arguments from left to right:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">(Â· , Â·) <span class="hljs-number">1</span> <span class="hljs-number">2</span>
===&gt;
(<span class="hljs-number">1</span>, Â·) <span class="hljs-number">2</span>
===&gt;
(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
</code></pre>
<p>Anonymous functions can be applied in precisely the same way as functions defined using <code class="hljs">def</code> or <code class="hljs">let</code>.
The command <code class="hljs">#eval (fun x =&gt; x + x) 5</code> results in:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">10
</code></pre>
<p>while <code class="hljs">#eval (Â· * 2) 5</code> results in:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">10
</code></pre>
<h2 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h2>
<p>Each name in Lean occurs in a <em>namespace</em>, which is a collection of names.
Names are placed in namespaces using <code class="hljs">.</code>, so <code class="hljs">List.map</code> is the name <code class="hljs">map</code> in the <code class="hljs">List</code> namespace.
Names in different namespaces do not conflict with each other, even if they are otherwise identical.
This means that <code class="hljs">List.map</code> and <code class="hljs">Array.map</code> are different names.
Namespaces may be nested, so <code class="hljs">Project.Frontend.User.loginTime</code> is the name <code class="hljs">loginTime</code> in the nested namespace <code class="hljs">Project.Frontend.User</code>.</p>
<p>Names can be directly defined within a namespace.
For instance, the name <code class="hljs">double</code> can be defined in the <code class="hljs">Nat</code> namespace:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span>.<span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat := x + x
</code></pre>
<p>Because <code class="hljs">Nat</code> is also the name of a type, dot notation is available to call <code class="hljs">Nat.double</code> on expressions with type <code class="hljs">Nat</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (<span class="hljs-number">4</span> : Nat).double
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">8
</code></pre>
<p>In addition to defining names directly in a namespace, a sequence of declarations can be placed in a namespace using the <code class="hljs">namespace</code> and <code class="hljs">end</code> commands.
For instance, this defines <code class="hljs">triple</code> and <code class="hljs">quadruple</code> in the namespace <code class="hljs">NewNamespace</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">namespace</span> NewNamespace
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat := <span class="hljs-number">3</span> * x
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">q</span><span class="hljs-title">u</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">r</span><span class="hljs-title">u</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span> Nat := <span class="hljs-number">2</span> * x + <span class="hljs-number">2</span> * x
<span class="hljs-keyword">end</span> NewNamespace
</code></pre>
<p>To refer to them, prefix their names with <code class="hljs">NewNamespace.</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> NewNamespace.triple
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">NewNamespace.triple (x : Nat) : Nat
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> NewNamespace.quadruple
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">NewNamespace.quadruple (x : Nat) : Nat
</code></pre>
<p>Namespaces may be <em>opened</em>, which allows the names in them to be used without explicit qualification.
Writing <code class="hljs">open MyNamespace in</code> before an expression causes the contents of <code class="hljs">MyNamespace</code> to be available in the expression.
For example, <code class="hljs">timesTwelve</code> uses both <code class="hljs">quadruple</code> and <code class="hljs">triple</code> after opening <code class="hljs">NewNamespace</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">Tw</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-params">(x : Nat)</span> <span class="hljs-symbol">:</span></span>=
  <span class="hljs-keyword">open</span> NewNamespace <span class="hljs-keyword">in</span>
  quadruple (triple x)
</code></pre>
<p>Namespaces can also be opened prior to a command.
This allows all parts of the command to refer to the contents of the namespace, rather than just a single expression.
To do this, place the <code class="hljs">open ... in</code> prior to the command.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> NewNamespace <span class="hljs-keyword">in</span>
<span class="hljs-keyword">#check</span> quadruple
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">NewNamespace.quadruple (x : Nat) : Nat
</code></pre>
<p>Function signatures show the name's full namespace.
Namespaces may additionally be opened for <em>all</em> following commands for the rest of the file.
To do this, simply omit the <code class="hljs">in</code> from a top-level usage of <code class="hljs">open</code>.</p>
<h2 id="if-let"><a class="header" href="#if-let">if let</a></h2>
<p>When consuming values that have a sum type, it is often the case that only a single constructor is of interest.
For instance, given this type that represents a subset of Markdown inline elements:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Inline : <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  | lineBreak
  | string : String â Inline
  | emph : Inline â Inline
  | strong : Inline â Inline
</code></pre>
<p>a function that recognizes string elements and extracts their contents can be written:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">I</span><span class="hljs-title">n</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">e</span>.<span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">g?</span> <span class="hljs-params">(inline : Inline)</span> <span class="hljs-symbol">:</span></span> Option String :=
  <span class="hljs-keyword">match</span> inline <span class="hljs-keyword">with</span>
  | Inline.string s =&gt; some s
  | _ =&gt; none
</code></pre>
<p>An alternative way of writing this function's body uses <code class="hljs">if</code> together with <code class="hljs">let</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">I</span><span class="hljs-title">n</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">e</span>.<span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">g?</span> <span class="hljs-params">(inline : Inline)</span> <span class="hljs-symbol">:</span></span> Option String :=
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> Inline.string s := inline <span class="hljs-keyword">then</span>
    some s
  <span class="hljs-keyword">else</span> none
</code></pre>
<p>This is very much like the pattern-matching <code class="hljs">let</code> syntax.
The difference is that it can be used with sum types, because a fallback is provided in the <code class="hljs">else</code> case.
In some contexts, using <code class="hljs">if let</code> instead of <code class="hljs">match</code> can make code easier to read.</p>
<h2 id="positional-structure-arguments"><a class="header" href="#positional-structure-arguments">Positional Structure Arguments</a></h2>
<p>The <a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/structures.html">section on structures</a> presents two ways of constructing structures:</p>
<ol>
<li>The constructor can be called directly, as in <code class="hljs">Point.mk 1 2</code>.</li>
<li>Brace notation can be used, as in <code class="hljs">{ x := 1, y := 2 }</code>.</li>
</ol>
<p>In some contexts, it can be convenient to pass arguments positionally, rather than by name, but without naming the constructor directly.
For instance, defining a variety of similar structure types can help keep domain concepts separate, but the natural way to read the code may treat each of them as being essentially a tuple.
In these contexts, the arguments can be enclosed in angle brackets <code class="hljs">â¨</code> and <code class="hljs">â©</code>.
A <code class="hljs">Point</code> can be written <code class="hljs">â¨1, 2â©</code>.
Be careful!
Even though they look like the less-than sign <code class="hljs">&lt;</code> and greater-than sign <code class="hljs">&gt;</code>, these brackets are different.
They can be input using <code class="hljs">\&lt;</code> and <code class="hljs">\&gt;</code>, respectively.</p>
<p>Just as with the brace notation for named constructor arguments, this positional syntax can only be used in a context where Lean can determine the structure's type, either from a type annotation or from other type information in the program.
For instance, <code class="hljs">#eval â¨1, 2â©</code> yields the following error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">invalid constructor â¨...â©, expected type must be an inductive type 
  ?m.34991
</code></pre>
<p>The metavariable in the error is because there is no type information available.
Adding an annotation, such as in <code class="hljs">#eval (â¨1, 2â© : Point)</code>, solves the problem:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">{ x := 1.000000, y := 2.000000 }
</code></pre>
<h2 id="string-interpolation"><a class="header" href="#string-interpolation">String Interpolation</a></h2>
<p>In Lean, prefixing a string with <code class="hljs">s!</code> triggers <em>interpolation</em>, where expressions contained in curly braces inside the string are replaced with their values.
This is similar to <code class="hljs">f</code>-strings in Python and <code class="hljs">$</code>-prefixed strings in C#.
For instance,</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> s!<span class="hljs-string">"three fives is {NewNamespace.triple 5}"</span>
</code></pre>
<p>yields the output</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">"three fives is 15"
</code></pre>
<p>Not all expressions can be interpolated into a string.
For instance, attempting to interpolate a function results in an error.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> s!<span class="hljs-string">"three fives is {NewNamespace.triple}"</span>
</code></pre>
<p>yields the output</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">failed to synthesize instance
  ToString (Nat â Nat)
</code></pre>
<p>This is because there is no standard way to convert functions into strings.
The Lean compiler maintains a table that describes how to convert values of various types into strings, and the message <code class="hljs">failed to synthesize instance</code> means that the Lean compiler didn't find an entry in this table for the given type.
This uses the same language feature as the <code class="hljs">deriving Repr</code> syntax that was described in the <a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/structures.html">section on structures</a>.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<h2 id="evaluating-expressions-1"><a class="header" href="#evaluating-expressions-1">Evaluating Expressions</a></h2>
<p>In Lean, computation occurs when expressions are evaluated.
This follows the usual rules of mathematical expressions: sub-expressions are replaced by their values following the usual order of operations, until the entire expression has become a value.
When evaluating an <code class="hljs">if</code> or a <code class="hljs">match</code>, the expressions in the branches are not evaluated until the value of the condition or the match subject has been found.</p>
<p>Once they have been given a value, variables never change.
Similarly to mathematics but unlike most programming languages, Lean variables are simply placeholders for values, rather than addresses to which new values can be written.
Variables' values may come from global definitions with <code class="hljs">def</code>, local definitions with <code class="hljs">let</code>, as named arguments to functions, or from pattern matching.</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>Functions in Lean are first-class values, meaning that they can be passed as arguments to other functions, saved in variables, and used like any other value.
Every Lean function takes exactly one argument.
To encode a function that takes more than one argument, Lean uses a technique called currying, where providing the first argument returns a function that expects the remaining arguments.
To encode a function that takes no arguments, Lean uses the <code class="hljs">Unit</code> type, which is the least informative possible argument.</p>
<p>There are three primary ways of creating functions:</p>
<ol>
<li>Anonymous functions are written using <code class="hljs">fun</code>.
For instance, a function that swaps the fields of a <code class="hljs">Point</code> can be written <code class="hljs">fun (point : Point) =&gt; { x := point.y, y := point.x : Point }</code></li>
<li>Very simple anonymous functions are written by placing one or more centered dots <code class="hljs">Â·</code> inside of parentheses.
Each centered dot becomes an argument to the function, and the parentheses delimit its body.
For instance, a function that subtracts one from its argument can be written as <code class="hljs">(Â· - 1)</code> instead of as <code class="hljs">fun x =&gt; x - 1</code>.</li>
<li>Functions can be defined using <code class="hljs">def</code> or <code class="hljs">let</code> by adding an argument list or by using pattern-matching notation.</li>
</ol>
<h2 id="types-1"><a class="header" href="#types-1">Types</a></h2>
<p>Lean checks that every expression has a type.
Types, such as <code class="hljs">Int</code>, <code class="hljs">Point</code>, <code class="hljs">{Î± : Type} â Nat â Î± â List Î±</code>, and <code class="hljs">Option (String â (Nat Ã String))</code>, describe the values that may eventually be found for an expression.
Like other languages, types in Lean can express lightweight specifications for programs that are checked by the Lean compiler, obviating the need for certain classes of unit test.
Unlike most languages, Lean's types can also express arbitrary mathematics, unifying the worlds of programming and theorem proving.
While using Lean for proving theorems is mostly out of scope for this book, <em><a href="https://leanprover.github.io/theorem_proving_in_lean4/">Theorem Proving in Lean 4</a></em> contains more information on this topic.</p>
<p>Some expressions can be given multiple types.
For instance, <code class="hljs">3</code> can be an <code class="hljs">Int</code> or a <code class="hljs">Nat</code>.
In Lean, this should be understood as two separate expressions, one with type <code class="hljs">Nat</code> and one with type <code class="hljs">Int</code>, that happen to be written in the same way, rather than as two different types for the same thing.</p>
<p>Lean is sometimes able to determine types automatically, but types must often be provided by the user.
This is because Lean's type system is so expressive.
Even when Lean can find a type, it may not find the desired typeâ<code class="hljs">3</code> could be intended to be used as an <code class="hljs">Int</code>, but Lean will give it the type <code class="hljs">Nat</code> if there are no further constraints.
In general, it is a good idea to write most types explicitly, only letting Lean fill out the very obvious types.
This improves Lean's error messages and helps make programmer intent more clear.</p>
<p>Some functions or datatypes take types as arguments.
They are called <em>polymorphic</em>.
Polymorphism allows programs such as one that calculates the length of a list without caring what type the entries in the list have.
Because types are first class in Lean, polymorphism does not require any special syntax, so types are passed just like other arguments.
Giving an argument a name in a function type allows later types to mention that argument, and the type of applying that function to an argument is found by replacing the argument's name with the argument's value.</p>
<h2 id="structures-and-inductive-types"><a class="header" href="#structures-and-inductive-types">Structures and Inductive Types</a></h2>
<p>Brand new datatypes can be introduced to Lean using the <code class="hljs">structure</code> or <code class="hljs">inductive</code> features.
These new types are not considered to be equivalent to any other type, even if their definitions are otherwise identical.
Datatypes have <em>constructors</em> that explain the ways in which their values can be constructed, and each constructor takes some number of arguments.
Constructors in Lean are not the same as constructors in object-oriented languages: Lean's constructors are inert holders of data, rather than active code that initializes an allocated object.</p>
<p>Typically, <code class="hljs">structure</code> is used to introduce a product type (that is, a type with just one constructor that takes any number of arguments), while <code class="hljs">inductive</code> is used to introduce a sum type (that is, a type with many distinct constructors).
Datatypes defined with <code class="hljs">structure</code> are provided with one accessor function for each of the constructor's arguments.
Both structures and inductive datatypes may be consumed with pattern matching, which exposes the values stored inside of constructors using a subset of the syntax used to call said constructors.
Pattern matching means that knowing how to create a value implies knowing how to consume it.</p>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<p>A definition is recursive when the name being defined is used in the definition itself.
Because Lean is an interactive theorem prover in addition to being a programming language, there are certain restrictions placed on recursive definitions.
In Lean's logical side, circular definitions could lead to logical inconsistency.</p>
<p>In order to ensure that recursive definitions do not undermine the logical side of Lean, Lean must be able to prove that all recursive functions terminate, no matter what arguments they are called with.
In practice, this means either that recursive calls are all performed on a structurally-smaller piece of the input, which ensures that there is always progress towards a base case, or that users must provide some other evidence that the function always terminates.
Similarly, recursive inductive types are not allowed to have a constructor that takes a function <em>from</em> the type as an argument, because this would make it possible to encode non-terminating functions.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h1>
<p>While Lean has been designed to have a rich interactive environment in which programmers can get quite a lot of feedback from the language without leaving the confines of their favorite text editor, it is also a language in which real programs can be written.
This means that it also has a batch-mode compiler, a build system, a package manager, and all the other tools that are necessary for writing programs.</p>
<p>While the <a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know.html">previous chapter</a> presented the basics of functional programming in Lean, this chapter explains how to start a programming project, compile it, and run the result.
Programs that run and interact with their environment (e.g. by reading input from standard input or creating files) are difficult to reconcile with the understanding of computation as the evaluation of mathematical expressions.
In addition to a description of the Lean build tools, this chapter also provides a way to think about functional programs that interact with the world.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="running-a-program"><a class="header" href="#running-a-program">Running a Program</a></h1>
<p>The simplest way to run a Lean program is to use the <code class="hljs">--run</code> option to the Lean executable.
Create a file called <code class="hljs">Hello.lean</code> and enter the following contents:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> IO Unit := IO.println <span class="hljs-string">"Hello, world!"</span>
</code></pre>
<p>Then, from the command line, run:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">lean --run Hello.lean
</code></pre>
<p>The program displays <code class="hljs">Hello, world!</code> and exits.</p>
<h2 id="anatomy-of-a-greeting"><a class="header" href="#anatomy-of-a-greeting">Anatomy of a Greeting</a></h2>
<p>When Lean is invoked with the <code class="hljs">--run</code> option, it invokes the program's <code class="hljs">main</code> definition.
In programs that do not take command-line arguments, <code class="hljs">main</code> should have type <code class="hljs">IO Unit</code>.
This means that <code class="hljs">main</code> is not a function, because there are no arrows (<code class="hljs">â</code>) in its type.
Instead of being a function that has side effects, <code class="hljs">main</code> consists of a description of effects to be carried out.</p>
<p>As discussed in <a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/polymorphism.html">the preceding chapter</a>, <code class="hljs">Unit</code> is the simplest inductive type.
It has a single constructor called <code class="hljs">unit</code> that takes no arguments.
Languages in the C tradition have a notion of a <code class="hljs">void</code> function that does not return any value at all.
In Lean, all functions take an argument and return a value, and the lack of interesting arguments or return values can be signaled by using the <code class="hljs">Unit</code> type instead.
If <code class="hljs">Bool</code> represents a single bit of information, <code class="hljs">Unit</code> represents zero bits of information.</p>
<p><code class="hljs">IO Î±</code> is the type of a program that, when executed, will either throw an exception or return a value of type <code class="hljs">Î±</code>.
During execution, this program may have side effects.
These programs are referred to as <code class="hljs">IO</code> <em>actions</em>.
Lean distinguishes between <em>evaluation</em> of expressions, which strictly adheres to the mathematical model of substitution of values for variables and reduction of sub-expressions without side effects, and <em>execution</em> of <code class="hljs">IO</code> actions, which rely on an external system to interact with the world.
<code class="hljs">IO.println</code> is a function from strings to <code class="hljs">IO</code> actions that, when executed, write the given string to standard output.
Because this action doesn't read any interesting information from the environment in the process of emitting the string, <code class="hljs">IO.println</code> has type <code class="hljs">String â IO Unit</code>.
If it did return something interesting, then that would be indicated by the <code class="hljs">IO</code> action having a type other than <code class="hljs">Unit</code>.</p>
<h2 id="functional-programming-vs-effects"><a class="header" href="#functional-programming-vs-effects">Functional Programming vs Effects</a></h2>
<p>Lean's model of computation is based on the evaluation of mathematical expressions, in which variables are given exactly one value that does not change over time.
The result of evaluating an expression does not change, and evaluating the same expression again will always yield the same result.</p>
<p>On the other hand, useful programs must interact with the world.
A program that performs neither input nor output can't ask a user for data, create files on disk, or open network connections.
Lean is written in itself, and the Lean compiler certainly reads files, creates files, and interacts with text editors.
How can a language in which the same expression always yields the same result support programs that read files from disk, when the contents of these files might change over time?</p>
<p>This apparent contradiction can be resolved by thinking a bit differently about side effects.
Imagine a cafÃ© that sells coffee and sandwiches.
This cafÃ© has two employees: a cook who fulfills orders, and a worker at the counter who interacts with customers and places order slips.
The cook is a surly person, who really prefers not to have any contact with the world outside, but who is very good at consistently delivering the food and drinks that the cafÃ© is known for.
In order to do this, however, the cook needs peace and quiet, and can't be disturbed with conversation.
The counter worker is friendly, but completely incompetent in the kitchen.
Customers interact with the counter worker, who delegates all actual cooking to the cook.
If the cook has a question for a customer, such as clarifying an allergy, they send a little note to the counter worker, who interacts with the customer and passes a note back to the cook with the result.</p>
<p>In this analogy, the cook is the Lean language.
When provided with an order, the cook faithfully and consistently delivers what is requested.
The counter worker is the surrounding run-time system that interacts with the world and can accept payments, dispense food, and have conversations with customers.
Working together, the two employees serve all the functions of the restaurant, but their responsibilities are divided, with each performing the tasks that they're best at.
Just as keeping customers away allows the cook to focus on making truly excellent coffee and sandwiches, Lean's lack of side effects allows programs to be used as part of formal mathematical proofs.
It also helps programmers understand the parts of the program in isolation from each other, because there are no hidden state changes that create subtle coupling between components.
The cook's notes represent <code class="hljs">IO</code> actions that are produced by evaluating Lean expressions, and the counter worker's replies are the values that are passed back from effects.</p>
<p>This model of side effects is quite similar to how the overall aggregate of the Lean language, its compiler, and its run-time system (RTS) work.
Primitives in the run-time system, written in C, implement all the basic effects.
When running a program, the RTS invokes the <code class="hljs">main</code> action, which returns new <code class="hljs">IO</code> actions to the RTS for execution.
The RTS executes these actions, delegating to the user's Lean code to carry out computations.
From the internal perspective of Lean, programs are free of side effects, and <code class="hljs">IO</code> actions are just descriptions of tasks to be carried out.
From the external perspective of the program's user, there is a layer of side effects that create an interface to the program's core logic.</p>
<h2 id="real-world-functional-programming"><a class="header" href="#real-world-functional-programming">Real-World Functional Programming</a></h2>
<p>The other useful way to think about side effects in Lean is by considering <code class="hljs">IO</code> actions to be functions that take the entire world as an argument and return a value paired with a new world.
In this case, reading a line of text from standard input <em>is</em> a pure function, because a different world is provided as an argument each time.
Writing a line of text to standard output is a pure function, because the world that the function returns is different from the one that it began with.
Programs do need to be careful to never re-use the world, nor to fail to return a new worldâthis would amount to time travel or the end of the world, after all.
Careful abstraction boundaries can make this style of programming safe.
If every primitive <code class="hljs">IO</code> action accepts one world and returns a new one, and they can only be combined with tools that preserve this invariant, then the problem cannot occur.</p>
<p>This model cannot be implemented.
After all, the entire universe cannot be turned into a Lean value and placed into memory.
However, it is possible to implement a variation of this model with an abstract token that stands for the world.
When the program is started, it is provided with a world token.
This token is then passed on to the IO primitives, and their returned tokens are similarly passed to the next step.
At the end of the program, the token is returned to the operating system.</p>
<p>This model of side effects is a good description of how <code class="hljs">IO</code> actions as descriptions of tasks to be carried out by the RTS are represented internally in Lean.
The actual functions that transform the real world are behind an abstraction barrier.
But real programs typically consist of a sequence of effects, rather than just one.
To enable programs to use multiple effects, there is a sub-language of Lean called <code class="hljs">do</code> notation that allows these primitive <code class="hljs">IO</code> actions to be safely composed into a larger, useful program.</p>
<h2 id="combining-io-actions"><a class="header" href="#combining-io-actions">Combining <code>IO</code> Actions</a></h2>
<p>Most useful programs accept input in addition to producing output.
Furthermore, they may take decisions based on input, using the input data as part of a computation.
The following program, called <code class="hljs">HelloName.lean</code>, asks the user for their name and then greets them:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> stdin â IO.getStdin
  <span class="hljs-keyword">let</span> stdout â IO.getStdout

  stdout.putStrLn <span class="hljs-string">"How would you like to be addressed?"</span>
  <span class="hljs-keyword">let</span> input â stdin.getLine
  <span class="hljs-keyword">let</span> name := input.dropRightWhile Char.isWhitespace

  stdout.putStrLn s!<span class="hljs-string">"Hello, {name}!"</span>
</code></pre>
<p>In this program, the <code class="hljs">main</code> action consists of a <code class="hljs">do</code> block.
This block contains a sequence of <em>statements</em>, which can be both local variables (introduced using <code class="hljs">let</code>) and actions that are to be executed.
Just as SQL can be thought of as a special-purpose language for interacting with databases, the <code class="hljs">do</code> syntax can be thought of as a special-purpose sub-language within Lean that is dedicated to modeling imperative programs.
<code class="hljs">IO</code> actions that are built with a <code class="hljs">do</code> block are executed by executing the statements in order.</p>
<p>This program can be run in the same manner as the prior program:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">lean --run HelloName.lean
</code></pre>
<p>If the user responds with <code class="hljs">David</code>, a session of interaction with the program reads:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">How would you like to be addressed?
David
Hello, David!
</code></pre>
<p>The type signature line is just like the one for <code class="hljs">Hello.lean</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
</code></pre>
<p>The only difference is that it ends with the keyword <code class="hljs">do</code>, which initiates a sequence of commands.
Each indented line following the keyword <code class="hljs">do</code> is part of the same sequence of commands.</p>
<p>The first two lines, which read:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">  <span class="hljs-keyword">let</span> stdin â IO.getStdin
  <span class="hljs-keyword">let</span> stdout â IO.getStdout
</code></pre>
<p>retrieve the <code class="hljs">stdin</code> and <code class="hljs">stdout</code> handles by executing the library actions <code class="hljs">IO.getStdin</code> and <code class="hljs">IO.getStdout</code>, respectively.
In a <code class="hljs">do</code> block, <code class="hljs">let</code> has a slightly different meaning than in an ordinary expression.
Ordinarily, the local definition in a <code class="hljs">let</code> can be used in just one expression, which immediately follows the local definition.
In a <code class="hljs">do</code> block, local bindings introduced by <code class="hljs">let</code> are available in all statements in the remainder of the <code class="hljs">do</code> block, rather than just the next one.
Additionally, <code class="hljs">let</code> typically connects the name being defined to its definition using <code class="hljs">:=</code>, while some <code class="hljs">let</code> bindings in <code class="hljs">do</code> use a left arrow (<code class="hljs">â</code> or <code class="hljs">&lt;-</code>) instead.
Using an arrow means that the value of the expression is an <code class="hljs">IO</code> action that should be executed, with the result of the action saved in the local variable.
In other words, if the expression to the right of the arrow has type <code class="hljs">IO Î±</code>, then the variable has type <code class="hljs">Î±</code> in the remainder of the <code class="hljs">do</code> block.
<code class="hljs">IO.getStdin</code> and <code class="hljs">IO.getStdout</code> are <code class="hljs">IO</code> actions in order to allow <code class="hljs">stdin</code> and <code class="hljs">stdout</code> to be locally overridden in a program, which can be convenient.
If they were global variables as in C, then there would be no meaningful way to override them, but <code class="hljs">IO</code> actions can return different values each time they are executed.</p>
<p>The next part of the <code class="hljs">do</code> block is responsible for asking the user for their name:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">  stdout.putStrLn <span class="hljs-string">"How would you like to be addressed?"</span>
  <span class="hljs-keyword">let</span> input â stdin.getLine
  <span class="hljs-keyword">let</span> name := input.dropRightWhile Char.isWhitespace
</code></pre>
<p>The first line writes the question to <code class="hljs">stdout</code>, the second line requests input from <code class="hljs">stdin</code>, and the third line removes the trailing newline (plus any other trailing whitespace) from the input line.
The definition of <code class="hljs">name</code> uses <code class="hljs">:=</code>, rather than <code class="hljs">â</code>, because <code class="hljs">String.dropRightWhile</code> is an ordinary function on strings, rather than an <code class="hljs">IO</code> action.</p>
<p>Finally, the last line in the program is:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">  stdout.putStrLn s!"Hello, {name}!"
</code></pre>
<p>It uses <a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/conveniences.html#string-interpolation">string interpolation</a> to insert the provided name into a greeting string, writing the result to <code class="hljs">stdout</code>.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="step-by-step"><a class="header" href="#step-by-step">Step By Step</a></h1>
<p>A <code class="hljs">do</code> block can be executed one line at a time.
Start with the program from the prior section:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">  <span class="hljs-keyword">let</span> stdin â IO.getStdin
  <span class="hljs-keyword">let</span> stdout â IO.getStdout
  stdout.putStrLn <span class="hljs-string">"How would you like to be addressed?"</span>
  <span class="hljs-keyword">let</span> input â stdin.getLine
  <span class="hljs-keyword">let</span> name := input.dropRightWhile Char.isWhitespace
  stdout.putStrLn s!<span class="hljs-string">"Hello, {name}!"</span>
</code></pre>
<h2 id="standard-io"><a class="header" href="#standard-io">Standard IO</a></h2>
<p>The first line is <code class="hljs">  let stdin â IO.getStdin</code>, while the remainder is:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">  <span class="hljs-keyword">let</span> stdout â IO.getStdout
  stdout.putStrLn <span class="hljs-string">"How would you like to be addressed?"</span>
  <span class="hljs-keyword">let</span> input â stdin.getLine
  <span class="hljs-keyword">let</span> name := input.dropRightWhile Char.isWhitespace
  stdout.putStrLn s!<span class="hljs-string">"Hello, {name}!"</span>
</code></pre>
<p>To execute a <code class="hljs">let</code> statement that uses a <code class="hljs">â</code>, start by evaluating the expression to the right of the arrow (in this case, <code class="hljs">IO.getStdIn</code>).
Because this expression is just a variable, its value is looked up.
The resulting value is a built-in primitive <code class="hljs">IO</code> action.
The next step is to execute this <code class="hljs">IO</code> action, resulting in a value that represents the standard input stream, which has type <code class="hljs">IO.FS.Stream</code>.
Standard input is then associated with the name to the left of the arrow (here <code class="hljs">stdin</code>) for the remainder of the <code class="hljs">do</code> block.</p>
<p>Executing the second line, <code class="hljs">  let stdout â IO.getStdout</code>, proceeds similarly.
First, the expression <code class="hljs">IO.getStdout</code> is evaluated, yielding an <code class="hljs">IO</code> action that will return the standard output.
Next, this action is executed, actually returning the standard output.
Finally, this value is associated with the name <code class="hljs">stdout</code> for the remainder of the <code class="hljs">do</code> block.</p>
<h2 id="asking-a-question"><a class="header" href="#asking-a-question">Asking a Question</a></h2>
<p>Now that <code class="hljs">stdin</code> and <code class="hljs">stdout</code> have been found, the remainder of the block consists of a question and an answer:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">  stdout.putStrLn <span class="hljs-string">"How would you like to be addressed?"</span>
  <span class="hljs-keyword">let</span> input â stdin.getLine
  <span class="hljs-keyword">let</span> name := input.dropRightWhile Char.isWhitespace
  stdout.putStrLn s!<span class="hljs-string">"Hello, {name}!"</span>
</code></pre>
<p>The first statement in the block, <code class="hljs">  stdout.putStrLn "How would you like to be addressed?"</code>, consists of an expression.
To execute an expression, it is first evaluated.
In this case, <code class="hljs">IO.FS.Stream.putStrLn</code> has type <code class="hljs">IO.FS.Stream â String â IO Unit</code>.
This means that it is a function that accepts a stream and a string, returning an <code class="hljs">IO</code> action.
The expression uses <a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/structures.html#behind-the-scenes">accessor notation</a> for a function call.
This function is applied to two arguments: the standard output stream and a string.
The value of the expression is an <code class="hljs">IO</code> action that will write the string and a newline character to the output stream.
Having found this value, the next step is to execute it, which causes the string and newline to actually be written to <code class="hljs">stdout</code>.
Statements that consist only of expressions do not introduce any new variables.</p>
<p>The next statement in the block is <code class="hljs">  let input â stdin.getLine</code>.
<code class="hljs">IO.FS.Stream.getLine</code> has type <code class="hljs">IO.FS.Stream â IO String</code>, which means that it is a function from a stream to an <code class="hljs">IO</code> action that will return a string.
Once again, this is an example of accessor notation.
This <code class="hljs">IO</code> action is executed, and the program waits until the user has typed a complete line of input.
Assume the user writes "<code class="hljs">David</code>".
The resulting line (<code class="hljs">"David\n"</code>) is associated with <code class="hljs">input</code>, where the escape sequence <code class="hljs">\n</code> denotes the newline character.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">  <span class="hljs-keyword">let</span> name := input.dropRightWhile Char.isWhitespace
  stdout.putStrLn s!<span class="hljs-string">"Hello, {name}!"</span>
</code></pre>
<p>The next line, <code class="hljs">  let name := input.dropRightWhile Char.isWhitespace</code>, is a <code class="hljs">let</code> statement.
Unlike the other <code class="hljs">let</code> statements in this program, it uses <code class="hljs">:=</code> instead of <code class="hljs">â</code>.
This means that the expression will be evaluated, but the resulting value need not be an <code class="hljs">IO</code> action and will not be executed.
In this case, <code class="hljs">String.dropRightWhile</code> takes a string and a predicate over characters and returns a new string from which all the characters at the end of the string that satisfy the predicate have been removed.
For example,</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> <span class="hljs-string">"Hello!!!"</span>.dropRightWhile (Â· == '!')
</code></pre>
<p>yields</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">"Hello"
</code></pre>
<p>and</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> <span class="hljs-string">"Hello...   "</span>.dropRightWhile (<span class="hljs-keyword">fun</span> c =&gt; not (c.isAlphanum))
</code></pre>
<p>yields</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">"Hello"
</code></pre>
<p>in which all non-alphanumeric characters have been removed from the right side of the string.
In the current line of the program, whitespace characters (including the newline) are removed from the right side of the input string, resulting in <code class="hljs">"David"</code>, which is associated with <code class="hljs">name</code> for the remainder of the block.</p>
<h2 id="greeting-the-user"><a class="header" href="#greeting-the-user">Greeting the User</a></h2>
<p>All that remains to be executed in the <code class="hljs">do</code> block is a single statement:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">  stdout.putStrLn s!<span class="hljs-string">"Hello, {name}!"</span>
</code></pre>
<p>The string argument to <code class="hljs">putStrLn</code> is constructed via string interpolation, yielding the string <code class="hljs">"Hello, David!"</code>.
Because this statement is an expression, it is evaluated to yield an <code class="hljs">IO</code> action that will print this string with a newline to standard output.
Once the expression has been evaluated, the resulting <code class="hljs">IO</code> action is executed, resulting in the greeting.</p>
<h2 id="io-actions-as-values"><a class="header" href="#io-actions-as-values"><code>IO</code> Actions as Values</a></h2>
<p>In the above description, it can be difficult to see why the distinction between evaluating expressions and executing <code class="hljs">IO</code> actions is necessary.
After all, each action is executed immediately after it is produced.
Why not simply carry out the effects during evaluation, as is done in other languages?</p>
<p>The answer is twofold.
First off, separating evaluation from execution means that programs must be explicit about which functions can have side effects.
Because the parts of the program that do not have effects are much more amenable to mathematical reasoning, whether in the heads of programmers or using Lean's facilities for formal proof, this separation can make it easier to avoid bugs.
Secondly, not all <code class="hljs">IO</code> actions need be executed at the time that they come into existence.
The ability to mention an action without carrying it out allows ordinary functions to be used as control structures.</p>
<p>For instance, the function <code class="hljs">twice</code> takes an <code class="hljs">IO</code> action as its argument, returning a new action that will execute the first one twice.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">tw</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">e</span> <span class="hljs-params">(action : IO Unit)</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  action
  action
</code></pre>
<p>For instance, executing</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">twice (IO.println <span class="hljs-string">"shy"</span>)
</code></pre>
<p>results in</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">shy
shy
</code></pre>
<p>being printed.
This can be generalized to a version that runs the underlying action any number of times:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">n</span><span class="hljs-title">T</span><span class="hljs-title">i</span><span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">s</span> <span class="hljs-params">(action : IO Unit)</span> <span class="hljs-symbol">:</span></span> Nat â IO Unit
  | <span class="hljs-number">0</span> =&gt; pure ()
  | n + <span class="hljs-number">1</span> =&gt; <span class="hljs-keyword">do</span>
    action
    nTimes action n
</code></pre>
<p>In the base case for <code class="hljs">Nat.zero</code>, the result is <code class="hljs">pure ()</code>.
The function <code class="hljs">pure</code> creates an <code class="hljs">IO</code> action that has no side effects, but returns <code class="hljs">pure</code>'s argument, which in this case is the constructor for <code class="hljs">Unit</code>.
As an action that does nothing and returns nothing interesting, <code class="hljs">pure ()</code> is at the same time utterly boring and very useful.
In the recursive step, a <code class="hljs">do</code> block is used to create an action that first executes <code class="hljs">action</code> and then executes the result of the recursive call.
Executing <code class="hljs">nTimes (IO.println "Hello") 3</code> causes the following output:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Hello
Hello
Hello
</code></pre>
<p>In addition to using functions as control structures, the fact that <code class="hljs">IO</code> actions are first-class values means that they can be saved in data structures for later execution.
For instance, the function <code class="hljs">countdown</code> takes a <code class="hljs">Nat</code> and returns a list of unexecuted <code class="hljs">IO</code> actions, one for each <code class="hljs">Nat</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">d</span><span class="hljs-title">ow</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> Nat â List (IO Unit)
  | <span class="hljs-number">0</span> =&gt; [IO.println <span class="hljs-string">"Blast off!"</span>]
  | n + <span class="hljs-number">1</span> =&gt; IO.println s!<span class="hljs-string">"{n + 1}"</span> :: countdown n
</code></pre>
<p>This function has no side effects, and does not print anything.
For example, it can be applied to an argument, and the length of the resulting list of actions can be checked:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">m5</span> <span class="hljs-symbol">:</span></span> List (IO Unit) := countdown <span class="hljs-number">5</span>
</code></pre>
<p>This list contains six elements (one for each number, plus a <code class="hljs">"Blast off!"</code> action for zero):</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> from5.length
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">6
</code></pre>
<p>The function <code class="hljs">runActions</code> takes a list of actions and constructs a single action that runs them all in order:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">r</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">A</span><span class="hljs-title">c</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> List (IO Unit) â IO Unit
  | [] =&gt; pure ()
  | act :: actions =&gt; <span class="hljs-keyword">do</span>
    act
    runActions actions
</code></pre>
<p>Its structure is essentially the same as that of <code class="hljs">nTimes</code>, except instead of having one action that is executed for each <code class="hljs">Nat.succ</code>, the action under each <code class="hljs">List.cons</code> is to be executed.
Similarly, <code class="hljs">runActions</code> does not itself run the actions.
It creates a new action that will run them, and that action must be placed in a position where it will be executed as a part of <code class="hljs">main</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> IO Unit := runActions from5
</code></pre>
<p>Running this program results in the following output:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">5
4
3
2
1
Blast off!
</code></pre>
<p>What happens when this program is run?
The first step is to evaluate <code class="hljs">main</code>. That occurs as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">main
===&gt;
runActions from5
===&gt;
runActions (countdown <span class="hljs-number">5</span>)
===&gt;
runActions
  [IO.println <span class="hljs-string">"5"</span>,
   IO.println <span class="hljs-string">"4"</span>,
   IO.println <span class="hljs-string">"3"</span>,
   IO.println <span class="hljs-string">"2"</span>,
   IO.println <span class="hljs-string">"1"</span>,
   IO.println <span class="hljs-string">"Blast off!"</span>]
===&gt;
<span class="hljs-keyword">do</span> IO.println <span class="hljs-string">"5"</span>
   IO.println <span class="hljs-string">"4"</span>
   IO.println <span class="hljs-string">"3"</span>
   IO.println <span class="hljs-string">"2"</span>
   IO.println <span class="hljs-string">"1"</span>
   IO.println <span class="hljs-string">"Blast off!"</span>
   pure ()
</code></pre>
<p>The resulting <code class="hljs">IO</code> action is a <code class="hljs">do</code> block.
Each step of the <code class="hljs">do</code> block is then executed, one at a time, yielding the expected output.
The final step, <code class="hljs">pure ()</code>, does not have any effects, and it is only present because the definition of <code class="hljs">runActions</code> needs a base case.</p>
<h2 id="exercise"><a class="header" href="#exercise">Exercise</a></h2>
<p>Step through the execution of the following program on a piece of paper:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> englishGreeting := IO.println <span class="hljs-string">"Hello!"</span>
  IO.println <span class="hljs-string">"Bonjour!"</span>
  englishGreeting
</code></pre>
<p>While stepping through the program's execution, identify when an expression is being evaluated and when an <code class="hljs">IO</code> action is being executed.
When executing an <code class="hljs">IO</code> action results in a side effect, write it down.
After doing this, run the program with Lean and double-check that your predictions about the side effects were correct.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="starting-a-project"><a class="header" href="#starting-a-project">Starting a Project</a></h1>
<p>As a program written in Lean becomes more serious, an ahead-of-time compiler-based workflow that results in an executable becomes more attractive.
Like other languages, Lean has tools for building multiple-file packages and managing dependencies.
The standard Lean build tool is called Lake (short for "Lean Make"), and it is configured in Lean.
Just as Lean contains a special-purpose language for writing programs with effects (the <code class="hljs">do</code> language), Lake contains a special-purpose language for configuring builds.
These languages are referred to as <em>embedded domain-specific languages</em> (or sometimes <em>domain-specific embedded languages</em>, abbreviated EDSL or DSEL).
They are <em>domain-specific</em> in the sense that they are used for a particular purpose, with concepts from some sub-domain, and they are typically not suitable for general-purpose programming.
They are <em>embedded</em> because they occur inside another language's syntax.
While Lean contains rich facilities for creating EDSLs, they are beyond the scope of this book.</p>
<h2 id="first-steps"><a class="header" href="#first-steps">First steps</a></h2>
<p>To get started with a project that uses Lake, use the command <code class="hljs">lake new greeting</code> in a directory that does not already contain a file or directory called <code class="hljs">greeting</code>.
This creates a directory called <code class="hljs">greeting</code> that contains the following files:</p>
<ul>
<li><code class="hljs">Main.lean</code> is the file in which the Lean compiler will look for the <code class="hljs">main</code> action.</li>
<li><code class="hljs">Greeting.lean</code> and <code class="hljs">Greeting/Basic.lean</code> are the scaffolding of a support library for the program.</li>
<li><code class="hljs">lakefile.lean</code> contains the configuration that <code class="hljs">lake</code> needs to build the application.</li>
<li><code class="hljs">lean-toolchain</code> contains an identifier for the specific version of Lean that is used for the project.</li>
</ul>
<p>Additionally, <code class="hljs">lake new</code> initializes the project as a Git repository and configures its <code class="hljs">.gitignore</code> file to ignore intermediate build products.
Typically, the majority of the application logic will be in a collection of libraries for the program, while <code class="hljs">Main.lean</code> will contain a small wrapper around these pieces that does things like parsing command lines and executing the central application logic.
To create a project in an already-existing directory, run <code class="hljs">lake init</code> instead of <code class="hljs">lake new</code>.</p>
<p>By default, the library file <code class="hljs">Greeting/Basic.lean</code> contains a single definition:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">l</span><span class="hljs-title">o</span> <span class="hljs-symbol">:</span></span>= <span class="hljs-string">"world"</span>
</code></pre>
<p>The library file <code class="hljs">Greeting.lean</code> imports <code class="hljs">Greeting/Basic.lean</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-comment">-- This module serves as the root of the `Greeting` library.</span>
<span class="hljs-comment">-- Import modules here that should be built as part of the library.</span>
<span class="hljs-keyword">import</span> Â«GreetingÂ».Basic
</code></pre>
<p>This means that everything defined in <code class="hljs">Greetings/Basic.lean</code> is also available to files that import <code class="hljs">Greetings.lean</code>.
In <code class="hljs">import</code> statements, dots are interpreted as directories on disk.
Placing guillemets around a name, as in <code class="hljs">Â«GreetingÂ»</code>, allow it to contain spaces or other characters that are normally not allowed in Lean names, and it allows reserved keywords such as <code class="hljs">if</code> or <code class="hljs">def</code> to be used as ordinary names by writing <code class="hljs">Â«ifÂ»</code> or <code class="hljs">Â«defÂ»</code>.
This prevents issues when the package name provided to <code class="hljs">lake new</code> contains such characters.</p>
<p>The executable source <code class="hljs">Main.lean</code> contains:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">import</span> Â«GreetingÂ»

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> IO Unit :=
  IO.println s!<span class="hljs-string">"Hello, {hello}!"</span>
</code></pre>
<p>Because <code class="hljs">Main.lean</code> imports <code class="hljs">Greetings.lean</code> and <code class="hljs">Greetings.lean</code> imports <code class="hljs">Greetings/Basic.lean</code>, the definition of <code class="hljs">hello</code> is available in <code class="hljs">main</code>.</p>
<p>To build the package, run the command <code class="hljs">lake build</code>.
After a number of build commands scroll by, the resulting binary has been placed in <code class="hljs">build/bin</code>.
Running <code class="hljs">./build/bin/greeting</code> results in <code class="hljs">Hello, world!</code>.</p>
<h2 id="lakefiles"><a class="header" href="#lakefiles">Lakefiles</a></h2>
<p>A <code class="hljs">lakefile.lean</code> describes a <em>package</em>, which is a coherent collection of Lean code for distribution, analogous to an <code class="hljs">npm</code> or <code class="hljs">nuget</code> package or a Rust crate.
A package may contain any number of libraries or executables.
While the <a href="https://github.com/leanprover/lean4/blob/master/src/lake/README.md">documentation for Lake</a> describes the available options in a lakefile, it makes use of a number of Lean features that have not yet been described here.
The generated <code class="hljs">lakefile.lean</code> contains the following:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">import</span> Lake
<span class="hljs-keyword">open</span> Lake DSL

package Â«greetingÂ» <span class="hljs-keyword">where</span>
  <span class="hljs-comment">-- add package configuration options here</span>

lean_lib Â«GreetingÂ» <span class="hljs-keyword">where</span>
  <span class="hljs-comment">-- add library configuration options here</span>

<span class="hljs-meta">@[default_target]</span>
lean_exe Â«greetingÂ» <span class="hljs-keyword">where</span>
  root := `Main
  <span class="hljs-comment">-- Enables the use of the Lean interpreter by the executable (e.g.,</span>
  <span class="hljs-comment">-- `runFrontend`) at the expense of increased binary size on Linux.</span>
  <span class="hljs-comment">-- Remove this line if you do not need such functionality.</span>
  supportInterpreter := true
</code></pre>
<p>This initial Lakefile consists of three items:</p>
<ul>
<li>a <em>package</em> declaration, named <code class="hljs">greeting</code>,</li>
<li>a <em>library</em> declaration, named <code class="hljs">Greeting</code>, and</li>
<li>an <em>executable</em>, also named <code class="hljs">greeting</code>.</li>
</ul>
<p>Each of these names is enclosed in guillemets to allow users more freedom in picking package names.</p>
<p>Each Lakefile will contain exactly one package, but any number of libraries or executables.
Additionally, Lakefiles may contain <em>external libraries</em>, which are libraries not written in Lean to be statically linked with the resulting executable, <em>custom targets</em>, which are build targets that don't fit naturally into the library/executable taxonomy, <em>dependencies</em>, which are declarations of other Lean packages (either locally or from remote Git repositories), and <em>scripts</em>, which are essentially <code class="hljs">IO</code> actions (similar to <code class="hljs">main</code>), but that additionally have access to metadata about the package configuration.
The items in the Lakefile allow things like source file locations, module hierarchies, and compiler flags to be configured.
Generally speaking, however, the defaults are reasonable.</p>
<p>Libraries, executables, and custom targets are all called <em>targets</em>.
By default, <code class="hljs">lake build</code> builds those targets that are annotated with <code class="hljs">@[default_target]</code>.
This annotation is an <em>attribute</em>, which is metadata that can be associated with a Lean declaration.
Attributes are similar to Java annotations or C# and Rust attributes.
They are used pervasively throughout Lean.
To build a target that is not annotated with <code class="hljs">@[default_target]</code>, specify the target's name as an argument after <code class="hljs">lake build</code>.</p>
<h2 id="libraries-and-imports"><a class="header" href="#libraries-and-imports">Libraries and Imports</a></h2>
<p>A Lean library consists of a hierarchically organized collection of source files from which names can be imported, called <em>modules</em>.
By default, a library has a single root file that matches its name.
In this case, the root file for the library <code class="hljs">Greeting</code> is <code class="hljs">Greeting.lean</code>.
The first line of <code class="hljs">Main.lean</code>, which is <code class="hljs">import Greeting</code>, makes the contents of <code class="hljs">Greeting.lean</code> available in <code class="hljs">Main.lean</code>.</p>
<p>Additional module files may be added to the library by creating a directory called <code class="hljs">Greeting</code> and placing them inside.
These names can be imported by replacing the directory separator with a dot.
For instance, creating the file <code class="hljs">Greeting/Smile.lean</code> with the contents:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">x</span><span class="hljs-title">p</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> String := <span class="hljs-string">"a big smile"</span>
</code></pre>
<p>means that <code class="hljs">Main.lean</code> can use the definition as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">import</span> Greeting
<span class="hljs-keyword">import</span> Greeting.Smile

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> IO Unit :=
  IO.println s!<span class="hljs-string">"Hello, {hello}, with {expression}!"</span>
</code></pre>
<p>The module name hierarchy is decoupled from the namespace hierarchy.
In Lean, modules are units of code distribution, while namespaces are units of code organization.
That is, names defined in the module <code class="hljs">Greeting.Smile</code> are not automatically in a corresponding namespace <code class="hljs">Greeting.Smile</code>.
Modules may place names into any namespace they like, and the code that imports them may <code class="hljs">open</code> the namespace or not.
<code class="hljs">import</code> is used to make the contents of a source file available, while <code class="hljs">open</code> makes names from a namespace available in the current context without prefixes.
In the Lakefile, the line <code class="hljs">import Lake</code> makes the contents of the <code class="hljs">Lake</code> module available, while the line <code class="hljs">open Lake DSL</code> makes the contents of the <code class="hljs">Lake</code> and <code class="hljs">Lake.DSL</code> namespaces available without any prefixes.
<code class="hljs">Lake.DSL</code> is opened because opening <code class="hljs">Lake</code> makes <code class="hljs">Lake.DSL</code> available as just <code class="hljs">DSL</code>, just like all other names in the <code class="hljs">Lake</code> namespace.
The <code class="hljs">Lake</code> module places names into both the <code class="hljs">Lake</code> and <code class="hljs">Lake.DSL</code> namespaces.</p>
<p>Namespaces may also be opened <em>selectively</em>, making only some of their names available without explicit prefixes.
This is done by writing the desired names in parentheses.
For example, <code class="hljs">Nat.toFloat</code> converts a natural number to a <code class="hljs">Float</code>.
It can be made available as <code class="hljs">toFloat</code> using <code class="hljs">open Nat (toFloat)</code>.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="worked-example-cat"><a class="header" href="#worked-example-cat">Worked Example: <code>cat</code></a></h1>
<p>The standard Unix utility <code class="hljs">cat</code> takes a number of command-line options, followed by zero or more input files.
If no files are provided, or if one of them is a dash (<code class="hljs">-</code>), then it takes the standard input as the corresponding input instead of reading a file.
The contents of the inputs are written, one after the other, to the standard output.
If a specified input file does not exist, this is noted on standard error, but <code class="hljs">cat</code> continues concatenating the remaining inputs.
A non-zero exit code is returned if any of the input files do not exist.</p>
<p>This section describes a simplified version of <code class="hljs">cat</code>, called <code class="hljs">feline</code>.
Unlike commonly-used versions of <code class="hljs">cat</code>, <code class="hljs">feline</code> has no command-line options for features such as numbering lines, indicating non-printing characters, or displaying help text.
Furthermore, it cannot read more than once from a standard input that's associated with a terminal device.</p>
<p>To get the most benefit from this section, follow along yourself.
It's OK to copy-paste the code examples, but it's even better to type them in by hand.
This makes it easier to learn the mechanical process of typing in code, recovering from mistakes, and interpreting feedback from the compiler.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h2>
<p>The first step in implementing <code class="hljs">feline</code> is to create a package and decide how to organize the code.
In this case, because the program is so simple, all the code will be placed in <code class="hljs">Main.lean</code>.
The first step is to run <code class="hljs">lake new feline</code>.
Edit the Lakefile to remove the library, and delete the generated library code and the reference to it from <code class="hljs">Main.lean</code>.
Once this has been done, <code class="hljs">lakefile.lean</code> should contain:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">import</span> Lake
<span class="hljs-keyword">open</span> Lake DSL

package Â«felineÂ» {
  <span class="hljs-comment">-- add package configuration options here</span>
}

<span class="hljs-meta">@[default_target]</span>
lean_exe Â«felineÂ» {
  root := `Main
}
</code></pre>
<p>and <code class="hljs">Main.lean</code> should contain something like:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> IO Unit :=
  IO.println s!<span class="hljs-string">"Hello, cats!"</span>
</code></pre>
<p>Alternatively, running <code class="hljs">lake new feline exe</code> instructs <code class="hljs">lake</code> to use a template that does not include a library section, making it unnecessary to edit the file.</p>
<p>Ensure that the code can be built by running <code class="hljs">lake build</code>.</p>
<h2 id="concatenating-streams"><a class="header" href="#concatenating-streams">Concatenating Streams</a></h2>
<p>Now that the basic skeleton of the program has been built, it's time to actually enter the code.
A proper implementation of <code class="hljs">cat</code> can be used with infinite IO streams, such as <code class="hljs">/dev/random</code>, which means that it can't read its input into memory before outputting it.
Furthermore, it should not work one character at a time, as this leads to frustratingly slow performance.
Instead, it's better to read contiguous blocks of data all at once, directing the data to the standard output one block at a time.</p>
<p>The first step is to decide how big of a block to read.
For the sake of simplicity, this implementation uses a conservative 20 kilobyte block.
<code class="hljs">USize</code> is analogous to <code class="hljs">size_t</code> in Câit's an unsigned integer type that is big enough to represent all valid array sizes.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">b</span><span class="hljs-title">u</span><span class="hljs-title">f</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">z</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> USize := <span class="hljs-number">20</span> * <span class="hljs-number">1024</span>
</code></pre>
<h3 id="streams"><a class="header" href="#streams">Streams</a></h3>
<p>The main work of <code class="hljs">feline</code> is done by <code class="hljs">dump</code>, which reads input one block at a time, dumping the result to standard output, until the end of the input has been reached:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">partial</span> <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">p</span> <span class="hljs-params">(stream : IO.FS.Stream)</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> buf â stream.read bufsize
  <span class="hljs-keyword">if</span> buf.isEmpty <span class="hljs-keyword">then</span>
    pure ()
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">let</span> stdout â IO.getStdout
    stdout.write buf
    dump stream
</code></pre>
<p>The <code class="hljs">dump</code> function is declared <code class="hljs">partial</code>, because it calls itself recursively on input that is not immediately smaller than an argument.
When a function is declared to be partial, Lean does not require a proof that it terminates.
On the other hand, partial functions are also much less amenable to proofs of correctness, because allowing infinite loops in Lean's logic would make it unsound.
However, there is no way to prove that <code class="hljs">dump</code> terminates, because infinite input (such as from <code class="hljs">/dev/random</code>) would mean that it does not, in fact, terminate.
In cases like this, there is no alternative to declaring the function <code class="hljs">partial</code>.</p>
<p>The type <code class="hljs">IO.FS.Stream</code> represents a POSIX stream.
Behind the scenes, it is represented as a structure that has one field for each POSIX stream operation.
Each operation is represented as an IO action that provides the corresponding operation:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">S</span><span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">m</span></span> <span class="hljs-keyword">where</span>
  flush   : IO Unit
  read    : USize â IO ByteArray
  write   : ByteArray â IO Unit
  getLine : IO String
  putStr  : String â IO Unit
</code></pre>
<p>The Lean compiler contains <code class="hljs">IO</code> actions (such as <code class="hljs">IO.getStdout</code>, which is called in <code class="hljs">dump</code>) to get streams that represent standard input, standard output, and standard error.
These are <code class="hljs">IO</code> actions rather than ordinary definitions because Lean allows these standard POSIX streams to be replaced in a process, which makes it easier to do things like capturing the output from a program into a string by writing a custom <code class="hljs">IO.FS.Stream</code>.</p>
<p>The control flow in <code class="hljs">dump</code> is essentially a <code class="hljs">while</code> loop.
When <code class="hljs">dump</code> is called, if the stream has reached the end of the file, <code class="hljs">pure ()</code> terminates the function by returning the constructor for <code class="hljs">Unit</code>.
If the stream has not yet reached the end of the file, one block is read, and its contents are written to <code class="hljs">stdout</code>, after which <code class="hljs">dump</code> calls itself directly.
The recursive calls continue until <code class="hljs">stream.read</code> returns an empty byte array, which indicates that the end of the file has been reached.</p>
<p>When an <code class="hljs">if</code> expression occurs as a statement in a <code class="hljs">do</code>, as in <code class="hljs">dump</code>, each branch of the <code class="hljs">if</code> is implicitly provided with a <code class="hljs">do</code>.
In other words, the sequence of steps following the <code class="hljs">else</code> are treated as a sequence of <code class="hljs">IO</code> actions to be executed, just as if they had a <code class="hljs">do</code> at the beginning.
Names introduced with <code class="hljs">let</code> in the branches of the <code class="hljs">if</code> are visible only in their own branches, and are not in scope outside of the <code class="hljs">if</code>.</p>
<p>There is no danger of running out of stack space while calling <code class="hljs">dump</code> because the recursive call happens as the very last step in the function, and its result is returned directly rather than being manipulated or computed with.
This kind of recursion is called <em>tail recursion</em>, and it is described in more detail <a href="https://leanprover.github.io/functional_programming_in_lean/programs-proofs/tail-recursion.html">later in this book</a>.
Because the compiled code does not need to retain any state, the Lean compiler can compile the recursive call to a jump.</p>
<p>If <code class="hljs">feline</code> only redirected standard input to standard output, then <code class="hljs">dump</code> would be sufficient.
However, it also needs to be able to open files that are provided as command-line arguments and emit their contents.
When its argument is the name of a file that exists, <code class="hljs">fileStream</code> returns a stream that reads the file's contents.
When the argument is not a file, <code class="hljs">fileStream</code> emits an error and returns <code class="hljs">none</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">S</span><span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">m</span> <span class="hljs-params">(filename : System.FilePath)</span> <span class="hljs-symbol">:</span></span> IO (Option IO.FS.Stream) := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> fileExists â filename.pathExists
  <span class="hljs-keyword">if</span> not fileExists <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">let</span> stderr â IO.getStderr
    stderr.putStrLn s!<span class="hljs-string">"File not found: {filename}"</span>
    pure none
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">let</span> handle â IO.FS.Handle.mk filename IO.FS.Mode.read
    pure (some (IO.FS.Stream.ofHandle handle))
</code></pre>
<p>Opening a file as a stream takes two steps.
First, a file handle is created by opening the file in read mode.
A Lean file handle tracks an underlying file descriptor.
When there are no references to the file handle value, a finalizer closes the file descriptor.
Second, the file handle is given the same interface as a POSIX stream using <code class="hljs">IO.FS.Stream.ofHandle</code>, which fills each field of the <code class="hljs">Stream</code> structure with the corresponding <code class="hljs">IO</code> action that works on file handles.</p>
<h3 id="handling-input"><a class="header" href="#handling-input">Handling Input</a></h3>
<p>The main loop of <code class="hljs">feline</code> is another tail-recursive function, called <code class="hljs">process</code>.
In order to return a non-zero exit code if any of the inputs could not be read, <code class="hljs">process</code> takes an argument <code class="hljs">exitCode</code> that represents the current exit code for the whole program.
Additionally, it takes a list of input files to be processed.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">c</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">s</span> <span class="hljs-params">(exitCode : UInt32)</span> <span class="hljs-params">(args : List String)</span> <span class="hljs-symbol">:</span></span> IO UInt32 := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">match</span> args <span class="hljs-keyword">with</span>
  | [] =&gt; pure exitCode
  | <span class="hljs-string">"-"</span> :: args =&gt;
    <span class="hljs-keyword">let</span> stdin â IO.getStdin
    dump stdin
    process exitCode args
  | filename :: args =&gt;
    <span class="hljs-keyword">let</span> stream â fileStream â¨filenameâ©
    <span class="hljs-keyword">match</span> stream <span class="hljs-keyword">with</span>
    | none =&gt;
      process <span class="hljs-number">1</span> args
    | some stream =&gt;
      dump stream
      process exitCode args
</code></pre>
<p>Just as with <code class="hljs">if</code>, each branch of a <code class="hljs">match</code> that is used as a statement in a <code class="hljs">do</code> is implicitly provided with its own <code class="hljs">do</code>.</p>
<p>There are three possibilities.
One is that no more files remain to be processed, in which case <code class="hljs">process</code> returns the error code unchanged.
Another is that the specified filename is <code class="hljs">"-"</code>, in which case <code class="hljs">process</code> dumps the contents of the standard input and then processes the remaining filenames.
The final possibility is that an actual filename was specified.
In this case, <code class="hljs">fileStream</code> is used to attempt to open the file as a POSIX stream.
Its argument is encased in <code class="hljs">â¨ ... â©</code> because a <code class="hljs">FilePath</code> is a single-field structure that contains a string.
If the file could not be opened, it is skipped, and the recursive call to <code class="hljs">process</code> sets the exit code to <code class="hljs">1</code>.
If it could, then it is dumped, and the recursive call to <code class="hljs">process</code> leaves the exit code unchanged.</p>
<p><code class="hljs">process</code> does not need to be marked <code class="hljs">partial</code> because it is structurally recursive.
Each recursive call is provided with the tail of the input list, and all Lean lists are finite.
Thus, <code class="hljs">process</code> does not introduce any non-termination.</p>
<h3 id="main"><a class="header" href="#main">Main</a></h3>
<p>The final step is to write the <code class="hljs">main</code> action.
Unlike prior examples, <code class="hljs">main</code> in <code class="hljs">feline</code> is a function.
In Lean, <code class="hljs">main</code> can have one of three types:</p>
<ul>
<li><code class="hljs">main : IO Unit</code> corresponds to programs that cannot read their command-line arguments and always indicate success with an exit code of <code class="hljs">0</code>,</li>
<li><code class="hljs">main : IO UInt32</code> corresponds to <code class="hljs">int main(void)</code> in C, for programs without arguments that return exit codes, and</li>
<li><code class="hljs">main : List String â IO UInt32</code> corresponds to <code class="hljs">int main(int argc, char **argv)</code> in C, for programs that take arguments and signal success or failure.</li>
</ul>
<p>If no arguments were provided, <code class="hljs">feline</code> should read from standard input as if it were called with a single <code class="hljs">"-"</code> argument.
Otherwise, the arguments should be processed one after the other.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">n</span> <span class="hljs-params">(args : List String)</span> <span class="hljs-symbol">:</span></span> IO UInt32 :=
  <span class="hljs-keyword">match</span> args <span class="hljs-keyword">with</span>
  | [] =&gt; process <span class="hljs-number">0</span> [<span class="hljs-string">"-"</span>]
  | _ =&gt;  process <span class="hljs-number">0</span> args
</code></pre>
<h2 id="meow"><a class="header" href="#meow">Meow!</a></h2>
<p>To check whether <code class="hljs">feline</code> works, the first step is to build it with <code class="hljs">lake build</code>.
First off, when called without arguments, it should emit what it receives from standard input.
Check that</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">echo "It works!" | ./build/bin/feline
</code></pre>
<p>emits <code class="hljs">It works!</code>.</p>
<p>Secondly, when called with files as arguments, it should print them.
If the file <code class="hljs">test1.txt</code> contains</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">It's time to find a warm spot
</code></pre>
<p>and <code class="hljs">test2.txt</code> contains</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">and curl up!
</code></pre>
<p>then the command</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">./build/bin/feline test1.txt test2.txt
</code></pre>
<p>should emit</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">It's time to find a warm spot
and curl up!
</code></pre>
<p>Finally, the <code class="hljs">-</code> argument should be handled appropriately.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">echo "and purr" | ./build/bin/feline test1.txt - test2.txt
</code></pre>
<p>should yield</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">It's time to find a warm spot
and purr
and curl up!
</code></pre>
<h2 id="exercise-1"><a class="header" href="#exercise-1">Exercise</a></h2>
<p>Extend <code class="hljs">feline</code> with support for usage information.
The extended version should accept a command-line argument <code class="hljs">--help</code> that causes documentation about the available command-line options to be written to standard output.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="additional-conveniences-1"><a class="header" href="#additional-conveniences-1">Additional Conveniences</a></h1>
<h2 id="nested-actions"><a class="header" href="#nested-actions">Nested Actions</a></h2>
<p>Many of the functions in <code class="hljs">feline</code> exhibit a repetitive pattern in which an <code class="hljs">IO</code> action's result is given a name, and then used immediately and only once.
For instance, in <code class="hljs">dump</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">partial</span> <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">p</span> <span class="hljs-params">(stream : IO.FS.Stream)</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> buf â stream.read bufsize
  <span class="hljs-keyword">if</span> buf.isEmpty <span class="hljs-keyword">then</span>
    pure ()
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">let</span> stdout â IO.getStdout
    stdout.write buf
    dump stream
</code></pre>
<p>the pattern occurs for <code class="hljs">stdout</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">    <span class="hljs-keyword">let</span> stdout â IO.getStdout
    stdout.write buf
</code></pre>
<p>Similarly, <code class="hljs">fileStream</code> contains the following snippet:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">  <span class="hljs-keyword">let</span> fileExists â filename.pathExists
  <span class="hljs-keyword">if</span> not fileExists <span class="hljs-keyword">then</span>
</code></pre>
<p>When Lean is compiling a <code class="hljs">do</code> block, expressions that consist of a left arrow immediately under parentheses are lifted to the nearest enclosing <code class="hljs">do</code>, and their results are bound to a unique name.
This unique name replaces the origin of the expression.
This means that <code class="hljs">dump</code> can also be written as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">partial</span> <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">p</span> <span class="hljs-params">(stream : IO.FS.Stream)</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> buf â stream.read bufsize
  <span class="hljs-keyword">if</span> buf.isEmpty <span class="hljs-keyword">then</span>
    pure ()
  <span class="hljs-keyword">else</span>
    (â IO.getStdout).write buf
    dump stream
</code></pre>
<p>This version of <code class="hljs">dump</code> avoids introducing names that are used only once, which can greatly simplify a program.
<code class="hljs">IO</code> actions that Lean lifts from a nested expression context are called <em>nested actions</em>.</p>
<p><code class="hljs">fileStream</code> can be simplified using the same technique:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">S</span><span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">m</span> <span class="hljs-params">(filename : System.FilePath)</span> <span class="hljs-symbol">:</span></span> IO (Option IO.FS.Stream) := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">if</span> not (â filename.pathExists) <span class="hljs-keyword">then</span>
    (â IO.getStderr).putStrLn s!<span class="hljs-string">"File not found: {filename}"</span>
    pure none
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">let</span> handle â IO.FS.Handle.mk filename IO.FS.Mode.read
    pure (some (IO.FS.Stream.ofHandle handle))
</code></pre>
<p>In this case, the local name of <code class="hljs">handle</code> could also have been eliminated using nested actions, but the resulting expression would have been long and complicated.
Even though it's often good style to use nested actions, it can still sometimes be helpful to name intermediate results.</p>
<p>It is important to remember, however, that nested actions are only a shorter notation for <code class="hljs">IO</code> actions that occur in a surrounding <code class="hljs">do</code> block.
The side effects that are involved in executing them still occur in the same order, and execution of side effects is not interspersed with the evaluation of expressions.
For an example of where this might be confusing, consider the following helper definitions that return data after announcing to the world that they have been executed:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">N</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">A</span> <span class="hljs-symbol">:</span></span> IO Nat := <span class="hljs-keyword">do</span>
  (â IO.getStdout).putStrLn <span class="hljs-string">"A"</span>
  pure <span class="hljs-number">5</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">N</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">B</span> <span class="hljs-symbol">:</span></span> IO Nat := <span class="hljs-keyword">do</span>
  (â IO.getStdout).putStrLn <span class="hljs-string">"B"</span>
  pure <span class="hljs-number">7</span>
</code></pre>
<p>These definitions are intended to stand in for more complicated <code class="hljs">IO</code> code that might validate user input, read a database, or open a file.</p>
<p>A program that prints <code class="hljs">0</code> when number A is five, or number <code class="hljs">B</code> otherwise, can be written as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> a : Nat := <span class="hljs-keyword">if</span> (â getNumA) == <span class="hljs-number">5</span> <span class="hljs-keyword">then</span> <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> (â getNumB)
  (â IO.getStdout).putStrLn s!<span class="hljs-string">"The answer is {a}"</span>
</code></pre>
<p>However, this program probably has more side effects (such as prompting for user input or reading a database) than was intended.
The definition of <code class="hljs">getNumA</code> makes it clear that it will always return <code class="hljs">5</code>, and thus the program should not read number B.
However, running the program results in the following output:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">A
B
The answer is 0
</code></pre>
<p><code class="hljs">getNumB</code> was executed because <code class="hljs">test</code> is equivalent to this definition:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> x â getNumA
  <span class="hljs-keyword">let</span> y â getNumB
  <span class="hljs-keyword">let</span> a : Nat := <span class="hljs-keyword">if</span> x == <span class="hljs-number">5</span> <span class="hljs-keyword">then</span> <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> y
  (â IO.getStdout).putStrLn s!<span class="hljs-string">"The answer is {a}"</span>
</code></pre>
<p>This is due to the rule that nested actions are lifted to the <em>closest enclosing</em> <code class="hljs">do</code> block.
The branches of the <code class="hljs">if</code> were not implicitly wrapped in <code class="hljs">do</code> blocks because the <code class="hljs">if</code> is not itself a statement in the <code class="hljs">do</code> blockâthe statement is the <code class="hljs">let</code> that defines <code class="hljs">a</code>.
Indeed, they could not be wrapped this way, because the type of the conditional expression is <code class="hljs">Nat</code>, not <code class="hljs">IO Nat</code>.</p>
<h2 id="flexible-layouts-for-do"><a class="header" href="#flexible-layouts-for-do">Flexible Layouts for <code>do</code></a></h2>
<p>In Lean, <code class="hljs">do</code> expressions are whitespace-sensitive.
Each <code class="hljs">IO</code> action or local binding in the <code class="hljs">do</code> is expected to start on its own line, and they should all have the same indentation.
Almost all uses of <code class="hljs">do</code> should be written this way.
In some rare contexts, however, manual control over whitespace and indentation may be necessary, or it may be convenient to have multiple small actions on a single line.
In these cases, newlines can be replaced with a semicolon and indentation can be replaced with curly braces.</p>
<p>For instance, all of the following programs are equivalent:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-comment">-- This version uses only whitespace-sensitive layout</span>
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> stdin â IO.getStdin
  <span class="hljs-keyword">let</span> stdout â IO.getStdout

  stdout.putStrLn <span class="hljs-string">"How would you like to be addressed?"</span>
  <span class="hljs-keyword">let</span> name := (â stdin.getLine).trim
  stdout.putStrLn s!<span class="hljs-string">"Hello, {name}!"</span>

<span class="hljs-comment">-- This version is as explicit as possible</span>
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span> {
  <span class="hljs-keyword">let</span> stdin â IO.getStdin;
  <span class="hljs-keyword">let</span> stdout â IO.getStdout;

  stdout.putStrLn <span class="hljs-string">"How would you like to be addressed?"</span>;
  <span class="hljs-keyword">let</span> name := (â stdin.getLine).trim;
  stdout.putStrLn s!<span class="hljs-string">"Hello, {name}!"</span>
}

<span class="hljs-comment">-- This version uses a semicolon to put two actions on the same line</span>
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> stdin â IO.getStdin; <span class="hljs-keyword">let</span> stdout â IO.getStdout

  stdout.putStrLn <span class="hljs-string">"How would you like to be addressed?"</span>
  <span class="hljs-keyword">let</span> name := (â stdin.getLine).trim
  stdout.putStrLn s!<span class="hljs-string">"Hello, {name}!"</span>
</code></pre>
<p>Idiomatic Lean code uses curly braces with <code class="hljs">do</code> very rarely.</p>
<h2 id="running-io-actions-with-eval"><a class="header" href="#running-io-actions-with-eval">Running <code>IO</code> Actions With <code>#eval</code></a></h2>
<p>Lean's <code class="hljs">#eval</code> command can be used to execute <code class="hljs">IO</code> actions, rather than just evaluating them.
Normally, adding a <code class="hljs">#eval</code> command to a Lean file causes Lean to evaluate the provided expression, convert the resulting value to a string, and provide that string as a tooltip and in the info window.
Rather than failing because <code class="hljs">IO</code> actions can't be converted to strings, <code class="hljs">#eval</code> executes them, carrying out their side effects.
If the result of execution is the <code class="hljs">Unit</code> value <code class="hljs">()</code>, then no result string is shown, but if it is a type that can be converted to a string, then Lean displays the resulting value.</p>
<p>This means that, given the prior definitions of <code class="hljs">countdown</code> and <code class="hljs">runActions</code>,</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> runActions (countdown <span class="hljs-number">3</span>)
</code></pre>
<p>displays</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">3
2
1
Blast off!
</code></pre>
<p>This is the output produced by running the <code class="hljs">IO</code> action, rather than some opaque representation of the action itself.
In other words, for <code class="hljs">IO</code> actions, <code class="hljs">#eval</code> both <em>evaluates</em> the provided expression and <em>executes</em> the resulting action value.</p>
<p>Quickly testing <code class="hljs">IO</code> actions with <code class="hljs">#eval</code> can be much more convenient that compiling and running whole programs.
However, there are some limitations.
For instance, reading from standard input simply returns empty input.
Additionally, the <code class="hljs">IO</code> action is re-executed whenever Lean needs to update the diagnostic information that it provides to users, and this can happen at unpredictable times.
An action that reads and writes files, for instance, may do so at inconvenient times.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="summary-1"><a class="header" href="#summary-1">Summary</a></h1>
<h2 id="evaluation-vs-execution"><a class="header" href="#evaluation-vs-execution">Evaluation vs Execution</a></h2>
<p>Side effects are aspects of program execution that go beyond the evaluation of mathematical expressions, such as reading files, throwing exceptions, or triggering industrial machinery.
While most languages allow side effects to occur during evaluation, Lean does not.
Instead, Lean has a type called <code class="hljs">IO</code> that represents <em>descriptions</em> of programs that use side effects.
These descriptions are then executed by the language's run-time system, which invokes the Lean expression evaluator to carry out specific computations.
Values of type <code class="hljs">IO Î±</code> are called <em><code class="hljs">IO</code> actions</em>.
The simplest is <code class="hljs">pure</code>, which returns its argument and has no actual side effects.</p>
<p><code class="hljs">IO</code> actions can also be understood as functions that take the whole world as an argument and return a new world in which the side effect has occurred.
Behind the scenes, the <code class="hljs">IO</code> library ensures that the world is never duplicated, created, or destroyed.
While this model of side effects cannot actually be implemented, as the whole universe is too big to fit in memory, the real world can be represented by a token that is passed around through the program.</p>
<p>An <code class="hljs">IO</code> action <code class="hljs">main</code> is executed when the program starts.
<code class="hljs">main</code> can have one of three types:</p>
<ul>
<li><code class="hljs">main : IO Unit</code> is used for simple programs that cannot read their command-line arguments and always return exit code <code class="hljs">0</code>,</li>
<li><code class="hljs">main : IO UInt32</code> is used for programs without arguments that may signal success or failure, and</li>
<li><code class="hljs">main : List String â IO UInt32</code> is used for programs that take command-line arguments and signal success or failure.</li>
</ul>
<h2 id="do-notation"><a class="header" href="#do-notation"><code>do</code> Notation</a></h2>
<p>The Lean standard library provides a number of basic <code class="hljs">IO</code> actions that represent effects such as reading from and writing to files and interacting with standard input and standard output.
These base <code class="hljs">IO</code> actions are composed into larger <code class="hljs">IO</code> actions using <code class="hljs">do</code> notation, which is a built-in domain-specific language for writing descriptions of programs with side effects.
A <code class="hljs">do</code> expression contains a sequence of <em>statements</em>, which may be:</p>
<ul>
<li>expressions that represent <code class="hljs">IO</code> actions,</li>
<li>ordinary local definitions with <code class="hljs">let</code> and <code class="hljs">:=</code>, where the defined name refers to the value of the provided expression, or</li>
<li>local definitions with <code class="hljs">let</code> and <code class="hljs">â</code>, where the defined name refers to the result of executing the value of the provided expression.</li>
</ul>
<p><code class="hljs">IO</code> actions that are written with <code class="hljs">do</code> are executed one statement at a time.</p>
<p>Furthermore, <code class="hljs">if</code> and <code class="hljs">match</code> expressions that occur immediately under a <code class="hljs">do</code> are implicitly considered to have their own <code class="hljs">do</code> in each branch.
Inside of a <code class="hljs">do</code> expression, <em>nested actions</em> are expressions with a left arrow immediately under parentheses.
The Lean compiler implicitly lifts them to the nearest enclosing <code class="hljs">do</code>, which may be implicitly part of a branch of a <code class="hljs">match</code> or <code class="hljs">if</code> expression, and gives them a unique name.
This unique name then replaces the origin site of the nested action.</p>
<h2 id="compiling-and-running-programs"><a class="header" href="#compiling-and-running-programs">Compiling and Running Programs</a></h2>
<p>A Lean program that consists of a single file with a <code class="hljs">main</code> definition can be run using <code class="hljs">lean --run FILE</code>.
While this can be a nice way to get started with a simple program, most programs will eventually graduate to a multiple-file project that should be compiled before running.</p>
<p>Lean projects are organized into <em>packages</em>, which are collections of libraries and executables together with information about dependencies and a build configuration.
Packages are described using Lake, a Lean build tool.
Use <code class="hljs">lake new</code> to create a Lake package in a new directory, or <code class="hljs">lake init</code> to create one in the current directory.
Lake package configuration is another domain-specific language.
Use <code class="hljs">lake build</code> to build a project.</p>
<h2 id="partiality"><a class="header" href="#partiality">Partiality</a></h2>
<p>One consequence of following the mathematical model of expression evaluation is that every expression must have a value.
This rules out both incomplete pattern matches that fail to cover all constructors of a datatype and programs that can fall into an infinite loop.
Lean ensures that all <code class="hljs">match</code> expressions cover all cases, and that all recursive functions are either structurally recursive or have an explicit proof of termination.</p>
<p>However, some real programs require the possibility of looping infinitely, because they handle potentially-infinite data, such as POSIX streams.
Lean provides an escape hatch: functions whose definition is marked <code class="hljs">partial</code> are not required to terminate.
This comes at a cost.
Because types are a first-class part of the Lean language, functions can return types.
Partial functions, however, are not evaluated during type checking, because an infinite loop in a function could cause the type checker to enter an infinite loop.
Furthermore, mathematical proofs are unable to inspect the definitions of partial functions, which means that programs that use them are much less amenable to formal proof.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="interlude-propositions-proofs-and-indexing"><a class="header" href="#interlude-propositions-proofs-and-indexing">Interlude: Propositions, Proofs, and Indexing</a></h1>
<p>Like many languages, Lean uses square brackets for indexing into arrays and lists.
For instance, if <code class="hljs">woodlandCritters</code> is defined as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">w</span><span class="hljs-title">o</span><span class="hljs-title">o</span><span class="hljs-title">d</span><span class="hljs-title">l</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">C</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> List String :=
  [<span class="hljs-string">"hedgehog"</span>, <span class="hljs-string">"deer"</span>, <span class="hljs-string">"snail"</span>]
</code></pre>
<p>then the individual components can be extracted:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">d</span><span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">h</span><span class="hljs-title">o</span><span class="hljs-title">g</span> <span class="hljs-symbol">:</span></span>= woodlandCritters[<span class="hljs-number">0</span>]
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-symbol">:</span></span>= woodlandCritters[<span class="hljs-number">1</span>]
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">n</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span> <span class="hljs-symbol">:</span></span>= woodlandCritters[<span class="hljs-number">2</span>]
</code></pre>
<p>However, attempting to extract the fourth element results in a compile-time error, rather than a run-time error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">o</span><span class="hljs-title">o</span><span class="hljs-title">p</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span>= woodlandCritters[<span class="hljs-number">3</span>]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to prove index is valid, possible solutions:
  - Use `have`-expressions to prove the index is valid
  - Use `a[i]!` notation instead, runtime check is perfomed, and 'Panic' error message is produced if index is not valid
  - Use `a[i]?` notation instead, result is an `Option` type
  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid
â¢ 3 &lt; List.length woodlandCritters
</code></pre>
<p>This error message is saying Lean tried to automatically mathematically prove that <code class="hljs">3 &lt; List.length woodlandCritters</code>, which would mean that the lookup was safe, but that it could not do so.
Out-of-bounds errors are a common class of bugs, and Lean uses its dual nature as a programming language and a theorem prover to rule out as many as possible.</p>
<p>Understanding how this works requires an understanding of three key ideas: propositions, proofs, and tactics.</p>
<h2 id="propositions-and-proofs"><a class="header" href="#propositions-and-proofs">Propositions and Proofs</a></h2>
<p>A <em>proposition</em> is a statement that can be true or false.
All of the following are propositions:</p>
<ul>
<li>1 + 1 = 2</li>
<li>Addition is commutative</li>
<li>There are infinitely many prime numbers</li>
<li>1 + 1 = 15</li>
<li>Paris is the capital of France</li>
<li>Buenos Aires is the capital of South Korea</li>
<li>All birds can fly</li>
</ul>
<p>On the other hand, nonsense statements are not propositions.
None of the following are propositions:</p>
<ul>
<li>1 + green = ice cream</li>
<li>All capital cities are prime numbers</li>
<li>At least one gorg is a fleep</li>
</ul>
<p>Propositions come in two varieties: those that are purely mathematical, relying only on our definitions of concepts, and those that are facts about the world.
Theorem provers like Lean are concerned with the former category, and have nothing to say about the flight capabilities of penguins or the legal status of cities.</p>
<p>A <em>proof</em> is a convincing argument that a proposition is true.
For mathematical propositions, these arguments make use of the definitions of the concepts that are involved as well as the rules of logical argumentation.
Most proofs are written for people to understand, and leave out many tedious details.
Computer-aided theorem provers like Lean are designed to allow mathematicians to write proofs while omitting many details, and it is the software's responsibility to fill in the missing explicit steps.
This decreases the likelihood of oversights or mistakes.</p>
<p>In Lean, a program's type describes the ways it can be interacted with.
For instance, a program of type <code class="hljs">Nat â List String</code> is a function that takes a <code class="hljs">Nat</code> argument and produces a list of strings.
In other words, each type specifies what counts as a program with that type.</p>
<p>In Lean, propositions are in fact types.
They specify what counts as evidence that the statement is true.
The proposition is proved by providing this evidence.
On the other hand, if the proposition is false, then it will be impossible to construct this evidence.</p>
<p>For example, the proposition "1 + 1 = 2" can be written directly in Lean.
The evidence for this proposition is the constructor <code class="hljs">rfl</code>, which is short for <em>reflexivity</em>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">e</span><span class="hljs-title">P</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">O</span><span class="hljs-title">n</span><span class="hljs-title">e</span><span class="hljs-title">I</span><span class="hljs-title">s</span><span class="hljs-title">Tw</span><span class="hljs-title">o</span> <span class="hljs-symbol">:</span></span> <span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">2</span> := <span class="hljs-built_in">rfl</span>
</code></pre>
<p>On the other hand, <code class="hljs">rfl</code> does not prove the false proposition "1 + 1 = 15":</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">e</span><span class="hljs-title">P</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">O</span><span class="hljs-title">n</span><span class="hljs-title">e</span><span class="hljs-title">I</span><span class="hljs-title">s</span><span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">f</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> <span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">15</span> := <span class="hljs-built_in">rfl</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">type mismatch
  rfl
has type
  1 + 1 = 1 + 1 : Prop
but is expected to have type
  1 + 1 = 15 : Prop
</code></pre>
<p>This error message indicates that <code class="hljs">rfl</code> can prove that two expressions are equal when both sides of the equality statement are already the same number.
Because <code class="hljs">1 + 1</code> evaluates directly to <code class="hljs">2</code>, they are considered to be the same, which allows <code class="hljs">onePlusOneIsTwo</code> to be accepted.
Just as <code class="hljs">Type</code> describes types such as <code class="hljs">Nat</code>, <code class="hljs">String</code>, and <code class="hljs">List (Nat Ã String Ã (Int â Float))</code> that represent data structures and functions, <code class="hljs">Prop</code> describes propositions.</p>
<p>When a proposition has been proven, it is called a <em>theorem</em>.
In Lean, it is conventional to declare theorems with the <code class="hljs">theorem</code> keyword instead of <code class="hljs">def</code>.
This helps readers see which declarations are intended to be read as mathematical proofs, and which are definitions.
Generally speaking, with a proof, what matters is that there is evidence that a proposition is true, but it's not particularly important <em>which</em> evidence was provided.
With definitions, on the other hand, it matters very much which particular value is selectedâafter all, a definition of addition that always returns <code class="hljs">0</code> is clearly wrong.</p>
<p>The prior example could be rewritten as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">O</span><span class="hljs-title">n</span><span class="hljs-title">e</span><span class="hljs-title">P</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">O</span><span class="hljs-title">n</span><span class="hljs-title">e</span><span class="hljs-title">I</span><span class="hljs-title">s</span><span class="hljs-title">Tw</span><span class="hljs-title">o</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> := <span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">2</span>

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">e</span><span class="hljs-title">P</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">O</span><span class="hljs-title">n</span><span class="hljs-title">e</span><span class="hljs-title">I</span><span class="hljs-title">s</span><span class="hljs-title">Tw</span><span class="hljs-title">o</span> <span class="hljs-symbol">:</span></span> OnePlusOneIsTwo := <span class="hljs-built_in">rfl</span>
</code></pre>
<h2 id="tactics"><a class="header" href="#tactics">Tactics</a></h2>
<p>Proofs are normally written using <em>tactics</em>, rather than by providing evidence directly.
Tactics are small programs that construct evidence for a proposition.
These programs run in a <em>proof state</em> that tracks the statement that is to be proved (called the <em>goal</em>) along with the assumptions that are available to prove it.
Running a tactic on a goal results in a new proof state that contains new goals.
The proof is complete when all goals have been proven.</p>
<p>To write a proof with tactics, begin the definition with <code class="hljs">by</code>.
Writing <code class="hljs">by</code> puts Lean into tactic mode until the end of the next indented block.
While in tactic mode, Lean provides ongoing feedback about the current proof state.
Written with tactics, <code class="hljs">onePlusOneIsTwo</code> is still quite short:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">e</span><span class="hljs-title">P</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">O</span><span class="hljs-title">n</span><span class="hljs-title">e</span><span class="hljs-title">I</span><span class="hljs-title">s</span><span class="hljs-title">Tw</span><span class="hljs-title">o</span> <span class="hljs-symbol">:</span></span> <span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">2</span> := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">simp</span>
</code></pre>
<p>The <code class="hljs">simp</code> tactic, short for "simplify", is the workhorse of Lean proofs.
It rewrites the goal to as simple a form as possible, taking care of parts of the proof that are small enough.
In particular, it proves simple equality statements.
Behind the scenes, a detailed formal proof is constructed, but using <code class="hljs">simp</code> hides this complexity.</p>
<p>Tactics are useful for a number of reasons:</p>
<ol>
<li>Many proofs are complicated and tedious when written out down to the smallest detail, and tactics can automate these uninteresting parts.</li>
<li>Proofs written with tactics are easier to maintain over time, because flexible automation can paper over small changes to definitions.</li>
<li>Because a single tactic can prove many different theorems, Lean can use tactics behind the scenes to free users from writing proofs by hand. For instance, an array lookup requires a proof that the index is in bounds, and a tactic can typically construct that proof without the user needing to worry about it.</li>
</ol>
<p>Behind the scenes, indexing notation uses a tactic to prove that the user's lookup operation is safe.
This tactic is <code class="hljs">simp</code>, configured to take certain arithmetic identities into account.</p>
<h2 id="connectives"><a class="header" href="#connectives">Connectives</a></h2>
<p>The basic building blocks of logic, such as "and", "or", "true", "false", and "not", are called <em>logical connectives</em>.
Each connective defines what counts as evidence of its truth.
For example, to prove a statement "<em>A</em> and <em>B</em>", one must prove both <em>A</em> and <em>B</em>.
This means that evidence for "<em>A</em> and <em>B</em>" is a pair that contains both evidence for <em>A</em> and evidence for <em>B</em>.
Similarly, evidence for "<em>A</em> or <em>B</em>" consists of either evidence for <em>A</em> or evidence for <em>B</em>.</p>
<p>In particular, most of these connectives are defined like datatypes, and they have constructors.
If <code class="hljs">A</code> and <code class="hljs">B</code> are propositions, then "<code class="hljs">A</code> and <code class="hljs">B</code>" (written <code class="hljs">A â§ B</code>) is a proposition.
Evidence for <code class="hljs">A â§ B</code> consists of the constructor <code class="hljs">And.intro</code>, which has the type <code class="hljs">A â B â A â§ B</code>.
Replacing <code class="hljs">A</code> and <code class="hljs">B</code> with concrete propositions, it is possible to prove <code class="hljs">1 + 1 = 2 â§ "Str".append "ing" = "String"</code> with <code class="hljs">And.intro rfl rfl</code>.
Of course, <code class="hljs">simp</code> is also powerful enough to find this proof:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">d</span><span class="hljs-title">A</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">A</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-symbol">:</span></span> <span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">2</span> â§ <span class="hljs-string">"Str"</span>.append <span class="hljs-string">"ing"</span> = <span class="hljs-string">"String"</span> := <span class="hljs-keyword">by</span> <span class="hljs-keyword">simp</span>
</code></pre>
<p>Similarly, "<code class="hljs">A</code> or <code class="hljs">B</code>" (written <code class="hljs">A â¨ B</code>) has two constructors, because a proof of "<code class="hljs">A</code> or <code class="hljs">B</code>" requires only that one of the two underlying propositions be true.
There are two constructors: <code class="hljs">Or.inl</code>, with type <code class="hljs">A â A â¨ B</code>, and <code class="hljs">Or.inr</code>, with type <code class="hljs">B â A â¨ B</code>.</p>
<p>Implication (if <em>A</em> then <em>B</em>) is represented using functions.
In particular, a function that transforms evidence for <em>A</em> into evidence for <em>B</em> is itself evidence that <em>A</em> implies <em>B</em>.
This is different from the usual description of implication, in which <code class="hljs">A â B</code> is shorthand for <code class="hljs">Â¬A â¨ B</code>, but the two formulations are equivalent.</p>
<p>Because evidence for an "and" is a constructor, it can be used with pattern matching.
For instance, a proof that <em>A</em> and <em>B</em> implies <em>A</em> or <em>B</em> is a function that pulls the evidence of <em>A</em> (or of <em>B</em>) out of the evidence for <em>A</em> and <em>B</em>, and then uses this evidence to produce evidence of <em>A</em> or <em>B</em>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">I</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">O</span><span class="hljs-title">r</span> <span class="hljs-symbol">:</span></span> A â§ B â A â¨ B :=
  <span class="hljs-keyword">fun</span> andEvidence =&gt;
    <span class="hljs-keyword">match</span> andEvidence <span class="hljs-keyword">with</span>
    | And.intro a b =&gt; Or.inl a
</code></pre>
<table><thead><tr><th>Connective</th><th>Lean Syntax</th><th>Evidence</th></tr></thead><tbody>
<tr><td>True</td><td><code class="hljs">True</code></td><td><code class="hljs">True.intro : True</code></td></tr>
<tr><td>False</td><td><code class="hljs">False</code></td><td>No evidence</td></tr>
<tr><td><em>A</em> and <em>B</em></td><td><code class="hljs">A â§ B</code></td><td><code class="hljs">And.intro : A â B â A â§ B</code></td></tr>
<tr><td><em>A</em> or <em>B</em></td><td><code class="hljs">A â¨ B</code></td><td>Either <code class="hljs">Or.inl : A â A â¨ B</code> or <code class="hljs">Or.inr : B â A â¨ B</code></td></tr>
<tr><td><em>A</em> implies <em>B</em></td><td><code class="hljs">A â B</code></td><td>A function that transforms evidence of <em>A</em> into evidence of <em>B</em></td></tr>
<tr><td>not <em>A</em></td><td><code class="hljs">Â¬A</code></td><td>A function that would transform evidence of <em>A</em> into evidence of <code class="hljs">False</code></td></tr>
</tbody></table>
<p>The <code class="hljs">simp</code> tactic can prove theorems that use these connectives.
For example:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">e</span><span class="hljs-title">P</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">O</span><span class="hljs-title">n</span><span class="hljs-title">e</span><span class="hljs-title">A</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">L</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">s</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> <span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">2</span> â¨ <span class="hljs-number">3</span> &lt; <span class="hljs-number">5</span> := <span class="hljs-keyword">by</span> <span class="hljs-keyword">simp</span>
<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">t</span><span class="hljs-title">Tw</span><span class="hljs-title">o</span><span class="hljs-title">E</span><span class="hljs-title">q</span><span class="hljs-title">u</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Â¬(<span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">5</span>) := <span class="hljs-keyword">by</span> <span class="hljs-keyword">simp</span>
<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">u</span><span class="hljs-title">e</span><span class="hljs-title">I</span><span class="hljs-title">s</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">u</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> True := True.<span class="hljs-keyword">intro</span>
<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">u</span><span class="hljs-title">e</span><span class="hljs-title">O</span><span class="hljs-title">r</span><span class="hljs-title">F</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> True â¨ False := <span class="hljs-keyword">by</span> <span class="hljs-keyword">simp</span>
<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">f</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">I</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">u</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> False â True := <span class="hljs-keyword">by</span> <span class="hljs-keyword">simp</span>
</code></pre>
<h2 id="evidence-as-arguments"><a class="header" href="#evidence-as-arguments">Evidence as Arguments</a></h2>
<p>While <code class="hljs">simp</code> does a great job proving propositions that involve equalities and inequalities of specific numbers, it is not very good at proving statements that involve variables.
For instance, <code class="hljs">simp</code> can prove that <code class="hljs">4 &lt; 15</code>, but it can't easily tell that because <code class="hljs">x &lt; 4</code>, it's also true that <code class="hljs">x &lt; 15</code>.
Because index notation uses <code class="hljs">simp</code> behind the scenes to prove that array access is safe, it can require a bit of hand-holding.</p>
<p>One of the easiest ways to make indexing notation work well is to have the function that performs a lookup into a data structure take the required evidence of safety as an argument.
For instance, a function that returns the third entry in a list is not generally safe because lists might contain zero, one, or two entries:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">d</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Î± := xs[<span class="hljs-number">2</span>]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to prove index is valid, possible solutions:
  - Use `have`-expressions to prove the index is valid
  - Use `a[i]!` notation instead, runtime check is perfomed, and 'Panic' error message is produced if index is not valid
  - Use `a[i]?` notation instead, result is an `Option` type
  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid
Î± : Type ?u.3908
xs : List Î±
â¢ 2 &lt; List.length xs
</code></pre>
<p>However, the obligation to show that the list has at least three entries can be imposed on the caller by adding an argument that consists of evidence that the indexing operation is safe:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">d</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-params">(ok : xs.length &gt; 2)</span> <span class="hljs-symbol">:</span></span> Î± := xs[<span class="hljs-number">2</span>]
</code></pre>
<p>In this example, <code class="hljs">xs.length &gt; 2</code> is not a program that checks <em>whether</em> <code class="hljs">xs</code> has more than 2 entries.
It is a proposition that could be true or false, and the argument <code class="hljs">ok</code> must be evidence that it is true.</p>
<p>When the function is called on a concrete list, its length is known.
In these cases, <code class="hljs">by simp</code> can construct the evidence automatically:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-keyword">#eval</span> third woodlandCritters (<span class="hljs-keyword">by</span> <span class="hljs-keyword">simp</span>)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">"snail"
</code></pre>
<h2 id="indexing-without-evidence"><a class="header" href="#indexing-without-evidence">Indexing Without Evidence</a></h2>
<p>In cases where it's not practical to prove that an indexing operation is in bounds, there are other alternatives.
Adding a question mark results in an <code class="hljs">Option</code>, where the result is <code class="hljs">some</code> if the index is in bounds, and <code class="hljs">none</code> otherwise.
For example:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">d</span><span class="hljs-title">O</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Option Î± := xs[<span class="hljs-number">2</span>]?

<span class="hljs-keyword">#eval</span> thirdOption woodlandCritters
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">some "snail"
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> thirdOption [<span class="hljs-string">"only"</span>, <span class="hljs-string">"two"</span>]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">none
</code></pre>
<p>There is also a version that crashes the program when the index is out of bounds, rather than returning an <code class="hljs">Option</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> woodlandCritters[<span class="hljs-number">1</span>]!
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">"deer"
</code></pre>
<p>Be careful!
Because code that is run with <code class="hljs">#eval</code> runs in the context of the Lean compiler, selecting the wrong index can crash your IDE.</p>
<h2 id="messages-you-may-meet-3"><a class="header" href="#messages-you-may-meet-3">Messages You May Meet</a></h2>
<p>In addition to the error that occurs when Lean is unable to find compile-time evidence that an indexing operation is safe, polymorphic functions that use unsafe indexing may produce the following message:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">a</span><span class="hljs-title">f</span><span class="hljs-title">e</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">d</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Î± := xs[<span class="hljs-number">2</span>]!
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to synthesize instance
  Inhabited Î±
</code></pre>
<p>This is due to a technical restriction that is part of keeping Lean usable as both a logic for proving theorems and a programming language.
In particular, only programs whose types contain at least one value are allowed to crash.
This is because a proposition in Lean is a kind of type that classifies evidence of its truth.
False propositions have no such evidence.
If a program with an empty type could crash, then that crashing program could be used as a kind of fake evidence for a false proposition.</p>
<p>Internally, Lean contains a table of types that are known to have at least one value.
This error is saying that some arbitrary type <code class="hljs">Î±</code> is not necessarily in that table.
The next chapter describes how to add to this table, and how to successfully write functions like <code class="hljs">unsafeThird</code>.</p>
<p>Adding whitespace between a list and the brackets used for lookup can cause another message:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> woodlandCritters [<span class="hljs-number">1</span>]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">function expected at
  woodlandCritters
term has type
  List String
</code></pre>
<p>Adding a space causes Lean to treat the expression as a function application, and the index as a list that contains a single number.
This error message results from having Lean attempt to treat <code class="hljs">woodlandCritters</code> as a function.</p>
<h2 id="exercises-4"><a class="header" href="#exercises-4">Exercises</a></h2>
<ul>
<li>Prove the following theorems using <code class="hljs">rfl</code>: <code class="hljs">2 + 3 = 5</code>, <code class="hljs">15 - 8 = 7</code>, <code class="hljs">"Hello, ".append "world" = "Hello, world"</code>. What happens if <code class="hljs">rfl</code> is used to prove <code class="hljs">5 &lt; 18</code>? Why?</li>
<li>Prove the following theorems using <code class="hljs">by simp</code>: <code class="hljs">2 + 3 = 5</code>, <code class="hljs">15 - 8 = 7</code>, <code class="hljs">"Hello, ".append "world" = "Hello, world"</code>, <code class="hljs">5 &lt; 18</code>.</li>
<li>Write a function that looks up the fifth entry in a list. Pass the evidence that this lookup is safe as an argument to the function.</li>
</ul>
<div style="break-before:page;page-break-before:always"></div><h1 id="overloading-and-type-classes"><a class="header" href="#overloading-and-type-classes">Overloading and Type Classes</a></h1>
<p>In many languages, the built-in datatypes get special treatment.
For example, in C and Java, <code class="hljs">+</code> can be used to add <code class="hljs">float</code>s and <code class="hljs">int</code>s, but not arbitrary-precision numbers from a third-party library.
Similarly, numeric literals can be used directly for the built-in types, but not for user-defined number types.
Other languages provide an <em>overloading</em> mechanism for operators, where the same operator can be given a meaning for a new type.
In these languages, such as C++ and C#, a wide variety of built-in operators can be overloaded, and the compiler uses the type checker to select a particular implementation.</p>
<p>In addition to numeric literals and operators, many languages allow overloading of functions or methods.
In C++, Java, C# and Kotlin, multiple implementations of a method are allowed, with differing numbers and types of arguments.
The compiler uses the number of arguments and their types to determine which overload was intended.</p>
<p>Function and operator overloading has a key limitation: polymorphic functions can't restrict their type arguments to types for which a given overload exists.
For example, an overloaded method might be defined for strings, byte arrays, and file pointers, but there's no way to write a second method that works for any of these.
Instead, this second method must itself be overloaded for each type that has an overload of the original method, resulting in many boilerplate definitions instead of a single polymorphic definition.
Another consequence of this restriction is that some operators (such as equality in Java) end up being defined for <em>every</em> combination of arguments, even when it is not necessarily sensible to do so.
If programmers are not very careful, this can lead to programs that crash at runtime or silently compute an incorrect result.</p>
<p>Lean implements overloading using a mechanism called <em>type classes</em>, pioneered in Haskell, that allows overloading of operators, functions, and literals in a manner that works well with polymorphism.
A type class describes a collection of overloadable operations.
To overload these operations for a new type, an <em>instance</em> is created that contains an implementation of each operation for the new type.
For example, a type class named <code class="hljs">Add</code> describes types that allow addition, and an instance of <code class="hljs">Add</code> for <code class="hljs">Nat</code> provides an implementation of addition for <code class="hljs">Nat</code>.</p>
<p>The terms <em>class</em> and <em>instance</em> can be confusing for those who are used to object-oriented languages, because they are not closely related to classes and instances in object-oriented languages.
However, they do share common roots: in everyday language, the term "class" refers to a group that shares some common attributes.
While classes in object-oriented programming certainly describe groups of objects with common attributes, the term additionally refers to a specific mechanism in a programming language for describing such a group.
Type classes are also a means of describing types that share common attributes (namely, implementations of certain operations), but they don't really have anything else in common with classes as found in object-oriented programming.</p>
<p>A Lean type class is much more analogous to a Java or C# <em>interface</em>.
Both type classes and interfaces describe a conceptually related set of operations that are implemented for a type or collection of types.
Similarly, an instance of a type class is akin to the code in a Java or C# class that is prescribed by the implemented interfaces, rather than an instance of a Java or C# class.
Unlike Java or C#'s interfaces, types can be given instances for type classes that the author of the type does not have access to.
In this way, they are very similar to Rust traits.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="positive-numbers"><a class="header" href="#positive-numbers">Positive Numbers</a></h1>
<p>In some applications, only positive numbers make sense.
For example, compilers and interpreters typically use one-indexed line and column numbers for source positions, and a datatype that represents only non-empty lists will never report a length of zero.
Rather than relying on natural numbers, and littering the code with assertions that the number is not zero, it can be useful to design a datatype that represents only positive numbers.</p>
<p>One way to represent positive numbers is very similar to <code class="hljs">Nat</code>, except with <code class="hljs">one</code> as the base case instead of <code class="hljs">zero</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Pos : <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  | one : Pos
  | succ : Pos â Pos
</code></pre>
<p>This datatype represents exactly the intended set of values, but it is not very convenient to use.
For example, numeric literals are rejected:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> Pos := <span class="hljs-number">7</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to synthesize instance
  OfNat Pos 7
</code></pre>
<p>Instead, the constructors must be used directly:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> Pos :=
  Pos.succ (Pos.succ (Pos.succ (Pos.succ (Pos.succ (Pos.succ Pos.one)))))
</code></pre>
<p>Similarly, addition and multiplication are not easy to use:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> Pos := seven + seven
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to synthesize instance
  HAdd Pos Pos ?m.291
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">y</span><span class="hljs-title">N</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Pos := seven * seven
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to synthesize instance
  HMul Pos Pos ?m.291
</code></pre>
<p>Each of these error messages begins with <code class="hljs">failed to synthesize instance</code>.
This indicates that the error is due to an overloaded operation that has not been implemented, and it describes the type class that must be implemented.</p>
<h2 id="classes-and-instances"><a class="header" href="#classes-and-instances">Classes and Instances</a></h2>
<p>A type class consists of a name, some parameters, and a collection of <em>methods</em>.
The parameters describe the types for which overloadable operations are being defined, and the methods are the names and type signatures of the overloadable operations.
Once again, there is a terminology clash with object-oriented languages.
In object-oriented programming, a method is essentially a function that is connected to a particular object in memory, with special access to the object's private state.
Objects are interacted with via their methods.
In Lean, the term "method" refers to an operation that has been declared to be overloadable, with no special connection to objects or values or private fields.</p>
<p>One way to overload addition is to define a type class named <code class="hljs">Plus</code>, with an addition method named <code class="hljs">plus</code>.
Once an instance of <code class="hljs">Plus</code> for <code class="hljs">Nat</code> has been defined, it becomes possible to add two <code class="hljs">Nat</code>s using <code class="hljs">Plus.plus</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> Plus.plus <span class="hljs-number">5</span> <span class="hljs-number">3</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">8
</code></pre>
<p>Adding more instances allows <code class="hljs">Plus.plus</code> to take more types of arguments.</p>
<p>In the following type class declaration, <code class="hljs">Plus</code> is the name of the class, <code class="hljs">Î± : Type</code> is the only argument, and <code class="hljs">plus : Î± â Î± â Î±</code> is the only method:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">P</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span></span> <span class="hljs-keyword">where</span>
  plus : Î± â Î± â Î±
</code></pre>
<p>This declaration says that there is a type class <code class="hljs">Plus</code> that overloads operations with respect to a type <code class="hljs">Î±</code>.
In particular, there is one overloaded operation called <code class="hljs">plus</code> that takes two <code class="hljs">Î±</code>s and returns an <code class="hljs">Î±</code>.</p>
<p>Type classes are first class, just as types are first class.
In particular, a type class is another kind of type.
The type of <code class="hljs">Plus</code> is <code class="hljs">Type â Type</code>, because it takes a type as an argument (<code class="hljs">Î±</code>) and results in a new type that describes the overloading of <code class="hljs">Plus</code>'s operation for <code class="hljs">Î±</code>.</p>
<p>To overload <code class="hljs">plus</code> for a particular type, write an instance:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Plus Nat <span class="hljs-keyword">where</span>
  plus := Nat.add
</code></pre>
<p>The colon after <code class="hljs">instance</code> indicates that <code class="hljs">Plus Nat</code> is indeed a type.
Each method of class <code class="hljs">Plus</code> should be assigned a value using <code class="hljs">:=</code>.
In this case, there is only one method: <code class="hljs">plus</code>.</p>
<p>By default, type class methods are defined in a namespace with the same name as the type class.
It can be convenient to <code class="hljs">open</code> the namespace so that users don't need to type the name of the class first.
Parentheses in an <code class="hljs">open</code> command indicate that only the indicated names from the namespace are to be made accessible:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> Plus (plus)

<span class="hljs-keyword">#eval</span> plus <span class="hljs-number">5</span> <span class="hljs-number">3</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">8
</code></pre>
<p>Defining an addition function for <code class="hljs">Pos</code> and an instance of <code class="hljs">Plus Pos</code> allows <code class="hljs">plus</code> to be used to add both <code class="hljs">Pos</code> and <code class="hljs">Nat</code> values:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">s</span>.<span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> Pos â Pos â Pos
  | Pos.one, k =&gt; Pos.succ k
  | Pos.succ n, k =&gt; Pos.succ (n.plus k)

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Plus Pos <span class="hljs-keyword">where</span>
  plus := Pos.plus

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> Pos := plus seven seven
</code></pre>
<p>Because there is not yet an instance of <code class="hljs">Plus Float</code>, attempting to add two floating-point numbers with <code class="hljs">plus</code> fails with a familiar message:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> plus <span class="hljs-number">5.2</span> <span class="hljs-number">917.25861</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to synthesize instance
  Plus Float
</code></pre>
<p>These errors mean that Lean was unable to find an instance for a given type class.</p>
<h2 id="overloaded-addition"><a class="header" href="#overloaded-addition">Overloaded Addition</a></h2>
<p>Lean's built-in addition operator is syntactic sugar for a type class called <code class="hljs">HAdd</code>, which flexibly allows the arguments to addition to have different types.
<code class="hljs">HAdd</code> is short for <em>heterogeneous addition</em>.
For example, an <code class="hljs">HAdd</code> instance can be written to allow a <code class="hljs">Nat</code> to be added to a <code class="hljs">Float</code>, resulting in a new <code class="hljs">Float</code>.
When a programmer writes <code class="hljs">x + y</code>, it is interpreted as meaning <code class="hljs">HAdd.hAdd x y</code>.</p>
<p>While an understanding of the full generality of <code class="hljs">HAdd</code> relies on features that are discussed in <a href="https://leanprover.github.io/functional_programming_in_lean/type-classes/out-params.html">another section in this chapter</a>, there is a simpler type class called <code class="hljs">Add</code> that does not allow the types of the arguments to be mixed.
The Lean libraries are set up so that an instance of <code class="hljs">Add</code> will be found when searching for an instance of <code class="hljs">HAdd</code> in which both arguments have the same type.</p>
<p>Defining an instance of <code class="hljs">Add Pos</code> allows <code class="hljs">Pos</code> values to use ordinary addition syntax:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Add Pos <span class="hljs-keyword">where</span>
  add := Pos.plus

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> Pos := seven + seven
</code></pre>
<h2 id="conversion-to-strings"><a class="header" href="#conversion-to-strings">Conversion to Strings</a></h2>
<p>Another useful built-in class is called <code class="hljs">ToString</code>.
Instances of <code class="hljs">ToString</code> provide a standard way of converting values from a given type into strings.
For example, a <code class="hljs">ToString</code> instance is used when a value occurs in an interpolated string, and it determines how the <code class="hljs">IO.println</code> function used at the <a href="https://leanprover.github.io/functional_programming_in_lean/hello-world/running-a-program.html#running-a-program">beginning of the description of <code class="hljs">IO</code></a> will display a value.</p>
<p>For example, one way to convert a <code class="hljs">Pos</code> into a <code class="hljs">String</code> is to reveal its inner structure.
The function <code class="hljs">posToString</code> takes a <code class="hljs">Bool</code> that determines whether to parenthesize uses of <code class="hljs">Pos.succ</code>, which should be <code class="hljs">true</code> in the initial call to the function and <code class="hljs">false</code> in all recursive calls.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-title">o</span><span class="hljs-title">s</span><span class="hljs-title">T</span><span class="hljs-title">o</span><span class="hljs-title">S</span><span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">g</span> <span class="hljs-params">(atTop : Bool)</span> <span class="hljs-params">(p : Pos)</span> <span class="hljs-symbol">:</span></span> String :=
  <span class="hljs-keyword">let</span> paren s := <span class="hljs-keyword">if</span> atTop <span class="hljs-keyword">then</span> s <span class="hljs-keyword">else</span> <span class="hljs-string">"("</span> ++ s ++ <span class="hljs-string">")"</span>
  <span class="hljs-keyword">match</span> p <span class="hljs-keyword">with</span>
  | Pos.one =&gt; <span class="hljs-string">"Pos.one"</span>
  | Pos.succ n =&gt; paren s!<span class="hljs-string">"Pos.succ {posToString false n}"</span>
</code></pre>
<p>Using this function for a <code class="hljs">ToString</code> instance:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> ToString Pos <span class="hljs-keyword">where</span>
  toString := posToString true
</code></pre>
<p>results in informative, yet overwhelming, output:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> s!<span class="hljs-string">"There are {seven}"</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">"There are Pos.succ (Pos.succ (Pos.succ (Pos.succ (Pos.succ (Pos.succ Pos.one)))))"
</code></pre>
<p>On the other hand, every positive number has a corresponding <code class="hljs">Nat</code>.
Converting it to a <code class="hljs">Nat</code> and then using the <code class="hljs">ToString Nat</code> instance (that is, the overloading of <code class="hljs">toString</code> for <code class="hljs">Nat</code>) is a quick way to generate much shorter output:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">s</span>.<span class="hljs-title">t</span><span class="hljs-title">o</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> Pos â Nat
  | Pos.one =&gt; <span class="hljs-number">1</span>
  | Pos.succ n =&gt; n.toNat + <span class="hljs-number">1</span>

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> ToString Pos <span class="hljs-keyword">where</span>
  toString x := toString (x.toNat)

<span class="hljs-keyword">#eval</span> s!<span class="hljs-string">"There are {seven}"</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">"There are 7"
</code></pre>
<p>When more than one instance is defined, the most recent takes precedence.
Additionally, if a type has a <code class="hljs">ToString</code> instance, then it can be used to display the result of <code class="hljs">#eval</code> even if the type in question was not defined with <code class="hljs">deriving Repr</code>, so <code class="hljs">#eval seven</code> outputs <code class="hljs">7</code>.</p>
<h2 id="overloaded-multiplication"><a class="header" href="#overloaded-multiplication">Overloaded Multiplication</a></h2>
<p>For multiplication, there is a type class called <code class="hljs">HMul</code> that allows mixed argument types, just like <code class="hljs">HAdd</code>.
Just as <code class="hljs">x + y</code> is interpreted as <code class="hljs">HAdd.hAdd x y</code>, <code class="hljs">x * y</code> is interpreted as <code class="hljs">HMul.hMul x y</code>.
For the common case of multiplication of two arguments with the same type, a <code class="hljs">Mul</code> instance suffices.</p>
<p>An instance of <code class="hljs">Mul</code> allows ordinary multiplication syntax to be used with <code class="hljs">Pos</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">s</span>.<span class="hljs-title">m</span><span class="hljs-title">u</span><span class="hljs-title">l</span> <span class="hljs-symbol">:</span></span> Pos â Pos â Pos
  | Pos.one, k =&gt; k
  | Pos.succ n, k =&gt; n.mul k + k

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Mul Pos <span class="hljs-keyword">where</span>
  mul := Pos.mul
</code></pre>
<p>With this instance, multiplication works as expected:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> [seven * Pos.one,
       seven * seven,
       Pos.succ Pos.one * seven]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">[7, 49, 14]
</code></pre>
<h2 id="literal-numbers"><a class="header" href="#literal-numbers">Literal Numbers</a></h2>
<p>It is quite inconvenient to write out a sequence of constructors for positive numbers.
One way to work around the problem would be to provide a function to convert a <code class="hljs">Nat</code> into a <code class="hljs">Pos</code>.
However, this approach has downsides.
First off, because <code class="hljs">Pos</code> cannot represent <code class="hljs">0</code>, the resulting function would either convert a <code class="hljs">Nat</code> to a bigger number, or it would return <code class="hljs">Option Pos</code>.
Neither is particularly convenient for users.
Secondly, the need to call the function explicitly would make programs that use positive numbers much less convenient to write than programs that use <code class="hljs">Nat</code>.
Having a trade-off between precise types and convenient APIs means that the precise types become less useful.</p>
<p>In Lean, natural number literals are interpreted using a type class called <code class="hljs">OfNat</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">O</span><span class="hljs-title">f</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(_ : Nat)</span></span> <span class="hljs-keyword">where</span>
  ofNat : Î±
</code></pre>
<p>This type class takes two arguments: <code class="hljs">Î±</code> is the type for which a natural number is overloaded, and the unnamed <code class="hljs">Nat</code> argument is the actual literal number that was encountered in the program.
The method <code class="hljs">ofNat</code> is then used as the value of the numeric literal.
Because the class contains the <code class="hljs">Nat</code> argument, it becomes possible to define only instances for those values where the number makes sense.</p>
<p><code class="hljs">OfNat</code> demonstrates that the arguments to type classes do not need to be types.
Because types in Lean are first-class participants in the language that can be passed as arguments to functions and given definitions with <code class="hljs">def</code> and <code class="hljs">abbrev</code>, there is no barrier that prevents non-type arguments in positions where a less-flexible language could not permit them.
This flexibility allows overloaded operations to be provided for particular values as well as particular types.</p>
<p>For example, a sum type that represents natural numbers less than four can be defined as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> LT4 <span class="hljs-keyword">where</span>
  | zero
  | one
  | two
  | three
<span class="hljs-keyword">deriving</span> Repr
</code></pre>
<p>While it would not make sense to allow <em>any</em> literal number to be used for this type, numbers less than four clearly make sense:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> OfNat LT4 <span class="hljs-number">0</span> <span class="hljs-keyword">where</span>
  ofNat := LT4.zero

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> OfNat LT4 <span class="hljs-number">1</span> <span class="hljs-keyword">where</span>
  ofNat := LT4.one

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> OfNat LT4 <span class="hljs-number">2</span> <span class="hljs-keyword">where</span>
  ofNat := LT4.two

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> OfNat LT4 <span class="hljs-number">3</span> <span class="hljs-keyword">where</span>
  ofNat := LT4.three
</code></pre>
<p>With these instances, the following examples work:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (<span class="hljs-number">3</span> : LT4)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">LT4.three
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (<span class="hljs-number">0</span> : LT4)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">LT4.zero
</code></pre>
<p>On the other hand, out-of-bounds literals are still not allowed:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (<span class="hljs-number">4</span> : LT4)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to synthesize instance
OfNat LT4 4
</code></pre>
<p>For <code class="hljs">Pos</code>, the <code class="hljs">OfNat</code> instance should work for <em>any</em> <code class="hljs">Nat</code> other than <code class="hljs">Nat.zero</code>.
Another way to phrase this is to say that for all natural numbers <code class="hljs">n</code>, the instance should work for <code class="hljs">n + 1</code>.
Just as names like <code class="hljs">Î±</code> automatically become implicit arguments to functions that Lean fills out on its own, instances can take automatic implicit arguments.
In this instance, the argument <code class="hljs">n</code> stands for any <code class="hljs">Nat</code>, and the instance is defined for a <code class="hljs">Nat</code> that's one greater:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> OfNat Pos (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">where</span>
  ofNat :=
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> natPlusOne : Nat â Pos
      | <span class="hljs-number">0</span> =&gt; Pos.one
      | k + <span class="hljs-number">1</span> =&gt; Pos.succ (natPlusOne k)
    natPlusOne n
</code></pre>
<p>Because <code class="hljs">n</code> stands for a <code class="hljs">Nat</code> that's one less than what the user wrote, the helper function <code class="hljs">natPlusOne</code> returns a <code class="hljs">Pos</code> that's one greater than its argument.
This makes it possible to use natural number literals for positive numbers, but not for zero:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">i</span><span class="hljs-title">g</span><span class="hljs-title">h</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> Pos := <span class="hljs-number">8</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">o</span> <span class="hljs-symbol">:</span></span> Pos := <span class="hljs-number">0</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to synthesize instance
  OfNat Pos 0
</code></pre>
<h2 id="exercises-5"><a class="header" href="#exercises-5">Exercises</a></h2>
<h3 id="another-representation"><a class="header" href="#another-representation">Another Representation</a></h3>
<p>An alternative way to represent a positive number is as the successor of some <code class="hljs">Nat</code>.
Replace the definition of <code class="hljs">Pos</code> with a structure whose constructor is named <code class="hljs">succ</code> that contains a <code class="hljs">Nat</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">s</span></span> <span class="hljs-keyword">where</span>
  succ ::
  pred : Nat
</code></pre>
<p>Define instances of <code class="hljs">Add</code>, <code class="hljs">Mul</code>, <code class="hljs">ToString</code>, and <code class="hljs">OfNat</code> that allow this version of <code class="hljs">Pos</code> to be used conveniently.</p>
<h3 id="even-numbers"><a class="header" href="#even-numbers">Even Numbers</a></h3>
<p>Define a datatype that represents only even numbers. Define instances of <code class="hljs">Add</code>, <code class="hljs">Mul</code>, and <code class="hljs">ToString</code> that allow it to be used conveniently.
<code class="hljs">OfNat</code> requires a feature that is introduced in <a href="https://leanprover.github.io/functional_programming_in_lean/type-classes/polymorphism.html">the next section</a>.</p>
<h3 id="http-requests"><a class="header" href="#http-requests">HTTP Requests</a></h3>
<p>An HTTP request begins with an identification of a HTTP method, such as <code class="hljs">GET</code> or <code class="hljs">POST</code>, along with a URI and an HTTP version.
Define an inductive type that represents an interesting subset of the HTTP methods, and a structure that represents HTTP responses.
Responses should have a <code class="hljs">ToString</code> instance that makes it possible to debug them.
Use a type class to associate different <code class="hljs">IO</code> actions with each HTTP method, and write a test harness as an <code class="hljs">IO</code> action that calls each method and prints the result.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="type-classes-and-polymorphism"><a class="header" href="#type-classes-and-polymorphism">Type Classes and Polymorphism</a></h1>
<p>It can be useful to write functions that work for <em>any</em> overloading of a given function.
For instance, <code class="hljs">IO.println</code> works for any type that has an instance of <code class="hljs">ToString</code>.
This is indicated using square brackets around the required instance: the type of <code class="hljs">IO.println</code> is <code class="hljs">{Î± : Type} â [ToString Î±] â Î± â IO Unit</code>.
This type says that <code class="hljs">IO.println</code> accepts an argument of type <code class="hljs">Î±</code>, which Lean should determine automatically, and that there must be a <code class="hljs">ToString</code> instance available for <code class="hljs">Î±</code>.
It returns an <code class="hljs">IO</code> action.</p>
<h2 id="checking-polymorphic-functions-types"><a class="header" href="#checking-polymorphic-functions-types">Checking Polymorphic Functions' Types</a></h2>
<p>Checking the type of a function that takes implicit arguments or uses type classes requires the use of some additional syntax.
Simply writing</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> (IO.println)
</code></pre>
<p>yields a type with metavariables:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">IO.println : ?m.3620 â IO Unit
</code></pre>
<p>This is because Lean does its best to discover implicit arguments, and the presence of metavariables indicates that it did not yet discover enough type information to do so.
To understand the signature of a function, this feature can be suppressed with an at-sign (<code class="hljs">@</code>) before the function's name:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> @IO.println
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">@IO.println : {Î± : Type u_1} â [inst : ToString Î±] â Î± â IO Unit
</code></pre>
<p>In this output, the instance itself has been given the name <code class="hljs">inst</code>.
Additionally, there is a <code class="hljs">u_1</code> after <code class="hljs">Type</code>, which uses a feature of Lean that has not yet been introduced.
For now, ignore these parameters to <code class="hljs">Type</code>.</p>
<h2 id="defining-polymorphic-functions-with-instance-implicits"><a class="header" href="#defining-polymorphic-functions-with-instance-implicits">Defining Polymorphic Functions with Instance Implicits</a></h2>
<p>A function that sums all entries in a list needs two instances: <code class="hljs">Add</code> allows the entries to be added, and an <code class="hljs">OfNat</code> instance for <code class="hljs">0</code> provides a sensible value to return for the empty list:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-params">[Add Î±]</span> <span class="hljs-params">[OfNat Î± 0]</span> <span class="hljs-symbol">:</span></span> List Î± â Î±
  | [] =&gt; <span class="hljs-number">0</span>
  | x :: xs =&gt; x + xs.sum
</code></pre>
<p>This function can be used for a list of <code class="hljs">Nat</code>s:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> List Nat := [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]

<span class="hljs-keyword">#eval</span> fourNats.sum
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">10
</code></pre>
<p>but not for a list of <code class="hljs">Pos</code> numbers:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> List Pos := [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]

<span class="hljs-keyword">#eval</span> fourPos.sum
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to synthesize instance
  OfNat Pos 0
</code></pre>
<p>Specifications of required instances in square brackets are called <em>instance implicits</em>.
Behind the scenes, every type class defines a structure that has a field for each overloaded operation.
Instances are values of that structure type, with each field containing an implementation.
At a call site, Lean is responsible for finding an instance value to pass for each instance implicit argument.
The most important difference between ordinary implicit arguments and instance implicits is the strategy that Lean uses to find an argument value.
In the case of ordinary implicit arguments, Lean uses a technique called <em>unification</em> to find a single unique argument value that would allow the program to pass the type checker.
This process relies only on the specific types involved in the function's definition and the call site.
For instance implicits, Lean instead consults a built-in table of instance values.</p>
<p>Just as the <code class="hljs">OfNat</code> instance for <code class="hljs">Pos</code> took a natural number <code class="hljs">n</code> as an automatic implicit argument, instances may also take instance implicit arguments themselves.
The <a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/polymorphism.html">section on polymorphism</a> presented a polymorphic point type:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">P</span><span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span></span> <span class="hljs-keyword">where</span>
  x : Î±
  y : Î±
<span class="hljs-keyword">deriving</span> Repr
</code></pre>
<p>Addition of points should add the underlying <code class="hljs">x</code> and <code class="hljs">y</code> fields.
Thus, an <code class="hljs">Add</code> instance for <code class="hljs">PPoint</code> requires an <code class="hljs">Add</code> instance for whatever type these fields have.
In other words, the <code class="hljs">Add</code> instance for <code class="hljs">PPoint</code> requires a further <code class="hljs">Add</code> instance for <code class="hljs">Î±</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[Add Î±]</span> <span class="hljs-symbol">:</span></span> Add (PPoint Î±) <span class="hljs-keyword">where</span>
  add p1 p2 := { x := p1.x + p2.x, y := p1.y + p2.y }
</code></pre>
<p>When Lean encounters an addition of two points, it searches for and finds this instance.
It then performs a further search for the <code class="hljs">Add Î±</code> instance.</p>
<p>The instance values that are constructed in this way are values of the type class's structure type.
A successful recursive instance search results in a structure value that has a reference to another structure value.
An instance of <code class="hljs">Add (PPoint Nat)</code> contains a reference to the instance of <code class="hljs">Add Nat</code> that was found.</p>
<p>This recursive search process means that type classes offer significantly more power than plain overloaded functions.
A library of polymorphic instances is a set of code building blocks that the compiler will assemble on its own, given nothing but the desired type.
Polymorphic functions that take instance arguments are latent requests to the type class mechanism to assemble helper functions behind the scenes.
The API's clients are freed from the burden of plumbing together all of the necessary parts by hand.</p>
<h2 id="methods-and-implicit-arguments"><a class="header" href="#methods-and-implicit-arguments">Methods and Implicit Arguments</a></h2>
<p>The type of <code class="hljs">@OfNat.ofNat</code> may be surprising.
It is <code class="hljs">{Î± : Type} â (n : Nat) â [OfNat Î± n] â Î±</code>, in which the <code class="hljs">Nat</code> argument <code class="hljs">n</code> occurs as an explicit function argument.
In the declaration of the method, however, <code class="hljs">ofNat</code> simply has type <code class="hljs">Î±</code>.
This seeming discrepancy is because declaring a type class really results in the following:</p>
<ul>
<li>A structure type to contain the implementation of each overloaded operation</li>
<li>A namespace with the same name as the class</li>
<li>For each method, a function in the class's namespace that retrieves its implementation from an instance</li>
</ul>
<p>This is analogous to the way that declaring a new structure also declares accessor functions.
The primary difference is that a structure's accessors take the structure value as an explicit argument, while the type class methods take the instance value as an instance implicit to be found automatically by Lean.</p>
<p>In order for Lean to find an instance, its arguments must be available.
This means that each argument to the type class must be an argument to the method that occurs before the instance.
It is most convenient when these arguments are implicit, because Lean does the work of discovering their values.
For example, <code class="hljs">@Add.add</code> has the type <code class="hljs">{Î± : Type} â [Add Î±] â Î± â Î± â Î±</code>.
In this case, the type argument <code class="hljs">Î±</code> can be implicit because the arguments to <code class="hljs">Add.add</code> provide information about which type the user intended.
This type can then be used to search for the <code class="hljs">Add</code> instance.</p>
<p>In the case of <code class="hljs">ofNat</code>, however, the particular <code class="hljs">Nat</code> literal to be decoded does not appear as part of any other argument.
This means that Lean would have no information to use when attempting to figure out the implicit argument <code class="hljs">n</code>.
The result would be a very inconvenient API.
Thus, in these cases, Lean uses an explicit argument for the class's method.</p>
<h2 id="exercises-6"><a class="header" href="#exercises-6">Exercises</a></h2>
<h3 id="even-number-literals"><a class="header" href="#even-number-literals">Even Number Literals</a></h3>
<p>Write an instance of <code class="hljs">OfNat</code> for the even number datatype from the <a href="https://leanprover.github.io/functional_programming_in_lean/type-classes/pos.html#even-numbers">previous section's exercises</a> that uses recursive instance search.
For the base instance, it is necessary to write <code class="hljs">OfNat Even Nat.zero</code> instead of <code class="hljs">OfNat Even 0</code>.</p>
<h3 id="recursive-instance-search-depth"><a class="header" href="#recursive-instance-search-depth">Recursive Instance Search Depth</a></h3>
<p>There is a limit to how many times the Lean compiler will attempt a recursive instance search.
This places a limit on the size of even number literals defined in the previous exercise.
Experimentally determine what the limit is.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="controlling-instance-search"><a class="header" href="#controlling-instance-search">Controlling Instance Search</a></h1>
<p>An instance of the <code class="hljs">Add</code> class is sufficient to allow two expressions with type <code class="hljs">Pos</code> to be conveniently added, producing another <code class="hljs">Pos</code>.
However, in many cases, it can be useful to be more flexible and allow <em>heterogeneous</em> operator overloading, where the arguments may have different types.
For example, adding a <code class="hljs">Nat</code> to a <code class="hljs">Pos</code> or a <code class="hljs">Pos</code> to a <code class="hljs">Nat</code> will always yield a <code class="hljs">Pos</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">d</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> Nat â Pos â Pos
  | <span class="hljs-number">0</span>, p =&gt; p
  | n + <span class="hljs-number">1</span>, p =&gt; Pos.succ (addNatPos n p)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">d</span><span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">s</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> Pos â Nat â Pos
  | p, <span class="hljs-number">0</span> =&gt; p
  | p, n + <span class="hljs-number">1</span> =&gt; Pos.succ (addPosNat p n)
</code></pre>
<p>These functions allow natural numbers to be added to positive numbers, but they cannot be used with the <code class="hljs">Add</code> type class, which expects both arguments to <code class="hljs">add</code> to have the same type.</p>
<h2 id="heterogeneous-overloadings"><a class="header" href="#heterogeneous-overloadings">Heterogeneous Overloadings</a></h2>
<p>As mentioned in the section on <a href="https://leanprover.github.io/functional_programming_in_lean/type-classes/pos.html#overloaded-addition">overloaded addition</a>, Lean provides a type class called <code class="hljs">HAdd</code> for overloading addition heterogeneously.
The <code class="hljs">HAdd</code> class takes three type parameters: the two argument types and the return type.
Instances of <code class="hljs">HAdd Nat Pos Pos</code> and <code class="hljs">HAdd Pos Nat Pos</code> allow ordinary addition notation to be used to mix the types:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> HAdd Nat Pos Pos <span class="hljs-keyword">where</span>
  hAdd := addNatPos

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> HAdd Pos Nat Pos <span class="hljs-keyword">where</span>
  hAdd := addPosNat
</code></pre>
<p>Given the above two instances, the following examples work:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (<span class="hljs-number">3</span> : Pos) + (<span class="hljs-number">5</span> : Nat)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">8
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (<span class="hljs-number">3</span> : Nat) + (<span class="hljs-number">5</span> : Pos)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">8
</code></pre>
<p>The definition of the <code class="hljs">HAdd</code> type class is very much like the following definition of <code class="hljs">HPlus</code> with the corresponding instances:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">H</span><span class="hljs-title">P</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(Î² : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(Î³ : <span class="hljs-built_in">Type</span>)</span></span> <span class="hljs-keyword">where</span>
  hPlus : Î± â Î² â Î³

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> HPlus Nat Pos Pos <span class="hljs-keyword">where</span>
  hPlus := addNatPos

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> HPlus Pos Nat Pos <span class="hljs-keyword">where</span>
  hPlus := addPosNat
</code></pre>
<p>However, instances of <code class="hljs">HPlus</code> are significantly less useful than instances of <code class="hljs">HAdd</code>.
When attempting to use these instances with <code class="hljs">#eval</code>, an error occurs:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> HPlus.hPlus (<span class="hljs-number">3</span> : Pos) (<span class="hljs-number">5</span> : Nat)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">typeclass instance problem is stuck, it is often due to metavariables
  HPlus Pos Nat ?m.7527
</code></pre>
<p>This happens because there is a metavariable in the type, and Lean has no way to solve it.</p>
<p>As discussed in <a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/polymorphism.html">the initial description of polymorphism</a>, metavariables represent unknown parts of a program that could not be inferred.
When an expression is written following <code class="hljs">#eval</code>, Lean attempts to determine its type automatically.
In this case, it could not.
Because the third type parameter for <code class="hljs">HPlus</code> was unknown, Lean couldn't carry out type class instance search, but instance search is the only way that Lean could determine the expression's type.
That is, the <code class="hljs">HPlus Pos Nat Pos</code> instance can only apply if the expression should have type <code class="hljs">Pos</code>, but there's nothing in the program other than the instance itself to indicate that it should have this type.</p>
<p>One solution to the problem is to ensure that all three types are available by adding a type annotation to the whole expression:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (HPlus.hPlus (<span class="hljs-number">3</span> : Pos) (<span class="hljs-number">5</span> : Nat) : Pos)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">8
</code></pre>
<p>However, this solution is not very convenient for users of the positive number library.</p>
<h2 id="output-parameters"><a class="header" href="#output-parameters">Output Parameters</a></h2>
<p>This problem can also be solved by declaring <code class="hljs">Î³</code> to be an <em>output parameter</em>.
Most type class parameters are inputs to the search algorithm: they are used to select an instance.
For example, in an <code class="hljs">OfNat</code> instance, both the type and the natural number are used to select a particular interpretation of a natural number literal.
However, in some cases, it can be convenient to start the search process even when some of the type parameters are not yet known, and use the instances that are discovered in the search to determine values for metavariables.
The parameters that aren't needed to start instance search are outputs of the process, which is declared with the <code class="hljs">outParam</code> modifier:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">H</span><span class="hljs-title">P</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(Î² : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(Î³ : outParam <span class="hljs-built_in">Type</span>)</span></span> <span class="hljs-keyword">where</span>
  hPlus : Î± â Î² â Î³
</code></pre>
<p>With this output parameter, type class instance search is able to select an instance without knowing <code class="hljs">Î³</code> in advance.
For instance:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> HPlus.hPlus (<span class="hljs-number">3</span> : Pos) (<span class="hljs-number">5</span> : Nat)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">8
</code></pre>
<p>It might be helpful to think of output parameters as defining a kind of function.
Any given instance of a type class that has one or more output parameters provides Lean with instructions for determining the outputs from the inputs.
The process of searching for an instance, possibly recursively, ends up being more powerful than mere overloading.
Output parameters can determine other types in the program, and instance search can assemble a collection of underlying instances into a program that has this type.</p>
<h2 id="default-instances"><a class="header" href="#default-instances">Default Instances</a></h2>
<p>Deciding whether a parameter is an input or an output controls the circumstances under which Lean will initiate type class search.
In particular, type class search does not occur until all inputs are known.
However, in some cases, output parameters are not enough, and instance search should also occur when some inputs are unknown.
This is a bit like default values for optional function arguments in Python or Kotlin, except default <em>types</em> are being selected.</p>
<p><em>Default instances</em> are instances that are available for instance search <em>even when not all their inputs are known</em>.
When one of these instances can be used, it will be used.
This can cause programs to successfully type check, rather than failing with errors related to unknown types and metavariables.
On the other hand, default instances can make instance selection less predictable.
In particular, if an undesired default instance is selected, then an expression may have a different type than expected, which can cause confusing type errors to occur elsewhere in the program.
Be selective about where default instances are used!</p>
<p>One example of where default instances can be useful is an instance of <code class="hljs">HPlus</code> that can be derived from an <code class="hljs">Add</code> instance.
In other words, ordinary addition is a special case of heterogeneous addition in which all three types happen to be the same.
This can be implemented using the following instance:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[Add Î±]</span> <span class="hljs-symbol">:</span></span> HPlus Î± Î± Î± <span class="hljs-keyword">where</span>
  hPlus := Add.add
</code></pre>
<p>With this instance, <code class="hljs">hPlus</code> can be used for any addable type, like <code class="hljs">Nat</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> HPlus.hPlus (<span class="hljs-number">3</span> : Nat) (<span class="hljs-number">5</span> : Nat)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">8
</code></pre>
<p>However, this instance will only be used in situations where the types of both arguments are known.
For example,</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> HPlus.hPlus (<span class="hljs-number">5</span> : Nat) (<span class="hljs-number">3</span> : Nat)
</code></pre>
<p>yields the type</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">HPlus.hPlus 5 3 : Nat
</code></pre>
<p>as expected, but</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> HPlus.hPlus (<span class="hljs-number">5</span> : Nat)
</code></pre>
<p>yields a type that contains two metavariables, one for the remaining argument and one for the return type:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">HPlus.hPlus 5 : ?m.7706 â ?m.7708
</code></pre>
<p>In the vast majority of cases, when someone supplies one argument to addition, the other argument will have the same type.
To make this instance into a default instance, apply the <code class="hljs">default_instance</code> attribute:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-meta">@[default_instance]</span>
<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[Add Î±]</span> <span class="hljs-symbol">:</span></span> HPlus Î± Î± Î± <span class="hljs-keyword">where</span>
  hPlus := Add.add
</code></pre>
<p>With this default instance, the example has a more useful type:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> HPlus.hPlus (<span class="hljs-number">5</span> : Nat)
</code></pre>
<p>yields</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">HPlus.hPlus 5 : Nat â Nat
</code></pre>
<p>Each operator that exists in overloadable heterogeneous and homogeneous versions follows the pattern of a default instance that allows the homogeneous version to be used in contexts where the heterogeneous is expected.
The infix operator is replaced with a call to the heterogeneous version, and the homogeneous default instance is selected when possible.</p>
<p>Similarly, simply writing <code class="hljs">5</code> gives a <code class="hljs">Nat</code> rather than a type with a metavariable that is waiting for more information in order to select an <code class="hljs">OfNat</code> instance.
This is because the <code class="hljs">OfNat</code> instance for <code class="hljs">Nat</code> is a default instance.</p>
<p>Default instances can also be assigned <em>priorities</em> that affect which will be chosen in situations where more than one might apply.
For more information on default instance priorities, please consult the Lean manual.</p>
<h2 id="exercises-7"><a class="header" href="#exercises-7">Exercises</a></h2>
<p>Define an instance of <code class="hljs">HMul (PPoint Î±) Î± (PPoint Î±)</code> that multiplies both projections by the scalar.
It should work for any type <code class="hljs">Î±</code> for which there is a <code class="hljs">Mul Î±</code> instance.
For example,</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> {x := <span class="hljs-number">2.5</span>, y := <span class="hljs-number">3.7</span> : PPoint Float} * <span class="hljs-number">2.0</span>
</code></pre>
<p>should yield</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">{ x := 5.000000, y := 7.400000 }
</code></pre>
<div style="break-before:page;page-break-before:always"></div><h1 id="arrays-and-indexing"><a class="header" href="#arrays-and-indexing">Arrays and Indexing</a></h1>
<p>The <a href="https://leanprover.github.io/functional_programming_in_lean/props-proofs-indexing.html">Interlude</a> describes how to use indexing notation in order to look up entries in a list by their position.
This syntax is also governed by a type class, and it can be used for a variety of different types.</p>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>For instance, Lean arrays are much more efficient than linked lists for most purposes.
In Lean, the type <code class="hljs">Array Î±</code> is a dynamically-sized array holding values of type <code class="hljs">Î±</code>, much like a Java <code class="hljs">ArrayList</code>, a C++ <code class="hljs">std::vector</code>, or a Rust <code class="hljs">Vec</code>.
Unlike <code class="hljs">List</code>, which has a pointer indirection on each use of the <code class="hljs">cons</code> constructor, arrays occupy a contiguous region of memory, which is much better for processor caches.
Also, looking up a value in an array takes constant time, while lookup in a linked list takes time proportional to the index being accessed.</p>
<p>In pure functional languages like Lean, it is not possible to mutate a given position in a data structure.
Instead, a copy is made that has the desired modifications.
When using an array, the Lean compiler and runtime contain an optimization that can allow modifications to be implemented as mutations behind the scenes when there is only a single unique reference to an array.</p>
<p>Arrays are written similarly to lists, but with a leading <code class="hljs">#</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">n</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> Array String :=
  #[<span class="hljs-string">"sloe"</span>, <span class="hljs-string">"birch"</span>, <span class="hljs-string">"elm"</span>, <span class="hljs-string">"oak"</span>]
</code></pre>
<p>The number of values in an array can be found using <code class="hljs">Array.size</code>.
For instance, <code class="hljs">northernTrees.size</code> evaluates to <code class="hljs">4</code>.
For indices that are smaller than an array's size, indexing notation can be used to find the corresponding value, just as with lists.
That is, <code class="hljs">northernTrees[2]</code> evaluates to <code class="hljs">"elm"</code>.
Similarly, the compiler requires a proof that an index is in bounds, and attempting to look up a value outside the bounds of the array results in a compile-time error, just as with lists.
For instance, <code class="hljs">northernTrees[8]</code> results in:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to prove index is valid, possible solutions:
  - Use `have`-expressions to prove the index is valid
  - Use `a[i]!` notation instead, runtime check is perfomed, and 'Panic' error message is produced if index is not valid
  - Use `a[i]?` notation instead, result is an `Option` type
  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid
â¢ 8 &lt; Array.size northernTrees
</code></pre>
<h2 id="non-empty-lists"><a class="header" href="#non-empty-lists">Non-Empty Lists</a></h2>
<p>A datatype that represents non-empty lists can be defined as a structure with a field for the head of the list and a field for the tail, which is an ordinary, potentially empty list:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">N</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">E</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">y</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  head : Î±
  tail : List Î±
</code></pre>
<p>For example, the non-empty list <code class="hljs">idahoSpiders</code> (which contains some spider species native to the US state of Idaho) consists of <code class="hljs">"Banded Garden Spider"</code> followed by four other spiders, for a total of five spiders:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">d</span><span class="hljs-title">a</span><span class="hljs-title">h</span><span class="hljs-title">o</span><span class="hljs-title">S</span><span class="hljs-title">p</span><span class="hljs-title">i</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> NonEmptyList String := {
  head := <span class="hljs-string">"Banded Garden Spider"</span>,
  tail := [
    <span class="hljs-string">"Long-legged Sac Spider"</span>,
    <span class="hljs-string">"Wolf Spider"</span>,
    <span class="hljs-string">"Hobo Spider"</span>,
    <span class="hljs-string">"Cat-faced Spider"</span>
  ]
}
</code></pre>
<p>Looking up the value at a specific index in this list with a recursive function should consider three possibilities:</p>
<ol>
<li>The index is <code class="hljs">0</code>, in which case the head of the list should be returned.</li>
<li>The index is <code class="hljs">n + 1</code> and the tail is empty, in which case the index is out of bounds.</li>
<li>The index is <code class="hljs">n + 1</code> and the tail is non-empty, in which case the function can be called recursively on the tail and <code class="hljs">n</code>.</li>
</ol>
<p>For example, a lookup function that returns an <code class="hljs">Option</code> can be written as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">N</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">E</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">y</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">t?</span> <span class="hljs-symbol">:</span></span> NonEmptyList Î± â Nat â Option Î±
  | xs, <span class="hljs-number">0</span> =&gt; some xs.head
  | {head := _, tail := []}, _ + <span class="hljs-number">1</span> =&gt; none
  | {head := _, tail := h :: t}, n + <span class="hljs-number">1</span> =&gt; get? {head := h, tail := t} n
</code></pre>
<p>Each case in the pattern match corresponds to one of the possibilities above.
The recursive call to <code class="hljs">get?</code> does not require a <code class="hljs">NonEmptyList</code> namespace qualifier because the body of the definition is implicitly in the definition's namespace.
Another way to write this function uses <code class="hljs">get?</code> for lists when the index is greater than zero:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">N</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">E</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">y</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">t?</span> <span class="hljs-symbol">:</span></span> NonEmptyList Î± â Nat â Option Î±
  | xs, <span class="hljs-number">0</span> =&gt; some xs.head
  | xs, n + <span class="hljs-number">1</span> =&gt; xs.tail.get? n
</code></pre>
<p>If the list contains one entry, then only <code class="hljs">0</code> is a valid index.
If it contains two entries, then both <code class="hljs">0</code> and <code class="hljs">1</code> are valid indices.
If it contains three entries, then <code class="hljs">0</code>, <code class="hljs">1</code>, and <code class="hljs">2</code> are valid indices.
In other words, the valid indices into a non-empty list are natural numbers that are strictly less than the length of the list, which are less than or equal to the length of the tail.</p>
<p>The definition of what it means for an index to be in bounds should be written as an <code class="hljs">abbrev</code> because the tactics used to find evidence that indices are acceptable are able to solve inequalities of numbers, but they don't know anything about the name <code class="hljs">NonEmptyList.inBounds</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">abbrev</span> NonEmptyList.inBounds (xs : NonEmptyList Î±) (i : Nat) : <span class="hljs-built_in">Prop</span> :=
  i â¤ xs.tail.length
</code></pre>
<p>This function returns a proposition that might be true or false.
For instance, <code class="hljs">2</code> is in bounds for <code class="hljs">idahoSpiders</code>, while <code class="hljs">5</code> is not:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">S</span><span class="hljs-title">p</span><span class="hljs-title">i</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> idahoSpiders.inBounds <span class="hljs-number">2</span> := <span class="hljs-keyword">by</span> <span class="hljs-keyword">simp</span>

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">t</span><span class="hljs-title">S</span><span class="hljs-title">i</span><span class="hljs-title">x</span><span class="hljs-title">S</span><span class="hljs-title">p</span><span class="hljs-title">i</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> Â¬idahoSpiders.inBounds <span class="hljs-number">5</span> := <span class="hljs-keyword">by</span> <span class="hljs-keyword">simp</span>
</code></pre>
<p>The logical negation operator has a very low precedence, which means that <code class="hljs">Â¬idahoSpiders.inBounds 5</code> is equivalent to <code class="hljs">Â¬(idahoSpiders.inBounds 5)</code>.</p>
<p>This fact can be used to write a lookup function that requires evidence that the index is valid, and thus need not return <code class="hljs">Option</code>, by delegating to the version for lists that checks the evidence at compile time:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">N</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">E</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">y</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">t</span> <span class="hljs-params">(xs : NonEmptyList Î±)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-params">(ok : xs.inBounds i)</span> <span class="hljs-symbol">:</span></span> Î± :=
  <span class="hljs-keyword">match</span> i <span class="hljs-keyword">with</span>
  | <span class="hljs-number">0</span> =&gt; xs.head
  | n + <span class="hljs-number">1</span> =&gt; xs.tail[n]
</code></pre>
<p>It is, of course, possible to write this function to use the evidence directly, rather than delegating to a standard library function that happens to be able to use the same evidence.
This requires techniques for working with proofs and propositions that are described later in this book.</p>
<h2 id="overloading-indexing"><a class="header" href="#overloading-indexing">Overloading Indexing</a></h2>
<p>Indexing notation for a collection type can be overloaded by defining an instance of the <code class="hljs">GetElem</code> type class.
For the sake of flexiblity, <code class="hljs">GetElem</code> has four parameters:</p>
<ul>
<li>The type of the collection</li>
<li>The type of the index</li>
<li>The type of elements that are extracted from the collection</li>
<li>A function that determines what counts as evidence that the index is in bounds</li>
</ul>
<p>The element type and the evidence function are both output parameters.
<code class="hljs">GetElem</code> has a single method, <code class="hljs">getElem</code>, which takes a collection value, an index value, and evidence that the index is in bounds as arguments, and returns an element:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">G</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">E</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">m</span> <span class="hljs-params">(coll : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(idx : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(item : outParam <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(inBounds : outParam (coll â idx â <span class="hljs-built_in">Prop</span>)</span>)</span> <span class="hljs-keyword">where</span>
  getElem : (c : coll) â (i : idx) â inBounds c i â item
</code></pre>
<p>In the case of <code class="hljs">NonEmptyList Î±</code>, these parameters are:</p>
<ul>
<li>The collection is <code class="hljs">NonEmptyList Î±</code></li>
<li>Indices have type <code class="hljs">Nat</code></li>
<li>The type of elements is <code class="hljs">Î±</code></li>
<li>An index is in bounds if it is less than or equal to the length of the tail</li>
</ul>
<p>In fact, the <code class="hljs">GetElem</code> instance can delegate directly to <code class="hljs">NonEmptyList.get</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> GetElem (NonEmptyList Î±) Nat Î± NonEmptyList.inBounds <span class="hljs-keyword">where</span>
  getElem := NonEmptyList.get
</code></pre>
<p>With this instance, <code class="hljs">NonEmptyList</code> becomes just as convenient to use as <code class="hljs">List</code>.
Evaluating <code class="hljs">idahoSpiders[0]</code> yields <code class="hljs">"Banded Garden Spider"</code>, while <code class="hljs">idahoSpiders[9]</code> leads to the compile-time error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to prove index is valid, possible solutions:
  - Use `have`-expressions to prove the index is valid
  - Use `a[i]!` notation instead, runtime check is perfomed, and 'Panic' error message is produced if index is not valid
  - Use `a[i]?` notation instead, result is an `Option` type
  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid
â¢ NonEmptyList.inBounds idahoSpiders 9
</code></pre>
<p>Because both the collection type and the index type are input parameters to the <code class="hljs">GetElem</code> type class, new types can be used to index into existing collections.
The positive number type <code class="hljs">Pos</code> is a perfectly reasonable index into a <code class="hljs">List</code>, with the caveat that it cannot point at the first entry.
The follow instance of <code class="hljs">GetElem</code> allows <code class="hljs">Pos</code> to be used just as conveniently as <code class="hljs">Nat</code> to find a list entry:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> GetElem (List Î±) Pos Î± (<span class="hljs-keyword">fun</span> list n =&gt; list.length &gt; n.toNat) <span class="hljs-keyword">where</span>
  getElem (xs : List Î±) (i : Pos) ok := xs[i.toNat]
</code></pre>
<p>Indexing can also make sense for non-numeric indices.
For example, <code class="hljs">Bool</code> can be used to select between the fields in a point, with <code class="hljs">false</code> corresponding to <code class="hljs">x</code> and <code class="hljs">true</code> corresponding to <code class="hljs">y</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> GetElem (PPoint Î±) Bool Î± (<span class="hljs-keyword">fun</span> _ _ =&gt; True) <span class="hljs-keyword">where</span>
  getElem (p : PPoint Î±) (i : Bool) _ :=
    <span class="hljs-keyword">if</span> not i <span class="hljs-keyword">then</span> p.x <span class="hljs-keyword">else</span> p.y
</code></pre>
<p>In this case, both Booleans are valid indices.
Because every possible <code class="hljs">Bool</code> is in bounds, the evidence is simply the true proposition <code class="hljs">True</code>.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="standard-classes"><a class="header" href="#standard-classes">Standard Classes</a></h1>
<p>This section presents a variety of operators and functions that can be overloaded using type classes in Lean.
Each operator or function corresponds to a method of a type class.
Unlike C++, infix operators in Lean are defined as abbreviations for named functions; this means that overloading them for new types is not done using the operator itself, but rather using the underlying name (such as <code class="hljs">HAdd.hAdd</code>).</p>
<h2 id="arithmetic"><a class="header" href="#arithmetic">Arithmetic</a></h2>
<p>Most arithmetic operators are available in a heterogeneous form, where the arguments may have different type and an output parameter decides the type of the resulting expression.
For each heterogeneous operator, there is a corresponding homogeneous version that can found by removing the letter <code class="hljs">h</code>, so that <code class="hljs">HAdd.hAdd</code> becomes <code class="hljs">Add.add</code>.
The following arithmetic operators are overloaded:</p>
<table><thead><tr><th>Expression</th><th>Desugaring</th><th>Class Name</th></tr></thead><tbody>
<tr><td><code class="hljs">x + y</code></td><td><code class="hljs">HAdd.hAdd x y</code></td><td><code class="hljs">HAdd</code></td></tr>
<tr><td><code class="hljs">x - y</code></td><td><code class="hljs">HSub.hSub x y</code></td><td><code class="hljs">HSub</code></td></tr>
<tr><td><code class="hljs">x * y</code></td><td><code class="hljs">HMul.hMul x y</code></td><td><code class="hljs">HMul</code></td></tr>
<tr><td><code class="hljs">x / y</code></td><td><code class="hljs">HDiv.hDiv x y</code></td><td><code class="hljs">HDiv</code></td></tr>
<tr><td><code class="hljs">x % y</code></td><td><code class="hljs">HMod.hMod x y</code></td><td><code class="hljs">HMod</code></td></tr>
<tr><td><code class="hljs">x ^ y</code></td><td><code class="hljs">HPow.hPow x y</code></td><td><code class="hljs">HPow</code></td></tr>
<tr><td><code class="hljs">(- x)</code></td><td><code class="hljs">Neg.neg x</code></td><td><code class="hljs">Neg</code></td></tr>
</tbody></table>
<h2 id="bitwise-operators"><a class="header" href="#bitwise-operators">Bitwise Operators</a></h2>
<p>Lean contains a number of standard bitwise operators that are overloaded using type classes.
There are instances for fixed-width types such as <code class="hljs">UInt8</code>, <code class="hljs">UInt16</code>, <code class="hljs">UInt32</code>, <code class="hljs">UInt64</code>, and <code class="hljs">USize</code>.
The latter is the size of words on the current platform, typically 32 or 64 bits.
The following bitwise operators are overloaded:</p>
<table><thead><tr><th>Expression</th><th>Desugaring</th><th>Class Name</th></tr></thead><tbody>
<tr><td><code class="hljs">x &amp;&amp;&amp; y</code></td><td><code class="hljs">HAnd.hAnd x y</code></td><td><code class="hljs">HAnd</code></td></tr>
<tr><td><code class="hljs">x ||| y </code></td><td><code class="hljs">HOr.hOr x y</code></td><td><code class="hljs">HOr</code></td></tr>
<tr><td><code class="hljs">x ^^^ y</code></td><td><code class="hljs">HXor.hXor x y</code></td><td><code class="hljs">HXor</code></td></tr>
<tr><td><code class="hljs">~~~ x</code></td><td><code class="hljs">Complement.complement x</code></td><td><code class="hljs">Complement</code></td></tr>
<tr><td><code class="hljs">x &gt;&gt;&gt; y</code></td><td><code class="hljs">HShiftRight.hShiftRight x y</code></td><td><code class="hljs">HShiftRight</code></td></tr>
<tr><td><code class="hljs">x &lt;&lt;&lt; y</code></td><td><code class="hljs">HShiftLeft.hShiftLeft x y</code></td><td><code class="hljs">HShiftLeft</code></td></tr>
</tbody></table>
<p>Because the names <code class="hljs">And</code> and <code class="hljs">Or</code> are already taken as the names of logical connectives, the homogeneous versions of <code class="hljs">HAnd</code> and <code class="hljs">HOr</code> are called <code class="hljs">AndOp</code> and <code class="hljs">OrOp</code> rather than <code class="hljs">And</code> and <code class="hljs">Or</code>.</p>
<h2 id="equality-and-ordering"><a class="header" href="#equality-and-ordering">Equality and Ordering</a></h2>
<p>Testing equality of two values typically uses the <code class="hljs">BEq</code> class, which is short for "Boolean equality".
Due to Lean's use as a theorem prover, there are really two kinds of equality operators in Lean:</p>
<ul>
<li><em>Boolean equality</em> is the same kind of equality that is found in other programming languages. It is a function that takes two values and returns a <code class="hljs">Bool</code>. Boolean equality is written with two equals signs, just as in Python and C#. Because Lean is a pure functional language, there's no separate notions of reference vs value equalityâpointers cannot be observed directly.</li>
<li><em>Propositional equality</em> is the mathematical statement that two things are equal. Propositional equality is not a function; rather, it is a mathematical statement that admits proof. It is written with a single equals sign. A statement of propositional equality is like a type that classifies evidence of this equality.</li>
</ul>
<p>Both notions of equality are important, and used for different purposes.
Boolean equality is useful in programs, when a decision needs to be made about whether two values are equal.
For example, <code class="hljs">"Octopus" ==  "Cuttlefish"</code> evaluates to <code class="hljs">false</code>, and <code class="hljs">"Octopodes" ==  "Octo".append "podes"</code> evaluates to <code class="hljs">true</code>.
Some values, such as functions, cannot be checked for equality.
For example, <code class="hljs">(fun (x : Nat) =&gt; 1 + x) == (Nat.succ Â·)</code> yields the error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to synthesize instance
  BEq (Nat â Nat)
</code></pre>
<p>As this message indicates, <code class="hljs">==</code> is overloaded using a type class.
The expression <code class="hljs">x == y</code> is actually shorthand for <code class="hljs">BEq.beq x y</code>.</p>
<p>Propositional equality is a mathematical statement rather than an invocation of a program.
Because propositions are like types that describe evidence for some statement, propositional equality has more in common with types like <code class="hljs">String</code> and <code class="hljs">Nat â List Int</code> than it does with Boolean equality.
This means that it can't automatically be checked.
However, the equality of any two expressions can be stated in Lean, so long as they have the same type.
The statement <code class="hljs">(fun (x : Nat) =&gt; 1 + x) = (Nat.succ Â·)</code> is a perfectly reasonable statement.
From the perspective of mathematics, two functions are equal if they map equal inputs to equal outputs, so this statement is even true, though it requires a two-line proof to convince Lean of this fact.</p>
<p>Generally speaking, when using Lean as a programming language, it's easiest to stick to Boolean functions rather than propositions.
However, as the names <code class="hljs">true</code> and <code class="hljs">false</code> for <code class="hljs">Bool</code>'s constructors suggest, this difference is sometimes blurred.
Some propositions are <em>decidable</em>, which means that they can be checked just like a Boolean function.
The function that checks whether the proposition is true or false is called a <em>decision procedure</em>, and it returns <em>evidence</em> of the truth or falsity of the proposition.
Some examples of decidable propositions include equality and inequality of natural numbers, equality of strings, and "ands" and "ors" of propositions that are themselves decidable.</p>
<p>In Lean, <code class="hljs">if</code> works with decidable propositions.
For example, <code class="hljs">2 &lt; 4</code> is a proposition:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-number">2</span> &lt; <span class="hljs-number">4</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">2 &lt; 4 : Prop
</code></pre>
<p>Nonetheless, it is perfectly acceptable to write it as the condition in an <code class="hljs">if</code>.
For example, <code class="hljs">if 2 &lt; 4 then 1 else 2</code> has type <code class="hljs">Nat</code> and evaluates to <code class="hljs">1</code>.</p>
<p>Not all propositions are decidable.
If they were, then computers would be able to prove any true proposition just by running the decision procedure, and mathematicians would be out of a job.
More specifically, decidable propositions have an instance of the <code class="hljs">Decidable</code> type class which has a method that is the decision procedure.
Trying to use a proposition that isn't decidable as if it were a <code class="hljs">Bool</code> results in a failure to find the <code class="hljs">Decidable</code> instance.
For example, <code class="hljs">if (fun (x : Nat) =&gt; 1 + x) = (Nat.succ Â·) then "yes" else "no"</code> results in:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to synthesize instance
  Decidable ((fun x =&gt; 1 + x) = fun x =&gt; Nat.succ x)
</code></pre>
<p>The following propositions, that are usually decidable, are overloaded with type classes:</p>
<table><thead><tr><th>Expression</th><th>Desugaring</th><th>Class Name</th></tr></thead><tbody>
<tr><td><code class="hljs">x &lt; y</code></td><td><code class="hljs">LT.lt x y</code></td><td><code class="hljs">LT</code></td></tr>
<tr><td><code class="hljs">x â¤ y</code></td><td><code class="hljs">LE.le x y</code></td><td><code class="hljs">LE</code></td></tr>
<tr><td><code class="hljs">x &gt; y</code></td><td><code class="hljs">LT.lt y x</code></td><td><code class="hljs">LT</code></td></tr>
<tr><td><code class="hljs">x â¥ y</code></td><td><code class="hljs">LE.le y x</code></td><td><code class="hljs">LE</code></td></tr>
</tbody></table>
<p>Because defining new propositions hasn't yet been demonstrated, it may be difficult to define new instances of <code class="hljs">LT</code> and <code class="hljs">LE</code>.</p>
<p>Additionally, comparing values using <code class="hljs">&lt;</code>, <code class="hljs">==</code>, and <code class="hljs">&gt;</code> can be inefficient.
Checking first whether one value is less than another, and then whether they are equal, can require two traversals over large data structures.
To solve this problem, Java and C# have standard <code class="hljs">compareTo</code> and <code class="hljs">CompareTo</code> methods (respectively) that can be overridden by a class in order to implement all three operations at the same time.
These methods return a negative integer if the receiver is less than the argument, zero if they are equal, and a positive integer if the receiver is greater than the argument.
Rather than overload the meaning of integers, Lean has a built-in inductive type that describes these three possibilities:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Ordering <span class="hljs-keyword">where</span>
| lt
| eq
| gt
</code></pre>
<p>The <code class="hljs">Ord</code> type class can be overloaded to produce these comparisons.
For <code class="hljs">Pos</code>, an implementation can be:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">s</span>.<span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">p</span> <span class="hljs-symbol">:</span></span> Pos â Pos â Ordering
  | Pos.one, Pos.one =&gt; Ordering.eq
  | Pos.one, Pos.succ _ =&gt; Ordering.lt
  | Pos.succ _, Pos.one =&gt; Ordering.gt
  | Pos.succ n, Pos.succ k =&gt; comp n k

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Ord Pos <span class="hljs-keyword">where</span>
  compare := Pos.comp
</code></pre>
<p>In situations where <code class="hljs">compareTo</code> would be the right approach in Java, use <code class="hljs">Ord.compare</code> in Lean.</p>
<h2 id="hashing"><a class="header" href="#hashing">Hashing</a></h2>
<p>Java and C# have <code class="hljs">hashCode</code> and <code class="hljs">GetHashCode</code> methods, respectively, that compute a hash of a value for use in data structures such as hash tables.
The Lean equivalent is a type class called <code class="hljs">Hashable</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">H</span><span class="hljs-title">a</span><span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span></span> <span class="hljs-keyword">where</span>
  hash : Î± â UInt64
</code></pre>
<p>If two values are considered equal according to a <code class="hljs">BEq</code> instance for their type, then they should have the same hashes.
In other words, if <code class="hljs">x == y</code> then <code class="hljs">hash x == hash y</code>.
If <code class="hljs">x â  y</code>, then <code class="hljs">hash x</code> won't necessarily differ from <code class="hljs">hash y</code> (after all, there are infinitely more <code class="hljs">Nat</code> values than there are <code class="hljs">UInt64</code> values), but data structures built on hashing will have better performance if unequal values are likely to have unequal hashes.
This is the same expectation as in Java and C#.</p>
<p>The standard library contains a function <code class="hljs">mixHash</code> with type <code class="hljs">UInt64 â UInt64 â UInt64</code> that can be used to combine hashes for different fields for a constructor.
A reasonable hash function for an inductive datatype can be written by assigning a unique number to each constructor, and then mixing that number with the hashes of each field.
For example, a <code class="hljs">Hashable</code> instance for <code class="hljs">Pos</code> can be written:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> Pos â UInt64
  | Pos.one =&gt; <span class="hljs-number">0</span>
  | Pos.succ n =&gt; mixHash <span class="hljs-number">1</span> (hashPos n)

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Hashable Pos <span class="hljs-keyword">where</span>
  hash := hashPos
</code></pre>
<p><code class="hljs">Hashable</code> instances for polymorphic types can use recursive instance search.
Hashing a <code class="hljs">NonEmptyList Î±</code> is only possible when <code class="hljs">Î±</code> can be hashed:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[Hashable Î±]</span> <span class="hljs-symbol">:</span></span> Hashable (NonEmptyList Î±) <span class="hljs-keyword">where</span>
  hash xs := mixHash (hash xs.head) (hash xs.tail)
</code></pre>
<p>Binary trees use both recursion and recursive instance search in the implementations of <code class="hljs">BEq</code> and <code class="hljs">Hashable</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> BinTree (Î± : <span class="hljs-built_in">Type</span>) <span class="hljs-keyword">where</span>
  | leaf : BinTree Î±
  | branch : BinTree Î± â Î± â BinTree Î± â BinTree Î±

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">B</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span> <span class="hljs-params">[BEq Î±]</span> <span class="hljs-symbol">:</span></span> BinTree Î± â BinTree Î± â Bool
  | BinTree.leaf, BinTree.leaf =&gt;
    true
  | BinTree.branch l x r, BinTree.branch l2 x2 r2 =&gt;
    x == x2 &amp;&amp; eqBinTree l l2 &amp;&amp; eqBinTree r r2
  | _, _ =&gt;
    false

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[BEq Î±]</span> <span class="hljs-symbol">:</span></span> BEq (BinTree Î±) <span class="hljs-keyword">where</span>
  beq := eqBinTree

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">B</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span> <span class="hljs-params">[Hashable Î±]</span> <span class="hljs-symbol">:</span></span> BinTree Î± â UInt64
  | BinTree.leaf =&gt;
    <span class="hljs-number">0</span>
  | BinTree.branch left x right =&gt;
    mixHash <span class="hljs-number">1</span> (mixHash (hashBinTree left) (mixHash (hash x) (hashBinTree right)))

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[Hashable Î±]</span> <span class="hljs-symbol">:</span></span> Hashable (BinTree Î±) <span class="hljs-keyword">where</span>
  hash := hashBinTree
</code></pre>
<h2 id="deriving-standard-classes"><a class="header" href="#deriving-standard-classes">Deriving Standard Classes</a></h2>
<p>Instance of classes like <code class="hljs">BEq</code> and <code class="hljs">Hashable</code> are often quite tedious to implement by hand.
Lean includes a feature called <em>instance deriving</em> that allows the compiler to automatically construct well-behaved instances of many type classes.
In fact, the <code class="hljs">deriving Repr</code> phrase in the definition of <code class="hljs">Point</code> in the <a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/structures.html">section on structures</a> is an example of instance deriving.</p>
<p>Instances can be derived in two ways.
The first can be used when defining a structure or inductive type.
In this case, add <code class="hljs">deriving</code> to the end of the type declaration followed by the names of the classes for which instances should be derived.
For a type that is already defined, a standalone <code class="hljs">deriving</code> command can be used.
Write <code class="hljs">deriving instance C1, C2, ... for T</code> to derive instances of <code class="hljs">C1, C2, ...</code> for the type <code class="hljs">T</code> after the fact.</p>
<p><code class="hljs">BEq</code> and <code class="hljs">Hashable</code> instances can be derived for <code class="hljs">Pos</code> and <code class="hljs">NonEmptyList</code> using a very small amount of code:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">deriving</span> <span class="hljs-keyword">instance</span> BEq, Hashable <span class="hljs-keyword">for</span> Pos
<span class="hljs-keyword">deriving</span> <span class="hljs-keyword">instance</span> BEq, Hashable, Repr <span class="hljs-keyword">for</span> NonEmptyList
</code></pre>
<p>Instances can be derived for at least the following classes:</p>
<ul>
<li><code class="hljs">Inhabited</code></li>
<li><code class="hljs">BEq</code></li>
<li><code class="hljs">Repr</code></li>
<li><code class="hljs">Hashable</code></li>
<li><code class="hljs">Ord</code></li>
</ul>
<p>In some cases, however, the derived <code class="hljs">Ord</code> instance may not produce precisely the ordering desired in an application.
When this is the case, it's fine to write an <code class="hljs">Ord</code> instance by hand.
The collection of classes for which instances can be derived can be extended by advanced users of Lean.</p>
<p>Aside from the clear advantages in programmer productivity and code readability, deriving instances also makes code easier to maintain, because the instances are updated as the definitions of types evolve.
Changesets involving updates to datatypes are easier to read without line after line of formulaic modifications to equality tests and hash computation.</p>
<h2 id="appending"><a class="header" href="#appending">Appending</a></h2>
<p>Many datatypes have some sort of append operator.
In Lean, appending two values is overloaded with the type class <code class="hljs">HAppend</code>, which is a heterogeneous operation like that used for arithmetic operations:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">H</span><span class="hljs-title">A</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(Î² : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(Î³ : outParam <span class="hljs-built_in">Type</span>)</span></span> <span class="hljs-keyword">where</span>
  hAppend : Î± â Î² â Î³
</code></pre>
<p>The syntax <code class="hljs">xs ++ ys</code> desugars to <code class="hljs">HAppend.hAppend xs ys</code>.
For homogeneous cases, it's enough to implement an instance of <code class="hljs">Append</code>, which follows the usual pattern:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Append (NonEmptyList Î±) <span class="hljs-keyword">where</span>
  append xs ys :=
    { head := xs.head, tail := xs.tail ++ ys.head :: ys.tail }
</code></pre>
<p>After defining the above instance,</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> idahoSpiders ++ idahoSpiders
</code></pre>
<p>has the following output:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">{ head := "Banded Garden Spider",
tail := ["Long-legged Sac Spider",
         "Wolf Spider",
         "Hobo Spider",
         "Cat-faced Spider",
         "Banded Garden Spider",
         "Long-legged Sac Spider",
         "Wolf Spider",
         "Hobo Spider",
         "Cat-faced Spider"] }
</code></pre>
<p>Similarly, a definition of <code class="hljs">HAppend</code> allows non-empty lists to be appended to ordinary lists:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> HAppend (NonEmptyList Î±) (List Î±) (NonEmptyList Î±) <span class="hljs-keyword">where</span>
  hAppend xs ys :=
    { head := xs.head, tail := xs.tail ++ ys }
</code></pre>
<p>With this instance available,</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> idahoSpiders ++ [<span class="hljs-string">"Trapdoor Spider"</span>]
</code></pre>
<p>results in</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">{ head := "Banded Garden Spider",
  tail := ["Long-legged Sac Spider", "Wolf Spider", "Hobo Spider", "Cat-faced Spider", "Trapdoor Spider"] }
</code></pre>
<h2 id="functors"><a class="header" href="#functors">Functors</a></h2>
<p>A polymorphic type is a <em>functor</em> if it has an overload for a function named <code class="hljs">map</code> that transforms every element contained in it by a function.
While most languages use this terminology, C#'s equivalent to <code class="hljs">map</code> is called <code class="hljs">System.Linq.Enumerable.Select</code>.
For example, mapping a function over a list constructs a new list in which each entry from the starting list has been replaced by the result of the function on that entry.
Mapping a function <code class="hljs">f</code> over an <code class="hljs">Option</code> leaves <code class="hljs">none</code> untouched, and replaces <code class="hljs">some x</code> with <code class="hljs">some (f x)</code>.</p>
<p>Here are some examples of functors and how their <code class="hljs">Functor</code> instances overload <code class="hljs">map</code>:</p>
<ul>
<li><code class="hljs">Functor.map (Â· + 5) [1, 2, 3]</code> evaluates to <code class="hljs">[6, 7, 8]</code></li>
<li><code class="hljs">Functor.map toString (some (List.cons 5 List.nil))</code> evaluates to <code class="hljs">some "[5]"</code></li>
<li><code class="hljs">Functor.map List.reverse [[1, 2, 3], [4, 5, 6]]</code> evaluates to <code class="hljs">[[3, 2, 1], [6, 5, 4]]</code></li>
</ul>
<p>Because <code class="hljs">Functor.map</code> is a bit of a long name for this common operation, Lean also provides an infix operator for mapping a function, namely <code class="hljs">&lt;$&gt;</code>.
The prior examples can be rewritten as follows:</p>
<ul>
<li><code class="hljs">(Â· + 5) &lt;$&gt; [1, 2, 3]</code> evaluates to <code class="hljs">[6, 7, 8]</code></li>
<li><code class="hljs">toString &lt;$&gt; (some (List.cons 5 List.nil))</code> evaluates to <code class="hljs">some "[5]"</code></li>
<li><code class="hljs">List.reverse &lt;$&gt; [[1, 2, 3], [4, 5, 6]]</code> evaluates to <code class="hljs">[[3, 2, 1], [6, 5, 4]]</code></li>
</ul>
<p>An instance of <code class="hljs">Functor</code> for <code class="hljs">NonEmptyList</code> requires specifying the <code class="hljs">map</code> function.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Functor NonEmptyList <span class="hljs-keyword">where</span>
  map f xs := { head := f xs.head, tail := f &lt;$&gt; xs.tail }
</code></pre>
<p>Here, <code class="hljs">map</code> uses the <code class="hljs">Functor</code> instance for <code class="hljs">List</code> to map the function over the tail.
This instance is defined for <code class="hljs">NonEmptyList</code> rather than for <code class="hljs">NonEmptyList Î±</code> because the argument type <code class="hljs">Î±</code> plays no role in resolving the type class.
A <code class="hljs">NonEmptyList</code> can have a function mapped over it <em>no matter what the type of entries is</em>.
If <code class="hljs">Î±</code> were a parameter to the class, then it would be possible to make versions of <code class="hljs">Functor</code> that only worked for <code class="hljs">NonEmptyList Nat</code>, but part of being a functor is that <code class="hljs">map</code> works for any entry type.</p>
<p>Here is an instance of <code class="hljs">Functor</code> for <code class="hljs">PPoint</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Functor PPoint <span class="hljs-keyword">where</span>
  map f p := { x := f p.x, y := f p.y }
</code></pre>
<p>In this case, <code class="hljs">f</code> has been applied to both <code class="hljs">x</code> and <code class="hljs">y</code>.</p>
<p>Even when the type contained in a functor is itself a functor, mapping a function only goes down one layer.
That is, when using <code class="hljs">map</code> on a <code class="hljs">NonEmptyList (PPoint Nat)</code>, the function being mapped should take <code class="hljs">PPoint Nat</code> as its argument rather than <code class="hljs">Nat</code>.</p>
<p>The definition of the <code class="hljs">Functor</code> class uses one more language feature that has not yet been discussed: default method definitions.
Normally, a class will specify some minimal set of overloadable operations that make sense together, and then use polymorphic functions with instance implicit arguments that build on the overloaded operations to provide a larger library of features.
For example, the function <code class="hljs">concat</code> can concatenate any non-empty list whose entries are appendable:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">c</span><span class="hljs-title">a</span><span class="hljs-title">t</span> <span class="hljs-params">[Append Î±]</span> <span class="hljs-params">(xs : NonEmptyList Î±)</span> <span class="hljs-symbol">:</span></span> Î± :=
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> catList (start : Î±) : List Î± â Î±
    | [] =&gt; start
    | (z :: zs) =&gt; catList (start ++ z) zs
  catList xs.head xs.tail
</code></pre>
<p>However, for some classes, there are operations that can be more efficiently implemented with knowledge of the internals of a datatype.</p>
<p>In these cases, a default method definition can be provided.
A default method definition provides a default implementation of a method in terms of the other methods.
However, instance implementors may choose to override this default with something more efficient.
Default method definitions contain <code class="hljs">:=</code> in a <code class="hljs">class</code> definition.</p>
<p>In the case of <code class="hljs">Functor</code>, some types have a more efficient way of implementing <code class="hljs">map</code> when the function being mapped ignores its argument.
Functions that ignore their arguments are called <em>constant functions</em> because they always return the same value.
Here is the definition of <code class="hljs">Functor</code>, in which <code class="hljs">mapConst</code> has a default implementation:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">c</span><span class="hljs-title">t</span><span class="hljs-title">o</span><span class="hljs-title">r</span> <span class="hljs-params">(f : <span class="hljs-built_in">Type</span> â <span class="hljs-built_in">Type</span>)</span></span> <span class="hljs-keyword">where</span>
  map : {Î± Î² : <span class="hljs-built_in">Type</span>} â (Î± â Î²) â f Î± â f Î²

  mapConst {Î± Î² : <span class="hljs-built_in">Type</span>} (x : Î±) (coll : f Î²) : f Î± :=
    map (<span class="hljs-keyword">fun</span> _ =&gt; x) coll
</code></pre>
<p>Just as a <code class="hljs">Hashable</code> instance that doesn't respect <code class="hljs">BEq</code> is buggy, a <code class="hljs">Functor</code> instance that moves around the data as it maps the function is also buggy.
For example, a buggy <code class="hljs">Functor</code> instance for <code class="hljs">List</code> might throw away its argument and always return the empty list, or it might reverse the list.
A bad instance for <code class="hljs">PPoint</code> might place <code class="hljs">f x</code> in both the <code class="hljs">x</code> and the <code class="hljs">y</code> fields.
Specifically, <code class="hljs">Functor</code> instances should follow two rules:</p>
<ol>
<li>Mapping the identity function should result in the original argument.</li>
<li>Mapping two composed functions should have the same effect as composing their mapping.</li>
</ol>
<p>More formally, the first rule says that <code class="hljs">id &lt;$&gt; x</code> equals <code class="hljs">x</code>.
The second rule says that <code class="hljs">map (fun y =&gt; f (g y)) x</code> equals <code class="hljs">map f (map g x)</code>.
The composition <code class="hljs">fun y =&gt; f (g y)</code> can also be written <code class="hljs">f â g</code>.
These rules prevent implementations of <code class="hljs">map</code> that move the data around or delete some of it.</p>
<h2 id="messages-you-may-meet-4"><a class="header" href="#messages-you-may-meet-4">Messages You May Meet</a></h2>
<p>Lean is not able to derive instances for all classes.
For example, the code</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">deriving</span> <span class="hljs-keyword">instance</span> ToString <span class="hljs-keyword">for</span> NonEmptyList
</code></pre>
<p>results in the following error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">default handlers have not been implemented yet, class: 'ToString' types: [NonEmptyList]
</code></pre>
<p>Invoking <code class="hljs">deriving instance</code> causes Lean to consult an internal table of code generators for type class instances.
If the code generator is found, then it is invoked on the provided type to create the instance.
This message, however, means that no code generator was found for <code class="hljs">ToString</code>.</p>
<h2 id="exercises-8"><a class="header" href="#exercises-8">Exercises</a></h2>
<ul>
<li>Write an instance of <code class="hljs">HAppend (List Î±) (NonEmptyList Î±) (NonEmptyList Î±)</code> and test it.</li>
<li>Implement a <code class="hljs">Functor</code> instance for the binary tree datatype.</li>
</ul>
<div style="break-before:page;page-break-before:always"></div><h1 id="coercions"><a class="header" href="#coercions">Coercions</a></h1>
<p>In mathematics, it is common to use the same symbol to stand for different aspects of some object in different contexts.
For example, if a ring is referred to in a context where a set is expected, then it is understood that the ring's underlying set is what's intended.
In programming languages, it is common to have rules to automatically translate values of one type into values of another type.
For instance, Java allows a <code class="hljs">byte</code> to be automatically promoted to an <code class="hljs">int</code>, and Kotlin allows a non-nullable type to be used in a context that expects a nullable version of the type.</p>
<p>In Lean, both purposes are served by a mechanism called <em>coercions</em>.
When Lean encounters an expression of one type in a context that expects a different type, it will attempt to coerce the expression before reporting a type error.
Unlike Java, C, and Kotlin, the coercions are extensible by defining instances of type classes.</p>
<h2 id="positive-numbers-1"><a class="header" href="#positive-numbers-1">Positive Numbers</a></h2>
<p>For example, every positive number corresponds to a natural number.
The function <code class="hljs">Pos.toNat</code> that was defined earlier converts a <code class="hljs">Pos</code> to the corresponding <code class="hljs">Nat</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">s</span>.<span class="hljs-title">t</span><span class="hljs-title">o</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> Pos â Nat
  | Pos.one =&gt; <span class="hljs-number">1</span>
  | Pos.succ n =&gt; n.toNat + <span class="hljs-number">1</span>
</code></pre>
<p>The function <code class="hljs">List.drop</code>, with type <code class="hljs">{Î± : Type} â Nat â List Î± â List Î±</code>, removes a prefix of a list.
Applying <code class="hljs">List.drop</code> to a <code class="hljs">Pos</code>, however, leads to a type error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].drop (<span class="hljs-number">2</span> : Pos)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">application type mismatch
  List.drop 2
argument
  2
has type
  Pos : Type
but is expected to have type
  Nat : Type
</code></pre>
<p>Because the author of <code class="hljs">List.drop</code> did not make it a method of a type class, it can't be overridden by defining a new instance.</p>
<p>The type class <code class="hljs">Coe</code> describes overloaded ways of coercing from one type to another:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span><span class="hljs-title">o</span><span class="hljs-title">e</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(Î² : <span class="hljs-built_in">Type</span>)</span></span> <span class="hljs-keyword">where</span>
  coe : Î± â Î²
</code></pre>
<p>An instance of <code class="hljs">Coe Pos Nat</code> is enough to allow the prior code to work:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Coe Pos Nat <span class="hljs-keyword">where</span>
  coe x := x.toNat

<span class="hljs-keyword">#eval</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].drop (<span class="hljs-number">2</span> : Pos)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">[3, 4]
</code></pre>
<p>Using <code class="hljs">#check</code> shows the result of the instance search that was used behind the scenes:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].drop (<span class="hljs-number">2</span> : Pos)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">List.drop (Pos.toNat 2) [1, 2, 3, 4] : List Nat
</code></pre>
<h2 id="chaining-coercions"><a class="header" href="#chaining-coercions">Chaining Coercions</a></h2>
<p>When searching for coercions, Lean will attempt to assemble a coercion out of a chain of smaller coercions.
For example, there is already a coercion from <code class="hljs">Nat</code> to <code class="hljs">Int</code>.
Because of that instance, combined with the <code class="hljs">Coe Pos Nat</code> instance, the following code is accepted:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">e</span><span class="hljs-title">I</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> Int := Pos.one
</code></pre>
<p>This definition uses two coercions: from <code class="hljs">Pos</code> to <code class="hljs">Nat</code>, and then from <code class="hljs">Nat</code> to <code class="hljs">Int</code>.</p>
<p>The Lean compiler does not get stuck in the presence of circular coercions.
For example, even if two types <code class="hljs">A</code> and <code class="hljs">B</code> can be coerced to one another, their mutual coercions can be used to find a path:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> A <span class="hljs-keyword">where</span>
  | a

<span class="hljs-keyword">inductive</span> B <span class="hljs-keyword">where</span>
  | b

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Coe A B <span class="hljs-keyword">where</span>
  coe _ := B.b

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Coe B A <span class="hljs-keyword">where</span>
  coe _ := A.a

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Coe Unit A <span class="hljs-keyword">where</span>
  coe _ := A.a

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">c</span><span class="hljs-title">e</span><span class="hljs-title">d</span><span class="hljs-title">T</span><span class="hljs-title">o</span><span class="hljs-title">B</span> <span class="hljs-symbol">:</span></span> B := ()
</code></pre>
<p>Remember: the double parentheses <code class="hljs">()</code> is short for the constructor <code class="hljs">Unit.unit</code>.
After deriving a <code class="hljs">Repr B</code> instance,</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> coercedToB
</code></pre>
<p>results in:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">B.b
</code></pre>
<p>The <code class="hljs">Option</code> type can be used similarly to nullable types in C# and Kotlin: the <code class="hljs">none</code> constructor represents the absence of a value.
The Lean standard library defines a coercion from any type <code class="hljs">Î±</code> to <code class="hljs">Option Î±</code> that wraps the value in <code class="hljs">some</code>.
This allows option types to be used in a manner even more similar to nullable types, because <code class="hljs">some</code> can be omitted.
For instance, the function <code class="hljs">List.getLast?</code> that finds the last entry in a list can be written without a <code class="hljs">some</code> around the return value <code class="hljs">x</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">l</span><span class="hljs-title">a</span><span class="hljs-title">s</span><span class="hljs-title">t?</span> <span class="hljs-symbol">:</span></span> List Î± â Option Î±
  | [] =&gt; none
  | [x] =&gt; x
  | _ :: x :: xs =&gt; last? (x :: xs)
</code></pre>
<p>Instance search finds the coercion, and inserts a call to <code class="hljs">coe</code>, which wraps the argument in <code class="hljs">some</code>.
These coercions can be chained, so that nested uses of <code class="hljs">Option</code> don't require nested <code class="hljs">some</code> constructors:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">s</span><span class="hljs-title">P</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">s</span><span class="hljs-title">P</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> Option (Option (Option String)) :=
  <span class="hljs-string">"Please don't tell me"</span>
</code></pre>
<p>Coercions are only activated automatically when Lean encounters a mismatch between an inferred type and a type that is imposed from the rest of the program.
In cases with other errors, coercions are not activated.
For example, if the error is that an instance is missing, coercions will not be used:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">s</span><span class="hljs-title">P</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">s</span><span class="hljs-title">P</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">s</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> Option (Option (Option Nat)) :=
  <span class="hljs-number">392</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to synthesize instance
  OfNat (Option (Option (Option Nat))) 392
</code></pre>
<p>This can be worked around by manually indicating the desired type to be used for <code class="hljs">OfNat</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">s</span><span class="hljs-title">P</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">s</span><span class="hljs-title">P</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">s</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> Option (Option (Option Nat)) :=
  (<span class="hljs-number">392</span> : Nat)
</code></pre>
<p>Additionally, coercions can be manually inserted using an up arrow:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">s</span><span class="hljs-title">P</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">s</span><span class="hljs-title">P</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">s</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> Option (Option (Option Nat)) :=
  â(<span class="hljs-number">392</span> : Nat)
</code></pre>
<p>In some cases, this can be used to ensure that Lean finds the right instances.
It can also make the programmer's intentions more clear.</p>
<h2 id="non-empty-lists-and-dependent-coercions"><a class="header" href="#non-empty-lists-and-dependent-coercions">Non-Empty Lists and Dependent Coercions</a></h2>
<p>An instance of <code class="hljs">Coe Î± Î²</code> makes sense when the type <code class="hljs">Î²</code> has a value that can represent each value from the type <code class="hljs">Î±</code>.
Coercing from <code class="hljs">Nat</code> to <code class="hljs">Int</code> makes sense, because the type <code class="hljs">Int</code> contains all the natural numbers.
Similarly, a coercion from non-empty lists to ordinary lists makes sense because the <code class="hljs">List</code> type can represent every non-empty list:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Coe (NonEmptyList Î±) (List Î±) <span class="hljs-keyword">where</span>
  coe
    | { head := x, tail := xs } =&gt; x :: xs
</code></pre>
<p>This allows non-empty lists to be used with the entire <code class="hljs">List</code> API.</p>
<p>On the other hand, it is impossible to write an instance of <code class="hljs">Coe (List Î±) (NonEmptyList Î±)</code>, because there's no non-empty list that can represent the empty list.
This limitation can be worked around by using another version of coercions, which are called <em>dependent coercions</em>.
Dependent coercions can be used when the ability to coerce from one type to another depends on which particular value is being coerced.
Just as the <code class="hljs">OfNat</code> type class takes the particular <code class="hljs">Nat</code> being overloaded as a parameter, dependent coercion takes the value being coerced as a parameter:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span><span class="hljs-title">o</span><span class="hljs-title">e</span><span class="hljs-title">D</span><span class="hljs-title">e</span><span class="hljs-title">p</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(x : Î±)</span> <span class="hljs-params">(Î² : <span class="hljs-built_in">Type</span>)</span></span> <span class="hljs-keyword">where</span>
  coe : Î²
</code></pre>
<p>This is a chance to select only certain values, either by imposing further type class constraints on the value or by writing certain constructors directly.
For example, any <code class="hljs">List</code> that is not actually empty can be coerced to a <code class="hljs">NonEmptyList</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> CoeDep (List Î±) (x :: xs) (NonEmptyList Î±) <span class="hljs-keyword">where</span>
  coe := { head := x, tail := xs }
</code></pre>
<h2 id="coercing-to-types"><a class="header" href="#coercing-to-types">Coercing to Types</a></h2>
<p>In mathematics, it is common to have a concept that consists of a set equipped with additional structure.
For example, a monoid is some set <em>S</em>, an element <em>s</em> of <em>S</em>, and an associative binary operator on <em>S</em>, such that <em>s</em> is neutral on the left and right of the operator.
<em>S</em> is referred to as the "carrier set" of the monoid.
The natural numbers with zero and addition form a monoid, because addition is associative and adding zero to any number is the identity.
Similarly, the natural numbers with one and multiplication also form a monoid.
Monoids are also widely used in functional programming: lists, the empty list, and the append operator form a monoid, as do strings, the empty string, and string append:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">M</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">i</span><span class="hljs-title">d</span></span> <span class="hljs-keyword">where</span>
  Carrier : <span class="hljs-built_in">Type</span>
  neutral : Carrier
  op : Carrier â Carrier â Carrier

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">n</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">M</span><span class="hljs-title">u</span><span class="hljs-title">l</span><span class="hljs-title">M</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">i</span><span class="hljs-title">d</span> <span class="hljs-symbol">:</span></span> Monoid :=
  { Carrier := Nat, neutral := <span class="hljs-number">1</span>, op := (Â· * Â·) }

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">n</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">A</span><span class="hljs-title">d</span><span class="hljs-title">d</span><span class="hljs-title">M</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">i</span><span class="hljs-title">d</span> <span class="hljs-symbol">:</span></span> Monoid :=
  { Carrier := Nat, neutral := <span class="hljs-number">0</span>, op := (Â· + Â·) }

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">g</span><span class="hljs-title">M</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">i</span><span class="hljs-title">d</span> <span class="hljs-symbol">:</span></span> Monoid :=
  { Carrier := String, neutral := <span class="hljs-string">""</span>, op := String.append }

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">M</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">i</span><span class="hljs-title">d</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-symbol">:</span></span> Monoid :=
  { Carrier := List Î±, neutral := [], op := List.append }
</code></pre>
<p>Given a monoid, it is possible to write the <code class="hljs">foldMap</code> function that, in a single pass, transforms the entries in a list into a monoid's carrier set and then combines them using the monoid's operator.
Because monoids have a neutral element, there is a natural result to return when the list is empty, and because the operator is associative, clients of the function don't have to care whether the recursive function combines elements from left to right or from right to left.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">l</span><span class="hljs-title">d</span><span class="hljs-title">M</span><span class="hljs-title">a</span><span class="hljs-title">p</span> <span class="hljs-params">(M : Monoid)</span> <span class="hljs-params">(f : Î± â M.Carrier)</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> M.Carrier :=
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> go (soFar : M.Carrier) : List Î± â M.Carrier
    | [] =&gt; soFar
    | y :: ys =&gt; go (M.op soFar (f y)) ys
  go M.neutral xs
</code></pre>
<p>Even though a monoid consists of three separate pieces of information, it is common to just refer to the monoid's name in order to refer to its set.
Instead of saying "Let A be a monoid and let <em>x</em> and <em>y</em> be elements of its carrier set", it is common to say "Let <em>A</em> be a monoid and let <em>x</em> and <em>y</em> be elements of <em>A</em>".
This practice can be encoded in Lean by defining a new kind of coercion, from the monoid to its carrier set.</p>
<p>The <code class="hljs">CoeSort</code> class is just like the <code class="hljs">Coe</code> class, with the exception that the target of the coercion must be a <em>sort</em>, namely <code class="hljs">Type</code> or <code class="hljs">Prop</code>.
The term <em>sort</em> in Lean refers to these types that classify other typesâ<code class="hljs">Type</code> classifies types that themselves classify data, and <code class="hljs">Prop</code> classifies propositions that themselves classify evidence of their truth.
Just as <code class="hljs">Coe</code> is checked when a type mismatch occurs, <code class="hljs">CoeSort</code> is used when something other than a sort is provided in a context where a sort would be expected.</p>
<p>The coercion from a monoid into its carrier set extracts the carrier:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> CoeSort Monoid <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  coe m := m.Carrier
</code></pre>
<p>With this coercion, the type signatures become less bureaucratic:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">l</span><span class="hljs-title">d</span><span class="hljs-title">M</span><span class="hljs-title">a</span><span class="hljs-title">p</span> <span class="hljs-params">(M : Monoid)</span> <span class="hljs-params">(f : Î± â M)</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> M :=
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> go (soFar : M) : List Î± â M
    | [] =&gt; soFar
    | y :: ys =&gt; go (M.op soFar (f y)) ys
  go M.neutral xs
</code></pre>
<p>Another useful example of <code class="hljs">CoeSort</code> is used to bridge the gap between <code class="hljs">Bool</code> and <code class="hljs">Prop</code>.
As discussed in <a href="https://leanprover.github.io/functional_programming_in_lean/type-classes/standard-classes.html#equality-and-ordering">the section on ordering and equality</a>, Lean's <code class="hljs">if</code> expression expects the condition to be a decidable proposition rather than a <code class="hljs">Bool</code>.
Programs typically need to be able to branch based on Boolean values, however.
Rather than have two kinds of <code class="hljs">if</code> expression, the Lean standard library defines a coercion from <code class="hljs">Bool</code> to the proposition that the <code class="hljs">Bool</code> in question is equal to <code class="hljs">true</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> CoeSort Bool <span class="hljs-built_in">Prop</span> <span class="hljs-keyword">where</span>
  coe b := b = true
</code></pre>
<p>In this case, the sort in question is <code class="hljs">Prop</code> rather than <code class="hljs">Type</code>.</p>
<h2 id="coercing-to-functions"><a class="header" href="#coercing-to-functions">Coercing to Functions</a></h2>
<p>Many datatypes that occur regularly in programming consist of a function along with some extra information about it.
For example, a function might be accompanied by a name to show in logs or by some configuration data.
Additionally, putting a type in a field of a structure, similarly to the <code class="hljs">Monoid</code> example, can make sense in contexts where there is more than one way to implement an operation and more manual control is needed than type classes would allow.
For example, the specific details of values emitted by a JSON serializer may be important because another application expects a particular format.
Sometimes, the function itself may be derivable from just the configuration data.</p>
<p>A type class called <code class="hljs">CoeFun</code> can transform values from non-function types to function types.
<code class="hljs">CoeFun</code> has two parameters: the first is the type whose values should be transformed into functions, and the second is an output parameter that determines exactly which function type is being targeted.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span><span class="hljs-title">o</span><span class="hljs-title">e</span><span class="hljs-title">F</span><span class="hljs-title">u</span><span class="hljs-title">n</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(makeFunctionType : outParam (Î± â <span class="hljs-built_in">Type</span>)</span>)</span> <span class="hljs-keyword">where</span>
  coe : (x : Î±) â makeFunctionType x
</code></pre>
<p>The second parameter is itself a function that computes a type.
In Lean, types are first-class and can be passed to functions or returned from them, just like anything else.</p>
<p>For example, a function that adds a constant amount to its argument can be represented as a wrapper around the amount to add, rather than by defining an actual function:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">A</span><span class="hljs-title">d</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span></span> <span class="hljs-keyword">where</span>
  howMuch : Nat
</code></pre>
<p>A function that adds five to its argument has a <code class="hljs">5</code> in the <code class="hljs">howMuch</code> field:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">d5</span> <span class="hljs-symbol">:</span></span> Adder := â¨<span class="hljs-number">5</span>â©
</code></pre>
<p>This <code class="hljs">Adder</code> type is not a function, and applying it to an argument results in an error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> add5 <span class="hljs-number">3</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">function expected at
  add5
term has type
  Adder
</code></pre>
<p>Defining a <code class="hljs">CoeFun</code> instance causes Lean to transform the adder into a function with type <code class="hljs">Nat â Nat</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> CoeFun Adder (<span class="hljs-keyword">fun</span> _ =&gt; Nat â Nat) <span class="hljs-keyword">where</span>
  coe a := (Â· + a.howMuch)

<span class="hljs-keyword">#eval</span> add5 <span class="hljs-number">3</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">8
</code></pre>
<p>Because all <code class="hljs">Adder</code>s should be transformed into <code class="hljs">Nat â Nat</code> functions, the argument to <code class="hljs">CoeFun</code>'s second parameter was ignored.</p>
<p>When the value itself is needed to determine the right function type, then <code class="hljs">CoeFun</code>'s second parameter is no longer ignored.
For example, given the following representation of JSON values:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> JSON <span class="hljs-keyword">where</span>
  | true : JSON
  | false : JSON
  | null : JSON
  | string : String â JSON
  | number : Float â JSON
  | object : List (String Ã JSON) â JSON
  | array : List JSON â JSON
<span class="hljs-keyword">deriving</span> Repr
</code></pre>
<p>a JSON serializer is a structure that tracks the type it knows how to serialize along with the serialization code itself:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">S</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">r</span></span> <span class="hljs-keyword">where</span>
  Contents : <span class="hljs-built_in">Type</span>
  serialize : Contents â JSON
</code></pre>
<p>A serializer for strings need only wrap the provided string in the <code class="hljs">JSON.string</code> constructor:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">S</span><span class="hljs-title">t</span><span class="hljs-title">r</span> <span class="hljs-symbol">:</span></span> Serializer :=
  { Contents := String,
    serialize := JSON.string
  }
</code></pre>
<p>Viewing JSON serializers as functions that serialize their argument requires extracting the inner type of serializable data:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> CoeFun Serializer (<span class="hljs-keyword">fun</span> s =&gt; s.Contents â JSON) <span class="hljs-keyword">where</span>
  coe s := s.serialize
</code></pre>
<p>Given this instance, a serializer can be applied directly to an argument:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">b</span><span class="hljs-title">u</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">d</span><span class="hljs-title">R</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">p</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-params">(title : String)</span> <span class="hljs-params">(R : Serializer)</span> <span class="hljs-params">(record : R.Contents)</span> <span class="hljs-symbol">:</span></span> JSON :=
  JSON.object [
    (<span class="hljs-string">"title"</span>, JSON.string title),
    (<span class="hljs-string">"status"</span>, JSON.number <span class="hljs-number">200</span>),
    (<span class="hljs-string">"record"</span>, R record)
  ]
</code></pre>
<p>The serializer can be passed directly to <code class="hljs">buildResponse</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> buildResponse <span class="hljs-string">"Functional Programming in Lean"</span> Str <span class="hljs-string">"Programming is fun!"</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">JSON.object
  [("title", JSON.string "Functional Programming in Lean"),
   ("status", JSON.number 200.000000),
   ("record", JSON.string "Programming is fun!")]
</code></pre>
<h3 id="aside-json-as-a-string"><a class="header" href="#aside-json-as-a-string">Aside: JSON as a String</a></h3>
<p>It can be a bit difficult to understand JSON when encoded as Lean objects.
To help make sure that the serialized response was what was expected, it can be convenient to write a simple converter from <code class="hljs">JSON</code> to <code class="hljs">String</code>.
The first step is to simplify the display of numbers.
<code class="hljs">JSON</code> doesn't distinguish between integers and floating point numbers, and the type <code class="hljs">Float</code> is used to represent both.
In Lean, <code class="hljs">Float.toString</code> includes a number of trailing zeros:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (<span class="hljs-number">5</span> : Float).toString
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">"5.000000"
</code></pre>
<p>The solution is to write a little function that cleans up the presentation by dropping all trailing zeros, followed by a trailing decimal point:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">p</span><span class="hljs-title">D</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">i</span><span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">s</span> <span class="hljs-params">(numString : String)</span> <span class="hljs-symbol">:</span></span> String :=
  <span class="hljs-keyword">if</span> numString.contains '.' <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">let</span> noTrailingZeros := numString.dropRightWhile (Â· == '<span class="hljs-number">0</span>')
    noTrailingZeros.dropRightWhile (Â· == '.')
  <span class="hljs-keyword">else</span> numString
</code></pre>
<p>With this definition, <code class="hljs">#eval dropDecimals (5 : Float).toString</code> yields <code class="hljs">"5"</code>, and <code class="hljs">#eval dropDecimals (5.2 : Float).toString</code> yields <code class="hljs">"5.2"</code>.</p>
<p>The next step is to define a helper function to append a list of strings with a separator in between them:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">S</span><span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">g</span>.<span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">p</span><span class="hljs-title">a</span><span class="hljs-title">r</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span> <span class="hljs-params">(sep : String)</span> <span class="hljs-params">(strings : List String)</span> <span class="hljs-symbol">:</span></span> String :=
  <span class="hljs-keyword">match</span> strings <span class="hljs-keyword">with</span>
  | [] =&gt; <span class="hljs-string">""</span>
  | x :: xs =&gt; String.join (x :: xs.map (sep ++ Â·))
</code></pre>
<p>This function is useful to account for comma-separated elements in JSON arrays and objects.
<code class="hljs">#eval ", ".separate ["1", "2"]</code> yields <code class="hljs">"1, 2"</code>, <code class="hljs">#eval ", ".separate ["1"]</code> yields <code class="hljs">"1"</code>, and <code class="hljs">#eval ", ".separate []</code> yields <code class="hljs">""</code>.</p>
<p>Finally, a string escaping procedure is needed for JSON strings, so that the Lean string containing <code class="hljs">"Hello!"</code> can be output as <code class="hljs">"\"Hello!\""</code>.
Fortunately, the Lean compiler contains an internal function for escaping JSON strings already, called <code class="hljs">Lean.Json.escape</code>.
To access this function, add <code class="hljs">import Lean</code> to the beginning of your file.</p>
<p>The function that emits a string from a <code class="hljs">JSON</code> value is declared <code class="hljs">partial</code> because Lean cannot see that it terminates.
This is because recursive calls to <code class="hljs">asString</code> occur in functions that are being applied by <code class="hljs">List.map</code>, and this pattern of recursion is complicated enough that Lean cannot see that the recursive calls are actually being performed on smaller values.
In an application that just needs to produce JSON strings and doesn't need to mathematically reason about the process, having the function be <code class="hljs">partial</code> is not likely to cause problems.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">partial</span> <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">J</span><span class="hljs-title">S</span><span class="hljs-title">O</span><span class="hljs-title">N</span>.<span class="hljs-title">a</span><span class="hljs-title">s</span><span class="hljs-title">S</span><span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">g</span> <span class="hljs-params">(val : JSON)</span> <span class="hljs-symbol">:</span></span> String :=
  <span class="hljs-keyword">match</span> val <span class="hljs-keyword">with</span>
  | true =&gt; <span class="hljs-string">"true"</span>
  | false =&gt; <span class="hljs-string">"false"</span>
  | null =&gt; <span class="hljs-string">"null"</span>
  | string s =&gt; <span class="hljs-string">"\""</span> ++ Lean.Json.escape s ++ <span class="hljs-string">"\""</span>
  | number n =&gt; dropDecimals n.toString
  | object members =&gt;
    <span class="hljs-keyword">let</span> memberToString mem :=
      <span class="hljs-string">"\""</span> ++ Lean.Json.escape mem.fst ++ <span class="hljs-string">"\": "</span> ++ asString mem.snd
    <span class="hljs-string">"{"</span> ++ <span class="hljs-string">", "</span>.separate (members.map memberToString) ++ <span class="hljs-string">"}"</span>
  | array elements =&gt;
    <span class="hljs-string">"["</span> ++ <span class="hljs-string">", "</span>.separate (elements.map asString) ++ <span class="hljs-string">"]"</span>
</code></pre>
<p>With this definition, the output of serialization is easier to read:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (buildResponse <span class="hljs-string">"Functional Programming in Lean"</span> Str <span class="hljs-string">"Programming is fun!"</span>).asString
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">"{\\"title\\": \\"Functional Programming in Lean\\", \\"status\\": 200, \\"record\\": \\"Programming is fun!\\"}"
</code></pre>
<h2 id="messages-you-may-meet-5"><a class="header" href="#messages-you-may-meet-5">Messages You May Meet</a></h2>
<p>Natural number literals are overloaded with the <code class="hljs">OfNat</code> type class.
Because coercions fire in cases where types don't match, rather than in cases of missing instances, a missing <code class="hljs">OfNat</code> instance for a type does not cause a coercion from <code class="hljs">Nat</code> to be applied:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">s</span><span class="hljs-title">P</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">s</span><span class="hljs-title">P</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">s</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> Option (Option (Option Nat)) :=
  <span class="hljs-number">392</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to synthesize instance
  OfNat (Option (Option (Option Nat))) 392
</code></pre>
<h2 id="design-considerations"><a class="header" href="#design-considerations">Design Considerations</a></h2>
<p>Coercions are a powerful tool that should be used responsibly.
On the one hand, they can allow an API to naturally follow the everyday rules of the domain being modeled.
This can be the difference between a bureaucratic mess of manual conversion functions and a clear program.
As Abelson and Sussman wrote in the preface to <em>Structure and Interpretation of Computer Programs</em> (MIT Press, 1996),</p>
<blockquote>
<p>Programs must be written for people to read, and only incidentally for machines to execute.</p>
</blockquote>
<p>Coercions, used wisely, are a valuable means of achieving readable code that can serve as the basis for communication with domain experts.
APIs that rely heavily on coercions have a number of important limitations, however.
Think carefully about these limitations before using coercions in your own libraries.</p>
<p>First off, coercions are only applied in contexts where enough type information is available for Lean to know all of the types involved, because there are no output parameters in the coercion type classes. This means that a return type annotation on a function can be the difference between a type error and a successfully applied coercion.
For example, the coercion from non-empty lists to lists makes the following program work:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">l</span><span class="hljs-title">a</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">S</span><span class="hljs-title">p</span><span class="hljs-title">i</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-symbol">:</span></span> Option String :=
  List.getLast? idahoSpiders
</code></pre>
<p>On the other hand, if the type annotation is omitted, then the result type is unknown, so Lean is unable to find the coercion:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">l</span><span class="hljs-title">a</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">S</span><span class="hljs-title">p</span><span class="hljs-title">i</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-symbol">:</span></span>=
  List.getLast? idahoSpiders
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">application type mismatch
  List.getLast? idahoSpiders
argument
  idahoSpiders
has type
  NonEmptyList String : Type
but is expected to have type
  List ?m.34258 : Type
</code></pre>
<p>More generally, when a coercion is not applied for some reason, the user receives the original type error, which can make it difficult to debug chains of coercions.</p>
<p>Finally, coercions are not applied in the context of field accessor notation.
This means that there is still an important difference between expressions that need to be coerced and those that don't, and this difference is visible to users of your API.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="additional-conveniences-2"><a class="header" href="#additional-conveniences-2">Additional Conveniences</a></h1>
<h2 id="constructor-syntax-for-instances"><a class="header" href="#constructor-syntax-for-instances">Constructor Syntax for Instances</a></h2>
<p>Behind the scenes, type classes are structure types and instances are values of these types.
The only differences are that Lean stores additional information about type classes, such as which parameters are output parameters, and that instances are registered for searching.
While values that have structure types are typically defined using either <code class="hljs">â¨...â©</code> syntax or with braces and fields, and instances are typically defined using <code class="hljs">where</code>, both syntaxes work for both kinds of definition.</p>
<p>For example, a forestry application might represent trees as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  latinName : String
  commonNames : List String

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">o</span><span class="hljs-title">a</span><span class="hljs-title">k</span> <span class="hljs-symbol">:</span></span> Tree :=
  â¨<span class="hljs-string">"Quercus robur"</span>, [<span class="hljs-string">"common oak"</span>, <span class="hljs-string">"European oak"</span>]â©

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">b</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">c</span><span class="hljs-title">h</span> <span class="hljs-symbol">:</span></span> Tree :=
  { latinName := <span class="hljs-string">"Betula pendula"</span>,
    commonNames := [<span class="hljs-string">"silver birch"</span>, <span class="hljs-string">"warty birch"</span>]
  }

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">l</span><span class="hljs-title">o</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Tree <span class="hljs-keyword">where</span>
  latinName := <span class="hljs-string">"Prunus spinosa"</span>
  commonNames := [<span class="hljs-string">"sloe"</span>, <span class="hljs-string">"blackthorn"</span>]
</code></pre>
<p>All three syntaxes are equivalent.</p>
<p>Similarly, type class instances can be defined using all three syntaxes:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">a</span><span class="hljs-title">y</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span></span> <span class="hljs-keyword">where</span>
  displayName : Î± â String

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Display Tree :=
  â¨Tree.latinNameâ©

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Display Tree :=
  { displayName := Tree.latinName }

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Display Tree <span class="hljs-keyword">where</span>
  displayName t := t.latinName
</code></pre>
<p>Generally speaking, the <code class="hljs">where</code> syntax should be used for instances, and the curly-brace syntax should be used for structures.
The <code class="hljs">â¨...â©</code> syntax can be useful when emphasizing that a structure type is very much like a tuple in which the fields happen to be named, but the names are not important at the moment.
However, there are situations where it can make sense to use other alternatives.
In particular, a library might provide a function that constructs an instance value.
Placing a call to this function after <code class="hljs">:=</code> in an instance declaration is the easiest way to use such a function.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>When experimenting with Lean code, definitions can be more convenient to use than <code class="hljs">#eval</code> or <code class="hljs">#check</code> commands.
First off, definitions don't produce any output, which can help keep the reader's focus on the most interesting output.
Secondly, it's easiest to write most Lean programs by starting with a type signature, allowing Lean to provide more assistance and better error messages while writing the program itself.
On the other hand, <code class="hljs">#eval</code> and <code class="hljs">#check</code> are easiest to use in contexts where Lean is able to determine the type from the provided expression.
Thirdly, <code class="hljs">#eval</code> cannot be used with expressions whose types don't have <code class="hljs">ToString</code> or <code class="hljs">Repr</code> instances, such as functions.
Finally, multi-step <code class="hljs">do</code> blocks, <code class="hljs">let</code>-expressions, and other syntactic forms that take multiple lines are particularly difficult to write with a type annotation in <code class="hljs">#eval</code> or <code class="hljs">#check</code>, simply because the required parenthesization can be difficult to predict.</p>
<p>To work around these issues, Lean supports the explicit indication of examples in a source file.
An example is like a definition without a name.
For instance, a non-empty list of birds commonly found in Copenhagen's green spaces can be written:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : NonEmptyList String :=
  { head := <span class="hljs-string">"Sparrow"</span>,
    tail := [<span class="hljs-string">"Duck"</span>, <span class="hljs-string">"Swan"</span>, <span class="hljs-string">"Magpie"</span>, <span class="hljs-string">"Eurasian coot"</span>, <span class="hljs-string">"Crow"</span>]
  }
</code></pre>
<p>Examples may define functions by accepting arguments:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> (n : Nat) (k : Nat) : Bool :=
  n + k == k + n
</code></pre>
<p>While this creates a function behind the scenes, this function has no name and cannot be called.
Nonetheless, this is useful for demonstrating how a library can be used with arbitrary or unknown values of some given type.
In source files, <code class="hljs">example</code> declarations are best paired with comments that explain how the example illustrates the concepts of the library.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="summary-2"><a class="header" href="#summary-2">Summary</a></h1>
<h2 id="type-classes-and-overloading"><a class="header" href="#type-classes-and-overloading">Type Classes and Overloading</a></h2>
<p>Type classes are Lean's mechanism for overloading functions and operators.
A polymorphic function can be used with multiple types, but it behaves in the same manner no matter which type it is used with.
For example, a polymorphic function that appends two lists can be used no matter the type of the entries in the list, but it is unable to have different behavior depending on which particular type is found.
An operation that is overloaded with type classes, on the other hand, can also be used with multiple types.
However, each type requires its own implementation of the overloaded operation.
This means that the behavior can vary based on which type is provided.</p>
<p>A <em>type class</em> has a name, parameters, and a body that consists of a number of names with types.
The name is a way to refer to the overloaded operations, the parameters determine which aspects of the definitions can be overloaded, and the body provides the names and type signatures of the overloadable operations.
Each overloadable operation is called a <em>method</em> of the type class.
Type classes may provide default implementations of some methods in terms of the others, freeing implementors from defining each overload by hand when it is not needed.</p>
<p>An <em>instance</em> of a type class provides implementations of the methods for given parameters.
Instances may be polymorphic, in which case they can work for a variety of parameters, and they may optionally provide more specific implementations of default methods in cases where a more efficient version exists for some particular type.</p>
<p>Type class parameters are either <em>input parameters</em> (the default), or <em>output parameters</em> (indicated by an <code class="hljs">outParam</code> modifier).
Lean will not begin searching for an instance until all input parameters are no longer metavariables, while output parameters may be solved while searching for instances.
Parameters to a type class need not be typesâthey may also be ordinary values.
The <code class="hljs">OfNat</code> type class, used to overload natural number literals, takes the overloaded <code class="hljs">Nat</code> itself as a parameter, which allows instances to restrict the allowed numbers.</p>
<p>Instances may be marked with a <code class="hljs">@[default_instance]</code> attribute.
When an instance is a default instance, then it will be chosen as a fallback when Lean would otherwise fail to find an instance due to the presence of metavariables in the type.</p>
<h2 id="type-classes-for-common-syntax"><a class="header" href="#type-classes-for-common-syntax">Type Classes for Common Syntax</a></h2>
<p>Most infix operators in Lean are overridden with a type class.
For instance, the addition operator corresponds to a type class called <code class="hljs">Add</code>.
Most of these operators have a corresponding heterogeneous version, in which the two arguments need not have the same type.
These heterogenous operators are overloaded using a version of the class whose name starts with <code class="hljs">H</code>, such as <code class="hljs">HAdd</code>.</p>
<p>Indexing syntax is overloaded using a type class called <code class="hljs">GetElem</code>, which involves proofs.
<code class="hljs">GetElem</code> has two output parameters, which are the type of elements to be extracted from the collection and a function that can be used to determine what counts as evidence that the index value is in bounds for the collection.
This evidence is described by a proposition, and Lean attempts to prove this proposition when array indexing is used.
When Lean is unable to check that list or array access operations are in bounds at compile time, the check can be deferred to run time by appending a <code class="hljs">?</code> to the indexing operation.</p>
<h2 id="functors-1"><a class="header" href="#functors-1">Functors</a></h2>
<p>A functor is a polymorphic type that supports a mapping operation.
This mapping operation transforms all elements "in place", changing no other structure.
For instance, lists are functors and the mapping operation may neither drop, duplicate, nor mix up entries in the list.</p>
<p>While functors are defined by having <code class="hljs">map</code>, the <code class="hljs">Functor</code> type class in Lean contains an additional default method that is responsible for mapping the constant function over a value, replacing all values whose type are given by polymorphic type variable with the same new value.
For some functors, this can be done more efficiently than traversing the entire structure.</p>
<h2 id="deriving-instances"><a class="header" href="#deriving-instances">Deriving Instances</a></h2>
<p>Many type classes have very standard implementations.
For instance, the Boolean equality class <code class="hljs">BEq</code> is usually implemented by first checking whether both arguments are built with the same constructor, and then checking whether all their arguments are equal.
Instances for these classes can be created <em>automatically</em>.</p>
<p>When defining an inductive type or a structure, a <code class="hljs">deriving</code> clause at the end of the declaration will cause instances to be created automatically.
Additionally, the <code class="hljs">deriving instance ... for ...</code> command can be used outside of the definition of a datatype to cause an instance to be generated.
Because each class for which instances can be derived requires special handling, not all classes are derivable.</p>
<h2 id="coercions-1"><a class="header" href="#coercions-1">Coercions</a></h2>
<p>Coercions allow Lean to recover from what would normally be a compile-time error by inserting a call to a function that transforms data from one type to another.
For example, the coercion from any type <code class="hljs">Î±</code> to the type <code class="hljs">Option Î±</code> allows values to be written directly, rather than with the <code class="hljs">some</code> constructor, making <code class="hljs">Option</code> work more like nullable types from object-oriented languages.</p>
<p>There are multiple kinds of coercion.
They can recover from different kinds of errors, and they are represented by their own type classes.
The <code class="hljs">Coe</code> class is used to recover from type errors.
When Lean has an expression of type <code class="hljs">Î±</code> in a context that expects something with type <code class="hljs">Î²</code>, Lean first attempts to string together a chain of coercions that can transform <code class="hljs">Î±</code>s into <code class="hljs">Î²</code>s, and only displays the error when this cannot be done.
The <code class="hljs">CoeDep</code> class takes the specific value being coerced as an extra parameter, allowing either further type class search to be done on the value or allowing constructors to be used in the instance to limit the scope of the conversion.
The <code class="hljs">CoeFun</code> class intercepts what would otherwise be a "not a function" error when compiling a function application, and allows the value in the function position to be transformed into an actual function if possible.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="monads"><a class="header" href="#monads">Monads</a></h1>
<p>In C# and Kotlin, the <code class="hljs">?.</code> operator is a way to look up a property or call a method on a potentially-null value.
If the receiver is <code class="hljs">null</code>, the whole expression is null.
Otherwise, the underlying non-<code class="hljs">null</code> value receives the call.
Uses of <code class="hljs">?.</code> can be chained, in which case the first <code class="hljs">null</code> result terminates the chain of lookups.
Chaining null-checks like this is much more convenient than writing and maintaining deeply nested <code class="hljs">if</code>s.</p>
<p>Similarly, exceptions are significantly more convenient than manually checking and propagating error codes.
At the same time, logging is easiest to accomplish by having a dedicated logging framework, rather than having each function return both its log results and its return value.
Chained null checks and exceptions typically require language designers to anticipate this use case, while logging frameworks typically make use of side effects to decouple code that logs from the accumulation of the logs.</p>
<p>All these features and more can be implemented in library code as instances of a common API called <code class="hljs">Monad</code>.
Lean provides dedicated syntax that makes this API convenient to use, but can also get in the way of understanding what is going on behind the scenes.
This chapter begins with the nitty-gritty presentation of manually nesting null checks, and builds from there to the convenient, general API.
Please suspend your disbelief in the meantime.</p>
<h2 id="checking-for-none-dont-repeat-yourself"><a class="header" href="#checking-for-none-dont-repeat-yourself">Checking for <code>none</code>: Don't Repeat Yourself</a></h2>
<p>In Lean, pattern matching can be used to chain checks for null.
Getting the first entry from a list can just use the optional indexing notation:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Option Î± :=
  xs[<span class="hljs-number">0</span>]?
</code></pre>
<p>The result must be an <code class="hljs">Option</code> because empty lists have no first entry.
Extracting the first and third entries requires a check that each is not <code class="hljs">none</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">d</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Option (Î± Ã Î±) :=
  <span class="hljs-keyword">match</span> xs[<span class="hljs-number">0</span>]? <span class="hljs-keyword">with</span>
  | none =&gt; none
  | some first =&gt;
    <span class="hljs-keyword">match</span> xs[<span class="hljs-number">2</span>]? <span class="hljs-keyword">with</span>
    | none =&gt; none
    | some third =&gt;
      some (first, third)
</code></pre>
<p>Similarly, extracting the first, third, and fifth entries requires more checks that the values are not <code class="hljs">none</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">d</span><span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">f</span><span class="hljs-title">t</span><span class="hljs-title">h</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Option (Î± Ã Î± Ã Î±) :=
  <span class="hljs-keyword">match</span> xs[<span class="hljs-number">0</span>]? <span class="hljs-keyword">with</span>
  | none =&gt; none
  | some first =&gt;
    <span class="hljs-keyword">match</span> xs[<span class="hljs-number">2</span>]? <span class="hljs-keyword">with</span>
    | none =&gt; none
    | some third =&gt;
      <span class="hljs-keyword">match</span> xs[<span class="hljs-number">4</span>]? <span class="hljs-keyword">with</span>
      | none =&gt; none
      | some fifth =&gt;
        some (first, third, fifth)
</code></pre>
<p>And adding the seventh entry to this sequence begins to become quite unmanageable:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">d</span><span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">f</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">S</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">h</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Option (Î± Ã Î± Ã Î± Ã Î±) :=
  <span class="hljs-keyword">match</span> xs[<span class="hljs-number">0</span>]? <span class="hljs-keyword">with</span>
  | none =&gt; none
  | some first =&gt;
    <span class="hljs-keyword">match</span> xs[<span class="hljs-number">2</span>]? <span class="hljs-keyword">with</span>
    | none =&gt; none
    | some third =&gt;
      <span class="hljs-keyword">match</span> xs[<span class="hljs-number">4</span>]? <span class="hljs-keyword">with</span>
      | none =&gt; none
      | some fifth =&gt;
        <span class="hljs-keyword">match</span> xs[<span class="hljs-number">6</span>]? <span class="hljs-keyword">with</span>
        | none =&gt; none
        | some seventh =&gt;
          some (first, third, fifth, seventh)
</code></pre>
<p>The fundamental problem with this code is that it addresses two concerns: extracting the numbers and checking that all of them are present, but the second concern is addressed by copying and pasting the code that handles the <code class="hljs">none</code> case.
It is often good style to lift a repetitive segment into a helper function:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-params">(opt : Option Î±)</span> <span class="hljs-params">(next : Î± â Option Î²)</span> <span class="hljs-symbol">:</span></span> Option Î² :=
  <span class="hljs-keyword">match</span> opt <span class="hljs-keyword">with</span>
  | none =&gt; none
  | some x =&gt; next x
</code></pre>
<p>This helper, which is used similarly to <code class="hljs">?.</code> in C# and Kotlin, takes care of propagating <code class="hljs">none</code> values.
It takes two arguments: an optional value and a function to apply when the value is not <code class="hljs">none</code>.
If the first argument is <code class="hljs">none</code>, then the helper returns <code class="hljs">none</code>.
If the first argument is not <code class="hljs">none</code>, then the function is applied to the contents of the <code class="hljs">some</code> constructor.</p>
<p>Now, <code class="hljs">firstThird</code> can be rewritten to use <code class="hljs">andThen</code> instead of pattern matching:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">d</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Option (Î± Ã Î±) :=
  andThen xs[<span class="hljs-number">0</span>]? <span class="hljs-keyword">fun</span> first =&gt;
  andThen xs[<span class="hljs-number">2</span>]? <span class="hljs-keyword">fun</span> third =&gt;
  some (first, third)
</code></pre>
<p>In Lean, functions don't need to be enclosed in parentheses when passed as arguments.
The following equivalent definition uses more parentheses and indents the bodies of functions:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">d</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Option (Î± Ã Î±) :=
  andThen xs[<span class="hljs-number">0</span>]? (<span class="hljs-keyword">fun</span> first =&gt;
    andThen xs[<span class="hljs-number">2</span>]? (<span class="hljs-keyword">fun</span> third =&gt;
      some (first, third)))
</code></pre>
<p>The <code class="hljs">andThen</code> helper provides a sort of "pipeline" through which values flow, and the version with the somewhat unusual indentation is more suggestive of this fact.
Improving the syntax used to write <code class="hljs">andThen</code> can make these computations even easier to understand.</p>
<h3 id="infix-operators"><a class="header" href="#infix-operators">Infix Operators</a></h3>
<p>In Lean, infix operators can be declared using the <code class="hljs">infix</code>, <code class="hljs">infixl</code>, and <code class="hljs">infixr</code> commands, which create (respectively) non-associative, left-associative, and right-associative operators.
When used multiple times in a row, a <em>left associative</em> operator stacks up the opening parentheses on the left side of the expression.
The addition operator <code class="hljs">+</code> is left associative, so <code class="hljs">w + x + y + z</code> is equivalent to <code class="hljs">(((w + x) + y) + z)</code>.
The exponentiation operator <code class="hljs">^</code> is right associative, so <code class="hljs">w ^ x ^ y ^ z</code> is equivalent to <code class="hljs">(w ^ (x ^ (y ^ z)))</code>.
Comparison operators such as <code class="hljs">&lt;</code> are non-associative, so <code class="hljs">x &lt; y &lt; z</code> is a syntax error and requires manual parentheses.</p>
<p>The following declaration makes <code class="hljs">andThen</code> into an infix operator:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">infixl</span>:<span class="hljs-number">55</span> <span class="hljs-string">" ~~&gt; "</span> =&gt; andThen
</code></pre>
<p>The number following the colon declares the <em>precedence</em> of the new infix operator.
In ordinary mathematical notation, <code class="hljs">x + y * z</code> is equivalent to <code class="hljs">x + (y * z)</code> even though both <code class="hljs">+</code> and <code class="hljs">*</code> are left associative.
In Lean, <code class="hljs">+</code> has precedence 65 and <code class="hljs">*</code> has precedence 70.
Higher-precedence operators are applied before lower-precedence operators.
According to the declaration of <code class="hljs">~~&gt;</code>, both <code class="hljs">+</code> and <code class="hljs">*</code> have higher precedence, and thus apply first.
Typically, figuring out the most convenient precedences for a group of operators requires some experimentation and a large collection of examples.</p>
<p>Following the new infix operator is a double arrow <code class="hljs">=&gt;</code>, which specifies the named function to be used for the infix operator.
Lean's standard library uses this feature to define <code class="hljs">+</code> and <code class="hljs">*</code> as infix operators that point at <code class="hljs">HAdd.hAdd</code> and <code class="hljs">HMul.hMul</code>, respectively, allowing type classes to be used to overload the infix operators.
Here, however, <code class="hljs">andThen</code> is just an ordinary function.</p>
<p>Having defined an infix operator for <code class="hljs">andThen</code>, <code class="hljs">firstThird</code> can be rewritten in a way that brings the "pipeline" feeling of <code class="hljs">none</code>-checks front and center:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">d</span><span class="hljs-title">I</span><span class="hljs-title">n</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">x</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Option (Î± Ã Î±) :=
  xs[<span class="hljs-number">0</span>]? ~~&gt; <span class="hljs-keyword">fun</span> first =&gt;
  xs[<span class="hljs-number">2</span>]? ~~&gt; <span class="hljs-keyword">fun</span> third =&gt;
  some (first, third)
</code></pre>
<p>This style is much more concise when writing larger functions:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">d</span><span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">f</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">S</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">h</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Option (Î± Ã Î± Ã Î± Ã Î±) :=
  xs[<span class="hljs-number">0</span>]? ~~&gt; <span class="hljs-keyword">fun</span> first =&gt;
  xs[<span class="hljs-number">2</span>]? ~~&gt; <span class="hljs-keyword">fun</span> third =&gt;
  xs[<span class="hljs-number">4</span>]? ~~&gt; <span class="hljs-keyword">fun</span> fifth =&gt;
  xs[<span class="hljs-number">6</span>]? ~~&gt; <span class="hljs-keyword">fun</span> seventh =&gt;
  some (first, third, fifth, seventh)
</code></pre>
<h2 id="propagating-error-messages"><a class="header" href="#propagating-error-messages">Propagating Error Messages</a></h2>
<p>Pure functional languages such as Lean have no built-in exception mechanism for error handling, because throwing or catching an exception is outside of the step-by-step evaluation model for expressions.
However, functional programs certainly need to handle errors.
In the case of <code class="hljs">firstThirdFifthSeventh</code>, it is likely relevant for a user to know just how long the list was and where the lookup failed.</p>
<p>This is typically accomplished by defining a datatype that can be either an error or a result, and translating functions with exceptions into functions that return this datatype:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Except (Îµ : <span class="hljs-built_in">Type</span>) (Î± : <span class="hljs-built_in">Type</span>) <span class="hljs-keyword">where</span>
  | error : Îµ â Except Îµ Î±
  | ok : Î± â Except Îµ Î±
<span class="hljs-keyword">deriving</span> BEq, Hashable, Repr
</code></pre>
<p>The type variable <code class="hljs">Îµ</code> stands for the type of errors that can be produced by the function.
Callers are expected to handle both errors and successes, which makes the type variable <code class="hljs">Îµ</code> play a role that is a bit like that of a list of checked exceptions in Java.</p>
<p>Similarly to <code class="hljs">Option</code>, <code class="hljs">Except</code> can be used to indicate a failure to find an entry in a list.
In this case, the error type is a <code class="hljs">String</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">t</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span> Except String Î± :=
  <span class="hljs-keyword">match</span> xs[i]? <span class="hljs-keyword">with</span>
  | none =&gt; Except.error s!<span class="hljs-string">"Index {i} not found (maximum is {xs.length - 1})"</span>
  | some x =&gt; Except.ok x
</code></pre>
<p>Looking up an in-bounds value yields an <code class="hljs">Except.ok</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">d</span><span class="hljs-title">i</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">P</span><span class="hljs-title">l</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> List String :=
  [<span class="hljs-string">"ramsons"</span>, <span class="hljs-string">"sea plantain"</span>, <span class="hljs-string">"sea buckthorn"</span>, <span class="hljs-string">"garden nasturtium"</span>]

<span class="hljs-keyword">#eval</span> get ediblePlants <span class="hljs-number">2</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Except.ok "sea buckthorn"
</code></pre>
<p>Looking up an out-of-bounds value yields an <code class="hljs">Except.error</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> get ediblePlants <span class="hljs-number">4</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Except.error "Index 4 not found (maximum is 3)"
</code></pre>
<p>A single list lookup can conveniently return a value or an error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Except String Î± :=
  get xs <span class="hljs-number">0</span>
</code></pre>
<p>However, performing two list lookups requires handling potential failures:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">d</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Except String (Î± Ã Î±) :=
  <span class="hljs-keyword">match</span> get xs <span class="hljs-number">0</span> <span class="hljs-keyword">with</span>
  | Except.error msg =&gt; Except.error msg
  | Except.ok first =&gt;
    <span class="hljs-keyword">match</span> get xs <span class="hljs-number">2</span> <span class="hljs-keyword">with</span>
    | Except.error msg =&gt; Except.error msg
    | Except.ok third =&gt;
      Except.ok (first, third)
</code></pre>
<p>Adding another list lookup to the function requires still more error handling:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">d</span><span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">f</span><span class="hljs-title">t</span><span class="hljs-title">h</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Except String (Î± Ã Î± Ã Î±) :=
  <span class="hljs-keyword">match</span> get xs <span class="hljs-number">0</span> <span class="hljs-keyword">with</span>
  | Except.error msg =&gt; Except.error msg
  | Except.ok first =&gt;
    <span class="hljs-keyword">match</span> get xs <span class="hljs-number">2</span> <span class="hljs-keyword">with</span>
    | Except.error msg =&gt; Except.error msg
    | Except.ok third =&gt;
      <span class="hljs-keyword">match</span> get xs <span class="hljs-number">4</span> <span class="hljs-keyword">with</span>
      | Except.error msg =&gt; Except.error msg
      | Except.ok fifth =&gt;
        Except.ok (first, third, fifth)
</code></pre>
<p>And one more list lookup begins to become quite unmanageable:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">d</span><span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">f</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">S</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">h</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Except String (Î± Ã Î± Ã Î± Ã Î±) :=
  <span class="hljs-keyword">match</span> get xs <span class="hljs-number">0</span> <span class="hljs-keyword">with</span>
  | Except.error msg =&gt; Except.error msg
  | Except.ok first =&gt;
    <span class="hljs-keyword">match</span> get xs <span class="hljs-number">2</span> <span class="hljs-keyword">with</span>
    | Except.error msg =&gt; Except.error msg
    | Except.ok third =&gt;
      <span class="hljs-keyword">match</span> get xs <span class="hljs-number">4</span> <span class="hljs-keyword">with</span>
      | Except.error msg =&gt; Except.error msg
      | Except.ok fifth =&gt;
        <span class="hljs-keyword">match</span> get xs <span class="hljs-number">6</span> <span class="hljs-keyword">with</span>
        | Except.error msg =&gt; Except.error msg
        | Except.ok seventh =&gt;
          Except.ok (first, third, fifth, seventh)
</code></pre>
<p>Once again, a common pattern can be factored out into a helper.
Each step through the function checks for an error, and only proceeds with the rest of the computation if the result was a success.
A new version of <code class="hljs">andThen</code> can be defined for <code class="hljs">Except</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-params">(attempt : Except e Î±)</span> <span class="hljs-params">(next : Î± â Except e Î²)</span> <span class="hljs-symbol">:</span></span> Except e Î² :=
  <span class="hljs-keyword">match</span> attempt <span class="hljs-keyword">with</span>
  | Except.error msg =&gt; Except.error msg
  | Except.ok x =&gt; next x
</code></pre>
<p>Just as with <code class="hljs">Option</code>, this version of <code class="hljs">andThen</code> allows a more concise definition of <code class="hljs">firstThird</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">d'</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Except String (Î± Ã Î±) :=
  andThen (get xs <span class="hljs-number">0</span>) <span class="hljs-keyword">fun</span> first  =&gt;
  andThen (get xs <span class="hljs-number">2</span>) <span class="hljs-keyword">fun</span> third =&gt;
  Except.ok (first, third)
</code></pre>
<p>In both the <code class="hljs">Option</code> and <code class="hljs">Except</code> case, there are two repeating patterns: there is the checking of intermediate results at each step, which has been factored out into <code class="hljs">andThen</code>, and there is the final successful result, which is <code class="hljs">some</code> or <code class="hljs">Except.ok</code>, respectively.
For the sake of convenience, success can be factored out into a helper called <code class="hljs">ok</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">o</span><span class="hljs-title">k</span> <span class="hljs-params">(x : Î±)</span> <span class="hljs-symbol">:</span></span> Except Îµ Î± := Except.ok x
</code></pre>
<p>Similarly, failure can be factored out into a helper called <code class="hljs">fail</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span> <span class="hljs-params">(err : Îµ)</span> <span class="hljs-symbol">:</span></span> Except Îµ Î± := Except.error err
</code></pre>
<p>Using <code class="hljs">ok</code> and <code class="hljs">fail</code> makes <code class="hljs">get</code> a little more readable:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">t</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span> Except String Î± :=
  <span class="hljs-keyword">match</span> xs[i]? <span class="hljs-keyword">with</span>
  | none =&gt; fail s!<span class="hljs-string">"Index {i} not found (maximum is {xs.length - 1})"</span>
  | some x =&gt; ok x
</code></pre>
<p>After adding the infix declaration for <code class="hljs">andThen</code>, <code class="hljs">firstThird</code> can be just as concise as the version that returns an <code class="hljs">Option</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">infixl</span>:<span class="hljs-number">55</span> <span class="hljs-string">" ~~&gt; "</span> =&gt; andThen

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">d</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Except String (Î± Ã Î±) :=
  get xs <span class="hljs-number">0</span> ~~&gt; <span class="hljs-keyword">fun</span> first =&gt;
  get xs <span class="hljs-number">2</span> ~~&gt; <span class="hljs-keyword">fun</span> third =&gt;
  ok (first, third)
</code></pre>
<p>The technique scales similarly to larger functions:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">d</span><span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">f</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">S</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">h</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Except String (Î± Ã Î± Ã Î± Ã Î±) :=
  get xs <span class="hljs-number">0</span> ~~&gt; <span class="hljs-keyword">fun</span> first =&gt;
  get xs <span class="hljs-number">2</span> ~~&gt; <span class="hljs-keyword">fun</span> third =&gt;
  get xs <span class="hljs-number">4</span> ~~&gt; <span class="hljs-keyword">fun</span> fifth =&gt;
  get xs <span class="hljs-number">6</span> ~~&gt; <span class="hljs-keyword">fun</span> seventh =&gt;
  ok (first, third, fifth, seventh)
</code></pre>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<p>A number is even if dividing it by 2 leaves no remainder:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">E</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-params">(i : Int)</span> <span class="hljs-symbol">:</span></span> Bool :=
  i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>
</code></pre>
<p>The function <code class="hljs">sumAndFindEvens</code> computes the sum of a list while remembering the even numbers encountered along the way:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">A</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">E</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> List Int â List Int Ã Int
  | [] =&gt; ([], <span class="hljs-number">0</span>)
  | i :: is =&gt;
    <span class="hljs-keyword">let</span> (moreEven, sum) := sumAndFindEvens is
    (<span class="hljs-keyword">if</span> isEven i <span class="hljs-keyword">then</span> i :: moreEven <span class="hljs-keyword">else</span> moreEven, sum + i)
</code></pre>
<p>This function is a simplified example of a common pattern.
Many programs need to traverse a data structure once, while both computing a main result and accumulating some kind of tertiary extra result.
One example of this is logging: a program that is an <code class="hljs">IO</code> action can always log to a file on disk, but because the disk is outside of the mathematical world of Lean functions, it becomes much more difficult to prove things about logs based on <code class="hljs">IO</code>.
Another example is a function that computes the sum of all the nodes in a tree with an inorder traversal, while simultaneously recording each nodes visited:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">S</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> BinTree Int â List Int Ã Int
  | BinTree.leaf =&gt; ([], <span class="hljs-number">0</span>)
  | BinTree.branch l x r =&gt;
    <span class="hljs-keyword">let</span> (leftVisited, leftSum) := inorderSum l
    <span class="hljs-keyword">let</span> (hereVisited, hereSum) := ([x], x)
    <span class="hljs-keyword">let</span> (rightVisited, rightSum) := inorderSum r
    (leftVisited ++ hereVisited ++ rightVisited, leftSum + hereSum + rightSum)
</code></pre>
<p>Both <code class="hljs">sumAndFindEvens</code> and <code class="hljs">inorderSum</code> have a common repetitive structure.
Each step of computation returns a pair that consists of a list of data that have been saved along with the primary result.
The lists are then appended, and the primary result is computed and paired with the appended lists.
The common structure becomes more apparent with a small rewrite of <code class="hljs">sumAndFindEvens</code> that more cleanly separates the concerns of saving even numbers and computing the sum:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">A</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">E</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> List Int â List Int Ã Int
  | [] =&gt; ([], <span class="hljs-number">0</span>)
  | i :: is =&gt;
    <span class="hljs-keyword">let</span> (moreEven, sum) := sumAndFindEvens is
    <span class="hljs-keyword">let</span> (evenHere, ()) := (<span class="hljs-keyword">if</span> isEven i <span class="hljs-keyword">then</span> [i] <span class="hljs-keyword">else</span> [], ())
    (evenHere ++ moreEven, sum + i)
</code></pre>
<p>For the sake of clarity, a pair that consists of an accumulated result together with a value can be given its own name:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">W</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">L</span><span class="hljs-title">o</span><span class="hljs-title">g</span> <span class="hljs-params">(logged : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span></span> <span class="hljs-keyword">where</span>
  log : List logged
  val : Î±
</code></pre>
<p>Similarly, the process of saving a list of accumulated results while passing a value on to the next step of a computation can be factored out into a helper, once again named <code class="hljs">andThen</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-params">(result : WithLog Î± Î²)</span> <span class="hljs-params">(next : Î² â WithLog Î± Î³)</span> <span class="hljs-symbol">:</span></span> WithLog Î± Î³ :=
  <span class="hljs-keyword">let</span> {log := thisOut, val := thisRes} := result
  <span class="hljs-keyword">let</span> {log := nextOut, val := nextRes} := next thisRes
  {log := thisOut ++ nextOut, val := nextRes}
</code></pre>
<p>In the case of errors, <code class="hljs">ok</code> represents an operation that always succeeds.
Here, however, it is an operation that simply returns a value without logging anything:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">o</span><span class="hljs-title">k</span> <span class="hljs-params">(x : Î²)</span> <span class="hljs-symbol">:</span></span> WithLog Î± Î² := {log := [], val := x}
</code></pre>
<p>Just as <code class="hljs">Except</code> provides <code class="hljs">fail</code> as a possibility, <code class="hljs">WithLog</code> should allow items to be added to a log.
This has no interesting return value associated with it, so it returns <code class="hljs">Unit</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">a</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-params">(data : Î±)</span> <span class="hljs-symbol">:</span></span> WithLog Î± Unit :=
  {log := [data], val := ()}
</code></pre>
<p><code class="hljs">WithLog</code>, <code class="hljs">andThen</code>, <code class="hljs">ok</code>, and <code class="hljs">save</code> can be used to separate the logging concern from the summing concern in both programs:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">A</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">E</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> List Int â WithLog Int Int
  | [] =&gt; ok <span class="hljs-number">0</span>
  | i :: is =&gt;
    andThen (<span class="hljs-keyword">if</span> isEven i <span class="hljs-keyword">then</span> save i <span class="hljs-keyword">else</span> ok ()) <span class="hljs-keyword">fun</span> () =&gt;
    andThen (sumAndFindEvens is) <span class="hljs-keyword">fun</span> sum =&gt;
    ok (i + sum)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">S</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> BinTree Int â WithLog Int Int
  | BinTree.leaf =&gt; ok <span class="hljs-number">0</span>
  | BinTree.branch l x r =&gt;
    andThen (inorderSum l) <span class="hljs-keyword">fun</span> leftSum =&gt;
    andThen (save x) <span class="hljs-keyword">fun</span> () =&gt;
    andThen (inorderSum r) <span class="hljs-keyword">fun</span> rightSum =&gt;
    ok (leftSum + x + rightSum)
</code></pre>
<p>And, once again, the infix operator helps put focus on the correct steps:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">infixl</span>:<span class="hljs-number">55</span> <span class="hljs-string">" ~~&gt; "</span> =&gt; andThen

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">A</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">E</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> List Int â WithLog Int Int
  | [] =&gt; ok <span class="hljs-number">0</span>
  | i :: is =&gt;
    (<span class="hljs-keyword">if</span> isEven i <span class="hljs-keyword">then</span> save i <span class="hljs-keyword">else</span> ok ()) ~~&gt; <span class="hljs-keyword">fun</span> () =&gt;
    sumAndFindEvens is ~~&gt; <span class="hljs-keyword">fun</span> sum =&gt;
    ok (i + sum)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">S</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> BinTree Int â WithLog Int Int
  | BinTree.leaf =&gt; ok <span class="hljs-number">0</span>
  | BinTree.branch l x r =&gt;
    inorderSum l ~~&gt; <span class="hljs-keyword">fun</span> leftSum =&gt;
    save x ~~&gt; <span class="hljs-keyword">fun</span> () =&gt;
    inorderSum r ~~&gt; <span class="hljs-keyword">fun</span> rightSum =&gt;
    ok (leftSum + x + rightSum)
</code></pre>
<h2 id="numbering-tree-nodes"><a class="header" href="#numbering-tree-nodes">Numbering Tree Nodes</a></h2>
<p>An <em>inorder numbering</em> of a tree associates each data point in the tree with the step it would be visited at in an inorder traversal of the tree.
For example, consider <code class="hljs">aTree</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> BinTree <span class="hljs-keyword">in</span>
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span>=
  branch
    (branch
       (branch leaf <span class="hljs-string">"a"</span> (branch leaf <span class="hljs-string">"b"</span> leaf))
       <span class="hljs-string">"c"</span>
       leaf)
    <span class="hljs-string">"d"</span>
    (branch leaf <span class="hljs-string">"e"</span> leaf)
</code></pre>
<p>Its inorder numbering is:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">BinTree.branch
  (BinTree.branch
    (BinTree.branch (BinTree.leaf) (0, "a") (BinTree.branch (BinTree.leaf) (1, "b") (BinTree.leaf)))
    (2, "c")
    (BinTree.leaf))
  (3, "d")
  (BinTree.branch (BinTree.leaf) (4, "e") (BinTree.leaf))
</code></pre>
<p>Trees are most naturally processed with recursive functions, but the usual pattern of recursion on trees makes it difficult to compute an inorder numbering.
This is because the highest number assigned anywhere in the left subtree is used to determine the numbering of a node's data value, and then again to determine the starting point for numbering the right subtree.
In an imperative language, this issue can be worked around by using a mutable variable that contains the next number to be assigned.
The following Python program computes an inorder numbering using a mutable variable:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Branch</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, value, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):</span>
        self.left = left
        self.value = value
        self.right = right
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">f'Branch(<span class="hljs-subst">{self.value!r}</span>, left=<span class="hljs-subst">{self.left!r}</span>, right=<span class="hljs-subst">{self.right!r}</span>)'</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">number</span>(<span class="hljs-params">tree</span>):</span>
    num = <span class="hljs-number">0</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helper</span>(<span class="hljs-params">t</span>):</span>
        <span class="hljs-keyword">nonlocal</span> num
        <span class="hljs-keyword">if</span> t <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>
        <span class="hljs-keyword">else</span>:
            new_left = helper(t.left)
            new_value = (num, t.value)
            num += <span class="hljs-number">1</span>
            new_right = helper(t.right)
            <span class="hljs-keyword">return</span> Branch(left=new_left, value=new_value, right=new_right)

    <span class="hljs-keyword">return</span> helper(tree)
</code></pre>
<p>The numbering of the Python equivalent of <code class="hljs">aTree</code> is:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-python hljs">a_tree = Branch(<span class="hljs-string">"d"</span>,
                left=Branch(<span class="hljs-string">"c"</span>,
                            left=Branch(<span class="hljs-string">"a"</span>, left=<span class="hljs-literal">None</span>, right=Branch(<span class="hljs-string">"b"</span>)),
                            right=<span class="hljs-literal">None</span>),
                right=Branch(<span class="hljs-string">"e"</span>))
</code></pre>
<p>and its numbering is:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">&gt;&gt;&gt; number(a_tree)
Branch((3, 'd'), left=Branch((2, 'c'), left=Branch((0, 'a'), left=None, right=Branch((1, 'b'), left=None, right=None)), right=None), right=Branch((4, 'e'), left=None, right=None))
</code></pre>
<p>Even though Lean does not have mutable variables, a workaround exists.
From the point of view of the rest of the world, the mutable variable can be thought of as having two relevant aspects: its value when the function is called, and its value when the function returns.
In other words, a function that uses a mutable variable can be seen as a function that takes the mutable variable's starting value as an argument, returning a pair of the variable's final value and the function's result.
This final value can then be passed as an argument to the next step.</p>
<p>Just as the Python example uses an outer function that establishes a mutable variable and an inner helper function that changes the variable, a Lean version of the function uses an outer function that provides the variable's starting value and explicitly returns the function's result along with an inner helper function that threads the variable's value while computing the numbered tree:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">n</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">b</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(t : BinTree Î±)</span> <span class="hljs-symbol">:</span></span> BinTree (Nat Ã Î±) :=
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> helper (n : Nat) : BinTree Î± â (Nat Ã BinTree (Nat Ã Î±))
    | BinTree.leaf =&gt; (n, BinTree.leaf)
    | BinTree.branch left x right =&gt;
      <span class="hljs-keyword">let</span> (k, numberedLeft) := helper n left
      <span class="hljs-keyword">let</span> (i, numberedRight) := helper (k + <span class="hljs-number">1</span>) right
      (i, BinTree.branch numberedLeft (k, x) numberedRight)
  (helper <span class="hljs-number">0</span> t).snd
</code></pre>
<p>This code, like the <code class="hljs">none</code>-propagating <code class="hljs">Option</code> code, the <code class="hljs">error</code>-propagating <code class="hljs">Except</code> code, and the log-accumulating <code class="hljs">WithLog</code> code, commingles two concerns: propagating the value of the counter, and actually traversing the tree to find the result.
Just as in those cases, an <code class="hljs">andThen</code> helper can be defined to propagate state from one step of a computation to another.
The first step is to give a name to the pattern of taking an input state as an argument and returning an output state together with a value:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">S</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span> <span class="hljs-params">(Ï : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> :=
  Ï â (Ï Ã Î±)
</code></pre>
<p>In the case of <code class="hljs">State</code>, <code class="hljs">ok</code> is a function that returns the input state unchanged, along with the provided value:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">o</span><span class="hljs-title">k</span> <span class="hljs-params">(x : Î±)</span> <span class="hljs-symbol">:</span></span> State Ï Î± :=
  <span class="hljs-keyword">fun</span> s =&gt; (s, x)
</code></pre>
<p>When working with a mutable variable, there are two fundamental operations: reading the value and replacing it with a new one.
Reading the current value is accomplished with a function that places the input state unmodified into the output state, and also places it into the value field:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> State Ï Ï :=
  <span class="hljs-keyword">fun</span> s =&gt; (s, s)
</code></pre>
<p>Writing a new value consists of ignoring the input state, and placing the provided new value into the output state:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">t</span> <span class="hljs-params">(s : Ï)</span> <span class="hljs-symbol">:</span></span> State Ï Unit :=
  <span class="hljs-keyword">fun</span> _ =&gt; (s, ())
</code></pre>
<p>Finally, two computations that use state can be sequenced by finding both the output state and return value of the first function, then passing them both into the next function:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-params">(first : State Ï Î±)</span> <span class="hljs-params">(next : Î± â State Ï Î²)</span> <span class="hljs-symbol">:</span></span> State Ï Î² :=
  <span class="hljs-keyword">fun</span> s =&gt;
    <span class="hljs-keyword">let</span> (s', x) := first s
    next x s'

<span class="hljs-keyword">infixl</span>:<span class="hljs-number">55</span> <span class="hljs-string">" ~~&gt; "</span> =&gt; andThen
</code></pre>
<p>Using <code class="hljs">State</code> and its helpers, local mutable state can be simulated:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">n</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">b</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(t : BinTree Î±)</span> <span class="hljs-symbol">:</span></span> BinTree (Nat Ã Î±) :=
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> helper : BinTree Î± â State Nat (BinTree (Nat Ã Î±))
    | BinTree.leaf =&gt; ok BinTree.leaf
    | BinTree.branch left x right =&gt;
      helper left ~~&gt; <span class="hljs-keyword">fun</span> numberedLeft =&gt;
      get ~~&gt; <span class="hljs-keyword">fun</span> n =&gt;
      set (n + <span class="hljs-number">1</span>) ~~&gt; <span class="hljs-keyword">fun</span> () =&gt;
      helper right ~~&gt; <span class="hljs-keyword">fun</span> numberedRight =&gt;
      ok (BinTree.branch numberedLeft (n, x) numberedRight)
  (helper t <span class="hljs-number">0</span>).snd
</code></pre>
<p>Because <code class="hljs">State</code> simulates only a single local variable, <code class="hljs">get</code> and <code class="hljs">set</code> don't need to refer to any particular variable name.</p>
<h2 id="monads-a-functional-design-pattern"><a class="header" href="#monads-a-functional-design-pattern">Monads: A Functional Design Pattern</a></h2>
<p>Each of these examples has consisted of:</p>
<ul>
<li>A polymorphic type, such as <code class="hljs">Option</code>, <code class="hljs">Except Îµ</code>, <code class="hljs">WithLog logged</code>, or <code class="hljs">State Ï</code></li>
<li>An operator <code class="hljs">andThen</code> that takes care of some repetitive aspect of sequencing programs that have this type</li>
<li>An operator <code class="hljs">ok</code> that is (in some sense) the most boring way to use the type</li>
<li>A collection of other operations, such as <code class="hljs">none</code>, <code class="hljs">fail</code>, <code class="hljs">save</code>, and <code class="hljs">get</code>, that name ways of using the type</li>
</ul>
<p>This style of API is called a <em>monad</em>.
While the idea of monads is derived from a branch of mathematics called category theory, no understanding of category theory is needed in order to use them for programming.
The key idea of monads is that each monad encodes a particular kind of side effect using the tools provided by the pure functional language Lean.
For example, <code class="hljs">Option</code> represents programs that can fail by returning <code class="hljs">none</code>, <code class="hljs">Except</code> represents programs that can throw exceptions, <code class="hljs">WithLog</code> represents programs that accumulate a log while running, and <code class="hljs">State</code> represents programs with a single mutable variable.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="the-monad-type-class"><a class="header" href="#the-monad-type-class">The Monad Type Class</a></h1>
<p>Rather than having to import an operator like <code class="hljs">ok</code> or <code class="hljs">andThen</code> for each type that is a monad, the Lean standard library contains a type class that allow them to be overloaded, so that the same operators can be used for <em>any</em> monad.
Monads have two operations, which are the equivalent of <code class="hljs">ok</code> and <code class="hljs">andThen</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">M</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">a</span><span class="hljs-title">d</span> <span class="hljs-params">(m : <span class="hljs-built_in">Type</span> â <span class="hljs-built_in">Type</span>)</span></span> <span class="hljs-keyword">where</span>
  pure : Î± â m Î±
  bind : m Î± â (Î± â m Î²) â m Î²
</code></pre>
<p>This definition is slightly simplified.
The actual definition in the Lean library is somewhat more involved, and will be presented later.</p>
<p>The <code class="hljs">Monad</code> instances for <code class="hljs">Option</code> and <code class="hljs">Except</code> can be created by adapting the definitions of their respective <code class="hljs">andThen</code> operations:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Monad Option <span class="hljs-keyword">where</span>
  pure x := some x
  bind opt next :=
    <span class="hljs-keyword">match</span> opt <span class="hljs-keyword">with</span>
    | none =&gt; none
    | some x =&gt; next x

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Monad (Except Îµ) <span class="hljs-keyword">where</span>
  pure x := Except.ok x
  bind attempt next :=
    <span class="hljs-keyword">match</span> attempt <span class="hljs-keyword">with</span>
    | Except.error e =&gt; Except.error e
    | Except.ok x =&gt; next x
</code></pre>
<p>As an example, <code class="hljs">firstThirdFifthSeventh</code> was defined separately for <code class="hljs">Option Î±</code> and <code class="hljs">Except String Î±</code> return types.
Now, it can be defined polymorphically for <em>any</em> monad.
It does, however, require a lookup function as an argument, because different monads might fail to find a result in different ways.
The infix version of <code class="hljs">bind</code> is <code class="hljs">&gt;&gt;=</code>, which plays the same role as <code class="hljs">~~&gt;</code> in the examples.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">d</span><span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">f</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">S</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">h</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">(lookup : List Î± â Nat â m Î±)</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> m (Î± Ã Î± Ã Î± Ã Î±) :=
  lookup xs <span class="hljs-number">0</span> &gt;&gt;= <span class="hljs-keyword">fun</span> first =&gt;
  lookup xs <span class="hljs-number">2</span> &gt;&gt;= <span class="hljs-keyword">fun</span> third =&gt;
  lookup xs <span class="hljs-number">4</span> &gt;&gt;= <span class="hljs-keyword">fun</span> fifth =&gt;
  lookup xs <span class="hljs-number">6</span> &gt;&gt;= <span class="hljs-keyword">fun</span> seventh =&gt;
  pure (first, third, fifth, seventh)
</code></pre>
<p>Given example lists of slow mammals and fast birds, this implementation of <code class="hljs">firstThirdFifthSeventh</code> can be used with <code class="hljs">Option</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">l</span><span class="hljs-title">ow</span><span class="hljs-title">M</span><span class="hljs-title">a</span><span class="hljs-title">m</span><span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> List String :=
  [<span class="hljs-string">"Three-toed sloth"</span>, <span class="hljs-string">"Slow loris"</span>]

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">a</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">B</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">d</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> List String := [
  <span class="hljs-string">"Peregrine falcon"</span>,
  <span class="hljs-string">"Saker falcon"</span>,
  <span class="hljs-string">"Golden eagle"</span>,
  <span class="hljs-string">"Gray-headed albatross"</span>,
  <span class="hljs-string">"Spur-winged goose"</span>,
  <span class="hljs-string">"Swift"</span>,
  <span class="hljs-string">"Anna's hummingbird"</span>
]

<span class="hljs-keyword">#eval</span> firstThirdFifthSeventh (<span class="hljs-keyword">fun</span> xs i =&gt; xs[i]?) slowMammals
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">none
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> firstThirdFifthSeventh (<span class="hljs-keyword">fun</span> xs i =&gt; xs[i]?) fastBirds
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">some ("Peregrine falcon", "Golden eagle", "Spur-winged goose", "Anna's hummingbird")
</code></pre>
<p>After renaming <code class="hljs">Except</code>'s lookup function <code class="hljs">get</code> to something more specific, the very same  implementation of <code class="hljs">firstThirdFifthSeventh</code> can be used with <code class="hljs">Except</code> as well:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">O</span><span class="hljs-title">r</span><span class="hljs-title">E</span><span class="hljs-title">x</span><span class="hljs-title">c</span><span class="hljs-title">e</span><span class="hljs-title">p</span><span class="hljs-title">t</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span> Except String Î± :=
  <span class="hljs-keyword">match</span> xs[i]? <span class="hljs-keyword">with</span>
  | none =&gt; Except.error s!<span class="hljs-string">"Index {i} not found (maximum is {xs.length - 1})"</span>
  | some x =&gt; Except.ok x

<span class="hljs-keyword">#eval</span> firstThirdFifthSeventh getOrExcept slowMammals
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Except.error "Index 2 not found (maximum is 1)"
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> firstThirdFifthSeventh getOrExcept fastBirds
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Except.ok ("Peregrine falcon", "Golden eagle", "Spur-winged goose", "Anna's hummingbird")
</code></pre>
<p>The fact that <code class="hljs">m</code> must have a <code class="hljs">Monad</code> instance means that the <code class="hljs">&gt;&gt;=</code> and <code class="hljs">pure</code> operations are available.</p>
<h2 id="general-monad-operations"><a class="header" href="#general-monad-operations">General Monad Operations</a></h2>
<p>Because many different types are monads, functions that are polymorphic over <em>any</em> monad are very powerful.
For example, the function <code class="hljs">mapM</code> is a version of <code class="hljs">map</code> that uses a <code class="hljs">Monad</code> to sequence and combine the results of applying a function:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">M</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">(f : Î± â m Î²)</span> <span class="hljs-symbol">:</span></span> List Î± â m (List Î²)
  | [] =&gt; pure []
  | x :: xs =&gt;
    f x &gt;&gt;= <span class="hljs-keyword">fun</span> hd =&gt;
    mapM f xs &gt;&gt;= <span class="hljs-keyword">fun</span> tl =&gt;
    pure (hd :: tl)
</code></pre>
<p>The return type of the function argument <code class="hljs">f</code> determines which <code class="hljs">Monad</code> instance will be used.
In other words, <code class="hljs">mapM</code> can be used for functions that produce logs, for functions that can fail, or for functions that use mutable state.
Because <code class="hljs">f</code>'s type determines the available effects, they can be tightly controlled by API designers.</p>
<p>As described in <a href="https://leanprover.github.io/functional_programming_in_lean/monads.html#numbering-tree-nodes">this chapter's introduction</a>, <code class="hljs">State Ï Î±</code> represents programs that make use of a mutable variable of type <code class="hljs">Ï</code> and return a value of type <code class="hljs">Î±</code>.
These programs are actually functions from a starting state to a pair of a value and a final state.
The <code class="hljs">Monad</code> class requires that its parameter expect a single type argumentâthat is, it should be a <code class="hljs">Type â Type</code>.
This means that the instance for <code class="hljs">State</code> should mention the state type <code class="hljs">Ï</code>, which becomes a parameter to the instance:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Monad (State Ï) <span class="hljs-keyword">where</span>
  pure x := <span class="hljs-keyword">fun</span> s =&gt; (s, x)
  bind first next :=
    <span class="hljs-keyword">fun</span> s =&gt;
      <span class="hljs-keyword">let</span> (s', x) := first s
      next x s'
</code></pre>
<p>This means that the type of the state cannot change between calls to <code class="hljs">get</code> and <code class="hljs">set</code> that are sequenced using <code class="hljs">bind</code>, which is a reasonable rule for stateful computations.
The operator <code class="hljs">increment</code> increases a saved state by a given amount, returning the old value:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">c</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-params">(howMuch : Int)</span> <span class="hljs-symbol">:</span></span> State Int Int :=
  get &gt;&gt;= <span class="hljs-keyword">fun</span> i =&gt;
  set (i + howMuch) &gt;&gt;= <span class="hljs-keyword">fun</span> () =&gt;
  pure i
</code></pre>
<p>Using <code class="hljs">mapM</code> with <code class="hljs">increment</code> results in a program that computes the sum of the entries in a list.
More specifically, the mutable variable contains the sum so far, while the resulting list contains a running sum.
In other words, <code class="hljs">mapM increment</code> has type <code class="hljs">List Int â State Int (List Int)</code>, and expanding the definition of <code class="hljs">State</code> yields <code class="hljs">List Int â Int â (Int Ã List Int)</code>.
It takes an initial sum as an argument, which should be <code class="hljs">0</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> mapM increment [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>] <span class="hljs-number">0</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">(15, [0, 1, 3, 6, 10])
</code></pre>
<p>A <a href="https://leanprover.github.io/functional_programming_in_lean/monads.html#logging">logging effect</a> can be represented using <code class="hljs">WithLog</code>.
Just like <code class="hljs">State</code>, its <code class="hljs">Monad</code> instance is polymorphic with respect to the type of the logged data:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Monad (WithLog logged) <span class="hljs-keyword">where</span>
  pure x := {log := [], val := x}
  bind result next :=
    <span class="hljs-keyword">let</span> {log := thisOut, val := thisRes} := result
    <span class="hljs-keyword">let</span> {log := nextOut, val := nextRes} := next thisRes
    {log := thisOut ++ nextOut, val := nextRes}
</code></pre>
<p><code class="hljs">saveIfEven</code> is a function that logs even numbers but returns its argument unchanged:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">a</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">I</span><span class="hljs-title">f</span><span class="hljs-title">E</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-params">(i : Int)</span> <span class="hljs-symbol">:</span></span> WithLog Int Int :=
  (<span class="hljs-keyword">if</span> isEven i <span class="hljs-keyword">then</span>
    save i
   <span class="hljs-keyword">else</span> pure ()) &gt;&gt;= <span class="hljs-keyword">fun</span> () =&gt;
  pure i
</code></pre>
<p>Using this function with <code class="hljs">mapM</code> results in a log containing even numbers paired with an unchanged input list:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> mapM saveIfEven [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">{ log := [2, 4], val := [1, 2, 3, 4, 5] }
</code></pre>
<h2 id="the-identity-monad"><a class="header" href="#the-identity-monad">The Identity Monad</a></h2>
<p>Monads encode programs with effects, such as failure, exceptions, or logging, into explicit representations as data and functions.
Sometimes, however, an API will be written to use a monad for flexibility, but the API's client may not require any encoded effects.
The <em>identity monad</em> is a monad that has no effects, and allows pure code to be used with monadic APIs:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">I</span><span class="hljs-title">d</span> <span class="hljs-params">(t : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> := t

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Monad Id <span class="hljs-keyword">where</span>
  pure x := x
  bind x f := f x
</code></pre>
<p>The type of <code class="hljs">pure</code> should be <code class="hljs">Î± â Id Î±</code>, but <code class="hljs">Id Î±</code> reduces to just <code class="hljs">Î±</code>.
Similarly, the type of <code class="hljs">bind</code> should be <code class="hljs">Î± â (Î± â Id Î²) â Id Î²</code>.
Because this reduces to <code class="hljs">Î± â (Î± â Î²) â Î²</code>, the second argument can be applied to the first to find the result.</p>
<p>With the identity monad, <code class="hljs">mapM</code> becomes equivalent to <code class="hljs">map</code>.
To call it this way, however, Lean requires a hint that the intended monad is <code class="hljs">Id</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> mapM (m := Id) (Â· + <span class="hljs-number">1</span>) [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">[2, 3, 4, 5, 6]
</code></pre>
<p>Omitting the hint results in an error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> mapM (Â· + <span class="hljs-number">1</span>) [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to synthesize instance
  HAdd Nat Nat (?m.9063 ?m.9065)
</code></pre>
<p>In this error, the application of one metavariable to another indicates that Lean doesn't run the type-level computation backwards.
The return type of the function is expected to be the monad applied to some other type.
Similarly, using <code class="hljs">mapM</code> with a function whose type doesn't provide any specific hints about which monad is to be used results in an "instance problem stuck" message:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> mapM (<span class="hljs-keyword">fun</span> x =&gt; x) [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">typeclass instance problem is stuck, it is often due to metavariables
  Monad ?m.9063
</code></pre>
<h2 id="the-monad-contract"><a class="header" href="#the-monad-contract">The Monad Contract</a></h2>
<p>Just as every pair of instances of <code class="hljs">BEq</code> and <code class="hljs">Hashable</code> should ensure that any two equal values have the same hash, there is a contract that each instance of <code class="hljs">Monad</code> should obey.
First, <code class="hljs">pure</code> should be a left identity of <code class="hljs">bind</code>.
That is, <code class="hljs">bind (pure v) f</code> should be the same as <code class="hljs">f v</code>.
Secondly, <code class="hljs">pure</code> should be a right identity of <code class="hljs">bind</code>, so <code class="hljs">bind v pure</code> is the same as <code class="hljs">v</code>.
Finally, <code class="hljs">bind</code> should be associative, so <code class="hljs">bind (bind v f) g</code> is the same as <code class="hljs">bind v (fun x =&gt; bind (f x) g)</code>.</p>
<p>This contract specifies the expected properties of programs with effects more generally.
Because <code class="hljs">pure</code> has no effects, sequencing its effects with <code class="hljs">bind</code> shouldn't change the result.
The associative property of <code class="hljs">bind</code> basically says that the sequencing bookkeeping itself doesn't matter, so long as the order in which things are happening is preserved.</p>
<h2 id="exercises-9"><a class="header" href="#exercises-9">Exercises</a></h2>
<h3 id="mapping-on-a-tree"><a class="header" href="#mapping-on-a-tree">Mapping on a Tree</a></h3>
<p>Define a function <code class="hljs">BinTree.mapM</code>.
By analogy to <code class="hljs">mapM</code> for lists, this function should apply a monadic function to each data entry in a tree, as a preorder traversal.
The type signature should be:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">def BinTree.mapM [Monad m] (f : Î± â m Î²) : BinTree Î± â m (BinTree Î²)
</code></pre>
<h3 id="the-option-monad-contract"><a class="header" href="#the-option-monad-contract">The Option Monad Contract</a></h3>
<p>First, write a convincing argument that the <code class="hljs">Monad</code> instance for <code class="hljs">Option</code> satisfies the monad contract.
Then, consider the following instance:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Monad Option <span class="hljs-keyword">where</span>
  pure x := some x
  bind opt next := none
</code></pre>
<p>Both methods have the correct type.
Why does this instance violate the monad contract?</p>
<div style="break-before:page;page-break-before:always"></div><h2 id="example-arithmetic-in-monads"><a class="header" href="#example-arithmetic-in-monads">Example: Arithmetic in Monads</a></h2>
<p>Monads are a way of encoding programs with side effects into a language that does not have them.
It would be easy to read this as a sort of admission that pure functional programs are missing something important, requiring programmers to jump through hoops just to write a normal program.
However, while using the <code class="hljs">Monad</code> API does impose a syntactic cost on a program, it brings two important benefits:</p>
<ol>
<li>Programs must be honest about which effects they use in their types. A quick glance at a type signature describes <em>everything</em> that the program can do, rather than just what it accepts and what it returns.</li>
<li>Not every language provides the same effects. For example, only some language have exceptions. Other languages have unique, exotic effects, such as <a href="https://www2.cs.arizona.edu/icon/">Icon's searching over multiple values</a> and Scheme or Ruby's continuations. Because monads can encode <em>any</em> effect, programmers can choose which ones are the best fit for a given application, rather than being stuck with what the language developers provided.</li>
</ol>
<p>One example of a program that can make sense in a variety of monads is an evaluator for arithmetic expressions.</p>
<h3 id="arithmetic-expressions"><a class="header" href="#arithmetic-expressions">Arithmetic Expressions</a></h3>
<p>An arithmetic expression is either a literal integer or a primitive binary operator applied to two expressions. The operators are addition, subtraction, multiplication, and division:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Expr (op : <span class="hljs-built_in">Type</span>) <span class="hljs-keyword">where</span>
  | const : Int â Expr op
  | prim : op â Expr op â Expr op â Expr op


<span class="hljs-keyword">inductive</span> Arith <span class="hljs-keyword">where</span>
  | plus
  | minus
  | times
  | div
</code></pre>
<p>The expression <code class="hljs">2 + 3</code> is represented:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> Expr <span class="hljs-keyword">in</span>
<span class="hljs-keyword">open</span> Arith <span class="hljs-keyword">in</span>
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">tw</span><span class="hljs-title">o</span><span class="hljs-title">P</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Expr Arith :=
  prim plus (const <span class="hljs-number">2</span>) (const <span class="hljs-number">3</span>)
</code></pre>
<p>and <code class="hljs">14 / (45 - 5 * 9)</code> is represented:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> Expr <span class="hljs-keyword">in</span>
<span class="hljs-keyword">open</span> Arith <span class="hljs-keyword">in</span>
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">D</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">i</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">d</span> <span class="hljs-symbol">:</span></span> Expr Arith :=
  prim div (const <span class="hljs-number">14</span>) (prim minus (const <span class="hljs-number">45</span>) (prim times (const <span class="hljs-number">5</span>) (const <span class="hljs-number">9</span>)))
</code></pre>
<h3 id="evaluating-expressions-2"><a class="header" href="#evaluating-expressions-2">Evaluating Expressions</a></h3>
<p>Because expressions include division, and division by zero is undefined, evaluation might fail.
One way to represent failure is to use <code class="hljs">Option</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">O</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> Expr Arith â Option Int
  | Expr.const i =&gt; pure i
  | Expr.prim p e1 e2 =&gt;
    evaluateOption e1 &gt;&gt;= <span class="hljs-keyword">fun</span> v1 =&gt;
    evaluateOption e2 &gt;&gt;= <span class="hljs-keyword">fun</span> v2 =&gt;
    <span class="hljs-keyword">match</span> p <span class="hljs-keyword">with</span>
    | Arith.plus =&gt; pure (v1 + v2)
    | Arith.minus =&gt; pure (v1 - v2)
    | Arith.times =&gt; pure (v1 * v2)
    | Arith.div =&gt; <span class="hljs-keyword">if</span> v2 == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> none <span class="hljs-keyword">else</span> pure (v1 / v2)
</code></pre>
<p>This definition uses the <code class="hljs">Monad Option</code> instance to propagate failures from evaluating both branches of a binary operator.
However, the function mixes two concerns: evaluating subexpressions and applying a binary operator to the results.
It can be improved by splitting it into two functions:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">y</span><span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> Arith â Int â Int â Option Int
  | Arith.plus, x, y =&gt; pure (x + y)
  | Arith.minus, x, y =&gt; pure (x - y)
  | Arith.times, x, y =&gt; pure (x * y)
  | Arith.div, x, y =&gt; <span class="hljs-keyword">if</span> y == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> none <span class="hljs-keyword">else</span> pure (x / y)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">O</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> Expr Arith â Option Int
  | Expr.const i =&gt; pure i
  | Expr.prim p e1 e2 =&gt;
    evaluateOption e1 &gt;&gt;= <span class="hljs-keyword">fun</span> v1 =&gt;
    evaluateOption e2 &gt;&gt;= <span class="hljs-keyword">fun</span> v2 =&gt;
    applyPrim p v1 v2
</code></pre>
<p>Running <code class="hljs">#eval evaluateOption fourteenDivided</code> yields <code class="hljs">none</code>, as expected, but this is not a very useful error message.
Because the code was written using <code class="hljs">&gt;&gt;=</code> rather than by explicitly handling the <code class="hljs">none</code> constructor, only a small modification is required for it to provide an error message on failure:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">y</span><span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> Arith â Int â Int â Except String Int
  | Arith.plus, x, y =&gt; pure (x + y)
  | Arith.minus, x, y =&gt; pure (x - y)
  | Arith.times, x, y =&gt; pure (x * y)
  | Arith.div, x, y =&gt;
    <span class="hljs-keyword">if</span> y == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>
      Except.error s!<span class="hljs-string">"Tried to divide {x} by zero"</span>
    <span class="hljs-keyword">else</span> pure (x / y)


<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">E</span><span class="hljs-title">x</span><span class="hljs-title">c</span><span class="hljs-title">e</span><span class="hljs-title">p</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> Expr Arith â Except String Int
  | Expr.const i =&gt; pure i
  | Expr.prim p e1 e2 =&gt;
    evaluateExcept e1 &gt;&gt;= <span class="hljs-keyword">fun</span> v1 =&gt;
    evaluateExcept e2 &gt;&gt;= <span class="hljs-keyword">fun</span> v2 =&gt;
    applyPrim p v1 v2
</code></pre>
<p>The only difference is that the type signature mentions <code class="hljs">Except String</code> instead of <code class="hljs">Option</code>, and the failing case uses <code class="hljs">Except.error</code> instead of <code class="hljs">none</code>.
By making <code class="hljs">evaluate</code> polymorphic over its monad and passing it <code class="hljs">applyPrim</code> as an argument, a single evaluator becomes capable of both forms of error reporting:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">y</span><span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">m</span><span class="hljs-title">O</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> Arith â Int â Int â Option Int
  | Arith.plus, x, y =&gt; pure (x + y)
  | Arith.minus, x, y =&gt; pure (x - y)
  | Arith.times, x, y =&gt; pure (x * y)
  | Arith.div, x, y =&gt;
    <span class="hljs-keyword">if</span> y == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>
      none
    <span class="hljs-keyword">else</span> pure (x / y)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">y</span><span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">m</span><span class="hljs-title">E</span><span class="hljs-title">x</span><span class="hljs-title">c</span><span class="hljs-title">e</span><span class="hljs-title">p</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> Arith â Int â Int â Except String Int
  | Arith.plus, x, y =&gt; pure (x + y)
  | Arith.minus, x, y =&gt; pure (x - y)
  | Arith.times, x, y =&gt; pure (x * y)
  | Arith.div, x, y =&gt;
    <span class="hljs-keyword">if</span> y == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>
      Except.error s!<span class="hljs-string">"Tried to divide {x} by zero"</span>
    <span class="hljs-keyword">else</span> pure (x / y)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">M</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">(applyPrim : Arith â Int â Int â m Int)</span><span class="hljs-symbol">:</span></span> Expr Arith â m Int
  | Expr.const i =&gt; pure i
  | Expr.prim p e1 e2 =&gt;
    evaluateM applyPrim e1 &gt;&gt;= <span class="hljs-keyword">fun</span> v1 =&gt;
    evaluateM applyPrim e2 &gt;&gt;= <span class="hljs-keyword">fun</span> v2 =&gt;
    applyPrim p v1 v2
</code></pre>
<p>Using it with <code class="hljs">applyPrimOption</code> works just like the first version of <code class="hljs">evaluate</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> evaluateM applyPrimOption fourteenDivided
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">none
</code></pre>
<p>Similarly, using it with <code class="hljs">applyPrimExcept</code> works just like the version with error messages:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> evaluateM applyPrimExcept fourteenDivided
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Except.error "Tried to divide 14 by zero"
</code></pre>
<p>The code can still be improved.
The functions <code class="hljs">applyPrimOption</code> and <code class="hljs">applyPrimExcept</code> differ only in their treatment of division, which can be extracted into another parameter to the evaluator:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">y</span><span class="hljs-title">D</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">O</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span> <span class="hljs-params">(x : Int)</span> <span class="hljs-params">(y : Int)</span> <span class="hljs-symbol">:</span></span> Option Int :=
    <span class="hljs-keyword">if</span> y == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>
      none
    <span class="hljs-keyword">else</span> pure (x / y)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">y</span><span class="hljs-title">D</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">E</span><span class="hljs-title">x</span><span class="hljs-title">c</span><span class="hljs-title">e</span><span class="hljs-title">p</span><span class="hljs-title">t</span> <span class="hljs-params">(x : Int)</span> <span class="hljs-params">(y : Int)</span> <span class="hljs-symbol">:</span></span> Except String Int :=
    <span class="hljs-keyword">if</span> y == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>
      Except.error s!<span class="hljs-string">"Tried to divide {x} by zero"</span>
    <span class="hljs-keyword">else</span> pure (x / y)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">y</span><span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">m</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">(applyDiv : Int â Int â m Int)</span> <span class="hljs-symbol">:</span></span> Arith â Int â Int â m Int
  | Arith.plus, x, y =&gt; pure (x + y)
  | Arith.minus, x, y =&gt; pure (x - y)
  | Arith.times, x, y =&gt; pure (x * y)
  | Arith.div, x, y =&gt; applyDiv x y

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">M</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">(applyDiv : Int â Int â m Int)</span><span class="hljs-symbol">:</span></span> Expr Arith â m Int
  | Expr.const i =&gt; pure i
  | Expr.prim p e1 e2 =&gt;
    evaluateM applyDiv e1 &gt;&gt;= <span class="hljs-keyword">fun</span> v1 =&gt;
    evaluateM applyDiv e2 &gt;&gt;= <span class="hljs-keyword">fun</span> v2 =&gt;
    applyPrim applyDiv p v1 v2
</code></pre>
<p>In this refactored code, the fact that the two code paths differ only in their treatment of failure has been made fully apparent.</p>
<h3 id="further-effects"><a class="header" href="#further-effects">Further Effects</a></h3>
<p>Failure and exceptions are not the only kinds of effects that can be interesting when working with an evaluator.
While division's only side effect is failure, adding other primitive operators to the expressions make it possible to express other effects.</p>
<p>The first step is an additional refactoring, extracting division from the datatype of primitives:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Prim (special : <span class="hljs-built_in">Type</span>) <span class="hljs-keyword">where</span>
  | plus
  | minus
  | times
  | other : special â Prim special

<span class="hljs-keyword">inductive</span> CanFail <span class="hljs-keyword">where</span>
  | div
</code></pre>
<p>The name <code class="hljs">CanFail</code> suggests that the effect introduced by division is potential failure.</p>
<p>The second step is to broaden the scope of the division handler argument to <code class="hljs">evaluateM</code> so that it can process any special operator:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">O</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> CanFail â Int â Int â Option Int
  | CanFail.div, x, y =&gt; <span class="hljs-keyword">if</span> y == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> none <span class="hljs-keyword">else</span> pure (x / y)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">E</span><span class="hljs-title">x</span><span class="hljs-title">c</span><span class="hljs-title">e</span><span class="hljs-title">p</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> CanFail â Int â Int â Except String Int
  | CanFail.div, x, y =&gt;
    <span class="hljs-keyword">if</span> y == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>
      Except.error s!<span class="hljs-string">"Tried to divide {x} by zero"</span>
    <span class="hljs-keyword">else</span> pure (x / y)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">y</span><span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">m</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">(applySpecial : special â Int â Int â m Int)</span> <span class="hljs-symbol">:</span></span> Prim special â Int â Int â m Int
  | Prim.plus, x, y =&gt; pure (x + y)
  | Prim.minus, x, y =&gt; pure (x - y)
  | Prim.times, x, y =&gt; pure (x * y)
  | Prim.other op, x, y =&gt; applySpecial op x y

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">M</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">(applySpecial : special â Int â Int â m Int)</span><span class="hljs-symbol">:</span></span> Expr (Prim special) â m Int
  | Expr.const i =&gt; pure i
  | Expr.prim p e1 e2 =&gt;
    evaluateM applySpecial e1 &gt;&gt;= <span class="hljs-keyword">fun</span> v1 =&gt;
    evaluateM applySpecial e2 &gt;&gt;= <span class="hljs-keyword">fun</span> v2 =&gt;
    applyPrim applySpecial p v1 v2
</code></pre>
<h4 id="no-effects"><a class="header" href="#no-effects">No Effects</a></h4>
<p>The type <code class="hljs">Empty</code> has no constructors, and thus no values, like the <code class="hljs">Nothing</code> type in Scala or Kotlin.
In Scala and Kotlin, <code class="hljs">Nothing</code> can represent computations that never return a result, such as functions that crash the program, throw exceptions, or always fall into infinite loops.
An argument to a function or method of type <code class="hljs">Nothing</code> indicates dead code, as there will never be a suitable argument value.
Lean doesn't support infinite loops and exceptions, but <code class="hljs">Empty</code> is still useful as an indication to the type system that a function cannot be called.
Using the syntax <code class="hljs">nomatch E</code> when <code class="hljs">E</code> is an expression whose type has no constructors indicates to Lean that the current expression need not return a result, because it could never have been called. </p>
<p>Using <code class="hljs">Empty</code> as the parameter to <code class="hljs">Prim</code> indicates that there are no additional cases beyond <code class="hljs">Prim.plus</code>, <code class="hljs">Prim.minus</code>, and <code class="hljs">Prim.times</code>, because it is impossible to come up with a value of type <code class="hljs">Empty</code> to place in the <code class="hljs">Prim.other</code> constructor.
Because a function to apply an operator of type <code class="hljs">Empty</code> to two integers can never be called, it doesn't need to return a result.
Thus, it can be used in <em>any</em> monad:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">y</span><span class="hljs-title">E</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">y</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">(op : Empty)</span> <span class="hljs-params">(_ : Int)</span> <span class="hljs-params">(_ : Int)</span> <span class="hljs-symbol">:</span></span> m Int :=
  <span class="hljs-keyword">nomatch</span> op
</code></pre>
<p>This can be used together with <code class="hljs">Id</code>, the identity monad, to evaluate expressions that have no effects whatsoever:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> Expr Prim <span class="hljs-keyword">in</span>
<span class="hljs-keyword">#eval</span> evaluateM (m := Id) applyEmpty (prim plus (const <span class="hljs-number">5</span>) (const (-<span class="hljs-number">14</span>)))
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">-9
</code></pre>
<h4 id="nondeterministic-search"><a class="header" href="#nondeterministic-search">Nondeterministic Search</a></h4>
<p>Instead of simply failing when encountering division by zero, it would also be sensible to backtrack and try a different input.
Given the right monad, the very same <code class="hljs">evaluateM</code> can perform a nondeterministic search for a <em>set</em> of answers that do not result in failure.
This requires, in addition to division, some means of specifying a choice of results.
One way to do this is to add a function <code class="hljs">choose</code> to the language of expressions that instructs the evaluator to pick either of its arguments while searching for non-failing results.</p>
<p>The result of the evaluator is now a multiset of values, rather than a single value.
The rules for evaluation into a multiset are:</p>
<ul>
<li>Constants <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-31-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-111" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-112"><span class="mi" id="MathJax-Span-113" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span> evaluate to singleton sets <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-32-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>n</mi></mrow></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-114" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-115"><span class="texatom" id="MathJax-Span-116"><span class="mrow" id="MathJax-Span-117"><span class="mi" id="MathJax-Span-118" style="font-family:MathJax_Math;font-style:italic">n</span></span></span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></math></span></span>.</li>
<li>Arithmetic operators other than division are called on each pair from the Cartesian product of the operators, so <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-33-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>X</mi><mo>+</mo><mi>Y</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-119" style="width:3.631em;display:inline-block"><span style="display:inline-block;position:relative;width:2.905em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1002.9em,2.583em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-120"><span class="mi" id="MathJax-Span-121" style="font-family:MathJax_Math;font-style:italic">X<span style="display:inline-block;overflow:hidden;height:1px;width:0.042em"></span></span><span class="mo" id="MathJax-Span-122" style="font-family:MathJax_Main;padding-left:0.244em">+</span><span class="mi" id="MathJax-Span-123" style="font-family:MathJax_Math;font-style:italic;padding-left:0.244em">Y<span style="display:inline-block;overflow:hidden;height:1px;width:0.204em"></span></span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.148em;border-left:0px solid;width:0px;height:1.052em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi><mo>+</mo><mi>Y</mi></math></span></span> evaluates to <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-34-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>{</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>&amp;#x2223;</mo><mi>x</mi><mo>&amp;#x2208;</mo><mi>X</mi><mo>,</mo><mi>y</mi><mo>&amp;#x2208;</mo><mi>Y</mi><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>}</mo></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-124" style="width:12.179em;display:inline-block"><span style="display:inline-block;position:relative;width:9.8em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.494em,1009.72em,2.744em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-125"><span class="mo" id="MathJax-Span-126" style="font-family:MathJax_Main">{</span><span class="mi" id="MathJax-Span-127" style="font-family:MathJax_Math;font-style:italic">x</span><span class="mo" id="MathJax-Span-128" style="font-family:MathJax_Main;padding-left:0.244em">+</span><span class="mi" id="MathJax-Span-129" style="font-family:MathJax_Math;font-style:italic;padding-left:0.244em">y<span style="display:inline-block;overflow:hidden;height:1px;width:0.002em"></span></span><span class="mo" id="MathJax-Span-130" style="font-family:MathJax_Main;padding-left:0.284em">â£</span><span class="mi" id="MathJax-Span-131" style="font-family:MathJax_Math;font-style:italic;padding-left:0.284em">x</span><span class="mo" id="MathJax-Span-132" style="font-family:MathJax_Main;padding-left:0.284em">â</span><span class="mi" id="MathJax-Span-133" style="font-family:MathJax_Math;font-style:italic;padding-left:0.284em">X<span style="display:inline-block;overflow:hidden;height:1px;width:0.042em"></span></span><span class="mo" id="MathJax-Span-134" style="font-family:MathJax_Main">,</span><span class="mi" id="MathJax-Span-135" style="font-family:MathJax_Math;font-style:italic;padding-left:0.163em">y<span style="display:inline-block;overflow:hidden;height:1px;width:0.002em"></span></span><span class="mo" id="MathJax-Span-136" style="font-family:MathJax_Main;padding-left:0.284em">â</span><span class="mi" id="MathJax-Span-137" style="font-family:MathJax_Math;font-style:italic;padding-left:0.284em">Y<span style="display:inline-block;overflow:hidden;height:1px;width:0.204em"></span></span><span class="mo" id="MathJax-Span-138" style="font-family:MathJax_Main">}</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.348em;border-left:0px solid;width:0px;height:1.353em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo fence="false" stretchy="false">{</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>â£</mo><mi>x</mi><mo>â</mo><mi>X</mi><mo>,</mo><mi>y</mi><mo>â</mo><mi>Y</mi><mo fence="false" stretchy="false">}</mo></math></span></span>.</li>
<li>Division <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-35-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mi>Y</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-139" style="width:2.663em;display:inline-block"><span style="display:inline-block;position:relative;width:2.139em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.494em,1002.14em,2.744em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-140"><span class="mi" id="MathJax-Span-141" style="font-family:MathJax_Math;font-style:italic">X<span style="display:inline-block;overflow:hidden;height:1px;width:0.042em"></span></span><span class="texatom" id="MathJax-Span-142"><span class="mrow" id="MathJax-Span-143"><span class="mo" id="MathJax-Span-144" style="font-family:MathJax_Main">/</span></span></span><span class="mi" id="MathJax-Span-145" style="font-family:MathJax_Math;font-style:italic">Y<span style="display:inline-block;overflow:hidden;height:1px;width:0.204em"></span></span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.348em;border-left:0px solid;width:0px;height:1.353em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mi>Y</mi></math></span></span> evaluates to <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-36-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>{</mo><mi>x</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mi>y</mi><mo>&amp;#x2223;</mo><mi>x</mi><mo>&amp;#x2208;</mo><mi>X</mi><mo>,</mo><mi>y</mi><mo>&amp;#x2208;</mo><mi>Y</mi><mo>,</mo><mi>y</mi><mo>&amp;#x2260;</mo><mn>0</mn><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>}</mo></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-146" style="width:14.679em;display:inline-block"><span style="display:inline-block;position:relative;width:11.817em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.494em,1011.74em,2.744em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-147"><span class="mo" id="MathJax-Span-148" style="font-family:MathJax_Main">{</span><span class="mi" id="MathJax-Span-149" style="font-family:MathJax_Math;font-style:italic">x</span><span class="texatom" id="MathJax-Span-150"><span class="mrow" id="MathJax-Span-151"><span class="mo" id="MathJax-Span-152" style="font-family:MathJax_Main">/</span></span></span><span class="mi" id="MathJax-Span-153" style="font-family:MathJax_Math;font-style:italic">y<span style="display:inline-block;overflow:hidden;height:1px;width:0.002em"></span></span><span class="mo" id="MathJax-Span-154" style="font-family:MathJax_Main;padding-left:0.284em">â£</span><span class="mi" id="MathJax-Span-155" style="font-family:MathJax_Math;font-style:italic;padding-left:0.284em">x</span><span class="mo" id="MathJax-Span-156" style="font-family:MathJax_Main;padding-left:0.284em">â</span><span class="mi" id="MathJax-Span-157" style="font-family:MathJax_Math;font-style:italic;padding-left:0.284em">X<span style="display:inline-block;overflow:hidden;height:1px;width:0.042em"></span></span><span class="mo" id="MathJax-Span-158" style="font-family:MathJax_Main">,</span><span class="mi" id="MathJax-Span-159" style="font-family:MathJax_Math;font-style:italic;padding-left:0.163em">y<span style="display:inline-block;overflow:hidden;height:1px;width:0.002em"></span></span><span class="mo" id="MathJax-Span-160" style="font-family:MathJax_Main;padding-left:0.284em">â</span><span class="mi" id="MathJax-Span-161" style="font-family:MathJax_Math;font-style:italic;padding-left:0.284em">Y<span style="display:inline-block;overflow:hidden;height:1px;width:0.204em"></span></span><span class="mo" id="MathJax-Span-162" style="font-family:MathJax_Main">,</span><span class="mi" id="MathJax-Span-163" style="font-family:MathJax_Math;font-style:italic;padding-left:0.163em">y<span style="display:inline-block;overflow:hidden;height:1px;width:0.002em"></span></span><span class="mo" id="MathJax-Span-164" style="font-family:MathJax_Main;padding-left:0.284em">â </span><span class="mn" id="MathJax-Span-165" style="font-family:MathJax_Main;padding-left:0.284em">0</span><span class="mo" id="MathJax-Span-166" style="font-family:MathJax_Main">}</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.348em;border-left:0px solid;width:0px;height:1.353em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo fence="false" stretchy="false">{</mo><mi>x</mi><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mi>y</mi><mo>â£</mo><mi>x</mi><mo>â</mo><mi>X</mi><mo>,</mo><mi>y</mi><mo>â</mo><mi>Y</mi><mo>,</mo><mi>y</mi><mo>â </mo><mn>0</mn><mo fence="false" stretchy="false">}</mo></math></span></span>. In other words, all <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-37-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-167" style="width:0.607em;display:inline-block"><span style="display:inline-block;position:relative;width:0.486em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.45em,2.542em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-168"><span class="mn" id="MathJax-Span-169" style="font-family:MathJax_Main">0</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.098em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math></span></span> values in <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-38-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>Y</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-170" style="width:0.97em;display:inline-block"><span style="display:inline-block;position:relative;width:0.768em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.77em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-171"><span class="mi" id="MathJax-Span-172" style="font-family:MathJax_Math;font-style:italic">Y<span style="display:inline-block;overflow:hidden;height:1px;width:0.204em"></span></span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Y</mi></math></span></span>  are thrown out.</li>
<li>A choice <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-39-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;normal&quot;>c</mi><mi mathvariant=&quot;normal&quot;>h</mi><mi mathvariant=&quot;normal&quot;>o</mi><mi mathvariant=&quot;normal&quot;>o</mi><mi mathvariant=&quot;normal&quot;>s</mi><mi mathvariant=&quot;normal&quot;>e</mi></mrow><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-173" style="width:6.373em;display:inline-block"><span style="display:inline-block;position:relative;width:5.123em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.494em,1005.04em,2.744em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-174"><span class="texatom" id="MathJax-Span-175"><span class="mrow" id="MathJax-Span-176"><span class="mi" id="MathJax-Span-177" style="font-family:MathJax_Main">c</span><span class="mi" id="MathJax-Span-178" style="font-family:MathJax_Main">h</span><span class="mi" id="MathJax-Span-179" style="font-family:MathJax_Main">o</span><span class="mi" id="MathJax-Span-180" style="font-family:MathJax_Main">o</span><span class="mi" id="MathJax-Span-181" style="font-family:MathJax_Main">s</span><span class="mi" id="MathJax-Span-182" style="font-family:MathJax_Main">e</span></span></span><span class="mo" id="MathJax-Span-183" style="font-family:MathJax_Main">(</span><span class="mi" id="MathJax-Span-184" style="font-family:MathJax_Math;font-style:italic">x</span><span class="mo" id="MathJax-Span-185" style="font-family:MathJax_Main">,</span><span class="mi" id="MathJax-Span-186" style="font-family:MathJax_Math;font-style:italic;padding-left:0.163em">y<span style="display:inline-block;overflow:hidden;height:1px;width:0.002em"></span></span><span class="mo" id="MathJax-Span-187" style="font-family:MathJax_Main">)</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.348em;border-left:0px solid;width:0px;height:1.353em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">c</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></math></span></span> evaluates to <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-40-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>{</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>}</mo></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-188" style="width:3.107em;display:inline-block"><span style="display:inline-block;position:relative;width:2.502em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.494em,1002.42em,2.744em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-189"><span class="mo" id="MathJax-Span-190" style="font-family:MathJax_Main">{</span><span class="mi" id="MathJax-Span-191" style="font-family:MathJax_Math;font-style:italic">x</span><span class="mo" id="MathJax-Span-192" style="font-family:MathJax_Main">,</span><span class="mi" id="MathJax-Span-193" style="font-family:MathJax_Math;font-style:italic;padding-left:0.163em">y<span style="display:inline-block;overflow:hidden;height:1px;width:0.002em"></span></span><span class="mo" id="MathJax-Span-194" style="font-family:MathJax_Main">}</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.348em;border-left:0px solid;width:0px;height:1.353em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo fence="false" stretchy="false">{</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo fence="false" stretchy="false">}</mo></math></span></span>.</li>
</ul>
<p>For example, <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-41-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn><mo>+</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;normal&quot;>c</mi><mi mathvariant=&quot;normal&quot;>h</mi><mi mathvariant=&quot;normal&quot;>o</mi><mi mathvariant=&quot;normal&quot;>o</mi><mi mathvariant=&quot;normal&quot;>s</mi><mi mathvariant=&quot;normal&quot;>e</mi></mrow><mo stretchy=&quot;false&quot;>(</mo><mn>2</mn><mo>,</mo><mn>5</mn><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-195" style="width:8.47em;display:inline-block"><span style="display:inline-block;position:relative;width:6.817em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.494em,1006.74em,2.744em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-196"><span class="mn" id="MathJax-Span-197" style="font-family:MathJax_Main">1</span><span class="mo" id="MathJax-Span-198" style="font-family:MathJax_Main;padding-left:0.244em">+</span><span class="texatom" id="MathJax-Span-199" style="padding-left:0.244em"><span class="mrow" id="MathJax-Span-200"><span class="mi" id="MathJax-Span-201" style="font-family:MathJax_Main">c</span><span class="mi" id="MathJax-Span-202" style="font-family:MathJax_Main">h</span><span class="mi" id="MathJax-Span-203" style="font-family:MathJax_Main">o</span><span class="mi" id="MathJax-Span-204" style="font-family:MathJax_Main">o</span><span class="mi" id="MathJax-Span-205" style="font-family:MathJax_Main">s</span><span class="mi" id="MathJax-Span-206" style="font-family:MathJax_Main">e</span></span></span><span class="mo" id="MathJax-Span-207" style="font-family:MathJax_Main">(</span><span class="mn" id="MathJax-Span-208" style="font-family:MathJax_Main">2</span><span class="mo" id="MathJax-Span-209" style="font-family:MathJax_Main">,</span><span class="mn" id="MathJax-Span-210" style="font-family:MathJax_Main;padding-left:0.163em">5</span><span class="mo" id="MathJax-Span-211" style="font-family:MathJax_Main">)</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.348em;border-left:0px solid;width:0px;height:1.353em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo>+</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">c</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow><mo stretchy="false">(</mo><mn>2</mn><mo>,</mo><mn>5</mn><mo stretchy="false">)</mo></math></span></span> evaluates to <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-42-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>{</mo><mn>3</mn><mo>,</mo><mn>6</mn><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>}</mo></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-212" style="width:3.067em;display:inline-block"><span style="display:inline-block;position:relative;width:2.462em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.494em,1002.38em,2.744em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-213"><span class="mo" id="MathJax-Span-214" style="font-family:MathJax_Main">{</span><span class="mn" id="MathJax-Span-215" style="font-family:MathJax_Main">3</span><span class="mo" id="MathJax-Span-216" style="font-family:MathJax_Main">,</span><span class="mn" id="MathJax-Span-217" style="font-family:MathJax_Main;padding-left:0.163em">6</span><span class="mo" id="MathJax-Span-218" style="font-family:MathJax_Main">}</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.348em;border-left:0px solid;width:0px;height:1.353em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo fence="false" stretchy="false">{</mo><mn>3</mn><mo>,</mo><mn>6</mn><mo fence="false" stretchy="false">}</mo></math></span></span>, <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-43-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn><mo>+</mo><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mn>0</mn></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-219" style="width:4.075em;display:inline-block"><span style="display:inline-block;position:relative;width:3.268em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.494em,1003.23em,2.744em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-220"><span class="mn" id="MathJax-Span-221" style="font-family:MathJax_Main">1</span><span class="mo" id="MathJax-Span-222" style="font-family:MathJax_Main;padding-left:0.244em">+</span><span class="mn" id="MathJax-Span-223" style="font-family:MathJax_Main;padding-left:0.244em">2</span><span class="texatom" id="MathJax-Span-224"><span class="mrow" id="MathJax-Span-225"><span class="mo" id="MathJax-Span-226" style="font-family:MathJax_Main">/</span></span></span><span class="mn" id="MathJax-Span-227" style="font-family:MathJax_Main">0</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.348em;border-left:0px solid;width:0px;height:1.353em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo>+</mo><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mn>0</mn></math></span></span> evaluates to <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-44-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>{</mo><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>}</mo></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-228" style="width:1.252em;display:inline-block"><span style="display:inline-block;position:relative;width:1.01em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.494em,1000.93em,2.744em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-229"><span class="mo" id="MathJax-Span-230" style="font-family:MathJax_Main">{</span><span class="mo" id="MathJax-Span-231" style="font-family:MathJax_Main">}</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.348em;border-left:0px solid;width:0px;height:1.353em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo fence="false" stretchy="false">{</mo><mo fence="false" stretchy="false">}</mo></math></span></span>, and <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-45-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>90</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>/</mo></mrow><mo stretchy=&quot;false&quot;>(</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;normal&quot;>c</mi><mi mathvariant=&quot;normal&quot;>h</mi><mi mathvariant=&quot;normal&quot;>o</mi><mi mathvariant=&quot;normal&quot;>o</mi><mi mathvariant=&quot;normal&quot;>s</mi><mi mathvariant=&quot;normal&quot;>e</mi></mrow><mo stretchy=&quot;false&quot;>(</mo><mo>&amp;#x2212;</mo><mn>5</mn><mo>,</mo><mn>5</mn><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mn>5</mn><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-232" style="width:12.26em;display:inline-block"><span style="display:inline-block;position:relative;width:9.881em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.494em,1009.8em,2.744em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-233"><span class="mn" id="MathJax-Span-234" style="font-family:MathJax_Main">90</span><span class="texatom" id="MathJax-Span-235"><span class="mrow" id="MathJax-Span-236"><span class="mo" id="MathJax-Span-237" style="font-family:MathJax_Main">/</span></span></span><span class="mo" id="MathJax-Span-238" style="font-family:MathJax_Main">(</span><span class="texatom" id="MathJax-Span-239"><span class="mrow" id="MathJax-Span-240"><span class="mi" id="MathJax-Span-241" style="font-family:MathJax_Main">c</span><span class="mi" id="MathJax-Span-242" style="font-family:MathJax_Main">h</span><span class="mi" id="MathJax-Span-243" style="font-family:MathJax_Main">o</span><span class="mi" id="MathJax-Span-244" style="font-family:MathJax_Main">o</span><span class="mi" id="MathJax-Span-245" style="font-family:MathJax_Main">s</span><span class="mi" id="MathJax-Span-246" style="font-family:MathJax_Main">e</span></span></span><span class="mo" id="MathJax-Span-247" style="font-family:MathJax_Main">(</span><span class="mo" id="MathJax-Span-248" style="font-family:MathJax_Main">â</span><span class="mn" id="MathJax-Span-249" style="font-family:MathJax_Main">5</span><span class="mo" id="MathJax-Span-250" style="font-family:MathJax_Main">,</span><span class="mn" id="MathJax-Span-251" style="font-family:MathJax_Main;padding-left:0.163em">5</span><span class="mo" id="MathJax-Span-252" style="font-family:MathJax_Main">)</span><span class="mo" id="MathJax-Span-253" style="font-family:MathJax_Main;padding-left:0.244em">+</span><span class="mn" id="MathJax-Span-254" style="font-family:MathJax_Main;padding-left:0.244em">5</span><span class="mo" id="MathJax-Span-255" style="font-family:MathJax_Main">)</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.348em;border-left:0px solid;width:0px;height:1.353em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>90</mn><mrow class="MJX-TeXAtom-ORD"><mo>/</mo></mrow><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">c</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow><mo stretchy="false">(</mo><mo>â</mo><mn>5</mn><mo>,</mo><mn>5</mn><mo stretchy="false">)</mo><mo>+</mo><mn>5</mn><mo stretchy="false">)</mo></math></span></span> evaluates to <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-46-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>{</mo><mn>9</mn><mo fence=&quot;false&quot; stretchy=&quot;false&quot;>}</mo></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-256" style="width:1.857em;display:inline-block"><span style="display:inline-block;position:relative;width:1.494em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.494em,1001.41em,2.744em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-257"><span class="mo" id="MathJax-Span-258" style="font-family:MathJax_Main">{</span><span class="mn" id="MathJax-Span-259" style="font-family:MathJax_Main">9</span><span class="mo" id="MathJax-Span-260" style="font-family:MathJax_Main">}</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.348em;border-left:0px solid;width:0px;height:1.353em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo fence="false" stretchy="false">{</mo><mn>9</mn><mo fence="false" stretchy="false">}</mo></math></span></span>.
Using multisets instead of true sets simplifies the code by removing the need to check for uniqueness of elements.</p>
<p>A monad that represents this non-deterministic effect must be able to represent a situation in which there are no answers, and a situation in which there is at least one answer together with any remaining answers:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Many (Î± : <span class="hljs-built_in">Type</span>) <span class="hljs-keyword">where</span>
  | none : Many Î±
  | more : Î± â (Unit â Many Î±) â Many Î±
</code></pre>
<p>This datatype looks very much like <code class="hljs">List</code>.
The difference is that where <code class="hljs">cons</code> stores the rest of the list, <code class="hljs">more</code> stores a function that should compute the next value on demand.
This means that a consumer of <code class="hljs">Many</code> can stop the search when some number of results have been found.</p>
<p>A single result is represented by a <code class="hljs">more</code> constructor that returns no further results:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">M</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">y</span>.<span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">e</span> <span class="hljs-params">(x : Î±)</span> <span class="hljs-symbol">:</span></span> Many Î± := Many.more x (<span class="hljs-keyword">fun</span> () =&gt; Many.none)
</code></pre>
<p>The union of two multisets of results can be computed by checking whether the first multiset is empty.
If so, the second multiset is the union.
If not, the union consists of the first element of the first multiset followed by the union of the rest of the first multiset with the second multiset:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">M</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">y</span>.<span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> Many Î± â Many Î± â Many Î±
  | Many.none, ys =&gt; ys
  | Many.more x xs, ys =&gt; Many.more x (<span class="hljs-keyword">fun</span> () =&gt; union (xs ()) ys)
</code></pre>
<p>It can be convenient to start a search process with a list of values.
<code class="hljs">Many.fromList</code> converts a list into a multiset of results:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">M</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">y</span>.<span class="hljs-title">f</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> List Î± â Many Î±
  | [] =&gt; Many.none
  | x :: xs =&gt; Many.more x (<span class="hljs-keyword">fun</span> () =&gt; fromList xs)
</code></pre>
<p>Similarly, once a search has been specified, it can be convenient to extract either a number of values, or all the values:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">M</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">y</span>.<span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">k</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Nat â Many Î± â List Î±
  | <span class="hljs-number">0</span>, _ =&gt; []
  | _ + <span class="hljs-number">1</span>, Many.none =&gt; []
  | n + <span class="hljs-number">1</span>, Many.more x xs =&gt; x :: (xs ()).take n

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">M</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">y</span>.<span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">k</span><span class="hljs-title">e</span><span class="hljs-title">A</span><span class="hljs-title">l</span><span class="hljs-title">l</span> <span class="hljs-symbol">:</span></span> Many Î± â List Î±
  | Many.none =&gt; []
  | Many.more x xs =&gt; x :: (xs ()).takeAll
</code></pre>
<p>A <code class="hljs">Monad Many</code> instance requires a <code class="hljs">bind</code> operator.
In a nondeterministic search, sequencing two operations consists of taking all possibilities from the first step and running the rest of the program on each of them, taking the union of the results.
In other words, if the first step returns three possible answers, the second step needs to be tried for all three.
Because the second step can return any number of answers for each input, taking their union represents the entire search space.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">M</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">y</span>.<span class="hljs-title">b</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-symbol">:</span></span> Many Î± â (Î± â Many Î²) â Many Î²
  | Many.none, _ =&gt;
    Many.none
  | Many.more x xs, f =&gt;
    (f x).union (bind (xs ()) f)
</code></pre>
<p><code class="hljs">Many.one</code> and <code class="hljs">Many.bind</code> obey the monad contract.
To check that <code class="hljs">Many.bind (Many.one v) f</code> is the same as <code class="hljs">f v</code>, start by evaluating the expression as far as possible:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">Many.bind (Many.one v) f
===&gt;
Many.bind (Many.more v (<span class="hljs-keyword">fun</span> () =&gt; Many.none)) f
===&gt;
(f v).union (Many.bind Many.none f)
===&gt;
(f v).union Many.none
</code></pre>
<p>The empty multiset is a right identity of <code class="hljs">union</code>, so the answer is equivalent to <code class="hljs">f v</code>.
To check that <code class="hljs">Many.bind v Many.one</code> is the same as <code class="hljs">v</code>, consider that <code class="hljs">bind</code> takes the union of applying <code class="hljs">Many.one</code> to each element of <code class="hljs">v</code>.
In other words, if <code class="hljs">v</code> has the form <code class="hljs">{v1, v2, v3, ..., vn}</code>, then <code class="hljs">Many.bind v Many.one</code> is <code class="hljs">{v1} âª {v2} âª {v3} âª ... âª {vn}</code>, which is <code class="hljs">{v1, v2, v3, ..., vn}</code>.</p>
<p>Finally, to check that <code class="hljs">Many.bind</code> is associative, check that <code class="hljs">Many.bind (Many.bind bind v f) g</code> is the same as <code class="hljs">Many.bind v (fun x =&gt; Many.bind (f x) g)</code>.
If <code class="hljs">v</code> has the form <code class="hljs">{v1, v2, v3, ..., vn}</code>, then:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">Many.bind v f
===&gt;
f v1 âª f v2 âª f v3 âª ... âª f vn
</code></pre>
<p>which means that</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">Many.bind (Many.bind bind v f) g
===&gt;
Many.bind (f v1) g âª
Many.bind (f v2) g âª
Many.bind (f v3) g âª
... âª
Many.bind (f vn) g
</code></pre>
<p>Similarly,</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">Many.bind v (<span class="hljs-keyword">fun</span> x =&gt; Many.bind (f x) g)
===&gt;
(<span class="hljs-keyword">fun</span> x =&gt; Many.bind (f x) g) v1 âª
(<span class="hljs-keyword">fun</span> x =&gt; Many.bind (f x) g) v2 âª
(<span class="hljs-keyword">fun</span> x =&gt; Many.bind (f x) g) v3 âª
... âª
(<span class="hljs-keyword">fun</span> x =&gt; Many.bind (f x) g) vn
===&gt;
Many.bind (f v1) g âª
Many.bind (f v2) g âª
Many.bind (f v3) g âª
... âª
Many.bind (f vn) g
</code></pre>
<p>Thus, both sides are equal, so <code class="hljs">Many.bind</code> is associative.</p>
<p>The resulting monad instance is:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Monad Many <span class="hljs-keyword">where</span>
  pure := Many.one
  bind := Many.bind
</code></pre>
<p>An example search using this monad finds all the combinations of numbers in a list that add to 15:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">d</span><span class="hljs-title">s</span><span class="hljs-title">T</span><span class="hljs-title">o</span> <span class="hljs-params">(goal : Nat)</span> <span class="hljs-symbol">:</span></span> List Nat â Many (List Nat)
  | [] =&gt;
    <span class="hljs-keyword">if</span> goal == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>
      pure []
    <span class="hljs-keyword">else</span>
      Many.none
  | x :: xs =&gt;
    <span class="hljs-keyword">if</span> x &gt; goal <span class="hljs-keyword">then</span>
      addsTo goal xs
    <span class="hljs-keyword">else</span>
      (addsTo goal xs).union
        (addsTo (goal - x) xs &gt;&gt;= <span class="hljs-keyword">fun</span> answer =&gt;
         pure (x :: answer))
</code></pre>
<p>The search process is recursive over the list.
The empty list is a successful search when the goal is <code class="hljs">0</code>; otherwise, it fails.
When the list is non-empty, there are two possibilities: either the head of the list is greater than the goal, in which case it cannot participate in any successful searches, or it is not, in which case it can.
If the head of the list is <em>not</em> a candidate, then the search proceeds to the tail of the list.
If the head is a candidate, then there are two possibilities to be combined with <code class="hljs">Many.union</code>: either the solutions found contain the head, or they do not.
The solutions that do not contain the head are found with a recursive call on the tail, while the solutions that do contain it result from subtracting the head from the goal, and then attaching the head to the solutions that result from the recursive call.</p>
<p>Returning to the arithmetic evaluator that produces multisets of results, the <code class="hljs">both</code> and <code class="hljs">neither</code> operators can be written as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> NeedsSearch
  | div
  | choose

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">y</span><span class="hljs-title">S</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">r</span><span class="hljs-title">c</span><span class="hljs-title">h</span> <span class="hljs-symbol">:</span></span> NeedsSearch â Int â Int â Many Int
  | NeedsSearch.choose, x, y =&gt;
    Many.fromList [x, y]
  | NeedsSearch.div, x, y =&gt;
    <span class="hljs-keyword">if</span> y == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>
      Many.none
    <span class="hljs-keyword">else</span> Many.one (x / y)
</code></pre>
<p>Using these operators, the earlier examples can be evaluated:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> Expr Prim NeedsSearch

<span class="hljs-keyword">#eval</span> (evaluateM applySearch (prim plus (const <span class="hljs-number">1</span>) (prim (other choose) (const <span class="hljs-number">2</span>) (const <span class="hljs-number">5</span>)))).takeAll
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">[3, 6]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (evaluateM applySearch (prim plus (const <span class="hljs-number">1</span>) (prim (other div) (const <span class="hljs-number">2</span>) (const <span class="hljs-number">0</span>)))).takeAll
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">[]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (evaluateM applySearch (prim (other div) (const <span class="hljs-number">90</span>) (prim plus (prim (other choose) (const (-<span class="hljs-number">5</span>)) (const <span class="hljs-number">5</span>)) (const <span class="hljs-number">5</span>)))).takeAll
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">[9]
</code></pre>
<h4 id="custom-environments"><a class="header" href="#custom-environments">Custom Environments</a></h4>
<p>The evaluator can be made user-extensible by allowing strings to be used as operators, and then providing a mapping from strings to a function that implements them.
For example, users could extend the evaluator with a remainder operator or with one that returns the maximum of its two arguments.
The mapping from function names to function implementations is called an <em>environment</em>.</p>
<p>The environments needs to be passed in each recursive call.
Initially, it might seem that <code class="hljs">evaluateM</code> needs an extra argument to hold the environment, and that this argument should be passed to each recursive invocation.
However, passing an argument like this is another form of monad, so an appropriate <code class="hljs">Monad</code> instance allows the evaluator to be used unchanged.</p>
<p>Using functions as a monad is typically called a <em>reader</em> monad.
When evaluating expressions in the reader monad, the following rules are used:</p>
<ul>
<li>Constants <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-47-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-261" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-262"><span class="mi" id="MathJax-Span-263" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span> evaluate to constant functions <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-48-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x3BB;</mo></mrow><mi>e</mi><mo>.</mo><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-264" style="width:2.623em;display:inline-block"><span style="display:inline-block;position:relative;width:2.099em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1002.1em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-265"><span class="texatom" id="MathJax-Span-266"><span class="mrow" id="MathJax-Span-267"><span class="mo" id="MathJax-Span-268" style="font-family:MathJax_Math;font-style:italic">Î»</span></span></span><span class="mi" id="MathJax-Span-269" style="font-family:MathJax_Math;font-style:italic">e</span><span class="mo" id="MathJax-Span-270" style="font-family:MathJax_Main">.</span><span class="mi" id="MathJax-Span-271" style="font-family:MathJax_Math;font-style:italic;padding-left:0.163em">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:1.002em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mo>Î»</mo></mrow><mi>e</mi><mo>.</mo><mi>n</mi></math></span></span>,</li>
<li>Arithmetic operators evaluate to functions that pass their arguments on, so <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-49-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi><mo>+</mo><mi>g</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-272" style="width:2.825em;display:inline-block"><span style="display:inline-block;position:relative;width:2.26em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1002.26em,2.704em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-273"><span class="mi" id="MathJax-Span-274" style="font-family:MathJax_Math;font-style:italic">f<span style="display:inline-block;overflow:hidden;height:1px;width:0.042em"></span></span><span class="mo" id="MathJax-Span-275" style="font-family:MathJax_Main;padding-left:0.244em">+</span><span class="mi" id="MathJax-Span-276" style="font-family:MathJax_Math;font-style:italic;padding-left:0.244em">g<span style="display:inline-block;overflow:hidden;height:1px;width:0.002em"></span></span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.297em;border-left:0px solid;width:0px;height:1.252em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>+</mo><mi>g</mi></math></span></span> evaluates to <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-50-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x3BB;</mo></mrow><mi>e</mi><mo>.</mo><mi>f</mi><mo stretchy=&quot;false&quot;>(</mo><mi>e</mi><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mi>g</mi><mo stretchy=&quot;false&quot;>(</mo><mi>e</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-277" style="width:7.784em;display:inline-block"><span style="display:inline-block;position:relative;width:6.252em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.494em,1006.17em,2.744em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-278"><span class="texatom" id="MathJax-Span-279"><span class="mrow" id="MathJax-Span-280"><span class="mo" id="MathJax-Span-281" style="font-family:MathJax_Math;font-style:italic">Î»</span></span></span><span class="mi" id="MathJax-Span-282" style="font-family:MathJax_Math;font-style:italic">e</span><span class="mo" id="MathJax-Span-283" style="font-family:MathJax_Main">.</span><span class="mi" id="MathJax-Span-284" style="font-family:MathJax_Math;font-style:italic;padding-left:0.163em">f<span style="display:inline-block;overflow:hidden;height:1px;width:0.042em"></span></span><span class="mo" id="MathJax-Span-285" style="font-family:MathJax_Main">(</span><span class="mi" id="MathJax-Span-286" style="font-family:MathJax_Math;font-style:italic">e</span><span class="mo" id="MathJax-Span-287" style="font-family:MathJax_Main">)</span><span class="mo" id="MathJax-Span-288" style="font-family:MathJax_Main;padding-left:0.244em">+</span><span class="mi" id="MathJax-Span-289" style="font-family:MathJax_Math;font-style:italic;padding-left:0.244em">g<span style="display:inline-block;overflow:hidden;height:1px;width:0.002em"></span></span><span class="mo" id="MathJax-Span-290" style="font-family:MathJax_Main">(</span><span class="mi" id="MathJax-Span-291" style="font-family:MathJax_Math;font-style:italic">e</span><span class="mo" id="MathJax-Span-292" style="font-family:MathJax_Main">)</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.348em;border-left:0px solid;width:0px;height:1.353em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow class="MJX-TeXAtom-ORD"><mo>Î»</mo></mrow><mi>e</mi><mo>.</mo><mi>f</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>+</mo><mi>g</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></math></span></span>, and</li>
<li>Custom operators evaluate to the result of applying the custom operator to the arguments, so <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-51-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi><mtext>&amp;#xA0;</mtext><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;normal&quot;>O</mi><mi mathvariant=&quot;normal&quot;>P</mi></mrow><mtext>&amp;#xA0;</mtext><mi>g</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-293" style="width:3.712em;display:inline-block"><span style="display:inline-block;position:relative;width:2.986em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1002.99em,2.704em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-294"><span class="mi" id="MathJax-Span-295" style="font-family:MathJax_Math;font-style:italic">f<span style="display:inline-block;overflow:hidden;height:1px;width:0.042em"></span></span><span class="mtext" id="MathJax-Span-296" style="font-family:MathJax_Main">&nbsp;</span><span class="texatom" id="MathJax-Span-297"><span class="mrow" id="MathJax-Span-298"><span class="mi" id="MathJax-Span-299" style="font-family:MathJax_Main">O</span><span class="mi" id="MathJax-Span-300" style="font-family:MathJax_Main">P</span></span></span><span class="mtext" id="MathJax-Span-301" style="font-family:MathJax_Main">&nbsp;</span><span class="mi" id="MathJax-Span-302" style="font-family:MathJax_Math;font-style:italic">g<span style="display:inline-block;overflow:hidden;height:1px;width:0.002em"></span></span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.297em;border-left:0px solid;width:0px;height:1.252em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mtext>&nbsp;</mtext><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">O</mi><mi mathvariant="normal">P</mi></mrow><mtext>&nbsp;</mtext><mi>g</mi></math></span></span> evaluates to
<span class="MathJax_Preview" style="color:inherit;display:none"></span><div class="MathJax_Display" style="text-align:center"><span class="MathJax" id="MathJax-Element-52-Frame" tabindex="0" style="text-align:center;position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x3BB;</mo></mrow><mi>e</mi><mo>.</mo><mrow><mo>{</mo><mtable columnalign=&quot;left left&quot; rowspacing=&quot;.2em&quot; columnspacing=&quot;1em&quot; displaystyle=&quot;false&quot;><mtr><mtd><mi>h</mi><mo stretchy=&quot;false&quot;>(</mo><mi>f</mi><mo stretchy=&quot;false&quot;>(</mo><mi>e</mi><mo stretchy=&quot;false&quot;>)</mo><mo>,</mo><mi>g</mi><mo stretchy=&quot;false&quot;>(</mo><mi>e</mi><mo stretchy=&quot;false&quot;>)</mo><mo stretchy=&quot;false&quot;>)</mo></mtd><mtd><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;normal&quot;>i</mi><mi mathvariant=&quot;normal&quot;>f</mi></mrow><mtext>&amp;#xA0;</mtext><mi>e</mi><mtext>&amp;#xA0;</mtext><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;normal&quot;>c</mi><mi mathvariant=&quot;normal&quot;>o</mi><mi mathvariant=&quot;normal&quot;>n</mi><mi mathvariant=&quot;normal&quot;>t</mi><mi mathvariant=&quot;normal&quot;>a</mi><mi mathvariant=&quot;normal&quot;>i</mi><mi mathvariant=&quot;normal&quot;>n</mi><mi mathvariant=&quot;normal&quot;>s</mi></mrow><mtext>&amp;#xA0;</mtext><mo stretchy=&quot;false&quot;>(</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;normal&quot;>O</mi><mi mathvariant=&quot;normal&quot;>P</mi></mrow><mo>,</mo><mi>h</mi><mo stretchy=&quot;false&quot;>)</mo></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;normal&quot;>o</mi><mi mathvariant=&quot;normal&quot;>t</mi><mi mathvariant=&quot;normal&quot;>h</mi><mi mathvariant=&quot;normal&quot;>e</mi><mi mathvariant=&quot;normal&quot;>r</mi><mi mathvariant=&quot;normal&quot;>w</mi><mi mathvariant=&quot;normal&quot;>i</mi><mi mathvariant=&quot;normal&quot;>s</mi><mi mathvariant=&quot;normal&quot;>e</mi></mrow></mtd></mtr></mtable><mo fence=&quot;true&quot; stretchy=&quot;true&quot; symmetric=&quot;true&quot;></mo></mrow></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-303" style="width:21.857em;display:inline-block"><span style="display:inline-block;position:relative;width:17.623em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.857em,1017.62em,4.518em,-999.998em);top:-3.425em;left:0em"><span class="mrow" id="MathJax-Span-304"><span class="texatom" id="MathJax-Span-305"><span class="mrow" id="MathJax-Span-306"><span class="mo" id="MathJax-Span-307" style="font-family:MathJax_Math;font-style:italic">Î»</span></span></span><span class="mi" id="MathJax-Span-308" style="font-family:MathJax_Math;font-style:italic">e</span><span class="mo" id="MathJax-Span-309" style="font-family:MathJax_Main">.</span><span class="mrow" id="MathJax-Span-310" style="padding-left:0.163em"><span class="mo" id="MathJax-Span-311" style="vertical-align:0em"><span style="font-family:MathJax_Size3">{</span></span><span class="mtable" id="MathJax-Span-312" style="padding-right:0.163em;padding-left:0.163em"><span style="display:inline-block;position:relative;width:15.042em;height:0px"><span style="position:absolute;clip:rect(2.542em,1005.2em,4.8em,-999.998em);top:-3.99em;left:0em"><span style="display:inline-block;position:relative;width:5.325em;height:0px"><span style="position:absolute;clip:rect(3.107em,1005.2em,4.357em,-999.998em);top:-4.554em;left:0em"><span class="mtd" id="MathJax-Span-313"><span class="mrow" id="MathJax-Span-314"><span class="mi" id="MathJax-Span-315" style="font-family:MathJax_Math;font-style:italic">h</span><span class="mo" id="MathJax-Span-316" style="font-family:MathJax_Main">(</span><span class="mi" id="MathJax-Span-317" style="font-family:MathJax_Math;font-style:italic">f<span style="display:inline-block;overflow:hidden;height:1px;width:0.042em"></span></span><span class="mo" id="MathJax-Span-318" style="font-family:MathJax_Main">(</span><span class="mi" id="MathJax-Span-319" style="font-family:MathJax_Math;font-style:italic">e</span><span class="mo" id="MathJax-Span-320" style="font-family:MathJax_Main">)</span><span class="mo" id="MathJax-Span-321" style="font-family:MathJax_Main">,</span><span class="mi" id="MathJax-Span-322" style="font-family:MathJax_Math;font-style:italic;padding-left:0.163em">g<span style="display:inline-block;overflow:hidden;height:1px;width:0.002em"></span></span><span class="mo" id="MathJax-Span-323" style="font-family:MathJax_Main">(</span><span class="mi" id="MathJax-Span-324" style="font-family:MathJax_Math;font-style:italic">e</span><span class="mo" id="MathJax-Span-325" style="font-family:MathJax_Main">)</span><span class="mo" id="MathJax-Span-326" style="font-family:MathJax_Main">)</span></span></span><span style="display:inline-block;width:0px;height:3.994em"></span></span><span style="position:absolute;clip:rect(3.188em,1000.45em,4.155em,-999.998em);top:-3.304em;left:0em"><span class="mtd" id="MathJax-Span-355"><span class="mrow" id="MathJax-Span-356"><span class="mn" id="MathJax-Span-357" style="font-family:MathJax_Main">0</span></span></span><span style="display:inline-block;width:0px;height:3.994em"></span></span></span><span style="display:inline-block;width:0px;height:3.994em"></span></span><span style="position:absolute;clip:rect(2.542em,1008.63em,4.8em,-999.998em);top:-3.99em;left:6.333em"><span style="display:inline-block;position:relative;width:8.752em;height:0px"><span style="position:absolute;clip:rect(3.107em,1008.63em,4.357em,-999.998em);top:-4.554em;left:0em"><span class="mtd" id="MathJax-Span-327"><span class="mrow" id="MathJax-Span-328"><span class="texatom" id="MathJax-Span-329"><span class="mrow" id="MathJax-Span-330"><span class="mi" id="MathJax-Span-331" style="font-family:MathJax_Main">i</span><span class="mi" id="MathJax-Span-332" style="font-family:MathJax_Main">f<span style="display:inline-block;overflow:hidden;height:1px;width:0.083em"></span></span></span></span><span class="mtext" id="MathJax-Span-333" style="font-family:MathJax_Main">&nbsp;</span><span class="mi" id="MathJax-Span-334" style="font-family:MathJax_Math;font-style:italic">e</span><span class="mtext" id="MathJax-Span-335" style="font-family:MathJax_Main">&nbsp;</span><span class="texatom" id="MathJax-Span-336"><span class="mrow" id="MathJax-Span-337"><span class="mi" id="MathJax-Span-338" style="font-family:MathJax_Main">c</span><span class="mi" id="MathJax-Span-339" style="font-family:MathJax_Main">o</span><span class="mi" id="MathJax-Span-340" style="font-family:MathJax_Main">n</span><span class="mi" id="MathJax-Span-341" style="font-family:MathJax_Main">t</span><span class="mi" id="MathJax-Span-342" style="font-family:MathJax_Main">a</span><span class="mi" id="MathJax-Span-343" style="font-family:MathJax_Main">i</span><span class="mi" id="MathJax-Span-344" style="font-family:MathJax_Main">n</span><span class="mi" id="MathJax-Span-345" style="font-family:MathJax_Main">s</span></span></span><span class="mtext" id="MathJax-Span-346" style="font-family:MathJax_Main">&nbsp;</span><span class="mo" id="MathJax-Span-347" style="font-family:MathJax_Main">(</span><span class="texatom" id="MathJax-Span-348"><span class="mrow" id="MathJax-Span-349"><span class="mi" id="MathJax-Span-350" style="font-family:MathJax_Main">O</span><span class="mi" id="MathJax-Span-351" style="font-family:MathJax_Main">P</span></span></span><span class="mo" id="MathJax-Span-352" style="font-family:MathJax_Main">,</span><span class="mi" id="MathJax-Span-353" style="font-family:MathJax_Math;font-style:italic;padding-left:0.163em">h</span><span class="mo" id="MathJax-Span-354" style="font-family:MathJax_Main">)</span></span></span><span style="display:inline-block;width:0px;height:3.994em"></span></span><span style="position:absolute;clip:rect(3.188em,1004.08em,4.115em,-999.998em);top:-3.304em;left:0em"><span class="mtd" id="MathJax-Span-358"><span class="mrow" id="MathJax-Span-359"><span class="texatom" id="MathJax-Span-360"><span class="mrow" id="MathJax-Span-361"><span class="mi" id="MathJax-Span-362" style="font-family:MathJax_Main">o</span><span class="mi" id="MathJax-Span-363" style="font-family:MathJax_Main">t</span><span class="mi" id="MathJax-Span-364" style="font-family:MathJax_Main">h</span><span class="mi" id="MathJax-Span-365" style="font-family:MathJax_Main">e</span><span class="mi" id="MathJax-Span-366" style="font-family:MathJax_Main">r</span><span class="mi" id="MathJax-Span-367" style="font-family:MathJax_Main">w</span><span class="mi" id="MathJax-Span-368" style="font-family:MathJax_Main">i</span><span class="mi" id="MathJax-Span-369" style="font-family:MathJax_Main">s</span><span class="mi" id="MathJax-Span-370" style="font-family:MathJax_Main">e</span></span></span></span></span><span style="display:inline-block;width:0px;height:3.994em"></span></span></span><span style="display:inline-block;width:0px;height:3.994em"></span></span></span></span><span class="mo" id="MathJax-Span-371"></span></span></span><span style="display:inline-block;width:0px;height:3.429em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-1.248em;border-left:0px solid;width:0px;height:3.052em"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow class="MJX-TeXAtom-ORD"><mo>Î»</mo></mrow><mi>e</mi><mo>.</mo><mrow><mo>{</mo><mtable columnalign="left left" rowspacing=".2em" columnspacing="1em" displaystyle="false"><mtr><mtd><mi>h</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo>,</mo><mi>g</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mtd><mtd><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">i</mi><mi mathvariant="normal">f</mi></mrow><mtext>&nbsp;</mtext><mi>e</mi><mtext>&nbsp;</mtext><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">s</mi></mrow><mtext>&nbsp;</mtext><mo stretchy="false">(</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">O</mi><mi mathvariant="normal">P</mi></mrow><mo>,</mo><mi>h</mi><mo stretchy="false">)</mo></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">o</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">h</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">w</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow></mtd></mtr></mtable><mo fence="true" stretchy="true" symmetric="true"></mo></mrow></math></span></span></div>
with <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-53-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-372" style="width:0.607em;display:inline-block"><span style="display:inline-block;position:relative;width:0.486em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.45em,2.542em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-373"><span class="mn" id="MathJax-Span-374" style="font-family:MathJax_Main">0</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.098em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math></span></span> serving as a fallback in case an unknown operator is applied.</li>
</ul>
<p>To define the reader monad in Lean, the first step is to define the <code class="hljs">Reader</code> type and the effect that allows users to get ahold of the environment:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">R</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(Ï : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> := Ï â Î±

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">d</span> <span class="hljs-symbol">:</span></span> Reader Ï Ï := <span class="hljs-keyword">fun</span> env =&gt; env
</code></pre>
<p>By convention, the Greek letter <code class="hljs">Ï</code>, which is pronounced "rho", is used for environments.</p>
<p>The fact that constants in arithmetic expressions evaluate to constant functions suggests that the appropriate definition of <code class="hljs">pure</code> for <code class="hljs">Reader</code> is a a constant function:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">R</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span>.<span class="hljs-title">p</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">e</span> <span class="hljs-params">(x : Î±)</span> <span class="hljs-symbol">:</span></span> Reader Ï Î± := <span class="hljs-keyword">fun</span> _ =&gt; x
</code></pre>
<p>On the other hand, <code class="hljs">bind</code> is a bit tricker.
Its type is <code class="hljs">Reader Ï Î± â (Î± â Reader Ï Î²) â Reader Ï Î²</code>.
This type can be easier to understand by expanding the definitions of <code class="hljs">Reader</code>, which yields <code class="hljs">(Ï â Î±) â (Î± â Ï â Î²) â Ï â Î²</code>.
It should take an environment-accepting function as its first argument, while the second argument should transform the result of the environment-accepting function into yet another environment-accepting function.
The result of combining these is itself a function, waiting for an environment.</p>
<p>It's possible to use Lean interactively to get help writing this function.
The first step is to write down the arguments and return type, being very explicit in order to get as much help as possible, with an underscore for the definition's body:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">R</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span>.<span class="hljs-title">b</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">{Ï : <span class="hljs-built_in">Type</span>}</span> <span class="hljs-params">{Î± : <span class="hljs-built_in">Type</span>}</span> <span class="hljs-params">{Î² : <span class="hljs-built_in">Type</span>}</span>
  <span class="hljs-params">(result : Ï â Î±)</span> <span class="hljs-params">(next : Î± â Ï â Î²)</span> <span class="hljs-symbol">:</span></span> Ï â Î² :=
  _
</code></pre>
<p>Lean provides a message that describes which variables are available in scope, and the type that's expected for the result.
The <code class="hljs">â¢</code> symbol, called a <em>turnstile</em> due to its resemblance to subway entrances, separates the local variables from the desired type, which is <code class="hljs">Ï â Î²</code> in this message:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Ï Î± Î² : Type
result : Ï â Î±
next : Î± â Ï â Î²
â¢ Ï â Î²
</code></pre>
<p>Because the return type is a function, a good first step is to wrap a <code class="hljs">fun</code> around the underscore:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">R</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span>.<span class="hljs-title">b</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">{Ï : <span class="hljs-built_in">Type</span>}</span> <span class="hljs-params">{Î± : <span class="hljs-built_in">Type</span>}</span> <span class="hljs-params">{Î² : <span class="hljs-built_in">Type</span>}</span>
  <span class="hljs-params">(result : Ï â Î±)</span> <span class="hljs-params">(next : Î± â Ï â Î²)</span> <span class="hljs-symbol">:</span></span> Ï â Î² :=
  <span class="hljs-keyword">fun</span> env =&gt; _
</code></pre>
<p>The resulting message now shows the function's argument as a local variable:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Ï Î± Î² : Type
result : Ï â Î±
next : Î± â Ï â Î²
env : Ï
â¢ Î²
</code></pre>
<p>The only thing in the context that can produce a <code class="hljs">Î²</code> is <code class="hljs">next</code>, and it will require two arguments to do so.
Each argument can itself be an underscore:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">R</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span>.<span class="hljs-title">b</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">{Ï : <span class="hljs-built_in">Type</span>}</span> <span class="hljs-params">{Î± : <span class="hljs-built_in">Type</span>}</span> <span class="hljs-params">{Î² : <span class="hljs-built_in">Type</span>}</span>
  <span class="hljs-params">(result : Ï â Î±)</span> <span class="hljs-params">(next : Î± â Ï â Î²)</span> <span class="hljs-symbol">:</span></span> Ï â Î² :=
  <span class="hljs-keyword">fun</span> env =&gt; next _ _
</code></pre>
<p>The two underscores have the following respective messages associated with them:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Ï Î± Î² : Type
result : Ï â Î±
next : Î± â Ï â Î²
env : Ï
â¢ Î±
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Ï Î± Î² : Type
result : Ï â Î±
next : Î± â Ï â Î²
env : Ï
â¢ Ï
</code></pre>
<p>Attacking the first underscore, only one thing in the context can produce an <code class="hljs">Î±</code>, namely <code class="hljs">result</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">R</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span>.<span class="hljs-title">b</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">{Ï : <span class="hljs-built_in">Type</span>}</span> <span class="hljs-params">{Î± : <span class="hljs-built_in">Type</span>}</span> <span class="hljs-params">{Î² : <span class="hljs-built_in">Type</span>}</span>
  <span class="hljs-params">(result : Ï â Î±)</span> <span class="hljs-params">(next : Î± â Ï â Î²)</span> <span class="hljs-symbol">:</span></span> Ï â Î² :=
  <span class="hljs-keyword">fun</span> env =&gt; next (result _) _
</code></pre>
<p>Now, both underscores have the same error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Ï Î± Î² : Type
result : Ï â Î±
next : Î± â Ï â Î²
env : Ï
â¢ Ï
</code></pre>
<p>Happily, both underscores can be replaced by <code class="hljs">env</code>, yielding:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">R</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span>.<span class="hljs-title">b</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">{Ï : <span class="hljs-built_in">Type</span>}</span> <span class="hljs-params">{Î± : <span class="hljs-built_in">Type</span>}</span> <span class="hljs-params">{Î² : <span class="hljs-built_in">Type</span>}</span>
  <span class="hljs-params">(result : Ï â Î±)</span> <span class="hljs-params">(next : Î± â Ï â Î²)</span> <span class="hljs-symbol">:</span></span> Ï â Î² :=
  <span class="hljs-keyword">fun</span> env =&gt; next (result env) env
</code></pre>
<p>The final version can be obtained by undoing the expansion of <code class="hljs">Reader</code> and cleaning up the explicit details:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">R</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span>.<span class="hljs-title">b</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">(result : Reader Ï Î±)</span> <span class="hljs-params">(next : Î± â Reader Ï Î²)</span> <span class="hljs-symbol">:</span></span> Reader Ï Î² :=
  <span class="hljs-keyword">fun</span> env =&gt; next (result env) env
</code></pre>
<p>It's not always possible to write correct functions by simply "following the types", and it carries the risk of not understanding the resulting program.
However, it can also be easier to understand a program that has been written than one that has not, and the process of filling in the underscores can bring insights.
In this case, <code class="hljs">Reader.bind</code> works just like <code class="hljs">bind</code> for <code class="hljs">Id</code>, except it accepts an additional argument that it then passes down to its arguments, and this intuition can help in understanding how it works.</p>
<p><code class="hljs">Reader.pure</code>, which generates constant functions, and <code class="hljs">Reader.bind</code> obey the monad contract.
To check that <code class="hljs">Reader.bind (Reader.pure v) f</code> is the same as <code class="hljs">f v</code>, it's enough to replace definitions until the last step:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">Reader.bind (Reader.pure v) f
===&gt;
<span class="hljs-keyword">fun</span> env =&gt; f ((Reader.pure v) env) env
===&gt;
<span class="hljs-keyword">fun</span> env =&gt; f ((<span class="hljs-keyword">fun</span> _ =&gt; v) env) env
===&gt;
<span class="hljs-keyword">fun</span> env =&gt; f v env
===&gt;
f v
</code></pre>
<p>For every function <code class="hljs">f</code>, <code class="hljs">fun x =&gt; f x</code> is the same as <code class="hljs">f</code>, so the first part of the contract is satisfied.
To check that <code class="hljs">Reader.bind r Reader.pure</code> is the same as <code class="hljs">r</code>, a similar technique works:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">Reader.bind r Reader.pure
===&gt;
<span class="hljs-keyword">fun</span> env =&gt; Reader.pure (r env) env
===&gt;
<span class="hljs-keyword">fun</span> env =&gt; (<span class="hljs-keyword">fun</span> _ =&gt; (r env)) env
===&gt;
<span class="hljs-keyword">fun</span> env =&gt; r env
</code></pre>
<p>Because reader actions <code class="hljs">r</code> are themselves functions, this is the same as <code class="hljs">r</code>.
To check associativity, the same thing can be done for both <code class="hljs">Reader.bind (Reader.bind r f) g</code> and <code class="hljs">Reader.bind r (fun x =&gt; Reader.bind (f x) g)</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">Reader.bind (Reader.bind r f) g
===&gt;
<span class="hljs-keyword">fun</span> env =&gt; g ((Reader.bind r f) env) env
===&gt;
<span class="hljs-keyword">fun</span> env =&gt; g ((<span class="hljs-keyword">fun</span> env' =&gt; f (r env') env') env) env
===&gt;
<span class="hljs-keyword">fun</span> env =&gt; g (f (r env) env) env
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">Reader.bind r (<span class="hljs-keyword">fun</span> x =&gt; Reader.bind (f x) g)
===&gt;
Reader.bind r (<span class="hljs-keyword">fun</span> x =&gt; <span class="hljs-keyword">fun</span> env =&gt; g (f x env) env)
===&gt;
<span class="hljs-keyword">fun</span> env =&gt; (<span class="hljs-keyword">fun</span> x =&gt; <span class="hljs-keyword">fun</span> env' =&gt; g (f x env') env') (r env) env
===&gt;
<span class="hljs-keyword">fun</span> env =&gt; (<span class="hljs-keyword">fun</span> env' =&gt; g (f (r env) env') env') env
===&gt;
<span class="hljs-keyword">fun</span> env =&gt; g (f (r env) env) env
</code></pre>
<p>Thus, a <code class="hljs">Monad (Reader Ï)</code> instance is justified:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Monad (Reader Ï) <span class="hljs-keyword">where</span>
  pure x := <span class="hljs-keyword">fun</span> _ =&gt; x
  bind x f := <span class="hljs-keyword">fun</span> env =&gt; f (x env) env
</code></pre>
<p>The custom environments that will be passed to the expression evaluator can be represented as lists of pairs:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">abbrev</span> Env : <span class="hljs-built_in">Type</span> := List (String Ã (Int â Int â Int))
</code></pre>
<p>For instance, <code class="hljs">exampleEnv</code> contains maximum and modulus functions:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">x</span><span class="hljs-title">a</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">E</span><span class="hljs-title">n</span><span class="hljs-title">v</span> <span class="hljs-symbol">:</span></span> Env := [(<span class="hljs-string">"max"</span>, max), (<span class="hljs-string">"mod"</span>, (Â· % Â·))]
</code></pre>
<p>Lean already has a function <code class="hljs">List.lookup</code> that finds the value associated with a key in a list of pairs, so <code class="hljs">applyPrimReader</code> needs only check whether the custom function is present in the environment. It returns <code class="hljs">0</code> if the function is unknown:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">y</span><span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">m</span><span class="hljs-title">R</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(op : String)</span> <span class="hljs-params">(x : Int)</span> <span class="hljs-params">(y : Int)</span> <span class="hljs-symbol">:</span></span> Reader Env Int :=
  read &gt;&gt;= <span class="hljs-keyword">fun</span> env =&gt;
  <span class="hljs-keyword">match</span> env.lookup op <span class="hljs-keyword">with</span>
  | none =&gt; pure <span class="hljs-number">0</span>
  | some f =&gt; pure (f x y)
</code></pre>
<p>Using <code class="hljs">evaluateM</code> with <code class="hljs">applyPrimReader</code> and an expression results in a function that expects an environment.
Luckily, <code class="hljs">exampleEnv</code> is available:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> Expr Prim <span class="hljs-keyword">in</span>
<span class="hljs-keyword">#eval</span> evaluateM applyPrimReader (prim (other <span class="hljs-string">"max"</span>) (prim plus (const <span class="hljs-number">5</span>) (const <span class="hljs-number">4</span>)) (prim times (const <span class="hljs-number">3</span>) (const <span class="hljs-number">2</span>))) exampleEnv
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">9
</code></pre>
<p>Like <code class="hljs">Many</code>, <code class="hljs">Reader</code> is an example of an effect that is difficult to encode in most languages, but type classes and monads make it just as convenient as any other effect.
The dynamic or special variables found in Common Lisp, Clojure, and Emacs Lisp can be used like <code class="hljs">Reader</code>.
Similarly, Scheme and Racket's parameter objects are an effect that exactly correspond to <code class="hljs">Reader</code>.
The Kotlin idiom of context objects can solve a similar problem, but they are fundamentally a means of passing function arguments automatically, so this idiom is more like the encoding as a reader monad than it is an effect in the language.</p>
<h2 id="exercises-10"><a class="header" href="#exercises-10">Exercises</a></h2>
<h3 id="checking-contracts"><a class="header" href="#checking-contracts">Checking Contracts</a></h3>
<p>Check the monad contract for <code class="hljs">State Ï</code> and <code class="hljs">Except Îµ</code>.</p>
<h3 id="readers-with-failure"><a class="header" href="#readers-with-failure">Readers with Failure</a></h3>
<p>Adapt the reader monad example so that it can also indicate failure when the custom operator is not defined, rather than just returning zero.
In other words, given these definitions:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">R</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">O</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span> <span class="hljs-params">(Ï : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> := Ï â Option Î±

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">R</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">E</span><span class="hljs-title">x</span><span class="hljs-title">c</span><span class="hljs-title">e</span><span class="hljs-title">p</span><span class="hljs-title">t</span> <span class="hljs-params">(Îµ : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(Ï : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> := Ï â Except Îµ Î±
</code></pre>
<p>do the following:</p>
<ol>
<li>Write suitable <code class="hljs">pure</code> and <code class="hljs">bind</code> functions</li>
<li>Check that these functions satisfy the <code class="hljs">Monad</code> contract</li>
<li>Write <code class="hljs">Monad</code> instances for <code class="hljs">ReaderOption</code> and <code class="hljs">ReaderExcept</code></li>
<li>Define suitable <code class="hljs">applyPrim</code> operators and test them with <code class="hljs">evaluateM</code> on some example expressions</li>
</ol>
<h3 id="a-tracing-evaluator"><a class="header" href="#a-tracing-evaluator">A Tracing Evaluator</a></h3>
<p>The <code class="hljs">WithLog</code> type can be used with the evaluator to add optional tracing of some operations.
In particular, the type <code class="hljs">ToTrace</code> can serve as a signal to trace a given operator:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> ToTrace (Î± : <span class="hljs-built_in">Type</span>) : <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  | trace : Î± â ToTrace Î±
</code></pre>
<p>For the tracing evaluator, expressions should have type <code class="hljs">Expr (Prim (ToTrace (Prim Empty)))</code>.
This says that the operators in the expression consist of addition, subtraction, and multiplication, augmented with traced versions of each. The innermost argument is <code class="hljs">Empty</code> to signal that there are no further special operators inside of <code class="hljs">trace</code>, only the three basic ones.</p>
<p>Do the following:</p>
<ol>
<li>Implement a <code class="hljs">Monad (WithLog logged)</code> instance</li>
<li>Write an <code class="hljs">applyTraced</code> function to apply traced operators to their arguments, logging both the operator and the arguments, with type <code class="hljs">ToTrace (Prim Empty) â Int â Int â WithLog (Prim Empty Ã Int Ã Int) Int</code></li>
</ol>
<p>If the exercise has been completed correctly, then</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">open</span> Expr Prim ToTrace <span class="hljs-keyword">in</span>
<span class="hljs-keyword">#eval</span> evaluateM applyTraced (prim (other (trace times)) (prim (other (trace plus)) (const <span class="hljs-number">1</span>) (const <span class="hljs-number">2</span>)) (prim (other (trace minus)) (const <span class="hljs-number">3</span>) (const <span class="hljs-number">4</span>)))
</code></pre>
<p>should result in</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">{ log := [(Prim.plus, 1, 2), (Prim.minus, 3, 4), (Prim.times, 3, -1)], val := -3 }
</code></pre>
<p>Hint: values of type <code class="hljs">Prim Empty</code> will appear in the resulting log. In order to display them as a result of <code class="hljs">#eval</code>, the following instances are required:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">deriving</span> <span class="hljs-keyword">instance</span> Repr <span class="hljs-keyword">for</span> WithLog
<span class="hljs-keyword">deriving</span> <span class="hljs-keyword">instance</span> Repr <span class="hljs-keyword">for</span> Empty
<span class="hljs-keyword">deriving</span> <span class="hljs-keyword">instance</span> Repr <span class="hljs-keyword">for</span> Prim
</code></pre>
<div style="break-before:page;page-break-before:always"></div><h1 id="do-notation-for-monads"><a class="header" href="#do-notation-for-monads"><code>do</code>-Notation for Monads</a></h1>
<p>While APIs based on monads are very powerful, the explicit use of <code class="hljs">&gt;&gt;=</code> with anonymous functions is still somewhat noisy.
Just as infix operators are used instead of explicit calls to <code class="hljs">HAdd.hAdd</code>, Lean provides a syntax for monads called <em><code class="hljs">do</code>-notation</em> that can make programs that use monads easier to read and write.
This is the very same <code class="hljs">do</code>-notation that is used to write programs in <code class="hljs">IO</code>, and <code class="hljs">IO</code> is also a monad.</p>
<p>In <a href="https://leanprover.github.io/functional_programming_in_lean/hello-world.html">Hello, World!</a>, the <code class="hljs">do</code> syntax is used to combine <code class="hljs">IO</code> actions, but the meaning of these programs is explained directly.
Understanding how to program with monads means that <code class="hljs">do</code> can now be explained in terms of how it translates into uses of the underlying monad operators.</p>
<p>The first translation of <code class="hljs">do</code> is used when the only statement in the <code class="hljs">do</code> is a single expression <code class="hljs">E</code>.
In this case, the <code class="hljs">do</code> is removed, so</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">do</span> E
</code></pre>
<p>translates to</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">E
</code></pre>
<p>The second translation is used when the first statement of the <code class="hljs">do</code> is a <code class="hljs">let</code> with an arrow, binding a local variable.
This translates to a use of <code class="hljs">&gt;&gt;=</code> together with a function that binds that very same variable, so</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">do</span> <span class="hljs-keyword">let</span> x â E1
   Stmt
   ...
   En
</code></pre>
<p>translates to</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">E1 &gt;&gt;= <span class="hljs-keyword">fun</span> x =&gt;
<span class="hljs-keyword">do</span> Stmt
   ...
   En
</code></pre>
<p>When the first statement of the <code class="hljs">do</code> block is an expression, then it is considered to be a monadic action that returns <code class="hljs">Unit</code>, so the function matches the <code class="hljs">Unit</code> constructor and</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">do</span> E1
   Stmt
   ...
   En
</code></pre>
<p>translates to</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">E1 &gt;&gt;= <span class="hljs-keyword">fun</span> () =&gt;
<span class="hljs-keyword">do</span> Stmt
   ...
   En
</code></pre>
<p>Finally, when the first statement of the <code class="hljs">do</code> block is a <code class="hljs">let</code> that uses <code class="hljs">:=</code>, the translated form is an ordinary let expression, so</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">do</span> <span class="hljs-keyword">let</span> x := E1
   Stmt
   ...
   En
</code></pre>
<p>translates to</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">let</span> x := E1
<span class="hljs-keyword">do</span> Stmt
   ...
   En
</code></pre>
<p>The definition of <code class="hljs">firstThirdFifthSeventh</code> that uses the <code class="hljs">Monad</code> class looks like this:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">d</span><span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">f</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">S</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">h</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">(lookup : List Î± â Nat â m Î±)</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> m (Î± Ã Î± Ã Î± Ã Î±) :=
  lookup xs <span class="hljs-number">0</span> &gt;&gt;= <span class="hljs-keyword">fun</span> first =&gt;
  lookup xs <span class="hljs-number">2</span> &gt;&gt;= <span class="hljs-keyword">fun</span> third =&gt;
  lookup xs <span class="hljs-number">4</span> &gt;&gt;= <span class="hljs-keyword">fun</span> fifth =&gt;
  lookup xs <span class="hljs-number">6</span> &gt;&gt;= <span class="hljs-keyword">fun</span> seventh =&gt;
  pure (first, third, fifth, seventh)
</code></pre>
<p>Using <code class="hljs">do</code>-notation, it becomes significantly more readable:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">d</span><span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">f</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">S</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">h</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">(lookup : List Î± â Nat â m Î±)</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> m (Î± Ã Î± Ã Î± Ã Î±) := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> first â lookup xs <span class="hljs-number">0</span>
  <span class="hljs-keyword">let</span> third â lookup xs <span class="hljs-number">2</span>
  <span class="hljs-keyword">let</span> fifth â lookup xs <span class="hljs-number">4</span>
  <span class="hljs-keyword">let</span> seventh â lookup xs <span class="hljs-number">6</span>
  pure (first, third, fifth, seventh)
</code></pre>
<p>Without the <code class="hljs">Monad</code> type class, the function <code class="hljs">number</code> that numbers the nodes of a tree was written:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">n</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">b</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(t : BinTree Î±)</span> <span class="hljs-symbol">:</span></span> BinTree (Nat Ã Î±) :=
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> helper : BinTree Î± â State Nat (BinTree (Nat Ã Î±))
    | BinTree.leaf =&gt; ok BinTree.leaf
    | BinTree.branch left x right =&gt;
      helper left ~~&gt; <span class="hljs-keyword">fun</span> numberedLeft =&gt;
      get ~~&gt; <span class="hljs-keyword">fun</span> n =&gt;
      set (n + <span class="hljs-number">1</span>) ~~&gt; <span class="hljs-keyword">fun</span> () =&gt;
      helper right ~~&gt; <span class="hljs-keyword">fun</span> numberedRight =&gt;
      ok (BinTree.branch numberedLeft (n, x) numberedRight)
  (helper t <span class="hljs-number">0</span>).snd
</code></pre>
<p>With <code class="hljs">Monad</code> and <code class="hljs">do</code>, its definition is much less noisy:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">n</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">b</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(t : BinTree Î±)</span> <span class="hljs-symbol">:</span></span> BinTree (Nat Ã Î±) :=
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> helper : BinTree Î± â State Nat (BinTree (Nat Ã Î±))
    | BinTree.leaf =&gt; pure BinTree.leaf
    | BinTree.branch left x right =&gt; <span class="hljs-keyword">do</span>
      <span class="hljs-keyword">let</span> numberedLeft â helper left
      <span class="hljs-keyword">let</span> n â get
      set (n + <span class="hljs-number">1</span>)
      <span class="hljs-keyword">let</span> numberedRight â helper right
      ok (BinTree.branch numberedLeft (n, x) numberedRight)
  (helper t <span class="hljs-number">0</span>).snd
</code></pre>
<p>All of the conveniences from <code class="hljs">do</code> with <code class="hljs">IO</code> are also available when using it with other monads.
For example, nested actions also work in any monad.
The original definition of <code class="hljs">mapM</code> was:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">M</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">(f : Î± â m Î²)</span> <span class="hljs-symbol">:</span></span> List Î± â m (List Î²)
  | [] =&gt; pure []
  | x :: xs =&gt;
    f x &gt;&gt;= <span class="hljs-keyword">fun</span> hd =&gt;
    mapM f xs &gt;&gt;= <span class="hljs-keyword">fun</span> tl =&gt;
    pure (hd :: tl)
</code></pre>
<p>With <code class="hljs">do</code>-notation, it can be written:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">M</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">(f : Î± â m Î²)</span> <span class="hljs-symbol">:</span></span> List Î± â m (List Î²)
  | [] =&gt; pure []
  | x :: xs =&gt; <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">let</span> hd â f x
    <span class="hljs-keyword">let</span> tl â mapM f xs
    pure (hd :: tl)
</code></pre>
<p>Using nested actions makes it almost as short as the original non-monadic <code class="hljs">map</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">M</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">(f : Î± â m Î²)</span> <span class="hljs-symbol">:</span></span> List Î± â m (List Î²)
  | [] =&gt; pure []
  | x :: xs =&gt; <span class="hljs-keyword">do</span>
    pure ((â f x) :: (â mapM f xs))
</code></pre>
<p>Using nested actions, <code class="hljs">number</code> can be made much more concise:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">c</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> State Nat Nat := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> n â get
  set (n + <span class="hljs-number">1</span>)
  pure n

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">n</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">b</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(t : BinTree Î±)</span> <span class="hljs-symbol">:</span></span> BinTree (Nat Ã Î±) :=
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> helper : BinTree Î± â State Nat (BinTree (Nat Ã Î±))
    | BinTree.leaf =&gt; pure BinTree.leaf
    | BinTree.branch left x right =&gt; <span class="hljs-keyword">do</span>
      pure (BinTree.branch (â helper left) ((â increment), x) (â helper right))
  (helper t <span class="hljs-number">0</span>).snd
</code></pre>
<h2 id="exercises-11"><a class="header" href="#exercises-11">Exercises</a></h2>
<ul>
<li>Rewrite <code class="hljs">evaluateM</code>, its helpers, and the different specific use cases using <code class="hljs">do</code>-notation instead of explicit calls to <code class="hljs">&gt;&gt;=</code>.</li>
<li>Rewrite <code class="hljs">firstThirdFifthSeventh</code> using nested actions.</li>
</ul>
<div style="break-before:page;page-break-before:always"></div><h1 id="the-io-monad"><a class="header" href="#the-io-monad">The IO Monad</a></h1>
<p><code class="hljs">IO</code> as a monad can be understood from two perspectives, which were described in the section on <a href="https://leanprover.github.io/functional_programming_in_lean/hello-world/running-a-program.html">running programs</a>.
Each can help to understand the meanings of <code class="hljs">pure</code> and <code class="hljs">bind</code> for <code class="hljs">IO</code>.</p>
<p>From the first perspective, an <code class="hljs">IO</code> action is an instruction to Lean's run-time system.
For example, the instruction might be "read a string from this file descriptor, then re-invoke the pure Lean code with the string".
This perspective is an <em>exterior</em> one, viewing the program from the perspective of the operating system.
In this case, <code class="hljs">pure</code> is an <code class="hljs">IO</code> action that does not request any effects from the RTS, and <code class="hljs">bind</code> instructs the RTS to first carry out one potentially-effectful operation and then invoke the rest of the program with the resulting value.</p>
<p>From the second perspective, an <code class="hljs">IO</code> action transforms the whole world.
<code class="hljs">IO</code> actions are actually pure, because they receive a unique world as an argument and then return the changed world.
This perspective is an <em>interior</em> one that matches how <code class="hljs">IO</code> is represented inside of Lean.
The world is represented in Lean as a token, and the <code class="hljs">IO</code> monad is structured to make sure that each token is used exactly once.</p>
<p>To see how this works, it can be helpful to peel back one definition at a time.
The <code class="hljs">#print</code> command reveals the internals of Lean datatypes and definitions.
For example,</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#print</span> Nat
</code></pre>
<p>results in</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">inductive Nat : Type
number of parameters: 0
constructors:
Nat.zero : Nat
Nat.succ : Nat â Nat
</code></pre>
<p>and</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#print</span> Char.isAlpha
</code></pre>
<p>results in</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">def Char.isAlpha : Char â Bool :=
fun c =&gt; Char.isUpper c || Char.isLower c
</code></pre>
<p>Sometimes, the output of <code class="hljs">#print</code> includes Lean features that have not yet been presented in this book.
For example,</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#print</span> List.isEmpty
</code></pre>
<p>produces</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">def List.isEmpty.{u} : {Î± : Type u} â List Î± â Bool :=
fun {Î±} x =&gt;
  match x with
  | [] =&gt; true
  | head :: tail =&gt; false
</code></pre>
<p>which includes a <code class="hljs">.{u}</code> after the definition's name, and annotates types as <code class="hljs">Type u</code> rather than just <code class="hljs">Type</code>.
This can be safely ignored for now.</p>
<p>Printing the definition of <code class="hljs">IO</code> shows that it's defined in terms of simpler structures:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#print</span> IO
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">@[reducible] def IO : Type â Type :=
EIO IO.Error
</code></pre>
<p><code class="hljs">IO.Error</code> represents all the errors that could be thrown by an <code class="hljs">IO</code> action:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#print</span> IO.Error
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">inductive IO.Error : Type
number of parameters: 0
constructors:
IO.Error.alreadyExists : Option String â UInt32 â String â IO.Error
IO.Error.otherError : UInt32 â String â IO.Error
IO.Error.resourceBusy : UInt32 â String â IO.Error
IO.Error.resourceVanished : UInt32 â String â IO.Error
IO.Error.unsupportedOperation : UInt32 â String â IO.Error
IO.Error.hardwareFault : UInt32 â String â IO.Error
IO.Error.unsatisfiedConstraints : UInt32 â String â IO.Error
IO.Error.illegalOperation : UInt32 â String â IO.Error
IO.Error.protocolError : UInt32 â String â IO.Error
IO.Error.timeExpired : UInt32 â String â IO.Error
IO.Error.interrupted : String â UInt32 â String â IO.Error
IO.Error.noFileOrDirectory : String â UInt32 â String â IO.Error
IO.Error.invalidArgument : Option String â UInt32 â String â IO.Error
IO.Error.permissionDenied : Option String â UInt32 â String â IO.Error
IO.Error.resourceExhausted : Option String â UInt32 â String â IO.Error
IO.Error.inappropriateType : Option String â UInt32 â String â IO.Error
IO.Error.noSuchThing : Option String â UInt32 â String â IO.Error
IO.Error.unexpectedEof : IO.Error
IO.Error.userError : String â IO.Error
</code></pre>
<p><code class="hljs">EIO Îµ Î±</code> represents <code class="hljs">IO</code> actions that will either terminate with an error of type <code class="hljs">Îµ</code> or succeed with a value of type <code class="hljs">Î±</code>.
This means that, like the <code class="hljs">Except Îµ</code> monad, the <code class="hljs">IO</code> monad includes the ability to define error handling and exceptions.</p>
<p>Peeling back another layer, <code class="hljs">EIO</code> is itself defined in terms of a simpler structure:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#print</span> EIO
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">def EIO : Type â Type â Type :=
fun Îµ =&gt; EStateM Îµ IO.RealWorld
</code></pre>
<p>The <code class="hljs">EStateM</code> monad includes both errors and stateâit's a combination of <code class="hljs">Except</code> and <code class="hljs">State</code>.
It is defined using another type, <code class="hljs">EStateM.Result</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#print</span> EStateM
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">def EStateM.{u} : Type u â Type u â Type u â Type u :=
fun Îµ Ï Î± =&gt; Ï â EStateM.Result Îµ Ï Î±
</code></pre>
<p>In other words, a program with type <code class="hljs">EStateM Îµ Ï Î±</code> is a function that accepts an initial state of type <code class="hljs">Ï</code> and returns an <code class="hljs">EStateM.Result Îµ Ï Î±</code>.</p>
<p><code class="hljs">EStateM.Result</code> is very much like the definition of <code class="hljs">Except</code>, with one constructor that indicates a successful termination and one constructor that indicates an error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#print</span> EStateM.Result
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">inductive EStateM.Result.{u} : Type u â Type u â Type u â Type u
number of parameters: 3
constructors:
EStateM.Result.ok : {Îµ Ï Î± : Type u} â Î± â Ï â EStateM.Result Îµ Ï Î±
EStateM.Result.error : {Îµ Ï Î± : Type u} â Îµ â Ï â EStateM.Result Îµ Ï Î±
</code></pre>
<p>Just like <code class="hljs">Except Îµ Î±</code>, the <code class="hljs">ok</code> constructor includes a result of type <code class="hljs">Î±</code>, and the <code class="hljs">error</code> constructor includes an exception of type <code class="hljs">Îµ</code>.
Unlike <code class="hljs">Except</code>, both constructors have an additional state field that includes the final state of the computation.</p>
<p>The <code class="hljs">Monad</code> instance for <code class="hljs">EStateM Îµ Ï</code> requires <code class="hljs">pure</code> and <code class="hljs">bind</code>.
Just as with <code class="hljs">State</code>, the implementation of <code class="hljs">pure</code> for <code class="hljs">EStateM</code> accepts an initial state and returns it unchanged, and just as with <code class="hljs">Except</code>, it returns its argument in the <code class="hljs">ok</code> constructor:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#print</span> EStateM.pure
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">protected def EStateM.pure.{u} : {Îµ Ï Î± : Type u} â Î± â EStateM Îµ Ï Î± :=
fun {Îµ Ï Î±} a s =&gt; EStateM.Result.ok a s
</code></pre>
<p><code class="hljs">protected</code> means that the full name <code class="hljs">EStateM.pure</code> is needed even if the <code class="hljs">EStateM</code> namespace has been opened.</p>
<p>Similarly, <code class="hljs">bind</code> for <code class="hljs">EStateM</code> takes an initial state as an argument.
It passes this initial state to its first action.
Like <code class="hljs">bind</code> for <code class="hljs">Except</code>, it then checks whether the result is an error.
If so, the error is returned unchanged and the second argument to <code class="hljs">bind</code> remains unused.
If the result was a success, then the second argument is applied to both the returned value and to the resulting state.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#print</span> EStateM.bind
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">protected def EStateM.bind.{u} : {Îµ Ï Î± Î² : Type u} â EStateM Îµ Ï Î± â (Î± â EStateM Îµ Ï Î²) â EStateM Îµ Ï Î² :=
fun {Îµ Ï Î± Î²} x f s =&gt;
  match x s with
  | EStateM.Result.ok a s =&gt; f a s
  | EStateM.Result.error e s =&gt; EStateM.Result.error e s
</code></pre>
<p>Putting all of this together, <code class="hljs">IO</code> is a monad that tracks state and errors at the same time.
The collection of available errors is that given by the datatype <code class="hljs">IO.Error</code>, which has constructors that describe many things that can go wrong in a program.
The state is a type that represents the real world, called <code class="hljs">IO.RealWorld</code>.
Each basic <code class="hljs">IO</code> action receives this real world and returns another one, paired either with an error or a result.
In <code class="hljs">IO</code>, <code class="hljs">pure</code> returns the world unchanged, while <code class="hljs">bind</code> passes the modified world from one action into the next action.</p>
<p>Because the entire universe doesn't fit in a computer's memory, the world being passed around is just a representation.
So long as world tokens are not re-used, the representation is safe.
This means that world tokens do not need to contain any data at all:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#print</span> IO.RealWorld
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">def IO.RealWorld : Type :=
Unit
</code></pre>
<div style="break-before:page;page-break-before:always"></div><h1 id="additional-conveniences-3"><a class="header" href="#additional-conveniences-3">Additional Conveniences</a></h1>
<h2 id="shared-argument-types"><a class="header" href="#shared-argument-types">Shared Argument Types</a></h2>
<p>When defining a function that takes multiple arguments that have the same type, both can be written before the same colon.
For example,</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">u</span><span class="hljs-title">a</span><span class="hljs-title">l?</span> <span class="hljs-params">[BEq Î±]</span> <span class="hljs-params">(x : Î±)</span> <span class="hljs-params">(y : Î±)</span> <span class="hljs-symbol">:</span></span> Option Î± :=
  <span class="hljs-keyword">if</span> x == y <span class="hljs-keyword">then</span>
    some x
  <span class="hljs-keyword">else</span>
    none
</code></pre>
<p>can be written</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">u</span><span class="hljs-title">a</span><span class="hljs-title">l?</span> <span class="hljs-params">[BEq Î±]</span> <span class="hljs-params">(x y : Î±)</span> <span class="hljs-symbol">:</span></span> Option Î± :=
  <span class="hljs-keyword">if</span> x == y <span class="hljs-keyword">then</span>
    some x
  <span class="hljs-keyword">else</span>
    none
</code></pre>
<p>This is especially useful when the type signature is large.</p>
<h2 id="leading-dot-notation"><a class="header" href="#leading-dot-notation">Leading Dot Notation</a></h2>
<p>The constructors of an inductive type are in a namespace.
This allows multiple related inductive types to use the same constructor names, but it can lead to programs becoming verbose.
In contexts where the inductive type in question is known, the namespace can be omitted by preceding the constructor's name with a dot, and Lean uses the expected type to resolve the constructor names.
For example, a function that mirrors a binary tree can be written:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">B</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span>.<span class="hljs-title">m</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">r</span> <span class="hljs-symbol">:</span></span> BinTree Î± â BinTree Î±
  | BinTree.leaf =&gt; BinTree.leaf
  | BinTree.branch l x r =&gt; BinTree.branch (mirror r) x (mirror l)
</code></pre>
<p>Omitting the namespaces makes it significantly shorter, at the cost of making the program harder to read in contexts like code review tools that don't include the Lean compiler:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">B</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span>.<span class="hljs-title">m</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">r</span> <span class="hljs-symbol">:</span></span> BinTree Î± â BinTree Î±
  | .leaf =&gt; .leaf
  | .branch l x r =&gt; .branch (mirror r) x (mirror l)
</code></pre>
<p>Using the expected type of an expression to disambiguate a namespace is also applicable to names other than constructors.
If <code class="hljs">BinTree.empty</code> is defined as an alternative way of creating <code class="hljs">BinTree</code>s, then it can also be used with dot notation:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">B</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span>.<span class="hljs-title">e</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">y</span> <span class="hljs-symbol">:</span></span> BinTree Î± := .leaf

<span class="hljs-keyword">#check</span> (.empty : BinTree Nat)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">BinTree.empty : BinTree Nat
</code></pre>
<h2 id="or-patterns"><a class="header" href="#or-patterns">Or-Patterns</a></h2>
<p>In contexts that allow multiple patterns, such as <code class="hljs">match</code>-expressions, multiple patterns may share their result expressions.
The datatype <code class="hljs">Weekday</code> that represents days of the week:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Weekday <span class="hljs-keyword">where</span>
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday
  | saturday
  | sunday
  <span class="hljs-keyword">deriving</span> Repr
</code></pre>
<p>Pattern matching can be used to check whether a day is a weekend:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">W</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">k</span><span class="hljs-title">d</span><span class="hljs-title">a</span><span class="hljs-title">y</span>.<span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">W</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">k</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">(day : Weekday)</span> <span class="hljs-symbol">:</span></span> Bool :=
  <span class="hljs-keyword">match</span> day <span class="hljs-keyword">with</span>
  | Weekday.saturday =&gt; true
  | Weekday.sunday =&gt; true
  | _ =&gt; false
</code></pre>
<p>This can already be simplified by using constructor dot notation:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">W</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">k</span><span class="hljs-title">d</span><span class="hljs-title">a</span><span class="hljs-title">y</span>.<span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">W</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">k</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">(day : Weekday)</span> <span class="hljs-symbol">:</span></span> Bool :=
  <span class="hljs-keyword">match</span> day <span class="hljs-keyword">with</span>
  | .saturday =&gt; true
  | .sunday =&gt; true
  | _ =&gt; false
</code></pre>
<p>Because both weekend patterns have the same result expression (<code class="hljs">true</code>), they can be condensed into one:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">W</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">k</span><span class="hljs-title">d</span><span class="hljs-title">a</span><span class="hljs-title">y</span>.<span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">W</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">k</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">(day : Weekday)</span> <span class="hljs-symbol">:</span></span> Bool :=
  <span class="hljs-keyword">match</span> day <span class="hljs-keyword">with</span>
  | .saturday | .sunday =&gt; true
  | _ =&gt; false
</code></pre>
<p>This can be further simplified into a version in which the argument is not named:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">W</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">k</span><span class="hljs-title">d</span><span class="hljs-title">a</span><span class="hljs-title">y</span>.<span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">W</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">k</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-symbol">:</span></span> Weekday â Bool
  | .saturday | .sunday =&gt; true
  | _ =&gt; false
</code></pre>
<p>Behind the scenes, the result expression is simply duplicated across each pattern.
This means that patterns can bind variables, as in this example that removes the <code class="hljs">inl</code> and <code class="hljs">inr</code> constructors from a sum type in which both contain the same type of value:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Î± â Î± â Î±
  | .inl x | .inr x =&gt; x
</code></pre>
<p>Because the result expression is duplicated, the variables bound by the patterns are not required to have the same types.
Overloaded functions that work for multiple types may be used to write a single result expression that works for patterns that bind variables of different types:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">g</span><span class="hljs-title">y</span> <span class="hljs-symbol">:</span></span> Nat â Weekday â String
  | .inl x | .inr x =&gt; s!<span class="hljs-string">"It is {repr x}"</span>
</code></pre>
<p>In practice, only variables shared in all patterns can be referred to in the result expression, because the result must make sense for each pattern.
In <code class="hljs">getTheNat</code>, only <code class="hljs">n</code> can be accessed, and attempts to use either <code class="hljs">x</code> or <code class="hljs">y</code> lead to errors.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> (Nat Ã Î±) â (Nat Ã Î²) â Nat
  | .inl (n, x) | .inr (n, y) =&gt; n
</code></pre>
<p>Attempting to access <code class="hljs">x</code> in a similar definition causes an error because there is no <code class="hljs">x</code> available in the second pattern:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">A</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">h</span><span class="hljs-title">a</span> <span class="hljs-symbol">:</span></span> (Nat Ã Î±) â (Nat Ã Î±) â Î±
  | .inl (n, x) | .inr (n, y) =&gt; x
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unknown identifier 'x'
</code></pre>
<p>The fact that the result expression is essentially copy-pasted to each branch of the pattern match can lead to some surprising behavior.
For example, the following definitions are acceptable because the <code class="hljs">inr</code> version of the result expression refers to the global definition of <code class="hljs">str</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">r</span> <span class="hljs-symbol">:</span></span>= <span class="hljs-string">"Some string"</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">S</span><span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">g</span> <span class="hljs-symbol">:</span></span> (Nat Ã String) â (Nat Ã Î²) â String
  | .inl (n, str) | .inr (n, y) =&gt; str
</code></pre>
<p>Calling this function on both constructors reveals the confusing behavior.
In the first case, a type annotation is needed to tell Lean which type <code class="hljs">Î²</code> should be:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> getTheString (.inl (<span class="hljs-number">20</span>, <span class="hljs-string">"twenty"</span>) : (Nat Ã String) â (Nat Ã String))
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">"twenty"
</code></pre>
<p>In the second case, the global definition is used:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> getTheString (.inr (<span class="hljs-number">20</span>, <span class="hljs-string">"twenty"</span>))
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">"Some string"
</code></pre>
<p>Using or-patterns can vastly simplify some definitions and increase their clarity, as in <code class="hljs">Weekday.isWeekend</code>.
Because there is a potential for confusing behavior, it's a good idea to be careful when using them, especially when variables of multiple types or disjoint sets of variables are involved.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="summary-3"><a class="header" href="#summary-3">Summary</a></h1>
<h2 id="encoding-side-effects"><a class="header" href="#encoding-side-effects">Encoding Side Effects</a></h2>
<p>Lean is a pure functional language.
This means that it does not include side effects such as mutable variables, logging, or exceptions.
However, most side effects can be <em>encoded</em> using a combination of functions and inductive types or structures.
For example, mutable state can be encoded as a function from an initial state to a pair of a final state and a result, and exceptions can be encoded as an inductive type with constructors for successful termination and errors.</p>
<p>Each set of encoded effects is a type.
As a result, if a program uses these encoded effects, then this is apparent in its type.
Functional programming does not mean that programs can't use effects, it simply requires that they be <em>honest</em> about which effects they use.
A Lean type signature describes not only the types of arguments that a function expects and the type of result that it returns, but also which effects it may use.</p>
<h2 id="the-monad-type-class-1"><a class="header" href="#the-monad-type-class-1">The Monad Type Class</a></h2>
<p>It's possible to write purely functional programs in languages that allow effects anywhere.
For example, <code class="hljs">2 + 3</code> is a valid Python program that has no effects at all.
Similarly, combining programs that have effects requires a way to state the order in which the effects must occur.
It matters whether an exception is thrown before or after modifying a variable, after all.</p>
<p>The type class <code class="hljs">Monad</code> captures these two important properties.
It has two methods: <code class="hljs">pure</code> represents programs that have no effects, and <code class="hljs">bind</code> sequences effectful programs.
The contract for <code class="hljs">Monad</code> instances ensures that <code class="hljs">bind</code> and <code class="hljs">pure</code> actually capture pure computation and sequencing.</p>
<h2 id="do-notation-for-monads-1"><a class="header" href="#do-notation-for-monads-1"><code>do</code>-Notation for Monads</a></h2>
<p>Rather than being limited to <code class="hljs">IO</code>, <code class="hljs">do</code>-notation works for any monad.
It allows programs that use monads to be written in a style that is reminiscent of statement-oriented languages, with statements sequenced after one another.
Additionally, <code class="hljs">do</code>-notation enables a number of additional convenient shorthands, such as nested actions.
A program written with <code class="hljs">do</code> is translated to applications of <code class="hljs">&gt;&gt;=</code> behind the scenes.</p>
<h2 id="custom-monads"><a class="header" href="#custom-monads">Custom Monads</a></h2>
<p>Different languages provide different sets of side effects.
While most languages feature mutable variables and file I/O, not all have features like exceptions.
Other languages offer effects that are rare or unique, like Icon's search-based program execution, Scheme and Ruby's continuations, and Common Lisp's resumable exceptions.
An advantage to encoding effects with monads is that programs are not limited to the set of effects that are provided by the language.
Because Lean is designed to make programming with any monad convenient, programmers are free to choose exactly the set of side effects that make sense for any given application.</p>
<h2 id="the-io-monad-1"><a class="header" href="#the-io-monad-1">The <code>IO</code> Monad</a></h2>
<p>Programs that can affect the real world are written as <code class="hljs">IO</code> actions in Lean.
<code class="hljs">IO</code> is one monad among many.
The <code class="hljs">IO</code> monad encodes state and exceptions, with the state being used to keep track of the state of the world and the exceptions modeling failure and recovery.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="functors-applicative-functors-and-monads"><a class="header" href="#functors-applicative-functors-and-monads">Functors, Applicative Functors, and Monads</a></h1>
<p><code class="hljs">Functor</code> and <code class="hljs">Monad</code> both describe operations for types that are still waiting for a type argument.
One way to understand them is that <code class="hljs">Functor</code> describes containers in which the contained data can be transformed, and <code class="hljs">Monad</code> describes an encoding of programs with side effects.
This understanding is incomplete, however.
After all, <code class="hljs">Option</code> has instances for both <code class="hljs">Functor</code> and <code class="hljs">Monad</code>, and simultaneously represents an optional value <em>and</em> a computation that might fail to return a value.</p>
<p>From the perspective of data structures, <code class="hljs">Option</code> is a bit like a nullable type or like a list that can contain at most one entry.
From the perspective of control structures, <code class="hljs">Option</code> represents a computation that might terminate early without a result.
Typically, programs that use the <code class="hljs">Functor</code> instance are easiest to think of as using <code class="hljs">Option</code> as a data structure, while programs that use the <code class="hljs">Monad</code> instance are easiest to think of as using <code class="hljs">Option</code> to allow early failure, but learning to use both of these perspectives fluently is an important part of becoming proficient at functional programming.</p>
<p>There is a deeper relationship between functors and monads.
It turns out that <em>every monad is a functor</em>.
Another way to say this is that the monad abstraction is more powerful than the functor abstraction, because not every functor is a monad.
Furthermore, there is an additional intermediate abstraction, called <em>applicative functors</em>, that has enough power to write many interesting programs and yet permits libraries that cannot use the <code class="hljs">Monad</code> interface.
The type class <code class="hljs">Applicative</code> provides the overloadable operations of applicative functors.
Every monad is an applicative functor, and every applicative functor is a functor, but the converses do not hold.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="structures-and-inheritance"><a class="header" href="#structures-and-inheritance">Structures and Inheritance</a></h1>
<p>In order to understand the full definitions of <code class="hljs">Functor</code>, <code class="hljs">Applicative</code>, and <code class="hljs">Monad</code>, another Lean feature is necessary: structure inheritance.
Structure inheritance allows one structure type to provide the interface of another, along with additional fields.
This can be useful when modeling concepts that have a clear taxonomic relationship.
For example, take a model of mythical creatures.
Some of them are large, and some are small:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">M</span><span class="hljs-title">y</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">C</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">e</span></span> <span class="hljs-keyword">where</span>
  large : Bool
<span class="hljs-keyword">deriving</span> Repr
</code></pre>
<p>Behind the scenes, defining the <code class="hljs">MythicalCreature</code> structure creates an inductive type with a single constructor called <code class="hljs">mk</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> MythicalCreature.mk
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">MythicalCreature.mk (large : Bool) : MythicalCreature
</code></pre>
<p>Similarly, a function <code class="hljs">MythicalCreature.large</code> is created that actually extracts the field from the constructor:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> MythicalCreature.large
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">MythicalCreature.large (self : MythicalCreature) : Bool
</code></pre>
<p>In most old stories, each monster can be defeated in some way.
A description of a monster should include this information, along with whether it is large:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">M</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">M</span><span class="hljs-title">y</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">C</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">e</span></span> <span class="hljs-keyword">where</span>
  vulnerability : String
<span class="hljs-keyword">deriving</span> Repr
</code></pre>
<p>The <code class="hljs">extends MythicalCreature</code> in the heading states that every monster is also mythical.
To define a <code class="hljs">Monster</code>, both the fields from <code class="hljs">MythicalCreature</code> and the fields from <code class="hljs">Monster</code> should be provided.
A troll is a large monster that is vulnerable to sunlight:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">l</span><span class="hljs-title">l</span> <span class="hljs-symbol">:</span></span> Monster <span class="hljs-keyword">where</span>
  large := true
  vulnerability := <span class="hljs-string">"sunlight"</span>
</code></pre>
<p>Behind the scenes, inheritance is implemented using composition.
The constructor <code class="hljs">Monster.mk</code> takes a <code class="hljs">MythicalCreature</code> as its argument:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> Monster.mk
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Monster.mk (toMythicalCreature : MythicalCreature) (vulnerability : String) : Monster
</code></pre>
<p>In addition to defining functions to extract the value of each new field, a function <code class="hljs">Monster.toMythicalCreature</code> is defined with type <code class="hljs">Monster â MythicalCreature</code>.
This can be used to extract the underlying creature.</p>
<p>Moving up the inheritance hierarchy in Lean is not the same thing as upcasting in object-oriented languages.
An upcast operator causes a value from a derived class to be treated as an instance of the parent class, but the value retains its identity and structure.
In Lean, however, moving up the inheritance hierarchy actually erases the underlying information.
To see this in action, consider the result of evaluating <code class="hljs">troll.toMythicalCreature</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> troll.toMythicalCreature
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">{ large := true }
</code></pre>
<p>Only the fields of <code class="hljs">MythicalCreature</code> remain.</p>
<p>Just like the <code class="hljs">where</code> syntax, curly-brace notation with field names also works with structure inheritance:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">l</span><span class="hljs-title">l</span> <span class="hljs-symbol">:</span></span> Monster := {large := true, vulnerability := <span class="hljs-string">"sunlight"</span>}
</code></pre>
<p>However, the anonymous angle-bracket notation that delegates to the underlying constructor reveals the internal details:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">l</span><span class="hljs-title">l</span> <span class="hljs-symbol">:</span></span> Monster := â¨true, <span class="hljs-string">"sunlight"</span>â©
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">application type mismatch
  Monster.mk true
argument
  true
has type
  Bool : Type
but is expected to have type
  MythicalCreature : Type
</code></pre>
<p>An extra set of angle brackets is required, which invokes <code class="hljs">MythicalCreature.mk</code> on <code class="hljs">true</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">l</span><span class="hljs-title">l</span> <span class="hljs-symbol">:</span></span> Monster := â¨â¨trueâ©, <span class="hljs-string">"sunlight"</span>â©
</code></pre>
<p>Lean's dot notation is capable of taking inheritance into account.
In other words, the existing <code class="hljs">MythicalCreature.large</code> can be used with a <code class="hljs">Monster</code>, and Lean automatically inserts the call to <code class="hljs">Monster.toMythicalCreature</code> before the call to <code class="hljs">MythicalCreature.large</code>.
However, this only occurs when using dot notation, and applying the field lookup function using normal function call syntax results in a type error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> MythicalCreature.large troll
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">application type mismatch
  troll.large
argument
  troll
has type
  Monster : Type
but is expected to have type
  MythicalCreature : Type
</code></pre>
<p>Dot notation can also take inheritance into account for user-defined functions.
A small creature is one that is not large:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">M</span><span class="hljs-title">y</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">C</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">e</span>.<span class="hljs-title">s</span><span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">l</span> <span class="hljs-params">(c : MythicalCreature)</span> <span class="hljs-symbol">:</span></span> Bool := !c.large
</code></pre>
<p>Evaluating <code class="hljs">troll.small</code> yields <code class="hljs">false</code>, while attempting to evaluate <code class="hljs">MythicalCreature.small troll</code> results in:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">application type mismatch
  MythicalCreature.small troll
argument
  troll
has type
  Monster : Type
but is expected to have type
  MythicalCreature : Type
</code></pre>
<h3 id="multiple-inheritance"><a class="header" href="#multiple-inheritance">Multiple Inheritance</a></h3>
<p>A helper is a mythical creature that can provide assistance when given the correct payment:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">H</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">M</span><span class="hljs-title">y</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">C</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">e</span></span> <span class="hljs-keyword">where</span>
  assistance : String
  payment : String
<span class="hljs-keyword">deriving</span> Repr
</code></pre>
<p>For example, a <em>nisse</em> is a kind of small elf that's known to help around the house when provided with tasty porridge:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">n</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Helper <span class="hljs-keyword">where</span>
  large := false
  assistance := <span class="hljs-string">"household tasks"</span>
  payment := <span class="hljs-string">"porridge"</span>
</code></pre>
<p>If domesticated, trolls make excellent helpers.
They are strong enough to plow a whole field in a single night, though they require model goats to keep them satisfied with their lot in life.
A monstrous assistant is a monster that is also a helper:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">M</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">A</span><span class="hljs-title">s</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">M</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span>, <span class="hljs-title">H</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span></span> <span class="hljs-keyword">where</span>
<span class="hljs-keyword">deriving</span> Repr
</code></pre>
<p>A value of this structure type must fill in all of the fields from both parent structures:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">d</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">l</span><span class="hljs-title">l</span> <span class="hljs-symbol">:</span></span> MonstrousAssistant <span class="hljs-keyword">where</span>
  large := false
  assistance := <span class="hljs-string">"heavy labor"</span>
  payment := <span class="hljs-string">"toy goats"</span>
  vulnerability := <span class="hljs-string">"sunlight"</span>
</code></pre>
<p>Both of the parent structure types extend <code class="hljs">MythicalCreature</code>.
If multiple inheritance were implemented naÃ¯vely, then this could lead to a "diamond problem", where it would be unclear which path to <code class="hljs">large</code> should be taken from a given <code class="hljs">MonstrousAssistant</code>.
Should it take <code class="hljs">large</code> from the contained <code class="hljs">Monster</code> or from the contained <code class="hljs">Helper</code>?
In Lean, the answer is that the first specified path to the grandparent structure is taken, and the additional parent structures' fields are copied rather than having the new structure include both parents directly.</p>
<p>This can be seen by examining the signature of the constructor for <code class="hljs">MonstrousAssistant</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> MonstrousAssistant.mk
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">MonstrousAssistant.mk (toMonster : Monster) (assistance payment : String) : MonstrousAssistant
</code></pre>
<p>It takes a <code class="hljs">Monster</code> as an argument, along with the two fields that <code class="hljs">Helper</code> introduces on top of <code class="hljs">MythicalCreature</code>.
Similarly, while <code class="hljs">MonstrousAssistant.toMonster</code> merely extracts the <code class="hljs">Monster</code> from the constructor, <code class="hljs">MonstrousAssistant.toHelper</code> has no <code class="hljs">Helper</code> to extract.
The <code class="hljs">#print</code> command exposes its implementation:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#print</span> MonstrousAssistant.toHelper
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">@[reducible] def MonstrousAssistant.toHelper : MonstrousAssistant â Helper :=
fun self =&gt;
  { toMythicalCreature := self.toMonster.toMythicalCreature, assistance := self.assistance, payment := self.payment }
</code></pre>
<p>This function constructs a <code class="hljs">Helper</code> from the fields of <code class="hljs">MonstrousAssistant</code>.
The <code class="hljs">@[reducible]</code> attribute has the same effect as writing <code class="hljs">abbrev</code>.</p>
<h3 id="default-declarations"><a class="header" href="#default-declarations">Default Declarations</a></h3>
<p>When one structure inherits from another, default field definitions can be used to instantiate the parent structure's fields based on the child structure's fields.
If more size specificity is required than whether a creature is large or not, a dedicated datatype describing sizes can be used together with inheritance, yielding a structure in which the <code class="hljs">large</code> field is computed from the contents of the <code class="hljs">size</code> field:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Size <span class="hljs-keyword">where</span>
  | small
  | medium
  | large
<span class="hljs-keyword">deriving</span> BEq

<span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">S</span><span class="hljs-title">i</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">d</span><span class="hljs-title">C</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">e</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">M</span><span class="hljs-title">y</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">C</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">e</span></span> <span class="hljs-keyword">where</span>
  size : Size
  large := size == Size.large
</code></pre>
<p>This default definition is only a default definition, however.
Unlike property inheritance in a language like C# or Scala, the definitions in the child structure are only used when no specific value for <code class="hljs">large</code> is provided, and nonsensical results can occur:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">C</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> SizedCreature <span class="hljs-keyword">where</span>
  large := false
  size := .large
</code></pre>
<p>If the child structure should not deviate from the parent structure, there are a few options:</p>
<ol>
<li>Documenting the relationship, as is done for <code class="hljs">BEq</code> and <code class="hljs">Hashable</code></li>
<li>Defining a proposition that the fields are related appropriately, and designing the API to require evidence that the proposition is true where it matters</li>
<li>Not using inheritance at all</li>
</ol>
<p>The second option could look like this:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">abbrev</span> SizesMatch (sc : SizedCreature) : <span class="hljs-built_in">Prop</span> :=
  sc.large = (sc.size == Size.large)
</code></pre>
<p>Note that a single equality sign is used to indicate the equality <em>proposition</em>, while a double equality sign is used to indicate a function that checks equality and returns a <code class="hljs">Bool</code>.
<code class="hljs">SizesMatch</code> is defined as an <code class="hljs">abbrev</code> because it should automatically be unfolded in proofs, so that <code class="hljs">simp</code> can see the equality that should be proven.</p>
<p>A <em>huldre</em> is a medium-sized mythical creatureâin fact, they are the same size as humans.
The two sized fields on <code class="hljs">huldre</code> match one another:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">h</span><span class="hljs-title">u</span><span class="hljs-title">l</span><span class="hljs-title">d</span><span class="hljs-title">r</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> SizedCreature <span class="hljs-keyword">where</span>
  size := .medium

<span class="hljs-keyword">example</span> : SizesMatch huldre := <span class="hljs-keyword">by</span>
  simp
</code></pre>
<h3 id="type-class-inheritance"><a class="header" href="#type-class-inheritance">Type Class Inheritance</a></h3>
<p>Behind the scenes, type classes are structures.
Defining a new type class defines a new structure, and defining an instance creates a value of that structure type.
They are then added to internal tables in Lean that allow it to find the instances upon request.
A consequence of this is that type classes may inherit from other type classes.</p>
<p>Because it uses precisely the same language features, type class inheritance supports all the features of structure inheritance, including multiple inheritance, default implementations of parent types' methods, and automatic collapsing of diamonds.
This is useful in many of the same situations that multiple interface inheritance is useful in languages like Java, C# and Kotlin.
By carefully designing type class inheritance hierarchies, programmers can get the best of both worlds: a fine-grained collection of independently-implementable abstractions, and automatic construction of these specific abstractions from larger, more general abstractions.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="applicative-functors"><a class="header" href="#applicative-functors">Applicative Functors</a></h1>
<p>An <em>applicative functor</em> is a functor that has two additional operations available: <code class="hljs">pure</code> and <code class="hljs">seq</code>.
<code class="hljs">pure</code> is the same operator used in <code class="hljs">Monad</code>, because <code class="hljs">Monad</code> in fact inherits from <code class="hljs">Applicative</code>.
<code class="hljs">seq</code> is much like <code class="hljs">map</code>: it allows a function to be used in order to transform the contents of a datatype.
However, with <code class="hljs">seq</code>, the function is itself contained in the datatype: <code class="hljs">f (Î± â Î²) â (Unit â f Î±) â f Î²</code>.
Having the function under the type <code class="hljs">f</code> allows the <code class="hljs">Applicative</code> instance to control how the function is applied, while <code class="hljs">Functor.map</code> unconditionally applies a function.
The second argument has a type that begins with <code class="hljs">Unit â</code> to allow the definition of <code class="hljs">seq</code> to short-circuit in cases where the function will never be applied.</p>
<p>The value of this short-circuiting behavior can be seen in the instance of <code class="hljs">Applicative Option</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Applicative Option <span class="hljs-keyword">where</span>
  pure x := .some x
  seq f x :=
    <span class="hljs-keyword">match</span> f <span class="hljs-keyword">with</span>
    | none =&gt; none
    | some g =&gt; g &lt;$&gt; x ()
</code></pre>
<p>In this case, if there is no function for <code class="hljs">seq</code> to apply, then there is no need to compute its argument, so <code class="hljs">x</code> is never called.
The same consideration informs the instance of <code class="hljs">Applicative</code> for <code class="hljs">Except</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Applicative (Except Îµ) <span class="hljs-keyword">where</span>
  pure x := .ok x
  seq f x :=
    <span class="hljs-keyword">match</span> f <span class="hljs-keyword">with</span>
    | .error e =&gt; .error e
    | .ok g =&gt; g &lt;$&gt; x ()
</code></pre>
<p>This short-circuiting behavior depends only on the <code class="hljs">Option</code> or <code class="hljs">Except</code> structures that <em>surround</em> the function, rather than on the function itself.</p>
<p>Monads can be seen as a way of capturing the notion of sequentially executing statements into a pure functional language.
The result of one statement can affect which further statements run.
This can be seen in the type of <code class="hljs">bind</code>: <code class="hljs">m Î± â (Î± â m Î²) â m Î²</code>.
The first statement's resulting value is an input into a function that computes the next statement to execute.
Successive uses of <code class="hljs">bind</code> are like a sequence of statements in an imperative programming language, and <code class="hljs">bind</code> is powerful enough to implement control structures like conditionals and loops.</p>
<p>Following this analogy, <code class="hljs">Applicative</code> captures function application in a language that has side effects.
The arguments to a function in languages like Kotlin or C# are evaluated from left to right.
Side effects performed by earlier arguments occur before those performed by later arguments.
A function is not powerful enough to implement custom short-circuiting operators that depend on the specific <em>value</em> of an argument, however.</p>
<p>Typically, <code class="hljs">seq</code> is not invoked directly.
Instead, the operator <code class="hljs">&lt;*&gt;</code> is used.
This operator wraps its second argument in <code class="hljs">fun () =&gt; ...</code>, simplifying the call site.
In other words, <code class="hljs">E1 &lt;*&gt; E2</code> is syntactic sugar for <code class="hljs">Seq.seq E1 (fun () =&gt; E2)</code>.</p>
<p>The key feature that allows <code class="hljs">seq</code> to be used with multiple arguments is that a multiple-argument Lean function is really a single-argument function that returns another function that's waiting for the rest of the arguments.
In other words, if the first argument to <code class="hljs">seq</code> is awaiting multiple arguments, then the result of the <code class="hljs">seq</code> will be awaiting the rest.
For example, <code class="hljs">some Plus.plus</code> can have the type <code class="hljs">Option (Nat â Nat â Nat)</code>.
Providing one argument, <code class="hljs">some Plus.plus &lt;*&gt; some 4</code>, results in the type <code class="hljs">Option (Nat â Nat)</code>.
This can itself be used with <code class="hljs">seq</code>, so <code class="hljs">some Plus.plus &lt;*&gt; some 4 &lt;*&gt; some 7</code> has the type <code class="hljs">Option Nat</code>.</p>
<p>Not every functor is applicative.
<code class="hljs">Pair</code> is like the built-in product type <code class="hljs">Prod</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">P</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">r</span> <span class="hljs-params">(Î± Î² : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  first : Î±
  second : Î²
</code></pre>
<p>Like <code class="hljs">Except</code>, <code class="hljs">Pair</code> has type <code class="hljs">Type â Type â Type</code>.
This means that <code class="hljs">Pair Î±</code> has type <code class="hljs">Type â Type</code>, and a <code class="hljs">Functor</code> instance is possible:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Functor (Pair Î±) <span class="hljs-keyword">where</span>
  map f x := â¨x.first, f x.secondâ©
</code></pre>
<p>This instance obeys the <code class="hljs">Functor</code> contract.</p>
<p>The two properties to check are that <code class="hljs">id &lt;$&gt; Pair.mk x y = Pair.mk x y</code> and that <code class="hljs">f &lt;$&gt; g &lt;$&gt; Pair.mk x y = (f â g) &lt;$&gt; Pair.mk x y</code>.
The first property can be checked by just stepping through the evaluation of the left side, and noticing that it evaluates to the right side:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">id &lt;$&gt; Pair.mk x y
===&gt;
Pair.mk x (id y)
===&gt;
Pair.mk x y
</code></pre>
<p>The second can be checked by stepping through both sides, and noting that they yield the same result:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">f &lt;$&gt; g &lt;$&gt; Pair.mk x y
===&gt;
f &lt;$&gt; Pair.mk x (g y)
===&gt;
Pair.mk x (f (g y))

(f â g) &lt;$&gt; Pair.mk x y
===&gt;
Pair.mk x ((f â g) y)
===&gt;
Pair.mk x (f (g y))
</code></pre>
<p>Attempting to define an <code class="hljs">Applicative</code> instance, however, does not work so well.
It will require a definition of <code class="hljs">pure</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">P</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">r</span>.<span class="hljs-title">p</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">e</span> <span class="hljs-params">(x : Î²)</span> <span class="hljs-symbol">:</span></span> Pair Î± Î² := _
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Î² Î± : Type
x : Î²
â¢ Pair Î± Î²
</code></pre>
<p>There is a value with type <code class="hljs">Î²</code> in scope (namely <code class="hljs">x</code>), and the error message from the underscore suggests that the next step is to use the constructor <code class="hljs">Pair.mk</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">P</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">r</span>.<span class="hljs-title">p</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">e</span> <span class="hljs-params">(x : Î²)</span> <span class="hljs-symbol">:</span></span> Pair Î± Î² := Pair.mk _ x
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder for argument 'first'
context:
Î² Î± : Type
x : Î²
â¢ Î±
</code></pre>
<p>Unfortunately, there is no <code class="hljs">Î±</code> available.
Because <code class="hljs">pure</code> would need to work for <em>all possible types</em> Î± to define an instance of <code class="hljs">Applicative (Pair Î±)</code>, this is impossible.
After all, a caller could choose <code class="hljs">Î±</code> to be <code class="hljs">Empty</code>, which has no values at all.</p>
<h2 id="a-non-monadic-applicative"><a class="header" href="#a-non-monadic-applicative">A Non-Monadic Applicative</a></h2>
<p>When validating user input to a form, it's generally considered to be best to provide many errors at once, rather than one error at a time.
This allows the user to have an overview of what is needed to please the computer, rather than feeling badgered as they correct the errors field by field.</p>
<p>Ideally, validating user input will be visible in the type of the function that's doing the validating.
It should return a datatype that is specificâchecking that a text box contains a number should return an actual numeric type, for instance.
A validation routine could throw an exception when the input does not pass validation.
Exceptions have a major drawback, however: they terminate the program at the first error, making it impossible to accumulate a list of errors.</p>
<p>On the other hand, the common design pattern of accumulating a list of errors and then failing when it is non-empty is also problematic.
A long nested sequences of <code class="hljs">if</code> statements that validate each sub-section of the input data is hard to maintain, and it's easy to lose track of an error message or two.
Ideally, validation can be performed using an API that enables a new value to be returned yet automatically tracks and accumulates error messages.</p>
<p>An applicative functor called <code class="hljs">Validate</code> provides one way to implement this style of API.
Like the <code class="hljs">Except</code> monad, <code class="hljs">Validate</code> allows a new value to be constructed that characterizes the validated data accurately.
Unlike <code class="hljs">Except</code>, it allows multiple errors to be accumulated, without a risk of forgetting to check whether the list is empty.</p>
<h3 id="user-input"><a class="header" href="#user-input">User Input</a></h3>
<p>As an example of user input, take the following structure:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">R</span><span class="hljs-title">aw</span><span class="hljs-title">I</span><span class="hljs-title">n</span><span class="hljs-title">p</span><span class="hljs-title">u</span><span class="hljs-title">t</span></span> <span class="hljs-keyword">where</span>
  name : String
  birthYear : String
</code></pre>
<p>The business logic to be implemented is the following:</p>
<ol>
<li>The name may not be empty</li>
<li>The birth year must be numeric and non-negative</li>
<li>The birth year must be greater than 1900, and less than or equal to the year in which the form is validated</li>
</ol>
<p>Representing these as a datatype will require a new feature, called <em>subtypes</em>.
With this tool in hand, a validation framework can be written that uses an applicative functor to track errors, and these rules can be implemented in the framework.</p>
<h3 id="subtypes"><a class="header" href="#subtypes">Subtypes</a></h3>
<p>Representing these conditions is easiest with one additional Lean type, called <code class="hljs">Subtype</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">S</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">t</span><span class="hljs-title">y</span><span class="hljs-title">p</span><span class="hljs-title">e</span> <span class="hljs-params">{Î± : <span class="hljs-built_in">Type</span>}</span> <span class="hljs-params">(p : Î± â <span class="hljs-built_in">Prop</span>)</span></span> <span class="hljs-keyword">where</span>
  val : Î±
  property : p val
</code></pre>
<p>This structure has two type parameters: an implicit parameter that is the type of data <code class="hljs">Î±</code>, and an explicit parameter <code class="hljs">p</code> that is a predicate over <code class="hljs">Î±</code>.
A <em>predicate</em> is a logical statement with a variable in it that can be replaced with a value to yield an actual statement, like the <a href="https://leanprover.github.io/functional_programming_in_lean/type-classes/indexing.html#overloading-indexing">parameter to <code class="hljs">GetElem</code></a> that describes what it means for an index to be in bounds for a lookup.
In the case of <code class="hljs">Subtype</code>, the predicate slices out some subset of the values of <code class="hljs">Î±</code> for which the predicate holds.
The structure's two fields are, respectively, a value from <code class="hljs">Î±</code> and evidence that the value satisfies the predicate <code class="hljs">p</code>.
Lean has special syntax for <code class="hljs">Subtype</code>.
If <code class="hljs">p</code> has type <code class="hljs">Î± â Prop</code>, then the type <code class="hljs">Subtype p</code> can also be written <code class="hljs">{x : Î± // p x}</code>, or even <code class="hljs">{x // p x}</code> when the type can be inferred automatically.</p>
<p><a href="https://leanprover.github.io/functional_programming_in_lean/type-classes/pos.html">Representing positive numbers as inductive types</a> is clear and easy to program with.
However, it has a key disadvantage.
While <code class="hljs">Nat</code> and <code class="hljs">Int</code> have the structure of ordinary inductive types from the perspective of Lean programs, the compiler treats them specially and uses fast arbitrary-precision number libraries to implement them.
This is not the case for additional user-defined types.
However, a subtype of <code class="hljs">Nat</code> that restricts it to non-zero numbers allows the new type to use the efficient representation while still ruling out zero at compile time:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">F</span><span class="hljs-title">a</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> := {x : Nat // x &gt; <span class="hljs-number">0</span>}
</code></pre>
<p>The smallest fast positive number is still one.
Now, instead of being a constructor of an inductive type, it's an instance of a structure that's constructed with angle brackets.
The first argument is the underlying <code class="hljs">Nat</code>, and the second argument is the evidence that said <code class="hljs">Nat</code> is greater than zero:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> FastPos := â¨<span class="hljs-number">1</span>, <span class="hljs-keyword">by</span> <span class="hljs-keyword">simp</span>â©
</code></pre>
<p>The <code class="hljs">OfNat</code> instance is very much like that for <code class="hljs">Pos</code>, except it uses a short tactic proof to provide evidence that <code class="hljs">n + 1 &gt; 0</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> OfNat FastPos (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">where</span>
  ofNat := â¨n + <span class="hljs-number">1</span>, <span class="hljs-keyword">by</span> <span class="hljs-keyword">simp_arith</span>â©
</code></pre>
<p>The <code class="hljs">simp_arith</code> tactic is a version of <code class="hljs">simp</code> that takes additional arithmetic identities into account.</p>
<p>Subtypes are a two-edged sword.
They allow efficient representation of validation rules, but they transfer the burden of maintaining these rules to the users of the library, who have to <em>prove</em> that they are not violating important invariants.
Generally, it's a good idea to use them internally to a library, providing an API to users that automatically ensures that all invariants are satisfied, with any necessary proofs being internal to the library.</p>
<p>Checking whether a value of type <code class="hljs">Î±</code> is in the subtype <code class="hljs">{x : Î± // p x}</code> usually requires that the proposition <code class="hljs">p x</code> be decidable.
The <a href="https://leanprover.github.io/functional_programming_in_lean/type-classes/standard-classes.html#equality-and-ordering">section on equality and ordering classes</a> describes how decidable propositions can be used with <code class="hljs">if</code>.
When <code class="hljs">if</code> is used with a decidable proposition, a name can be provided.
In the <code class="hljs">then</code> branch, the name is bound to evidence that the proposition is true, and in the <code class="hljs">else</code> branch, it is bound to evidence that the proposition is false.
This comes in handy when checking whether a given <code class="hljs">Nat</code> is positive:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span>.<span class="hljs-title">a</span><span class="hljs-title">s</span><span class="hljs-title">F</span><span class="hljs-title">a</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">P</span><span class="hljs-title">o</span><span class="hljs-title">s?</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span> Option FastPos :=
  <span class="hljs-keyword">if</span> h : n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>
    some â¨n, hâ©
  <span class="hljs-keyword">else</span> none
</code></pre>
<p>In the <code class="hljs">then</code> branch, <code class="hljs">h</code> is bound to evidence that <code class="hljs">n &gt; 0</code>, and this evidence can be used as the second argument to <code class="hljs">Subtype</code>'s constructor.</p>
<h3 id="validated-input"><a class="header" href="#validated-input">Validated Input</a></h3>
<p>The validated user input is a structure that expresses the business logic using multiple techniques:</p>
<ul>
<li>The structure type itself encodes the year in which it was checked for validity, so that <code class="hljs">CheckedInput 2019</code> is not the same type as <code class="hljs">CheckedInput 2020</code></li>
<li>The birth year is represented as a <code class="hljs">Nat</code> rather than a <code class="hljs">String</code></li>
<li>Subtypes are used to constrain the allowed values in the name and birth year fields</li>
</ul>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">C</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">k</span><span class="hljs-title">e</span><span class="hljs-title">d</span><span class="hljs-title">I</span><span class="hljs-title">n</span><span class="hljs-title">p</span><span class="hljs-title">u</span><span class="hljs-title">t</span> <span class="hljs-params">(thisYear : Nat)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  name : {n : String // n â  <span class="hljs-string">""</span>}
  birthYear : {y : Nat // y &gt; <span class="hljs-number">1900</span> â§ y â¤ thisYear}
</code></pre>
<p>An input validator should take the current year and a <code class="hljs">RawInput</code> as arguments, returning either a checked input or at least one validation failure.
This is represented by the <code class="hljs">Validate</code> type:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Validate (Îµ Î± : <span class="hljs-built_in">Type</span>) : <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  | ok : Î± â Validate Îµ Î±
  | errors : NonEmptyList Îµ â Validate Îµ Î±
</code></pre>
<p>It looks very much like <code class="hljs">Except</code>.
The only difference is that the <code class="hljs">error</code> constructor may contain more than one failure.</p>
<p>Validate is a functor.
Mapping a function over it transforms any successful value that might be present, just as in the <code class="hljs">Functor</code> instance for <code class="hljs">Except</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Functor (Validate Îµ) <span class="hljs-keyword">where</span>
  map f
   | .ok x =&gt; .ok (f x)
   | .errors errs =&gt; .errors errs
</code></pre>
<p>The <code class="hljs">Applicative</code> instance for <code class="hljs">Validate</code> has an important difference from the instance for <code class="hljs">Except</code>: while the instance for <code class="hljs">Except</code> terminates at the first error encountered, the instance for <code class="hljs">Validate</code> is careful to accumulate all errors from <em>both</em> the function and the argument branches:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Applicative (Validate Îµ) <span class="hljs-keyword">where</span>
  pure := .ok
  seq f x :=
    <span class="hljs-keyword">match</span> f <span class="hljs-keyword">with</span>
    | .ok g =&gt; g &lt;$&gt; (x ())
    | .errors errs =&gt;
      <span class="hljs-keyword">match</span> x () <span class="hljs-keyword">with</span>
      | .ok _ =&gt; .errors errs
      | .errors errs' =&gt; .errors (errs ++ errs')
</code></pre>
<p>Using <code class="hljs">.errors</code> together with the constructor for <code class="hljs">NonEmptyList</code> is a bit verbose.
Helpers like <code class="hljs">reportError</code> make code more readable.
In this application, error reports will consist of field names paired with messages:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">d</span> <span class="hljs-symbol">:</span></span>= String

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">p</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">E</span><span class="hljs-title">r</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">r</span> <span class="hljs-params">(f : Field)</span> <span class="hljs-params">(msg : String)</span> <span class="hljs-symbol">:</span></span> Validate (Field Ã String) Î± :=
  .errors { head := (f, msg), tail := [] }
</code></pre>
<p>The <code class="hljs">Applicative</code> instance for <code class="hljs">Validate</code> allows the checking procedures for each field to be written independently and then composed.
Checking a name consists of ensuring that a string is non-empty, then returning evidence of this fact in the form of a <code class="hljs">Subtype</code>.
This uses the evidence-binding version of <code class="hljs">if</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">k</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">m</span><span class="hljs-title">e</span> <span class="hljs-params">(name : String)</span> <span class="hljs-symbol">:</span></span> Validate (Field Ã String) {n : String // n â  <span class="hljs-string">""</span>} :=
  <span class="hljs-keyword">if</span> h : name = <span class="hljs-string">""</span> <span class="hljs-keyword">then</span>
    reportError <span class="hljs-string">"name"</span> <span class="hljs-string">"Required"</span>
  <span class="hljs-keyword">else</span> pure â¨name, hâ©
</code></pre>
<p>In the <code class="hljs">then</code> branch, <code class="hljs">h</code> is bound to evidence that <code class="hljs">name = ""</code>, while it is bound to evidence that <code class="hljs">Â¬name = ""</code> in the <code class="hljs">else</code> branch.</p>
<p>It's certainly the case that some validation errors make other checks impossible.
For example, it makes no sense to check whether the birth year field is greater than 1900 if a confused user wrote the word <code class="hljs">"syzygy"</code> instead of a number.
Checking the allowed range of the number is only meaningful after ensuring that the field in fact contains a number.
This can be expressed using the function <code class="hljs">andThen</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">V</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">d</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span>.<span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-params">(val : Validate Îµ Î±)</span> <span class="hljs-params">(next : Î± â Validate Îµ Î²)</span> <span class="hljs-symbol">:</span></span> Validate Îµ Î² :=
  <span class="hljs-keyword">match</span> val <span class="hljs-keyword">with</span>
  | .errors errs =&gt; .errors errs
  | .ok x =&gt; next x
</code></pre>
<p>While this function's type signature makes it suitable to be used as <code class="hljs">bind</code> in a <code class="hljs">Monad</code> instance, there are good reasons not to do so.
They are described <a href="https://leanprover.github.io/functional_programming_in_lean/functor-applicative-monad/applicative-contract.html#additional-stipulations">in the section that describes the <code class="hljs">Applicative</code> contract</a>.</p>
<p>To check that the birth year is a number, a built-in function called <code class="hljs">String.toNat? : String â Option Nat</code> is useful.
It's most user-friendly to eliminate leading and trailing whitespace first using <code class="hljs">String.trim</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">k</span><span class="hljs-title">Y</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">r</span><span class="hljs-title">I</span><span class="hljs-title">s</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span> <span class="hljs-params">(year : String)</span> <span class="hljs-symbol">:</span></span> Validate (Field Ã String) Nat :=
  <span class="hljs-keyword">match</span> year.trim.toNat? <span class="hljs-keyword">with</span>
  | none =&gt; reportError <span class="hljs-string">"birth year"</span> <span class="hljs-string">"Must be digits"</span>
  | some n =&gt; pure n
</code></pre>
<p>To check that the provided year is in the expected range, nested uses of the evidence-providing form of <code class="hljs">if</code> are in order:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">k</span><span class="hljs-title">B</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">Y</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">r</span> <span class="hljs-params">(thisYear year : Nat)</span> <span class="hljs-symbol">:</span></span> Validate (Field Ã String) {y : Nat // y &gt; <span class="hljs-number">1900</span> â§ y â¤ thisYear} :=
  <span class="hljs-keyword">if</span> h : year &gt; <span class="hljs-number">1900</span> <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">if</span> h' : year â¤ thisYear <span class="hljs-keyword">then</span>
      pure â¨year, <span class="hljs-keyword">by</span> <span class="hljs-keyword">simp</span> [*]â©
    <span class="hljs-keyword">else</span> reportError <span class="hljs-string">"birth year"</span> s!<span class="hljs-string">"Must be no later than {thisYear}"</span>
  <span class="hljs-keyword">else</span> reportError <span class="hljs-string">"birth year"</span> <span class="hljs-string">"Must be after 1900"</span>
</code></pre>
<p>Finally, these three components can be combined using <code class="hljs">seq</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">k</span><span class="hljs-title">I</span><span class="hljs-title">n</span><span class="hljs-title">p</span><span class="hljs-title">u</span><span class="hljs-title">t</span> <span class="hljs-params">(year : Nat)</span> <span class="hljs-params">(input : RawInput)</span> <span class="hljs-symbol">:</span></span> Validate (Field Ã String) (CheckedInput year) :=
  pure CheckedInput.mk &lt;*&gt;
    checkName input.name &lt;*&gt;
    (checkYearIsNat input.birthYear).andThen <span class="hljs-keyword">fun</span> birthYearAsNat =&gt;
      checkBirthYear year birthYearAsNat
</code></pre>
<p>Testing <code class="hljs">checkInput</code> shows that it can indeed return multiple pieces of feedback:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> checkInput <span class="hljs-number">2023</span> {name := <span class="hljs-string">"David"</span>, birthYear := <span class="hljs-string">"1984"</span>}
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Validate.ok { name := "David", birthYear := 1984 }
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> checkInput <span class="hljs-number">2023</span> {name := <span class="hljs-string">""</span>, birthYear := <span class="hljs-string">"2045"</span>}
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Validate.errors { head := ("name", "Required"), tail := [("birth year", "Must be no later than 2023")] }
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> checkInput <span class="hljs-number">2023</span> {name := <span class="hljs-string">"David"</span>, birthYear := <span class="hljs-string">"syzygy"</span>}
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Validate.errors { head := ("birth year", "Must be digits"), tail := [] }
</code></pre>
<p>Form validation with <code class="hljs">checkInput</code> illustrates a key advantage of <code class="hljs">Applicative</code> over <code class="hljs">Monad</code>.
Because <code class="hljs">&gt;&gt;=</code> provides enough power to modify the rest of the program's execution based on the value from the first step, it <em>must</em> receive a value from the first step to pass on.
If no value is received (e.g. because an error has occurred), then <code class="hljs">&gt;&gt;=</code> cannot execute the rest of the program.
<code class="hljs">Validate</code> demonstrates why it can be useful to run the rest of the program anyway: in cases where the earlier data isn't needed, running the rest of the program can yield useful information (in this case, more validation errors).
<code class="hljs">Applicative</code>'s <code class="hljs">&lt;*&gt;</code> may run both of its arguments before recombining the results.
Similarly, <code class="hljs">&gt;&gt;=</code> forces sequential execution.
Each step must complete before the next may run.
This is generally useful, but it makes it impossible to have parallel execution of different threads that naturally emerges from the program's actual data dependencies.
A more powerful abstraction like <code class="hljs">Monad</code> increases the flexibility that's available to the API consumer, but it decreases the flexibility that is available to the API implementor.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="the-applicative-contract"><a class="header" href="#the-applicative-contract">The Applicative Contract</a></h1>
<p>Just like <code class="hljs">Functor</code>, <code class="hljs">Monad</code>, and types that implement <code class="hljs">BEq</code> and <code class="hljs">Hashable</code>, <code class="hljs">Applicative</code> has a set of rules that all instances should adhere to.</p>
<p>There are four rules that an applicative functor should follow:</p>
<ol>
<li>It should respect identity, so <code class="hljs">pure id &lt;*&gt; v = v</code></li>
<li>It should respect function composition, so <code class="hljs">pure (Â· â Â·) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</code></li>
<li>Sequencing pure operations should be a no-op, so <code class="hljs">pure f &lt;*&gt; pure x = pure (f x)</code></li>
<li>The ordering of pure operations doesn't matter, so <code class="hljs">u &lt;*&gt; pure x = pure (fun f =&gt; f x) &lt;*&gt; u</code></li>
</ol>
<p>To check these for the <code class="hljs">Applicative Option</code> instance, start by expanding <code class="hljs">pure</code> into <code class="hljs">some</code>.</p>
<p>The first rule states that <code class="hljs">some id &lt;*&gt; v = v</code>.
The definition of <code class="hljs">seq</code> for <code class="hljs">Option</code> states that this is the same as <code class="hljs">id &lt;$&gt; v = v</code>, which is one of the <code class="hljs">Functor</code> rules that have already been checked.</p>
<p>The second rule states that <code class="hljs">some (Â· â Â·) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</code>.
If any of <code class="hljs">u</code>, <code class="hljs">v</code>, or <code class="hljs">w</code> is <code class="hljs">none</code>, then both sides are <code class="hljs">none</code>, so the property holds.
Assuming that <code class="hljs">u</code> is <code class="hljs">some f</code>, that <code class="hljs">v</code> is <code class="hljs">some g</code>, and that <code class="hljs">w</code> is <code class="hljs">some x</code>, then this is equivalent to saying that <code class="hljs">some (Â· â Â·) &lt;*&gt; some f &lt;*&gt; some g &lt;*&gt; some x = some f &lt;*&gt; (some g &lt;*&gt; some x)</code>.
Evaluating the two sides yields the same result:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">some (Â· â Â·) &lt;*&gt; some f &lt;*&gt; some g &lt;*&gt; some x
===&gt;
some (f â Â·) &lt;*&gt; some g &lt;*&gt; some x
===&gt;
some (f â g) &lt;*&gt; some x
===&gt;
some ((f â g) x)
===&gt;
some (f (g x))

some f &lt;*&gt; (some g &lt;*&gt; some x)
===&gt;
some f &lt;*&gt; (some (g x))
===&gt;
some (f (g x))
</code></pre>
<p>The third rule follows directly from the definition of <code class="hljs">seq</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">some f &lt;*&gt; some x
===&gt;
f &lt;$&gt; some x
===&gt;
some (f x)
</code></pre>
<p>In the fourth case, assume that <code class="hljs">u</code> is <code class="hljs">some f</code>, because if it's <code class="hljs">none</code>, both sides of the equation are <code class="hljs">none</code>.
<code class="hljs">some f &lt;*&gt; some x</code> evaluates directly to <code class="hljs">some (f x)</code>, as does <code class="hljs">some (fun g =&gt; g x) &lt;*&gt; some f</code>.</p>
<h2 id="all-applicatives-are-functors"><a class="header" href="#all-applicatives-are-functors">All Applicatives are Functors</a></h2>
<p>The two operators for <code class="hljs">Applicative</code> are enough to define <code class="hljs">map</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">p</span> <span class="hljs-params">[Applicative f]</span> <span class="hljs-params">(g : Î± â Î²)</span> <span class="hljs-params">(x : f Î±)</span> <span class="hljs-symbol">:</span></span> f Î² :=
  pure g &lt;*&gt; x
</code></pre>
<p>This can only be used to implement <code class="hljs">Functor</code> if the contract for <code class="hljs">Applicative</code> guarantees the contract for <code class="hljs">Functor</code>, however.
The first rule of <code class="hljs">Functor</code> is that <code class="hljs">id &lt;$&gt; x = x</code>, which follows directly from the first rule for <code class="hljs">Applicative</code>.
The second rule of <code class="hljs">Functor</code> is that <code class="hljs">map (f â g) x = map f (map g x)</code>.
Unfolding the definition of <code class="hljs">map</code> here results in <code class="hljs">pure (f â g) &lt;*&gt; x = pure f &lt;*&gt; (pure g &lt;*&gt; x)</code>.
Using the rule that sequencing pure operations is a no-op, the left side can be rewritten to <code class="hljs">pure (Â· â Â·) &lt;*&gt; pure f &lt;*&gt; pure g &lt;*&gt; x</code>.
This is an instance of the rule that states that applicative functors respect function composition.</p>
<p>This justifies a definition of <code class="hljs">Applicative</code> that extends <code class="hljs">Functor</code>, with a default definition of <code class="hljs">map</code> given in terms of <code class="hljs">pure</code> and <code class="hljs">seq</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-params">(f : <span class="hljs-built_in">Type</span> â <span class="hljs-built_in">Type</span>)</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">F</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">c</span><span class="hljs-title">t</span><span class="hljs-title">o</span><span class="hljs-title">r</span> <span class="hljs-title">f</span></span> <span class="hljs-keyword">where</span>
  pure : Î± â f Î±
  seq : f (Î± â Î²) â (Unit â f Î±) â f Î²
  map g x := seq (pure g) (<span class="hljs-keyword">fun</span> () =&gt; x)
</code></pre>
<h2 id="all-monads-are-applicative-functors"><a class="header" href="#all-monads-are-applicative-functors">All Monads are Applicative Functors</a></h2>
<p>An instance of <code class="hljs">Monad</code> already requires an implementation of <code class="hljs">pure</code>.
Together with <code class="hljs">bind</code>, this is enough to define <code class="hljs">seq</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">q</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">(f : m (Î± â Î²)</span>) <span class="hljs-params">(x : Unit â m Î±)</span> <span class="hljs-symbol">:</span></span> m Î² := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> g â f
  <span class="hljs-keyword">let</span> y â x ()
  pure (g y)
</code></pre>
<p>Once again, checking that the <code class="hljs">Monad</code> contract implies the <code class="hljs">Applicative</code> contract will allow this to be used as a default definition for <code class="hljs">seq</code> if <code class="hljs">Monad</code> extends <code class="hljs">Applicative</code>.</p>
<p>The rest of this section consists of an argument that this implementation of <code class="hljs">seq</code> based on <code class="hljs">bind</code> in fact satisfies the <code class="hljs">Applicative</code> contract.
One of the beautiful things about functional programming is that this kind of argument can be worked out on a piece of paper with a pencil, using the kinds of evaluation rules from <a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/evaluating.html">the initial section on evaluating expressions</a>.
Thinking about the meanings of the operations while reading these arguments can sometimes help with understanding.</p>
<p>Replacing <code class="hljs">do</code>-notation with explicit uses of <code class="hljs">&gt;&gt;=</code> makes it easier to apply the <code class="hljs">Monad</code> rules:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">q</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">(f : m (Î± â Î²)</span>) <span class="hljs-params">(x : Unit â m Î±)</span> <span class="hljs-symbol">:</span></span> m Î² := <span class="hljs-keyword">do</span>
  f &gt;&gt;= <span class="hljs-keyword">fun</span> g =&gt;
  x () &gt;&gt;= <span class="hljs-keyword">fun</span> y =&gt;
  pure (g y)
</code></pre>
<p>To check that this definition respects identity, check that <code class="hljs">seq (pure id) (fun () =&gt; v) = v</code>.
The left hand side is equivalent to <code class="hljs">pure id &gt;&gt;= fun g =&gt; (fun () =&gt; v) () &gt;&gt;= fun y =&gt; pure (g y)</code>.
The unit function in the middle can be eliminated immediately, yielding <code class="hljs">pure id &gt;&gt;= fun g =&gt; v &gt;&gt;= fun y =&gt; pure (g y)</code>.
Using the fact that <code class="hljs">pure</code> is a left identity of <code class="hljs">&gt;&gt;=</code>, this is the same as <code class="hljs">v &gt;&gt;= fun y =&gt; pure (id y)</code>, which is <code class="hljs">v &gt;&gt;= fun y =&gt; pure y</code>.
Because <code class="hljs">fun x =&gt; f x</code> is the same as <code class="hljs">f</code>, this is the same as <code class="hljs">v &gt;&gt;= pure</code>, and the fact that <code class="hljs">pure</code> is a right identity of <code class="hljs">&gt;&gt;=</code> can be used to get <code class="hljs">v</code>.</p>
<p>This kind of informal reasoning can be made easier to read with a bit of reformatting.
In the following chart, read "EXPR1 ={ REASON }= EXPR2" as "EXPR1 is the same as EXPR2 because REASON":</p>
<div class="equational">
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">pure id &gt;&gt;= <span class="hljs-keyword">fun</span> g =&gt; v &gt;&gt;= <span class="hljs-keyword">fun</span> y =&gt; pure (g y)</code></pre>
</div>
<div class="explanation">
={ <em><code class="hljs">pure</code> is a left identity of <code class="hljs">&gt;&gt;=</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">v &gt;&gt;= <span class="hljs-keyword">fun</span> y =&gt; pure (id y)</code></pre>
</div>
<div class="explanation">
={ <em>Reduce the call to <code class="hljs">id</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">v &gt;&gt;= <span class="hljs-keyword">fun</span> y =&gt; pure y</code></pre>
</div>
<div class="explanation">
={ <em><code class="hljs">fun x =&gt; f x</code> is the same as <code class="hljs">f</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">v &gt;&gt;= pure</code></pre>
</div>
<div class="explanation">
={ <em><code class="hljs">pure</code> is a right identity of <code class="hljs">&gt;&gt;=</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">v</code></pre>
</div>
</div>
<p>To check that it respects function composition, check that <code class="hljs">pure (Â· â Â·) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</code>.
The first step is to replace <code class="hljs">&lt;*&gt;</code> with this definition of <code class="hljs">seq</code>.
After that, a (somewhat long) series of steps that use the identity and associativity rules from the <code class="hljs">Monad</code> contract is enough to get from one to the other:</p>
<div class="equational">
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">seq (seq (seq (pure (Â· â Â·)) (<span class="hljs-keyword">fun</span> _ =&gt; u))
      (<span class="hljs-keyword">fun</span> _ =&gt; v))
  (<span class="hljs-keyword">fun</span> _ =&gt; w)</code></pre>
</div>
<div class="explanation">
={ <em>Definition of <code class="hljs">seq</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">((pure (Â· â Â·) &gt;&gt;= <span class="hljs-keyword">fun</span> f =&gt;
   u &gt;&gt;= <span class="hljs-keyword">fun</span> x =&gt;
   pure (f x)) &gt;&gt;= <span class="hljs-keyword">fun</span> g =&gt;
  v &gt;&gt;= <span class="hljs-keyword">fun</span> y =&gt;
  pure (g y)) &gt;&gt;= <span class="hljs-keyword">fun</span> h =&gt;
 w &gt;&gt;= <span class="hljs-keyword">fun</span> z =&gt;
 pure (h z)</code></pre>
</div>
<div class="explanation">
={ <em><code class="hljs">pure</code> is a left identity of <code class="hljs">&gt;&gt;=</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">((u &gt;&gt;= <span class="hljs-keyword">fun</span> x =&gt;
   pure (x â Â·)) &gt;&gt;= <span class="hljs-keyword">fun</span> g =&gt;
   v &gt;&gt;= <span class="hljs-keyword">fun</span> y =&gt;
  pure (g y)) &gt;&gt;= <span class="hljs-keyword">fun</span> h =&gt;
 w &gt;&gt;= <span class="hljs-keyword">fun</span> z =&gt;
 pure (h z)</code></pre>
</div>
<div class="explanation">
={ <em>Insertion of parentheses for clarity</em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">((u &gt;&gt;= <span class="hljs-keyword">fun</span> x =&gt;
   pure (x â Â·)) &gt;&gt;= (<span class="hljs-keyword">fun</span> g =&gt;
   v &gt;&gt;= <span class="hljs-keyword">fun</span> y =&gt;
  pure (g y))) &gt;&gt;= <span class="hljs-keyword">fun</span> h =&gt;
 w &gt;&gt;= <span class="hljs-keyword">fun</span> z =&gt;
 pure (h z)</code></pre>
</div>
<div class="explanation">
={ <em>Associativity of <code class="hljs">&gt;&gt;=</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">(u &gt;&gt;= <span class="hljs-keyword">fun</span> x =&gt;
  pure (x â Â·) &gt;&gt;= <span class="hljs-keyword">fun</span> g =&gt;
 v  &gt;&gt;= <span class="hljs-keyword">fun</span> y =&gt; pure (g y)) &gt;&gt;= <span class="hljs-keyword">fun</span> h =&gt;
 w &gt;&gt;= <span class="hljs-keyword">fun</span> z =&gt;
 pure (h z)</code></pre>
</div>
<div class="explanation">
={ <em><code class="hljs">pure</code> is a left identity of <code class="hljs">&gt;&gt;=</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">(u &gt;&gt;= <span class="hljs-keyword">fun</span> x =&gt;
  v &gt;&gt;= <span class="hljs-keyword">fun</span> y =&gt;
  pure (x â y)) &gt;&gt;= <span class="hljs-keyword">fun</span> h =&gt;
 w &gt;&gt;= <span class="hljs-keyword">fun</span> z =&gt;
 pure (h z)</code></pre>
</div>
<div class="explanation">
={ <em>Associativity of <code class="hljs">&gt;&gt;=</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">u &gt;&gt;= <span class="hljs-keyword">fun</span> x =&gt;
v &gt;&gt;= <span class="hljs-keyword">fun</span> y =&gt;
pure (x â y) &gt;&gt;= <span class="hljs-keyword">fun</span> h =&gt;
w &gt;&gt;= <span class="hljs-keyword">fun</span> z =&gt;
pure (h z)</code></pre>
</div>
<div class="explanation">
={ <em><code class="hljs">pure</code> is a left identity of <code class="hljs">&gt;&gt;=</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">u &gt;&gt;= <span class="hljs-keyword">fun</span> x =&gt;
v &gt;&gt;= <span class="hljs-keyword">fun</span> y =&gt;
w &gt;&gt;= <span class="hljs-keyword">fun</span> z =&gt;
pure ((x â y) z)</code></pre>
</div>
<div class="explanation">
={ <em>Definition of function composition</em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">u &gt;&gt;= <span class="hljs-keyword">fun</span> x =&gt;
v &gt;&gt;= <span class="hljs-keyword">fun</span> y =&gt;
w &gt;&gt;= <span class="hljs-keyword">fun</span> z =&gt;
pure (x (y z))</code></pre>
</div>
<div class="explanation">
={ <em>Time to start moving backwards!<code class="hljs">pure</code> is a left identity of <code class="hljs">&gt;&gt;=</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">u &gt;&gt;= <span class="hljs-keyword">fun</span> x =&gt;
v &gt;&gt;= <span class="hljs-keyword">fun</span> y =&gt;
w &gt;&gt;= <span class="hljs-keyword">fun</span> z =&gt;
pure (y z) &gt;&gt;= <span class="hljs-keyword">fun</span> q =&gt;
pure (x q)</code></pre>
</div>
<div class="explanation">
={ <em>Associativity of <code class="hljs">&gt;&gt;=</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">u &gt;&gt;= <span class="hljs-keyword">fun</span> x =&gt;
v &gt;&gt;= <span class="hljs-keyword">fun</span> y =&gt;
 (w &gt;&gt;= <span class="hljs-keyword">fun</span> p =&gt;
  pure (y p)) &gt;&gt;= <span class="hljs-keyword">fun</span> q =&gt;
 pure (x q)</code></pre>
</div>
<div class="explanation">
={ <em>Associativity of <code class="hljs">&gt;&gt;=</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">u &gt;&gt;= <span class="hljs-keyword">fun</span> x =&gt;
 (v &gt;&gt;= <span class="hljs-keyword">fun</span> y =&gt;
  w &gt;&gt;= <span class="hljs-keyword">fun</span> q =&gt;
  pure (y q)) &gt;&gt;= <span class="hljs-keyword">fun</span> z =&gt;
 pure (x z)</code></pre>
</div>
<div class="explanation">
={ <em>This includes the definition of <code class="hljs">seq</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">u &gt;&gt;= <span class="hljs-keyword">fun</span> x =&gt;
seq v (<span class="hljs-keyword">fun</span> () =&gt; w) &gt;&gt;= <span class="hljs-keyword">fun</span> q =&gt;
pure (x q)</code></pre>
</div>
<div class="explanation">
={ <em>This also includes the definition of <code class="hljs">seq</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">seq u (<span class="hljs-keyword">fun</span> () =&gt; seq v (<span class="hljs-keyword">fun</span> () =&gt; w))</code></pre>
</div>
</div>
<p>To check that sequencing pure operations is a no-op:</p>
<div class="equational">
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">seq (pure f) (<span class="hljs-keyword">fun</span> () =&gt; pure x)</code></pre>
</div>
<div class="explanation">
={ <em>Replacing <code class="hljs">seq</code> with its definition</em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">pure f &gt;&gt;= <span class="hljs-keyword">fun</span> g =&gt;
pure x &gt;&gt;= <span class="hljs-keyword">fun</span> y =&gt;
pure (g y)</code></pre>
</div>
<div class="explanation">
={ <em><code class="hljs">pure</code> is a left identity of <code class="hljs">&gt;&gt;=</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">pure f &gt;&gt;= <span class="hljs-keyword">fun</span> g =&gt;
pure (g x)</code></pre>
</div>
<div class="explanation">
={ <em><code class="hljs">pure</code> is a left identity of <code class="hljs">&gt;&gt;=</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">pure (f x)</code></pre>
</div>
</div>
<p>And finally, to check that the ordering of pure operations doesn't matter:</p>
<div class="equational">
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">seq u (<span class="hljs-keyword">fun</span> () =&gt; pure x)</code></pre>
</div>
<div class="explanation">
={ <em>Definition of <code class="hljs">seq</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">u &gt;&gt;= <span class="hljs-keyword">fun</span> f =&gt;
pure x &gt;&gt;= <span class="hljs-keyword">fun</span> y =&gt;
pure (f y)</code></pre>
</div>
<div class="explanation">
={ <em><code class="hljs">pure</code> is a left identity of <code class="hljs">&gt;&gt;=</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">u &gt;&gt;= <span class="hljs-keyword">fun</span> f =&gt;
pure (f x)</code></pre>
</div>
<div class="explanation">
={ <em>Clever replacement of one expression by an equivalent one that makes the rule match</em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">u &gt;&gt;= <span class="hljs-keyword">fun</span> f =&gt;
pure ((<span class="hljs-keyword">fun</span> g =&gt; g x) f)</code></pre>
</div>
<div class="explanation">
={ <em><code class="hljs">pure</code> is a left identity of <code class="hljs">&gt;&gt;=</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">pure (<span class="hljs-keyword">fun</span> g =&gt; g x) &gt;&gt;= <span class="hljs-keyword">fun</span> h =&gt;
u &gt;&gt;= <span class="hljs-keyword">fun</span> f =&gt;
pure (h f)</code></pre>
</div>
<div class="explanation">
={ <em>Definition of <code class="hljs">seq</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">seq (pure (<span class="hljs-keyword">fun</span> f =&gt; f x)) (<span class="hljs-keyword">fun</span> () =&gt; u)</code></pre>
</div>
</div>
<p>This justifies a definition of <code class="hljs">Monad</code> that extends <code class="hljs">Applicative</code>, with a default definition of <code class="hljs">seq</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">M</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">a</span><span class="hljs-title">d</span> <span class="hljs-params">(m : <span class="hljs-built_in">Type</span> â <span class="hljs-built_in">Type</span>)</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-title">m</span></span> <span class="hljs-keyword">where</span>
  bind : m Î± â (Î± â m Î²) â m Î²
  seq f x :=
    bind f <span class="hljs-keyword">fun</span> g =&gt;
    bind (x ()) <span class="hljs-keyword">fun</span> y =&gt;
    pure (g y)
</code></pre>
<p><code class="hljs">Applicative</code>'s own default definition of <code class="hljs">map</code> means that every <code class="hljs">Monad</code> instance automatically generates <code class="hljs">Applicative</code> and <code class="hljs">Functor</code> instances as well.</p>
<h2 id="additional-stipulations"><a class="header" href="#additional-stipulations">Additional Stipulations</a></h2>
<p>In addition to adhering to the individual contracts associated with each type class, combined implementations <code class="hljs">Functor</code>, <code class="hljs">Applicative</code> and <code class="hljs">Monad</code> should work equivalently to these default implementations.
In other words, a type that provides both <code class="hljs">Applicative</code> and <code class="hljs">Monad</code> instances should not have an implementation of <code class="hljs">seq</code> that works differently from the version that the <code class="hljs">Monad</code> instance generates as a default implementation.
This is important because polymorphic functions may be refactored to replace a use of <code class="hljs">&gt;&gt;=</code> with an equivalent use of <code class="hljs">&lt;*&gt;</code>, or a use of <code class="hljs">&lt;*&gt;</code> with an equivalent use of <code class="hljs">&gt;&gt;=</code>.
This refactoring should not change the meaning of programs that use this code.</p>
<p>This rule explains why <code class="hljs">Validate.andThen</code> should not be used to implement <code class="hljs">bind</code> in a <code class="hljs">Monad</code> instance.
On its own, it obeys the monad contract.
However, when it is used to implement <code class="hljs">seq</code>, the behavior is not equivalent to <code class="hljs">seq</code> itself.
To see where they differ, take the example of two computations, both of which return errors.
Start with an example of a case where two errors should be returned, one from validating a function (which could have just as well resulted from a prior argument to the function), and one from validating an argument:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">t</span><span class="hljs-title">F</span><span class="hljs-title">u</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> Validate String (Nat â String) :=
  .errors { head := <span class="hljs-string">"First error"</span>, tail := [] }

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">t</span><span class="hljs-title">A</span><span class="hljs-title">r</span><span class="hljs-title">g</span> <span class="hljs-symbol">:</span></span> Validate String Nat :=
  .errors { head := <span class="hljs-string">"Second error"</span>, tail := [] }
</code></pre>
<p>Combining them with the version of <code class="hljs">&lt;*&gt;</code> from <code class="hljs">Validate</code>'s <code class="hljs">Applicative</code> instance results in both errors being reported to the user:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">notFun &lt;*&gt; notArg
===&gt;
<span class="hljs-keyword">match</span> notFun <span class="hljs-keyword">with</span>
| .ok g =&gt; g &lt;$&gt; notArg
| .errors errs =&gt;
  <span class="hljs-keyword">match</span> notArg <span class="hljs-keyword">with</span>
  | .ok _ =&gt; .errors errs
  | .errors errs' =&gt; .errors (errs ++ errs')
===&gt;
<span class="hljs-keyword">match</span> notArg <span class="hljs-keyword">with</span>
| .ok _ =&gt; .errors { head := <span class="hljs-string">"First error"</span>, tail := [] }
| .errors errs' =&gt; .errors ({ head := <span class="hljs-string">"First error"</span>, tail := [] } ++ errs')
===&gt;
.errors ({ head := <span class="hljs-string">"First error"</span>, tail := [] } ++ { head := <span class="hljs-string">"Second error"</span>, tail := []})
===&gt;
.errors { head := <span class="hljs-string">"First error"</span>, tail := [<span class="hljs-string">"Second error"</span>]}
</code></pre>
<p>Using the version of <code class="hljs">seq</code> that was implemented with <code class="hljs">&gt;&gt;=</code>, here rewritten to <code class="hljs">andThen</code>, results in only the first error being available:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">seq notFun (<span class="hljs-keyword">fun</span> () =&gt; notArg)
===&gt;
notFun.andThen <span class="hljs-keyword">fun</span> g =&gt;
notArg.andThen <span class="hljs-keyword">fun</span> y =&gt;
pure (g y)
===&gt;
<span class="hljs-keyword">match</span> notFun <span class="hljs-keyword">with</span>
| .errors errs =&gt; .errors errs
| .ok val =&gt;
  (<span class="hljs-keyword">fun</span> g =&gt;
    notArg.andThen <span class="hljs-keyword">fun</span> y =&gt;
    pure (g y)) val
===&gt;
.errors { head := <span class="hljs-string">"First error"</span>, tail := [] }
</code></pre>
<div style="break-before:page;page-break-before:always"></div><h1 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h1>
<h2 id="recovery-from-failure"><a class="header" href="#recovery-from-failure">Recovery from Failure</a></h2>
<p><code class="hljs">Validate</code> can also be used in situations where there is more than one way for input to be acceptable.
For the input form <code class="hljs">RawInput</code>, an alternative set of business rules that implement conventions from a legacy system might be the following:</p>
<ol>
<li>All human users must provide a birth year that is four digits.</li>
<li>Users born prior to 1970 do not need to provide names, due to incomplete older records.</li>
<li>Users born after 1970 must provide names.</li>
<li>Companies should enter <code class="hljs">"FIRM"</code> as their year of birth and provide a company name.</li>
</ol>
<p>No particular provision is made for users born in 1970.
It is expected that they will either give up, lie about their year of birth, or call.
The company considers this an acceptable cost of doing business.</p>
<p>The following inductive type captures the values that can be produced from these stated rules:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">abbrev</span> NonEmptyString := {s : String // s â  <span class="hljs-string">""</span>}

<span class="hljs-keyword">inductive</span> LegacyCheckedInput <span class="hljs-keyword">where</span>
  | humanBefore1970 :
    (birthYear : {y : Nat // y &gt; <span class="hljs-number">999</span> â§ y &lt; <span class="hljs-number">1970</span>}) â
    String â
    LegacyCheckedInput
  | humanAfter1970 :
    (birthYear : {y : Nat // y &gt; <span class="hljs-number">1970</span>}) â
    NonEmptyString â
    LegacyCheckedInput
  | company :
    NonEmptyString â
    LegacyCheckedInput
<span class="hljs-keyword">deriving</span> Repr
</code></pre>
<p>A validator for these rules is more complicated, however, as it must address all three cases.
While it can be written as a series of nested <code class="hljs">if</code> expressions, it's easier to design the three cases independently and then combine them.
This requires a means of recovering from failure while preserving error messages:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">V</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">d</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span>.<span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">E</span><span class="hljs-title">l</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-params">(a : Validate Îµ Î±)</span> <span class="hljs-params">(b : Unit â Validate Îµ Î±)</span> <span class="hljs-symbol">:</span></span> Validate Îµ Î± :=
  <span class="hljs-keyword">match</span> a <span class="hljs-keyword">with</span>
  | .ok x =&gt; .ok x
  | .errors errs1 =&gt;
    <span class="hljs-keyword">match</span> b () <span class="hljs-keyword">with</span>
    | .ok x =&gt; .ok x
    | .errors errs2 =&gt; .errors (errs1 ++ errs2)
</code></pre>
<p>This pattern of recovery from failures is common enough that Lean has built-in syntax for it, attached to a type class named <code class="hljs">OrElse</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">O</span><span class="hljs-title">r</span><span class="hljs-title">E</span><span class="hljs-title">l</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span></span> <span class="hljs-keyword">where</span>
  orElse : Î± â (Unit â Î±) â Î±
</code></pre>
<p>The expression <code class="hljs">E1 &lt;|&gt; E2</code> is short for <code class="hljs">OrElse.orElse E1 (fun () =&gt; E2)</code>.
An instance of <code class="hljs">OrElse</code> for <code class="hljs">Validate</code> allows this syntax to be used for error recovery:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> OrElse (Validate Îµ Î±) <span class="hljs-keyword">where</span>
  orElse := Validate.orElse
</code></pre>
<p>The validator for <code class="hljs">LegacyCheckedInput</code> can be built from a validator for each constructor.
The rules for a company state that the birth year should be the string <code class="hljs">"FIRM"</code> and that the name should be non-empty.
The constructor <code class="hljs">LegacyCheckedInput.company</code>, however, has no representation of the birth year at all, so there's no easy way to carry it out using <code class="hljs">&lt;*&gt;</code>.
The key is to use a function with <code class="hljs">&lt;*&gt;</code> that ignores its argument.</p>
<p>Checking that a Boolean condition holds without recording any evidence of this fact in a type can be accomplished with <code class="hljs">checkThat</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">k</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">t</span> <span class="hljs-params">(condition : Bool)</span> <span class="hljs-params">(field : Field)</span> <span class="hljs-params">(msg : String)</span> <span class="hljs-symbol">:</span></span> Validate (Field Ã String) Unit :=
  <span class="hljs-keyword">if</span> condition <span class="hljs-keyword">then</span> pure () <span class="hljs-keyword">else</span> reportError field msg
</code></pre>
<p>This definition of <code class="hljs">checkCompany</code> uses <code class="hljs">checkThat</code>, and then throws away the resulting <code class="hljs">Unit</code> value:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">k</span><span class="hljs-title">C</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">y</span> <span class="hljs-params">(input : RawInput)</span> <span class="hljs-symbol">:</span></span> Validate (Field Ã String) LegacyCheckedInput :=
  pure (<span class="hljs-keyword">fun</span> () name =&gt; .company name) &lt;*&gt;
    checkThat (input.birthYear == <span class="hljs-string">"FIRM"</span>) <span class="hljs-string">"birth year"</span> <span class="hljs-string">"FIRM if a company"</span> &lt;*&gt;
    checkName input.name
</code></pre>
<p>However, this definition is quite noisy.
It can be simplified in two ways.
The first is to replace the first use of <code class="hljs">&lt;*&gt;</code> with a specialized version that automatically ignores the value returned by the first argument, called <code class="hljs">*&gt;</code>.
This operator is also controlled by a type class, called <code class="hljs">SeqRight</code>, and <code class="hljs">E1 *&gt; E2</code> is syntactic sugar for <code class="hljs">SeqRight.seqRight E1 (fun () =&gt; E2)</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">S</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">R</span><span class="hljs-title">i</span><span class="hljs-title">g</span><span class="hljs-title">h</span><span class="hljs-title">t</span> <span class="hljs-params">(f : <span class="hljs-built_in">Type</span> â <span class="hljs-built_in">Type</span>)</span></span> <span class="hljs-keyword">where</span>
  seqRight : f Î± â (Unit â f Î²) â f Î²
</code></pre>
<p>There is a default implementation of <code class="hljs">seqRight</code> in terms of <code class="hljs">seq</code>: <code class="hljs">seqRight (a : f Î±) (b : Unit â f Î²) : f Î² := pure (fun _ x =&gt; x) &lt;*&gt; a &lt;*&gt; b ()</code>.</p>
<p>Using <code class="hljs">seqRight</code>, <code class="hljs">checkCompany</code> becomes simpler:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">k</span><span class="hljs-title">C</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">y</span> <span class="hljs-params">(input : RawInput)</span> <span class="hljs-symbol">:</span></span> Validate (Field Ã String) LegacyCheckedInput :=
  checkThat (input.birthYear == <span class="hljs-string">"FIRM"</span>) <span class="hljs-string">"birth year"</span> <span class="hljs-string">"FIRM if a company"</span> *&gt;
  pure .company &lt;*&gt; checkName input.name
</code></pre>
<p>One more simplification is possible.
For every <code class="hljs">Applicative</code>, <code class="hljs">pure F &lt;*&gt; E</code> is equivalent to <code class="hljs">f &lt;$&gt; E</code>.
In other words, using <code class="hljs">seq</code> to apply a function that was placed into the <code class="hljs">Applicative</code> type using <code class="hljs">pure</code> is overkill, and the function could have just been applied using <code class="hljs">Functor.map</code>.
This simplification yields:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">k</span><span class="hljs-title">C</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">y</span> <span class="hljs-params">(input : RawInput)</span> <span class="hljs-symbol">:</span></span> Validate (Field Ã String) LegacyCheckedInput :=
  checkThat (input.birthYear == <span class="hljs-string">"FIRM"</span>) <span class="hljs-string">"birth year"</span> <span class="hljs-string">"FIRM if a company"</span> *&gt;
  .company &lt;$&gt; checkName input.name
</code></pre>
<p>The remaining two constructors of <code class="hljs">LegacyCheckedInput</code> use subtypes for their fields.
A general-purpose tool for checking subtypes will make these easier to read:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">k</span><span class="hljs-title">S</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">t</span><span class="hljs-title">y</span><span class="hljs-title">p</span><span class="hljs-title">e</span> <span class="hljs-params">{Î± : <span class="hljs-built_in">Type</span>}</span> <span class="hljs-params">(v : Î±)</span> <span class="hljs-params">(p : Î± â <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-params">[Decidable (p v)</span>] <span class="hljs-params">(err : Îµ)</span> <span class="hljs-symbol">:</span></span> Validate Îµ {x : Î± // p x} :=
  <span class="hljs-keyword">if</span> h : p v <span class="hljs-keyword">then</span>
    pure â¨v, hâ©
  <span class="hljs-keyword">else</span>
    .errors { head := err, tail := [] }
</code></pre>
<p>In the function's argument list, it's important that the type class <code class="hljs">[Decidable (p v)]</code> occur after the specification of the arguments <code class="hljs">v</code> and <code class="hljs">p</code>.
Otherwise, it would refer to an additional set of automatic implicit arguments, rather than to the manually-provided values.
The <code class="hljs">Decidable</code> instance is what allows the proposition <code class="hljs">p v</code> to be checked using <code class="hljs">if</code>.</p>
<p>The two human cases do not need any additional tools:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">k</span><span class="hljs-title">H</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">B</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">e1970</span> <span class="hljs-params">(input : RawInput)</span> <span class="hljs-symbol">:</span></span> Validate (Field Ã String) LegacyCheckedInput :=
  (checkYearIsNat input.birthYear).andThen <span class="hljs-keyword">fun</span> y =&gt;
    .humanBefore1970 &lt;$&gt;
      checkSubtype y (<span class="hljs-keyword">fun</span> x =&gt; x &gt; <span class="hljs-number">999</span> â§ x &lt; <span class="hljs-number">1970</span>) (<span class="hljs-string">"birth year"</span>, <span class="hljs-string">"less than 1970"</span>) &lt;*&gt;
      pure input.name

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">k</span><span class="hljs-title">H</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">A</span><span class="hljs-title">f</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r1970</span> <span class="hljs-params">(input : RawInput)</span> <span class="hljs-symbol">:</span></span> Validate (Field Ã String) LegacyCheckedInput :=
  (checkYearIsNat input.birthYear).andThen <span class="hljs-keyword">fun</span> y =&gt;
    .humanAfter1970 &lt;$&gt;
      checkSubtype y (Â· &gt; <span class="hljs-number">1970</span>) (<span class="hljs-string">"birth year"</span>, <span class="hljs-string">"greater than 1970"</span>) &lt;*&gt;
      checkName input.name
</code></pre>
<p>The validators for the three cases can be combined using <code class="hljs">&lt;|&gt;</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">k</span><span class="hljs-title">L</span><span class="hljs-title">e</span><span class="hljs-title">g</span><span class="hljs-title">a</span><span class="hljs-title">c</span><span class="hljs-title">y</span><span class="hljs-title">I</span><span class="hljs-title">n</span><span class="hljs-title">p</span><span class="hljs-title">u</span><span class="hljs-title">t</span> <span class="hljs-params">(input : RawInput)</span> <span class="hljs-symbol">:</span></span> Validate (Field Ã String) LegacyCheckedInput :=
  checkCompany input &lt;|&gt; checkHumanBefore1970 input &lt;|&gt; checkHumanAfter1970 input
</code></pre>
<p>The successful cases return constructors of <code class="hljs">LegacyCheckedInput</code>, as expected:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> checkLegacyInput â¨<span class="hljs-string">"Johnny's Troll Groomers"</span>, <span class="hljs-string">"FIRM"</span>â©
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Validate.ok (LegacyCheckedInput.company "Johnny's Troll Groomers")
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> checkLegacyInput â¨<span class="hljs-string">"Johnny"</span>, <span class="hljs-string">"1963"</span>â©
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Validate.ok (LegacyCheckedInput.humanBefore1970 1963 "Johnny")
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> checkLegacyInput â¨<span class="hljs-string">""</span>, <span class="hljs-string">"1963"</span>â©
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Validate.ok (LegacyCheckedInput.humanBefore1970 1963 "")
</code></pre>
<p>The worst possible input returns all the possible failures:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> checkLegacyInput â¨<span class="hljs-string">""</span>, <span class="hljs-string">"1970"</span>â©
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Validate.errors
  { head := ("birth year", "FIRM if a company"),
    tail := [("name", "Required"),
             ("birth year", "less than 1970"),
             ("birth year", "greater than 1970"),
             ("name", "Required")] }
</code></pre>
<h2 id="the-alternative-class"><a class="header" href="#the-alternative-class">The <code>Alternative</code> Class</a></h2>
<p>Many types support a notion of failure and recovery.
The <code class="hljs">Many</code> monad from the section on <a href="https://leanprover.github.io/functional_programming_in_lean/monads/arithmetic.html#nondeterministic-search">evaluating arithmetic expressions in a variety of monads</a> is one such type, as is <code class="hljs">Option</code>.
Both support failure without providing a reason (unlike, say, <code class="hljs">Except</code> and <code class="hljs">Validate</code>, which require some indication of what went wrong).</p>
<p>The <code class="hljs">Alternative</code> class describes applicative functors that have additional operators for failure and recovery:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><span class="hljs-title">l</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">n</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-params">(f : <span class="hljs-built_in">Type</span> â <span class="hljs-built_in">Type</span>)</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-title">f</span></span> <span class="hljs-keyword">where</span>
  failure : f Î±
  orElse : f Î± â (Unit â f Î±) â f Î±
</code></pre>
<p>Just as implementors of <code class="hljs">Add Î±</code> get <code class="hljs">HAdd Î± Î± Î±</code> instances for free, implementors of <code class="hljs">Alternative</code> get <code class="hljs">OrElse</code> instances for free:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[Alternative f]</span> <span class="hljs-symbol">:</span></span> OrElse (f Î±) <span class="hljs-keyword">where</span>
  orElse := Alternative.orElse
</code></pre>
<p>The implementation of <code class="hljs">Alternative</code> for <code class="hljs">Option</code> keeps the first none-<code class="hljs">none</code> argument:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Alternative Option <span class="hljs-keyword">where</span>
  failure := none
  orElse
    | some x, _ =&gt; some x
    | none, y =&gt; y ()
</code></pre>
<p>Similarly, the implementation for <code class="hljs">Many</code> follows the general structure of <code class="hljs">Many.union</code>, with minor differences due to the laziness-inducing <code class="hljs">Unit</code> parameters being placed differently:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">M</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">y</span>.<span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">E</span><span class="hljs-title">l</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Many Î± â (Unit â Many Î±) â Many Î±
  | .none, ys =&gt; ys ()
  | .more x xs, ys =&gt; .more x (<span class="hljs-keyword">fun</span> () =&gt; orElse (xs ()) ys)

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Alternative Many <span class="hljs-keyword">where</span>
  failure := .none
  orElse := Many.orElse
</code></pre>
<p>Like other type classes, <code class="hljs">Alternative</code> enables the definition of a variety of operations that work for <em>any</em> applicative functor that implements <code class="hljs">Alternative</code>.
One of the most important is <code class="hljs">guard</code>, which causes <code class="hljs">failure</code> when a decidable proposition is false:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-title">u</span><span class="hljs-title">a</span><span class="hljs-title">r</span><span class="hljs-title">d</span> <span class="hljs-params">[Alternative f]</span> <span class="hljs-params">(p : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-params">[Decidable p]</span> <span class="hljs-symbol">:</span></span> f Unit :=
  <span class="hljs-keyword">if</span> p <span class="hljs-keyword">then</span>
    pure ()
  <span class="hljs-keyword">else</span> failure
</code></pre>
<p>It is very useful in monadic programs to terminate execution early.
In <code class="hljs">Many</code>, it can be used to filter out a whole branch of a search, as in the following program that computes all even divisors of a natural number:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">M</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">y</span>.<span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">d</span><span class="hljs-title">ow</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> Nat â Many Nat
  | <span class="hljs-number">0</span> =&gt; .none
  | n + <span class="hljs-number">1</span> =&gt; .more n (<span class="hljs-keyword">fun</span> () =&gt; countdown n)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">D</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">s</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span> Many Nat := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> k â Many.countdown (n + <span class="hljs-number">1</span>)
  guard (k % <span class="hljs-number">2</span> = <span class="hljs-number">0</span>)
  guard (n % k = <span class="hljs-number">0</span>)
  pure k
</code></pre>
<p>Running it on <code class="hljs">20</code> yields the expected results:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (evenDivisors <span class="hljs-number">20</span>).takeAll
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">[20, 10, 4, 2]
</code></pre>
<h2 id="exercises-12"><a class="header" href="#exercises-12">Exercises</a></h2>
<h3 id="improve-validation-friendliness"><a class="header" href="#improve-validation-friendliness">Improve Validation Friendliness</a></h3>
<p>The errors returned from <code class="hljs">Validate</code> programs that use <code class="hljs">&lt;|&gt;</code> can be difficult to read, because inclusion in the list of errors simply means that the error can be reached through <em>some</em> code path.
A more structured error report can be used to guide the user through the process more accurately:</p>
<ul>
<li>Replace the <code class="hljs">NonEmptyList</code> in <code class="hljs">Validate.error</code> with a bare type variable, and then update the definitions of the <code class="hljs">Applicative (Validate Îµ)</code> and <code class="hljs">OrElse (Validate Îµ Î±)</code> instances to require only that there be an <code class="hljs">Append Îµ</code> instance available.</li>
<li>Define a function <code class="hljs">Validate.mapErrors : Validate Îµ Î± â (Îµ â Îµ') â Validate Îµ' Î±</code> that transforms all the errors in a validation run.</li>
<li>Using the datatype <code class="hljs">TreeError</code> to represent errors, rewrite the legacy validation system to track its path through the three alternatives.</li>
<li>Write a function <code class="hljs">report : TreeError â String</code> that outputs a user-friendly view of the <code class="hljs">TreeError</code>'s accumulated warnings and errors.</li>
</ul>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> TreeError <span class="hljs-keyword">where</span>
  | field : Field â String â TreeError
  | path : String â TreeError â TreeError
  | both : TreeError â TreeError â TreeError

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Append TreeError <span class="hljs-keyword">where</span>
  append := .both
</code></pre>
<div style="break-before:page;page-break-before:always"></div><h1 id="universes"><a class="header" href="#universes">Universes</a></h1>
<p>In the interests of simplicity, this book has thus far papered over an important feature of Lean: <em>universes</em>.
A universe is a type that classifies other types.
Two of them are familiar: <code class="hljs">Type</code> and <code class="hljs">Prop</code>.
<code class="hljs">Type</code> classifies ordinary types, such as <code class="hljs">Nat</code>, <code class="hljs">String</code>, <code class="hljs">Int â String Ã Char</code>, and <code class="hljs">IO Unit</code>.
<code class="hljs">Prop</code> classifies propositions that may be true or false, such as <code class="hljs">"nisse" = "elf"</code> or <code class="hljs">3 &gt; 2</code>.
The type of <code class="hljs">Prop</code> is <code class="hljs">Type</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-built_in">Prop</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Prop : Type
</code></pre>
<p>For technical reasons, more universes than these two are needed.
In particular, <code class="hljs">Type</code> cannot itself be a <code class="hljs">Type</code>.
This would allow a logical paradox to be constructed and undermine Lean's usefulness as a theorem prover.</p>
<p>The formal argument for this is known as <em>Girard's Paradox</em>.
It related to a better-known paradox known as <em>Russell's Paradox</em>, which was used to show that early versions of set theory were inconsistent.
In these set theories, a set can be defined by a property.
For example, one might have the set of all red things, the set of all fruit, the set of all natural numbers, or even the set of all sets.
Given a set, one can ask whether a given element is contained in it.
For instance, a bluebird is not contained in the set of all red things, but the set of all red things is contained in the set of all sets.
Indeed, the set of all sets even contains itself.</p>
<p>What about the set of all sets that do not contain themselves?
It contains the set of all red things, as the set of all red things is not itself red.
It does not contain the set of all sets, because the set of all sets contains itself.
But does it contain itself?
If it does contain itself, then it cannot contain itself.
But if it does not, then it must.</p>
<p>This is a contradiction, which demonstrates that something was wrong with the initial assumptions.
In particular, allowing sets to be constructed by providing an arbitrary property is too powerful.
Later versions of set theory restrict the formation of sets to remove the paradox.</p>
<p>A related paradox can be constructed in versions of dependent type theory that assign the type <code class="hljs">Type</code> to <code class="hljs">Type</code>.
To ensure that Lean has consistent logical foundations and can be used as a tool for mathematics, <code class="hljs">Type</code> needs to have some other type.
This type is called <code class="hljs">Type 1</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> <span class="hljs-built_in">Type</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Type : Type 1
</code></pre>
<p>Similarly, <code class="hljs">Type 1</code> is a <code class="hljs">Type 2</code>,
<code class="hljs">Type 2</code> is a <code class="hljs">Type 3</code>,
<code class="hljs">Type 3</code> is a <code class="hljs">Type 4</code>, and so forth.</p>
<p>Function types occupy the smallest universe that can contain both the argument type and the return type.
This means that <code class="hljs">Nat â Nat</code> is a <code class="hljs">Type</code>, <code class="hljs">Type â Type</code> is a <code class="hljs">Type 1</code>, and <code class="hljs">Type 1 â Type 2</code> is a <code class="hljs">Type 3</code>.</p>
<p>There is one exception to this rule.
If the return type of a function is a <code class="hljs">Prop</code>, then the whole function type is in <code class="hljs">Prop</code>, even if the argument is in a larger universe such as <code class="hljs">Type</code> or even <code class="hljs">Type 1</code>.
In particular, this means that predicates over values that have ordinary types are in <code class="hljs">Prop</code>.
For example, the type <code class="hljs">(n : Nat) â n = n + 0</code> represents a function from a <code class="hljs">Nat</code> to evidence that it is equal to itself plus zero.
Even though <code class="hljs">Nat</code> is in <code class="hljs">Type</code>, this function type is in <code class="hljs">Prop</code> due to this rule.
Similarly, even though <code class="hljs">Type</code> is in <code class="hljs">Type 1</code>, the function type <code class="hljs">Type â 2 + 2 = 4</code> is still in <code class="hljs">Prop</code>.</p>
<h2 id="user-defined-types"><a class="header" href="#user-defined-types">User Defined Types</a></h2>
<p>Structures and inductive datatypes can be declared to inhabit particular universes.
Lean then checks whether each datatype avoids paradoxes by being in a universe that's large enough to prevent it from containing its own type.
For instance, in the following declaration, <code class="hljs">MyList</code> is declared to reside in <code class="hljs">Type</code>, and so is its type argument <code class="hljs">Î±</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> MyList (Î± : <span class="hljs-built_in">Type</span>) : <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  | nil : MyList Î±
  | cons : Î± â MyList Î± â MyList Î±
</code></pre>
<p><code class="hljs">MyList</code> itself is a <code class="hljs">Type â Type</code>.
This means that it cannot be used to contain actual types, because then its argument would be <code class="hljs">Type</code>, which is a <code class="hljs">Type 1</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">y</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">O</span><span class="hljs-title">f</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> MyList <span class="hljs-built_in">Type</span> :=
  .cons Nat .nil
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">application type mismatch
  MyList Type
argument
  Type
has type
  Type 1 : Type 2
but is expected to have type
  Type : Type 1
</code></pre>
<p>Updating <code class="hljs">MyList</code> so that its argument is a <code class="hljs">Type 1</code> results in a definition rejected by Lean:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> MyList (Î± : <span class="hljs-built_in">Type</span> <span class="hljs-number">1</span>) : <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  | nil : MyList Î±
  | cons : Î± â MyList Î± â MyList Î±
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">invalid universe level in constructor 'MyList.cons', parameter has type
  Î±
at universe level
  2
it must be smaller than or equal to the inductive datatype universe level
  1
</code></pre>
<p>This error occurs because the argument to <code class="hljs">cons</code> with type <code class="hljs">Î±</code> is from a larger universe than <code class="hljs">MyList</code>.
Placing <code class="hljs">MyList</code> itself in <code class="hljs">Type 1</code> solves this issue, but at the cost of <code class="hljs">MyList</code> now being itself inconvenient to use in contexts that expect a <code class="hljs">Type</code>.</p>
<p>The specific rules that govern whether a datatype is allowed are somewhat complicated.
Generally speaking, it's easiest to start with the datatype in the same universe as the largest of its arguments.
Then, if Lean rejects the definition, increase its level by one, which will usually go through.</p>
<h2 id="universe-polymorphism"><a class="header" href="#universe-polymorphism">Universe Polymorphism</a></h2>
<p>Defining a datatype in a specific universe can lead to code duplication.
Placing <code class="hljs">MyList</code> in <code class="hljs">Type â Type</code> means that it can't be used for an actual list of types.
Placing it in <code class="hljs">Type 1 â Type 1</code> means that it can't be used for a list of lists of types.
Rather than copy-pasting the datatype to create versions in <code class="hljs">Type</code>, <code class="hljs">Type 1</code>, <code class="hljs">Type 2</code>, and so on, a feature called <em>universe polymorphism</em> can be used to write a single definition that can be instantiated in any of these universes.</p>
<p>Ordinary polymorphic types use variables to stand for types in a definition.
This allows Lean to fill in the variables differently, which enables these definitions to be used with a variety of types.
Similarly, universe polymorphism allows variables to stand for universes in a definition, enabling Lean to fill them in differently so that they can be used with a variety of universes.
Just as type arguments are conventionally named with Greek letters, universe arguments are conventionally named <code class="hljs">u</code>, <code class="hljs">v</code>, and <code class="hljs">w</code>.</p>
<p>This definition of <code class="hljs">MyList</code> doesn't specify a particular universe level, but instead uses a variable <code class="hljs">u</code> to stand for any level.
If the resulting datatype is used with <code class="hljs">Type</code>, then <code class="hljs">u</code> is <code class="hljs">0</code>, and if it's used with <code class="hljs">Type 3</code>, then <code class="hljs">u</code> is <code class="hljs">3</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> MyList (Î± : <span class="hljs-built_in">Type</span> u) : <span class="hljs-built_in">Type</span> u <span class="hljs-keyword">where</span>
  | nil : MyList Î±
  | cons : Î± â MyList Î± â MyList Î±
</code></pre>
<p>With this definition, the same definition of <code class="hljs">MyList</code> can be used to contain both actual natural numbers and the natural number type itself:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">y</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">O</span><span class="hljs-title">f</span><span class="hljs-title">N</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">b</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> MyList Nat :=
  .cons <span class="hljs-number">0</span> (.cons <span class="hljs-number">1</span> .nil)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">y</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">O</span><span class="hljs-title">f</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> MyList <span class="hljs-built_in">Type</span> :=
  .cons Nat .nil
</code></pre>
<p>It can even contain itself:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">y</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">O</span><span class="hljs-title">f</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> MyList (<span class="hljs-built_in">Type</span> â <span class="hljs-built_in">Type</span>) :=
  .cons MyList .nil
</code></pre>
<p>It would seem that this would make it possible to write a logical paradox.
After all, the whole point of the universe system is to rule out self-referential types.
Behind the scenes, however, each occurrence of <code class="hljs">MyList</code> is provided with a universe level argument.
In essence, the universe-polymorphic definition of <code class="hljs">MyList</code> created a <em>copy</em> of the datatype at each level, and the level argument selects which copy is to be used.
These level arguments are written with a dot and curly braces, so <code class="hljs">MyList.{0} : Type â Type</code>, <code class="hljs">MyList.{1} : Type 1 â Type 1</code>, and <code class="hljs">MyList.{2} : Type 2 â Type 2</code>.</p>
<p>Writing the levels explicitly, the prior example becomes:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">y</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">O</span><span class="hljs-title">f</span><span class="hljs-title">N</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">b</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> MyList.{<span class="hljs-number">0</span>} Nat :=
  .cons <span class="hljs-number">0</span> (.cons <span class="hljs-number">1</span> .nil)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">y</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">O</span><span class="hljs-title">f</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> MyList.{<span class="hljs-number">1</span>} <span class="hljs-built_in">Type</span> :=
  .cons Nat .nil

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">y</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">O</span><span class="hljs-title">f</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> MyList.{<span class="hljs-number">1</span>} (<span class="hljs-built_in">Type</span> â <span class="hljs-built_in">Type</span>) :=
  .cons MyList.{<span class="hljs-number">0</span>} .nil
</code></pre>
<p>When a universe-polymorphic definition takes multiple types as arguments, it's a good idea to give each argument its own level variable for maximum flexibility.
For example, a version of <code class="hljs">Sum</code> with a single level argument can be written as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Sum (Î± : <span class="hljs-built_in">Type</span> u) (Î² : <span class="hljs-built_in">Type</span> u) : <span class="hljs-built_in">Type</span> u <span class="hljs-keyword">where</span>
  | inl : Î± â Sum Î± Î²
  | inr : Î² â Sum Î± Î²
</code></pre>
<p>This definition can be used at multiple levels:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">g</span><span class="hljs-title">O</span><span class="hljs-title">r</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> Sum String Nat := .inl <span class="hljs-string">"hello"</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">y</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">O</span><span class="hljs-title">r</span><span class="hljs-title">T</span><span class="hljs-title">y</span><span class="hljs-title">p</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Sum <span class="hljs-built_in">Type</span> <span class="hljs-built_in">Type</span> := .inr Nat
</code></pre>
<p>However, it requires that both arguments be in the same universe:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">g</span><span class="hljs-title">O</span><span class="hljs-title">r</span><span class="hljs-title">T</span><span class="hljs-title">y</span><span class="hljs-title">p</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Sum String <span class="hljs-built_in">Type</span> := .inr Nat
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">application type mismatch
  Sum String Type
argument
  Type
has type
  Type 1 : Type 2
but is expected to have type
  Type : Type 1
</code></pre>
<p>This datatype can be made more flexible by using different variables for the two type arguments' universe levels, and then declaring that the resulting datatype is in the largest of the two:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Sum (Î± : <span class="hljs-built_in">Type</span> u) (Î² : <span class="hljs-built_in">Type</span> v) : <span class="hljs-built_in">Type</span> (max u v) <span class="hljs-keyword">where</span>
  | inl : Î± â Sum Î± Î²
  | inr : Î² â Sum Î± Î²
</code></pre>
<p>This allows <code class="hljs">Sum</code> to be used with arguments from different universes:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">g</span><span class="hljs-title">O</span><span class="hljs-title">r</span><span class="hljs-title">T</span><span class="hljs-title">y</span><span class="hljs-title">p</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Sum String <span class="hljs-built_in">Type</span> := .inr Nat
</code></pre>
<p>In positions where Lean expects a universe level, any of the following are allowed:</p>
<ul>
<li>A concrete level, like <code class="hljs">0</code> or <code class="hljs">1</code></li>
<li>A variable that stands for a level, such as <code class="hljs">u</code> or <code class="hljs">v</code></li>
<li>The maximum of two levels, written as <code class="hljs">max</code> applied to the levels</li>
<li>A level increase, written with <code class="hljs">+ 1</code></li>
</ul>
<h3 id="writing-universe-polymorphic-definitions"><a class="header" href="#writing-universe-polymorphic-definitions">Writing Universe-Polymorphic Definitions</a></h3>
<p>Until now, every datatype defined in this book has been in <code class="hljs">Type</code>, the smallest universe of data.
When presenting polymorphic datatypes from the Lean standard library, such as <code class="hljs">List</code> and <code class="hljs">Sum</code>, this book created non-universe-polymorphic versions of them.
The real versions use universe polymorphism to enable code re-use between type-level and non-type-level programs.</p>
<p>There are a few general guidelines to follow when writing universe-polymorphic types.
First off, independent type arguments should have different universe variables, which enables the polymorphic definition to be used with a wider variety of arguments, increasing the potential for code reuse.
Secondly, the whole type is itself typically either in the maximum of all the universe variables, or one greater than this maximum.
Try the smaller of the two first.
Finally, it's a good idea to put the new type in as small of a universe as possible, which allows it to be used more flexibly in other contexts.
Non-polymorphic types, such as <code class="hljs">Nat</code> and <code class="hljs">String</code>, can be placed directly in <code class="hljs">Type 0</code>.</p>
<h3 id="prop-and-polymorphism"><a class="header" href="#prop-and-polymorphism"><code>Prop</code> and Polymorphism</a></h3>
<p>Just as <code class="hljs">Type</code>, <code class="hljs">Type 1</code>, and so on describe types that classify programs and data, <code class="hljs">Prop</code> classifies logical propositions.
A type in <code class="hljs">Prop</code> describes what counts as convincing evidence for the truth of a statement.
Propositions are like ordinary types in many ways: they can be declared inductively, they can have constructors, and functions can take propositions as arguments.
However, unlike datatypes, it typically doesn't matter <em>which</em> evidence is provided for the truth of a statement, only <em>that</em> evidence is provided.
On the other hand, it is very important that a program not only return a <code class="hljs">Nat</code>, but that it's the <em>correct</em> <code class="hljs">Nat</code>.</p>
<p><code class="hljs">Prop</code> is at the bottom of the universe hierarchy, and the type of <code class="hljs">Prop</code> is <code class="hljs">Type</code>.
This means that <code class="hljs">Prop</code> is a suitable argument to provide to <code class="hljs">List</code>, for the same reason that <code class="hljs">Nat</code> is.
Lists of propositions have type <code class="hljs">List Prop</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">u</span><span class="hljs-title">e</span><span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">p</span><span class="hljs-title">o</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> List <span class="hljs-built_in">Prop</span> := [
  <span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">2</span>,
  <span class="hljs-string">"Hello, "</span> ++ <span class="hljs-string">"world!"</span> = <span class="hljs-string">"Hello, world!"</span>
]
</code></pre>
<p>Filling out the universe argument explicitly demonstrates that <code class="hljs">Prop</code> is a <code class="hljs">Type</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">u</span><span class="hljs-title">e</span><span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">p</span><span class="hljs-title">o</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> List.{<span class="hljs-number">0</span>} <span class="hljs-built_in">Prop</span> := [
  <span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">2</span>,
  <span class="hljs-string">"Hello, "</span> ++ <span class="hljs-string">"world!"</span> = <span class="hljs-string">"Hello, world!"</span>
]
</code></pre>
<p>Behind the scenes, <code class="hljs">Prop</code> and <code class="hljs">Type</code> are united into a single hierarchy called <code class="hljs">Sort</code>.
<code class="hljs">Prop</code> is the same as <code class="hljs">Sort 0</code>, <code class="hljs">Type 0</code> is <code class="hljs">Sort 1</code>, <code class="hljs">Type 1</code> is <code class="hljs">Sort 2</code>, and so forth.
In fact, <code class="hljs">Type u</code> is the same as <code class="hljs">Sort (u+1)</code>.
When writing programs with Lean, this is typically not relevant, but it may occur in error messages from time to time, and it explains the name of the <code class="hljs">CoeSort</code> class.
Additionally, having <code class="hljs">Prop</code> as <code class="hljs">Sort 0</code> allows one more universe operator to become useful.
The universe level <code class="hljs">imax u v</code> is <code class="hljs">0</code> when <code class="hljs">v</code> is <code class="hljs">0</code>, or the larger of <code class="hljs">u</code> or <code class="hljs">v</code> otherwise.
Together with <code class="hljs">Sort</code>, this allows the special rule for functions that return <code class="hljs">Prop</code>s to be used when writing code that should be as portable as possible between <code class="hljs">Prop</code> and <code class="hljs">Type</code> universes.</p>
<h2 id="polymorphism-in-practice"><a class="header" href="#polymorphism-in-practice">Polymorphism in Practice</a></h2>
<p>In the remainder of the book, definitions of polymorphic datatypes, structures, and classes will use universe polymorphism in order to be consistent with the Lean standard library.
This will enable the complete presentation of the <code class="hljs">Functor</code>, <code class="hljs">Applicative</code>, and <code class="hljs">Monad</code> classes to be completely consistent with their actual definitions.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="the-complete-definitions"><a class="header" href="#the-complete-definitions">The Complete Definitions</a></h1>
<p>Now that all the relevant language features have been presented, this section describes the complete, honest definitions of <code class="hljs">Functor</code>, <code class="hljs">Applicative</code>, and <code class="hljs">Monad</code> as they occur in the Lean standard library.
For the sake of understanding, no details are omitted.</p>
<h2 id="functor"><a class="header" href="#functor">Functor</a></h2>
<p>The complete definition of the <code class="hljs">Functor</code> class makes use of universe polymorphism and a default method implementation:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">c</span><span class="hljs-title">t</span><span class="hljs-title">o</span><span class="hljs-title">r</span> <span class="hljs-params">(f : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> (max (u+<span class="hljs-number">1</span>) v) <span class="hljs-keyword">where</span>
  map : {Î± Î² : <span class="hljs-built_in">Type</span> u} â (Î± â Î²) â f Î± â f Î²
  mapConst : {Î± Î² : <span class="hljs-built_in">Type</span> u} â Î± â f Î² â f Î± :=
    Function.comp map (Function.const _)
</code></pre>
<p>In this definition, <code class="hljs">Function.comp</code> is function composition, which is typically written with the <code class="hljs">â</code> operator.
<code class="hljs">Function.const</code> is the <em>constant function</em>, which is a two-argument function that ignores its second argument.
Applying this function to only one argument produces a function that always returns the same value, which is useful when an API demands a function but a program doesn't need to compute different results for different arguments.
A simple version of <code class="hljs">Function.const</code> can be written as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">C</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">t</span>  <span class="hljs-params">(x : Î±)</span> <span class="hljs-params">(_ : Î²)</span> <span class="hljs-symbol">:</span></span> Î± := x
</code></pre>
<p>Using it with one argument as the function argument to <code class="hljs">List.map</code> demonstrates its utility:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].map (simpleConst <span class="hljs-string">"same"</span>)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">["same", "same", "same"]
</code></pre>
<p>The actual function has the following signature:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Function.const.{u, v} {Î± : Sort u} (Î² : Sort v) (a : Î±) (aâ : Î²) : Î±
</code></pre>
<p>Here, the type argument <code class="hljs">Î²</code> is an explicit argument, so the default definition of <code class="hljs">Functor.mapConst</code> provides an <code class="hljs">_</code> argument that instructs Lean to find a unique type to pass to <code class="hljs">Function.const</code> that would cause the program to type check.
<code class="hljs">(Function.comp map (Function.const _) : Î± â f Î² â f Î±)</code> is equivalent to <code class="hljs">fun (x : Î±) (y : f Î²) =&gt; map (fun _ =&gt; x) y</code>.</p>
<p>The <code class="hljs">Functor</code> type class inhabits a universe that is the greater of <code class="hljs">u+1</code> and <code class="hljs">v</code>.
Here, <code class="hljs">u</code> is the level of universes accepted as arguments to <code class="hljs">f</code>, while <code class="hljs">v</code> is the universe returned by <code class="hljs">f</code>.
To see why the structure that implements the <code class="hljs">Functor</code> type class must be in a universe that's larger than <code class="hljs">u</code>, begin with a simplified definition of the class:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">c</span><span class="hljs-title">t</span><span class="hljs-title">o</span><span class="hljs-title">r</span> <span class="hljs-params">(f : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> (max (u+<span class="hljs-number">1</span>) v) <span class="hljs-keyword">where</span>
  map : {Î± Î² : <span class="hljs-built_in">Type</span> u} â (Î± â Î²) â f Î± â f Î²
</code></pre>
<p>This type class's structure type is equivalent to the following inductive type:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Functor (f : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v) : <span class="hljs-built_in">Type</span> (max (u+<span class="hljs-number">1</span>) v) <span class="hljs-keyword">where</span>
  | mk : ({Î± Î² : <span class="hljs-built_in">Type</span> u} â (Î± â Î²) â f Î± â f Î²) â Functor f
</code></pre>
<p>The implementation of the <code class="hljs">map</code> method that is passed as an argument to <code class="hljs">Functor.mk</code> contains a function that takes two types in <code class="hljs">Type u</code> as arguments.
This means that the type of the function itself is in <code class="hljs">Type (u+1)</code>, so <code class="hljs">Functor</code> must also be at a level that is at least <code class="hljs">u+1</code>.
Similarly, other arguments to the function have a type built by applying <code class="hljs">f</code>, so it must also have a level that is at least <code class="hljs">v</code>.
All the type classes in this section share this property.</p>
<h2 id="applicative"><a class="header" href="#applicative">Applicative</a></h2>
<p>The <code class="hljs">Applicative</code> type class is actually built from a number of smaller classes that each contain some of the relevant methods.
The first are <code class="hljs">Pure</code> and <code class="hljs">Seq</code>, which contain <code class="hljs">pure</code> and <code class="hljs">seq</code> respectively:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">P</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">e</span> <span class="hljs-params">(f : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> (max (u+<span class="hljs-number">1</span>) v) <span class="hljs-keyword">where</span>
  pure {Î± : <span class="hljs-built_in">Type</span> u} : Î± â f Î±

<span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">S</span><span class="hljs-title">e</span><span class="hljs-title">q</span> <span class="hljs-params">(f : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> (max (u+<span class="hljs-number">1</span>) v) <span class="hljs-keyword">where</span>
  seq : {Î± Î² : <span class="hljs-built_in">Type</span> u} â f (Î± â Î²) â (Unit â f Î±) â f Î²
</code></pre>
<p>In addition to these, <code class="hljs">Applicative</code> also depends on <code class="hljs">SeqRight</code> and an analogous <code class="hljs">SeqLeft</code> class:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">S</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">R</span><span class="hljs-title">i</span><span class="hljs-title">g</span><span class="hljs-title">h</span><span class="hljs-title">t</span> <span class="hljs-params">(f : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> (max (u+<span class="hljs-number">1</span>) v) <span class="hljs-keyword">where</span>
  seqRight : {Î± Î² : <span class="hljs-built_in">Type</span> u} â f Î± â (Unit â f Î²) â f Î²

<span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">S</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">L</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-params">(f : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> (max (u+<span class="hljs-number">1</span>) v) <span class="hljs-keyword">where</span>
  seqLeft : {Î± Î² : <span class="hljs-built_in">Type</span> u} â f Î± â (Unit â f Î²) â f Î±
</code></pre>
<p>The <code class="hljs">seqRight</code> function, which was introduced in the <a href="https://leanprover.github.io/functional_programming_in_lean/functor-applicative-monad/alternative.html">section about alternatives and validation</a>, is easiest to understand from the perspective of effects.
<code class="hljs">E1 *&gt; E2</code>, which desugars to <code class="hljs">SeqRight.seqRight E1 (fun () =&gt; E2)</code>, can be understood as first executing <code class="hljs">E1</code>, and then <code class="hljs">E2</code>, resulting only in <code class="hljs">E2</code>'s result.
Effects from <code class="hljs">E1</code> may result in <code class="hljs">E2</code> not being run, or being run multiple times.
Indeed, if <code class="hljs">f</code> has a <code class="hljs">Monad</code> instance, then <code class="hljs">E1 *&gt; E2</code> is equivalent to <code class="hljs">do let _ â E1; E2</code>, but <code class="hljs">seqRight</code> can be used with types like <code class="hljs">Validate</code> that are not monads.</p>
<p>Its cousin <code class="hljs">seqLeft</code> is very similar, except the leftmost expression's value is returned.
<code class="hljs">E1 &lt;* E2</code> desugars to <code class="hljs">SeqLeft.seqLeft E1 (fun () =&gt; E2)</code>.
<code class="hljs">SeqLeft.seqLeft</code> has type <code class="hljs">f Î± â (Unit â f Î²) â f Î±</code>, which is identical to that of <code class="hljs">seqRight</code> except for the fact that it returns <code class="hljs">f Î±</code>.
<code class="hljs">E1 &lt;* E2</code> can be understood as a program that first executes <code class="hljs">E1</code>, and then <code class="hljs">E2</code>, returning the original result for <code class="hljs">E1</code>.
If <code class="hljs">f</code> has a <code class="hljs">Monad</code> instance, then <code class="hljs">E1 &lt;* E2</code> is equivalent to <code class="hljs">do let x â E1; _ â E2; pure x</code>.
Generally speaking, <code class="hljs">seqLeft</code> is useful for specifying extra conditions on a value in a validation or parser-like workflow without changing the value itself.</p>
<p>The definition of <code class="hljs">Applicative</code> extends all these classes, along with <code class="hljs">Functor</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-params">(f : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">F</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">c</span><span class="hljs-title">t</span><span class="hljs-title">o</span><span class="hljs-title">r</span> <span class="hljs-title">f</span>, <span class="hljs-title">P</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">e</span> <span class="hljs-title">f</span>, <span class="hljs-title">S</span><span class="hljs-title">e</span><span class="hljs-title">q</span> <span class="hljs-title">f</span>, <span class="hljs-title">S</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">L</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-title">f</span>, <span class="hljs-title">S</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">R</span><span class="hljs-title">i</span><span class="hljs-title">g</span><span class="hljs-title">h</span><span class="hljs-title">t</span> <span class="hljs-title">f</span></span> <span class="hljs-keyword">where</span>
  map      := <span class="hljs-keyword">fun</span> x y =&gt; Seq.seq (pure x) <span class="hljs-keyword">fun</span> _ =&gt; y
  seqLeft  := <span class="hljs-keyword">fun</span> a b =&gt; Seq.seq (Functor.map (Function.const _) a) b
  seqRight := <span class="hljs-keyword">fun</span> a b =&gt; Seq.seq (Functor.map (Function.const _ id) a) b
</code></pre>
<p>A complete definition of <code class="hljs">Applicative</code> requires only definitions for <code class="hljs">pure</code> and <code class="hljs">seq</code>.
This is because there are default definitions for all of the methods from <code class="hljs">Functor</code>, <code class="hljs">SeqLeft</code>, and <code class="hljs">SeqRight</code>.
The <code class="hljs">mapConst</code> method of <code class="hljs">Functor</code> has its own default implementation in terms of <code class="hljs">Functor.map</code>.
These default implementations should only be overridden with new functions that are behaviorally equivalent, but more efficient.
The default implementations should be seen as specifications for correctness as well as automatically-created code.</p>
<p>The default implementation for <code class="hljs">seqLeft</code> is very compact.
Replacing some of the names with their syntactic sugar or their definitions can provide another view on it, so:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">fun</span> a b =&gt; Seq.seq (Functor.map (Function.const _) a) b
</code></pre>
<p>becomes</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">fun</span> a b =&gt; Seq.seq ((<span class="hljs-keyword">fun</span> x _ =&gt; x) &lt;$&gt; a) b
</code></pre>
<p>How should <code class="hljs">(fun x _ =&gt; x) &lt;$&gt; a</code> be understood?
Here, <code class="hljs">a</code> has type <code class="hljs">f Î±</code>, and <code class="hljs">f</code> is a functor.
If <code class="hljs">f</code> is <code class="hljs">List</code>, then <code class="hljs">(fun x _ =&gt; x) &lt;$&gt; [1, 2, 3]</code> evaluates to <code class="hljs">[fun _ =&gt; 1, fun _ =&gt; 2, fun _ =&gt; 3]</code>.
If <code class="hljs">f</code> is <code class="hljs">Option</code>, then <code class="hljs">(fun x _ =&gt; x) &lt;$&gt; some "hello"</code> evaluates to <code class="hljs">some (fun _ =&gt; "hello")</code>.
In each case, the values in the functor are replaced by functions that return the original value, ignoring their argument.
When combined with <code class="hljs">seq</code>, this function discards the values from <code class="hljs">seq</code>'s second argument.</p>
<p>The default implementation for <code class="hljs">seqRight</code> is very similar, except <code class="hljs">const</code> has an additional argument <code class="hljs">id</code>.
This definition can be understood similarly, by first introducing some standard syntactic sugar and then replacing some names with their definitions:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">fun</span> a b =&gt; Seq.seq (Functor.map (Function.const _ id) a) b
===&gt;
<span class="hljs-keyword">fun</span> a b =&gt; Seq.seq ((<span class="hljs-keyword">fun</span> _ =&gt; id) &lt;$&gt; a) b
===&gt;
<span class="hljs-keyword">fun</span> a b =&gt; Seq.seq ((<span class="hljs-keyword">fun</span> _ =&gt; <span class="hljs-keyword">fun</span> x =&gt; x) &lt;$&gt; a) b
===&gt;
<span class="hljs-keyword">fun</span> a b =&gt; Seq.seq ((<span class="hljs-keyword">fun</span> _ x =&gt; x) &lt;$&gt; a) b
</code></pre>
<p>How should <code class="hljs">(fun _ x =&gt; x) &lt;$&gt; a</code> be understood?
Once again, examples are useful.
<code class="hljs">(fun _ x =&gt; x) &lt;$&gt; [1, 2, 3]</code> is equivalent to <code class="hljs">[fun x =&gt; x, fun x =&gt; x, fun x =&gt; x]</code>, and <code class="hljs">(fun _ x =&gt; x) &lt;$&gt; some "hello"</code> is equivalent to <code class="hljs">some (fun x =&gt; x)</code>.
In other words, <code class="hljs">(fun _ x =&gt; x) &lt;$&gt; a</code> preserves the overall shape of <code class="hljs">a</code>, but each value is replaced by the identity function.
From the perspective of effects, the side effects of <code class="hljs">a</code> occur, but the values are thrown out when it is used with <code class="hljs">seq</code>.</p>
<h2 id="monad"><a class="header" href="#monad">Monad</a></h2>
<p>Just as the constituent operations of <code class="hljs">Applicative</code> are split into their own type classes, <code class="hljs">Bind</code> has its own class as well:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">(m : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v)</span></span> <span class="hljs-keyword">where</span>
  bind : {Î± Î² : <span class="hljs-built_in">Type</span> u} â m Î± â (Î± â m Î²) â m Î²
</code></pre>
<p><code class="hljs">Monad</code> extends <code class="hljs">Applicative</code> with <code class="hljs">Bind</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">M</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">a</span><span class="hljs-title">d</span> <span class="hljs-params">(m : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-title">m</span>, <span class="hljs-title">B</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> (max (u+<span class="hljs-number">1</span>) v) <span class="hljs-keyword">where</span>
  map      f x := bind x (Function.comp pure f)
  seq      f x := bind f <span class="hljs-keyword">fun</span> y =&gt; Functor.map y (x ())
  seqLeft  x y := bind x <span class="hljs-keyword">fun</span> a =&gt; bind (y ()) (<span class="hljs-keyword">fun</span> _ =&gt; pure a)
  seqRight x y := bind x <span class="hljs-keyword">fun</span> _ =&gt; y ()
</code></pre>
<p>Tracing the collection of inherited methods and default methods from the entire hierarchy shows that a <code class="hljs">Monad</code> instance requires only implementations of <code class="hljs">bind</code> and <code class="hljs">pure</code>.
In other words, <code class="hljs">Monad</code> instances automatically yield implementations of <code class="hljs">seq</code>, <code class="hljs">seqLeft</code>, <code class="hljs">seqRight</code>, <code class="hljs">map</code>, and <code class="hljs">mapConst</code>.
From the perspective of API boundaries, any type with a <code class="hljs">Monad</code> instance gets instances for <code class="hljs">Bind</code>, <code class="hljs">Pure</code>, <code class="hljs">Seq</code>, <code class="hljs">Functor</code>, <code class="hljs">SeqLeft</code>, and <code class="hljs">SeqRight</code>.</p>
<h2 id="exercises-13"><a class="header" href="#exercises-13">Exercises</a></h2>
<ol>
<li>Understand the default implementations of <code class="hljs">map</code>, <code class="hljs">seq</code>, <code class="hljs">seqLeft</code>, and <code class="hljs">seqRight</code> in <code class="hljs">Monad</code> by working through examples such as <code class="hljs">Option</code> and <code class="hljs">Except</code>. In other words, substitute their definitions for <code class="hljs">bind</code> and <code class="hljs">pure</code> into the default definitions, and simplify them to recover the versions <code class="hljs">map</code>, <code class="hljs">seq</code>, <code class="hljs">seqLeft</code>, and <code class="hljs">seqRight</code> that would be written by hand.</li>
<li>On paper or in a text file, prove to yourself that the default implementations of <code class="hljs">map</code> and <code class="hljs">seq</code> satisfy the contracts for <code class="hljs">Functor</code> and <code class="hljs">Applicative</code>. In this argument, you're allowed to use the rules from the <code class="hljs">Monad</code> contract as well as ordinary expression evaluation.</li>
</ol>
<div style="break-before:page;page-break-before:always"></div><h1 id="summary-4"><a class="header" href="#summary-4">Summary</a></h1>
<h2 id="type-classes-and-structures"><a class="header" href="#type-classes-and-structures">Type Classes and Structures</a></h2>
<p>Behind the scenes, type classes are represented by structures.
Defining a class defines a structure, and additionally creates an empty table of instances.
Defining an instance creates a value that either has the structure as its type or is a function that can return the structure, and additionally adds an entry to the table.
Instance search consists of constructing an instance by consulting the instance tables.
Both structures and classes may provide default values for fields (which are default implementations of methods).</p>
<h2 id="structures-and-inheritance-1"><a class="header" href="#structures-and-inheritance-1">Structures and Inheritance</a></h2>
<p>Structures may inherit from other structures.
Behind the scenes, a structure that inherits from another structure contains an instance of the original structure as a field.
In other words, inheritance is implemented with composition.
When multiple inheritance is used, only the unique fields from the additional parent structures are used to avoid a diamond problem, and the functions that would normally extract the parent value are instead organized to construct one.
Record dot notation takes structure inheritance into account.</p>
<p>Because type classes are just structures with some additional automation applied, all of these features are available in type classes.
Together with default methods, this can be used to create a fine-grained hierarchy of interfaces that nonetheless does not impose a large burden on clients, because the small classes that the large classes inherit from can be automatically implemented.</p>
<h2 id="applicative-functors-1"><a class="header" href="#applicative-functors-1">Applicative Functors</a></h2>
<p>An applicative functor is a functor with two additional operations:</p>
<ul>
<li><code class="hljs">pure</code>, which is the same operator as that for <code class="hljs">Monad</code></li>
<li><code class="hljs">seq</code>, which allows a function to be applied in the context of the functor.</li>
</ul>
<p>While monads can represent arbitrary programs with control flow, applicative functors can only run function arguments from left to right.
Because they are less powerful, they provide less control to programs written against the interface, while the implementor of the method has a greater degree of freedom.
Some useful types can implement <code class="hljs">Applicative</code> but not <code class="hljs">Monad</code>.</p>
<p>In fact, the type classes <code class="hljs">Functor</code>, <code class="hljs">Applicative</code>, and <code class="hljs">Monad</code> form a hierarchy of power.
Moving up the hierarchy, from <code class="hljs">Functor</code> towards <code class="hljs">Monad</code>, allows more powerful programs to be written, but fewer types implement the more powerful classes.
Polymorphic programs should be written to use as weak of an abstraction as possible, while datatypes should be given instances that are as powerful as possible.
This maximizes code re-use.
The more powerful type classes extend the less powerful ones, which means that an implementation of <code class="hljs">Monad</code> provides implementations of <code class="hljs">Functor</code> and <code class="hljs">Applicative</code> for free.</p>
<p>Each class has a set of methods to be implemented and a corresponding contract that specifies additional rules for the methods.
Programs that are written against these interfaces expect that the additional rules are followed, and may be buggy if they are not.
The default implementations of <code class="hljs">Functor</code>'s methods in terms of <code class="hljs">Applicative</code>'s, and of <code class="hljs">Applicative</code>'s in terms of <code class="hljs">Monad</code>'s, will obey these rules.</p>
<h2 id="universes-1"><a class="header" href="#universes-1">Universes</a></h2>
<p>To allow Lean to be used as both a programming language and a theorem prover, some restrictions on the language are necessary.
This includes restrictions on recursive functions that ensure that they all either terminate or are marked as <code class="hljs">partial</code> and written to return types that are not uninhabited.
Additionally, it must be impossible to represent certain kinds of logical paradoxes as types.</p>
<p>One of the restrictions that rules out certain paradoxes is that every type is assigned to a <em>universe</em>.
Universes are types such as <code class="hljs">Prop</code>, <code class="hljs">Type</code>, <code class="hljs">Type 1</code>, <code class="hljs">Type 2</code>, and so forth.
These types describe other typesâjust as <code class="hljs">0</code> and <code class="hljs">17</code> are described by <code class="hljs">Nat</code>, <code class="hljs">Nat</code> is itself described by <code class="hljs">Type</code>, and <code class="hljs">Type</code> is described by <code class="hljs">Type 1</code>.
The type of functions that take a type as an argument must be a larger universe than the argument's universe.</p>
<p>Because each declared datatype has a universe, writing code that uses types like data would quickly become annoying, requiring each polymorphic type to be copy-pasted to take arguments from <code class="hljs">Type 1</code>.
A feature called <em>universe polymorphism</em> allows Lean programs and datatypes to take universe levels as arguments, just as ordinary polymorphism allows programs to take types as arguments.
Generally speaking, Lean libraries should use universe polymorphism when implementing libraries of polymorphic operations.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="monad-transformers"><a class="header" href="#monad-transformers">Monad Transformers</a></h1>
<p>A monad is a way to encode some collection of side effects in a pure language.
Different monads provide different effects, such as state and error handling.
Many monads even provide useful effects that aren't available in most languages, such as nondeterministic searches, readers, and even continuations.</p>
<p>A typical application has a core set of easily testable functions written without monads paired with an outer wrapper that uses a monad to encode the necessary application logic.
These monads are constructed from well-known components.
For example:</p>
<ul>
<li>Mutable state is encoded with a function parameter and a return value that have the same type</li>
<li>Error handling is encoded by having a return type that is similar to <code class="hljs">Except</code>, with constructors for success and failure</li>
<li>Logging is encoded by pairing the return value with the log</li>
</ul>
<p>Writing each monad by hand is tedious, however, involving boilerplate definitions of the various type classes.
Each of these components can also be extracted to a definition that modifies some other monad to add an additional effect.
Such a definition is called a <em>monad transformer</em>.
A concrete monad can be build from a collection of monad transformers, which enables much more code re-use.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="combining-io-and-reader"><a class="header" href="#combining-io-and-reader">Combining IO and Reader</a></h1>
<p>One case where a reader monad can be useful is when there is some notion of the "current configuration" of the application that is passed through many recursive calls.
An example of such a program is <code class="hljs">tree</code>, which recursively prints the files in the current directory and its subdirectories, indicating their tree structure using characters.
The version of <code class="hljs">tree</code> in this chapter, called <code class="hljs">doug</code> after the mighty Douglas Fir tree that adorns the west coast of North America, provides the option of Unicode box-drawing characters or their ASCII equivalents when indicating directory structure.</p>
<p>For example, the following commands create a directory structure and some empty files in a directory called <code class="hljs">doug-demo</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">$ cd doug-demo
$ mkdir -p a/b/c
$ mkdir -p a/d
$ mkdir -p a/e/f
$ touch a/b/hello
$ touch a/d/another-file
$ touch a/e/still-another-file-again
</code></pre>
<p>Running <code class="hljs">doug</code> results in the following:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">$ doug
âââ doug-demo/
â   âââ a/
â   â   âââ b/
â   â   â   âââ hello
â   â   â   âââ c/
â   â   âââ d/
â   â   â   âââ another-file
â   â   âââ e/
â   â   â   âââ f/
â   â   â   âââ still-another-file-again
</code></pre>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>Internally, <code class="hljs">doug</code> passes a configuration value downwards as it recursively traverses the directory structure.
This configuration contains two fields: <code class="hljs">useASCII</code> determines whether to use Unicode box-drawing characters or ASCII vertical line and dash characters to indicate structure, and <code class="hljs">currentPrefix</code> contains a string to prepend to each line of output.
As the current directory deepens, the prefix string accumulates indicators of being in a directory.
The configuration is a structure:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">C</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">g</span></span> <span class="hljs-keyword">where</span>
  useASCII : Bool := false
  currentPrefix : String := <span class="hljs-string">""</span>
</code></pre>
<p>This structure has default definitions for both fields.
The default <code class="hljs">Config</code> uses Unicode display with no prefix.</p>
<p>Users who invoke <code class="hljs">doug</code> will need to be able to provide command-line arguments.
The usage information is as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">a</span><span class="hljs-title">g</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> String :=
  <span class="hljs-string">"Usage: doug [--ascii]
Options:
\t--ascii\tUse ASCII characters to display the directory structure"</span>
</code></pre>
<p>Accordingly, a configuration can be constructed by examining a list of command-line arguments:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">g</span><span class="hljs-title">F</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">A</span><span class="hljs-title">r</span><span class="hljs-title">g</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> List String â Option Config
  | [] =&gt; some {} <span class="hljs-comment">-- both fields default</span>
  | [<span class="hljs-string">"--ascii"</span>] =&gt; some {useASCII := true}
  | _ =&gt; none
</code></pre>
<p>The <code class="hljs">main</code> function is a wrapper around an inner worker, called <code class="hljs">dirTree</code>, that shows the contents of a directory using a configuration.
Before calling <code class="hljs">dirTree</code>, <code class="hljs">main</code> is responsible for processing command-line arguments.
It must also return the appropriate exit code to the operating system:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">n</span> <span class="hljs-params">(args : List String)</span> <span class="hljs-symbol">:</span></span> IO UInt32 := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">match</span> configFromArgs args <span class="hljs-keyword">with</span>
  | some config =&gt;
    dirTree config (â IO.currentDir)
    pure <span class="hljs-number">0</span>
  | none =&gt;
    IO.eprintln s!<span class="hljs-string">"Didn't understand argument(s) {"</span> <span class="hljs-string">".separate args}\n"</span>
    IO.eprintln usage
    pure <span class="hljs-number">1</span>
</code></pre>
<p>Not all paths should be shown in the directory tree.
In particular, files named <code class="hljs">.</code> or <code class="hljs">..</code> should be skipped, as they are actually features used for navigation rather than files <em>per se</em>.
Of those files that should be shown, there are two kinds: ordinary files and directories:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Entry <span class="hljs-keyword">where</span>
  | file : String â Entry
  | dir : String â Entry
</code></pre>
<p>To determine whether a file should be shown, along with which kind of entry it is, <code class="hljs">doug</code> uses <code class="hljs">toEntry</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">o</span><span class="hljs-title">E</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">y</span> <span class="hljs-params">(path : System.FilePath)</span> <span class="hljs-symbol">:</span></span> IO (Option Entry) := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">match</span> path.components.getLast? <span class="hljs-keyword">with</span>
  | none =&gt; pure (some (.dir <span class="hljs-string">""</span>))
  | some <span class="hljs-string">"."</span> | some <span class="hljs-string">".."</span> =&gt; pure none
  | some name =&gt;
    pure (some (<span class="hljs-keyword">if</span> (â path.isDir) <span class="hljs-keyword">then</span> .dir name <span class="hljs-keyword">else</span> .file name))
</code></pre>
<p><code class="hljs">System.FilePath.components</code> converts a path into a list of path components, splitting the name at directory separators.
If there is no last component, then the path is the root directory.
If the last component is a special navigation file (<code class="hljs">.</code> or <code class="hljs">..</code>), then the file should be excluded.
Otherwise, directories and files are wrapped in the corresponding constructors.</p>
<p>Lean's logic has no way to know that directory trees are finite.
Indeed, some systems allow the construction of circular directory structures.
Thus, <code class="hljs">dirTree</code> is declared <code class="hljs">partial</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">partial</span> <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span> <span class="hljs-params">(cfg : Config)</span> <span class="hljs-params">(path : System.FilePath)</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">match</span> â toEntry path <span class="hljs-keyword">with</span>
  | none =&gt; pure ()
  | some (.file name) =&gt; showFileName cfg name
  | some (.dir name) =&gt;
    showDirName cfg name
    <span class="hljs-keyword">let</span> contents â path.readDir
    <span class="hljs-keyword">let</span> newConfig := cfg.inDirectory
    doList contents.toList <span class="hljs-keyword">fun</span> d =&gt;
      dirTree newConfig d.path
</code></pre>
<p>The call to <code class="hljs">toEntry</code> is a <a href="https://leanprover.github.io/functional_programming_in_lean/hello-world/conveniences.html#nested-actions">nested action</a>âthe parentheses are optional in positions where the arrow couldn't have any other meaning, such as <code class="hljs">match</code>.
When the filename doesn't correspond to an entry in the tree (e.g. because it is <code class="hljs">..</code>), <code class="hljs">dirTree</code> does nothing.
When the filename points to an ordinary file, <code class="hljs">dirTree</code> calls a helper to show it with the current configuration.
When the filename points to a directory, it is shown with a helper, and then its contents are recursively shown in a new configuration in which the prefix has been extended to account for being in a new directory.</p>
<p>Showing the names of files and directories is achieved with <code class="hljs">showFileName</code> and <code class="hljs">showDirName</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">ow</span><span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">m</span><span class="hljs-title">e</span> <span class="hljs-params">(cfg : Config)</span> <span class="hljs-params">(file : String)</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  IO.println (cfg.fileName file)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">ow</span><span class="hljs-title">D</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">m</span><span class="hljs-title">e</span> <span class="hljs-params">(cfg : Config)</span> <span class="hljs-params">(dir : String)</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  IO.println (cfg.dirName dir)
</code></pre>
<p>Both of these helpers delegate to functions on <code class="hljs">Config</code> that take the ASCII vs Unicode setting into account:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">C</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">g</span>.<span class="hljs-title">p</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(cfg : Config)</span> <span class="hljs-symbol">:</span></span>=
  <span class="hljs-keyword">if</span> cfg.useASCII <span class="hljs-keyword">then</span> <span class="hljs-string">"|--"</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"âââ"</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">C</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">g</span>.<span class="hljs-title">p</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">D</span><span class="hljs-title">i</span><span class="hljs-title">r</span> <span class="hljs-params">(cfg : Config)</span> <span class="hljs-symbol">:</span></span>=
  <span class="hljs-keyword">if</span> cfg.useASCII <span class="hljs-keyword">then</span> <span class="hljs-string">"|  "</span> <span class="hljs-keyword">else</span> <span class="hljs-string">"â  "</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">C</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">g</span>.<span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">m</span><span class="hljs-title">e</span> <span class="hljs-params">(cfg : Config)</span> <span class="hljs-params">(file : String)</span> <span class="hljs-symbol">:</span></span> String :=
  s!<span class="hljs-string">"{cfg.currentPrefix}{cfg.preFile} {file}"</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">C</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">g</span>.<span class="hljs-title">d</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">m</span><span class="hljs-title">e</span> <span class="hljs-params">(cfg : Config)</span> <span class="hljs-params">(dir : String)</span> <span class="hljs-symbol">:</span></span> String :=
  s!<span class="hljs-string">"{cfg.currentPrefix}{cfg.preFile} {dir}/"</span>
</code></pre>
<p>Similarly, <code class="hljs">Config.inDirectory</code> extends the prefix with a directory marker:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">C</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">g</span>.<span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">D</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">t</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">y</span> <span class="hljs-params">(cfg : Config)</span> <span class="hljs-symbol">:</span></span> Config :=
  {cfg <span class="hljs-keyword">with</span> currentPrefix := cfg.preDir ++ <span class="hljs-string">" "</span> ++ cfg.currentPrefix}
</code></pre>
<p>Iterating an IO action over a list of directory contents is achieved using <code class="hljs">doList</code>.
Because <code class="hljs">doList</code> carries out all the actions in a list and does not base control-flow decisions on the values returned by any of the actions, the full power of <code class="hljs">Monad</code> is not necessary, and it will work for any <code class="hljs">Applicative</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">o</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">[Applicative f]</span> <span class="hljs-symbol">:</span></span> List Î± â (Î± â f Unit) â f Unit
  | [], _ =&gt; pure ()
  | x :: xs, action =&gt;
    action x *&gt;
    doList xs action
</code></pre>
<h2 id="using-a-custom-monad"><a class="header" href="#using-a-custom-monad">Using a Custom Monad</a></h2>
<p>While this implementation of <code class="hljs">doug</code> works, manually passing the configuration around is verbose and error-prone.
The type system will not catch it if the wrong configuration is passed downwards, for instance.
A reader effect ensures that the same configuration is passed to all recursive calls, unless it is manually overridden, and it helps make the code less verbose.</p>
<p>To create a version of <code class="hljs">IO</code> that is also a reader of <code class="hljs">Config</code>, first define the type and its <code class="hljs">Monad</code> instance, following the recipe from <a href="https://leanprover.github.io/functional_programming_in_lean/monads/arithmetic.html#custom-environments">the evaluator example</a>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">C</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">g</span><span class="hljs-title">I</span><span class="hljs-title">O</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> :=
  Config â IO Î±

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> Monad ConfigIO <span class="hljs-keyword">where</span>
  pure x := <span class="hljs-keyword">fun</span> _ =&gt; pure x
  bind result next := <span class="hljs-keyword">fun</span> cfg =&gt; <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">let</span> v â result cfg
    next v cfg
</code></pre>
<p>The difference between this <code class="hljs">Monad</code> instance and the one for <code class="hljs">Reader</code> is that this one uses <code class="hljs">do</code>-notation in the <code class="hljs">IO</code> monad as the body of the function that <code class="hljs">bind</code> returns, rather than applying <code class="hljs">next</code> directly to the value returned from <code class="hljs">result</code>.
Any <code class="hljs">IO</code> effects performed by <code class="hljs">result</code> must occur before <code class="hljs">next</code> is invoked, which is ensured by the <code class="hljs">IO</code> monad's <code class="hljs">bind</code> operator.
<code class="hljs">ConfigIO</code> is not universe polymorphic because the underlying <code class="hljs">IO</code> type is also not universe polymorphic.</p>
<p>Running a <code class="hljs">ConfigIO</code> action involves transforming it into an <code class="hljs">IO</code> action by providing it with a configuration:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">C</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">g</span><span class="hljs-title">I</span><span class="hljs-title">O</span>.<span class="hljs-title">r</span><span class="hljs-title">u</span><span class="hljs-title">n</span> <span class="hljs-params">(action : ConfigIO Î±)</span> <span class="hljs-params">(cfg : Config)</span> <span class="hljs-symbol">:</span></span> IO Î± :=
  action cfg
</code></pre>
<p>This function is not really necessary, as a caller could simply provide the configuration directly.
However, naming the operation can make it easier to see which parts of the code are intended to run in which monad.</p>
<p>The next step is to define a means of accessing the current configuration as part of <code class="hljs">ConfigIO</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">C</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">g</span> <span class="hljs-symbol">:</span></span> ConfigIO Config :=
  <span class="hljs-keyword">fun</span> cfg =&gt; pure cfg
</code></pre>
<p>This is just like <code class="hljs">read</code> from <a href="https://leanprover.github.io/functional_programming_in_lean/monads/arithmetic.html#custom-environments">the evaluator example</a>, except it uses <code class="hljs">IO</code>'s <code class="hljs">pure</code> to return its value rather than doing so directly.
Because entering a directory modifies the current configuration for the scope of a recursive call, it will be necessary to have a way to override a configuration:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">l</span><span class="hljs-title">o</span><span class="hljs-title">c</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">l</span><span class="hljs-title">y</span> <span class="hljs-params">(change : Config â Config)</span> <span class="hljs-params">(action : ConfigIO Î±)</span> <span class="hljs-symbol">:</span></span> ConfigIO Î± :=
  <span class="hljs-keyword">fun</span> cfg =&gt; action (change cfg)
</code></pre>
<p>Much of the code used in <code class="hljs">doug</code> has no need for configurations, and <code class="hljs">doug</code> calls ordinary Lean <code class="hljs">IO</code> actions from the standard library that certainly don't need a <code class="hljs">Config</code>.
Ordinary <code class="hljs">IO</code> actions can be run using <code class="hljs">runIO</code>, which ignores the configuration argument:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">r</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">I</span><span class="hljs-title">O</span> <span class="hljs-params">(action : IO Î±)</span> <span class="hljs-symbol">:</span></span> ConfigIO Î± :=
  <span class="hljs-keyword">fun</span> _ =&gt; action
</code></pre>
<p>With these components, <code class="hljs">showFileName</code> and <code class="hljs">showDirName</code> can be updated to take their configuration arguments implicitly through the <code class="hljs">ConfigIO</code> monad.
They use <a href="https://leanprover.github.io/functional_programming_in_lean/hello-world/conveniences.html#nested-actions">nested actions</a> to retrieve the configuration, and <code class="hljs">runIO</code> to actually execute the call to <code class="hljs">IO.println</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">ow</span><span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">m</span><span class="hljs-title">e</span> <span class="hljs-params">(file : String)</span> <span class="hljs-symbol">:</span></span> ConfigIO Unit := <span class="hljs-keyword">do</span>
  runIO (IO.println ((â currentConfig).fileName file))

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">ow</span><span class="hljs-title">D</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">m</span><span class="hljs-title">e</span> <span class="hljs-params">(dir : String)</span> <span class="hljs-symbol">:</span></span> ConfigIO Unit := <span class="hljs-keyword">do</span>
  runIO (IO.println ((â currentConfig).dirName dir))
</code></pre>
<p>In the new version of <code class="hljs">dirTree</code>, the calls to <code class="hljs">toEntry</code> and <code class="hljs">System.FilePath.readDir</code> are wrapped in <code class="hljs">runIO</code>.
Additionally, instead of building a new configuration and then requiring the programmer to keep track of which one to pass to recursive calls, it uses <code class="hljs">locally</code> to naturally delimit the modified configuration to only a small region of the program, in which it is the <em>only</em> valid configuration:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">partial</span> <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span> <span class="hljs-params">(path : System.FilePath)</span> <span class="hljs-symbol">:</span></span> ConfigIO Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">match</span> â runIO (toEntry path) <span class="hljs-keyword">with</span>
    | none =&gt; pure ()
    | some (.file name) =&gt; showFileName name
    | some (.dir name) =&gt;
      showDirName name
      <span class="hljs-keyword">let</span> contents â runIO path.readDir
      locally (Â·.inDirectory)
        (doList contents.toList <span class="hljs-keyword">fun</span> d =&gt;
          dirTree d.path)
</code></pre>
<p>The new version of <code class="hljs">main</code> uses <code class="hljs">ConfigIO.run</code> to invoke <code class="hljs">dirTree</code> with the initial configuration:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">n</span> <span class="hljs-params">(args : List String)</span> <span class="hljs-symbol">:</span></span> IO UInt32 := <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">match</span> configFromArgs args <span class="hljs-keyword">with</span>
    | some config =&gt;
      (dirTree (â IO.currentDir)).run config
      pure <span class="hljs-number">0</span>
    | none =&gt;
      IO.eprintln s!<span class="hljs-string">"Didn't understand argument(s) {"</span> <span class="hljs-string">".separate args}\n"</span>
      IO.eprintln usage
      pure <span class="hljs-number">1</span>
</code></pre>
<p>This custom monad has a number of advantages over passing configurations manually:</p>
<ol>
<li>It is easier to ensure that configurations are passed down unchanged, except when changes are desired</li>
<li>The concern of passing the configuration onwards is more clearly separated from the concern of printing directory contents</li>
<li>As the program grows, there will be more and more intermediate layers that do nothing with configurations except propagate them, and these layers don't need to be rewritten as the configuration logic changes</li>
</ol>
<p>However, there are also some clear downsides:</p>
<ol>
<li>As the program evolves and the monad requires more features, each of the basic operators such as <code class="hljs">locally</code> and <code class="hljs">currentConfig</code> will need to be updated</li>
<li>Wrapping ordinary <code class="hljs">IO</code> actions in <code class="hljs">runIO</code> is noisy and distracts from the flow of the program</li>
<li>Writing monads instances by hand is repetitive, and the technique for adding a reader effect to another monad is a design pattern that requires documentation and communication overhead</li>
</ol>
<p>Using a technique called <em>monad transformers</em>, all of these downsides can be addressed.
A monad transformer takes a monad as an argument and returns a new monad.
Monad transformers consist of:</p>
<ol>
<li>A definition of the transformer itself, which is typically a function from types to types</li>
<li>A <code class="hljs">Monad</code> instance that assumes the inner type is already a monad</li>
<li>An operator to "lift" an action from the inner monad to the transformed monad, akin to <code class="hljs">runIO</code></li>
</ol>
<h2 id="adding-a-reader-to-any-monad"><a class="header" href="#adding-a-reader-to-any-monad">Adding a Reader to Any Monad</a></h2>
<p>Adding a reader effect to <code class="hljs">IO</code> was accomplished in <code class="hljs">ConfigIO</code> by wrapping <code class="hljs">IO Î±</code> in a function type.
The Lean standard library contains a function that can do this to <em>any</em> polymorphic type, called <code class="hljs">ReaderT</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">R</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">T</span> <span class="hljs-params">(Ï : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(m : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> (max u v) :=
  Ï â m Î±
</code></pre>
<p>Its arguments are as follows:</p>
<ul>
<li><code class="hljs">Ï</code> is the environment that is accessible to the reader</li>
<li><code class="hljs">m</code> is the monad that is being transformed, such as <code class="hljs">IO</code></li>
<li><code class="hljs">Î±</code> is the type of values being returned by the monadic computation
Both <code class="hljs">Î±</code> and <code class="hljs">Ï</code> are in the same universe because the operator that retrieves the environment in the monad will have type <code class="hljs">m Ï</code>.</li>
</ul>
<p>With <code class="hljs">ReaderT</code>, <code class="hljs">ConfigIO</code> becomes:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">abbrev</span> ConfigIO (Î± : <span class="hljs-built_in">Type</span>) : <span class="hljs-built_in">Type</span> := ReaderT Config IO Î±
</code></pre>
<p>It is an <code class="hljs">abbrev</code> because <code class="hljs">ReaderT</code> has many useful features defined in the standard library that a non-reducible definition would hide.
Rather than taking responsibility for making these work directly for <code class="hljs">ConfigIO</code>, it's easier to simply have <code class="hljs">ConfigIO</code> behave identically to <code class="hljs">ReaderT Config IO</code>.</p>
<p>The manually-written <code class="hljs">currentConfig</code> obtained the environment out of the reader.
This effect can be defined in a generic form for all uses of <code class="hljs">ReaderT</code>, under the name <code class="hljs">read</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">d</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-symbol">:</span></span> ReaderT Ï m Ï :=
   <span class="hljs-keyword">fun</span> env =&gt; pure env
</code></pre>
<p>However, not every monad that provides a reader effect is built with <code class="hljs">ReaderT</code>.
The type class <code class="hljs">MonadReader</code> allows any monad to provide a <code class="hljs">read</code> operator:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">M</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">R</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(Ï : outParam (<span class="hljs-built_in">Type</span> u)</span>) <span class="hljs-params">(m : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> (max (u + <span class="hljs-number">1</span>) v) <span class="hljs-keyword">where</span>
  read : m Ï

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-symbol">:</span></span> MonadReader Ï (ReaderT Ï m) <span class="hljs-keyword">where</span>
  read := <span class="hljs-keyword">fun</span> env =&gt; pure env

<span class="hljs-keyword">export</span> MonadReader (read)
</code></pre>
<p>The type <code class="hljs">Ï</code> is an output parameter because any given monad typically only provides a single type of environment through a reader, so automatically selecting it when the monad is known makes programs more convenient to write.</p>
<p>The <code class="hljs">Monad</code> instance for <code class="hljs">ReaderT</code> is essentially the same as the <code class="hljs">Monad</code> instance for <code class="hljs">ConfigIO</code>, except <code class="hljs">IO</code> has been replaced by some arbitrary monad argument <code class="hljs">m</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-symbol">:</span></span> Monad (ReaderT Ï m) <span class="hljs-keyword">where</span>
  pure x := <span class="hljs-keyword">fun</span> _ =&gt; pure x
  bind result next := <span class="hljs-keyword">fun</span> env =&gt; <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">let</span> v â result env
    next v env
</code></pre>
<p>The next step is to eliminate uses of <code class="hljs">runIO</code>.
When Lean encounters a mismatch in monad types, it automatically attempts to use a type class called <code class="hljs">MonadLift</code> to transform the actual monad into the expected monad.
This process is similar to the use of coercions.
<code class="hljs">MonadLift</code> is defined as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">M</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-params">(m : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-params">(n : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> w)</span></span> <span class="hljs-keyword">where</span>
  monadLift : {Î± : <span class="hljs-built_in">Type</span> u} â m Î± â n Î±
</code></pre>
<p>The method <code class="hljs">monadLift</code> translates from the monad <code class="hljs">m</code> to the monad <code class="hljs">n</code>.
The process is called "lifting" because it takes an action in the embedded monad and makes it into an action in the surrounding monad.
In this case, it will be used to "lift" from <code class="hljs">IO</code> to <code class="hljs">ReaderT Config IO</code>, though the instance works for <em>any</em> inner monad <code class="hljs">m</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> MonadLift m (ReaderT Ï m) <span class="hljs-keyword">where</span>
  monadLift action := <span class="hljs-keyword">fun</span> _ =&gt; action
</code></pre>
<p>The implementation of <code class="hljs">monadLift</code> is very similar to that of <code class="hljs">runIO</code>.
Indeed, it is enough to define <code class="hljs">showFileName</code> and <code class="hljs">showDirName</code> without using <code class="hljs">runIO</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">ow</span><span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">m</span><span class="hljs-title">e</span> <span class="hljs-params">(file : String)</span> <span class="hljs-symbol">:</span></span> ConfigIO Unit := <span class="hljs-keyword">do</span>
  IO.println s!<span class="hljs-string">"{(â read).currentPrefix} {file}"</span>

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">ow</span><span class="hljs-title">D</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">m</span><span class="hljs-title">e</span> <span class="hljs-params">(dir : String)</span> <span class="hljs-symbol">:</span></span> ConfigIO Unit := <span class="hljs-keyword">do</span>
  IO.println s!<span class="hljs-string">"{(â read).currentPrefix} {dir}/"</span>
</code></pre>
<p>One final operation from the original <code class="hljs">ConfigIO</code> remains to be translated to a use of <code class="hljs">ReaderT</code>: <code class="hljs">locally</code>.
The definition can be translated directly to <code class="hljs">ReaderT</code>, but the Lean standard library provides a more general version.
The standard version is called <code class="hljs">withReader</code>, and it is part of a type class called <code class="hljs">MonadWithReader</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">M</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">W</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">R</span><span class="hljs-title">e</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(Ï : outParam (<span class="hljs-built_in">Type</span> u)</span>) <span class="hljs-params">(m : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v)</span></span> <span class="hljs-keyword">where</span>
  withReader {Î± : <span class="hljs-built_in">Type</span> u} : (Ï â Ï) â m Î± â m Î±
</code></pre>
<p>Just as in <code class="hljs">MonadReader</code>, the environment <code class="hljs">Ï</code> is an <code class="hljs">outParam</code>.
The <code class="hljs">withReader</code> operation is exported, so that it doesn't need to be written with the type class name before it:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">export</span> MonadWithReader (withReader)
</code></pre>
<p>The instance for <code class="hljs">ReaderT</code> is essentially the same as the definition of <code class="hljs">locally</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> MonadWithReader Ï (ReaderT Ï m) <span class="hljs-keyword">where</span>
  withReader change action :=
    <span class="hljs-keyword">fun</span> cfg =&gt; action (change cfg)
</code></pre>
<p>With these definitions in place, the new version of <code class="hljs">dirTree</code> can be written:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">partial</span> <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span> <span class="hljs-params">(path : System.FilePath)</span> <span class="hljs-symbol">:</span></span> ConfigIO Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">match</span> â toEntry path <span class="hljs-keyword">with</span>
    | none =&gt; pure ()
    | some (.file name) =&gt; showFileName name
    | some (.dir name) =&gt;
      showDirName name
      <span class="hljs-keyword">let</span> contents â path.readDir
      withReader (Â·.inDirectory)
        (doList contents.toList <span class="hljs-keyword">fun</span> d =&gt;
          dirTree d.path)
</code></pre>
<p>Aside from replacing <code class="hljs">locally</code> with <code class="hljs">withReader</code>, it is the same as before.</p>
<p>Replacing the custom <code class="hljs">ConfigIO</code> type with <code class="hljs">ReaderT</code> did not save a large number of lines of code in this section.
However, rewriting the code using components from the standard library does have long-term benefits.
First, readers who know about <code class="hljs">ReaderT</code> don't need to take time to understand the <code class="hljs">Monad</code> instance for <code class="hljs">ConfigIO</code>, working backwards to the meaning of monad itself.
Instead, they can be confident in their initial understanding.
Next, adding further effects to the monad (such as a state effect to count the files in each directory and display a count at the end) requires far fewer changes to the code, because the monad transformers and <code class="hljs">MonadLift</code> instances provided in the library work well together.
Finally, using a set of type classes included in the standard library, polymorphic code can be written in such a way that it can work with a variety of monads without having to care about details like the order in which the monad transformers were applied.
Just as some functions work in any monad, others can work in any monad that provides a certain type of state, or a certain type of exceptions, without having to specifically describe the <em>way</em> in which a particular concrete monad provides the state or exceptions.</p>
<h2 id="exercises-14"><a class="header" href="#exercises-14">Exercises</a></h2>
<h3 id="controlling-the-display-of-dotfiles"><a class="header" href="#controlling-the-display-of-dotfiles">Controlling the Display of Dotfiles</a></h3>
<p>Files whose names begin with a dot character (<code class="hljs">'.'</code>) typically represent files that should usually be hidden, such as source-control metadata and configuration files.
Modify <code class="hljs">doug</code> with an option to show or hide filenames that begin with a dot.
This option should be controlled with a <code class="hljs">-a</code> command-line option.</p>
<h3 id="starting-directory-as-argument"><a class="header" href="#starting-directory-as-argument">Starting Directory as Argument</a></h3>
<p>Modify <code class="hljs">doug</code> so that it takes a starting directory as an additional command-line argument.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="a-monad-construction-kit"><a class="header" href="#a-monad-construction-kit">A Monad Construction Kit</a></h1>
<p><code class="hljs">ReaderT</code> is far from the only useful monad transformer.
This section describes a number of additional transformers.
Each monad transformer consists of the following:</p>
<ol>
<li>A definition or datatype <code class="hljs">T</code> that takes a monad as an argument.
It should have a type like <code class="hljs">(Type u â Type v) â Type u â Type v</code>, though it may accept additional arguments prior to the monad.</li>
<li>A <code class="hljs">Monad</code> instance for <code class="hljs">T m</code> that relies on an instance of <code class="hljs">Monad m</code>. This enables the transformed monad to be used as a monad.</li>
<li>A <code class="hljs">MonadLift</code> instance that translates actions of type <code class="hljs">m Î±</code> into actions of type <code class="hljs">T m Î±</code>, for arbitrary monads <code class="hljs">m</code>. This enables actions from the underlying monad to be used in the transformed monad.</li>
</ol>
<p>Furthermore, the <code class="hljs">Monad</code> instance for the transformer should obey the contract for <code class="hljs">Monad</code>, at least if the underlying <code class="hljs">Monad</code> instance does.
In addition, <code class="hljs">monadLift (pure x)</code> should be equivalent to <code class="hljs">pure x</code> in the transformed monad, and <code class="hljs">monadLift</code> should distribute over <code class="hljs">bind</code> so that <code class="hljs">monadLift (x &gt;&gt;= f)</code> is the same as <code class="hljs">monadLift x &gt;&gt;= fun y =&gt; monadLift (f y)</code>.</p>
<p>Many monad transformers additionally define type classes in the style of <code class="hljs">MonadReader</code> that describe the actual effects available in the monad.
This can provide more flexibility: it allows programs to be written that rely only on an interface, and don't constrain the underlying monad to be implemented by a given transformer.
The type classes are a way for programs to express their requirements, and monad transformers are a convenient way to meet these requirements.</p>
<h2 id="failure-with-optiont"><a class="header" href="#failure-with-optiont">Failure with <code>OptionT</code></a></h2>
<p>Failure, represented by the <code class="hljs">Option</code> monad, and exceptions, represented by the <code class="hljs">Except</code> monad, both have corresponding transformers.
In the case of <code class="hljs">Option</code>, failure can be added to a monad by having it contain values of type <code class="hljs">Option Î±</code> where it would otherwise contain values of type <code class="hljs">Î±</code>.
For example, <code class="hljs">IO (Option Î±)</code> represents <code class="hljs">IO</code> actions that don't always return a value of type <code class="hljs">Î±</code>.
This suggests the definition of the monad transformer <code class="hljs">OptionT</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">O</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">T</span> <span class="hljs-params">(m : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> v :=
  m (Option Î±)
</code></pre>
<p>As an example of <code class="hljs">OptionT</code> in action, consider a program that asks the user questions.
The function <code class="hljs">getSomeInput</code> asks for a line of input and removes whitespace from both ends.
If the resulting trimmed input is non-empty, then it is returned, but the function fails if there are no non-whitespace characters:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">S</span><span class="hljs-title">o</span><span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">I</span><span class="hljs-title">n</span><span class="hljs-title">p</span><span class="hljs-title">u</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> OptionT IO String := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> input â (â IO.getStdin).getLine
  <span class="hljs-keyword">let</span> trimmed := input.trim
  <span class="hljs-keyword">if</span> trimmed == <span class="hljs-string">""</span> <span class="hljs-keyword">then</span>
    failure
  <span class="hljs-keyword">else</span> pure trimmed
</code></pre>
<p>This particular application tracks users with their name and their favorite species of beetle:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">U</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">I</span><span class="hljs-title">n</span><span class="hljs-title">f</span><span class="hljs-title">o</span></span> <span class="hljs-keyword">where</span>
  name : String
  favoriteBeetle : String
</code></pre>
<p>Asking the user for input is no more verbose than a function that uses only <code class="hljs">IO</code> would be:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">U</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">I</span><span class="hljs-title">n</span><span class="hljs-title">f</span><span class="hljs-title">o</span> <span class="hljs-symbol">:</span></span> OptionT IO UserInfo := <span class="hljs-keyword">do</span>
  IO.println <span class="hljs-string">"What is your name?"</span>
  <span class="hljs-keyword">let</span> name â getSomeInput
  IO.println <span class="hljs-string">"What is your favorite species of beetle?"</span>
  <span class="hljs-keyword">let</span> beetle â getSomeInput
  pure â¨name, beetleâ©
</code></pre>
<p>However, because the function runs in an <code class="hljs">OptionT IO</code> context rather than just in <code class="hljs">IO</code>, failure in the first call to <code class="hljs">getSomeInput</code> causes the whole <code class="hljs">getUserInfo</code> to fail, with control never reaching the question about beetles.
The main function, <code class="hljs">interact</code>, invokes <code class="hljs">getUserInfo</code> in a purely <code class="hljs">IO</code> context, which allows it to check whether the call succeeded or failed by matching on the inner <code class="hljs">Option</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">a</span><span class="hljs-title">c</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">match</span> â getUserInfo <span class="hljs-keyword">with</span>
  | none =&gt; IO.eprintln <span class="hljs-string">"Missing info"</span>
  | some â¨name, beetleâ© =&gt; IO.println s!<span class="hljs-string">"Hello {name}, whose favorite beetle is {beetle}."</span>
</code></pre>
<h3 id="the-monad-instance"><a class="header" href="#the-monad-instance">The Monad Instance</a></h3>
<p>Writing the monad instance reveals a difficulty.
Based on the types, <code class="hljs">pure</code> should use <code class="hljs">pure</code> from the underlying monad <code class="hljs">m</code> together with <code class="hljs">some</code>.
Just as <code class="hljs">bind</code> for <code class="hljs">Option</code> branches on the first argument, propagating <code class="hljs">none</code>, <code class="hljs">bind</code> for <code class="hljs">OptionT</code> should run the monadic action that makes up the first argument, branch on the result, and then propagate <code class="hljs">none</code>.
Following this sketch yields the following definition, which Lean does not accept:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-symbol">:</span></span> Monad (OptionT m) <span class="hljs-keyword">where</span>
  pure x := pure (some x)
  bind action next := <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">match</span> (â action) <span class="hljs-keyword">with</span>
    | none =&gt; pure none
    | some v =&gt; next v
</code></pre>
<p>The error message shows a cryptic type mismatch:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">application type mismatch
  pure (some x)
argument
  some x
has type
  Option Î±â : Type ?u.25
but is expected to have type
  Î±â : Type ?u.25
</code></pre>
<p>The problem here is that Lean is selecting the wrong <code class="hljs">Monad</code> instance for the surrounding use of <code class="hljs">pure</code>.
Similar errors occur for the definition of <code class="hljs">bind</code>.
One solution is to use type annotations to guide Lean to the correct <code class="hljs">Monad</code> instance:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-symbol">:</span></span> Monad (OptionT m) <span class="hljs-keyword">where</span>
  pure x := (pure (some x) : m (Option _))
  bind action next := (<span class="hljs-keyword">do</span>
    <span class="hljs-keyword">match</span> (â action) <span class="hljs-keyword">with</span>
    | none =&gt; pure none
    | some v =&gt; next v : m (Option _))
</code></pre>
<p>While this solution works, it is inelegant and the code becomes a bit noisy.</p>
<p>An alternative solution is to define functions whose type signatures guide Lean to the correct instances.
In fact, <code class="hljs">OptionT</code> could have been defined as a structure:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">O</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">T</span> <span class="hljs-params">(m : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> v <span class="hljs-keyword">where</span>
  run : m (Option Î±)
</code></pre>
<p>This would solve the problem, because the constructor <code class="hljs">OptionT.mk</code> and the field accessor <code class="hljs">OptionT.run</code> would guide type class inference to the correct instances.
The downside to doing this is that structure values would need to be allocated and deallocated repeatedly when running code that uses it, while the direct definition is a compile-time-only feature.
The best of both worlds can be achieved by defining functions that serve the same role as <code class="hljs">OptionT.mk</code> and <code class="hljs">OptionT.run</code>, but that work with the direct definition:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">O</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">T</span>.<span class="hljs-title">m</span><span class="hljs-title">k</span> <span class="hljs-params">(x : m (Option Î±)</span>) <span class="hljs-symbol">:</span></span> OptionT m Î± := x

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">O</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">T</span>.<span class="hljs-title">r</span><span class="hljs-title">u</span><span class="hljs-title">n</span> <span class="hljs-params">(x : OptionT m Î±)</span> <span class="hljs-symbol">:</span></span> m (Option Î±) := x
</code></pre>
<p>Both functions return their inputs unchanged, but they indicate the boundary between code that is intended to present the interface of <code class="hljs">OptionT</code> and code that is intended to present the interface of the underlying monad <code class="hljs">m</code>.
Using these helpers, the <code class="hljs">Monad</code> instance becomes more readable:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-symbol">:</span></span> Monad (OptionT m) <span class="hljs-keyword">where</span>
  pure x := OptionT.mk (pure (some x))
  bind action next := OptionT.mk <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">match</span> â action <span class="hljs-keyword">with</span>
    | none =&gt; pure none
    | some v =&gt; next v
</code></pre>
<p>Here, the use of <code class="hljs">OptionT.mk</code> indicates that its arguments should be considered as code that uses the interface of <code class="hljs">m</code>, which allows Lean to select the correct <code class="hljs">Monad</code> instances.</p>
<p>After defining the monad instance, it's a good idea to check that the monad contract is satisfied.
The first step is to show that <code class="hljs">bind (pure v) f</code> is the same as <code class="hljs">f v</code>.
Here's the steps:</p>
<div class="equational">
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">bind (pure v) f</code></pre>
</div>
<div class="explanation">
={ <em>Unfolding the definitions of <code class="hljs">bind</code> and <code class="hljs">pure</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">OptionT.mk <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">match</span> â pure (some v) <span class="hljs-keyword">with</span>
  | none =&gt; pure none
  | some x =&gt; f x</code></pre>
</div>
<div class="explanation">
={ <em>Desugaring nested action syntax</em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">OptionT.mk <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> y â pure (some v)
  <span class="hljs-keyword">match</span> y <span class="hljs-keyword">with</span>
  | none =&gt; pure none
  | some x =&gt; f x</code></pre>
</div>
<div class="explanation">
={ <em>Desugaring <code class="hljs">do</code>-notation</em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">OptionT.mk
  (pure (some v) &gt;&gt;= <span class="hljs-keyword">fun</span> y =&gt;
    <span class="hljs-keyword">match</span> y <span class="hljs-keyword">with</span>
    | none =&gt; pure none
    | some x =&gt; f x)</code></pre>
</div>
<div class="explanation">
={ <em>Using the first monad rule for <code class="hljs">m</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">OptionT.mk
  (<span class="hljs-keyword">match</span> some v <span class="hljs-keyword">with</span>
   | none =&gt; pure none
   | some x =&gt; f x)</code></pre>
</div>
<div class="explanation">
={ <em>Reduce <code class="hljs">match</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">OptionT.mk (f v)</code></pre>
</div>
<div class="explanation">
={ <em>Definition of <code class="hljs">OptionT.mk</code></em> }=
</div>
<div class="term">
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">f v</code></pre>
</div>
</div>
<p>The second rule states that <code class="hljs">bind w pure</code> is the same as <code class="hljs">w</code>.
To demonstrate this, unfold the definitions of <code class="hljs">bind</code> and <code class="hljs">pure</code>, yielding:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">OptionT.mk <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">match</span> â w <span class="hljs-keyword">with</span>
    | none =&gt; pure none
    | some v =&gt; pure (some v)
</code></pre>
<p>In this pattern match, the result of both cases is the same as the pattern being matched, just with <code class="hljs">pure</code> around it.
In other words, it is equivalent to <code class="hljs">w &gt;&gt;= fun y =&gt; pure y</code>, which is an instance of <code class="hljs">m</code>'s second monad rule.</p>
<p>The final rule states that <code class="hljs">bind (bind v f) g</code>  is the same as <code class="hljs">bind v (fun x =&gt; bind (f x) g)</code>.
It can be checked in the same way, by expanding the definitions of <code class="hljs">bind</code> and <code class="hljs">pure</code> and then delegating to the underlying monad <code class="hljs">m</code>.</p>
<h3 id="an-alternative-instance"><a class="header" href="#an-alternative-instance">An <code>Alternative</code> Instance</a></h3>
<p>One convenient way to use <code class="hljs">OptionT</code> is through the <code class="hljs">Alternative</code> type class.
Successful return is already indicated by <code class="hljs">pure</code>, and the <code class="hljs">failure</code> and <code class="hljs">orElse</code> methods of <code class="hljs">Alternative</code> provide a way to write a program that returns the first successful result from a number of subprograms:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-symbol">:</span></span> Alternative (OptionT m) <span class="hljs-keyword">where</span>
  failure := OptionT.mk (pure none)
  orElse x y := OptionT.mk <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">match</span> â x <span class="hljs-keyword">with</span>
    | some result =&gt; pure (some result)
    | none =&gt; y ()
</code></pre>
<h3 id="lifting"><a class="header" href="#lifting">Lifting</a></h3>
<p>Lifting an action from <code class="hljs">m</code> to <code class="hljs">OptionT m</code> only requires wrapping <code class="hljs">some</code> around the result of the computation:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-symbol">:</span></span> MonadLift m (OptionT m) <span class="hljs-keyword">where</span>
  monadLift action := OptionT.mk <span class="hljs-keyword">do</span>
    pure (some (â action))
</code></pre>
<h2 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h2>
<p>The monad transformer version of <code class="hljs">Except</code> is very similar to the monad transformer version of <code class="hljs">Option</code>.
Adding exceptions of type <code class="hljs">Îµ</code> to some monadic action of type <code class="hljs">m Î±</code> can be accomplished by adding exceptions to <code class="hljs">Î±</code>, yielding type <code class="hljs">m (Except Îµ Î±)</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">E</span><span class="hljs-title">x</span><span class="hljs-title">c</span><span class="hljs-title">e</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">T</span> <span class="hljs-params">(Îµ : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(m : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> v :=
  m (Except Îµ Î±)
</code></pre>
<p><code class="hljs">OptionT</code> provides <code class="hljs">mk</code> and <code class="hljs">run</code> functions to guide the type checker towards the correct <code class="hljs">Monad</code> instances.
This trick is also useful for <code class="hljs">ExceptT</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">E</span><span class="hljs-title">x</span><span class="hljs-title">c</span><span class="hljs-title">e</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">T</span>.<span class="hljs-title">m</span><span class="hljs-title">k</span> <span class="hljs-params">{Îµ Î± : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">(x : m (Except Îµ Î±)</span>) <span class="hljs-symbol">:</span></span> ExceptT Îµ m Î± := x

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">E</span><span class="hljs-title">x</span><span class="hljs-title">c</span><span class="hljs-title">e</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">T</span>.<span class="hljs-title">r</span><span class="hljs-title">u</span><span class="hljs-title">n</span> <span class="hljs-params">{Îµ Î± : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">(x : ExceptT Îµ m Î±)</span> <span class="hljs-symbol">:</span></span> m (Except Îµ Î±) := x
</code></pre>
<p>The <code class="hljs">Monad</code> instance for <code class="hljs">ExceptT</code> is also very similar to the instance for <code class="hljs">OptionT</code>.
The only difference is that it propagates a specific error value, rather than <code class="hljs">none</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">{Îµ : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">{m : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v}</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-symbol">:</span></span> Monad (ExceptT Îµ m) <span class="hljs-keyword">where</span>
  pure x := ExceptT.mk (pure (Except.ok x))
  bind result next := ExceptT.mk <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">match</span> â result <span class="hljs-keyword">with</span>
    | .error e =&gt; pure (.error e)
    | .ok x =&gt; next x
</code></pre>
<p>The type signatures of <code class="hljs">ExceptT.mk</code> and <code class="hljs">ExceptT.run</code> contain a subtle detail: they annotate the universe levels of <code class="hljs">Î±</code> and <code class="hljs">Îµ</code> explicitly.
If they are not explicitly annotated, then Lean generates a more general type signature in which they have distinct polymorphic universe variables.
However, the definition of <code class="hljs">ExceptT</code> expects them to be in the same universe, because they can both be provided as arguments to <code class="hljs">m</code>.
This can lead to a problem in the <code class="hljs">Monad</code> instance where the universe level solver fails to find a working solution:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">E</span><span class="hljs-title">x</span><span class="hljs-title">c</span><span class="hljs-title">e</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">T</span>.<span class="hljs-title">m</span><span class="hljs-title">k</span> <span class="hljs-params">(x : m (Except Îµ Î±)</span>) <span class="hljs-symbol">:</span></span> ExceptT Îµ m Î± := x

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">{Îµ : <span class="hljs-built_in">Type</span> u}</span> <span class="hljs-params">{m : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v}</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-symbol">:</span></span> Monad (ExceptT Îµ m) <span class="hljs-keyword">where</span>
  pure x := ExceptT.mk (pure (Except.ok x))
  bind result next := ExceptT.mk <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">match</span> (â result) <span class="hljs-keyword">with</span>
    | .error e =&gt; pure (.error e)
    | .ok x =&gt; next x
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">stuck at solving universe constraint
  max ?u.12144 ?u.12145 =?= u
while trying to unify
  ExceptT Îµ m Î±â
with
  (ExceptT Îµ m Î±â) Îµ m Î±â
</code></pre>
<p>This kind of error message is typically caused by underconstrained universe variables.
Diagnosing it can be tricky, but a good first step is to look for reused universe variables in some definitions that are not reused in others.</p>
<p>Unlike <code class="hljs">Option</code>, the <code class="hljs">Except</code> datatype is typically not used as a data structure.
It is always used as a control structure with its <code class="hljs">Monad</code> instance.
This means that it is reasonable to lift <code class="hljs">Except Îµ</code> actions into <code class="hljs">ExceptT Îµ m</code>, as well as actions from the underlying monad <code class="hljs">m</code>.
Lifting <code class="hljs">Except</code> actions into <code class="hljs">ExceptT</code> actions is done by wrapping them in <code class="hljs">m</code>'s <code class="hljs">pure</code>, because an action that only has exception effects cannot have any effects from the monad <code class="hljs">m</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-symbol">:</span></span> MonadLift (Except Îµ) (ExceptT Îµ m) <span class="hljs-keyword">where</span>
  monadLift action := ExceptT.mk (pure action)
</code></pre>
<p>Because actions from <code class="hljs">m</code> do not have any exceptions in them, their value should be wrapped in <code class="hljs">Except.ok</code>.
This can be accomplished using the fact that <code class="hljs">Functor</code> is a superclass of <code class="hljs">Monad</code>, so applying a function to the result of any monadic computation can be accomplished using <code class="hljs">Functor.map</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-symbol">:</span></span> MonadLift m (ExceptT Îµ m) <span class="hljs-keyword">where</span>
  monadLift action := ExceptT.mk (.ok &lt;$&gt; action)
</code></pre>
<h3 id="type-classes-for-exceptions"><a class="header" href="#type-classes-for-exceptions">Type Classes for Exceptions</a></h3>
<p>Exception handling fundamentally consists of two operations: the ability to throw exceptions, and the ability to recover from them.
Thus far, this has been accomplished using the constructors of <code class="hljs">Except</code> and pattern matching, respectively.
However, this ties a program that uses exceptions to one specific encoding of the exception handling effect.
Using a type class to capture these operations allows a program that uses exceptions to be used in <em>any</em> monad that supports throwing and catching.</p>
<p>Throwing an exception should take an exception as an argument, and it should be allowed in any context where a monadic action is requested.
The "any context" part of the specification can be written as a type by writing <code class="hljs">m Î±</code>âbecause there's no way to produce a value of any arbitrary type, the <code class="hljs">throw</code> operation must be doing something that causes control to leave that part of the program.
Catching an exception should accept any monadic action together with a handler, and the handler should explain how to get back to the action's type from an exception:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">M</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">E</span><span class="hljs-title">x</span><span class="hljs-title">c</span><span class="hljs-title">e</span><span class="hljs-title">p</span><span class="hljs-title">t</span> <span class="hljs-params">(Îµ : outParam (<span class="hljs-built_in">Type</span> u)</span>) <span class="hljs-params">(m : <span class="hljs-built_in">Type</span> v â <span class="hljs-built_in">Type</span> w)</span></span> <span class="hljs-keyword">where</span>
  throw : Îµ â m Î±
  tryCatch : m Î± â (Îµ â m Î±) â m Î±
</code></pre>
<p>The universe levels on <code class="hljs">MonadExcept</code> differ from those of <code class="hljs">ExceptT</code>.
In <code class="hljs">ExceptT</code>, both <code class="hljs">Îµ</code> and <code class="hljs">Î±</code> have the same level, while <code class="hljs">MonadExcept</code> imposes no such limitation.
This is because <code class="hljs">MonadExcept</code> never places an exception value inside of <code class="hljs">m</code>.
The most general universe signature recognizes the fact that <code class="hljs">Îµ</code> and <code class="hljs">Î±</code> are completely independent in this definition.
Being more general means that the type class can be instantiated for a wider variety of types.</p>
<p>An example program that uses <code class="hljs">MonadExcept</code> is a simple division service.
The program is divided into two parts: a frontend that supplies a user interface based on strings that handles errors, and a backend that actually does the division.
Both the frontend and the backend can throw exceptions, the former for ill-formed input and the latter for division by zero errors.
The exceptions are an inductive type:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Err <span class="hljs-keyword">where</span>
  | divByZero
  | notANumber : String â Err
</code></pre>
<p>The backend checks for zero, and divides if it can:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">B</span><span class="hljs-title">a</span><span class="hljs-title">c</span><span class="hljs-title">k</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">[MonadExcept Err m]</span> <span class="hljs-params">(n k : Int)</span> <span class="hljs-symbol">:</span></span> m Int :=
  <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>
    throw .divByZero
  <span class="hljs-keyword">else</span> pure (n / k)
</code></pre>
<p>The frontend's helper <code class="hljs">asNumber</code> throws an exception if the string it is passed is not a number.
The overall frontend converts its inputs to <code class="hljs">Int</code>s and calls the backend, handling exceptions by returning a friendly string error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">s</span><span class="hljs-title">N</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">b</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">[MonadExcept Err m]</span> <span class="hljs-params">(s : String)</span> <span class="hljs-symbol">:</span></span> m Int :=
  <span class="hljs-keyword">match</span> s.toInt? <span class="hljs-keyword">with</span>
  | none =&gt; throw (.notANumber s)
  | some i =&gt; pure i

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">F</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">[MonadExcept Err m]</span> <span class="hljs-params">(n k : String)</span> <span class="hljs-symbol">:</span></span> m String :=
  tryCatch (<span class="hljs-keyword">do</span> pure (toString (â divBackend (â asNumber n) (â asNumber k))))
    <span class="hljs-keyword">fun</span>
      | .divByZero =&gt; pure <span class="hljs-string">"Division by zero!"</span>
      | .notANumber s =&gt; pure s!<span class="hljs-string">"Not a number: \"{s}\""</span>
</code></pre>
<p>Throwing and catching exceptions is common enough that Lean provides a special syntax for using <code class="hljs">MonadExcept</code>.
Just as <code class="hljs">+</code> is short for <code class="hljs">HAdd.hAdd</code>, <code class="hljs">try</code> and <code class="hljs">catch</code> can be used as shorthand for the <code class="hljs">tryCatch</code> method:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">F</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">[MonadExcept Err m]</span> <span class="hljs-params">(n k : String)</span> <span class="hljs-symbol">:</span></span> m String :=
  <span class="hljs-keyword">try</span>
    pure (toString (â divBackend (â asNumber n) (â asNumber k)))
  <span class="hljs-keyword">catch</span>
    | .divByZero =&gt; pure <span class="hljs-string">"Division by zero!"</span>
    | .notANumber s =&gt; pure s!<span class="hljs-string">"Not a number: \"{s}\""</span>
</code></pre>
<p>In addition to <code class="hljs">Except</code> and <code class="hljs">ExceptT</code>, there are useful <code class="hljs">MonadExcept</code> instances for other types that may not seem like exceptions at first glance.
For example, failure due to <code class="hljs">Option</code> can be seen as throwing an exception that contains no data whatsoever, so there is an instance of <code class="hljs">MonadExcept Unit Option</code> that allows <code class="hljs">try ... catch ...</code> syntax to be used with <code class="hljs">Option</code>.</p>
<h2 id="state"><a class="header" href="#state">State</a></h2>
<p>A simulation of mutable state is added to a monad by having monadic actions accept a starting state as an argument and return a final state together with their result.
The bind operator for a state monad provides the final state of one action as an argument to the next action, threading the state through the program.
This pattern can also be expressed as a monad transformer:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">S</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">T</span> <span class="hljs-params">(Ï : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-params">(m : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span> u)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> (max u v) :=
  Ï â m (Î± Ã Ï)
</code></pre>
<p>Once again, the monad instance is very similar to that for <code class="hljs">State</code>.
The only difference is that the input and output states are passed around and returned in the underlying monad, rather than with pure code:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-symbol">:</span></span> Monad (StateT Ï m) <span class="hljs-keyword">where</span>
  pure x := <span class="hljs-keyword">fun</span> s =&gt; pure (x, s)
  bind result next := <span class="hljs-keyword">fun</span> s =&gt; <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">let</span> (v, s') â result s
    next v s'
</code></pre>
<p>The corresponding type class has <code class="hljs">get</code> and <code class="hljs">set</code> methods.
One downside of <code class="hljs">get</code> and <code class="hljs">set</code> is that it becomes too easy to <code class="hljs">set</code> the wrong state when updating it.
This is because retrieving the state, updating it, and saving the updated state is a natural way to write some programs.
For example, the following program counts the number of diacritic-free English vowels and consonants in a string of letters:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">L</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">C</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">s</span></span> <span class="hljs-keyword">where</span>
  vowels : Nat
  consonants : Nat
<span class="hljs-keyword">deriving</span> Repr

<span class="hljs-keyword">inductive</span> Err <span class="hljs-keyword">where</span>
  | notALetter : Char â Err
<span class="hljs-keyword">deriving</span> Repr

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">v</span><span class="hljs-title">ow</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span>=
  <span class="hljs-keyword">let</span> lowerVowels := <span class="hljs-string">"aeiuoy"</span>
  lowerVowels ++ lowerVowels.map (Â·.toUpper)

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span>=
  <span class="hljs-keyword">let</span> lowerConsonants := <span class="hljs-string">"bcdfghjklmnpqrstvwxz"</span>
  lowerConsonants ++ lowerConsonants.map (Â·.toUpper )

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span> <span class="hljs-params">(str : String)</span> <span class="hljs-symbol">:</span></span> StateT LetterCounts (Except Err) Unit :=
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> loop (chars : List Char) := <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">match</span> chars <span class="hljs-keyword">with</span>
    | [] =&gt; pure ()
    | c :: cs =&gt;
      <span class="hljs-keyword">let</span> st â get
      <span class="hljs-keyword">let</span> st' â
        <span class="hljs-keyword">if</span> c.isAlpha <span class="hljs-keyword">then</span>
          <span class="hljs-keyword">if</span> vowels.contains c <span class="hljs-keyword">then</span>
            pure {st <span class="hljs-keyword">with</span> vowels := st.vowels + <span class="hljs-number">1</span>}
          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> consonants.contains c <span class="hljs-keyword">then</span>
            pure {st <span class="hljs-keyword">with</span> consonants := st.consonants + <span class="hljs-number">1</span>}
          <span class="hljs-keyword">else</span> <span class="hljs-comment">-- modified or non-English letter</span>
            pure st
        <span class="hljs-keyword">else</span> throw (.notALetter c)
      set st'
      loop cs
  loop str.toList
</code></pre>
<p>It would be very easy to write <code class="hljs">set st</code> instead of <code class="hljs">set st'</code>.
In a large program, this kind of mistake can lead to difficult-to-diagnose bugs.</p>
<p>While using a nested action for the call to <code class="hljs">get</code> would solve this problem, it can't solve all such problems.
For example, a function might update a field on a structure based on the values of two other fields.
This would require two separate nested-action calls to <code class="hljs">get</code>.
Because the Lean compiler contains optimizations that are only effective when there is a single reference to a value, duplicating the references to the state might lead to code that is significantly slower.
Both the potential performance problem and the potential bug can be worked around by using <code class="hljs">modify</code>, which transforms the state using a function:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span> <span class="hljs-params">(str : String)</span> <span class="hljs-symbol">:</span></span> StateT LetterCounts (Except Err) Unit :=
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> loop (chars : List Char) := <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">match</span> chars <span class="hljs-keyword">with</span>
    | [] =&gt; pure ()
    | c :: cs =&gt;
      <span class="hljs-keyword">if</span> c.isAlpha <span class="hljs-keyword">then</span>
        <span class="hljs-keyword">if</span> vowels.contains c <span class="hljs-keyword">then</span>
          modify <span class="hljs-keyword">fun</span> st =&gt; {st <span class="hljs-keyword">with</span> vowels := st.vowels + <span class="hljs-number">1</span>}
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> consonants.contains c <span class="hljs-keyword">then</span>
          modify <span class="hljs-keyword">fun</span> st =&gt; {st <span class="hljs-keyword">with</span> consonants := st.consonants + <span class="hljs-number">1</span>}
        <span class="hljs-keyword">else</span> <span class="hljs-comment">-- modified or non-English letter</span>
          pure ()
      <span class="hljs-keyword">else</span> throw (.notALetter c)
      loop cs
  loop str.toList
</code></pre>
<p>The type class contains a function akin to <code class="hljs">modify</code> called <code class="hljs">modifyGet</code>, which allows the function to both compute a return value and transform an old state in a single step.
The function returns a pair in which the first element is the return value, and the second element is the new state; <code class="hljs">modify</code> just adds the constructor of <code class="hljs">Unit</code> to the pair used in <code class="hljs">modifyGet</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">o</span><span class="hljs-title">d</span><span class="hljs-title">i</span><span class="hljs-title">f</span><span class="hljs-title">y</span> <span class="hljs-params">[MonadState Ï m]</span> <span class="hljs-params">(f : Ï â Ï)</span> <span class="hljs-symbol">:</span></span> m Unit :=
  modifyGet <span class="hljs-keyword">fun</span> s =&gt; ((), f s)
</code></pre>
<p>The definition of <code class="hljs">MonadState</code> is as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">M</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">S</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span> <span class="hljs-params">(Ï : outParam (<span class="hljs-built_in">Type</span> u)</span>) <span class="hljs-params">(m : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Type</span> (max (u+<span class="hljs-number">1</span>) v) <span class="hljs-keyword">where</span>
  get : m Ï
  set : Ï â m PUnit
  modifyGet : (Ï â Î± Ã Ï) â m Î±
</code></pre>
<p><code class="hljs">PUnit</code> is a version of the <code class="hljs">Unit</code> type that is universe-polymorphic to allow it to be in <code class="hljs">Type u</code> instead of <code class="hljs">Type</code>.
While it would be possible to provide a default implementation of <code class="hljs">modifyGet</code> in terms of <code class="hljs">get</code> and <code class="hljs">set</code>, it would not admit the optimizations that make <code class="hljs">modifyGet</code> useful in the first place, rendering the method useless.</p>
<h2 id="of-classes-and-the-functions"><a class="header" href="#of-classes-and-the-functions"><code>Of</code> Classes and <code>The</code> Functions</a></h2>
<p>Thus far, each monad type class that takes extra information, like the type of exceptions for <code class="hljs">MonadExcept</code> or the type of the state for <code class="hljs">MonadState</code>, has this type of extra information as an output parameter.
For simple programs, this is generally convenient, because a monad that combines one use each of <code class="hljs">StateT</code>, <code class="hljs">ReaderT</code>, and <code class="hljs">ExceptT</code> has only a single state type, environment type, and exception type.
As monads grow in complexity, however, they may involve multiple states or errors types.
In this case, the use of an output parameter makes it impossible to target both states in the same <code class="hljs">do</code>-block.</p>
<p>For these cases, there are additional type classes in which the extra information is not an output parameter.
These versions of the type classes use the word <code class="hljs">Of</code> in the name.
For example, <code class="hljs">MonadStateOf</code> is like <code class="hljs">MonadState</code>, but without an <code class="hljs">outParam</code> modifier.</p>
<p>Similarly, there are versions of the type class methods that accept the type of the extra information as an <em>explicit</em>, rather than implicit, argument.
For <code class="hljs">MonadStateOf</code>, there are <code class="hljs">getThe</code> with type</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">(Ï : <span class="hljs-built_in">Type</span> u) â {m : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v} â [MonadStateOf Ï m] â m Ï
</code></pre>
<p>and <code class="hljs">modifyThe</code> with type</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">(Ï : <span class="hljs-built_in">Type</span> u) â {m : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v} â [MonadStateOf Ï m] â (Ï â Ï) â m PUnit
</code></pre>
<p>There is no <code class="hljs">setThe</code> because the type of the new state is enough to decide which surrounding state monad transformer to use.</p>
<p>In the Lean standard library, there are instances of the non-<code class="hljs">Of</code> versions of the classes defined in terms of the instances of the versions with <code class="hljs">Of</code>.
In other words, implementing the <code class="hljs">Of</code> version yields implementations of both.
It's generally a good idea to implement the <code class="hljs">Of</code> version, and then start writing programs using the non-<code class="hljs">Of</code> versions of the class, transitioning to the <code class="hljs">Of</code> version if the output parameter becomes inconvenient.</p>
<h2 id="transformers-and-id"><a class="header" href="#transformers-and-id">Transformers and <code>Id</code></a></h2>
<p>The identity monad <code class="hljs">Id</code> is the monad that has no effects whatsoever, to be used in contexts that expect a monad for some reason but where none is actually necessary.
Another use of <code class="hljs">Id</code> is to serve as the bottom of a stack of monad transformers.
For instance, <code class="hljs">StateT Ï Id</code> works just like <code class="hljs">State Ï</code>.</p>
<h2 id="exercises-15"><a class="header" href="#exercises-15">Exercises</a></h2>
<h3 id="monad-contract"><a class="header" href="#monad-contract">Monad Contract</a></h3>
<p>Using pencil and paper, check that the rules of the monad transformer contract are satisfied for each monad transformer in this section.</p>
<h3 id="logging-transformer"><a class="header" href="#logging-transformer">Logging Transformer</a></h3>
<p>Define a monad transformer version of <code class="hljs">WithLog</code>.
Also define the corresponding type class <code class="hljs">MonadWithLog</code>, and write a program that combines logging and exceptions.</p>
<h3 id="counting-files"><a class="header" href="#counting-files">Counting Files</a></h3>
<p>Modify <code class="hljs">doug</code>'s monad with <code class="hljs">StateT</code> such that it counts the number of directories and files seen.
At the end of execution, it should display a report like:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">  Viewed 38 files in 5 directories.
</code></pre>
<div style="break-before:page;page-break-before:always"></div><h1 id="ordering-monad-transformers"><a class="header" href="#ordering-monad-transformers">Ordering Monad Transformers</a></h1>
<p>When composing a monad from a stack of monad transformers, it's important to be aware that the order in which the monad transformers are layered matters.
Different orderings of the same set of transformers result in different monads.</p>
<p>This version of <code class="hljs">countLetters</code> is just like the previous version, except it uses type classes to describe the set of available effects instead of providing a concrete monad:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">[MonadState LetterCounts m]</span> <span class="hljs-params">[MonadExcept Err m]</span> <span class="hljs-params">(str : String)</span> <span class="hljs-symbol">:</span></span> m Unit :=
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> loop (chars : List Char) := <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">match</span> chars <span class="hljs-keyword">with</span>
    | [] =&gt; pure ()
    | c :: cs =&gt;
      <span class="hljs-keyword">if</span> c.isAlpha <span class="hljs-keyword">then</span>
        <span class="hljs-keyword">if</span> vowels.contains c <span class="hljs-keyword">then</span>
          modify <span class="hljs-keyword">fun</span> st =&gt; {st <span class="hljs-keyword">with</span> vowels := st.vowels + <span class="hljs-number">1</span>}
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> consonants.contains c <span class="hljs-keyword">then</span>
          modify <span class="hljs-keyword">fun</span> st =&gt; {st <span class="hljs-keyword">with</span> consonants := st.consonants + <span class="hljs-number">1</span>}
        <span class="hljs-keyword">else</span> <span class="hljs-comment">-- modified or non-English letter</span>
          pure ()
      <span class="hljs-keyword">else</span> throw (.notALetter c)
      loop cs
  loop str.toList
</code></pre>
<p>The state and exception monad transformers can be combined in two different orders, each resulting in a monad that has instances of both type classes:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">abbrev</span> M1 := StateT LetterCounts (ExceptT Err Id)
<span class="hljs-keyword">abbrev</span> M2 := ExceptT Err (StateT LetterCounts Id)
</code></pre>
<p>When run on input for which the program does not throw an exception, both monads yield similar results:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> countLetters (m := M1) <span class="hljs-string">"hello"</span> â¨<span class="hljs-number">0</span>, <span class="hljs-number">0</span>â©
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Except.ok ((), { vowels := 2, consonants := 3 })
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> countLetters (m := M2) <span class="hljs-string">"hello"</span> â¨<span class="hljs-number">0</span>, <span class="hljs-number">0</span>â©
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">(Except.ok (), { vowels := 2, consonants := 3 })
</code></pre>
<p>However, there is a subtle difference between these return values.
In the case of <code class="hljs">M1</code>, the outermost constructor is <code class="hljs">Except.ok</code>, and it contains a pair of the unit constructor with the final state.
In the case of <code class="hljs">M2</code>, the outermost constructor is the pair, which contains <code class="hljs">Except.ok</code> applied only to the unit constructor.
The final state is outside of <code class="hljs">Except.ok</code>.
In both cases, the program returns the counts of vowels and consonants.</p>
<p>On the other hand, only one monad yields a count of vowels and consonants when the string causes an exception to be thrown.
Using <code class="hljs">M1</code>, only an exception value is returned:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> countLetters (m := M1) <span class="hljs-string">"hello!"</span> â¨<span class="hljs-number">0</span>, <span class="hljs-number">0</span>â©
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Except.error (StEx.Err.notALetter '!')
</code></pre>
<p>Using <code class="hljs">M2</code>, the exception value is paired with the state as it was at the time that the exception was thrown:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> countLetters (m := M2) <span class="hljs-string">"hello!"</span> â¨<span class="hljs-number">0</span>, <span class="hljs-number">0</span>â©
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">(Except.error (StEx.Err.notALetter '!'), { vowels := 2, consonants := 3 })
</code></pre>
<p>It might be tempting to think that <code class="hljs">M2</code> is superior to <code class="hljs">M1</code> because it provides more information that might be useful when debugging.
The same program might compute <em>different</em> answers in <code class="hljs">M1</code> than it does in <code class="hljs">M2</code>, and there's no principled reason to say that one of these answers is necessarily better than the other.
This can be seen by adding a step to the program that handles exceptions:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">W</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">F</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">l</span><span class="hljs-title">b</span><span class="hljs-title">a</span><span class="hljs-title">c</span><span class="hljs-title">k</span>
    <span class="hljs-params">[Monad m]</span> <span class="hljs-params">[MonadState LetterCounts m]</span> <span class="hljs-params">[MonadExcept Err m]</span>
    <span class="hljs-params">(str : String)</span> <span class="hljs-symbol">:</span></span> m Unit :=
  <span class="hljs-keyword">try</span>
    countLetters str
  <span class="hljs-keyword">catch</span> _ =&gt;
    countLetters <span class="hljs-string">"Fallback"</span>
</code></pre>
<p>This program always succeeds, but it might succeed with different results.
If no exception is thrown, then the results are the same as <code class="hljs">countLetters</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> countWithFallback (m := M1) <span class="hljs-string">"hello"</span> â¨<span class="hljs-number">0</span>, <span class="hljs-number">0</span>â©
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Except.ok ((), { vowels := 2, consonants := 3 })
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> countWithFallback (m := M2) <span class="hljs-string">"hello"</span> â¨<span class="hljs-number">0</span>, <span class="hljs-number">0</span>â©
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">(Except.ok (), { vowels := 2, consonants := 3 })
</code></pre>
<p>However, if the exception is thrown and caught, then the final states are very different.
With <code class="hljs">M1</code>, the final state contains only the letter counts from <code class="hljs">"Fallback"</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> countWithFallback (m := M1) <span class="hljs-string">"hello!"</span> â¨<span class="hljs-number">0</span>, <span class="hljs-number">0</span>â©
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Except.ok ((), { vowels := 2, consonants := 6 })
</code></pre>
<p>With <code class="hljs">M2</code>, the final state contains letter counts from both <code class="hljs">"hello"</code> and from <code class="hljs">"Fallback"</code>, as one would expect in an imperative language:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> countWithFallback (m := M2) <span class="hljs-string">"hello!"</span> â¨<span class="hljs-number">0</span>, <span class="hljs-number">0</span>â©
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">(Except.ok (), { vowels := 4, consonants := 9 })
</code></pre>
<p>In <code class="hljs">M1</code>, throwing an exception "rolls back" the state to where the exception was caught.
In <code class="hljs">M2</code>, modifications to the state persist across the throwing and catching of exceptions.
This difference can be seen by unfolding the definitions of <code class="hljs">M1</code> and <code class="hljs">M2</code>.
<code class="hljs">M1 Î±</code> unfolds to <code class="hljs">LetterCounts â Except Err (Î± Ã LetterCounts)</code>, and <code class="hljs">M2 Î±</code> unfolds to <code class="hljs">LetterCounts â Except Err Î± Ã LetterCounts</code>.
That is to say, <code class="hljs">M1 Î±</code> describes functions that take an initial letter count, returning either an error or an <code class="hljs">Î±</code> paired with updated counts.
When an exception is thrown in <code class="hljs">M1</code>, there is no final state.
<code class="hljs">M2 Î±</code> describes functions that take an initial letter count and return a new letter count paired with either an error or an <code class="hljs">Î±</code>.
When an exception is thrown in <code class="hljs">M2</code>, it is accompanied by a state.</p>
<h2 id="commuting-monads"><a class="header" href="#commuting-monads">Commuting Monads</a></h2>
<p>In the jargon of functional programming, two monad transformers are said to <em>commute</em> if they can be re-ordered without the meaning of the program changing.
The fact that the result of the program can differ when <code class="hljs">StateT</code> and <code class="hljs">ExceptT</code> are reordered means that state and exceptions do not commute.
In general, monad transformers should not be expected to commute.</p>
<p>Even though not all monad transformers commute, some do.
For example, two uses of <code class="hljs">StateT</code> can be re-ordered.
Expanding the definitions in <code class="hljs">StateT Ï (StateT Ï' Id) Î±</code> yields the type <code class="hljs">Ï â Ï' â ((Î± Ã Ï) Ã Ï')</code>, and <code class="hljs">StateT Ï' (StateT Ï Id) Î±</code> yields <code class="hljs">Ï' â Ï â ((Î± Ã Ï') Ã Ï)</code>.
In other words, the differences between them are that they nest the <code class="hljs">Ï</code> and <code class="hljs">Ï'</code> types in different places in the return type, and they accept their arguments in a different order.
Any client code will still need to provide the same inputs, and it will still receive the same outputs.</p>
<p>Most programming languages that have both mutable state and exceptions work like <code class="hljs">M2</code>.
In those languages, state that <em>should</em> be rolled back when an exception is thrown is difficult to express, and it usually needs to be simulated in a manner that looks much like the passing of explicit state values in <code class="hljs">M1</code>.
Monad transformers grant the freedom to choose an interpretation of effect ordering that works for the problem at hand, with both choices being equally easy to program with.
However, they also require care to be taken in the choice of ordering of transformers.
With great expressive power comes the responsibility to check that what's being expressed is what is intended, and the type signature of <code class="hljs">countWithFallback</code> is probably more polymorphic than it should be.</p>
<h2 id="exercises-16"><a class="header" href="#exercises-16">Exercises</a></h2>
<ul>
<li>Check that <code class="hljs">ReaderT</code> and <code class="hljs">StateT</code> commute by expanding their definitions and reasoning about the resulting types.</li>
<li>Do <code class="hljs">ReaderT</code> and <code class="hljs">ExceptT</code> commute? Check your answer by expanding their definitions and reasoning about the resulting types.</li>
<li>Construct a monad transformer <code class="hljs">ManyT</code> based on the definition of <code class="hljs">Many</code>, with a suitable <code class="hljs">Alternative</code> instance. Check that it satisfies the <code class="hljs">Monad</code> contract.</li>
<li>Does <code class="hljs">ManyT</code> commute with <code class="hljs">StateT</code>? If so, check your answer by expanding definitions and reasoning about the resulting types. If not, write a program in <code class="hljs">ManyT (StateT Ï Id)</code> and a program in <code class="hljs">StateT Ï (ManyT Id)</code>. Each program should be one that makes more sense for the given ordering of monad transformers.</li>
</ul>
<div style="break-before:page;page-break-before:always"></div><h1 id="more-do-features"><a class="header" href="#more-do-features">More do Features</a></h1>
<p>Lean's <code class="hljs">do</code>-notation provides a syntax for writing programs with monads that resembles imperative programming languages.
In addition to providing a convenient syntax for programs with monads, <code class="hljs">do</code>-notation provides syntax for using certain monad transformers.</p>
<h2 id="single-branched-if"><a class="header" href="#single-branched-if">Single-Branched <code>if</code></a></h2>
<p>When working in a monad, a common pattern is to carry out a side effect only if some condition is true.
For instance, <code class="hljs">countLetters</code> contains a check for vowels or consonants, and letters that are neither have no effect on the state.
This is captured by having the <code class="hljs">else</code> branch evaluate to <code class="hljs">pure ()</code>, which has no effects:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span> <span class="hljs-params">(str : String)</span> <span class="hljs-symbol">:</span></span> StateT LetterCounts (Except Err) Unit :=
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> loop (chars : List Char) := <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">match</span> chars <span class="hljs-keyword">with</span>
    | [] =&gt; pure ()
    | c :: cs =&gt;
      <span class="hljs-keyword">if</span> c.isAlpha <span class="hljs-keyword">then</span>
        <span class="hljs-keyword">if</span> vowels.contains c <span class="hljs-keyword">then</span>
          modify <span class="hljs-keyword">fun</span> st =&gt; {st <span class="hljs-keyword">with</span> vowels := st.vowels + <span class="hljs-number">1</span>}
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> consonants.contains c <span class="hljs-keyword">then</span>
          modify <span class="hljs-keyword">fun</span> st =&gt; {st <span class="hljs-keyword">with</span> consonants := st.consonants + <span class="hljs-number">1</span>}
        <span class="hljs-keyword">else</span> <span class="hljs-comment">-- modified or non-English letter</span>
          pure ()
      <span class="hljs-keyword">else</span> throw (.notALetter c)
      loop cs
  loop str.toList
</code></pre>
<p>When an <code class="hljs">if</code> is a statement in a <code class="hljs">do</code>-block, rather than being an expression, then <code class="hljs">else pure ()</code> can simply be omitted, and Lean inserts it automatically.
The following definition of <code class="hljs">countLetters</code> is completely equivalent:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span> <span class="hljs-params">(str : String)</span> <span class="hljs-symbol">:</span></span> StateT LetterCounts (Except Err) Unit :=
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> loop (chars : List Char) := <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">match</span> chars <span class="hljs-keyword">with</span>
    | [] =&gt; pure ()
    | c :: cs =&gt;
      <span class="hljs-keyword">if</span> c.isAlpha <span class="hljs-keyword">then</span>
        <span class="hljs-keyword">if</span> vowels.contains c <span class="hljs-keyword">then</span>
          modify <span class="hljs-keyword">fun</span> st =&gt; {st <span class="hljs-keyword">with</span> vowels := st.vowels + <span class="hljs-number">1</span>}
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> consonants.contains c <span class="hljs-keyword">then</span>
          modify <span class="hljs-keyword">fun</span> st =&gt; {st <span class="hljs-keyword">with</span> consonants := st.consonants + <span class="hljs-number">1</span>}
      <span class="hljs-keyword">else</span> throw (.notALetter c)
      loop cs
  loop str.toList
</code></pre>
<p>A program that uses a state monad to count the entries in a list that satisfy some monadic check can be written as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">[MonadState Nat m]</span> <span class="hljs-params">(p : Î± â m Bool)</span> <span class="hljs-symbol">:</span></span> List Î± â m Unit
  | [] =&gt; pure ()
  | x :: xs =&gt; <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span> â p x <span class="hljs-keyword">then</span>
      modify (Â· + <span class="hljs-number">1</span>)
    count p xs
</code></pre>
<p>Similarly, <code class="hljs">if not E1 then STMT...</code> can instead be written <code class="hljs">unless E1 do STMT...</code>.
The converse of <code class="hljs">count</code> that counts entries that don't satisfy the monadic check can be written by replacing <code class="hljs">if</code> with <code class="hljs">unless</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">N</span><span class="hljs-title">o</span><span class="hljs-title">t</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">[MonadState Nat m]</span> <span class="hljs-params">(p : Î± â m Bool)</span> <span class="hljs-symbol">:</span></span> List Î± â m Unit
  | [] =&gt; pure ()
  | x :: xs =&gt; <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">unless</span> â p x <span class="hljs-keyword">do</span>
      modify (Â· + <span class="hljs-number">1</span>)
    countNot p xs
</code></pre>
<p>Understanding single-branched <code class="hljs">if</code> and <code class="hljs">unless</code> does not require thinking about monad transformers.
They simply replace the missing branch with <code class="hljs">pure ()</code>.
The remaining extensions in this section, however, require Lean to automatically rewrite the <code class="hljs">do</code>-block to add a local transformer on top of the monad that the <code class="hljs">do</code>-block is written in.</p>
<h2 id="early-return"><a class="header" href="#early-return">Early Return</a></h2>
<p>The standard library contains a function <code class="hljs">List.find?</code> that returns the first entry in a list that satisfies some check.
A simple implementation that doesn't make use of the fact that <code class="hljs">Option</code> is a monad loops over the list using a recursive function, with an <code class="hljs">if</code> to stop the loop when the desired entry is found:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d?</span> <span class="hljs-params">(p : Î± â Bool)</span> <span class="hljs-symbol">:</span></span> List Î± â Option Î±
  | [] =&gt; none
  | x :: xs =&gt;
    <span class="hljs-keyword">if</span> p x <span class="hljs-keyword">then</span>
      some x
    <span class="hljs-keyword">else</span>
      find? p xs
</code></pre>
<p>Imperative languages typically sport the <code class="hljs">return</code> keyword that aborts the execution of a function, immediately returning some value to the caller.
In Lean, this is available in <code class="hljs">do</code>-notation, and <code class="hljs">return</code> halts the execution of a <code class="hljs">do</code>-block, with <code class="hljs">return</code>'s argument being the value returned from the monad.
In other words, <code class="hljs">List.find?</code> could have been written like this:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d?</span> <span class="hljs-params">(p : Î± â Bool)</span> <span class="hljs-symbol">:</span></span> List Î± â Option Î±
  | [] =&gt; failure
  | x :: xs =&gt; <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span> p x <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> x
    find? p xs
</code></pre>
<p>Early return in imperative languages is a bit like an exception that can only cause the current stack frame to be unwound.
Both early return and exceptions terminate execution of a block of code, effectively replacing the surrounding code with the thrown value.
Behind the scenes, early return in Lean is implemented using a version of <code class="hljs">ExceptT</code>.
Each <code class="hljs">do</code>-block that uses early return is wrapped in an exception handler (in the sense of the function <code class="hljs">tryCatch</code>).
Early returns are translated to throwing the value as an exception, and the handlers catch the thrown value and return it immediately.
In other words, the <code class="hljs">do</code>-block's original return value type is also used as the exception type.</p>
<p>Making this more concrete, the helper function <code class="hljs">runCatch</code> strips a layer of <code class="hljs">ExceptT</code> from the top of a monad transformer stack when the exception type and return type are the same:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">r</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">C</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">c</span><span class="hljs-title">h</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">(action : ExceptT Î± m Î±)</span> <span class="hljs-symbol">:</span></span> m Î± := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">match</span> â action <span class="hljs-keyword">with</span>
  | Except.ok x =&gt; pure x
  | Except.error x =&gt; pure x
</code></pre>
<p>The <code class="hljs">do</code>-block in <code class="hljs">List.find?</code> that uses early return is translated to a <code class="hljs">do</code>-block that does not use early return by wrapping it in a use of <code class="hljs">runCatch</code>, and replacing early returns with <code class="hljs">throw</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d?</span> <span class="hljs-params">(p : Î± â Bool)</span> <span class="hljs-symbol">:</span></span> List Î± â Option Î±
  | [] =&gt; failure
  | x :: xs =&gt;
    runCatch <span class="hljs-keyword">do</span>
      <span class="hljs-keyword">if</span> p x <span class="hljs-keyword">then</span> throw x <span class="hljs-keyword">else</span> pure ()
      monadLift (find? p xs)
</code></pre>
<p>Another situation in which early return is useful is command-line applications that terminate early if the arguments or input are incorrect.
Many programs begin with a section that validates arguments and inputs before proceeding to the main body of the program.
The following version of <a href="https://leanprover.github.io/functional_programming_in_lean/hello-world/running-a-program.html">the greeting program <code class="hljs">hello-name</code></a> checks that no command-line arguments were provided:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">n</span> <span class="hljs-params">(argv : List String)</span> <span class="hljs-symbol">:</span></span> IO UInt32 := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> stdin â IO.getStdin
  <span class="hljs-keyword">let</span> stdout â IO.getStdout
  <span class="hljs-keyword">let</span> stderr â IO.getStderr

  <span class="hljs-keyword">unless</span> argv == [] <span class="hljs-keyword">do</span>
    stderr.putStrLn s!<span class="hljs-string">"Expected no arguments, but got {argv.length}"</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>

  stdout.putStrLn <span class="hljs-string">"How would you like to be addressed?"</span>
  stdout.flush

  <span class="hljs-keyword">let</span> name := (â stdin.getLine).trim
  <span class="hljs-keyword">if</span> name == <span class="hljs-string">""</span> <span class="hljs-keyword">then</span>
    stderr.putStrLn s!<span class="hljs-string">"No name provided"</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>

  stdout.putStrLn s!<span class="hljs-string">"Hello, {name}!"</span>

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
</code></pre>
<p>Running it with no arguments and typing the name <code class="hljs">David</code> yields the same result as the previous version:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">$ lean --run EarlyReturn.lean
How would you like to be addressed?
David
Hello, David!
</code></pre>
<p>Providing the name as a command-line argument instead of an answer causes an error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">$ lean --run EarlyReturn.lean David
Expected no arguments, but got 1
</code></pre>
<p>And providing no name causes the other error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">$ lean --run EarlyReturn.lean
How would you like to be addressed?

No name provided
</code></pre>
<p>The program that uses early return avoids needing to nest the control flow, as is done in this version that does not use early return:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">n</span> <span class="hljs-params">(argv : List String)</span> <span class="hljs-symbol">:</span></span> IO UInt32 := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> stdin â IO.getStdin
  <span class="hljs-keyword">let</span> stdout â IO.getStdout
  <span class="hljs-keyword">let</span> stderr â IO.getStderr

  <span class="hljs-keyword">if</span> argv != [] <span class="hljs-keyword">then</span>
    stderr.putStrLn s!<span class="hljs-string">"Expected no arguments, but got {argv.length}"</span>
    pure <span class="hljs-number">1</span>
  <span class="hljs-keyword">else</span>
    stdout.putStrLn <span class="hljs-string">"How would you like to be addressed?"</span>
    stdout.flush

    <span class="hljs-keyword">let</span> name := (â stdin.getLine).trim
    <span class="hljs-keyword">if</span> name == <span class="hljs-string">""</span> <span class="hljs-keyword">then</span>
      stderr.putStrLn s!<span class="hljs-string">"No name provided"</span>
      pure <span class="hljs-number">1</span>
    <span class="hljs-keyword">else</span>
      stdout.putStrLn s!<span class="hljs-string">"Hello, {name}!"</span>
      pure <span class="hljs-number">0</span>
</code></pre>
<p>One important difference between early return in Lean and early return in imperative languages is that Lean's early return applies only to the current <code class="hljs">do</code>-block.
When the entire definition of a function is in the same <code class="hljs">do</code> block, this difference doesn't matter.
But if <code class="hljs">do</code> occurs underneath some other structures, then the difference becomes apparent.
For example, given the following definition of <code class="hljs">greet</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">t</span> <span class="hljs-params">(name : String)</span> <span class="hljs-symbol">:</span></span> String :=
  <span class="hljs-string">"Hello, "</span> ++ Id.run <span class="hljs-keyword">do</span> <span class="hljs-keyword">return</span> name
</code></pre>
<p>the expression <code class="hljs">greet "David"</code> evaluates to <code class="hljs">"Hello, David"</code>, not just <code class="hljs">"David"</code>.</p>
<h2 id="loops"><a class="header" href="#loops">Loops</a></h2>
<p>Just as every program with mutable state can be rewritten to a program that passes the state as arguments, every loop can be rewritten as a recursive function.
From one perspective, <code class="hljs">List.find?</code> is most clear as a recursive function.
After all, its definition mirrors the structure of the list: if the head passes the check, then it should be returned; otherwise look in the tail.
When no more entries remain, the answer is <code class="hljs">none</code>.
From another perspective, <code class="hljs">List.find?</code> is most clear as a loop.
After all, the program consults the entries in order until a satisfactory one is found, at which point it terminates.
If the loop terminates without having returned, the answer is <code class="hljs">none</code>.</p>
<h3 id="looping-with-form"><a class="header" href="#looping-with-form">Looping with ForM</a></h3>
<p>Lean includes a type class that describes looping over a container type in some monad.
This class is called <code class="hljs">ForM</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">M</span> <span class="hljs-params">(m : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> v)</span> <span class="hljs-params">(Î³ : <span class="hljs-built_in">Type</span> wâ)</span> <span class="hljs-params">(Î± : outParam (<span class="hljs-built_in">Type</span> wâ)</span>)</span> <span class="hljs-keyword">where</span>
  forM [Monad m] : Î³ â (Î± â m PUnit) â m PUnit
</code></pre>
<p>This class is quite general.
The parameter <code class="hljs">m</code> is a monad with some desired effects, <code class="hljs">Î³</code> is the collection to be looped over, and <code class="hljs">Î±</code> is the type of elements from the collection.
Typically, <code class="hljs">m</code> is allowed to be any monad, but it is possible to have a data structure that e.g. only supports looping in <code class="hljs">IO</code>.
The method <code class="hljs">forM</code> takes a collection, a monadic action to be run for its effects on each element from the collection, and is then responsible for running the actions.</p>
<p>The instance for <code class="hljs">List</code> allows <code class="hljs">m</code> to be any monad, it sets <code class="hljs">Î³</code> to be <code class="hljs">List Î±</code>, and sets the class's <code class="hljs">Î±</code> to be the same <code class="hljs">Î±</code> found in the list:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">M</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-symbol">:</span></span> List Î± â (Î± â m PUnit) â m PUnit
  | [], _ =&gt; pure ()
  | x :: xs, action =&gt; <span class="hljs-keyword">do</span>
    action x
    forM xs action

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> ForM m (List Î±) Î± <span class="hljs-keyword">where</span>
  forM := List.forM
</code></pre>
<p>The <a href="https://leanprover.github.io/functional_programming_in_lean/monad-transformers/reader-io.html#implementation">function <code class="hljs">doList</code> from <code class="hljs">doug</code></a> is <code class="hljs">forM</code> for lists.
Because <code class="hljs">forM</code> is intended to be used in <code class="hljs">do</code>-blocks, it uses <code class="hljs">Monad</code> rather than <code class="hljs">Applicative</code>.
<code class="hljs">forM</code> can be used to make <code class="hljs">countLetters</code> much shorter:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span> <span class="hljs-params">(str : String)</span> <span class="hljs-symbol">:</span></span> StateT LetterCounts (Except Err) Unit :=
  forM str.toList <span class="hljs-keyword">fun</span> c =&gt; <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span> c.isAlpha <span class="hljs-keyword">then</span>
      <span class="hljs-keyword">if</span> vowels.contains c <span class="hljs-keyword">then</span>
        modify <span class="hljs-keyword">fun</span> st =&gt; {st <span class="hljs-keyword">with</span> vowels := st.vowels + <span class="hljs-number">1</span>}
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> consonants.contains c <span class="hljs-keyword">then</span>
        modify <span class="hljs-keyword">fun</span> st =&gt; {st <span class="hljs-keyword">with</span> consonants := st.consonants + <span class="hljs-number">1</span>}
    <span class="hljs-keyword">else</span> throw (.notALetter c)
</code></pre>
<p>The instance for <code class="hljs">Many</code> is very similar:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">M</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">y</span>.<span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">M</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-symbol">:</span></span> Many Î± â (Î± â m PUnit) â m PUnit
  | Many.none, _ =&gt; pure ()
  | Many.more first rest, action =&gt; <span class="hljs-keyword">do</span>
    action first
    forM (rest ()) action

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> ForM m (Many Î±) Î± <span class="hljs-keyword">where</span>
  forM := Many.forM
</code></pre>
<p>Because <code class="hljs">Î³</code> can be any type at all, <code class="hljs">ForM</code> can support non-polymorphic collections.
A very simple collection is one of the natural numbers less than some given number, in reverse order:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">A</span><span class="hljs-title">l</span><span class="hljs-title">l</span><span class="hljs-title">L</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">s</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">n</span></span> <span class="hljs-keyword">where</span>
  num : Nat
</code></pre>
<p>Its <code class="hljs">forM</code> operator applies the provided action to each smaller <code class="hljs">Nat</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">A</span><span class="hljs-title">l</span><span class="hljs-title">l</span><span class="hljs-title">L</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">s</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">n</span>.<span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">M</span> <span class="hljs-params">[Monad m]</span> <span class="hljs-params">(coll : AllLessThan)</span> <span class="hljs-params">(action : Nat â m Unit)</span> <span class="hljs-symbol">:</span></span> m Unit :=
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> countdown : Nat â m Unit
    | <span class="hljs-number">0</span> =&gt; pure ()
    | n + <span class="hljs-number">1</span> =&gt; <span class="hljs-keyword">do</span>
      action n
      countdown n
  countdown coll.num

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> ForM m AllLessThan Nat <span class="hljs-keyword">where</span>
  forM := AllLessThan.forM
</code></pre>
<p>Running <code class="hljs">IO.println</code> on each number less than five can be accomplished with <code class="hljs">forM</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> forM { num := <span class="hljs-number">5</span> : AllLessThan } IO.println
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">4
3
2
1
0
</code></pre>
<p>An example <code class="hljs">ForM</code> instance that works only in a particular monad is one that loops over the lines read from an IO stream, such as standard input:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">O</span><span class="hljs-title">f</span></span> <span class="hljs-keyword">where</span>
  stream : IO.FS.Stream

<span class="hljs-keyword">partial</span> <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">O</span><span class="hljs-title">f</span>.<span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">M</span> <span class="hljs-params">(readFrom : LinesOf)</span> <span class="hljs-params">(action : String â IO Unit)</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> line â readFrom.stream.getLine
  <span class="hljs-keyword">if</span> line == <span class="hljs-string">""</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> ()
  action line
  forM readFrom action

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> ForM IO LinesOf String <span class="hljs-keyword">where</span>
  forM := LinesOf.forM
</code></pre>
<p>The definition of <code class="hljs">forM</code> is marked <code class="hljs">partial</code> because there is no guarantee that the stream is finite.
In this case, <code class="hljs">IO.FS.Stream.getLine</code> works only in the <code class="hljs">IO</code> monad, so no other monad can be used for looping.</p>
<p>This example program uses this looping construct to filter out lines that don't contain letters:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">n</span> <span class="hljs-params">(argv : List String)</span> <span class="hljs-symbol">:</span></span> IO UInt32 := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">if</span> argv != [] <span class="hljs-keyword">then</span>
    IO.eprintln <span class="hljs-string">"Unexpected arguments"</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>

  forM (LinesOf.mk (â IO.getStdin)) <span class="hljs-keyword">fun</span> line =&gt; <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span> line.any (Â·.isAlpha) <span class="hljs-keyword">then</span>
      IO.print line

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
</code></pre>
<p>The file <code class="hljs">test-data</code> contains:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">Hello!
!!!!!
12345
abc123

Ok
</code></pre>
<p>Invoking this program, which is stored in <code class="hljs">ForMIO.lean</code>, yields the following output:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">$ lean --run ForMIO.lean &lt; test-data
Hello!
abc123
Ok
</code></pre>
<h3 id="stopping-iteration"><a class="header" href="#stopping-iteration">Stopping Iteration</a></h3>
<p>Terminating a loop early is difficult to do with <code class="hljs">forM</code>.
Writing a function that iterates over the <code class="hljs">Nat</code>s in an <code class="hljs">AllLessThan</code> only until <code class="hljs">3</code> is reached requires a means of stopping the loop partway through.
One way to achieve this is to use <code class="hljs">forM</code> with the <code class="hljs">OptionT</code> monad transformer.
The first step is to define <code class="hljs">OptionT.exec</code>, which discards information about both the return value and whether or not the transformed computation succeeded:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">O</span><span class="hljs-title">p</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">T</span>.<span class="hljs-title">e</span><span class="hljs-title">x</span><span class="hljs-title">e</span><span class="hljs-title">c</span> <span class="hljs-params">[Applicative m]</span> <span class="hljs-params">(action : OptionT m Î±)</span> <span class="hljs-symbol">:</span></span> m Unit :=
  action *&gt; pure ()
</code></pre>
<p>Then, failure in the <code class="hljs">OptionT</code> instance of <code class="hljs">Alternative</code> can be used to terminate looping early:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">T</span><span class="hljs-title">o</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span> IO Unit :=
  <span class="hljs-keyword">let</span> nums : AllLessThan := â¨nâ©
  OptionT.exec (forM nums <span class="hljs-keyword">fun</span> i =&gt; <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">3</span> <span class="hljs-keyword">then</span> failure <span class="hljs-keyword">else</span> IO.println i)
</code></pre>
<p>A quick test demonstrates that this solution works:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> countToThree <span class="hljs-number">7</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">6
5
4
3
</code></pre>
<p>However, this code is not so easy to read.
Terminating a loop early is a common task, and Lean provides more syntactic sugar to make this easier.
This same function can also be written as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">T</span><span class="hljs-title">o</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> nums : AllLessThan := â¨nâ©
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">3</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">break</span>
    IO.println i
</code></pre>
<p>Testing it reveals that it works just like the prior version:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> countToThree <span class="hljs-number">7</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">6
5
4
3
</code></pre>
<p>At the time of writing, the <code class="hljs">for ... in ... do ...</code> syntax desugars to the use of a type class called <code class="hljs">ForIn</code>, which is a somewhat more complicated version of <code class="hljs">ForM</code> that keeps track of state and early termination.
However, there is a plan to refactor <code class="hljs">for</code> loops to use the simpler <code class="hljs">ForM</code>, with monad transformers inserted as necessary.
In the meantime, an adapter is provided that converts a <code class="hljs">ForM</code> instance into a <code class="hljs">ForIn</code> instance, called <code class="hljs">ForM.forIn</code>.
To enable <code class="hljs">for</code> loops based on a <code class="hljs">ForM</code> instance, add something like the following, with appropriate replacements for <code class="hljs">AllLessThan</code> and <code class="hljs">Nat</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> ForIn m AllLessThan Nat <span class="hljs-keyword">where</span>
  forIn := ForM.forIn
</code></pre>
<p>Note, however, that this adapter only works for <code class="hljs">ForM</code> instances that keep the monad unconstrained, as most of them do.
This is because the adapter uses <code class="hljs">StateT</code> and <code class="hljs">ExceptT</code>, rather than the underlying monad.</p>
<p>Early return is supported in <code class="hljs">for</code> loops.
The translation of <code class="hljs">do</code> blocks with early return into a use of an exception monad transformer applies equally well underneath <code class="hljs">forM</code> as the earlier use of <code class="hljs">OptionT</code> to halt iteration does.
This version of <code class="hljs">List.find?</code> makes use of both:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d?</span> <span class="hljs-params">(p : Î± â Bool)</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Option Î± := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> xs <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span> p x <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> x
  failure
</code></pre>
<p>In addition to <code class="hljs">break</code>, <code class="hljs">for</code> loops support <code class="hljs">continue</code> to skip the rest of the loop body in an iteration.
An alternative (but confusing) formulation of <code class="hljs">List.find?</code> skips elements that don't satisfy the check:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d?</span> <span class="hljs-params">(p : Î± â Bool)</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Option Î± := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> xs <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span> not (p x) <span class="hljs-keyword">then</span> <span class="hljs-keyword">continue</span>
    <span class="hljs-keyword">return</span> x
  failure
</code></pre>
<p>A <code class="hljs">Range</code> is a structure that consists of a starting number, an ending number, and a step.
They represent a sequence of natural numbers, from the starting number to the ending number, increasing by the step each time.
Lean has special syntax to construct ranges, consisting of square brackets, numbers, and colons that comes in four varieties.
The stopping point must always be provided, while the start and the step are optional, defaulting to <code class="hljs">0</code> and <code class="hljs">1</code>, respectively:</p>
<table><thead><tr><th>Expression</th><th>Start</th><th>Stop</th><th>Step</th><th>As List</th></tr></thead><tbody>
<tr><td><code class="hljs">[:10]</code></td><td><code class="hljs">0</code></td><td><code class="hljs">10</code></td><td><code class="hljs">1</code></td><td><code class="hljs">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></td></tr>
<tr><td><code class="hljs">[2:10]</code></td><td><code class="hljs">2</code></td><td><code class="hljs">10</code></td><td><code class="hljs">1</code></td><td><code class="hljs">[2, 3, 4, 5, 6, 7, 8, 9]</code></td></tr>
<tr><td><code class="hljs">[:10:3]</code></td><td><code class="hljs">0</code></td><td><code class="hljs">10</code></td><td><code class="hljs">3</code></td><td><code class="hljs">[0, 3, 6, 9]</code></td></tr>
<tr><td><code class="hljs">[2:10:3]</code></td><td><code class="hljs">2</code></td><td><code class="hljs">10</code></td><td><code class="hljs">3</code></td><td><code class="hljs">[2, 5, 8]</code></td></tr>
</tbody></table>
<p>Note that the starting number <em>is</em> included in the range, while the stopping numbers is not.
All three arguments are <code class="hljs">Nat</code>s, which means that ranges cannot count downâa range where the starting number is greater than or equal to the stopping number simply contains no numbers.</p>
<p>Ranges can be used with <code class="hljs">for</code> loops to draw numbers from the range.
This program counts even numbers from four to eight:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">T</span><span class="hljs-title">o</span><span class="hljs-title">E</span><span class="hljs-title">i</span><span class="hljs-title">g</span><span class="hljs-title">h</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">4</span>:<span class="hljs-number">9</span>:<span class="hljs-number">2</span>] <span class="hljs-keyword">do</span>
    IO.println i
</code></pre>
<p>Running it yields:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">4
6
8
</code></pre>
<p>Finally, <code class="hljs">for</code> loops support iterating over multiple collections in parallel, by separating the <code class="hljs">in</code> clauses with commas.
Looping halts when the first collection runs out of elements, so the declaration:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-title">a</span><span class="hljs-title">r</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">L</span><span class="hljs-title">o</span><span class="hljs-title">o</span><span class="hljs-title">p</span> <span class="hljs-symbol">:</span></span>= <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-string">"currant"</span>, <span class="hljs-string">"gooseberry"</span>, <span class="hljs-string">"rowan"</span>], y <span class="hljs-keyword">in</span> [<span class="hljs-number">4</span>:<span class="hljs-number">8</span>] <span class="hljs-keyword">do</span>
    IO.println (x, y)
</code></pre>
<p>produces three lines of output:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> parallelLoop
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">(currant, 4)
(gooseberry, 5)
(rowan, 6)
</code></pre>
<h2 id="mutable-variables"><a class="header" href="#mutable-variables">Mutable Variables</a></h2>
<p>In addition to early <code class="hljs">return</code>, <code class="hljs">else</code>-less <code class="hljs">if</code>, and <code class="hljs">for</code> loops, Lean supports local mutable variables within a <code class="hljs">do</code> block.
Behind the scenes, these mutable variables desugar to a use of <code class="hljs">StateT</code>, rather than being implemented by true mutable variables.
Once again, functional programming is used to simulate imperative programming.</p>
<p>A local mutable variable is introduced with <code class="hljs">let mut</code> instead of plain <code class="hljs">let</code>.
The definition <code class="hljs">two</code>, which uses the identity monad <code class="hljs">Id</code> to enable <code class="hljs">do</code>-syntax without introducing any effects, counts to <code class="hljs">2</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">tw</span><span class="hljs-title">o</span> <span class="hljs-symbol">:</span></span> Nat := Id.run <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x := <span class="hljs-number">0</span>
  x := x + <span class="hljs-number">1</span>
  x := x + <span class="hljs-number">1</span>
  <span class="hljs-keyword">return</span> x
</code></pre>
<p>This code is equivalent to a definition that uses <code class="hljs">StateT</code> to add <code class="hljs">1</code> twice:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">tw</span><span class="hljs-title">o</span> <span class="hljs-symbol">:</span></span> Nat :=
  <span class="hljs-keyword">let</span> block : StateT Nat Id Nat := <span class="hljs-keyword">do</span>
    modify (Â· + <span class="hljs-number">1</span>)
    modify (Â· + <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> (â get)
  <span class="hljs-keyword">let</span> (result, _finalState) := block <span class="hljs-number">0</span>
  result
</code></pre>
<p>Local mutable variables work well with all the other features of <code class="hljs">do</code>-notation that provide convenient syntax for monad transformers.
The definition <code class="hljs">three</code> counts the number of entries in a three-entry list:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Nat := Id.run <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x := <span class="hljs-number">0</span>
  <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">do</span>
    x := x + <span class="hljs-number">1</span>
  <span class="hljs-keyword">return</span> x
</code></pre>
<p>Similarly, <code class="hljs">six</code> adds the entries in a list:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">x</span> <span class="hljs-symbol">:</span></span> Nat := Id.run <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x := <span class="hljs-number">0</span>
  <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">do</span>
    x := x + y
  <span class="hljs-keyword">return</span> x
</code></pre>
<p><code class="hljs">List.count</code> counts the number of entries in a list that satisfy some check:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-params">(p : Î± â Bool)</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Nat := Id.run <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> found := <span class="hljs-number">0</span>
  <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> xs <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span> p x <span class="hljs-keyword">then</span> found := found + <span class="hljs-number">1</span>
  <span class="hljs-keyword">return</span> found
</code></pre>
<p>Local mutable variables can be more convenient to use and easier to read than an explicit local use of <code class="hljs">StateT</code>.
However, they don't have the full power of unrestricted mutable variables from imperative languages.
In particular, they can only be modified in the <code class="hljs">do</code>-block in which they are introduced.
This means, for instance, that <code class="hljs">for</code>-loops can't be replaced by otherwise-equivalent recursive helper functions.
This version of <code class="hljs">List.count</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-params">(p : Î± â Bool)</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> Nat := Id.run <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> found := <span class="hljs-number">0</span>
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> go : List Î± â Id Unit
    | [] =&gt; pure ()
    | y :: ys =&gt; <span class="hljs-keyword">do</span>
      <span class="hljs-keyword">if</span> p y <span class="hljs-keyword">then</span> found := found + <span class="hljs-number">1</span>
      go ys
  <span class="hljs-keyword">return</span> found
</code></pre>
<p>yields the following error on the attempted mutation of <code class="hljs">found</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">`found` cannot be mutated, only variables declared using `let mut` can be mutated. If you did not intent to mutate but define `found`, consider using `let found` instead
</code></pre>
<p>This is because the recursive function is written in the identity monad, and only the monad of the <code class="hljs">do</code>-block in which the variable is introduced is transformed with <code class="hljs">StateT</code>.</p>
<h2 id="what-counts-as-a-do-block"><a class="header" href="#what-counts-as-a-do-block">What counts as a <code>do</code> block?</a></h2>
<p>Many features of <code class="hljs">do</code>-notation apply only to a single <code class="hljs">do</code>-block.
Early return terminates the current block, and mutable variables can only be mutated in the block that they are defined in.
To use them effectively, it's important to know what counts as "the same block".</p>
<p>Generally speaking, the indented block following the <code class="hljs">do</code> keyword counts as a block, and the immediate sequence of statements underneath it are part of that block.
Statements in independent blocks that are nonetheless contained in a block are not considered part of the block.
However, the rules that govern what exactly counts as the same block are slightly subtle, so some examples are in order.
The precise nature of the rules can be tested by setting up a program with a mutable variable and seeing where the mutation is allowed.
This program has a mutation that is clearly in the same block as the mutable variable:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : Id Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x := <span class="hljs-number">0</span>
  x := x + <span class="hljs-number">1</span>
</code></pre>
<p>When a mutation occurs in a <code class="hljs">do</code>-block that is part of a <code class="hljs">let</code>-statement that defines a name using <code class="hljs">:=</code>, then it is not considered to be part of the block:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : Id Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x := <span class="hljs-number">0</span>
  <span class="hljs-keyword">let</span> other := <span class="hljs-keyword">do</span>
    x := x + <span class="hljs-number">1</span>
  other
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">`x` cannot be mutated, only variables declared using `let mut` can be mutated. If you did not intent to mutate but define `x`, consider using `let x` instead
</code></pre>
<p>However, a <code class="hljs">do</code>-block that occurs under a <code class="hljs">let</code>-statement that defines a name using <code class="hljs">â</code> is considered part of the surrounding block.
The following program is accepted:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : Id Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x := <span class="hljs-number">0</span>
  <span class="hljs-keyword">let</span> other â <span class="hljs-keyword">do</span>
    x := x + <span class="hljs-number">1</span>
  pure other
</code></pre>
<p>Similarly, <code class="hljs">do</code>-blocks that occur as arguments to functions are independent of their surrounding blocks.
The following program is not accepted:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : Id Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x := <span class="hljs-number">0</span>
  <span class="hljs-keyword">let</span> addFour (y : Id Nat) := Id.run y + <span class="hljs-number">4</span>
  addFour <span class="hljs-keyword">do</span>
    x := <span class="hljs-number">5</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">`x` cannot be mutated, only variables declared using `let mut` can be mutated. If you did not intent to mutate but define `x`, consider using `let x` instead
</code></pre>
<p>If the <code class="hljs">do</code> keyword is completely redundant, then it does not introduce a new block.
This program is accepted, and is equivalent to the first one in this section:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : Id Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x := <span class="hljs-number">0</span>
  <span class="hljs-keyword">do</span> x := x + <span class="hljs-number">1</span>
</code></pre>
<p>The contents of branches under a <code class="hljs">do</code> (such as those introduced by <code class="hljs">match</code> or <code class="hljs">if</code>) are considered to be part of the surrounding block, whether or not a redundant <code class="hljs">do</code> is added.
The following programs are all accepted:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : Id Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x := <span class="hljs-number">0</span>
  <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">2</span> <span class="hljs-keyword">then</span>
    x := x + <span class="hljs-number">1</span>

<span class="hljs-keyword">example</span> : Id Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x := <span class="hljs-number">0</span>
  <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">2</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">do</span>
    x := x + <span class="hljs-number">1</span>

<span class="hljs-keyword">example</span> : Id Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x := <span class="hljs-number">0</span>
  <span class="hljs-keyword">match</span> true <span class="hljs-keyword">with</span>
  | true =&gt; x := x + <span class="hljs-number">1</span>
  | false =&gt; x := <span class="hljs-number">17</span>

<span class="hljs-keyword">example</span> : Id Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x := <span class="hljs-number">0</span>
  <span class="hljs-keyword">match</span> true <span class="hljs-keyword">with</span>
  | true =&gt; <span class="hljs-keyword">do</span>
    x := x + <span class="hljs-number">1</span>
  | false =&gt; <span class="hljs-keyword">do</span>
    x := <span class="hljs-number">17</span>
</code></pre>
<p>Similarly, the <code class="hljs">do</code> that occurs as part of the <code class="hljs">for</code> and <code class="hljs">unless</code> syntax is just part of their syntax, and does not introduce a fresh <code class="hljs">do</code>-block.
These programs are also accepted:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : Id Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x := <span class="hljs-number">0</span>
  <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>:<span class="hljs-number">5</span>] <span class="hljs-keyword">do</span>
   x := x + y

<span class="hljs-keyword">example</span> : Id Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x := <span class="hljs-number">0</span>
  <span class="hljs-keyword">unless</span> <span class="hljs-number">1</span> &lt; <span class="hljs-number">5</span> <span class="hljs-keyword">do</span>
    x := x + <span class="hljs-number">1</span>
</code></pre>
<h2 id="imperative-or-functional-programming"><a class="header" href="#imperative-or-functional-programming">Imperative or Functional Programming?</a></h2>
<p>The imperative features provided by Lean's <code class="hljs">do</code>-notation allow many programs to very closely resemble their counterparts in languages like Rust, Java, or C#.
This resemblance is very convenient when translating an imperative algorithm into Lean, and some tasks are just most naturally thought of imperatively.
The introduction of monads and monad transformers enables imperative programs to be written in purely functional languages, and <code class="hljs">do</code>-notation as a specialized syntax for monads (potentially locally transformed) allows functional programmers to have the best of both worlds: the strong reasoning principles afforded by immutability and a tight control over available effects through the type system are combined with syntax and libraries that allow programs that use effects to look familiar and be easy to read.
Monads and monad transformers allow functional versus imperative programming to be a matter of perspective.</p>
<h2 id="exercises-17"><a class="header" href="#exercises-17">Exercises</a></h2>
<ul>
<li>Rewrite <code class="hljs">doug</code> to use <code class="hljs">for</code> instead of the <code class="hljs">doList</code> function. Are there other opportunities to use the features introduced in this section to improve the code? If so, use them!</li>
</ul>
<div style="break-before:page;page-break-before:always"></div><h1 id="additional-conveniences-4"><a class="header" href="#additional-conveniences-4">Additional Conveniences</a></h1>
<h2 id="pipe-operators"><a class="header" href="#pipe-operators">Pipe Operators</a></h2>
<p>Functions are normally written before their arguments.
When reading a program from left to right, this promotes a view in which the function's <em>output</em> is paramountâthe function has a goal to achieve (that is, a value to compute), and it receives arguments to support it in this process.
But some programs are easier to understand in terms of an input that is successively refined to produce the output.
For these situations, Lean provides a <em>pipeline</em> operator which is similar to the that provided by F#.
Pipeline operators are useful in the same situations as Clojure's threading macros.</p>
<p>The pipeline <code class="hljs">E1 |&gt; E2</code> is short for <code class="hljs">E2 E1</code>.
For example, evaluating:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> some <span class="hljs-number">5</span> |&gt; toString
</code></pre>
<p>results in:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">"(some 5)"
</code></pre>
<p>While this change of emphasis can make some programs more convenient to read, pipelines really come into their own when they contain many components.</p>
<p>With the definition:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">s3</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span> Nat := n * <span class="hljs-number">3</span>
</code></pre>
<p>the following pipeline:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> <span class="hljs-number">5</span> |&gt; times3 |&gt; toString |&gt; (<span class="hljs-string">"It is "</span> ++ Â·)
</code></pre>
<p>yields:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">"It is 15"
</code></pre>
<p>More generally, a series of pipelines <code class="hljs">E1 |&gt; E2 |&gt; E3 |&gt; E4</code> is short for nested function applications <code class="hljs">E4 (E3 (E2 E1))</code>.</p>
<p>Pipelines may also be written in reverse.
In this case, they do not place the subject of data transformation first; however, in cases where many nested parentheses pose a challenge for readers, they can clarify the steps of application.
The prior example could be equivalently written as:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (<span class="hljs-string">"It is "</span> ++ Â·) &lt;| toString &lt;| times3 &lt;| <span class="hljs-number">5</span>
</code></pre>
<p>which is short for:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (<span class="hljs-string">"It is "</span> ++ Â·) (toString (times3 <span class="hljs-number">5</span>))
</code></pre>
<p>Lean's method dot notation that uses the name of the type before the dot to resolve the namespace of the operator after the dot serves a similar purpose to pipelines.
Even without the pipeline operator, it is possible to write <code class="hljs">[1, 2, 3].reverse</code> instead of <code class="hljs">List.reverse [1, 2, 3]</code>.
However, the pipeline operator is also useful for dotted functions when using many of them.
<code class="hljs">([1, 2, 3].reverse.drop 1).reverse</code> can also be written as <code class="hljs">[1, 2, 3] |&gt; List.reverse |&gt; List.drop 1 |&gt; List.reverse</code>.
This version avoids having to parenthesize expressions simply because they accept arguments, and it recovers the convenience of a chain of method calls in languages like Kotlin or C#.
However, it still requires the namespace to be provided by hand.
As a final convenience, Lean provides the "pipeline dot" operator, which groups functions like the pipeline but uses the name of the type to resolve namespaces.
With "pipeline dot", the example can be rewritten to <code class="hljs">[1, 2, 3] |&gt;.reverse |&gt;.drop 1 |&gt;.reverse</code>.</p>
<h2 id="infinite-loops"><a class="header" href="#infinite-loops">Infinite Loops</a></h2>
<p>Within a <code class="hljs">do</code>-block, the <code class="hljs">repeat</code> keyword introduces an infinite loop.
For example, a program that spams the string <code class="hljs">"Spam!"</code> can use it:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">p</span><span class="hljs-title">a</span><span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  repeat IO.println <span class="hljs-string">"Spam!"</span>
</code></pre>
<p>A <code class="hljs">repeat</code> loop supports <code class="hljs">break</code> and <code class="hljs">continue</code>, just like <code class="hljs">for</code> loops.</p>
<p>The <code class="hljs">dump</code> function from the <a href="https://leanprover.github.io/functional_programming_in_lean/hello-world/cat.html#streams">implementation of <code class="hljs">feline</code></a> uses a recursive function to run forever:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">partial</span> <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">p</span> <span class="hljs-params">(stream : IO.FS.Stream)</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> buf â stream.read bufsize
  <span class="hljs-keyword">if</span> buf.isEmpty <span class="hljs-keyword">then</span>
    pure ()
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">let</span> stdout â IO.getStdout
    stdout.write buf
    dump stream
</code></pre>
<p>This function can be greatly shortened using <code class="hljs">repeat</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">p</span> <span class="hljs-params">(stream : IO.FS.Stream)</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> stdout â IO.getStdout
  repeat <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">let</span> buf â stream.read bufsize
    <span class="hljs-keyword">if</span> buf.isEmpty <span class="hljs-keyword">then</span> <span class="hljs-keyword">break</span>
    stdout.write buf
</code></pre>
<p>Neither <code class="hljs">spam</code> nor <code class="hljs">dump</code> need to be declared as <code class="hljs">partial</code> because they are not themselves infinitely recursive.
Instead, <code class="hljs">repeat</code> makes use of a type whose <code class="hljs">ForM</code> instance is <code class="hljs">partial</code>.
Partiality does not "infect" calling functions.</p>
<h2 id="while-loops"><a class="header" href="#while-loops">While Loops</a></h2>
<p>When programming with local mutability, <code class="hljs">while</code> loops can be a convenient alternative to <code class="hljs">repeat</code> with an <code class="hljs">if</code>-guarded <code class="hljs">break</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">p</span> <span class="hljs-params">(stream : IO.FS.Stream)</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> stdout â IO.getStdout
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> buf â stream.read bufsize
  <span class="hljs-keyword">while</span> not buf.isEmpty <span class="hljs-keyword">do</span>
    stdout.write buf
    buf â stream.read bufsize
</code></pre>
<p>Behind the scenes, <code class="hljs">while</code> is just a simpler notation for <code class="hljs">repeat</code>.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="summary-5"><a class="header" href="#summary-5">Summary</a></h1>
<h2 id="combining-monads"><a class="header" href="#combining-monads">Combining Monads</a></h2>
<p>When writing a monad from scratch, there are design patterns that tend to describe the ways that each effect is added to the monad.
Reader effects are added by having the monad's type be a function from the reader's environment, state effects are added by including a function from the initial state to the value paired with the final state, failure or exceptions are added by including a sum type in the return type, and logging or other output is added by including a product type in the return type.
Existing monads can be made part of the return type as well, allowing their effects to be included in the new monad.</p>
<p>These design patterns are made into a library of reusable software components by defining <em>monad transformers</em>, which add an effect to some base monad.
Monad transformers take the simpler monad types as arguments, returning the enhanced monad types.
At a minimum, a monad transformer should provide the following instances:</p>
<ol>
<li>A <code class="hljs">Monad</code> instance that assumes the inner type is already a monad</li>
<li>A <code class="hljs">MonadLift</code> instance to translate an action from the inner monad to the transformed monad</li>
</ol>
<p>Monad transformers may be implemented as polymorphic structures or inductive datatypes, but they are most often implemented as functions from the underlying monad type to the enhanced monad type.</p>
<h2 id="type-classes-for-effects"><a class="header" href="#type-classes-for-effects">Type Classes for Effects</a></h2>
<p>A common design pattern is to implement a particular effect by defining a monad that has the effect, a monad transformer that adds it to another monad, and a type class that provides a generic interface to the effect.
This allows programs to be written that merely specify which effects they need, so the caller can provide any monad that has the right effects.</p>
<p>Sometimes, auxiliary type information (e.g. the state's type in a monad that provides state, or the exception's type in a monad that provides exceptions) is an output parameter, and sometimes it is not.
The output parameter is most useful for simple programs that use each kind of effect only once, but it risks having the type checker commit to a the wrong type too early when multiple instances of the same effect are used in a given program.
Thus, both versions are typically provided, with the ordinary-parameter version of the type class having a name that ends in <code class="hljs">-Of</code>.</p>
<h2 id="monad-transformers-dont-commute"><a class="header" href="#monad-transformers-dont-commute">Monad Transformers Don't Commute</a></h2>
<p>It is important to note that changing the order of transformers in a monad can change the meaning of programs that use the monad.
For instance, re-ordering <code class="hljs">StateT</code> and <code class="hljs">ExceptT</code> can result either in programs that lose state modifications when exceptions are thrown or programs that keep changes.
While most imperative languages provide only the latter, the increased flexibility provided by monad transformers demands thought and attention to choose the correct variety for the task at hand.</p>
<h2 id="do-notation-for-monad-transformers"><a class="header" href="#do-notation-for-monad-transformers"><code>do</code>-Notation for Monad Transformers</a></h2>
<p>Lean's <code class="hljs">do</code>-blocks support early return, in which the block is terminated with some value, locally mutable variables, <code class="hljs">for</code>-loops with <code class="hljs">break</code> and <code class="hljs">continue</code>, and single-branched <code class="hljs">if</code>-statements.
While this may seem to be introducing imperative features that would get in the way of using Lean to write proofs, it is in fact nothing more than a more convenient syntax for certain common uses of monad transformers.
Behind the scenes, whatever monad the <code class="hljs">do</code>-block is written in is transformed by appropriate uses of <code class="hljs">ExceptT</code> and <code class="hljs">StateT</code> to support these additional effects.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="programming-with-dependent-types"><a class="header" href="#programming-with-dependent-types">Programming with Dependent Types</a></h1>
<p>In most statically-typed programming languages, there is a hermetic seal between the world of types and the world of programs.
Types and programs have different grammars and they are used at different times.
Types are typically used at compile time, to check that a program obeys certain invariants.
Programs are used at run time, to actually perform computations.
When the two interact, it is usually in the form of a type-case operator like an "instance-of" check or a casting operator that provides the type checker with information that was otherwise unavailable, to be verified at run time.
In other words, the interaction consists of types being inserted into the world of programs, gaining some limited run-time meaning.</p>
<p>Lean does not impose this strict separation.
In Lean, programs may compute types and types may contain programs.
Placing programs in types allows their full computation power to be used at compile time, and the ability to return types from functions makes types into first-class participants in the programming process.</p>
<p><em>Dependent types</em> are types that contain non-type expressions.
A common source of dependent types is a named argument to a function.
For example, the function <code class="hljs">natOrStringThree</code> returns either a natural number or a string, depending on which <code class="hljs">Bool</code> it is passed:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">n</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">O</span><span class="hljs-title">r</span><span class="hljs-title">S</span><span class="hljs-title">t</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">g</span><span class="hljs-title">T</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span> <span class="hljs-params">(b : Bool)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-keyword">if</span> b <span class="hljs-keyword">then</span> Nat <span class="hljs-keyword">else</span> String :=
  <span class="hljs-keyword">match</span> b <span class="hljs-keyword">with</span>
  | true =&gt; (<span class="hljs-number">3</span> : Nat)
  | false =&gt; <span class="hljs-string">"three"</span>
</code></pre>
<p>Further examples of dependent types include:</p>
<ul>
<li><a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/polymorphism.html">The introductory section on polymorphism</a> contains <code class="hljs">posOrNegThree</code>, in which the function's return type depends on the value of the argument.</li>
<li><a href="https://leanprover.github.io/functional_programming_in_lean/type-classes/pos.html#literal-numbers">The <code class="hljs">OfNat</code> type class</a> depends on the specific natural number literal being used.</li>
<li><a href="https://leanprover.github.io/functional_programming_in_lean/functor-applicative-monad/applicative.html#validated-input">The <code class="hljs">CheckedInput</code> structure</a> used in the example of validators depends on the year in which validation occurred.</li>
<li><a href="https://leanprover.github.io/functional_programming_in_lean/functor-applicative-monad/applicative.html#subtypes">Subtypes</a> contain propositions that refer to particular values.</li>
<li>Essentially all interesting propositions, including those that determine the validity of <a href="https://leanprover.github.io/functional_programming_in_lean/props-proofs-indexing.html">array indexing notation</a>, are types that contain values and are thus dependent types.</li>
</ul>
<p>Dependent types vastly increase the power of a type system.
The flexibility of return types that branch on argument values enables programs to be written that cannot easily be given types in other type systems.
At the same time, dependent types allow a type signature to restrict which values may be returned from a function, enabling strong invariants to be enforced at compile time.</p>
<p>However, programming with dependent types can be quite complex, and it requires a whole set of skills above and beyond functional programming.
Expressive specifications can be complicated to fulfill, and there is a real risk of tying oneself in knots and being unable to complete the program.
On the other hand, this process can lead to new understanding, which can be expressed in a refined type that can be fulfilled.
While this chapter scratches the surface of dependently typed programming, it is a deep topic that deserves an entire book of its own.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="indexed-families"><a class="header" href="#indexed-families">Indexed Families</a></h1>
<p>Polymorphic inductive types take type arguments.
For instance, <code class="hljs">List</code> takes an argument that determines the type of the entries in the list, and <code class="hljs">Except</code> takes arguments that determine the types of the exceptions or values.
These type arguments, which are the same in every constructor of the datatype, are referred to as <em>parameters</em>.</p>
<p>Arguments to inductive types need not be the same in every constructor, however.
Inductive types in which the arguments to the type vary based on the choice of constructor are called <em>indexed families</em>, and the arguments that vary are referred to as <em>indices</em>.
The "hello world" of indexed families is a type of lists that contains the length of the list in addition to the type of entries, conventionally referred to as "vectors":</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Vect (Î± : <span class="hljs-built_in">Type</span> u) : Nat â <span class="hljs-built_in">Type</span> u <span class="hljs-keyword">where</span>
   | nil : Vect Î± <span class="hljs-number">0</span>
   | cons : Î± â Vect Î± n â Vect Î± (n + <span class="hljs-number">1</span>)
</code></pre>
<p>Function declarations may take some arguments before the colon, indicating that they are available in the entire definition, and some arguments after, indicating a desire to pattern-match on them and define the function case by case.
Inductive datatypes have a similar principle: the argument <code class="hljs">Î±</code> is named at the top of the datatype declaration, prior to the colon, which indicates that it is a parameter that must be provided as the first argument in all occurrences of <code class="hljs">Vect</code> in the definition, while the <code class="hljs">Nat</code> argument occurs after the colon, indicating that it is an index that may vary.
Indeed, the three occurrences of <code class="hljs">Vect</code> in the <code class="hljs">nil</code> and <code class="hljs">cons</code> constructor declarations consistently provide <code class="hljs">Î±</code> as the first argument, while the second argument is different in each case.</p>
<p>The declaration of <code class="hljs">nil</code> states that it is a constructor of type <code class="hljs">Vect Î± 0</code>.
This means that using <code class="hljs">Vect.nil</code> in a context expecting a <code class="hljs">Vect String 3</code> is a type error, just as <code class="hljs">[1, 2, 3]</code> is a type error in a context that expects a <code class="hljs">List String</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : Vect String <span class="hljs-number">3</span> := Vect.nil
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">type mismatch
  Vect.nil
has type
  Vect String 0 : Type
but is expected to have type
  Vect String 3 : Type
</code></pre>
<p>The mismatch between <code class="hljs">0</code> and <code class="hljs">3</code> in this example plays exactly the same role as any other type mismatch, even though <code class="hljs">0</code> and <code class="hljs">3</code> are not themselves types.</p>
<p>Indexed families are called <em>families</em> of types because different index values can make different constructors available for use.
In some sense, an indexed family is not a type; rather, it is a collection of related types, and the choice of index values also chooses a type from the collection.
Choosing the index <code class="hljs">5</code> for <code class="hljs">Vect</code> means that only the constructor <code class="hljs">cons</code> is available, and choosing the index <code class="hljs">0</code> means that only <code class="hljs">nil</code> is available.</p>
<p>If the index is not yet known (e.g. because it is a variable), then no constructor can be used until it becomes known.
Using <code class="hljs">n</code> for the length allows neither <code class="hljs">Vect.nil</code> nor <code class="hljs">Vect.cons</code>, because there's no way to know whether the variable <code class="hljs">n</code> should stand for a <code class="hljs">Nat</code> that matches <code class="hljs">0</code> or <code class="hljs">n + 1</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : Vect String n := Vect.nil
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">type mismatch
  Vect.nil
has type
  Vect String 0 : Type
but is expected to have type
  Vect String n : Type
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : Vect String n := Vect.cons <span class="hljs-string">"Hello"</span> (Vect.cons <span class="hljs-string">"world"</span> Vect.nil)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">type mismatch
  Vect.cons "Hello" (Vect.cons "world" Vect.nil)
has type
  Vect String (0 + 1 + 1) : Type
but is expected to have type
  Vect String n : Type
</code></pre>
<p>Having the length of the list as part of its type means that the type becomes more informative.
For example, <code class="hljs">Vect.replicate</code> is a function that creates a <code class="hljs">Vect</code> with a number of copies of a given value.
The type that says this precisely is:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">V</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">t</span>.<span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-params">(x : Î±)</span> <span class="hljs-symbol">:</span></span> Vect Î± n := _
</code></pre>
<p>The argument <code class="hljs">n</code> appears as the length of the result.
The message associated with the underscore placeholder describes the task at hand:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Î± : Type u_1
n : Nat
x : Î±
â¢ Vect Î± n
</code></pre>
<p>When working with indexed families, constructors can only be applied when Lean can see that the constructor's index matches the index in the expected type.
However, neither constructor has an index that matches <code class="hljs">n</code>â<code class="hljs">nil</code> matches <code class="hljs">Nat.zero</code>, and <code class="hljs">cons</code> matches <code class="hljs">Nat.succ</code>.
Just as in the example type errors, the variable <code class="hljs">n</code> could stand for either, depending on which <code class="hljs">Nat</code> is provided to the function as an argument.
The solution is to use pattern matching to consider both of the possible cases:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">V</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">t</span>.<span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-params">(x : Î±)</span> <span class="hljs-symbol">:</span></span> Vect Î± n :=
  <span class="hljs-keyword">match</span> n <span class="hljs-keyword">with</span>
  | <span class="hljs-number">0</span> =&gt; _
  | k + <span class="hljs-number">1</span> =&gt; _
</code></pre>
<p>Because <code class="hljs">n</code> occurs in the expected type, pattern matching on <code class="hljs">n</code> <em>refines</em> the expected type in the two cases of the match.
In the first underscore, the expected type has become <code class="hljs">Vect Î± 0</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Î± : Type u_1
n : Nat
x : Î±
â¢ Vect Î± 0
</code></pre>
<p>In the second underscore, it has become <code class="hljs">Vect Î± (k + 1)</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Î± : Type u_1
n : Nat
x : Î±
k : Nat
â¢ Vect Î± (k + 1)
</code></pre>
<p>When pattern matching refines the type of a program in addition to discovering the structure of a value, it is called <em>dependent pattern matching</em>.</p>
<p>The refined type makes it possible to apply the constructors.
The first underscore matches <code class="hljs">Vect.nil</code>, and the second matches <code class="hljs">Vect.cons</code>: </p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">V</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">t</span>.<span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-params">(x : Î±)</span> <span class="hljs-symbol">:</span></span> Vect Î± n :=
  <span class="hljs-keyword">match</span> n <span class="hljs-keyword">with</span>
  | <span class="hljs-number">0</span> =&gt; .nil
  | k + <span class="hljs-number">1</span> =&gt; .cons _ _
</code></pre>
<p>The first underscore under the <code class="hljs">.cons</code> should have type <code class="hljs">Î±</code>.
There is an <code class="hljs">Î±</code> available, namely <code class="hljs">x</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Î± : Type u_1
n : Nat
x : Î±
k : Nat
â¢ Î±
</code></pre>
<p>The second underscore should be a <code class="hljs">Vect Î± k</code>, which can be produced by a recursive call to <code class="hljs">replicate</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Î± : Type u_1
n : Nat
x : Î±
k : Nat
â¢ Vect Î± k
</code></pre>
<p>Here is the final definition of <code class="hljs">replicate</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">V</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">t</span>.<span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-params">(x : Î±)</span> <span class="hljs-symbol">:</span></span> Vect Î± n :=
  <span class="hljs-keyword">match</span> n <span class="hljs-keyword">with</span>
  | <span class="hljs-number">0</span> =&gt; .nil
  | k + <span class="hljs-number">1</span> =&gt; .cons x (replicate k x)
</code></pre>
<p>In addition to providing assistance while writing the function, the informative type of <code class="hljs">Vect.replicate</code> also allows client code to rule out a number of unexpected functions without having to read the source code.
A version of <code class="hljs">replicate</code> for lists could produce a list of the wrong length:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-params">(x : Î±)</span> <span class="hljs-symbol">:</span></span> List Î± :=
  <span class="hljs-keyword">match</span> n <span class="hljs-keyword">with</span>
  | <span class="hljs-number">0</span> =&gt; []
  | k + <span class="hljs-number">1</span> =&gt; x :: x :: replicate k x
</code></pre>
<p>However, making this mistake with <code class="hljs">Vect.replicate</code> is a type error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">V</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">t</span>.<span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">c</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-params">(x : Î±)</span> <span class="hljs-symbol">:</span></span> Vect Î± n :=
  <span class="hljs-keyword">match</span> n <span class="hljs-keyword">with</span>
  | <span class="hljs-number">0</span> =&gt; .nil
  | k + <span class="hljs-number">1</span> =&gt; .cons x (.cons x (replicate k x))
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">application type mismatch
  cons x (cons x (replicate k x))
argument
  cons x (replicate k x)
has type
  Vect Î± (k + 1) : Type ?u.1998
but is expected to have type
  Vect Î± k : Type ?u.1998
</code></pre>
<p>The function <code class="hljs">List.zip</code> combines two lists by pairing the first entry in the first list with the first entry in the second list, the second entry in the first list with the second entry in the second list, and so forth.
<code class="hljs">List.zip</code> can be used to pair the three highest peaks in the US state of Oregon with the three highest peaks in Denmark:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">[<span class="hljs-string">"Mount Hood"</span>,
 <span class="hljs-string">"Mount Jefferson"</span>,
 <span class="hljs-string">"South Sister"</span>].zip [<span class="hljs-string">"MÃ¸llehÃ¸j"</span>, <span class="hljs-string">"Yding SkovhÃ¸j"</span>, <span class="hljs-string">"Ejer BavnehÃ¸j"</span>]
</code></pre>
<p>The result is a list of three pairs:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">[(<span class="hljs-string">"Mount Hood"</span>, <span class="hljs-string">"MÃ¸llehÃ¸j"</span>),
 (<span class="hljs-string">"Mount Jefferson"</span>, <span class="hljs-string">"Yding SkovhÃ¸j"</span>),
 (<span class="hljs-string">"South Sister"</span>, <span class="hljs-string">"Ejer BavnehÃ¸j"</span>)]
</code></pre>
<p>It's somewhat unclear what should happen when the lists have different lengths.
Like many languages, Lean chooses to ignore the extra entries in one of the lists.
For instance, combining the heights of the five highest peaks in Oregon with those of the three highest peaks in Denmark yields three pairs.
In particular,</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">[<span class="hljs-number">3428.8</span>, <span class="hljs-number">3201</span>, <span class="hljs-number">3158.5</span>, <span class="hljs-number">3075</span>, <span class="hljs-number">3064</span>].zip [<span class="hljs-number">170.86</span>, <span class="hljs-number">170.77</span>, <span class="hljs-number">170.35</span>]
</code></pre>
<p>evaluates to</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">[(<span class="hljs-number">3428.8</span>, <span class="hljs-number">170.86</span>), (<span class="hljs-number">3201</span>, <span class="hljs-number">170.77</span>), (<span class="hljs-number">3158.5</span>, <span class="hljs-number">170.35</span>)]
</code></pre>
<p>While this approach is convenient because it always returns an answer, it runs the risk of throwing away data when the lists unintentionally have different lengths.
F# takes a different approach: its version of <code class="hljs">List.zip</code> throws an exception when the lengths don't match, as can be seen in this <code class="hljs">fsi</code> session:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-fsharp hljs">&gt; List.zip [3428.8; 3201.0; 3158.5; 3075.0; 3064.0] [170.86; 170.77; 170.35];;
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">System.ArgumentException: The lists had different lengths.
list2 is 2 elements shorter than list1 (Parameter 'list2')
   at Microsoft.FSharp.Core.DetailedExceptions.invalidArgDifferentListLength[?](String arg1, String arg2, Int32 diff) in /builddir/build/BUILD/dotnet-v3.1.424-SDK/src/fsharp.3ef6f0b514198c0bfa6c2c09fefe41a740b024d5/src/fsharp/FSharp.Core/local.fs:line 24
   at Microsoft.FSharp.Primitives.Basics.List.zipToFreshConsTail[a,b](FSharpList`1 cons, FSharpList`1 xs1, FSharpList`1 xs2) in /builddir/build/BUILD/dotnet-v3.1.424-SDK/src/fsharp.3ef6f0b514198c0bfa6c2c09fefe41a740b024d5/src/fsharp/FSharp.Core/local.fs:line 918
   at Microsoft.FSharp.Primitives.Basics.List.zip[T1,T2](FSharpList`1 xs1, FSharpList`1 xs2) in /builddir/build/BUILD/dotnet-v3.1.424-SDK/src/fsharp.3ef6f0b514198c0bfa6c2c09fefe41a740b024d5/src/fsharp/FSharp.Core/local.fs:line 929
   at Microsoft.FSharp.Collections.ListModule.Zip[T1,T2](FSharpList`1 list1, FSharpList`1 list2) in /builddir/build/BUILD/dotnet-v3.1.424-SDK/src/fsharp.3ef6f0b514198c0bfa6c2c09fefe41a740b024d5/src/fsharp/FSharp.Core/list.fs:line 466
   at &lt;StartupCode$FSI_0006&gt;.$FSI_0006.main@()
Stopped due to error
</code></pre>
<p>This avoids accidentally discarding information, but crashing a program comes with its own difficulties.
The Lean equivalent, which would use the <code class="hljs">Option</code> or <code class="hljs">Except</code> monads, would introduce a burden that may not be worth the safety.</p>
<p>Using <code class="hljs">Vect</code>, however, it is possible to write a version of <code class="hljs">zip</code> with a type that requires that both arguments have the same length:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">V</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">t</span>.<span class="hljs-title">z</span><span class="hljs-title">i</span><span class="hljs-title">p</span> <span class="hljs-symbol">:</span></span> Vect Î± n â Vect Î² n â Vect (Î± Ã Î²) n
  | .nil, .nil =&gt; .nil
  | .cons x xs, .cons y ys =&gt; .cons (x, y) (zip xs ys)
</code></pre>
<p>This definition only has patterns for the cases where either both arguments are <code class="hljs">Vect.nil</code> or both arguments are <code class="hljs">Vect.cons</code>, and Lean accepts the definition without a "missing cases" error like the one that results from a similar definition for <code class="hljs">List</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">z</span><span class="hljs-title">i</span><span class="hljs-title">p</span> <span class="hljs-symbol">:</span></span> List Î± â List Î² â List (Î± Ã Î²)
  | [], [] =&gt; []
  | x :: xs, y :: ys =&gt; (x, y) :: zip xs ys
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">missing cases:
(List.cons _ _), []
[], (List.cons _ _)
</code></pre>
<p>This is because the constructor used in the first pattern, <code class="hljs">nil</code> or <code class="hljs">cons</code>, <em>refines</em> the type checker's knowledge about the length <code class="hljs">n</code>.
When the first pattern is <code class="hljs">nil</code>, the type checker can additionally determine that the length was <code class="hljs">0</code>, so the only possible choice for the second pattern is <code class="hljs">nil</code>.
Similarly, when the first pattern is <code class="hljs">cons</code>, the type checker can determine that the length was <code class="hljs">k+1</code> for some <code class="hljs">Nat</code> <code class="hljs">k</code>, so the only possible choice for the second pattern is <code class="hljs">cons</code>.
Indeed, adding a case that uses <code class="hljs">nil</code> and <code class="hljs">cons</code> together is a type error, because the lengths don't match:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">V</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">t</span>.<span class="hljs-title">z</span><span class="hljs-title">i</span><span class="hljs-title">p</span> <span class="hljs-symbol">:</span></span> Vect Î± n â Vect Î² n â Vect (Î± Ã Î²) n
  | .nil, .nil =&gt; .nil
  | .nil, .cons y ys =&gt; .nil
  | .cons x xs, .cons y ys =&gt; .cons (x, y) (zip xs ys)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">type mismatch
  Vect.cons y ys
has type
  Vect Î² (?m.4718 + 1) : Type ?u.4530
but is expected to have type
  Vect Î² 0 : Type ?u.4530
</code></pre>
<p>The refinement of the length can be observed by making <code class="hljs">n</code> into an explicit argument:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">V</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">t</span>.<span class="hljs-title">z</span><span class="hljs-title">i</span><span class="hljs-title">p</span> <span class="hljs-symbol">:</span></span> (n : Nat) â Vect Î± n â Vect Î² n â Vect (Î± Ã Î²) n
  | <span class="hljs-number">0</span>, .nil, .nil =&gt; .nil
  | k + <span class="hljs-number">1</span>, .cons x xs, .cons y ys =&gt; .cons (x, y) (zip k xs ys)
</code></pre>
<h2 id="exercises-18"><a class="header" href="#exercises-18">Exercises</a></h2>
<p>Getting a feel for programming with dependent types requires experience, and the exercises in this section are very important.
For each exercise, try to see which mistakes the type checker can catch, and which ones it can't, by experimenting with the code as you go.
This is also a good way to develop a feel for the error messages.</p>
<ul>
<li>
<p>Double-check that <code class="hljs">Vect.zip</code> gives the right answer when combining the three highest peaks in Oregon with the three highest peaks in Denmark.
Because <code class="hljs">Vect</code> doesn't have the syntactic sugar that <code class="hljs">List</code> has, it can be helpful to begin by defining <code class="hljs">oregonianPeaks : Vect String 3</code> and <code class="hljs">danishPeaks : Vect String 3</code>.</p>
</li>
<li>
<p>Define a function <code class="hljs">Vect.map</code> with type <code class="hljs">(Î± â Î²) â Vect Î± n â Vect Î² n</code>.</p>
</li>
<li>
<p>Define a function <code class="hljs">Vect.zipWith</code> that combines the entries in a <code class="hljs">Vect</code> one at a time with a function.
It should have the type <code class="hljs">(Î± â Î² â Î³) â Vect Î± n â Vect Î² n â Vect Î³ n</code>.</p>
</li>
<li>
<p>Define a function <code class="hljs">Vect.unzip</code> that splits a <code class="hljs">Vect</code> of pairs into a pair of <code class="hljs">Vect</code>s. It should have the type <code class="hljs">Vect (Î± Ã Î²) n â Vect Î± n Ã Vect Î² n</code>.</p>
</li>
<li>
<p>Define a function <code class="hljs">Vect.snoc</code> that adds an entry to the <em>end</em> of a <code class="hljs">Vect</code>. Its type should be <code class="hljs">Vect Î± n â Î± â Vect Î± (n + 1)</code> and <code class="hljs">#eval Vect.snoc (.cons "snowy" .nil) "peaks"</code> should yield <code class="hljs">Vect.cons "snowy" (Vect.cons "peaks" (Vect.nil))</code>. The name <code class="hljs">snoc</code> is a traditional functional programming pun: it is <code class="hljs">cons</code> backwards.</p>
</li>
<li>
<p>Define a function <code class="hljs">Vect.reverse</code> that reverses the order of a <code class="hljs">Vect</code>.</p>
</li>
<li>
<p>Define a function <code class="hljs">Vect.drop</code> with the following type: <code class="hljs">(n : Nat) â Vect Î± (k + n) â Vect Î± k</code>.
Verify that it works by checking that <code class="hljs">#eval danishPeaks.drop 2</code> yields <code class="hljs">Vect.cons "Ejer BavnehÃ¸j" (Vect.nil)</code>.</p>
</li>
<li>
<p>Define a function <code class="hljs">Vect.take</code> with type <code class="hljs">(n : Nat) â Vect Î± (k + n) â Vect Î± n</code> that returns the first <code class="hljs">n</code> entries in the <code class="hljs">Vect</code>. Check that it works on an example.</p>
</li>
</ul>
<div style="break-before:page;page-break-before:always"></div><h1 id="the-universe-design-pattern"><a class="header" href="#the-universe-design-pattern">The Universe Design Pattern</a></h1>
<p>In Lean, types such as <code class="hljs">Type</code>, <code class="hljs">Type 3</code>, and <code class="hljs">Prop</code> that classify other types are known as universes.
However, the term <em>universe</em> is also used for a design pattern in which a datatype is used to represent a subset of Lean's types, and a function converts the datatype's constructors into actual types.
The values of this datatype are called <em>codes</em> for their types.</p>
<p>Just like Lean's built-in universes, the universes implemented with this pattern are types that describe some collection of available types, even though the mechanism by which it is done is different.
In Lean, there are types such as <code class="hljs">Type</code>, <code class="hljs">Type 3</code>, and <code class="hljs">Prop</code> that directly describe other types.
This arrangement is referred to as <em>universes Ã  la Russell</em>.
The user-defined universes described in this section represent all of their types as <em>data</em>, and include an explicit function to interpret these codes into actual honest-to-goodness types.
This arrangement is referred to as <em>universes Ã  la Tarski</em>.
While languages such as Lean that are based on dependent type theory almost always use Russell-style universes, Tarski-style universes are a useful pattern for defining APIs in these languages.</p>
<p>Defining a custom universe makes it possible to carve out a closed collection of types that can be used with an API.
Because the collection of types is closed, recursion over the codes allows programs to work for <em>any</em> type in the universe.
One example of a custom universe has the codes <code class="hljs">nat</code>, standing for <code class="hljs">Nat</code>, and <code class="hljs">bool</code>, standing for <code class="hljs">Bool</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> NatOrBool <span class="hljs-keyword">where</span>
  | nat | bool

<span class="hljs-keyword">abbrev</span> NatOrBool.asType (code : NatOrBool) : <span class="hljs-built_in">Type</span> :=
  <span class="hljs-keyword">match</span> code <span class="hljs-keyword">with</span>
  | .nat =&gt; Nat
  | .bool =&gt; Bool
</code></pre>
<p>Pattern matching on a code allows the type to be refined, just as pattern matching on the constructors of <code class="hljs">Vect</code> allows the expected length to be refined.
For instance, a program that deserializes the types in this universe from a string can be written as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">d</span><span class="hljs-title">e</span> <span class="hljs-params">(t : NatOrBool)</span> <span class="hljs-params">(input : String)</span> <span class="hljs-symbol">:</span></span> Option t.asType :=
  <span class="hljs-keyword">match</span> t <span class="hljs-keyword">with</span>
  | .nat =&gt; input.toNat?
  | .bool =&gt;
    <span class="hljs-keyword">match</span> input <span class="hljs-keyword">with</span>
    | <span class="hljs-string">"true"</span> =&gt; some true
    | <span class="hljs-string">"false"</span> =&gt; some false
    | _ =&gt; none
</code></pre>
<p>Dependent pattern matching on <code class="hljs">t</code> allows the expected result type <code class="hljs">t.asType</code> to be respectively refined to <code class="hljs">NatOrBool.nat.asType</code> and <code class="hljs">NatOrBool.bool.asType</code>, and these compute to the actual types <code class="hljs">Nat</code> and <code class="hljs">Bool</code>.</p>
<p>Like any other data, codes may be recursive.
The type <code class="hljs">NestedPairs</code> codes for any possible nesting of the pair and natural number types:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> NestedPairs <span class="hljs-keyword">where</span>
  | nat : NestedPairs
  | pair : NestedPairs â NestedPairs â NestedPairs

<span class="hljs-keyword">abbrev</span> NestedPairs.asType : NestedPairs â <span class="hljs-built_in">Type</span>
  | .nat =&gt; Nat
  | .pair t1 t2 =&gt; asType t1 Ã asType t2
</code></pre>
<p>In this case, the interpretation function <code class="hljs">NestedPairs.asType</code> is recursive.
This means that recursion over codes is required in order to implement <code class="hljs">BEq</code> for the universe:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">N</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">d</span><span class="hljs-title">P</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">s</span>.<span class="hljs-title">b</span><span class="hljs-title">e</span><span class="hljs-title">q</span> <span class="hljs-params">(t : NestedPairs)</span> <span class="hljs-params">(x y : t.asType)</span> <span class="hljs-symbol">:</span></span> Bool :=
  <span class="hljs-keyword">match</span> t <span class="hljs-keyword">with</span>
  | .nat =&gt; x == y
  | .pair t1 t2 =&gt; beq t1 x.fst y.fst &amp;&amp; beq t2 x.snd y.snd

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">{t : NestedPairs}</span> <span class="hljs-symbol">:</span></span> BEq t.asType <span class="hljs-keyword">where</span>
  beq x y := t.beq x y
</code></pre>
<p>Even though every type in the <code class="hljs">NestedPairs</code> universe already has a <code class="hljs">BEq</code> instance, type class search does not automatically check every possible case of a datatype in an instance declaration, because there might be infinitely many such cases, as with <code class="hljs">NestedPairs</code>.
Attempting to appeal directly to the <code class="hljs">BEq</code> instances rather than explaining to Lean how to find them by recursion on the codes results in an error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">{t : NestedPairs}</span> <span class="hljs-symbol">:</span></span> BEq t.asType <span class="hljs-keyword">where</span>
  beq x y := x == y
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to synthesize instance
  BEq (NestedPairs.asType t)
</code></pre>
<p>The <code class="hljs">t</code> in the error message stands for an unknown value of type <code class="hljs">NestedPairs</code>.</p>
<h2 id="type-classes-vs-universes"><a class="header" href="#type-classes-vs-universes">Type Classes vs Universes</a></h2>
<p>Type classes allow an open-ended collection of types to be used with an API as long as they have implementations of the necessary interfaces.
In most cases, this is preferable.
It is hard to predict all use cases for an API ahead of time, and type classes are a convenient way to allow library code to be used with more types than the original author expected.</p>
<p>A universe Ã  la Tarski, on the other hand, restricts the API to be usable only with a predetermined collection of types.
This is useful in a few situations:</p>
<ul>
<li>When a function should act very differently depending on which type it is passedâit is impossible to pattern match on types themselves, but pattern matching on codes for types is allowed</li>
<li>When an external system inherently limits the types of data that may be provided, and extra flexibility is not desired</li>
<li>When additional properties of a type are required over and above the implementation of some operations</li>
</ul>
<p>Type classes are useful in many of the same situations as interfaces in Java or C#, while a universe Ã  la Tarski can be useful in cases where a sealed class might be used, but where an ordinary inductive datatype is not usable.</p>
<h2 id="a-universe-of-finite-types"><a class="header" href="#a-universe-of-finite-types">A Universe of Finite Types</a></h2>
<p>Restricting the types that can be used with an API to a predetermined collection can enable operations that would be impossible for an open-ended API.
For example, functions can't normally be compared for equality.
Functions should be considered equal when they map the same inputs to the same outputs.
Checking this could take infinite amounts of time, because comparing two functions with type <code class="hljs">Nat â Bool</code> would require checking that the functions returned the same <code class="hljs">Bool</code> for each and every <code class="hljs">Nat</code>.</p>
<p>In other words, a function from an infinite type is itself infinite.
Functions can be viewed as tables, and a function whose argument type is infinite requires infinitely many rows to represent each case.
But functions from finite types require only finitely many rows in their tables, making them finite.
Two functions whose argument type is finite can be checked for equality by enumerating all possible arguments, calling the functions on each of them, and then comparing the results.
Checking higher-order functions for equality requires generating all possible functions of a given type, which additionally requires that the return type is finite so that each element of the argument type can be mapped to each element of the return type.
This is not a <em>fast</em> method, but it does complete in finite time.</p>
<p>One way to represent finite types is by a universe:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Finite <span class="hljs-keyword">where</span>
  | unit : Finite
  | bool : Finite
  | pair : Finite â Finite â Finite
  | arr : Finite â Finite â Finite

<span class="hljs-keyword">abbrev</span> Finite.asType : Finite â <span class="hljs-built_in">Type</span>
  | .unit =&gt; Unit
  | .bool =&gt; Bool
  | .pair t1 t2 =&gt; asType t1 Ã asType t2
  | .arr t1 t2 =&gt; asType t1 â asType t2
</code></pre>
<p>In this universe, the constructor <code class="hljs">arr</code> stands for the function type, which is written with an <code class="hljs">arr</code>ow.</p>
<p>Comparing two values from this universe for equality is almost the same as in the <code class="hljs">NestedPairs</code> universe.
The only important difference is the addition of the case for <code class="hljs">arr</code>, which uses a helper called <code class="hljs">Finite.enumerate</code> to generate every value from the type coded for by <code class="hljs">t1</code>, checking that the two functions return equal results for every possible input:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">e</span>.<span class="hljs-title">b</span><span class="hljs-title">e</span><span class="hljs-title">q</span> <span class="hljs-params">(t : Finite)</span> <span class="hljs-params">(x y : t.asType)</span> <span class="hljs-symbol">:</span></span> Bool :=
  <span class="hljs-keyword">match</span> t <span class="hljs-keyword">with</span>
  | .unit =&gt; true
  | .bool =&gt; x == y
  | .pair t1 t2 =&gt; beq t1 x.fst y.fst &amp;&amp; beq t2 x.snd y.snd
  | .arr t1 t2 =&gt;
    t1.enumerate.all <span class="hljs-keyword">fun</span> arg =&gt; beq t2 (x arg) (y arg)
</code></pre>
<p>The standard library function <code class="hljs">List.all</code> checks that the provided function returns <code class="hljs">true</code> on every entry of a list.
This function can be used to compare functions on the Booleans for equality:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> Finite.beq (.arr .bool .bool) (<span class="hljs-keyword">fun</span> _ =&gt; true) (<span class="hljs-keyword">fun</span> b =&gt; b == b)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">true
</code></pre>
<p>It can also be used to compare functions from the standard library:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> Finite.beq (.arr .bool .bool) (<span class="hljs-keyword">fun</span> _ =&gt; true) not
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">false
</code></pre>
<p>It can even compare functions built using tools such as function composition:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> Finite.beq (.arr .bool .bool) id (not â not)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">true
</code></pre>
<p>This is because the <code class="hljs">Finite</code> universe codes for Lean's <em>actual</em> function type, not a special analogue created by the library.</p>
<p>The implementation of <code class="hljs">enumerate</code> is also by recursion on the codes from <code class="hljs">Finite</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">e</span>.<span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span> <span class="hljs-params">(t : Finite)</span> <span class="hljs-symbol">:</span></span> List t.asType :=
    <span class="hljs-keyword">match</span> t <span class="hljs-keyword">with</span>
    | .unit =&gt; [()]
    | .bool =&gt; [true, false]
    | .pair t1 t2 =&gt; t1.enumerate.product t2.enumerate
    | .arr t1 t2 =&gt; t1.functions t2.enumerate
</code></pre>
<p>In the case for <code class="hljs">Unit</code>, there is only a single value.
In the case for <code class="hljs">Bool</code>, there are two values to return (<code class="hljs">true</code> and <code class="hljs">false</code>).
In the case for pairs, the result should be the Cartesian product of the values for the type coded for by <code class="hljs">t1</code> and the values for the type coded for by <code class="hljs">t2</code>.
In other words, every value from <code class="hljs">t1</code> should be paired with every value from <code class="hljs">t2</code>.
The helper function <code class="hljs">List.product</code> can certainly be written with an ordinary recursive function, but here it is defined using <code class="hljs">for</code> in the identity monad:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">p</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">d</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">t</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-params">(ys : List Î²)</span> <span class="hljs-symbol">:</span></span> List (Î± Ã Î²) := Id.run <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> out : List (Î± Ã Î²) := []
  <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> xs <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> ys <span class="hljs-keyword">do</span>
      out := (x, y) :: out
  pure out.reverse
</code></pre>
<p>Finally, the case of <code class="hljs">Finite.enumerate</code> for functions delegates to a helper called <code class="hljs">Finite.functions</code> that takes a list of all of the return values to target as an argument.</p>
<p>Generally speaking, generating all of the functions from some finite type to a collection of result values can be thought of as generating the functions' tables.
Each function assigns an output to each input, which means that a given function has <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-54-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-375" style="width:0.647em;display:inline-block"><span style="display:inline-block;position:relative;width:0.526em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.53em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-376"><span class="mi" id="MathJax-Span-377" style="font-family:MathJax_Math;font-style:italic">k</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span> rows in its table when there are <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-55-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-378" style="width:0.647em;display:inline-block"><span style="display:inline-block;position:relative;width:0.526em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.53em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-379"><span class="mi" id="MathJax-Span-380" style="font-family:MathJax_Math;font-style:italic">k</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span> possible arguments.
Because each row of the table could select any of <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-56-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-381" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-382"><span class="mi" id="MathJax-Span-383" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span> possible outputs, there are <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-57-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>n</mi><mi>k</mi></msup></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-384" style="width:1.333em;display:inline-block"><span style="display:inline-block;position:relative;width:1.05em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.413em,1001.05em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-385"><span class="msubsup" id="MathJax-Span-386"><span style="display:inline-block;position:relative;width:1.05em;height:0px"><span style="position:absolute;clip:rect(3.429em,1000.57em,4.115em,-999.998em);top:-3.99em;left:0em"><span class="mi" id="MathJax-Span-387" style="font-family:MathJax_Math;font-style:italic">n</span><span style="display:inline-block;width:0px;height:3.994em"></span></span><span style="position:absolute;top:-4.353em;left:0.607em"><span class="mi" id="MathJax-Span-388" style="font-size:70.7%;font-family:MathJax_Math;font-style:italic">k</span><span style="display:inline-block;width:0px;height:3.994em"></span></span></span></span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:1.153em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mi>k</mi></msup></math></span></span> potential functions to generate.</p>
<p>Once again, generating the functions from a finite type to some list of values is recursive on the code that describes the finite type:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">e</span>.<span class="hljs-title">f</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">c</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">s</span> <span class="hljs-params">(t : Finite)</span> <span class="hljs-params">(results : List Î±)</span> <span class="hljs-symbol">:</span></span> List (t.asType â Î±) :=
    <span class="hljs-keyword">match</span> t <span class="hljs-keyword">with</span>
</code></pre>
<p>The table for functions from <code class="hljs">Unit</code> contains one row, because the function can't pick different results based on which input it is provided.
This means that one function is generated for each potential input.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">      | .unit =&gt;
        results.map <span class="hljs-keyword">fun</span> r =&gt;
          <span class="hljs-keyword">fun</span> () =&gt; r
</code></pre>
<p>There are <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-58-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>n</mi><mn>2</mn></msup></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-389" style="width:1.333em;display:inline-block"><span style="display:inline-block;position:relative;width:1.05em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.413em,1001.05em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-390"><span class="msubsup" id="MathJax-Span-391"><span style="display:inline-block;position:relative;width:1.05em;height:0px"><span style="position:absolute;clip:rect(3.429em,1000.57em,4.115em,-999.998em);top:-3.99em;left:0em"><span class="mi" id="MathJax-Span-392" style="font-family:MathJax_Math;font-style:italic">n</span><span style="display:inline-block;width:0px;height:3.994em"></span></span><span style="position:absolute;top:-4.353em;left:0.607em"><span class="mn" id="MathJax-Span-393" style="font-size:70.7%;font-family:MathJax_Main">2</span><span style="display:inline-block;width:0px;height:3.994em"></span></span></span></span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:1.153em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>n</mi><mn>2</mn></msup></math></span></span> functions from <code class="hljs">Bool</code> when there are <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-59-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-394" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-395"><span class="mi" id="MathJax-Span-396" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span> result values, because each individual function of type <code class="hljs">Bool â Î±</code> uses the <code class="hljs">Bool</code> to select between two particular <code class="hljs">Î±</code>s:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">      | .bool =&gt;
        (results.product results).map <span class="hljs-keyword">fun</span> (r1, r2) =&gt;
          <span class="hljs-keyword">fun</span>
            | true =&gt; r1
            | false =&gt; r2
</code></pre>
<p>Generating the functions from pairs can be achieved by taking advantage of currying.
A function from a pair can be transformed into a function that takes the first element of the pair and returns a function that's waiting for the second element of the pair.
Doing this allows <code class="hljs">Finite.functions</code> to be used recursively in this case:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">      | .pair t1 t2 =&gt;
        <span class="hljs-keyword">let</span> f1s := t1.functions &lt;| t2.functions results
        f1s.map <span class="hljs-keyword">fun</span> f =&gt;
          <span class="hljs-keyword">fun</span> (x, y) =&gt;
            f x y
</code></pre>
<p>Generating higher-order functions is a bit of a brain bender.
Each higher-order function takes a function as its argument.
This argument function can be distinguished from other functions based on its input/output behavior.
In general, the higher-order function can apply the argument function to every possible argument, and it can then carry out any possible behavior based on the result of applying the argument function.
This suggests a means of constructing the higher-order functions:</p>
<ul>
<li>Begin with a list of all possible arguments to the function that is itself an argument.</li>
<li>For each possible argument, construct all possible behaviors that can result from the observation of applying the argument function to the possible argument. This can be done using <code class="hljs">Finite.functions</code> and recursion over the rest of the possible arguments, because the result of the recursion represents the functions based on the observations of the rest of the possible arguments. <code class="hljs">Finite.functions</code> constructs all the ways of achieving these based on the observation for the current argument.</li>
<li>For potential behavior in response to these observations, construct a higher-order function that applies the argument function to the current possible argument. The result of this is then passed to the observation behavior.</li>
<li>The base case of the recursion is a higher-order function that observes nothing for each result valueâit ignores the argument function and simply returns the result value.</li>
</ul>
<p>Defining this recursive function directly causes Lean to be unable to prove that the whole function terminates.
However, using a simpler form of recursion called a <em>right fold</em> can be used to make it clear to the termination checker that the function terminates.
A right fold takes three arguments: a step function that combines the head of the list with the result of the recursion over the tail, a default value to return when the list is empty, and the list being processed.
It then analyzes the list, essentially replacing each <code class="hljs">::</code> in the list with a call to the step function and replacing <code class="hljs">[]</code> with the default value:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">l</span><span class="hljs-title">d</span><span class="hljs-title">r</span> <span class="hljs-params">(f : Î± â Î² â Î²)</span> <span class="hljs-params">(default : Î²)</span> <span class="hljs-symbol">:</span></span> List Î± â Î²
  | []     =&gt; default
  | a :: l =&gt; f a (foldr f default l)
</code></pre>
<p>Finding the sum of the <code class="hljs">Nat</code>s in a list can be done with <code class="hljs">foldr</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].foldr (Â· + Â·) <span class="hljs-number">0</span>
===&gt;
(<span class="hljs-number">1</span> :: <span class="hljs-number">2</span> :: <span class="hljs-number">3</span> :: <span class="hljs-number">4</span> :: <span class="hljs-number">5</span> :: []).foldr (Â· + Â·) <span class="hljs-number">0</span>
===&gt;
(<span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span> + <span class="hljs-number">5</span> + <span class="hljs-number">0</span>)
===&gt;
<span class="hljs-number">15</span>
</code></pre>
<p>With <code class="hljs">foldr</code>, the higher-order functions can be created as follows:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">      | .arr t1 t2 =&gt;
        <span class="hljs-keyword">let</span> args := t1.enumerate
        <span class="hljs-keyword">let</span> base :=
          results.map <span class="hljs-keyword">fun</span> r =&gt;
            <span class="hljs-keyword">fun</span> _ =&gt; r
        args.foldr
          (<span class="hljs-keyword">fun</span> arg rest =&gt;
            (t2.functions rest).map <span class="hljs-keyword">fun</span> more =&gt;
              <span class="hljs-keyword">fun</span> f =&gt; more (f arg) f)
          base
</code></pre>
<p>The complete definition of <code class="hljs">Finite.Functions</code> is:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">e</span>.<span class="hljs-title">f</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">c</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">s</span> <span class="hljs-params">(t : Finite)</span> <span class="hljs-params">(results : List Î±)</span> <span class="hljs-symbol">:</span></span> List (t.asType â Î±) :=
    <span class="hljs-keyword">match</span> t <span class="hljs-keyword">with</span>
      | .unit =&gt;
        results.map <span class="hljs-keyword">fun</span> r =&gt;
          <span class="hljs-keyword">fun</span> () =&gt; r
      | .bool =&gt;
        (results.product results).map <span class="hljs-keyword">fun</span> (r1, r2) =&gt;
          <span class="hljs-keyword">fun</span>
            | true =&gt; r1
            | false =&gt; r2
      | .pair t1 t2 =&gt;
        <span class="hljs-keyword">let</span> f1s := t1.functions &lt;| t2.functions results
        f1s.map <span class="hljs-keyword">fun</span> f =&gt;
          <span class="hljs-keyword">fun</span> (x, y) =&gt;
            f x y
      | .arr t1 t2 =&gt;
        <span class="hljs-keyword">let</span> args := t1.enumerate
        <span class="hljs-keyword">let</span> base :=
          results.map <span class="hljs-keyword">fun</span> r =&gt;
            <span class="hljs-keyword">fun</span> _ =&gt; r
        args.foldr
          (<span class="hljs-keyword">fun</span> arg rest =&gt;
            (t2.functions rest).map <span class="hljs-keyword">fun</span> more =&gt;
              <span class="hljs-keyword">fun</span> f =&gt; more (f arg) f)
          base
</code></pre>
<p>Because <code class="hljs">Finite.enumerate</code> and <code class="hljs">Finite.functions</code> call each other, they must be defined in a <code class="hljs">mutual</code> block.
In other words, right before the definition of <code class="hljs">Finite.enumerate</code> is the <code class="hljs">mutual</code> keyword:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-meta">mutual</span>
  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">e</span>.<span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span> <span class="hljs-params">(t : Finite)</span> <span class="hljs-symbol">:</span></span> List t.asType :=
    <span class="hljs-keyword">match</span> t <span class="hljs-keyword">with</span>
</code></pre>
<p>and right after the definition of <code class="hljs">Finite.functions</code> is the <code class="hljs">end</code> keyword:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">      | .arr t1 t2 =&gt;
        <span class="hljs-keyword">let</span> args := t1.enumerate
        <span class="hljs-keyword">let</span> base :=
          results.map <span class="hljs-keyword">fun</span> r =&gt;
            <span class="hljs-keyword">fun</span> _ =&gt; r
        args.foldr
          (<span class="hljs-keyword">fun</span> arg rest =&gt;
            (t2.functions rest).map <span class="hljs-keyword">fun</span> more =&gt;
              <span class="hljs-keyword">fun</span> f =&gt; more (f arg) f)
          base
<span class="hljs-keyword">end</span>
</code></pre>
<p>This algorithm for comparing functions is not particularly practical.
The number of cases to check grows exponentially; even a simple type like <code class="hljs">((Bool Ã Bool) â Bool) â Bool</code> describes 65536 distinct functions.
Why are there so many?
Based on the reasoning above, and using <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-60-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mrow><mo>|</mo><mi>T</mi><mo>|</mo></mrow></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-397" style="width:1.575em;display:inline-block"><span style="display:inline-block;position:relative;width:1.252em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.494em,1001.13em,2.744em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-398"><span class="mrow" id="MathJax-Span-399"><span class="mo" id="MathJax-Span-400" style="font-family:MathJax_Main">|</span><span class="mi" id="MathJax-Span-401" style="font-family:MathJax_Math;font-style:italic">T<span style="display:inline-block;overflow:hidden;height:1px;width:0.123em"></span></span><span class="mo" id="MathJax-Span-402" style="font-family:MathJax_Main">|</span></span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.348em;border-left:0px solid;width:0px;height:1.353em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>|</mo><mi>T</mi><mo>|</mo></mrow></math></span></span> to represent the number of values described by the type <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-61-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>T</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-403" style="width:0.929em;display:inline-block"><span style="display:inline-block;position:relative;width:0.728em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.73em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-404"><span class="mi" id="MathJax-Span-405" style="font-family:MathJax_Math;font-style:italic">T<span style="display:inline-block;overflow:hidden;height:1px;width:0.123em"></span></span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi></math></span></span>, we should expect that
<span class="MathJax_Preview" style="color:inherit;display:none"></span></p><div class="MathJax_Display" style="text-align:center"><span class="MathJax" id="MathJax-Element-62-Frame" tabindex="0" style="text-align:center;position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mrow><mo>|</mo><mrow><mrow><mo>(</mo><mrow><mrow><mo>(</mo><mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;monospace&quot;>B</mi><mi mathvariant=&quot;monospace&quot;>o</mi><mi mathvariant=&quot;monospace&quot;>o</mi><mi mathvariant=&quot;monospace&quot;>l</mi></mrow><mo>&amp;#x00D7;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;monospace&quot;>B</mi><mi mathvariant=&quot;monospace&quot;>o</mi><mi mathvariant=&quot;monospace&quot;>o</mi><mi mathvariant=&quot;monospace&quot;>l</mi></mrow></mrow><mo>)</mo></mrow><mo stretchy=&quot;false&quot;>&amp;#x2192;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;monospace&quot;>B</mi><mi mathvariant=&quot;monospace&quot;>o</mi><mi mathvariant=&quot;monospace&quot;>o</mi><mi mathvariant=&quot;monospace&quot;>l</mi></mrow></mrow><mo>)</mo></mrow><mo stretchy=&quot;false&quot;>&amp;#x2192;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;monospace&quot;>B</mi><mi mathvariant=&quot;monospace&quot;>o</mi><mi mathvariant=&quot;monospace&quot;>o</mi><mi mathvariant=&quot;monospace&quot;>l</mi></mrow></mrow><mo>|</mo></mrow></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-406" style="width:18.51em;display:inline-block"><span style="display:inline-block;position:relative;width:14.921em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.494em,1014.8em,2.744em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-407"><span class="mrow" id="MathJax-Span-408"><span class="mo" id="MathJax-Span-409" style="vertical-align:0em"><span style="font-family:MathJax_Main">|</span></span><span class="mrow" id="MathJax-Span-410"><span class="mrow" id="MathJax-Span-411"><span class="mo" id="MathJax-Span-412" style="font-family:MathJax_Main">(</span><span class="mrow" id="MathJax-Span-413"><span class="mrow" id="MathJax-Span-414"><span class="mo" id="MathJax-Span-415" style="font-family:MathJax_Main">(</span><span class="mrow" id="MathJax-Span-416"><span class="texatom" id="MathJax-Span-417"><span class="mrow" id="MathJax-Span-418"><span class="mi" id="MathJax-Span-419" style="font-family:MathJax_Typewriter">B</span><span class="mi" id="MathJax-Span-420" style="font-family:MathJax_Typewriter">o</span><span class="mi" id="MathJax-Span-421" style="font-family:MathJax_Typewriter">o</span><span class="mi" id="MathJax-Span-422" style="font-family:MathJax_Typewriter">l</span></span></span><span class="mo" id="MathJax-Span-423" style="font-family:MathJax_Main;padding-left:0.244em">Ã</span><span class="texatom" id="MathJax-Span-424" style="padding-left:0.244em"><span class="mrow" id="MathJax-Span-425"><span class="mi" id="MathJax-Span-426" style="font-family:MathJax_Typewriter">B</span><span class="mi" id="MathJax-Span-427" style="font-family:MathJax_Typewriter">o</span><span class="mi" id="MathJax-Span-428" style="font-family:MathJax_Typewriter">o</span><span class="mi" id="MathJax-Span-429" style="font-family:MathJax_Typewriter">l</span></span></span></span><span class="mo" id="MathJax-Span-430" style="font-family:MathJax_Main">)</span></span><span class="mo" id="MathJax-Span-431" style="font-family:MathJax_Main;padding-left:0.284em">â</span><span class="texatom" id="MathJax-Span-432" style="padding-left:0.284em"><span class="mrow" id="MathJax-Span-433"><span class="mi" id="MathJax-Span-434" style="font-family:MathJax_Typewriter">B</span><span class="mi" id="MathJax-Span-435" style="font-family:MathJax_Typewriter">o</span><span class="mi" id="MathJax-Span-436" style="font-family:MathJax_Typewriter">o</span><span class="mi" id="MathJax-Span-437" style="font-family:MathJax_Typewriter">l</span></span></span></span><span class="mo" id="MathJax-Span-438" style="font-family:MathJax_Main">)</span></span><span class="mo" id="MathJax-Span-439" style="font-family:MathJax_Main;padding-left:0.284em">â</span><span class="texatom" id="MathJax-Span-440" style="padding-left:0.284em"><span class="mrow" id="MathJax-Span-441"><span class="mi" id="MathJax-Span-442" style="font-family:MathJax_Typewriter">B</span><span class="mi" id="MathJax-Span-443" style="font-family:MathJax_Typewriter">o</span><span class="mi" id="MathJax-Span-444" style="font-family:MathJax_Typewriter">o</span><span class="mi" id="MathJax-Span-445" style="font-family:MathJax_Typewriter">l</span></span></span></span><span class="mo" id="MathJax-Span-446" style="vertical-align:0em"><span style="font-family:MathJax_Main">|</span></span></span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.348em;border-left:0px solid;width:0px;height:1.353em"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow><mo>|</mo><mrow><mrow><mo>(</mo><mrow><mrow><mo>(</mo><mrow><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="monospace">B</mi><mi mathvariant="monospace">o</mi><mi mathvariant="monospace">o</mi><mi mathvariant="monospace">l</mi></mrow><mo>Ã</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="monospace">B</mi><mi mathvariant="monospace">o</mi><mi mathvariant="monospace">o</mi><mi mathvariant="monospace">l</mi></mrow></mrow><mo>)</mo></mrow><mo stretchy="false">â</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="monospace">B</mi><mi mathvariant="monospace">o</mi><mi mathvariant="monospace">o</mi><mi mathvariant="monospace">l</mi></mrow></mrow><mo>)</mo></mrow><mo stretchy="false">â</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="monospace">B</mi><mi mathvariant="monospace">o</mi><mi mathvariant="monospace">o</mi><mi mathvariant="monospace">l</mi></mrow></mrow><mo>|</mo></mrow></math></span></span></div>
is 
<span class="MathJax_Preview" style="color:inherit;display:none"></span><div class="MathJax_Display" style="text-align:center"><span class="MathJax" id="MathJax-Element-63-Frame" tabindex="0" style="text-align:center;position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><msup><mrow><mo>|</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;normal&quot;>B</mi><mi mathvariant=&quot;normal&quot;>o</mi><mi mathvariant=&quot;normal&quot;>o</mi><mi mathvariant=&quot;normal&quot;>l</mi></mrow><mo>|</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mrow><mo>|</mo><mrow><mrow><mo>(</mo><mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;monospace&quot;>B</mi><mi mathvariant=&quot;monospace&quot;>o</mi><mi mathvariant=&quot;monospace&quot;>o</mi><mi mathvariant=&quot;monospace&quot;>l</mi></mrow><mo>&amp;#x00D7;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;monospace&quot;>B</mi><mi mathvariant=&quot;monospace&quot;>o</mi><mi mathvariant=&quot;monospace&quot;>o</mi><mi mathvariant=&quot;monospace&quot;>l</mi></mrow></mrow><mo>)</mo></mrow><mo stretchy=&quot;false&quot;>&amp;#x2192;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;monospace&quot;>B</mi><mi mathvariant=&quot;monospace&quot;>o</mi><mi mathvariant=&quot;monospace&quot;>o</mi><mi mathvariant=&quot;monospace&quot;>l</mi></mrow></mrow><mo>|</mo></mrow></mrow></msup><mo>,</mo></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-447" style="width:11.857em;display:inline-block"><span style="display:inline-block;position:relative;width:9.558em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.252em,1009.48em,2.744em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-448"><span class="msubsup" id="MathJax-Span-449"><span style="display:inline-block;position:relative;width:9.276em;height:0px"><span style="position:absolute;clip:rect(3.107em,1002.42em,4.357em,-999.998em);top:-3.99em;left:0em"><span class="mrow" id="MathJax-Span-450"><span class="mo" id="MathJax-Span-451" style="font-family:MathJax_Main">|</span><span class="texatom" id="MathJax-Span-452"><span class="mrow" id="MathJax-Span-453"><span class="mi" id="MathJax-Span-454" style="font-family:MathJax_Main">B</span><span class="mi" id="MathJax-Span-455" style="font-family:MathJax_Main">o</span><span class="mi" id="MathJax-Span-456" style="font-family:MathJax_Main">o</span><span class="mi" id="MathJax-Span-457" style="font-family:MathJax_Main">l</span></span></span><span class="mo" id="MathJax-Span-458" style="font-family:MathJax_Main">|</span></span><span style="display:inline-block;width:0px;height:3.994em"></span></span><span style="position:absolute;top:-4.474em;left:2.542em"><span class="texatom" id="MathJax-Span-459"><span class="mrow" id="MathJax-Span-460"><span class="mrow" id="MathJax-Span-461"><span class="mo" id="MathJax-Span-462" style="vertical-align:0em"><span><span style="font-size:70.7%;font-family:MathJax_Main">|</span></span></span><span class="mrow" id="MathJax-Span-463"><span class="mrow" id="MathJax-Span-464"><span class="mo" id="MathJax-Span-465" style="font-size:70.7%;font-family:MathJax_Main">(</span><span class="mrow" id="MathJax-Span-466"><span class="texatom" id="MathJax-Span-467"><span class="mrow" id="MathJax-Span-468"><span class="mi" id="MathJax-Span-469" style="font-size:70.7%;font-family:MathJax_Typewriter">B</span><span class="mi" id="MathJax-Span-470" style="font-size:70.7%;font-family:MathJax_Typewriter">o</span><span class="mi" id="MathJax-Span-471" style="font-size:70.7%;font-family:MathJax_Typewriter">o</span><span class="mi" id="MathJax-Span-472" style="font-size:70.7%;font-family:MathJax_Typewriter">l</span></span></span><span class="mo" id="MathJax-Span-473" style="font-size:70.7%;font-family:MathJax_Main">Ã</span><span class="texatom" id="MathJax-Span-474"><span class="mrow" id="MathJax-Span-475"><span class="mi" id="MathJax-Span-476" style="font-size:70.7%;font-family:MathJax_Typewriter">B</span><span class="mi" id="MathJax-Span-477" style="font-size:70.7%;font-family:MathJax_Typewriter">o</span><span class="mi" id="MathJax-Span-478" style="font-size:70.7%;font-family:MathJax_Typewriter">o</span><span class="mi" id="MathJax-Span-479" style="font-size:70.7%;font-family:MathJax_Typewriter">l</span></span></span></span><span class="mo" id="MathJax-Span-480" style="font-size:70.7%;font-family:MathJax_Main">)</span></span><span class="mo" id="MathJax-Span-481" style="font-size:70.7%;font-family:MathJax_Main">â</span><span class="texatom" id="MathJax-Span-482"><span class="mrow" id="MathJax-Span-483"><span class="mi" id="MathJax-Span-484" style="font-size:70.7%;font-family:MathJax_Typewriter">B</span><span class="mi" id="MathJax-Span-485" style="font-size:70.7%;font-family:MathJax_Typewriter">o</span><span class="mi" id="MathJax-Span-486" style="font-size:70.7%;font-family:MathJax_Typewriter">o</span><span class="mi" id="MathJax-Span-487" style="font-size:70.7%;font-family:MathJax_Typewriter">l</span></span></span></span><span class="mo" id="MathJax-Span-488" style="vertical-align:0em"><span><span style="font-size:70.7%;font-family:MathJax_Main">|</span></span></span></span></span></span><span style="display:inline-block;width:0px;height:3.994em"></span></span></span></span><span class="mo" id="MathJax-Span-489" style="font-family:MathJax_Main">,</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.348em;border-left:0px solid;width:0px;height:1.652em"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mrow><mo>|</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="normal">B</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">l</mi></mrow><mo>|</mo></mrow><mrow class="MJX-TeXAtom-ORD"><mrow><mo>|</mo><mrow><mrow><mo>(</mo><mrow><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="monospace">B</mi><mi mathvariant="monospace">o</mi><mi mathvariant="monospace">o</mi><mi mathvariant="monospace">l</mi></mrow><mo>Ã</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="monospace">B</mi><mi mathvariant="monospace">o</mi><mi mathvariant="monospace">o</mi><mi mathvariant="monospace">l</mi></mrow></mrow><mo>)</mo></mrow><mo stretchy="false">â</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="monospace">B</mi><mi mathvariant="monospace">o</mi><mi mathvariant="monospace">o</mi><mi mathvariant="monospace">l</mi></mrow></mrow><mo>|</mo></mrow></mrow></msup><mo>,</mo></math></span></span></div>
which is
<span class="MathJax_Preview" style="color:inherit;display:none"></span><div class="MathJax_Display" style="text-align:center"><span class="MathJax" id="MathJax-Element-64-Frame" tabindex="0" style="text-align:center;position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mrow><mo>|</mo><mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;monospace&quot;>B</mi><mi mathvariant=&quot;monospace&quot;>o</mi><mi mathvariant=&quot;monospace&quot;>o</mi><mi mathvariant=&quot;monospace&quot;>l</mi></mrow><mo>&amp;#x00D7;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi mathvariant=&quot;monospace&quot;>B</mi><mi mathvariant=&quot;monospace&quot;>o</mi><mi mathvariant=&quot;monospace&quot;>o</mi><mi mathvariant=&quot;monospace&quot;>l</mi></mrow></mrow><mo>|</mo></mrow></mrow></msup></mrow></msup><mo>,</mo></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-490" style="width:5.002em;display:inline-block"><span style="display:inline-block;position:relative;width:4.034em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.212em,1003.95em,2.704em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-491"><span class="msubsup" id="MathJax-Span-492"><span style="display:inline-block;position:relative;width:3.752em;height:0px"><span style="position:absolute;clip:rect(3.188em,1000.45em,4.115em,-999.998em);top:-3.99em;left:0em"><span class="mn" id="MathJax-Span-493" style="font-family:MathJax_Main">2</span><span style="display:inline-block;width:0px;height:3.994em"></span></span><span style="position:absolute;top:-4.393em;left:0.486em"><span class="texatom" id="MathJax-Span-494"><span class="mrow" id="MathJax-Span-495"><span class="msubsup" id="MathJax-Span-496"><span style="display:inline-block;position:relative;width:3.188em;height:0px"><span style="position:absolute;clip:rect(3.389em,1000.33em,4.115em,-999.998em);top:-3.99em;left:0em"><span class="mn" id="MathJax-Span-497" style="font-size:70.7%;font-family:MathJax_Main">2</span><span style="display:inline-block;width:0px;height:3.994em"></span></span><span style="position:absolute;top:-4.272em;left:0.365em"><span class="texatom" id="MathJax-Span-498"><span class="mrow" id="MathJax-Span-499"><span class="mrow" id="MathJax-Span-500"><span class="mo" id="MathJax-Span-501" style="font-size:50%;font-family:MathJax_Main">|</span><span class="mrow" id="MathJax-Span-502"><span class="texatom" id="MathJax-Span-503"><span class="mrow" id="MathJax-Span-504"><span class="mi" id="MathJax-Span-505" style="font-size:50%;font-family:MathJax_Typewriter">B</span><span class="mi" id="MathJax-Span-506" style="font-size:50%;font-family:MathJax_Typewriter">o</span><span class="mi" id="MathJax-Span-507" style="font-size:50%;font-family:MathJax_Typewriter">o</span><span class="mi" id="MathJax-Span-508" style="font-size:50%;font-family:MathJax_Typewriter">l</span></span></span><span class="mo" id="MathJax-Span-509" style="font-size:50%;font-family:MathJax_Main">Ã</span><span class="texatom" id="MathJax-Span-510"><span class="mrow" id="MathJax-Span-511"><span class="mi" id="MathJax-Span-512" style="font-size:50%;font-family:MathJax_Typewriter">B</span><span class="mi" id="MathJax-Span-513" style="font-size:50%;font-family:MathJax_Typewriter">o</span><span class="mi" id="MathJax-Span-514" style="font-size:50%;font-family:MathJax_Typewriter">o</span><span class="mi" id="MathJax-Span-515" style="font-size:50%;font-family:MathJax_Typewriter">l</span></span></span></span><span class="mo" id="MathJax-Span-516" style="font-size:50%;font-family:MathJax_Main">|</span></span></span></span><span style="display:inline-block;width:0px;height:3.994em"></span></span></span></span></span></span><span style="display:inline-block;width:0px;height:3.994em"></span></span></span></span><span class="mo" id="MathJax-Span-517" style="font-family:MathJax_Main">,</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.297em;border-left:0px solid;width:0px;height:1.652em"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mrow><mo>|</mo><mrow><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="monospace">B</mi><mi mathvariant="monospace">o</mi><mi mathvariant="monospace">o</mi><mi mathvariant="monospace">l</mi></mrow><mo>Ã</mo><mrow class="MJX-TeXAtom-ORD"><mi mathvariant="monospace">B</mi><mi mathvariant="monospace">o</mi><mi mathvariant="monospace">o</mi><mi mathvariant="monospace">l</mi></mrow></mrow><mo>|</mo></mrow></mrow></msup></mrow></msup><mo>,</mo></math></span></span></div>
which is
<span class="MathJax_Preview" style="color:inherit;display:none"></span><div class="MathJax_Display" style="text-align:center"><span class="MathJax" id="MathJax-Element-65-Frame" tabindex="0" style="text-align:center;position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msup><mn>2</mn><mn>4</mn></msup></mrow></msup></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-518" style="width:1.575em;display:inline-block"><span style="display:inline-block;position:relative;width:1.252em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.212em,1001.25em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-519"><span class="msubsup" id="MathJax-Span-520"><span style="display:inline-block;position:relative;width:1.252em;height:0px"><span style="position:absolute;clip:rect(3.188em,1000.45em,4.115em,-999.998em);top:-3.99em;left:0em"><span class="mn" id="MathJax-Span-521" style="font-family:MathJax_Main">2</span><span style="display:inline-block;width:0px;height:3.994em"></span></span><span style="position:absolute;top:-4.393em;left:0.486em"><span class="texatom" id="MathJax-Span-522"><span class="mrow" id="MathJax-Span-523"><span class="msubsup" id="MathJax-Span-524"><span style="display:inline-block;position:relative;width:0.647em;height:0px"><span style="position:absolute;clip:rect(3.389em,1000.33em,4.115em,-999.998em);top:-3.99em;left:0em"><span class="mn" id="MathJax-Span-525" style="font-size:70.7%;font-family:MathJax_Main">2</span><span style="display:inline-block;width:0px;height:3.994em"></span></span><span style="position:absolute;top:-4.272em;left:0.365em"><span class="mn" id="MathJax-Span-526" style="font-size:50%;font-family:MathJax_Main">4</span><span style="display:inline-block;width:0px;height:3.994em"></span></span></span></span></span></span><span style="display:inline-block;width:0px;height:3.994em"></span></span></span></span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:1.403em"></span></span></nobr><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><msup><mn>2</mn><mn>4</mn></msup></mrow></msup></math></span></span></div>
or 65536.
Nested exponentials grow quickly, and there are many higher-order functions.<p></p>
<h2 id="exercises-19"><a class="header" href="#exercises-19">Exercises</a></h2>
<ul>
<li>Write a function that converts any value from a type coded for by <code class="hljs">Finite</code> into a string. Functions should be represented as their tables.</li>
<li>Add the empty type <code class="hljs">Empty</code> to <code class="hljs">Finite</code> and <code class="hljs">Finite.beq</code>.</li>
<li>Add <code class="hljs">Option</code> to <code class="hljs">Finite</code> and <code class="hljs">Finite.beq</code>.</li>
</ul>
<div style="break-before:page;page-break-before:always"></div><h1 id="worked-example-typed-queries"><a class="header" href="#worked-example-typed-queries">Worked Example: Typed Queries</a></h1>
<p>Indexed families are very useful when building an API that is supposed to resemble some other language.
They can be used to write a library of HTML constructors that don't permit generating invalid HTML, to encode the specific rules of a configuration file format, or to model complicated business constraints.
This section describes an encoding of a subset of relational algebra in Lean using indexed families, as a simpler demonstration of techniques that can be used to build a more powerful database query language.</p>
<p>This subset uses the type system to enforce requirements such as disjointness of field names, and it uses type-level computation to reflect the schema into the types of values that are returned from a query.
It is not a realistic system, howeverâdatabases are represented as linked lists of linked lists, the type system is much simpler than that of SQL, and the operators of relational algebra don't really match those of SQL.
However, it is large enough to demonstrate useful principles and techniques.</p>
<h2 id="a-universe-of-data"><a class="header" href="#a-universe-of-data">A Universe of Data</a></h2>
<p>In this relational algebra, the base data that can be held in columns can have types <code class="hljs">Int</code>, <code class="hljs">String</code>, and <code class="hljs">Bool</code> and are described by the universe <code class="hljs">DBType</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> DBType <span class="hljs-keyword">where</span>
  | int | string | bool

<span class="hljs-keyword">abbrev</span> DBType.asType : DBType â <span class="hljs-built_in">Type</span>
  | .int =&gt; Int
  | .string =&gt; String
  | .bool =&gt; Bool
</code></pre>
<p>Using <code class="hljs">asType</code> allows these codes to be used for types.
For example:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (<span class="hljs-string">"Mount Hood"</span> : DBType.string.asType)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">"Mount Hood"
</code></pre>
<p>It is possible to compare the values described by any of the three database types for equality.
Explaining this to Lean, however, requires a bit of work.
Simply using <code class="hljs">BEq</code> directly fails:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">D</span><span class="hljs-title">B</span><span class="hljs-title">T</span><span class="hljs-title">y</span><span class="hljs-title">p</span><span class="hljs-title">e</span>.<span class="hljs-title">b</span><span class="hljs-title">e</span><span class="hljs-title">q</span> <span class="hljs-params">(t : DBType)</span> <span class="hljs-params">(x y : t.asType)</span> <span class="hljs-symbol">:</span></span> Bool :=
  x == y
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">failed to synthesize instance
  BEq (asType t)
</code></pre>
<p>Just as in the nested pairs universe, type class search doesn't automatically check each possibility for <code class="hljs">t</code>'s value
The solution is to use pattern matching to refine the types of <code class="hljs">x</code> and <code class="hljs">y</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">D</span><span class="hljs-title">B</span><span class="hljs-title">T</span><span class="hljs-title">y</span><span class="hljs-title">p</span><span class="hljs-title">e</span>.<span class="hljs-title">b</span><span class="hljs-title">e</span><span class="hljs-title">q</span> <span class="hljs-params">(t : DBType)</span> <span class="hljs-params">(x y : t.asType)</span> <span class="hljs-symbol">:</span></span> Bool :=
  <span class="hljs-keyword">match</span> t <span class="hljs-keyword">with</span>
  | .int =&gt; x == y
  | .string =&gt; x == y
  | .bool =&gt; x == y
</code></pre>
<p>In this version of the function, <code class="hljs">x</code> and <code class="hljs">y</code> have types <code class="hljs">Int</code>, <code class="hljs">String</code>, and <code class="hljs">Bool</code> in the three respective cases, and these types all have <code class="hljs">BEq</code> instances.
The definition of <code class="hljs">dbEq</code> can be used to define a <code class="hljs">BEq</code> instance for the types that are coded for by <code class="hljs">DBType</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">{t : DBType}</span> <span class="hljs-symbol">:</span></span> BEq t.asType <span class="hljs-keyword">where</span>
  beq := t.beq
</code></pre>
<p>This is not the same as an instance for the codes themselves:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> BEq DBType <span class="hljs-keyword">where</span>
  beq
    | .int, .int =&gt; true
    | .string, .string =&gt; true
    | .bool, .bool =&gt; true
    | _, _ =&gt; false
</code></pre>
<p>The former instance allows comparison of values drawn from the types described by the codes, while the latter allows comparison of the codes themselves.</p>
<p>A <code class="hljs">Repr</code> instance can be written using the same technique.
The method of the <code class="hljs">Repr</code> class is called <code class="hljs">reprPrec</code> because it is designed to take things like operator precedence into account when displaying values.
Refining the type through dependent pattern matching allows the <code class="hljs">reprPrec</code> methods from the <code class="hljs">Repr</code> instances for <code class="hljs">Int</code>, <code class="hljs">String</code>, and <code class="hljs">Bool</code> to be used:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-params">{t : DBType}</span> <span class="hljs-symbol">:</span></span> Repr t.asType <span class="hljs-keyword">where</span>
  reprPrec :=
    <span class="hljs-keyword">match</span> t <span class="hljs-keyword">with</span>
    | .int =&gt; reprPrec
    | .string =&gt; reprPrec
    | .bool =&gt; reprPrec
</code></pre>
<h2 id="schemas-and-tables"><a class="header" href="#schemas-and-tables">Schemas and Tables</a></h2>
<p>A schema describes the name and type of each column in a database:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">C</span><span class="hljs-title">o</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">n</span></span> <span class="hljs-keyword">where</span>
  name : String
  contains : DBType

<span class="hljs-keyword">abbrev</span> Schema := List Column
</code></pre>
<p>In fact, a schema can be seen as a universe that describes rows in a table.
The empty schema describes the unit type, a schema with a single column describes that value on its own, and a schema with at least two columns is represented by a tuple:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">abbrev</span> Row : Schema â <span class="hljs-built_in">Type</span>
  | [] =&gt; Unit
  | [col] =&gt; col.contains.asType
  | col1 :: col2 :: cols =&gt; col1.contains.asType Ã Row (col2::cols)
</code></pre>
<p>As described in <a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/polymorphism.html#prod">the initial section on product types</a>, Lean's product type and tuples are right-associative.
This means that nested pairs are equivalent to ordinary flat tuples.</p>
<p>A table is a list of rows that share a schema:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">abbrev</span> Table (s : Schema) := List (Row s)
</code></pre>
<p>For example, a diary of visits to mountain peaks can be represented with the schema <code class="hljs">peak</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">abbrev</span> peak : Schema := [
  â¨<span class="hljs-string">"name"</span>, DBType.stringâ©,
  â¨<span class="hljs-string">"location"</span>, DBType.stringâ©,
  â¨<span class="hljs-string">"elevation"</span>, DBType.intâ©,
  â¨<span class="hljs-string">"lastVisited"</span>, .intâ©
]
</code></pre>
<p>A selection of peaks visited by the author of this book appears as an ordinary list of tuples:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">D</span><span class="hljs-title">i</span><span class="hljs-title">a</span><span class="hljs-title">r</span><span class="hljs-title">y</span> <span class="hljs-symbol">:</span></span> Table peak := [
  (<span class="hljs-string">"Mount Nebo"</span>,       <span class="hljs-string">"USA"</span>,     <span class="hljs-number">3637</span>, <span class="hljs-number">2013</span>),
  (<span class="hljs-string">"Moscow Mountain"</span>,  <span class="hljs-string">"USA"</span>,     <span class="hljs-number">1519</span>, <span class="hljs-number">2015</span>),
  (<span class="hljs-string">"Himmelbjerget"</span>,    <span class="hljs-string">"Denmark"</span>,  <span class="hljs-number">147</span>, <span class="hljs-number">2004</span>),
  (<span class="hljs-string">"Mount St. Helens"</span>, <span class="hljs-string">"USA"</span>,     <span class="hljs-number">2549</span>, <span class="hljs-number">2010</span>)
]
</code></pre>
<p>Another example consists of waterfalls and a diary of visits to them:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">abbrev</span> waterfall : Schema := [
  â¨<span class="hljs-string">"name"</span>, .stringâ©,
  â¨<span class="hljs-string">"location"</span>, .stringâ©,
  â¨<span class="hljs-string">"lastVisited"</span>, .intâ©
]

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">w</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">f</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">l</span><span class="hljs-title">D</span><span class="hljs-title">i</span><span class="hljs-title">a</span><span class="hljs-title">r</span><span class="hljs-title">y</span> <span class="hljs-symbol">:</span></span> Table waterfall := [
  (<span class="hljs-string">"Multnomah Falls"</span>, <span class="hljs-string">"USA"</span>, <span class="hljs-number">2018</span>),
  (<span class="hljs-string">"Shoshone Falls"</span>,  <span class="hljs-string">"USA"</span>, <span class="hljs-number">2014</span>)
]
</code></pre>
<h3 id="recursion-and-universes-revisited"><a class="header" href="#recursion-and-universes-revisited">Recursion and Universes, Revisited</a></h3>
<p>The convenient structuring of rows as tuples comes at a cost: the fact that <code class="hljs">Row</code> treats its two base cases separately means that functions that use <code class="hljs">Row</code> in their types and are defined recursively over the codes (that, is the schema) need to make the same distinctions.
One example of a case where this matters is an equality check that uses recursion over the schema to define a function that checks rows for equality.
This example does not pass Lean's type checker:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">R</span><span class="hljs-title">ow</span>.<span class="hljs-title">b</span><span class="hljs-title">E</span><span class="hljs-title">q</span> <span class="hljs-params">(r1 r2 : Row s)</span> <span class="hljs-symbol">:</span></span> Bool :=
  <span class="hljs-keyword">match</span> s <span class="hljs-keyword">with</span>
  | [] =&gt; true
  | col::cols =&gt;
    <span class="hljs-keyword">match</span> r1, r2 <span class="hljs-keyword">with</span>
    | (v1, r1'), (v2, r2') =&gt;
      v1 == v2 &amp;&amp; bEq r1' r2'
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">type mismatch
  (v1, r1')
has type
  ?m.6559 Ã ?m.6562 : Type (max ?u.6571 ?u.6570)
but is expected to have type
  Row (col :: cols) : Type
</code></pre>
<p>The problem is that the pattern <code class="hljs">col :: cols</code> does not sufficiently refine the type of the rows.
This is because Lean cannot yet tell whether the singleton pattern <code class="hljs">[col]</code> or the <code class="hljs">col1 :: col2 :: cols</code> pattern in the definition of <code class="hljs">Row</code> was matched, so the call to <code class="hljs">Row</code> does not compute down to a pair type.
The solution is to mirror the structure of <code class="hljs">Row</code> in the definition of <code class="hljs">Row.bEq</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">R</span><span class="hljs-title">ow</span>.<span class="hljs-title">b</span><span class="hljs-title">E</span><span class="hljs-title">q</span> <span class="hljs-params">(r1 r2 : Row s)</span> <span class="hljs-symbol">:</span></span> Bool :=
  <span class="hljs-keyword">match</span> s <span class="hljs-keyword">with</span>
  | [] =&gt; true
  | [_] =&gt; r1 == r2
  | _::_::_ =&gt;
    <span class="hljs-keyword">match</span> r1, r2 <span class="hljs-keyword">with</span>
    | (v1, r1'), (v2, r2') =&gt;
      v1 == v2 &amp;&amp; bEq r1' r2'

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> BEq (Row s) <span class="hljs-keyword">where</span>
  beq := Row.bEq
</code></pre>
<p>Unlike in other contexts, functions that occur in types cannot be considered only in terms of their input/output behavior.
Programs that use these types will find themselves forced to mirror the algorithm used in the type-level function so that their structure matches the pattern-matching and recursive behavior of the type.
A big part of the skill of programming with dependent types is the selection of appropriate type-level functions with the right computational behavior.</p>
<h3 id="column-pointers"><a class="header" href="#column-pointers">Column Pointers</a></h3>
<p>Some queries only make sense if a schema contains a particular column.
For example, a query that returns mountains with an elevation greater than 1000 meters only makes sense in the context of a schema with a <code class="hljs">"elevation"</code> column that contains integers.
One way to indicate that a column is contained in a schema is to provide a pointer directly to it, and defining the pointer as an indexed family makes it possible to rule out invalid pointers.</p>
<p>There are two ways that a column can be present in a schema: either it is at the beginning of the schema, or it is somewhere later in the schema.
Eventually, if a column is later in a schema, then it will be the beginning of some tail of the schema.</p>
<p>The indexed family <code class="hljs">HasCol</code> is a translation of the specification into Lean code:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> HasCol : Schema â String â DBType â <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  | here : HasCol (â¨name, tâ© :: _) name t
  | there : HasCol s name t â HasCol (_ :: s) name t
</code></pre>
<p>The family's three arguments are the schema, the column name, and its type.
All three are indices, but re-ordering the arguments to place the schema after the column name and type would allow the name and type to be parameters.
The constructor <code class="hljs">here</code> can be used when the schema begins with the column <code class="hljs">â¨name, tâ©</code>; it is thus a pointer to the first column in the schema that can only be used when the first column has the desired name and type.
The constructor <code class="hljs">there</code> transforms a pointer into a smaller schema into a pointer into a schema with one more column on it.</p>
<p>Because <code class="hljs">"elevation"</code> is the third column in <code class="hljs">peak</code>, it can be found by looking past the first two columns with <code class="hljs">there</code>, after which it is the first column.
In other words, to satisfy the type <code class="hljs">HasCol peak "elevation" .int</code>, use the expression <code class="hljs">.there (.there .here)</code>.
One way to think about <code class="hljs">HasCol</code> is as a kind of decorated <code class="hljs">Nat</code>â<code class="hljs">zero</code> corresponds to <code class="hljs">here</code>, and <code class="hljs">succ</code> corresponds to <code class="hljs">there</code>.
The extra type information makes it impossible to have off-by-one errors.</p>
<p>A pointer to a particular column in a schema can be used to extract that column's value from a row:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">R</span><span class="hljs-title">ow</span>.<span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">t</span> <span class="hljs-params">(row : Row s)</span> <span class="hljs-params">(col : HasCol s n t)</span> <span class="hljs-symbol">:</span></span> t.asType :=
  <span class="hljs-keyword">match</span> s, col, row <span class="hljs-keyword">with</span>
  | [_], .here, v =&gt; v
  | _::_::_, .here, (v, _) =&gt; v
  | _::_::_, .there next, (_, r) =&gt; get r next
</code></pre>
<p>The first step is to pattern match on the schema, because this determines whether the row is a tuple or a single value.
No case is needed for the empty schema because there is a <code class="hljs">HasCol</code> available, and both constructors of <code class="hljs">HasCol</code> specify non-empty schemas.
If the schema has just a single column, then the pointer must point to it, so only the <code class="hljs">here</code> constructor of <code class="hljs">HasCol</code> need be matched.
If the schema has two or more columns, then there must be a case for <code class="hljs">here</code>, in which case the value is the first one in the row, and one for <code class="hljs">there</code>, in which case a recursive call is used.
Because the <code class="hljs">HasCol</code> type guarantees that the column exists in the row, <code class="hljs">Row.get</code> does not need to return an <code class="hljs">Option</code>.</p>
<p><code class="hljs">HasCol</code> plays two roles:</p>
<ol>
<li>
<p>It serves as <em>evidence</em> that a column with a particular name and type exists in a schema.</p>
</li>
<li>
<p>It serves as <em>data</em> that can be used to find the value associated with the column in a row.</p>
</li>
</ol>
<p>The first role, that of evidence, is similar to way that propositions are used.
The definition of the indexed family <code class="hljs">HasCol</code> can be read as a specification of what counts as evidence that a given column exists.
Unlike propositions, however, it matters which constructor of <code class="hljs">HasCol</code> was used.
In the second role, the constructors are used like <code class="hljs">Nat</code>s to find data in a collection.
Programming with indexed families often requires the ability to switch fluently between both perspectives.</p>
<h3 id="subschemas"><a class="header" href="#subschemas">Subschemas</a></h3>
<p>One important operation in relational algebra is to <em>project</em> a table or row into a smaller schema.
Every column not present in the smaller schema is forgotten.
In order for projection to make sense, the smaller schema must be a subschema of the larger schema, which means that every column in the smaller schema must be present in the larger schema.
Just as <code class="hljs">HasCol</code> makes it possible to write a single-column lookup in a row that cannot fail, a representation of the subschema relationship as an indexed family makes it possible to write a projection function that cannot fail.</p>
<p>The ways in which one schema can be a subschema of another can be defined as an indexed family.
The basic idea is that a smaller schema is a subschema of a bigger schema if every column in the smaller schema occurs in the bigger schema.
If the smaller schema is empty, then it's certainly a subschema of the bigger schema, represented by the constructor <code class="hljs">nil</code>.
If the smaller schema has a column, then that column must be in the bigger schema, and all the rest of the columns in the subschema must also be a subschema of the bigger schema.
This is represented by the constructor <code class="hljs">cons</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Subschema : Schema â Schema â <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  | nil : Subschema [] bigger
  | cons :
      HasCol bigger n t â
      Subschema smaller bigger â
      Subschema (â¨n, tâ© :: smaller) bigger
</code></pre>
<p>In other words, <code class="hljs">Subschema</code> assigns each column of the smaller schema a <code class="hljs">HasCol</code> that points to its location in the larger schema.</p>
<p>The schema <code class="hljs">travelDiary</code> represents the fields that are common to both <code class="hljs">peak</code> and <code class="hljs">waterfall</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">abbrev</span> travelDiary : Schema :=
  [â¨<span class="hljs-string">"name"</span>, .stringâ©, â¨<span class="hljs-string">"location"</span>, .stringâ©, â¨<span class="hljs-string">"lastVisited"</span>, .intâ©]
</code></pre>
<p>It is certainly a subschema of <code class="hljs">peak</code>, as shown by this example:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : Subschema travelDiary peak :=
  .cons .here
    (.cons (.there .here)
      (.cons (.there (.there (.there .here))) .nil))
</code></pre>
<p>However, code like this is difficult to read and difficult to maintain.
One way to improve it is to instruct Lean to write the <code class="hljs">Subschema</code> and <code class="hljs">HasCol</code> constructors automatically.
This can be done using the tactic feature that was introduced in <a href="https://leanprover.github.io/functional_programming_in_lean/props-proofs-indexing.html">the Interlude on propositions and proofs</a>.
That interlude uses <code class="hljs">by simp</code> to provide evidence of various propositions.</p>
<p>In this context, two tactics are useful:</p>
<ul>
<li>The <code class="hljs">constructor</code> tactic instructs Lean to solve the problem using the constructor of a datatype.</li>
<li>The <code class="hljs">repeat</code> tactic instructs Lean to repeat a tactic over and over until it either fails or the proof is finished.</li>
</ul>
<p>In the next example, <code class="hljs">by constructor</code> has the same effect as just writing <code class="hljs">.nil</code> would have:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-keyword">example</span> : Subschema [] peak := <span class="hljs-keyword">by</span> <span class="hljs-keyword">constructor</span>
</code></pre>
<p>However, attempting that same tactic with a slightly more complicated type fails:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-keyword">example</span> : Subschema [â¨<span class="hljs-string">"location"</span>, .stringâ©] peak := <span class="hljs-keyword">by</span> <span class="hljs-keyword">constructor</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case a
â¢ HasCol peak "location" DBType.string

case a
â¢ Subschema [] peak
</code></pre>
<p>Errors that begin with <code class="hljs">unsolved goals</code> describe tactics that failed to completely build the expressions that they were supposed to.
In Lean's tactic language, a <em>goal</em> is a type that a tactic is to fulfill by constructing an appropriate expression behind the scenes.
In this case, <code class="hljs">constructor</code> caused <code class="hljs">Subschema.cons</code> to be applied, and the two goals represent the two arguments expected by <code class="hljs">cons</code>.
Adding another instance of <code class="hljs">constructor</code> causes the first goal (<code class="hljs">HasCol peak \"location\" DBType.string</code>) to be addressed with <code class="hljs">HasCol.there</code>, because <code class="hljs">peak</code>'s first column is not <code class="hljs">"location"</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-keyword">example</span> : Subschema [â¨<span class="hljs-string">"location"</span>, .stringâ©] peak := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">constructor</span>
  <span class="hljs-keyword">constructor</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case a.a
â¢ HasCol
    [{ name := "location", contains := DBType.string }, { name := "elevation", contains := DBType.int },
      { name := "lastVisited", contains := DBType.int }]
    "location" DBType.string

case a
â¢ Subschema [] peak
</code></pre>
<p>However, adding a third <code class="hljs">constructor</code> results in the first goal being solved, because <code class="hljs">HasCol.here</code> is applicable:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-keyword">example</span> : Subschema [â¨<span class="hljs-string">"location"</span>, .stringâ©] peak := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">constructor</span>
  <span class="hljs-keyword">constructor</span>
  <span class="hljs-keyword">constructor</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case a
â¢ Subschema [] peak
</code></pre>
<p>A fourth instance of <code class="hljs">constructor</code> solves the <code class="hljs">Subschema peak []</code> goal:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-keyword">example</span> : Subschema [â¨<span class="hljs-string">"location"</span>, .stringâ©] peak := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">constructor</span>
  <span class="hljs-keyword">constructor</span>
  <span class="hljs-keyword">constructor</span>
  <span class="hljs-keyword">constructor</span>
</code></pre>
<p>Indeed, a version written without the use of tactics has four constructors:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">example</span> : Subschema [â¨<span class="hljs-string">"location"</span>, .stringâ©] peak :=
  .cons (.there .here) .nil
</code></pre>
<p>Instead of experimenting to find the right number of times to write <code class="hljs">constructor</code>, the <code class="hljs">repeat</code> tactic can be used to ask Lean to just keep trying <code class="hljs">constructor</code> as long as it keeps making progress:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-keyword">example</span> : Subschema [â¨<span class="hljs-string">"location"</span>, .stringâ©] peak := <span class="hljs-keyword">by</span> <span class="hljs-keyword">repeat</span> <span class="hljs-keyword">constructor</span>
</code></pre>
<p>This more flexible version also works for more interesting <code class="hljs">Subschema</code> problems:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-keyword">example</span> : Subschema travelDiary peak := <span class="hljs-keyword">by</span> <span class="hljs-keyword">repeat</span> <span class="hljs-keyword">constructor</span>

<span class="hljs-keyword">example</span> : Subschema travelDiary waterfall := <span class="hljs-keyword">by</span> <span class="hljs-keyword">repeat</span> <span class="hljs-keyword">constructor</span>
</code></pre>
<p>The approach of blindly trying constructors until something works is not very useful for types like <code class="hljs">Nat</code> or <code class="hljs">List Bool</code>.
Just because an expression has type <code class="hljs">Nat</code> doesn't mean that it's the <em>correct</em> <code class="hljs">Nat</code>, after all.
But types like <code class="hljs">HasCol</code> and <code class="hljs">Subschema</code> are sufficiently constrained by their indices that only one constructor will ever be applicable, which means that the contents of the program itself are less interesting, and a computer can pick the correct one.</p>
<p>If one schema is a subschema of another, then it is also a subschema of the larger schema extended with an additional column.
This fact can be captured as a function definition.
<code class="hljs">Subschema.addColumn</code> takes evidence that <code class="hljs">smaller</code> is a subschema of <code class="hljs">bigger</code>, and then returns evidence that <code class="hljs">smaller</code> is a subschema of <code class="hljs">c :: bigger</code>, that is, <code class="hljs">bigger</code> with one additional column:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">S</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">s</span><span class="hljs-title">c</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">m</span><span class="hljs-title">a</span>.<span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">d</span><span class="hljs-title">C</span><span class="hljs-title">o</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">n</span> <span class="hljs-params">(sub : Subschema smaller bigger)</span> <span class="hljs-symbol">:</span></span> Subschema smaller (c :: bigger) :=
  <span class="hljs-keyword">match</span> sub <span class="hljs-keyword">with</span>
  | .nil  =&gt; .nil
  | .cons col sub' =&gt; .cons (.there col) sub'.addColumn
</code></pre>
<p>A subschema describes where to find each column from the smaller schema in the larger schema.
<code class="hljs">Subschema.addColumn</code> must translate these descriptions from the original larger schema into the extended larger schema.
In the <code class="hljs">nil</code> case, the smaller schema is <code class="hljs">[]</code>, and <code class="hljs">nil</code> is also evidence that <code class="hljs">[]</code> is a subschema of <code class="hljs">c :: bigger</code>.
In the <code class="hljs">cons</code> case, which describes how to place one column from <code class="hljs">smaller</code> into <code class="hljs">larger</code>, the placement of the column needs to be adjusted with <code class="hljs">there</code> to account for the new column <code class="hljs">c</code>, and a recursive call adjusts the rest of the columns.</p>
<p>Another way to think about <code class="hljs">Subschema</code> is that it defines a <em>relation</em> between two schemasâthe existence of an expression  with type <code class="hljs">Subschema bigger smaller</code> means that <code class="hljs">(bigger, smaller)</code> is in the relation.
This relation is reflexive, meaning that every schema is a subschema of itself:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">S</span><span class="hljs-title">u</span><span class="hljs-title">b</span><span class="hljs-title">s</span><span class="hljs-title">c</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">m</span><span class="hljs-title">a</span>.<span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">x</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> (s : Schema) â Subschema s s
  | [] =&gt; .nil
  | _ :: cs =&gt; .cons .here (reflexive cs).addColumn
</code></pre>
<h3 id="projecting-rows"><a class="header" href="#projecting-rows">Projecting Rows</a></h3>
<p>Given evidence that <code class="hljs">s'</code> is a subschema of <code class="hljs">s</code>, a row in <code class="hljs">s</code> can be projected into a row in <code class="hljs">s'</code>.
This is done using the evidence that <code class="hljs">s'</code> is a subschema of <code class="hljs">s</code>, which explains where each column of <code class="hljs">s'</code> is found in <code class="hljs">s</code>.
The new row in <code class="hljs">s'</code> is built up one column at a time by retrieving the value from the appropriate place in the old row.</p>
<p>The function that performs this projection, <code class="hljs">Row.project</code>, has three cases, one for each case of <code class="hljs">Row</code> itself.
It uses <code class="hljs">Row.get</code> together with each <code class="hljs">HasCol</code> in the <code class="hljs">Subschema</code> argument to construct the projected row:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">R</span><span class="hljs-title">ow</span>.<span class="hljs-title">p</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">j</span><span class="hljs-title">e</span><span class="hljs-title">c</span><span class="hljs-title">t</span> <span class="hljs-params">(row : Row s)</span> <span class="hljs-symbol">:</span></span> (s' : Schema) â Subschema s' s â Row s'
  | [], .nil =&gt; ()
  | [_], .cons c .nil =&gt; row.get c
  | _::_::_, .cons c cs =&gt; (row.get c, row.project _ cs)
</code></pre>
<h2 id="conditions-and-selection"><a class="header" href="#conditions-and-selection">Conditions and Selection</a></h2>
<p>Projection removes unwanted columns from a table, but queries must also be able to remove unwanted rows.
This operation is called <em>selection</em>.
Selection relies on having a means of expressing which rows are desired.</p>
<p>The example query language contains expressions, which are analogous to what can be written in a <code class="hljs">WHERE</code> clause in SQL.
Expressions are represented by the indexed family <code class="hljs">DBExpr</code>.
Because expressions can refer to columns from the database, but different sub-expressions all have the same schema, <code class="hljs">DBExpr</code> takes the database schema as a parameter.
Additionally, each expression has a type, and these vary, making it an index:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> DBExpr (s : Schema) : DBType â <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  | col (n : String) (loc : HasCol s n t) : DBExpr s t
  | eq (e1 e2 : DBExpr s t) : DBExpr s .bool
  | lt (e1 e2 : DBExpr s .int) : DBExpr s .bool
  | and (e1 e2 : DBExpr s .bool) : DBExpr s .bool
  | const : t.asType â DBExpr s t
</code></pre>
<p>The <code class="hljs">col</code> constructor represents a reference to a column in the database.
The <code class="hljs">eq</code> constructor compares two expressions for equality, <code class="hljs">lt</code> checks whether one is less than the other, <code class="hljs">and</code> is Boolean conjunction, and <code class="hljs">const</code> is a constant value of some type.</p>
<p>For example, an expression in <code class="hljs">peak</code> that checks whether the <code class="hljs">elevation</code> column is greater than 1000 and the location is <code class="hljs">"Denmark"</code> can be written:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">l</span><span class="hljs-title">I</span><span class="hljs-title">n</span><span class="hljs-title">D</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">r</span><span class="hljs-title">k</span> <span class="hljs-symbol">:</span></span> DBExpr peak .bool :=
  .and (.lt (.const <span class="hljs-number">1000</span>) (.col <span class="hljs-string">"elevation"</span> (<span class="hljs-keyword">by</span> <span class="hljs-keyword">repeat</span> <span class="hljs-keyword">constructor</span>)))
       (.eq (.col <span class="hljs-string">"location"</span> (<span class="hljs-keyword">by</span> <span class="hljs-keyword">repeat</span> <span class="hljs-keyword">constructor</span>)) (.const <span class="hljs-string">"Denmark"</span>))
</code></pre>
<p>This is somewhat noisy.
In particular, references to columns contain boilerplate calls to <code class="hljs">by repeat constructor</code>.
A Lean feature called <em>macros</em> can help make expressions easier to read by eliminating this boilerplate:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-keyword">macro</span> <span class="hljs-string">"c!"</span> n:term : term =&gt; `(DBExpr.col $n (<span class="hljs-keyword">by</span> <span class="hljs-keyword">repeat</span> <span class="hljs-keyword">constructor</span>))
</code></pre>
<p>This declaration adds the <code class="hljs">c!</code> keyword to Lean, and instructs Lean to replace any instance of <code class="hljs">c!</code> followed by an expression with the corresponding <code class="hljs">DBExpr.col</code> construction.
Here, <code class="hljs">term</code> stands for Lean expressions, rather than commands, tactics, or some other part of the language.
Lean macros are a bit like C preprocessor macros, except they are better integrated into the language and they automatically avoid some of the pitfalls of CPP.
In fact, they are very closely related to macros in Scheme and Racket.</p>
<p>With this macro, the expression can be much easier to read:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">l</span><span class="hljs-title">I</span><span class="hljs-title">n</span><span class="hljs-title">D</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">r</span><span class="hljs-title">k</span> <span class="hljs-symbol">:</span></span> DBExpr peak .bool :=
  .and (.lt (.const <span class="hljs-number">1000</span>) (c! <span class="hljs-string">"elevation"</span>))
       (.eq (c! <span class="hljs-string">"location"</span>) (.const <span class="hljs-string">"Denmark"</span>))
</code></pre>
<p>Finding the value of an expression with respect to a given row uses <code class="hljs">Row.get</code> to extract column references, and it delegates to Lean's operations on values for every other expression:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">D</span><span class="hljs-title">B</span><span class="hljs-title">E</span><span class="hljs-title">x</span><span class="hljs-title">p</span><span class="hljs-title">r</span>.<span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">a</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">e</span> <span class="hljs-params">(row : Row s)</span> <span class="hljs-symbol">:</span></span> DBExpr s t â t.asType
  | .col _ loc =&gt; row.get loc
  | .eq e1 e2  =&gt; evaluate row e1 == evaluate row e2
  | .lt e1 e2  =&gt; evaluate row e1 &lt; evaluate row e2
  | .and e1 e2 =&gt; evaluate row e1 &amp;&amp; evaluate row e2
  | .const v =&gt; v
</code></pre>
<p>Evaluating the expression for Valby Bakke, the tallest hill in the Copenhagen area, yields <code class="hljs">false</code> because Valby Bakke is much less than 1 km over sea level:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> tallInDenmark.evaluate (<span class="hljs-string">"Valby Bakke"</span>, <span class="hljs-string">"Denmark"</span>, <span class="hljs-number">31</span>, <span class="hljs-number">2023</span>)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">false
</code></pre>
<p>Evaluating it for a fictional mountain of 1230m elevation yields <code class="hljs">true</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> tallInDenmark.evaluate (<span class="hljs-string">"Fictional mountain"</span>, <span class="hljs-string">"Denmark"</span>, <span class="hljs-number">1230</span>, <span class="hljs-number">2023</span>)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">true
</code></pre>
<p>Evaluating it for the highest peak in the US state of Idaho yields <code class="hljs">false</code>, as Idaho is not part of Denmark:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> tallInDenmark.evaluate (<span class="hljs-string">"Mount Borah"</span>, <span class="hljs-string">"USA"</span>, <span class="hljs-number">3859</span>, <span class="hljs-number">1996</span>)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">false
</code></pre>
<h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<p>The query language is based on relational algebra.
In addition to tables, it includes the following operators:</p>
<ol>
<li>The union of two expressions that have the same schema combines the rows that result from two queries</li>
<li>The difference of two expressions that have the same schema removes rows found in the second result from the rows in the first result</li>
<li>Selection by some criterion filters the result of a query according to an expression</li>
<li>Projection into a subschema, removing columns from the result of a query</li>
<li>Cartesian product, combining every row from one query with every row from another</li>
<li>Renaming a column in the result of a query, which modifies its schema</li>
<li>Prefixing all columns in a query with a name</li>
</ol>
<p>The last operator is not strictly necessary, but it makes the language more convenient to use.</p>
<p>Once again, queries are represented by an indexed family:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Query : Schema â <span class="hljs-built_in">Type</span> <span class="hljs-keyword">where</span>
  | table : Table s â Query s
  | union : Query s â Query s â Query s
  | diff : Query s â Query s â Query s
  | select : Query s â DBExpr s .bool â Query s
  | project : Query s â (s' : Schema) â Subschema s' s â Query s'
  | product :
      Query s1 â Query s2 â
      disjoint (s1.map Column.name) (s2.map Column.name) â
      Query (s1 ++ s2)
  | renameColumn :
      Query s â (c : HasCol s n t) â (n' : String) â !((s.map Column.name).contains n') â
      Query (s.renameColumn c n')
  | prefixWith :
      (n : String) â Query s â
      Query (s.map <span class="hljs-keyword">fun</span> c =&gt; {c <span class="hljs-keyword">with</span> name := n ++ <span class="hljs-string">"."</span> ++ c.name})
</code></pre>
<p>The <code class="hljs">select</code> constructor requires that the expression used for selection return a Boolean.
The <code class="hljs">product</code> constructor's type contains a call to <code class="hljs">disjoint</code>, which ensures that the two schemas don't share any names:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">j</span><span class="hljs-title">o</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-params">[BEq Î±]</span> <span class="hljs-params">(xs ys : List Î±)</span> <span class="hljs-symbol">:</span></span> Bool :=
  not (xs.any ys.contains || ys.any xs.contains)
</code></pre>
<p>The use of an expression of type <code class="hljs">Bool</code> where a type is expected triggers a coercion from <code class="hljs">Bool</code> to <code class="hljs">Prop</code>.
Just as decidable propositions can be considered to be Booleans, where evidence for the proposition is coerced to <code class="hljs">true</code> and refutations of the proposition are coerced to <code class="hljs">false</code>, Booleans are coerced into the proposition that states that the expression is equal to <code class="hljs">true</code>.
Because all uses of the library are expected to occur in contexts where the schemas are known ahead of time, this proposition can be proved with <code class="hljs">by simp</code>.
Similarly, the <code class="hljs">renameColumn</code> constructor checks that the new name does not already exist in the schema.
It uses the helper <code class="hljs">Schema.renameColumn</code> to change the name of the column pointed to by <code class="hljs">HasCol</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">S</span><span class="hljs-title">c</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">m</span><span class="hljs-title">a</span>.<span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">a</span><span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">C</span><span class="hljs-title">o</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> (s : Schema) â HasCol s n t â String â Schema
  | c :: cs, .here, n' =&gt; {c <span class="hljs-keyword">with</span> name := n'} :: cs
  | c :: cs, .there next, n' =&gt; c :: renameColumn cs next n'
</code></pre>
<h2 id="executing-queries"><a class="header" href="#executing-queries">Executing Queries</a></h2>
<p>Executing queries requires a number of helper functions.
The result of a query is a table; this means that each operation in the query language requires a corresponding implementation that works with tables.</p>
<h3 id="cartesian-product"><a class="header" href="#cartesian-product">Cartesian Product</a></h3>
<p>Taking the Cartesian product of two tables is done by appending each row from the first table to each row from the second.
First off, due to the structure of <code class="hljs">Row</code>, adding a single column to a row requires pattern matching on its schema in order to determine whether the result will be a bare value or a tuple.
Because this is a common operation, factoring the pattern matching out into a helper is convenient:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">d</span><span class="hljs-title">V</span><span class="hljs-title">a</span><span class="hljs-title">l</span> <span class="hljs-params">(v : c.contains.asType)</span> <span class="hljs-params">(row : Row s)</span> <span class="hljs-symbol">:</span></span> Row (c :: s) :=
  <span class="hljs-keyword">match</span> s, row <span class="hljs-keyword">with</span>
  | [], () =&gt; v
  | c' :: cs, v' =&gt; (v, v')
</code></pre>
<p>Appending two rows is recursive on the structure of both the first schema and the first row, because the structure of the row proceeds in lock-step with the structure of the schema.
When the first row is empty, appending returns the second row.
When the first row is a singleton, the value is added to the second row.
When the first row contains multiple columns, the first column's value is added to the result of recursion on the remainder of the row.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">R</span><span class="hljs-title">ow</span>.<span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">(r1 : Row s1)</span> <span class="hljs-params">(r2 : Row s2)</span> <span class="hljs-symbol">:</span></span> Row (s1 ++ s2) :=
  <span class="hljs-keyword">match</span> s1, r1 <span class="hljs-keyword">with</span>
  | [], () =&gt; r2
  | [_], v =&gt; addVal v r2
  | _::_::_, (v, r') =&gt; (v, r'.append r2)
</code></pre>
<p><code class="hljs">List.flatMap</code> applies a function that itself returns a list to every entry in an input list, returning the result of appending the resulting lists in order:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">f</span><span class="hljs-title">l</span><span class="hljs-title">a</span><span class="hljs-title">t</span><span class="hljs-title">M</span><span class="hljs-title">a</span><span class="hljs-title">p</span> <span class="hljs-params">(f : Î± â List Î²)</span> <span class="hljs-symbol">:</span></span> (xs : List Î±) â List Î²
  | [] =&gt; []
  | x :: xs =&gt; f x ++ xs.flatMap f
</code></pre>
<p>The type signature suggests that <code class="hljs">List.flatMap</code> could be used to implement a <code class="hljs">Monad List</code> instance.
Indeed, together with <code class="hljs">pure x := [x]</code>, <code class="hljs">List.flatMap</code> does implement a monad.
However, it's not a very useful <code class="hljs">Monad</code> instance.
The <code class="hljs">List</code> monad is basically a version of <code class="hljs">Many</code> that explores <em>every</em> possible path through the search space in advance, before users have the chance to request some number of values.
Because of this performance trap, it's usually not a good idea to define a <code class="hljs">Monad</code> instance for <code class="hljs">List</code>.
Here, however, the query language has no operator for restricting the number of results to be returned, so combining all possibilities is exactly what is desired:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">T</span><span class="hljs-title">a</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span>.<span class="hljs-title">c</span><span class="hljs-title">a</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">d</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">t</span> <span class="hljs-params">(table1 : Table s1)</span> <span class="hljs-params">(table2 : Table s2)</span> <span class="hljs-symbol">:</span></span> Table (s1 ++ s2) :=
  table1.flatMap <span class="hljs-keyword">fun</span> r1 =&gt; table2.map r1.append
</code></pre>
<p>Just as with <code class="hljs">List.product</code>, a loop with mutation in the identity monad can be used as an alternative implementation technique:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">T</span><span class="hljs-title">a</span><span class="hljs-title">b</span><span class="hljs-title">l</span><span class="hljs-title">e</span>.<span class="hljs-title">c</span><span class="hljs-title">a</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">a</span><span class="hljs-title">n</span><span class="hljs-title">P</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">d</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">t</span> <span class="hljs-params">(table1 : Table s1)</span> <span class="hljs-params">(table2 : Table s2)</span> <span class="hljs-symbol">:</span></span> Table (s1 ++ s2) := Id.run <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> out : Table (s1 ++ s2) := []
  <span class="hljs-keyword">for</span> r1 <span class="hljs-keyword">in</span> table1 <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">for</span> r2 <span class="hljs-keyword">in</span> table2 <span class="hljs-keyword">do</span>
      out := (r1.append r2) :: out
  pure out.reverse
</code></pre>
<h3 id="difference"><a class="header" href="#difference">Difference</a></h3>
<p>Removing undesired rows from a table can be done using <code class="hljs">List.filter</code>, which takes a list and a function that returns a <code class="hljs">Bool</code>.
A new list is returned that contains only the entries for which the function returns <code class="hljs">true</code>.
For instance,</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">[<span class="hljs-string">"Willamette"</span>, <span class="hljs-string">"Columbia"</span>, <span class="hljs-string">"Sandy"</span>, <span class="hljs-string">"Deschutes"</span>].filter (Â·.length &gt; <span class="hljs-number">8</span>)
</code></pre>
<p>evaluates to</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">[<span class="hljs-string">"Willamette"</span>, <span class="hljs-string">"Deschutes"</span>]
</code></pre>
<p>because <code class="hljs">"Columbia"</code> and <code class="hljs">"Sandy"</code> have lengths less than or equal to <code class="hljs">8</code>.
Removing the entries of a table can be done using the helper <code class="hljs">List.without</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span>.<span class="hljs-title">w</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">t</span> <span class="hljs-params">[BEq Î±]</span> <span class="hljs-params">(source banned : List Î±)</span> <span class="hljs-symbol">:</span></span> List Î± :=
  source.filter <span class="hljs-keyword">fun</span> r =&gt; !(banned.contains r)
</code></pre>
<p>This will be used with the <code class="hljs">BEq</code> instance for <code class="hljs">Row</code> when interpreting queries.</p>
<h3 id="renaming-columns"><a class="header" href="#renaming-columns">Renaming Columns</a></h3>
<p>Renaming a column in a row is done with a recursive function that traverses the row until the column in question is found, at which point the column with the new name gets the same value as the column with the old name:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">R</span><span class="hljs-title">ow</span>.<span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">a</span><span class="hljs-title">m</span><span class="hljs-title">e</span> <span class="hljs-params">(c : HasCol s n t)</span> <span class="hljs-params">(row : Row s)</span> <span class="hljs-symbol">:</span></span> Row (s.renameColumn c n') :=
  <span class="hljs-keyword">match</span> s, row, c <span class="hljs-keyword">with</span>
  | [_], v, .here =&gt; v
  | _::_::_, (v, r), .here =&gt; (v, r)
  | _::_::_, (v, r), .there next =&gt; addVal v (r.<span class="hljs-built_in">rename</span> next)
</code></pre>
<p>While this function changes the <em>type</em> of its argument, the actual return value contains precisely the same data as the original argument.
From a run-time perspective, <code class="hljs">renameRow</code> is nothing but a slow identity function.
One difficulty in programming with indexed families is that when performance matters, this kind of operation can get in the way.
It takes a very careful, often brittle, design to eliminate these kinds of "re-indexing" functions.</p>
<h3 id="prefixing-column-names"><a class="header" href="#prefixing-column-names">Prefixing Column Names</a></h3>
<p>Adding a prefix to column names is very similar to renaming a column.
Instead of proceeding to a desired column and then returning, <code class="hljs">prefixRow</code> must process all columns:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">x</span><span class="hljs-title">R</span><span class="hljs-title">ow</span> <span class="hljs-params">(row : Row s)</span> <span class="hljs-symbol">:</span></span> Row (s.map <span class="hljs-keyword">fun</span> c =&gt; {c <span class="hljs-keyword">with</span> name := n ++ <span class="hljs-string">"."</span> ++ c.name}) :=
  <span class="hljs-keyword">match</span> s, row <span class="hljs-keyword">with</span>
  | [], _ =&gt; ()
  | [_], v =&gt; v
  | _::_::_, (v, r) =&gt; (v, prefixRow r)
</code></pre>
<p>This can be used with <code class="hljs">List.map</code> in order to add a prefix to all rows in a table.
Once again, this function only exists to change the type of a value.</p>
<h3 id="putting-the-pieces-together"><a class="header" href="#putting-the-pieces-together">Putting the Pieces Together</a></h3>
<p>With all of these helpers defined, executing a query requires only a short recursive function:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">Q</span><span class="hljs-title">u</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">y</span>.<span class="hljs-title">e</span><span class="hljs-title">x</span><span class="hljs-title">e</span><span class="hljs-title">c</span> <span class="hljs-symbol">:</span></span> Query s â Table s
  | .table t =&gt; t
  | .union q1 q2 =&gt; exec q1 ++ exec q2
  | .diff q1 q2 =&gt; exec q1 |&gt;.without (exec q2)
  | .select q e =&gt; exec q |&gt;.filter e.evaluate
  | .project q _ sub =&gt; exec q |&gt;.map (Â·.project _ sub)
  | .product q1 q2 _ =&gt; exec q1 |&gt;.cartesianProduct (exec q2)
  | .renameColumn q c _ _ =&gt; exec q |&gt;.map (Â·.<span class="hljs-built_in">rename</span> c)
  | .prefixWith _ q =&gt; exec q |&gt;.map prefixRow
</code></pre>
<p>Some arguments to the constructors are not used during execution.
In particular, both the constructor <code class="hljs">project</code> and the function <code class="hljs">Row.project</code> take the smaller schema as explicit arguments, but the type of the <em>evidence</em> that this schema is a subschema of the larger schema contains enough information for Lean to fill out the argument automatically.
Similarly, the fact that the two tables have disjoint column names that is required by the <code class="hljs">product</code> constructor is not needed by <code class="hljs">Table.cartesianProduct</code>.
Generally speaking, dependent types provide many opportunities to have Lean fill out arguments on behalf of the programmer.</p>
<p>Dot notation is used with the results of queries to call functions defined both in the <code class="hljs">Table</code> and <code class="hljs">List</code> namespaces, such <code class="hljs">List.map</code>, <code class="hljs">List.filter</code>, and <code class="hljs">Table.cartesianProduct</code>.
This works because <code class="hljs">Table</code> is defined using <code class="hljs">abbrev</code>.
Just like type class search, dot notation can see through definitions created with <code class="hljs">abbrev</code>. </p>
<p>The implementation of <code class="hljs">select</code> is also quite concise.
After executing the query <code class="hljs">q</code>, <code class="hljs">List.filter</code> is used to remove the rows that do not satisfy the expression.
Filter expects a function from <code class="hljs">Row s</code> to <code class="hljs">Bool</code>, but <code class="hljs">DBExpr.evaluate</code> has type <code class="hljs">Row s â DBExpr s t â t.asType</code>.
Because the type of the <code class="hljs">select</code> constructor requires that the expression have type <code class="hljs">DBExpr s .bool</code>, <code class="hljs">t.asType</code> is actually <code class="hljs">Bool</code> in this context.</p>
<p>A query that finds the heights of all mountain peaks with an elevation greater than 500 meters can be written:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-keyword">open</span> Query <span class="hljs-keyword">in</span>
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">x</span><span class="hljs-title">a</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">e1</span> <span class="hljs-symbol">:</span></span>=
  table mountainDiary |&gt;.select
  (.lt (.const <span class="hljs-number">500</span>) (c! <span class="hljs-string">"elevation"</span>)) |&gt;.project
  [â¨<span class="hljs-string">"elevation"</span>, .intâ©] (<span class="hljs-keyword">by</span> <span class="hljs-keyword">repeat</span> <span class="hljs-keyword">constructor</span>)
</code></pre>
<p>Executing it returns the expected list of integers:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> example1.exec
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">[3637, 1519, 2549]
</code></pre>
<p>To plan a sightseeing tour, it may be relevant to match all pairs mountains and waterfalls in the same location.
This can be done by taking the Cartesian product of both tables, selecting only the rows in which they are equal, and then projecting out the names:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-keyword">open</span> Query <span class="hljs-keyword">in</span>
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">x</span><span class="hljs-title">a</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">e2</span> <span class="hljs-symbol">:</span></span>=
  <span class="hljs-keyword">let</span> mountain := table mountainDiary |&gt;.prefixWith <span class="hljs-string">"mountain"</span>
  <span class="hljs-keyword">let</span> waterfall := table waterfallDiary |&gt;.prefixWith <span class="hljs-string">"waterfall"</span>
  mountain.product waterfall (<span class="hljs-keyword">by</span> <span class="hljs-keyword">simp</span>)
    |&gt;.select (.eq (c! <span class="hljs-string">"mountain.location"</span>) (c! <span class="hljs-string">"waterfall.location"</span>))
    |&gt;.project [â¨<span class="hljs-string">"mountain.name"</span>, .stringâ©, â¨<span class="hljs-string">"waterfall.name"</span>, .stringâ©] (<span class="hljs-keyword">by</span> <span class="hljs-keyword">repeat</span> <span class="hljs-keyword">constructor</span>)
</code></pre>
<p>Because the example data includes only waterfalls in the USA, executing the query returns pairs of mountains and waterfalls in the US:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> example2.exec
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">[("Mount Nebo", "Multnomah Falls"),
 ("Mount Nebo", "Shoshone Falls"),
 ("Moscow Mountain", "Multnomah Falls"),
 ("Moscow Mountain", "Shoshone Falls"),
 ("Mount St. Helens", "Multnomah Falls"),
 ("Mount St. Helens", "Shoshone Falls")]
</code></pre>
<h3 id="errors-you-may-meet"><a class="header" href="#errors-you-may-meet">Errors You May Meet</a></h3>
<p>Many potential errors are ruled out by the definition of <code class="hljs">Query</code>.
For instance, forgetting the added qualifier in <code class="hljs">"mountain.location"</code> yields a compile-time error that highlights the column reference <code class="hljs">c! "location"</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-keyword">open</span> Query <span class="hljs-keyword">in</span>
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">x</span><span class="hljs-title">a</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">e2</span> <span class="hljs-symbol">:</span></span>=
  <span class="hljs-keyword">let</span> mountains := table mountainDiary |&gt;.prefixWith <span class="hljs-string">"mountain"</span>
  <span class="hljs-keyword">let</span> waterfalls := table waterfallDiary |&gt;.prefixWith <span class="hljs-string">"waterfall"</span>
  mountains.product waterfalls (<span class="hljs-keyword">by</span> <span class="hljs-keyword">simp</span>)
    |&gt;.select (.eq (c! <span class="hljs-string">"location"</span>) (c! <span class="hljs-string">"waterfall.location"</span>))
    |&gt;.project [â¨<span class="hljs-string">"mountain.name"</span>, .stringâ©, â¨<span class="hljs-string">"waterfall.name"</span>, .stringâ©] (<span class="hljs-keyword">by</span> <span class="hljs-keyword">repeat</span> <span class="hljs-keyword">constructor</span>)
</code></pre>
<p>This is excellent feedback!
On the other hand, the text of the error message is quite difficult to act on:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case a.a.a.a.a.a.a
mountains : Query (List.map (fun c =&gt; { name := "mountain" ++ "." ++ c.name, contains := c.contains }) peak) :=
  prefixWith "mountain" (table mountainDiary)
waterfalls : Query (List.map (fun c =&gt; { name := "waterfall" ++ "." ++ c.name, contains := c.contains }) waterfall) :=
  prefixWith "waterfall" (table waterfallDiary)
â¢ HasCol (List.map (fun c =&gt; { name := "waterfall" ++ "." ++ c.name, contains := c.contains }) []) "location" ?m.109970
</code></pre>
<p>Similarly, forgetting to add prefixes to the names of the two tables results in an error on <code class="hljs">by simp</code>, which should provide evidence that the schemas are in fact disjoint;</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-keyword">open</span> Query <span class="hljs-keyword">in</span>
<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">e</span><span class="hljs-title">x</span><span class="hljs-title">a</span><span class="hljs-title">m</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">e2</span> <span class="hljs-symbol">:</span></span>=
  <span class="hljs-keyword">let</span> mountains := table mountainDiary
  <span class="hljs-keyword">let</span> waterfalls := table waterfallDiary
  mountains.product waterfalls (<span class="hljs-keyword">by</span> <span class="hljs-keyword">simp</span>)
    |&gt;.select (.eq (c! <span class="hljs-string">"mountain.location"</span>) (c! <span class="hljs-string">"waterfall.location"</span>))
    |&gt;.project [â¨<span class="hljs-string">"mountain.name"</span>, .stringâ©, â¨<span class="hljs-string">"waterfall.name"</span>, .stringâ©] (<span class="hljs-keyword">by</span> <span class="hljs-keyword">repeat</span> <span class="hljs-keyword">constructor</span>)
</code></pre>
<p>However, the error message is similarly unhelpful:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
mountains : Query peak := table mountainDiary
waterfalls : Query waterfall := table waterfallDiary
â¢ False
</code></pre>
<p>Lean's macro system contains everything needed not only to provide a convenient syntax for queries, but also to arrange for the error messages to be helpful.
Unfortunately, it is beyond the scope of this book to provide a description of implementing languages with Lean macros.
An indexed family such as <code class="hljs">Query</code> is probably best as the core of a typed database interaction library, rather than its user interface.</p>
<h2 id="exercises-20"><a class="header" href="#exercises-20">Exercises</a></h2>
<h3 id="dates"><a class="header" href="#dates">Dates</a></h3>
<p>Define a structure to represent dates. Add it to the <code class="hljs">DBType</code> universe and update the rest of the code accordingly. Provide the extra <code class="hljs">DBExpr</code> constructors that seem to be necessary.</p>
<h3 id="nullable-types"><a class="header" href="#nullable-types">Nullable Types</a></h3>
<p>Add support for nullable columns to the query language by representing database types with the following structure:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">N</span><span class="hljs-title">D</span><span class="hljs-title">B</span><span class="hljs-title">T</span><span class="hljs-title">y</span><span class="hljs-title">p</span><span class="hljs-title">e</span></span> <span class="hljs-keyword">where</span>
  underlying : DBType
  nullable : Bool

<span class="hljs-keyword">abbrev</span> NDBType.asType (t : NDBType) : <span class="hljs-built_in">Type</span> :=
  <span class="hljs-keyword">if</span> t.nullable <span class="hljs-keyword">then</span>
    Option t.underlying.asType
  <span class="hljs-keyword">else</span>
    t.underlying.asType
</code></pre>
<p>Use this type in place of <code class="hljs">DBType</code> in <code class="hljs">Column</code> and <code class="hljs">DBExpr</code>, and look up SQL's rules for <code class="hljs">NULL</code> and comparison operators to determine the types of <code class="hljs">DBExpr</code>'s constructors.</p>
<h3 id="experimenting-with-tactics"><a class="header" href="#experimenting-with-tactics">Experimenting with Tactics</a></h3>
<p>What is the result of asking Lean to find values of the following types using <code class="hljs">by repeat constructor</code>? Explain why each gives the result that it does.</p>
<ul>
<li><code class="hljs">Nat</code></li>
<li><code class="hljs">List Nat</code></li>
<li><code class="hljs">Vect Nat 4</code></li>
<li><code class="hljs">Row []</code></li>
<li><code class="hljs">Row [â¨"price", .intâ©]</code></li>
<li><code class="hljs">Row peak</code></li>
<li><code class="hljs">HasCol [â¨"price", .intâ©, â¨"price", .intâ©] "price" .int</code></li>
</ul>
<div style="break-before:page;page-break-before:always"></div><h1 id="indices-parameters-and-universe-levels"><a class="header" href="#indices-parameters-and-universe-levels">Indices, Parameters, and Universe Levels</a></h1>
<p>The distinction between indices and parameters of an inductive type is more than just a way to describe arguments to the type that either vary or do not between the constructors.
Whether an argument to an inductive type is a parameter or an index also matters when it comes time to determine the relationships between their universe levels.
In particular, an inductive type may have the same universe level as a parameter, but it must be in a larger universe than its indices.
This restriction is necessary to ensure that Lean can be used as a theorem prover as well as a programming languageâwithout it, Lean's logic would be inconsistent.
Experimenting with error messages is a good way to illustrate these rules, as well as the precise rules that determine whether an argument to a type is a parameter or an index.</p>
<p>Generally speaking, the definition of an inductive type takes its parameters before a colon and its indices after the colon.
Parameters are given names like function arguments, whereas indices only have their types described.
This can be seen in the definition of <code class="hljs">Vect</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Vect (Î± : <span class="hljs-built_in">Type</span> u) : Nat â <span class="hljs-built_in">Type</span> u <span class="hljs-keyword">where</span>
   | nil : Vect Î± <span class="hljs-number">0</span>
   | cons : Î± â Vect Î± n â Vect Î± (n + <span class="hljs-number">1</span>)
</code></pre>
<p>In this definition, <code class="hljs">Î±</code> is a parameter and the <code class="hljs">Nat</code> is an index.
Parameters may be referred to throughout the definition (for example, <code class="hljs">Vect.cons</code> uses <code class="hljs">Î±</code> for the type of its first argument), but they must always be used consistently.
Because indices are expected to change, they are assigned individual values at each constructor, rather than being provided as arguments at the top of the datatype definition.</p>
<p>A very simple datatype with a parameter is <code class="hljs">WithParameter</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> WithParameter (Î± : <span class="hljs-built_in">Type</span> u) : <span class="hljs-built_in">Type</span> u <span class="hljs-keyword">where</span>
  | test : Î± â WithParameter Î±
</code></pre>
<p>The universe level <code class="hljs">u</code> can be used for both the parameter and for the inductive type itself, illustrating that parameters do not increase the universe level of a datatype.
Similarly, when there are multiple parameters, the inductive type receives whichever universe level is greater:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> WithTwoParameters (Î± : <span class="hljs-built_in">Type</span> u) (Î² : <span class="hljs-built_in">Type</span> v) : <span class="hljs-built_in">Type</span> (max u v) <span class="hljs-keyword">where</span>
  | test : Î± â Î² â WithTwoParameters Î± Î²
</code></pre>
<p>Because parameters do not increase the universe level of a datatype, they can be more convenient to work with.
Lean attempts to identify arguments that are described like indices (after the colon), but used like parameters, and turn them into parameters:
Both of the following inductive datatypes have their parameter written after the colon:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> WithParameterAfterColon : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> u <span class="hljs-keyword">where</span>
  | test : Î± â WithParameterAfterColon Î±

<span class="hljs-keyword">inductive</span> WithParameterAfterColon2 : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> u <span class="hljs-keyword">where</span>
  | test1 : Î± â WithParameterAfterColon2 Î±
  | test2 : WithParameterAfterColon2 Î±
</code></pre>
<p>When a parameter is not named in the initial datatype declaration, different names may be used for it in each constructor, so long as they are used consistently.
The following declaration is accepted:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> WithParameterAfterColonDifferentNames : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> u <span class="hljs-keyword">where</span>
  | test1 : Î± â WithParameterAfterColonDifferentNames Î±
  | test2 : Î² â WithParameterAfterColonDifferentNames Î²
</code></pre>
<p>However, this flexibility does not extend to datatypes that explicitly declare the names of their parameters:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> WithParameterBeforeColonDifferentNames (Î± : <span class="hljs-built_in">Type</span> u) : <span class="hljs-built_in">Type</span> u <span class="hljs-keyword">where</span>
  | test1 : Î± â WithParameterBeforeColonDifferentNames Î±
  | test2 : Î² â WithParameterBeforeColonDifferentNames Î²
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">inductive datatype parameter mismatch
  Î²
expected
  Î±
</code></pre>
<p>Similarly, attempting to name an index results in an error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> WithNamedIndex (Î± : <span class="hljs-built_in">Type</span> u) : <span class="hljs-built_in">Type</span> (u + <span class="hljs-number">1</span>) <span class="hljs-keyword">where</span>
  | test1 : WithNamedIndex Î±
  | test2 : WithNamedIndex Î± â WithNamedIndex Î± â WithNamedIndex (Î± Ã Î±)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">inductive datatype parameter mismatch
  Î± Ã Î±
expected
  Î±
</code></pre>
<p>Using an appropriate universe level and placing the index after the colon results in a declaration that is acceptable:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> WithIndex : <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> (u + <span class="hljs-number">1</span>) <span class="hljs-keyword">where</span>
  | test1 : WithIndex Î±
  | test2 : WithIndex Î± â WithIndex Î± â WithIndex (Î± Ã Î±)
</code></pre>
<p>Even though Lean can sometimes determine that an argument after the colon in an inductive type declaration is a parameter when it is used consistently in all constructors, all parameters are still required to come before all indices.
Attempting to place a parameter after an index results in the argument being considered an index itself, which would require the universe level of the datatype to increase:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> ParamAfterIndex : Nat â <span class="hljs-built_in">Type</span> u â <span class="hljs-built_in">Type</span> u <span class="hljs-keyword">where</span>
  | test1 : ParamAfterIndex <span class="hljs-number">0</span> Î³
  | test2 : ParamAfterIndex n Î³ â ParamAfterIndex k Î³ â ParamAfterIndex (n + k) Î³
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">invalid universe level in constructor 'ParamAfterIndex.test1', parameter 'Î³' has type
  Type u
at universe level
  u+2
it must be smaller than or equal to the inductive datatype universe level
  u+1
</code></pre>
<p>Parameters need not be types.
This example shows that ordinary datatypes such as <code class="hljs">Nat</code> may be used as parameters:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> NatParam (n : Nat) : Nat â <span class="hljs-built_in">Type</span> u <span class="hljs-keyword">where</span>
  | five : NatParam <span class="hljs-number">4</span> <span class="hljs-number">5</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">inductive datatype parameter mismatch
  4
expected
  n
</code></pre>
<p>Using the <code class="hljs">n</code> as suggested causes the declaration to be accepted:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> NatParam (n : Nat) : Nat â <span class="hljs-built_in">Type</span> u <span class="hljs-keyword">where</span>
  | five : NatParam n <span class="hljs-number">5</span>
</code></pre>
<p>What can be concluded from these experiments?
The rules of parameters and indices are as follows:</p>
<ol>
<li>Parameters must be used identically in each constructor's type.</li>
<li>All parameters must come before all indices.</li>
<li>The universe level of the datatype being defined must be at least as large as the largest parameter, and strictly larger than the largest index.</li>
<li>Named arguments written before the colon are always parameters, while arguments after the colon are typically indices. Lean may determine that the usage of arguments after the colon makes them into parameters if they are used consistently in all constructors and don't come after any indices.</li>
</ol>
<p>When in doubt, the Lean command <code class="hljs">#print</code> can be used to check how many of a datatype's arguments are parameters.
For example, for <code class="hljs">Vect</code>, it points out that the number of parameters is 1:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#print</span> Vect
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">inductive Vect.{u} : Type u â Nat â Type u
number of parameters: 1
constructors:
Vect.nil : {Î± : Type u} â Vect Î± 0
Vect.cons : {Î± : Type u} â {n : Nat} â Î± â Vect Î± n â Vect Î± (n + 1)
</code></pre>
<p>It is worth thinking about which arguments should be parameters and which should be indices when choosing the order of arguments to a datatype.
Having as many arguments as possible be parameters helps keep universe levels under control, which can make a complicated program easier to type check.
One way to make this possible is to ensure that all parameters come before all indices in the argument list.</p>
<p>Additionally, even though Lean is capable of determining that arguments after the colon are nonetheless parameters by their usage, it's a good idea to write parameters with explicit names.
This makes the intention clear to readers, and it causes Lean to report an error if the argument is mistakenly used inconsistently across the constructors.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="pitfalls-of-programming-with-dependent-types"><a class="header" href="#pitfalls-of-programming-with-dependent-types">Pitfalls of Programming with Dependent Types</a></h1>
<p>The flexibility of dependent types allows more useful programs to be accepted by a type checker, because the language of types is expressive enough to describe variations that less-expressive type systems cannot.
At the same time, the ability of dependent types to express very fine-grained specifications allows more buggy programs to be rejected by a type checker.
This power comes at a cost.</p>
<p>The close coupling between the internals of type-returning functions such as <code class="hljs">Row</code> and the types that they produce is an instance of a bigger difficulty: the distinction between the interface and the implementation of functions begins to break down when functions are used in types.
Normally, all refactorings are valid as long as they don't change the type signature or input-output behavior of a function.
Functions can be rewritten to use more efficient algorithms and data structures, bugs can be fixed, and code clarity can be improved without breaking client code.
When the function is used in a type, however, the internals of the function's implementation become part of the type, and thus part of the <em>interface</em> to another program.</p>
<p>As an example, take the following two implementations of addition on <code class="hljs">Nat</code>.
<code class="hljs">Nat.plusL</code> is recursive on its first argument:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span>.<span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">L</span> <span class="hljs-symbol">:</span></span> Nat â Nat â Nat
  | <span class="hljs-number">0</span>, k =&gt; k
  | n + <span class="hljs-number">1</span>, k =&gt; plusL n k + <span class="hljs-number">1</span>
</code></pre>
<p><code class="hljs">Nat.plusR</code>, on the other hand, is recursive on its second argument:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span>.<span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">R</span> <span class="hljs-symbol">:</span></span> Nat â Nat â Nat
  | n, <span class="hljs-number">0</span> =&gt; n
  | n, k + <span class="hljs-number">1</span> =&gt; plusR n k + <span class="hljs-number">1</span>
</code></pre>
<p>Both implementations of addition are faithful to the underlying mathematical concept, and they thus return the same result when given the same arguments.</p>
<p>However, these two implementations present quite different interfaces when they are used in types.
As an example, take a function that appends two <code class="hljs">Vect</code>s.
This function should return a <code class="hljs">Vect</code> whose length is the sum of the length of the arguments.
Because <code class="hljs">Vect</code> is essentially a <code class="hljs">List</code> with a more informative type, it makes sense to write the function just as one would for <code class="hljs">List.append</code>, with pattern matching and recursion on the first argument.
Starting with a type signature and initial pattern match pointing at placeholders yields two messages:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">L</span> <span class="hljs-symbol">:</span></span> Vect Î± n â Vect Î± k â Vect Î± (n.plusL k)
  | .nil, ys =&gt; _
  | .cons x xs, ys =&gt; _
</code></pre>
<p>The first message, in the <code class="hljs">nil</code> case, states that the placeholder should be replaced by a <code class="hljs">Vect</code> with length <code class="hljs">plusL 0 k</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Î± : Type u_1
n k : Nat
ys : Vect Î± k
â¢ Vect Î± (Nat.plusL 0 k)
</code></pre>
<p>The second message, in the <code class="hljs">cons</code> case, states that the placeholder should be replaced by a <code class="hljs">Vect</code> with length <code class="hljs">plusL (nâ + 1) k</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Î± : Type u_1
n k nâ : Nat
x : Î±
xs : Vect Î± nâ
ys : Vect Î± k
â¢ Vect Î± (Nat.plusL (nâ + 1) k)
</code></pre>
<p>The symbol after <code class="hljs">n</code>, called a <em>dagger</em>, is used to indicate names that Lean has internally invented.
Behind the scenes, pattern matching on the first <code class="hljs">Vect</code> implicitly caused the value of the first <code class="hljs">Nat</code> to be refined as well, because the index on the constructor <code class="hljs">cons</code> is <code class="hljs">n + 1</code>, with the tail of the <code class="hljs">Vect</code> having length <code class="hljs">n</code>.
Here, <code class="hljs">nâ</code> represents the <code class="hljs">Nat</code> that is one less than the argument <code class="hljs">n</code>.</p>
<h2 id="definitional-equality"><a class="header" href="#definitional-equality">Definitional Equality</a></h2>
<p>In the definition of <code class="hljs">plusL</code>, there is a pattern case <code class="hljs">0, k =&gt; k</code>.
This applies in the length used in the first placeholder, so another way to write the underscore's type <code class="hljs">Vect Î± (Nat.plusL 0 k)</code> is <code class="hljs">Vect Î± k</code>.
Similarly, <code class="hljs">plusL</code> contains a pattern case <code class="hljs">n + 1, k =&gt; plusN n k + 1</code>.
This means that the type of the second underscore can be equivalently written <code class="hljs">Vect Î± (plusL nâ k + 1)</code>.</p>
<p>To expose what is going on behind the scenes, the first step is to write the <code class="hljs">Nat</code> arguments explicitly, which also results in daggerless error messages because the names are now written explicitly in the program:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">L</span> <span class="hljs-symbol">:</span></span> (n k : Nat) â Vect Î± n â Vect Î± k â Vect Î± (n.plusL k)
  | <span class="hljs-number">0</span>, k, .nil, ys =&gt; _
  | n + <span class="hljs-number">1</span>, k, .cons x xs, ys =&gt; _
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Î± : Type u_1
k : Nat
ys : Vect Î± k
â¢ Vect Î± (Nat.plusL 0 k)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Î± : Type u_1
n k : Nat
x : Î±
xs : Vect Î± n
ys : Vect Î± k
â¢ Vect Î± (Nat.plusL (n + 1) k)
</code></pre>
<p>Annotating the underscores with the simplified versions of the types does not introduce a type error, which means that the types as written in the program are equivalent to the ones that Lean found on its own:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">L</span> <span class="hljs-symbol">:</span></span> (n k : Nat) â Vect Î± n â Vect Î± k â Vect Î± (n.plusL k)
  | <span class="hljs-number">0</span>, k, .nil, ys =&gt; (_ : Vect Î± k)
  | n + <span class="hljs-number">1</span>, k, .cons x xs, ys =&gt; (_ : Vect Î± (n.plusL k + <span class="hljs-number">1</span>))
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Î± : Type u_1
k : Nat
ys : Vect Î± k
â¢ Vect Î± k
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Î± : Type u_1
n k : Nat
x : Î±
xs : Vect Î± n
ys : Vect Î± k
â¢ Vect Î± (Nat.plusL n k + 1)
</code></pre>
<p>The first case demands a <code class="hljs">Vect Î± k</code>, and <code class="hljs">ys</code> has that type.
This is parallel to the way that appending the empty list to any other list returns that other list.
Refining the definition with <code class="hljs">ys</code> instead of the first underscore yields a program with only one remaining underscore to be filled out:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">L</span> <span class="hljs-symbol">:</span></span> (n k : Nat) â Vect Î± n â Vect Î± k â Vect Î± (n.plusL k)
  | <span class="hljs-number">0</span>, k, .nil, ys =&gt; ys
  | n + <span class="hljs-number">1</span>, k, .cons x xs, ys =&gt; (_ : Vect Î± (n.plusL k + <span class="hljs-number">1</span>))
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Î± : Type u_1
n k : Nat
x : Î±
xs : Vect Î± n
ys : Vect Î± k
â¢ Vect Î± (Nat.plusL n k + 1)
</code></pre>
<p>Something very important has happened here.
In a context where Lean expected a <code class="hljs">Vect Î± (Nat.plusL 0 k)</code>, it received a <code class="hljs">Vect Î± k</code>.
However, <code class="hljs">Nat.plusL</code> is not an <code class="hljs">abbrev</code>, so it may seem like it shouldn't be running during type checking.
Something else is happening.</p>
<p>The key to understanding what's going on is that Lean doesn't just expand <code class="hljs">abbrev</code>s while type checking.
It can also perform computation while checking whether two types are equivalent to one another, such that any expression of one type can be used in a context that expects the other type.
This property is called <em>definitional equality</em>, and it is subtle.</p>
<p>Certainly, two types that are written identically are considered to be definitionally equalâ<code class="hljs">Nat</code> and <code class="hljs">Nat</code> or <code class="hljs">List String</code> and <code class="hljs">List String</code> should be considered equal.
Any two concrete types built from different datatypes are not equal, so <code class="hljs">List Nat</code> is not equal to <code class="hljs">Int</code>.
Additionally, types that differ only by renaming internal names are equal, so <code class="hljs">(n : Nat) â Vect String n</code> is the same as <code class="hljs">(k : Nat) â Vect String k</code>.
Because types can contain ordinary data, definitional equality must also describe when data are equal.
Uses of the same constructors are equal, so <code class="hljs">0</code> equals <code class="hljs">0</code> and <code class="hljs">[5, 3, 1]</code> equals <code class="hljs">[5, 3, 1]</code>.</p>
<p>Types contain more than just function arrows, datatypes, and constructors, however.
They also contain <em>variables</em> and <em>functions</em>.
Definitional equality of variables is relatively simple: each variable is equal only to itself, so <code class="hljs">(n k : Nat) â Vect Int n</code> is not definitionally equal to <code class="hljs">(n k : Nat) â Vect Int k</code>.
Functions, on the other hand, are more complicated.
While mathematics considers two functions to be equal if they have identical input-output behavior, there is no efficient algorithm to check that, and the whole point of definitional equality is for Lean to check whether two types are interchangeable.
Instead, Lean considers functions to be definitionally equal either when they are both <code class="hljs">fun</code>-expressions with definitionally equal bodies.
In other words, two functions must use <em>the same algorithm</em> that calls <em>the same helpers</em> to be considered definitionally equal.
This is not typically very helpful, so definitional equality of functions is mostly used when the exact same defined function occurs in two types.</p>
<p>When functions are <em>called</em> in a type, checking definitional equality may involve reducing the function call.
The type <code class="hljs">Vect String (1 + 4)</code> is definitionally equal to the type <code class="hljs">Vect String (3 + 2)</code> because <code class="hljs">1 + 4</code> is definitionally equal to <code class="hljs">3 + 2</code>.
To check their equality, both are reduced to <code class="hljs">5</code>, and then the constructor rule can be used five times.
Definitional equality of functions applied to data can be checked first by seeing if they're already the sameâthere's no need to reduce <code class="hljs">["a", "b"] ++ ["c"]</code> to check that it's equal to <code class="hljs">["a", "b"] ++ ["c"]</code>, after all.
If not, the function is called and replaced with its value, and the value can then be checked.</p>
<p>Not all function arguments are concrete data.
For example, types may contain <code class="hljs">Nat</code>s that are not built from the <code class="hljs">zero</code> and <code class="hljs">succ</code> constructors.
In the type <code class="hljs">(n : Nat) â Vect String n</code>, the variable <code class="hljs">n</code> is a <code class="hljs">Nat</code>, but it is impossible to know <em>which</em> <code class="hljs">Nat</code> it is before the function is called.
Indeed, the function may be called first with <code class="hljs">0</code>, and then later with <code class="hljs">17</code>, and then again with <code class="hljs">33</code>.
As seen in the definition of <code class="hljs">appendL</code>, variables with type <code class="hljs">Nat</code> may also be passed to functions such as <code class="hljs">plusL</code>.
Indeed, the type <code class="hljs">(n : Nat) â Vect String n</code> is definitionally equal to the type <code class="hljs">(n : Nat) â Vect String (Nat.plusL 0 n)</code>.</p>
<p>The reason that <code class="hljs">n</code> and <code class="hljs">Nat.plusL 0 n</code> are definitionally equal is that <code class="hljs">plusL</code>'s pattern match examines its <em>first</em> argument.
This is problematic: <code class="hljs">(n : Nat) â Vect String n</code> is <em>not</em> definitionally equal to <code class="hljs">(n : Nat) â Vect String (Nat.plusL n 0)</code>, even though zero should be both a left and a right identity of addition.
This happens because pattern matching gets stuck when it encounters variables.
Until the actual value of <code class="hljs">n</code> becomes known, there is no way to know which case of <code class="hljs">Nat.plusL n 0</code> should be selected.</p>
<p>The same issue appears with the <code class="hljs">Row</code> function in the query example.
The type <code class="hljs">Row (c :: cs)</code> does not reduce to any datatype because the definition of <code class="hljs">Row</code> has separate cases for singleton lists and lists with at least two entries.
In other words, it gets stuck when trying to match the variable <code class="hljs">cs</code> against concrete <code class="hljs">List</code> constructors.
This is why almost every function that takes apart or constructs a <code class="hljs">Row</code> needs to match the same three cases as <code class="hljs">Row</code> itself: getting it unstuck reveals concrete types that can be used for either pattern matching or constructors.</p>
<p>The missing case in <code class="hljs">appendL</code> requires a <code class="hljs">Vect Î± (Nat.plusL n k + 1)</code>.
The <code class="hljs">+ 1</code> in the index suggests that the next step is to use <code class="hljs">Vect.cons</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">L</span> <span class="hljs-symbol">:</span></span> (n k : Nat) â Vect Î± n â Vect Î± k â Vect Î± (n.plusL k)
  | <span class="hljs-number">0</span>, k, .nil, ys =&gt; ys
  | n + <span class="hljs-number">1</span>, k, .cons x xs, ys =&gt; .cons x (_ : Vect Î± (n.plusL k))
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Î± : Type u_1
n k : Nat
x : Î±
xs : Vect Î± n
ys : Vect Î± k
â¢ Vect Î± (Nat.plusL n k)
</code></pre>
<p>A recursive call to <code class="hljs">appendL</code> can construct a <code class="hljs">Vect</code> with the desired length:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">L</span> <span class="hljs-symbol">:</span></span> (n k : Nat) â Vect Î± n â Vect Î± k â Vect Î± (n.plusL k)
  | <span class="hljs-number">0</span>, k, .nil, ys =&gt; ys
  | n + <span class="hljs-number">1</span>, k, .cons x xs, ys =&gt; .cons x (appendL n k xs ys)
</code></pre>
<p>Now that the program is finished, removing the explicit matching on <code class="hljs">n</code> and <code class="hljs">k</code> makes it easier to read and easier to call the function:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">L</span> <span class="hljs-symbol">:</span></span> Vect Î± n â Vect Î± k â Vect Î± (n.plusL k)
  | .nil, ys =&gt; ys
  | .cons x xs, ys =&gt; .cons x (appendL xs ys)
</code></pre>
<p>Comparing types using definitional equality means that everything involved in definitional equality, including the internals of function definitions, becomes part of the <em>interface</em> of programs that use dependent types and indexed families.
Exposing the internals of a function in a type means that refactoring the exposed program may cause programs that use it to no longer type check.
In particular, the fact that <code class="hljs">plusL</code> is used in the type of <code class="hljs">appendL</code> means that the definition of <code class="hljs">plusL</code> cannot be replaced by the otherwise-equivalent <code class="hljs">plusR</code>.</p>
<h2 id="getting-stuck-on-addition"><a class="header" href="#getting-stuck-on-addition">Getting Stuck on Addition</a></h2>
<p>What happens if append is defined with <code class="hljs">plusR</code> instead?
Beginning in the same way, with explicit lengths and placeholder underscores in each case, reveals the following useful error messages:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">R</span> <span class="hljs-symbol">:</span></span> (n k : Nat) â Vect Î± n â Vect Î± k â Vect Î± (n.plusR k)
  | <span class="hljs-number">0</span>, k, .nil, ys =&gt; _
  | n + <span class="hljs-number">1</span>, k, .cons x xs, ys =&gt; _
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Î± : Type u_1
k : Nat
ys : Vect Î± k
â¢ Vect Î± (Nat.plusR 0 k)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Î± : Type u_1
n k : Nat
x : Î±
xs : Vect Î± n
ys : Vect Î± k
â¢ Vect Î± (Nat.plusR (n + 1) k)
</code></pre>
<p>However, attempting to place a <code class="hljs">Vect Î± k</code> type annotation around the first placeholder results in an type mismatch error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">R</span> <span class="hljs-symbol">:</span></span> (n k : Nat) â Vect Î± n â Vect Î± k â Vect Î± (n.plusR k)
  | <span class="hljs-number">0</span>, k, .nil, ys =&gt; (_ : Vect Î± k)
  | n + <span class="hljs-number">1</span>, k, .cons x xs, ys =&gt; _
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">type mismatch
  ?m.3036
has type
  Vect Î± k : Type ?u.2973
but is expected to have type
  Vect Î± (Nat.plusR 0 k) : Type ?u.2973
</code></pre>
<p>This error is pointing out that <code class="hljs">plusR 0 k</code> and <code class="hljs">k</code> are <em>not</em> definitionally equal.</p>
<p>This is because <code class="hljs">plusR</code> has the following definition:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span>.<span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">R</span> <span class="hljs-symbol">:</span></span> Nat â Nat â Nat
  | n, <span class="hljs-number">0</span> =&gt; n
  | n, k + <span class="hljs-number">1</span> =&gt; plusR n k + <span class="hljs-number">1</span>
</code></pre>
<p>Its pattern matching occurs on the <em>second</em> argument, not the first argument, which means that the presence of the variable <code class="hljs">k</code> in that position prevents it from reducing.
<code class="hljs">Nat.add</code> in Lean's standard library is equivalent to <code class="hljs">plusR</code>, not <code class="hljs">plusL</code>, so attempting to use it in this definition results in precisely the same difficulties:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">R</span> <span class="hljs-symbol">:</span></span> (n k : Nat) â Vect Î± n â Vect Î± k â Vect Î± (n + k)
  | <span class="hljs-number">0</span>, k, .nil, ys =&gt; (_ : Vect Î± k)
  | n + <span class="hljs-number">1</span>, k, .cons x xs, ys =&gt; _
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">type mismatch
  ?m.3068
has type
  Vect Î± k : Type ?u.2973
but is expected to have type
  Vect Î± (0 + k) : Type ?u.2973
</code></pre>
<p>Addition is getting <em>stuck</em> on the variables.
Getting it unstuck requires <a href="https://leanprover.github.io/functional_programming_in_lean/type-classes/standard-classes.html#equality-and-ordering">propositional equality</a>.</p>
<h2 id="propositional-equality"><a class="header" href="#propositional-equality">Propositional Equality</a></h2>
<p>Propositional equality is the mathematical statement that two expressions are equal.
While definitional equality is a kind of ambient fact that Lean automatically checks when required, statements of propositional equality require explicit proofs.
Once an equality proposition has been proved, it can be used in a program to modify a type, replacing one side of the equality with the other, which can unstick the type checker.</p>
<p>The reason why definitional equality is so limited is to enable it to be checked by an algorithm.
Propositional equality is much richer, but the computer cannot in general check whether two expressions are propositionally equal, though it can verify that a purported proof is in fact a proof.
The split between definitional and propositional equality represents a division of labor between humans and machines: the most boring equalities are checked automatically as part of definitional equality, freeing the human mind to work on the interesting problems available in propositional equality.
Similarly, definitional equality is invoked automatically by the type checker, while propositional equality must be specifically appealed to.</p>
<p>In <a href="https://leanprover.github.io/functional_programming_in_lean/props-proofs-indexing.html">Propositions, Proofs, and Indexing</a>, some equality statements are proved using <code class="hljs">simp</code>.
All of these equality statements are ones in which the propositional equality is in fact already a definitional equality.
Typically, statements of propositional equality are proved by first getting them into a form where they are either definitional or close enough to existing proved equalities, and then using tools like <code class="hljs">simp</code> to take care of the simplified cases.
The <code class="hljs">simp</code> tactic is quite powerful: behind the scenes, it uses a number of fast, automated tools to construct a proof.
A simpler tactic called <code class="hljs">rfl</code> specifically uses definitional equality to prove propositional equality.
The name <code class="hljs">rfl</code> is short for <em>reflexivity</em>, which is the property of equality that states that everything equals itself.</p>
<p>Unsticking <code class="hljs">appendR</code> requires a proof that <code class="hljs">k = Nat.plusR 0 k</code>, which is not a definitional equality because <code class="hljs">plusR</code> is stuck on the variable in its second argument.
To get it to compute, the <code class="hljs">k</code> must become a concrete constructor.
This is a job for pattern matching.</p>
<p>In particular, because <code class="hljs">k</code> could be <em>any</em> <code class="hljs">Nat</code>, this task requires a function that can return evidence that <code class="hljs">k = Nat.plusR 0 k</code> for <em>any</em> <code class="hljs">k</code> whatsoever.
This should be a function that returns a proof of equality, with type <code class="hljs">(k : Nat) â k = Nat.plusR 0 k</code>.
Getting it started with initial patterns and placeholders yields the following messages:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">R</span><span class="hljs-title">_</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> (k : Nat) â k = Nat.plusR <span class="hljs-number">0</span> k
  | <span class="hljs-number">0</span> =&gt; _
  | k + <span class="hljs-number">1</span> =&gt; _
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
â¢ 0 = Nat.plusR 0 0
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
k : Nat
â¢ k + 1 = Nat.plusR 0 (k + 1)
</code></pre>
<p>Having refined <code class="hljs">k</code> to <code class="hljs">0</code> via pattern matching, the first placeholder stands for evidence of a statement that does hold definitionally.
The <code class="hljs">rfl</code> tactic takes care of it, leaving only the second placeholder:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">R</span><span class="hljs-title">_</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> (k : Nat) â k = Nat.plusR <span class="hljs-number">0</span> k
  | <span class="hljs-number">0</span> =&gt; <span class="hljs-keyword">by</span> <span class="hljs-built_in">rfl</span>
  | k + <span class="hljs-number">1</span> =&gt; _
</code></pre>
<p>The second placeholder is a bit trickier.
The expression <code class="hljs">Nat.plusR 0 k + 1</code> is definitionally equal to <code class="hljs">Nat.plusR 0 (k + 1)</code>.
This means that the goal could also be written <code class="hljs">k + 1 = Nat.plusR 0 k + 1</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">R</span><span class="hljs-title">_</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> (k : Nat) â k = Nat.plusR <span class="hljs-number">0</span> k
  | <span class="hljs-number">0</span> =&gt; <span class="hljs-keyword">by</span> <span class="hljs-built_in">rfl</span>
  | k + <span class="hljs-number">1</span> =&gt; (_ : k + <span class="hljs-number">1</span> = Nat.plusR <span class="hljs-number">0</span> k + <span class="hljs-number">1</span>)
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
k : Nat
â¢ k + 1 = Nat.plusR 0 k + 1
</code></pre>
<p>Underneath the <code class="hljs">+ 1</code> on each side of the equality statement is another instance of what the function itself returns.
In other words, a recursive call on <code class="hljs">k</code> would return evidence that <code class="hljs">k = Nat.plusR 0 k</code>.
Equality wouldn't be equality if it didn't apply to function arguments. 
In other words, if <code class="hljs">x = y</code>, then <code class="hljs">f x = f y</code>.
The standard library contains a function <code class="hljs">congrArg</code> that takes a function and an equality proof and returns a new proof where the function has been applied to both sides of the equality.
In this case, the function is <code class="hljs">(Â· + 1)</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">R</span><span class="hljs-title">_</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> (k : Nat) â k = Nat.plusR <span class="hljs-number">0</span> k
  | <span class="hljs-number">0</span> =&gt; <span class="hljs-keyword">by</span> <span class="hljs-built_in">rfl</span>
  | k + <span class="hljs-number">1</span> =&gt;
    congrArg (Â· + <span class="hljs-number">1</span>) (plusR_zero_left k)
</code></pre>
<p>Propositional equalities can be deployed in a program using the rightward triangle operator <code class="hljs">â¸</code>.
Given an equality proof as its first argument and some other expression as its second, this operator replaces instances of the left side of the equality with the right side of the equality in the second argument's type.
In other words, the following definition contains no type errors:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">R</span> <span class="hljs-symbol">:</span></span> (n k : Nat) â Vect Î± n â Vect Î± k â Vect Î± (n.plusR k)
  | <span class="hljs-number">0</span>, k, .nil, ys =&gt; plusR_zero_left k â¸ (_ : Vect Î± k)
  | n + <span class="hljs-number">1</span>, k, .cons x xs, ys =&gt; _
</code></pre>
<p>The first placeholder has the expected type:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Î± : Type u_1
k : Nat
ys : Vect Î± k
â¢ Vect Î± k
</code></pre>
<p>It can now be filled in with <code class="hljs">ys</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">R</span> <span class="hljs-symbol">:</span></span> (n k : Nat) â Vect Î± n â Vect Î± k â Vect Î± (n.plusR k)
  | <span class="hljs-number">0</span>, k, .nil, ys =&gt; plusR_zero_left k â¸ ys
  | n + <span class="hljs-number">1</span>, k, .cons x xs, ys =&gt; _
</code></pre>
<p>Filling in the remaining placeholder requires unsticking another instance of addition:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
Î± : Type u_1
n k : Nat
x : Î±
xs : Vect Î± n
ys : Vect Î± k
â¢ Vect Î± (Nat.plusR (n + 1) k)
</code></pre>
<p>Here, the statement to be proved is that <code class="hljs">Nat.plusR (n + 1) k = Nat.plusR n k + 1</code>, which can be used with <code class="hljs">â¸</code> to draw the <code class="hljs">+ 1</code> out to the top of the expression so that it matches the index of <code class="hljs">cons</code>.</p>
<p>The proof is a recursive function that pattern matches on the second argument to <code class="hljs">plusR</code>, namely <code class="hljs">k</code>.
This is because <code class="hljs">plusR</code> itself pattern matches on its second argument, so the proof can "unstick" it through pattern matching, exposing the computational behavior.
The skeleton of the proof is very similar to that of <code class="hljs">plusR_zero_left</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">R</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span> (k : Nat) â Nat.plusR (n + <span class="hljs-number">1</span>) k = Nat.plusR n k + <span class="hljs-number">1</span>
  | <span class="hljs-number">0</span> =&gt; <span class="hljs-keyword">by</span> <span class="hljs-built_in">rfl</span>
  | k + <span class="hljs-number">1</span> =&gt; _
</code></pre>
<p>The remaining case's type is definitionally equal to <code class="hljs">Nat.plusR (n + 1) k + 1 = Nat.plusR n (k + 1) + 1</code>, so it can be solved with <code class="hljs">congrArg</code>, just as in <code class="hljs">plusR_zero_left</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">don't know how to synthesize placeholder
context:
n k : Nat
â¢ Nat.plusR (n + 1) (k + 1) = Nat.plusR n (k + 1) + 1
</code></pre>
<p>This results in a finished proof:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">R</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span> (k : Nat) â Nat.plusR (n + <span class="hljs-number">1</span>) k = Nat.plusR n k + <span class="hljs-number">1</span>
  | <span class="hljs-number">0</span> =&gt; <span class="hljs-keyword">by</span> <span class="hljs-built_in">rfl</span>
  | k + <span class="hljs-number">1</span> =&gt; congrArg (Â· + <span class="hljs-number">1</span>) (plusR_succ_left n k)
</code></pre>
<p>The finished proof can be used to unstick the second case in <code class="hljs">appendR</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">R</span> <span class="hljs-symbol">:</span></span> (n k : Nat) â Vect Î± n â Vect Î± k â Vect Î± (n.plusR k)
  | <span class="hljs-number">0</span>, k, .nil, ys =&gt; plusR_zero_left k â¸ ys
  | n + <span class="hljs-number">1</span>, k, .cons x xs, ys =&gt; plusR_succ_left n k â¸ .cons x (appendR n k xs ys)
</code></pre>
<p>When making the length arguments to <code class="hljs">appendR</code> implicit again, they are no longer explicitly named to be appealed to in the proofs.
However, Lean's type checker has enough information to fill them in automatically behind the scenes, because no other values would allow the types to match:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">R</span> <span class="hljs-symbol">:</span></span> Vect Î± n â Vect Î± k â Vect Î± (n.plusR k)
  | .nil, ys =&gt; plusR_zero_left _ â¸ ys
  | .cons x xs, ys =&gt; plusR_succ_left _ _ â¸ .cons x (appendR xs ys)
</code></pre>
<h2 id="pros-and-cons"><a class="header" href="#pros-and-cons">Pros and Cons</a></h2>
<p>Indexed families have an important property: pattern matching on them affects definitional equality.
For example, in the <code class="hljs">nil</code> case in a <code class="hljs">match</code> expression on a <code class="hljs">Vect</code>, the length simply <em>becomes</em> <code class="hljs">0</code>.
Definitional equality can be very convenient, because it is always active and does not need to be invoked explicitly.</p>
<p>However, the use of definitional equality with dependent types and pattern matching has serious software engineering drawbacks.
First off, functions must be written especially to be used in types, and functions that are convenient to use in types may not use the most efficient algorithms.
Once a function has been exposed through using it in a type, its implementation has become part of the interface, leading to difficulties in future refactoring.
Secondly, definitional equality can be slow.
When asked to check whether two expressions are definitionally equal, Lean may need to run large amounts of code if the functions in question are complicated and have many layers of abstraction.
Third, error messages that result from failures of definitional equality are not always very easy to understand, because they may be phrased in terms of the internals of functions.
It is not always easy to understand the provenance of the expressions in the error messages.
Finally, encoding non-trivial invariants in a collection of indexed families and dependently-typed functions can often be brittle.
It is often necessary to change early definitions in a system when the exposed reduction behavior of functions proves to not provide convenient definitional equalities.
The alternative is to litter the program with appeals to equality proofs, but these can become quite unwieldy.</p>
<p>In idiomatic Lean code, indexed datatypes are not used very often.
Instead, subtypes and explicit propositions are typically used to enforce important invariants.
This approach involves many explicit proofs, and very few appeals to definitional equality.
As befits an interactive theorem prover, Lean has been designed to make explicit proofs convenient.
Generally speaking, this approach should be preferred in most cases.</p>
<p>However, understanding indexed families of datatypes is important.
Recursive functions such as <code class="hljs">plusR_zero_left</code> and <code class="hljs">plusR_succ_left</code> are in fact <em>proofs by mathematical induction</em>.
The base case of the recursion corresponds to the base case in induction, and the recursive call represents an appeal to the induction hypothesis.
More generally, new propositions in Lean are often defined as inductive types of evidence, and these inductive types usually have indices.
The process of proving theorems is in fact constructing expressions with these types behind the scenes, in a process not unlike the proofs in this section.
Also, indexed datatypes are sometimes exactly the right tool for the job.
Fluency in their use is an important part of knowing when to use them.</p>
<h2 id="exercises-21"><a class="header" href="#exercises-21">Exercises</a></h2>
<ul>
<li>Using a recursive function in the style of <code class="hljs">plusR_succ_left</code>, prove that for all <code class="hljs">Nat</code>s <code class="hljs">n</code> and <code class="hljs">k</code>, <code class="hljs">n.plusR k = n + k</code>.</li>
<li>Write a function on <code class="hljs">Vect</code> for which <code class="hljs">plusR</code> is more natural than <code class="hljs">plusL</code>, where <code class="hljs">plusL</code> would require proofs to be used in the definition.</li>
</ul>
<div style="break-before:page;page-break-before:always"></div><h1 id="summary-6"><a class="header" href="#summary-6">Summary</a></h1>
<h2 id="dependent-types"><a class="header" href="#dependent-types">Dependent Types</a></h2>
<p>Dependent types, where types contain non-type code such as function calls and ordinary data constructors, lead to a massive increase in the expressive power of a type system.
The ability to <em>compute</em> a type from the <em>value</em> of an argument means that the return type of a function can vary based on which argument is provided.
This can be used, for example, to have the result type of a database query depend on the database's schema and the specific query issued, without needing any potentially-failing cast operations on the result of the query.
When the query changes, so does the type that results from running it, enabling immediate compile-time feedback.</p>
<p>When a function's return type depends on a value, analyzing the value with pattern matching can result in the type being <em>refined</em>, as a variable that stands for a value is replaced by the constructors in the pattern.
The type signature of a function documents the way that the return type depends on the argument value, and pattern matching then explains how the return type can be fulfilled for each potential argument.</p>
<p>Ordinary code that occurs in types is run during type checking, though <code class="hljs">partial</code> functions that might loop infinitely are not called.
Mostly, this computation follows the rules of ordinary evaluation that were introduced in <a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/evaluating.html">the very beginning of this book</a>, with expressions being progressively replaced by their values until a final value is found.
Computation during type checking has an important difference from run-time computation: some values in types may be <em>variables</em> whose values are not yet known.
In these cases, pattern-matching gets "stuck" and does not proceed until or unless a particular constructor is selected, e.g. by pattern matching.
Type-level computation can be seen as a kind of partial evaluation, where only the parts of the program that are sufficiently known need to be evaluated and other parts are left alone.</p>
<h2 id="the-universe-pattern"><a class="header" href="#the-universe-pattern">The Universe Pattern</a></h2>
<p>A common pattern when working with dependent types is to section off some subset of the type system.
For example, a database query library might be able to return varying-length strings, fixed-length strings, or numbers in certain ranges, but it will never return a function, a user-defined datatype, or an <code class="hljs">IO</code> action.
A domain-specific subset of the type system can be defined by first defining a datatype with constructors that match the structure of the desired types, and then defining a function that interprets values from this datatype into honest-to-goodness types.
The constructors are referred to as <em>codes</em> for the types in question, and the entire pattern is sometimes referred to as a <em>universe Ã  la Tarski</em>, or just as a <em>universe</em> when context makes it clear that universes such as <code class="hljs">Type 3</code> or <code class="hljs">Prop</code> are not what's meant.</p>
<p>Custom universes are an alternative to defining a type class with instances for each type of interest.
Type classes are extensible, but extensibility is not always desired.
Defining a custom universe has a number of advantages over using the types directly:</p>
<ul>
<li>Generic operations that work for <em>any</em> type in the universe, such as equality testing and serialization, can be implemented by recursion on codes.</li>
<li>The types accepted by external systems can be represented precisely, and the definition of the code datatype serves to document what can be expected.</li>
<li>Lean's pattern matching completeness checker ensures that no codes are forgotten, while solutions based on type classes defer missing instance errors to client code.</li>
</ul>
<h2 id="indexed-families-1"><a class="header" href="#indexed-families-1">Indexed Families</a></h2>
<p>Datatypes can take two separate kinds of arguments: <em>parameters</em> are identical in each constructor of the datatype, while <em>indices</em> may vary between constructors.
For a given choice of index, only some constructors of the datatype are available.
As an example, <code class="hljs">Vect.nil</code> is available only when the length index is <code class="hljs">0</code>, and <code class="hljs">Vect.cons</code> is available only when the length index is <code class="hljs">n+1</code> for some <code class="hljs">n</code>.
While parameters are typically written as named arguments before the colon in a datatype declaration, and indices as arguments in a function type after the colon, Lean can infer when an argument after the colon is used as a parameter.</p>
<p>Indexed families allow the expression of complicated relationships between data, all checked by the compiler.
The datatype's invariants can be encoded directly, and there is no way to violate them, not even temporarily.
Informing the compiler about the datatype's invariants brings a major benefit: the compiler can now inform the programmer about what must be done to satisfy them.
The strategic use of compile-time errors, especially those resulting from underscores, can make it possible to offload some of the programming thought process to Lean, freeing up the programmer's mind to worry about other things.</p>
<p>Encoding invariants using indexed families can lead to difficulties.
First off, each invariant requires its own datatype, which then requires its own support libraries.
<code class="hljs">List.append</code> and <code class="hljs">Vect.append</code> are not interchangeable, after all.
This can lead to code duplication.
Secondly, convenient use of indexed families requires that the recursive structure of functions used in types match the recursive structure of the programs being type checked.
Programming with indexed families is the art of arranging for the right coincidences to occur.
While it's possible to work around missing coincidences with appeals to equality proofs, it is difficult, and it leads to programs littered with cryptic justifications.
Thirdly, running complicated code on large values during type checking can lead to compile-time slowdowns.
Avoiding these slowdowns for complicated programs can require specialized techniques.</p>
<h2 id="definitional-and-propositional-equality"><a class="header" href="#definitional-and-propositional-equality">Definitional and Propositional Equality</a></h2>
<p>Lean's type checker must, from time to time, check whether two types should be considered interchangeable.
Because types can contain arbitrary programs, it must therefore be able to check arbitrary programs for equality.
However, there is no efficient algorithm to check arbitrary programs for fully-general mathematical equality.
To work around this, Lean contains two notions of equality:</p>
<ul>
<li>
<p><em>Definitional equality</em> is an underapproximation of equality that essentially checks for equality of syntactic representation modulo computation and renaming of bound variables. Lean automatically checks for definitional equality in situations where it is required.</p>
</li>
<li>
<p><em>Propositional equality</em> must be explicitly proved and explicitly invoked by the programmer. In return, Lean automatically checks that the proofs are valid and that the invocations accomplish the right goal.</p>
</li>
</ul>
<p>The two notions of equality represent a division of labor between programmers and Lean itself.
Definitional equality is simple, but automatic, while propositional equality is manual, but expressive.
Propositional equality can be used to unstick otherwise-stuck programs in types.</p>
<p>However, the frequent use of propositional equality to unstick type-level computation is typically a code smell.
It typically means that coincidences were not well-engineered, and it's usually a better idea to either redesign the types and indices or to use a different technique to enforce the needed invariants.
When propositional equality is instead used to prove that a program meets a specification, or as part of a subtype, there is less reason to be suspicious.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="interlude-tactics-induction-and-proofs"><a class="header" href="#interlude-tactics-induction-and-proofs">Interlude: Tactics, Induction, and Proofs</a></h1>
<h2 id="a-note-on-proofs-and-user-interfaces"><a class="header" href="#a-note-on-proofs-and-user-interfaces">A Note on Proofs and User Interfaces</a></h2>
<p>This book presents the process of writing proofs as if they are written in one go and submitted to Lean, which then replies with error messages that describe what remains to be done.
The actual process of interacting with Lean is much more pleasant.
Lean provides information about the proof as the cursor is moved through it and there are a number of interactive features that make proving easier.
Please consult the documentation of your Lean development environment for more information.</p>
<p>The approach in this book that focuses on incrementally building a proof and showing the messages that result demonstrates the kinds of interactive feedback that Lean provides while writing a proof, even though it is much slower than the process used by experts.
At the same time, seeing incomplete proofs evolve towards completeness is a useful perspective on proving.
As your skill in writing proofs increases, Lean's feedback will come to feel less like errors and more like support for your own thought processes.
Learning the interactive approach is very important.</p>
<h2 id="recursion-and-induction"><a class="header" href="#recursion-and-induction">Recursion and Induction</a></h2>
<p>The functions <code class="hljs">plusR_succ_left</code> and <code class="hljs">plusR_zero_left</code> from the preceding chapter can be seen from two perspectives.
On the one hand, they are recursive functions that build up evidence for a proposition, just as other recursive functions might construct a list, a string, or any other data structure.
On the other, they also correspond to proofs by <em>mathematical induction</em>.</p>
<p>Mathematical induction is a proof technique where a statement is proven for <em>all</em> natural numbers in two steps:</p>
<ol>
<li>The statement is shown to hold for <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-66-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-527" style="width:0.607em;display:inline-block"><span style="display:inline-block;position:relative;width:0.486em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.45em,2.542em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-528"><span class="mn" id="MathJax-Span-529" style="font-family:MathJax_Main">0</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.098em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math></span></span>. This is called the <em>base case</em>.</li>
<li>Under the assumption that the statement holds for some arbitrarily chosen number <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-67-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-530" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-531"><span class="mi" id="MathJax-Span-532" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span>, it is shown to hold for <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-68-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>+</mo><mn>1</mn></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-533" style="width:2.946em;display:inline-block"><span style="display:inline-block;position:relative;width:2.381em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1002.3em,2.583em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-534"><span class="mi" id="MathJax-Span-535" style="font-family:MathJax_Math;font-style:italic">n</span><span class="mo" id="MathJax-Span-536" style="font-family:MathJax_Main;padding-left:0.244em">+</span><span class="mn" id="MathJax-Span-537" style="font-family:MathJax_Main;padding-left:0.244em">1</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.148em;border-left:0px solid;width:0px;height:1.052em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>+</mo><mn>1</mn></math></span></span>. This is called the <em>induction step</em>. The assumption that the statement holds for <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-69-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-538" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-539"><span class="mi" id="MathJax-Span-540" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span> is called the <em>induction hypothesis</em>.</li>
</ol>
<p>Because it's impossible to check the statement for <em>every</em> natural number, induction provides a means of writing a proof that could, in principle, be expanded to any particular natural number.
For example, if a concrete proof were desired for the number 3, then it could be constructed by using first the base case and then the induction step three times, to show the statement for 0, 1, 2, and finally 3.
Thus, it proves the statement for all natural numbers.</p>
<h2 id="the-induction-tactic"><a class="header" href="#the-induction-tactic">The Induction Tactic</a></h2>
<p>Writing proofs by induction as recursive functions that use helpers such as <code class="hljs">congrArg</code> does not always do a good job of expressing the intentions behind the proof.
While recursive functions indeed have the structure of induction, they should probably be viewed as an <em>encoding</em> of a proof.
Furthermore, Lean's tactic system provides a number of opportunities to automate the construction of a proof that are not available when writing the recursive function explicitly.
Lean provides an induction <em>tactic</em> that can carry out an entire proof by induction in a single tactic block.
Behind the scenes, Lean constructs the recursive function that corresponds the use of induction.</p>
<p>To prove <code class="hljs">plusR_zero_left</code> with the induction tactic, begin by writing its signature (using <code class="hljs">theorem</code>, because this really is a proof).
Then, use <code class="hljs">by induction k</code> as the body of the definition:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">R</span><span class="hljs-title">_</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-params">(k : Nat)</span> <span class="hljs-symbol">:</span></span> k = Nat.plusR <span class="hljs-number">0</span> k := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> k
</code></pre>
<p>The resulting message states that there are two goals:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case zero
â¢ Nat.zero = Nat.plusR 0 Nat.zero

case succ
nâ : Nat
n_ihâ : nâ = Nat.plusR 0 nâ
â¢ Nat.succ nâ = Nat.plusR 0 (Nat.succ nâ)
</code></pre>
<p>A tactic block is a program that is run while the Lean type checker processes a file, somewhat like a much more powerful C preprocessor macro.
The tactics generate the actual program.</p>
<p>In the tactic language, there can be a number of goals.
Each goal consists of a type together with some assumptions.
These are analogous to using underscores as placeholdersâthe type in the goal represents what is to be proved, and the assumptions represent what is in-scope and can be used.
In the case of the goal <code class="hljs">case zero</code>, there are no assumptions and the type is <code class="hljs">Nat.zero = Nat.plusR 0 Nat.zero</code>âthis is the theorem statement with <code class="hljs">0</code> instead of <code class="hljs">k</code>.
In the goal <code class="hljs">case succ</code>, there are two assumptions, named <code class="hljs">nâ</code> and <code class="hljs">n_ihâ</code>.
Behind the scenes, the <code class="hljs">induction</code> tactic creates a dependent pattern match that refines the overall type, and <code class="hljs">nâ</code> represents the argument to <code class="hljs">Nat.succ</code> in the pattern.
The assumption <code class="hljs">n_ihâ</code> represents the result of calling the generated function recursively on <code class="hljs">nâ</code>.
Its type is the overall type of the theorem, just with <code class="hljs">nâ</code> instead of <code class="hljs">k</code>.
The type to be fulfilled as part of the goal <code class="hljs">case succ</code> is the overall theorem statement, with <code class="hljs">Nat.succ nâ</code> instead of <code class="hljs">k</code>.</p>
<p>The two goals that result from the use of the <code class="hljs">induction</code> tactic correspond to the base case and the induction step in the description of mathematical induction.
The base case is <code class="hljs">case zero</code>.
In <code class="hljs">case succ</code>, <code class="hljs">n_ihâ</code> corresponds to the induction hypothesis, while the whole of <code class="hljs">case succ</code> is the induction step.</p>
<p>The next step in writing the proof is to focus on each of the two goals in turn.
Just as <code class="hljs">pure ()</code> can be used in a <code class="hljs">do</code> block to indicate "do nothing", the tactic language has a statement <code class="hljs">skip</code> that also does nothing.
This can be used when Lean's syntax requires a tactic, but it's not yet clear which one should be used.
Adding <code class="hljs">with</code> to the end of the <code class="hljs">induction</code> statement provides a syntax that is similar to pattern matching:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">R</span><span class="hljs-title">_</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-params">(k : Nat)</span> <span class="hljs-symbol">:</span></span> k = Nat.plusR <span class="hljs-number">0</span> k := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> k <span class="hljs-keyword">with</span>
  | zero =&gt; <span class="hljs-keyword">skip</span>
  | succ n ih =&gt; <span class="hljs-keyword">skip</span>
</code></pre>
<p>Each of the two <code class="hljs">skip</code> statements has a message associated with it.
The first shows the base case:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case zero
â¢ Nat.zero = Nat.plusR 0 Nat.zero
</code></pre>
<p>The second shows the induction step:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case succ
n : Nat
ih : n = Nat.plusR 0 n
â¢ Nat.succ n = Nat.plusR 0 (Nat.succ n)
</code></pre>
<p>In the induction step, the inaccessible names with daggers have been replaced with the names provided after <code class="hljs">succ</code>, namely <code class="hljs">n</code> and <code class="hljs">ih</code>.</p>
<p>The cases after <code class="hljs">induction ... with</code> are not patterns: they consist of the name of a goal followed by zero or more names.
The names are used for assumptions introduced in the goal; it is an error to provide more names than the goal introduces:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">R</span><span class="hljs-title">_</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-params">(k : Nat)</span> <span class="hljs-symbol">:</span></span> k = Nat.plusR <span class="hljs-number">0</span> k := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> k <span class="hljs-keyword">with</span>
  | zero =&gt; <span class="hljs-keyword">skip</span>
  | succ n ih lots of names =&gt; <span class="hljs-keyword">skip</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">too many variable names provided at alternative 'succ', #5 provided, but #2 expected
</code></pre>
<p>Focusing on the base case, the <code class="hljs">rfl</code> tactic works just as well inside of the <code class="hljs">induction</code> tactic as it does in a recursive function:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">R</span><span class="hljs-title">_</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-params">(k : Nat)</span> <span class="hljs-symbol">:</span></span> k = Nat.plusR <span class="hljs-number">0</span> k := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> k <span class="hljs-keyword">with</span>
  | zero =&gt; <span class="hljs-keyword">rfl</span>
  | succ n ih =&gt; <span class="hljs-keyword">skip</span>
</code></pre>
<p>In the recursive function version of the proof, a type annotation made the expected type something that was easier to understand.
In the tactic language, there are a number of specific ways to transform a goal to make it easier to solve.
The <code class="hljs">unfold</code> tactic replaces a defined name with its definition:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">R</span><span class="hljs-title">_</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-params">(k : Nat)</span> <span class="hljs-symbol">:</span></span> k = Nat.plusR <span class="hljs-number">0</span> k := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> k <span class="hljs-keyword">with</span>
  | zero =&gt; <span class="hljs-keyword">rfl</span>
  | succ n ih =&gt;
    <span class="hljs-keyword">unfold</span> Nat.plusR
</code></pre>
<p>Now, the right-hand side of the equality in the goal has become <code class="hljs">Nat.plusR 0 n + 1</code> instead of <code class="hljs">Nat.plusR 0 (Nat.succ n)</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case succ
n : Nat
ih : n = Nat.plusR 0 n
â¢ Nat.succ n = Nat.plusR 0 n + 1
</code></pre>
<p>Instead of appealing to functions like <code class="hljs">congrArg</code> and operators like <code class="hljs">â¸</code>, there are tactics that allow equality proofs to be used to transform proof goals.
One of the most important is <code class="hljs">rw</code>, which takes a list of equality proofs and replaces the left side with the right side in the goal.
This almost does the right thing in <code class="hljs">plusR_zero_left</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">R</span><span class="hljs-title">_</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-params">(k : Nat)</span> <span class="hljs-symbol">:</span></span> k = Nat.plusR <span class="hljs-number">0</span> k := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> k <span class="hljs-keyword">with</span>
  | zero =&gt; <span class="hljs-keyword">rfl</span>
  | succ n ih =&gt;
    <span class="hljs-keyword">unfold</span> Nat.plusR
    <span class="hljs-keyword">rw</span> [ih]
</code></pre>
<p>However, the direction of the rewrite was incorrect.
Replacing <code class="hljs">n</code> with <code class="hljs">Nat.plusR 0 n</code> made the goal more complicated rather than less complicated:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case succ
n : Nat
ih : n = Nat.plusR 0 n
â¢ Nat.succ (Nat.plusR 0 n) = Nat.plusR 0 (Nat.plusR 0 n) + 1
</code></pre>
<p>This can be remedied by placing a left arrow before <code class="hljs">ih</code> in the call to <code class="hljs">rewrite</code>, which instructs it to replace the right-hand side of the equality with the left-hand side:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">R</span><span class="hljs-title">_</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-params">(k : Nat)</span> <span class="hljs-symbol">:</span></span> k = Nat.plusR <span class="hljs-number">0</span> k := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> k <span class="hljs-keyword">with</span>
  | zero =&gt; <span class="hljs-keyword">rfl</span>
  | succ n ih =&gt;
    <span class="hljs-keyword">unfold</span> Nat.plusR
    <span class="hljs-keyword">rw</span> [âih]
</code></pre>
<p>This rewrite makes both sides of the equation identical, and Lean takes care of the <code class="hljs">rfl</code> on its own.
The proof is complete.</p>
<h2 id="tactic-golf"><a class="header" href="#tactic-golf">Tactic Golf</a></h2>
<p>So far, the tactic language has not shown its true value.
The above proof is no shorter than the recursive function; it's merely written in a domain-specific language instead of the full Lean language.
But proofs with tactics can be shorter, easier, and more maintainable.
Just as a lower score is better in the game of golf, a shorter proof is better in the game of tactic golf.</p>
<p>The induction step of <code class="hljs">plusR_zero_left</code> can be proved using the simplification tactic <code class="hljs">simp</code>.
Using <code class="hljs">simp</code> on its own does not help:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">R</span><span class="hljs-title">_</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-params">(k : Nat)</span> <span class="hljs-symbol">:</span></span> k = Nat.plusR <span class="hljs-number">0</span> k := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> k <span class="hljs-keyword">with</span>
  | zero =&gt; <span class="hljs-keyword">rfl</span>
  | succ n ih =&gt;
    <span class="hljs-keyword">simp</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">simp made no progress
</code></pre>
<p>However, <code class="hljs">simp</code> can be configured to make use of a set of definitions.
Just like <code class="hljs">rw</code>, these arguments are provided in a list.
Asking <code class="hljs">simp</code> to take the definition of <code class="hljs">Nat.plusR</code> into account leads to a simpler goal:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">R</span><span class="hljs-title">_</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-params">(k : Nat)</span> <span class="hljs-symbol">:</span></span> k = Nat.plusR <span class="hljs-number">0</span> k := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> k <span class="hljs-keyword">with</span>
  | zero =&gt; <span class="hljs-keyword">rfl</span>
  | succ n ih =&gt;
    <span class="hljs-keyword">simp</span> [Nat.plusR]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case succ
n : Nat
ih : n = Nat.plusR 0 n
â¢ n = Nat.plusR 0 n
</code></pre>
<p>In particular, the goal is now identical to the induction hypothesis.
In addition to automatically proving simple equality statements, the simplifier automatically replaces goals like <code class="hljs">Nat.succ A = Nat.succ B</code> with <code class="hljs">A = B</code>.
Because the induction hypothesis <code class="hljs">ih</code> has exactly the right type, the <code class="hljs">exact</code> tactic can indicate that it should be used:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">R</span><span class="hljs-title">_</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-params">(k : Nat)</span> <span class="hljs-symbol">:</span></span> k = Nat.plusR <span class="hljs-number">0</span> k := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> k <span class="hljs-keyword">with</span>
  | zero =&gt; <span class="hljs-keyword">rfl</span>
  | succ n ih =&gt;
    <span class="hljs-keyword">simp</span> [Nat.plusR]
    <span class="hljs-keyword">exact</span> ih
</code></pre>
<p>However, the use of <code class="hljs">exact</code> is somewhat fragile.
Renaming the induction hypothesis, which may happen while "golfing" the proof, would cause this proof to stop working.
The <code class="hljs">assumption</code> tactic solves the current goal if <em>any</em> of the assumptions match it:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">R</span><span class="hljs-title">_</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-params">(k : Nat)</span> <span class="hljs-symbol">:</span></span> k = Nat.plusR <span class="hljs-number">0</span> k := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> k <span class="hljs-keyword">with</span>
  | zero =&gt; <span class="hljs-keyword">rfl</span>
  | succ n ih =&gt;
    <span class="hljs-keyword">simp</span> [Nat.plusR]
    <span class="hljs-keyword">assumption</span>
</code></pre>
<p>This proof is no shorter than the prior proof that used unfolding and explicit rewriting.
However, a series of transformations can make it much shorter, taking advantage of the fact that <code class="hljs">simp</code> can solve many kinds of goals.
The first step is to drop the <code class="hljs">with</code> at the end of <code class="hljs">induction</code>.
For structured, readable proofs, the <code class="hljs">with</code> syntax is convenient.
It complains if any cases are missing, and it shows the structure of the induction clearly.
But shortening proofs can often require a more liberal approach.</p>
<p>Using <code class="hljs">induction</code> without <code class="hljs">with</code> simply results in a proof state with two goals.
The <code class="hljs">case</code> tactic can be used to select one of them, just as in the branches of the <code class="hljs">induction ... with</code> tactic.
In other words, the following proof is equivalent to the prior proof:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">R</span><span class="hljs-title">_</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-params">(k : Nat)</span> <span class="hljs-symbol">:</span></span> k = Nat.plusR <span class="hljs-number">0</span> k := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> k
  <span class="hljs-keyword">case</span> zero =&gt; <span class="hljs-keyword">rfl</span>
  <span class="hljs-keyword">case</span> succ n ih =&gt;
    <span class="hljs-keyword">simp</span> [Nat.plusR]
    <span class="hljs-keyword">assumption</span>
</code></pre>
<p>In a context with a single goal (namely, <code class="hljs">k = Nat.plusR 0 k</code>), the <code class="hljs">induction k</code> tactic yields two goals.
In general, a tactic will either fail with an error or take a goal and transform it into zero or more new goals.
Each new goal represents what remains to be proved.
If the result is zero goals, then the tactic was a success, and that part of the proof is done.</p>
<p>The <code class="hljs">&lt;;&gt;</code> operator takes two tactics as arguments, resulting in a new tactic.
<code class="hljs">T1 &lt;;&gt; T2</code> applies <code class="hljs">T1</code> to the current goal, and then applies <code class="hljs">T2</code> in <em>all</em> goals created by <code class="hljs">T1</code>.
In other words, <code class="hljs">&lt;;&gt;</code> enables a general tactic that can solve many kinds of goals to be used on multiple new goals all at once.
One such general tactic is <code class="hljs">simp</code>.</p>
<p>Because <code class="hljs">simp</code> can both complete the proof of the base case and make progress on the proof of the induction step, using it with <code class="hljs">induction</code> and <code class="hljs">&lt;;&gt;</code> shortens the proof:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">R</span><span class="hljs-title">_</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-params">(k : Nat)</span> <span class="hljs-symbol">:</span></span> k = Nat.plusR <span class="hljs-number">0</span> k := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> k &lt;;&gt; <span class="hljs-keyword">simp</span> [Nat.plusR]
</code></pre>
<p>This results in only a single goal, the transformed induction step:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case succ
nâ : Nat
n_ihâ : nâ = Nat.plusR 0 nâ
â¢ nâ = Nat.plusR 0 nâ
</code></pre>
<p>Running <code class="hljs">assumption</code> in this goal completes the proof:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">R</span><span class="hljs-title">_</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">f</span><span class="hljs-title">t</span> <span class="hljs-params">(k : Nat)</span> <span class="hljs-symbol">:</span></span> k = Nat.plusR <span class="hljs-number">0</span> k := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> k &lt;;&gt; <span class="hljs-keyword">simp</span> [Nat.plusR] &lt;;&gt; <span class="hljs-keyword">assumption</span>
</code></pre>
<p>Here, <code class="hljs">exact</code> would not have been possible, because <code class="hljs">ih</code> was never explicitly named.</p>
<p>For beginners, this proof is not easier to read.
However, a common pattern for expert users is to take care of a number of simple cases with powerful tactics like <code class="hljs">simp</code>, allowing them to focus the text of the proof on the interesting cases.
Additionally, these proofs tend to be more robust in the face of small changes to the functions and datatypes involved in the proof.
The game of tactic golf is a useful part of developing good taste and style when writing proofs.</p>
<h2 id="induction-on-other-datatypes"><a class="header" href="#induction-on-other-datatypes">Induction on Other Datatypes</a></h2>
<p>Mathematical induction proves a statement for natural numbers by providing a base case for <code class="hljs">Nat.zero</code> and an induction step for <code class="hljs">Nat.succ</code>.
The principle of induction is also valid for other datatypes.
Constructors without recursive arguments form the base cases, while constructors with recursive arguments form the induction steps.
The ability to carry out proofs by induction is the very reason why they are called <em>inductive</em> datatypes.</p>
<p>One example of this is induction on binary trees.
Induction on binary trees is a proof technique where a statement is proven for <em>all</em> binary trees in two steps:</p>
<ol>
<li>The statement is shown to hold for <code class="hljs">BinTree.leaf</code>. This is called the base case.</li>
<li>Under the assumption that the statement holds for some arbitrarily chosen trees <code class="hljs">l</code> and <code class="hljs">r</code>, it is shown to hold for <code class="hljs">BinTree.branch l x r</code>, where <code class="hljs">x</code> is an arbitrarily-chosen new data point. This is called the <em>induction step</em>. The assumptions that the statement holds for <code class="hljs">l</code> and <code class="hljs">r</code> are called the <em>induction hypotheses</em>.</li>
</ol>
<p><code class="hljs">BinTree.count</code> counts the number of branches in a tree:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">B</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span>.<span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-symbol">:</span></span> BinTree Î± â Nat
  | .leaf =&gt; <span class="hljs-number">0</span>
  | .branch l _ r =&gt;
    <span class="hljs-number">1</span> + l.count + r.count
</code></pre>
<p><a href="https://leanprover.github.io/functional_programming_in_lean/monads/conveniences.html#leading-dot-notation">Mirroring a tree</a> does not change the number of branches in it.
This can be proven using induction on trees.
The first step is to state the theorem and invoke <code class="hljs">induction</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">B</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span>.<span class="hljs-title">m</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-params">(t : BinTree Î±)</span> <span class="hljs-symbol">:</span></span> t.mirror.count = t.count := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> t <span class="hljs-keyword">with</span>
  | leaf =&gt; <span class="hljs-keyword">skip</span>
  | branch l x r ihl ihr =&gt; <span class="hljs-keyword">skip</span>
</code></pre>
<p>The base case states that counting the mirror of a leaf is the same as counting the leaf:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case leaf
Î± : Type
â¢ count (mirror leaf) = count leaf
</code></pre>
<p>The induction step allows the assumption that mirroring the left and right subtrees won't affect their branch counts, and requests a proof that mirroring a branch with these subtrees also preserves the overall branch count:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case branch
Î± : Type
l : BinTree Î±
x : Î±
r : BinTree Î±
ihl : count (mirror l) = count l
ihr : count (mirror r) = count r
â¢ count (mirror (branch l x r)) = count (branch l x r)
</code></pre>
<p>The base case is true because mirroring <code class="hljs">leaf</code> results in <code class="hljs">leaf</code>, so the left and right sides are definitionally equal.
This can be expressed by using <code class="hljs">simp</code> with instructions to unfold <code class="hljs">BinTree.mirror</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">B</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span>.<span class="hljs-title">m</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-params">(t : BinTree Î±)</span> <span class="hljs-symbol">:</span></span> t.mirror.count = t.count := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> t <span class="hljs-keyword">with</span>
  | leaf =&gt; <span class="hljs-keyword">simp</span> [BinTree.mirror]
  | branch l x r ihl ihr =&gt; <span class="hljs-keyword">skip</span>
</code></pre>
<p>In the induction step, nothing in the goal immediately matches the induction hypotheses.
Simplifying using the definitions of <code class="hljs">BinTree.count</code> and <code class="hljs">BinTree.mirror</code> reveals the relationship:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">B</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span>.<span class="hljs-title">m</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-params">(t : BinTree Î±)</span> <span class="hljs-symbol">:</span></span> t.mirror.count = t.count := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> t <span class="hljs-keyword">with</span>
  | leaf =&gt; <span class="hljs-keyword">simp</span> [BinTree.mirror]
  | branch l x r ihl ihr =&gt;
    <span class="hljs-keyword">simp</span> [BinTree.mirror, BinTree.count]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case branch
Î± : Type
l : BinTree Î±
x : Î±
r : BinTree Î±
ihl : count (mirror l) = count l
ihr : count (mirror r) = count r
â¢ 1 + count (mirror r) + count (mirror l) = 1 + count l + count r
</code></pre>
<p>Both induction hypotheses can be used to rewrite the left-hand side of the goal into something almost like the right-hand side:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">B</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span>.<span class="hljs-title">m</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-params">(t : BinTree Î±)</span> <span class="hljs-symbol">:</span></span> t.mirror.count = t.count := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> t <span class="hljs-keyword">with</span>
  | leaf =&gt; <span class="hljs-keyword">simp</span> [BinTree.mirror]
  | branch l x r ihl ihr =&gt;
    <span class="hljs-keyword">simp</span> [BinTree.mirror, BinTree.count]
    <span class="hljs-keyword">rw</span> [ihl, ihr]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case branch
Î± : Type
l : BinTree Î±
x : Î±
r : BinTree Î±
ihl : count (mirror l) = count l
ihr : count (mirror r) = count r
â¢ 1 + count r + count l = 1 + count l + count r
</code></pre>
<p>The <code class="hljs">simp_arith</code> tactic, a version of <code class="hljs">simp</code> that can use additional arithmetic identities, is enough to prove this goal, yielding:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">B</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span>.<span class="hljs-title">m</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-params">(t : BinTree Î±)</span> <span class="hljs-symbol">:</span></span> t.mirror.count = t.count := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> t <span class="hljs-keyword">with</span>
  | leaf =&gt; <span class="hljs-keyword">simp</span> [BinTree.mirror]
  | branch l x r ihl ihr =&gt;
    <span class="hljs-keyword">simp</span> [BinTree.mirror, BinTree.count]
    <span class="hljs-keyword">rw</span> [ihl, ihr]
    <span class="hljs-keyword">simp_arith</span>
</code></pre>
<p>In addition to definitions to be unfolded, the simplifier can also be passed names of equality proofs to use as rewrites while it simplifies proof goals.
<code class="hljs">BinTree.mirror_count</code> can also be written:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">B</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span>.<span class="hljs-title">m</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-params">(t : BinTree Î±)</span> <span class="hljs-symbol">:</span></span> t.mirror.count = t.count := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> t <span class="hljs-keyword">with</span>
  | leaf =&gt; <span class="hljs-keyword">simp</span> [BinTree.mirror]
  | branch l x r ihl ihr =&gt;
    <span class="hljs-keyword">simp_arith</span> [BinTree.mirror, BinTree.count, ihl, ihr]
</code></pre>
<p>As proofs grow more complicated, listing assumptions by hand can become tedious.
Furthermore, manually writing assumption names can make it more difficult to re-use proof steps for multiple subgoals.
The argument <code class="hljs">*</code> to <code class="hljs">simp</code> or <code class="hljs">simp_arith</code> instructs them to use <em>all</em> assumptions while simplifying or solving the goal.
In other words, the proof could also be written:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">B</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span>.<span class="hljs-title">m</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-params">(t : BinTree Î±)</span> <span class="hljs-symbol">:</span></span> t.mirror.count = t.count := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> t <span class="hljs-keyword">with</span>
  | leaf =&gt; <span class="hljs-keyword">simp</span> [BinTree.mirror]
  | branch l x r ihl ihr =&gt;
    <span class="hljs-keyword">simp_arith</span> [BinTree.mirror, BinTree.count, *]
</code></pre>
<p>Because both branches are using the simplifier, the proof can be reduced to:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">B</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span>.<span class="hljs-title">m</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">c</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">n</span><span class="hljs-title">t</span> <span class="hljs-params">(t : BinTree Î±)</span> <span class="hljs-symbol">:</span></span> t.mirror.count = t.count := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> t &lt;;&gt; <span class="hljs-keyword">simp_arith</span> [BinTree.mirror, BinTree.count, *]
</code></pre>
<h2 id="exercises-22"><a class="header" href="#exercises-22">Exercises</a></h2>
<ul>
<li>Prove <code class="hljs">plusR_succ_left</code> using the <code class="hljs">induction ... with</code> tactic.</li>
<li>Rewrite the proof of <code class="hljs">plus_succ_left</code> to use <code class="hljs">&lt;;&gt;</code> in a single line.</li>
<li>Prove that appending lists is associative using induction on lists: <code class="hljs">theorem List.append_assoc (xs ys zs : List Î±) : xs ++ (ys ++ zs) = (xs ++ ys) ++ zs</code></li>
</ul>
<div style="break-before:page;page-break-before:always"></div><h1 id="programming-proving-and-performance"><a class="header" href="#programming-proving-and-performance">Programming, Proving, and Performance</a></h1>
<p>This chapter is about programming.
Programs need to compute the correct result, but they also need to do so efficiently.
To write efficient functional programs, it's important to know both how to use data structures appropriately and how to think about the time and space needed to run a program.</p>
<p>This chapter is also about proofs.
One of the most important data structures for efficient programming in Lean is the array, but safe use of arrays requires proving that array indices are in bounds.
Furthermore, most interesting algorithms on arrays do not follow the pattern of structural recursionâinstead, they iterate over the array.
While these algorithms terminate, Lean will not necessarily be able to automatically check this.
Proofs can be used to demonstrate why a program terminates.</p>
<p>Rewriting programs to make them faster often results in code that is more difficult to understand.
Proofs can also show that two programs always compute the same answers, even if they do so with different algorithms or implementation techniques.
In this way, the slow, straightforward program can serve as a specification for the fast, complicated version.</p>
<p>Combining proofs and programming allows programs to be both safe and efficient.
Proofs allow elision of run-time bounds checks, they render many tests unnecessary, and they provide an extremely high level of confidence in a program without introducing any runtime performance overhead.
However, proving theorems about programs can be time consuming and expensive, so other tools are often more economical.</p>
<p>Interactive theorem proving is a deep topic.
This chapter provides only a taste, oriented towards the proofs that come up in practice while programming in Lean.
Most interesting theorems are not closely related to programming.
Please refer to <a href="https://leanprover.github.io/functional_programming_in_lean/next-steps.html">Next Steps</a> for a list of resources for learning more.
Just as when learning programming, however, there's no substitute for hands-on experience when learning to write proofsâit's time to get started!</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="tail-recursion"><a class="header" href="#tail-recursion">Tail Recursion</a></h1>
<p>While Lean's <code class="hljs">do</code>-notation makes it possible to use traditional loop syntax such as <code class="hljs">for</code> and <code class="hljs">while</code>, these constructs are translated behind the scenes to invocations of recursive functions.
In most programming languages, recursive functions have a key disadvantage with respect to loops: loops consume no space on the stack, while recursive functions consume stack space proportional to the number of recursive calls.
Stack space is typically limited, and it is often necessary to take algorithms that are naturally expressed as recursive functions and rewrite them as loops paired with an explicit mutable heap-allocated stack.</p>
<p>In functional programming, the opposite is typically true.
Programs that are naturally expressed as mutable loops may consume stack space, while rewriting them to recursive functions can cause them to run quickly.
This is due to a key aspect of functional programming languages: <em>tail-call elimination</em>.
A tail call is a call from one function to another that can be compiled to an ordinary jump, replacing the current stack frame rather than pushing a new one, and tail-call elimination is the process of implementing this transformation.</p>
<p>Tail-call elimination is not just merely an optional optimization.
Its presence is a fundamental part of being able to write efficient functional code.
For it to be useful, it must be reliable.
Programmers must be able to reliably identify tail calls, and they must be able to trust that the compiler will eliminate them.</p>
<p>The function <code class="hljs">NonTail.sum</code> adds the contents of a list of <code class="hljs">Nat</code>s:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">N</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">T</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span>.<span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> List Nat â Nat
  | [] =&gt; <span class="hljs-number">0</span>
  | x :: xs =&gt; x + sum xs
</code></pre>
<p>Applying this function to the list <code class="hljs">[1, 2, 3]</code> results in the following sequence of evaluation steps:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">NonTail.sum [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
===&gt;
<span class="hljs-number">1</span> + (NonTail.sum [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
===&gt;
<span class="hljs-number">1</span> + (<span class="hljs-number">2</span> + (NonTail.sum [<span class="hljs-number">3</span>]))
===&gt;
<span class="hljs-number">1</span> + (<span class="hljs-number">2</span> + (<span class="hljs-number">3</span> + (NonTail.sum [])))
===&gt;
<span class="hljs-number">1</span> + (<span class="hljs-number">2</span> + (<span class="hljs-number">3</span> + <span class="hljs-number">0</span>))
===&gt;
<span class="hljs-number">1</span> + (<span class="hljs-number">2</span> + <span class="hljs-number">3</span>)
===&gt;
<span class="hljs-number">1</span> + <span class="hljs-number">5</span>
===&gt;
<span class="hljs-number">6</span>
</code></pre>
<p>In the evaluation steps, parentheses indicate recursive calls to <code class="hljs">NonTail.sum</code>.
In other words, to add the three numbers, the program must first check that the list is non-empty.
To add the head of the list (<code class="hljs">1</code>) to the sum of the tail of the list, it is first necessary to compute the sum of the tail of the list:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-number">1</span> + (NonTail.sum [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
</code></pre>
<p>But to compute the sum of the tail of the list, the program must check whether it is empty.
It is not - the tail is itself a list with <code class="hljs">2</code> at its head.
The resulting step is waiting for the return of <code class="hljs">NonTail.sum [3]</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-number">1</span> + (<span class="hljs-number">2</span> + (NonTail.sum [<span class="hljs-number">3</span>]))
</code></pre>
<p>The whole point of the run-time call stack is to keep track of the values <code class="hljs">1</code>, <code class="hljs">2</code>, and <code class="hljs">3</code> along with the instruction to add them to the result of the recursive call.
As recursive calls are completed, control returns to the stack frame that made the call, so each step of addition is performed.
Storing the heads of the list and the instructions to add them is not free; it takes space proportional to the length of the list.</p>
<p>The function <code class="hljs">Tail.sum</code> also adds the contents of a list of <code class="hljs">Nat</code>s:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">T</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span>.<span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">H</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(soFar : Nat)</span> <span class="hljs-symbol">:</span></span> List Nat â Nat
  | [] =&gt; soFar
  | x :: xs =&gt; sumHelper (x + soFar) xs

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">T</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span>.<span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List Nat)</span> <span class="hljs-symbol">:</span></span> Nat :=
  Tail.sumHelper <span class="hljs-number">0</span> xs
</code></pre>
<p>Applying it to the list <code class="hljs">[1, 2, 3]</code> results in the following sequence of evaluation steps:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">Tail.sum [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
===&gt;
Tail.sumHelper <span class="hljs-number">0</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
===&gt;
Tail.sumHelper (<span class="hljs-number">0</span> + <span class="hljs-number">1</span>) [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
===&gt;
Tail.sumHelper <span class="hljs-number">1</span> [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
===&gt;
Tail.sumHelper (<span class="hljs-number">1</span> + <span class="hljs-number">2</span>) [<span class="hljs-number">3</span>]
===&gt;
Tail.sumHelper <span class="hljs-number">3</span> [<span class="hljs-number">3</span>]
===&gt;
Tail.sumHelper (<span class="hljs-number">3</span> + <span class="hljs-number">3</span>) []
===&gt;
Tail.sumHelper <span class="hljs-number">6</span> []
===&gt;
<span class="hljs-number">6</span>
</code></pre>
<p>The internal helper function calls itself recursively, but it does so in a way where nothing needs to be remembered in order to compute the final result.
When <code class="hljs">Tail.sumHelper</code> reaches its base case, control can be returned directly to <code class="hljs">Tail.sum</code>, because the intermediate invocations of <code class="hljs">Tail.sumHelper</code> simply return the results of their recursive calls unmodified.
In other words, a single stack frame can be re-used for each recursive invocation of <code class="hljs">Tail.sumHelper</code>.
Tail-call elimination is exactly this re-use of the stack frame, and <code class="hljs">Tail.sumHelper</code> is referred to as a <em>tail-recursive function</em>.</p>
<p>The first argument to <code class="hljs">Tail.sumHelper</code> contains all of the information that would otherwise need to be tracked in the call stackânamely, the sum of the numbers encountered so far.
In each recursive call, this argument is updated with new information, rather than adding new information to the call stack.
Arguments like <code class="hljs">soFar</code> that replace the information from the call stack are called <em>accumulators</em>.</p>
<p>At the time of writing and on the author's computer, <code class="hljs">NonTail.sum</code> crashes with a stack overflow when passed a list with 216,856 or more entries.
<code class="hljs">Tail.sum</code>, on the other hand, can sum a list of 100,000,000 elements without a stack overflow.
Because no new stack frames need to be pushed while running <code class="hljs">Tail.sum</code>, it is completely equivalent to a <code class="hljs">while</code> loop with a mutable variable that holds the current list.
At each recursive call, the function argument on the stack is simply replaced with the next node of the list.</p>
<h2 id="tail-and-non-tail-positions"><a class="header" href="#tail-and-non-tail-positions">Tail and Non-Tail Positions</a></h2>
<p>The reason why <code class="hljs">Tail.sumHelper</code> is tail recursive is that the recursive call is in <em>tail position</em>.
Informally speaking, a function call is in tail position when the caller does not need to modify the returned value in any way, but will just return it directly.
More formally, tail position can be defined explicitly for expressions.</p>
<p>If a <code class="hljs">match</code>-expression is in tail position, then each of its branches is also in tail position.
Once a <code class="hljs">match</code> has selected a branch, control proceeds immediately to it.
Similarly, both branches of an <code class="hljs">if</code>-expression are in tail position if the <code class="hljs">if</code>-expression itself is in tail position.
Finally, if a <code class="hljs">let</code>-expression is in tail position, then its body is as well.</p>
<p>All other positions are not in tail position.
The arguments to a function or a constructor are not in tail position because evaluation must track the function or constructor that will be applied to the argument's value.
The body of an inner function is not in tail position because control may not even pass to it: function bodies are not evaluated until the function is called.
Similarly, the body of a function type is not in tail position.
To evaluate <code class="hljs">E</code> in <code class="hljs">(x : Î±) â E</code>, it is necessary to track that the resulting type must have <code class="hljs">(x : Î±) â ...</code> wrapped around it.</p>
<p>In <code class="hljs">NonTail.sum</code>, the recursive call is not in tail position because it is an argument to <code class="hljs">+</code>.
In <code class="hljs">Tail.sumHelper</code>, the recursive call is in tail position because it is immediately underneath a pattern match, which itself is the body of the function.</p>
<p>At the time of writing, Lean only eliminates direct tail calls in recursive functions.
This means that tail calls to <code class="hljs">f</code> in <code class="hljs">f</code>'s definition will be eliminated, but not tail calls to some other function <code class="hljs">g</code>.
While it is certainly possible to eliminate a tail call to some other function, saving a stack frame, this is not yet implemented in Lean.</p>
<h2 id="reversing-lists"><a class="header" href="#reversing-lists">Reversing Lists</a></h2>
<p>The function <code class="hljs">NonTail.reverse</code> reverses lists by appending the head of each sub-list to the end of the result:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">N</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">T</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span>.<span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> List Î± â List Î±
  | [] =&gt; []
  | x :: xs =&gt; reverse xs ++ [x]
</code></pre>
<p>Using it to reverse <code class="hljs">[1, 2, 3]</code> yields the following sequence of steps:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">NonTail.reverse [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
===&gt;
(NonTail.reverse [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) ++ [<span class="hljs-number">1</span>]
===&gt;
((NonTail.reverse [<span class="hljs-number">3</span>]) ++ [<span class="hljs-number">2</span>]) ++ [<span class="hljs-number">1</span>]
===&gt;
(((NonTail.reverse []) ++ [<span class="hljs-number">3</span>]) ++ [<span class="hljs-number">2</span>]) ++ [<span class="hljs-number">1</span>]
===&gt;
(([] ++ [<span class="hljs-number">3</span>]) ++ [<span class="hljs-number">2</span>]) ++ [<span class="hljs-number">1</span>]
===&gt;
([<span class="hljs-number">3</span>] ++ [<span class="hljs-number">2</span>]) ++ [<span class="hljs-number">1</span>]
===&gt;
[<span class="hljs-number">3</span>, <span class="hljs-number">2</span>] ++ [<span class="hljs-number">1</span>]
===&gt;
[<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]
</code></pre>
<p>The tail-recursive version uses <code class="hljs">x :: Â·</code> instead of <code class="hljs">Â· ++ [x]</code> on the accumulator at each step:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">T</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span>.<span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">H</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(soFar : List Î±)</span> <span class="hljs-symbol">:</span></span> List Î± â List Î±
  | [] =&gt; soFar
  | x :: xs =&gt; reverseHelper (x :: soFar) xs

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">T</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span>.<span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> List Î± :=
  Tail.reverseHelper [] xs
</code></pre>
<p>This is because the context saved in each stack frame while computing with <code class="hljs">NonTail.reverse</code> is applied beginning at the base case.
Each "remembered" piece of context is executed in last-in, first-out order.
On the other hand, the accumulator-passing version modifies the accumulator beginning from the first entry in the list, rather than the original base case, as can be seen in the series of reduction steps:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">Tail.reverse [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
===&gt;
Tail.reverseHelper [] [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
===&gt;
Tail.reverseHelper [<span class="hljs-number">1</span>] [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
===&gt;
Tail.reverseHelper [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>] [<span class="hljs-number">3</span>]
===&gt;
Tail.reverseHelper [<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>] []
===&gt;
[<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]
</code></pre>
<p>In other words, the non-tail-recursive version starts at the base case, modifying the result of recursion from right to left through the list.
The entries in the list affect the accumulator in a first-in, first-out order.
The tail-recursive version with the accumulator starts at the head of the list, modifying an initial accumulator value from left to right through the list.</p>
<p>Because addition is commutative, nothing needed to be done to account for this in <code class="hljs">Tail.sum</code>.
Appending lists is not commutative, so care must be taken to find an operation that has the same effect when run in the opposite direction.
Appending <code class="hljs">[x]</code> after the result of the recursion in <code class="hljs">NonTail.reverse</code> is analogous to adding <code class="hljs">x</code> to the beginning of the list when the result is built in the opposite order.</p>
<h2 id="multiple-recursive-calls"><a class="header" href="#multiple-recursive-calls">Multiple Recursive Calls</a></h2>
<p>In the definition of <code class="hljs">BinTree.mirror</code>, there are two recursive calls:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">B</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">T</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span>.<span class="hljs-title">m</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">r</span><span class="hljs-title">o</span><span class="hljs-title">r</span> <span class="hljs-symbol">:</span></span> BinTree Î± â BinTree Î±
  | .leaf =&gt; .leaf
  | .branch l x r =&gt; .branch (mirror r) x (mirror l)
</code></pre>
<p>Just as imperative languages would typically use a while loop for functions like <code class="hljs">reverse</code> and <code class="hljs">sum</code>, they would typically use recursive functions for this kind of traversal.
This function cannot be straightforwardly rewritten to be tail recursive using accumulator-passing style.</p>
<p>Typically, if more than one recursive call is required for each recursive step, then it will be difficult to use accumulator-passing style.
This difficulty is similar to the difficulty of rewriting a recursive function to use a loop and an explicit data structure, with the added complication of convincing Lean that the function terminates.
However, as in <code class="hljs">BinTree.mirror</code>, multiple recursive calls often indicate a data structure that has a constructor with multiple recursive occurrences of itself.
In these cases, the depth of the structure is often logarithmic with respect to its overall size, which makes the tradeoff between stack and heap less stark.
There are systematic techniques for making these functions tail-recursive, such as using <em>continuation-passing style</em>, but they are outside the scope of this chapter.</p>
<h2 id="exercises-23"><a class="header" href="#exercises-23">Exercises</a></h2>
<p>Translate each of the following non-tail-recursive functions into accumulator-passing tail-recursive functions:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">N</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">T</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span>.<span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">n</span><span class="hljs-title">g</span><span class="hljs-title">t</span><span class="hljs-title">h</span> <span class="hljs-symbol">:</span></span> List Î± â Nat
  | [] =&gt; <span class="hljs-number">0</span>
  | _ :: xs =&gt; NonTail.length xs + <span class="hljs-number">1</span> 
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">N</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">T</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span>.<span class="hljs-title">f</span><span class="hljs-title">a</span><span class="hljs-title">c</span><span class="hljs-title">t</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">i</span><span class="hljs-title">a</span><span class="hljs-title">l</span> <span class="hljs-symbol">:</span></span> Nat â Nat
  | <span class="hljs-number">0</span> =&gt; <span class="hljs-number">1</span>
  | n + <span class="hljs-number">1</span> =&gt; factorial n * (n + <span class="hljs-number">1</span>)
</code></pre>
<p>The translation of <code class="hljs">NonTail.filter</code> should result in a program that takes constant stack space through tail recursion, and time linear in the length of the input list.
A constant factor overhead is acceptable relative to the original:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">N</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">T</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span>.<span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(p : Î± â Bool)</span> <span class="hljs-symbol">:</span></span> List Î± â List Î±
  | [] =&gt; []
  | x :: xs =&gt;
    <span class="hljs-keyword">if</span> p x <span class="hljs-keyword">then</span>
      x :: filter p xs
    <span class="hljs-keyword">else</span>
      filter p xs
</code></pre>
<div style="break-before:page;page-break-before:always"></div><h1 id="proving-equivalence"><a class="header" href="#proving-equivalence">Proving Equivalence</a></h1>
<p>Programs that have been rewritten to use tail recursion and an accumulator can look quite different from the original program.
The original recursive function is often much easier to understand, but it runs the risk of exhausting the stack at run time.
After testing both versions of the program on examples to rule out simple bugs, proofs can be used to show once and for all that the programs are equivalent.</p>
<h2 id="proving-sum-equal"><a class="header" href="#proving-sum-equal">Proving <code>sum</code> Equal</a></h2>
<p>To prove that both versions of <code class="hljs">sum</code> are equal, begin by writing the theorem statement with a stub proof:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> NonTail.sum = Tail.sum := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">skip</span>
</code></pre>
<p>As expected, Lean describes an unsolved goal:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
â¢ NonTail.sum = Tail.sum
</code></pre>
<p>The <code class="hljs">rfl</code> tactic cannot be applied here, because <code class="hljs">NonTail.sum</code> and <code class="hljs">Tail.sum</code> are not definitionally equal.
Functions can be equal in more ways than just definitional equality, however.
It is also possible to prove that two functions are equal by proving that they produce equal outputs for the same input.
In other words, <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-70-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi><mo>=</mo><mi>g</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-541" style="width:2.905em;display:inline-block"><span style="display:inline-block;position:relative;width:2.341em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1002.34em,2.704em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-542"><span class="mi" id="MathJax-Span-543" style="font-family:MathJax_Math;font-style:italic">f<span style="display:inline-block;overflow:hidden;height:1px;width:0.042em"></span></span><span class="mo" id="MathJax-Span-544" style="font-family:MathJax_Main;padding-left:0.284em">=</span><span class="mi" id="MathJax-Span-545" style="font-family:MathJax_Math;font-style:italic;padding-left:0.284em">g<span style="display:inline-block;overflow:hidden;height:1px;width:0.002em"></span></span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.297em;border-left:0px solid;width:0px;height:1.252em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>=</mo><mi>g</mi></math></span></span> can be proved by proving that <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-71-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>f</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mi>g</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-546" style="width:6.252em;display:inline-block"><span style="display:inline-block;position:relative;width:5.042em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.494em,1004.96em,2.744em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-547"><span class="mi" id="MathJax-Span-548" style="font-family:MathJax_Math;font-style:italic">f<span style="display:inline-block;overflow:hidden;height:1px;width:0.042em"></span></span><span class="mo" id="MathJax-Span-549" style="font-family:MathJax_Main">(</span><span class="mi" id="MathJax-Span-550" style="font-family:MathJax_Math;font-style:italic">x</span><span class="mo" id="MathJax-Span-551" style="font-family:MathJax_Main">)</span><span class="mo" id="MathJax-Span-552" style="font-family:MathJax_Main;padding-left:0.284em">=</span><span class="mi" id="MathJax-Span-553" style="font-family:MathJax_Math;font-style:italic;padding-left:0.284em">g<span style="display:inline-block;overflow:hidden;height:1px;width:0.002em"></span></span><span class="mo" id="MathJax-Span-554" style="font-family:MathJax_Main">(</span><span class="mi" id="MathJax-Span-555" style="font-family:MathJax_Math;font-style:italic">x</span><span class="mo" id="MathJax-Span-556" style="font-family:MathJax_Main">)</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.348em;border-left:0px solid;width:0px;height:1.353em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></math></span></span> for all possible inputs <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-72-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-557" style="width:0.728em;display:inline-block"><span style="display:inline-block;position:relative;width:0.567em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.53em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-558"><span class="mi" id="MathJax-Span-559" style="font-family:MathJax_Math;font-style:italic">x</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span>.
This principle is called <em>function extensionality</em>.
Function extensionality is exactly the reason why <code class="hljs">NonTail.sum</code> equals <code class="hljs">Tail.sum</code>: they both sum lists of numbers.</p>
<p>In Lean's tactic language, function extensionality is invoked using <code class="hljs">funext</code>, followed by a name to be used for the arbitrary argument.
The arbitrary argument is added as an assumption to the context, and the goal changes to require a proof that the functions applied to this argument are equal:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> NonTail.sum = Tail.sum := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">funext</span> xs
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case h
xs : List Nat
â¢ NonTail.sum xs = Tail.sum xs
</code></pre>
<p>This goal can be proved by induction on the argument <code class="hljs">xs</code>.
Both <code class="hljs">sum</code> functions return <code class="hljs">0</code> when applied to the empty list, which serves as a base case.
Adding a number to the beginning of the input list causes both functions to add that number to the result, which serves as an induction step.
Invoking the <code class="hljs">induction</code> tactic results in two goals:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> NonTail.sum = Tail.sum := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">funext</span> xs
  <span class="hljs-keyword">induction</span> xs <span class="hljs-keyword">with</span>
  | nil =&gt; <span class="hljs-keyword">skip</span>
  | cons y ys ih =&gt; <span class="hljs-keyword">skip</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case h.nil
â¢ NonTail.sum [] = Tail.sum []
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case h.cons
y : Nat
ys : List Nat
ih : NonTail.sum ys = Tail.sum ys
â¢ NonTail.sum (y :: ys) = Tail.sum (y :: ys)
</code></pre>
<p>The base case for <code class="hljs">nil</code> can be solved using <code class="hljs">rfl</code>, because both functions return <code class="hljs">0</code> when passed the empty list:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> NonTail.sum = Tail.sum := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">funext</span> xs
  <span class="hljs-keyword">induction</span> xs <span class="hljs-keyword">with</span>
  | nil =&gt; <span class="hljs-keyword">rfl</span>
  | cons y ys ih =&gt; <span class="hljs-keyword">skip</span>
</code></pre>
<p>The first step in solving the induction step is to simplify the goal, asking <code class="hljs">simp</code> to unfold <code class="hljs">NonTail.sum</code> and <code class="hljs">Tail.sum</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> NonTail.sum = Tail.sum := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">funext</span> xs
  <span class="hljs-keyword">induction</span> xs <span class="hljs-keyword">with</span>
  | nil =&gt; <span class="hljs-keyword">rfl</span>
  | cons y ys ih =&gt;
    <span class="hljs-keyword">simp</span> [NonTail.sum, Tail.sum]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case h.cons
y : Nat
ys : List Nat
ih : NonTail.sum ys = Tail.sum ys
â¢ y + NonTail.sum ys = Tail.sumHelper 0 (y :: ys)
</code></pre>
<p>Unfolding <code class="hljs">Tail.sum</code> revealed that it immediately delegates to <code class="hljs">Tail.sumHelper</code>, which should also be simplified:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> NonTail.sum = Tail.sum := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">funext</span> xs
  <span class="hljs-keyword">induction</span> xs <span class="hljs-keyword">with</span>
  | nil =&gt; <span class="hljs-keyword">rfl</span>
  | cons y ys ih =&gt;
    <span class="hljs-keyword">simp</span> [NonTail.sum, Tail.sum, Tail.sumHelper]
</code></pre>
<p>In the resulting goal, <code class="hljs">sumHelper</code> has taken a step of computation and added <code class="hljs">y</code> to the accumulator:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case h.cons
y : Nat
ys : List Nat
ih : NonTail.sum ys = Tail.sum ys
â¢ y + NonTail.sum ys = Tail.sumHelper y ys
</code></pre>
<p>Rewriting with the induction hypothesis removes all mentions of <code class="hljs">NonTail.sum</code> from the goal:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> NonTail.sum = Tail.sum := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">funext</span> xs
  <span class="hljs-keyword">induction</span> xs <span class="hljs-keyword">with</span>
  | nil =&gt; <span class="hljs-keyword">rfl</span>
  | cons y ys ih =&gt;
    <span class="hljs-keyword">simp</span> [NonTail.sum, Tail.sum, Tail.sumHelper]
    <span class="hljs-keyword">rw</span> [ih]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case h.cons
y : Nat
ys : List Nat
ih : NonTail.sum ys = Tail.sum ys
â¢ y + Tail.sum ys = Tail.sumHelper y ys
</code></pre>
<p>This new goal states that adding some number to the sum of a list is the same as using that number as the initial accumulator in <code class="hljs">sumHelper</code>.
For the sake of clarity, this new goal can be proved as a separate theorem:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">d</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">a</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List Nat)</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span>
    n + Tail.sum xs = Tail.sumHelper n xs := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">skip</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
xs : List Nat
n : Nat
â¢ n + Tail.sum xs = Tail.sumHelper n xs
</code></pre>
<p>Once again, this is a proof by induction where the base case uses <code class="hljs">rfl</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">d</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">a</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List Nat)</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span>
    n + Tail.sum xs = Tail.sumHelper n xs := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> xs <span class="hljs-keyword">with</span>
  | nil =&gt; <span class="hljs-keyword">rfl</span>
  | cons y ys ih =&gt; <span class="hljs-keyword">skip</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case cons
n y : Nat
ys : List Nat
ih : n + Tail.sum ys = Tail.sumHelper n ys
â¢ n + Tail.sum (y :: ys) = Tail.sumHelper n (y :: ys)
</code></pre>
<p>Because this is an inductive step, the goal should be simplified until it matches the induction hypothesis <code class="hljs">ih</code>.
Simplifying, using the definitions of <code class="hljs">Tail.sum</code> and <code class="hljs">Tail.sumHelper</code>, results in the following:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">a</span><span class="hljs-title">d</span><span class="hljs-title">d</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">a</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List Nat)</span> <span class="hljs-params">(n : Nat)</span> <span class="hljs-symbol">:</span></span>
    n + Tail.sum xs = Tail.sumHelper n xs := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> xs <span class="hljs-keyword">with</span>
  | nil =&gt; <span class="hljs-keyword">rfl</span>
  | cons y ys ih =&gt;
    <span class="hljs-keyword">simp</span> [Tail.sum, Tail.sumHelper]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case cons
n y : Nat
ys : List Nat
ih : n + Tail.sum ys = Tail.sumHelper n ys
â¢ n + Tail.sumHelper y ys = Tail.sumHelper (y + n) ys
</code></pre>
<p>Ideally, the induction hypothesis could be used to replace <code class="hljs">Tail.sumHelper (y + n) ys</code>, but they don't match.
The induction hypothesis can be used for <code class="hljs">Tail.sumHelper n ys</code>, not <code class="hljs">Tail.sumHelper (y + n) ys</code>.
In other words, this proof is stuck.</p>
<h2 id="a-second-attempt"><a class="header" href="#a-second-attempt">A Second Attempt</a></h2>
<p>Rather than attempting to muddle through the proof, it's time to take a step back and think.
Why is it that the tail-recursive version of the function is equal to the non-tail-recursive version?
Fundamentally speaking, at each entry in the list, the accumulator grows by the same amount as would be added to the result of the recursion.
This insight can be used to write an elegant proof.
Crucially, the proof by induction must be set up such that the induction hypothesis can be applied to <em>any</em> accumulator value.</p>
<p>Discarding the prior attempt, the insight can be encoded as the following statement:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">_</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">a</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List Nat)</span> <span class="hljs-symbol">:</span></span>
    (n : Nat) â n + NonTail.sum xs = Tail.sumHelper n xs := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">skip</span>
</code></pre>
<p>In this statement, it's very important that <code class="hljs">n</code> is part of the type that's after the colon.
The resulting goal begins with <code class="hljs">â (n : Nat)</code>, which is short for "For all <code class="hljs">n</code>":</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
xs : List Nat
â¢ â (n : Nat), n + NonTail.sum xs = Tail.sumHelper n xs
</code></pre>
<p>Using the induction tactic results in goals that include this "for all" statement:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">_</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">a</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List Nat)</span> <span class="hljs-symbol">:</span></span>
    (n : Nat) â n + NonTail.sum xs = Tail.sumHelper n xs := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> xs <span class="hljs-keyword">with</span>
  | nil =&gt; <span class="hljs-keyword">skip</span>
  | cons y ys ih =&gt; <span class="hljs-keyword">skip</span>
</code></pre>
<p>In the <code class="hljs">nil</code> case, the goal is:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case nil
â¢ â (n : Nat), n + NonTail.sum [] = Tail.sumHelper n []
</code></pre>
<p>For the induction step for <code class="hljs">cons</code>, both the induction hypothesis and the specific goal contain the "for all <code class="hljs">n</code>":</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case cons
y : Nat
ys : List Nat
ih : â (n : Nat), n + NonTail.sum ys = Tail.sumHelper n ys
â¢ â (n : Nat), n + NonTail.sum (y :: ys) = Tail.sumHelper n (y :: ys)
</code></pre>
<p>In other words, the goal has become more challenging to prove, but the induction hypothesis is correspondingly more useful.</p>
<p>A mathematical proof for a statement that beings with "for all <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-73-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-560" style="width:0.728em;display:inline-block"><span style="display:inline-block;position:relative;width:0.567em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.53em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-561"><span class="mi" id="MathJax-Span-562" style="font-family:MathJax_Math;font-style:italic">x</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span>" should assume some arbitrary <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-74-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-563" style="width:0.728em;display:inline-block"><span style="display:inline-block;position:relative;width:0.567em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.53em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-564"><span class="mi" id="MathJax-Span-565" style="font-family:MathJax_Math;font-style:italic">x</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span>, and prove the statement.
"Arbitrary" means that no additional properties of <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-75-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-566" style="width:0.728em;display:inline-block"><span style="display:inline-block;position:relative;width:0.567em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.53em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-567"><span class="mi" id="MathJax-Span-568" style="font-family:MathJax_Math;font-style:italic">x</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span> are assumed, so the resulting statement will work for <em>any</em> <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-76-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-569" style="width:0.728em;display:inline-block"><span style="display:inline-block;position:relative;width:0.567em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.53em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-570"><span class="mi" id="MathJax-Span-571" style="font-family:MathJax_Math;font-style:italic">x</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span>.
In Lean, a "for all" statement is a dependent function: no matter which specific value it is applied to, it will return evidence of the proposition.
Similarly, the process of picking an arbitrary <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-77-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-572" style="width:0.728em;display:inline-block"><span style="display:inline-block;position:relative;width:0.567em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.53em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-573"><span class="mi" id="MathJax-Span-574" style="font-family:MathJax_Math;font-style:italic">x</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span> is the same as using <code class="hljs">fun x =&gt; ...</code>.
In the tactic language, this process of selecting an arbitrary <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-78-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-575" style="width:0.728em;display:inline-block"><span style="display:inline-block;position:relative;width:0.567em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.53em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-576"><span class="mi" id="MathJax-Span-577" style="font-family:MathJax_Math;font-style:italic">x</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span> is performed using the <code class="hljs">intro</code> tactic, which produces the function behind the scenes when the tactic script has completed.
The <code class="hljs">intro</code> tactic should be provided with the name to be used for this arbitrary value.</p>
<p>Using the <code class="hljs">intro</code> tactic in the <code class="hljs">nil</code> case removes the <code class="hljs">â (n : Nat),</code> from the goal, and adds an assumption <code class="hljs">n : Nat</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">_</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">a</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List Nat)</span> <span class="hljs-symbol">:</span></span>
    (n : Nat) â n + NonTail.sum xs = Tail.sumHelper n xs := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> xs <span class="hljs-keyword">with</span>
  | nil =&gt; <span class="hljs-keyword">intro</span> n
  | cons y ys ih =&gt; <span class="hljs-keyword">skip</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case nil
n : Nat
â¢ n + NonTail.sum [] = Tail.sumHelper n []
</code></pre>
<p>Both sides of this propositional equality are definitionally equal to <code class="hljs">n</code>, so <code class="hljs">rfl</code> suffices:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">_</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">a</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List Nat)</span> <span class="hljs-symbol">:</span></span>
    (n : Nat) â n + NonTail.sum xs = Tail.sumHelper n xs := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> xs <span class="hljs-keyword">with</span>
  | nil =&gt;
    <span class="hljs-keyword">intro</span> n
    <span class="hljs-keyword">rfl</span>
  | cons y ys ih =&gt; <span class="hljs-keyword">skip</span>
</code></pre>
<p>The <code class="hljs">cons</code> goal also contains a "for all":</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case cons
y : Nat
ys : List Nat
ih : â (n : Nat), n + NonTail.sum ys = Tail.sumHelper n ys
â¢ â (n : Nat), n + NonTail.sum (y :: ys) = Tail.sumHelper n (y :: ys)
</code></pre>
<p>This suggests the use of <code class="hljs">intro</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">_</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">a</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List Nat)</span> <span class="hljs-symbol">:</span></span>
    (n : Nat) â n + NonTail.sum xs = Tail.sumHelper n xs := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> xs <span class="hljs-keyword">with</span>
  | nil =&gt;
    <span class="hljs-keyword">intro</span> n
    <span class="hljs-keyword">rfl</span>
  | cons y ys ih =&gt;
    <span class="hljs-keyword">intro</span> n
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case cons
y : Nat
ys : List Nat
ih : â (n : Nat), n + NonTail.sum ys = Tail.sumHelper n ys
n : Nat
â¢ n + NonTail.sum (y :: ys) = Tail.sumHelper n (y :: ys)
</code></pre>
<p>The proof goal now contains both <code class="hljs">NonTail.sum</code> and <code class="hljs">Tail.sumHelper</code> applied to <code class="hljs">y :: ys</code>.
The simplifier can make the next step more clear:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">_</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">a</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List Nat)</span> <span class="hljs-symbol">:</span></span>
    (n : Nat) â n + NonTail.sum xs = Tail.sumHelper n xs := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> xs <span class="hljs-keyword">with</span>
  | nil =&gt;
    <span class="hljs-keyword">intro</span> n
    <span class="hljs-keyword">rfl</span>
  | cons y ys ih =&gt;
    <span class="hljs-keyword">intro</span> n
    <span class="hljs-keyword">simp</span> [NonTail.sum, Tail.sumHelper]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case cons
y : Nat
ys : List Nat
ih : â (n : Nat), n + NonTail.sum ys = Tail.sumHelper n ys
n : Nat
â¢ n + (y + NonTail.sum ys) = Tail.sumHelper (y + n) ys
</code></pre>
<p>This goal is very close to matching the induction hypothesis.
There are two ways in which it does not match:</p>
<ul>
<li>The left-hand side of the equation is <code class="hljs">n + (y + NonTail.sum ys)</code>, but the induction hypothesis needs the left-hand side to be a number added to <code class="hljs">NonTail.sum ys</code>.
In other words, this goal should be rewritten to <code class="hljs">(n + y) + NonTail.sum ys</code>, which is valid because addition of natural numbers is associative.</li>
<li>When the left side has been rewritten to <code class="hljs">(y + n) + NonTail.sum ys</code>, the accumulator argument on the right side should be <code class="hljs">n + y</code> rather than <code class="hljs">y + n</code> in order to match.
This rewrite is valid because addition is also commutative.</li>
</ul>
<p>The associativity and commutativity of addition have already been proved in Lean's standard library.
The proof of associativity is named <code class="hljs">Nat.add_assoc</code>, and its type is <code class="hljs">(n m k : Nat) â (n + m) + k = n + (m + k)</code>, while the proof of commutativity is called <code class="hljs">Nat.add_comm</code> and has type <code class="hljs">(n m : Nat) â n + m = m + n</code>.
Normally, the <code class="hljs">rw</code> tactic is provided with an expression whose type is an equality.
However, if the argument is instead a dependent function whose return type is an equality, it attempts to find arguments to the function that would allow the equality to match something in the goal.
There is only one opportunity to apply associativity, though the direction of the rewrite must be reversed because the right side of the equality in <code class="hljs">Nat.add_assoc</code> is the one that matches the proof goal:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">_</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">a</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List Nat)</span> <span class="hljs-symbol">:</span></span>
    (n : Nat) â n + NonTail.sum xs = Tail.sumHelper n xs := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> xs <span class="hljs-keyword">with</span>
  | nil =&gt;
    <span class="hljs-keyword">intro</span> n
    <span class="hljs-keyword">rfl</span>
  | cons y ys ih =&gt;
    <span class="hljs-keyword">intro</span> n
    <span class="hljs-keyword">simp</span> [NonTail.sum, Tail.sumHelper]
    <span class="hljs-keyword">rw</span> [âNat.add_assoc]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case cons
y : Nat
ys : List Nat
ih : â (n : Nat), n + NonTail.sum ys = Tail.sumHelper n ys
n : Nat
â¢ n + y + NonTail.sum ys = Tail.sumHelper (y + n) ys
</code></pre>
<p>Rewriting directly with <code class="hljs">Nat.add_comm</code>, however, leads to the wrong result.
The <code class="hljs">rw</code> tactic guesses the wrong location for the rewrite, leading to an unintended goal:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">_</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">a</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List Nat)</span> <span class="hljs-symbol">:</span></span>
    (n : Nat) â n + NonTail.sum xs = Tail.sumHelper n xs := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> xs <span class="hljs-keyword">with</span>
  | nil =&gt;
    <span class="hljs-keyword">intro</span> n
    <span class="hljs-keyword">rfl</span>
  | cons y ys ih =&gt;
    <span class="hljs-keyword">intro</span> n
    <span class="hljs-keyword">simp</span> [NonTail.sum, Tail.sumHelper]
    <span class="hljs-keyword">rw</span> [âNat.add_assoc]
    <span class="hljs-keyword">rw</span> [Nat.add_comm]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case cons
y : Nat
ys : List Nat
ih : â (n : Nat), n + NonTail.sum ys = Tail.sumHelper n ys
n : Nat
â¢ NonTail.sum ys + (n + y) = Tail.sumHelper (y + n) ys
</code></pre>
<p>This can be fixed by explicitly providing <code class="hljs">y</code> and <code class="hljs">n</code> as arguments to <code class="hljs">Nat.add_comm</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">_</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">a</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List Nat)</span> <span class="hljs-symbol">:</span></span>
    (n : Nat) â n + NonTail.sum xs = Tail.sumHelper n xs := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> xs <span class="hljs-keyword">with</span>
  | nil =&gt;
    <span class="hljs-keyword">intro</span> n
    <span class="hljs-keyword">rfl</span>
  | cons y ys ih =&gt;
    <span class="hljs-keyword">intro</span> n
    <span class="hljs-keyword">simp</span> [NonTail.sum, Tail.sumHelper]
    <span class="hljs-keyword">rw</span> [âNat.add_assoc]
    <span class="hljs-keyword">rw</span> [Nat.add_comm y n]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case cons
y : Nat
ys : List Nat
ih : â (n : Nat), n + NonTail.sum ys = Tail.sumHelper n ys
n : Nat
â¢ n + y + NonTail.sum ys = Tail.sumHelper (n + y) ys
</code></pre>
<p>The goal now matches the induction hypothesis.
In particular, the induction hypothesis's type is a dependent function type.
Applying <code class="hljs">ih</code> to <code class="hljs">n + y</code> results in exactly the desired type.
The <code class="hljs">exact</code> tactic completes a proof goal if its argument has exactly the desired type:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">_</span><span class="hljs-title">h</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">a</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-params">(xs : List Nat)</span> <span class="hljs-symbol">:</span></span>
    (n : Nat) â n + NonTail.sum xs = Tail.sumHelper n xs := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> xs <span class="hljs-keyword">with</span>
  | nil =&gt; <span class="hljs-keyword">intro</span> n; <span class="hljs-keyword">rfl</span>
  | cons y ys ih =&gt;
    <span class="hljs-keyword">intro</span> n
    <span class="hljs-keyword">simp</span> [NonTail.sum, Tail.sumHelper]
    <span class="hljs-keyword">rw</span> [âNat.add_assoc]
    <span class="hljs-keyword">rw</span> [Nat.add_comm y n]
    <span class="hljs-keyword">exact</span> ih (n + y)
</code></pre>
<p>The actual proof requires only a little additional work to get the goal to match the helper's type.
The first step is still to invoke function extensionality:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> NonTail.sum = Tail.sum := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">funext</span> xs
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case h
xs : List Nat
â¢ NonTail.sum xs = Tail.sum xs
</code></pre>
<p>The next step is unfold <code class="hljs">Tail.sum</code>, exposing <code class="hljs">Tail.sumHelper</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> NonTail.sum = Tail.sum := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">funext</span> xs
  <span class="hljs-keyword">simp</span> [Tail.sum]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case h
xs : List Nat
â¢ NonTail.sum xs = Tail.sumHelper 0 xs
</code></pre>
<p>Having done this, the types almost match.
However, the helper has an additional addend on the left side.
In other words, the proof goal is <code class="hljs">NonTail.sum xs = Tail.sumHelper 0 xs</code>, but applying <code class="hljs">non_tail_sum_eq_helper_accum</code> to <code class="hljs">xs</code> and <code class="hljs">0</code> yields the type <code class="hljs">0 + NonTail.sum xs = Tail.sumHelper 0 xs</code>.
Another standard library proof, <code class="hljs">Nat.zero_add</code>, has type <code class="hljs">(n : Nat) â 0 + n = n</code>.
Applying this function to <code class="hljs">NonTail.sum xs</code> results in an expression with type <code class="hljs">0 + NonTail.sum xs = NonTail.sum xs</code>, so rewriting from right to left results in the desired goal:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> NonTail.sum = Tail.sum := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">funext</span> xs
  <span class="hljs-keyword">simp</span> [Tail.sum]
  <span class="hljs-keyword">rw</span> [âNat.zero_add (NonTail.sum xs)]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case h
xs : List Nat
â¢ 0 + NonTail.sum xs = Tail.sumHelper 0 xs
</code></pre>
<p>Finally, the helper can be used to complete the proof:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">m</span> <span class="hljs-symbol">:</span></span> NonTail.sum = Tail.sum := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">funext</span> xs
  <span class="hljs-keyword">simp</span> [Tail.sum]
  <span class="hljs-keyword">rw</span> [âNat.zero_add (NonTail.sum xs)]
  <span class="hljs-keyword">exact</span> non_tail_sum_eq_helper_accum xs <span class="hljs-number">0</span>
</code></pre>
<p>This proof demonstrates a general pattern that can be used when proving that an accumulator-passing tail-recursive function is equal to the non-tail-recursive version.
The first step is to discover the relationship between the starting accumulator argument and the final result.
For instance, beginning <code class="hljs">Tail.sumHelper</code> with an accumulator of <code class="hljs">n</code> results in the final sum being added to <code class="hljs">n</code>, and beginning <code class="hljs">Tail.reverseHelper</code> with an accumulator of <code class="hljs">ys</code> results in the final reversed list being prepended to <code class="hljs">ys</code>.
The second step is to write down this relationship as a theorem statement and prove it by induction.
While the accumulator is always initialized with some neutral value in practice, such as <code class="hljs">0</code> or <code class="hljs">[]</code>, this more general statement that allows the starting accumulator to be any value is what's needed to get a strong enough induction hypothesis.
Finally, using this helper theorem with the actual initial accumulator value results in the desired proof.
For example, in <code class="hljs">non_tail_sum_eq_tail_sum</code>, the accumulator is specified to be <code class="hljs">0</code>.
This may require rewriting the goal to make the neutral initial accumulator values occur in the right place.</p>
<h2 id="exercise-2"><a class="header" href="#exercise-2">Exercise</a></h2>
<h3 id="warming-up"><a class="header" href="#warming-up">Warming Up</a></h3>
<p>Write your own proofs for <code class="hljs">Nat.zero_add</code>, <code class="hljs">Nat.add_assoc</code>, and <code class="hljs">Nat.add_comm</code> using the <code class="hljs">induction</code> tactic.</p>
<h3 id="more-accumulator-proofs"><a class="header" href="#more-accumulator-proofs">More Accumulator Proofs</a></h3>
<h4 id="reversing-lists-1"><a class="header" href="#reversing-lists-1">Reversing Lists</a></h4>
<p>Adapt the proof for <code class="hljs">sum</code> into a proof for <code class="hljs">NonTail.reverse</code> and <code class="hljs">Tail.reverse</code>.
The first step is to think about the relationship between the accumulator value being passed to <code class="hljs">Tail.reverseHelper</code> and the non-tail-recursive reverse.
Just as adding a number to the accumulator in <code class="hljs">Tail.sumHelper</code> is the same as adding it to the overall sum, using <code class="hljs">List.cons</code> to add a new entry to the accumulator in <code class="hljs">Tail.reverseHelper</code> is equivalent to some change to the overall result.
Try three or four different accumulator values with pencil and paper until the relationship becomes clear.
Use this relationship to prove a suitable helper theorem.
Then, write down the overall theorem.
Because <code class="hljs">NonTail.reverse</code> and <code class="hljs">Tail.reverse</code> are polymorphic, stating their equality requires the use of <code class="hljs">@</code> to stop Lean from trying to figure out which type to use for <code class="hljs">Î±</code>.
Once <code class="hljs">Î±</code> is treated as an ordinary argument, <code class="hljs">funext</code> should be invoked with both <code class="hljs">Î±</code> and <code class="hljs">xs</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">l</span><span class="hljs-title">_</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">s</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> @NonTail.reverse = @Tail.reverse := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">funext</span> Î± xs
</code></pre>
<p>This results in a suitable goal:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case h.h
Î± : Type u_1
xs : List Î±
â¢ NonTail.reverse xs = Tail.reverse xs
</code></pre>
<h4 id="factorial"><a class="header" href="#factorial">Factorial</a></h4>
<p>Prove that <code class="hljs">NonTail.factorial</code> from the exercises in the previous section is equal to your tail-recursive solution by finding the relationship between the accumulator and the result and proving a suitable helper theorem.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="arrays-and-termination"><a class="header" href="#arrays-and-termination">Arrays and Termination</a></h1>
<p>To write efficient code, it is important to select appropriate data structures.
Linked lists have their place: in some applications, the ability to share the tails of lists is very important.
However, most use cases for a variable-length sequential collection of data are better served by arrays, which have both less memory overhead and better locality.</p>
<p>Arrays, however, have two drawbacks relative to lists:</p>
<ol>
<li>Arrays are accessed through indexing, rather than by pattern matching, which imposes <a href="https://leanprover.github.io/functional_programming_in_lean/props-proofs-indexing.html">proof obligations</a> in order to maintain safety.</li>
<li>A loop that processes an entire array from left to right is a tail-recursive function, but it does not have an argument that decreases on each call.</li>
</ol>
<p>Making effective use of arrays requires knowing how to prove to Lean that an array index is in bounds, and how to prove that an array index that approaches the size of the array also causes the program to terminate.
Both of these are expressed using an inequality proposition, rather than propositional equality.</p>
<h2 id="inequality"><a class="header" href="#inequality">Inequality</a></h2>
<p>Because different types have different notions of ordering, inequality is governed by two type classes, called <code class="hljs">LE</code> and <code class="hljs">LT</code>.
The table in the section on <a href="https://leanprover.github.io/functional_programming_in_lean/type-classes/standard-classes.html#equality-and-ordering">standard type classes</a> describes how these classes relate to the syntax:</p>
<table><thead><tr><th>Expression</th><th>Desugaring</th><th>Class Name</th></tr></thead><tbody>
<tr><td><code class="hljs">x &lt; y</code></td><td><code class="hljs">LT.lt x y</code></td><td><code class="hljs">LT</code></td></tr>
<tr><td><code class="hljs">x â¤ y</code></td><td><code class="hljs">LE.le x y</code></td><td><code class="hljs">LE</code></td></tr>
<tr><td><code class="hljs">x &gt; y</code></td><td><code class="hljs">LT.lt y x</code></td><td><code class="hljs">LT</code></td></tr>
<tr><td><code class="hljs">x â¥ y</code></td><td><code class="hljs">LE.le y x</code></td><td><code class="hljs">LE</code></td></tr>
</tbody></table>
<p>In other words, a type may customize the meaning of the <code class="hljs">&lt;</code> and <code class="hljs">â¤</code> operators, while <code class="hljs">&gt;</code> and <code class="hljs">â¥</code> derive their meanings from <code class="hljs">&lt;</code> and <code class="hljs">â¤</code>.
The classes <code class="hljs">LT</code> and <code class="hljs">LE</code> have methods that return propositions rather than <code class="hljs">Bool</code>s:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">L</span><span class="hljs-title">E</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span> u)</span></span> <span class="hljs-keyword">where</span>
  le : Î± â Î± â <span class="hljs-built_in">Prop</span>

<span class="hljs-theorem"><span class="hljs-keyword">class</span> <span class="hljs-title">L</span><span class="hljs-title">T</span> <span class="hljs-params">(Î± : <span class="hljs-built_in">Type</span> u)</span></span> <span class="hljs-keyword">where</span>
  lt : Î± â Î± â <span class="hljs-built_in">Prop</span>
</code></pre>
<p>The instance of <code class="hljs">LE</code> for <code class="hljs">Nat</code> delegates to <code class="hljs">Nat.le</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> LE Nat <span class="hljs-keyword">where</span>
  le := Nat.le
</code></pre>
<p>Defining <code class="hljs">Nat.le</code> requires a feature of Lean that has not yet been presented: it is an inductively-defined relation.</p>
<h3 id="inductively-defined-propositions-predicates-and-relations"><a class="header" href="#inductively-defined-propositions-predicates-and-relations">Inductively-Defined Propositions, Predicates, and Relations</a></h3>
<p><code class="hljs">Nat.le</code> is an <em>inductively-defined relation</em>.
Just as <code class="hljs">inductive</code> can be used to create new datatypes, it can also be used to create new propositions.
When a proposition takes an argument, it is referred to as a <em>predicate</em> that may be true for some, but not all, potential arguments.
Propositions that take multiple arguments are called <em>relations</em>.</p>
<p>Each constructor of an inductively defined proposition is a way to prove it.
In other words, the declaration of the proposition describes the different forms of evidence that it is true.
A proposition with no arguments that has a single constructor can be quite easy to prove:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> EasyToProve : <span class="hljs-built_in">Prop</span> <span class="hljs-keyword">where</span>
  | heresTheProof : EasyToProve
</code></pre>
<p>The proof consists of using its constructor:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">f</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">r</span><span class="hljs-title">l</span><span class="hljs-title">y</span><span class="hljs-title">E</span><span class="hljs-title">a</span><span class="hljs-title">s</span><span class="hljs-title">y</span> <span class="hljs-symbol">:</span></span> EasyToProve := <span class="hljs-keyword">by</span>
  constructor
</code></pre>
<p>In fact, the proposition <code class="hljs">True</code>, which should always be easy to prove, is defined just like <code class="hljs">EasyToProve</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> True : <span class="hljs-built_in">Prop</span> <span class="hljs-keyword">where</span>
  | intro : True
</code></pre>
<p>Inductively-defined propositions that don't take arguments are not nearly as interesting as inductively-defined datatypes.
This is because data is interesting in its own rightâthe natural number <code class="hljs">3</code> is different from the number <code class="hljs">35</code>, and someone who has ordered 3 pizzas will be upset if 35 arrive at their door 30 minutes later.
The constructors of a proposition describe ways in which the proposition can be true, but once a proposition has been proved, there is no need to know <em>which</em> underlying constructors were used.
This is why most interesting inductively-defined types in the <code class="hljs">Prop</code> universe take arguments.</p>
<p>The inductively-defined predicate <code class="hljs">IsThree</code> states that its argument is three:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> IsThree : Nat â <span class="hljs-built_in">Prop</span> <span class="hljs-keyword">where</span>
  | isThree : IsThree <span class="hljs-number">3</span>
</code></pre>
<p>The mechanism used here is just like <a href="https://leanprover.github.io/functional_programming_in_lean/dependent-types/typed-queries.html#column-pointers">indexed families such as <code class="hljs">HasCol</code></a>, except the resulting type is a proposition that can be proved rather than data that can be used.</p>
<p>Using this predicate, it is possible to prove that three is indeed three:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> IsThree <span class="hljs-number">3</span> := <span class="hljs-keyword">by</span>
  constructor
</code></pre>
<p>Similarly, <code class="hljs">IsFive</code> is a predicate that states that its argument is <code class="hljs">5</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> IsFive : Nat â <span class="hljs-built_in">Prop</span> <span class="hljs-keyword">where</span>
  | isFive : IsFive <span class="hljs-number">5</span>
</code></pre>
<p>If a number is three, then the result of adding two to it should be five.
This can be expressed as a theorem statement:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">_</span><span class="hljs-title">tw</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> IsThree n â IsFive (n + <span class="hljs-number">2</span>) := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">skip</span>
</code></pre>
<p>The resulting goal has a function type:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
n : Nat
â¢ IsThree n â IsFive (n + 2)
</code></pre>
<p>Thus, the <code class="hljs">intro</code> tactic can be used to convert the argument into an assumption:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">_</span><span class="hljs-title">tw</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> IsThree n â IsFive (n + <span class="hljs-number">2</span>) := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">intro</span> three
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
n : Nat
three : IsThree n
â¢ IsFive (n + 2)
</code></pre>
<p>Given the assumption that <code class="hljs">n</code> is three, it should be possible to use the constructor of <code class="hljs">IsFive</code> to complete the proof:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">_</span><span class="hljs-title">tw</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> IsThree n â IsFive (n + <span class="hljs-number">2</span>) := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">intro</span> three
  <span class="hljs-keyword">constructor</span>
</code></pre>
<p>However, this results in an error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">tactic 'constructor' failed, no applicable constructor found
n : Nat
three : IsThree n
â¢ IsFive (n + 2)
</code></pre>
<p>This error occurs because <code class="hljs">n + 2</code> is not definitionally equal to <code class="hljs">5</code>.
In an ordinary function definition, dependent pattern matching on the assumption <code class="hljs">three</code> could be used to refine <code class="hljs">n</code> to <code class="hljs">3</code>.
The tactic equivalent of dependent pattern matching is <code class="hljs">cases</code>, which has a syntax similar to that of <code class="hljs">induction</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">_</span><span class="hljs-title">tw</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> IsThree n â IsFive (n + <span class="hljs-number">2</span>) := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">intro</span> three
  <span class="hljs-keyword">cases</span> three <span class="hljs-keyword">with</span>
  | isThree =&gt; <span class="hljs-keyword">skip</span>
</code></pre>
<p>In the remaining case, <code class="hljs">n</code> has been refined to <code class="hljs">3</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case isThree
â¢ IsFive (3 + 2)
</code></pre>
<p>Because <code class="hljs">3 + 2</code> is definitionally equal to <code class="hljs">5</code>, the constructor is now applicable:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">u</span><span class="hljs-title">s</span><span class="hljs-title">_</span><span class="hljs-title">tw</span><span class="hljs-title">o</span><span class="hljs-title">_</span><span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">v</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> IsThree n â IsFive (n + <span class="hljs-number">2</span>) := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">intro</span> three
  <span class="hljs-keyword">cases</span> three <span class="hljs-keyword">with</span>
  | isThree =&gt; <span class="hljs-keyword">constructor</span>
</code></pre>
<p>The standard false proposition <code class="hljs">False</code> has no constructors, making it impossible to provide direct evidence for.
The only way to provide evidence for <code class="hljs">False</code> is if an assumption is itself impossible, similarly to how <code class="hljs">nomatch</code> can be used to mark code that the type system can see is unreachable.
As described in <a href="https://leanprover.github.io/functional_programming_in_lean/props-proofs-indexing.html#connectives">the initial Interlude on proofs</a>, the negation <code class="hljs">Not A</code> is short for <code class="hljs">A â False</code>.
<code class="hljs">Not A</code> can also be written <code class="hljs">Â¬A</code>.</p>
<p>It is not the case that four is three:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">_</span><span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Â¬ IsThree <span class="hljs-number">4</span> := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">skip</span>
</code></pre>
<p>The initial proof goal contains <code class="hljs">Not</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
â¢ Â¬IsThree 4
</code></pre>
<p>The fact that it's actually a function type can be exposed using <code class="hljs">simp</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">_</span><span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Â¬ IsThree <span class="hljs-number">4</span> := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">simp</span> [Not]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
â¢ IsThree 4 â False
</code></pre>
<p>Because the goal is a function type, <code class="hljs">intro</code> can be used to convert the argument into an assumption.
There is no need to keep <code class="hljs">simp</code>, as <code class="hljs">intro</code> can unfold the definition of <code class="hljs">Not</code> itself:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">_</span><span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Â¬ IsThree <span class="hljs-number">4</span> := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">intro</span> h
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
h : IsThree 4
â¢ False
</code></pre>
<p>In this proof, the <code class="hljs">cases</code> tactic solves the goal immediately:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">_</span><span class="hljs-title">n</span><span class="hljs-title">o</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">t</span><span class="hljs-title">h</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> Â¬ IsThree <span class="hljs-number">4</span> := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">intro</span> h
  <span class="hljs-keyword">cases</span> h
</code></pre>
<p>Just as a pattern match on a <code class="hljs">Vect String 2</code> doesn't need to include a case for <code class="hljs">Vect.nil</code>, a proof by cases over <code class="hljs">IsThree 4</code> doesn't need to include a case for <code class="hljs">isThree</code>.</p>
<h3 id="inequality-of-natural-numbers"><a class="header" href="#inequality-of-natural-numbers">Inequality of Natural Numbers</a></h3>
<p>The definition of <code class="hljs">Nat.le</code> has a parameter and an index:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">inductive</span> Nat.le (n : Nat) : Nat â <span class="hljs-built_in">Prop</span>
  | refl : Nat.le n n
  | step : Nat.le n m â Nat.le n (m + <span class="hljs-number">1</span>)
</code></pre>
<p>The parameter <code class="hljs">n</code> is the number that should be smaller, while the index is the number that should be greater than or equal to <code class="hljs">n</code>.
The <code class="hljs">refl</code> constructor is used when both numbers are equal, while the <code class="hljs">step</code> constructor is used when the index is greater than <code class="hljs">n</code>.</p>
<p>From the perspective of evidence, a proof that <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-79-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>&amp;#x2264;</mo><mi>k</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-578" style="width:3.067em;display:inline-block"><span style="display:inline-block;position:relative;width:2.462em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1002.46em,2.623em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-579"><span class="mi" id="MathJax-Span-580" style="font-family:MathJax_Math;font-style:italic">n</span><span class="mo" id="MathJax-Span-581" style="font-family:MathJax_Main;padding-left:0.284em">â¤</span><span class="mi" id="MathJax-Span-582" style="font-family:MathJax_Math;font-style:italic;padding-left:0.284em">k</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.198em;border-left:0px solid;width:0px;height:1.153em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>â¤</mo><mi>k</mi></math></span></span> consists of finding some number <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-80-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>d</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-583" style="width:0.647em;display:inline-block"><span style="display:inline-block;position:relative;width:0.526em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.53em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-584"><span class="mi" id="MathJax-Span-585" style="font-family:MathJax_Math;font-style:italic">d<span style="display:inline-block;overflow:hidden;height:1px;width:0.002em"></span></span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>d</mi></math></span></span> such that <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-81-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>+</mo><mi>d</mi><mo>=</mo><mi>m</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-586" style="width:5.728em;display:inline-block"><span style="display:inline-block;position:relative;width:4.599em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1004.56em,2.583em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-587"><span class="mi" id="MathJax-Span-588" style="font-family:MathJax_Math;font-style:italic">n</span><span class="mo" id="MathJax-Span-589" style="font-family:MathJax_Main;padding-left:0.244em">+</span><span class="mi" id="MathJax-Span-590" style="font-family:MathJax_Math;font-style:italic;padding-left:0.244em">d<span style="display:inline-block;overflow:hidden;height:1px;width:0.002em"></span></span><span class="mo" id="MathJax-Span-591" style="font-family:MathJax_Main;padding-left:0.284em">=</span><span class="mi" id="MathJax-Span-592" style="font-family:MathJax_Math;font-style:italic;padding-left:0.284em">m</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.148em;border-left:0px solid;width:0px;height:1.052em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>+</mo><mi>d</mi><mo>=</mo><mi>m</mi></math></span></span>.
In Lean, the proof then consists of a <code class="hljs">Nat.le.refl</code> constructor wrapped by <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-82-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>d</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-593" style="width:0.647em;display:inline-block"><span style="display:inline-block;position:relative;width:0.526em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.53em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-594"><span class="mi" id="MathJax-Span-595" style="font-family:MathJax_Math;font-style:italic">d<span style="display:inline-block;overflow:hidden;height:1px;width:0.002em"></span></span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>d</mi></math></span></span> instances of <code class="hljs">Nat.le.step</code>.
Each <code class="hljs">step</code> constructor adds one to its index argument, so <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-83-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>d</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-596" style="width:0.647em;display:inline-block"><span style="display:inline-block;position:relative;width:0.526em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.53em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-597"><span class="mi" id="MathJax-Span-598" style="font-family:MathJax_Math;font-style:italic">d<span style="display:inline-block;overflow:hidden;height:1px;width:0.002em"></span></span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>d</mi></math></span></span> <code class="hljs">step</code> constructors adds <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-84-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>d</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-599" style="width:0.647em;display:inline-block"><span style="display:inline-block;position:relative;width:0.526em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.53em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-600"><span class="mi" id="MathJax-Span-601" style="font-family:MathJax_Math;font-style:italic">d<span style="display:inline-block;overflow:hidden;height:1px;width:0.002em"></span></span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>d</mi></math></span></span> to the larger number.
For example, evidence that four is less than or equal to seven consists of three <code class="hljs">step</code>s around a <code class="hljs">refl</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> <span class="hljs-number">4</span> â¤ <span class="hljs-number">7</span> :=
  <span class="hljs-keyword">open</span> Nat.le <span class="hljs-keyword">in</span>
  step (step (step refl))
</code></pre>
<p>The strict less-than relation is defined by adding one to the number on the left:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span>.<span class="hljs-title">l</span><span class="hljs-title">t</span> <span class="hljs-params">(n m : Nat)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> :=
  Nat.le (n + <span class="hljs-number">1</span>) m

<span class="hljs-theorem"><span class="hljs-keyword">instance</span> <span class="hljs-symbol">:</span></span> LT Nat <span class="hljs-keyword">where</span>
  lt := Nat.lt
</code></pre>
<p>Evidence that four is strictly less than seven consists of two <code class="hljs">step</code>'s around a <code class="hljs">refl</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">f</span><span class="hljs-title">o</span><span class="hljs-title">u</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">v</span><span class="hljs-title">e</span><span class="hljs-title">n</span> <span class="hljs-symbol">:</span></span> <span class="hljs-number">4</span> &lt; <span class="hljs-number">7</span> :=
  <span class="hljs-keyword">open</span> Nat.le <span class="hljs-keyword">in</span>
  step (step refl)
</code></pre>
<p>This is because <code class="hljs">4 &lt; 7</code> is equivalent to <code class="hljs">5 â¤ 7</code>.</p>
<h2 id="proving-termination"><a class="header" href="#proving-termination">Proving Termination</a></h2>
<p>The function <code class="hljs">Array.map</code> transforms an array with a function, returning a new array that contains the result of applying the function to each element of the input array.
Writing it as a tail-recursive function follows the usual pattern of delegating to a function that passes the output array in an accumulator.
The accumulator is initialized with an empty array.
The accumulator-passing helper function also takes an argument that tracks the current index into the array, which starts at <code class="hljs">0</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">A</span><span class="hljs-title">r</span><span class="hljs-title">r</span><span class="hljs-title">a</span><span class="hljs-title">y</span>.<span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">p</span> <span class="hljs-params">(f : Î± â Î²)</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-symbol">:</span></span> Array Î² :=
  arrayMapHelper f arr Array.empty <span class="hljs-number">0</span>
</code></pre>
<p>The helper should, at each iteration, check whether the index is still in bounds.
If so, it should loop again with the transformed element added to the end of the accumulator and the index incremented by <code class="hljs">1</code>.
If not, then it should terminate and return the accumulator.
An initial implementation of this code fails because Lean is unable to prove that the array index is valid:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">r</span><span class="hljs-title">r</span><span class="hljs-title">a</span><span class="hljs-title">y</span><span class="hljs-title">M</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">H</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(f : Î± â Î²)</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-params">(soFar : Array Î²)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span> Array Î² :=
  <span class="hljs-keyword">if</span> i &lt; arr.size <span class="hljs-keyword">then</span>
    arrayMapHelper f arr (soFar.push (f arr[i])) (i + <span class="hljs-number">1</span>)
  <span class="hljs-keyword">else</span> soFar
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to prove index is valid, possible solutions:
  - Use `have`-expressions to prove the index is valid
  - Use `a[i]!` notation instead, runtime check is perfomed, and 'Panic' error message is produced if index is not valid
  - Use `a[i]?` notation instead, result is an `Option` type
  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid
Î± : Type ?u.1704
Î² : Type ?u.1707
f : Î± â Î²
arr : Array Î±
soFar : Array Î²
i : Nat
â¢ i &lt; Array.size arr
</code></pre>
<p>However, the conditional expression already checks the precise condition that the array index's validity demands (namely, <code class="hljs">i &lt; arr.size</code>).
Adding a name to the <code class="hljs">if</code> resolves the issue, because it adds an assumption that the array indexing tactic can use:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">r</span><span class="hljs-title">r</span><span class="hljs-title">a</span><span class="hljs-title">y</span><span class="hljs-title">M</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">H</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(f : Î± â Î²)</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-params">(soFar : Array Î²)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span> Array Î² :=
  <span class="hljs-keyword">if</span> inBounds : i &lt; arr.size <span class="hljs-keyword">then</span>
    arrayMapHelper f arr (soFar.push (f arr[i])) (i + <span class="hljs-number">1</span>)
  <span class="hljs-keyword">else</span> soFar
</code></pre>
<p>Lean does not, however, accept the modified program, because the recursive call is not made on an argument to one of the input constructors.
In fact, both the accumulator and the index grow, rather than shrinking:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">fail to show termination for
  arrayMapHelper
with errors
argument #6 was not used for structural recursion
  failed to eliminate recursive application
    arrayMapHelper fâ arr (Array.push soFar (fâ arr[i])) (i + 1)

structural recursion cannot be used

failed to prove termination, use `termination_by` to specify a well-founded relation
</code></pre>
<p>Nevertheless, this function terminates, so simply marking it <code class="hljs">partial</code> would be unfortunate.</p>
<p>Why does <code class="hljs">arrayMapHelper</code> terminate?
Each iteration checks whether the index <code class="hljs">i</code> is still in bounds for the array <code class="hljs">arr</code>.
If so, <code class="hljs">i</code> is incremented and the loop repeats.
If not, the program terminates.
Because <code class="hljs">arr.size</code> is a finite number, <code class="hljs">i</code> can be incremented only a finite number of times.
Even though no argument to the function decreases on each call, <code class="hljs">arr.size - i</code> decreases toward zero.</p>
<p>Lean can be instructed to use another expression for termination by providing a <code class="hljs">termination_by</code> clause at the end of a definition.
The <code class="hljs">termination_by</code> clause has two components: names for the function's arguments and an expression using those names that should decrease on each call.
For <code class="hljs">arrayMapHelper</code>, the final definition looks like this:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span><span class="hljs-title">r</span><span class="hljs-title">r</span><span class="hljs-title">a</span><span class="hljs-title">y</span><span class="hljs-title">M</span><span class="hljs-title">a</span><span class="hljs-title">p</span><span class="hljs-title">H</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(f : Î± â Î²)</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-params">(soFar : Array Î²)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span> Array Î² :=
  <span class="hljs-keyword">if</span> inBounds : i &lt; arr.size <span class="hljs-keyword">then</span>
    arrayMapHelper f arr (soFar.push (f arr[i])) (i + <span class="hljs-number">1</span>)
  <span class="hljs-keyword">else</span> soFar
<span class="hljs-keyword">termination_by</span> arrayMapHelper _ arr _ i _ =&gt; arr.size - i
</code></pre>
<p>A similar termination proof can be used to write <code class="hljs">Array.find</code>, a function that finds the first element in an array that satisfies a Boolean function and returns both the element and its index:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">A</span><span class="hljs-title">r</span><span class="hljs-title">r</span><span class="hljs-title">a</span><span class="hljs-title">y</span>.<span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-params">(p : Î± â Bool)</span> <span class="hljs-symbol">:</span></span> Option (Nat Ã Î±) :=
  findHelper arr p <span class="hljs-number">0</span>
</code></pre>
<p>Once again, the helper function terminates because <code class="hljs">arr.size - i</code> decreases as <code class="hljs">i</code> increases:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">H</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-params">(p : Î± â Bool)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span> Option (Nat Ã Î±) :=
  <span class="hljs-keyword">if</span> h : i &lt; arr.size <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">let</span> x := arr[i]
    <span class="hljs-keyword">if</span> p x <span class="hljs-keyword">then</span>
      some (i, x)
    <span class="hljs-keyword">else</span> findHelper arr p (i + <span class="hljs-number">1</span>)
  <span class="hljs-keyword">else</span> none
<span class="hljs-keyword">termination_by</span> findHelper arr p i =&gt; arr.size - i
</code></pre>
<p>Not all termination arguments are as quite as simple as this one.
However, the basic structure of identifying some expression based on the function's arguments that will decrease in each call occurs in all termination proofs.
Sometimes, creativity can be required in order to figure out just why a function terminates, and sometimes Lean requires additional proofs in order to accept the termination argument.</p>
<h2 id="exercises-24"><a class="header" href="#exercises-24">Exercises</a></h2>
<ul>
<li>Implement a <code class="hljs">ForM (Array Î±)</code> instance on arrays using a tail-recursive accumulator-passing function and a <code class="hljs">termination_by</code> clause.</li>
<li>Implement a function to reverse arrays using a tail-recursive accumulator-passing function that <em>doesn't</em> need a <code class="hljs">termination_by</code> clause.</li>
<li>Reimplement <code class="hljs">Array.map</code>, <code class="hljs">Array.find</code>, and the <code class="hljs">ForM</code> instance using <code class="hljs">for ... in ...</code> loops in the identity monad and compare the resulting code.</li>
<li>Reimplement array reversal using a <code class="hljs">for ... in ...</code> loop in the identity monad. Compare it to the tail-recursive function.</li>
</ul>
<div style="break-before:page;page-break-before:always"></div><h1 id="more-inequalities"><a class="header" href="#more-inequalities">More Inequalities</a></h1>
<p>Lean's built-in proof automation is sufficient to check that <code class="hljs">arrayMapHelper</code> and <code class="hljs">findHelper</code> terminate.
All that was needed was to provide an expression whose value decreases with each recursive call.
However, Lean's built-in automation is not magic, and it often needs some help.</p>
<h2 id="merge-sort"><a class="header" href="#merge-sort">Merge Sort</a></h2>
<p>One example of a function whose termination proof is non-trivial is merge sort on <code class="hljs">List</code>.
Merge sort consists of two phases: first, a list is split in half.
Each half is sorted using merge sort, and then the results are merged using a function that combines two sorted lists into a larger sorted list.
The base cases are the empty list and the singleton list, both of which are already considered to be sorted.</p>
<p>To merge two sorted lists, there are two basic cases to consider:</p>
<ol>
<li>If one of the input lists is empty, then the result is the other list.</li>
<li>If both lists are non-empty, then their heads should be compared. The result of the function is the smaller of the two heads, followed by the result of merging the remaining entries of both lists.</li>
</ol>
<p>This is not structurally recursive on either list.
The recursion terminates because an entry is removed from one of the two lists in each recursive call, but it could be either list.
The <code class="hljs">termination_by</code> clause uses the sum of the length of both lists as a decreasing value:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">g</span><span class="hljs-title">e</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-params">(ys : List Î±)</span> <span class="hljs-symbol">:</span></span> List Î± :=
  <span class="hljs-keyword">match</span> xs, ys <span class="hljs-keyword">with</span>
  | [], _ =&gt; ys
  | _, [] =&gt; xs
  | x'::xs', y'::ys' =&gt;
    <span class="hljs-keyword">match</span> Ord.compare x' y' <span class="hljs-keyword">with</span>
    | .lt | .eq =&gt; x' :: merge xs' (y' :: ys')
    | .gt =&gt; y' :: merge (x'::xs') ys'
<span class="hljs-keyword">termination_by</span> merge xs ys =&gt; xs.length + ys.length
</code></pre>
<p>In addition to using the lengths of the lists, a pair that contains both lists can also be provided:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">g</span><span class="hljs-title">e</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-params">(ys : List Î±)</span> <span class="hljs-symbol">:</span></span> List Î± :=
  <span class="hljs-keyword">match</span> xs, ys <span class="hljs-keyword">with</span>
  | [], _ =&gt; ys
  | _, [] =&gt; xs
  | x'::xs', y'::ys' =&gt;
    <span class="hljs-keyword">match</span> Ord.compare x' y' <span class="hljs-keyword">with</span>
    | .lt | .eq =&gt; x' :: merge xs' (y' :: ys')
    | .gt =&gt; y' :: merge (x'::xs') ys'
<span class="hljs-keyword">termination_by</span> merge xs ys =&gt; (xs, ys)
</code></pre>
<p>This works because Lean has a built-in notion of sizes of data, expressed through a type class called <code class="hljs">WellFoundedRelation</code>.
The instance for pairs automatically considers them to be smaller if either the first or the second item in the pair shrinks.</p>
<p>A simple way to split a list is to add each entry in the input list to two alternating output lists:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">s</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(lst : List Î±)</span> <span class="hljs-symbol">:</span></span> (List Î± Ã List Î±) :=
  <span class="hljs-keyword">match</span> lst <span class="hljs-keyword">with</span>
  | [] =&gt; ([], [])
  | x :: xs =&gt;
    <span class="hljs-keyword">let</span> (a, b) := splitList xs
    (x :: b, a)
</code></pre>
<p>Merge sort checks whether a base case has been reached.
If so, it returns the input list.
If not, it splits the input, and merges the result of sorting each half:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">S</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> List Î± :=
  <span class="hljs-keyword">if</span> h : xs.length &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">match</span> xs <span class="hljs-keyword">with</span>
    | [] =&gt; []
    | [x] =&gt; [x]
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">let</span> halves := splitList xs
    merge (mergeSort halves.fst) (mergeSort halves.snd)
</code></pre>
<p>Lean's pattern match compiler is able to tell that the assumption <code class="hljs">h</code> introduced by the <code class="hljs">if</code> that tests whether <code class="hljs">xs.length &lt; 2</code> rules out lists longer than one entry, so there is no "missing cases" error.
However, even though this program always terminates, it is not structurally recursive:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">fail to show termination for
  mergeSort
with errors
argument #3 was not used for structural recursion
  failed to eliminate recursive application
    mergeSort halves.fst

structural recursion cannot be used

failed to prove termination, use `termination_by` to specify a well-founded relation
</code></pre>
<p>The reason it terminates is that <code class="hljs">splitList</code> always returns lists that are shorter than its input.
Thus, the length of <code class="hljs">halves.fst</code> and <code class="hljs">halves.snd</code> are less than the length of <code class="hljs">xs</code>.
This can be expressed using a <code class="hljs">termination_by</code> clause:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">S</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> List Î± :=
  <span class="hljs-keyword">if</span> h : xs.length &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">match</span> xs <span class="hljs-keyword">with</span>
    | [] =&gt; []
    | [x] =&gt; [x]
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">let</span> halves := splitList xs
    merge (mergeSort halves.fst) (mergeSort halves.snd)
<span class="hljs-keyword">termination_by</span> mergeSort xs =&gt; xs.length
</code></pre>
<p>With this clause, the error message changes.
Instead of complaining that the function isn't structurally recursive, Lean instead points out that it was unable to automatically prove that <code class="hljs">(splitList xs).fst.length &lt; xs.length</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
Î± : Type u_1
xs : List Î±
h : Â¬List.length xs &lt; 2
halves : List Î± Ã List Î± := splitList xs
â¢ List.length (splitList xs).fst &lt; List.length xs
</code></pre>
<h2 id="splitting-a-list-makes-it-shorter"><a class="header" href="#splitting-a-list-makes-it-shorter">Splitting a List Makes it Shorter</a></h2>
<p>It will also be necessary to prove that <code class="hljs">(splitList xs).snd.length &lt; xs.length</code>.
Because <code class="hljs">splitList</code> alternates between adding entries to the two lists, it is easiest to prove both statements at once, so the structure of the proof can follow the algorithm used to implement <code class="hljs">splitList</code>.
In other words, it is easiest to prove that <code class="hljs">â(lst : List), (splitList lst).fst.length &lt; lst.length â§ (splitList lst).snd.length &lt; lst.length</code>.</p>
<p>Unfortunately, the statement is false.
In particular, <code class="hljs">splitList []</code> is <code class="hljs">([], [])</code>. Both output lists have length <code class="hljs">0</code>, which is not less than <code class="hljs">0</code>, the length of the input list.
Similarly, <code class="hljs">splitList ["basalt"]</code> evaluates to <code class="hljs">(["basalt"], [])</code>, and <code class="hljs">["basalt"]</code> is not shorter than <code class="hljs">["basalt"]</code>.
However, <code class="hljs">splitList ["basalt", "granite"]</code> evaluates to <code class="hljs">(["basalt"], ["granite"])</code>, and both of these output lists are shorter than the input list.</p>
<p>It turns out that the lengths of the output lists are always less than or equal to the length of the input list, but they are only strictly shorter when the input list contains at least two entries.
It turns out to be easiest to prove the former statement, then extend it to the latter statement.
Begin with a theorem statement:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">s</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(lst : List Î±)</span> <span class="hljs-symbol">:</span></span>
    (splitList lst).fst.length â¤ lst.length â§
      (splitList lst).snd.length â¤ lst.length := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">skip</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
Î± : Type u_1
lst : List Î±
â¢ List.length (splitList lst).fst â¤ List.length lst â§ List.length (splitList lst).snd â¤ List.length lst
</code></pre>
<p>Because <code class="hljs">splitList</code> is structurally recursive on the list, the proof should use induction.
The structural recursion in <code class="hljs">splitList</code> fits a proof by induction perfectly: the base case of the induction matches the base case of the recursion, and the inductive step matches the recursive call.
The <code class="hljs">induction</code> tactic gives two goals:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">s</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(lst : List Î±)</span> <span class="hljs-symbol">:</span></span>
    (splitList lst).fst.length â¤ lst.length â§
      (splitList lst).snd.length â¤ lst.length := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> lst <span class="hljs-keyword">with</span>
  | nil =&gt; <span class="hljs-keyword">skip</span>
  | cons x xs ih =&gt; <span class="hljs-keyword">skip</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case nil
Î± : Type u_1
â¢ List.length (splitList []).fst â¤ List.length [] â§ List.length (splitList []).snd â¤ List.length []
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case cons
Î± : Type u_1
x : Î±
xs : List Î±
ih : List.length (splitList xs).fst â¤ List.length xs â§ List.length (splitList xs).snd â¤ List.length xs
â¢ List.length (splitList (x :: xs)).fst â¤ List.length (x :: xs) â§
    List.length (splitList (x :: xs)).snd â¤ List.length (x :: xs)
</code></pre>
<p>The goal for the <code class="hljs">nil</code> case can be proved by invoking the simplifier and instructing it to unfold the definition of <code class="hljs">splitList</code>, because the length of the empty list is less than or equal to the length of the empty list.
Similarly, simplifying with <code class="hljs">splitList</code> in the <code class="hljs">cons</code> case places <code class="hljs">Nat.succ</code> around the lengths in the goal:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">s</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(lst : List Î±)</span> <span class="hljs-symbol">:</span></span>
    (splitList lst).fst.length â¤ lst.length â§
      (splitList lst).snd.length â¤ lst.length := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> lst <span class="hljs-keyword">with</span>
  | nil =&gt; <span class="hljs-keyword">simp</span> [splitList]
  | cons x xs ih =&gt;
    <span class="hljs-keyword">simp</span> [splitList]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case cons
Î± : Type u_1
x : Î±
xs : List Î±
ih : List.length (splitList xs).fst â¤ List.length xs â§ List.length (splitList xs).snd â¤ List.length xs
â¢ Nat.succ (List.length (splitList xs).snd) â¤ Nat.succ (List.length xs) â§
    List.length (splitList xs).fst â¤ Nat.succ (List.length xs)
</code></pre>
<p>This is because the call to <code class="hljs">List.length</code> consumes the head of the list <code class="hljs">x :: xs</code>, converting it to a <code class="hljs">Nat.succ</code>, in both the length of the input list and the length of the first output list.</p>
<p>Writing <code class="hljs">A â§ B</code> in Lean is short for <code class="hljs">And A B</code>.
<code class="hljs">And</code> is a structure type in the <code class="hljs">Prop</code> universe:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">A</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">(a b : <span class="hljs-built_in">Prop</span>)</span> <span class="hljs-symbol">:</span></span> <span class="hljs-built_in">Prop</span> <span class="hljs-keyword">where</span>
  intro ::
  left : a
  right : b
</code></pre>
<p>In other words, a proof of <code class="hljs">A â§ B</code> consists of the <code class="hljs">And.intro</code> constructor applied to a proof of <code class="hljs">A</code> in the <code class="hljs">left</code> field and a proof of <code class="hljs">B</code> in the <code class="hljs">right</code> field.</p>
<p>The <code class="hljs">cases</code> tactic allows a proof to consider each constructor of a datatype or each potential proof of a proposition in turn.
It corresponds to a <code class="hljs">match</code> expression without recursion.
Using <code class="hljs">cases</code> on a structure results in the structure being broken apart, with an assumption added for each field of the structure, just as a pattern match expression extracts the field of a structure for use in a program.
Because structures have only one constructor, using <code class="hljs">cases</code> on a structure does not result in additional goals.</p>
<p>Because <code class="hljs">ih</code> is a proof of <code class="hljs">List.length (splitList xs).fst â¤ List.length xs â§ List.length (splitList xs).snd â¤ List.length xs</code>, using <code class="hljs">cases ih</code> results in an assumption that <code class="hljs">List.length (splitList xs).fst â¤ List.length xs</code> and an assumption that <code class="hljs">List.length (splitList xs).snd â¤ List.length xs</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">s</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(lst : List Î±)</span> <span class="hljs-symbol">:</span></span>
    (splitList lst).fst.length â¤ lst.length â§
      (splitList lst).snd.length â¤ lst.length := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> lst <span class="hljs-keyword">with</span>
  | nil =&gt; <span class="hljs-keyword">simp</span> [splitList]
  | cons x xs ih =&gt;
    <span class="hljs-keyword">simp</span> [splitList]
    <span class="hljs-keyword">cases</span> ih
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case cons.intro
Î± : Type u_1
x : Î±
xs : List Î±
leftâ : List.length (splitList xs).fst â¤ List.length xs
rightâ : List.length (splitList xs).snd â¤ List.length xs
â¢ Nat.succ (List.length (splitList xs).snd) â¤ Nat.succ (List.length xs) â§
    List.length (splitList xs).fst â¤ Nat.succ (List.length xs)
</code></pre>
<p>Because the goal of the proof is also an <code class="hljs">And</code>, the <code class="hljs">constructor</code> tactic can be used to apply <code class="hljs">And.intro</code>, resulting in a goal for each argument:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">s</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(lst : List Î±)</span> <span class="hljs-symbol">:</span></span>
    (splitList lst).fst.length â¤ lst.length â§
      (splitList lst).snd.length â¤ lst.length := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> lst <span class="hljs-keyword">with</span>
  | nil =&gt; <span class="hljs-keyword">simp</span> [splitList]
  | cons x xs ih =&gt;
    <span class="hljs-keyword">simp</span> [splitList]
    <span class="hljs-keyword">cases</span> ih
    <span class="hljs-keyword">constructor</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case cons.intro.left
Î± : Type u_1
x : Î±
xs : List Î±
leftâ : List.length (splitList xs).fst â¤ List.length xs
rightâ : List.length (splitList xs).snd â¤ List.length xs
â¢ Nat.succ (List.length (splitList xs).snd) â¤ Nat.succ (List.length xs)

case cons.intro.right
Î± : Type u_1
x : Î±
xs : List Î±
leftâ : List.length (splitList xs).fst â¤ List.length xs
rightâ : List.length (splitList xs).snd â¤ List.length xs
â¢ List.length (splitList xs).fst â¤ Nat.succ (List.length xs)
</code></pre>
<p>The <code class="hljs">left</code> goal is very similar to the <code class="hljs">leftâ</code> assumption, except the goal wraps both sides of the inequality in <code class="hljs">Nat.succ</code>.
Likewise, the <code class="hljs">right</code> goal resembles the <code class="hljs">rightâ</code> assumption, except the goal adds a <code class="hljs">Nat.succ</code> only to the length of the input list.
It's time to prove that these wrappings of <code class="hljs">Nat.succ</code> preserve the truth of the statement.</p>
<h3 id="adding-one-to-both-sides"><a class="header" href="#adding-one-to-both-sides">Adding One to Both Sides</a></h3>
<p>For the <code class="hljs">left</code> goal, the statement to prove is <code class="hljs">Nat.succ_le_succ : n â¤ m â Nat.succ n â¤ Nat.succ m</code>.
In other words, if <code class="hljs">n â¤ m</code>, then adding one to both sides doesn't change this fact.
Why is this true?
The proof that <code class="hljs">n â¤ m</code> is a <code class="hljs">Nat.le.refl</code> constructor with <code class="hljs">m - n</code> instances of the <code class="hljs">Nat.le.step</code> constructor wrapped around it.
Adding one to both sides simply means that the <code class="hljs">refl</code> applies to a number that's one larger than before, with the same number of <code class="hljs">step</code> constructors.</p>
<p>More formally, the proof is by induction on the evidence that <code class="hljs">n â¤ m</code>.
If the evidence is <code class="hljs">refl</code>, then <code class="hljs">n = m</code>, so <code class="hljs">Nat.succ n = Nat.succ m</code> and <code class="hljs">refl</code> can be used again.
If the evidence is <code class="hljs">step</code>, then the induction hypothesis provides evidence that <code class="hljs">Nat.succ n â¤ Nat.succ m</code>, and the goal is to show that <code class="hljs">Nat.succ n â¤ Nat.succ (Nat.succ m)</code>.
This can be done by using <code class="hljs">step</code> together with the induction hypothesis.</p>
<p>In Lean, the theorem statement is:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span>.<span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">c</span> <span class="hljs-symbol">:</span></span> n â¤ m â Nat.succ n â¤ Nat.succ m := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">skip</span>
</code></pre>
<p>and the error message recapitulates it:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
n m : Nat
â¢ n â¤ m â Nat.succ n â¤ Nat.succ m
</code></pre>
<p>The first step is to use the <code class="hljs">intro</code> tactic, bringing the hypothesis that <code class="hljs">n â¤ m</code> into scope and giving it a name:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span>.<span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">c</span> <span class="hljs-symbol">:</span></span> n â¤ m â Nat.succ n â¤ Nat.succ m := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">intro</span> h
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
n m : Nat
h : n â¤ m
â¢ Nat.succ n â¤ Nat.succ m
</code></pre>
<p>Because the proof is by induction on the evidence that <code class="hljs">n â¤ m</code>, the next tactic is <code class="hljs">induction h</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span>.<span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">c</span> <span class="hljs-symbol">:</span></span> n â¤ m â Nat.succ n â¤ Nat.succ m := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">intro</span> h
  <span class="hljs-keyword">induction</span> h
</code></pre>
<p>This results in two goals, once for each constructor of <code class="hljs">Nat.le</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case refl
n m : Nat
â¢ Nat.succ n â¤ Nat.succ n

case step
n m mâ : Nat
aâ : Nat.le n mâ
a_ihâ : Nat.succ n â¤ Nat.succ mâ
â¢ Nat.succ n â¤ Nat.succ (Nat.succ mâ)
</code></pre>
<p>The goal for <code class="hljs">refl</code> can itself be solved using <code class="hljs">refl</code>, which the <code class="hljs">constructor</code> tactic selects.
The goal for <code class="hljs">step</code> will also require a use of the <code class="hljs">step</code> constructor:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span>.<span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">c</span> <span class="hljs-symbol">:</span></span> n â¤ m â Nat.succ n â¤ Nat.succ m := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">intro</span> h
  <span class="hljs-keyword">induction</span> h <span class="hljs-keyword">with</span>
  | refl =&gt; <span class="hljs-keyword">constructor</span>
  | step h' ih =&gt; <span class="hljs-keyword">constructor</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case step.a
n m mâ : Nat
h' : Nat.le n mâ
ih : Nat.succ n â¤ Nat.succ mâ
â¢ Nat.le (Nat.succ n) (mâ + 1)
</code></pre>
<p>The goal is no longer shown using the <code class="hljs">â¤</code> operator, but it is equivalent to the induction hypothesis <code class="hljs">ih</code>.
The <code class="hljs">assumption</code> tactic automatically selects an assumption that fulfills the goal, and the proof is complete:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span>.<span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">c</span> <span class="hljs-symbol">:</span></span> n â¤ m â Nat.succ n â¤ Nat.succ m := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">intro</span> h
  <span class="hljs-keyword">induction</span> h <span class="hljs-keyword">with</span>
  | refl =&gt; <span class="hljs-keyword">constructor</span>
  | step h' ih =&gt;
    <span class="hljs-keyword">constructor</span>
    <span class="hljs-keyword">assumption</span>
</code></pre>
<p>Written as a recursive function, the proof is:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span>.<span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">c</span> <span class="hljs-symbol">:</span></span> n â¤ m â Nat.succ n â¤ Nat.succ m
  | .refl =&gt; .refl
  | .step h' =&gt; .step (Nat.succ_le_succ h')
</code></pre>
<p>It can be instructional to compare the tactic-based proof by induction with this recursive function.
Which proof steps correspond to which parts of the definition?</p>
<h3 id="adding-one-to-the-greater-side"><a class="header" href="#adding-one-to-the-greater-side">Adding One to the Greater Side</a></h3>
<p>The second inequality needed to prove <code class="hljs">splitList_shorter_le</code> is <code class="hljs">â(n m : Nat), n â¤ m â n â¤ Nat.succ m</code>.
This proof is almost identical to <code class="hljs">Nat.succ_le_succ</code>.
Once again, the incoming assumption that <code class="hljs">n â¤ m</code> essentially tracks the difference between <code class="hljs">n</code> and <code class="hljs">m</code> in the number of <code class="hljs">Nat.le.step</code> constructors.
Thus, the proof should add an extra <code class="hljs">Nat.le.step</code> in the base case.
The proof can be written:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span>.<span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">_</span><span class="hljs-title">o</span><span class="hljs-title">f</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> n â¤ m â n â¤ Nat.succ m := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">intro</span> h
  <span class="hljs-keyword">induction</span> h <span class="hljs-keyword">with</span>
  | refl =&gt; <span class="hljs-keyword">constructor</span>; <span class="hljs-keyword">constructor</span>
  | step =&gt; <span class="hljs-keyword">constructor</span>; <span class="hljs-keyword">assumption</span>
</code></pre>
<p>To reveal what's going on behind the scenes, the <code class="hljs">apply</code> and <code class="hljs">exact</code> tactics can be used to indicate exactly which constructor is being applied.
The <code class="hljs">apply</code> tactic solves the current goal by applying a function or constructor whose return type matches, creating new goals for each argument that was not provided, while <code class="hljs">exact</code> fails if any new goals would be needed:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span>.<span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">_</span><span class="hljs-title">o</span><span class="hljs-title">f</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> n â¤ m â n â¤ Nat.succ m := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">intro</span> h
  <span class="hljs-keyword">induction</span> h <span class="hljs-keyword">with</span>
  | refl =&gt; <span class="hljs-keyword">apply</span> Nat.le.step; <span class="hljs-keyword">exact</span> Nat.le.refl
  | step _ ih =&gt; <span class="hljs-keyword">apply</span> Nat.le.step; <span class="hljs-keyword">exact</span> ih
</code></pre>
<p>The proof can be golfed:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span>.<span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">_</span><span class="hljs-title">o</span><span class="hljs-title">f</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(h : n â¤ m)</span> <span class="hljs-symbol">:</span></span> n â¤ Nat.succ m := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> h &lt;;&gt; <span class="hljs-keyword">repeat</span> (first | <span class="hljs-keyword">constructor</span> | <span class="hljs-keyword">assumption</span>)
</code></pre>
<p>In this short tactic script, both goals introduced by <code class="hljs">induction</code> are addressed using <code class="hljs">repeat (first | constructor | assumption)</code>.
The tactic <code class="hljs">first | T1 | T2 | ... | Tn</code> means to use try <code class="hljs">T1</code> through <code class="hljs">Tn</code> in order, using the first tactic that succeeds.
In other words, <code class="hljs">repeat (first | constructor | assumption)</code> applies constructors as long as it can, and then attempts to solve the goal using an assumption.</p>
<p>Finally, the proof can be written as a recursive function:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">N</span><span class="hljs-title">a</span><span class="hljs-title">t</span>.<span class="hljs-title">l</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">u</span><span class="hljs-title">c</span><span class="hljs-title">c</span><span class="hljs-title">_</span><span class="hljs-title">o</span><span class="hljs-title">f</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> n â¤ m â n â¤ Nat.succ m
  | .refl =&gt; .step .refl
  | .step h =&gt; .step (Nat.le_succ_of_le h)
</code></pre>
<p>Each style of proof can be appropriate to different circumstances.
The detailed proof script is useful in cases where beginners may be reading the code, or where the steps of the proof provide some kind of insight.
The short, highly-automated proof script is typically easier to maintain, because automation is frequently both flexible and robust in the face of small changes to definitions and datatypes.
The recursive function is typically both harder to understand from the perspective of mathematical proofs and harder to maintain, but it can be a useful bridge for programmers who are beginning to work with interactive theorem proving.</p>
<h3 id="finishing-the-proof"><a class="header" href="#finishing-the-proof">Finishing the Proof</a></h3>
<p>Now that both helper theorems have been proved, the rest of <code class="hljs">splitList_shorter_le</code> will be completed quickly.
The current proof state has two goals, for the left and right sides of the <code class="hljs">And</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case cons.intro.left
Î± : Type u_1
x : Î±
xs : List Î±
leftâ : List.length (splitList xs).fst â¤ List.length xs
rightâ : List.length (splitList xs).snd â¤ List.length xs
â¢ Nat.succ (List.length (splitList xs).snd) â¤ Nat.succ (List.length xs)

case cons.intro.right
Î± : Type u_1
x : Î±
xs : List Î±
leftâ : List.length (splitList xs).fst â¤ List.length xs
rightâ : List.length (splitList xs).snd â¤ List.length xs
â¢ List.length (splitList xs).fst â¤ Nat.succ (List.length xs)
</code></pre>
<p>The goals are named for the fields of the <code class="hljs">And</code> structure. This means that the <code class="hljs">case</code> tactic (not to be confused with <code class="hljs">cases</code>) can be used to focus on each of them in turn:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">s</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(lst : List Î±)</span> <span class="hljs-symbol">:</span></span>
    (splitList lst).fst.length â¤ lst.length â§ (splitList lst).snd.length â¤ lst.length := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> lst <span class="hljs-keyword">with</span>
  | nil =&gt; <span class="hljs-keyword">simp</span> [splitList]
  | cons x xs ih =&gt;
    <span class="hljs-keyword">simp</span> [splitList]
    <span class="hljs-keyword">cases</span> ih
    <span class="hljs-keyword">constructor</span>
    <span class="hljs-keyword">case</span> left =&gt; <span class="hljs-keyword">skip</span>
    <span class="hljs-keyword">case</span> right =&gt; <span class="hljs-keyword">skip</span>
</code></pre>
<p>Instead of a single error that lists both unsolved goals, there are now two messages, one on each <code class="hljs">skip</code>.
For the <code class="hljs">left</code> goal, <code class="hljs">Nat.succ_le_succ</code> can be used:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
Î± : Type u_1
x : Î±
xs : List Î±
leftâ : List.length (splitList xs).fst â¤ List.length xs
rightâ : List.length (splitList xs).snd â¤ List.length xs
â¢ Nat.succ (List.length (splitList xs).snd) â¤ Nat.succ (List.length xs)
</code></pre>
<p>In the right goal, <code class="hljs">Nat.le_suc_of_le</code> fits:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
Î± : Type u_1
x : Î±
xs : List Î±
leftâ : List.length (splitList xs).fst â¤ List.length xs
rightâ : List.length (splitList xs).snd â¤ List.length xs
â¢ List.length (splitList xs).fst â¤ Nat.succ (List.length xs)
</code></pre>
<p>Both theorems include the precondition that <code class="hljs">n â¤ m</code>.
These can be found as the <code class="hljs">leftâ</code> and <code class="hljs">rightâ</code> assumptions, which means that the <code class="hljs">assumption</code> tactic takes care of the final goals:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">s</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">l</span><span class="hljs-title">e</span> <span class="hljs-params">(lst : List Î±)</span> <span class="hljs-symbol">:</span></span>
    (splitList lst).fst.length â¤ lst.length â§ (splitList lst).snd.length â¤ lst.length := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> lst <span class="hljs-keyword">with</span>
  | nil =&gt; <span class="hljs-keyword">simp</span> [splitList]
  | cons x xs ih =&gt;
    <span class="hljs-keyword">simp</span> [splitList]
    <span class="hljs-keyword">cases</span> ih
    <span class="hljs-keyword">constructor</span>
    <span class="hljs-keyword">case</span> left =&gt; <span class="hljs-keyword">apply</span> Nat.succ_le_succ; <span class="hljs-keyword">assumption</span>
    <span class="hljs-keyword">case</span> right =&gt; <span class="hljs-keyword">apply</span> Nat.le_succ_of_le; <span class="hljs-keyword">assumption</span>
</code></pre>
<p>The next step is to return to the actual theorem that is needed to prove that merge sort terminates: that so long as a list has at least two entries, both results of splitting it are strictly shorter.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">s</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(lst : List Î±)</span> <span class="hljs-params">(_ : lst.length â¥ 2)</span> <span class="hljs-symbol">:</span></span>
    (splitList lst).fst.length &lt; lst.length â§
      (splitList lst).snd.length &lt; lst.length := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">skip</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
Î± : Type u_1
lst : List Î±
xâ : List.length lst â¥ 2
â¢ List.length (splitList lst).fst &lt; List.length lst â§ List.length (splitList lst).snd &lt; List.length lst
</code></pre>
<p>Pattern matching works just as well in tactic scripts as it does in programs.
Because <code class="hljs">lst</code> has at least two entries, they can be exposed with <code class="hljs">match</code>, which also refines the type through dependent pattern matching:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">s</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(lst : List Î±)</span> <span class="hljs-params">(_ : lst.length â¥ 2)</span> <span class="hljs-symbol">:</span></span>
    (splitList lst).fst.length &lt; lst.length â§
      (splitList lst).snd.length &lt; lst.length := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">match</span> lst <span class="hljs-keyword">with</span>
  | x :: y :: xs =&gt;
    <span class="hljs-keyword">skip</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
Î± : Type u_1
lst : List Î±
x y : Î±
xs : List Î±
xâ : List.length (x :: y :: xs) â¥ 2
â¢ List.length (splitList (x :: y :: xs)).fst &lt; List.length (x :: y :: xs) â§
    List.length (splitList (x :: y :: xs)).snd &lt; List.length (x :: y :: xs)
</code></pre>
<p>Simplifying using <code class="hljs">splitList</code> removes <code class="hljs">x</code> and <code class="hljs">y</code>, resulting in the computed lengths of lists each gaining a <code class="hljs">Nat.succ</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">s</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(lst : List Î±)</span> <span class="hljs-params">(_ : lst.length â¥ 2)</span> <span class="hljs-symbol">:</span></span>
    (splitList lst).fst.length &lt; lst.length â§
      (splitList lst).snd.length &lt; lst.length := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">match</span> lst <span class="hljs-keyword">with</span>
  | x :: y :: xs =&gt;
    <span class="hljs-keyword">simp</span> [splitList]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
Î± : Type u_1
lst : List Î±
x y : Î±
xs : List Î±
xâ : List.length (x :: y :: xs) â¥ 2
â¢ Nat.succ (List.length (splitList xs).fst) &lt; Nat.succ (Nat.succ (List.length xs)) â§
    Nat.succ (List.length (splitList xs).snd) &lt; Nat.succ (Nat.succ (List.length xs))
</code></pre>
<p>Replacing <code class="hljs">simp</code> with <code class="hljs">simp_arith</code> removes these <code class="hljs">Nat.succ</code> constructors, because <code class="hljs">simp_arith</code> makes use of the fact that <code class="hljs">n + 1 &lt; m + 1</code> implies <code class="hljs">n &lt; m</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">s</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(lst : List Î±)</span> <span class="hljs-params">(_ : lst.length â¥ 2)</span> <span class="hljs-symbol">:</span></span>
    (splitList lst).fst.length &lt; lst.length â§
      (splitList lst).snd.length &lt; lst.length := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">match</span> lst <span class="hljs-keyword">with</span>
  | x :: y :: xs =&gt;
    <span class="hljs-keyword">simp_arith</span> [splitList]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
Î± : Type u_1
lst : List Î±
x y : Î±
xs : List Î±
xâ : List.length (x :: y :: xs) â¥ 2
â¢ List.length (splitList xs).fst â¤ List.length xs â§ List.length (splitList xs).snd â¤ List.length xs
</code></pre>
<p>This goal now matches <code class="hljs">splitList_shorter_le</code>, which can be used to conclude the proof:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">s</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(lst : List Î±)</span> <span class="hljs-params">(_ : lst.length â¥ 2)</span> <span class="hljs-symbol">:</span></span>
    (splitList lst).fst.length &lt; lst.length â§
      (splitList lst).snd.length &lt; lst.length := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">match</span> lst <span class="hljs-keyword">with</span>
  | x :: y :: xs =&gt;
    <span class="hljs-keyword">simp_arith</span> [splitList]
    <span class="hljs-keyword">apply</span> splitList_shorter_le
</code></pre>
<p>The facts needed to prove that <code class="hljs">mergeSort</code> terminates can be pulled out of the resulting <code class="hljs">And</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">s</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">f</span><span class="hljs-title">s</span><span class="hljs-title">t</span> <span class="hljs-params">(lst : List Î±)</span> <span class="hljs-params">(h : lst.length â¥ 2)</span> <span class="hljs-symbol">:</span></span>
    (splitList lst).fst.length &lt; lst.length :=
  splitList_shorter lst h |&gt;.left

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">s</span><span class="hljs-title">p</span><span class="hljs-title">l</span><span class="hljs-title">i</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">s</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">h</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">(lst : List Î±)</span> <span class="hljs-params">(h : lst.length â¥ 2)</span> <span class="hljs-symbol">:</span></span>
    (splitList lst).snd.length &lt; lst.length :=
  splitList_shorter lst h |&gt;.right
</code></pre>
<h2 id="merge-sort-terminates"><a class="header" href="#merge-sort-terminates">Merge Sort Terminates</a></h2>
<p>Merge sort has two recursive calls, one for each sub-list returned by <code class="hljs">splitList</code>.
Each recursive call will require a proof that the length of the list being passed to it is shorter than the length of the input list.
It's usually convenient to write a termination proof in two steps: first, write down the propositions that will allow Lean to verify termination, and then prove them.
Otherwise, it's possible to put a lot of effort into proving the propositions, only to find out that they aren't quite what's needed to establish that the recursive calls are on smaller inputs.</p>
<p>The <code class="hljs">sorry</code> tactic can prove any goal, even false ones.
It isn't intended for use in production code or final proofs, but it is a convenient way to "sketch out" a proof or program ahead of time.
Any definitions or theorems that use <code class="hljs">sorry</code> are annotated with a warning.</p>
<p>The initial sketch of <code class="hljs">mergeSort</code>'s termination argument that uses <code class="hljs">sorry</code> can be written by copying the goals that Lean couldn't prove into <code class="hljs">have</code>-expressions.
In Lean, <code class="hljs">have</code> is similar to <code class="hljs">let</code>.
When using <code class="hljs">have</code>, the name is optional.
Typically, <code class="hljs">let</code> is used to define names that refer to interesting values, while <code class="hljs">have</code> is used to locally prove propositions that can be found when Lean is searching for evidence that an array lookup is in-bounds or that a function terminates.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">S</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> List Î± :=
  <span class="hljs-keyword">if</span> h : xs.length &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">match</span> xs <span class="hljs-keyword">with</span>
    | [] =&gt; []
    | [x] =&gt; [x]
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">let</span> halves := splitList xs
    <span class="hljs-keyword">have</span> : halves.fst.length &lt; xs.length := <span class="hljs-keyword">by</span>
      <span class="hljs-tag">sorry</span>
    <span class="hljs-keyword">have</span> : halves.snd.length &lt; xs.length := <span class="hljs-keyword">by</span>
      <span class="hljs-tag">sorry</span>
    merge (mergeSort halves.fst) (mergeSort halves.snd)
<span class="hljs-keyword">termination_by</span> mergeSort xs =&gt; xs.length
</code></pre>
<p>The warning is located on the name <code class="hljs">mergeSort</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output warning hljs">declaration uses 'sorry'
</code></pre>
<p>Because there are no errors, the proposed propositions are enough to establish termination.</p>
<p>The proofs begin by applying the helper theorems:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">S</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> List Î± :=
  <span class="hljs-keyword">if</span> h : xs.length &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">match</span> xs <span class="hljs-keyword">with</span>
    | [] =&gt; []
    | [x] =&gt; [x]
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">let</span> halves := splitList xs
    <span class="hljs-keyword">have</span> : halves.fst.length &lt; xs.length := <span class="hljs-keyword">by</span>
      <span class="hljs-keyword">apply</span> splitList_shorter_fst
    <span class="hljs-keyword">have</span> : halves.snd.length &lt; xs.length := <span class="hljs-keyword">by</span>
      <span class="hljs-keyword">apply</span> splitList_shorter_snd
    merge (mergeSort halves.fst) (mergeSort halves.snd)
<span class="hljs-keyword">termination_by</span> mergeSort xs =&gt; xs.length
</code></pre>
<p>Both proofs fail, because <code class="hljs">splitList_shorter_fst</code> and <code class="hljs">splitList_shorter_snd</code> both require a proof that <code class="hljs">xs.length â¥ 2</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case h
Î± : Type ?u.37732
instâ : Ord Î±
xs : List Î±
h : Â¬List.length xs &lt; 2
halves : List Î± Ã List Î± := splitList xs
â¢ List.length xs â¥ 2
</code></pre>
<p>To check that this will be enough to complete the proof, add it using <code class="hljs">sorry</code> and check for errors:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">S</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> List Î± :=
  <span class="hljs-keyword">if</span> h : xs.length &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">match</span> xs <span class="hljs-keyword">with</span>
    | [] =&gt; []
    | [x] =&gt; [x]
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">let</span> halves := splitList xs
    <span class="hljs-keyword">have</span> : xs.length â¥ <span class="hljs-number">2</span> := <span class="hljs-keyword">by</span> <span class="hljs-tag">sorry</span>
    <span class="hljs-keyword">have</span> : halves.fst.length &lt; xs.length := <span class="hljs-keyword">by</span>
      <span class="hljs-keyword">apply</span> splitList_shorter_fst
      <span class="hljs-keyword">assumption</span>
    <span class="hljs-keyword">have</span> : halves.snd.length &lt; xs.length := <span class="hljs-keyword">by</span>
      <span class="hljs-keyword">apply</span> splitList_shorter_snd
      <span class="hljs-keyword">assumption</span>
    merge (mergeSort halves.fst) (mergeSort halves.snd)
<span class="hljs-keyword">termination_by</span> mergeSort xs =&gt; xs.length
</code></pre>
<p>Once again, there is only a warning.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output warning hljs">declaration uses 'sorry'
</code></pre>
<p>There is one promising assumption available: <code class="hljs">h : Â¬List.length xs &lt; 2</code>, which comes from the <code class="hljs">if</code>.
Clearly, if it is not the case that <code class="hljs">xs.length &lt; 2</code>, then <code class="hljs">xs.length â¥ 2</code>.
The Lean library provides this theorem under the name <code class="hljs">Nat.ge_of_not_lt</code>.
The program is now complete:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">S</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(xs : List Î±)</span> <span class="hljs-symbol">:</span></span> List Î± :=
  <span class="hljs-keyword">if</span> h : xs.length &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">match</span> xs <span class="hljs-keyword">with</span>
    | [] =&gt; []
    | [x] =&gt; [x]
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">let</span> halves := splitList xs
    <span class="hljs-keyword">have</span> : xs.length â¥ <span class="hljs-number">2</span> := <span class="hljs-keyword">by</span>
      <span class="hljs-keyword">apply</span> Nat.ge_of_not_lt
      <span class="hljs-keyword">assumption</span>
    <span class="hljs-keyword">have</span> : halves.fst.length &lt; xs.length := <span class="hljs-keyword">by</span>
      <span class="hljs-keyword">apply</span> splitList_shorter_fst
      <span class="hljs-keyword">assumption</span>
    <span class="hljs-keyword">have</span> : halves.snd.length &lt; xs.length := <span class="hljs-keyword">by</span>
      <span class="hljs-keyword">apply</span> splitList_shorter_snd
      <span class="hljs-keyword">assumption</span>
    merge (mergeSort halves.fst) (mergeSort halves.snd)
<span class="hljs-keyword">termination_by</span> mergeSort xs =&gt; xs.length
</code></pre>
<p>The function can be tested on examples:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> mergeSort [<span class="hljs-string">"soapstone"</span>, <span class="hljs-string">"geode"</span>, <span class="hljs-string">"mica"</span>, <span class="hljs-string">"limestone"</span>]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">["geode", "limestone", "mica", "soapstone"]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> mergeSort [<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">22</span>, <span class="hljs-number">15</span>]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">[3, 5, 15, 22]
</code></pre>
<h2 id="division-as-iterated-subtraction"><a class="header" href="#division-as-iterated-subtraction">Division as Iterated Subtraction</a></h2>
<p>Just as multiplication is iterated addition and exponentiation is iterated multiplication, division can be understood as iterated subtraction.
The <a href="https://leanprover.github.io/functional_programming_in_lean/getting-to-know/datatypes-and-patterns.html#recursive-functions">very first description of recursive functions in this book</a> presents a version of division that terminates when the divisor is not zero, but that Lean does not accept.
Proving that division terminates requires the use of a fact about inequalities.</p>
<p>The first step is to refine the definition of division so that it requires evidence that the divisor is not zero:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">i</span><span class="hljs-title">v</span> <span class="hljs-params">(n k : Nat)</span> <span class="hljs-params">(ok : k &gt; 0)</span> <span class="hljs-symbol">:</span></span> Nat :=
  <span class="hljs-keyword">if</span> n &lt; k <span class="hljs-keyword">then</span>
    <span class="hljs-number">0</span>
  <span class="hljs-keyword">else</span>
    <span class="hljs-number">1</span> + div (n - k) k ok
</code></pre>
<p>The error message is somewhat longer, due to the additional argument, but it contains essentially the same information:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">fail to show termination for
  div
with errors
argument #1 was not used for structural recursion
  failed to eliminate recursive application
    div (n - k) k ok

argument #2 was not used for structural recursion
  failed to eliminate recursive application
    div (n - k) k ok

argument #3 was not used for structural recursion
  application type mismatch
    @Nat.le.brecOn (Nat.succ 0) fun k ok =&gt; Nat â Nat
  argument
    fun k ok =&gt; Nat â Nat
  has type
    (k : Nat) â k &gt; 0 â Type : Type 1
  but is expected to have type
    (a : Nat) â Nat.le (Nat.succ 0) a â Prop : Type

structural recursion cannot be used

failed to prove termination, use `termination_by` to specify a well-founded relation
</code></pre>
<p>This definition of <code class="hljs">div</code> terminates because the first argument <code class="hljs">n</code> is smaller on each recursive call.
This can be expressed using a <code class="hljs">termination_by</code> clause:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">i</span><span class="hljs-title">v</span> <span class="hljs-params">(n k : Nat)</span> <span class="hljs-params">(ok : k &gt; 0)</span> <span class="hljs-symbol">:</span></span> Nat :=
  <span class="hljs-keyword">if</span> h : n &lt; k <span class="hljs-keyword">then</span>
    <span class="hljs-number">0</span>
  <span class="hljs-keyword">else</span>
    <span class="hljs-number">1</span> + div (n - k) k ok
<span class="hljs-keyword">termination_by</span> div n k ok =&gt; n
</code></pre>
<p>Now, the error is confined to the recursive call:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
n k : Nat
ok : k &gt; 0
h : Â¬n &lt; k
â¢ n - k &lt; n
</code></pre>
<p>This can be proved using a theorem from the standard library, <code class="hljs">Nat.sub_lt</code>.
This theorem states that <code class="hljs">â {n k : Nat}, 0 &lt; n â 0 &lt; k â n - k &lt; n</code> (the curly braces indicate that <code class="hljs">n</code> and <code class="hljs">k</code> are implicit arguments).
Using this theorem requires demonstrating that both <code class="hljs">n</code> and <code class="hljs">k</code> are greater than zero.
Because <code class="hljs">k &gt; 0</code> is syntactic sugar for <code class="hljs">0 &lt; k</code>, the only necessary goal is to show that <code class="hljs">0 &lt; n</code>.
There are two possibilities: either <code class="hljs">n</code> is <code class="hljs">0</code>, or it is <code class="hljs">n' + 1</code> for some other <code class="hljs">Nat</code> <code class="hljs">n'</code>.
But <code class="hljs">n</code> cannot be <code class="hljs">0</code>.
The fact that the <code class="hljs">if</code> selected the second branch means that <code class="hljs">Â¬ n &lt; k</code>, but if <code class="hljs">n = 0</code> and <code class="hljs">k &gt; 0</code> then <code class="hljs">n</code> must be less than <code class="hljs">k</code>, which would be a contradiction.
This, <code class="hljs">n = Nat.succ n'</code>, and <code class="hljs">Nat.succ n'</code> is clearly greater than <code class="hljs">0</code>.</p>
<p>The full definition of <code class="hljs">div</code>, including the termination proof, is:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">d</span><span class="hljs-title">i</span><span class="hljs-title">v</span> <span class="hljs-params">(n k : Nat)</span> <span class="hljs-params">(ok : k &gt; 0)</span> <span class="hljs-symbol">:</span></span> Nat :=
  <span class="hljs-keyword">if</span> h : n &lt; k <span class="hljs-keyword">then</span>
    <span class="hljs-number">0</span>
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">have</span> : <span class="hljs-number">0</span> &lt; n := <span class="hljs-keyword">by</span>
      <span class="hljs-keyword">cases</span> n <span class="hljs-keyword">with</span>
      | zero =&gt; <span class="hljs-built_in">contradiction</span>
      | succ n' =&gt; <span class="hljs-keyword">simp_arith</span>
    <span class="hljs-keyword">have</span> : n - k &lt; n := <span class="hljs-keyword">by</span>
      <span class="hljs-keyword">apply</span> Nat.sub_lt &lt;;&gt; <span class="hljs-keyword">assumption</span>
    <span class="hljs-number">1</span> + div (n - k) k ok
<span class="hljs-keyword">termination_by</span> div n k ok =&gt; n
</code></pre>
<h2 id="exercises-25"><a class="header" href="#exercises-25">Exercises</a></h2>
<p>Prove the following theorems:</p>
<ul>
<li>For all natural numbers <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-85-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-602" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-603"><span class="mi" id="MathJax-Span-604" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span>, <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-86-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn><mo>&amp;lt;</mo><mi>n</mi><mo>+</mo><mn>1</mn></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-605" style="width:5.204em;display:inline-block"><span style="display:inline-block;position:relative;width:4.196em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1004.12em,2.583em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-606"><span class="mn" id="MathJax-Span-607" style="font-family:MathJax_Main">0</span><span class="mo" id="MathJax-Span-608" style="font-family:MathJax_Main;padding-left:0.284em">&lt;</span><span class="mi" id="MathJax-Span-609" style="font-family:MathJax_Math;font-style:italic;padding-left:0.284em">n</span><span class="mo" id="MathJax-Span-610" style="font-family:MathJax_Main;padding-left:0.244em">+</span><span class="mn" id="MathJax-Span-611" style="font-family:MathJax_Main;padding-left:0.244em">1</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.148em;border-left:0px solid;width:0px;height:1.052em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn><mo>&lt;</mo><mi>n</mi><mo>+</mo><mn>1</mn></math></span></span>.</li>
<li>For all natural numbers <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-87-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-612" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-613"><span class="mi" id="MathJax-Span-614" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span>, <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-88-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn><mo>&amp;#x2264;</mo><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-615" style="width:3.067em;display:inline-block"><span style="display:inline-block;position:relative;width:2.462em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1002.46em,2.623em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-616"><span class="mn" id="MathJax-Span-617" style="font-family:MathJax_Main">0</span><span class="mo" id="MathJax-Span-618" style="font-family:MathJax_Main;padding-left:0.284em">â¤</span><span class="mi" id="MathJax-Span-619" style="font-family:MathJax_Math;font-style:italic;padding-left:0.284em">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.198em;border-left:0px solid;width:0px;height:1.103em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn><mo>â¤</mo><mi>n</mi></math></span></span>.</li>
<li>For all natural numbers <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-89-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-620" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-621"><span class="mi" id="MathJax-Span-622" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span> and <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-90-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-623" style="width:0.647em;display:inline-block"><span style="display:inline-block;position:relative;width:0.526em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.53em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-624"><span class="mi" id="MathJax-Span-625" style="font-family:MathJax_Math;font-style:italic">k</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span>, <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-91-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo><mo>&amp;#x2212;</mo><mo stretchy=&quot;false&quot;>(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mi>n</mi><mo>&amp;#x2212;</mo><mi>k</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-626" style="width:13.913em;display:inline-block"><span style="display:inline-block;position:relative;width:11.212em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.494em,1011.21em,2.744em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-627"><span class="mo" id="MathJax-Span-628" style="font-family:MathJax_Main">(</span><span class="mi" id="MathJax-Span-629" style="font-family:MathJax_Math;font-style:italic">n</span><span class="mo" id="MathJax-Span-630" style="font-family:MathJax_Main;padding-left:0.244em">+</span><span class="mn" id="MathJax-Span-631" style="font-family:MathJax_Main;padding-left:0.244em">1</span><span class="mo" id="MathJax-Span-632" style="font-family:MathJax_Main">)</span><span class="mo" id="MathJax-Span-633" style="font-family:MathJax_Main;padding-left:0.244em">â</span><span class="mo" id="MathJax-Span-634" style="font-family:MathJax_Main;padding-left:0.244em">(</span><span class="mi" id="MathJax-Span-635" style="font-family:MathJax_Math;font-style:italic">k</span><span class="mo" id="MathJax-Span-636" style="font-family:MathJax_Main;padding-left:0.244em">+</span><span class="mn" id="MathJax-Span-637" style="font-family:MathJax_Main;padding-left:0.244em">1</span><span class="mo" id="MathJax-Span-638" style="font-family:MathJax_Main">)</span><span class="mo" id="MathJax-Span-639" style="font-family:MathJax_Main;padding-left:0.284em">=</span><span class="mi" id="MathJax-Span-640" style="font-family:MathJax_Math;font-style:italic;padding-left:0.284em">n</span><span class="mo" id="MathJax-Span-641" style="font-family:MathJax_Main;padding-left:0.244em">â</span><span class="mi" id="MathJax-Span-642" style="font-family:MathJax_Math;font-style:italic;padding-left:0.244em">k</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.348em;border-left:0px solid;width:0px;height:1.353em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>â</mo><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi><mo>â</mo><mi>k</mi></math></span></span></li>
<li>For all natural numbers <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-92-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-643" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-644"><span class="mi" id="MathJax-Span-645" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span> and <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-93-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-646" style="width:0.647em;display:inline-block"><span style="display:inline-block;position:relative;width:0.526em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.53em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-647"><span class="mi" id="MathJax-Span-648" style="font-family:MathJax_Math;font-style:italic">k</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span>, if <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-94-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi><mo>&amp;lt;</mo><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-649" style="width:3.067em;display:inline-block"><span style="display:inline-block;position:relative;width:2.462em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1002.46em,2.542em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-650"><span class="mi" id="MathJax-Span-651" style="font-family:MathJax_Math;font-style:italic">k</span><span class="mo" id="MathJax-Span-652" style="font-family:MathJax_Main;padding-left:0.284em">&lt;</span><span class="mi" id="MathJax-Span-653" style="font-family:MathJax_Math;font-style:italic;padding-left:0.284em">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.098em;border-left:0px solid;width:0px;height:1.002em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi><mo>&lt;</mo><mi>n</mi></math></span></span> then <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-95-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>&amp;#x2260;</mo><mn>0</mn></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-654" style="width:3.067em;display:inline-block"><span style="display:inline-block;position:relative;width:2.462em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.534em,1002.42em,2.704em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-655"><span class="mi" id="MathJax-Span-656" style="font-family:MathJax_Math;font-style:italic">n</span><span class="mo" id="MathJax-Span-657" style="font-family:MathJax_Main;padding-left:0.284em">â </span><span class="mn" id="MathJax-Span-658" style="font-family:MathJax_Main;padding-left:0.284em">0</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.297em;border-left:0px solid;width:0px;height:1.252em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>â </mo><mn>0</mn></math></span></span></li>
<li>For all natural numbers <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-96-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-659" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-660"><span class="mi" id="MathJax-Span-661" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span>, <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-97-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>&amp;#x2212;</mo><mi>n</mi><mo>=</mo><mn>0</mn></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-662" style="width:5.365em;display:inline-block"><span style="display:inline-block;position:relative;width:4.317em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1004.28em,2.583em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-663"><span class="mi" id="MathJax-Span-664" style="font-family:MathJax_Math;font-style:italic">n</span><span class="mo" id="MathJax-Span-665" style="font-family:MathJax_Main;padding-left:0.244em">â</span><span class="mi" id="MathJax-Span-666" style="font-family:MathJax_Math;font-style:italic;padding-left:0.244em">n</span><span class="mo" id="MathJax-Span-667" style="font-family:MathJax_Main;padding-left:0.284em">=</span><span class="mn" id="MathJax-Span-668" style="font-family:MathJax_Main;padding-left:0.284em">0</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.148em;border-left:0px solid;width:0px;height:1.052em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>â</mo><mi>n</mi><mo>=</mo><mn>0</mn></math></span></span></li>
<li>For all natural numbers <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-98-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-669" style="width:0.768em;display:inline-block"><span style="display:inline-block;position:relative;width:0.607em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.817em,1000.61em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-670"><span class="mi" id="MathJax-Span-671" style="font-family:MathJax_Math;font-style:italic">n</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.653em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span> and <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-99-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>k</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-672" style="width:0.647em;display:inline-block"><span style="display:inline-block;position:relative;width:0.526em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.53em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-673"><span class="mi" id="MathJax-Span-674" style="font-family:MathJax_Math;font-style:italic">k</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></span></span>, if <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-100-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>+</mo><mn>1</mn><mo>&amp;lt;</mo><mi>k</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-675" style="width:5.284em;display:inline-block"><span style="display:inline-block;position:relative;width:4.236em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1004.24em,2.583em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-676"><span class="mi" id="MathJax-Span-677" style="font-family:MathJax_Math;font-style:italic">n</span><span class="mo" id="MathJax-Span-678" style="font-family:MathJax_Main;padding-left:0.244em">+</span><span class="mn" id="MathJax-Span-679" style="font-family:MathJax_Main;padding-left:0.244em">1</span><span class="mo" id="MathJax-Span-680" style="font-family:MathJax_Main;padding-left:0.284em">&lt;</span><span class="mi" id="MathJax-Span-681" style="font-family:MathJax_Math;font-style:italic;padding-left:0.284em">k</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.148em;border-left:0px solid;width:0px;height:1.052em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>+</mo><mn>1</mn><mo>&lt;</mo><mi>k</mi></math></span></span> then <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-101-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>n</mi><mo>&amp;lt;</mo><mi>k</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-682" style="width:3.067em;display:inline-block"><span style="display:inline-block;position:relative;width:2.462em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1002.46em,2.542em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-683"><span class="mi" id="MathJax-Span-684" style="font-family:MathJax_Math;font-style:italic">n</span><span class="mo" id="MathJax-Span-685" style="font-family:MathJax_Main;padding-left:0.284em">&lt;</span><span class="mi" id="MathJax-Span-686" style="font-family:MathJax_Math;font-style:italic;padding-left:0.284em">k</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.098em;border-left:0px solid;width:0px;height:1.002em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>&lt;</mo><mi>k</mi></math></span></span></li>
</ul>
<div style="break-before:page;page-break-before:always"></div><h1 id="safe-array-indices"><a class="header" href="#safe-array-indices">Safe Array Indices</a></h1>
<p>The <code class="hljs">GetElem</code> instance for <code class="hljs">Array</code> and <code class="hljs">Nat</code> requires a proof that the provided <code class="hljs">Nat</code> is smaller than the array.
In practice, these proofs often end up being passed to functions along with the indices.
Rather than passing an index and a proof separately, a type called <code class="hljs">Fin</code> can be used to bundle up the index and the proof into a single value.
This can make code easier to read.
Additionally, many of the built-in operations on arrays take their index arguments as <code class="hljs">Fin</code> rather than as <code class="hljs">Nat</code>, so using these built-in operations requires understanding how to use <code class="hljs">Fin</code>.</p>
<p>The type <code class="hljs">Fin n</code> represents numbers that are strictly less than <code class="hljs">n</code>.
In other words, <code class="hljs">Fin 3</code> describes <code class="hljs">0</code>, <code class="hljs">1</code>, and <code class="hljs">2</code>, while <code class="hljs">Fin 0</code> has no values at all.
The definition of <code class="hljs">Fin</code> resembles <code class="hljs">Subtype</code>, as a <code class="hljs">Fin n</code> is a structure that contains a <code class="hljs">Nat</code> and a proof that it is less than <code class="hljs">n</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">structure</span> <span class="hljs-title">F</span><span class="hljs-title">i</span><span class="hljs-title">n</span> <span class="hljs-params">(n : Nat)</span></span> <span class="hljs-keyword">where</span>
  val  : Nat
  isLt : LT.lt val n
</code></pre>
<p>Lean includes instances of <code class="hljs">ToString</code> and <code class="hljs">OfNat</code> that allow <code class="hljs">Fin</code> values to be conveniently used as numbers.
In other words, the output of <code class="hljs">#eval (5 : Fin 8)</code> is <code class="hljs">5</code>, rather than something like <code class="hljs">{val := 5, isLt := _}</code>.</p>
<p>Instead of failing when the provided number is larger than the bound, the <code class="hljs">OfNat</code> instance for <code class="hljs">Fin</code> returns a value modulo the bound.
This means that <code class="hljs">#eval (45 : Fin 10)</code> results in <code class="hljs">5</code> rather than a compile-time error.</p>
<p>In a return type, a <code class="hljs">Fin</code> returned as a found index makes its connection to the data structure in which it was found more clear.
The <code class="hljs">Array.find</code> in the <a href="https://leanprover.github.io/functional_programming_in_lean/programs-proofs/arrays-termination.html#proving-termination">previous section</a> returns an index that the caller cannot immediately use to perform lookups into the array, because the information about its validity has been lost.
A more specific type results in a value that can be used without making the program significantly more complicated:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d</span><span class="hljs-title">H</span><span class="hljs-title">e</span><span class="hljs-title">l</span><span class="hljs-title">p</span><span class="hljs-title">e</span><span class="hljs-title">r</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-params">(p : Î± â Bool)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span> Option (Fin arr.size Ã Î±) :=
  <span class="hljs-keyword">if</span> h : i &lt; arr.size <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">let</span> x := arr[i]
    <span class="hljs-keyword">if</span> p x <span class="hljs-keyword">then</span>
      some (â¨i, hâ©, x)
    <span class="hljs-keyword">else</span> findHelper arr p (i + <span class="hljs-number">1</span>)
  <span class="hljs-keyword">else</span> none
<span class="hljs-keyword">termination_by</span> findHelper arr p i =&gt; arr.size - i

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">A</span><span class="hljs-title">r</span><span class="hljs-title">r</span><span class="hljs-title">a</span><span class="hljs-title">y</span>.<span class="hljs-title">f</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">d</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-params">(p : Î± â Bool)</span> <span class="hljs-symbol">:</span></span> Option (Fin arr.size Ã Î±) :=
  findHelper arr p <span class="hljs-number">0</span>
</code></pre>
<h2 id="exercise-3"><a class="header" href="#exercise-3">Exercise</a></h2>
<p>Write a function <code class="hljs">Fin.next? : Fin n â Option (Fin n)</code> that returns the next largest <code class="hljs">Fin</code> when it would be in bounds, or <code class="hljs">none</code> if not.
Check that</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (<span class="hljs-number">3</span> : Fin <span class="hljs-number">8</span>).next?
</code></pre>
<p>outputs</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">some 4
</code></pre>
<p>and that</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> (<span class="hljs-number">7</span> : Fin <span class="hljs-number">8</span>).next?
</code></pre>
<p>outputs</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">none
</code></pre>
<div style="break-before:page;page-break-before:always"></div><h1 id="insertion-sort-and-array-mutation"><a class="header" href="#insertion-sort-and-array-mutation">Insertion Sort and Array Mutation</a></h1>
<p>While insertion sort does not have the optimal worst-case time complexity for a sorting algorithm, it still has a number of useful properties:</p>
<ul>
<li>It is simple and straightforward to implement and understand</li>
<li>It is an in-place algorithm, requiring no additional space to run</li>
<li>It is a stable sort</li>
<li>It is fast when the input is already almost sorted</li>
</ul>
<p>In-place algorithms are particularly useful in Lean due to the way it manages memory.
In some cases, operations that would normally copy an array can be optimized into mutation.
This includes swapping elements in an array.</p>
<p>Most languages and run-time systems with automatic memory management, including JavaScript, the JVM, and .NET, use tracing garbage collection.
When memory needs to be reclaimed, the system starts at a number of <em>roots</em> (such as the call stack and global values) and then determines which values can be reached by recursively chasing pointers.
Any values that can't be reached are deallocated, freeing memory.</p>
<p>Reference counting is an alternative to tracing garbage collection that is used by a number of languages, including Python, Swift, and Lean.
In a system with reference counting, each object in memory has a field that tracks how many references there are to it.
When a new reference is established, the counter is incremented.
When a reference ceases to exist, the counter is decremented.
When the counter reaches zero, the object is immediately deallocated.</p>
<p>Reference counting has one major disadvantage compared to a tracing garbage collector: circular references can lead to memory leaks.
If object <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-102-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-687" style="width:0.97em;display:inline-block"><span style="display:inline-block;position:relative;width:0.768em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.534em,1000.73em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-688"><span class="mi" id="MathJax-Span-689" style="font-family:MathJax_Math;font-style:italic">A</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:1.002em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math></span></span> references object <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-103-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-690" style="width:0.97em;display:inline-block"><span style="display:inline-block;position:relative;width:0.768em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.77em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-691"><span class="mi" id="MathJax-Span-692" style="font-family:MathJax_Math;font-style:italic">B</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>B</mi></math></span></span> , and object <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-104-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-693" style="width:0.97em;display:inline-block"><span style="display:inline-block;position:relative;width:0.768em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.77em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-694"><span class="mi" id="MathJax-Span-695" style="font-family:MathJax_Math;font-style:italic">B</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>B</mi></math></span></span> references object <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-105-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-696" style="width:0.97em;display:inline-block"><span style="display:inline-block;position:relative;width:0.768em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.534em,1000.73em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-697"><span class="mi" id="MathJax-Span-698" style="font-family:MathJax_Math;font-style:italic">A</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:1.002em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math></span></span>, they will never be deallocated, even if nothing else in the program references either <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-106-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-699" style="width:0.97em;display:inline-block"><span style="display:inline-block;position:relative;width:0.768em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.534em,1000.73em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-700"><span class="mi" id="MathJax-Span-701" style="font-family:MathJax_Math;font-style:italic">A</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:1.002em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math></span></span> or <span class="MathJax_Preview" style="color:inherit;display:none"></span><span class="MathJax" id="MathJax-Element-107-Frame" tabindex="0" style="position:relative" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>B</mi></math>" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-702" style="width:0.97em;display:inline-block"><span style="display:inline-block;position:relative;width:0.768em;height:0px;font-size:124%"><span style="position:absolute;clip:rect(1.575em,1000.77em,2.502em,-999.998em);top:-2.377em;left:0em"><span class="mrow" id="MathJax-Span-703"><span class="mi" id="MathJax-Span-704" style="font-family:MathJax_Math;font-style:italic">B</span></span><span style="display:inline-block;width:0px;height:2.381em"></span></span></span><span style="display:inline-block;overflow:hidden;vertical-align:-0.048em;border-left:0px solid;width:0px;height:0.953em"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>B</mi></math></span></span>.
Circular references result either from uncontrolled recursion or from mutable references.
Because Lean supports neither, it is impossible to construct circular references.</p>
<p>Reference counting means that the Lean runtime system's primitives for allocating and deallocating data structures can check whether a reference count is about to fall to zero, and re-use an existing object instead of allocating a new one.
This is particularly important when working with large arrays.</p>
<p>An implementation of insertion sort for Lean arrays should satisfy the following criteria:</p>
<ol>
<li>Lean should accept the function without a <code class="hljs">partial</code> annotation</li>
<li>If passed an array to which there are no other references, it should modify the array in-place rather than allocating a new one</li>
</ol>
<p>The first criterion is easy to check: if Lean accepts the definition, then it is satisfied.
The second, however, requires a means of testing it.
Lean provides a built-in function called <code class="hljs">dbgTraceIfShared</code> with the following signature:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#check</span> dbgTraceIfShared
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">dbgTraceIfShared.{u} {Î± : Type u} (s : String) (a : Î±) : Î±
</code></pre>
<p>It takes a string and a value as arguments, and prints a message that uses the string to standard error if the value has more than one reference, returning the value.
This is not, strictly speaking, a pure function.
However, it is intended to be used only during development to check that a function is in fact able to re-use memory rather than allocating and copying.</p>
<p>When learning to use <code class="hljs">dbgTraceIfShared</code>, it's important to know that <code class="hljs">#eval</code> will report that many more values are shared than in compiled code.
This can be confusing.
It's important to build an executable with <code class="hljs">lake</code> rather than experimenting in an editor.</p>
<p>Insertion sort consists of two loops.
The outer loop moves a pointer from left to right across the array to be sorted.
After each iteration, the region of the array to the left of the pointer is sorted, while the region to the right may not yet be sorted.
The inner loop takes the element pointed to by the pointer and moves it to the left until the appropriate location has been found and the loop invariant has been restored.
In other words, each iteration inserts the next element of the array into the appropriate location in the sorted region.</p>
<h2 id="the-inner-loop"><a class="header" href="#the-inner-loop">The Inner Loop</a></h2>
<p>The inner loop of insertion sort can be implemented as a tail-recursive function that takes the array and the index of the element being inserted as arguments.
The element being inserted is repeatedly swapped with the element to its left until either the element to the left is smaller or the beginning of the array is reached.
The inner loop is structurally recursive on the <code class="hljs">Nat</code> that is inside the <code class="hljs">Fin</code> used to index into the array:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">S</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">d</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-params">(i : Fin arr.size)</span> <span class="hljs-symbol">:</span></span> Array Î± :=
  <span class="hljs-keyword">match</span> i <span class="hljs-keyword">with</span>
  | â¨<span class="hljs-number">0</span>, _â© =&gt; arr
  | â¨i' + <span class="hljs-number">1</span>, _â© =&gt;
    <span class="hljs-keyword">have</span> : i' &lt; arr.size := <span class="hljs-keyword">by</span>
      <span class="hljs-keyword">simp</span> [Nat.lt_of_succ_lt, *]
    <span class="hljs-keyword">match</span> Ord.compare arr[i'] arr[i] <span class="hljs-keyword">with</span>
    | .lt | .eq =&gt; arr
    | .gt =&gt;
      insertSorted (arr.<span class="hljs-built_in">swap</span> â¨i', <span class="hljs-keyword">by</span> <span class="hljs-keyword">assumption</span>â© i) â¨i', <span class="hljs-keyword">by</span> <span class="hljs-keyword">simp</span> [*]â©
</code></pre>
<p>If the index <code class="hljs">i</code> is <code class="hljs">0</code>, then the element being inserted into the sorted region has reached the beginning of the region and is the smallest.
If the index is <code class="hljs">i' + 1</code>, then the element at <code class="hljs">i'</code> should be compared to the element at <code class="hljs">i</code>.
Note that while <code class="hljs">i</code> is a <code class="hljs">Fin arr.size</code>, <code class="hljs">i'</code> is just a <code class="hljs">Nat</code> because it results from the <code class="hljs">val</code> field of <code class="hljs">i</code>.
It is thus necessary to prove that <code class="hljs">i' &lt; arr.size</code> before <code class="hljs">i'</code> can be used to index into <code class="hljs">arr</code>.</p>
<p>Omitting the <code class="hljs">have</code>-expression with the proof that <code class="hljs">i' &lt; arr.size</code> reveals the following goal:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
Î± : Type ?u.7
instâ : Ord Î±
arr : Array Î±
i : Fin (Array.size arr)
i' : Nat
isLtâ : i' + 1 &lt; Array.size arr
â¢ i' &lt; Array.size arr
</code></pre>
<p>The hint <code class="hljs">Nat.lt_of_succ_lt</code> is a theorem from Lean's standard library.
Its signature, found by <code class="hljs">#check Nat.lt_of_succ_lt</code>, is</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">Nat.lt_of_succ_lt {n m : Nat} (aâ : Nat.succ n &lt; m) : n &lt; m
</code></pre>
<p>In other words, it states that if <code class="hljs">n + 1 &lt; m</code>, then <code class="hljs">n &lt; m</code>.
The <code class="hljs">*</code> passed to <code class="hljs">simp</code> causes it to combine <code class="hljs">Nat.lt_of_succ_lt</code> with the <code class="hljs">isLt</code> field from <code class="hljs">i</code> to get the final proof.</p>
<p>Having established that <code class="hljs">i'</code> can be used to look up the element to the left of the element being inserted, the two elements are looked up and compared. 
If the element to the left is less than or equal to the element being inserted, then the loop is finished and the invariant has been restored.
If the element to the left is greater than the element being inserted, then the elements are swapped and the inner loop begins again.
<code class="hljs">Array.swap</code> takes both of its indices as <code class="hljs">Fin</code>s, and the <code class="hljs">by assumption</code> that establishes that <code class="hljs">i' &lt; arr.size</code> makes use of the <code class="hljs">have</code>.
The index to be examined on the next round through the inner loop is also <code class="hljs">i'</code>, but <code class="hljs">by assumption</code> is not sufficient in this case.
This is because the proof was written for the original array <code class="hljs">arr</code>, not the result of swapping two elements.
The <code class="hljs">simp</code> tactic's database contains the fact that swapping two elements of an array doesn't change its size, and the <code class="hljs">[*]</code> argument instructs it to additionally use the assumption introduced by <code class="hljs">have</code>.</p>
<h2 id="the-outer-loop"><a class="header" href="#the-outer-loop">The Outer Loop</a></h2>
<p>The outer loop of insertion sort moves the pointer from left to right, invoking <code class="hljs">insertSorted</code> at each iteration to insert the element at the pointer into the correct position in the array.
The basic form of the loop resembles the implementation of <code class="hljs">Array.map</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">S</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">o</span><span class="hljs-title">o</span><span class="hljs-title">p</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span> Array Î± :=
  <span class="hljs-keyword">if</span> h : i &lt; arr.size <span class="hljs-keyword">then</span>
    insertionSortLoop (insertSorted arr â¨i, hâ©) (i + <span class="hljs-number">1</span>)
  <span class="hljs-keyword">else</span>
    arr
</code></pre>
<p>The resulting error is also the same as the error that occurs without a <code class="hljs">termination_by</code> clause on <code class="hljs">Array.map</code>, because there is no argument that decreases at every recursive call:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">fail to show termination for
  insertionSortLoop
with errors
argument #4 was not used for structural recursion
  failed to eliminate recursive application
    insertionSortLoop (insertSorted arr { val := i, isLt := h }) (i + 1)

structural recursion cannot be used

failed to prove termination, use `termination_by` to specify a well-founded relation
</code></pre>
<p>Before constructing the termination proof, it can be convenient to test the definition with a <code class="hljs">partial</code> modifier to make sure that it returns the expected answers:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">partial</span> <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">S</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">o</span><span class="hljs-title">o</span><span class="hljs-title">p</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span> Array Î± :=
  <span class="hljs-keyword">if</span> h : i &lt; arr.size <span class="hljs-keyword">then</span>
    insertionSortLoop (insertSorted arr â¨i, hâ©) (i + <span class="hljs-number">1</span>)
  <span class="hljs-keyword">else</span>
    arr
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> insertionSortLoop #[<span class="hljs-number">5</span>, <span class="hljs-number">17</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>] <span class="hljs-number">0</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">#[3, 5, 8, 17]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> insertionSortLoop #[<span class="hljs-string">"metamorphic"</span>, <span class="hljs-string">"igneous"</span>, <span class="hljs-string">"sedentary"</span>] <span class="hljs-number">0</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">#["igneous", "metamorphic", "sedentary"]
</code></pre>
<h3 id="termination"><a class="header" href="#termination">Termination</a></h3>
<p>Once again, the function terminates because the difference between the index and the size of the array being processed decreases on each recursive call.
This time, however, Lean does not accept the <code class="hljs">termination_by</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">S</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">o</span><span class="hljs-title">o</span><span class="hljs-title">p</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span> Array Î± :=
  <span class="hljs-keyword">if</span> h : i &lt; arr.size <span class="hljs-keyword">then</span>
    insertionSortLoop (insertSorted arr â¨i, hâ©) (i + <span class="hljs-number">1</span>)
  <span class="hljs-keyword">else</span>
    arr
<span class="hljs-keyword">termination_by</span> insertionSortLoop arr i =&gt; arr.size - i
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">failed to prove termination, possible solutions:
  - Use `have`-expressions to prove the remaining goals
  - Use `termination_by` to specify a different well-founded relation
  - Use `decreasing_by` to specify your own tactic for discharging this kind of goal
Î± : Type u_1
instâ : Ord Î±
arr : Array Î±
i : Nat
h : i &lt; Array.size arr
â¢ Array.size (insertSorted arr { val := i, isLt := h }) - (i + 1) &lt; Array.size arr - i
</code></pre>
<p>The problem is that Lean has no way to know that <code class="hljs">insertSorted</code> returns an array that's the same size as the one it is passed.
In order to prove that <code class="hljs">insertionSortLoop</code> terminates, it is necessary to first prove that <code class="hljs">insertSorted</code> doesn't change the size of the array.
Copying the unproved termination condition from the error message to the function and "proving" it with <code class="hljs">sorry</code> allows the function to be temporarily accepted:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">S</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">o</span><span class="hljs-title">o</span><span class="hljs-title">p</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span> Array Î± :=
  <span class="hljs-keyword">if</span> h : i &lt; arr.size <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">have</span> : (insertSorted arr â¨i, hâ©).size - (i + <span class="hljs-number">1</span>) &lt; arr.size - i := <span class="hljs-keyword">by</span>
      <span class="hljs-tag">sorry</span>
    insertionSortLoop (insertSorted arr â¨i, hâ©) (i + <span class="hljs-number">1</span>)
  <span class="hljs-keyword">else</span>
    arr
<span class="hljs-keyword">termination_by</span> insertionSortLoop arr i =&gt; arr.size - i
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output warning hljs">declaration uses 'sorry'
</code></pre>
<p>Because <code class="hljs">insertSorted</code> is structurally recursive on the index of the element being inserted, the proof should be by induction on the index.
In the base case, the array is returned unchanged, so its length certainly does not change.
For the inductive step, the induction hypothesis is that a recursive call on the next smaller index will not change the length of the array.
There are two cases two consider: either the element has been fully inserted into the sorted region and the array is returned unchanged, in which case the length is also unchanged, or the element is swapped with the next one before the recursive call.
However, swapping two elements in an array doesn't change the size of it, and the induction hypothesis states that the recursive call with the next index returns an array that's the same size as its argument.
Thus, the size remains unchanged.</p>
<p>Translating this English-language theorem statement to Lean and proceeding using the techniques from this chapter is enough to prove the base case and make progress in the inductive step:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">d</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-params">(i : Fin arr.size)</span> <span class="hljs-symbol">:</span></span>
    (insertSorted arr i).size = arr.size := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">match</span> i <span class="hljs-keyword">with</span>
  | â¨j, isLtâ© =&gt;
    <span class="hljs-keyword">induction</span> j <span class="hljs-keyword">with</span>
    | zero =&gt; <span class="hljs-keyword">simp</span> [insertSorted]
    | succ j' ih =&gt;
      <span class="hljs-keyword">simp</span> [insertSorted]
</code></pre>
<p>The simplification using <code class="hljs">insertSorted</code> in the inductive step revealed the pattern match in <code class="hljs">insertSorted</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case succ
Î± : Type u_1
instâ : Ord Î±
arr : Array Î±
i : Fin (Array.size arr)
j' : Nat
ih : â (isLt : j' &lt; Array.size arr), Array.size (insertSorted arr { val := j', isLt := isLt }) = Array.size arr
isLt : Nat.succ j' &lt; Array.size arr
â¢ Array.size
      (match compare arr[j'] arr[{ val := Nat.succ j', isLt := isLt }] with
      | Ordering.lt =&gt; arr
      | Ordering.eq =&gt; arr
      | Ordering.gt =&gt;
        insertSorted
          (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) } { val := Nat.succ j', isLt := isLt })
          { val := j',
            isLt :=
              (_ :
                j' &lt;
                  Array.size
                    (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) }
                      { val := Nat.succ j', isLt := isLt })) }) =
    Array.size arr
</code></pre>
<p>When faced with a goal that includes <code class="hljs">if</code> or <code class="hljs">match</code>, the <code class="hljs">split</code> tactic (not to be confused with the <code class="hljs">split</code> function used in the definition of merge sort) replaces the goal with one new goal for each path of control flow:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">d</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-params">(i : Fin arr.size)</span> <span class="hljs-symbol">:</span></span>
    (insertSorted arr i).size = arr.size := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">match</span> i <span class="hljs-keyword">with</span>
  | â¨j, isLtâ© =&gt;
    <span class="hljs-keyword">induction</span> j <span class="hljs-keyword">with</span>
    | zero =&gt; <span class="hljs-keyword">simp</span> [insertSorted]
    | succ j' ih =&gt;
      <span class="hljs-keyword">simp</span> [insertSorted]
      <span class="hljs-keyword">split</span>
</code></pre>
<p>Additionally, each new goal has an assumption that indicates which branch led to that goal, named <code class="hljs">heqâ</code> in this case:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case succ.h_1
Î± : Type u_1
instâ : Ord Î±
arr : Array Î±
i : Fin (Array.size arr)
j' : Nat
ih : â (isLt : j' &lt; Array.size arr), Array.size (insertSorted arr { val := j', isLt := isLt }) = Array.size arr
isLt : Nat.succ j' &lt; Array.size arr
xâ : Ordering
heqâ : compare arr[j'] arr[{ val := Nat.succ j', isLt := isLt }] = Ordering.lt
â¢ Array.size arr = Array.size arr

case succ.h_2
Î± : Type u_1
instâ : Ord Î±
arr : Array Î±
i : Fin (Array.size arr)
j' : Nat
ih : â (isLt : j' &lt; Array.size arr), Array.size (insertSorted arr { val := j', isLt := isLt }) = Array.size arr
isLt : Nat.succ j' &lt; Array.size arr
xâ : Ordering
heqâ : compare arr[j'] arr[{ val := Nat.succ j', isLt := isLt }] = Ordering.eq
â¢ Array.size arr = Array.size arr

case succ.h_3
Î± : Type u_1
instâ : Ord Î±
arr : Array Î±
i : Fin (Array.size arr)
j' : Nat
ih : â (isLt : j' &lt; Array.size arr), Array.size (insertSorted arr { val := j', isLt := isLt }) = Array.size arr
isLt : Nat.succ j' &lt; Array.size arr
xâ : Ordering
heqâ : compare arr[j'] arr[{ val := Nat.succ j', isLt := isLt }] = Ordering.gt
â¢ Array.size
      (insertSorted
        (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) } { val := Nat.succ j', isLt := isLt })
        { val := j',
          isLt :=
            (_ :
              j' &lt;
                Array.size
                  (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) }
                    { val := Nat.succ j', isLt := isLt })) }) =
    Array.size arr
</code></pre>
<p>Rather than write proofs for both simple cases, adding <code class="hljs">&lt;;&gt; try rfl</code> after <code class="hljs">split</code> causes the two straightforward cases to disappear immediately, leaving only a single goal:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">d</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-params">(i : Fin arr.size)</span> <span class="hljs-symbol">:</span></span>
    (insertSorted arr i).size = arr.size := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">match</span> i <span class="hljs-keyword">with</span>
  | â¨j, isLtâ© =&gt;
    <span class="hljs-keyword">induction</span> j <span class="hljs-keyword">with</span>
    | zero =&gt; <span class="hljs-keyword">simp</span> [insertSorted]
    | succ j' ih =&gt;
      <span class="hljs-keyword">simp</span> [insertSorted]
      <span class="hljs-keyword">split</span> &lt;;&gt; <span class="hljs-keyword">try</span> <span class="hljs-keyword">rfl</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case succ.h_3
Î± : Type u_1
instâ : Ord Î±
arr : Array Î±
i : Fin (Array.size arr)
j' : Nat
ih : â (isLt : j' &lt; Array.size arr), Array.size (insertSorted arr { val := j', isLt := isLt }) = Array.size arr
isLt : Nat.succ j' &lt; Array.size arr
xâ : Ordering
heqâ : compare arr[j'] arr[{ val := Nat.succ j', isLt := isLt }] = Ordering.gt
â¢ Array.size
      (insertSorted
        (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) } { val := Nat.succ j', isLt := isLt })
        { val := j',
          isLt :=
            (_ :
              j' &lt;
                Array.size
                  (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) }
                    { val := Nat.succ j', isLt := isLt })) }) =
    Array.size arr
</code></pre>
<p>Unfortunately, the induction hypothesis is not strong enough to prove this goal.
The induction hypothesis states that calling <code class="hljs">insertSorted</code> on <code class="hljs">arr</code> leaves the size unchanged, but the proof goal is to show that the result of the recursive call with the result of swapping leaves the size unchanged.
Successfully completing the proof requires an induction hypothesis that works for <em>any</em> array that is passed to <code class="hljs">insertSorted</code> together with the smaller index as an argument</p>
<p>It is possible to get a strong induction hypothesis by using the <code class="hljs">generalizing</code> option to the <code class="hljs">induction</code> tactic.
This option brings additional assumptions from the context into the statement that's used to generate the base case, the induction hypothesis, and the goal to be shown in the inductive step.
Generalizing over <code class="hljs">arr</code> leads to a stronger hypothesis:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">d</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-params">(i : Fin arr.size)</span> <span class="hljs-symbol">:</span></span>
    (insertSorted arr i).size = arr.size := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">match</span> i <span class="hljs-keyword">with</span>
  | â¨j, isLtâ© =&gt;
    <span class="hljs-keyword">induction</span> j <span class="hljs-keyword">generalizing</span> arr <span class="hljs-keyword">with</span>
    | zero =&gt; <span class="hljs-keyword">simp</span> [insertSorted]
    | succ j' ih =&gt;
      <span class="hljs-keyword">simp</span> [insertSorted]
      <span class="hljs-keyword">split</span> &lt;;&gt; <span class="hljs-keyword">try</span> <span class="hljs-keyword">rfl</span>
</code></pre>
<p>In the resulting goal, <code class="hljs">arr</code> is now part of a "for all" statement in the inductive hypothesis:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case succ.h_3
Î± : Type u_1
instâ : Ord Î±
j' : Nat
ih :
  â (arr : Array Î±),
    Fin (Array.size arr) â
      â (isLt : j' &lt; Array.size arr), Array.size (insertSorted arr { val := j', isLt := isLt }) = Array.size arr
arr : Array Î±
i : Fin (Array.size arr)
isLt : Nat.succ j' &lt; Array.size arr
xâ : Ordering
heqâ : compare arr[j'] arr[{ val := Nat.succ j', isLt := isLt }] = Ordering.gt
â¢ Array.size
      (insertSorted
        (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) } { val := Nat.succ j', isLt := isLt })
        { val := j',
          isLt :=
            (_ :
              j' &lt;
                Array.size
                  (Array.swap arr { val := j', isLt := (_ : j' &lt; Array.size arr) }
                    { val := Nat.succ j', isLt := isLt })) }) =
    Array.size arr
</code></pre>
<p>However, this whole proof is beginning to get unmanageable.
The next step would be to introduce a variable standing for the length of the result of swapping, show that it is equal to <code class="hljs">arr.size</code>, and then show that this variable is also equal to the length of the array that results from the recursive call.
These equality statement can then be chained together to prove the goal.
It's much easier, however, to carefully reformulate the theorem statement such that the induction hypothesis is automatically strong enough and the variables are already introduced.
The reformulated statement reads:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">d</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(len : Nat)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span>
    (arr : Array Î±) â (isLt : i &lt; arr.size) â arr.size = len â
    (insertSorted arr â¨i, isLtâ©).size = len := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">skip</span>
</code></pre>
<p>This version of the theorem statement is easier to prove for a few reasons:</p>
<ol>
<li>Rather than bundling up the index and the proof of its validity in a <code class="hljs">Fin</code>, the index comes before the array.
This allows the induction hypothesis to naturally generalize over the array and the proof that <code class="hljs">i</code> is in bounds.</li>
<li>An abstract length <code class="hljs">len</code> is introduced to stand for <code class="hljs">array.size</code>.
Proof automation is often better at working with explicit statements of equality.</li>
</ol>
<p>The resulting proof state shows the statement that will be used to generate the induction hypothesis, as well as the base case and the goal of the inductive step:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
Î± : Type u_1
instâ : Ord Î±
len i : Nat
â¢ â (arr : Array Î±) (isLt : i &lt; Array.size arr),
    Array.size arr = len â Array.size (insertSorted arr { val := i, isLt := isLt }) = len
</code></pre>
<p>Compare the statement with the goals that result from the <code class="hljs">induction</code> tactic:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">d</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(len : Nat)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span>
    (arr : Array Î±) â (isLt : i &lt; arr.size) â arr.size = len â
    (insertSorted arr â¨i, isLtâ©).size = len := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> i <span class="hljs-keyword">with</span>
  | zero =&gt; <span class="hljs-keyword">skip</span>
  | succ i' ih =&gt; <span class="hljs-keyword">skip</span>
</code></pre>
<p>In the base case, each occurrence of <code class="hljs">i</code> has been replaced by <code class="hljs">0</code>.
Using <code class="hljs">intro</code> to introduce each assumption and then simplifying using <code class="hljs">insertSorted</code> will prove the goal, because <code class="hljs">insertSorted</code> at index <code class="hljs">zero</code> returns its argument unchanged:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case zero
Î± : Type u_1
instâ : Ord Î±
len : Nat
â¢ â (arr : Array Î±) (isLt : Nat.zero &lt; Array.size arr),
    Array.size arr = len â Array.size (insertSorted arr { val := Nat.zero, isLt := isLt }) = len
</code></pre>
<p>In the inductive step, the induction hypothesis has exactly the right strength.
It will be useful for <em>any</em> array, so long as that array has length <code class="hljs">len</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case succ
Î± : Type u_1
instâ : Ord Î±
len i' : Nat
ih :
  â (arr : Array Î±) (isLt : i' &lt; Array.size arr),
    Array.size arr = len â Array.size (insertSorted arr { val := i', isLt := isLt }) = len
â¢ â (arr : Array Î±) (isLt : Nat.succ i' &lt; Array.size arr),
    Array.size arr = len â Array.size (insertSorted arr { val := Nat.succ i', isLt := isLt }) = len
</code></pre>
<p>In the base case, <code class="hljs">simp</code> reduces the goal to <code class="hljs">arr.size = len</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">d</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(len : Nat)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span>
    (arr : Array Î±) â (isLt : i &lt; arr.size) â arr.size = len â
    (insertSorted arr â¨i, isLtâ©).size = len := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> i <span class="hljs-keyword">with</span>
  | zero =&gt;
    <span class="hljs-keyword">intro</span> arr isLt hLen
    <span class="hljs-keyword">simp</span> [insertSorted]
  | succ i' ih =&gt; <span class="hljs-keyword">skip</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case zero
Î± : Type u_1
instâ : Ord Î±
len : Nat
arr : Array Î±
isLt : Nat.zero &lt; Array.size arr
hLen : Array.size arr = len
â¢ Array.size arr = len
</code></pre>
<p>This can be proved using the assumption <code class="hljs">hLen</code>.
Adding the <code class="hljs">*</code> parameter to <code class="hljs">simp</code> instructs it to additionally use assumptions, which solves the goal:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">d</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(len : Nat)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span>
    (arr : Array Î±) â (isLt : i &lt; arr.size) â arr.size = len â
    (insertSorted arr â¨i, isLtâ©).size = len := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> i <span class="hljs-keyword">with</span>
  | zero =&gt;
    <span class="hljs-keyword">intro</span> arr isLt hLen
    <span class="hljs-keyword">simp</span> [insertSorted, *]
  | succ i' ih =&gt; <span class="hljs-keyword">skip</span>
</code></pre>
<p>In the inductive step, introducing assumptions and simplifying the goal results once again in a goal that contains a pattern match:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">d</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(len : Nat)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span>
    (arr : Array Î±) â (isLt : i &lt; arr.size) â (arr.size = len) â
    (insertSorted arr â¨i, isLtâ©).size = len := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> i <span class="hljs-keyword">with</span>
  | zero =&gt;
    <span class="hljs-keyword">intro</span> arr isLt hLen
    <span class="hljs-keyword">simp</span> [insertSorted, *]
  | succ i' ih =&gt;
    <span class="hljs-keyword">intro</span> arr isLt hLen
    <span class="hljs-keyword">simp</span> [insertSorted]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case succ
Î± : Type u_1
instâ : Ord Î±
len i' : Nat
ih :
  â (arr : Array Î±) (isLt : i' &lt; Array.size arr),
    Array.size arr = len â Array.size (insertSorted arr { val := i', isLt := isLt }) = len
arr : Array Î±
isLt : Nat.succ i' &lt; Array.size arr
hLen : Array.size arr = len
â¢ Array.size
      (match compare arr[i'] arr[{ val := Nat.succ i', isLt := isLt }] with
      | Ordering.lt =&gt; arr
      | Ordering.eq =&gt; arr
      | Ordering.gt =&gt;
        insertSorted
          (Array.swap arr { val := i', isLt := (_ : i' &lt; Array.size arr) } { val := Nat.succ i', isLt := isLt })
          { val := i',
            isLt :=
              (_ :
                i' &lt;
                  Array.size
                    (Array.swap arr { val := i', isLt := (_ : i' &lt; Array.size arr) }
                      { val := Nat.succ i', isLt := isLt })) }) =
    len
</code></pre>
<p>Using the <code class="hljs">split</code> tactic results in one goal for each pattern.
Once again, the first two goals result from branches without recursive calls, so the induction hypothesis is not necessary:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">d</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(len : Nat)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span>
    (arr : Array Î±) â (isLt : i &lt; arr.size) â (arr.size = len) â
    (insertSorted arr â¨i, isLtâ©).size = len := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> i <span class="hljs-keyword">with</span>
  | zero =&gt;
    <span class="hljs-keyword">intro</span> arr isLt hLen
    <span class="hljs-keyword">simp</span> [insertSorted, *]
  | succ i' ih =&gt;
    <span class="hljs-keyword">intro</span> arr isLt hLen
    <span class="hljs-keyword">simp</span> [insertSorted]
    <span class="hljs-keyword">split</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case succ.h_1
Î± : Type u_1
instâ : Ord Î±
len i' : Nat
ih :
  â (arr : Array Î±) (isLt : i' &lt; Array.size arr),
    Array.size arr = len â Array.size (insertSorted arr { val := i', isLt := isLt }) = len
arr : Array Î±
isLt : Nat.succ i' &lt; Array.size arr
hLen : Array.size arr = len
xâ : Ordering
heqâ : compare arr[i'] arr[{ val := Nat.succ i', isLt := isLt }] = Ordering.lt
â¢ Array.size arr = len

case succ.h_2
Î± : Type u_1
instâ : Ord Î±
len i' : Nat
ih :
  â (arr : Array Î±) (isLt : i' &lt; Array.size arr),
    Array.size arr = len â Array.size (insertSorted arr { val := i', isLt := isLt }) = len
arr : Array Î±
isLt : Nat.succ i' &lt; Array.size arr
hLen : Array.size arr = len
xâ : Ordering
heqâ : compare arr[i'] arr[{ val := Nat.succ i', isLt := isLt }] = Ordering.eq
â¢ Array.size arr = len

case succ.h_3
Î± : Type u_1
instâ : Ord Î±
len i' : Nat
ih :
  â (arr : Array Î±) (isLt : i' &lt; Array.size arr),
    Array.size arr = len â Array.size (insertSorted arr { val := i', isLt := isLt }) = len
arr : Array Î±
isLt : Nat.succ i' &lt; Array.size arr
hLen : Array.size arr = len
xâ : Ordering
heqâ : compare arr[i'] arr[{ val := Nat.succ i', isLt := isLt }] = Ordering.gt
â¢ Array.size
      (insertSorted
        (Array.swap arr { val := i', isLt := (_ : i' &lt; Array.size arr) } { val := Nat.succ i', isLt := isLt })
        { val := i',
          isLt :=
            (_ :
              i' &lt;
                Array.size
                  (Array.swap arr { val := i', isLt := (_ : i' &lt; Array.size arr) }
                    { val := Nat.succ i', isLt := isLt })) }) =
    len
</code></pre>
<p>Running <code class="hljs">try assumption</code> in each goal that results from <code class="hljs">split</code> eliminates both of the non-recursive goals:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">d</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(len : Nat)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span>
    (arr : Array Î±) â (isLt : i &lt; arr.size) â (arr.size = len) â
    (insertSorted arr â¨i, isLtâ©).size = len := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> i <span class="hljs-keyword">with</span>
  | zero =&gt;
    <span class="hljs-keyword">intro</span> arr isLt hLen
    <span class="hljs-keyword">simp</span> [insertSorted, *]
  | succ i' ih =&gt;
    <span class="hljs-keyword">intro</span> arr isLt hLen
    <span class="hljs-keyword">simp</span> [insertSorted]
    <span class="hljs-keyword">split</span> &lt;;&gt; <span class="hljs-keyword">try</span> <span class="hljs-keyword">assumption</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
case succ.h_3
Î± : Type u_1
instâ : Ord Î±
len i' : Nat
ih :
  â (arr : Array Î±) (isLt : i' &lt; Array.size arr),
    Array.size arr = len â Array.size (insertSorted arr { val := i', isLt := isLt }) = len
arr : Array Î±
isLt : Nat.succ i' &lt; Array.size arr
hLen : Array.size arr = len
xâ : Ordering
heqâ : compare arr[i'] arr[{ val := Nat.succ i', isLt := isLt }] = Ordering.gt
â¢ Array.size
      (insertSorted
        (Array.swap arr { val := i', isLt := (_ : i' &lt; Array.size arr) } { val := Nat.succ i', isLt := isLt })
        { val := i',
          isLt :=
            (_ :
              i' &lt;
                Array.size
                  (Array.swap arr { val := i', isLt := (_ : i' &lt; Array.size arr) }
                    { val := Nat.succ i', isLt := isLt })) }) =
    len
</code></pre>
<p>The new formulation of the proof goal, in which a constant <code class="hljs">len</code> is used for the lengths of all the arrays involved in the recursive function, falls nicely within the kinds of problems that <code class="hljs">simp</code> can solve.
This final proof goal can be solved by <code class="hljs">simp [*]</code>, because the assumptions that relate the array's length to <code class="hljs">len</code> are important:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">d</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(len : Nat)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span>
    (arr : Array Î±) â (isLt : i &lt; arr.size) â (arr.size = len) â
    (insertSorted arr â¨i, isLtâ©).size = len := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> i <span class="hljs-keyword">with</span>
  | zero =&gt;
    <span class="hljs-keyword">intro</span> arr isLt hLen
    <span class="hljs-keyword">simp</span> [insertSorted, *]
  | succ i' ih =&gt;
    <span class="hljs-keyword">intro</span> arr isLt hLen
    <span class="hljs-keyword">simp</span> [insertSorted]
    <span class="hljs-keyword">split</span> &lt;;&gt; <span class="hljs-keyword">try</span> <span class="hljs-keyword">assumption</span>
    <span class="hljs-keyword">simp</span> [*]
</code></pre>
<p>Finally, because <code class="hljs">simp [*]</code> can use assumptions, the <code class="hljs">try assumption</code> line can be replaced by <code class="hljs">simp [*]</code>, shortening the proof:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantac hljs"><span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">d</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(len : Nat)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span>
    (arr : Array Î±) â (isLt : i &lt; arr.size) â (arr.size = len) â
    (insertSorted arr â¨i, isLtâ©).size = len := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> i <span class="hljs-keyword">with</span>
  | zero =&gt;
    <span class="hljs-keyword">intro</span> arr isLt hLen
    <span class="hljs-keyword">simp</span> [insertSorted, *]
  | succ i' ih =&gt;
    <span class="hljs-keyword">intro</span> arr isLt hLen
    <span class="hljs-keyword">simp</span> [insertSorted]
    <span class="hljs-keyword">split</span> &lt;;&gt; <span class="hljs-keyword">simp</span> [*]
</code></pre>
<p>This proof can now be used to replace the <code class="hljs">sorry</code> in <code class="hljs">insertionSortLoop</code>.
Providing <code class="hljs">arr.size</code> as the <code class="hljs">len</code> argument to the theorem causes the final conclusion to be <code class="hljs">(insertSorted arr â¨i, isLtâ©).size = arr.size</code>, so the rewrite ends with a very manageable proof goal:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantacnorfl hljs">  <span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">S</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">o</span><span class="hljs-title">o</span><span class="hljs-title">p</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span> Array Î± :=
    <span class="hljs-keyword">if</span> h : i &lt; arr.size <span class="hljs-keyword">then</span>
      <span class="hljs-keyword">have</span> : (insertSorted arr â¨i, hâ©).size - (i + <span class="hljs-number">1</span>) &lt; arr.size - i := <span class="hljs-keyword">by</span>
        <span class="hljs-keyword">rw</span> [insert_sorted_size_eq arr.size i arr h <span class="hljs-built_in">rfl</span>]
      insertionSortLoop (insertSorted arr â¨i, hâ©) (i + <span class="hljs-number">1</span>)
    <span class="hljs-keyword">else</span>
      arr
<span class="hljs-keyword">termination_by</span> insertionSortLoop arr i =&gt; arr.size - i
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output error hljs">unsolved goals
Î± : Type ?u.22173
instâ : Ord Î±
arr : Array Î±
i : Nat
h : i &lt; Array.size arr
â¢ Array.size arr - (i + 1) &lt; Array.size arr - i
</code></pre>
<p>The proof <code class="hljs">Nat.sub_succ_lt_self</code> is part of Lean's standard library.
It's type is <code class="hljs">â (a i : Nat), i &lt; a â a - (i + 1) &lt; a - i</code>, which is exactly what's needed:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantacnorfl hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">S</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">o</span><span class="hljs-title">o</span><span class="hljs-title">p</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span> Array Î± :=
  <span class="hljs-keyword">if</span> h : i &lt; arr.size <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">have</span> : (insertSorted arr â¨i, hâ©).size - (i + <span class="hljs-number">1</span>) &lt; arr.size - i := <span class="hljs-keyword">by</span>
      <span class="hljs-keyword">rw</span> [insert_sorted_size_eq arr.size i arr h <span class="hljs-built_in">rfl</span>]
      <span class="hljs-keyword">simp</span> [Nat.sub_succ_lt_self, *]
    insertionSortLoop (insertSorted arr â¨i, hâ©) (i + <span class="hljs-number">1</span>)
  <span class="hljs-keyword">else</span>
    arr
<span class="hljs-keyword">termination_by</span> insertionSortLoop arr i =&gt; arr.size - i
</code></pre>
<h2 id="the-driver-function"><a class="header" href="#the-driver-function">The Driver Function</a></h2>
<p>Insertion sort itself calls <code class="hljs">insertionSortLoop</code>, initializing the index that demarcates the sorted region of the array from the unsorted region to <code class="hljs">0</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">S</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-symbol">:</span></span> Array Î± :=
   insertionSortLoop arr <span class="hljs-number">0</span>
</code></pre>
<p>A few quick tests show the function is at least not blatantly wrong:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> insertionSort #[<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">#[1, 3, 4, 7]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-keyword">#eval</span> insertionSort #[ <span class="hljs-string">"quartz"</span>, <span class="hljs-string">"marble"</span>, <span class="hljs-string">"granite"</span>, <span class="hljs-string">"hematite"</span>]
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-output info hljs">#["granite", "hematite", "marble", "quartz"]
</code></pre>
<h2 id="is-this-really-insertion-sort"><a class="header" href="#is-this-really-insertion-sort">Is This Really Insertion Sort?</a></h2>
<p>Insertion sort is <em>defined</em> to be an in-place sorting algorithm.
What makes it useful, despite its quadratic worst-case run time, is that it is a stable sorting algorithm that doesn't allocate extra space and that handles almost-sorted data efficiently.
If each iteration of the inner loop allocated a new array, then the algorithm wouldn't <em>really</em> be insertion sort.</p>
<p>Lean's array operations, such as <code class="hljs">Array.set</code> and <code class="hljs">Array.swap</code>, check whether the array in question has a reference count that is greater than one.
If so, then the array is visible to multiple parts of the code, which means that it must be copied.
Otherwise, Lean would no longer be a pure functional language.
However, when the reference count is exactly one, there are no other potential observers of the value.
In these cases, the array primitives mutate the array in place.
What other parts of the program don't know can't hurt them.</p>
<p>Lean's proof logic works at the level of pure functional programs, not the underlying implementation.
This means that the best way to discover whether a program unnecessarily copies data is to test it.
Adding calls to <code class="hljs">dbgTraceIfShared</code> at each point where mutation is desired causes the provided message to be printed to <code class="hljs">stderr</code> when the value in question has more than one reference.</p>
<p>Insertion sort has precisely one place that is at risk of copying rather than mutating: the call to <code class="hljs">Array.swap</code>.
Replacing <code class="hljs">arr.swap â¨i', by assumptionâ© i</code> with <code class="hljs">((dbgTraceIfShared "array to swap" arr).swap â¨i', by assumptionâ© i)</code> causes the program to emit <code class="hljs">shared RC array to swap</code> whenever it is unable to mutate the array.
However, this change to the program changes the proofs as well, because now there's a call to an additional function.
Because <code class="hljs">dbgTraceIfShared</code> returns its second argument directly, adding it to the calls to <code class="hljs">simp</code> is enough to fix the proofs.</p>
<p>The complete instrumented code for insertion sort is:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-leantacnorfl hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">S</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">d</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-params">(i : Fin arr.size)</span> <span class="hljs-symbol">:</span></span> Array Î± :=
  <span class="hljs-keyword">match</span> i <span class="hljs-keyword">with</span>
  | â¨<span class="hljs-number">0</span>, _â© =&gt; arr
  | â¨i' + <span class="hljs-number">1</span>, _â© =&gt;
    <span class="hljs-keyword">have</span> : i' &lt; arr.size := <span class="hljs-keyword">by</span>
      <span class="hljs-keyword">simp</span> [Nat.lt_of_succ_lt, *]
    <span class="hljs-keyword">match</span> Ord.compare arr[i'] arr[i] <span class="hljs-keyword">with</span>
    | .lt | .eq =&gt; arr
    | .gt =&gt;
      insertSorted
        ((dbgTraceIfShared <span class="hljs-string">"array to swap"</span> arr).<span class="hljs-built_in">swap</span> â¨i', <span class="hljs-keyword">by</span> <span class="hljs-keyword">assumption</span>â© i)
        â¨i', <span class="hljs-keyword">by</span> <span class="hljs-keyword">simp</span> [dbgTraceIfShared, *]â©

<span class="hljs-theorem"><span class="hljs-keyword">theorem</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">e</span><span class="hljs-title">d</span><span class="hljs-title">_</span><span class="hljs-title">s</span><span class="hljs-title">i</span><span class="hljs-title">z</span><span class="hljs-title">e</span><span class="hljs-title">_</span><span class="hljs-title">e</span><span class="hljs-title">q</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(len : Nat)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span>
    (arr : Array Î±) â (isLt : i &lt; arr.size) â (arr.size = len) â
    (insertSorted arr â¨i, isLtâ©).size = len := <span class="hljs-keyword">by</span>
  <span class="hljs-keyword">induction</span> i <span class="hljs-keyword">with</span>
  | zero =&gt;
    <span class="hljs-keyword">intro</span> arr isLt hLen
    <span class="hljs-keyword">simp</span> [insertSorted, *]
  | succ i' ih =&gt;
    <span class="hljs-keyword">intro</span> arr isLt hLen
    <span class="hljs-keyword">simp</span> [insertSorted, dbgTraceIfShared]
    <span class="hljs-keyword">split</span> &lt;;&gt; <span class="hljs-keyword">simp</span> [*]

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">S</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">o</span><span class="hljs-title">o</span><span class="hljs-title">p</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-params">(i : Nat)</span> <span class="hljs-symbol">:</span></span> Array Î± :=
  <span class="hljs-keyword">if</span> h : i &lt; arr.size <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">have</span> : (insertSorted arr â¨i, hâ©).size - (i + <span class="hljs-number">1</span>) &lt; arr.size - i := <span class="hljs-keyword">by</span>
      <span class="hljs-keyword">rw</span> [insert_sorted_size_eq arr.size i arr h <span class="hljs-built_in">rfl</span>]
      <span class="hljs-keyword">simp</span> [Nat.sub_succ_lt_self, *]
    insertionSortLoop (insertSorted arr â¨i, hâ©) (i + <span class="hljs-number">1</span>)
  <span class="hljs-keyword">else</span>
    arr
<span class="hljs-keyword">termination_by</span> insertionSortLoop arr i =&gt; arr.size - i

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">s</span><span class="hljs-title">e</span><span class="hljs-title">r</span><span class="hljs-title">t</span><span class="hljs-title">i</span><span class="hljs-title">o</span><span class="hljs-title">n</span><span class="hljs-title">S</span><span class="hljs-title">o</span><span class="hljs-title">r</span><span class="hljs-title">t</span> <span class="hljs-params">[Ord Î±]</span> <span class="hljs-params">(arr : Array Î±)</span> <span class="hljs-symbol">:</span></span> Array Î± :=
  insertionSortLoop arr <span class="hljs-number">0</span>
</code></pre>
<p>A bit of cleverness is required to check whether the instrumentation actually works.
First off, the Lean compiler aggressively optimizes function calls away when all their arguments are known at compile time.
Simply writing a program that applies <code class="hljs">insertionSort</code> to a large array is not sufficient, because the resulting compiled code may contain only the sorted array as a constant.
The easiest way to ensure that the compiler doesn't optimize away the sorting routine is to read the array from <code class="hljs">stdin</code>.
Secondly, the compiler performs dead code elimination.
Adding extra <code class="hljs">let</code>s to the program won't necessarily result in more references in running code if the <code class="hljs">let</code>-bound variables are never used.
To ensure that the extra reference is not eliminated entirely, it's important to ensure that the extra reference is somehow used.</p>
<p>The first step in testing the instrumentation is to write <code class="hljs">getLines</code>, which reads an array of lines from standard input:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-title">e</span><span class="hljs-title">t</span><span class="hljs-title">L</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">e</span><span class="hljs-title">s</span> <span class="hljs-symbol">:</span></span> IO (Array String) := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> stdin â IO.getStdin
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> lines : Array String := #[]
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> currLine â stdin.getLine
  <span class="hljs-keyword">while</span> !currLine.isEmpty <span class="hljs-keyword">do</span>
     <span class="hljs-comment">-- Drop trailing newline:</span>
    lines := lines.push (currLine.dropRight <span class="hljs-number">1</span>)
    currLine â stdin.getLine
  pure lines
</code></pre>
<p><code class="hljs">IO.FS.Stream.getLine</code> returns a complete line of text, including the trailing newline.
It returns <code class="hljs">""</code> when the end-of-file marker has been reached.</p>
<p>Next, two separate <code class="hljs">main</code> routines are needed.
Both read the array to be sorted from standard input, ensuring that the calls to <code class="hljs">insertionSort</code> won't be replaced by their return values at compile time.
Both then print to the console, ensuring that the calls to <code class="hljs">insertionSort</code> won't be optimized away entirely.
One of them prints only the sorted array, while the other prints both the sorted array and the original array.
The second function should trigger a warning that <code class="hljs">Array.swap</code> had to allocate a new array:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">U</span><span class="hljs-title">n</span><span class="hljs-title">i</span><span class="hljs-title">q</span><span class="hljs-title">u</span><span class="hljs-title">e</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> lines â getLines
  <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> insertionSort lines <span class="hljs-keyword">do</span>
    IO.println line

<span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">n</span><span class="hljs-title">S</span><span class="hljs-title">h</span><span class="hljs-title">a</span><span class="hljs-title">r</span><span class="hljs-title">e</span><span class="hljs-title">d</span> <span class="hljs-symbol">:</span></span> IO Unit := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">let</span> lines â getLines
  IO.println <span class="hljs-string">"--- Sorted lines: ---"</span>
  <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> insertionSort lines <span class="hljs-keyword">do</span>
    IO.println line

  IO.println <span class="hljs-string">""</span>
  IO.println <span class="hljs-string">"--- Original data: ---"</span>
  <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines <span class="hljs-keyword">do</span>
    IO.println line
</code></pre>
<p>The actual <code class="hljs">main</code> simply selects one of the two main actions based on the provided command-line arguments:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs"><span class="hljs-theorem"><span class="hljs-keyword">def</span> <span class="hljs-title">m</span><span class="hljs-title">a</span><span class="hljs-title">i</span><span class="hljs-title">n</span> <span class="hljs-params">(args : List String)</span> <span class="hljs-symbol">:</span></span> IO UInt32 := <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">match</span> args <span class="hljs-keyword">with</span>
  | [<span class="hljs-string">"--shared"</span>] =&gt; mainShared; pure <span class="hljs-number">0</span>
  | [<span class="hljs-string">"--unique"</span>] =&gt; mainUnique; pure <span class="hljs-number">0</span>
  | _ =&gt;
    IO.println <span class="hljs-string">"Expected single argument, either \"--shared\" or \"--unique\""</span>
    pure <span class="hljs-number">1</span>
</code></pre>
<p>Running it with no arguments produces the expected usage information:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">$ sort
Expected single argument, either "--shared" or "--unique"
</code></pre>
<p>The file <code class="hljs">test-data</code> contains the following rocks:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">schist
feldspar
diorite
pumice
obsidian
shale
gneiss
marble
flint
</code></pre>
<p>Using the instrumented insertion sort on these rocks results them being printed in alphabetical order:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">$ sort --unique &lt; test-data
diorite
feldspar
flint
gneiss
marble
obsidian
pumice
schist
shale
</code></pre>
<p>However, the version in which a reference is retained to the original array results in a notification on <code class="hljs">stderr</code> (namely, <code class="hljs">shared RC array to swap</code>) from the first call to <code class="hljs">Array.swap</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="hljs">$ sort --shared &lt; test-data
shared RC array to swap
--- Sorted lines: ---
diorite
feldspar
flint
gneiss
marble
obsidian
pumice
schist
shale

--- Original data: ---
schist
feldspar
diorite
pumice
obsidian
shale
gneiss
marble
flint
</code></pre>
<p>The fact that only a single <code class="hljs">shared RC</code> notification appears means that the array is copied only once.
This is because the copy that results from the call to <code class="hljs">Array.swap</code> is itself unique, so no further copies need to be made.
In an imperative language, subtle bugs can result from forgetting to explicitly copy an array before passing it by reference.
When running <code class="hljs">sort --shared</code>, the array is copied as needed to preserve the pure functional meaning of Lean programs, but no more.</p>
<h2 id="other-opportunities-for-mutation"><a class="header" href="#other-opportunities-for-mutation">Other Opportunities for Mutation</a></h2>
<p>The use of mutation instead of copying when references are unique is not limited to array update operators.
Lean also attempts to "recycle" constructors whose reference counts are about to fall to zero, reusing them instead of allocating new data.
This means, for instance, that <code class="hljs">List.map</code> will mutate a linked list in place, at least in cases when nobody could possibly notice.
One of the most important steps in optimizing hot loops in Lean code is making sure that the data being modified is not referred to from multiple locations.</p>
<h2 id="exercises-26"><a class="header" href="#exercises-26">Exercises</a></h2>
<ul>
<li>
<p>Write a function that reverses arrays. Test that if the input array has a reference count of one, then your function does not allocate a new array.</p>
</li>
<li>
<p>Implement either merge sort or quicksort for arrays. Prove that your implementation terminates, and test that it doesn't allocate more arrays than expected. This is a challenging exercise!</p>
</li>
</ul>
<div style="break-before:page;page-break-before:always"></div><h1 id="special-types"><a class="header" href="#special-types">Special Types</a></h1>
<p>Understanding the representation of data in memory is very important.
Usually, the representation can be understood from the definition of a datatype.
Each constructor corresponds to an object in memory that has a header that includes a tag and a reference count.
The constructor's arguments are each represented by a pointer to some other object.
In other words, <code class="hljs">List</code> really is a linked list and extracting a field from a <code class="hljs">structure</code> really does just chase a pointer.</p>
<p>There are, however, some important exceptions to this rule.
A number of types are treated specially by the compiler.
For example, the type <code class="hljs">UInt32</code> is defined as <code class="hljs">Fin (2 ^ 32)</code>, but it is replaced at run-time with an actual native implementation based on machine words.
Similarly, even though the definition of <code class="hljs">Nat</code> suggests an implementation similar to <code class="hljs">List Unit</code>, the actual run-time representation uses immediate machine words for sufficiently-small numbers and an efficient arbitrary-precision arithmetic library for larger numbers.
The Lean compiler translates from definitions that use pattern matching into the appropriate operations for this representation, and calls to operations like addition and subtraction are mapped to fast operations from the underlying arithmetic library.
After all, addition should not take time linear in the size of the addends.</p>
<p>The fact that some types have special representations also means that care is needed when working with them.
Most of these types consist of a <code class="hljs">structure</code> that is treated specially by the compiler.
With these structures, using the constructor or the field accessors directly can trigger an expensive conversion from an efficient representation to a slow one that is convenient for proofs.
For example, <code class="hljs">String</code> is defined as a structure that contains a list of characters, but the run-time representation of strings uses UTF-8, not linked lists of pointers to characters.
Applying the constructor to a list of characters creates a byte array that encodes them in UTF-8, and accessing the field of the structure takes time linear in the length of the string to decode the UTF-8 representation and allocate a linked list.
Arrays are represented similarly.
From the logical perspective, arrays are structures that contain a list of array elements, but the run-time representation is a dynamically-sized array.
At run time, the constructor translates the list into an array, and the field accessor allocates a linked list from the array.
The various array operations are replaced with efficient versions by the compiler that mutate the array when possible instead of allocating a new one.</p>
<p>Both types themselves and proofs of propositions are completely erased from compiled code.
In other words, they take up no space, and any computations that might have been performed as part of a proof are similarly erased.
This means that proofs can take advantage of the convenient interface to strings and arrays as inductively-defined lists, including using induction to prove things about them, without imposing slow conversion steps while the program is running.
For these built-in types, a convenient logical representation of the data does not imply that the program must be slow.</p>
<p>If a structure type has only a single non-type non-proof field, then the constructor itself disappears at run time, being replaced with its single argument.
In other words, a subtype is represented identically to its underlying type, rather than with an extra layer of indirection.
Similarly, <code class="hljs">Fin</code> is just <code class="hljs">Nat</code> in memory, and single-field structures can be created to keep track of different uses of <code class="hljs">Nat</code>s or <code class="hljs">String</code>s without paying a performance penalty.
If a constructor has no non-type non-proof arguments, then the constructor also disappears and is replaced with a constant value where the pointer would otherwise be used.
This means that <code class="hljs">true</code>, <code class="hljs">false</code>, and <code class="hljs">none</code> are constant values, rather than pointers to heap-allocated objects.</p>
<p>The following types have special representations:</p>
<table><thead><tr><th>Type</th><th>Logical representation</th><th>Run-time Representation</th></tr></thead><tbody>
<tr><td><code class="hljs">Nat</code></td><td>Unary, with one pointer from each <code class="hljs">Nat.succ</code></td><td>Efficient arbitrary-precision integers</td></tr>
<tr><td><code class="hljs">Int</code></td><td>A sum type with constructors for positive or negative values, each containing a <code class="hljs">Nat</code></td><td>Efficient arbitrary-precision integers</td></tr>
<tr><td><code class="hljs">UInt8</code>, <code class="hljs">UInt16</code>, <code class="hljs">UInt32</code>, <code class="hljs">UInt64</code></td><td>A <code class="hljs">Fin</code> with an appropriate bound</td><td>Fixed-precision machine integers</td></tr>
<tr><td><code class="hljs">Char</code></td><td>A <code class="hljs">UInt32</code> paired with a proof that it's a valid code point</td><td>Ordinary characters</td></tr>
<tr><td><code class="hljs">String</code></td><td>A structure that contains a <code class="hljs">List Char</code> in a field called <code class="hljs">data</code></td><td>UTF-8-encoded string</td></tr>
<tr><td><code class="hljs">Array Î±</code></td><td>A structure that contains a <code class="hljs">List Î±</code> in a field called <code class="hljs">data</code></td><td>Packed arrays of pointers to <code class="hljs">Î±</code> values</td></tr>
<tr><td><code class="hljs">Sort u</code></td><td>A type</td><td>Erased completely</td></tr>
<tr><td>Proofs of propositions</td><td>Whatever data is suggested by the proposition when considered as a type of evidence</td><td>Erased completely</td></tr>
</tbody></table>
<h2 id="exercise-4"><a class="header" href="#exercise-4">Exercise</a></h2>
<p>The <a href="https://leanprover.github.io/functional_programming_in_lean/type-classes/pos.html">definition of <code class="hljs">Pos</code></a> does not take advantage of Lean's compilation of <code class="hljs">Nat</code> to an efficient type.
At run time, it is essentially a linked list.
Alternatively, a subtype can be defined that allows Lean's fast <code class="hljs">Nat</code> type to be used internally, as described <a href="https://leanprover.github.io/functional_programming_in_lean/functor-applicative-monad/applicative.html#subtypes">in the initial section on subtypes</a>.
At run time, the proof will be erased.
Because the resulting structure has only a single data field, it is represented as that field, which means that this new representation of <code class="hljs">Pos</code> is identical to that of <code class="hljs">Nat</code>.</p>
<p>After proving the theorem <code class="hljs">â {n k : Nat}, n â  0 â k â  0 â n + k â  0</code>, define instances of <code class="hljs">ToString</code>, and <code class="hljs">Add</code> for this new representation of <code class="hljs">Pos</code>. Then, define an instance of <code class="hljs">Mul</code>, proving any necessary theorems along the way.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="summary-7"><a class="header" href="#summary-7">Summary</a></h1>
<h2 id="tail-recursion-1"><a class="header" href="#tail-recursion-1">Tail Recursion</a></h2>
<p>Tail recursion is recursion in which the results of recursive calls are returned immediately, rather than being used in some other way.
These recursive calls are called <em>tail calls</em>.
Tail calls are interesting because they can be compiled to a jump instruction rather than a call instruction, and the current stack frame can be re-used instead of pushing a new frame.
In other words, tail-recursive functions are actually loops.</p>
<p>A common way to make a recursive function faster is to rewrite it in accumulator-passing style.
Instead of using the call stack to remember what is to be done with the result of a recursive call, an additional argument called an <em>accumulator</em> is used to collect this information.
For example, an accumulator for a tail-recursive function that reverses a list contains the already-seen list entries, in reverse order.</p>
<p>In Lean, only self-tail-calls are optimized into loops.
In other words, two functions that each end with a tail call to the other will not be optimized.</p>
<h2 id="reference-counting-and-in-place-updates"><a class="header" href="#reference-counting-and-in-place-updates">Reference Counting and In-Place Updates</a></h2>
<p>Rather than using a tracing garbage collector, as is done in Java, C#, and most JavaScript implementations, Lean uses reference counting for memory management.
This means that each value in memory contains a field that tracks how many other values refer to it, and the run-time system maintains these counts as references appear or disappear.
Reference counting is also used in Python, PHP, and Swift.</p>
<p>When asked to allocate a fresh object, Lean's run-time system is able to recycle existing objects whose reference counts are falling to zero.
Additionally, array operations such as <code class="hljs">Array.set</code> and <code class="hljs">Array.swap</code> will mutate an array if its reference count is one, rather than allocating a modified copy.
If <code class="hljs">Array.swap</code> holds the only reference to an array, then no other part of the program can tell that it was mutated rather than copied.</p>
<p>Writing efficient code in Lean requires the use of tail recursion and being careful to ensure that large arrays are used uniquely.
While tail calls can be identified by inspecting the function's definition, understanding whether a value is referred to uniquely may require reading the whole program.
The debugging helper <code class="hljs">dbgTraceIfShared</code> can be used at key locations in the program to check that a value is not shared.</p>
<h2 id="proving-programs-correct"><a class="header" href="#proving-programs-correct">Proving Programs Correct</a></h2>
<p>Rewriting a program in accumulator-passing style, or making other transformations that make it run faster, can also make it more difficult to understand.
It can be useful to keep the original version of the program that is more clearly correct, and then use it as an executable specification for the optimized version.
While techniques such as unit testing work just as well in Lean as in any other language, Lean also enables the use of mathematical proofs that completely ensure that both versions of the function return the same result for <em>all possible</em> inputs.</p>
<p>Typically, proving that two functions are equal is done using function extensionality (the <code class="hljs">funext</code> tactic), which is the principle that two functions are equal if they return the same values for every input.
If the functions are recursive, then induction is usually a good way to prove that their outputs are the same.
Usually, the recursive definition of the function will make recursive calls on one particular argument; this argument is a good choice for induction.
In some cases, the induction hypothesis is not strong enough.
Fixing this problem usually requires thought about how to construct a more general version of the theorem statement that provides induction hypotheses that are strong enough.
In particular, to prove that a function is equivalent to an accumulator-passing version, a theorem statement that relates arbitrary initial accumulator values to the final result of the original function is needed.</p>
<h2 id="safe-array-indices-1"><a class="header" href="#safe-array-indices-1">Safe Array Indices</a></h2>
<p>The type <code class="hljs">Fin n</code> represents natural numbers that are strictly less than <code class="hljs">n</code>.
<code class="hljs">Fin</code> is short for "finite".
As with subtypes, a <code class="hljs">Fin n</code> is a structure that contains a <code class="hljs">Nat</code> and a proof that this <code class="hljs">Nat</code> is less than <code class="hljs">n</code>.
There are no values of type <code class="hljs">Fin 0</code>.</p>
<p>If <code class="hljs">arr</code> is an <code class="hljs">Array Î±</code>, then <code class="hljs">Fin arr.size</code> always contains a number that is a suitable index into <code class="hljs">arr</code>.
Many of the built-in array operators, such as <code class="hljs">Array.swap</code>, take <code class="hljs">Fin</code> values as arguments rather than separated proof objects.</p>
<p>Lean provides instances of most of the useful numeric type classes for <code class="hljs">Fin</code>.
The <code class="hljs">OfNat</code> instances for <code class="hljs">Fin</code> perform modular arithmetic rather than failing at compile time if the number provided is larger than the <code class="hljs">Fin</code> can accept.</p>
<h2 id="provisional-proofs"><a class="header" href="#provisional-proofs">Provisional Proofs</a></h2>
<p>Sometimes, it can be useful to pretend that a statement is proved without actually doing the work of proving it.
This can be useful when making sure that a proof of a statement would be suitable for some task, such as a rewrite in another proof, determining that an array access is safe, or showing that a recursive call is made on a smaller value than the original argument.
It's very frustrating to spend time proving something, only to discover that some other proof would have been more useful.</p>
<p>The <code class="hljs">sorry</code> tactic causes Lean to provisionally accept a statement as if it were a real proof.
It can be seen as analogous to a stub method that throws a <code class="hljs">NotImplementedException</code> in C#.
Any proof that relies on <code class="hljs">sorry</code> includes a warning in Lean.</p>
<p>Be careful!
The <code class="hljs">sorry</code> tactic can prove <em>any</em> statement, even false statements.
Proving that <code class="hljs">3 &lt; 2</code> can cause an out-of-bounds array access to persist to runtime, unexpectedly crashing a program.
Using <code class="hljs">sorry</code> is convenient during development, but keeping it in the code is dangerous.</p>
<h2 id="proving-termination-1"><a class="header" href="#proving-termination-1">Proving Termination</a></h2>
<p>When a recursive function does not use structural recursion, Lean cannot automatically determine that it terminates.
In these situations, the function could just be marked <code class="hljs">partial</code>.
However, it is also possible to provide a proof that the function terminates.</p>
<p>Partial functions have a key downside: they can't be unfolded during type checking or in proofs.
This means that Lean's value as an interactive theorem prover can't be applied to them.
Additionally, showing that a function that is expected to terminate actually always does terminate removes one more potential source of bugs.</p>
<p>The <code class="hljs">termination_by</code> clause that's allowed at the end of a function can be used to specify the reason why a recursive function terminates.
The clause maps the function's arguments to an expression that is expected to be smaller for each recursive call.
Some examples of expressions that might decrease are the difference between a growing index into an array and the array's size, the length of a list that's cut in half at each recursive call, or a pair of lists, exactly one of which shrinks on each recursive call.</p>
<p>Lean contains proof automation that can automatically determine that some expressions shrink with each call, but many interesting programs will require manual proofs.
These proofs can be provided with <code class="hljs">have</code>, a version of <code class="hljs">let</code> that's intended for locally providing proofs rather than values.</p>
<p>A good way to write recursive functions is to begin by declaring them <code class="hljs">partial</code> and debugging them with testing until they return the right answers.
Then, <code class="hljs">partial</code> can be removed and replaced with a <code class="hljs">termination_by</code> clause.
Lean will place error highlights on each recursive call for which a proof is needed that contains the statement that needs to be proved.
Each of these statements can be placed in a <code class="hljs">have</code>, with the proof being <code class="hljs">sorry</code>.
If Lean accepts the program and it still passes its tests, the final step is to actually prove the theorems that enable Lean to accept it.
This approach can prevent wasting time on proving that a buggy program terminates.</p>
<div style="break-before:page;page-break-before:always"></div><h1 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h1>
<p>This book introduces the very basics of functional programming in Lean, including a tiny amount of interactive theorem proving.
Using dependently-typed functional languages like Lean is a deep topic, and much can be said.
Depending on your interests, the following resources might be useful for learning Lean 4.</p>
<h2 id="learning-lean"><a class="header" href="#learning-lean">Learning Lean</a></h2>
<p>Lean 4 itself is described in the following resources:</p>
<ul>
<li><a href="https://lean-lang.org/theorem_proving_in_lean4/">Theorem Proving in Lean 4</a> is a tutorial on writing proofs using Lean.</li>
<li><a href="https://lean-lang.org/lean4/doc/">The Lean 4 Manual</a> provides a reference for the language and its features. At the time of writing, it is still incomplete, but it describes many aspects of Lean in greater detail than this book.</li>
<li><a href="https://djvelleman.github.io/HTPIwL/">How To Prove It With Lean</a> is a Lean-based accompaniment to the well-regarded textbook <a href="https://www.cambridge.org/highereducation/books/how-to-prove-it/6D2965D625C6836CD4A785A2C843B3DA"><em>How To Prove It</em></a> that provides an introduction to writing paper-and-pencil mathematical proofs.</li>
<li><a href="https://github.com/arthurpaulino/lean4-metaprogramming-book">Metaprogramming in Lean 4</a> provides an overview of Lean's extension mechanisms, from infix operators and notations to macros, custom tactics, and full-on custom embedded languages.</li>
<li><a href="https://lean-lang.org/functional_programming_in_lean/">Functional Programming in Lean</a> may be interesting to readers who enjoy jokes about recursion.</li>
</ul>
<p>However, the best way to continue learning Lean is to start reading and writing code, consulting the documentation when you get stuck.
Additionally, the <a href="https://leanprover.zulipchat.com/">Lean Zulip</a> is an excellent place to meet other Lean users, ask for help, and help others.</p>
<h2 id="the-standard-library"><a class="header" href="#the-standard-library">The Standard Library</a></h2>
<p>Out of the box, Lean itself includes a fairly minimal library.
Lean is self-hosted, and the included code is just enough to implement Lean itself.
For many applications, a larger standard library is needed.</p>
<p><a href="https://github.com/leanprover/std4">std4</a> is an in-progress standard library that includes many data structures, tactics, type class instances, and functions that are out of scope for the Lean compiler itself.
To use <code class="hljs">std4</code>, the first step is to find a commit in its history that's compatible with the version of Lean 4 that you're using (that is, one in which the <code class="hljs">lean-toolchain</code> file matches the one in your project).
Then, add the following to the top level of your <code class="hljs">lakefile.lean</code>, where <code class="hljs">COMMIT_HASH</code> is the appropriate version:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-lean hljs">require std <span class="hljs-built_in">from</span> git
  <span class="hljs-string">"https://github.com/leanprover/std4/"</span> @ <span class="hljs-string">"COMMIT_HASH"</span>
</code></pre>
<h2 id="mathematics-in-lean"><a class="header" href="#mathematics-in-lean">Mathematics in Lean</a></h2>
<p>Most resources for mathematicians are written for Lean 3.
A wide selection are available at <a href="https://leanprover-community.github.io/learn.html">the community site</a>.
To get started doing mathematics in Lean 4, it is probably easiest to participate in the process of porting the mathematics library <code class="hljs">mathlib</code> from Lean 3 to Lean 4.
Please see the <a href="https://github.com/leanprover-community/mathlib4"><code class="hljs">mathlib4</code> README</a> for further information.</p>
<h2 id="using-dependent-types-in-computer-science"><a class="header" href="#using-dependent-types-in-computer-science">Using Dependent Types in Computer Science</a></h2>
<p>Coq is a language that has a lot in common with Lean.
For computer scientists, the <a href="https://softwarefoundations.cis.upenn.edu/">Software Foundations</a> series of interactive textbooks provides an excellent introduction to applications of Coq in computer science.
The fundamental ideas of Lean and Coq are very similar, and skills are readily transferable between the systems.</p>
<h2 id="programming-with-dependent-types-1"><a class="header" href="#programming-with-dependent-types-1">Programming with Dependent Types</a></h2>
<p>For programmers who are interested in learning to use indexed families and dependent types to structure programs, Edwin Brady's <a href="https://www.manning.com/books/type-driven-development-with-idris"><em>Type Driven Development with Idris</em></a> provides an excellent introduction.
Like Coq, Idris is a close cousin of Lean, though it lacks tactics.</p>
<h2 id="understanding-dependent-types"><a class="header" href="#understanding-dependent-types">Understanding Dependent Types</a></h2>
<p><a href="https://thelittletyper.com/"><em>The Little Typer</em></a> is a book for programmers who haven't formally studied logic or the theory of programming languages, but who want to build an understanding of the core ideas of dependent type theory.
While all of the above resources aim to be as practical as possible, <em>The Little Typer</em> presents an approach to dependent type theory where the very basics are built up from scratch, using only concepts from programming.
Disclaimer: the author of <em>Functional Programming in Lean</em> is also an author of <em>The Little Typer</em>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear:both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        
        
        
        
        
        
        

        <!-- Custom JS scripts -->
        
    

<div style="position:absolute;width:0px;height:0px;overflow:hidden;padding:0px;border:0px;margin:0px"><div id="MathJax_Font_Test" style="position:absolute;visibility:hidden;top:0px;left:0px;width:auto;padding:0px;border:0px;margin:0px;white-space:nowrap;text-align:left;text-indent:0px;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;font-size:40px;font-weight:normal;font-style:normal;font-size-adjust:none;font-family:MathJax_Typewriter,sans-serif"></div></div>

</div>

<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>