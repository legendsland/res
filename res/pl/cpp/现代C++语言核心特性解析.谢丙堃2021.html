<!DOCTYPE html><html><head>
<meta name="dc.identifier" content="res/92cabc2c0484ebed6b0bef70e348c44b3652d71e">

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>现代C++语言核心特性解析.谢丙堃2021</title>
<style>
@page {
  padding: 0pt;
  margin: 0pt;
}

body {
  /*text-align: center;*/
  padding: 0pt;
  margin: 0pt;
}
</style>
<style>
.biao_tou_dan_yuan_ge {
  display: block;
  line-height: 180%;
  text-indent: 0;
  margin: 1em 0;
}

.calibre {
  display: block;
  font-size: 1em;
  padding-left: 0;
  padding-right: 0;
  margin: 0 5pt;
}

.calibre1 {
  font-weight: bold;
}

.calibre2 {
  color: gray;
  display: block;
  height: 2px;
  margin: 0.5em auto;
  border: currentColor inset 1px;
}

.calibre3 {
  display: block;
}

.calibre4 {
  text-decoration: none;
}

.calibre5 {
  display: block;
  line-height: 180%;
  text-align: right;
  text-indent: 0;
  margin: 1em 0;
}

.calibre6 {
  display: block;
  line-height: 150%;
  list-style-type: disc;
  margin-bottom: 1em;
  margin-right: 0;
  margin-top: 1em;
}

.calibre7 {
  height: auto;
  width: 15%;
}

.calibre8 {
  height: auto;
  width: 80%;
}

.calibre9 {
  height: auto;
  width: 30%;
}

.calibre10 {
  font-family: Courier, Menlo, Monaco, Consolas, monospace;
}

.calibre11 {
  border-collapse: collapse;
  border-spacing: 0;
  display: table;
  text-indent: 0;
  margin: 15px auto 30px;
}

.calibre12 {
  display: table-header-group;
  vertical-align: middle;
}

.calibre13 {
  display: table-row;
  vertical-align: inherit;
}

.calibre14 {
  display: table-cell;
  font-size: 0.75em;
  font-weight: bold;
  page-break-inside: avoid;
  text-align: center;
  vertical-align: auto;
  padding: 0.3em;
  border: #000 solid 1px;
}

.calibre15 {
  display: table-row-group;
  vertical-align: middle;
}

.calibre16 {
  display: table-cell;
  font-size: 0.75em;
  page-break-inside: avoid;
  text-align: left;
  vertical-align: auto;
  padding: 0.3em;
  border: #000 solid 1px;
}

.calibre17 {
  background-color: #f1f6fc;
  display: table-row;
  vertical-align: inherit;
}

.calibre18 {
  height: auto;
  width: 45%;
}

.calibre19 {
  display: block;
}

.calibre20 {
  border-radius: 0.5em;
  box-shadow: 5px 5px 5px #c7c7c7;
  display: block;
  margin: 1em 0 1.5em;
  padding: 0.5em 1.5em;
  border: #146eb4 solid 1px;
}

.calibre21 {
  color: #0092dd;
}

.calibre22 {
  font-style: italic;
}

.calibre23 {
  font-size: 0.75em;
  line-height: normal;
  vertical-align: super;
}

.calibre24 {
  font-weight: bold;
  line-height: 1.2;
}

.dai_ma_wu_xing_hao {
  display: block;
  font-family: Courier, Menlo, Monaco, Consolas, monospace;
  font-size: 0.75em;
  white-space: pre-wrap;
  word-wrap: break-word;
  margin: 1.3em 0;
  padding: 0.3em;
  border: #000 solid 1px;
}

.di_1ji_wu_xu_lie_biao {
  display: list-item;
}

.not-in-toc {
  background-color: #f1f6fc;
  color: #0092DD;
  display: block;
  font-size: 1.66667em;
  font-weight: bold;
  line-height: 1.2;
  text-align: center;
  width: 100%;
  margin: 0.67em 0;
  padding: 0.75em 0;
  border-top: #c7c7c7 dashed 1px;
  border-right: #FFF solid 1px;
  border-bottom: #c7c7c7 dashed 1px;
  border-left: #FFF solid 1px;
}

.sgc-toc-level {
  display: block;
  line-height: 1.5;
  text-indent: 0;
  margin: 1.5em 0;
}

.sgc-toc-level1 {
  display: block;
  line-height: 1.5;
  text-indent: 2em;
  margin: 0.5em 0;
}

.sgc-toc-level2 {
  display: block;
  line-height: 1.5;
  text-indent: 4em;
  margin: 0.1em 0;
}

.sgc-toc-title {
  background-color: #f1f6fc;
  color: #0092dd;
  display: block;
  font-size: 1.66667em;
  line-height: 1.2;
  text-align: center;
  width: 100%;
  padding: 0.75em 0;
  border-top: #c7c7c7 dashed 1px;
  border-right: #FFF solid 1px;
  border-bottom: #c7c7c7 dashed 1px;
  border-left: #FFF solid 1px;
}

.sigil_not_in_toc {
  color: #0092DD;
  display: block;
  font-size: 1.29167em;
  font-weight: bold;
  line-height: 1.2;
  margin: 0.83em 0;
  padding: 0.3em;
}

.sigil_not_in_toc1 {
  color: #0092DD;
  display: block;
  font-size: 1.29167em;
  font-weight: bold;
  line-height: 1.2;
  margin: 1em 0;
  padding: 0.3em;
}

.sigil_not_in_toc2 {
  display: block;
  font-size: 1.29167em;
  font-weight: bold;
  line-height: 1.2;
  margin: 1.33em 0;
}

.tu {
  display: block;
  line-height: 180%;
  text-align: center;
  text-indent: 0;
  margin: 1em 0;
}

.tu_ti {
  display: block;
  font-size: 0.83333em;
  line-height: 180%;
  text-align: center;
  text-indent: 0;
  margin: 1em 0;
}

.zw {
  display: block;
  line-height: 180%;
  text-indent: 2em;
  margin: 1em 0;
}</style>
<style>
@page {
  margin-bottom: 5pt;
  margin-top: 5pt;
}</style>
<style>

</style>
<link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>
<body>
<div id="book-container"><div id="titlepage.xhtml"><div>

        <div>
            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="100%" height="100%" viewBox="0 0 566 715" preserveAspectRatio="none">
                <image width="566" height="715" xlink:href="data:image/jpeg;base64,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Utvh/blrOSK6eI23LEJkTNuDZbJ9sVej8DJHaW1uL1v9HLFXCYJDHlTzyp6Y/KusgcMmAAMdhUtJjRnaJpf9j6ctmJ3mVWJUvyQD0GepA960aKKACmuu5CvqKdRQBnsjKcEGp7eMrljx2qzRTbFYgltw53A4NEUGw5Y5NT0UrsLBRRRQMKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACq7zNuwOBVioHhJYkc0ARurXCEE9OcetQ4I4xirsUewdeafgelNMlohtkKqSe9T0UUhoKKKKBhRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABTZH2LmnVHKm9eO1ADFnOeQMVNketVhExOCMVL5C+poAkyKMio/IX1NL5K+/50APyKKZ5K+/50UASUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRVcO32tkz8oQHHvk0UAf/2Q=="></image>
            </svg>
        </div>
    </div></div>
<div id="OEBPS/Text/TOC.xhtml"><div class="calibre">

  <div class="sgc-toc-title" id="OEBPS/Text/TOC.xhtml.calibre_pb_0">
    目 &nbsp; &nbsp;录
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/epub.html">版权信息</a>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/epub_0001.html">版 权</a>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/epub_0002.html">内容提要</a>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/epub_0003.html">推荐序</a>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/epub_0004.html">前言</a>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/epub_0005.html">资源与支持</a>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter001.html">第1章 新基础类型（C++11～C++20）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter001.html.nav_point_16">1.1 整数类型long long</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter001.html.nav_point_17">1.2 新字符类型char16_t和char32_t</a>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter001.html.nav_point_18">1.2.1 字符集和编码方法</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter001.html.nav_point_19">1.2.2 使用新字符类型char16_t和char32_t</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter001.html.nav_point_20">1.2.3 wchar_t存在的问题</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter001.html.nav_point_21">1.2.4 新字符串连接</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter001.html.nav_point_22">1.2.5 库对新字符类型的支持</a>
      </div>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter001.html.nav_point_23">1.3 char8_t字符类型</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter001.html.nav_point_24">1.4 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter002.html">第2章 内联和嵌套命名空间（C++11～C++20）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter002.html.nav_point_26">2.1 内联命名空间的定义和使用</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter002.html.nav_point_27">2.2 嵌套命名空间的简化语法</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter002.html.nav_point_28">2.3 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter003.html">第3章 auto占位符（C++11～C++17）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter003.html.nav_point_30">3.1 重新定义的auto关键字</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter003.html.nav_point_31">3.2 推导规则</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter003.html.nav_point_32">3.3 什么时候使用auto</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter003.html.nav_point_33">3.4 返回类型推导</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter003.html.nav_point_34">3.5 lambda表达式中使用auto类型推导</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter003.html.nav_point_35">3.6 非类型模板形参占位符</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter003.html.nav_point_36">3.7 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter004.html">第4章 decltype说明符（C++11～C++17）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter004.html.nav_point_38">4.1 回顾typeof和typeid</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter004.html.nav_point_39">4.2 使用decltype说明符</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter004.html.nav_point_40">4.3 推导规则</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter004.html.nav_point_41">4.4 cv限定符的推导</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter004.html.nav_point_42">4.5 decltype(auto)</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter004.html.nav_point_43">4.6 decltype(auto)作为非类型模板形参占位符</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter004.html.nav_point_44">4.7 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter005.html">第5章 函数返回类型后置（C++11）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter005.html.nav_point_46">5.1 使用函数返回类型后置声明函数</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter005.html.nav_point_47">5.2 推导函数模板返回类型</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter005.html.nav_point_48">5.3 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter006.html">第6章 右值引用（C++11 C++17 C++20）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter006.html.nav_point_50">6.1 左值和右值</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter006.html.nav_point_51">6.2 左值引用</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter006.html.nav_point_52">6.3 右值引用</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter006.html.nav_point_53">6.4 右值的性能优化空间</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter006.html.nav_point_54">6.5 移动语义</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter006.html.nav_point_55">6.6 值类别</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter006.html.nav_point_56">6.7 将左值转换为右值</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter006.html.nav_point_57">6.8 万能引用和引用折叠</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter006.html.nav_point_58">6.9 完美转发</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter006.html.nav_point_59">6.10 针对局部变量和右值引用的隐式移动操作</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter006.html.nav_point_60">6.11 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter007.html">第7章 lambda表达式（C++11～C++20）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter007.html.nav_point_62">7.1 lambda表达式语法</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter007.html.nav_point_63">7.2 捕获列表</a>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter007.html.nav_point_64">7.2.1 作用域</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter007.html.nav_point_65">7.2.2 捕获值和捕获引用</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter007.html.nav_point_66">7.2.3 特殊的捕获方法</a>
      </div>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter007.html.nav_point_67">7.3 lambda表达式的实现原理</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter007.html.nav_point_68">7.4 无状态lambda表达式</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter007.html.nav_point_69">7.5 在STL中使用lambda表达式</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter007.html.nav_point_70">7.6 广义捕获</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter007.html.nav_point_71">7.7 泛型lambda表达式</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter007.html.nav_point_72">7.8 常量lambda表达式和捕获*this</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter007.html.nav_point_73">7.9 捕获[=, this]</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter007.html.nav_point_74">7.10 模板语法的泛型lambda表达式</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter007.html.nav_point_75">7.11 可构造和可赋值的无状态lambda表达式</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter007.html.nav_point_76">7.12 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter008.html">第8章 非静态数据成员默认初始化（C++11 C++20）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter008.html.nav_point_78">8.1 使用默认初始化</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter008.html.nav_point_79">8.2 位域的默认初始化</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter008.html.nav_point_80">8.3 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter009.html">第9章 列表初始化（C++11 C++20）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter009.html.nav_point_82">9.1 回顾变量初始化</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter009.html.nav_point_83">9.2 使用列表初始化</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter009.html.nav_point_84">9.3 std::initializer_list详解</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter009.html.nav_point_85">9.4 使用列表初始化的注意事项</a>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter009.html.nav_point_86">9.4.1 隐式缩窄转换问题</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter009.html.nav_point_87">9.4.2 列表初始化的优先级问题</a>
      </div>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter009.html.nav_point_88">9.5 指定初始化</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter009.html.nav_point_89">9.6 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter010.html">第10章 默认和删除函数（C++11）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter010.html.nav_point_91">10.1 类的特殊成员函数</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter010.html.nav_point_92">10.2 显式默认和显式删除</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter010.html.nav_point_93">10.3 显式删除的其他用法</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter010.html.nav_point_94">10.4 explicit和=delete</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter010.html.nav_point_95">10.5 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter011.html">第11章 非受限联合类型（C++11）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter011.html.nav_point_97">11.1 联合类型在C++中的局限性</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter011.html.nav_point_98">11.2 使用非受限联合类型</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter011.html.nav_point_99">11.3 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter012.html">第12章 委托构造函数（C++11）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter012.html.nav_point_101">12.1 冗余的构造函数</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter012.html.nav_point_102">12.2 委托构造函数</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter012.html.nav_point_103">12.3 委托模板构造函数</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter012.html.nav_point_104">12.4 捕获委托构造函数的异常</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter012.html.nav_point_105">12.5 委托参数较少的构造函数</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter012.html.nav_point_106">12.6 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter013.html">第13章 继承构造函数（C++11）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter013.html.nav_point_108">13.1 继承关系中构造函数的困局</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter013.html.nav_point_109">13.2 使用继承构造函数</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter013.html.nav_point_110">13.3 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter014.html">第14章 强枚举类型（C++11 C++17 C++20）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter014.html.nav_point_112">14.1 枚举类型的弊端</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter014.html.nav_point_113">14.2 使用强枚举类型</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter014.html.nav_point_114">14.3 列表初始化有底层类型枚举对象</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter014.html.nav_point_115">14.4 使用using打开强枚举类型</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter014.html.nav_point_116">14.5 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter015.html">第15章 扩展的聚合类型（C++17 C++20）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter015.html.nav_point_118">15.1 聚合类型的新定义</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter015.html.nav_point_119">15.2 聚合类型的初始化</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter015.html.nav_point_120">15.3 扩展聚合类型的兼容问题</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter015.html.nav_point_121">15.4 禁止聚合类型使用用户声明的构造函数</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter015.html.nav_point_122">15.5 使用带小括号的列表初始化聚合类型对象</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter015.html.nav_point_123">15.6 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter016.html">第16章 override和final说明符（C++11）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter016.html.nav_point_125">16.1 重写、重载和隐藏</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter016.html.nav_point_126">16.2 重写引发的问题</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter016.html.nav_point_127">16.3 使用override说明符</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter016.html.nav_point_128">16.4 使用final说明符</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter016.html.nav_point_129">16.5 override和final说明符的特别之处</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter016.html.nav_point_130">16.6 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter017.html">第17章 基于范围的for循环（C++11 C++17 C++20）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter017.html.nav_point_132">17.1 烦琐的容器遍历</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter017.html.nav_point_133">17.2 基于范围的for循环语法</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter017.html.nav_point_134">17.3 begin和end函数不必返回相同类型</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter017.html.nav_point_135">17.4 临时范围表达式的陷阱</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter017.html.nav_point_136">17.5 实现一个支持基于范围的for循环的类</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter017.html.nav_point_137">17.6 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter018.html">第18章 支持初始化语句的if和switch（C++17）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter018.html.nav_point_139">18.1 支持初始化语句的if</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter018.html.nav_point_140">18.2 支持初始化语句的switch</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter018.html.nav_point_141">18.3 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter019.html">第19章 static_assert声明</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter019.html.nav_point_143">19.1 运行时断言</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter019.html.nav_point_144">19.2 静态断言的需求</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter019.html.nav_point_145">19.3 静态断言</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter019.html.nav_point_146">19.4 单参数static_assert</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter019.html.nav_point_147">19.5 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter020.html">第20章 结构化绑定（C++17 C++20）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter020.html.nav_point_149">20.1 使用结构化绑定</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter020.html.nav_point_150">20.2 深入理解结构化绑定</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter020.html.nav_point_151">20.3 结构化绑定的3种类型</a>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter020.html.nav_point_152">20.3.1 绑定到原生数组</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter020.html.nav_point_153">20.3.2 绑定到结构体和类对象</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter020.html.nav_point_154">20.3.3 绑定到元组和类元组的对象</a>
      </div>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter020.html.nav_point_155">20.4 实现一个类元组类型</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter020.html.nav_point_156">20.5 绑定的访问权限问题</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter020.html.nav_point_157">20.6 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter021.html">第21章 noexcept关键字（C++11 C++17 C++20）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter021.html.nav_point_159">21.1 使用noexcept代替throw</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter021.html.nav_point_160">21.2 用noexcept来解决移动构造问题</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter021.html.nav_point_161">21.3 noexcept和throw()</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter021.html.nav_point_162">21.4 默认使用noexcept的函数</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter021.html.nav_point_163">21.5 使用noexcept的时机</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter021.html.nav_point_164">21.6 将异常规范作为类型的一部分</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter021.html.nav_point_165">21.7 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter022.html">第22章 类型别名和别名模板（C++11 C++14）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter022.html.nav_point_167">22.1 类型别名</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter022.html.nav_point_168">22.2 别名模板</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter022.html.nav_point_169">22.3 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter023.html">第23章 指针字面量nullptr（C++11）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter023.html.nav_point_171">23.1 零值整数字面量</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter023.html.nav_point_172">23.2 nullptr关键字</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter023.html.nav_point_173">23.3 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter024.html">第24章 三向比较（C++20）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter024.html.nav_point_175">24.1 “太空飞船”（spaceship）运算符</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter024.html.nav_point_176">24.2 三向比较的返回类型</a>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter024.html.nav_point_177">24.2.1 std::strong_ordering</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter024.html.nav_point_178">24.2.2 std::weak_ordering</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter024.html.nav_point_179">24.2.3 std::partial_ordering</a>
      </div>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter024.html.nav_point_180">24.3 对基础类型的支持</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter024.html.nav_point_181">24.4 自动生成的比较运算符函数</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter024.html.nav_point_182">24.5 兼容旧代码</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter024.html.nav_point_183">24.6 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter025.html">第25章 线程局部存储（C++11）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter025.html.nav_point_185">25.1 操作系统和编译器对线程局部存储的支持</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter025.html.nav_point_186">25.2 thread_local说明符</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter025.html.nav_point_187">25.3 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter026.html">第26章 扩展的inline说明符（C++17）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter026.html.nav_point_189">26.1 定义非常量静态成员变量的问题</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter026.html.nav_point_190">26.2 使用inline说明符</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter026.html.nav_point_191">26.3 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter027.html">第27章 常量表达式（C++11～C++20）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter027.html.nav_point_193">27.1 常量的不确定性</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter027.html.nav_point_194">27.2 constexpr值</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter027.html.nav_point_195">27.3 constexpr函数</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter027.html.nav_point_196">27.4 constexpr构造函数</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter027.html.nav_point_197">27.5 对浮点的支持</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter027.html.nav_point_198">27.6 C++14标准对常量表达式函数的增强</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter027.html.nav_point_199">27.7 constexpr lambdas表达式</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter027.html.nav_point_200">27.8 constexpr的内联属性</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter027.html.nav_point_201">27.9 if constexpr</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter027.html.nav_point_202">27.10 允许constexpr虚函数</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter027.html.nav_point_203">27.11 允许在constexpr函数中出现Try-catch</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter027.html.nav_point_204">27.12 允许在constexpr中进行平凡的默认初始化</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter027.html.nav_point_205">27.13 允许在constexpr中更改联合类型的有效成员</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter027.html.nav_point_206">27.14 使用consteval声明立即函数</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter027.html.nav_point_207">27.15 使用constinit检查常量初始化</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter027.html.nav_point_208">27.16 判断常量求值环境</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter027.html.nav_point_209">27.17 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter028.html">第28章 确定的表达式求值顺序（C++17）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter028.html.nav_point_211">28.1 表达式求值顺序的不确定性</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter028.html.nav_point_212">28.2 表达式求值顺序详解</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter028.html.nav_point_213">28.3 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter029.html">第29章 字面量优化（C++11～C++17）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter029.html.nav_point_215">29.1 十六进制浮点字面量</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter029.html.nav_point_216">29.2 二进制整数字面量</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter029.html.nav_point_217">29.3 单引号作为整数分隔符</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter029.html.nav_point_218">29.4 原生字符串字面量</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter029.html.nav_point_219">29.5 用户自定义字面量</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter029.html.nav_point_220">29.6 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter030.html">第30章 alignas和alignof（C++11 C++17）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter030.html.nav_point_222">30.1 不可忽视的数据对齐问题</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter030.html.nav_point_223">30.2 C++11标准之前控制数据对齐的方法</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter030.html.nav_point_224">30.3 使用alignof运算符</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter030.html.nav_point_225">30.4 使用alignas说明符</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter030.html.nav_point_226">30.5 其他关于对齐字节长度的支持</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter030.html.nav_point_227">30.6 C++17中使用new分配指定对齐字节长度的对象</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter030.html.nav_point_228">30.7 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter031.html">第31章 属性说明符和标准属性（C++11～C++20）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter031.html.nav_point_230">31.1 GCC的属性语法</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter031.html.nav_point_231">31.2 MSVC的属性语法</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter031.html.nav_point_232">31.3 标准属性说明符语法</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter031.html.nav_point_233">31.4 使用using打开属性的命名空间</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter031.html.nav_point_234">31.5 标准属性</a>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter031.html.nav_point_235">31.5.1 noreturn</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter031.html.nav_point_236">31.5.2 carries_dependency</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter031.html.nav_point_237">31.5.3 deprecated</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter031.html.nav_point_238">31.5.4 fallthrough</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter031.html.nav_point_239">31.5.5 nodiscard</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter031.html.nav_point_240">31.5.6 maybe_unused</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter031.html.nav_point_241">31.5.7 likely和unlikely</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter031.html.nav_point_242">31.5.8 no_unique_address</a>
      </div>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter031.html.nav_point_243">31.6 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter032.html">第32章 新增预处理器和宏（C++17 C++20）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter032.html.nav_point_245">32.1 预处理器__has_include</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter032.html.nav_point_246">32.2 特性测试宏</a>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter032.html.nav_point_247">32.2.1 属性特性测试宏</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter032.html.nav_point_248">32.2.2 语言功能特性测试宏</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter032.html.nav_point_249">32.2.3 标准库功能特性测试宏</a>
      </div>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter032.html.nav_point_250">32.3 新增宏VA_OPT</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter032.html.nav_point_251">32.4 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter033.html">第33章 协程（C++20）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter033.html.nav_point_253">33.1 协程的使用方法</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter033.html.nav_point_254">33.2 协程的实现原理</a>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter033.html.nav_point_255">33.2.1 co_await运算符原理</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter033.html.nav_point_256">33.2.2 co_yield运算符原理</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter033.html.nav_point_257">33.2.3 co_return运算符原理</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter033.html.nav_point_258">33.2.4 promise_type的其他功能</a>
      </div>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter033.html.nav_point_259">33.3 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter034.html">第34章 基础特性的其他优化（C++11～C++20）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter034.html.nav_point_261">34.1 显式自定义类型转换运算符（C++11）</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter034.html.nav_point_262">34.2 关于std::launder()（C++17）</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter034.html.nav_point_263">34.3 返回值优化（C++11～C++17）</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter034.html.nav_point_264">34.4 允许按值进行默认比较（C++20）</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter034.html.nav_point_265">34.5 支持new表达式推导数组长度（C++20）</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter034.html.nav_point_266">34.6 允许数组转换为未知范围的数组（C++20）</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter034.html.nav_point_267">34.7 在delete运算符函数中析构对象（C++20）</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter034.html.nav_point_268">34.8 调用伪析构函数结束对象声明周期（C++20）</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter034.html.nav_point_269">34.9 修复const和默认复制构造函数不匹配造成无法编译的问题（C++20）</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter034.html.nav_point_270">34.10 不推荐使用volatile的情况（C++20）</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter034.html.nav_point_271">34.11 不推荐在下标表达式中使用逗号运算符（C++20）</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter034.html.nav_point_272">34.12 模块（C++20）</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter034.html.nav_point_273">34.13 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter035.html">第35章 可变参数模板（C++11 C++17 C++20）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter035.html.nav_point_275">35.1 可变参数模板的概念和语法</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter035.html.nav_point_276">35.2 形参包展开</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter035.html.nav_point_277">35.3 sizeof...运算符</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter035.html.nav_point_278">35.4 可变参数模板的递归计算</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter035.html.nav_point_279">35.5 折叠表达式</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter035.html.nav_point_280">35.6 一元折叠表达式中空参数包的特殊处理</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter035.html.nav_point_281">35.7 using声明中的包展开</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter035.html.nav_point_282">35.8 lambda表达式初始化捕获的包展开</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter035.html.nav_point_283">35.9 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter036.html">第36章 typename优化（C++17 C++20）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter036.html.nav_point_285">36.1 允许使用typename声明模板形参</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter036.html.nav_point_286">36.2 减少typename使用的必要性</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter036.html.nav_point_287">36.3 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter037.html">第37章 模板参数优化（C++11 C++17 C++20）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter037.html.nav_point_289">37.1 允许常量求值作为所有非类型模板的实参</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter037.html.nav_point_290">37.2 允许局部和匿名类型作为模板实参</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter037.html.nav_point_291">37.3 允许函数模板的默认模板参数</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter037.html.nav_point_292">37.4 函数模板添加到ADL查找规则</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter037.html.nav_point_293">37.5 允许非类型模板形参中的字面量类类型</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter037.html.nav_point_294">37.6 扩展的模板参数匹配规则</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter037.html.nav_point_295">37.7 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter038.html">第38章 类模板的模板实参推导（C++17 C++20）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter038.html.nav_point_297">38.1 通过初始化构造推导类模板的模板实参</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter038.html.nav_point_298">38.2 拷贝初始化优先</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter038.html.nav_point_299">38.3 lambda类型的用途</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter038.html.nav_point_300">38.4 别名模板的类模板实参推导</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter038.html.nav_point_301">38.5 聚合类型的类模板实参推导</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter038.html.nav_point_302">38.6 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter039.html">第39章 用户自定义推导指引（C++17）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter039.html.nav_point_304">39.1 使用自定义推导指引推导模板实例</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter039.html.nav_point_305">39.2 聚合类型类模板的推导指引</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter039.html.nav_point_306">39.3 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter040.html">第40章 SFINAE（C++11）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter040.html.nav_point_308">40.1 替换失败和编译错误</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter040.html.nav_point_309">40.2 SFINAE规则详解</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter040.html.nav_point_310">40.3 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter041.html">第41章 概念和约束（C++20）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter041.html.nav_point_312">41.1 使用std::enable_if约束模板</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter041.html.nav_point_313">41.2 概念的背景介绍</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter041.html.nav_point_314">41.3 使用concept和约束表达式定义概念</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter041.html.nav_point_315">41.4 requires子句和约束检查顺序</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter041.html.nav_point_316">41.5 原子约束</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter041.html.nav_point_317">41.6 requires表达式</a>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter041.html.nav_point_318">41.6.1 简单要求</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter041.html.nav_point_319">41.6.2 类型要求</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter041.html.nav_point_320">41.6.3 复合要求</a>
      </div>

      <div class="sgc-toc-level2">
        <a href="#OEBPS/Text/chapter041.html.nav_point_321">41.6.4 嵌套要求</a>
      </div>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter041.html.nav_point_322">41.7 约束可变参数模板</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter041.html.nav_point_323">41.8 约束类模板特化</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter041.html.nav_point_324">41.9 约束auto</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter041.html.nav_point_325">41.10 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/chapter042.html">第42章 模板特性的其他优化（C++11 C++14）</a>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter042.html.nav_point_327">42.1 外部模板（C++11）</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter042.html.nav_point_328">42.2 连续右尖括号的解析优化（C++11）</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter042.html.nav_point_329">42.3 friend声明模板形参（C++11）</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter042.html.nav_point_330">42.4 变量模板（C++14）</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter042.html.nav_point_331">42.5 explicit(bool)</a>
    </div>

    <div class="sgc-toc-level1">
      <a href="#OEBPS/Text/chapter042.html.nav_point_332">42.6 总结</a>
    </div>
  </div>

  <div class="sgc-toc-level">
    <a href="#OEBPS/Text/appendix.html">附 录 特性章节对照表</a>
  </div>
</div></div>
<div id="OEBPS/Text/epub.html"><div class="calibre">

  <h1 class="not-in-toc" id="OEBPS/Text/epub.html.calibre_pb_0">版权信息</h1>

  <p class="zw">书名：现代C++语言核心特性解析</p>

  <p class="zw">ISBN：978-7-115-56417-7</p>

  <p class="zw"><strong class="calibre1">本书由人民邮电出版社发行数字版。版权所有，侵权必究。</strong></p>
  <hr class="calibre2">

  <p class="zw">您购买的人民邮电出版社电子书仅供您个人使用，未经授权，不得以任何方式复制和传播本书内容。</p>

  <p class="zw">我们愿意相信读者具有这样的良知和觉悟，与我们共同保护知识产权。</p>

  <p class="zw">如果购买者有侵权行为，我们可能对该用户实施包括但不限于关闭该帐号等维权措施，并可能追究法律责任。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/epub.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/epub_0001.html"><div class="calibre">

  <h1 id="OEBPS/Text/epub_0001.html.nav_point_0" class="not-in-toc">版　　权</h1>

  <p class="zw"><strong class="calibre1">著　　　</strong>　谢丙堃</p>

  <p class="zw"><strong class="calibre1">责任编辑</strong>　陈聪聪</p>
  <hr class="calibre2">

  <p class="zw">人民邮电出版社出版发行　　北京市丰台区成寿寺路11号</p>

  <p class="zw"><strong class="calibre1">邮编</strong>　100164 　<strong class="calibre1">电子邮件</strong>　315@ptpress.com.cn</p>

  <p class="zw"><strong class="calibre1">网址</strong>　<a href="http://www.ptpress.com.cn" class="calibre4">http://www.ptpress.com.cn</a></p>
  <hr class="calibre2">

  <p class="zw"><strong class="calibre1">读者服务热线：</strong>(010)81055410</p>

  <p class="zw"><strong class="calibre1">反盗版热线：</strong>(010)81055315</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/epub_0001.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/epub_0002.html"><div class="calibre">

  <h1 id="OEBPS/Text/epub_0002.html.nav_point_1" class="not-in-toc">内容提要</h1>

  <p class="zw">本书是一本C++进阶图书，全书分为42章，深入探讨了从C++11到C++20引入的核心特性。书中不仅通过大量的实例代码讲解特性的概念和语法，还从编译器的角度分析特性的实现原理，书中还穿插了C++标准委员会制定特性标准时的一些小故事，帮助读者知其然也知其所以然。</p>

  <p class="zw">本书适合因为工作需要学习C++新特性的C++从业者，同样也适合对C++新特性非常感兴趣的C++爱好者。此外，具备C++基础知识的C++初学者也可以通过本书领略C++的另外一道风景。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/epub_0002.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/epub_0003.html"><div class="calibre">

  <h1 id="OEBPS/Text/epub_0003.html.nav_point_2" class="not-in-toc">推荐序</h1>

  <p class="zw">在现代计算机的历史中，剑桥大学有着很重要的地位。1949年5月6日，剑桥大学制造的EDSAC计算机成功运行，成为世界上第一台具有完整功能的存储程序计算机。EDSAC是由剑桥大学数学实验室设计的，核心人物是莫里斯·威尔克斯（Maurice Wilkes）（1913—2010）。</p>

  <p class="zw">1951年，爱迪生-韦斯利出版社（Addison-Wesley）出版了一本名为《为电子数字计算机准备程序》的书，书中介绍了如何为EDSAC计算机编写软件，这本书开创了一个新的出版领域，是出版历史中最早的软件编程图书。这本书的第一作者便是莫里斯·威尔克斯，第二作者是EDSAC团队的另一个成员戴维德·惠勒（David J. WHEELER）（1927—2004）。</p>

  <p class="zw">1970年，剑桥大学数学实验室改名为计算机实验室。</p>

  <p class="zw">1975年，一个来自丹麦的年轻人申请到剑桥大学读博士，面试他的便是莫里斯·威尔克斯和罗杰·尼达姆（Roger Needham）。罗杰于1962年加入剑桥大学数学实验室，后来成为微软欧洲研究院的首任院长。</p>

  <p class="zw">今天回想起来，1975年的这次面试可谓阵容强大，两位面试官一位是EDSAC的总设计师，一位是后来的研究院院长。</p>

  <p class="zw">两位资深的面试官轮番提问，一个问题接着一个问题，让被面试者难以应付，有点焦头烂额。不过虽然面试过程很痛苦，但是结果却非常让人愉快，被面试的年轻人通过了面试。这个年轻人便是今天被尊称为C++之父的本贾尼·斯特劳斯特卢普（Bjarne Stroustrup）先生。本贾尼出生于1950年，25岁时就已经在丹麦的奥尔胡斯大学获得了硕士学位。这次面试让他得到了到现代计算机的摇篮之一继续学习的机会，也让他满足了女朋友的心愿。在到剑桥面试之前，本贾尼已经拿到了一所大学的邀约（offer），但他的女朋友说：“如果你能拿到剑桥大学的邀约，你应该选择剑桥。”</p>

  <p class="zw">获得剑桥大学的学习机会，实现了女朋友的愿望，让本贾尼也很高兴。更重要的是，指导本贾尼博士学业的导师便是EDSAC的设计者之一戴维德·惠勒。</p>

  <p class="zw">多年之后在本贾尼获得计算机历史博物馆的院士荣誉后接受采访时，他仍清楚地记得第一次到惠勒办公室时的情景。本贾尼坐下来后，想听听导师安排自己做什么。没想到，惠勒提出了一个问题：“你知道读博士和读硕士的差别吗？”</p>

  <p class="zw">本贾尼回答道：“不知道。”</p>

  <p class="zw">惠勒说：“如果一定需要我告诉你应该做什么，那么你就是来读硕士。”</p>

  <p class="zw">本贾尼明白了，导师是让他自己寻找研究方向。于是本贾尼花了一年时间来寻找研究方向，经过大量的调查和分析，最后选择了分布式系统。</p>

  <p class="zw">1979年，本贾尼在剑桥大学拿到了博士学位。经过一番努力，他最终获得了到大洋彼岸的贝尔实验室工作的机会。</p>

  <p class="zw">于是本贾尼先生带着妻子和女儿从英国到了美国。贝尔实验室位于美国新泽西州的默里山。在本贾尼到达前，那里已经因为发明了UNIX和C语言而名扬天下。</p>

  <p class="zw">到贝尔实验室报到后，本贾尼找到自己的主管，坐下来，想听听领导安排自己做什么。领导的指示非常简单：“做点有趣的东西。”</p>

  <p class="zw">回想起当年在剑桥第一次接受惠勒导师指导的经历，本贾尼对这个回答已经不惊异了。而且感到非常高兴，因为可以按照自己的想法大干一场。</p>

  <p class="zw">做什么呢？本贾尼在做博士研究时，使用了一种名叫Simula的语言，它的最大特点就是“面向对象”，可以非常直观地表达现实世界，代码很优雅。但相对于贝尔实验室里流行的C语言来说，Simula的效率不够高。一个伟大的想法浮现在本贾尼的脑海里，那就是做一种新的编程语言，它既有C的高效性，又有Simula的自然和优雅。</p>

  <p class="zw">想好了就动手，本贾尼把自己的新语言临时取名为“带有类的C”（C with Classes），开始改造编译器。</p>

  <p class="zw">开发一种新的编程语言是一项巨大的工程，定义语法、开发编译器、编写用户手册等。在这个过程中，本贾尼给自己的新语言取了一个简单的名字：C++。</p>

  <p class="zw">经过近5年的工作，1984年，C++语言的参考手册在贝尔实验室内部发布了。</p>

  <p class="zw">1985年，C++的商业版本对外发布，C++开始了走向世界的步伐。</p>

  <p class="zw">我在20世纪90年代读大学时，专业课程里安排的编程语言有FORTRAN、C以及汇编语言，没有C++。但是在图书馆里，我找到了介绍C++的书。更重要的是，当年流行的Borland C++ 3.1集成开发环境里大量使用了C++语言，最著名的就是宝蓝（Borland）公司开发的窗口库OWL（Object Windows Library）。于是我开始自学C++语言，并且使用C++语言编写了一些程序，包括我的毕业设计程序。</p>

  <p class="zw">2005年，在上海的C++大会上，第一次见到本贾尼先生，近距离聆听了他关于C++的演讲。从那以后，多次与本贾尼先生见面，与他谈论的话题也逐渐增多。</p>

  <p class="zw">2019年11月，本贾尼先生亲临C++大会会场，演讲间隙与很多与会者微笑合影。特别是在与本贾尼的座谈结束后，很多人走到本贾尼身边，请求合影。本贾尼先生有求必应，座谈大约12点结束，我上了个卫生间回来，合影仍在继续。根据主办方的安排，这天的午餐是所有讲师与本贾尼先生共进午餐，因为合影，午餐被推迟了十几分钟。餐厅在5楼，午餐后有演讲或者想听演讲的讲师离开了，本贾尼先生继续在餐厅，一边喝茶，一边聊天，我与他聊到13点多后，因为有事也到4楼会场了。大约14点左右，我在会场侧面的卫生间门口，又见到本贾尼先生，他被一位同行拦住，请求合影。就是在这样“人生有三急”的情况下，本贾尼先生还是非常配合地与那位同行来了个二人合照。我当时真是佩服本贾尼先生的平易和温和。</p>

  <p class="zw">从2010年起，C++语言走上了快车道，在过去10年间发布了4个版本，大刀阔斧地引入了很多新的特征。在C++11开始的4个已发布版本中，C++引入了100多个新特征。这么多新特征让很多人感觉C++仿佛成了一门新的语言。于是便有了现代C++的说法。</p>

  <p class="zw">与经典C++相比，现代C++的学习难度也比较大。这意味着对于一些老的C++程序员，学习现代C++也是有挑战的。如何快速掌握现代C++呢？</p>

  <p class="zw">在2008年《软件调试》第1版出版后，我在高端调试网站举办了一个书友活动，在那次活动中，一个年轻帅气的年轻人给我留下了深刻的印象，他风华正茂，目光炯炯有神。他就是谢丙堃，当时在武汉大学读书。</p>

  <p class="zw">去年年底，丙堃发了一份书稿给我，是关于现代C++的，我翻看了一下，书中选取了现代C++的40多个特征，每个特征一章，从多个角度解读这个特征。可贵的是，书中不仅有代码示例，结合实际代码来说理，还有作者的很多感悟和经验分享。</p>

  <p class="zw">现代社会中，每个人都忙忙碌碌，特别是程序员群体，大多忙得像个陀螺。人生就在这样的忙碌中一天天过去。偶尔的闲暇也往往被各种游戏和刷屏占据，顾不上思考人生的方向和怎么实现目标。丙堃能在工作之余，坚持3年之久，日积月累，沉淀下这样一份书稿，真是难能可贵，钦佩之余，略缀数语于书前，聊表寸心。</p>

  <p class="calibre5">张银奎　　　</p>

  <p class="calibre5">2021年3月于盛格塾</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/epub_0003.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/epub_0004.html"><div class="calibre">

  <h1 id="OEBPS/Text/epub_0004.html.nav_point_3" class="not-in-toc">前言</h1>

  <h2 class="sigil_not_in_toc" id="OEBPS/Text/epub_0004.html.nav_point_4">为什么要写这本书</h2>

  <p class="zw">近10年来C++的更新可谓是非常频繁，这让我在2017年时感受到了一丝不安。那个时候我发现在开源平台上已经有很多项目采用C++11和C++14标准编写，其中不乏一些知名的代码库，而公司里所用的编译环境还没有完全支持C++11，也很少有人真正了解过C++11的新特性。这带来一个很严重的问题，公司项目依赖的代码库更新到最新标准以后，我们将难以在一时之间维护甚至阅读它们，因为C++之父曾经说过“These enhancements are sufficient to make C++11 feel like a new language.”，他认为新特性的增强足以使C++11感觉像是一种新语言。可见即使是掌握C++11标准也需要将其当作一门新语言去学习，更何况当时的情况是C++17标准对C++又一次进行了大幅更新，很多原来的理解已经不准确甚至是不正确的了。尽管如此，我当时却没办法找到一本深入探讨C++11～C++17最新语言特性的书，在互联网上也只能找到零散的资料，并且大多数还是英文的。于是我产生了自己动手写一本深入探讨 C++最新语言特性的图书的想法。事实证明，我的担忧是有必要的。到目前为止已经有越来越多的项目开始迁移到新的C++标准，例如LLVM(C++14)、thrust(C++17)等，C++正在进入一个全新的时代，作为程序员的我们必须与时俱进地学习这些新特性来确保我们的技术不会过时。</p>

  <h2 class="sigil_not_in_toc" id="OEBPS/Text/epub_0004.html.nav_point_5">本书的组织结构</h2>

  <p class="zw">本书的内容编排是理论结合实践，涵盖了C++11～C++20全部新增的语言核心特性，本书既能当作一本教材让读者可以由浅入深、由基础特性到高级特性来掌握新增特性的原理和用法，也能作为一本“字典”让读者有针对性地查阅单个特性。</p>

  <p class="zw">本书分为两个部分，第一部分（第1～34章）是讲解基础特性，这部分内容在编程过程中会经常用到，具体如下。</p>

  <p class="zw">第1章介绍C++11～C++20新增的基础类型，包括新的long long整型和多个新字符类型。</p>

  <p class="zw">第2章介绍内联和嵌套命名空间，通过本章读者将学到如何在外部无感知的情况下切换命名空间。</p>

  <p class="zw">第3章探讨了新特性中的重点auto占位符，探究它的推导规则，在lambda表达式中的应用，这将会是读者在现今C++中用到最多的关键字。</p>

  <p class="zw">第4章探讨了decltype说明符，同样阐述了其推导规则，并将decltype(auto)和auto做了详细比较，有助于读者厘清两者的区别。</p>

  <p class="zw">第5章介绍了函数返回类型后置特性，读者可以通过这种函数声明方式让编译器自动推导返回类型。</p>

  <p class="zw">第6章深入探讨了右值引用，该特性是所有新特性中最难理解的特性之一。本章一步一步引导读者理解右值引用的含义和用途，并介绍其在移动语义中发挥的重要作用。另外还深入介绍了值类别，包括泛左值、纯右值和将亡值。</p>

  <p class="zw">第7章介绍了lambda表达式特性，C++11～C++20逐步递进地讨论了lambda表达式功能的增强，包括基础语法、广义捕获、泛型lambda表达式以及如何在lambda表达式中使用模板语法。</p>

  <p class="zw">第8章介绍了新的类成员的初始化方法，并且阐述了该方法与初始化列表的区别和优势。</p>

  <p class="zw">第9章探究了列表初始化，该特性为初始化容器类型的对象提供了方便。本章详细描述了其工作原理并且演示了如何让自定义容器支持列表初始化。</p>

  <p class="zw">第10章介绍了指定默认和删除函数的方法，读者通过本章可以学到如何通过指定默认函数强制编译器生成函数，以及删除特定函数让编译器无法自动生成。</p>

  <p class="zw">第11章介绍非受限联合类型，该特性可以解决联合类型在C++中缺乏实用性的问题，通过非受限联合类型可以在联合类型中声明非平凡类型成员。</p>

  <p class="zw">第12章和第13章介绍了委托构造函数和继承构造函数，它们都是为了解决C++类中构造函数代码冗余的问题。</p>

  <p class="zw">第14章探究了强枚举类型，强枚举类型解决了普通枚举类型中几个一直被诟病的问题，包括类型检查不严格、底层类型定义不清晰等。</p>

  <p class="zw">第15章详细探讨了扩展的聚合类型，阐明聚合类型的新定义，指出该新定义下过去代码中可能出现的问题。</p>

  <p class="zw">第16章介绍了override和final说明符，说明了重写、重载和隐藏的区别，读者可以通过这两个说明符将虚函数重写的语法检查工作交给编译器。</p>

  <p class="zw">第17章深入探讨了基于范围的for循环，该特性能简化枚举容器中元素的代码，除了描述该特性的使用方法，本章还说明了for循环的实现原理，并且实现了一个支持基于范围的for循环容器例子。</p>

  <p class="zw">第18章介绍了支持初始化语句的if和switch，使用该特性可以将变量的初始化以及条件判断统一到相同的作用域。</p>

  <p class="zw">第19章介绍了static_assert关键字，读者可以通过本章了解如何通过static_assert让代码在编译阶段就找到错误。</p>

  <p class="zw">第20章深入探讨了结构化绑定的使用方式、规则和原理，通过本章，读者将学会如何让C++像Python一样返回多个值，如何让一个第三方类型支持结构化绑定语法。</p>

  <p class="zw">第21章介绍了noexcept关键字，描述了noexcept相对于throw()的优势，并且探讨了noexcept在作为运算符时如何为移动构造函数提供异常控制的支持。</p>

  <p class="zw">第22章讨论了类型别名和别名模板，读者通过本章将学会通过using关键字定义类型别名，并且掌握别名模板为后续模板的相关特性打下基础。</p>

  <p class="zw">第23章介绍了指针字面量nullptr，讨论了nullptr对比0作为空指针常量的优势。</p>

  <p class="zw">第24章探究了三向比较特性，阐述了三向比较运算符的语法，返回类型特征以及自动生成其他比较运算符的规则。</p>

  <p class="zw">第25章介绍了线程局部存储，读者可以从本章了解到编译器和操作系统支持线程局部存储的方法，以及线程局部存储解决了哪些问题。</p>

  <p class="zw">第26章介绍了扩展的inline说明符特性，该特性解决了类的非常量静态成员变量声明必须和定义分开的问题。</p>

  <p class="zw">第27章深入探究了常量表达式。本章有一定难度，不仅介绍了使用constexpr定义常量表达式函数、构造函数，并且分不同时期的标准探讨了使常量表达式成立的规则的变化，另外还讨论了constexpr在if控制结构、lambda表达式和虚函数中的应用。</p>

  <p class="zw">第28章讨论了表达式求值顺序的问题，新特性解决了C++17之前C++标准没有对表达式求值顺序做严格规定的问题。</p>

  <p class="zw">第29章讨论了新标准对字面量的优化，其中集中描述了新标准对二进制整数、十六进制浮点、原生字符串字面量的支持，另外还详细介绍了如何实现自定义字面量。</p>

  <p class="zw">第30章深入探讨了alignas和alignof关键字。本章从CPU的角度出发讨论了数据对齐对于程序运行效率的重要性，进而说明如何使用新标准提供的方式完成数据对齐，最后用实例证明了数据对齐对性能的影响。</p>

  <p class="zw">第31章介绍了属性说明符和标准属性，通过本章读者将学会使用属性的方法，了解指定属性的规则，并且能充分理解C++11到C++20中的9个标准属性。</p>

  <p class="zw">第32章介绍了新增预处理器和宏。本章展示了使用__has_include预处理器判断是否包含头文件的方法，并且介绍了一系列的特性测试宏，使用它们可以判断编译器对某个特性的支持程度。</p>

  <p class="zw">第33章深入探讨了协程的使用方法和原理，从如何简单地借助标准库使用协程入手，分别诠释了co_await、co_yield和co_return运算符原理，并且展示了如何自定义一个支持协程的类型。</p>

  <p class="zw">第34章是一些其他基础特性的优化，虽然这些特性比较简短不成体系但是却也相当重要，比如返回值优化，允许数组转换为未知范围的数组等。</p>

  <p class="zw">从第35章开始进入本书的第二部分，第二部分主要探讨的是模板相关的新特性，具体如下。</p>

  <p class="zw">第35章深入讨论了可变参数模板。本章中除了介绍可变参数模板的基本语法，还深入讨论了形参包展开的各种场景，展示了使用可变参数模板进行模板元编程的方法，最后探讨了C++17中折叠表达式的语法和规则。</p>

  <p class="zw">第36章介绍了新标准对typename的优化，新标准明确指明了可以省略typename的场景，并且让模板参数支持使用typename。</p>

  <p class="zw">第37章集中介绍了新标准对模板参数的改进，包括允许局部和匿名类型作为模板实参、将函数模板添加到ADL查找规则中等。</p>

  <p class="zw">第38章讨论了新标准模板推导的优化，在C++17标准之前实例化类模板必须显式指定模板实参，但是现在不需要了。本章介绍了使用构造函数推导类模板实参的方法以及它在各种场景下的应用。</p>

  <p class="zw">第39章介绍了用户定义推导指引，读者通过本章将学到如何通过自定义推导指引来控制编译器推导模板实例路径。</p>

  <p class="zw">第40章讨论了SFINAE规则，通过SFINAE规则开发人员能够控制编译器选择模板实例化的方法，SFINAE规则也是模板元编程必不可少的组成部分。</p>

  <p class="zw">第41章深入探讨了概念和约束，通过这部分内容读者可以体会到对编译器前所未有的掌控力，概念可以通过各方面约束编译器对模板的实例化。本章详细讨论了concept和requires的语法和使用规则，并且展示了其在可变参数模板和auto中的约束作用。</p>

  <p class="zw">第42章介绍了模板特性的其他优化，包括新增的变量模板以及使用friend声明模板形参的优化等。</p>

  <h2 class="sigil_not_in_toc" id="OEBPS/Text/epub_0004.html.nav_point_6">本书特色</h2>

  <p class="zw">本书并不是直接告诉读者C++11～C++20的新特性该怎么使用，而是希望读者通过本书能够了解新特性诞生的前因后果，用实际例子探讨过去C++中的缺陷以及新特性如何修复和完善优化，并且尽可能地描述新特性在编译器中的实现原理。它没有告诉读者“你应该这样使用这个新特性”，而是在说“嘿，我有一个不错的新特性，可以解决你手中的问题，它的原理是……而且关于这个特性我还有一个小故事，想听听么？”另外，为了保证新特性被编译器切实有效地实现，本书中几乎所有的代码都采用GCC、CLang和MSVC编译过。在编译器表现与C++标准描述不一致的时候会提醒读者注意其中的区别。</p>

  <h2 class="sigil_not_in_toc" id="OEBPS/Text/epub_0004.html.nav_point_7">读完这本书你将收获什么</h2>

  <p class="zw">为什么我的类在使用C++17标准后无法初始化对象了？</p>

  <p class="zw">为什么在不改变任何代码的情况下，用新编译器编译的程序运行效率提高了？</p>

  <p class="zw">想定义lambda表达式用于异步调用，却发现导致未定义的行为该怎么办？</p>

  <p class="zw">想让编辑器自动推导返回类型该怎么办？</p>

  <p class="zw">作为库的作者，想在客户调用库代码的时候判断客户提供的类是否具有某个成员函数，以及采用不同的实现方案时该怎么做？</p>

  <p class="zw">读完这本书读者不仅会找到以上这些问题的答案，还将了解答案背后的原理和故事。</p>

  <h2 class="sigil_not_in_toc" id="OEBPS/Text/epub_0004.html.nav_point_8">面向读者</h2>

  <p class="zw">本书的读者需要具有一定的C++基础，并且想要学习C++新特性或者因为工作项目需要学习C++新特性。对于有基础的读者来说，本书的大部分章节都比较容易理解，极少数章节可能需要反复阅读以加深理解。模板相关的大部分章节也不会成为阅读的障碍，有泛型编程和模板元编程经验的读者理解起来会更快一些。对于初学者来说，建议在阅读的时候手边备一本C++编程基础的图书，在阅读本书的时候会经常用到。</p>

  <h2 class="sigil_not_in_toc" id="OEBPS/Text/epub_0004.html.nav_point_9">致谢</h2>

  <p class="zw">感谢我的好友赵歆、李正伟，你们当年的提议和3年多来的鼓励给了我写这本书的信心和动力。</p>

  <p class="zw">感谢人民邮电出版社的各位编辑对本书出版付出的辛勤劳动，特别感谢陈聪聪编辑在本书从草稿到出版过程中对我的帮助，正是您的热情指导才让这本书如此迅速地与读者相见，也特别感谢张银奎老师对本书的认可并且为本书作序，谢谢你们。</p>

  <p class="zw">最后要感谢我的家人，没有你们的默默付出、鼓励和支持，我可能无法提笔写下这本书，感谢你们。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/epub_0004.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/epub_0005.html"><div class="calibre">
 
 <h1 id="OEBPS/Text/epub_0005.html.nav_point_10" class="not-in-toc">资源与支持</h1> 
 <p class="zw">本书由异步社区出品，社区（https://www.epubit.com/）为读者提供相关资源和后续服务。</p> 
 <h3 class="sigil_not_in_toc1" id="OEBPS/Text/epub_0005.html.nav_point_11">配套资源</h3> 
 <p class="zw">本书提供如下资源：</p> 
 <ul class="calibre6"> 
  <li class="di_1ji_wu_xu_lie_biao">本书源代码。</li> 
 </ul> 
 <p class="zw">要获得以上配套资源，请在异步社区本书页面中单击<img alt="" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE0AAAAcCAIAAACruaW1AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwwAADsIB3nSZJQAAAnNJREFUWEftmL1OG0EQx3mUSIQKgRQqRIOUR0LQYFLYRXgHFKRUCMmFHwFBiouuTOtr0rm9xsXdzV5mZ2ZvP42xRYLuwuhfrO/++/HbmT3bt9P+H/HOOaxIcKqmllZvQzWVtEx4nJDdVV9Pq6tP1dmHfuvqqLr+DD/vBczlhMfb6uJj2KHXuthDKKaznNXkOPQNQJMTphNOpaC+3A9N/Vd9ecBn1clnZBqGmG5DzrwQt40C5qU0sS7m46BLMy/ji9XZGJatyuUjLGzbEXl036mS4YMoYRZ0SYitW+UTaRdTWETT5MWzyzKxzBrtN6iJvWtxfBqTUTOFu8lTzDIlt14qHm9TzohBFk0Szs6MqzR7kV7fVC0LlDDQ9nm9Ohty4ggypUSqTBJi8xacBRCPzmeeqRWcWIqpMEhk1oWXj7k7+Uu17DLJBvYbTmeuFcchIZ54K06ao+MMzieuQDdycia6Y5TwuzCFwFec8yllTH0F1XDSjS7+NieGrivJGHHKKr26FQA/PPIVOY+fSYbzX+ez+0hzW05PvjOlxJOMAdzc6jLGY5w1b5FPJ3xOvfRf4YKiEH7L6eTK5ZSkCS1fjJ9Sa8RTvm4+/UXoDBizQ9LJcjokLicb9LcrpU43cppi7pKvEdO9Uj6lhJxdsGBul7iScd14vVQLeZjZouXR9GbRdsjhl618g/PpnRzZ5hVsKXgHTEseTjgOmxkP23xF3+MBETjetYRoOMOpAOrRYeAYgkaH0e/4yUloGoCC/2UY8HRbn++Gvl7rfBd+fGc6y4kBDzc6qwN4b/LlCEHg8ZuABZwc8Uuk3sWa92ADjnfOIUXb/gFMbq1Q09ZaSwAAAABJRU5ErkJggg==" width="77" height="28" class="calibre7">，跳转到下载界面，按提示进行操作即可。注意：为保证购书读者的权益，该操作会给出相关提示，要求输入提取码进行验证。</p> 
 <h3 class="sigil_not_in_toc1" id="OEBPS/Text/epub_0005.html.nav_point_12">提交错误信息</h3> 
 <p class="zw">作者和编辑尽最大努力来确保书中内容的准确性，但难免会存在疏漏。欢迎读者将发现的问题反馈给我们，帮助我们提升图书的质量。</p> 
 <p class="zw">当读者发现错误时，请登录异步社区，按书名搜索，进入本书页面，单击“提交勘误”，输入错误信息，单击“提交”按钮即可。本书的作者和编辑会对读者提交的错误信息进行审核，确认并接受后，读者将获赠异步社区的100积分。积分可用于在异步社区兑换优惠券、样书或奖品。</p> 
 <p class="tu"><img alt="" src="data:image/png;base64,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" width="479" height="266" class="calibre8"></p> 
 <h3 class="sigil_not_in_toc1" id="OEBPS/Text/epub_0005.html.nav_point_13">与我们联系</h3> 
 <p class="zw">我们的联系邮箱是chencongcong@ptpress.com.cn。</p> 
 <p class="zw">如果读者对本书有任何疑问或建议，请读者发邮件给我们，并请在邮件标题中注明本书书名，以便我们更高效地做出反馈。</p> 
 <p class="zw">如果读者有兴趣出版图书、录制教学视频，或者参与图书翻译、技术审校等工作，可以发邮件给我们；有意出版图书的作者也可以提交投稿。</p> 
 <p class="zw">如果读者所在的学校、培训机构或企业，想批量购买本书或异步社区出版的其他图书，也可以发邮件给我们。</p> 
 <p class="zw">如果读者在网上发现有针对异步社区出品图书的各种形式的盗版行为，包括对图书全部或部分内容的非授权传播，请读者将怀疑有侵权行为的链接发邮件给我们。读者的这一举动是对作者权益的保护，也是我们持续为读者提供有价值的内容的动力之源。</p> 
 <h3 class="sigil_not_in_toc1" id="OEBPS/Text/epub_0005.html.nav_point_14">关于异步社区和异步图书</h3> 
 <p class="zw">“异步社区”是人民邮电出版社旗下IT专业图书社区，致力于出版精品IT技术图书和相关学习产品，为作译者提供优质出版服务。异步社区创办于2015年8月，提供大量精品IT技术图书和电子书，以及高品质技术文章和视频课程。更多详情请访问异步社区官网https://www.epubit.com。</p> 
 <p class="zw">“异步图书”是由异步社区编辑团队策划出版的精品IT专业图书的品牌，依托于人民邮电出版社的计算机图书出版积累和专业编辑团队，相关图书在封面上印有异步图书的LOGO。异步图书的出版领域包括软件开发、大数据、AI、测试、前端、网络技术等。</p> 
 <p class="tu"><img alt="" src="data:image/jpg;base64,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" width="254" height="254" class="calibre9"></p> 
 <p class="tu_ti">异步社区</p> 
 <p class="tu"><img alt="" src="data:image/jpg;base64,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" width="248" height="249" class="calibre9"></p> 
 <p class="tu_ti">微信服务号</p> 
 <p class="zw"><br class="calibre3" id="OEBPS/Text/epub_0005.html.calibre_pb_1"></p> 
</div></div>
<div id="OEBPS/Text/chapter001.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter001.html.nav_point_15" class="not-in-toc">第1章　新基础类型（C++11～C++20）</h1>

  <h2 id="OEBPS/Text/chapter001.html.nav_point_16" class="sigil_not_in_toc">1.1　整数类型long long</h2>

  <p class="zw">整型<code class="calibre10">long long</code>虽然是C++11才新加入标准的，但是我们似乎很早就开始使用这个类型了，这其中包含了一个有趣的故事。</p>

  <p class="zw"><code class="calibre10">long long</code>这个类型早在1995年6月之前就由罗兰·哈丁格（Roland Hartinger）提出申请加入C++标准。但是当时的C++标准委员会以C语言中不存在这个基本类型为由，拒绝将这个类型加入C++中。而就在C++98标准出台的一年后，C99标准就添加了<code class="calibre10">long long</code>这个类型，并且流行的编译器也纷纷支持了该类型，这也就是我们很早就接触到<code class="calibre10">long long</code>的原因。在此之后C++标准委员会在C++11中才有计划将整型<code class="calibre10">long long</code>加入标准中。</p>

  <p class="zw">我们知道<code class="calibre10">long</code>通常表示一个32位整型，而<code class="calibre10">long long</code>则是用来表示一个64位的整型。不得不说，这种命名方式简单粗暴。不仅写法冗余，而且表达的含义也并不清晰。如果按照这个命名规则，那么128位整型就该被命名为<code class="calibre10">long long long</code>了。但是不管怎么样，<code class="calibre10">long long</code>既然已经加入了C++11的标准，那么我们能做的就是适应它，并且希望不会有<code class="calibre10">long long long</code>这种类型的诞生。</p>

  <p class="zw">C++标准中定义，<code class="calibre10">long long</code>是一个至少为64位的整数类型。请注意这里的用词“至少”，也就说<code class="calibre10">long long</code>的实际长度可能大于64位。不过我至今也没有看到大于64位长度的<code class="calibre10">long long</code>出现。另外，<code class="calibre10">long long</code>是一个有符号类型，对应的无符号类型为<code class="calibre10">unsigned long long</code>，当然读者可能看到过诸如<code class="calibre10">long long int</code>、<code class="calibre10">unsigned long long int</code>等类型，实际上它们和<code class="calibre10">long long</code>、<code class="calibre10">unsigned long long</code>具有相同的含义。C++标准还为其定义<code class="calibre10">LL</code>和<code class="calibre10">ULL</code>作为这两种类型的字面量后缀，所以在初始化<code class="calibre10">long long</code>类型变量的时候可以这么写：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10"><strong class="calibre1">long long x = 65536LL;</strong></code></pre>

  <p class="zw">当然，这里可以忽略<code class="calibre10">LL</code>这个字面量后缀，直接写成下面的形式也可以达到同样的效果：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10"><strong class="calibre1">long long x = 65536;</strong></code></pre>

  <p class="zw">要强调的是，字面量后缀并不是没有意义的，在某些场合下我们必须用到它才能让代码的逻辑正确，比如下面的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">long long x1 = 65536 &lt;&lt; 16;      // 计算得到的x1值为0
std::cout &lt;&lt; "x1 = " &lt;&lt; x1 &lt;&lt; std::endl;

long long x2 = 65536LL &lt;&lt; 16;    // 计算得到的x2值为4294967296（0x100000000）
std::cout &lt;&lt; "x2 = " &lt;&lt; x2 &lt;&lt; std::endl;</code></pre>

  <p class="zw">以上代码的目的是将<code class="calibre10">65536</code>左移16位，以获得一个更大的数值。但是，<code class="calibre10">x1</code>计算出来的值却是0，没有增大反而减小了。原因是在没有字面量后缀的情况下，这里的<code class="calibre10">65536</code>被当作32位整型操作，在左移16位以后，这个32位整型的值变成了0，所以事实是将0赋值给了<code class="calibre10">x1</code>，于是我们看到<code class="calibre10">x1</code>输出的结果为0。而在计算<code class="calibre10">x2</code>的过程中，代码给<code class="calibre10">65536</code>添加了字面量后缀<code class="calibre10">LL</code>，这使编译器将其编译为一个64位整型，左移16位后仍然可以获得正确的结果：<code class="calibre10">4294967296（0x100000000）</code>。另外，有些编译器可能在编译<code class="calibre10">long long x1 = 65536 &lt;&lt; 16;</code>的时候显示一些警告提示，而另一些编译器可能没有，无论如何我们必须在编写代码的时候足够小心，避免上面情况的发生。</p>

  <p class="zw">和其他整型一样，<code class="calibre10">long long</code>也能运用于枚举类型和位域，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10"> enum longlong_enum : long long {
      x1,
      x2
 };

 struct longlong_struct {
      long long x1 : 8;
      long long x2 : 24;
      long long x3 : 32;
 };

std::cout &lt;&lt; sizeof(longlong_enum::x1) &lt;&lt; std::endl;  // 输出大小为8
std::cout &lt;&lt; sizeof(longlong_struct) &lt;&lt; std::endl;    // 输出大小为8</code></pre>

  <p class="zw">作为一个新的整型<code class="calibre10">long long</code>，C++标准必须为它配套地加入整型的大小限制。在头文件中增加了以下宏，分别代表<code class="calibre10">long long</code>的最大值和最小值以及<code class="calibre10">unsigned long long</code>的最大值：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#define LLONG_MAX 9223372036854775807LL         // long long的最大值
#define LLONG_MIN (-9223372036854775807LL - 1)  // long long的最小值
#define ULLONG_MAX 0xffffffffffffffffULL        // unsigned long long的最大值</code></pre>

  <p class="zw">在C++中应该尽量少使用宏，用模板取而代之是明智的选择。C++标准中对标准库头文件做了扩展，特化了<code class="calibre10">long long</code>和<code class="calibre10">unsigned long long</code>版本的<code class="calibre10">numeric_ limits</code>类模板。这使我们能够更便捷地获取这些类型的最大值和最小值，如下面的代码示例：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;cstdio&gt;
int main(int argc, char *argv[])
{
      // 使用宏方法
      std::cout &lt;&lt; "LLONG_MAX = " &lt;&lt; LLONG_MAX &lt;&lt; std::endl;
      std::cout &lt;&lt; "LLONG_MIN = " &lt;&lt; LLONG_MIN &lt;&lt; std::endl;
      std::cout &lt;&lt; "ULLONG_MAX = " &lt;&lt; ULLONG_MAX &lt;&lt; std::endl;

      // 使用类模板方法
      std::cout &lt;&lt; "std::numeric_limits&lt;long long&gt;::max() = " 
            &lt;&lt; std::numeric_limits&lt;long long&gt;::max() &lt;&lt; std::endl;
      std::cout &lt;&lt; "std::numeric_limits&lt;long long&gt;::min() = " 
            &lt;&lt; std::numeric_limits&lt;long long&gt;::min() &lt;&lt; std::endl;
      std::cout &lt;&lt; "std::numeric_limits&lt;unsigned long long&gt;::max() = " 
            &lt;&lt; std::numeric_limits&lt;unsigned long long&gt;::max() &lt;&lt; std::endl;

      // 使用printf打印输出
      std::printf("LLONG_MAX = %lld\n", LLONG_MAX);
      std::printf("LLONG_MIN = %lld\n", LLONG_MIN);
      std::printf("ULLONG_MAX = %llu\n", ULLONG_MAX);
}</code></pre>

  <p class="zw">输出结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">LLONG_MAX = 9223372036854775807
LLONG_MIN = -9223372036854775808
ULLONG_MAX = 18446744073709551615
std::numeric_limits&lt;long long&gt;::max() = 9223372036854775807
std::numeric_limits&lt;long long&gt;::min() = -9223372036854775808
std::numeric_limits&lt;unsigned long long&gt;::max() = 18446744073709551615
LLONG_MAX = 9223372036854775807
LLONG_MIN = -9223372036854775808
ULLONG_MAX = 18446744073709551615</code></pre>

  <p class="zw">以上代码很容易理解，唯一需要说明的一点是，随着整型<code class="calibre10">long long</code>的加入，<code class="calibre10">std::printf</code>也加入了对其格式化打印的能力。新增的长度指示符<code class="calibre10">ll</code>可以用来指明变量是一个<code class="calibre10">long long</code>类型，所以我们分别使用<code class="calibre10">%lld</code>和<code class="calibre10">%llu</code>来格式化有符号和无符号的<code class="calibre10">long long</code>整型了。当然，使用C++标准的流输入/输出是一个更好的选择。</p>

  <h2 id="OEBPS/Text/chapter001.html.nav_point_17" class="sigil_not_in_toc">1.2　新字符类型char16_t和char32_t</h2>

  <p class="zw">在C++11标准中添加两种新的字符类型<code class="calibre10">char16_t</code>和<code class="calibre10">char32_t</code>，它们分别用来对应Unicode字符集的UTF-16和UTF-32两种编码方法。在正式介绍它们之前，需要先弄清楚字符集和编码方法的区别。</p>

  <h3 id="OEBPS/Text/chapter001.html.nav_point_18" class="sigil_not_in_toc1">1.2.1　字符集和编码方法</h3>

  <p class="zw">通常我们所说的字符集是指系统支持的所有抽象字符的集合，通常一个字符集的字符是稳定的。而编码方法是利用数字和字符集建立对应关系的一套方法，这个方法可以有很多种，比如Unicode字符集就有UTF-8、UTF-16和UTF-32这3种编码方法。除了Unicode字符集，我们常见的字符集还包括ASCII字符集、GB2312字符集、BIG5字符集等，它们都有各自的编码方法。字符集需要和编码方式对应，如果这个对应关系发生了错乱，那么我们就会看到计算机世界中令人深恶痛绝的乱码。不过，现在的计算机世界逐渐达成了一致，就是尽量以Unicode作为字符集标准，那么剩下的工作就是处理UTF-8、UTF-16和UTF-32这3种编码方法的问题了。</p>

  <p class="zw">UTF-8、UTF-16和UTF-32简单来说是使用不同大小内存空间的编码方法。</p>

  <p class="zw">UTF-32是最简单的编码方法，该方法用一个32位的内存空间（也就是4字节）存储一个字符编码，由于Unicode字符集的最大个数为0x10FFFF（ISO 10646），因此4字节的空间完全能够容纳任何一个字符编码。UTF-32编码方法的优点显而易见，它非常简单，计算字符串长度和查找字符都很方便；缺点也很明显，太占用内存空间。</p>

  <p class="zw">UTF-16编码方法所需的内存空间从32位缩小到16位（占用2字节），但是由于存储空间的缩小，因此UTF-16最多只能支持0xFFFF个字符，这显然不太够用，于是UTF-16采用了一种特殊的方法来表达无法表示的字符。简单来说，从0x0000～0xD7FF以及0xE000～0xFFFF直接映射到Unicode字符集，而剩下的0xD800～0xDFFF则用于映射0x10000～0x10FFFF的Unicode字符集，映射方法为：字符编码减去0x10000后剩下的20比特位分为高位和低位，高10位的映射范围为0xD800～0xDBFF，低10位的映射范围为0xDC00～0xDFFF。例如0x10437，减去0x10000后的高低位分别为0x1和0x37，分别加上0xD800和0xDC00的结果是0xD801和0xDC37。</p>

  <p class="zw">幸运的是，一般情况下0xFFFF足以覆盖日常字符需求，我们也不必为了UTF-16的特殊编码方法而烦恼。UTF-16编码的优势是可以用固定长度的编码表达常用的字符，所以计算字符长度和查找字符也比较方便。另外，在内存空间使用上也比UTF-32好得多。</p>

  <p class="zw">最后说一下我们最常用的UTF-8编码方法，它是一种可变长度的编码方法。由于UTF-8编码方法只占用8比特位（1字节），因此要表达完数量高达0x10FFFF的字符集，它采用了一种前缀编码的方法。这个方法可以用1～4字节表示字符个数为0x10FFFF的Unicode（ISO 10646）字符集。为了尽量节约空间，常用的字符通常用1～2字节就能表达，其他的字符才会用到3～4字节，所以在内存空间可以使用UTF-8，但是计算字符串长度和查找字符在UTF-8中却是一个令人头痛的问题。表1-1展示了UTF-8对应的范围。</p>

  <p class="zw">▼表1-1</p>

  <table border="1" width="90%" class="calibre11">
    <thead class="calibre12">
      <tr class="calibre13">
        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">代码范围 十六进制</p>
        </th>

        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">UTF-8 二进制</p>
        </th>

        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">注释</p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre15">
      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">000000～00007F 128个代码</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">0zzzzzzz</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">ASCII字符范围，字节由零开始</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">000080～0007FF 1920个代码</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">110yyyyy 10zzzzzz</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">第1字节由110开始，接着的字节由10开始</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">000800～00D7FF 00E000～00FFFF 61440个代码</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">1110xxxx 10yyyyyy 10zzzzzz</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">第1字节由1110开始，接着的字节由10开始</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">010000～10FFFF 1048576个代码</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11110www 10xxxxxx 10yyyyyy 10zzzzzz</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">将由11110开始，接着的字节从10开始</p>
        </td>
      </tr>
    </tbody>
  </table>

  <h3 id="OEBPS/Text/chapter001.html.nav_point_19" class="sigil_not_in_toc1">1.2.2　使用新字符类型char16_t和char32_t</h3>

  <p class="zw">对于UTF-8编码方法而言，普通类型似乎是无法满足需求的，毕竟普通类型无法表达变长的内存空间。所以一般情况下我们直接使用基本类型<code class="calibre10">char</code>进行处理，而过去也没有一个针对UTF-16和UTF-32的字符类型。到了C++11，<code class="calibre10">char16_t</code>和<code class="calibre10">char32_t</code>的出现打破了这个尴尬的局面。除此之外，C++11标准还为3种编码提供了新前缀用于声明3种编码字符和字符串的字面量，它们分别是UTF-8的前缀<code class="calibre10">u8</code>、UTF-16的前缀<code class="calibre10">u</code>和UTF-32的前缀<code class="calibre10">U</code>：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10"><strong class="calibre1">char utf8c = u8'a';             // C++17标准</strong>
<strong class="calibre1">//char utf8c = u8'好';</strong>
<strong class="calibre1">char16_t utf16c = u'好';</strong>
<strong class="calibre1">char32_t utf32c = U'好';</strong>
<strong class="calibre1">char utf8[] = u8"你好世界";</strong>
<strong class="calibre1">char16_t utf16[] = u"你好世界";</strong>
<strong class="calibre1">char32_t utf32[] = U"你好世界";</strong></code></pre>

  <p class="zw">在上面的代码中，分别使用UTF-8、UTF-16和UTF-32编码的字符和字符串对变量进行了初始化，代码很简单，不过还是有两个地方值得一提。</p>

  <p class="zw"><code class="calibre10">char utf8c = u8'a'</code>在C++11标准中实际上是无法编译成功的，因为在C++11标准中<code class="calibre10">u8</code>只能作为字符串字面量的前缀，而无法作为字符的前缀。这个问题直到C++17标准才得以解决，所以上述代码需要C++17的环境来执行编译。</p>

  <p class="zw"><code class="calibre10">char utf8c = u8'好'</code>是无法通过编译的，因为存储“好”需要3字节，显然utf8c只能存储1字节，所以会编译失败。</p>

  <h3 id="OEBPS/Text/chapter001.html.nav_point_20" class="sigil_not_in_toc1">1.2.3　wchar_t存在的问题</h3>

  <p class="zw">在C++98的标准中提供了一个<code class="calibre10">wchar_t</code>字符类型，并且还提供了前缀<code class="calibre10">L</code>，用它表示一个宽字符。事实上Windows系统的API使用的就是<code class="calibre10">wchar_t</code>，它在Windows内核中是一个最基础的字符类型：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10"><strong class="calibre1">HANDLE CreateFileW(</strong>
<strong class="calibre1">  LPCWSTR lpFileName,</strong>
<strong class="calibre1">  </strong>…
<strong class="calibre1">);</strong>

<strong class="calibre1">CreateFileW(L"c:\\tmp.txt", </strong>…<strong class="calibre1">);</strong></code></pre>

  <p class="zw">上面是一段在Windows系统上创建文件的伪代码，可以看出Windows为创建文件的API提供了宽字符版本，其中LPCWSTR实际上是<code class="calibre10">const wchar_t</code>的指针类型，我们可以通过<code class="calibre10">L</code>前缀来定义一个<code class="calibre10">wchar_t</code>类型的字符串字面量，并且将其作为实参传入API。</p>

  <p class="zw">讨论到这里读者会产生一个疑问，既然已经有了处理宽字符的字符类型，那么为什么又要加入新的字符类型呢？没错，<code class="calibre10">wchar_t</code>确实在一定程度上能够满足我们对于字符表达的需求，但是起初在定义<code class="calibre10">wchar_t</code>时并没有规定其占用内存的大小。于是就给了实现者充分的自由，以至于在Windows上<code class="calibre10">wchar_t</code>是一个16位长度的类型（2字节），而在Linux和macOS上<code class="calibre10">wchar_t</code>却是32位的（4字节）。这导致了一个严重的后果，我们写出的代码无法在不同平台上保持相同行为。而<code class="calibre10">char16_t</code>和<code class="calibre10">char32_t</code>的出现解决了这个问题，它们明确规定了其所占内存空间的大小，让代码在任何平台上都能够有一致的表现。</p>

  <h3 id="OEBPS/Text/chapter001.html.nav_point_21" class="sigil_not_in_toc1">1.2.4　新字符串连接</h3>

  <p class="zw">由于字符类型增多，因此我们还需要了解一下字符串连接的规则：如果两个字符串字面量具有相同的前缀，则生成的连接字符串字面量也具有该前缀，如表1-2所示。如果其中一个字符串字面量没有前缀，则将其视为与另一个字符串字面量具有相同前缀的字符串字面量，其他的连接行为由具体实现者定义。另外，这里的连接操作是编译时的行为，而不是一个转换。</p>

  <p class="zw">▼表1-2</p>

  <table border="1" width="90%" class="calibre11">
    <thead class="calibre12">
      <tr class="calibre13">
        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">源代码</p>
        </th>

        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">等同于</p>
        </th>

        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">
        </p></th>

        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">源代码</p>
        </th>

        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">等同于</p>
        </th>

        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">
        </p></th>

        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">源代码</p>
        </th>

        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">等同于</p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre15">
      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">u"a" u"b"</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">u"ab"</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">
        </p></td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">U"a" U"b"</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">U"ab"</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">
        </p></td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">L"a" L"b"</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">L"ab"</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">u"a" "b"</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">u"ab"</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">
        </p></td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">U"a" "b"</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">U"ab"</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">
        </p></td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">L"a" "b"</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">L"ab"</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">"a" u"b"</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">u"ab"</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">
        </p></td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">"a" U"b"</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">U"ab"</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">
        </p></td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">"a" L"b"</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">L"ab"</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="zw">需要注意的是，进行连接的字符依然是保持独立的，也就是说不会因为字符串连接，将两个字符合并为一个，例如连接<code class="calibre10">"\xA" "B"</code>的结果应该是<code class="calibre10">"\nB"</code>（换行符和字符B），而不是一个字符<code class="calibre10">"\xAB"</code>。</p>

  <h3 id="OEBPS/Text/chapter001.html.nav_point_22" class="sigil_not_in_toc1">1.2.5　库对新字符类型的支持</h3>

  <p class="zw">随着新字符类型加入C++11标准，相应的库函数也加入进来。C11在中增加了4个字符的转换函数，包括：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10"><strong class="calibre1">size_t mbrtoc16( char16_t</strong>*<strong class="calibre1"> pc16, const char</strong>*<strong class="calibre1"> s, size_t n, mbstate_t</strong>*<strong class="calibre1"> ps );</strong>
<strong class="calibre1">size_t c16rtomb( char</strong>*<strong class="calibre1"> s, char16_t c16, mbstate_t</strong>*<strong class="calibre1"> ps );</strong>
<strong class="calibre1">size_t mbrtoc32( char32_t</strong>*<strong class="calibre1"> pc32, const char</strong>*<strong class="calibre1"> s, size_t n, mbstate_t</strong>*<strong class="calibre1"> ps );</strong>
<strong class="calibre1">size_t c32rtomb( char</strong>*<strong class="calibre1"> s, char32_t c32, mbstate_t</strong>*<strong class="calibre1"> ps );</strong></code></pre>

  <p class="zw">它们的功能分别是多字节字符和UTF-16编码字符互转，以及多字节字符和UTF-32编码字符互转。在C++11中，我们可以通过包含<code class="calibre10">&lt;cuchar&gt;</code>来使用这4个函数。当然C++11中也添加了C++风格的转发方法<code class="calibre10">std::wstring_convert</code>以及<code class="calibre10">std::codecvt</code>。使用类模板<code class="calibre10">std::wstring_convert</code>和<code class="calibre10">std::codecvt</code>相结合，可以对多字节字符串和宽字符串进行转换。不过这里并不打算花费篇幅介绍这些转换方法，因为它们在C++17标准中已经不被推荐使用了，所以应该尽量避免使用它们。</p>

  <p class="zw">除此之外，C++标准库的字符串也加入了对新字符类型的支持，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10"><strong class="calibre1">using u16string = basic_string;</strong>
<strong class="calibre1">using u32string = basic_string;</strong>
<strong class="calibre1">using wstring = basic_string;</strong></code></pre>

  <h2 id="OEBPS/Text/chapter001.html.nav_point_23" class="sigil_not_in_toc">1.3　char8_t字符类型</h2>

  <p class="zw">使用char类型来处理UTF-8字符虽然可行，但是也会带来一些困扰，比如当库函数需要同时处理多种字符时必须采用不同的函数名称以区分普通字符和UTF-8字符。C++20标准新引入的类型<code class="calibre10">char8_t</code>可以解决以上问题，它可以代替<code class="calibre10">char</code>作为UTF-8的字符类型。<code class="calibre10">char8_t</code>具有和<code class="calibre10">unsigned char</code>相同的符号属性、存储大小、对齐方式以及整数转换等级。引入<code class="calibre10">char8_t</code>类型后，在C++17环境下可以编译的UTF-8字符相关的代码会出现问题，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10"><strong class="calibre1">char str[] = u8"text";  // C++17编译成功；C++20编译失败，需要char8_t</strong>
<strong class="calibre1">char c = u8'c';</strong></code></pre>

  <p class="zw">当然反过来也不行：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10"><strong class="calibre1">char8_t c8a[] = "text"; // C++20编译失败，需要char</strong>
<strong class="calibre1">char8_t c8 = 'c';</strong></code></pre>

  <p class="zw">另外，为了匹配新的<code class="calibre10">char8_t</code>字符类型，库函数也有相应的增加：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10"><strong class="calibre1">size_t mbrtoc8(char8_t</strong>*<strong class="calibre1"> pc8, const char</strong>*<strong class="calibre1"> s, size_t n, mbstate_t</strong>*<strong class="calibre1"> ps);</strong>
<strong class="calibre1">size_t c8rtomb(char</strong>*<strong class="calibre1"> s, char8_t c8, mbstate_t</strong>*<strong class="calibre1"> ps);</strong>

<strong class="calibre1">using u8string = basic_string;</strong></code></pre>

  <p class="zw">最后需要说明的是，上面这些例子只是C++标准库为新字符类型新增代码的冰山一角，有兴趣的读者可以翻阅标准库代码，包括<code class="calibre10">&lt;atomic&gt;</code>、<code class="calibre10">&lt;filesystem&gt;</code>、<code class="calibre10">&lt;istream&gt;</code>、<code class="calibre10">&lt;limits&gt;</code>、<code class="calibre10">&lt;locale&gt;</code>、<code class="calibre10">&lt;ostream&gt;</code>、<code class="calibre10">&lt;string&gt;</code>以及<code class="calibre10">&lt;string_ view&gt;</code>等头文件，这里就不一一介绍了。</p>

  <h2 id="OEBPS/Text/chapter001.html.nav_point_24" class="sigil_not_in_toc">1.4　总结</h2>

  <p class="zw">本章从C++最基础的新特性入手，介绍了整型<code class="calibre10">long long</code>以及<code class="calibre10">char8_t</code>、<code class="calibre10">char16_t</code>和<code class="calibre10">char32_t</code>字符类型。虽说这些新的基础类型非常简单，但是磨刀不误砍柴工，掌握新基础类型（尤其是3种不同的Unicode字符类型）会让我们在使用C++处理字符、字符串以及文本方面更加游刃有余。比如，当你正在为处理文本文件中UTF-32编码的字符而头痛时，采用新标准中<code class="calibre10">char32_t</code>和<code class="calibre10">u32string</code>也许会让问题迎刃而解。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter001.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter002.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter002.html.nav_point_25" class="not-in-toc">第2章　内联和嵌套命名空间（C++11～C++20）</h1>

  <h2 id="OEBPS/Text/chapter002.html.nav_point_26" class="sigil_not_in_toc">2.1　内联命名空间的定义和使用</h2>

  <p class="zw">开发一个大型工程必然会有很多开发人员的参与，也会引入很多第三方库，这导致程序中偶尔会碰到同名函数和类型，造成编译冲突的问题。为了缓解该问题对开发的影响，我们需要合理使用命名空间。程序员可以将函数和类型纳入命名空间中，这样在不同命名空间的函数和类型就不会产生冲突，当要使用它们的时候只需打开其指定的命名空间即可，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">namespace S1 {
  void foo() {}
}

namespace S2 {
  void foo() {}
}

using namespace S1;

int main()
{
  foo();
  S2::foo();
}</code></pre>

  <p class="zw">以上是命名空间的一个典型例子，例子中命名空间<code class="calibre10">S1</code>和<code class="calibre10">S2</code>都有相同的函数<code class="calibre10">foo</code>，在调用两个函数时，由于命名空间<code class="calibre10">S1</code>被<code class="calibre10">using</code>关键字打开，因此<code class="calibre10">S1</code>的<code class="calibre10">foo</code>函数可以直接使用，而<code class="calibre10">S2</code>的<code class="calibre10">foo</code>函数需要使用::来指定函数的命名空间。</p>

  <p class="zw">C++11标准增强了命名空间的特性，提出了内联命名空间的概念。内联命名空间能够把空间内函数和类型导出到父命名空间中，这样即使不指定子命名空间也可以使用其空间内的函数和类型了，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

namespace Parent {
  namespace Child1
  {
      void foo() { std::cout &lt;&lt; "Child1::foo()" &lt;&lt; std::endl; }
  }

  inline namespace Child2
  {
      void foo() { std::cout &lt;&lt; "Child2::foo()" &lt;&lt; std::endl; }
  }
}

int main()
{
  Parent::Child1::foo();
  Parent::foo();
}</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">Child1</code>不是一个内联命名空间，所以调用<code class="calibre10">Child1</code>的<code class="calibre10">foo</code>函数需要明确指定所属命名空间。而调用<code class="calibre10">Child2</code>的<code class="calibre10">foo</code>函数则方便了许多，直接指定父命名空间即可。现在问题来了，这个新特性的用途是什么呢？这里删除内联命名空间，将<code class="calibre10">foo</code>函数直接纳入<code class="calibre10">Parent</code>命名空间也能达到同样的效果。</p>

  <p class="zw">实际上，该特性可以帮助库作者无缝升级库代码，让客户不用修改任何代码也能够自由选择新老库代码。举个例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

namespace Parent {
void foo() { std::cout &lt;&lt; "foo v1.0" &lt;&lt; std::endl; }
}

int main()
{
  Parent::foo();
}</code></pre>

  <p class="zw">假设现在<code class="calibre10">Parent</code>代码库提供了一个接口<code class="calibre10">foo</code>来完成一些工作，突然某天由于加入了新特性，需要升级接口。有些用户喜欢新的特性但并不愿意为了新接口去修改他们的代码；还有部分用户认为新接口影响了稳定性，所以希望沿用老的接口。这里最直接的办法是提供两个不同的接口函数来对应不同的版本。但是如果库中函数很多，则会出现大量需要修改的地方。另一个方案就是使用内联命名空间，将不同版本的接口归纳到不同的命名空间中，然后给它们一个容易辨识的空间名称，最后将当前最新版本的接口以内联的方式导出到父命名空间中，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">namespace Parent {
  namespace V1 {
      void foo() { std::cout &lt;&lt; "foo v1.0" &lt;&lt; std::endl; }
  }

  inline namespace V2 {
      void foo() { std::cout &lt;&lt; "foo v2.0" &lt;&lt; std::endl; }
  }
}

int main()
{
  Parent::foo();
}</code></pre>

  <p class="zw">从上面的代码可以看出，虽然<code class="calibre10">foo</code>函数从<code class="calibre10">V1</code>升级到了<code class="calibre10">V2</code>，但是客户的代码并不需要任何修改。如果用户还想使用<code class="calibre10">V1</code>版本的函数，则只需要统一添加函数版本的命名空间，比如<code class="calibre10">Parent::V1::foo()</code>。使用这种方式管理接口版本非常清晰，如果想加入<code class="calibre10">V3</code>版本的接口，则只需要创建<code class="calibre10">V3</code>的内联命名空间，并且将命名空间<code class="calibre10">V2</code>的<code class="calibre10">inline</code>关键字删除。请注意，示例代码中只能有一个内联命名空间，否则编译时会造成二义性问题，编译器不知道使用哪个内联命名空间的<code class="calibre10">foo</code>函数。</p>

  <h2 id="OEBPS/Text/chapter002.html.nav_point_27" class="sigil_not_in_toc">2.2　嵌套命名空间的简化语法</h2>

  <p class="zw">有时候打开一个嵌套命名空间可能只是为了向前声明某个类或者函数，但是却需要编写冗长的嵌套代码，加入一些无谓的缩进，这很难让人接受。幸运的是，C++17标准允许使用一种更简洁的形式描述嵌套命名空间，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">namespace A::B::C {
  int foo() { return 5; }
}</code></pre>

  <p class="zw">以上代码等同于：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">namespace A {
  namespace B {
      namespace C {
            int foo() { return 5; }
      }
  }
}</code></pre>

  <p class="zw">很显然前者是一种更简洁的定义嵌套命名空间的方法。除简洁之外，它也更加符合我们已有的语法习惯，比如嵌套类：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::vector&lt;int&gt;::iterator it;</code></pre>

  <p class="zw">实际上这份语法规则的提案早在2003年的时候就已经提出，只不过到C++17才被正式引入标准。另外有些遗憾的是，在C++17标准中没有办法简洁地定义内联命名空间，这个问题直到C++20标准才得以解决。在C++20中，我们可以这样定义内联命名空间：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">namespace A::B::inline C {
    int foo() { return 5; }
}
// 或者
namespace A::inline B::C {
    int foo() { return 5; }
}</code></pre>

  <p class="zw">它们分别等同于：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">namespace A::B { 
    inline namespace C {
        int foo() { return 5; }
    } 
}

namespace A { 
    inline namespace B { 
        namespace C {
            int foo() { return 5; }
        } 
    } 
}</code></pre>

  <p class="zw">请注意，<code class="calibre10">inline</code>可以出现在除第一个<code class="calibre10">namespace</code>之外的任意<code class="calibre10">namespace</code>之前。</p>

  <h2 id="OEBPS/Text/chapter002.html.nav_point_28" class="sigil_not_in_toc">2.3　总结</h2>

  <p class="zw">本章主要介绍内联命名空间，正如上文中介绍的，该特性可以帮助库作者无缝切换代码版本而无须库的使用者参与。另外，使用新的嵌套命名空间语法能够有效消除代码冗余，提高代码的可读性。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter002.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter003.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter003.html.nav_point_29" class="not-in-toc">第3章　auto占位符（C++11～C++17）</h1>

  <h2 id="OEBPS/Text/chapter003.html.nav_point_30" class="sigil_not_in_toc">3.1 重新定义的auto关键字</h2>

  <p class="zw">严格来说<code class="calibre10">auto</code>并不是一个新的关键字，因为它从C++98标准开始就已经存在了。当时<code class="calibre10">auto</code>是用来声明自动变量的，简单地说，就是拥有自动生命期的变量，显然这是多余的，现在我们几乎不会使用它。于是C++11标准赋予了<code class="calibre10">auto</code>新的含义：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto i = 5;                      // 推断为int
auto str = "hello auto";         // 推断为const char*
auto sum(int a1, int a2)-&gt;int    // 返回类型后置，auto为返回值占位符
{
    return a1+a2;
}</code></pre>

  <p class="zw">在上面的代码中，我们不需要为<code class="calibre10">i</code>和<code class="calibre10">str</code>去声明具体的类型，<code class="calibre10">auto</code>要求编译器自动完成变量类型的推导工作。<code class="calibre10">sum</code>函数中的<code class="calibre10">auto</code>是一个返回值占位符，真正的返回值类型是<code class="calibre10">int</code>，<code class="calibre10">sum</code>函数声明采用了函数返回类型后置的方法，该方法主要用于函数模板的返回值推导（见第5章）。注意，<code class="calibre10">auto</code>占位符会让编译器去推导变量类型，如果我们编写的代码让编译器无法进行推导，那么使用<code class="calibre10">auto</code>会导致编译失败，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto i;    // 编译失败
i = 5;</code></pre>

  <p class="zw">很明显，以上代码在声明变量时没有对变量进行初始化，这使编译器无法确认其具体类型要导致编译错误，所以在使用<code class="calibre10">auto</code>占位符声明变量的时候必须初始化变量。进一步来说，有4点需要引起注意。</p>

  <p class="zw">1．当用一个<code class="calibre10">auto</code>关键字声明多个变量的时候，编译器遵从由左往右的推导规则，以最左边的表达式推断<code class="calibre10">auto</code>的具体类型：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int n = 5;
auto *pn = &amp;n, m = 10;</code></pre>

  <p class="zw">在上面的代码中，因为<code class="calibre10">&amp;n</code>类型为<code class="calibre10">int *</code>，所以<code class="calibre10">pn</code>的类型被推导为<code class="calibre10">int *</code>，<code class="calibre10">auto</code>被推导为<code class="calibre10">int</code>，于是<code class="calibre10">m</code>被声明为<code class="calibre10">int</code>类型，可以编译成功。但是如果写成下面的代码，将无法通过编译：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int n = 5;
auto *pn = &amp;n, m = 10.0;  // 编译失败，声明类型不统一</code></pre>

  <p class="zw">上面两段代码唯一的区别在于赋值<code class="calibre10">m</code>的是浮点数，这和<code class="calibre10">auto</code>推导类型不匹配，所以编译器通常会给予一条“in a declarator-list 'auto' must always deduce to the same type”报错信息。细心的读者可能会注意到，如果将赋值代码替换为<code class="calibre10">int m = 10.0;</code>，则编译器会进行缩窄转换，最终结果可能会在给出一条警告信息后编译成功，而在使用auto声明变量的情况下编译器是直接报错的。</p>

  <p class="zw">2．当使用条件表达式初始化<code class="calibre10">auto</code>声明的变量时，编译器总是使用表达能力更强的类型：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto i = true ? 5 : 8.0;    // i的数据类型为double</code></pre>

  <p class="zw">在上面的代码中，虽然能够确定表达式返回的是<code class="calibre10">int</code>类型，但是i的类型依旧会被推导为表达能力更强的类型<code class="calibre10">double</code>。</p>

  <p class="zw">3．虽然C++11标准已经支持在声明成员变量时初始化（见第8章），但是<code class="calibre10">auto</code>却无法在这种情况下声明非静态成员变量：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct sometype {
    auto i = 5;    // 错误，无法编译通过
};</code></pre>

  <p class="zw">在C++11中静态成员变量是可以用<code class="calibre10">auto</code>声明并且初始化的，不过前提是<code class="calibre10">auto</code>必须使用<code class="calibre10">const</code>限定符：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct sometype {
    static const auto i = 5;
};</code></pre>

  <p class="zw">遗憾的是，<code class="calibre10">const</code>限定符会导致<code class="calibre10">i</code>常量化，显然这不是我们想要的结果。幸运的是，在C++17标准中，对于静态成员变量，<code class="calibre10">auto</code>可以在没有<code class="calibre10">const</code>的情况下使用，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct sometype {
    static inline auto i = 5;    // C++17
};</code></pre>

  <p class="zw">4．按照C++20之前的标准，无法在函数形参列表中使用<code class="calibre10">auto</code>声明形参（注意，在C++14中，<code class="calibre10">auto</code>可以为lambda表达式声明形参）：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void echo(auto str) {…} // C++20之前编译失败，C++20编译成功</code></pre>

  <p class="zw">另外，<code class="calibre10">auto</code>也可以和<code class="calibre10">new</code>关键字结合。当然，我们通常不会这么用，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto i = new auto(5);
auto* j = new auto(5);</code></pre>

  <p class="zw">这种用法比较有趣，编译器实际上进行了两次推导，第一次是<code class="calibre10">auto(5)</code>，<code class="calibre10">auto</code>被推导为<code class="calibre10">int</code>类型，于是<code class="calibre10">new int</code>的类型为<code class="calibre10">int *</code>，再通过<code class="calibre10">int *</code>推导<code class="calibre10">i</code>和<code class="calibre10">j</code>的类型。我不建议像上面这样使用<code class="calibre10">auto</code>，因为它会破坏代码的可读性。在后面的内容中，我们将讨论应该在什么时候避免使用<code class="calibre10">auto</code>关键字。</p>

  <h2 id="OEBPS/Text/chapter003.html.nav_point_31" class="sigil_not_in_toc">3.2 推导规则</h2>

  <p class="zw">1．如果<code class="calibre10">auto</code>声明的变量是按值初始化，则推导出的类型会忽略<code class="calibre10">cv</code>限定符。进一步解释为，在使用<code class="calibre10">auto</code>声明变量时，既没有使用引用，也没有使用指针，那么编译器在推导的时候会忽略<code class="calibre10">const</code>和<code class="calibre10">volatile</code>限定符。当然<code class="calibre10">auto</code>本身也支持添加<code class="calibre10">cv</code>限定符：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">const int i = 5;
auto j = i;        // auto推导类型为int，而非const int
auto &amp;m = i;       // auto推导类型为const int，m推导类型为const int&amp;
auto *k = i;       // auto推导类型为const int，k推导类型为const int*
const auto n = j;  // auto推导类型为int，n的类型为const int</code></pre>

  <p class="zw">根据规则1，在上面的代码中，虽然<code class="calibre10">i</code>是<code class="calibre10">const int</code>类型，但是因为按值初始化会忽略<code class="calibre10">cv</code>限定符，所以<code class="calibre10">j</code>的推导类型是<code class="calibre10">int</code>而不是<code class="calibre10">const int</code>。而<code class="calibre10">m</code>和<code class="calibre10">k</code>分别按引用和指针初始化，因此其<code class="calibre10">cv</code>属性保留了下来。另外，可以用<code class="calibre10">const</code>结合<code class="calibre10">auto</code>，让<code class="calibre10">n</code>的类型推导为<code class="calibre10">const int</code>。</p>

  <p class="zw">2．使用<code class="calibre10">auto</code>声明变量初始化时，目标对象如果是引用，则引用属性会被忽略：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int i = 5;
int &amp;j = i;
auto m = j;    // auto推导类型为int，而非int&amp;</code></pre>

  <p class="zw">根据规则2，虽然<code class="calibre10">j</code>是<code class="calibre10">i</code>的引用，类型为<code class="calibre10">int&amp;</code>，但是在推导<code class="calibre10">m</code>的时候会忽略其引用。</p>

  <p class="zw">3．使用<code class="calibre10">auto</code>和万能引用声明变量时（见第6章），对于左值会将<code class="calibre10">auto</code>推导为引用类型：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int i = 5;
auto&amp;&amp; m = i;    // auto推导类型为int&amp; （这里涉及引用折叠的概念）
auto&amp;&amp; j = 5;    // auto推导类型为int</code></pre>

  <p class="zw">根据规则3，因为<code class="calibre10">i</code>是一个左值，所以<code class="calibre10">m</code>的类型被推导为<code class="calibre10">int&amp;</code>，<code class="calibre10">auto</code>被推导为<code class="calibre10">int&amp;</code>，这其中用到了引用折叠的规则。而5是一个右值，因此<code class="calibre10">j</code>的类型被推导为<code class="calibre10">int&amp;&amp;</code>，<code class="calibre10">auto</code>被推导为<code class="calibre10">int</code>。</p>

  <p class="zw">4．使用<code class="calibre10">auto</code>声明变量，如果目标对象是一个数组或者函数，则<code class="calibre10">auto</code>会被推导为对应的指针类型：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int i[5];
auto m = i;    // auto推导类型为int*
int sum(int a1, int a2)
{
    return a1+a2;
}
auto j = sum   // auto推导类型为int (__cdecl *)(int,int)</code></pre>

  <p class="zw">根据规则4，虽然<code class="calibre10">i</code>是数组类型，但是<code class="calibre10">m</code>会被推导退化为指针类型，同样，<code class="calibre10">j</code>也退化为函数指针类型。</p>

  <p class="zw">5．当<code class="calibre10">auto</code>关键字与列表初始化组合时，这里的规则有新老两个版本，这里只介绍新规则（C++17标准）。</p>

  <p class="zw">（1）直接使用列表初始化，列表中必须为单元素，否则无法编译，<code class="calibre10">auto</code>类型被推导为单元素的类型。</p>

  <p class="zw">（2）用等号加列表初始化，列表中可以包含单个或者多个元素，<code class="calibre10">auto</code>类型被推导为<code class="calibre10">std::initializer_list&lt;T&gt;</code>，其中<code class="calibre10">T</code>是元素类型。请注意，在列表中包含多个元素的时候，元素的类型必须相同，否则编译器会报错。</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto x1 = { 1, 2 };      // x1类型为 std::initializer_list&lt;int&gt;
auto x2 = { 1, 2.0 };    // 编译失败，花括号中元素类型不同
auto x3{ 1, 2 };         // 编译失败，不是单个元素
auto x4 = { 3 };         // x4类型为std::initializer_list&lt;int&gt;
auto x5{ 3 };            // x5类型为int</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">x1</code>根据规则5（2）被推导为<code class="calibre10">std::initializer_list&lt;T&gt;</code>，其中的元素都是<code class="calibre10">int</code>类型，所以<code class="calibre10">x1</code>被推导为<code class="calibre10">std::initializer_list&lt;int&gt;</code>。同样，<code class="calibre10">x2</code>也应该被推导为<code class="calibre10">std::initializer_list&lt;T&gt;</code>，但是显然两个元素类型不同，导致编译器无法确定<code class="calibre10">T</code>的类型，所以编译失败。根据规则5（1），<code class="calibre10">x3</code>包含多个元素，直接导致编译失败。<code class="calibre10">x4</code>和<code class="calibre10">x1</code>一样被推导为<code class="calibre10">std::initializer_ list&lt;int&gt;</code>，<code class="calibre10">x5</code>被推导为单元素的类型<code class="calibre10">int</code>。</p>

  <p class="zw">根据上面这些规则，读者可以思考下面的代码，<code class="calibre10">auto</code>会被推导成什么类型呢？</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class Base {
public:
  virtual void f()
  {
      std::cout &lt;&lt; "Base::f()" &lt;&lt; std::endl;
  };
};
class Derived : public Base {
public:
  virtual void f() override
  {
      std::cout &lt;&lt; "Derived::f()" &lt;&lt; std::endl;
  };
};
Base* d = new Derived();
auto b = *d;
b.f();</code></pre>

  <p class="zw">以上代码有<code class="calibre10">Derived</code>和<code class="calibre10">Base</code>之间的继承关系，并且<code class="calibre10">Derived</code>重写了<code class="calibre10">Base</code>的<code class="calibre10">f</code>函数。代码使用<code class="calibre10">new</code>创建了一个<code class="calibre10">Derived</code>对象，并赋值于基类的指针类型变量上。读者知道<code class="calibre10">d-&gt;f()</code>一定调用的是<code class="calibre10">Derived</code>的<code class="calibre10">f</code>函数。但是<code class="calibre10">b.f()</code>调用的又是谁的<code class="calibre10">f</code>函数呢？实际上，由于<code class="calibre10">auto b = *d</code>这一句代码是按值赋值的，因此<code class="calibre10">auto</code>会直接推导为<code class="calibre10">Base</code>。代码自然会调用<code class="calibre10">Base</code>的复制构造函数，也就是说<code class="calibre10">Derived</code>被切割成了<code class="calibre10">Base</code>，这里的<code class="calibre10">b.f()</code>最终调用<code class="calibre10">Base</code>的<code class="calibre10">f</code>函数。那么进一步发散，如果代码写的是<code class="calibre10">auto &amp;b = *d</code>，结果又会如何呢？这个就交给读者自己验证了。</p>

  <h2 id="OEBPS/Text/chapter003.html.nav_point_32" class="sigil_not_in_toc">3.3 什么时候使用auto</h2>

  <p class="zw">合理使用<code class="calibre10">auto</code>，可以让程序员从复杂的类型编码中解放出来，不但可以少敲很多代码，也会大大提高代码的可读性。但是事情总是有它的两面性，如果滥用<code class="calibre10">auto</code>，则会让代码失去可读性，不仅让后来人难以理解，间隔时间长了可能自己写的代码也要研读很久才能弄明白其含义。所以，下面我们来探讨一下，如何合理地使用<code class="calibre10">auto</code>。这里再多说一句，每个人对<code class="calibre10">auto</code>的使用可能有不同的理解，我这里阐述的是自己认为最合适的使用场景。首先简单归纳<code class="calibre10">auto</code>的使用规则。</p>

  <p class="zw">1．当一眼就能看出声明变量的初始化类型的时候可以使用<code class="calibre10">auto</code>。</p>

  <p class="zw">2．对于复杂的类型，例如<code class="calibre10">lambda</code>表达式、<code class="calibre10">bind</code>等直接使用<code class="calibre10">auto</code>。</p>

  <p class="zw">对于第一条规则，常见的是在容器的迭代器上使用，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::map&lt;std::string, int&gt; str2int;
// … 填充str2int的代码
for (std::map&lt;std::string, int&gt;::const_iterator it = str2int.cbegin();
  it != str2int.cend(); ++it) {}
// 或者
for (std::pair&lt;const std::string, int&gt; &amp;it : str2int) {}</code></pre>

  <p class="zw">上面的代码如果不用<code class="calibre10">auto</code>来声明迭代器，那么我们需要编写<code class="calibre10">std::map &lt;std::string, int&gt;::const_iterator</code>和<code class="calibre10">std::pair&lt;const std::string, int&gt;</code>来代替<code class="calibre10">auto</code>，而多出来的代码并不会增强代码的可读性，反而会让代码看起来冗余，因为通常我们一眼就能看明白<code class="calibre10">it</code>的具体类型。请注意，第二个<code class="calibre10">for</code>的<code class="calibre10">it</code>类型是<code class="calibre10">std::pair&lt;const std::string, int&gt;</code>，而不是<code class="calibre10">std::pair&lt;std:: string, int&gt;</code>，如果写成后者是无法通过编译的。直接使用<code class="calibre10">auto</code>，可以避免上述问题：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::map&lt;std::string, int&gt; str2int;
// … 填充str2int的代码
for (auto it = str2int.cbegin(); it != str2int.cend(); ++it) {}
// 或者
for (auto &amp;it : str2int) {}</code></pre>

  <p class="zw">反过来说，如果使用<code class="calibre10">auto</code>声明变量，则会导致其他程序员阅读代码时需要翻阅初始化变量的具体类型，那么我们需要慎重考虑是否适合使用<code class="calibre10">auto</code>关键字。</p>

  <p class="zw">对于第二条规则，我们有时候会遇到无法写出类型或者过于复杂的类型，或者即使能正确写出某些复杂类型，但是其他程序员阅读起来也很费劲，这种时候建议使用<code class="calibre10">auto</code>来声明，例如<code class="calibre10">lambda</code>表达式：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto l = [](int a1, int a2) { return a1 + a2; };</code></pre>

  <p class="zw">这里<code class="calibre10">l</code>的类型可能是一个这样的名称<code class="calibre10">xxx::&lt;lambda_efdefb7231ea076 22630c86251a36ed4&gt;</code>（不同的编译器命名方法会有所不同），我们根本无法写出其类型，只能用<code class="calibre10">auto</code>来声明。再例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int sum(int a1, int a2) { return a1 + a2; }
auto b = std::bind(sum, 5, std::placeholders::_1);</code></pre>

  <p class="zw">这里<code class="calibre10">b</code>的类型为<code class="calibre10">std::_Binder&lt;std::_Unforced,int(　cdecl &amp;) (int,int),int, const std::_Ph&lt;1&gt; &amp;&gt;</code>，绝大多数读者看到这种类型时会默契地选择使用<code class="calibre10">auto</code>来声明变量。</p>

  <h2 id="OEBPS/Text/chapter003.html.nav_point_33" class="sigil_not_in_toc">3.4 返回类型推导</h2>

  <p class="zw">C++14标准支持对返回类型声明为<code class="calibre10">auto</code>的推导，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto sum(int a1, int a2) { return a1 + a2; }</code></pre>

  <p class="zw">在上面的代码中，编译器会帮助我们推导<code class="calibre10">sum</code>的返回值，由于<code class="calibre10">a1</code>和<code class="calibre10">a2</code>都是<code class="calibre10">int</code>类型，所以其返回类型也是<code class="calibre10">int</code>，于是返回类型被推导为<code class="calibre10">int</code>类型。请注意，如果有多重返回值，那么需要保证返回值类型是相同的。例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto sum(long a1, long a2)
{
  if (a1 &lt; 0) {
      return 0;          // 返回int类型
  }
  else {
      return a1 + a2;    // 返回long类型
  }
}</code></pre>

  <p class="zw">以上代码中有两处返回，<code class="calibre10">return 0</code>返回的是<code class="calibre10">int</code>类型，而<code class="calibre10">return a1+a2</code>返回的是<code class="calibre10">long</code>类型，这种不同的返回类型会导致编译失败。</p>

  <h2 id="OEBPS/Text/chapter003.html.nav_point_34" class="sigil_not_in_toc">3.5 lambda表达式中使用auto类型推导</h2>

  <p class="zw">在C++14标准中我们还可以把<code class="calibre10">auto</code>写到<code class="calibre10">lambda</code>表达式的形参中，这样就得到了一个泛型的<code class="calibre10">lambda</code>表达式，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto l = [](auto a1, auto a2) { return a1 + a2; };
auto retval = l(5, 5.0);</code></pre>

  <p class="zw">在上面的代码中<code class="calibre10">a1</code>被推导为<code class="calibre10">int</code>类型，<code class="calibre10">a2</code>被推导为<code class="calibre10">double</code>类型，返回值<code class="calibre10">retval</code>被推导为<code class="calibre10">double</code>类型。</p>

  <p class="zw">让我们看一看<code class="calibre10">lambda</code>表达式返回<code class="calibre10">auto</code>引用的方法：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto l = [](int &amp;i)-&gt;auto&amp; { return i; };
auto x1 = 5;
auto &amp;x2 = l(x1);
assert(&amp;x1 == &amp;x2);    // 有相同的内存地址</code></pre>

  <p class="zw">起初在后置返回类型中使用<code class="calibre10">auto</code>是不允许的，但是后来人们发现，这是唯一让<code class="calibre10">lambda</code>表达式通过推导返回引用类型的方法了。</p>

  <h2 id="OEBPS/Text/chapter003.html.nav_point_35" class="sigil_not_in_toc">3.6 非类型模板形参占位符</h2>

  <p class="zw">C++17标准对<code class="calibre10">auto</code>关键字又一次进行了扩展，使它可以作为非类型模板形参的占位符。当然，我们必须保证推导出来的类型是可以用作模板形参的，否则无法通过编译，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
template&lt;auto N&gt;
void f()
{
  std::cout &lt;&lt; N &lt;&lt; std::endl;
}
int main()
{
  f&lt;5&gt;();     // N为int类型
  f&lt;'c'&gt;();   // N为char类型
  f&lt;5.0&gt;();   // 编译失败，模板参数不能为double
}</code></pre>

  <p class="zw">在上面的代码中，函数<code class="calibre10">f&lt;5&gt;()</code>中<code class="calibre10">5</code>的类型为<code class="calibre10">int</code>，所以<code class="calibre10">auto</code>被推导为<code class="calibre10">int</code>类型。同理，<code class="calibre10">f&lt;'c'&gt;()</code>的<code class="calibre10">auto</code>被推导为<code class="calibre10">char</code>类型。由于<code class="calibre10">f&lt;5.0&gt;()</code>的<code class="calibre10">5.0</code>被推导为<code class="calibre10">double</code>类型，但是模板参数不能为<code class="calibre10">double</code>类型，因此导致编译失败。</p>

  <h2 id="OEBPS/Text/chapter003.html.nav_point_36" class="sigil_not_in_toc">3.7 总结</h2>

  <p class="zw"><code class="calibre10">auto</code>占位符是现代C++中非常重要的特性，它能让代码变得更加简洁，从而减少编码的时间，与此同时，它还可以配合一些其他特性，让代码更加接近现代编程语言的风格。另外，本章虽然介绍了很多<code class="calibre10">auto</code>占位符的特性，但事实上还有一些并未提及，因为它们涉及另外一个重要的关键字<code class="calibre10">decltype</code>。我们将会在后面的章节做详细讨论。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter003.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter004.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter004.html.nav_point_37" class="not-in-toc">第4章　decltype说明符（C++11～C++17）</h1>

  <h2 id="OEBPS/Text/chapter004.html.nav_point_38" class="sigil_not_in_toc">4.1　回顾typeof和typeid</h2>

  <p class="zw">在C++11标准发布以前，GCC的扩展提供了一个名为<code class="calibre10">typeof</code>的运算符。通过该运算符可以获取操作数的具体类型。这让使用GCC的程序员在很早之前就具有了对对象类型进行推导的能力，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int a = 0;
typeof(a) b = 5;</code></pre>

  <p class="zw">由于<code class="calibre10">typeof</code>并非C++标准，因此就不再深入介绍了。关于<code class="calibre10">typeof</code>更多具体的用法可以参考GCC的相关文档。</p>

  <p class="zw">除使用GCC提供的<code class="calibre10">typeof</code>运算符获取对象类型以外，C++标准还提供了一个<code class="calibre10">typeid</code>运算符来获取与目标操作数类型有关的信息。获取的类型信息会包含在一个类型为<code class="calibre10">std::type_info</code>的对象里。我们可以调用成员函数<code class="calibre10">name</code>获取其类型名，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int x1 = 0;
double x2 = 5.5;
std::cout &lt;&lt; typeid(x1).name() &lt;&lt; std::endl;
std::cout &lt;&lt; typeid(x1 + x2).name() &lt;&lt; std::endl;
std::cout &lt;&lt; typeid(int).name() &lt;&lt; std::endl;</code></pre>

  <p class="zw">值得注意的是，成员函数<code class="calibre10">name</code>返回的类型名在C++标准中并没有明确的规范，所以输出的类型名会因编译器而异。比如，MSVC会输出一个符合程序员阅读习惯的名称，而GCC则会输出一个它自定义的名称。另外，还有3点也需要注意。</p>

  <p class="zw">1．<code class="calibre10">typeid</code>的返回值是一个左值，且其生命周期一直被扩展到程序生命周期结束。</p>

  <p class="zw">2．<code class="calibre10">typeid</code>返回的<code class="calibre10">std::type_info</code>删除了复制构造函数，若想保存<code class="calibre10">std::type_info</code>，只能获取其引用或者指针，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto t1 = typeid(int);     // 编译失败，没有复制构造函数无法编译
auto &amp;t2 = typeid(int);    // 编译成功，t2推导为const std::type_info&amp;
auto t3 = &amp;typeid(int);    // 编译成功，t3推导为const std::type_info*</code></pre>

  <p class="zw">3．<code class="calibre10">typeid</code>的返回值总是忽略类型的 cv 限定符，也就是<code class="calibre10">typeid(const T)==</code> <code class="calibre10">typeid(T))</code>。</p>

  <p class="zw">虽然<code class="calibre10">typeid</code>可以获取类型信息并帮助我们判断类型之间的关系，但遗憾的是，它并不能像<code class="calibre10">typeof</code>那样在编译期就确定对象类型。</p>

  <h2 id="OEBPS/Text/chapter004.html.nav_point_39" class="sigil_not_in_toc">4.2　使用decltype说明符</h2>

  <p class="zw">为了用统一方法解决上述问题，C++11标准引入了<code class="calibre10">decltype</code>说明符，使用<code class="calibre10">decltype</code>说明符可以获取对象或者表达式的类型，其语法与<code class="calibre10">typeof</code>类似：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int x1 = 0;
decltype(x1) x2 = 0;
std::cout &lt;&lt; typeid(x2).name() &lt;&lt; std::endl;  // x2的类型为int

double x3 = 0;
decltype(x1 + x3) x4 = x1 + x3;
std::cout &lt;&lt; typeid(x4).name() &lt;&lt; std::endl;  // x1+x3的类型为double

decltype({1, 2}) x5;                          // 编译失败，{1, 2}不是表达式</code></pre>

  <p class="zw">以上代码展示了<code class="calibre10">decltype</code>的一般用法，代码中分别获取变量<code class="calibre10">x1</code>和表达式<code class="calibre10">x1+x3</code>的类型并且声明该类型的变量。但是<code class="calibre10">decltype</code>的使用场景还远远不止于此。还记得在第3章中讨论过<code class="calibre10">auto</code>不能在非静态成员变量中使用吗？<code class="calibre10">decltype</code>却是可以的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct S1 {
  int x1;
  decltype(x1) x2;
  double x3;
  decltype(x2 + x3) x4;
};</code></pre>

  <p class="zw">比如，在函数的形参列表中使用：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int x1 = 0;
decltype(x1) sum(decltype(x1) a1, decltype(a1) a2)
{
  return a1 + a2;
}

auto x2 = sum(5, 10);</code></pre>

  <p class="zw">看到这里，读者应该会质疑<code class="calibre10">decltype</code>是否有实际用途，因为到目前为止我们看到的无非是一些画蛇添足的用法，直接声明变量类型或者使用<code class="calibre10">auto</code>占位符要简单得多。确实如此，上面的代码并没有展示<code class="calibre10">decltype</code>的独特之处，只是描述其基本功能。</p>

  <p class="zw">为了更好地讨论<code class="calibre10">decltype</code>的优势，需要用到函数返回类型后置（见第5章）的例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto sum(int a1, int a2)-&gt;int
{
    return a1+a2;
}</code></pre>

  <p class="zw">以上代码以C++11为标准，该标准中<code class="calibre10">auto</code>作为占位符并不能使编译器对函数返回类型进行推导，必须使用返回类型后置的形式指定返回类型。如果接下来想泛化这个函数，让其支持各种类型运算应该怎么办？由于形参不能声明为<code class="calibre10">auto</code>，因此我们需要用到函数模板：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T&gt;
T sum(T a1, T a2)
{
  return a1 + a2;
}

auto x1 = sum(5, 10);</code></pre>

  <p class="zw">代码看上去很好，但是并不能适应所有情况，因为调用者如果传递不同类型的实参，则无法编译通过：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto x2 = sum(5, 10.5);    // 编译失败，无法确定T的类型</code></pre>

  <p class="zw">既然如此，我们只能编写一个更加灵活的函数模板：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class R, class T1, class T2&gt;
R sum(T1 a1, T2 a2)
{
  return a1 + a2;
}

auto x3 = sum&lt;double&gt;(5, 10.5);</code></pre>

  <p class="zw">不错，这样好像可以满足我们泛化<code class="calibre10">sum</code>函数的要求了。但美中不足的是我们必须为函数模板指定返回值类型。为了让编译期完成所有的类型推导工作，我们决定继续优化函数模板：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T1, class T2&gt;
auto sum(T1 a1, T2 a2)-&gt;decltype(a1 + a2)
{
  return a1 + a2;
}

auto x4 = sum(5, 10.5);</code></pre>

  <p class="zw"><code class="calibre10">decltype</code>终于登场了，可以看到它完美地解决了之前需要指定返回类型的问题。解释一下这段代码，<code class="calibre10">auto</code>是返回类型的占位符，参数类型分别是<code class="calibre10">T1</code>和<code class="calibre10">T2</code>，我们利用<code class="calibre10">decltype</code>说明符能推断表达式的类型特性，在函数尾部对<code class="calibre10">auto</code>的类型进行说明，如此一来，在实例化<code class="calibre10">sum</code>函数的时候，编译器就能够知道<code class="calibre10">sum</code>的返回类型了。</p>

  <p class="zw">上述用法只推荐在C++11标准的编译环境中使用，因为C++14标准已经支持对<code class="calibre10">auto</code>声明的返回类型进行推导了，所以以上代码可以简化为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T1, class T2&gt;
auto sum(T1 a1, T2 a2)
{
  return a1 + a2;
}

auto x5 = sum(5, 10.5);</code></pre>

  <p class="zw">讲到这里，读者肯定有疑问了，在C++14中<code class="calibre10">decltype</code>的作用又被<code class="calibre10">auto</code>代替了。是否从C++14标准以后<code class="calibre10">decltype</code>就没有用武之地了呢？并不是这样的，<code class="calibre10">auto</code>作为返回类型的占位符还存在一些问题，请看下面的例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T&gt;
auto return_ref(T&amp; t)
{
  return t;
}

int x1 = 0;
static_assert(
    std::is_reference_v&lt;decltype(return_ref(x1))&gt;// 编译错误，返回值不为引用类型
    );</code></pre>

  <p class="zw">在上面的代码中，我们期望<code class="calibre10">return_ref</code>返回的是一个<code class="calibre10">T</code>的引用类型，但是如果编译此段代码，则必然会编译失败，因为<code class="calibre10">auto</code>被推导为值类型，这就是第3章所讲的<code class="calibre10">auto</code>推导规则2。如果想正确地返回引用类型，则需要用到<code class="calibre10">decltype</code>说明符，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T&gt;
auto return_ref(T&amp; t)-&gt;decltype(t)
{
  return t;
}

int x1 = 0;
static_assert(
    std::is_reference_v&lt;decltype(return_ref(x1))&gt;    // 编译成功
    );</code></pre>

  <p class="zw">以上两段代码几乎相同，只是在<code class="calibre10">return_ref</code>函数的尾部用<code class="calibre10">decltype(t)</code>声明了返回类型，但是代码却可以顺利地通过编译。为了弄清楚编译成功的原因，我们需要讨论<code class="calibre10">decltype</code>的推导规则。</p>

  <h2 id="OEBPS/Text/chapter004.html.nav_point_40" class="sigil_not_in_toc">4.3　推导规则</h2>

  <p class="zw"><code class="calibre10">decltype(e)</code>（其中<code class="calibre10">e</code>的类型为<code class="calibre10">T</code>）的推导规则有5条。</p>

  <p class="zw">1．如果<code class="calibre10">e</code>是一个未加括号的标识符表达式（结构化绑定除外）或者未加括号的类成员访问，则<code class="calibre10">decltype(e)</code>推断出的类型是<code class="calibre10">e</code>的类型<code class="calibre10">T</code>。如果并不存在这样的类型，或者<code class="calibre10">e</code>是一组重载函数，则无法进行推导。</p>

  <p class="zw">2．如果<code class="calibre10">e</code>是一个函数调用或者仿函数调用，那么<code class="calibre10">decltype(e)</code>推断出的类型是其返回值的类型。</p>

  <p class="zw">3．如果<code class="calibre10">e</code>是一个类型为<code class="calibre10">T</code>的左值，则<code class="calibre10">decltype(e)</code>是<code class="calibre10">T&amp;</code>。</p>

  <p class="zw">4．如果<code class="calibre10">e</code>是一个类型为<code class="calibre10">T</code>的将亡值，则<code class="calibre10">decltype(e)</code>是<code class="calibre10">T&amp;&amp;</code>。</p>

  <p class="zw">5．除去以上情况，则<code class="calibre10">decltype(e)</code>是<code class="calibre10">T</code>。</p>

  <p class="zw">根据这5条规则，我们来看一看C++标准文档给的几个例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">const int&amp;&amp; foo();
int i;
struct A {
    double x;
};
const A* a = new A();

decltype(foo());         // decltype(foo())推导类型为const int&amp;&amp;
decltype(i);             // decltype(i)推导类型为int
decltype(a-&gt;x);          // decltype(a-&gt;x)推导类型为double
decltype((a-&gt;x));        // decltype((a-&gt;x))推导类型为const double&amp;</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">decltype(foo())</code>满足规则2和规则4，<code class="calibre10">foo</code>函数的返回类型是<code class="calibre10">const int&amp;&amp;</code>，所以推导结果也为<code class="calibre10">const int&amp;&amp;</code>；<code class="calibre10">decltype(i)</code>和<code class="calibre10">decltype(a-&gt;x)</code>很简单，满足规则1，所以其类型为<code class="calibre10">int</code>和<code class="calibre10">double</code>；最后一句代码，由于<code class="calibre10">decltype((a-&gt;x))</code>推导的是一个带括号的表达式<code class="calibre10">(a-&gt;x)</code>，因此规则1不再适用，但很明显<code class="calibre10">a-&gt;x</code>是一个左值，又因为<code class="calibre10">a</code>带有<code class="calibre10">const</code>限定符，所以其类型被推导为<code class="calibre10">const double&amp;</code>。</p>

  <p class="zw">如果读者已经理解了<code class="calibre10">decltype</code>的推导规则，不妨尝试推导下列代码中<code class="calibre10">decltype</code>的推导结果：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int i;
int *j;
int n[10];
const int&amp;&amp; foo();
decltype(static_cast&lt;short&gt;(i));    // decltype(static_cast&lt;short&gt;(i))推导类
                                    // 型为short
decltype(j);                   // decltype(j)推导类型为int*
decltype(n);                   // decltype(n)推导类型为int[10]
decltype(foo);                 // decltype(foo)推导类型为int const &amp;&amp; (void)

struct A {
  int operator() () { return 0; }
};

A a;
decltype(a());                 // decltype(a())推导类型为int</code></pre>

  <p class="zw">最后让我们看几个更为复杂的例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int i;
int *j;
int n[10];
decltype(i=0);                      // decltype(i=0)推导类型为int&amp;
decltype(0,i);                      // decltype(0,i)推导类型为int&amp;
decltype(i,0);                      // decltype(i,0)推导类型为int
decltype(n[5]);                     // decltype(n[5])推导类型为int&amp;
decltype(*j);                       // decltype(*j)推导类型为int&amp;
decltype(static_cast&lt;int&amp;&amp;&gt;(i));    // decltype(static_cast&lt;int&amp;&amp;&gt;(i))推导类
                                    // 型为int&amp;&amp;
decltype(i++);                      // decltype(i++)推导类型为int
decltype(++i);                      // decltype(++i)推导类型为int&amp;
decltype("hello world");            // decltype("hello world")推导类型为
                                    // const char(&amp;)[12]</code></pre>

  <p class="zw">让我们来看一看上面代码中的例子都是怎么推导出来的。</p>

  <p class="zw">1．可以确认以上例子中的表达式都不是标识符表达式，这样就排除了规则1。</p>

  <p class="zw">2．<code class="calibre10">i=0</code>和<code class="calibre10">0,i</code>表达式都返回左值<code class="calibre10">i</code>，所以推导类型为<code class="calibre10">int&amp;</code>。</p>

  <p class="zw">3．<code class="calibre10">i,0</code>表达式返回0，所以推导类型为<code class="calibre10">int</code>。</p>

  <p class="zw">4．<code class="calibre10">n[5]</code>返回的是数组<code class="calibre10">n</code>中的第6个元素，也是左值，所以推导类型为<code class="calibre10">int&amp;</code>。</p>

  <p class="zw">5．*<code class="calibre10">j</code>很明显也是一个左值，所以推导类型也为<code class="calibre10">int&amp;</code>。</p>

  <p class="zw">6．<code class="calibre10">static_cast&lt;int&amp;&amp;&gt;(i)</code>被转换为一个将亡值类型，所以其推导类型为<code class="calibre10">int&amp;&amp;</code>。</p>

  <p class="zw">7．<code class="calibre10">i++</code>和<code class="calibre10">++i</code>分别返回右值和左值，所以推导类型分别为<code class="calibre10">int</code>和<code class="calibre10">int&amp;</code>。</p>

  <p class="zw">8．<code class="calibre10">hello world</code>是一个常量数组的左值，其推导类型为<code class="calibre10">const char(&amp;)[12]</code>。</p>

  <h2 id="OEBPS/Text/chapter004.html.nav_point_41" class="sigil_not_in_toc">4.4　cv限定符的推导</h2>

  <p class="zw">通常情况下，<code class="calibre10">decltype(e)</code>所推导的类型会同步<code class="calibre10">e</code>的<code class="calibre10">cv</code>限定符，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">const int i = 0;
decltype(i);    // decltype(i)推导类型为const int</code></pre>

  <p class="zw">但是还有其他情况，当<code class="calibre10">e</code>是未加括号的成员变量时，父对象表达式的<code class="calibre10">cv</code>限定符会被忽略，不能同步到推导结果：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct A {
    double x;
};
const A* a = new A();
decltype(a-&gt;x);    // decltype(a-&gt;x)推导类型为double, const属性被忽略</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">a</code>被声明为<code class="calibre10">const</code>类型，如果想在代码中改变<code class="calibre10">a</code>中<code class="calibre10">x</code>的值，则肯定会编译失败。但是<code class="calibre10">decltype(a-&gt;x)</code>却得到了一个没有<code class="calibre10">const</code>属性的<code class="calibre10">double</code>类型。当然，如果我们给<code class="calibre10">a-&gt;x</code>加上括号，则情况会有所不同：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct A {
    double x;
};
const A* a = new A();
decltype((a-&gt;x));    // decltype((a-&gt;x))推导类型为const double&amp;</code></pre>

  <p class="zw">总的来说，当<code class="calibre10">e</code>是加括号的数据成员时，父对象表达式的<code class="calibre10">cv</code>限定符会同步到推断结果。</p>

  <h2 id="OEBPS/Text/chapter004.html.nav_point_42" class="sigil_not_in_toc">4.5　decltype(auto)</h2>

  <p class="zw">在C++14标准中出现了<code class="calibre10">decltype</code>和<code class="calibre10">auto</code>两个关键字的结合体：<code class="calibre10">decltype(auto)</code>。它的作用简单来说，就是告诉编译器用<code class="calibre10">decltype</code>的推导表达式规则来推导<code class="calibre10">auto</code>。另外需要注意的是，<code class="calibre10">decltype(auto)</code>必须单独声明，也就是它不能结合指针、引用以及<code class="calibre10">cv</code>限定符。看完下面的例子，读者就会有所体会：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int i;
int&amp;&amp; f();
auto x1a = i;                   // x1a推导类型为int
decltype(auto) x1d = i;         // x1d推导类型为int
auto x2a = (i);                 // x2a推导类型为int
decltype(auto) x2d = (i);       // x2d推导类型为int&amp;
auto x3a = f();                 // x3a推导类型为int
decltype(auto) x3d = f();       // x3d推导类型为int&amp;&amp;
auto x4a = { 1, 2 };            // x4a推导类型为std::initializer_list&lt;int&gt;
decltype(auto) x4d = { 1, 2 };  // 编译失败, {1, 2}不是表达式
auto *x5a = &amp;i;                 // x5a推导类型为int*
decltype(auto)*x5d = &amp;i;        // 编译失败，decltype(auto)必须单独声明</code></pre>

  <p class="zw">观察上面的代码可以发现，<code class="calibre10">auto</code>和<code class="calibre10">decltype(auto)</code>的用法几乎相同，只是在推导规则上遵循<code class="calibre10">decltype</code>而已。比如<code class="calibre10">(i)</code>在<code class="calibre10">auto</code>规则的作用下，<code class="calibre10">x2a</code>的类型被推导为<code class="calibre10">int</code>，而<code class="calibre10">x2d</code>的类型被推导为<code class="calibre10">int&amp;</code>。另外，由于<code class="calibre10">decltype(auto)</code>必须单独声明，因此<code class="calibre10">x5d</code>无法通过编译。</p>

  <p class="zw">接下来让我们看一看<code class="calibre10">decltype(auto)</code>是如何发挥作用的。还记得<code class="calibre10">decltype</code>不可被<code class="calibre10">auto</code>代替的例子吗？<code class="calibre10">return_ref</code>想返回一个引用类型，但是如果直接使用<code class="calibre10">auto</code>，则一定会返回一个值类型。这让我们不得不采用返回类型后置的方式声明返回类型。</p>

  <p class="zw">现在有了<code class="calibre10">decltype(auto)</code>组合，我们可以进一步简化代码，消除返回类型后置的语法，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T&gt;
decltype(auto) return_ref(T&amp; t)
{
  return t;
}

int x1 = 0;
static_assert(
    std::is_reference_v&lt;decltype(return_ref(x1))&gt;    // 编译成功
    );</code></pre>

  <h2 id="OEBPS/Text/chapter004.html.nav_point_43" class="sigil_not_in_toc">4.6　decltype(auto)作为非类型模板形参占位符</h2>

  <p class="zw">与<code class="calibre10">auto</code>一样，在C++17标准中<code class="calibre10">decltype(auto)</code>也能作为非类型模板形参的占位符，其推导规则和上面介绍的保持一致，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
template&lt;decltype(auto) N&gt;
void f()
{
  std::cout &lt;&lt; N &lt;&lt; std::endl;
}

static const int x = 11;
static int y = 7;

int main()
{
  f&lt;x&gt;();        // N为const int类型
  f&lt;(x)&gt;();      // N为const int&amp;类型
  f&lt;y&gt;();        // 编译错误
  f&lt;(y)&gt;();      // N为int&amp;类型
}</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">x</code>的类型为<code class="calibre10">const int</code>，所以<code class="calibre10">f&lt;x&gt;()</code>推导出<code class="calibre10">N</code>为<code class="calibre10">const int</code>类型，这里和<code class="calibre10">auto</code>作为占位符的结果是一样的；<code class="calibre10">f&lt;(x)&gt;()</code>则不同，推导出的<code class="calibre10">N</code>为<code class="calibre10">const int&amp;</code>类型，符合<code class="calibre10">decltype(auto)</code>的推导规则。另外，<code class="calibre10">f&lt;y&gt;()</code>会导致编译出错，因为<code class="calibre10">y</code>不是一个常量，所以编译器无法对函数模板进行实例化。而<code class="calibre10">f&lt;(y)&gt;()</code>则没有这种问题，因为<code class="calibre10">(y)</code>被推断为了引用类型，恰好对于静态对象而言内存地址是固定的，所以可以顺利地通过编译，最终<code class="calibre10">N</code>被推导为<code class="calibre10">int&amp;</code>类型。</p>

  <h2 id="OEBPS/Text/chapter004.html.nav_point_44" class="sigil_not_in_toc">4.7　总结</h2>

  <p class="zw"><code class="calibre10">decltype</code>和<code class="calibre10">auto</code>的使用方式有一些相似之处，但是推导规则却有所不同，理解起来有一定难度。不过幸运的是，大部分情况下推导结果能够符合我们的预期。另外从上面的示例代码来看，在通常的编程过程中并不会存在太多使用<code class="calibre10">decltype</code>的情况。实际上，<code class="calibre10">decltype</code>说明符对于库作者更加实用。因为它很大程度上加强了C++的泛型能力，比如利用<code class="calibre10">decltype</code>和<code class="calibre10">SFINAE</code>特性让编译器自动选择正确的函数模板进行调用等，当然这些是比较高级的话题了，有兴趣的读者可以提前翻阅第40章的内容。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter004.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter005.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter005.html.nav_point_45" class="not-in-toc">第5章　函数返回类型后置（C++11）</h1>

  <h2 id="OEBPS/Text/chapter005.html.nav_point_46" class="sigil_not_in_toc">5.1　使用函数返回类型后置声明函数</h2>

  <p class="zw">前面已经出现了函数返回类型后置的例子，接下来我们将详细讨论C++11标准中的新语法特性：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto foo()-&gt;int
{
  return 42;
}</code></pre>

  <p class="zw">以上代码中的函数声明等同于<code class="calibre10">int foo()</code>，只不过采用了函数返回类型后置的方法，其中<code class="calibre10">auto</code>是一个占位符，函数名后<code class="calibre10">-&gt;</code>紧跟的<code class="calibre10">int</code>才是真正的返回类型。当然，在这个例子中传统的函数声明方式更加简洁。而在返回类型比较复杂的时候，比如返回一个函数指针类型，返回类型后置可能会是一个不错的选择，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int bar_impl(int x)
{
  return x;
}

typedef int(*bar)(int);
bar foo1()
{
  return bar_impl;
}

auto foo2()-&gt;int(*)(int)
{
  return bar_impl;
}

int main() {
  auto func = foo2();
  func(58);
}</code></pre>

  <p class="zw">在上面的代码中，函数<code class="calibre10">foo2</code>的返回类型不再是简单的<code class="calibre10">int</code>而是函数指针类型。使用传统函数声明语法的<code class="calibre10">foo1</code>无法将函数指针类型作为返回类型直接使用，所以需要使用<code class="calibre10">typedef</code>给函数指针类型创建别名<code class="calibre10">bar</code>，再使用别名作为函数<code class="calibre10">foo1</code>的返回类型。而使用函数返回类型后置语法的<code class="calibre10">foo2</code>则没有这个问题。同样，<code class="calibre10">auto</code>作为返回类型占位符，在<code class="calibre10">-&gt;</code>后声明返回的函数指针类型<code class="calibre10">int(*)(int)</code>即可。</p>

  <h2 id="OEBPS/Text/chapter005.html.nav_point_47" class="sigil_not_in_toc">5.2　推导函数模板返回类型</h2>

  <p class="zw">C++11标准中函数返回类型后置的作用之一是推导函数模板的返回类型，当然前提是需要用到<code class="calibre10">decltype</code>说明符，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T1, class T2&gt;
auto sum1(T1 t1, T2 t2)-&gt;decltype(t1 + t2)
{
  return t1 + t2;
}

int main() {
  auto x1 = sum1(4, 2);
}</code></pre>

  <p class="zw">在上面的代码中，函数模板<code class="calibre10">sum1</code>有两个模板形参<code class="calibre10">T1</code>和<code class="calibre10">T2</code>，它们分别是函数形参<code class="calibre10">t1</code>和<code class="calibre10">t2</code>的类型。为了让<code class="calibre10">sum1</code>函数的返回类型由实参自动推导，这里需要使用函数返回类型后置来指定<code class="calibre10">decltype</code>说明符推导类型作为函数的返回类型。请注意，<code class="calibre10">decltype(t1 + t2)</code>不能写在函数声明前，编译器在解析返回类型的时候还没解析到参数部分，所以它对<code class="calibre10">t1</code>和<code class="calibre10">t2</code>一无所知，自然会编译失败：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">decltype(t1 + t2) auto sum1(T1 t1, T2 t2) {…}  // 编译失败，无法识别t1和t2</code></pre>

  <p class="zw">实际上，在C++11标准中只用<code class="calibre10">decltype</code>关键字也能写出自动推导返回类型的函数模板，但是函数可读性却差了很多，以下是最容易理解的写法：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T1, class T2&gt;
decltype(T1() + T2()) sum2(T1 t1, T2 t2)
{
  return t1 + t2;
}

int main() {
  sum2(4, 2);
}</code></pre>

  <p class="zw">以上代码使用<code class="calibre10">decltype(T1()+T2())</code>让编译器为我们推导函数的返回类型，其中<code class="calibre10">T1()+T2()</code>表达式告诉编译器应该推导<code class="calibre10">T1</code>类型对象与<code class="calibre10">T2</code>类型对象之和的对象类型。但是这种写法并不通用，它存在一个潜在问题，由于<code class="calibre10">T1() + T2()</code>表达式使用了<code class="calibre10">T1</code>和<code class="calibre10">T2</code>类型的默认构造函数，因此编译器要求<code class="calibre10">T1</code>和<code class="calibre10">T2</code>的默认构造函数必须存在，否则会编译失败，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class IntWrap {
public:
  IntWrap(int n) : n_(n) {}
  IntWrap operator+ (const IntWrap&amp; other)
  {
      return IntWrap(n_ + other.n_);
  }
private:
  int n_;
};

int main() {
  sum2(IntWrap(1), IntWrap(2));    // 编译失败，IntWrap没有默认构造函数
}</code></pre>

  <p class="zw">虽然编译器在推导表达式类型的时候并没有真正计算表达式，但是会检查表达式是否正确，所以在推导<code class="calibre10">IntWrap() + IntWrap()</code>时会报错。为了解决这个问题，需要既可以在表达式中让<code class="calibre10">T1</code>和<code class="calibre10">T2</code>两个对象求和，又不用使用其构造函数方法，于是就有了以下两个函数模板：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T1, class T2&gt;
decltype(*static_cast&lt;T1 *&gt;(nullptr) + *static_cast&lt;T2 *&gt;(nullptr)) sum3(T1 t1, T2 t2)
{
  return t1 + t2;
}

template&lt;class T&gt;
T&amp;&amp; declval();

template&lt;class T1, class T2&gt;
decltype(declval&lt;T1&gt;() + declval&lt;T2&gt;()) sum4(T1 t1, T2 t2)
{
  return t1 + t2;
}

int main() {
  sum3(IntWrap(1), IntWrap(2));
  sum4(IntWrap(1), IntWrap(2));
}</code></pre>

  <p class="zw">在上面的代码中，函数模板<code class="calibre10">sum3</code>使用指针类型转换和解引用求和的方法推导返回值，其中<code class="calibre10">*static_cast&lt;T1 * &gt;(nullptr)+ * static_cast&lt;T2 * &gt;(nullptr)</code>分别将<code class="calibre10">nullptr</code>转换为<code class="calibre10">T1</code>和<code class="calibre10">T2</code>的指针类型，然后解引用求和，最后利用<code class="calibre10">decltype</code>推导出求和后的对象类型。由于编译器不会真的计算求值，因此这里求和操作不会有问题。</p>

  <p class="zw">函数模板<code class="calibre10">sum4</code>则是利用了另外一个技巧，其实本质上与<code class="calibre10">sum3</code>相似。在标准库中提供了一个<code class="calibre10">std::declval</code>函数模板声明（没有具体实现），它将类型<code class="calibre10">T</code>转换成引用类型，这样在使用<code class="calibre10">decltype</code>推导表达式类型时不必经过构造函数检查。由于标准库中<code class="calibre10">std::declval</code>的实现比较复杂，因此我在这里实现了一个简化版本。<code class="calibre10">declval&lt;T1&gt;() + declval&lt;T2&gt;()</code>表达式分别通过<code class="calibre10">declval</code>将<code class="calibre10">T1</code>和<code class="calibre10">T2</code>转换为引用类型并且求和，最后通过<code class="calibre10">decltype</code>推导返回类型。</p>

  <p class="zw">可以看出，虽然这两种方法都能达到函数返回类型后置的效果，但是它们在实现上更加复杂，同时要理解它们也必须有一定的模板元编程的知识。为了让代码更容易被其他人阅读和理解，还是建议使用函数返回类型后置的方法来推导返回类型。</p>

  <h2 id="OEBPS/Text/chapter005.html.nav_point_48" class="sigil_not_in_toc">5.3　总结</h2>

  <p class="zw">本章介绍了C++11标准中的函数返回类型后置语法，通过这种方法可以让返回复杂类型的函数声明更加清晰易读。在无法使用C++14以及更新标准的情况下，通过返回类型后置语法来推导函数模板的返回类型无疑是最便捷的方法。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter005.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter006.html"><div class="calibre">
 
 <h1 id="OEBPS/Text/chapter006.html.nav_point_49" class="not-in-toc">第6章　右值引用（C++11 C++17 C++20）</h1> 
 <h2 id="OEBPS/Text/chapter006.html.nav_point_50" class="sigil_not_in_toc">6.1　左值和右值</h2> 
 <p class="zw">左值和右值的概念早在C++98的时候就已经出现了，从最简单的字面理解，无非是表达式等号左边的值为左值，而表达式右边的值为右值，比如：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int x = 1;
int y = 3;
int z = x + y;</code></pre> 
 <p class="zw">以上面的代码为例，<code class="calibre10">x</code>是左值，<code class="calibre10">1</code>是右值；<code class="calibre10">y</code>是左值，<code class="calibre10">3</code>是右值；<code class="calibre10">z</code>是左值，<code class="calibre10">x+y</code>的结果是右值。用表达式等号左右的标准区分左值和右值虽然在一些场景下确实能得到正确结果，但是还是过于简单，有些情况下是无法准确区分左值和右值的，比如：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int a = 1;
int b = a;</code></pre> 
 <p class="zw">按照表达式等号左右的区分方式，在第一行代码中<code class="calibre10">a</code>是左值，<code class="calibre10">1</code>是右值；在第二行代码中<code class="calibre10">b</code>是左值，而<code class="calibre10">a</code>是右值。这里出现了矛盾，在第一行代码中我们判断<code class="calibre10">a</code>是一个左值，它却在第二行变成了右值，很明显这不是我们想要的结果，要准确地区分左值和右值还是应该理解其内在含义。</p> 
 <p class="zw">在C++中所谓的左值一般是指一个指向特定内存的具有名称的值（具名对象），它有一个相对稳定的内存地址，并且有一段较长的生命周期。而右值则是不指向稳定内存地址的匿名值（不具名对象），它的生命周期很短，通常是暂时性的。基于这一特征，我们可以用取地址符<code class="calibre10">&amp;</code>来判断左值和右值，能取到内存地址的值为左值，否则为右值。还是以上面的代码为例，因为<code class="calibre10">&amp;a</code>和<code class="calibre10">&amp;b</code>都是符合语法规则的，所以<code class="calibre10">a</code>和<code class="calibre10">b</code>都是左值，而<code class="calibre10">&amp;1</code>在GCC中会给出“lvalue required as unary '&amp;' operand”错误信息以提示程序员<code class="calibre10">&amp;</code>运算符需要的是一个左值。</p> 
 <p class="zw">上面的代码在左右值的判断上比较简单，但是并非所有的情况都是如此，下面这些情况左值和右值的判断可能是违反直觉的，例如：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int x = 1;

int get_val()
{
  return x;
}

void set_val(int val)
{
  x = val;
}

int main() 
{
  x++;
  ++x;
  int y = get_val();
  set_val(6);
}</code></pre> 
 <p class="zw">在上面的代码中，<code class="calibre10">x++</code>和++<code class="calibre10">x</code>虽然都是自增操作，但是却分为不同的左右值。其中<code class="calibre10">x++</code>是右值，因为在后置++操作中编译器首先会生成一份<code class="calibre10">x</code>值的临时复制，然后才对<code class="calibre10">x</code>递增，最后返回临时复制内容。而<code class="calibre10">++x</code>则不同，它是直接对<code class="calibre10">x</code>递增后马上返回其自身，所以<code class="calibre10">++x</code>是一个左值。如果对它们实施取地址操作，就会发现<code class="calibre10">++x</code>的取地址操作可以编译成功，而对<code class="calibre10">x++</code>取地址则会报错。但是从直觉上来说，<code class="calibre10">&amp;x++</code>看起来更像是会编译成功的一方：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int *p = &amp;x++;  // 编译失败
int *q = &amp;++x;  // 编译成功</code></pre> 
 <p class="zw">接着来看上一份代码中的<code class="calibre10">get_val</code>函数，该函数返回了一个全局变量<code class="calibre10">x</code>，虽然很明显变量<code class="calibre10">x</code>是一个左值，但是它经过函数返回以后变成了一个右值。原因和<code class="calibre10">x++</code>类似，在函数返回的时候编译器并不会返回<code class="calibre10">x</code>本身，而是返回<code class="calibre10">x</code>的临时复制，所以<code class="calibre10">int * p = &amp;get_val();</code>也会编译失败。对于<code class="calibre10">set_val</code>函数，该函数接受一个参数并且将参数的值赋值到<code class="calibre10">x</code>中。在<code class="calibre10">main</code>函数中<code class="calibre10">set_val(6);</code>实参<code class="calibre10">6</code>是一个右值，但是进入函数之后形参<code class="calibre10">val</code>却变成了一个左值，我们可以对<code class="calibre10">val</code>使用取地址符，并且不会引起任何问题：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void set_val(int val)
{
  int *p = &amp;val;
  x = val;
}</code></pre> 
 <p class="zw">最后需要强调的是，通常字面量都是一个右值，除字符串字面量以外：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int x = 1;
set_val(6);
auto p = &amp;"hello world";</code></pre> 
 <p class="zw">这一点非常容易被忽略，因为经验告诉我们上面的代码中前两行的<code class="calibre10">1</code>和<code class="calibre10">6</code>都是右值，因为不存在<code class="calibre10">&amp;1</code>和<code class="calibre10">&amp;6</code>的语法，这会让我们想当然地认为<code class="calibre10">"hello world"</code>也是一个右值，毕竟<code class="calibre10">&amp;"hello world"</code>的语法也很少看到。但是这段代码是可以编译成功的，其实原因仔细想来也很简单，编译器会将字符串字面量存储到程序的数据段中，程序加载的时候也会为其开辟内存空间，所以我们可以使用取地址符<code class="calibre10">&amp;</code>来获取字符串字面量的内存地址。</p> 
 <h2 id="OEBPS/Text/chapter006.html.nav_point_51" class="sigil_not_in_toc">6.2　左值引用</h2> 
 <p class="zw">左值引用是编程过程中的常用特性之一，它的出现让C++编程在一定程度上脱离了危险的指针。当我们需要将一个对象作为参数传递给子函数的时候，往往会使用左值引用，因为这样可以免去创建临时对象的操作。非常量左值的引用对象很单纯，它们必须是一个左值。对于这一点，常量左值引用的特性显得更加有趣，它除了能引用左值，还能够引用右值，比如：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int &amp;x1 = 7;          // 编译错误
const int &amp;x = 11;    // 编译成功</code></pre> 
 <p class="zw">在上面的代码中，第一行代码会编译报错，因为<code class="calibre10">int&amp;</code>无法绑定一个<code class="calibre10">int</code>类型的右值，但是第二行代码却可以编译成功。请注意，虽然在结果上<code class="calibre10">const int &amp;x = 11</code>和<code class="calibre10">const int x = 11</code>是一样的，但是从语法上来说，前者是被引用了，所以语句结束后<code class="calibre10">11</code>的生命周期被延长，而后者当语句结束后右值<code class="calibre10">11</code>应该被销毁。虽然常量左值引用可以引用右值的这个特性在赋值表达式中看不出什么实用价值，但是在函数形参列表中却有着巨大的作用。一个典型的例子就是复制构造函数和复制赋值运算符函数，通常情况下我们实现的这两个函数的形参都是一个常量左值引用，例如：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class X {
public:
  X() {}
  X(const X&amp;) {}
  X&amp; operator = (const X&amp;) { return *this; }
};

X make_x()
{
  return X();
}

int main() 
{
  X x1;
  X x2(x1);
  X x3(make_x());
  x3 = make_x();
}</code></pre> 
 <p class="zw">以上代码可以通过编译，但是如果这里将类<code class="calibre10">X</code>的复制构造函数和复制赋值函数形参类型的常量性删除，则<code class="calibre10">X x3(make_x());</code>和<code class="calibre10">x3 = make_x();</code>这两句代码会编译报错，因为非常量左值引用无法绑定到<code class="calibre10">make_x()</code>产生的右值。常量左值引用可以绑定右值是一条非常棒的特性，但是它也存在一个很大的缺点——常量性。一旦使用了常量左值引用，就表示我们无法在函数内修改该对象的内容（强制类型转换除外）。所以需要另外一个特性来帮助我们完成这项工作，它就是右值引用。</p> 
 <h2 id="OEBPS/Text/chapter006.html.nav_point_52" class="sigil_not_in_toc">6.3　右值引用</h2> 
 <p class="zw">顾名思义，右值引用是一种引用右值且只能引用右值的方法。在语法方面右值引用可以对比左值引用，在左值引用声明中，需要在类型后添加<code class="calibre10">&amp;</code>，而右值引用则是在类型后添加<code class="calibre10">&amp;&amp;</code>，例如：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int i = 0;
int &amp;j = i;    // 左值引用
int &amp;&amp;k = 11;  // 右值引用</code></pre> 
 <p class="zw">在上面的代码中，<code class="calibre10">k</code>是一个右值引用，如果试图用<code class="calibre10">k</code>引用变量<code class="calibre10">i</code>，则会引起编译错误。右值引用的特点之一是可以延长右值的生命周期，这个对于字面量<code class="calibre10">11</code>可能看不出效果，那么请看下面的例子：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10"># include &lt;iostream&gt;

class X {
public:
  X() { std::cout &lt;&lt; "X ctor" &lt;&lt; std::endl; }
  X(const X&amp;x) { std::cout &lt;&lt; "X copy ctor" &lt;&lt; std::endl; }
  ~X() { std::cout &lt;&lt; "X dtor" &lt;&lt; std::endl; }
  void show() { std::cout &lt;&lt; "show X" &lt;&lt; std::endl; }
};

X make_x()
{
  X x1;
  return x1;
}

int main()
{
  X &amp;&amp;x2 = make_x();
  x2.show();
}</code></pre> 
 <p class="zw">在理解这段代码之前，让我们想一下如果将<code class="calibre10">X &amp;&amp;x2 = make_x()</code>这句代码替换为<code class="calibre10">X x2 = make_x()</code>会发生几次构造。在没有进行任何优化的情况下应该是3次构造，首先<code class="calibre10">make_x</code>函数中<code class="calibre10">x1</code>会默认构造一次，然后<code class="calibre10">return x1</code>会使用复制构造产生临时对象，接着<code class="calibre10">X x2 = make_x()</code>会使用复制构造将临时对象复制到<code class="calibre10">x2</code>，最后临时对象被销毁。</p> 
 <p class="zw">以上流程在使用了右值引用以后发生了微妙的变化，让我们编译运行这段代码。请注意，用GCC编译以上代码需要加上命令行参数<code class="calibre10">-fno-elide-constructors</code>用于关闭函数返回值优化（RVO）。因为GCC的RVO优化会减少复制构造函数的调用，不利于语言特性实验：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">X ctor
X copy ctor
X dtor
show X
X dtor</code></pre> 
 <p class="zw">从运行结果可以看出上面的代码只发生了两次构造。第一次是<code class="calibre10">make_x</code>函数中<code class="calibre10">x1</code>的默认构造，第二次是<code class="calibre10">return x1</code>引发的复制构造。不同的是，由于<code class="calibre10">x2</code>是一个右值引用，引用的对象是函数<code class="calibre10">make_x</code>返回的临时对象，因此该临时对象的生命周期得到延长，所以我们可以在<code class="calibre10">X &amp;&amp;x2 = make_x()</code>语句结束后继续调用<code class="calibre10">show</code>函数而不会发生任何问题。对性能敏感的读者应该注意到了，延长临时对象生命周期并不是这里右值引用的最终目标，其真实目标应该是减少对象复制，提升程序性能。</p> 
 <h2 id="OEBPS/Text/chapter006.html.nav_point_53" class="sigil_not_in_toc">6.4　右值的性能优化空间</h2> 
 <p class="zw">通过6.3节的介绍我们知道了很多情况下右值都存储在临时对象中，当右值被使用之后程序会马上销毁对象并释放内存。这个过程可能会引发一个性能问题，例如：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
class BigMemoryPool {
public:
  static const int PoolSize = 4096;
  BigMemoryPool() : pool_(new char[PoolSize]) {}
  ~BigMemoryPool()
  {
      if (pool_ != nullptr) {
            delete[] pool_;
      }
  }

  BigMemoryPool(const BigMemoryPool&amp; other) : pool_(new char[PoolSize])
  {
      std::cout &lt;&lt; "copy big memory pool." &lt;&lt; std::endl;
      memcpy(pool_, other.pool_, PoolSize);
  }

private:

  char *pool_;
};

BigMemoryPool get_pool(const BigMemoryPool&amp; pool)
{
  return pool;
}

BigMemoryPool make_pool()
{
  BigMemoryPool pool;
  return get_pool(pool);
}

int main()
{
  BigMemoryPool my_pool = make_pool();
}</code></pre> 
 <p class="zw">以上代码同样需要加上编译参数<code class="calibre10">-fno-elide-constructors</code>，编译运行程序会在屏幕上输出字符串：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">copy big memory pool.
copy big memory pool.
copy big memory pool.</code></pre> 
 <p class="zw">可以看到<code class="calibre10">BigMemoryPool my_pool = make_pool();</code>调用了3次复制构造函数。</p> 
 <p class="zw">1．<code class="calibre10">get_pool</code>返回的<code class="calibre10">BigMemoryPool</code>临时对象调用复制构造函数复制了<code class="calibre10">pool</code>对象。</p> 
 <p class="zw">2．<code class="calibre10">make_pool</code>返回的<code class="calibre10">BigMemoryPool</code>临时对象调用复制构造函数复制了<code class="calibre10">get_pool</code>返回的临时对象。</p> 
 <p class="zw">3．<code class="calibre10">main</code>函数中<code class="calibre10">my_pool</code>调用其复制构造函数复制<code class="calibre10">make_pool</code>返回的临时对象。</p> 
 <p class="zw">该代码从正确性上看毫无问题，但是从运行性能的角度上看却还有巨大的优化空间。在这里每发生一次复制构造都会复制整整4KB的数据，如果数据量更大一些，比如4MB或者400MB，那么将对程序性能造成很大影响。</p> 
 <h2 id="OEBPS/Text/chapter006.html.nav_point_54" class="sigil_not_in_toc">6.5　移动语义</h2> 
 <p class="zw">仔细分析6.4节代码中3次复制构造函数的调用，不难发现第二次和第三次的复制构造是影响性能的主要原因。在这个过程中都有临时对象参与进来，而临时对象本身只是做数据的复制。如果有办法能将临时对象的内存直接转移到<code class="calibre10">my_pool</code>对象中，不就能消除内存复制对性能的消耗吗？好消息是在C++11标准中引入了移动语义，它可以帮助我们将临时对象的内存移动到<code class="calibre10">my_pool</code>对象中，以避免内存数据的复制。让我们简单修改一下<code class="calibre10">BigMemoryPool</code>类代码：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class BigMemoryPool {
public:
  static const int PoolSize = 4096;
  BigMemoryPool() : pool_(new char[PoolSize]) {}
  ~BigMemoryPool()
  {
      if (pool_ != nullptr) {
            delete[] pool_;
      }
  }

  BigMemoryPool(BigMemoryPool&amp;&amp; other)
  {
      std::cout &lt;&lt; "move big memory pool." &lt;&lt; std::endl;
      pool_ = other.pool_;
      other.pool_ = nullptr;
  }

  BigMemoryPool(const BigMemoryPool&amp; other) : pool_(new char[PoolSize])
  {
      std::cout &lt;&lt; "copy big memory pool." &lt;&lt; std::endl;
      memcpy(pool_, other.pool_, PoolSize);
  }

private:

  char *pool_;
};</code></pre> 
 <p class="zw">在上面的代码中增加了一个类<code class="calibre10">BigMemoryPool</code>的构造函数<code class="calibre10">BigMemoryPool (BigMemoryPool&amp;&amp; other)</code>，它的形参是一个右值引用类型，称为移动构造函数。这个名称很容易让人联想到复制构造函数，那么就让我们先了解一下它们的区别。</p> 
 <p class="zw">从构造函数的名称和它们的参数可以很明显地发现其中的区别，对于复制构造函数而言形参是一个左值引用，也就是说函数的实参必须是一个具名的左值，在复制构造函数中往往进行的是深复制，即在不能破坏实参对象的前提下复制目标对象。而移动构造函数恰恰相反，它接受的是一个右值，其核心思想是通过转移实参对象的数据以达成构造目标对象的目的，也就是说实参对象是会被修改的。</p> 
 <p class="zw">进一步来说类<code class="calibre10">BigMemoryPool</code>的移动构造函数，在函数中没有了复制构造中的内存复制，取而代之的是简单的指针替换操作。它将实参对象的<code class="calibre10">pool_</code>赋值到当前对象，然后置空实参对象以保证实参对象析构的时候不会影响这片内存的生命周期。</p> 
 <p class="zw">编译运行这段代码，其输出结果如下：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">copy big memory pool.
move big memory pool.
move big memory pool.</code></pre> 
 <p class="zw">可以看到后面两次的构造函数变成了移动构造函数，因为这两次操作中源对象都是右值（临时对象），对于右值编译器会优先选择使用移动构造函数去构造目标对象。当移动构造函数不存在的时候才会退而求其次地使用复制构造函数。在移动构造函数中使用了指针转移的方式构造目标对象，所以整个程序的运行效率得到大幅提升。</p> 
 <p class="zw">为了验证效率的提升，我们可以将上面的代码重复运行 100 万次，然后输出运行时间。请注意，在做实验前需要将构造函数中的打印输出语句删除，否则会影响实验数据：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;chrono&gt;
…
int main()
{
  auto start = std::chrono::high_resolution_clock::now();
  for (int i = 0; i &lt; 1000000; i++) {
      BigMemoryPool my_pool = make_pool();
  }
  auto end = std::chrono::high_resolution_clock::now();
  std::chrono::duration&lt;double&gt; diff = end - start;
  std::cout &lt;&lt; "Time to call make_pool :" &lt;&lt; diff.count() &lt;&lt; " s" &lt;&lt; std::endl;
}</code></pre> 
 <p class="zw">以上代码在我的机器上运行结果是0.206474s，如果将移动构造函数删除，运行结果是0.47077s，可见使用移动构造函数将性能提升了1倍多。</p> 
 <p class="zw">除移动构造函数能实现移动语义以外，移动赋值运算符函数也能完成移动操作，继续以<code class="calibre10">BigMemoryPool</code>为例，在这个类中添加移动赋值运算符函数：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class BigMemoryPool {
public:
  …
  BigMemoryPool&amp; operator=(BigMemoryPool&amp;&amp; other)
  {
      std::cout &lt;&lt; "move(operator=) big memory pool." &lt;&lt; std::endl;
      if (pool_ != nullptr) {
            delete[] pool_;
      }
      pool_ = other.pool_;
      other.pool_ = nullptr;
      return *this;
  }

private:

  char *pool_;
};

int main()
{
  BigMemoryPool my_pool;
  my_pool = make_pool();
}</code></pre> 
 <p class="zw">这段代码编译运行的结果是：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">copy big memory pool.
move big memory pool.
move(operator=) big memory pool.</code></pre> 
 <p class="zw">可以看到赋值操作<code class="calibre10">my_pool = make_pool()</code>调用了移动赋值运算符函数，这里的规则和构造函数一样，即编译器对于赋值源对象是右值的情况会优先调用移动赋值运算符函数，如果该函数不存在，则调用复制赋值运算符函数。</p> 
 <p class="zw">最后有两点需要说明一下。</p> 
 <p class="zw">1．同复制构造函数一样，编译器在一些条件下会生成一份移动构造函数，这些条件包括：没有任何的复制函数，包括复制构造函数和复制赋值函数；没有任何的移动函数，包括移动构造函数和移动赋值函数；也没有析构函数。虽然这些条件严苛得让人有些不太愉快，但是我们也不必对生成的移动构造函数有太多期待，因为编译器生成的移动构造函数和复制构造函数并没有什么区别。</p> 
 <p class="zw">2．虽然使用移动语义在性能上有很大收益，但是却也有一些风险，这些风险来自异常。试想一下，在一个移动构造函数中，如果当一个对象的资源移动到另一个对象时发生了异常，也就是说对象的一部分发生了转移而另一部分没有，这就会造成源对象和目标对象都不完整的情况发生，这种情况的后果是无法预测的。所以在编写移动语义的函数时建议确保函数不会抛出异常，与此同时，如果无法保证移动构造函数不会抛出异常，可以使用<code class="calibre10">noexcept</code>说明符限制该函数。这样当函数抛出异常的时候，程序不会再继续执行而是调用<code class="calibre10">std::terminate</code>中止执行以免造成其他不良影响。</p> 
 <h2 id="OEBPS/Text/chapter006.html.nav_point_55" class="sigil_not_in_toc">6.6　值类别</h2> 
 <p class="zw">到目前为止一切都非常容易理解，其中一个原因是我在前面的内容中隐藏了一个概念。但是在进一步探讨右值引用之前，我们必须先掌握这个概念——值类别。值类别是C++11标准中新引入的概念，具体来说它是表达式的一种属性，该属性将表达式分为3个类别，它们分别是左值（lvalue）、纯右值（prvalue）和将亡值（xvalue），如图6-1所示。从前面的内容中我们知道早在C++98的时候，已经有了一些关于左值和右值的概念了，只不过当时这些概念对于C++程序编写并不重要。但是由于C++11中右值引用的出现，值类别被赋予了全新的含义。可惜的是，在C++11标准中并没能够清晰地定义它们，比如在C++11的标准文档中，左值的概念只有一句话：“指定一个函数或一个对象”，这样的描述显然是不清晰的。这种糟糕的情况一直延续到C++17标准的推出才得到解决。所以现在是时候让我们重新认识这些概念了。</p> 
 <p class="tu"><img alt="0601" src="data:image/png;base64,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" width="552" height="184" class="calibre18"></p> 
 <p class="zw">▲图6-1</p> 
 <p class="zw">表达式首先被分为了泛左值（glvalue)和右值（rvalue），其中泛左值被进一步划分为左值和将亡值，右值又被划分为将亡值和纯右值。理解这些概念的关键在于泛左值、纯右值和将亡值。</p> 
 <p class="zw">1．所谓泛左值是指一个通过评估能够确定对象、位域或函数的标识的表达式。简单来说，它确定了对象或者函数的标识（具名对象）。</p> 
 <p class="zw">2．而纯右值是指一个通过评估能够用于初始化对象和位域，或者能够计算运算符操作数的值的表达式。</p> 
 <p class="zw">3．将亡值属于泛左值的一种，它表示资源可以被重用的对象和位域，通常这是因为它们接近其生命周期的末尾，另外也可能是经过右值引用的转换产生的。</p> 
 <p class="zw">剩下的两种类别就很容易理解了，其中左值是指非将亡值的泛左值，而右值则包含了纯右值和将亡值。再次强调，值类别都是表达式的属性，所以我们常说的左值和右值实际上指的是表达式，不过为了描述方便我们常常会忽略它。</p> 
 <p class="zw">是不是感觉有点晕。相信我，当我第一次看到这些概念的时候也是这个反应。不过好在我们对传统左值和右值的概念已经了然于心了，现在只需要做道连线题就能弄清楚它们的概念。实际上，这里的左值（lvalue）就是我们上文中描述的C++98的左值，而这里的纯右值（prvalue）则对应上文中描述的C++98的右值。最后我们惊喜地发现，现在只需要弄清楚将亡值（xvalue）到底是如何产生的就可以了。</p> 
 <p class="zw">从本质上说产生将亡值的途径有两种，第一种是使用类型转换将泛左值转换为该类型的右值引用。比如：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">static_cast&lt;BigMemoryPool&amp;&amp;&gt;(my_pool)</code></pre> 
 <p class="zw">第二种在C++17标准中引入，我们称它为临时量实质化，指的是纯右值转换到临时对象的过程。每当纯右值出现在一个需要泛左值的地方时，临时量实质化都会发生，也就是说都会创建一个临时对象并且使用纯右值对其进行初始化，这也符合纯右值的概念，而这里的临时对象就是一个将亡值。</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct X {
  int a;
};

int main()
{
  int b = X().a;
}</code></pre> 
 <p class="zw">在上面的代码中，<code class="calibre10">S()</code>是一个纯右值，访问其成员变量<code class="calibre10">a</code>却需要一个泛左值，所以这里会发生一次临时量实质化，将<code class="calibre10">S()</code>转换为将亡值，最后再访问其成员变量<code class="calibre10">a</code>。还有一点需要说明，在C++17标准之前临时变量是纯右值，只有转换为右值引用的类型才是将亡值。</p> 
 <p class="zw">在本节之后的内容中，依然会以左值和右值这样的术语为主。但是读者应该清楚，这里的左值是C++17中的左值（lvalue），右值是C++17中的纯右值（prvalue）和将亡值（xvalue）。对于将亡值（xvalue），读者实际上只需要知道它是泛左值和右值交集即可，后面的内容也不会重点强调它，所以不会影响到读者对后续内容的理解。</p> 
 <h2 id="OEBPS/Text/chapter006.html.nav_point_56" class="sigil_not_in_toc">6.7　将左值转换为右值</h2> 
 <p class="zw">在6.3节提到过右值引用只能绑定一个右值，如果尝试绑定，左值会导致编译错误：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int i = 0;
int &amp;&amp;k = i;    // 编译失败</code></pre> 
 <p class="zw">不过，如果想完成将右值引用绑定到左值这个“壮举”还是有办法的。在C++11标准中可以在不创建临时值的情况下显式地将左值通过<code class="calibre10">static_cast</code>转换为将亡值，通过值类别的内容我们知道将亡值属于右值，所以可以被右值引用绑定。值得注意的是，由于转换的并不是右值，因此它依然有着和转换之前相同的生命周期和内存地址，例如：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int i = 0;
int &amp;&amp;k = static_cast&lt;int&amp;&amp;&gt;(i);    // 编译成功</code></pre> 
 <p class="zw">读者在这里应该会有疑问，既然这个转换既不改变生命周期也不改变内存地址，那它有什么存在的意义呢？实际上它的最大作用是让左值使用移动语义，还是以<code class="calibre10">BigMemoryPool</code>为例：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">BigMemoryPool my_pool1;
BigMemoryPool my_pool2 = my_pool1;
BigMemoryPool my_pool3 = static_cast&lt;BigMemoryPool &amp;&amp;&gt;(my_pool1);</code></pre> 
 <p class="zw">在这段代码中，<code class="calibre10">my_pool1</code>是一个<code class="calibre10">BigMemoryPool</code>类型的对象，也是一个左值，所以用它去构造<code class="calibre10">my_pool2</code>的时候调用的是复制构造函数。为了让编译器调用移动构造函数构造<code class="calibre10">my_pool3</code>，这里使用了<code class="calibre10">static_cast&lt;BigMemoryPool &amp;&amp;&gt;(my_ pool1)</code>将<code class="calibre10">my_pool1</code>强制转换为右值（也是将亡值，为了叙述思路的连贯性后面不再强调）。由于调用了移动构造函数，<code class="calibre10">my_pool1</code>失去了自己的内存数据，后面的代码也不能对<code class="calibre10">my_pool1</code>进行操作了。</p> 
 <p class="zw">现在问题又来了，这样单纯地将一个左值数据转换到另外一个左值似乎并没有什么意义。在这个例子中的确如此，这样的转换不仅没有意义，而且如果有程序员在移动构造之后的代码中再次使用<code class="calibre10">my_pool1</code>还会引发未定义的行为。正确的使用场景是在一个右值被转换为左值后需要再次转换为右值，最典型的例子是一个右值作为实参传递到函数中。我们在讨论左值和右值的时候曾经提到过，无论一个函数的实参是左值还是右值，其形参都是一个左值，即使这个形参看上去是一个右值引用，例如：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void move_pool(BigMemoryPool &amp;&amp;pool)
{
  std::cout &lt;&lt; "call move_pool" &lt;&lt; std::endl;
  BigMemoryPool my_pool(pool);
}

int main()
{
  move_pool(make_pool());
}</code></pre> 
 <p class="zw">编译运行以上代码输出结果如下：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">copy big memory pool.
move big memory pool.
call move_pool
copy big memory pool.</code></pre> 
 <p class="zw">在上面的代码中，move_pool函数的实参是make_pool函数返回的临时对象，也是一个右值，move_pool的形参是一个右值引用，但是在使用形参pool构造my_pool的时候还是会调用复制构造函数而非移动构造函数。为了让my_pool调用移动构造函数进行构造，需要将形参pool强制转换为右值：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void move_pool(BigMemoryPool &amp;&amp;pool)
{
  std::cout &lt;&lt; "call move_pool" &lt;&lt; std::endl;
  BigMemoryPool my_pool(static_cast&lt;BigMemoryPool&amp;&amp;&gt;(pool));
}</code></pre> 
 <p class="zw">请注意，在这个场景下强制转换为右值就没有任何问题了，因为move_pool函数的实参是make_pool返回的临时对象，当函数调用结束后临时对象就会被销毁，所以转移其内存数据不会存在任何问题。</p> 
 <p class="zw">在C++11的标准库中还提供了一个函数模板std::move帮助我们将左值转换为右值，这个函数内部也是用static_cast做类型转换。只不过由于它是使用模板实现的函数，因此会根据传参类型自动推导返回类型，省去了指定转换类型的代码。另一方面从移动语义上来说，使用std::move函数的描述更加准确。所以建议读者使用std::move将左值转换为右值而非自己使用static_cast转换，例如：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void move_pool(BigMemoryPool &amp;&amp;pool)
{
  std::cout &lt;&lt; "call move_pool" &lt;&lt; std::endl;
  BigMemoryPool my_pool(std::move(pool));
}</code></pre> 
 <h2 id="OEBPS/Text/chapter006.html.nav_point_57" class="sigil_not_in_toc">6.8　万能引用和引用折叠</h2> 
 <p class="zw">6.2节提到过常量左值引用既可以引用左值又可以引用右值，是一个几乎万能的引用，但可惜的是由于其常量性，导致它的使用范围受到一些限制。其实在C++11中确实存在着一个被称为“万能”的引用，它看似是一个右值引用，但其实有着很大区别，请看下面的代码：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void foo(int &amp;&amp;i) {}    // i为右值引用

template&lt;class T&gt;
void bar(T &amp;&amp;t) {}        // t为万能引用

int get_val() { return 5; }
int &amp;&amp;x = get_val();      // x为右值引用
auto &amp;&amp;y = get_val();     // y为万能引用</code></pre> 
 <p class="zw">在上面的代码中，函数<code class="calibre10">foo</code>的形参<code class="calibre10">i</code>和变量<code class="calibre10">x</code>是右值引用，而函数模板的形参<code class="calibre10">t</code>和变量<code class="calibre10">y</code>则是万能引用。我们知道右值引用只能绑定一个右值，但是万能引用既可以绑定左值也可以绑定右值，甚至<code class="calibre10">const</code>和<code class="calibre10">volatile</code>的值都可以绑定，例如：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int i = 42;
const int j = 11;
bar(i);
bar(j);
bar(get_val());

auto &amp;&amp;x = i;
auto &amp;&amp;y = j;
auto &amp;&amp;z = get_val();</code></pre> 
 <p class="zw">看到这里读者应该已经发现了其中的奥秘。所谓的万能引用是因为发生了类型推导，在<code class="calibre10">T&amp;&amp;</code>和<code class="calibre10">auto&amp;&amp;</code>的初始化过程中都会发生类型的推导，如果已经有一个确定的类型，比如<code class="calibre10">int &amp;&amp;</code>，则是右值引用。在这个推导过程中，初始化的源对象如果是一个左值，则目标对象会推导出左值引用；反之如果源对象是一个右值，则会推导出右值引用，不过无论如何都会是一个引用类型。</p> 
 <p class="zw">万能引用能如此灵活地引用对象，实际上是因为在C++11中添加了一套引用叠加推导的规则——引用折叠。在这套规则中规定了在不同的引用类型互相作用的情况下应该如何推导出最终类型，如表6-1所示。</p> 
 <p class="zw">▼表6-1</p> 
 <table border="1" width="90%" class="calibre11"> 
  <thead class="calibre12"> 
   <tr class="calibre13"> 
    <th class="calibre14"> <p class="biao_tou_dan_yuan_ge">类模板型</p> </th> 
    <th class="calibre14"> <p class="biao_tou_dan_yuan_ge">T实际类型</p> </th> 
    <th class="calibre14"> <p class="biao_tou_dan_yuan_ge">最终类型</p> </th> 
   </tr> 
  </thead> 
  <tbody class="calibre15"> 
   <tr class="calibre13"> 
    <td class="calibre16"> <p class="biao_tou_dan_yuan_ge">T&amp;</p> </td> 
    <td class="calibre16"> <p class="biao_tou_dan_yuan_ge">R</p> </td> 
    <td class="calibre16"> <p class="biao_tou_dan_yuan_ge">R&amp;</p> </td> 
   </tr> 
   <tr class="calibre17"> 
    <td class="calibre16"> <p class="biao_tou_dan_yuan_ge">T&amp;</p> </td> 
    <td class="calibre16"> <p class="biao_tou_dan_yuan_ge">R&amp;</p> </td> 
    <td class="calibre16"> <p class="biao_tou_dan_yuan_ge">R&amp;</p> </td> 
   </tr> 
   <tr class="calibre13"> 
    <td class="calibre16"> <p class="biao_tou_dan_yuan_ge">T&amp;</p> </td> 
    <td class="calibre16"> <p class="biao_tou_dan_yuan_ge">R&amp;&amp;</p> </td> 
    <td class="calibre16"> <p class="biao_tou_dan_yuan_ge">R&amp;</p> </td> 
   </tr> 
   <tr class="calibre17"> 
    <td class="calibre16"> <p class="biao_tou_dan_yuan_ge">T&amp;&amp;</p> </td> 
    <td class="calibre16"> <p class="biao_tou_dan_yuan_ge">R</p> </td> 
    <td class="calibre16"> <p class="biao_tou_dan_yuan_ge">R&amp;&amp;</p> </td> 
   </tr> 
   <tr class="calibre13"> 
    <td class="calibre16"> <p class="biao_tou_dan_yuan_ge">T&amp;&amp;</p> </td> 
    <td class="calibre16"> <p class="biao_tou_dan_yuan_ge">R&amp;</p> </td> 
    <td class="calibre16"> <p class="biao_tou_dan_yuan_ge">R&amp;</p> </td> 
   </tr> 
   <tr class="calibre17"> 
    <td class="calibre16"> <p class="biao_tou_dan_yuan_ge">T&amp;&amp;</p> </td> 
    <td class="calibre16"> <p class="biao_tou_dan_yuan_ge">R&amp;&amp;</p> </td> 
    <td class="calibre16"> <p class="biao_tou_dan_yuan_ge">R&amp;&amp;</p> </td> 
   </tr> 
  </tbody> 
 </table> 
 <p class="zw">上面的表格显示了引用折叠的推导规则，可以看出在整个推导过程中，只要有左值引用参与进来，最后推导的结果就是一个左值引用。只有实际类型是一个非引用类型或者右值引用类型时，最后推导出来的才是一个右值引用。那么这个规则是如何在万能引用中体现的呢？让我们以函数模板<code class="calibre10">bar</code>为例看一下具体的推导过程。</p> 
 <p class="zw">在<code class="calibre10">bar(i);</code>中<code class="calibre10">i</code>是一个左值，所以<code class="calibre10">T</code>的推导类型结果是<code class="calibre10">int&amp;</code>，根据引用折叠规则<code class="calibre10">int&amp; &amp;&amp;</code>的最终推导类型为<code class="calibre10">int&amp;</code>，于是<code class="calibre10">bar</code>函数的形参是一个左值引用。而在<code class="calibre10">bar(get_val());</code>中<code class="calibre10">get_val</code>返回的是一个右值，所以<code class="calibre10">T</code>的推导类型为非引用类型<code class="calibre10">int</code>，于是最终的推导类型是<code class="calibre10">int&amp;&amp;</code>，<code class="calibre10">bar</code>函数的形参成为一个右值引用。</p> 
 <p class="zw">值得一提的是，万能引用的形式必须是<code class="calibre10">T&amp;&amp;</code>或者<code class="calibre10">auto&amp;&amp;</code>，也就是说它们必须在初始化的时候被直接推导出来，如果在推导中出现中间过程，则不是一个万能引用，例如：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;vector&gt;
template&lt;class T&gt;
void foo(std::vector&lt;T&gt; &amp;&amp;t) {}
int main()
{
  std::vector&lt;int&gt; v{ 1,2,3 };
  foo(v);                                // 编译错误
}</code></pre> 
 <p class="zw">在上面的代码中，<code class="calibre10">foo(v)</code>无法编译通过，因为<code class="calibre10">foo</code>的形参<code class="calibre10">t</code>并不是一个万能引用，而是一个右值引用。因为<code class="calibre10">foo</code>的形参类型是<code class="calibre10">std::vector&lt;T&gt;&amp;&amp;</code>而不是<code class="calibre10">T&amp;&amp;</code>，所以编译器无法将其看作一个万能引用处理。</p> 
 <h2 id="OEBPS/Text/chapter006.html.nav_point_58" class="sigil_not_in_toc">6.9　完美转发</h2> 
 <p class="zw">6.8节介绍了万能引用的语法和推导规则，但没有提到它的用途。现在是时候讨论这个问题了，万能引用最典型的用途被称为完美转发。在介绍完美转发之前，我们先看一个常规的转发函数模板：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;

template&lt;class T&gt;
void show_type(T t)
{
  std::cout &lt;&lt; typeid(t).name() &lt;&lt; std::endl;
}

template&lt;class T&gt;
void normal_forwarding(T t)
{
  show_type(t);
}

int main()
{
  std::string s = "hello world";
  normal_forwarding(s);
}</code></pre> 
 <p class="zw">在上面的代码中，函数<code class="calibre10">normal_forwarding</code>是一个常规的转发函数模板，它可以完成字符串的转发任务。但是它的效率却令人堪忧。因为<code class="calibre10">normal_forwarding</code>按值转发，也就是说<code class="calibre10">std::string</code>在转发过程中会额外发生一次临时对象的复制。其中一个解决办法是将<code class="calibre10">void normal_forwarding(T t)</code>替换为<code class="calibre10">void normal_ forwarding(T &amp;t)</code>，这样就能避免临时对象的复制。不过这样会带来另外一个问题，如果传递过来的是一个右值，则该代码无法通过编译，例如：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::string get_string()
{
  return "hi world";
}

normal_forwarding(get_string());    // 编译失败</code></pre> 
 <p class="zw">当然，我们还可以将<code class="calibre10">void normal_forwarding(T &amp;t)</code>替换为<code class="calibre10">void normal_forwarding (const T &amp;t)</code>来解决这个问题，因为常量左值引用是可以引用右值的。但是我们也知道，虽然常量左值引用在这个场景下可以“完美”地转发字符串，但是如果在后续的函数中需要修改该字符串，则会编译错误。所以这些方法都不能称得上是完美转发。</p> 
 <p class="zw">万能引用的出现改变了这个尴尬的局面。上文提到过，对于万能引用的形参来说，如果实参是给左值，则形参被推导为左值引用；反之如果实参是一个右值，则形参被推导为右值引用，所以下面的代码无论传递的是左值还是右值都可以被转发，而且不会发生多余的临时复制：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;

template&lt;class T&gt;
void show_type(T t)
{
  std::cout &lt;&lt; typeid(t).name() &lt;&lt; std::endl;
}

template&lt;class T&gt;
void perfect_forwarding(T &amp;&amp;t)
{
  show_type(static_cast&lt;T&amp;&amp;&gt;(t));
}

std::string get_string()
{
  return "hi world";
}

int main()
{
  std::string s = "hello world";
  perfect_forwarding(s);
  perfect_forwarding(get_string());
}</code></pre> 
 <p class="zw">如果已经理解了引用折叠规则，那么上面的代码就很容易理解了。唯一可能需要注意的是<code class="calibre10">show_type(static_cast&lt;T&amp;&amp;&gt;(t));</code>中的类型转换，之所以这里需要用到类型转换，是因为作为形参的<code class="calibre10">t</code>是左值。为了让转发将左右值的属性也带到目标函数中，这里需要进行类型转换。当实参是一个左值时，<code class="calibre10">T</code>被推导为<code class="calibre10">std::string&amp;</code>，于是<code class="calibre10">static_cast&lt;T&amp;&amp;&gt;</code>被推导为<code class="calibre10">static_cast&lt;std:: string&amp;&gt;</code>，传递到<code class="calibre10">show_type</code>函数时继续保持着左值引用的属性；当实参是一个右值时，<code class="calibre10">T</code>被推导为<code class="calibre10">std::string</code>，于是<code class="calibre10">static_cast &lt;T&amp;&amp;&gt;</code>被推导为<code class="calibre10">static_cast&lt;std::string&amp;&amp;&gt;</code>，所以传递到<code class="calibre10">show_type</code>函数时保持了右值引用的属性。</p> 
 <p class="zw">和移动语义的情况一样，显式使用<code class="calibre10">static_cast</code>类型转换进行转发不是一个便捷的方法。在C++11的标准库中提供了一个<code class="calibre10">std::forward</code>函数模板，在函数内部也是使用<code class="calibre10">static_cast</code>进行类型转换，只不过使用<code class="calibre10">std::forward</code>转发语义会表达得更加清晰，<code class="calibre10">std::forward</code>函数模板的使用方法也很简单：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T&gt;
void perfect_forwarding(T &amp;&amp;t)
{
  show_type(std::forward&lt;T&gt;(t));
}</code></pre> 
 <p class="zw">请注意<code class="calibre10">std::move</code>和<code class="calibre10">std::forward</code>的区别，其中<code class="calibre10">std::move</code>一定会将实参转换为一个右值引用，并且使用<code class="calibre10">std::move</code>不需要指定模板实参，模板实参是由函数调用推导出来的。而<code class="calibre10">std::forward</code>会根据左值和右值的实际情况进行转发，在使用的时候需要指定模板实参。</p> 
 <h2 id="OEBPS/Text/chapter006.html.nav_point_59" class="sigil_not_in_toc">6.10　针对局部变量和右值引用的隐式移动操作</h2> 
 <p class="zw">在对旧程序代码升级新编译环境之后，我们可能会发现程序运行的效率提高了，这里的原因一定少不了新标准的编译器在某些情况下将隐式复制修改为隐式移动。虽然这些是编译器“偷偷”完成的，但是我们不能因为运行效率提高就忽略其中的缘由，所以接下来我们要弄清楚这些隐式移动是怎么发生的：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

struct X {
  X() = default;
  X(const X&amp;) = default;
  X(X&amp;&amp;) {
      std::cout &lt;&lt; "move ctor";
  }
};

X f(X x) {
  return x;
}

int main() {
  X r = f(X{});
}</code></pre> 
 <p class="zw">这段代码很容易理解，函数<code class="calibre10">f</code>直接返回调用者传进来的实参<code class="calibre10">x</code>，在<code class="calibre10">main</code>函数中使用<code class="calibre10">r</code>接收<code class="calibre10">f</code>函数的返回值。关键问题是，这个赋值操作究竟是如何进行的。从代码上看，将<code class="calibre10">r</code>赋值为<code class="calibre10">x</code>应该是一个复制，对于旧时的标准这是没错的。但是对于支持移动语义的新标准，这个地方会隐式地采用移动构造函数来完成数据的交换。编译运行以上代码最终会显示<code class="calibre10">move ctor</code>字符串。</p> 
 <p class="zw">除此之外，对于局部变量也有相似的规则，只不过大多数时候编译器会采用更加高效的返回值优化代替移动操作，这里我们稍微修改一点<code class="calibre10">f</code>函数：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">X f() {
  X x;
  return x;
}

int main() {
  X r = f();
}</code></pre> 
 <p class="zw">请注意，编译以上代码的时候需要使用<code class="calibre10">-fno-elide-constructors</code>选项用于关闭返回值优化。然后运行编译好的程序，会发现<code class="calibre10">X r = f();</code>同样调用的是移动构造函数。</p> 
 <p class="zw">在C++20标准中，隐式移动操作针对右值引用和<code class="calibre10">throw</code>的情况进行了扩展，例如：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;

struct X {
  X() = default;
  X(const X&amp;) = default;
  X(X&amp;&amp;) {
      std::cout &lt;&lt; "move";
  }
};

X f(X &amp;&amp;x) {
  return x;
}

int main() {
  X r = f(X{});
}</code></pre> 
 <p class="zw">以上代码使用C++20之前的标准编译是不会调用任何移动构造函数的。原因前面也解释过，因为函数<code class="calibre10">f</code>的形参<code class="calibre10">x</code>是一个左值，对于左值要调用复制构造函数。要实现移动语义，需要将<code class="calibre10">return x;</code>修改为<code class="calibre10">return std::move(x);</code>。显然这里是有优化空间的，C++20标准规定在这种情况下可以隐式采用移动语义完成赋值。具体规则如下。</p> 
 <p class="zw">可隐式移动的对象必须是一个非易失或一个右值引用的非易失自动存储对象，在以下情况下可以使用移动代替复制。</p> 
 <p class="zw">1．<code class="calibre10">return</code>或者<code class="calibre10">co_return</code>语句中的返回对象是函数或者<code class="calibre10">lambda</code>表达式中的对象或形参。</p> 
 <p class="zw">2．<code class="calibre10">throw</code>语句中抛出的对象是函数或<code class="calibre10">try</code>代码块中的对象。</p> 
 <p class="zw">实际上<code class="calibre10">throw</code>调用移动构造的情况和<code class="calibre10">return</code>差不多，我们只需要将上面的代码稍作修改即可：</p> 
 <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void f() {
  X x;
  throw x;
}
int main() {
  try {
       f();
  }
  catch (…) {
  }
}</code></pre> 
 <p class="zw">可以看到函数<code class="calibre10">f</code>不再有返回值，它通过<code class="calibre10">throw</code>抛出<code class="calibre10">x</code>，<code class="calibre10">main</code>函数用<code class="calibre10">try-catch</code>捕获<code class="calibre10">f</code>抛出的<code class="calibre10">x</code>。这个捕获调用的就是移动构造函数。</p> 
 <h2 id="OEBPS/Text/chapter006.html.nav_point_60" class="sigil_not_in_toc">6.11　总结</h2> 
 <p class="zw">右值引用是C++11标准提出的一个非常重要的概念，它的出现不仅完善了C++的语法，改善了C++在数据转移时的执行效率，同时还增强了C++模板的能力。如果要在C++11提出的所有特性中选择一个对C++影响最深远的特性，我会毫不犹豫地选择右值引用。</p> 
 <p class="zw">随着C++引入右值引用以及与之相关的移动语义和完美转发，C++的语义变得更加丰富和合理，与此同时它的性能也有了更大的优化空间。对于这些优化空间，C++委员会已经对标准库进行了优化，比如常用的容器<code class="calibre10">vector</code>、<code class="calibre10">list</code>和<code class="calibre10">map</code>等均已支持移动构造函数和移动赋值运算符函数。另外，如<code class="calibre10">make_pair</code>、<code class="calibre10">make_tuple</code>以及<code class="calibre10">make_shared</code>等也都使用完美转发以提高程序的性能。对于我们而言，也应该灵活运用右值引用，避免在程序里出现无谓的复制，提高程序的运行效率。</p> 
 <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter006.html.calibre_pb_1"></p> 
</div></div>
<div id="OEBPS/Text/chapter007.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter007.html.nav_point_61" class="not-in-toc">第7章　lambda表达式（C++11～C++20）</h1>

  <h2 id="OEBPS/Text/chapter007.html.nav_point_62" class="sigil_not_in_toc">7.1　lambda表达式语法</h2>

  <p class="zw">lambda表达式是现代编程语言的一个基础特性，比如LISP、Python、C#等具备该特性。但是遗憾的是，直到C++11标准之前，C++都没有在语言特性层面上支持lambda表达式。程序员曾尝试使用库来实现lambda表达式的功能，比如Boost.Bind或Boost.Lambda，但是它们有着共同的缺点，实现代码非常复杂，使用的时候也需要十分小心，一旦有错误发生，就可能会出现一堆错误和警告信息，总之其编程体验并不好。</p>

  <p class="zw">另外，虽然C++一直以来都没有支持lambda表达式，但是它对lambda表达式的需求却非常高。最明显的就是STL，在STL中有大量需要传入谓词的算法函数，比如std::find_if、std::replace_if等。过去有两种方法实现谓词函数：编写纯函数或者仿函数。但是它们的定义都无法直接应用到函数调用的实参中，面对复杂工程的代码，我们可能需要四处切换源文件来搜索这些函数或者仿函数。</p>

  <p class="zw">为了解决上面这些问题，C++11标准为我们提供了lambda表达式的支持，而且语法非常简单明了。这种简单可能会让我们觉得它与传统的C++语法有点格格不入。不过在习惯新的语法之后，就会发觉lambda表达式的方便之处。</p>

  <p class="zw">lambda表达式的语法非常简单，具体定义如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">[ captures ] ( params ) specifiers exception -&gt; ret { body }</code></pre>

  <p class="zw">先不用急于解读这个定义，我们可以结合lambda表达式的例子来读懂它的语法：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

int main()
{
    int x = 5;
    auto foo = [x](int y)-&gt;int { return x * y; };
    std::cout &lt;&lt; foo(8) &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">在这个例子中，[x](int y)-&gt;int { return x * y; }是一个标准的lambda表达式，对应到lambda表达式的语法。</p>

  <p class="zw">　　[ captures ] —— 捕获列表，它可以捕获当前函数作用域的零个或多个变量，变量之间用逗号分隔。在对应的例子中，[x]是一个捕获列表，不过它只捕获了当前函数作用域的一个变量x，在捕获了变量之后，我们可以在lambda表达式函数体内使用这个变量，比如return x * y。另外，捕获列表的捕获方式有两种：按值捕获和引用捕获，下文会详细介绍。</p>

  <p class="zw">　　( params ) —— 可选参数列表，语法和普通函数的参数列表一样，在不需要参数的时候可以忽略参数列表。对应例子中的(int y)。</p>

  <p class="zw">　　specifiers —— 可选限定符，C++11中可以用mutable，它允许我们在lambda表达式函数体内改变按值捕获的变量，或者调用非const的成员函数。上面的例子中没有使用说明符。</p>

  <p class="zw">　　exception —— 可选异常说明符，我们可以使用noexcept来指明lambda是否会抛出异常。对应的例子中没有使用异常说明符。</p>

  <p class="zw">　　ret —— 可选返回值类型，不同于普通函数，lambda表达式使用返回类型后置的语法来表示返回类型，如果没有返回值（void类型），可以忽略包括-&gt;在内的整个部分。另外，我们也可以在有返回值的情况下不指定返回类型，这时编译器会为我们推导出一个返回类型。对应到上面的例子是-&gt;int。</p>

  <p class="zw">　　{ body } —— lambda表达式的函数体，这个部分和普通函数的函数体一样。对应例子中的{ return x * y; }。</p>

  <p class="zw">细心的读者肯定发现了一个有趣的事实，由于参数列表，限定符以及返回值都是可选的，于是我们可以写出的最简单的lambda表达式是[]{}。虽然看上去非常奇怪，但它确实是一个合法的lambda表达式。需要特别强调的是，上面的语法定义只属于C++11标准，C++14和C++17标准对lambda表达式又进行了很有用的扩展，我们会在后面介绍。</p>

  <h2 id="OEBPS/Text/chapter007.html.nav_point_63" class="sigil_not_in_toc">7.2　捕获列表</h2>

  <p class="zw">在lambda表达式的语法中，与传统C++语法差异最大的部分应该算是捕获列表了。实际上，除了语法差异较大之外，它也是lambda表达式中最为复杂的一个部分。接下来我们会把捕获列表分解开来逐步讨论其特性。</p>

  <h3 id="OEBPS/Text/chapter007.html.nav_point_64" class="sigil_not_in_toc1">7.2.1　作用域</h3>

  <p class="zw">我们必须了解捕获列表的作用域，通常我们说一个对象在某一个作用域内，不过这种说法在捕获列表中发生了变化。捕获列表中的变量存在于两个作用域——lambda表达式定义的函数作用域以及lambda表达式函数体的作用域。前者是为了捕获变量，后者是为了使用变量。另外，标准还规定能捕获的变量必须是一个自动存储类型。简单来说就是非静态的局部变量。让我们看一看下面的例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int x = 0;

int main()
{
    int y = 0;
    static int z = 0;
    auto foo = [x, y, z] {};
}</code></pre>

  <p class="zw">以上代码可能是无法通过编译的，其原因有两点：第一，变量x和z不是自动存储类型的变量；第二，x不存在于lambda表达式定义的作用域。这里可能无法编译，因为不同编译器对于这段代码的处理会有所不同，比如GCC就不会报错，而是给出警告。那么如果想在lambda表达式中使用全局变量或者静态局部变量该怎么办呢？马上能想到的办法是用参数列表传递全局变量或者静态局部变量，其实不必这么麻烦，直接用就行了，来看一看下面的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

int x = 1;
int main()
{
    int y = 2;
    static int z = 3;
    auto foo = [y] { return x + y + z; };
    std::cout &lt;&lt; foo() &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">在上面的代码中，虽然我们没有捕获变量x和z，但是依然可以使用它们。进一步来说，如果我们将一个lambda表达式定义在全局作用域，那么lambda表达式的捕获列表必须为空。因为根据上面提到的规则，捕获列表的变量必须是一个自动存储类型，但是全局作用域并没有这样的类型，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int x = 1;
auto foo = [] { return x; };
int main()
{
    foo();
}</code></pre>

  <h3 id="OEBPS/Text/chapter007.html.nav_point_65" class="sigil_not_in_toc1">7.2.2　捕获值和捕获引用</h3>

  <p class="zw">捕获列表的捕获方式分为捕获值和捕获引用，其中捕获值的语法我们已经在前面的例子中看到了，在[]中直接写入变量名，如果有多个变量，则用逗号分隔，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int main()
{
    int x = 5, y = 8;
    auto foo = [x, y] { return x * y; };
}</code></pre>

  <p class="zw">捕获值是将函数作用域的x和y的值复制到lambda表达式对象的内部，就如同lambda表达式的成员变量一样。</p>

  <p class="zw">捕获引用的语法与捕获值只有一个&amp;的区别，要表达捕获引用我们只需要在捕获变量之前加上&amp;，类似于取变量指针。只不过这里捕获的是引用而不是指针，在lambda表达式内可以直接使用变量名访问变量而不需解引用，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int main()
{
    int x = 5, y = 8;
    auto foo = [&amp;x, &amp;y] { return x * y; };
}</code></pre>

  <p class="zw">上面的两个例子只是读取变量的值，从结果上看两种捕获没有区别，但是如果加入变量的赋值操作，情况就不同了，请看下面的例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void bar1()
{
    int x = 5, y = 8;
    auto foo = [x, y] {
        x += 1;             // 编译失败，无法改变捕获变量的值
        y += 2;             // 编译失败，无法改变捕获变量的值
        return x * y;
    };
    std::cout &lt;&lt; foo() &lt;&lt; std::endl;
}

void bar2()
{
    int x = 5, y = 8;
    auto foo = [&amp;x, &amp;y] {
        x += 1;
        y += 2;
        return x * y;
    };
    std::cout &lt;&lt; foo() &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">在上面的代码中函数bar1无法通过编译，原因是我们无法改变捕获变量的值。这就引出了lambda表达式的一个特性：捕获的变量默认为常量，或者说lambda是一个常量函数（类似于常量成员函数）。bar2函数里的lambda表达式能够顺利地通过编译，虽然其函数体内也有改变变量x和y的行为。这是因为捕获的变量默认为常量指的是变量本身，当变量按值捕获的时候，变量本身就是值，所以改变值就会发生错误。相反，在捕获引用的情况下，捕获变量实际上是一个引用，我们在函数体内改变的并不是引用本身，而是引用的值，所以并没有被编译器拒绝。</p>

  <p class="zw">另外，还记得上文提到的可选说明符mutable吗？使用mutable说明符可以移除lambda表达式的常量性，也就是说我们可以在lambda表达式的函数体中修改捕获值的变量了，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void bar3()
{
    int x = 5, y = 8;
    auto foo = [x, y] () mutable {
        x += 1;
        y += 2;
        return x * y;
    };
    std::cout &lt;&lt; foo() &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">以上代码可以通过编译，也就是说lambda表达式成功地修改了其作用域内的x和y的值。值得注意的是，函数bar3相对于函数bar1除了增加说明符mutable，还多了一对()，这是因为语法规定lambda表达式如果存在说明符，那么形参列表不能省略。</p>

  <p class="zw">编译运行bar2和bar3两个函数会输出相同的结果，但这并不代表两个函数是等价的，捕获值和捕获引用还是存在着本质区别。当lambda表达式捕获值时，表达式内实际获得的是捕获变量的复制，我们可以任意地修改内部捕获变量，但不会影响外部变量。而捕获引用则不同，在lambda表达式内修改捕获引用的变量，对应的外部变量也会被修改：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

int main()
{
    int x = 5, y = 8;
    auto foo = [x, &amp;y]() mutable {
        x += 1;
        y += 2;
        std::cout &lt;&lt; "lambda x = " &lt;&lt; x &lt;&lt; ", y = " &lt;&lt; y &lt;&lt; std::endl;
        return x * y;
    };
    foo();
    std::cout &lt;&lt; "call1  x = " &lt;&lt; x &lt;&lt; ", y = " &lt;&lt; y &lt;&lt; std::endl;
    foo();
    std::cout &lt;&lt; "call2  x = " &lt;&lt; x &lt;&lt; ", y = " &lt;&lt; y &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">运行结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">lambda x = 6, y = 10
call1  x = 5, y = 10
lambda x = 7, y = 12
call2  x = 5, y = 12</code></pre>

  <p class="zw">观察上面这段代码的运行结果会发现，由于x是捕获值的变量，因此无论在lambda表达式内如何改变x的值，其外部作用域的变量都不会发生变化（一直保持为5）。而捕获引用的变量y会随着lambda表达式内的改变而改变。进一步审视x值的变化会发现另一个有趣的事实，虽然在lambda表达式内修改x不会影响外部x的值，但是它却能影响下次调用lambda表达式时x的值。更具体来说，当第一次调用foo的时候，x的值从5增加到6，这个状态持续到第二次调用foo，然后将x的值从6增加到7。</p>

  <p class="zw">对于捕获值的lambda表达式还有一点需要注意，捕获值的变量在lambda表达式定义的时候已经固定下来了，无论函数在lambda表达式定义后如何修改外部变量的值，lambda表达式捕获的值都不会变化，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

int main()
{
    int x = 5, y = 8;
    auto foo = [x, &amp;y]() mutable {
        x += 1;
        y += 2;
        std::cout &lt;&lt; "lambda x = " &lt;&lt; x &lt;&lt; ", y = " &lt;&lt; y &lt;&lt; std::endl;
        return x * y;
    };
    x = 9;
    y = 20;
    foo();
}</code></pre>

  <p class="zw">运行结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">lambda x = 6, y = 22</code></pre>

  <p class="zw">在上面的代码中，虽然在调用foo之前分别修改了x和y的值，但是捕获值的变量x依然延续着lambda定义时的值，而在捕获引用的变量y被重新赋值以后，lambda表达式捕获的变量y的值也跟着发生了变化。</p>

  <h3 id="OEBPS/Text/chapter007.html.nav_point_66" class="sigil_not_in_toc1">7.2.3　特殊的捕获方法</h3>

  <p class="zw">lambda表达式的捕获列表除了指定捕获变量之外还有3种特殊的捕获方法。</p>

  <p class="zw">1．[this] —— 捕获this指针，捕获this指针可以让我们使用this类型的成员变量和函数。</p>

  <p class="zw">2．[=] —— 捕获lambda表达式定义作用域的全部变量的值，包括this。</p>

  <p class="zw">3．[&amp;] —— 捕获lambda表达式定义作用域的全部变量的引用，包括this。</p>

  <p class="zw">首先来看看捕获this的情况：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

class A
{
public:
    void print()
    {
        std::cout &lt;&lt; "class A" &lt;&lt; std::endl;
    }

    void test()
    {
        auto foo = [this] { 
            print(); 
            x = 5; 
        };
        foo();
    }
private:
    int x;
};

int main()
{
    A a;
    a.test();
}</code></pre>

  <p class="zw">在上面的代码中，因为lambda表达式捕获了this指针，所以可以在lambda表达式内调用该类型的成员函数print或者使用其成员变量x。</p>

  <p class="zw">捕获全部变量的值或引用则更容易理解：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

int main()
{
    int x = 5, y = 8;
    auto foo = [=] { return x * y; };
    std::cout &lt;&lt; foo() &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">以上代码并没有指定需要捕获的变量，而是使用[=]捕获所有变量的值，这样在lambda表达式内也能访问x和y的值。同理，使用[&amp;]也会有同样的效果，读者不妨自己尝试一下。</p>

  <h2 id="OEBPS/Text/chapter007.html.nav_point_67" class="sigil_not_in_toc">7.3　lambda表达式的实现原理</h2>

  <p class="zw">如果读者是一个C++的老手，可能已经发现lambda表达式与函数对象（仿函数）非常相似，所以让我们从函数对象开始深入探讨lambda表达式的实现原理。请看下面的例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

class Bar
{
public:
    Bar(int x, int y) : x_(x), y_(y) {}
    int operator () ()
    {
        return x_ * y_;
    }
private:
int x_;
int y_;
};

int main()
{
    int x = 5, y = 8;
    auto foo = [x, y] { return x * y; };
    Bar bar(x, y);
    std::cout &lt;&lt; "foo() = " &lt;&lt; foo() &lt;&lt; std::endl;
    std::cout &lt;&lt; "bar() = " &lt;&lt; bar() &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">在上面的代码中，foo是一个lambda表达式，而bar是一个函数对象。它们都能在初始化的时候获取main函数中变量x和y的值，并在调用之后返回相同的结果。这两者比较明显的区别如下。</p>

  <p class="zw">1．使用lambda表达式不需要我们去显式定义一个类，这一点在快速实现功能上有较大的优势。</p>

  <p class="zw">2．使用函数对象可以在初始化的时候有更加丰富的操作，例如Bar bar(x+y, x * y)，而这个操作在C++11标准的lambda表达式中是不允许的。另外，在Bar初始化对象的时候使用全局或者静态局部变量也是没有问题的。</p>

  <p class="zw">这样看来在C++11标准中，lambda表达式的优势在于书写简单方便且易于维护，而函数对象的优势在于使用更加灵活不受限制，但总的来说它们非常相似。而实际上这也正是lambda表达式的实现原理。</p>

  <p class="zw">lambda表达式在编译期会由编译器自动生成一个闭包类，在运行时由这个闭包类产生一个对象，我们称它为闭包。在C++中，所谓的闭包可以简单地理解为一个匿名且可以包含定义时作用域上下文的函数对象。现在让我们抛开这些概念，观察lambda表达式究竟是什么样子的。</p>

  <p class="zw">首先，定义一个简单的lambda表达式：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

int main()
{
    int x = 5, y = 8;
    auto foo = [=] { return x * y; };
  int z = foo();
}</code></pre>

  <p class="zw">接着，我们用GCC输出其GIMPLE的中间代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">main ()
{
  int D.39253;
  {
    int x;
    int y;
    struct __lambda0 foo;
    typedef struct __lambda0 __lambda0;
    int z;

    try
      {
        x = 5;
        y = 8;
        foo.__x = x;
        foo.__y = y;
        z = main()::&lt;lambda()&gt;::operator() (&amp;foo);
      }
    finally
      {
        foo = {CLOBBER};
      }
  }
  D.39253 = 0;
  return D.39253;
}

main()::&lt;lambda()&gt;::operator() (const struct __lambda0 * const __closure)
{
  int D.39255;
  const int x [value-expr: __closure-&gt;__x];
  const int y [value-expr: __closure-&gt;__y];

  _1 = __closure-&gt;__x;
  _2 = __closure-&gt;__y;
  D.39255 = _1 * _2;
  return D.39255;
}</code></pre>

  <p class="zw">从上面的中间代码可以看出lambda表达式的类型名为__lambda0，通过这个类型实例化了对象foo，然后在函数内对foo对象的成员__x和__y进行赋值，最后通过自定义的()运算符对表达式执行计算并将结果赋值给变量z。在这个过程中，__lambda0是一个拥有operator()自定义运算符的结构体，这也正是函数对象类型的特性。所以，在某种程度上来说，lambda表达式是C++11给我们提供的一块语法糖而已，lambda表达式的功能完全能够手动实现，而且如果实现合理，代码在运行效率上也不会有差距，只不过实用lambda表达式让代码编写更加轻松了。</p>

  <h2 id="OEBPS/Text/chapter007.html.nav_point_68" class="sigil_not_in_toc">7.4　无状态lambda表达式</h2>

  <p class="zw">C++标准对于无状态的lambda表达式有着特殊的照顾，即它可以隐式转换为函数指针，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void f(void(*)()) {}
void g() { f([] {}); } // 编译成功</code></pre>

  <p class="zw">在上面的代码中，lambda表达式[] {}隐式转换为void(*)()类型的函数指针。同样，看下面的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void f(void(&amp;)()) {}
void g() { f(*[] {}); }</code></pre>

  <p class="zw">这段代码也可以顺利地通过编译。我们经常会在STL的代码中遇到lambda表达式的这种应用。</p>

  <h2 id="OEBPS/Text/chapter007.html.nav_point_69" class="sigil_not_in_toc">7.5　在STL中使用lambda表达式</h2>

  <p class="zw">要探讨lambda表达式的常用场合，就必须讨论C++的标准库STL。在STL中我们常常会见到这样一些算法函数，它们的形参需要传入一个函数指针或函数对象从而完成整个算法，例如std::sort、std::find_if等。</p>

  <p class="zw">在C++11标准以前，我们通常需要在函数外部定义一个辅助函数或辅助函数对象类型。对于简单的需求，我们也可能使用STL提供的辅助函数，例如std::less、std::plus等。另外，针对稍微复杂一点的需求还可能会用到std::bind1st、std::bind2nd等函数。总之，无论使用以上的哪种方法，表达起来都相当晦涩。大多数情况下，我们可能必须自己动手编写辅助函数或辅助函数对象类型。</p>

  <p class="zw">幸运的是，在有了lambda表达式以后，这些问题就迎刃而解了。我们可以直接在STL算法函数的参数列表内实现辅助函数，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main()
{
    std::vector&lt;int&gt; x = {1, 2, 3, 4, 5};
    std::cout &lt;&lt; *std::find_if(x.cbegin(), 
                        x.cend(), 
                        [](int i) { return (i % 3) == 0; }) &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">函数std::find_if需要一个辅助函数帮助确定需要找出的值，而这里我们使用lambda表达式直接在传参时定义了辅助函数。无论是编写还是阅读代码，直接定义lambda表达式都比定义辅助函数更加简洁且容易理解。</p>

  <h2 id="OEBPS/Text/chapter007.html.nav_point_70" class="sigil_not_in_toc">7.6　广义捕获</h2>

  <p class="zw">C++14标准中定义了广义捕获，所谓广义捕获实际上是两种捕获方式，第一种称为简单捕获，这种捕获就是我们在前文中提到的捕获方法，即[identifier]、[&amp;identifier]以及[this]等。第二种叫作初始化捕获，这种捕获方式是在C++14标准中引入的，它解决了简单捕获的一个重要问题，即只能捕获lambda表达式定义上下文的变量，而无法捕获表达式结果以及自定义捕获变量名，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int main()
{
    int x = 5;
    auto foo = [x = x + 1]{ return x; };
}</code></pre>

  <p class="zw">以上在C++14标准之前是无法编译通过的，因为C++11标准只支持简单捕获。而C++14标准对这样的捕获进行了支持，在这段代码里捕获列表是一个赋值表达式，不过这个赋值表达式有点特殊，因为它通过等号跨越了两个作用域。等号左边的变量x存在于lambda表达式的作用域，而等号右边x存在于main函数的作用域。如果读者觉得两个x的写法有些绕，我们还可以采用更清晰的写法：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int main()
{
    int x = 5;
    auto foo = [r = x + 1]{ return r; };
}</code></pre>

  <p class="zw">很明显这里的变量r只存在于lambda表达式，如果此时在lambda表达式函数体里使用变量x，则会出现编译错误。初始化捕获在某些场景下是非常实用的，这里举两个例子，第一个场景是使用移动操作减少代码运行的开销，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;string&gt;

int main()
{
    std::string x = "hello c++ ";
    auto foo = [x = std::move(x)]{ return x + "world"; };
}</code></pre>

  <p class="zw">上面这段代码使用std::move对捕获列表变量x进行初始化，这样避免了简单捕获的复制对象操作，代码运行效率得到了提升。</p>

  <p class="zw">第二个场景是在异步调用时复制this对象，防止lambda表达式被调用时因原始this对象被析构造成未定义的行为，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;future&gt;

class Work
{
  private:
    int value;

  public:
    Work() : value(42) {}
    std::future&lt;int&gt; spawn()
    {
        return std::async([=]() -&gt; int { return value; });
    }
};

std::future&lt;int&gt; foo()
{
    Work tmp;
    return tmp.spawn();
}

int main()
{
    std::future&lt;int&gt; f = foo();
    f.wait();
  std::cout &lt;&lt; "f.get() = " &lt;&lt; f.get() &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">输出结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">f.get() = 32766</code></pre>

  <p class="zw">这里我们期待f.get()返回的结果是42，而实际上返回了32766，这就是一个未定义的行为，它造成了程序的计算错误，甚至有可能让程序崩溃。为了解决这个问题，我们引入初始化捕获的特性，将对象复制到lambda表达式内，让我们简单修改一下spawn函数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class Work
{
  private:
    int value;

  public:
    Work() : value(42) {}
    std::future&lt;int&gt; spawn()
    {
        return std::async([=, tmp = *this]() -&gt; int { return tmp.value; });
    }
};</code></pre>

  <p class="zw">以上代码使用初始化捕获，将*this复制到tmp对象中，然后在函数体内返回tmp对象的value。由于整个对象通过复制的方式传递到lambda表达式内，因此即使this所指的对象析构了也不会影响lambda表达式的计算。编译运行修改后的代码，程序正确地输出f.get() = 42。</p>

  <h2 id="OEBPS/Text/chapter007.html.nav_point_71" class="sigil_not_in_toc">7.7　泛型lambda表达式</h2>

  <p class="zw">C++14标准让lambda表达式具备了模版函数的能力，我们称它为泛型lambda表达式。虽然具备模版函数的能力，但是它的定义方式却用不到template关键字。实际上泛型lambda表达式语法要简单很多，我们只需要使用auto占位符即可，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int main()
{
    auto foo = [](auto a) { return a; };
    int three = foo(3);
    char const* hello = foo("hello");
}</code></pre>

  <p class="zw">由于泛型lambda表达式更多地利用了auto占位符的特性，而lambda表达式本身并没有什么变化，因此想更多地理解泛型lambda表达式，可以阅读第3章，这里就不再赘述了。</p>

  <h2 id="OEBPS/Text/chapter007.html.nav_point_72" class="sigil_not_in_toc">7.8　常量lambda表达式和捕获*this</h2>

  <p class="zw">C++17标准对lambda表达式同样有两处增强，一处是常量lambda表达式，另一处是对捕获*this的增强。其中常量lambda表达式的主要特性体现在constexpr关键字上，请阅读constexpr的有关章节来掌握常量lambda表达式的特性，这里主要说明一下对于捕获this的增强。</p>

  <p class="zw">还记得前面初始化捕获*this对象的代码吗？我们在捕获列表内复制了一份this指向的对象到tmp，然后使用tmp的value。没错，这样做确实解决了异步问题，但是这个解决方案并不优美。试想一下，如果在lambda表达式中用到了大量this指向的对象，那我们就不得不将它们全部修改，一旦遗漏就会引发问题。为了更方便地复制和使用*this对象，C++17增加了捕获列表的语法来简化这个操作，具体来说就是在捕获列表中直接添加[*this]，然后在lambda表达式函数体内直接使用this指向对象的成员，还是以前面的Work类为例：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class Work
{
  private:
    int value;

  public:
    Work() : value(42) {}
    std::future&lt;int&gt; spawn()
    {
        return std::async([=, *this]() -&gt; int { return value; });
    }
};</code></pre>

  <p class="zw">在上面的代码中没有再使用tmp=*this来初始化捕获列表，而是直接使用*this。在lambda表达式内也没有再使用tmp.value而是直接返回了value。编译运行这段代码可以得到预期的结果42。从结果可以看出，[*this]的语法让程序生成了一个*this对象的副本并存储在lambda表达式内，可以在lambda表达式内直接访问这个复制对象的成员，消除了之前lambda表达式需要通过tmp访问对象成员的尴尬。</p>

  <h2 id="OEBPS/Text/chapter007.html.nav_point_73" class="sigil_not_in_toc">7.9　捕获[=, this]</h2>

  <p class="zw">在C++20标准中，又对lambda表达式进行了小幅修改。这一次修改没有加强lambda表达式的能力，而是让this指针的相关语义更加明确。我们知道[=]可以捕获this指针，相似的，[=,*this]会捕获this对象的副本。但是在代码中大量出现[=]和[=,*this]的时候我们可能很容易忘记前者与后者的区别。为了解决这个问题，在C++20标准中引入了[=, this]捕获this指针的语法，它实际上表达的意思和[=]相同，目的是让程序员们区分它与[=,*this]的不同：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">[=, this]{}; // C++17 编译报错或者报警告， C++20成功编译</code></pre>

  <p class="zw">虽然在C++17标准中认为[=, this]{};是有语法问题的，但是实践中GCC和CLang都只是给出了警告而并未报错。另外，在C++20标准中还特别强调了要用[=, this]代替[=]，如果用GCC编译下面这段代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T&gt;
void g(T) {}

struct Foo {
  int n = 0;
  void f(int a) {
       g([=](int k) { return n + a * k; });
  }
};</code></pre>

  <p class="zw">编译器会输出警告信息，表示标准已经不再支持使用[=]隐式捕获this指针了，提示用户显式添加this或者*this。最后值得注意的是，同时用两种语法捕获this指针是不允许的，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">[this, *this]{};</code></pre>

  <p class="zw">这种写法在CLang中一定会给出编译错误，而GCC则稍显温柔地给出警告，在我看来这种写法没有意义，是应该避免的。</p>

  <h2 id="OEBPS/Text/chapter007.html.nav_point_74" class="sigil_not_in_toc">7.10　模板语法的泛型lambda表达式</h2>

  <p class="zw">在7.7节中我们讨论了C++14标准中lambda表达式通过支持auto来实现泛型。大部分情况下，这是一种不错的特性，但不幸的是，这种语法也会使我们难以与类型进行互动，对类型的操作变得异常复杂。用提案文档的举例来说：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;typename T&gt; struct is_std_vector : std::false_type { };
template &lt;typename T&gt; struct is_std_vector&lt;std::vector&lt;T&gt;&gt; : std::true_type { };
auto f = [](auto vector) {
static_assert(is_std_vector&lt;decltype(vector)&gt;::value, "");
};</code></pre>

  <p class="zw">普通的函数模板可以轻松地通过形参模式匹配一个实参为vector的容器对象，但是对于lambda表达式，auto不具备这种表达能力，所以不得不实现is_std_vector，并且通过static_assert来辅助判断实参的真实类型是否为vector。在C++委员会的专家看来，把一个本可以通过模板推导完成的任务交给static_assert来完成是不合适的。除此之外，这样的语法让获取vector存储对象的类型也变得十分复杂，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto f = [](auto vector) {
using T = typename decltype(vector)::value_type;
// …
};</code></pre>

  <p class="zw">当然，能这样实现已经是很侥幸了。我们知道vector容器类型会使用内嵌类型value_type表示存储对象的类型。但我们并不能保证面对的所有容器都会实现这一规则，所以依赖内嵌类型是不可靠的。</p>

  <p class="zw">进一步来说，decltype(obj)有时候并不能直接获取我们想要的类型。不记得decltype推导规则的读者可以复习一下前面的章节，这里就直接说明示例代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto f = [](const auto&amp; x) {
using T = decltype(x);
T copy = x; // 可以编译，但是语义错误
using Iterator = typename T::iterator; // 编译错误
};

std::vector&lt;int&gt; v;
f(v);</code></pre>

  <p class="zw">请注意，在上面的代码中，decltype(x)推导出来的类型并不是std::vector ，而是const std::vector &amp;，所以T copy = x;不是一个复制而是引用。对于一个引用类型来说，T::iterator也是不符合语法的，所以编译出错。在提案文档中，作者很友好地给出了一个解决方案，他使用了STL的decay，这样就可以将类型的cv以及引用属性删除，于是就有了以下代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto f = [](const auto&amp; x) {
using T = std::decay_t&lt;decltype(x)&gt;;
T copy = x;
using Iterator = typename T::iterator;
};</code></pre>

  <p class="zw">问题虽然解决了，但是要时刻注意auto，以免给代码带来意想不到的问题，况且这都是建立在容器本身设计得比较完善的情况下才能继续下去的。</p>

  <p class="zw">鉴于以上种种问题，C++委员会决定在C++20中添加模板对lambda的支持，语法非常简单：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">[]&lt;typename T&gt;(T t) {}</code></pre>

  <p class="zw">于是，上面那些让我们为难的例子就可以改写为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto f = []&lt;typename T&gt;(std::vector&lt;T&gt; vector) {
// …
};</code></pre>

  <p class="zw">以及</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto f = []&lt;typename T&gt;(T const&amp; x) {
T copy = x;
using Iterator = typename T::iterator;
};</code></pre>

  <p class="zw">上面的代码是否能让读者眼前一亮？这些代码不仅简洁了很多，而且也更符合C++泛型编程的习惯。</p>

  <p class="zw">最后再说一个有趣的故事，事实上早在2012年，让lambda支持模板的提案文档N3418已经提交给了C++委员会，不过当时这份提案并没有被接受，到2013年N3559中提出的基于auto的泛型在C++14标准中实现，而2017年lambda支持模板的提案又一次被提出来，这一次可以说是踩在N3559的肩膀上成功地加入了C++20标准。回过头来看整个过程，虽说算不上曲折，但也颇为耐人寻味，C++作为一个发展近30年的语言，依然在不断地探索和纠错中砺志前行。</p>

  <h2 id="OEBPS/Text/chapter007.html.nav_point_75" class="sigil_not_in_toc">7.11　可构造和可赋值的无状态lambda表达式</h2>

  <p class="zw">在7.4节中我们提到了无状态lambda表达式可以转换为函数指针，但遗憾的是，在C++20标准之前无状态的lambda表达式类型既不能构造也无法赋值，这阻碍了许多应用的实现。举例来说，我们已经了解了像std::sort和std::find_if这样的函数需要一个函数对象或函数指针来辅助排序和查找，这种情况我们可以使用lambda表达式完成任务。但是如果遇到std::map这种容器类型就不好办了，因为std::map的比较函数对象是通过模板参数确定的，这个时候我们需要的是一个类型：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto greater = [](auto x, auto y) { return x &gt; y; };
std::map&lt;std::string, int, decltype(greater)&gt; mymap;</code></pre>

  <p class="zw">这段代码的意图很明显，它首先定义了一个无状态的lambda表达式greate，然后使用decltype(greater)获取其类型作为模板实参传入模板。这个想法非常好，但是在C++17标准中是不可行的，因为lambda表达式类型无法构造。编译器会明确告知，lambda表达式的默认构造函数已经被删除了（“note:a lambda closure type has a deleted default constructor”）。</p>

  <p class="zw">除了无法构造，无状态的lambda表达式也没办法赋值，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto greater = [](auto x, auto y) { return x &gt; y; };
std::map&lt;std::string, int, decltype(greater)&gt; mymap1, mymap2;
mymap1 = mymap2;</code></pre>

  <p class="zw">这里mymap1 = mymap2;也会被编译器报错，原因是复制赋值函数也被删除了（“note: a lambda closure type has a deleted copy assignment operator”）。</p>

  <p class="zw">为了解决以上问题，C++20标准允许了无状态lambda表达式类型的构造和赋值，所以使用C++20标准的编译环境来编译上面的代码是可行的。</p>

  <h2 id="OEBPS/Text/chapter007.html.nav_point_76" class="sigil_not_in_toc">7.12　总结</h2>

  <p class="zw">在本章我们介绍了lambda表达式的语法、使用方法以及原理。总的来说lambda表达式不但容易使用，而且原理也容易理解。它很好地解决了过去C++中无法直接编写内嵌函数的尴尬。虽然在GCC中提供了一个叫作nest function的C语言扩展，这个扩展允许我们在函数内部编写内嵌函数，但这个特性一直没有被纳入标准当中。当然我们也并不用为此遗憾，因为现在提供的lambda表达式无论在语法简易程度上，还是用途广泛程度上都要优于nest function。合理地使用lambda表达式，可以让代码更加短小精悍的同时也具有良好的可读性。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter007.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter008.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter008.html.nav_point_77" class="not-in-toc">第8章　非静态数据成员默认初始化（C++11 C++20）</h1>

  <h2 id="OEBPS/Text/chapter008.html.nav_point_78" class="sigil_not_in_toc">8.1　使用默认初始化</h2>

  <p class="zw">在C++11以前，对非静态数据成员初始化需要用到初始化列表，当类的数据成员和构造函数较多时，编写构造函数会是一个令人头痛的问题：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class X {
public:
  X() : a_(0), b_(0.), c_("hello world") {}
  X(int a) : a_(a), b_(0.), c_("hello world") {}
  X(double b) : a_(0), b_(b), c_("hello world") {}
  X(const std::string &amp;c) : a_(0), b_(0.), c_(c) {}

private:
  int a_;
  double b_;
  std::string c_;
};</code></pre>

  <p class="zw">在上面的代码中，类<code class="calibre10">X</code>有4个构造函数，为了在构造的时候初始化非静态数据成员，它们的初始化列表有一些冗余代码，而造成的后果是维护困难且容易出错。为了解决这种问题，C++11标准提出了新的初始化方法，即在声明非静态数据成员的同时直接对其使用=或者<code class="calibre10">{}</code>（见第9章）初始化。在此之前只有类型为整型或者枚举类型的常量静态数据成员才有这种声明默认初始化的待遇：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class X {
public:
  X() {}
  X(int a) : a_(a) {}
  X(double b) : b_(b) {}
  X(const std::string &amp;c) : c_(c) {}

private:
  int a_ = 0;
  double b_{ 0. };
  std::string c_{ "hello world" };
};</code></pre>

  <p class="zw">以上代码使用了非静态数据成员默认初始化的方法，可以看到这种初始化的方式更加清晰合理，每个构造函数只需要专注于特殊成员的初始化，而其他的数据成员则默认使用声明时初始化的值。比如<code class="calibre10">X(const std::string c)</code>这个构造函数，它只需要关心数据成员<code class="calibre10">c_</code>的初始化而不必初始化<code class="calibre10">a_</code>和<code class="calibre10">b_</code>。在初始化的优先级上有这样的规则，初始化列表对数据成员的初始化总是优先于声明时默认初始化。</p>

  <p class="zw">最后来看一看非静态数据成员在声明时默认初始化需要注意的两个问题。</p>

  <p class="zw">1．不要使用括号<code class="calibre10">()</code>对非静态数据成员进行初始化，因为这样会造成解析问题，所以会编译错误。</p>

  <p class="zw">2．不要用<code class="calibre10">auto</code>来声明和初始化非静态数据成员，虽然这一点看起来合理，但是C++并不允许这么做。</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct X {
  int a(5);     // 编译错误，不能使用()进行默认初始化
  auto b = 8;   // 编译错误，不能使用auto声明和初始化非静态数据成员
};</code></pre>

  <h2 id="OEBPS/Text/chapter008.html.nav_point_79" class="sigil_not_in_toc">8.2　位域的默认初始化</h2>

  <p class="zw">在C++11标准提出非静态数据成员默认初始化方法之后，C++20标准又对该特性做了进一步扩充。在C++20中我们可以对数据成员的位域进行默认初始化了，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct  S {
  int y : 8 = 11;
  int z : 4 {7};
};</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">int</code>数据的低8位被初始化为11，紧跟它的高4位被初始化为7。</p>

  <p class="zw">位域的默认初始化语法很简单，但是也有一个需要注意的地方。当表示位域的常量表达式是一个条件表达式时我们就需要警惕了，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int a;
struct S2 {
    int y : true ? 8 : a = 42;
    int z : 1 || new int { 0 };
};</code></pre>

  <p class="zw">请注意，这段代码中并不存在默认初始化，因为最大化识别标识符的解析规则让<code class="calibre10">=42</code>和<code class="calibre10">{0}</code>不可能存在于解析的顶层。于是以上代码会被认为是：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int a;
struct S2 {
    int y : (true ? 8 : a = 42);
    int z : (1 || new int { 0 });
};</code></pre>

  <p class="zw">所以我们可以通过使用括号明确代码被解析的优先级来解决这个问题：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int a;
struct S2 {
  int y : (true ? 8 : a) = 42;
  int z : (1 || new int){ 0 };
};</code></pre>

  <p class="zw">通过以上方法就可以对<code class="calibre10">S2::y</code>和<code class="calibre10">S2::z</code>进行默认初始化了。</p>

  <h2 id="OEBPS/Text/chapter008.html.nav_point_80" class="sigil_not_in_toc">8.3　总结</h2>

  <p class="zw">非静态数据成员默认初始化在一定程度上解决了初始化列表代码冗余的问题，尤其在类中数据成员的数量较多或类重载的构造函数数量较多时，使用非静态数据成员默认初始化的优势尤其明显。另外，从代码的可读性来说，这种初始化方法更加简单直接。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter008.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter009.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter009.html.nav_point_81" class="not-in-toc">第9章　列表初始化（C++11 C++20）</h1>

  <h2 id="OEBPS/Text/chapter009.html.nav_point_82" class="sigil_not_in_toc">9.1　回顾变量初始化</h2>

  <p class="zw">在介绍列表初始化之前，让我们先回顾一下初始化变量的传统方法。其中常见的是使用括号和等号在变量声明时对其初始化，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct C {
  C(int a) {}
};

int main()
{
  int x = 5;
  int x1(8);
  C x2 = 4;
  C x3(4);
}</code></pre>

  <p class="zw">一般来说，我们称使用括号初始化的方式叫作直接初始化，而使用等号初始化的方式叫作拷贝初始化（复制初始化）。请注意，这里使用等号对变量初始化并不是调用等号运算符的赋值操作。实际情况是，等号是拷贝初始化，调用的依然是直接初始化对应的构造函数，只不过这里是隐式调用而已。如果我们将<code class="calibre10">C(int a)</code>声明为<code class="calibre10">explicit</code>，那么<code class="calibre10">C x2 = 4</code>就会编译失败。</p>

  <p class="zw">使用括号和等号只是直接初始化和拷贝初始化的代表，还有一些经常用到的初始化方式也属于它们。比如<code class="calibre10">new</code>运算符和类构造函数的初始化列表就属于直接初始化，而函数传参和<code class="calibre10">return</code>返回则是拷贝初始化。前者比较好理解，后者可以通过具体的例子来理解：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;map&gt;
struct C {
  C(int a) {}
};

void foo(C c) {}
C bar()
{
  return 5;
}

int main()
{
  foo(8);        // 拷贝初始化
  C c = bar();   // 拷贝初始化
}</code></pre>

  <p class="zw">这段代码中<code class="calibre10">foo</code>函数的传参和<code class="calibre10">bar</code>函数的返回都调用了隐式构造函数，是一个拷贝初始化。</p>

  <h2 id="OEBPS/Text/chapter009.html.nav_point_83" class="sigil_not_in_toc">9.2　使用列表初始化</h2>

  <p class="zw">C++11标准引入了列表初始化，它使用大括号{}对变量进行初始化，和传统变量初始化的规则一样，它也区分为直接初始化和拷贝初始化，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;string&gt;

struct C {
  C(std::string a, int b) {}
  C(int a) {}
};

void foo(C) {}
C bar()
{
  return {"world", 5};
}

int main()
{
  int x = {5};         // 拷贝初始化
  int x1{8};           // 直接初始化
  C x2 = {4};          // 拷贝初始化
  C x3{2};             // 直接初始化
  foo({8});            // 拷贝初始化
  foo({"hello", 8});   // 拷贝初始化
  C x4 = bar();        // 拷贝初始化
  C *x5 = new C{ "hi", 42 };  // 直接初始化
}</code></pre>

  <p class="zw">仔细观察以上代码会发现，列表初始化和传统的变量初始化几乎相同，除了<code class="calibre10">foo({"hello", 8})</code>和<code class="calibre10">return {"world", 5}</code>这两处不同。读者应该发现了列表初始化在这里的奥妙所在，它支持隐式调用多参数的构造函数，于是<code class="calibre10">{"hello", 8}</code>和<code class="calibre10">{"world", 5}</code>通过隐式调用构造函数<code class="calibre10">C::C(std::string a, int b)</code>成功构造了类C的对象。当然了，有时候我们并不希望编译器进行隐式构造，这时候只需要在特定构造函数上声明<code class="calibre10">explicit</code>即可。</p>

  <p class="zw">讨论使用大括号初始化变量就不得不提用大括号初始化数组，例如<code class="calibre10">int x[] = { 1,2,3,4,5 }</code>。不过遗憾的是，这个特性无法使用到STL的<code class="calibre10">vector</code>、<code class="calibre10">list</code>等容器中。想要初始化容器，我们不得不编写一个循环来完成初始化工作。现在，列表初始化将程序员从这个问题中解放了出来，我们可以使用列表初始化对标准容器进行初始化了，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;string&gt;

int main()
{
  int x[] = { 1,2,3,4,5 };
  int x1[]{ 1,2,3,4,5 };
  std::vector&lt;int&gt; x2{ 1,2,3,4,5 };
  std::vector&lt;int&gt; x3 = { 1,2,3,4,5 };
  std::list&lt;int&gt; x4{ 1,2,3,4,5 };
  std::list&lt;int&gt; x5 = { 1,2,3,4,5 };
  std::set&lt;int&gt; x6{ 1,2,3,4,5 };
  std::set&lt;int&gt; x7 = { 1,2,3,4,5 };
  std::map&lt;std::string, int&gt; x8{ {"bear",4}, {"cassowary",2}, {"tiger",7} };
  std::map&lt;std::string, int&gt; x9 = { {"bear",4}, {"cassowary",2}, {"tiger",7} };
}</code></pre>

  <p class="zw">以上代码在C++11环境下可以成功编译，可以看到使用列表初始化标准容器和初始化数组一样简单，唯一值得注意的地方是对<code class="calibre10">x8</code>和<code class="calibre10">x9</code>的初始化，因为它使用了列表初始化的一个特殊的特性。关于这个特性先卖一个关子，后面再做解释。让我们先将注意力放在如何能让容器支持列表初始化的问题上。</p>

  <h2 id="OEBPS/Text/chapter009.html.nav_point_84" class="sigil_not_in_toc">9.3　std::initializer_list详解</h2>

  <p class="zw">标准容器之所以能够支持列表初始化，离不开编译器支持的同时，它们自己也必须满足一个条件：支持<code class="calibre10">std::initializer_list</code>为形参的构造函数。<code class="calibre10">std::initializer_list</code>简单地说就是一个支持<code class="calibre10">begin</code>、<code class="calibre10">end</code>以及<code class="calibre10">size</code>成员函数的类模板，有兴趣的读者可以翻阅STL的源代码，然后会发现无论是它的结构还是函数都直截了当。编译器负责将列表里的元素（大括号包含的内容）构造为一个<code class="calibre10">std::initializer_list</code>的对象，然后寻找标准容器中支持<code class="calibre10">std:: initializer_list</code>为形参的构造函数并调用它。而标准容器的构造函数的处理就更加简单了，它们只需要调用<code class="calibre10">std::initializer_list</code>对象的<code class="calibre10">begin</code>和<code class="calibre10">end</code>函数，在循环中对本对象进行初始化。</p>

  <p class="zw">通过了解原理能够发现，支持列表初始化并不是标准容器的专利，我们也能写出一个支持列表初始化的类，需要做的只是添加一个以<code class="calibre10">std::initializer_list</code>为形参的构造函数罢了，比如下面的例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;

struct C {
  C(std::initializer_list&lt;std::string&gt; a)
  {
       for (const std::string* item = a.begin(); item != a.end(); ++item) {
            std::cout &lt;&lt; *item &lt;&lt; " ";
       }
       std::cout &lt;&lt; std::endl;
  }
};

int main()
{
  C c{ "hello", "c++", "world" };
}</code></pre>

  <p class="zw">上面这段代码实现了一个支持列表初始化的类 C，类 C 的构造函数为<code class="calibre10">C(std:: initializer_list&lt;std::string&gt; a)</code>，这是支持列表初始化所必需的，值得注意的是，<code class="calibre10">std:: initializer_list</code>的<code class="calibre10">begin</code>和<code class="calibre10">end</code>函数并不是返回的迭代器对象，而是一个常量对象指针<code class="calibre10">const T *</code>。本着刨根问底的精神，让我们进一步探究编译器对列表的初始化处理：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;
struct C {
  C(std::initializer_list&lt;std::string&gt; a)
  {
       for (const std::string* item = a.begin(); item != a.end(); ++item) {
            std::cout &lt;&lt; item &lt;&lt; " ";
       }
       std::cout &lt;&lt; std::endl;
  }

};

int main()
{
  C c{ "hello", "c++", "world" };
  std::cout &lt;&lt; "sizeof(std::string) = " &lt;&lt;
       std::hex &lt;&lt; sizeof(std::string) &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">运行输出结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">0x77fdd0 0x77fdf0 0x77fe10
sizeof(std::string) = 20</code></pre>

  <p class="zw">以上代码输出了<code class="calibre10">std::string</code>对象的内存地址以及单个对象的大小（不同编译环境的<code class="calibre10">std::string</code>实现方式会有所区别，其对象大小也会不同，这里的例子是使用GCC编译的，<code class="calibre10">std::string</code>对象的大小为0x20）。仔细观察3个内存地址会发现，它们的差别正好是<code class="calibre10">std::string</code>所占的内存大小。于是我们能推断出，编译器所进行的工作大概是这样的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">const std::string __a[3] = 
  {std::string{"hello"}, std::string{"c++"}, std::string{"world"}};
C c(std::initializer_list&lt;std::string&gt;(__a, __a+3));</code></pre>

  <p class="zw">另外，有兴趣的读者不妨用GCC对上面这段代码生成中间代码GIMPLE，不出意外会发现类似这样的中间代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">main ()
{
  struct initializer_list D.40094;
  const struct basic_string D.36430[3];
  …
  std::__cxx11::basic_string&lt;char&gt;::basic_string (&amp;D.36430[0], "hello", &amp;D.36424);
  …
  std::__cxx11::basic_string&lt;char&gt;::basic_string (&amp;D.36430[1], "c++", &amp;D.36426);
  …
  std::__cxx11::basic_string&lt;char&gt;::basic_string (&amp;D.36430[2], "world", &amp;D.36428);
  …
  D.40094._M_array = &amp;D.36430;
  D.40094._M_len = 3;
  C::C (&amp;c, D.40094);
  …
}</code></pre>

  <h2 id="OEBPS/Text/chapter009.html.nav_point_85" class="sigil_not_in_toc">9.4　使用列表初始化的注意事项</h2>

  <p class="zw">使用列表初始化是如此的方便，让人不禁想马上运用到自己的代码中去。但是请别着急，这里还有两个地方需要读者注意。</p>

  <h3 id="OEBPS/Text/chapter009.html.nav_point_86" class="sigil_not_in_toc1">9.4.1　隐式缩窄转换问题</h3>

  <p class="zw">隐式缩窄转换是在编写代码中稍不留意就会出现的，而且它的出现并不一定会引发错误，甚至有可能连警告都没有，所以有时候容易被人们忽略，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int x = 12345;
char y = x;</code></pre>

  <p class="zw">这段代码中变量<code class="calibre10">y</code>的初始化明显是一个隐式缩窄转换，这在传统变量初始化中是没有问题的，代码能顺利通过编译。但是如果采用列表初始化，比如<code class="calibre10">char z{ x }</code>，根据标准编译器通常会给出一个错误，MSVC和CLang就是这么做的，而GCC有些不同，它只是给出了警告。</p>

  <p class="zw">现在问题来了，在C++中哪些属于隐式缩窄转换呢？在C++标准里列出了这么4条规则。</p>

  <p class="zw">1．从浮点类型转换整数类型。</p>

  <p class="zw">2．从<code class="calibre10">long double</code>转换到<code class="calibre10">double</code>或<code class="calibre10">float</code>，或从<code class="calibre10">double</code>转换到<code class="calibre10">float</code>，除非转换源是常量表达式以及转换后的实际值在目标可以表示的值范围内。</p>

  <p class="zw">3．从整数类型或非强枚举类型转换到浮点类型，除非转换源是常量表达式，转换后的实际值适合目标类型并且能够将生成目标类型的目标值转换回原始类型的原始值。</p>

  <p class="zw">4．从整数类型或非强枚举类型转换到不能代表所有原始类型值的整数类型，除非源是一个常量表达式，其值在转换之后能够适合目标类型。</p>

  <p class="zw">4条规则虽然描述得比较复杂，但是要表达的意思还是很简单的，结合标准的例子就很容易理解了：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int x = 999;
const int y = 999;
const int z = 99;
const double cdb = 99.9;
double db = 99.9;
char c1 = x;  // 编译成功，传统变量初始化支持隐式缩窄转换
char c2{ x }; // 编译失败，可能是隐式缩窄转换，对应规则4
char c3{ y }; // 编译失败，确定是隐式缩窄转换，999超出char能够适应的范围，对应规则4
char c4{ z }; // 编译成功，99在char能够适应的范围内，对应规则4
unsigned char uc1 = { 5 };  // 编译成功，5在unsigned char能够适应的范围内，
                            // 对应规则4
unsigned char uc2 = { -1 }; // 编译失败，unsigned char不能够适应负数，对应规则4
unsigned int ui1 = { -1 };  //编译失败，unsigned int不能够适应负数，对应规则4
signed int si1 = { (unsigned int)-1 }; //编译失败，signed int不能够适应-1所对应的
                                   //unsigned int，通常是4294967295，对应规则4
int ii = { 2.0 };  // 编译失败，int不能适应浮点范围，对应规则1
float f1{ x };     // 编译失败，float可能无法适应整数或者互相转换，对应规则3
float f2{ 7 };     // 编译成功，7能够适应float，且float也能转换回整数7，对应规则3
float f3{ cdb };   // 编译成功，99.9能适应float，对应规则2
float f4{ db };    // 编译失败，可能是隐式缩窄转无法表达double，对应规则2</code></pre>

  <h3 id="OEBPS/Text/chapter009.html.nav_point_87" class="sigil_not_in_toc1">9.4.2　列表初始化的优先级问题</h3>

  <p class="zw">通过9.2节和9.3节的介绍我们知道，列表初始化既可以支持普通的构造函数，也能够支持以<code class="calibre10">std::initializer_list</code>为形参的构造函数。如果这两种构造函数同时出现在同一个类里，那么编译器会如何选择构造函数呢？比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::vector&lt;int&gt; x1(5, 5);
std::vector&lt;int&gt; x2{ 5, 5 };</code></pre>

  <p class="zw">以上两种方法都可以对<code class="calibre10">std::vector&lt;int&gt;</code>进行初始化，但是初始化的结果却是不同的。变量<code class="calibre10">x1</code>的初始化结果是包含5个元素，且5个元素的值都为5，调用了<code class="calibre10">vector(size_type count, const T&amp; value, const Allocator&amp; alloc = Allocator())</code>这个构造函数。而变量<code class="calibre10">x2</code>的初始化结果是包含两个元素，且两个元素的值为5，也就是调用了构造函数<code class="calibre10">vector( std::initializer_list&lt;T&gt; init, const Allocator&amp; alloc = Allocator() )</code>。所以，上述问题的结论是，如果有一个类同时拥有满足列表初始化的构造函数，且其中一个是以<code class="calibre10">std::initializer_list</code>为参数，那么编译器将优先以<code class="calibre10">std::initializer_ list</code>为参数构造函数。由于这个特性的存在，我们在编写或阅读代码的时候就一定需要注意初始化代码的意图是什么，应该选择哪种方法对变量初始化。</p>

  <p class="zw">最后让我们回头看一看9.2节中没有解答的一个问题，<code class="calibre10">std::map&lt;std:: string, int&gt; x8{ {"bear",4}, {"cassowary",2}, {"tiger",7} }</code>中两个层级的列表初始化分别使用了什么构造函数。其实答案已经非常明显了，内层<code class="calibre10">{"bear",4}</code>、<code class="calibre10">{"cassowary",2}</code>和<code class="calibre10">{"tiger",7}</code>都隐式调用了<code class="calibre10">std::pair</code>的构造函数<code class="calibre10">pair(const T1&amp; x, const T2&amp; y)</code>，而外层的<code class="calibre10">{</code>…<code class="calibre10">}</code>隐式调用的则是<code class="calibre10">std::map</code>的构造函数<code class="calibre10">map(std::initializer_list&lt;value_ type&gt;init, const Allocator&amp;)</code>。</p>

  <h2 id="OEBPS/Text/chapter009.html.nav_point_88" class="sigil_not_in_toc">9.5　指定初始化</h2>

  <p class="zw">为了提高数据成员初始化的可读性和灵活性，C++20标准中引入了指定初始化的特性。该特性允许指定初始化数据成员的名称，从而使代码意图更加明确。让我们看一看示例：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct Point {
  int x;
  int y;
};

Point p{ .x = 4, .y = 2 };</code></pre>

  <p class="zw">虽然在这段代码中<code class="calibre10">Point</code>的初始化并不如<code class="calibre10">Point p{ 4, 2 };</code>方便，但是这个例子却很好地展现了指定初始化语法。实际上，当初始化的结构体的数据成员比较多且真正需要赋值的只有少数成员的时候，这样的指定初始化就非常好用了：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct Point3D {
  int x;
  int y;
  int z;
};

Point3D p{ .z = 3 };    // x = 0, y = 0</code></pre>

  <p class="zw">在上面的代码中<code class="calibre10">Point3D</code>需要3个坐标，不过我们只需要设置<code class="calibre10">z</code>的值，指定<br class="calibre19">
  <code class="calibre10">.z = 3</code>即可。其中<code class="calibre10">x</code>和<code class="calibre10">y</code>坐标会调用默认初始化将其值设置为<code class="calibre10">0</code>。可能这个例子还是不能完全体现出它相对于<code class="calibre10">Point3D p{ 0, 0, 3 };</code>的优势所在，不过读者应该能感觉到，一旦结构体更加复杂，指定初始化就一定能带来不少方便之处。</p>

  <p class="zw">最后需要注意的是，并不是什么对象都能够指定初始化的。</p>

  <p class="zw">1．它要求对象必须是一个聚合类型，例如下面的结构体就无法使用指定初始化：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct Point3D {
  Point3D() {}
  int x;
  int y;
  int z;
};

Point3D p{ .z = 3 };    // 编译失败，Point3D不是一个聚合类型</code></pre>

  <p class="zw">这里读者可能会有疑问，如果不能提供构造函数，那么我们希望数据成员<code class="calibre10">x</code>和<code class="calibre10">y</code>的默认值不为<code class="calibre10">0</code>的时候应该怎么做？不要忘了，从C++11开始我们有了非静态成员变量直接初始化的方法，比如当希望<code class="calibre10">Point3D</code>的默认坐标值都是<code class="calibre10">100</code>时，代码可以修改为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct Point3D {
  int x = 100;
  int y = 100;
    int z = 100;
};

Point3D p{ .z = 3 };    // x = 100, y = 100, z = 3</code></pre>

  <p class="zw">2．指定的数据成员必须是非静态数据成员。这一点很好理解，静态数据成员不属于某个对象。</p>

  <p class="zw">3．每个非静态数据成员最多只能初始化一次：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">Point p{ .y = 4, .y = 2 };  // 编译失败，y不能初始化多次</code></pre>

  <p class="zw">4．非静态数据成员的初始化必须按照声明的顺序进行。请注意，这一点和C语言中指定初始化的要求不同，在C语言中，乱序的指定初始化是合法的，但C++不行。其实这一点也很好理解，因为C++中的数据成员会按照声明的顺序构造，按照顺序指定初始化会让代码更容易阅读：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">Point p{ .y = 4, .x = 2 };  // C++编译失败，C编译没问题</code></pre>

  <p class="zw">5．针对联合体中的数据成员只能初始化一次，不能同时指定：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">union u {
  int a; 
  const char* b; 
};

u f = { .a = 1 };        // 编译成功
u g = { .b = "asdf" };   // 编译成功
u h = { .a = 1, .b = "asdf" };    // 编译失败，同时指定初始化联合体中的多个数据成员</code></pre>

  <p class="zw">6．不能嵌套指定初始化数据成员。虽然这一点在C语言中也是允许的，但是C++标准认为这个特性很少有用，所以直接禁止了：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct Line {
  Point a;
  Point b;
};

Line l{ .a.y = 5 }; // 编译失败, .a.y = 5访问了嵌套成员，不符合C++标准</code></pre>

  <p class="zw">当然，如果确实想嵌套指定初始化，我们可以换一种形式来达到目的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">Line l{ .a {.y = 5} };</code></pre>

  <p class="zw">7．在C++20中，一旦使用指定初始化，就不能混用其他方法对数据成员初始化了，而这一点在C语言中是允许的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">Point p{ .x = 2, 3 };    // 编译失败，混用数据成员的初始化</code></pre>

  <p class="zw">8．最后再来了解一下指定初始化在C语言中处理数组的能力，当然在C++中这同样是被禁止的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int arr[3] = { [1] = 5 };    // 编译失败</code></pre>

  <p class="zw">C++标准中给出的禁止理由非常简单，它的语法和<code class="calibre10">lambda</code>表达式冲突了。</p>

  <h2 id="OEBPS/Text/chapter009.html.nav_point_89" class="sigil_not_in_toc">9.6　总结</h2>

  <p class="zw">列表初始化是我非常喜欢的一个特性，因为它解决了以往标准容器初始化十分不方便的问题，使用列表初始化可以让容器如同数组一般被初始化。除此以外，实现以<code class="calibre10">std::initializer_list</code>为形参的构造函数也非常容易，这使自定义容器支持列表初始化也变得十分简单。C++20引入的指定初始化在一定程度上简化了复杂聚合类型初始化工作，让初始化复杂聚合类型的代码变得简洁清晰。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter009.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter010.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter010.html.nav_point_90" class="not-in-toc">第10章　默认和删除函数（C++11）</h1>

  <h2 id="OEBPS/Text/chapter010.html.nav_point_91" class="sigil_not_in_toc">10.1　类的特殊成员函数</h2>

  <p class="zw">在定义一个类的时候，我们可能会省略类的构造函数，因为C++标准规定，在没有自定义构造函数的情况下，编译器会为类添加默认的构造函数。像这样有特殊待遇的成员函数一共有6个（C++11以前是4个），具体如下。</p>

  <p class="zw">1．默认构造函数。</p>

  <p class="zw">2．析构函数。</p>

  <p class="zw">3．复制构造函数。</p>

  <p class="zw">4．复制赋值运算符函数。</p>

  <p class="zw">5．移动构造函数（C++11新增）。</p>

  <p class="zw">6．移动赋值运算符函数（C++11新增）。</p>

  <p class="zw">添加默认特殊成员函数的这条特性非常实用，它让程序员可以有更多精力关注类本身的功能而不必为了某些语法特性而分心，同时也避免了让程序员编写重复的代码，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;string&gt;
#include &lt;vector&gt;
class City {
  std::string name;
  std::vector&lt;std::string&gt; street_name;
};

int main()
{
  City a, b;
  a = b;
}</code></pre>

  <p class="zw">在上面的代码中，我们虽然没有为<code class="calibre10">City</code>类添加复制赋值运算符函数<code class="calibre10">City:: operator= (const City &amp;)</code>，但是编译器仍然可以成功编译代码，并且在运行过程中正确地调用<code class="calibre10">std::string</code>和<code class="calibre10">std::vector&lt;std::string&gt;</code>的复制赋值运算符函数。假如编译器没有提供这条特性，我们就不得不在编写类的时候添加以下代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">City&amp; City::operator=(const City &amp; other)
{
  name = other.name;
  street_name = other.street_name;
  return *this;
}</code></pre>

  <p class="zw">很明显，编写这段代码除了满足语法的需求以外没有其他意义，很庆幸可以把这件事情交给编译器去处理。不过还不能高兴得太早，因为该特性的存在也给我们带来了一些麻烦。</p>

  <p class="zw">1．声明任何构造函数都会抑制默认构造函数的添加。</p>

  <p class="zw">2．一旦用自定义构造函数代替默认构造函数，类就将转变为非平凡类型。</p>

  <p class="zw">3．没有明确的办法彻底禁止特殊成员函数的生成（C++11之前）。</p>

  <p class="zw">下面来详细地解析这些问题，还是以<code class="calibre10">City</code>类为例，我们给它添加一个构造函数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;string&gt;
#include &lt;vector&gt;
class City {
  std::string name;
  std::vector&lt;std::string&gt; street_name;
public:
  City(const char *n) : name(n) {}
};

int main()
{
  City a("wuhan");
  City b;  // 编译失败，自定义构造函数抑制了默认构造函数
  b = a;
}</code></pre>

  <p class="zw">以上代码由于添加了构造函数<code class="calibre10">City(const char *n)</code>，导致编译器不再为类提供默认构造函数，因此在声明对象<code class="calibre10">b</code>的时候出现编译错误，为了解决这个问题我们不得不添加一个无参数的构造函数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class City {
  std::string name;
  std::vector&lt;std::string&gt; street_name;
public:
  City(const char *n) : name(n) {}
  City() {}    // 新添加的构造函数
};</code></pre>

  <p class="zw">可以看到这段代码新添加的构造函数什么也没做，但却必须定义。乍看虽然做了一些多此一举的工作，但是毕竟也能让程序重新编译和运行，问题得到了解决。真的是这样吗？事实上，我们又不知不觉地陷入另一个麻烦中，请看下面的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class Trivial
{
  int i;
public:
  Trivial(int n) : i(n), j(n) {}
  Trivial() {}
  int j;
};

int main()
{
  Trivial a(5);
  Trivial b;
  b = a;
  std::cout &lt;&lt; "std::is_trivial_v&lt;Trivial&gt;   : " 
    &lt;&lt; std::is_trivial_v&lt;Trivial&gt; &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">上面的代码中有两个动作会将<code class="calibre10">Trivial</code>类的类型从一个平凡类型转变为非平凡类型。第一是定义了一个构造函数<code class="calibre10">Trivial(int n)</code>，它导致编译器抑制添加默认构造函数，于是<code class="calibre10">Trivial</code>类转变为非平凡类型。第二是定义了一个无参数的构造函数，同样可以让<code class="calibre10">Trivial</code>类转变为非平凡类型。</p>

  <p class="zw">最后一个问题大家肯定也都遇到过，举例来说，有时候我们需要编写一个禁止复制操作的类，但是过去C++标准并没有提供这样的能力。聪明的程序员通过将复制构造函数和复制赋值运算符函数声明为<code class="calibre10">private</code>并且不提供函数实现的方式，间接地达成目的。为了使用方便，<code class="calibre10">boost</code>库也提供了<code class="calibre10">noncopyable</code>类辅助我们完成禁止复制的需求。</p>

  <p class="zw">不过就如前面的问题一样，虽然能间接地完成禁止复制的需求，但是这样的实现方法并不完美。比如，友元就能够在编译阶段破坏类对复制的禁止。这里可能会有读者反驳，虽然友元能够访问私有的复制构造函数，但是别忘了，我们并没有实现这个函数，也就是说程序最后仍然无法运行。没错，程序最后会在链接阶段报错，原因是找不到复制构造函数的实现。但是这个报错显然来得有些晚，试想一下，如果面临的是一个巨大的项目，有不计其数的源文件需要编译，那么编译过程将非常耗时。如果某个错误需要等到编译结束以后的链接阶段才能确定，那么修改错误的时间代价将会非常高，所以我们还是更希望能在编译阶段就找到错误。</p>

  <p class="zw">还有一个典型的例子，禁止重载函数的某些版本，考虑下面的例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class Base {
  void foo(long &amp;);
public:
  void foo(int) {}
};

int main()
{
  Base b;
  long l = 5;
  b.foo(8);
  b.foo(l);       // 编译错误
}</code></pre>

  <p class="zw">由于将成员函数<code class="calibre10">foo(long &amp;)</code>声明为私有访问并且没有提供代码实现，因此在调用<code class="calibre10">b.foo(l)</code>的时候会编译出错。这样看来它跟我们之前讨论的例子没有什么实际区别，再进一步讨论，假设现在我们需要继承<code class="calibre10">Base</code>类，并且实现子类的<code class="calibre10">foo</code>函数；另外，还想沿用基类<code class="calibre10">Base</code>的<code class="calibre10">foo</code>函数，于是这里使用<code class="calibre10">using</code>说明符将<code class="calibre10">Base</code>的<code class="calibre10">foo</code>成员函数引入子类，代码如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class Base {
  void foo(long &amp;);
public:
  void foo(int) {}
};

class Derived : public Base {
public:
  using Base::foo;
  void foo(const char *) {}
};

int main()
{
  Derived d;
  d.foo("hello");
  d.foo(5);
}</code></pre>

  <p class="zw">上面这段代码看上去合情合理，而实际上却无法通过编译。因为<code class="calibre10">using</code>说明符无法将基类的私有成员函数引入子类当中，即使这里我们将代码<code class="calibre10">d.foo(5)</code>删除，即不再调用基类的函数，编译器也是不会让这段代码编译成功的。</p>

  <h2 id="OEBPS/Text/chapter010.html.nav_point_92" class="sigil_not_in_toc">10.2　显式默认和显式删除</h2>

  <p class="zw">为了解决以上种种问题，C++11标准提供了一种方法能够简单有效又精确地控制默认特殊成员函数的添加和删除，我们将这种方法叫作显式默认和显式删除。显式默认和显式删除的语法非常简单，只需要在声明函数的尾部添加<code class="calibre10">=default</code>和<code class="calibre10">=delete</code>，它们分别指示编译器添加特殊函数的默认版本以及删除指定的函数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct type
{
  type() = default;
  virtual ~type() = delete;
  type(const type &amp;);
};
type::type(const type &amp;) = default;</code></pre>

  <p class="zw">以上代码显式地添加了默认构造和复制构造函数，同时也删除了析构函数。请注意，<code class="calibre10">=default</code>可以添加到类内部函数声明，也可以添加到类外部。这里默认构造函数的<code class="calibre10">=default</code>就是添加在类内部，而复制构造函数的<code class="calibre10">=default</code>则是添加在类外部。提供这种能力的意义在于，它可以让我们在不修改头文件里函数声明的情况下，改变函数内部的行为，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">// type.h
struct type {
  type();
  int x;
};

// type1.cpp
type::type() = default;

// type2.cpp
type::type() { x = 3; }</code></pre>

  <p class="zw"><code class="calibre10">=delete</code>与<code class="calibre10">=default</code>不同，它必须添加在类内部的函数声明中，如果将其添加到类外部，那么会引发编译错误。</p>

  <p class="zw">通过使用<code class="calibre10">=default</code>，我们可以很容易地解决之前提到的前两个问题，请观察以下代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class NonTrivial
{
  int i;
public:
  NonTrivial(int n) : i(n), j(n) {}
  NonTrivial() {}
  int j;
};

class Trivial
{
  int i;
public:
  Trivial(int n) : i(n), j(n) {}
  Trivial() = default;
  int j;
};

int main()
{
  Trivial a(5);
  Trivial b;
  b = a;
  std::cout &lt;&lt; "std::is_trivial_v&lt;Trivial&gt;   : " &lt;&lt; std::is_trivial_v&lt;Trivial&gt; &lt;&lt; std::endl;
  std::cout &lt;&lt; "std::is_trivial_v&lt;NonTrivial&gt; : " &lt;&lt; std::is_trivial_v&lt;NonTrivial&gt; &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">注意，我们只是将构造函数<code class="calibre10">NonTrivial() {}</code>替换为显式默认构造函数<code class="calibre10">Trivial() = default</code>，类就从非平凡类型恢复到平凡类型了。这样一来，既让编译器为类提供了默认构造函数，又保持了类本身的性质，可以说完美解决了之前的问题。</p>

  <p class="zw">另外，针对禁止调用某些函数的问题，我们可以使用<code class="calibre10">= delete</code>来删除特定函数，相对于使用<code class="calibre10">private</code>限制函数访问，使用<code class="calibre10">= delete</code>更加彻底，它从编译层面上抑制了函数的生成，所以无论调用者是什么身份（包括类的成员函数），都无法调用被删除的函数。进一步来说，由于必须在函数声明中使用<code class="calibre10">= delete</code>来删除函数，因此编译器可以在第一时间发现有代码错误地调用被删除的函数并且显示错误报告，这种快速报告错误的能力也是我们需要的，来看下面的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class NonCopyable
{
public:
  NonCopyable() = default;                       // 显式添加默认构造函数
  NonCopyable(const NonCopyable&amp;) = delete;      // 显式删除复制构造函数
  NonCopyable&amp; operator=(const NonCopyable&amp;) = delete;  // 显式删除复制赋值
                                                        // 运算符函数
};

int main()
{
  NonCopyable a, b;
  a = b;              //编译失败，复制赋值运算符已被删除
}</code></pre>

  <p class="zw">以上代码删除了类<code class="calibre10">NonCopyable</code>的复制构造函数和复制赋值运算符函数，这样就禁止了该类对象相互之间的复制操作。请注意，由于显式地删除了复制构造函数，导致默认情况下编译器也不再自动添加默认构造函数，因此我们必须显式地让编译器添加默认构造函数，否则会导致编译失败。</p>

  <p class="zw">最后，让我们用<code class="calibre10">= delete</code>来解决禁止重载函数的继承问题，这里只需要对基类<code class="calibre10">Base</code>稍作修改即可：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class Base {
//     void foo(long &amp;);
public:
  void foo(long &amp;) = delete;    // 删除foo(long &amp;)函数
  void foo(int) {}
};

class Derived : public Base {
public:
  using Base::foo;
  void foo(const char *) {}
};

int main()
{
  Derived d;
  d.foo("hello");
  d.foo(5);
}</code></pre>

  <p class="zw">请注意，上面对代码做了两处修改。第一是将<code class="calibre10">foo(long &amp;)</code>函数从<code class="calibre10">private</code>移动到<code class="calibre10">public</code>，第二是显式删除该函数。如果只是显式删除了函数，却没有将函数移动到<code class="calibre10">public</code>，那么编译还是会出错的。</p>

  <h2 id="OEBPS/Text/chapter010.html.nav_point_93" class="sigil_not_in_toc">10.3　显式删除的其他用法</h2>

  <p class="zw">显式删除不仅适用于类的成员函数，对于普通函数同样有效。只不过相对于应用于成员函数，应用于普通函数的意义就不大了：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void foo() = delete;
static void bar() = delete;
int main()
{
  bar();        // 编译失败，函数已经被显式删除
  foo();        // 编译失败，函数已经被显式删除
}</code></pre>

  <p class="zw">另外，显式删除还可以用于类的<code class="calibre10">new</code>运算符和类析构函数。显式删除特定类的<code class="calibre10">new</code>运算符可以阻止该类在堆上动态创建对象，换句话说它可以限制类的使用者只能通过自动变量、静态变量或者全局变量的方式创建对象，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct type 
{
  void * operator new(std::size_t) = delete;
};

type global_var;
int main()
{
  static type static_var;
  type auto_var;
  type *var_ptr = new type;    // 编译失败，该类的new已被删除
}</code></pre>

  <p class="zw">显式删除类的析构函数在某种程度上和删除<code class="calibre10">new</code>运算符的目的正好相反，它阻止类通过自动变量、静态变量或者全局变量的方式创建对象，但是却可以通过<code class="calibre10">new</code>运算符创建对象。原因是删除析构函数后，类无法进行析构。所以像自动变量、静态变量或者全局变量这种会隐式调用析构函数的对象就无法创建了，当然了，通过<code class="calibre10">new</code>运算符创建的对象也无法通过<code class="calibre10">delete</code>销毁，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct type 
{
  ~type() = delete;
};
type global_var;             // 编译失败，析构函数被删除无法隐式调用

int main()
{
  static type static_var;    // 编译失败，析构函数被删除无法隐式调用
  type auto_var;             // 编译失败，析构函数被删除无法隐式调用
  type *var_ptr = new type;
  delete var_ptr;            // 编译失败，析构函数被删除无法显式调用
}</code></pre>

  <p class="zw">通过上面的代码可以看出，只有<code class="calibre10">new</code>创建对象会成功，其他创建和销毁操作都会失败，所以这样的用法并不多见，大部分情况可能在单例模式中出现。</p>

  <h2 id="OEBPS/Text/chapter010.html.nav_point_94" class="sigil_not_in_toc">10.4　explicit和=delete</h2>

  <p class="zw">在类的构造函数上同时使用<code class="calibre10">explicit</code>和<code class="calibre10">=delete</code>是一个不明智的做法，它常常会造成代码行为混乱难以理解，应尽量避免这样做。下面这个例子就是反面教材：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct type
{
  type(long long) {}
  explicit type(long) = delete;
};
void foo(type) {}

int main()
{
  foo(type(58));
  foo(58);
}</code></pre>

  <p class="zw">读者可以在这里思考一下，上面哪句代码无法通过编译。答案是<code class="calibre10">foo(type(58))</code>会造成编译失败，原因是<code class="calibre10">type(58)</code>显式调用了构造函数，但是<code class="calibre10">explicit type(long)</code>却被删除了。<code class="calibre10">foo(58)</code>可以通过编译，因为编译器会选择<code class="calibre10">type(long long)</code>来构造对象。虽然原因解释得很清楚，但是建议还是不要这么使用，因为这样除了让人难以理解外，没有实际作用。</p>

  <h2 id="OEBPS/Text/chapter010.html.nav_point_95" class="sigil_not_in_toc">10.5　总结</h2>

  <p class="zw">C++在类特殊成员函数的生成上有一套比较复杂的规则，但是过去却没有一套方法帮助程序员去控制这套规则，作为一个相对底层的高级语言是令人失望的。好在C++11标准中引入了显式默认和显式删除的方法，这使我们可以精确地控制类特殊成员函数的生成以及删除，让过去必须通过一些技巧间接实现的功能得到更加完美的实现。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter010.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter011.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter011.html.nav_point_96" class="not-in-toc">第11章　非受限联合类型（C++11）</h1>

  <h2 id="OEBPS/Text/chapter011.html.nav_point_97" class="sigil_not_in_toc">11.1　联合类型在C++中的局限性</h2>

  <p class="zw">在编程的问题中，用尽量少的内存做尽可能多的事情一直都是一个重要的课题。C++中的联合类型（union）可以说是节约内存的一个典型代表。因为在联合类型中多个对象可以共享一片内存，相应的这片内存也只能由一个对象使用，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

union U
{
  int x1;
  float x2;
};

int main()
{
  U u;
  u.x1 = 5;
  std::cout &lt;&lt; u.x1 &lt;&lt; std::endl;
  std::cout &lt;&lt; u.x2 &lt;&lt; std::endl;

  u.x2 = 5.0;
  std::cout &lt;&lt; u.x1 &lt;&lt; std::endl;
  std::cout &lt;&lt; u.x2 &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">在上面的代码中联合类型<code class="calibre10">U</code>里的成员变量<code class="calibre10">x1</code>和<code class="calibre10">x2</code>共享同一片内存，所以修改<code class="calibre10">x1</code>的值，<code class="calibre10">x2</code>的值也会发生相应的变化，反之亦然。不过需要注意的是，虽然<code class="calibre10">x1</code>和<code class="calibre10">x2</code>共享同一片内存，但是由于CPU对不同类型内存的理解存在区别，因此即使内存相同也不能随意使用联合类型的成员变量，而是应该使用之前初始化过的变量。像这样多个对象共用一片内存的情况在内存紧缺时是非常实用的。不过令人遗憾的是，过去的联合类型在C++中的使用并不广泛，因为C++中的大多数对象不能成为联合类型的成员。过去的C++标准规定，联合类型的成员变量的类型不能是一个非平凡类型，也就是说它的成员类型不能有自定义构造函数，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">union U
{
  int x1;
  float x2;
  std::string x3;
};</code></pre>

  <p class="zw">上面的代码是无法通过编译的，因为<code class="calibre10">x3</code>存在自定义的构造函数，所以它是一个非平凡类型。但事实上，面向对象的编程中一个好的类应该隐藏内部的细节，这就要求构造函数足够强大并正确地初始化对象的内部数据结构，而编译器提供的构造函数往往不具备这样的能力，于是大多数情况下，我们会为自己的类添加一个好用的构造函数，但是这种良好的设计却造成了这个类型无法在联合类型中使用。基于这些问题，C++委员会在新的提案当中多次强调“我们没有任何理由限制联合类型使用的类型”。在这份提案中有一段话非常好地阐述了C++的设计理念，同时也批判了联合类型的限制对这种理念的背叛，这段话是这样说的：</p>

  <blockquote class="calibre20">
    <p class="zw"><span class="calibre21">当面对一个可能被滥用的功能时，语言的设计者往往有两条路可走，一是为了语言的安全性禁止此功能，另外则是为了语言的能力和灵活性允许这个功能，C++的设计者一般会采用后者。但是联合类型的设计却与这一理念背道而驰。这种限制完全没有必要，去除它可以让联合类型更加实用。</span></p>
  </blockquote>

  <p class="zw">回味这段话，C++的设计确实一直遵从这样的理念，我们熟悉的指针就是一个典型的代表！</p>

  <h2 id="OEBPS/Text/chapter011.html.nav_point_98" class="sigil_not_in_toc">11.2　使用非受限联合类型</h2>

  <p class="zw">为了让联合类型更加实用，在C++11标准中解除了大部分限制，联合类型的成员可以是除了引用类型外的所有类型。不过这样的修改引入了另外一个问题，如何精确初始化联合类型成员对象。这一点在过去的联合类型中不是一个问题，因为对于平凡类型，编译器只需要对成员对象都执行编译器提供的默认构造即可，虽然从同一内存多次初始化的角度来说这是不正确的，但是从结果上看没有任何问题。现在情况发生了变化，由于允许非平凡类型的存在，对所有成员一一进行默认构造明显是不可取的，因此我们需要有选择地初始化成员对象。实际上，让编译器去选择初始化本身也是不合适的，这个事情应该交给程序员来做。基于这些考虑，在C++11中如果有联合类型中存在非平凡类型，那么这个联合类型的特殊成员函数将被隐式删除，也就是说我们必须自己至少提供联合类型的构造和析构函数，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

union U
{
  U() {}        // 存在非平凡类型成员，必须提供构造函数
  ~U() {}       // 存在非平凡类型成员，必须提供析构函数
  int x1;
  float x2;
  std::string x3;
  std::vector&lt;int&gt; x4;
};

int main()
{
  U u;
  u.x3 = "hello world";
  std::cout &lt;&lt; u.x3;
}</code></pre>

  <p class="zw">在上面的代码中，由于<code class="calibre10">x3</code>和<code class="calibre10">x4</code>的类型<code class="calibre10">std::string</code>和<code class="calibre10">std::vector</code>是非平凡类型，因此<code class="calibre10">U</code>必须提供构造和析构函数。虽然这里提供的构造和析构函数什么也没有做，但是代码依然可以成功编译。不过请注意，能够编译通过并不代表没有问题，实际上这段代码会运行出错，因为非平凡类型<code class="calibre10">x3</code>并没有被构造，所以在赋值操作的时候必然会出错。现在修改一下代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

union U
{
  U() : x3() {}
  ~U() { x3.~basic_string(); }
  int x1;
  float x2;
  std::string x3;
  std::vector&lt;int&gt; x4;
};

int main()
{
  U u;
  u.x3 = "hello world";
  std::cout &lt;&lt; u.x3;
}</code></pre>

  <p class="zw">在上面的代码中，我们对联合类型<code class="calibre10">U</code>的构造和析构函数进行了修改。其中在构造函数中添加了初始化列表来构造<code class="calibre10">x3</code>，在析构函数中手动调用了<code class="calibre10">x3</code>的析构函数。前者很容易理解，而后者需要注意，联合类型在析构的时候编译器并不知道当前激活的是哪个成员，所以无法自动调用成员的析构函数，必须由程序员编写代码完成这部分工作。现在联合类型<code class="calibre10">U</code>的成员对象<code class="calibre10">x3</code>可以正常工作了，但是这种解决方案依然存在问题，因为在编写联合类型构造函数的时候无法确保哪个成员真正被使用。具体来说，如果在<code class="calibre10">main</code>函数内使用<code class="calibre10">U</code>的成员<code class="calibre10">x4</code>，由于<code class="calibre10">x4</code>并没有经过初始化，因此会导致程序出错：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

union U
{
  U() : x3() {}
  ~U() { x3.~basic_string(); }
  int x1;
  float x2;
  std::string x3;
  std::vector&lt;int&gt; x4;
};

int main()
{
  U u;
  u.x4.push_back(58);
}</code></pre>

  <p class="zw">基于这些考虑，我还是比较推荐让联合类型的构造和析构函数为空，也就是什么也不做，并且将其成员的构造和析构函数放在需要使用联合类型的地方。让我们继续修改上面的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

union U
{
  U() {}
  ~U() {}
  int x1;
  float x2;
  std::string x3;
  std::vector&lt;int&gt; x4;
};

int main()
{
  U u;
  new(&amp;u.x3) std::string("hello world");
  std::cout &lt;&lt; u.x3 &lt;&lt; std::endl;
  u.x3.~basic_string();

  new(&amp;u.x4) std::vector&lt;int&gt;;
  u.x4.push_back(58);
  std::cout &lt;&lt; u.x4[0] &lt;&lt; std::endl;
  u.x4.~vector();
}</code></pre>

  <p class="zw">请注意，上面的代码用了<code class="calibre10">placement new</code>的技巧来初始化构造<code class="calibre10">x3</code>和<code class="calibre10">x4</code>对象，在使用完对象后手动调用对象的析构函数。通过这样的方法保证了联合类型使用的灵活性和正确性。</p>

  <p class="zw">最后简单介绍一下非受限联合类型对静态成员变量的支持。联合类型的静态成员不属于联合类型的任何对象，所以并不是对象构造时被定义的，不能在联合类型内部初始化。实际上这一点和类的静态成员变量是一样的，当然了，它的初始化方法也和类的静态成员变量相同：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
union U
{
  static int x1;
};
int U::x1 = 42;

int main()
{
  std::cout &lt;&lt; U::x1 &lt;&lt; std::endl;
}</code></pre>

  <h2 id="OEBPS/Text/chapter011.html.nav_point_99" class="sigil_not_in_toc">11.3　总结</h2>

  <p class="zw">在C++中联合类型因为其实用性过低一直以来都是一个很少被提及的类型，尤其是现在对于动则16GB内存的PC来说，内存似乎已经不是人们关注的最重要的问题了。但是，我认为这次关于联合类型的修改的意义是非凡的，因为这个修改表达了C++对其设计理念的坚持，这种态度难能可贵。除此之外，现代PC的大内存并不能代表所有的机器环境，在一些生产环境中依旧需要能节省内存的程序。诚然，非受限联合类型在使用上有一些烦琐复杂，但作为C++程序员，合理利用内存也应该是一种理所当然的自我要求。如果开发环境支持C++17标准，则大部分情况下我们可以使用<code class="calibre10">std:: variant</code>来代替联合体。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter011.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter012.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter012.html.nav_point_100" class="not-in-toc">第12章　委托构造函数（C++11）</h1>

  <h2 id="OEBPS/Text/chapter012.html.nav_point_101" class="sigil_not_in_toc">12.1　冗余的构造函数</h2>

  <p class="zw">一个类有多个不同的构造函数在C++中是很常见的，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class X
{
public:
  X() : a_(0), b_(0.) { CommonInit(); }
  X(int a) : a_(a), b_(0.) { CommonInit(); }
  X(double b) : a_(0), b_(b) { CommonInit(); }
  X(int a, double b) : a_(a), b_(b) { CommonInit(); }
private:
  void CommonInit() {}
  int a_;
  double b_;
};</code></pre>

  <p class="zw">虽然这段代码在语法上没有任何问题，但是构造函数包含了太多重复代码，这使代码的维护变得困难。首先，类<code class="calibre10">X</code>需要在每个构造函数的初始化列表中初始化构造所有的成员变量，这段代码只有两个数据成员，而在现实代码编写中常常会有更多的数据成员或者更多的构造函数，那么在初始化列表中会有更多的重复内容，非常不利于代码的维护。其次，在构造函数主体中也有相同的情况，一旦类的构造过程需要依赖某个函数，那么所有构造函数的主体就需要调用这个函数，在例子中这个函数就是<code class="calibre10">CommonInit</code>。</p>

  <p class="zw">也许有读者会提出将数据成员的初始化放到<code class="calibre10">CommonInit</code>函数里，从而减轻初始化列表代码冗余的问题，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class X1
{
public:
  X1() { CommonInit(0, 0.); }
  X1(int a) { CommonInit(a, 0.); }
  X1(double b) { CommonInit(0, b); }
  X1(int a, double b) { CommonInit(a, b); }
private:
  void CommonInit(int a, double b)
  {
       a_ = a;
       b_ = b;
  }
  int a_;
  double b_;
};</code></pre>

  <p class="zw">以上代码在编译和运行上都没有问题，因为类<code class="calibre10">X1</code>的成员变量都是基本类型，所以在构造函数主体进行赋值也不会有什么问题。但是，如果成员函数中包含复杂的对象，那么就可能引发不确定问题，最好的情况是只影响类的构造效率，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class X2
{
public:
  X2() { CommonInit(0, 0.); }
  X2(int a) { CommonInit(a, 0.); }
  X2(double b) { CommonInit(0, b); }
  X2(int a, double b) { CommonInit(a, b); }
private:
  void CommonInit(int a, double b)
  {
       a_ = a;
       b_ = b;
       c_ = "hello world";
  }
  int a_;
  double b_;
  std::string c_;
};</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">std::string</code>类型的对象<code class="calibre10">c_</code>看似是在<code class="calibre10">CommonInit</code>函数中初始化为<code class="calibre10">hello world</code>，但是实际上它并不是一个初始化过程，而是一个赋值过程。因为对象的初始化过程早在构造函数主体执行之前，也就是初始化列表阶段就已经执行了。所以这里的c_对象进行了两次操作，一次为初始化，另一次才是赋值为hello world，很明显这样对程序造成了不必要的性能损失。另外，有些情况是不能使用函数主体对成员对象进行赋值的，比如禁用了赋值运算符的数据成员。</p>

  <p class="zw">当然读者还可能会提出通过为构造函数提供默认参数的方法来解决代码冗余的问题，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class X3
{
public:
  X3(double b) : a_(0), b_(b) { CommonInit(); }
  X3(int a = 0, double b = 0.) : a_(a), b_(b) { CommonInit(); }
private:
  void CommonInit() {}
  int a_;
  double b_;
};</code></pre>

  <p class="zw">这种做法的作用非常有限，可以看到上面这段代码，虽然通过默认参数的方式优化了两个构造函数，但是对于<code class="calibre10">X3(double b)</code>这个构造函数依然需要在初始化列表中重复初始化成员变量。另外，使用默认参数稍不注意就会引发二义性的问题，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class X4
{
public:
  X4(int c) : a_(0), b_(0.), c_(c) { CommonInit(); }
  X4(double b) : a_(0), b_(b), c_(0) { CommonInit(); }
  X4(int a = 0, double b = 0., int c = 0) : a_(a), b_(b), c_(c) { CommonInit(); }
private:
  void CommonInit() {}
  int a_;
  double b_;
  int c_;
};

int main()
{
  X4 x4(1);
}</code></pre>

  <p class="zw">以上代码无法通过编译，因为当<code class="calibre10">main</code>函数对<code class="calibre10">x4</code>进行构造时，编译器不知道应该调用<code class="calibre10">X4(int c)</code>还是<code class="calibre10">X4(int a = 0, double b = 0., int c = 0)</code>。所以让构造函数使用默认参数也不是一个好的解决方案。</p>

  <p class="zw">现在读者可以看出其中的问题了，过去C++没有提供一种复用同类型构造函数的方法，也就是说无法让一个构造函数将初始化的一部分工作委托给同类型的另外一个构造函数。这种功能的缺失就造成了程序员不得不编写重复烦琐代码的困境，更进一步来说它也造成了代码维护性下降。比如，如果想在类<code class="calibre10">X</code>中增加一个数据成员<code class="calibre10">d_</code>，那么就必须在4个构造函数的初始化列表中初始化成员变量<code class="calibre10">d_</code>，修改和删除也一样。</p>

  <h2 id="OEBPS/Text/chapter012.html.nav_point_102" class="sigil_not_in_toc">12.2　委托构造函数</h2>

  <p class="zw">为了合理复用构造函数来减少代码冗余，C++11标准支持了委托构造函数：某个类型的一个构造函数可以委托同类型的另一个构造函数对对象进行初始化。为了描述方便我们称前者为委托构造函数，后者为代理构造函数（英文直译为目标构造函数）。委托构造函数会将控制权交给代理构造函数，在代理构造函数执行完之后，再执行委托构造函数的主体。委托构造函数的语法非常简单，只需要在委托构造函数的初始化列表中调用代理构造函数即可，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class X
{
public:
  X() : X(0, 0.) {}
  X(int a) : X(a, 0.) {}
  X(double b) : X(0, b) {}
  X(int a, double b) : a_(a), b_(b) { CommonInit(); }
private:
  void CommonInit() {}
  int a_;
  double b_;
};</code></pre>

  <p class="zw">可以看到<code class="calibre10">X()</code>、<code class="calibre10">X(int a)</code>、<code class="calibre10">X(double b)</code>分别作为委托构造函数将控制权交给了代理构造函数<code class="calibre10">X(int a, double b)</code>。它们的执行顺序是先执行代理构造函数的初始化列表，接着执行代理构造函数的主体（也就是<code class="calibre10">CommonInit</code>函数），最后执行委托构造函数的主体，在这个例子中委托构造函数的主体都为空。</p>

  <p class="zw">委托构造函数的语法很简单，不过想合理使用它还需注意以下5点。</p>

  <p class="zw">1．每个构造函数都可以委托另一个构造函数为代理。也就是说，可能存在一个构造函数，它既是委托构造函数也是代理构造函数，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class X
{
public:
  X() : X(0) {}
  X(int a) : X(a, 0.) {}
  X(double b) : X(0, b) {}
  X(int a, double b) : a_(a), b_(b) { CommonInit(); }
private:
  void CommonInit() {}
  int a_;
  double b_;
};</code></pre>

  <p class="zw">在上面的代码中构造函数<code class="calibre10">X(int a)</code>，它既是一个委托构造函数，也是<code class="calibre10">X()</code>的代理构造函数。另外，除了自定义构造函数以外，我们还能让特殊构造函数也成为委托构造函数，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class X
{
public:
  X() : X(0) {}
  X(int a) : X(a, 0.) {}
  X(double b) : X(0, b) {}
  X(int a, double b) : a_(a), b_(b) { CommonInit(); }
  X(const X &amp;other) : X(other.a_, other.b_) {}          // 委托复制构造函数
private:
  void CommonInit() {}
  int a_;
  double b_;
};</code></pre>

  <p class="zw">以上代码增加了一个复制构造函数<code class="calibre10">X(const X &amp;other)</code>，并且把复制构造函数的控制权委托给了<code class="calibre10">X(int a, double b)</code>，而其自身主体不需要执行。</p>

  <p class="zw">2．不要递归循环委托！这一点非常重要，因为循环委托不会被编译器报错，随之而来的是程序运行时发生未定义行为，最常见的结果是程序因栈内存用尽而崩溃：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class X
{
public:
  X() : X(0) {}
  X(int a) : X(a, 0.) {}
  X(double b) : X(0, b) {}
  X(int a, double b) : X() { CommonInit(); }

private:
  void CommonInit() {}
  int a_;
  double b_;
};</code></pre>

  <p class="zw">上面代码中的3个构造函数形成了一个循环递归委托，<code class="calibre10">X()</code>委托到<code class="calibre10">X(int a)</code>，<code class="calibre10">X(int a)</code>委托到<code class="calibre10">X(int a, double b)</code>，最后<code class="calibre10">X(int a, double b)</code>又委托到<code class="calibre10">X()</code>。请读者务必注意不要编写出这样的循环递归委托代码，因为我目前实验的编译器，默认情况下除了CLang会给出错误提示，MSVC和GCC都不会发出任何警告。这里也建议读者在使用委托构造函数时，通常只指定一个代理构造函数即可，其他的构造函数都委托到这个代理构造函数，尽量不要形成链式委托，避免出现循环递归委托。</p>

  <p class="zw">3．如果一个构造函数为委托构造函数，那么其初始化列表里就不能对数据成员和基类进行初始化：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class X
{
public:
  X() : a_(0), b_(0) { CommonInit(); }
  X(int a) : X(), a_(a) {}   // 编译错误，委托构造函数不能在初始化列表初始化成员变量
  X(double b) : X(), b_(b) {}// 编译错误，委托构造函数不能在初始化列表初始化成员变量

private:
  void CommonInit() {}
  int a_;
  double b_;
};</code></pre>

  <p class="zw">在上面的代码中<code class="calibre10">X(int a)</code>和<code class="calibre10">X(double b)</code>都委托了<code class="calibre10">X()</code>作为代理构造函数，但是它们又打算初始化自己所需的成员变量，这样就导致了编译错误。其实这个错误很容易理解，因为根据C++标准规定，一旦类型有一个构造函数完成执行，那么就会认为其构造的对象已经构造完成。将这个规则放在这里来看，委托构造函数将控制权交给代理构造函数，代理构造函数执行完成以后，编译器认为对象已经构造成功，再次执行初始化列表必然会导致不可预知的问题，所以C++标准禁止了这样的语法。</p>

  <p class="zw">4．委托构造函数的执行顺序是先执行代理构造函数的初始化列表，然后执行代理构造函数的主体，最后执行委托构造函数的主体，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

class X
{
public:
  X() : X(0) { InitStep3(); }
  X(int a) : X(a, 0.) { InitStep2(); }
  X(double b) : X(0, b) {}
  X(int a, double b) : a_(a), b_(b) { InitStep1(); }
private:
  void InitStep1() { std::cout &lt;&lt; "InitStep1()" &lt;&lt; std::endl; }
  void InitStep2() { std::cout &lt;&lt; "InitStep2()" &lt;&lt; std::endl; }
  void InitStep3() { std::cout &lt;&lt; "InitStep3()" &lt;&lt; std::endl; }
  int a_;
  double b_;
};

int main()
{
  X x;
}</code></pre>

  <p class="zw">编译执行以上代码，输出结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">InitStep1()
InitStep2()
InitStep3()</code></pre>

  <p class="zw">5．如果在代理构造函数执行完成后，委托构造函数主体抛出了异常，则自动调用该类型的析构函数。这一条规则看起来有些奇怪，因为通常在没有完成构造函数的情况下，也就是说构造函数发生异常，对象类型的析构函数是不会被调用的。而这里的情况正好是一种中间状态，是否应该调用析构函数看似存在争议，其实不然，因为C++标准规定（规则3也提到过），一旦类型有一个构造函数完成执行，那么就会认为其构造的对象已经构造完成，所以发生异常后需要调用析构函数，来看一看具体的例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

class X
{
public:
  X() : X(0, 0.) { throw 1; }
  X(int a) : X(a, 0.) {}
  X(double b) : X(0, b) {}
  X(int a, double b) : a_(a), b_(b) { CommonInit(); }
  ~X() { std::cout &lt;&lt; "~X()" &lt;&lt; std::endl; }
private:
  void CommonInit() {}
  int a_;
  double b_;
};

int main()
{
  try {
       X x;
  }
  catch (…) {
  }
}</code></pre>

  <p class="zw">上面的代码中，构造函数<code class="calibre10">X()</code>委托构造函数<code class="calibre10">X(int a, double b)</code>对对象进行初始化，在代理构造函数初始化完成后，在<code class="calibre10">X()</code>主体内抛出了一个异常。这个异常会被<code class="calibre10">main</code>函数的<code class="calibre10">try cache</code>捕获，并且调用<code class="calibre10">X</code>的析构函数析构对象。读者不妨自己编译运行代码，并观察运行结果。</p>

  <h2 id="OEBPS/Text/chapter012.html.nav_point_103" class="sigil_not_in_toc">12.3　委托模板构造函数</h2>

  <p class="zw">委托模板构造函数是指一个构造函数将控制权委托到同类型的一个模板构造函数，简单地说，就是代理构造函数是一个函数模板。这样做的意义在于泛化了构造函数，减少冗余的代码的产生。将代理构造函数编写成函数模板往往会获得很好的效果，让我们看一看例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;deque&gt;

class X {
  template&lt;class T&gt; X(T first, T last) : l_(first, last) { }
  std::list&lt;int&gt; l_;
public:
  X(std::vector&lt;short&gt;&amp;);
  X(std::deque&lt;int&gt;&amp;);
};
X::X(std::vector&lt;short&gt;&amp; v) : X(v.begin(), v.end()) { }
X::X(std::deque&lt;int&gt;&amp; v) : X(v.begin(), v.end()) { }

int main()
{
  std::vector&lt;short&gt; a{ 1,2,3,4,5 };
  std::deque&lt;int&gt; b{ 1,2,3,4,5 };
  X x1(a);
  X x2(b);
}</code></pre>

  <p class="zw">在上面的代码中<code class="calibre10">template&lt;class T&gt; X(T first, T last)</code>是一个代理模板构造函数，<code class="calibre10">X(std::vector&lt;short&gt;&amp;)</code>和<code class="calibre10">X(std::deque&lt;int&gt;&amp;)</code>将控制权委托给了它。这样一来，我们就无须编写<code class="calibre10">std::vector&lt;short&gt;</code>和<code class="calibre10">std::deque &lt;int&gt;</code>版本的代理构造函数。后续增加委托构造函数也不需要修改代理构造函数，只需要保证参数类型支持迭代器就行了。</p>

  <h2 id="OEBPS/Text/chapter012.html.nav_point_104" class="sigil_not_in_toc">12.4　捕获委托构造函数的异常</h2>

  <p class="zw">当使用<code class="calibre10">Function-try-block</code>去捕获委托构造函数异常时，其过程和捕获初始化列表异常如出一辙。如果一个异常在代理构造函数的初始化列表或者主体中被抛出，那么委托构造函数的主体将不再被执行，与之相对的，控制权会交到异常捕获的<code class="calibre10">catch</code>代码块中：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

class X
{
public:
  X() try : X(0) {}
  catch (int e)
  {
       std::cout &lt;&lt; "catch: " &lt;&lt; e &lt;&lt; std::endl;
       throw 3;
  }
  X(int a) try : X(a, 0.) {}
  catch (int e)
  {
       std::cout &lt;&lt; "catch: " &lt;&lt; e &lt;&lt; std::endl;
       throw 2;
  }
  X(double b) : X(0, b) {}
  X(int a, double b) : a_(a), b_(b) { throw 1; }
private:
  int a_;
  double b_;
};

int main()
{
  try {
       X x;
  }
  catch (int e) {
       std::cout &lt;&lt; "catch: " &lt;&lt; e &lt;&lt; std::endl;
  }
}</code></pre>

  <p class="zw">编译运行以上代码，输出结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">catch: 1
catch: 2
catch: 3</code></pre>

  <p class="zw">由于这段代码是一个链式委托构造，<code class="calibre10">X()</code>委托到<code class="calibre10">X(int a)</code>，<code class="calibre10">X(int a)</code>委托到<code class="calibre10">X(int a, double b)</code>。因此在<code class="calibre10">X(int a, double b)</code>发生异常的时候，会以相反的顺序抛出异常。</p>

  <h2 id="OEBPS/Text/chapter012.html.nav_point_105" class="sigil_not_in_toc">12.5　委托参数较少的构造函数</h2>

  <p class="zw">看了以上各种示例代码，读者是否发现一个特点：将参数较少的构造函数委托给参数较多的构造函数。通常情况下我们建议这么做，因为这样做的自由度更高。但是，并不是完全否定从参数较多的构造函数委托参数较少的构造函数的意义。这种情况通常发生在构造函数的参数必须在函数体中使用的场景。以<code class="calibre10">std::fstream</code>作为例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">basic_fstream();
explicit basic_fstream(const char* s, ios_base::openmode mode);</code></pre>

  <p class="zw"><code class="calibre10">basic_fstream</code>的这两个构造函数，由于<code class="calibre10">basic_fstream(const char * s, ios_base::openmode mode)</code>需要在构造函数体内执行具体打开文件的操作，所以它完全可以委托<code class="calibre10">basic_fstream()</code>来完成一些最基础的初始化工作，最后执行到自己的主体时再打开文件：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">basic_fstream::basic_fstream(const char* s, ios_base::openmode mode)
  : basic_fstream()
{
  if (open(s, mode) == 0)
       setstate(failbit);
}</code></pre>

  <h2 id="OEBPS/Text/chapter012.html.nav_point_106" class="sigil_not_in_toc">12.6　总结</h2>

  <p class="zw">为了解决构造函数冗余的问题，C++委员会想了很多办法，本章介绍的委托构造函数就是其中之一，也是最重要的方法。通过委托构造函数，我们可以有效地减少构造函数重复初始化数据成员的问题，将初始化工作统一地交给某个构造函数来完成。这样在需要增减和修改数据成员的时候就只需要修改代理构造函数即可。不止如此，委托构造函数甚至支持通过模板来进一步简化编写多余构造函数的工作，可以说该特性对于复杂类结构是非常高效且实用的。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter012.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter013.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter013.html.nav_point_107" class="not-in-toc">第13章　继承构造函数（C++11）</h1>

  <h2 id="OEBPS/Text/chapter013.html.nav_point_108" class="sigil_not_in_toc">13.1　继承关系中构造函数的困局</h2>

  <p class="zw">相信读者在编程经历中一定遇到过下面的问题，假设现在有一个类<code class="calibre10">Base</code>提供了很多不同的构造函数。某一天，你发现<code class="calibre10">Base</code>无法满足未来业务需求，需要把<code class="calibre10">Base</code>作为基类派生出一个新类<code class="calibre10">Derived</code>并且对某些函数进行改造以满足未来新的业务需求，比如下面的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class Base {
public:
  Base() : x_(0), y_(0.) {};
  Base(int x, double y) : x_(x), y_(y) {}
  Base(int x) : x_(x), y_(0.) {}
  Base(double y) : x_(0), y_(y) {}
  void SomeFunc() {}
private:
  int x_;
  double y_;
};

class Derived : public Base {
public:
  Derived() {};
  Derived(int x, double y) : Base(x, y) {}
  Derived(int x) : Base(x) {}
  Derived(double y) : Base(y) {}
  void SomeFunc() {}
};</code></pre>

  <p class="zw">基类<code class="calibre10">Base</code>的<code class="calibre10">SomeFunc</code>无法满足当前的业务需求，于是在其派生类<code class="calibre10">Derived</code>中重写了这个函数，但令人头痛的是，面对<code class="calibre10">Base</code>中大量的构造函数，我们不得不在<code class="calibre10">Derived</code>中定义同样多的构造函数，目的仅仅是转发构造参数，因为派生类本身并没有需要初始化的数据成员。单纯地转发构造函数不仅会导致代码的冗余，而且大量重复的代码也会让程序更容易出错。实际上，这个工作完全可以让编译器自动完成，因为它实在太简单了，让编译器代劳不仅消除了代码冗余而且意图上也更加明确。</p>

  <h2 id="OEBPS/Text/chapter013.html.nav_point_109" class="sigil_not_in_toc">13.2　使用继承构造函数</h2>

  <p class="zw">我们都知道C++中可以使用<code class="calibre10">using</code>关键字将基类的函数引入派生类，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class Base {
public:
  void foo(int) {}
};

class Derived : public Base {
public:
  using Base::foo;
  void foo(char*) {}
};

int main()
{
  Derived d;
  d.foo(5);
}</code></pre>

  <p class="zw">C++11的继承构造函数正是利用了这一点，将<code class="calibre10">using</code>关键字的能力进行了扩展，使其能够引入基类的构造函数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class Base {
public:
  Base() : x_(0), y_(0.) {};
  Base(int x, double y) : x_(x), y_(y) {}
  Base(int x) : x_(x), y_(0.) {}
  Base(double y) : x_(0), y_(y) {}
private:
  int x_;
  double y_;
};

class Derived : public Base {
public:
  using Base::Base;
};</code></pre>

  <p class="zw">在上面的代码中，派生类<code class="calibre10">Derived</code>使用<code class="calibre10">using Base::Base</code>让编译器为自己生成转发到基类的构造函数，从结果上看这种实现方式和前面人工编写代码转发构造函数没有什么区别，但是在过程上代码变得更加简洁易于维护了。</p>

  <p class="zw">使用继承构造函数虽然很方便，但是还有6条规则需要注意。</p>

  <p class="zw">1．派生类是隐式继承基类的构造函数，所以只有在程序中使用了这些构造函数，编译器才会为派生类生成继承构造函数的代码。</p>

  <p class="zw">2．派生类不会继承基类的默认构造函数和复制构造函数。这一点乍看有些奇怪，但仔细想想也是顺理成章的。因为在C++语法规则中，执行派生类默认构造函数之前一定会先执行基类的构造函数。同样的，在执行复制构造函数之前也一定会先执行基类的复制构造函数。所以继承基类的默认构造函数和默认复制构造函数的做法是多余的，这里不会这么做。</p>

  <p class="zw">3．继承构造函数不会影响派生类默认构造函数的隐式声明，也就是说对于继承基类构造函数的派生类，编译器依然会为其自动生成默认构造函数的代码。</p>

  <p class="zw">4．在派生类中声明签名相同的构造函数会禁止继承相应的构造函数。这一条规则不太好理解，让我们结合代码来看一看：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class Base {
public:
  Base() : x_(0), y_(0.) {};
  Base(int x, double y) : x_(x), y_(y) {}
  Base(int x) : x_(x), y_(0.) { std::cout &lt;&lt; "Base(int x)" &lt;&lt; std::endl; }
  Base(double y) : x_(0), y_(y) { std::cout &lt;&lt; "Base(double y)" &lt;&lt; std::endl; }
private:
  int x_;
  double y_;
};

class Derived : public Base {
public:
  using Base::Base;
  Derived(int x) { std::cout &lt;&lt; "Derived(int x)" &lt;&lt; std::endl; }
};

int main()
{
  Derived d(5);
  Derived d1(5.5);
}</code></pre>

  <p class="zw">在上面的代码中，派生类<code class="calibre10">Derived</code>使用<code class="calibre10">using Base::Base</code>继承了基类的构造函数，但是由于<code class="calibre10">Derived</code>定义了构造函数<code class="calibre10">Derived(int x)</code>，该函数的签名与基类的构造函数<code class="calibre10">Base(int x)</code>相同，因此这个构造函数的继承被禁止了，<code class="calibre10">Derived d(5)</code>会调用派生类的构造函数并且输出<code class="calibre10">"Derived(int x)"</code>。另外，这个禁止动作并不会影响到其他签名的构造函数，<code class="calibre10">Derived d1(5.5)</code>依然可以成功地使用基类的构造函数进行构造初始化。</p>

  <p class="zw">5．派生类继承多个签名相同的构造函数会导致编译失败：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class Base1 {
public:
  Base1(int) { std::cout &lt;&lt; "Base1(int x)" &lt;&lt; std::endl; };
};

class Base2 {
public:
  Base2(int) { std::cout &lt;&lt; "Base2(int x)" &lt;&lt; std::endl; };
};

class Derived : public Base1, Base2 {
public:
  using Base1::Base1;
  using Base2::Base2;
};

int main()
{
  Derived d(5);
}</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">Derived</code>继承了两个类<code class="calibre10">Base1</code>和<code class="calibre10">Base2</code>，并且继承了它们的构造函数。但是由于这两个类的构造函数<code class="calibre10">Base1(int)</code>和<code class="calibre10">Base2(int)</code>拥有相同的签名，导致编译器在构造对象的时候不知道应该使用哪一个基类的构造函数，因此在编译时给出一个二义性错误。</p>

  <p class="zw">6．继承构造函数的基类构造函数不能为私有：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class Base {
  Base(int) {}
public:
  Base(double) {}
};

class Derived : public Base {
public:
  using Base::Base;
};

int main()
{
  Derived d(5.5);
  Derived d1(5);
}</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">Derived d1(5)</code>无法通过编译，因为它对应的基类构造函数<code class="calibre10">Base(int)</code>是一个私有函数，<code class="calibre10">Derived d(5.5)</code>则没有这个问题。</p>

  <p class="zw">最后再介绍一个有趣的问题，在早期的C++11编译器中，继承构造函数会把基类构造函数注入派生类，于是导致了这样一个问题：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

struct Base {
  Base() = default;
  template&lt;typename T&gt; Base(T, typename T::type = 0)
  {
       std::cout &lt;&lt; "Base(T, typename T::type)" &lt;&lt; std::endl;
  }
  Base(int) { std::cout &lt;&lt; "Base(int)" &lt;&lt; std::endl; }
};

struct Derived : Base {
  using Base::Base;
  Derived(int) { std::cout &lt;&lt; "Derived(int)" &lt;&lt; std::endl; }
};

int main()
{
  Derived d(42L);
}</code></pre>

  <p class="zw">上面这段代码用早期的编译器（比如GCC 6.4）编译运行的输出结果是<code class="calibre10">Base(int)</code>，而用新的GCC编译运行的输出结果是<code class="calibre10">Derived(int)</code>。在老的版本中，<code class="calibre10">template&lt;typename T&gt; Base(T, typename T::type = 0)</code>被注入派生类中，形成了这样两个构造函数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;typename T&gt; Derived(T);
template&lt;typename T&gt; Derived(T, typename T::type);</code></pre>

  <p class="zw">这是因为继承基类构造函数时，不会继承默认参数，而是在派生类中注入带有各种参数数量的构造函数的重载集合。于是，编译器理所当然地选择推导<code class="calibre10">Derived(T)</code>为<code class="calibre10">Derived(long)</code>作为构造函数。在构造基类时，由于<code class="calibre10">Base(long, typename long::type = 0)</code>显然是一个非法的声明，因此编译器选择使用<code class="calibre10">Base(int)</code>作为基类的构造函数。最终结果就是我们看到的输出了<code class="calibre10">Base(int)</code>。而在新版本中继承构造函数不会注入派生类，所以不存在这个问题，编译器会直接使用派生类的<code class="calibre10">Derived(int)</code>构造函数构造对象。</p>

  <h2 id="OEBPS/Text/chapter013.html.nav_point_110" class="sigil_not_in_toc">13.3　总结</h2>

  <p class="zw">本章介绍了继承构造函数特性，与委托构造函数特性委托本类中的构造函数不同，该特性用于有继承关系的派生类中，让派生类能够直截了当地使用基类构造函数，而不需要为每个派生类的构造函数反复编写继承的基类构造函数。至此，所有简化构造函数、消除构造函数的代码冗余的特性均已介绍完毕，它们分别是非静态数据成员默认初始化、委托构造函数以及本章介绍的继承构造函数。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter013.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter014.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter014.html.nav_point_111" class="not-in-toc">第14章　强枚举类型（C++11 C++17 C++20）</h1>

  <h2 id="OEBPS/Text/chapter014.html.nav_point_112" class="sigil_not_in_toc">14.1　枚举类型的弊端</h2>

  <p class="zw">C++之父本贾尼·斯特劳斯特卢普曾经在他的<em class="calibre22">The Design And Evolution Of C++</em>一书中写道“C enumerations constitute a curiously half-baked concept.”。翻译过来就是“C语言的枚举类型构成了一个奇怪且半生不熟的概念”，可见这位C++之父对于<code class="calibre10">enum</code>类型的现状是不满意的，主要原因是<code class="calibre10">enum</code>类型破坏了C++的类型安全。大多数情况下，我们说C++是一门类型安全的强类型语言，但是枚举类型在一定程度上却是一个例外，具体来说有以下几个方面的原因。</p>

  <p class="zw">首先，虽然枚举类型存在一定的安全检查功能，一个枚举类型不允许分配到另外一种枚举类型，而且整型也无法隐式转换成枚举类型。但是枚举类型却可以隐式转换为整型，因为C++标准文档提到“枚举类型可以采用整型提升的方法转换成整型”。请看下面的代码示例：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">enum School {
  principal,
  teacher,
  student
};

enum Company {
  chairman,
  manager,
  employee
};

int main()
{
  School x = student;
  Company y = manager;
  bool b = student &gt;= manager;    // 不同类型之间的比较操作
  b = x &lt; employee;
  int y = student;                // 隐式转换为int
}</code></pre>

  <p class="zw">在上面的代码中两个不同类型的枚举标识符<code class="calibre10">student</code>和<code class="calibre10">manager</code>可以进行比较，这在C++语言的其他类型中是很少看到的。这种比较合法的原因是枚举类型先被隐式转换为整型，然后才进行比较。同样的问题也出现在<code class="calibre10">student</code>直接赋值到<code class="calibre10">int</code>类型变量上的情况中。另外，下面的代码会触发C++对枚举的检查，它们是无法编译通过的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">School x = chairman;    // 类型不匹配，无法通过编译
Company y = student;    // 类型不匹配，无法通过编译
x = 1;                  // 整型无法隐式转换到枚举类型</code></pre>

  <p class="zw">然后是枚举类型的作用域问题，枚举类型会把其内部的枚举标识符导出到枚举被定义的作用域。也是就说，我们使用枚举标识符的时候，可以跳过对于枚举类型的描述：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">School x = student;
Company y = manager;</code></pre>

  <p class="zw">无论是初始化<code class="calibre10">x</code>，还是初始化<code class="calibre10">y</code>，我们都没有对<code class="calibre10">student</code>和<code class="calibre10">manager</code>的枚举类型进行描述。因为它们已经跳出了<code class="calibre10">School</code>和<code class="calibre10">Company</code>。在我们看到的第一个例子中，这没有什么问题，两种类型相安无事。但是如果遇到下面的这种情况就会让人头痛了：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">enum HighSchool {
  student,
  teacher,
  principal
};

enum University {
  student,
  professor,
  principal
};</code></pre>

  <p class="zw"><code class="calibre10">HighSchool</code>和<code class="calibre10">University</code>都有<code class="calibre10">student</code>和<code class="calibre10">principal</code>，而枚举类型又会将其枚举标识符导出到定义它们的作用域，这样就会发生重复定义，无法通过编译。解决此类问题的一个办法是使用命名空间，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">enum HighSchool {
  student,
  teacher,
  principal
};

namespace AcademicInstitution
{
enum University {
  student,
  professor,
  principal
};
}</code></pre>

  <p class="zw">这样一来，<code class="calibre10">University</code>的枚举标识符就会被导出到<code class="calibre10">AcademicInstitution</code>的作用域，和<code class="calibre10">HighSchool</code>的全局作用域区分开来。</p>

  <p class="zw">对于上面两个问题，有一个比较好但并不完美的解决方案，代码如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

class AuthorityType {
 enum InternalType
 {
     ITBan,
     ITGuest,
     ITMember,
     ITAdmin,
     ITSystem,
 };

 InternalType self_;

public:
 AuthorityType(InternalType self) : self_(self) {}

 bool operator &lt; (const AuthorityType &amp;other) const
 {
     return self_ &lt; other.self_;
 }

 bool operator &gt; (const AuthorityType &amp;other) const
 {
     return self_ &gt; other.self_;
 }

 bool operator &lt;= (const AuthorityType &amp;other) const
 {
     return self_ &lt;= other.self_;
 }

 bool operator &gt;= (const AuthorityType &amp;other) const
 {
     return self_ &gt;= other.self_;
 }

 bool operator == (const AuthorityType &amp;other) const
 {
     return self_ == other.self_;
 }

 bool operator != (const AuthorityType &amp;other) const
 {
     return self_ != other.self_;
 }

 const static AuthorityType System, Admin, Member, Guest, Ban;
};

#define DEFINE_AuthorityType(x) const AuthorityType \
 AuthorityType::x(AuthorityType::IT ## x)
DEFINE_AuthorityType(System);
DEFINE_AuthorityType(Admin);
DEFINE_AuthorityType(Member);
DEFINE_AuthorityType(Guest);
DEFINE_AuthorityType(Ban);

int main()
{
 bool b = AuthorityType::System &gt; AuthorityType::Admin;
 std::cout &lt;&lt; std::boolalpha &lt;&lt; b &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">让我们先看一看以上代码的优点。</p>

  <p class="zw">　　将枚举类型变量封装成类私有数据成员，保证无法被外界访问。访问枚举类型的数据成员必须通过对应的常量静态对象。另外，根据C++标准的约束，访问静态对象必须指明对象所属类型。也就是说，如果我们想访问<code class="calibre10">ITSystem</code>这个枚举标识符，就必须访问常量静态对象<code class="calibre10">System</code>，而访问<code class="calibre10">System</code>对象，就必须说明其所属类型，这使我们需要将代码写成<code class="calibre10">AuthorityType:: System</code>才能编译通过。</p>

  <p class="zw">　　由于我们实现了比较运算符，因此可以对枚举类型进行比较。但是比较运算符函数只接受同类型的参数，所以只允许相同类型进行比较。</p>

  <p class="zw">当然很明显，这样做也有缺点。</p>

  <p class="zw">　　最大的缺点是实现起来要多敲很多代码。</p>

  <p class="zw">　　枚举类型本身是一个POD类型，而我们实现的类破坏了这种特性。</p>

  <p class="zw">还有一个严重的问题是，无法指定枚举类型的底层类型。因此，不同的编译器对于相同枚举类型可能会有不同的底层类型，甚至有无符号也会不同。来看下面这段代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">enum E {
 e1 = 1,
 e2 = 2,
 e3 = 0xfffffff0
};

int main()
{
 bool b = e1 &lt; e3;
 std::cout &lt;&lt; std::boolalpha &lt;&lt; b &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">读者可以思考一下，上面这段代码的输出结果是什么？答案是不同的编译器会得到不同的结果。在GCC中，结果返回<code class="calibre10">true</code>，我们可以认为<code class="calibre10">E</code>的底层类型为<code class="calibre10">unsigned int</code>。如果输出<code class="calibre10">e3</code>，会发现其值为4294967280。但是在MSVC中结果输出为<code class="calibre10">false</code>，很明显在编译器内部将<code class="calibre10">E</code>定义为了<code class="calibre10">int</code>类型，输出<code class="calibre10">e3</code>的结果为−16。这种编译器上的区别会使在编写跨平台程序时出现重大问题。</p>

  <p class="zw">虽然说了这么多枚举类型存在的问题，但是我这里想强调一个观点，如果代码中有需要表达枚举语义的地方，还是应该使用枚举类型。原因就是在第一个问题中讨论的，枚举类型还是有一定的类型检查能力。我们应该避免使用宏和<code class="calibre10">const int</code>的方法去实现枚举，因为其缺点更加严重。</p>

  <p class="zw">值得一提的是，枚举类型缺乏类型检查的问题倒是成就了一种特殊用法。如果读者了解模板元编程，那么肯定见过一种被称为<code class="calibre10">enum hack</code>的枚举类型的用法。简单来说就是利用枚举值在编译期就能确定下来的特性，让编译器帮助我们完成一些计算：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
template&lt;int a, int b&gt;
struct add {
    enum {
        result = a + b
    };
};

int main()
{
    std::cout &lt;&lt; add&lt;5, 8&gt;::result &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">用GCC查看其GIMPLE的中间代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">main ()
{
  int D.39267;
  _1 = std::basic_ostream&lt;char&gt;::operator&lt;&lt; (&amp;cout, 13);
  std::basic_ostream&lt;char&gt;::operator&lt;&lt; (_1, endl);
  D.39267 = 0;
  return D.39267;
}</code></pre>

  <p class="zw">可以看到<code class="calibre10">add&lt;5, 8&gt;::result</code>在编译器编译代码的时候就已经计算出来了，运行时直接使用<code class="calibre10">&lt;&lt;</code>运算符输出结果13。</p>

  <h2 id="OEBPS/Text/chapter014.html.nav_point_113" class="sigil_not_in_toc">14.2　使用强枚举类型</h2>

  <p class="zw">由于枚举类型确实存在一些类型安全的问题，因此C++标准委员会在C++11标准中对其做出了重大升级，增加了强枚举类型。另外，为了保证老代码的兼容性，也保留了枚举类型之前的特性。强枚举类型具备以下3个新特性。</p>

  <p class="zw">1．枚举标识符属于强枚举类型的作用域。</p>

  <p class="zw">2．枚举标识符不会隐式转换为整型。</p>

  <p class="zw">3．能指定强枚举类型的底层类型，底层类型默认为<code class="calibre10">int</code>类型。</p>

  <p class="zw">定义强枚举类型的方法非常简单，只需要在枚举定义的<code class="calibre10">enum</code>关键字之后加上<code class="calibre10">class</code>关键字就可以了。下面将<code class="calibre10">HighSchool</code>和<code class="calibre10">University</code>改写为强枚举类型：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

enum class HighSchool {
    student,
    teacher,
    principal
};

enum class University {
    student,
    professor,
    principal
};

int main()
{
    HighSchool x = HighSchool::student;
    University y = University::student;
    bool b = x &lt; HighSchool::headmaster;
    std::cout &lt;&lt; std::boolalpha &lt;&lt; b &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">观察上面的代码可以发现，首先，在不使用命名空间的情况下，两个有着相同枚举标识符的强枚举类型可以在一个作用域内共存。这符合强枚举类型的第一个特性，其枚举标识符属于强枚举类型的作用域，无法从外部直接访问它们，所以在访问时必须加上枚举类型名，否则会编译失败，如<code class="calibre10">HighSchool::student</code>。其次，相同枚举类型的枚举标识符可以进行比较，但是不同枚举类型就无法比较其枚举标识符了，因为它们失去了隐式转换为整型的能力，这一点符合强枚举类型的第二个特性：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">HighSchool x = student;              // 编译失败，找不到student的定义
bool b = University::student &lt; HighSchool::headmaster;// 编译失败，比较的类型不同
int y = University::student;         // 编译失败，无法隐式转换为int类型</code></pre>

  <p class="zw">有了这两个特性的支持，强枚举类型就可以完美替代14.1节中实现的<code class="calibre10">AuthorityType</code>类，强枚举类型不仅实现起来非常简洁，而且还是POD类型。</p>

  <p class="zw">对于强枚举类型的第三个特性，我们可以在定义类型的时候使用:符号来指明其底层类型。利用它可以消除不同编译器带来的歧义：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">enum class E : unsigned int {
    e1 = 1,
    e2 = 2,
    e3 = 0xfffffff0
};

int main()
{
    bool b = e1 &lt; e3;
    std::cout &lt;&lt; std::boolalpha &lt;&lt; b &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">上面这段代码明确指明了枚举类型<code class="calibre10">E</code>的底层类型是无符号整型，这样一来无论使用GCC还是MSVC，最后返回的结果都是<code class="calibre10">true</code>。如果这里不指定具体的底层类型，编译器会使用<code class="calibre10">int</code>类型。但GCC和MSVC的行为又出现了一些区别：MSVC会编译成功，<code class="calibre10">e3</code>被编译为一个负值；而GCC则会报错，因为0xfffffff0超过了<code class="calibre10">int</code>能表达的最大正整数范围。</p>

  <p class="zw">在C++11标准中，我们除了能指定强枚举类型的底层类型，还可以指定枚举类型的底层类型，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">enum E : unsigned int {
    e1 = 1,
    e2 = 2,
    e3 = 0xfffffff0
};

int main()
{
    bool b = e1 &lt; e3;
    std::cout &lt;&lt; std::boolalpha &lt;&lt; b &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">另外，虽然我们多次强调了强枚举类型的枚举标识符是无法隐式转换为整型的，但还是可以通过<code class="calibre10">static_cast</code>对其进行强制类型转换，但我建议不要这样做。最后说一点，强枚举类型不允许匿名，我们必须给定一个类型名，否则无法通过编译。</p>

  <h2 id="OEBPS/Text/chapter014.html.nav_point_114" class="sigil_not_in_toc">14.3　列表初始化有底层类型枚举对象</h2>

  <p class="zw">从C++17标准开始，对有底层类型的枚举类型对象可以直接使用列表初始化。这条规则适用于所有的强枚举类型，因为它们都有默认的底层类型<code class="calibre10">int</code>，而枚举类型就必须显式地指定底层类型才能使用该特性：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">enum class Color {
  Red,
  Green,
  Blue
};
int main()
{
  Color c{ 5 };          // 编译成功
  Color c1 = 5;          // 编译失败
  Color c2 = { 5 };      // 编译失败
  Color c3(5);           // 编译失败
}</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">c</code>可以在C++17环境下成功编译运行，因为<code class="calibre10">Color</code>有默认底层类型<code class="calibre10">int</code>，所以能够通过列表初始化对象，但是<code class="calibre10">c1</code>、<code class="calibre10">c2</code>和<code class="calibre10">c3</code>就没有那么幸运了，它们的初始化方法都是非法的。同样的道理，下面的代码能编译通过：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">enum class Color1 : char {};
enum Color2 : short {};

int main()
{
  Color1 c{ 7 };
  Color2 c1{ 11 };
  Color2 c2 = Color2{ 5 };
}</code></pre>

  <p class="zw">请注意，虽然<code class="calibre10">Color2 c2 = Color2{ 5 }</code>和<code class="calibre10">Color c2 = { 5 }</code>在代码上有些类似，但是其含义是完全不同的。对于<code class="calibre10">Color2 c2 = Color2{ 5 }</code>来说，代码先通过列表初始化了一个临时对象，然后再赋值到<code class="calibre10">c2</code>，而<code class="calibre10">Color c2 = { 5 }</code>则没有这个过程。另外，没有指定底层类型的枚举类型是无法使用列表初始化的，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">enum Color3 {};

int main()
{
  Color3 c{ 7 };
}</code></pre>

  <p class="zw">以上代码一定会编译报错，因为无论是C++17还是在此之前的标准，<code class="calibre10">Color3</code>都没有底层类型。同所有的列表初始化一样，它禁止缩窄转换，所以下面的代码也是不允许的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">enum class Color1 : char {};

int main()
{
  Color1 c{ 7.11 };
}</code></pre>

  <p class="zw">到此为止，读者应该都会有这样一个疑问，C++11标准中对强枚举类型初始化做了严格限制，目的就是防止枚举类型的滥用。可是C++17又打破了这种严格的限制，我们似乎看不出这样做的好处。实际上，让有底层类型的枚举类型支持列表初始化的确有一个十分合理的动机。</p>

  <p class="zw">现在假设一个场景，我们需要一个新整数类型，该类型必须严格区别于其他整型，也就是说不能够和其他整型做隐式转换，显然使用<code class="calibre10">typedef</code>的方法是不行的。另外，虽然通过定义一个类的方法可以到达这个目的，但是这个方法需要编写大量的代码来重载运算符，也不是一个理想的方案。所以，C++的专家把目光投向了有底层类型的枚举类型，其特性几乎完美地符合以上要求，除了初始化整型值的时候需要用到强制类型转换。于是，C++17为有底层类型的枚举类型放宽了初始化的限制，让其支持列表初始化：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
enum class Index : int {};

int main()
{
  Index a{ 5 };
  Index b{ 10 };
  // a = 12;
  // int c = b;
  std::cout &lt;&lt; "a &lt; b is " 
       &lt;&lt; std::boolalpha 
       &lt;&lt; (a &lt; b) &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">在上面的代码中，定义了<code class="calibre10">Index</code>的底层类型为<code class="calibre10">int</code>，所以可以使用列表初始化<code class="calibre10">a</code>和<code class="calibre10">b</code>，由于<code class="calibre10">a</code>和<code class="calibre10">b</code>的枚举类型相同，因此所有<code class="calibre10">a &lt; b</code>的用法也是合法的。但是<code class="calibre10">a = 12</code>和<code class="calibre10">int c = b</code>无法成功编译，因为强枚举类型是无法与整型隐式相互转换的。</p>

  <p class="zw">最后提示一点，在C++17的标准库中新引入的<code class="calibre10">std::byte</code>类型就是用这种方法定义的。</p>

  <h2 id="OEBPS/Text/chapter014.html.nav_point_115" class="sigil_not_in_toc">14.4　使用using打开强枚举类型</h2>

  <p class="zw">C++20标准扩展了<code class="calibre10">using</code>功能，它可以打开强枚举类型的命名空间。在一些情况下，这样做会让代码更加简洁易读，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">enum class Color {
  Red,
  Green,
  Blue
};

const char* ColorToString(Color c)
{
  switch (c)
  {
  case Color::Red: return "Red";
  case Color::Green: return "Green";
  case Color::Blue: return "Blue";
  default:
       return "none";
  }
}</code></pre>

  <p class="zw">在上面的代码中，函数<code class="calibre10">ColorToString</code>中需要不断使用<code class="calibre10">Color::</code>来指定枚举标识符，这显然会让代码变得冗余。通过<code class="calibre10">using</code>我们可以简化这部分代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">const char* ColorToString(Color c)
{
  switch (c)
  {
  using enum Color;
  case Red: return "Red";
  case Green: return "Green";
  case Blue: return "Blue";
  default:
       return "none";
  }
}</code></pre>

  <p class="zw">以上代码使用<code class="calibre10">using enum Color;</code>将<code class="calibre10">Color</code>中的枚举标识符引入<code class="calibre10">swtich-case</code>作用域。请注意，<code class="calibre10">swtich-case</code>作用域之外依然需要使用<code class="calibre10">Color::</code>来指定枚举标识符。除了引入整个枚举标识符之外，<code class="calibre10">using</code>还可以指定引入的标识符，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">const char* ColorToString(Color c)
{
  switch (c)
  {
  using Color::Red;
  case Red: return "Red";
  case Color::Green: return "Green";
  case Color::Blue: return "Blue";
  default:
       return "none";
  }
}</code></pre>

  <p class="zw">以上代码使用<code class="calibre10">using Color::Red;</code>将<code class="calibre10">Red</code>引入<code class="calibre10">swtich-case</code>作用域，其他枚举标识符依然需要使用<code class="calibre10">Color::</code>来指定。</p>

  <h2 id="OEBPS/Text/chapter014.html.nav_point_116" class="sigil_not_in_toc">14.5　总结</h2>

  <p class="zw">本章介绍的强枚举类型不仅修正了枚举类型的缺点并且全面地扩展了枚举类型的特性。在编程过程中应该总是优先考虑强枚举类型，这样让我们更容易在编译期发现枚举类型上的疏漏，从而更早修复这些问题。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter014.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter015.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter015.html.nav_point_117" class="not-in-toc">第15章　扩展的聚合类型（C++17 C++20）</h1>

  <h2 id="OEBPS/Text/chapter015.html.nav_point_118" class="sigil_not_in_toc">15.1　聚合类型的新定义</h2>

  <p class="zw">C++17标准对聚合类型的定义做出了大幅修改，即从基类公开且非虚继承的类也可能是一个聚合。同时聚合类型还需要满足常规条件。</p>

  <p class="zw">1．没有用户提供的构造函数。</p>

  <p class="zw">2．没有私有和受保护的非静态数据成员。</p>

  <p class="zw">3．没有虚函数。</p>

  <p class="zw">在新的扩展中，如果类存在继承关系，则额外满足以下条件。</p>

  <p class="zw">4．必须是公开的基类，不能是私有或者受保护的基类。</p>

  <p class="zw">5．必须是非虚继承。</p>

  <p class="zw">请注意，这里并没有讨论基类是否需要是聚合类型，也就是说基类是否是聚合类型与派生类是否为聚合类型没有关系，只要满足上述5个条件，派生类就是聚合类型。在标准库<code class="calibre10">&lt;type_traits&gt;</code>中提供了一个聚合类型的甄别办法<code class="calibre10">is_aggregate</code>，它可以帮助我们判断目标类型是否为聚合类型：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;

class MyString : public std::string {};

int main()
{
  std::cout &lt;&lt; "std::is_aggregate_v&lt;std::string&gt; = "
       &lt;&lt; std::is_aggregate_v&lt;std::string&gt; &lt;&lt; std::endl;
  std::cout &lt;&lt; "std::is_aggregate_v&lt;MyString&gt; = "
       &lt;&lt; std::is_aggregate_v&lt;MyString&gt; &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">在上面的代码中，先通过<code class="calibre10">std::is_aggregate_v</code>判断<code class="calibre10">std::string</code>是否为聚合类型，根据我们对<code class="calibre10">std::string</code>的了解，它存在用户提供的构造函数，所以一定是非聚合类型。然后判断类<code class="calibre10">MyString</code>是否为聚合类型，虽然该类继承了<code class="calibre10">std::string</code>，但因为它是公开继承且是非虚继承，另外，在类中不存在用户提供的构造函数、虚函数以及私有或者受保护的数据成员，所以<code class="calibre10">MyString</code>应该是聚合类型。编译运行以上代码，输出的结果也和我们判断的一致：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::is_aggregate_v&lt;std::string&gt; = 0
std::is_aggregate_v&lt;MyString&gt; = 1</code></pre>

  <h2 id="OEBPS/Text/chapter015.html.nav_point_119" class="sigil_not_in_toc">15.2　聚合类型的初始化</h2>

  <p class="zw">由于聚合类型定义的扩展，聚合对象的初始化方法也发生了变化。过去要想初始化派生类的基类，需要在派生类中提供构造函数，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;

class MyStringWithIndex : public std::string {
public:
  MyStringWithIndex(const std::string&amp; str, int idx) : std::string(str), index_(idx) {}
  int index_ = 0;
};

std::ostream&amp; operator &lt;&lt; (std::ostream &amp;o, const MyStringWithIndex&amp; s)
{
  o &lt;&lt; s.index_ &lt;&lt; ":" &lt;&lt; s.c_str();
  return o;
}

int main()
{
  MyStringWithIndex s("hello world", 11);
  std::cout &lt;&lt; s &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">在上面的代码中，为了初始化基类我们不得不为<code class="calibre10">MyStringWithIndex</code>提供一个构造函数，用构造函数的初始化列表来初始化<code class="calibre10">std::string</code>。现在，由于聚合类型的扩展，这个过程得到了简化。需要做的修改只有两点，第一是删除派生类中用户提供的构造函数，第二是直接初始化：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;

class MyStringWithIndex : public std::string {
public:
  int index_ = 0;
};

std::ostream&amp; operator &lt;&lt; (std::ostream &amp;o, const MyStringWithIndex&amp; s)
{
  o &lt;&lt; s.index_ &lt;&lt; ":" &lt;&lt; s.c_str();
  return o;
}

int main()
{
  MyStringWithIndex s{ {"hello world"}, 11 };
  std::cout &lt;&lt; s &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">删除派生类中用户提供的构造函数是为了让<code class="calibre10">MyStringWithIndex</code>成为一个C++17标准的聚合类型，而作为聚合类型直接使用大括号初始化即可。<code class="calibre10">MyStringWithIndex s{ {"hello world"}, 11}</code>是典型的初始化基类聚合类型的方法。其中<code class="calibre10">{"hello world"}</code>用于基类的初始化，<code class="calibre10">11</code>用于<code class="calibre10">index_</code>的初始化。这里的规则总是假设基类是一种在所有数据成员之前声明的特殊成员。所以实际上，<code class="calibre10">{"hello world"}</code>的大括号也可以省略，直接使用<code class="calibre10">MyStringWithIndex s{ "hello world", 11}</code>也是可行的。另外，如果派生类存在多个基类，那么其初始化的顺序与继承的顺序相同：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;

class Count {
public:
  int Get() { return count_++; }
  int count_ = 0;
};

class MyStringWithIndex : 
  public std::string, 
  public Count {
public:
  int index_ = 0;
};

std::ostream&amp; operator &lt;&lt; (std::ostream &amp;o, MyStringWithIndex&amp; s)
{
  o &lt;&lt; s.index_ &lt;&lt; ":" &lt;&lt; s.Get() &lt;&lt; ":" &lt;&lt; s.c_str();
  return o;
}

int main()
{
  MyStringWithIndex s{ "hello world", 7, 11 };
  std::cout &lt;&lt; s &lt;&lt; std::endl;
  std::cout &lt;&lt; s &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">在上面的代码中，类<code class="calibre10">MyStringWithIndex</code>先后继承了<code class="calibre10">std::string</code>和<code class="calibre10">Count</code>，所以在初始化时需要按照这个顺序初始化对象。<code class="calibre10">{ "hello world", 7, 11}</code>中字符串<code class="calibre10">"hello world"</code>对应基类<code class="calibre10">std::string</code>，<code class="calibre10">7</code>对应基类<code class="calibre10">Count</code>，<code class="calibre10">11</code>对应数据成员<code class="calibre10">index_</code>。</p>

  <h2 id="OEBPS/Text/chapter015.html.nav_point_120" class="sigil_not_in_toc">15.3　扩展聚合类型的兼容问题</h2>

  <p class="zw">虽然扩展的聚合类型给我们提供了一些方便，但同时也带来了一个兼容老代码的问题，请考虑以下代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;

class BaseData {
  int data_;
public:
  int Get() { return data_; }
protected:
  BaseData() : data_(11) {}
};

class DerivedData : public BaseData {
public:
};

int main()
{
  DerivedData d{};
  std::cout &lt;&lt; d.Get() &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">以上代码使用C++11或者C++14标准可以编译成功，而使用C++17标准编译则会出现错误，主要原因就是聚合类型的定义发生了变化。在C++17之前，类<code class="calibre10">DerivedData</code>不是一个聚合类型，所以<code class="calibre10">DerivedData d{}</code>会调用编译器提供的默认构造函数。调用<code class="calibre10">DerivedData</code>默认构造函数的同时还会调用<code class="calibre10">BaseData</code>的构造函数。虽然这里<code class="calibre10">BaseData</code>声明的是受保护的构造函数，但是这并不妨碍派生类调用它。从C++17开始情况发生了变化，类<code class="calibre10">DerivedData</code>变成了一个聚合类型，以至于<code class="calibre10">DerivedData d{}</code>也跟着变成聚合类型的初始化，因为基类<code class="calibre10">BaseData</code>中的构造函数是受保护的关系，它不允许在聚合类型初始化中被调用，所以编译器无奈之下给出了一个编译错误。如果读者在更新开发环境到C++17标准的时候遇到了这样的问题，只需要为派生类提供一个默认构造函数即可。</p>

  <h2 id="OEBPS/Text/chapter015.html.nav_point_121" class="sigil_not_in_toc">15.4　禁止聚合类型使用用户声明的构造函数</h2>

  <p class="zw">在前面我们提到没有用户提供的构造函数是聚合类型的条件之一，但是请注意，用户提供的构造函数和用户声明的构造函数是有区别的，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
struct X {
  X() = default;
};

struct Y {
  Y() = delete;
};

int main() {
  std::cout &lt;&lt; std::boolalpha 
      &lt;&lt; "std::is_aggregate_v&lt;X&gt; : " &lt;&lt; std::is_aggregate_v&lt;X&gt; &lt;&lt; std::endl
      &lt;&lt; "std::is_aggregate_v&lt;Y&gt; : " &lt;&lt; std::is_aggregate_v&lt;Y&gt; &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">用C++17标准编译运行以上代码会输出：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::is_aggregate_v&lt;X&gt; : true
std::is_aggregate_v&lt;Y&gt; : true</code></pre>

  <p class="zw">由此可见，虽然类<code class="calibre10">X</code>和<code class="calibre10">Y</code>都有用户声明的构造函数，但是它们依旧是聚合类型。不过这就引出了一个问题，让我们将目光放在结构体<code class="calibre10">Y</code>上，因为它的默认构造函数被显式地删除了，所以该类型应该无法实例化对象，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">Y y1;     // 编译失败，使用了删除函数</code></pre>

  <p class="zw">但是作为聚合类型，我们却可以通过聚合初始化的方式将其实例化：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">Y y2{};   // 编译成功</code></pre>

  <p class="zw">编译成功的这个结果显然不是类型<code class="calibre10">Y</code>的设计者想看到的，而且这个问题很容易在真实的开发过程中被忽略，从而导致意想不到的结果。除了删除默认构造函数，将其列入私有访问中也会有同样的问题，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct Y {
private:
  Y() = default;
};

Y y1;        // 编译失败，构造函数为私有访问
y y2{};      // 编译成功</code></pre>

  <p class="zw">请注意，这里<code class="calibre10">Y() = default;</code>中的<code class="calibre10">= default</code>不能省略，否则<code class="calibre10">Y</code>会被识别为一个非聚合类型。</p>

  <p class="zw">为了避免以上问题的出现，在C++17标准中可以使用<code class="calibre10">explicit</code>说明符或者将<code class="calibre10">= default</code>声明到结构体外，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct X {
  explicit X() = default;
};

struct Y {
  Y();
};
Y::Y() = default;</code></pre>

  <p class="zw">这样一来，结构体<code class="calibre10">X</code>和<code class="calibre10">Y</code>被转变为非聚合类型，也就无法使用聚合初始化了。不过即使这样，还是没有解决相同类型不同实例化方式表现不一致的尴尬问题，所以在C++20标准中禁止聚合类型使用用户声明的构造函数，这种处理方式让所有的情况保持一致，是最为简单明确的方法。同样是本节中的第一段代码示例，用C++20环境编译的输出结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::is_aggregate_v&lt;X&gt; : false
std::is_aggregate_v&lt;Y&gt; : false</code></pre>

  <p class="zw">值得注意的是，这个规则的修改会改变一些旧代码的意义，比如我们经常用到的禁止复制构造的方法：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct X {
  std::string s;
  std::vector&lt;int&gt; v;
  X() = default;
  X(const X&amp;) = delete;
  X(X&amp;&amp;) = default;
};</code></pre>

  <p class="zw">上面这段代码中结构体<code class="calibre10">X</code>在C++17标准中是聚合类型，所以可以使用聚合类型初始化对象。但是升级编译环境到C++20标准会使<code class="calibre10">X</code>转变为非聚合对象，从而造成无法通过编译的问题。一个可行的解决方案是，不要直接使用<code class="calibre10">= delete;</code>来删除复制构造函数，而是通过加入或者继承一个不可复制构造的类型来实现类型的不可复制，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct X {
  std::string s;
  std::vector&lt;int&gt; v;
  [[no_unique_address]] NonCopyable nc;
};

// 或者

struct X : NonCopyable {
  std::string s;
  std::vector&lt;int&gt; v;
};</code></pre>

  <p class="zw">这种做法能让代码看起来更加简洁，所以我们往往会被推荐这样做。</p>

  <h2 id="OEBPS/Text/chapter015.html.nav_point_122" class="sigil_not_in_toc">15.5　使用带小括号的列表初始化聚合类型对象</h2>

  <p class="zw">通过15.2节，我们知道对于一个聚合类型可以使用带大括号的列表对其进行初始化，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct X {
  int i;
  float f;
};

X x{ 11, 7.0f };</code></pre>

  <p class="zw">如果将上面初始化代码中的大括号修改为小括号，C++17标准的编译器会给出无法匹配到对应构造函数<code class="calibre10">X::X(int, float)</code>的错误，这说明小括号会尝试调用其构造函数。这一点在C++20标准中做出了修改，它规定对于聚合类型对象的初始化可以用小括号列表来完成，其最终结果与大括号列表相同。所以以上代码可以修改为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">X x( 11, 7.0f );</code></pre>

  <p class="zw">另外，前面的章节曾提到过带大括号的列表初始化是不支持缩窄转换的，但是带小括号的列表初始化却是支持缩窄转换的，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct X {
  int i;
  short f;
};

X x1{ 11, 7.0 }; // 编译失败，7.0从double转换到short是缩窄转换
X x2( 11, 7.0 ); // 编译成功</code></pre>

  <p class="zw">需要注意的是，到目前为止该特性只在GCC中得到支持，而CLang和MSVC都还没有支持该特性。</p>

  <h2 id="OEBPS/Text/chapter015.html.nav_point_123" class="sigil_not_in_toc">15.6　总结</h2>

  <p class="zw">虽然本章的内容不多且较为容易理解，但它却是一个比较重要的章节。因为扩展的聚合类型改版了原本聚合类型的定义，这就导致了一些兼容性问题，这种情况在C++新特性中并不多见。如果不能牢固地掌握新定义的知识点，很容易导致代码无法通过编译，更严重的可能是导致代码运行出现逻辑错误，类似这种Bug又往往难以定位，所以对于扩展的聚合类型我们尤其需要重视起来。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter015.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter016.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter016.html.nav_point_124" class="not-in-toc">第16章　override和final说明符（C++11）</h1>

  <h2 id="OEBPS/Text/chapter016.html.nav_point_125" class="sigil_not_in_toc">16.1　重写、重载和隐藏</h2>

  <p class="zw">重写（override）、重载（overload）和隐藏（overwrite）在C++中是3个完全不同的概念，但是在平时的工作交流中，我发现有很多C++程序员对它们的概念模糊不清，经常误用或者混用这3个概念，所以在说明override说明符之前，我们先梳理一下三者的区别。</p>

  <p class="zw">1．重写（override）的意思更接近覆盖，在C++中是指派生类覆盖了基类的虚函数，这里的覆盖必须满足有相同的函数签名和返回类型，也就是说有相同的函数名、形参列表以及返回类型。</p>

  <p class="zw">2．重载（overload），它通常是指在同一个类中有两个或者两个以上函数，它们的函数名相同，但是函数签名不同，也就是说有不同的形参。这种情况在类的构造函数中最容易看到，为了让类更方便使用，我们经常会重载多个构造函数。</p>

  <p class="zw">3．隐藏（overwrite）的概念也十分容易与上面的概念混淆。隐藏是指基类成员函数，无论它是否为虚函数，当派生类出现同名函数时，如果派生类函数签名不同于基类函数，则基类函数会被隐藏。如果派生类函数签名与基类函数相同，则需要确定基类函数是否为虚函数，如果是虚函数，则这里的概念就是重写；否则基类函数也会被隐藏。另外，如果还想使用基类函数，可以使用<code class="calibre10">using</code>关键字将其引入派生类。</p>

  <h2 id="OEBPS/Text/chapter016.html.nav_point_126" class="sigil_not_in_toc">16.2　重写引发的问题</h2>

  <p class="zw">在编码过程中，重写虚函数很容易出现错误，原因是C++语法对重写的要求很高，稍不注意就会无法重写基类虚函数。更糟糕的是，即使我们写错了代码，编译器也可能不会提示任何错误信息，直到程序编译成功后，运行测试才会发现其中的逻辑问题，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class Base {
public:
  virtual void some_func() {}
  virtual void foo(int x) {}
  virtual void bar() const {}
  void baz() {}
};

class Derived : public Base {
public:
  virtual void sone_func() {}
  virtual void foo(int &amp;x) {}
  virtual void bar() {}
  virtual void baz() {}
};</code></pre>

  <p class="zw">以上代码可以编译成功，但是派生类<code class="calibre10">Derived</code>的4个函数都没有触发重写操作。第一个派生类虚函数<code class="calibre10">sone_func</code>的函数名与基类虚函数<code class="calibre10">some_func</code>不同，所以它不是重写。第二个派生类虚函数<code class="calibre10">foo(int &amp;x)</code>的形参列表与基类虚函数<code class="calibre10">foo(int x)</code>不同，所以同样不是重写。第三个派生类虚函数<code class="calibre10">bar()</code>相对于基类虚函数少了常量属性，所以不是重写。最后的基类成员函数<code class="calibre10">baz</code>根本不是虚函数，所以派生类的<code class="calibre10">baz</code>函数也不是重写。</p>

  <h2 id="OEBPS/Text/chapter016.html.nav_point_127" class="sigil_not_in_toc">16.3　使用override说明符</h2>

  <p class="zw">可以看到重写如此容易出错，光靠人力排查避免出错是很困难的，尤其当类的继承关系非常复杂的时候。所以C++11标准提供了一个非常实用的override说明符，这个说明符必须放到虚函数的尾部，它明确告诉编译器这个虚函数需要覆盖基类的虚函数，一旦编译器发现该虚函数不符合重写规则，就会给出错误提示。</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class Base {
public:
  virtual void some_func() {}
  virtual void foo(int x) {}
  virtual void bar() const {}
  void baz() {}
};

class Derived : public Base {
public:
  virtual void sone_func() override {}
  virtual void foo(int &amp;x) override {}
  virtual void bar() override {}
  virtual void baz() override {}
};</code></pre>

  <p class="zw">上面这段代码示例针对16.2节中的示例在派生类虚函数尾部都加上了override说明符，编译后编译器给出了4条错误信息，明确指出这4个函数都无法重写。如此一来，我们可以轻松地找到代码中的错误，而不必等到运行时再慢慢调试排查。override说明符不仅为派生类的编写者提供了方便，对于基类编写者同样也有帮助。假设某个基类需要修改虚函数的形参以确保满足新需求，那么在override的帮助下，基类编写者可以轻松地发现修改基类虚函数的代价。如果没有override说明符，则修改基类虚函数将面临很大的风险，因为编译器不会给出错误提示，我们只能靠测试来检查问题所在。</p>

  <h2 id="OEBPS/Text/chapter016.html.nav_point_128" class="sigil_not_in_toc">16.4　使用final说明符</h2>

  <p class="zw">在C++中，我们可以为基类声明纯虚函数来迫使派生类继承并且重写这个纯虚函数。但是一直以来，C++标准并没有提供一种方法来阻止派生类去继承基类的虚函数。C++11标准引入final说明符解决了上述问题，它告诉编译器该虚函数不能被派生类重写。final说明符用法和override说明符相同，需要声明在虚函数的尾部。</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class Base {
public:
  virtual void foo(int x) {}

};

class Derived : public Base {
public:
  void foo(int x) final {};
};

class Derived2 : public Derived {
public:
  void foo(int x) {};
};</code></pre>

  <p class="zw">在上面的代码中，因为基类<code class="calibre10">Derived</code>的虚函数<code class="calibre10">foo</code>声明为final，所以派生类<code class="calibre10">Derived2</code>重写<code class="calibre10">foo</code>函数的时候编译器会给出错误提示。请注意final和override说明符的一点区别，final说明符可以修饰最底层基类的虚函数而override则不行，所以在这个例子中final可以声明基类<code class="calibre10">Base</code>的虚函数<code class="calibre10">foo</code>，只不过我们通常不会这样做。</p>

  <p class="zw">有时候，override和final会同时出现。这种情况通常是由中间派生类继承基类后，希望后续其他派生类不能修改本类虚函数的行为而产生的，举个例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class Base {
public:
  virtual void log(const char *) const {…}
  virtual void foo(int x) {}

};

class BaseWithFileLog : public Base {
public:
  virtual void log(const char *) const override final {…}
};

class Derived : public BaseWithFileLog {
public:
  void foo(int x) {};
};</code></pre>

  <p class="zw">在上面这段代码中基类<code class="calibre10">Base</code>有一个虚函数<code class="calibre10">log</code>，它将日志打印到标准输出。但是为了能更好地保存日志，我们写了一个派生类<code class="calibre10">BaseWithFileLog</code>，重写了<code class="calibre10">log</code>函数将日志写入文件中。为了保证重写不会出现错误，并且后来的继承者不要改变日志的行为，为<code class="calibre10">log</code>函数添加了override和final说明符。这样一来，后续的派生类<code class="calibre10">Derived</code>只能重写虚函数<code class="calibre10">foo</code>而无法修改日志函数，保证了日志的一致。</p>

  <p class="zw">最后要说明的是，final说明符不仅能声明虚函数，还可以声明类。如果在类定义的时候声明了final，那么这个类将不能作为基类被其他类继承，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class Base final {
public:
  virtual void foo(int x) {}

};

class Derived : public Base {
public:
  void foo(int x) {};
};</code></pre>

  <p class="zw">在上面的代码中，由于<code class="calibre10">Base</code>被声明为final，因此<code class="calibre10">Derived</code>继承<code class="calibre10">Base</code>会在编译时出错。</p>

  <h2 id="OEBPS/Text/chapter016.html.nav_point_129" class="sigil_not_in_toc">16.5　override和final说明符的特别之处</h2>

  <p class="zw">为了和过去的C++代码保持兼容，增加保留的关键字需要十分谨慎。因为一旦增加了某个关键字，过去的代码就可能面临大量的修改。所以在C++11标准中，override和final并没有被作为保留的关键字，其中override只有在虚函数尾部才有意义，而final只有在虚函数尾部以及类声明的时候才有意义，因此以下代码仍然可以编译通过：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class X {
public:
  void override() {}
  void final() {}
};</code></pre>

  <p class="zw">不过，为了避免不必要的麻烦，建议读者不要将它们作为标识符来使用。</p>

  <h2 id="OEBPS/Text/chapter016.html.nav_point_130" class="sigil_not_in_toc">16.6　总结</h2>

  <p class="zw">本章介绍了override和final说明符，虽然它们的语法十分简单，但是却非常实用。尤其是override说明符，它指明类的成员函数必须是一个重写函数，要求编译器检查派生类中的虚函数确实重写了基类中的函数，否则就会引发一个编译错误。通常来说，我们应该用override说明有重写意图的虚函数，以免由于粗心大意造成不必要的错误。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter016.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter017.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter017.html.nav_point_131" class="not-in-toc">第17章　基于范围的for循环（C++11 C++17 C++20）</h1>

  <h2 id="OEBPS/Text/chapter017.html.nav_point_132" class="sigil_not_in_toc">17.1　烦琐的容器遍历</h2>

  <p class="zw">通常遍历一个容器里的所有元素会用到<code class="calibre10">for</code>循环和迭代器，在大多数情况下我们并不关心迭代器本身，而且在循环中使用迭代器的模式往往十分固定——获取开始的迭代器、不断更新当前迭代器、将当前迭代器与结束的迭代器作比较以及解引用当前迭代器获取我们真正关心的元素：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::map&lt;int, std::string&gt; index_map{ {1, "hello"}, {2, "world"}, {3, "!"} };

std::map&lt;int, std::string&gt;::iterator it = index_map.begin();
for (; it != index_map.end(); ++it) {
  std::cout &lt;&lt; "key=" &lt;&lt; (*it).first &lt;&lt; ", value=" &lt;&lt; (*it).second &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">从上面的代码可以看到，为了输出<code class="calibre10">index_map</code>中的内容不得不编写很多关于迭代器的代码，但迭代器本身并不是业务逻辑所关心的部分。对于这个问题的一个可行的解决方案是使用标准库提供的<code class="calibre10">std::for_each</code>函数，使用该函数只需要提供容器开始和结束的迭代器以及执行函数或者仿函数即可，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::map&lt;int, std::string&gt; index_map{ {1, "hello"}, {2, "world"}, {3, "!"} };

void print(std::map&lt;int, std::string&gt;::const_reference e)
{
  std::cout &lt;&lt; "key=" &lt;&lt; e.first &lt;&lt; ", value=" &lt;&lt; e.second &lt;&lt; std::endl;
}

std::for_each(index_map.begin(), index_map.end(), print);</code></pre>

  <p class="zw">相对于上一段代码，这段代码使用<code class="calibre10">std::for_each</code>遍历容器比直接使用迭代器的方法要简洁许多。实际上单纯的迭代器遍历操作完全可以交给编译器来完成，这样能让程序员专注于业务代码而非迭代器的循环。</p>

  <h2 id="OEBPS/Text/chapter017.html.nav_point_133" class="sigil_not_in_toc">17.2　基于范围的for循环语法</h2>

  <p class="zw">C++11标准引入了基于范围的<code class="calibre10">for</code>循环特性，该特性隐藏了迭代器的初始化和更新过程，让程序员只需要关心遍历对象本身，其语法也比传统<code class="calibre10">for</code>循环简洁很多：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">for ( range_declaration : range_expression ) loop_statement</code></pre>

  <p class="zw">基于范围的<code class="calibre10">for</code>循环不需要初始化语句、条件表达式以及更新表达式，取而代之的是一个范围声明和一个范围表达式。其中范围声明是一个变量的声明，其类型是范围表达式中元素的类型或者元素类型的引用。而范围表达式可以是数组或对象，对象必须满足以下2个条件中的任意一个。</p>

  <p class="zw">1．对象类型定义了<code class="calibre10">begin</code>和<code class="calibre10">end</code>成员函数。</p>

  <p class="zw">2．定义了以对象类型为参数的<code class="calibre10">begin</code>和<code class="calibre10">end</code>普通函数。</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;

std::map&lt;int, std::string&gt; index_map{ {1, "hello"}, {2, "world"}, {3, "!"} };
int int_array[] = { 0, 1, 2, 3, 4, 5 };

int main()
{
  for (const auto &amp;e : index_map) {
       std::cout &lt;&lt; "key=" &lt;&lt; e.first &lt;&lt; ", value=" &lt;&lt; e.second &lt;&lt; std::endl;
  }

  for (auto e : int_array) {
       std::cout &lt;&lt; e &lt;&lt; std::endl;
  }
}</code></pre>

  <p class="zw">以上代码通过基于范围的<code class="calibre10">for</code>循环遍历数组和标准库的<code class="calibre10">map</code>对象。其中<code class="calibre10">const auto &amp;e</code>和<code class="calibre10">auto e</code>是范围声明，而<code class="calibre10">index_map</code>和<code class="calibre10">int_array</code>是范围表达式。为了让范围声明更加简洁，推荐使用<code class="calibre10">auto</code>占位符。当然，这里使用<code class="calibre10">std::map&lt;int, std::string&gt;:: value_type</code>和<code class="calibre10">int</code>来替换<code class="calibre10">auto</code>也是可以的。值得注意的是，代码使用了两种形式的范围声明，前者是容器或者数组中元素的引用，而后者是容器或者数组中元素的值。一般来说，我们希望对于复杂的对象使用引用，而对于基础类型使用值，因为这样能够减少内存的复制。如果不会在循环过程中修改引用对象，那么推荐在范围声明中加上<code class="calibre10">const</code>限定符以帮助编译器生成更加高效的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;vector&gt;
struct X
{
  X() { std::cout &lt;&lt; "default ctor" &lt;&lt; std::endl; }
  X(const X&amp; other) {
       std::cout &lt;&lt; "copy ctor" &lt;&lt; std::endl;
  }
};

int main()
{
  std::vector&lt;X&gt; x(10);
  std::cout &lt;&lt; "for (auto n : x)" &lt;&lt; std::endl;
  for (auto n : x) {
  }
  std::cout &lt;&lt; "for (const auto &amp;n : x)" &lt;&lt; std::endl;
  for (const auto &amp;n : x) {
  }
}</code></pre>

  <p class="zw">编译运行上面这段代码会发现<code class="calibre10">for(auto n : x)</code>的循环调用10次复制构造函数，如果类<code class="calibre10">X</code>的数据量比较大且容器里的元素很多，那么这种复制的代价是无法接受的。而<code class="calibre10">for(const auto &amp;n : x)</code>则解决了这个问题，整个循环过程没有任何的数据复制。</p>

  <h2 id="OEBPS/Text/chapter017.html.nav_point_134" class="sigil_not_in_toc">17.3　begin和end函数不必返回相同类型</h2>

  <p class="zw">在C++11标准中基于范围的<code class="calibre10">for</code>循环相当于以下伪代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">{
  auto &amp;&amp; __range = range_expression;
  for (auto __begin = begin_expr, __end = end_expr; __begin != __end; ++__begin) {
       range_declaration = *__begin;
       loop_statement
  }
}</code></pre>

  <p class="zw">其中<code class="calibre10">begin_expr</code>和<code class="calibre10">end_expr</code>可能是<code class="calibre10">__range.begin()</code>和<code class="calibre10">__range.end()</code>，或者是<code class="calibre10">begin(__range)</code>和<code class="calibre10">end(__range)</code>。当然，如果<code class="calibre10">__range</code>是一个数组指针，那么还可能是<code class="calibre10">__range</code>和<code class="calibre10">__range+__count</code>（其中<code class="calibre10">__count</code>是数组元素个数）。这段伪代码有一个特点，它要求<code class="calibre10">begin_expr</code>和<code class="calibre10">end_expr</code>返回的必须是同类型的对象。但实际上这种约束完全没有必要，只要<code class="calibre10">__begin != __end</code>能返回一个有效的布尔值即可，所以C++17标准对基于范围的<code class="calibre10">for</code>循环的实现进行了改进，伪代码如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">{
  auto &amp;&amp; __range = range_expression;
  auto __begin = begin_expr;
  auto __end = end_expr;
  for (; __begin != __end; ++__begin) {
       range_declaration = *__begin;
       loop_statement
  }
}</code></pre>

  <p class="zw">可以看到，以上伪代码将<code class="calibre10">__begin</code>和<code class="calibre10">__end</code>分离到两条不同的语句，不再要求它们是相同类型。</p>

  <h2 id="OEBPS/Text/chapter017.html.nav_point_135" class="sigil_not_in_toc">17.4　临时范围表达式的陷阱</h2>

  <p class="zw">读者是否注意到了，无论是C++11还是C++17标准，基于范围的for循环伪代码都是由以下这句代码开始的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto &amp;&amp; __range = range_expression;</code></pre>

  <p class="zw">理解了右值引用的读者应该敏锐地发现了这里存在的陷阱<code class="calibre10">auto &amp;&amp;</code>。对于这个赋值表达式来说，如果<code class="calibre10">range_expression</code>是一个纯右值，那么右值引用会扩展其生命周期，保证其整个<code class="calibre10">for</code>循环过程中访问的安全性。但如果<code class="calibre10">range_ expression</code>是一个泛左值，那结果可就不确定了，参考以下代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class T {
  std::vector&lt;int&gt; data_;
public:
  std::vector&lt;int&gt;&amp; items() { return data_; }
  // …
};

T foo() 
{
    T t;
    return t;
}
for (auto&amp; x : foo().items()) {} // 未定义行为</code></pre>

  <p class="zw">请注意，这里的<code class="calibre10">for</code>循环会引发一个未定义的行为，因为<code class="calibre10">foo().items()</code>返回的是一个泛左值类型<code class="calibre10">std::vector&lt;int&gt;&amp;</code>，于是右值引用无法扩展其生命周期，导致<code class="calibre10">for</code>循环访问无效对象并造成未定义行为。对于这种情况请读者务必小心谨慎，将数据复制出来是一种解决方法：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">T thing = foo(); 
for (auto &amp; x :thing.items()) {}</code></pre>

  <p class="zw">在C++20标准中，基于范围的<code class="calibre10">for</code>循环增加了对初始化语句的支持，所以在C++20的环境下我们可以将上面的代码简化为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">for (T thing = foo(); auto &amp; x :thing.items()) {}</code></pre>

  <h2 id="OEBPS/Text/chapter017.html.nav_point_136" class="sigil_not_in_toc">17.5　实现一个支持基于范围的for循环的类</h2>

  <p class="zw">前面用大量篇幅介绍了使用基于范围的<code class="calibre10">for</code>循环遍历数组和标准容器的方法，实际上我们还可以让自定义类型支持基于范围的<code class="calibre10">for</code>循环。要完成这样的类型必须先实现一个类似标准库中的迭代器。</p>

  <p class="zw">1．该类型必须有一组和其类型相关的<code class="calibre10">begin</code>和<code class="calibre10">end</code>函数，它们可以是类型的成员函数，也可以是独立函数。</p>

  <p class="zw">2．<code class="calibre10">begin</code>和<code class="calibre10">end</code>函数需要返回一组类似迭代器的对象，并且这组对象必须支持<code class="calibre10">operator *</code>、<code class="calibre10">operator !=</code>和<code class="calibre10">operator ++</code>运算符函数。</p>

  <p class="zw">请注意，这里的<code class="calibre10">operator ++</code>应该是一个前缀版本，它需要通过声明一个不带形参的<code class="calibre10">operator ++</code>运算符函数来完成。下面是一个完整的例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

class IntIter {
public:
  IntIter(int *p) : p_(p) {}
  bool operator!=(const IntIter&amp; other)
  {
       return (p_ != other.p_);
  }

  const IntIter&amp; operator++()
  {
       p_++;
       return *this;
  }

  int operator*() const
  {
       return *p_;
  }
private:
  int *p_;
};

template&lt;unsigned int fix_size&gt;
class FixIntVector {
public:
  FixIntVector(std::initializer_list&lt;int&gt; init_list)
  {
       int *cur = data_;
       for (auto e : init_list) {
            *cur = e;
            cur++;
       }
  }

  IntIter begin()
  {
       return IntIter(data_);
  }

  IntIter end()
  {
       return IntIter(data_ + fix_size);
  }
private:
  int data_[fix_size]{0};
};

int main()
{
  FixIntVector&lt;10&gt; fix_int_vector {1, 3, 5, 7, 9};
  for (auto e : fix_int_vector)
  {
       std::cout &lt;&lt; e &lt;&lt; std::endl;
  }
}</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">FixIntVector</code>是存储<code class="calibre10">int</code>类型数组的类模板，类<code class="calibre10">IntIter</code>是<code class="calibre10">FixIntVector</code>的迭代器。在<code class="calibre10">FixIntVector</code>中实现了成员函数<code class="calibre10">begin</code>和<code class="calibre10">end</code>，它们返回了一组迭代器，分别表示数组的开始和结束位置。类<code class="calibre10">IntIter</code>本身实现了<code class="calibre10">operator *</code>、<code class="calibre10">operator !=</code>和<code class="calibre10">operator ++</code>运算符函数，其中<code class="calibre10">operator *</code>用于编译器生成解引用代码，<code class="calibre10">operator !=</code>用于生成循环条件代码，而前缀版本的<code class="calibre10">operator ++</code>用于更新迭代器。</p>

  <p class="zw">请注意，这里使用成员函数的方式实现了<code class="calibre10">begin</code>和<code class="calibre10">end</code>，但有时候需要遍历的容器可能是第三方提供的代码。这种情况下我们可以实现一组独立版本的<code class="calibre10">begin</code>和<code class="calibre10">end</code>函数，这样做的优点是能在不修改第三方代码的情况下支持基于范围的<code class="calibre10">for</code>循环。</p>

  <h2 id="OEBPS/Text/chapter017.html.nav_point_137" class="sigil_not_in_toc">17.6　总结</h2>

  <p class="zw">基于范围的<code class="calibre10">for</code>循环很好地解决了遍历容器过于烦琐的问题，它自动生成迭代器的遍历代码并将其隐藏于后台。强烈建议读者使用基于范围的<code class="calibre10">for</code>循环来处理单纯遍历容器的操作。当然，使用时需注意临时范围表达式结果的生命周期问题。另外，对于在遍历容器过程中需要修改容器的需求，还是需要使用迭代器来处理。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter017.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter018.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter018.html.nav_point_138" class="not-in-toc">第18章　支持初始化语句的if和switch（C++17）</h1>

  <h2 id="OEBPS/Text/chapter018.html.nav_point_139" class="sigil_not_in_toc">18.1 支持初始化语句的if</h2>

  <p class="zw">在C++17标准中，<code class="calibre10">if</code>控制结构可以在执行条件语句之前先执行一个初始化语句。语法如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">if (init; condition) {}</code></pre>

  <p class="zw">其中<code class="calibre10">init</code>是初始化语句，<code class="calibre10">condition</code>是条件语句，它们之间使用分号分隔。允许初始化语句的<code class="calibre10">if</code>结构让以下代码成为可能：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
bool foo()
{
  return true;
}
int main()
{
  if (bool b = foo(); b) {
       std::cout &lt;&lt; std::boolalpha &lt;&lt; "good! foo()=" &lt;&lt; b &lt;&lt; std::endl;
  }
}</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">bool b = foo()</code>是一个初始化语句，在初始化语句中声明的变量<code class="calibre10">b</code>能够在<code class="calibre10">if</code>的作用域继续使用。事实上，该变量的生命周期会一直伴随整个<code class="calibre10">if</code>结构，包括<code class="calibre10">else if</code>和<code class="calibre10">else</code>部分。</p>

  <p class="zw"><code class="calibre10">if</code>初始化语句中声明的变量拥有和整个<code class="calibre10">if</code>结构一样长的声明周期，所以前面的代码可以等价于：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
bool foo()
{
  return true;
}
int main()
{
  {
       bool b = foo();
       if (b) {
            std::cout &lt;&lt; std::boolalpha &lt;&lt; "good! foo()=" &lt;&lt; b &lt;&lt; std::endl;
       }
  }
}</code></pre>

  <p class="zw">当然，我们还可以在<code class="calibre10">if</code>结构中添加<code class="calibre10">else</code>部分：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">  if (bool b = foo(); b) {
       std::cout &lt;&lt; std::boolalpha &lt;&lt; "good! foo()=" &lt;&lt; b &lt;&lt; std::endl;
  }
  else {
       std::cout &lt;&lt; std::boolalpha &lt;&lt; "bad! foo()=" &lt;&lt; b &lt;&lt; std::endl;
  }</code></pre>

  <p class="zw">在<code class="calibre10">if</code>结构中引入<code class="calibre10">else if</code>后，情况会稍微变得复杂一点，因为在<code class="calibre10">else if</code>条件语句之前也可以使用初始化语句：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
bool foo()
{
  return false;
}
bool bar()
{
  return true;
}
int main()
{
  if (bool b = foo(); b) {
       std::cout &lt;&lt; std::boolalpha &lt;&lt; "foo()=" &lt;&lt; b &lt;&lt; std::endl;
  }
  else if (bool b1 = bar(); b1) {
       std::cout &lt;&lt; std::boolalpha 
            &lt;&lt; "foo()=" &lt;&lt; b
            &lt;&lt; ", bar()=" &lt;&lt; b1 &lt;&lt; std::endl;
  }
}</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">if</code>和<code class="calibre10">else if</code>都有初始化语句，它们分别初始化变量<code class="calibre10">b</code>和<code class="calibre10">b1</code>并且在各自条件成立的作用域内执行了日志输出。值得注意的是，<code class="calibre10">b</code>和<code class="calibre10">b1</code>的生命周期并不相同。其中变量<code class="calibre10">b</code>的生命周期会贯穿整个<code class="calibre10">if</code>结构（包括<code class="calibre10">else if</code>），可以看到在<code class="calibre10">else if</code>中也能引用变量<code class="calibre10">b</code>。但是<code class="calibre10">b1</code>则不同，它的生命周期只存在于<code class="calibre10">else if</code>以及后续存在的<code class="calibre10">else if</code>和<code class="calibre10">else</code>语句，而无法在之前的<code class="calibre10">if</code>中使用，等价于：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">{
  bool b = foo();
  if (b) {
       std::cout &lt;&lt; std::boolalpha &lt;&lt; "foo()=" &lt;&lt; b &lt;&lt; std::endl;
  }
  else {
       bool b1 = bar();
       if (b1) {
            std::cout &lt;&lt; std::boolalpha
                 &lt;&lt; "foo()=" &lt;&lt; b
                 &lt;&lt; ", bar()=" &lt;&lt; b1 &lt;&lt; std::endl;
       }
  }
}</code></pre>

  <p class="zw">因为<code class="calibre10">if</code>初始化语句声明的变量会贯穿整个<code class="calibre10">if</code>结构，所以我们可以利用该特性对整个<code class="calibre10">if</code>结构加锁，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;mutex&gt;
std::mutex mx;
bool shared_flag = true;
int main()
{
  if (std::lock_guard&lt;std::mutex&gt; lock(mx); shared_flag) { 
       shared_flag = false;
  }
}</code></pre>

  <p class="zw">继续扩展思路，从本质上来说初始化语句就是在执行条件判断之前先执行了一个语句，并且语句中声明的变量将拥有与<code class="calibre10">if</code>结构相同的生命周期。所以我们在代码中没有必要一定在初始化语句中初始化判断条件的变量，如<code class="calibre10">if(std::lock_guard &lt;std::mutex&gt; lock(mx); shared_flag)</code>，初始化语句并没有初始化条件判断的变量<code class="calibre10">shared_flag</code>。类似的例子还有：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;cstdio&gt;
#include &lt;string&gt;
int main()
{
  std::string str;
  if (char buf[10]{0}; std::fgets(buf, 10, stdin)) {
       str += buf; 
  }
}</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">if</code>的初始化语句只声明了一个数组<code class="calibre10">buf</code>并将<code class="calibre10">buf</code>作为实参传入<code class="calibre10">std::fgets</code>函数，而真正做条件判断的是<code class="calibre10">std::fgets</code>函数返回值。</p>

  <h2 id="OEBPS/Text/chapter018.html.nav_point_140" class="sigil_not_in_toc">18.2 支持初始化语句的switch</h2>

  <p class="zw">和<code class="calibre10">if</code>控制结构一样，<code class="calibre10">switch</code>在通过条件判断确定执行的代码分支之前也可以接受一个初始化语句。不同的是，<code class="calibre10">switch</code>结构不存在<code class="calibre10">else</code>和<code class="calibre10">else if</code>的情况，所以语法更加简单。这里以<code class="calibre10">std::condition_variable</code>为例，其成员函数<code class="calibre10">wait_for</code>需要一个<code class="calibre10">std:: unique_lock&lt;std::mutex&gt;&amp;</code>类型的实参，于是在<code class="calibre10">switch</code>的初始化语句中可以构造一个<code class="calibre10">std::unique_lock&lt;std::mutex&gt;</code>类型的对象，具体代码如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;condition_variable&gt;
#include &lt;chrono&gt;
using namespace std::chrono_literals;
std::condition_variable cv;
std::mutex cv_m;
int main()
{
  switch (std::unique_lock&lt;std::mutex&gt; lk(cv_m); cv.wait_for(lk, 100ms))
  {
  case std::cv_status::timeout:
       break;
  case std::cv_status::no_timeout:
       break;
  }
}</code></pre>

  <p class="zw"><code class="calibre10">switch</code>初始化语句声明的变量的生命周期会贯穿整个<code class="calibre10">switch</code>结构，这一点和<code class="calibre10">if</code>也相同，所以变量<code class="calibre10">lk</code>能够引用到任何一个<code class="calibre10">case</code>的分支中。</p>

  <h2 id="OEBPS/Text/chapter018.html.nav_point_141" class="sigil_not_in_toc">18.3 总结</h2>

  <p class="zw">读者应该已经注意到，所谓带初始化语句的if和switch的新特性只不过是一颗语法糖而已，其带来的功能可以轻易地用等价代码代替，但是C++委员会还是决定将该特性引入C++17标准。其中的一个原因是该特性并非是全新的语法，在<code class="calibre10">for</code>循环中已经存在类似的语法了，而且新增语法也不会增加语法的复杂度，所以无论是学习成本还是使用成本都是很低的。另外，使用该特性的等价代码并非是一种好的解决方案，因为增加大量的大括号和缩进并不利于代码的阅读和维护；而如果不增加大括号和缩进又会导致初始化代码声明的变量入侵<code class="calibre10">if</code>和<code class="calibre10">switch</code>以外的作用域，如此一来在代码整理和重构的时候可能会出现问题。因此将初始化语句和条件语句写在一行确实有助于代码阅读和整理，与此同时也能减少无谓的大括号和缩进，增加代码的可读性和可维护性。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter018.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter019.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter019.html.nav_point_142" class="not-in-toc">第19章　static_assert声明</h1>

  <h2 id="OEBPS/Text/chapter019.html.nav_point_143" class="sigil_not_in_toc">19.1　运行时断言</h2>

  <p class="zw">在静态断言出现以前，我们使用的是运行时断言，只有程序运行起来之后才有可能触发它。通常情况下运行时断言只会在Debug模式下使用，因为断言的行为比较粗暴，它会直接显示错误信息并终止程序。在Release版本中，我们通常会忽略断言（头文件<code class="calibre10">cassert</code>已经通过宏<code class="calibre10">NDEBUG</code>对Debug和Release版本做了区分处理，我们可以直接使用<code class="calibre10">assert</code>）。还有一点需要注意，断言不能代替程序中的错误检查，它只应该出现在需要表达式返回<code class="calibre10">true</code>的位置，例如：算术表达式的除数不能为0，分配内存的大小必须大于0等。相反，如果表达式中涉及外部输入，则不应该依赖断言，例如客户输入、服务端返回等：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void* resize_buffer(void* buffer, int new_size)
{
    assert(buffer != nullptr);           // OK，用assert检查函数参数
    assert(new_size &gt; 0);
    assert(new_size &lt;= MAX_BUFFER_SIZE);
    …
}

bool get_user_input(char c)
{
    assert(c == '\0x0d');                // 不合适，assert不应该用于检查外部输入
    …
}</code></pre>

  <p class="zw">在上面这段代码中，我们对函数<code class="calibre10">resize_buffer</code>的形参<code class="calibre10">buffer</code>和<code class="calibre10">new_size</code>进行了断言，显然作为一个重新分配内存的函数，这两个参数必须是合法的。建议一个断言处理一个判别式，这样一来当断言发生的时候能迅速定位到问题所在。如果写成<code class="calibre10">assert((buffer != nullptr) &amp;&amp; (new_size &gt; 0) &amp;&amp; (new_size &lt;= MAX_BUFFER_SIZE))</code>，则当断言发生的时候，我们还是无法马上确定问题。而函数<code class="calibre10">get_user_input</code>就不应该使用断言检查参数了，因为用户输入的字符可能是各种各样的。</p>

  <h2 id="OEBPS/Text/chapter019.html.nav_point_144" class="sigil_not_in_toc">19.2　静态断言的需求</h2>

  <p class="zw">虽然运行时断言可以满足一部分需求，但是它有一个缺点就是必须让程序运行到断言代码的位置才会触发断言。如果想在模板实例化的时候对模板实参进行约束，这种断言是无法办到的。我们需要一个能在编译阶段就给出断言的方法。可惜在C++11标准之前，没有一个标准方法来达到这个目的，我们需要利用其他特性来模拟。下面给出几个可行的方案：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#define STATIC_ASSERT_CONCAT_IMP(x, y) x ## y
#define STATIC_ASSERT_CONCAT(x, y) \
    STATIC_ASSERT_CONCAT_IMP(x, y)

// 方案1
#define STATIC_ASSERT(expr)                 \
    do {                                    \
        char STATIC_ASSERT_CONCAT(          \
            static_assert_var, __COUNTER__) \
            [(expr) != 0 ? 1 : -1];         \
    } while (0)

template&lt;bool&gt;
struct static_assert_st;
template&lt;&gt;
struct static_assert_st&lt;true&gt; {};

// 方案2
#define STATIC_ASSERT2(expr)    \
    static_assert_st&lt;(expr) != 0&gt;()

// 方案3
#define STATIC_ASSERT3(expr)        \
    static_assert_st&lt;(expr) != 0&gt;   \
    STATIC_ASSERT_CONCAT(           \
    static_assert_var, __COUNTER__)</code></pre>

  <p class="zw">以上代码的方案1，利用的技巧是数组的大小不能为负值，当<code class="calibre10">expr</code>表达式返回结果为<code class="calibre10">false</code>的时候，条件表达式求值为−1，这样就导致数组大小为−1，自然就会引发编译失败。方案2和方案3则是利用了C++模板特化的特性，当模板实参为<code class="calibre10">true</code>的时候，编译器能找到特化版本的定义。但当模板参数为false的时候，编译器无法找到相应的特化定义，从而编译失败。方案2和方案3的区别在于，方案2会构造临时对象，这让它无法出现在类和结构体的定义当中。而方案3则声明了一个变量，可以出现在结构体和类的定义中，但是它最大的问题是会改变结构体和类的内存布局。总而言之，虽然我们可以在一定程度上模拟静态断言，但是这些方案并不完美。</p>

  <h2 id="OEBPS/Text/chapter019.html.nav_point_145" class="sigil_not_in_toc">19.3　静态断言</h2>

  <p class="zw"><code class="calibre10">static_assert</code>声明是C++11标准引入的特性，用于在程序编译阶段评估常量表达式并对返回<code class="calibre10">false</code>的表达式断言，我们称这种断言为静态断言。它基本上满足我们对静态断言的要求。</p>

  <p class="zw">1．所有处理必须在编译期间执行，不允许有空间或时间上的运行时成本。</p>

  <p class="zw">2．它必须具有简单的语法。</p>

  <p class="zw">3．断言失败可以显示丰富的错误诊断信息。</p>

  <p class="zw">4．它可以在命名空间、类或代码块内使用。</p>

  <p class="zw">5．失败的断言会在编译阶段报错。</p>

  <p class="zw">C++11标准规定，使用<code class="calibre10">static_assert</code>需要传入两个实参：常量表达式和诊断消息字符串。请注意，第一个实参必须是常量表达式，因为编译器无法计算运行时才能确定结果的表达式：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;type_traits&gt;

class A {
};

class B : public A {
};

class C {
};

template&lt;class T&gt;
class E {
  static_assert(std::is_base_of&lt;A, T&gt;::value, "T is not base of A");
};

int main(int argc, char *argv[])
{
    static_assert(argc &gt; 0, "argc &gt; 0");  // 使用错误，argc&gt;0不是常量表达式
    E&lt;C&gt; x;                         // 使用正确，但由于A不是C的基类，所以触发断言
    static_assert(sizeof(int) &gt;= 4, // 使用正确，表达式返回真，不会触发失败断言
        "sizeof(int) &gt;= 4");
    E&lt;B&gt; y;                         // 使用正确，A是B的基类，不会触发失败断言
}</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">argc &gt; 0</code>依赖于用户输入的参数，显然不是一个常量表达式。在这种情况下，编译器会报错，符合上面的第5条要求。类模板<code class="calibre10">E</code>对<code class="calibre10">static_ assert</code>的使用是正确的，根据第1条和第4条要求，<code class="calibre10">static_assert</code>可以在类定义里使用并且不会改变类的内部状态。只不过在实例化类模板<code class="calibre10">E&lt;C&gt;</code>的时候，因为<code class="calibre10">A</code>不是<code class="calibre10">C</code>的基类，所以会触发静态断言，导致编译中断。</p>

  <h2 id="OEBPS/Text/chapter019.html.nav_point_146" class="sigil_not_in_toc">19.4　单参数static_assert</h2>

  <p class="zw">不知道读者是否和我有同样的想法，在大多数情况下使用<code class="calibre10">static_assert</code>的时候输入的诊断信息字符串就是常量表达式本身，所以让常量表达式作为诊断信息字符串参数的默认值是非常理想的。为了达到这个目的，我们可以定义一个宏：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#define LAZY_STATIC_ASSERT(B) static_assert(B, #B)</code></pre>

  <p class="zw">可能是该需求比较普遍的原因，2014年2月C++标准委员会就提出升级<code class="calibre10">static_ assert</code>的想法，希望让其支持单参数版本，即常量表达式，而断言输出的诊断信息为常量表达式本身。这个观点提出后得到了大多数人的认同，但是由于2014年2月C++14标准已经发布了，因此该特性不得不顺延到C++17标准中。在支持C++17标准的环境中，我们可以忽略第二个参数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;type_traits&gt;

class A {
};

class B : public A {
};

class C {
};

template&lt;class T&gt;
class E {
  static_assert(std::is_base_of&lt;A, T&gt;::value);
};

int main(int argc, char *argv[])
{
  E&lt;C&gt; x;                         // 使用正确，但由于A不是C的基类，会触发失败断言
  static_assert(sizeof(int) &lt; 4); // 使用正确，但表达式返回false，会触发失败断言
}</code></pre>

  <p class="zw">不过在GCC上，即使指定使用C++11标准，GCC依然支持单参数的<code class="calibre10">static_assert</code>。MSVC则不同，要使用单参数的<code class="calibre10">static_assert</code>需要指定C++17标准。</p>

  <h2 id="OEBPS/Text/chapter019.html.nav_point_147" class="sigil_not_in_toc">19.5　总结</h2>

  <p class="zw">静态断言并不是一个新鲜的概念，早在C++11标准出现之前，<code class="calibre10">boost</code>、<code class="calibre10">loki</code>等代码库就已经采用很多变通的办法实现了静态断言的部分功能。之所以这些代码库都会实现静态断言，主要是因为该特性可以将错误排查的工作前置到编译时，这对于程序员来说是非常友好的。C++11以及后来的C++17标准引入的<code class="calibre10">static_assert</code>完美地满足了静态断言的各种需求，当断言表达式是常量表达式的时候，我们应该优先使用<code class="calibre10">static_assert</code>静态断言。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter019.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter020.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter020.html.nav_point_148" class="not-in-toc">第20章　结构化绑定（C++17 C++20）</h1>

  <h2 id="OEBPS/Text/chapter020.html.nav_point_149" class="sigil_not_in_toc">20.1　使用结构化绑定</h2>

  <p class="zw">熟悉Python的读者应该知道，Python函数可以有多个返回值，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">def return_multiple_values():
    return 11, 7

x, y = return_multiple_values()</code></pre>

  <p class="zw">在上面的代码中函数<code class="calibre10">return_multiple_values</code>返回的是一个元组（tuple）(<code class="calibre10">11, 7</code>)，在函数返回后元组中元素的值被自动地分配到了<code class="calibre10">x</code>和<code class="calibre10">y</code>上。回过头来看C++，我们惊喜地发现在C++11标准中同样引入了元组的概念，通过元组C++也能返回多个值，但使用方法却不如Python那般简洁：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;tuple&gt;

std::tuple&lt;int, int&gt; return_multiple_values()
{
  return std::make_tuple(11, 7);
}

int main()
{
  int x = 0, y = 0;
  std::tie(x, y) = return_multiple_values();
  std::cout &lt;&lt; "x=" &lt;&lt; x &lt;&lt; " y=" &lt;&lt; y &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">可以看到，这段代码和Python完成了同样的工作，但代码却要麻烦许多。其中一个原因是C++11必须指定<code class="calibre10">return_multiple_values</code>函数的返回值类型，另外，在调用<code class="calibre10">return_multiple_values</code>函数前还需要声明变量<code class="calibre10">x</code>和<code class="calibre10">y</code>，并且使用函数模板<code class="calibre10">std::tie</code>将<code class="calibre10">x</code>和<code class="calibre10">y</code>通过引用绑定到<code class="calibre10">std::tuple&lt;int&amp;, int&amp;&gt;</code>上。对于第一个问题，我们可以使用C++14中<code class="calibre10">auto</code>的新特性来简化返回类型的声明（可以回顾第3章）：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto return_multiple_values()
{
  return std::make_tuple(11, 7);
}</code></pre>

  <p class="zw">重点来了，要想解决第二个问题就必须使用C++17标准中新引入的特性——结构化绑定。所谓结构化绑定是指将一个或者多个名称绑定到初始化对象中的一个或者多个子对象（或者元素）上，相当于给初始化对象的子对象（或者元素）起了别名，请注意别名不同于引用，这一点会在后面详细介绍。首先让我们看一看结构化绑定是如何化腐朽为神奇的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;tuple&gt;

auto return_multiple_values()
{
  return std::make_tuple(11, 7);
}

int main()
{
  auto[x, y] = return_multiple_values();
  std::cout &lt;&lt; "x=" &lt;&lt; x &lt;&lt; " y=" &lt;&lt; y &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">在上面这段代码中，<code class="calibre10">auto[x, y] = return_multiple_values()</code>是一个典型的结构化绑定声明，其中<code class="calibre10">auto</code>是类型占位符，<code class="calibre10">[x, y]</code>是绑定标识符列表，其中<code class="calibre10">x</code>和<code class="calibre10">y</code>是用于绑定的名称，绑定的目标是函数<code class="calibre10">return_multiple_values()</code>返回结果副本的子对象或者元素。用支持C++17标准的编译器编译运行这段代码会正确地输出：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">x=11 y=7</code></pre>

  <p class="zw">请注意，结构化绑定的目标不必是一个函数的返回结果，实际上等号的右边可以是任意一个合理的表达式，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;

struct BindTest {
  int a = 42;
  std::string b = "hello structured binding";
};

int main()
{
  BindTest bt;
  auto[x, y] = bt;
  std::cout &lt;&lt; "x=" &lt;&lt; x &lt;&lt; " y=" &lt;&lt; y &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">编译运行这段代码的输出如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">x=42 y=hello structured binding</code></pre>

  <p class="zw">可以看到结构化绑定能够直接绑定到结构体上。将其运用到基于范围的<code class="calibre10">for</code>循环中会有更好的效果：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

struct BindTest {
  int a = 42;
  std::string b = "hello structured binding";
};

int main()
{
  std::vector&lt;BindTest&gt; bt{ {11, "hello"},  {7, "c++"},  {42, "world"} };
  for (const auto&amp; [x, y] : bt) {
       std::cout &lt;&lt; "x=" &lt;&lt; x &lt;&lt; " y=" &lt;&lt; y &lt;&lt; std::endl;
  }
}</code></pre>

  <p class="zw">请注意以上代码的<code class="calibre10">for</code>循环部分。在这个基于范围的<code class="calibre10">for</code>循环中，通过结构化绑定直接将<code class="calibre10">x</code>和<code class="calibre10">y</code>绑定到向量<code class="calibre10">bt</code>中的结构体子对象上，省去了通过向量的元素访问成员变量<code class="calibre10">a</code>和<code class="calibre10">b</code>的步骤。</p>

  <h2 id="OEBPS/Text/chapter020.html.nav_point_150" class="sigil_not_in_toc">20.2　深入理解结构化绑定</h2>

  <p class="zw">在阅读了前面的内容之后，读者是否有这样的理解。</p>

  <p class="zw">1．结构化绑定的目标就是等号右边的对象。</p>

  <p class="zw">2．所谓的别名就是对等号右边对象的子对象或者元素的引用。</p>

  <p class="zw">如果确实是这么理解的，请忘掉它们，因为上面的理解是错误的。真实的情况是，在结构化绑定中编译器会根据限定符生成一个等号右边对象的匿名副本，而绑定的对象正是这个副本而非原对象本身。另外，这里的别名真的是单纯的别名，别名的类型和绑定目标对象的子对象类型相同，而引用类型本身就是一种和非引用类型不同的类型。在初步了解了结构和绑定的“真相”之后，现在我将使用伪代码进一步说明它是如何工作起来的。对于结构化绑定代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">BindTest bt;
const auto [x, y] = bt;</code></pre>

  <p class="zw">编译器为其生成的代码大概是这样的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">BindTest bt;
const auto _anonymous = bt;
aliasname x = _anonymous.a
aliasname y = _anonymous.b</code></pre>

  <p class="zw">在上面的伪代码中，<code class="calibre10">_anonymous</code>是编译器生成的匿名对象，可以注意到<code class="calibre10">const auto [x, y] = bt</code>中<code class="calibre10">auto</code>的限定符会直接应用到匿名对象<code class="calibre10">_anonymous</code>上。也就是说，<code class="calibre10">_anonymous</code>是<code class="calibre10">const</code>还是<code class="calibre10">volatile</code>完全依赖<code class="calibre10">auto</code>的限定符。另外，在伪代码中<code class="calibre10">x</code>和<code class="calibre10">y</code>的声明用了一个不存在的关键字<code class="calibre10">aliasname</code>来表达它们不是<code class="calibre10">_anonymous</code>成员的引用而是<code class="calibre10">_anonymous</code>成员的别名，也就是说<code class="calibre10">x</code>和<code class="calibre10">y</code>的类型分别为<code class="calibre10">const int</code>和<code class="calibre10">const std:: string</code>，而不是<code class="calibre10">const int&amp;</code>和<code class="calibre10">const std::string&amp;</code>。为了证明以上两点，读者可以尝试编译运行下面这段代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;

struct BindTest {
  int a = 42;
  std::string b = "hello structured binding";
};

int main()
{
  BindTest bt;
  const auto[x, y] = bt;

  std::cout &lt;&lt; "&amp;bt.a=" &lt;&lt; &amp;bt.a &lt;&lt; " &amp;x=" &lt;&lt; &amp;x &lt;&lt; std::endl;
  std::cout &lt;&lt; "&amp;bt.b=" &lt;&lt; &amp;bt.b &lt;&lt; " &amp;y=" &lt;&lt; &amp;y &lt;&lt; std::endl;
  std::cout &lt;&lt; "std::is_same_v&lt;const int, decltype(x)&gt;=" 
       &lt;&lt; std::is_same_v&lt;const int, decltype(x)&gt; &lt;&lt; std::endl;
  std::cout &lt;&lt; "std::is_same_v&lt;const std::string, decltype(y)&gt;=" 
       &lt;&lt; std::is_same_v&lt;const std::string, decltype(y)&gt; &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">编译运行的结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">&amp;bt.a=0x77fde0 &amp;x=0x77fd80
&amp;bt.b=0x77fde8 &amp;y=0x77fd88
std::is_same_v&lt;const int, decltype(x)&gt;=1
std::is_same_v&lt;const std::string, decltype(y)&gt;=1</code></pre>

  <p class="zw">正如上文中描述的那样，别名<code class="calibre10">x</code>并不是<code class="calibre10">bt.a</code>，因为它们的内存地址不同。另外，<code class="calibre10">x</code>和<code class="calibre10">y</code>的类型分别与<code class="calibre10">const int</code>和<code class="calibre10">const std::string</code>相同也证明了它们是别名而不是引用的事实。由此可见，如果在上面这段代码中试图使用<code class="calibre10">x</code>和<code class="calibre10">y</code>去修改<code class="calibre10">bt</code>的数据成员是无法成功的，因为一方面<code class="calibre10">x</code>和<code class="calibre10">y</code>都是常量类型；另一方面即使<code class="calibre10">x</code>和<code class="calibre10">y</code>是非常量类型，改变的<code class="calibre10">x</code>和<code class="calibre10">y</code>只会影响匿名对象而非<code class="calibre10">bt</code>本身。当然了，了解了结构化绑定的原理之后，写一个能改变<code class="calibre10">bt</code>成员变量的结构化绑定代码就很简单了：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int main()
{
  BindTest bt;
  auto&amp;[x, y] = bt;

  std::cout &lt;&lt; "&amp;bt.a=" &lt;&lt; &amp;bt.a &lt;&lt; " &amp;x=" &lt;&lt; &amp;x &lt;&lt; std::endl;
  std::cout &lt;&lt; "&amp;bt.b=" &lt;&lt; &amp;bt.b &lt;&lt; " &amp;y=" &lt;&lt; &amp;y &lt;&lt; std::endl;

  x = 11;
  std::cout &lt;&lt; "bt.a=" &lt;&lt; bt.a &lt;&lt; std::endl;
  bt.b = "hi structured binding";
  std::cout &lt;&lt; "y=" &lt;&lt; y &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">虽然只是将<code class="calibre10">const auto</code>修改为<code class="calibre10">auto&amp;</code>，但是已经能达到让<code class="calibre10">bt</code>数据成员和<code class="calibre10">x</code>、<code class="calibre10">y</code>相互修改的目的了：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">BindTest bt;
auto &amp;_anonymous = bt;
aliasname x = _anonymous.a
aliasname y = _anonymous.b</code></pre>

  <p class="zw">关于引用有趣的一点是，如果结构化绑定声明为<code class="calibre10">const auto&amp;[x, y] = bt</code>，那么<code class="calibre10">x = 11</code>会编译失败，因为<code class="calibre10">x</code>绑定的对象是一个常量引用，而<code class="calibre10">bt.b = "hi structured binding"</code>却能成功修改<code class="calibre10">y</code>的值，因为<code class="calibre10">bt</code>本身不存在常量问题。</p>

  <p class="zw">请注意，使用结构化绑定无法忽略对象的子对象或者元素：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto t = std::make_tuple(42, "hello world");
auto [x] = t;</code></pre>

  <p class="zw">以上代码是无法通过编译的，必须有两个别名分别对应<code class="calibre10">bt</code>的成员变量<code class="calibre10">a</code>和<code class="calibre10">b</code>。熟悉C++11的读者可能会提出仿照<code class="calibre10">std::tie</code>使用<code class="calibre10">std::ignore</code>的方案：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto t = std::make_tuple(42, "hello world");
int x = 0, y = 0;
std::tie(x, std::ignore) = t;
std::tie(y, std::ignore) = t;</code></pre>

  <p class="zw">虽然这个方案对于<code class="calibre10">std::tie</code>是有效的，但是结构化绑定的别名还有一个限制：无法在同一个作用域中重复使用。这一点和变量声明是一样的，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto t = std::make_tuple(42, "hello world");
auto[x, ignore] = t;
auto[y, ignore] = t;    // 编译错误，ignore无法重复声明</code></pre>

  <h2 id="OEBPS/Text/chapter020.html.nav_point_151" class="sigil_not_in_toc">20.3　结构化绑定的3种类型</h2>

  <p class="zw">结构化绑定可以作用于3种类型，包括原生数组、结构体和类对象、元组和类元组的对象，接下来将一一介绍。</p>

  <h3 id="OEBPS/Text/chapter020.html.nav_point_152" class="sigil_not_in_toc1">20.3.1　绑定到原生数组</h3>

  <p class="zw">我们在上面的示例代码中并没有见到过这种类型，它是3种情况中最简单的一种。绑定到原生数组即将标识符列表中的别名一一绑定到原生数组对应的元素上。所需条件仅仅是要求别名的数量与数组元素的个数一致，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

int main()
{
  int a[3]{ 1, 3, 5 };
  auto[x, y, z] = a;
  std::cout &lt;&lt; "[x, y, z]=[" 
       &lt;&lt; x &lt;&lt; ", " 
       &lt;&lt; y &lt;&lt; ", " 
       &lt;&lt; z &lt;&lt; "]" &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">以上代码很好理解，别名<code class="calibre10">x</code>、<code class="calibre10">y</code>和<code class="calibre10">z</code>分别绑定到<code class="calibre10">a[0]</code>、<code class="calibre10">a[1]</code>和<code class="calibre10">a[2]</code>所对应的匿名对象上。另外，绑定到原生数组需要小心数组的退化，因为在绑定的过程中编译器必须知道原生数组的元素个数，一旦数组退化为指针，就将失去这个属性。</p>

  <h3 id="OEBPS/Text/chapter020.html.nav_point_153" class="sigil_not_in_toc1">20.3.2　绑定到结构体和类对象</h3>

  <p class="zw">将标识符列表中的别名分别绑定到结构体和类的非静态成员变量上，这一点在之前的例子中已经见到了。但是我们之前没有提过关于这种绑定的限制条件，实际上这种情况的限制条件要比原生数组复杂得多。首先，类或者结构体中的非静态数据成员个数必须和标识符列表中的别名的个数相同；其次，这些数据成员必须是公有的（C++20标准修改了此项规则，详情见20.5节）；这些数据成员必须是在同一个类或者基类中；最后，绑定的类和结构体中不能存在匿名联合体：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class BindTest {
  int a = 42;        // 私有成员变量
public:
  double b = 11.7;
};

int main()
{
  BindTest bt;
  auto[x, y] = bt;
}</code></pre>

  <p class="zw">以上代码会编译错误，因为<code class="calibre10">BindTest</code>成员变量<code class="calibre10">a</code>是私有的，违反了绑定结构体的限制条件：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class BindBase1 {
public:
  int a = 42;
  double b = 11.7;
};

class BindTest1 : public BindBase1 {};

class BindBase2 {};

class BindTest2 : public BindBase2 {
public:
  int a = 42;
  double b = 11.7;
};

class BindBase3 {
public:
  int a = 42;
};

class BindTest3 : public BindBase3 {
public:
  double b = 11.7;
};

int main()
{
  BindTest1 bt1;
  BindTest2 bt2;
  BindTest3 bt3;
  auto[x1, y1] = bt1;    // 编译成功
  auto[x2, y2] = bt2;    // 编译成功
  auto[x3, y3] = bt3;    // 编译错误
}</code></pre>

  <p class="zw">在上面这段代码中，<code class="calibre10">auto[x1, y1] = bt1</code>和<code class="calibre10">auto[x2, y2] = bt2</code>可以顺利地编译，因为类<code class="calibre10">BindTest1</code>和<code class="calibre10">BindTest2</code>的非静态数据成员要么全部在派生类中定义，要么全部在基类中定义。<code class="calibre10">BindTest3</code>却不同，其中成员变量<code class="calibre10">a</code>的定义在基类，成员变量<code class="calibre10">b</code>的定义在派生类，这一点违反了绑定结构体的限制条件，所以<code class="calibre10">auto[x3, y3] = bt3</code>会导致编译错误。最后需要注意的是，类和结构体中不能出现匿名的联合体，而对于命名的联合体则没有限制。</p>

  <h3 id="OEBPS/Text/chapter020.html.nav_point_154" class="sigil_not_in_toc1">20.3.3　绑定到元组和类元组的对象</h3>

  <p class="zw">绑定到元组就是将标识符列表中的别名分别绑定到元组对象的各个元素。绑定到类元组又是什么意思呢？要解释这个概念就要从绑定的限制条件讲起。实际上，绑定元组和类元组有一系列抽象的条件：对于元组或者类元组类型<code class="calibre10">T</code>。</p>

  <p class="zw">1．需要满足<code class="calibre10">std::tuple_size&lt;T&gt;::value</code>是一个符合语法的表达式，并且该表达式获得的整数值与标识符列表中的别名个数相同。</p>

  <p class="zw">2．类型<code class="calibre10">T</code>还需要保证<code class="calibre10">std::tuple_element&lt;i, T&gt;::type</code>也是一个符合语法的表达式，其中<code class="calibre10">i</code>是小于<code class="calibre10">std::tuple_size&lt;T&gt;::value</code>的整数，表达式代表了类型<code class="calibre10">T</code>中第<code class="calibre10">i</code>个元素的类型。</p>

  <p class="zw">3．类型<code class="calibre10">T</code>必须存在合法的成员函数模板<code class="calibre10">get&lt;i&gt;()</code>或者函数模板<code class="calibre10">get&lt;i&gt;(t)</code>，其中<code class="calibre10">i</code>是小于<code class="calibre10">std::tuple_size&lt;T&gt;::value</code>的整数，<code class="calibre10">t</code>是类型<code class="calibre10">T</code>的实例，<code class="calibre10">get&lt;i&gt;()</code>和<code class="calibre10">get&lt;i&gt;(t)</code>返回的是实例<code class="calibre10">t</code>中第<code class="calibre10">i</code>个元素的值。</p>

  <p class="zw">理解上述条件会发现，它们其实比较抽象。这些条件并没有明确规定结构化绑定的类型一定是元组，任何具有上述条件特征的类型都可以成为绑定的目标。另外，获取这些条件特征的代价也并不高，只需要为目标类型提供<code class="calibre10">std::tuple_size</code>、<code class="calibre10">std::tuple_element</code>以及<code class="calibre10">get</code>的特化或者偏特化版本即可。实际上，标准库中除了元组本身毫无疑问地能够作为绑定目标以外，<code class="calibre10">std::pair</code>和<code class="calibre10">std::array</code>也能作为结构化绑定的目标，其原因就是它们是满足上述条件的类元组。说到这里，就不得不进一步讨论<code class="calibre10">std::pair</code>了，因为它对结构化绑定的支持给我们带来了一个不错的惊喜：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;

int main()
{
  std::map&lt;int, std::string&gt; id2str{ {1, "hello"}, 
  {3, "Structured"}, {5, "bindings"} };

  for (const auto&amp; elem : id2str) {
       std::cout &lt;&lt; "id=" &lt;&lt; elem.first
            &lt;&lt; ", str=" &lt;&lt; elem.second &lt;&lt; std::endl;
  }
}</code></pre>

  <p class="zw">上面这段代码是一个基于范围的<code class="calibre10">for</code>循环遍历<code class="calibre10">std::map</code>的例子，其中<code class="calibre10">elem</code>是<code class="calibre10">std::pair&lt;const int, std::string&gt;</code>类型，要在循环体中输出<code class="calibre10">key</code>和<code class="calibre10">value</code>的值就需要访问成员变量<code class="calibre10">first</code>和<code class="calibre10">second</code>。这个例子中使用基于范围的<code class="calibre10">for</code>循环已经比使用迭代器遍历<code class="calibre10">std::map</code>简单了很多，但是加入结构化绑定后代码将被进一步简化。我们可以将<code class="calibre10">std::pair</code>的成员变量<code class="calibre10">first</code>和<code class="calibre10">second</code>绑定到别名以保证代码阅读起来更加清晰：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">for (const auto&amp;[id, str]:id2str) {
  std::cout &lt;&lt; "id=" &lt;&lt; id 
       &lt;&lt; ", str=" &lt;&lt; str &lt;&lt; std::endl;
}</code></pre>

  <h2 id="OEBPS/Text/chapter020.html.nav_point_155" class="sigil_not_in_toc">20.4　实现一个类元组类型</h2>

  <p class="zw">我们已经知道了通过满足类元组的限制条件让任何类型支持结构化绑定的方法，现在是时候实践一下了。以上一节中提到的<code class="calibre10">BindTest3</code>为例，我们知道由于它的数据成员分散在派生类和基类之中，因此无法使用结构化绑定。下面将通过让其满足类元组的条件，从而达到支持结构化绑定的目的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;tuple&gt;

class BindBase3 {
public:
  int a = 42;
};

class BindTest3 : public BindBase3 {
public:
  double b = 11.7;
};

namespace std {
  template&lt;&gt;
  struct tuple_size&lt;BindTest3&gt; {
       static constexpr size_t value = 2;
  };

  template&lt;&gt;
  struct tuple_element&lt;0, BindTest3&gt; {
       using type = int;
  };

  template&lt;&gt;
  struct tuple_element&lt;1, BindTest3&gt; {
       using type = double;
  };
}

template&lt;std::size_t Idx&gt;
auto&amp; get(BindTest3 &amp;bt) = delete;

template&lt;&gt;
auto&amp; get&lt;0&gt;(BindTest3 &amp;bt) { return bt.a; }

template&lt;&gt;
auto&amp; get&lt;1&gt;(BindTest3 &amp;bt) { return bt.b;}

int main()
{
  BindTest3 bt3;
  auto&amp; [x3, y3] = bt3;
  x3 = 78;
  std::cout &lt;&lt; bt3.a &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">在上面这段代码中，我们为<code class="calibre10">BindTest3</code>实现了3种特性以满足类元组的限制条件。首先实现的是：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;&gt;
struct tuple_size&lt;BindTest3&gt; {
  static constexpr size_t value = 2;
};</code></pre>

  <p class="zw">它的作用是告诉编译器将要绑定的子对象和元素的个数，这里通过特化让<code class="calibre10">tuple_size&lt;BindTest3&gt;::value</code>的值为2，也就是存在两个子对象。然后需要明确的是每个子对象和元素的类型：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;&gt;
struct tuple_element&lt;0, BindTest3&gt; {
  using type = int;
};

template&lt;&gt;
struct tuple_element&lt;1, BindTest3&gt; {
  using type = double;
};</code></pre>

  <p class="zw">这里同样通过特化的方法指定了两个子对象的具体类型。最后需要实现的是get函数，注意，<code class="calibre10">get</code>函数的实现有两种方式，一种需要给<code class="calibre10">BindTest3</code>添加成员函数；另一种则不需要，我们通常会选择不破坏原有代码的方案，所以这里先展示后者：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;std::size_t Idx&gt;
auto&amp; get(BindTest3 &amp;bt) = delete;

template&lt;&gt;
auto&amp; get&lt;0&gt;(BindTest3 &amp;bt) { return bt.a; }

template&lt;&gt;
auto&amp; get&lt;1&gt;(BindTest3 &amp;bt) { return bt.b;}</code></pre>

  <p class="zw">可以看到函数模板<code class="calibre10">get</code>也特化出了两个函数实例，它们分别返回<code class="calibre10">bt.a</code>和<code class="calibre10">bt.b</code>的引用。之所以这里需要返回引用，是因为我希望结构化绑定的别名能够修改<code class="calibre10">BindTest3</code>的实例，如果需要的是一个只读的结构化绑定，则这里可以不必返回引用。最后<code class="calibre10">template&lt;std::size_t Idx&gt; auto&amp; get(BindTest3 &amp;bt) = delete</code>可以明确地告知编译器不要生成除了特化版本以外的函数实例以防止<code class="calibre10">get</code>函数模板被滥用。</p>

  <p class="zw">正如上文强调的，我不推荐实现成员函数版本的<code class="calibre10">get</code>函数，因为这需要修改原有的代码。但是当我们重新编写一个类，并且希望它支持结构化绑定的时候，也不妨尝试实现几个<code class="calibre10">get</code>成员函数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;tuple&gt;

class BindBase3 {
public:
  int a = 42;
};

class BindTest3 : public BindBase3 {
public:
  double b = 11.7;
  template&lt;std::size_t Idx&gt; auto&amp; get() = delete;

};

template&lt;&gt; auto&amp; BindTest3::get&lt;0&gt;() { return a; }
template&lt;&gt; auto&amp; BindTest3::get&lt;1&gt;() { return b; }

namespace std {
  template&lt;&gt;
  struct tuple_size&lt;BindTest3&gt; {
       static constexpr size_t value = 2;
  };

  template&lt;&gt;
  struct tuple_element&lt;0, BindTest3&gt; {
       using type = int;
  };

  template&lt;&gt;
  struct tuple_element&lt;1, BindTest3&gt; {
       using type = double;
  };
}

int main()
{
  BindTest3 bt3;
  auto&amp; [x3, y3] = bt3;
  x3 = 78;
  std::cout &lt;&lt; bt3.a &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">这段代码和第一份实现代码基本相同，我们只需要把精力集中到<code class="calibre10">get</code>成员函数的部分：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class BindTest3 : public BindBase3 {
public:
  double b = 11.7;
  template&lt;std::size_t Idx&gt; auto&amp; get() = delete;

};

template&lt;&gt; auto&amp; BindTest3::get&lt;0&gt;() { return a; }
template&lt;&gt; auto&amp; BindTest3::get&lt;1&gt;() { return b; }</code></pre>

  <p class="zw">这段代码中<code class="calibre10">get</code>成员函数的优势显而易见，成员函数不需要传递任何参数。另外，特化版本的函数<code class="calibre10">get&lt;0&gt;</code>和<code class="calibre10">get&lt;1&gt;</code>可以直接返回<code class="calibre10">a</code>和<code class="calibre10">b</code>，这显得格外简洁。读者不妨自己编译运行一下这两段代码，其输出结果应该都是<code class="calibre10">78</code>，修改<code class="calibre10">bt.a</code>成功。</p>

  <h2 id="OEBPS/Text/chapter020.html.nav_point_156" class="sigil_not_in_toc">20.5　绑定的访问权限问题</h2>

  <p class="zw">前面提到过，当在结构体或者类中使用结构化绑定的时候，需要有公开的访问权限，否则会导致编译失败。这条限制乍看是合理的，但是仔细想来却引入了一个相同条件下代码表现不一致的问题：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct A {
  friend void foo();
private:
  int i;
};

void foo() {
  A a{};
  auto x = a.i; // 编译成功
  auto [y] = a; // 编译失败
}</code></pre>

  <p class="zw">在上面这段代码中，<code class="calibre10">foo</code>是结构体<code class="calibre10">A</code>的友元函数，它可以访问<code class="calibre10">A</code>的私有成员<code class="calibre10">i</code>。但是，结构化绑定却失败了，这就明显不合理了。同样的问题还有访问自身成员的时候：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class C {
  int i;
  void foo(const C&amp; other) {
       auto [x] = other; // 编译失败
  }
};</code></pre>

  <p class="zw">为了解决这类问题，C++20标准规定结构化绑定的限制不再强调必须为公开数据成员，编译器会根据当前操作的上下文来判断是否允许结构化绑定。幸运的是，虽然标准是2018年提出修改的，但在我实验的3种编译器上，无论是C++17还是C++20标准，以上代码都可以顺利地通过编译。</p>

  <h2 id="OEBPS/Text/chapter020.html.nav_point_157" class="sigil_not_in_toc">20.6　总结</h2>

  <p class="zw">本章介绍的结构化绑定是新特性中比较有趣的一个，使用该特性可以直接绑定数据对象的内部成员，函数返回多个值就是其中一个应用。另外，自定义支持结构化绑定的类型也并不困难，代码库作者不妨为库中的类型添加类元组方法，让它们支持结构化绑定。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter020.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter021.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter021.html.nav_point_158" class="not-in-toc">第21章　noexcept关键字（C++11 C++17 C++20）</h1>

  <h2 id="OEBPS/Text/chapter021.html.nav_point_159" class="sigil_not_in_toc">21.1　使用noexcept代替throw</h2>

  <p class="zw">异常处理是C++语言的重要特性，在C++11标准之前，我们可以使用<code class="calibre10">throw (optional_type_list)</code>声明函数是否抛出异常，并描述函数抛出的异常类型。理论上，运行时必须检查函数发出的任何异常是否确实存在于<code class="calibre10">optional_ type_list</code>中，或者是否从该列表中的某个类型派生。如果不是，则会调用处理程序<code class="calibre10">std::unexpected</code>。但实际上，由于这个检查实现比较复杂，因此并不是所有编译器都会遵从这个规范。此外，大多数程序员似乎并不喜欢<code class="calibre10">throw(optional_ type_list)</code>这种声明抛出异常的方式，因为在他们看来抛出异常的类型并不是他们关心的事情，他们只需要关心函数是否会抛出异常，即是否使用了<code class="calibre10">throw()</code>来声明函数。</p>

  <p class="zw">使用<code class="calibre10">throw</code>声明函数是否抛出异常一直没有什么问题，直到C++11标准引入了移动构造函数。移动构造函数中包含着一个严重的异常陷阱。</p>

  <p class="zw">当我们想将一个容器的元素移动到另外一个新的容器中时。在C++11之前，由于没有移动语义，我们只能将原始容器的数据复制到新容器中。如果在数据复制的过程中复制构造函数发生了异常，那么我们可以丢弃新的容器，保留原始的容器。在这个环境中，原始容器的内容不会有任何变化。</p>

  <p class="zw">但是有了移动语义，原始容器的数据会逐一地移动到新容器中，如果数据移动的途中发生异常，那么原始容器也将无法继续使用，因为已经有一部分数据移动到新的容器中。这里读者可能会有疑问，如果发生异常就做一个反向移动操作，恢复原始容器的内容不就可以了吗？实际上，这样做并不可靠，因为我们无法保证恢复的过程中不会抛出异常。</p>

  <p class="zw">这里的问题是，<code class="calibre10">throw</code>并不能根据容器中移动的元素是否会抛出异常来确定移动构造函数是否允许抛出异常。针对这样的问题，C++标准委员会提出了<code class="calibre10">noexcept</code>说明符。</p>

  <p class="zw"><code class="calibre10">noexcept</code>是一个与异常相关的关键字，它既是一个说明符，也是一个运算符。作为说明符，它能够用来说明函数是否会抛出异常，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct X {
    int f() const noexcept
    {
        return 58;
    }
    void g() noexcept {}
};

int foo() noexcept
{
    return 42;
}</code></pre>

  <p class="zw">以上代码非常简单，用<code class="calibre10">noexcept</code>声明了函数<code class="calibre10">foo</code>以及<code class="calibre10">X</code>的成员函数<code class="calibre10">f</code>和<code class="calibre10">g</code>。指示编译器这几个函数是不会抛出异常的，编译器可以根据声明优化代码。请注意，<code class="calibre10">noexcept</code>只是告诉编译器不会抛出异常，但函数不一定真的不会抛出异常。这相当于对编译器的一种承诺，当我们在声明了<code class="calibre10">noexcept</code>的函数中抛出异常时，程序会调用<code class="calibre10">std::terminate</code>去结束程序的生命周期。</p>

  <p class="zw">另外，<code class="calibre10">noexcept</code>还能接受一个返回布尔的常量表达式，当表达式评估为<code class="calibre10">true</code>的时候，其行为和不带参数一样，表示函数不会抛出异常。反之，当表达式评估为<code class="calibre10">false</code>的时候，则表示该函数有可能会抛出异常。这个特性广泛应用于模板当中，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T&gt; 
T copy(const T &amp; o) noexcept {
    …
}</code></pre>

  <p class="zw">以上代码想实现一个复制函数，并且希望使用<code class="calibre10">noexcept</code>优化不抛出异常时的代码。但问题是如果<code class="calibre10">T</code>是一个复杂类型，那么调用其复制构造函数是有可能发生异常的。直接声明<code class="calibre10">noexcept</code>会导致当函数遇到异常的时候程序被终止，而不给我们处理异常的机会。我们希望只有在<code class="calibre10">T</code>是一个基础类型时复制函数才会被声明为<code class="calibre10">noexcept</code>，因为基础类型的复制是不会发生异常的。这时就需要用到带参数的<code class="calibre10">noexcept</code>了：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T&gt; 
T copy(const T &amp;o) noexcept(std::is_fundamental&lt;T&gt;::value) {
  …
}</code></pre>

  <p class="zw">上面这段代码通过<code class="calibre10">std::is_fundamental</code>来判断<code class="calibre10">T</code>是否为基础类型，如果<code class="calibre10">T</code>是基础类型，则复制函数被声明为<code class="calibre10">noexcept(true)</code>，即不会抛出异常。反之，函数被声明为<code class="calibre10">noexcept(false)</code>，表示函数有可能抛出异常。请注意，由于<code class="calibre10">noexcept</code>对表达式的评估是在编译阶段执行的，因此表达式必须是一个常量表达式。</p>

  <p class="zw">实际上，这段代码并不是最好的解决方案，因为我还希望在类型<code class="calibre10">T</code>的复制构造函数保证不抛出异常的情况下都使用<code class="calibre10">noexcept</code>声明。基于这点考虑，C++标准委员会又赋予了<code class="calibre10">noexcept</code>作为运算符的特性。<code class="calibre10">noexcept</code>运算符接受表达式参数并返回<code class="calibre10">true</code>或<code class="calibre10">false</code>。因为该过程是在编译阶段进行，所以表达式本身并不会被执行。而表达式的结果取决于编译器是否在表达式中找到潜在异常：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
int foo() noexcept
{
    return 42;
}

int foo1()
{
    return 42;
}

int foo2() throw()
{
    return 42;
}

int main()
{
    std::cout &lt;&lt; std::boolalpha;
    std::cout &lt;&lt; "noexcept(foo())  = " &lt;&lt; noexcept(foo()) &lt;&lt; std::endl;
    std::cout &lt;&lt; "noexcept(foo1()) = " &lt;&lt; noexcept(foo1()) &lt;&lt; std::endl;
    std::cout &lt;&lt; "noexcept(foo2()) = " &lt;&lt; noexcept(foo2()) &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">上面这段代码的运行结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">noexcept(foo())  = true
noexcept(foo1()) = false
noexcept(foo2()) = true</code></pre>

  <p class="zw"><code class="calibre10">noexcept</code>运算符能够准确地判断函数是否有声明不会抛出异常。有了这个工具，我们可以进一步优化复制函数模板：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T&gt;
T copy(const T &amp;o) noexcept(noexcept(T(o))) { 
  …
}</code></pre>

  <p class="zw">这段代码看起来有些奇怪，因为函数声明中连续出现了两个<code class="calibre10">noexcept</code>关键字，只不过两个关键字发挥了不同的作用。其中第二个关键字是运算符，它判断<code class="calibre10">T(o)</code>是否有可能抛出异常。而第一个<code class="calibre10">noexcept</code>关键字则是说明符，它接受第二个运算符的返回值，以此决定<code class="calibre10">T</code>类型的复制函数是否声明为不抛出异常。</p>

  <h2 id="OEBPS/Text/chapter021.html.nav_point_160" class="sigil_not_in_toc">21.2　用noexcept来解决移动构造问题</h2>

  <p class="zw">上文曾提到过，异常的存在对容器数据的移动构成了威胁，因为我们无法保证在移动构造的时候不抛出异常。现在<code class="calibre10">noexcept</code>运算符可以判断目标类型的移动构造函数是否有可能抛出异常。如果没有抛出异常的可能，那么函数可以选择进行移动操作；否则将使用传统的复制操作。</p>

  <p class="zw">下面，我们就来实现一个使用移动语义的容器经常用到的工具函数<code class="calibre10">swap</code>：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T&gt;
void swap(T&amp; a, T&amp; b)
noexcept(noexcept(T(std::move(a))) &amp;&amp; noexcept(a.operator=(std::move(b))))
{
    T tmp(std::move(a));
    a = std::move(b);
    b = std::move(tmp);
}</code></pre>

  <p class="zw">上面这段代码只做了两件事情：第一，检查类型<code class="calibre10">T</code>的移动构造函数和移动赋值函数是否都不会抛出异常；第二，通过移动构造函数和移动赋值函数移动对象<code class="calibre10">a</code>和<code class="calibre10">b</code>。在这个函数中使用<code class="calibre10">noexcept</code>的好处在于，它让编译器可以根据类型移动函数是否抛出异常来选择不同的优化策略。但是这个函数并没有解决上面容器移动的问题。</p>

  <p class="zw">继续改进<code class="calibre10">swap</code>函数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T&gt;
void swap(T&amp; a, T&amp; b)
noexcept(noexcept(T(std::move(a))) &amp;&amp; noexcept(a.operator=(std::move(b))))
{
    static_assert(noexcept(T(std::move(a)))
        &amp;&amp; noexcept(a.operator=(std::move(b))));
    T tmp(std::move(a));
    a = std::move(b);
    b = std::move(tmp);
}</code></pre>

  <p class="zw">改进版的<code class="calibre10">swap</code>在函数内部使用<code class="calibre10">static_assert</code>对类型<code class="calibre10">T</code>的移动构造函数和移动赋值函数进行检查，如果其中任何一个抛出异常，那么函数会编译失败。使用这种方法可以迫使类型<code class="calibre10">T</code>实现不抛出异常的移动构造函数和移动赋值函数。但是这种实现方式过于强势，我们希望在不满足移动要求的时候，有选择地使用复制方法完成移动操作。</p>

  <p class="zw">最终版<code class="calibre10">swap</code>函数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;type_traits
struct X {
    X() {}
    X(X&amp;&amp;) noexcept {}
    X(const X&amp;) {}
    X operator= (X&amp;&amp;) noexcept { return *this; }
    X operator= (const X&amp;) { return *this; }
};

struct X1 {
    X1() {}
    X1(X1&amp;&amp;) {}
    X1(const X1&amp;) {}
    X1 operator= (X1&amp;&amp;) { return *this; }
    X1 operator= (const X1&amp;) { return *this; }
};

template&lt;typename T&gt;
void swap_impl(T&amp; a, T&amp; b, std::integral_constant&lt;bool, true&gt;) noexcept
{
    T tmp(std::move(a));
    a = std::move(b);
    b = std::move(tmp);
}

template&lt;typename T&gt;
void swap_impl(T&amp; a, T&amp; b, std::integral_constant&lt;bool, false&gt;)
{
    T tmp(a);
    a = b;
    b = tmp;
}

template&lt;typename T&gt;
void swap(T&amp; a, T&amp; b)
noexcept(noexcept(swap_impl(a, b,
    std::integral_constant&lt;bool, noexcept(T(std::move(a)))
    &amp;&amp; noexcept(a.operator=(std::move(b)))&gt;())))
{
    swap_impl(a, b, std::integral_constant&lt;bool, noexcept(T(std::move(a)))
        &amp;&amp; noexcept(a.operator=(std::move(b)))&gt;());
}

int main()
{
    X x1, x2;
    swap(x1, x2);

    X1 x3, x4;
    swap(x3, x4);
}</code></pre>

  <p class="zw">以上代码实现了两个版本的<code class="calibre10">swap_impl</code>，它们的形参列表的前两个形参是相同的，只有第三个形参类型不同。第三个形参为<code class="calibre10">std::integral_constant&lt;bool, true&gt;</code>的函数会使用移动的方法交换数据，而第三个参数为<code class="calibre10">std::integral_ constant&lt;bool, false&gt;</code>的函数则会使用复制的方法来交换数据。<code class="calibre10">swap</code>函数会调用<code class="calibre10">swap_impl</code>，并且以移动构造函数和移动赋值函数是否会抛出异常为模板实参来实例化<code class="calibre10">swap_impl</code>的第三个参数。这样，不抛出异常的类型会实例化一个类型为<code class="calibre10">std::integral_constant&lt;bool, true&gt;</code>的对象，并调用使用移动方法的<code class="calibre10">swap_impl</code>；反之则调用使用复制方法的<code class="calibre10">swap_impl</code>。</p>

  <p class="zw">请注意这段代码中，我为了更多地展示<code class="calibre10">noexcept</code>的用法将代码写得有些复杂。实际上<code class="calibre10">noexcept(T(std::move(a))) &amp;&amp; noexcept(a.operator=(std:: move(b)))</code>这段代码完全可以使用<code class="calibre10">std::is_nothrow_move_constructible &lt;T&gt;::value &amp;&amp; std::is_nothrow_move_ assignable&lt;T&gt;::value</code>来代替。</p>

  <h2 id="OEBPS/Text/chapter021.html.nav_point_161" class="sigil_not_in_toc">21.3　noexcept和throw()</h2>

  <p class="zw">在了解了<code class="calibre10">noexcept</code>以后，现在是时候对比一下<code class="calibre10">noexcept</code>和<code class="calibre10">throw()</code>两种方法了。请注意，这两种指明不抛出异常的方法在外在行为上是一样的。如果用<code class="calibre10">noexcept</code>运算符去探测<code class="calibre10">noexcept</code>和<code class="calibre10">throw()</code>声明的函数，会返回相同的结果。</p>

  <p class="zw">但实际上在C++11标准中，它们在实现上确实是有一些差异的。如果一个函数在声明了<code class="calibre10">noexcept</code>的基础上抛出了异常，那么程序将不需要展开堆栈，并且它可以随时停止展开。另外，它不会调用<code class="calibre10">std::unexpected</code>，而是调用<code class="calibre10">std::terminate</code>结束程序。而<code class="calibre10">throw()</code>则需要展开堆栈，并调用<code class="calibre10">std::unexpected</code>。这些差异让使用<code class="calibre10">noexcept</code>程序拥有更高的性能。在C++17标准中，<code class="calibre10">throw()</code>成为<code class="calibre10">noexcept</code>的一个别名，也就是说<code class="calibre10">throw()</code>和<code class="calibre10">noexcept</code>拥有了同样的行为和实现。另外，在C++17标准中只有<code class="calibre10">throw()</code>被保留了下来，其他用<code class="calibre10">throw</code>声明函数抛出异常的方法都被移除了。在C++20中<code class="calibre10">throw()</code>也被标准移除了，使用<code class="calibre10">throw</code>声明函数异常的方法正式退出了历史舞台。</p>

  <h2 id="OEBPS/Text/chapter021.html.nav_point_162" class="sigil_not_in_toc">21.4　默认使用noexcept的函数</h2>

  <p class="zw">C++11标准规定下面几种函数会默认带有<code class="calibre10">noexcept</code>声明。</p>

  <p class="zw">1．默认构造函数、默认复制构造函数、默认赋值函数、默认移动构造函数和默认移动赋值函数。有一个额外要求，对应的函数在类型的基类和成员中也具有<code class="calibre10">noexcept</code>声明，否则其对应函数将不再默认带有<code class="calibre10">noexcept</code>声明。另外，自定义实现的函数默认也不会带有<code class="calibre10">noexcept</code>声明：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

struct X {
};

#define PRINT_NOEXCEPT(x)    \
    std::cout &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; std::endl

int main()
{
    X x;
    std::cout &lt;&lt; std::boolalpha;
    PRINT_NOEXCEPT(noexcept(X()));
    PRINT_NOEXCEPT(noexcept(X(x)));
    PRINT_NOEXCEPT(noexcept(X(std::move(x))));
    PRINT_NOEXCEPT(noexcept(x.operator=(x)));
    PRINT_NOEXCEPT(noexcept(x.operator=(std::move(x))));
}</code></pre>

  <p class="zw">以上代码的运行输出结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">noexcept(X()) = true
noexcept(X(x)) = true
noexcept(X(std::move(x))) = true
noexcept(x.operator=(x)) = true
noexcept(x.operator=(std::move(x))) = true</code></pre>

  <p class="zw">可以看到编译器默认实现的这些函数都是带有<code class="calibre10">noexcept</code>声明的。如果我们在类型<code class="calibre10">X</code>中加入某个成员变量<code class="calibre10">M</code>，情况会根据<code class="calibre10">M</code>的具体实现发生变化：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

struct M {
    M() {}
    M(const M&amp;) {}
    M(M&amp;&amp;) noexcept {}
    M operator= (const M&amp;) noexcept { return *this; }
    M operator= (M&amp;&amp;) { return *this; }
};

struct X {
    M m;
};

#define PRINT_NOEXCEPT(x)    \
    std::cout &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; std::endl

int main()
{
    X x;
    std::cout &lt;&lt; std::boolalpha;
    PRINT_NOEXCEPT(noexcept(X()));
    PRINT_NOEXCEPT(noexcept(X(x)));
    PRINT_NOEXCEPT(noexcept(X(std::move(x))));
    PRINT_NOEXCEPT(noexcept(x.operator=(x)));
    PRINT_NOEXCEPT(noexcept(x.operator=(std::move(x))));
}</code></pre>

  <p class="zw">这时的结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">noexcept(X()) = false
noexcept(X(x)) = false
noexcept(X(std::move(x))) = true
noexcept(x.operator=(x)) = true
noexcept(x.operator=(std::move(x))) = false</code></pre>

  <p class="zw">以上代码表明如果成员<code class="calibre10">m</code>的类型<code class="calibre10">M</code>自定义实现了默认函数，并且部分函数没有声明为<code class="calibre10">noexcept</code>，那么<code class="calibre10">X</code>对应的默认函数也会丢失<code class="calibre10">noexcept</code>声明。比如<code class="calibre10">M(){}</code>没有使用<code class="calibre10">noexcept</code>声明，导致<code class="calibre10">noexcept(X())</code>返回<code class="calibre10">false</code>，而<code class="calibre10">M(M&amp;&amp;) noexcept{}</code>使用了<code class="calibre10">noexcept</code>声明，则<code class="calibre10">noexcept(x.operator=(x))</code>返回<code class="calibre10">true</code>。</p>

  <p class="zw">2．类型的析构函数以及<code class="calibre10">delete</code>运算符默认带有<code class="calibre10">noexcept</code>声明，请注意即使自定义实现的析构函数也会默认带有<code class="calibre10">noexcept</code>声明，除非类型本身或者其基类和成员明确使用<code class="calibre10">noexcept(false)</code>声明析构函数，以上也同样适用于<code class="calibre10">delete</code>运算符：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

struct M {
    ~M() noexcept(false) {}
};

struct X {
};

struct X1 {
    ~X1() {}
};

struct X2 {
    ~X2() noexcept(false) {}
};

struct X3 {
    M m;
};

#define PRINT_NOEXCEPT(x)    \
    std::cout &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; std::endl

int main()
{
    X *x = new X;
    X1 *x1 = new X1;
    X2 *x2 = new X2;
    X3 *x3 = new X3;
    std::cout &lt;&lt; std::boolalpha;
    PRINT_NOEXCEPT(noexcept(x-&gt;~X()));
    PRINT_NOEXCEPT(noexcept(x1-&gt;~X1()));
    PRINT_NOEXCEPT(noexcept(x2-&gt;~X2()));
    PRINT_NOEXCEPT(noexcept(x3-&gt;~X3()));
    PRINT_NOEXCEPT(noexcept(delete x));
    PRINT_NOEXCEPT(noexcept(delete x1));
    PRINT_NOEXCEPT(noexcept(delete x2));
    PRINT_NOEXCEPT(noexcept(delete x3));
}</code></pre>

  <p class="zw">以上代码的运行输出结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">noexcept(x-&gt;~X()) = true
noexcept(x1-&gt;~X1()) = true
noexcept(x2-&gt;~X2()) = false
noexcept(x3-&gt;~X3()) = false
noexcept(delete x) = true
noexcept(delete x1) = true
noexcept(delete x2) = false
noexcept(delete x3) = false</code></pre>

  <p class="zw">可以看出<code class="calibre10">noexcept</code>运算符对于析构函数和<code class="calibre10">delete</code>运算符有着同样的结果。自定义析构函数<code class="calibre10">~X1()</code>依然会带有<code class="calibre10">noexcept</code>的声明，除非如同<code class="calibre10">~X2()</code>显示的声明<code class="calibre10">noexcept(false)</code>。<code class="calibre10">X3</code>有一个成员变量<code class="calibre10">m</code>，其类型<code class="calibre10">M</code>的析构函数被声明为<code class="calibre10">noexcept(false)</code>，这使<code class="calibre10">X3</code>的析构函数也被声明为<code class="calibre10">noexcept(false)</code>。</p>

  <h2 id="OEBPS/Text/chapter021.html.nav_point_163" class="sigil_not_in_toc">21.5　使用noexcept的时机</h2>

  <p class="zw">什么时候使用<code class="calibre10">noexcept</code>是一个关乎接口设计的问题。原因是一旦我们用<code class="calibre10">noexcept</code>声明了函数接口，就需要确保以后修改代码也不会抛出异常，不会有理由让我们删除<code class="calibre10">noexcept</code>声明。这是一种协议，试想一下，如果客户看到我们给出的接口使用了<code class="calibre10">noexcept</code>声明，他会自然而然地认为“哦好的，这个函数不会抛出异常，我不用为它添加额外的处理代码了”。如果某天，我们迫于业务需求撕毁了协议，并在某种情况下抛出异常，这对客户来说是很大的打击。因为编译器是不会提示客户，让他在代码中添加异常处理的。所以对于大多数函数和接口我们应该保持函数的异常中立。那么哪些函数可以使用<code class="calibre10">noexcept</code>声明呢？这里总结了两种情况。</p>

  <p class="zw">1．一定不会出现异常的函数。通常情况下，这种函数非常简短，例如求一个整数的绝对值、对基本类型的初始化等。</p>

  <p class="zw">2．当我们的目标是提供不会失败或者不会抛出异常的函数时可以使用<code class="calibre10">noexcept</code>声明。对于保证不会失败的函数，例如内存释放函数，一旦出现异常，相对于捕获和处理异常，终止程序是一种更好的选择。这也是<code class="calibre10">delete</code>会默认带有<code class="calibre10">noexcept</code>声明的原因。另外，对于保证不会抛出异常的函数而言，即使有错误发生，函数也更倾向用返回错误码的方式而不是抛出异常。</p>

  <p class="zw">除了上述两种理由，我认为保持函数的异常中立是一个明智的选择，因为将函数从没有<code class="calibre10">noexcept</code>声明修改为带<code class="calibre10">noexcept</code>声明并不会付出额外代价，而反过来的代价有可能是很大的。</p>

  <h2 id="OEBPS/Text/chapter021.html.nav_point_164" class="sigil_not_in_toc">21.6　将异常规范作为类型的一部分</h2>

  <p class="zw">在C++17标准之前，异常规范没有作为类型系统的一部分，所以下面的代码在编译阶段不会出现问题：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void(*fp)() noexcept = nullptr;
void foo() {}

int main()
{
  fp = &amp;foo;
}</code></pre>

  <p class="zw">在上面的代码中<code class="calibre10">fp</code>是一个指向确保不抛出异常的函数的指针，而函数<code class="calibre10">foo</code>则没有不抛出异常的保证。在C++17之前，它们的类型是相同的，也就是说<code class="calibre10">std::is_same &lt;decltype(fp), decltype(&amp;foo)&gt;::value</code>返回的结果为<code class="calibre10">true</code>。显然，这种宽松的规则会带来一些问题，例如一个会抛出异常的函数通过一个保证不抛出异常的函数指针进行调用，结果该函数确实抛出了异常，正常流程本应该是由程序捕获异常并进行下一步处理，但是由于函数指针保证不会抛出异常，因此程序直接调用<code class="calibre10">std::terminate</code>函数中止了程序：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;

void(*fp)() noexcept = nullptr;
void foo() 
{
  throw(5);
}

int main()
{
  fp = &amp;foo;
  try {
       fp();
  }
  catch (int e)
  {
       std::cout &lt;&lt; e &lt;&lt; std::endl;
  }
}</code></pre>

  <p class="zw">以上代码预期中的运行结果应该是输出数字5。但是由于函数指针的使用不当，导致程序意外中止并且只留下了一句：“terminate called after throwing an instance of ‘int’”。</p>

  <p class="zw">为了解决此类问题，C++17标准将异常规范引入了类型系统。这样一来，<code class="calibre10">fp = &amp;foo</code>就无法通过编译了，因为<code class="calibre10">fp</code>和<code class="calibre10">&amp;foo</code>变成了不同的类型，<code class="calibre10">std::is_same &lt;decltype(fp), decltype(&amp;foo)&gt;::value</code>会返回<code class="calibre10">false</code>。值得注意的是，虽然类型系统引入异常规范导致<code class="calibre10">noexcept</code>声明的函数指针无法接受没有<code class="calibre10">noexcept</code>声明的函数，但是反过来却是被允许的，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void(*fp)() = nullptr;
void foo() noexcept {}

int main()
{
  fp = &amp;foo;
}</code></pre>

  <p class="zw">这里的原因很容易理解，一方面这个设定可以保证现有代码的兼容性，旧代码不会因为没有声明<code class="calibre10">noexcept</code>的函数指针而编译报错。另一方面，在语义上也是可以接受的，因为函数指针既没有保证会抛出异常，也没有保证不会抛出异常，所以接受一个保证不会抛出异常的函数也合情合理。同样，虚函数的重写也遵守这个规则，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class Base {
public:
  virtual void foo() noexcept {}
};
class Derived : public Base {
public:
  void foo() override {};
};</code></pre>

  <p class="zw">以上代码无法编译成功，因为派生类试图用没有声明<code class="calibre10">noexcept</code>的虚函数重写基类中声明<code class="calibre10">noexcept</code>的虚函数，这是不允许的。但反过来是可以通过编译的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class Base {
public:
  virtual void foo() {}
};
class Derived : public Base {
public:
  void foo() noexcept override {};
};</code></pre>

  <p class="zw">最后需要注意的是模板带来的兼容性问题，在标准文档中给出了这样一个例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void g1() noexcept {}
void g2() {}
template&lt;class T&gt; void f(T *, T *) {}

int main()
{
  f(g1, g2);
}</code></pre>

  <p class="zw">在C++17中<code class="calibre10">g1</code>和<code class="calibre10">g2</code>已经是不同类型的函数，编译器无法推导出同一个模板参数，导致编译失败。为了让这段编译成功，需要简单修改一下函数模板：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T1, class T2&gt; void f(T1 *, T2 *) {}</code></pre>

  <h2 id="OEBPS/Text/chapter021.html.nav_point_165" class="sigil_not_in_toc">21.7　总结</h2>

  <p class="zw">异常规范是C++的语言功能特性之一，从C++11开始到C++17之前C++同时有两种异常规范，本章介绍的<code class="calibre10">noexcept</code>就是C++11新引入的一种，旧的动态异常则从C++17开始被废弃。相对于旧异常规范，新规范更加高效并且更加适合新增的C++特性，本章提到的对于移动构造函数的应用就是新规范的用法之一。另外值得注意的是，<code class="calibre10">noexcept</code>不仅是说明符同时也是运算符，它既能规定函数是否抛出异常也能获取到函数是否抛出异常，这一点让程序员有办法更为灵活地控制异常。最后，在函数类型中纳入异常规范可以完善C++的类型系统。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter021.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter022.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter022.html.nav_point_166" class="not-in-toc">第22章　类型别名和别名模板（C++11 C++14）</h1>

  <h2 id="OEBPS/Text/chapter022.html.nav_point_167" class="sigil_not_in_toc">22.1　类型别名</h2>

  <p class="zw">在C++的程序中，我们经常会看到特别长的类型名，比如<code class="calibre10">std::map&lt;int, std:: string&gt;::const_iterator</code>。为了让代码看起来更加简洁，往往会使用<code class="calibre10">typedef</code>为较长的类型名定义一个别名，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">typedef std::map&lt;int, std::string&gt;::const_iterator map_const_iter;
map_const_iter iter;</code></pre>

  <p class="zw">C++11标准提供了一个新的定义类型别名的方法，该方法使用<code class="calibre10">using</code>关键字，具体语法如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">using identifier = type-id</code></pre>

  <p class="zw">其中<code class="calibre10">identifier</code>是类型的别名标识符，<code class="calibre10">type-id</code>是已有的类型名。相对于<code class="calibre10">typedef</code>，我更喜欢<code class="calibre10">using</code>的语法，因为它很像是一个赋值表达式，只不过它所“赋值”的是一个类型。这种表达式在定义函数指针类型的别名时显得格外清晰：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">typedef void(*func1)(int, int);
using func2 = void(*)(int, int);</code></pre>

  <p class="zw">可以看到，使用<code class="calibre10">typedef</code>定义函数类型别名和定义其他类型别名是有所区别的，而使用<code class="calibre10">using</code>则不存在这种区别，这让使用<code class="calibre10">using</code>定义别名变得更加统一清晰。如果一定要找出<code class="calibre10">typedef</code>在定义类型别名上的一点优势，那应该只有对C语言的支持了。</p>

  <h2 id="OEBPS/Text/chapter022.html.nav_point_168" class="sigil_not_in_toc">22.2　别名模板</h2>

  <p class="zw">前面我们已经了解到使用<code class="calibre10">using</code>定义别名的基本用法，但是显然C++委员会不会因为这点内容就添加一个新的关键字。事实上<code class="calibre10">using</code>还承担着一个更加重要的特性——别名模板。所谓别名模板本质上也应该是一种模板，它的实例化过程是用自己的模板参数替换原始模板的模板参数，并实例化原始模板。定义别名模板的语法和定义类型别名并没有太大差异，只是多了模板形参列表：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt; template-parameter-list &gt;
using identifier = type-id;</code></pre>

  <p class="zw">其中<code class="calibre10">template-parameter-list</code>是模板的形参列表，而<code class="calibre10">identifier</code>和<code class="calibre10">type-id</code>是别名类模板型名和原始类模板型名。下面来看一个例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;map&gt;
#include &lt;string&gt;

template&lt;class T&gt;
using int_map = std::map&lt;int, T&gt;;

int main()
{
  int_map&lt;std::string&gt; int2string;
  int2string[11] = "7";
}</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">int_map</code>是一个别名模板，它有一个模板形参。当<code class="calibre10">int_map</code>发生实例化的时候，模板的实参<code class="calibre10">std::string</code>会替换<code class="calibre10">std::map&lt;int, T&gt;</code>中的<code class="calibre10">T</code>，所以真正实例化的类型是<code class="calibre10">std::map&lt;int, std::string&gt;</code>。通过这种方式，我们可以在模板形参比较多的时候简化模板形参。</p>

  <p class="zw">看到这里，有模板元编程经验的读者可能会提出<code class="calibre10">typedef</code>其实也能做到相同的事情。没错，我们是可以用<code class="calibre10">typedef</code>来改写上面的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;map&gt;
#include &lt;string&gt;

template&lt;class T&gt;
struct int_map {
  typedef std::map&lt;int, T&gt; type;
};

int main()
{
  int_map&lt;std::string&gt;::type int2string;
  int2string[11] = "7";
}</code></pre>

  <p class="zw">以上代码使用<code class="calibre10">typedef</code>和类型嵌套的方案也能达到同样的目的。不过很明显这种方案要复杂不少，不仅要定义一个<code class="calibre10">int_map</code>的结构体类型，还需要在类型里使用<code class="calibre10">typedef</code>来定义目标类型，最后必须使用<code class="calibre10">int_map&lt;std::string&gt;::type</code>来声明变量。除此之外，如果遇上了待决的类型，还需要在变量声明前加上<code class="calibre10">typename</code>关键字：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T&gt;
struct int_map {
  typedef std::map&lt;int, T&gt; type;
};

template&lt;class T&gt;
struct X {
  typename int_map&lt;T&gt;::type int2other;  // 必须带有typename关键字，否则编译错误
};</code></pre>

  <p class="zw">在上面这段代码中，类模板<code class="calibre10">X</code>没有确定模板形参<code class="calibre10">T</code>的类型，所以<code class="calibre10">int_map&lt;T&gt;::type</code>是一个未决类型，也就是说<code class="calibre10">int_map&lt;T&gt;::type</code>既有可能是一个类型，也有可能是一个静态成员变量，编译器是无法处理这种情况的。这里的<code class="calibre10">typename</code>关键字告诉编译器应该将<code class="calibre10">int_map&lt;T&gt;::type</code>作为类型来处理。而别名模板不会有<code class="calibre10">::type</code>的困扰，当然也不会有这样的问题了：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T&gt;
using int_map = std::map&lt;int, T&gt;;

template&lt;class T&gt;
struct X {
  int_map&lt;T&gt; int2other;      // 编译成功，别名模板不会有任何问题
};</code></pre>

  <p class="zw">值得一提的是，虽然别名模板有很多<code class="calibre10">typedef</code>不具备的优势，但是C++11标准库中的模板元编程函数都还是使用的<code class="calibre10">typedef</code>和类型嵌套的方案，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;bool, typename _Tp = void&gt;
struct enable_if { };

template&lt;typename _Tp&gt;
struct enable_if&lt;true, _Tp&gt;
{ typedef _Tp type; };</code></pre>

  <p class="zw">不过这种情况在C++14中得到了改善，在C++14标准库中模板元编程函数已经有了别名模板的版本。当然，为了保证与老代码的兼容性，<code class="calibre10">typedef</code>的方案依然存在。别名模板的模板元编程函数使用<code class="calibre10">_t</code>作为其名称的后缀以示区分：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;bool _Cond, typename _Tp = void&gt;
using enable_if_t = typename enable_if&lt;_Cond, _Tp&gt;::type;</code></pre>

  <h2 id="OEBPS/Text/chapter022.html.nav_point_169" class="sigil_not_in_toc">22.3　总结</h2>

  <p class="zw">本章介绍了使用<code class="calibre10">using</code>定义类型别名的方法，可以说这种新方法更符合C++的语法习惯。除此之外，使用<code class="calibre10">using</code>还可以定义别名模板，相对于内嵌类型实现类似别名模板的方案，该方法更加简单直接。建议读者在编译环境允许的情况下尝试使用<code class="calibre10">using</code>来定义别名。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter022.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter023.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter023.html.nav_point_170" class="not-in-toc">第23章　指针字面量nullptr（C++11）</h1>

  <h2 id="OEBPS/Text/chapter023.html.nav_point_171" class="sigil_not_in_toc">23.1　零值整数字面量</h2>

  <p class="zw">在C++标准中有一条特殊的规则，即<code class="calibre10">0</code>既是一个整型常量，又是一个空指针常量。<code class="calibre10">0</code>作为空指针常量还能隐式地转换为各种指针类型。比如我们在初始化变量的时候经常看到的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">char *p = NULL;
int x = 0;</code></pre>

  <p class="zw">这里的<code class="calibre10">NULL</code>是一个宏，在C++11标准之前其本质就是<code class="calibre10">0</code>：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
        #define NULL ((void *)0)
    #endif
#endif</code></pre>

  <p class="zw">在上面的代码中，C++将<code class="calibre10">NULL</code>定义为<code class="calibre10">0</code>，而C语言将<code class="calibre10">NULL</code>定义为<code class="calibre10">(void *)0</code>。之所以有所区别，是因为C++和C的标准定义不同，C++标准中定义空指针常量是评估为<code class="calibre10">0</code>的整数类型的常量表达式右值，而C标准中定义<code class="calibre10">0</code>为整型常量或者类型为<code class="calibre10">void *</code>的空指针常量。</p>

  <p class="zw">使用<code class="calibre10">0</code>代表不同类型的特殊规则给C++带来了二义性，对C++的学习和使用造成了不小的麻烦，下面是C++标准文档的两个例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">// 例子1
void f(int)
{
  std::cout &lt;&lt; "int" &lt;&lt; std::endl;
}

void f(char *)
{
  std::cout &lt;&lt; "char *" &lt;&lt; std::endl;
}

f(NULL);
f(reinterpret_cast&lt;char *&gt;(NULL));</code></pre>

  <p class="zw">在上面这段代码中<code class="calibre10">f(NULL)</code>函数调用的是<code class="calibre10">f(int)</code>函数，因为<code class="calibre10">NULL</code>会被优先解析为整数类型。没有办法让编译器自动识别传入<code class="calibre10">NULL</code>的意图，除非使用类型转换，将<code class="calibre10">NULL</code>转换到<code class="calibre10">char*</code>，<code class="calibre10">f(reinterpret_cast&lt;char *&gt;(NULL))</code>可以正确地调用<code class="calibre10">f(char *)</code>函数。注意，上面的代码可以在MSVC中编译执行。在GCC中，我们会得到一个<code class="calibre10">NULL</code>有二义性的错误提示。</p>

  <p class="zw">下面这个例子看起来就更加奇怪了：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">// 例子2
std::string s1(false);
std::string s2(true);</code></pre>

  <p class="zw">以上代码可以用MSVC编译，其中<code class="calibre10">s1</code>可以成功编译，但是<code class="calibre10">s2</code>则会编译失败。原因是<code class="calibre10">false</code>被隐式转换为<code class="calibre10">0</code>，而<code class="calibre10">0</code>又能作为空指针常量转换为<code class="calibre10">const char * const</code>，所以<code class="calibre10">s1</code>可以编译成功，<code class="calibre10">true</code>则没有这样的待遇。在GCC中，编译器对这种代码也进行了特殊处理，如果用<code class="calibre10">C++11(-std=c++11)</code>及其之后的标准来编译，则两条代码均会报错。但是如果用C++03以及之前的标准来编译，则虽然第一句代码能编译通过，但会给出警告信息，第二句代码依然编译失败。</p>

  <h2 id="OEBPS/Text/chapter023.html.nav_point_172" class="sigil_not_in_toc">23.2　nullptr关键字</h2>

  <p class="zw">鉴于<code class="calibre10">0</code>作为空指针常量的种种劣势，C++标准委员会在C++11中添加关键字<code class="calibre10">nullptr</code>表示空指针的字面量，它是一个<code class="calibre10">std::nullptr_t</code>类型的纯右值。<code class="calibre10">nullptr</code>的用途非常单纯，就是用来指示空指针，它不允许运用在算术表达式中或者与非指针类型进行比较（除了空指针常量<code class="calibre10">0</code>）。它还可以隐式转换为各种指针类型，但是无法隐式转换到非指针类型。注意，<code class="calibre10">0</code>依然保留着可以代表整数和空指针常量的特殊能力，保留这一点是为了让C++11标准兼容以前的C++代码。所以，下面给出的例子都能够顺利地通过编译：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">char* ch = nullptr;
char* ch2 = 0;
assert(ch == 0);
assert(ch == nullptr); 
assert(!ch);
assert(ch2 == nullptr);
assert(nullptr == 0);</code></pre>

  <p class="zw">将指针变量初始化为<code class="calibre10">0</code>或者<code class="calibre10">nullptr</code>的效果是一样的，在初始化以后它们也能够与<code class="calibre10">0</code>或者<code class="calibre10">nullptr</code>进行比较。从最后一句代码看出<code class="calibre10">nullptr</code>也可以和<code class="calibre10">0</code>直接比较，返回值为<code class="calibre10">true</code>。虽然<code class="calibre10">nullptr</code>可以和<code class="calibre10">0</code>进行比较，但这并不代表它的类型为整型，同时它也不能隐式转换为整型：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int n1 = nullptr;
char* ch1 = true ? 0 : nullptr;
int n2 = true ? nullptr : nullptr;
int n3 = true ? 0 : nullptr;</code></pre>

  <p class="zw">以上代码的第一句和第三句操作都是将一个<code class="calibre10">std::nullptr_t</code>类型赋值到<code class="calibre10">int</code>类型变量。由于这个转换并不能自动进行，因此会产生编译错误。而第二句和第四句中，因为条件表达式的 <code class="calibre10">:</code>前后类型不一致，而且无法简单扩展类型，所以同样会产生编译错误。请注意，上面代码中的第二句在MSVC中是可以编译通过的。</p>

  <p class="zw">进一步来看<code class="calibre10">nullptr</code>的类型<code class="calibre10">std::nullptr_t</code>，它并不是一个关键字，而是使用<code class="calibre10">decltype</code>将<code class="calibre10">nullptr</code>的类型定义在代码中，C++标准规定该类型的长度和<code class="calibre10">void *</code>相同：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">namespace std
{
  using nullptr_t = decltype(nullptr);
  // 等价于
  typedef decltype(nullptr) nullptr_t;
}

static_assert(sizeof(std::nullptr_t) == sizeof(void *));</code></pre>

  <p class="zw">我们还可以使用<code class="calibre10">std::nullptr_t</code>去创建自己的<code class="calibre10">nullptr</code>，并且有与<code class="calibre10">nullptr</code>相同的功能：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::nullptr_t null1, null2;

char* ch = null1;
char* ch2 = null2;
assert(ch == 0);
assert(ch == nullptr); 
assert(ch == null2);
assert(null1 == null2);
assert(nullptr == null1);</code></pre>

  <p class="zw">不过话说回来，虽然这段代码中<code class="calibre10">null1</code>、<code class="calibre10">null2</code>和<code class="calibre10">nullptr</code>的能力相同，但是它们还是有很大区别的。首先，<code class="calibre10">nullptr</code>是关键字，而其他两个是声明的变量。其次，<code class="calibre10">nullptr</code>是一个纯右值，而其他两个是左值：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::nullptr_t null1, null2;
std::cout &lt;&lt; "&amp;null1 = " &lt;&lt; &amp;null1 &lt;&lt; std::endl;  // null1和null2是左值，可
                                                  // 以成功获取对象指针，
std::cout &lt;&lt; "&amp;null2 = " &lt;&lt; &amp;null2 &lt;&lt; std::endl;  // 并且指针指向的内存地址不同</code></pre>

  <p class="zw">上面这段代码对<code class="calibre10">null1</code>和<code class="calibre10">null2</code>做了取地址的操作，并且返回不同的内存地址，证明它们都是左值。但是这个操作用在<code class="calibre10">nullptr</code>上肯定会产生编译错误：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::cout &lt;&lt; "&amp;nullptr = " &lt;&lt; &amp;nullptr &lt;&lt; std::endl;  // 编译失败，取地址操作
                                                      // 需要一个左值</code></pre>

  <p class="zw"><code class="calibre10">nullptr</code>是一个纯右值，对<code class="calibre10">nullptr进行</code>取地址操作就如同对常数取地址一样，这显然是错误的。讨论过<code class="calibre10">nullptr</code>的特性以后，我们再来看一看重载函数的例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void f(int)
{
  std::cout &lt;&lt; "int" &lt;&lt; std::endl;
}

void f(char *)
{
  std::cout &lt;&lt; "char *" &lt;&lt; std::endl;
}

f(nullptr);</code></pre>

  <p class="zw">以上代码的<code class="calibre10">f(nullptr)</code>会调用<code class="calibre10">f(char *)</code>，因为<code class="calibre10">nullptr</code>可以隐式转换为指针类型，而无法隐式转换为整型，所以编译器会找到形参为指针的函数版本。不过，如果这份代码中出现多个形参是指针的函数，则使用<code class="calibre10">nullptr</code>也会产生二义性，因为<code class="calibre10">nullptr</code>可以隐式转换为任何指针类型，所以编译器无法决定应该调用哪个形参为指针的函数。</p>

  <p class="zw">使用<code class="calibre10">nullptr</code>的另一个好处是，我们可以为函数模板或者类设计一些空指针类型的特化版本。在C++11以前这是不可能实现的，因为<code class="calibre10">0</code>的推导类型是<code class="calibre10">int</code>而不是空指针类型。现在我们可以利用<code class="calibre10">nullptr</code>的类型为<code class="calibre10">std::nullptr_t</code>写出下面的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

template&lt;class T&gt;
struct widget
{
  widget()
  {
       std::cout &lt;&lt; "template" &lt;&lt; std::endl;
  }
};

template&lt;&gt;
struct widget&lt;std::nullptr_t&gt;
{
  widget()
  {
       std::cout &lt;&lt; "nullptr" &lt;&lt; std::endl;
  }
};

template&lt;class T&gt;
widget&lt;T&gt;* make_widget(T)
{
  return new widget&lt;T&gt;();
}

int main()
{
  auto w1 = make_widget(0);
  auto w2 = make_widget(nullptr);
}</code></pre>

  <h2 id="OEBPS/Text/chapter023.html.nav_point_173" class="sigil_not_in_toc">23.3　总结</h2>

  <p class="zw"><code class="calibre10">nullptr</code>的出现消除了使用<code class="calibre10">0</code>带来的二义性，与此同时其类型和含义也更加明确。含义明确的好处是，C++标准可以加入一系列明确的规则去限制<code class="calibre10">nullptr</code>的使用，这让程序员能更快地发现编程时的错误。所以建议读者在编译器支持的情况下，总是优先使用<code class="calibre10">nullptr</code>而非<code class="calibre10">0</code>。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter023.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter024.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter024.html.nav_point_174" class="not-in-toc">第24章　三向比较（C++20）</h1>

  <h2 id="OEBPS/Text/chapter024.html.nav_point_175" class="sigil_not_in_toc">24.1　“太空飞船”（spaceship）运算符</h2>

  <p class="zw">C++20标准新引入了一个名为“太空飞船”（spaceship）的运算符<code class="calibre10">&lt;=&gt;</code>，它是一个三向比较运算符。<code class="calibre10">&lt;=&gt;</code>之所以被称为“太空飞船”运算符是因为<code class="calibre10">&lt;=&gt;</code>让著名的Perl语言专家兰德尔·L.施瓦茨想起1971年的一款电子游戏《星际迷航》中的太空飞船。读者应该也看出来了，<code class="calibre10">&lt;=&gt;</code>并不是C++20首创的，实际上Perl、PHP、Ruby等语言早已支持了三向比较运算符，C++是后来的学习者。</p>

  <p class="zw">顾名思义，三向比较就是在形如lhs &lt;=&gt; rhs的表达式中，两个比较的操作数<code class="calibre10">lhs</code>和<code class="calibre10">rhs</code>通过<code class="calibre10">&lt;=&gt;</code>比较可能产生3种结果，该结果可以和0比较，小于0、等于0或者大于0分别对应<code class="calibre10">lhs &lt; rhs</code>、<code class="calibre10">lhs == rhs</code>和<code class="calibre10">lhs &gt; rhs</code>。举例来说：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">bool b = 7 &lt;=&gt; 11 &lt; 0; // b == true</code></pre>

  <p class="zw">请注意，运算符<code class="calibre10">&lt;=&gt;</code>的返回值只能与0和自身类型来比较，如果同其他数值比较，编译器会报错：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">bool b = 7 &lt;=&gt; 11 &lt; 100; // 编译失败，&lt;=&gt;的结果不能与除0以外的数值比较</code></pre>

  <h2 id="OEBPS/Text/chapter024.html.nav_point_176" class="sigil_not_in_toc">24.2　三向比较的返回类型</h2>

  <p class="zw">可以看出<code class="calibre10">&lt;=&gt;</code>的返回结果并不是一个普通类型，根据标准三向比较会返回3种类型，分别为<code class="calibre10">std::strong_ordering</code>、<code class="calibre10">std::weak_ordering</code>以及<code class="calibre10">std:: partial_ordering</code>，而这3种类型又会分为有3～4种最终结果，下面就来一一介绍它们。</p>

  <h3 id="OEBPS/Text/chapter024.html.nav_point_177" class="sigil_not_in_toc1">24.2.1　std::strong_ordering</h3>

  <p class="zw"><code class="calibre10">std::strong_ordering</code>类型有3种比较结果，分别为<code class="calibre10">std::strong_ ordering::less</code>、<code class="calibre10">std::strong_ordering::equal</code>以及<code class="calibre10">std::strong_ ordering::greater</code>。表达式<code class="calibre10">lhs &lt;=&gt; rhs</code>分别表示<code class="calibre10">lhs &lt; rhs</code>、<code class="calibre10">lhs == rhs</code>以及<code class="calibre10">lhs &gt; rhs</code>。<code class="calibre10">std::strong_ordering</code>类型的结果强调的是<code class="calibre10">strong</code>的含义，表达的是一种可替换性，简单来说，若<code class="calibre10">lhs == rhs</code>，那么在任何情况下<code class="calibre10">rhs</code>和<code class="calibre10">lhs</code>都可以相互替换，也就是<code class="calibre10">fx(lhs) == fx(rhs)</code>。</p>

  <p class="zw">对于基本类型中的<code class="calibre10">int</code>类型，三向比较返回的是<code class="calibre10">std::strong_ordering</code>，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::cout &lt;&lt; typeid(decltype(7 &lt;=&gt; 11)).name();</code></pre>

  <p class="zw">用MSVC编译运行以上代码，会在输出窗口显示<code class="calibre10">class std::strong_ ordering</code>，刻意使用MSVC是因为它的<code class="calibre10">typeid(x).name()</code>可以输出友好可读的类型名称。对于有复杂结构的类型，<code class="calibre10">std::strong_ordering</code>要求其数据成员和基类的三向比较结果都为<code class="calibre10">std::strong_ordering</code>。例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;compare&gt;

struct B 
{
  int a;
  long b;
  auto operator &lt;=&gt; (const B&amp;) const = default;
};

struct D : B 
{
  short c;
  auto operator &lt;=&gt; (const D&amp;) const = default;
};

D x1, x2;
std::cout &lt;&lt; typeid(decltype(x1 &lt;=&gt; x2)).name();</code></pre>

  <p class="zw">上面这段代码用MSVC编译运行会输出<code class="calibre10">class std::strong_ordering</code>。请注意，默认情况下自定义类型是不存在三向比较运算符函数的，需要用户显式默认声明，比如在结构体<code class="calibre10">B</code>和<code class="calibre10">D</code>中声明<code class="calibre10">auto operator &lt;=&gt; (const B&amp;) const = default;</code>和<code class="calibre10">auto operator &lt;=&gt; (const D&amp;) const = default;</code>。对结构体<code class="calibre10">B</code>而言，由于<code class="calibre10">int</code>和<code class="calibre10">long</code>的比较结果都是<code class="calibre10">std::strong_ordering</code>，因此结构体<code class="calibre10">B</code>的三向比较结果也是<code class="calibre10">std::strong_ordering</code>。同理，对于结构体<code class="calibre10">D</code>，其基类和成员的比较结果是<code class="calibre10">std::strong_ordering</code>，<code class="calibre10">D</code>的三向比较结果同样是<code class="calibre10">std::strong_ordering</code>。另外，明确运算符的返回类型，使用<code class="calibre10">std::strong_ ordering</code>替换<code class="calibre10">auto</code>也是没问题的。</p>

  <h3 id="OEBPS/Text/chapter024.html.nav_point_178" class="sigil_not_in_toc1">24.2.2　std::weak_ordering</h3>

  <p class="zw"><code class="calibre10">std::weak_ordering</code>类型也有3种比较结果，分别为<code class="calibre10">std::weak_ ordering::less</code>、<code class="calibre10">std::weak_ordering::equivalent</code>以及<code class="calibre10">std::weak_ ordering::greater</code>。<code class="calibre10">std::weak_ordering</code>的含义正好与<code class="calibre10">std::strong_ ordering</code>相对，表达的是不可替换性。即若有<code class="calibre10">lhs == rhs</code>，则<code class="calibre10">rhs</code>和<code class="calibre10">lhs</code>不可以相互替换，也就是<code class="calibre10">fx(lhs) != fx(rhs)</code>。这种情况在基础类型中并没有，但是它常常发生在用户自定义类中，比如一个大小写不敏感的字符串类：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;compare&gt;
#include &lt;string&gt;

int ci_compare(const char* s1, const char* s2)
{
  while (tolower(*s1) == tolower(*s2++)) {
       if (*s1++ == '\0') {
            return 0;
       }
  }
  return tolower(*s1) - tolower(*--s2);
}

class CIString {
public:
  CIString(const char *s) : str_(s) {}

  std::weak_ordering operator&lt;=&gt;(const CIString&amp; b) const {
       return ci_compare(str_.c_str(), b.str_.c_str()) &lt;=&gt; 0;
  }
private:
  std::string str_;
};

CIString s1{ "HELLO" }, s2{"hello"};
std::cout &lt;&lt; (s1 &lt;=&gt; s2 == 0); // 输出为true</code></pre>

  <p class="zw">以上代码实现了一个简单的大小写不敏感的字符串类，它对于<code class="calibre10">s1</code>和<code class="calibre10">s2</code>的比较结果是<code class="calibre10">std::weak_ordering::equivalent</code>，表示两个操作数是等价的，但是它们不是相等的也不能相互替换。当<code class="calibre10">std::weak_ordering</code>和<code class="calibre10">std::strong_ ordering</code>同时出现在基类和数据成员的类型中时，该类型的三向比较结果是<code class="calibre10">std::weak_ordering</code>，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct D : B 
{
  CIString c{""};
  auto operator &lt;=&gt; (const D&amp;) const = default;
};

D w1, w2;
std::cout &lt;&lt; typeid(decltype(w1 &lt;=&gt; w2)).name();</code></pre>

  <p class="zw">用MSVC编译运行上面这段代码会输出<code class="calibre10">class std::weak_ordering</code>，因为<code class="calibre10">D</code>中的数据成员CIString的三向比较结果为<code class="calibre10">std::weak_ordering</code>。请注意，如果显式声明默认三向比较运算符函数为<code class="calibre10">std::strong_ordering operator &lt;=&gt; (const D&amp;) const = default;</code>，那么一定会遭遇到一个编译错误。</p>

  <h3 id="OEBPS/Text/chapter024.html.nav_point_179" class="sigil_not_in_toc1">24.2.3　std::partial_ordering</h3>

  <p class="zw"><code class="calibre10">std::partial_ordering</code>类型有4种比较结果，分别为<code class="calibre10">std::partial_ ordering::less</code>、<code class="calibre10">std::partial_ordering::equivalent</code>、<code class="calibre10">std::partial_ ordering::greater</code>以及<code class="calibre10">std::partial_ordering::unordered</code>。<code class="calibre10">std:: partial_ordering</code>约束力比<code class="calibre10">std::weak_ordering</code>更弱，它可以接受当<code class="calibre10">lhs == rhs</code>时<code class="calibre10">rhs</code>和<code class="calibre10">lhs</code>不能相互替换，同时它还能给出第四个结果<code class="calibre10">std::partial_ ordering::unordered</code>，表示进行比较的两个操作数没有关系。比如基础类型中的浮点数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::cout &lt;&lt; typeid(decltype(7.7 &lt;=&gt; 11.1)).name();</code></pre>

  <p class="zw">用MSVC编译运行以上代码会输出<code class="calibre10">class std::partial_ordering</code>。之所以会输出<code class="calibre10">class std::partial_ordering</code>而不是<code class="calibre10">std::strong_ordering</code>，是因为浮点的集合中存在一个特殊的NaN，它和其他浮点数值是没关系的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::cout &lt;&lt; ((0.0 / 0.0 &lt;=&gt; 1.0) == std::partial_ordering::unordered);</code></pre>

  <p class="zw">这段代码编译输出的结果为<code class="calibre10">true</code>。当<code class="calibre10">std::weak_ordering</code>和<code class="calibre10">std::　partial_ordering</code>同时出现在基类和数据成员的类型中时，该类型的三向比较结果是<code class="calibre10">std::partial_ordering</code>，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct D : B 
{
  CIString c{""};
  float u;
  auto operator &lt;=&gt; (const D&amp;) const = default;
};

D w1, w2;
std::cout &lt;&lt; typeid(decltype(w1 &lt;=&gt; w2)).name();</code></pre>

  <p class="zw">用MSVC编译运行以上代码会输出<code class="calibre10">class std::partial_ordering</code>，因为<code class="calibre10">D</code>中的数据成员<code class="calibre10">u</code>的三向比较结果为<code class="calibre10">std::partial_ordering</code>，同样，显式声明为其他返回类型也会让编译器报错。在C++20的标准库中有一个模板元函数<code class="calibre10">std::common_comparison_category</code>，它可以帮助我们在一个类型合集中判断出最终三向比较的结果类型，当类型合集中存在不支持三向比较的类型时，该模板元函数返回<code class="calibre10">void</code>。</p>

  <p class="zw">再次强调一下，<code class="calibre10">std::strong_ordering</code>、<code class="calibre10">std::weak_ordering</code>和<code class="calibre10">`std::partial_ordering`只能与`0`和类型自身比较。深究其原因，是这3个类只实现了参数类型为自身类型和`nullptr_t</code>的比较运算符函数。</p>

  <h2 id="OEBPS/Text/chapter024.html.nav_point_180" class="sigil_not_in_toc">24.3　对基础类型的支持</h2>

  <p class="zw">1．对两个算术类型的操作数进行一般算术转换，然后进行比较。其中整型的比较结果为<code class="calibre10">std::strong_ordering</code>，浮点型的比较结果为<code class="calibre10">std::partial_ordering</code>。例如<code class="calibre10">7 &lt;=&gt; 11.1</code>中，整型<code class="calibre10">7</code>会转换为浮点类型，然后再进行比较，最终结果为<code class="calibre10">std::partial_ordering</code>类型。</p>

  <p class="zw">2．对于无作用域枚举类型和整型操作数，枚举类型会转换为整型再进行比较，无作用域枚举类型无法与浮点类型比较：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">enum color {
  red
};

auto r = red &lt;=&gt; 11;   //编译成功
auto r = red &lt;=&gt; 11.1; //编译失败</code></pre>

  <p class="zw">3．对两个相同枚举类型的操作数比较结果，如果枚举类型不同，则无法编译。</p>

  <p class="zw">4．对于其中一个操作数为<code class="calibre10">bool</code>类型的情况，另一个操作数必须也是<code class="calibre10">bool</code>类型，否则无法编译。比较结果为<code class="calibre10">std::strong_ordering</code>。</p>

  <p class="zw">5．不支持作比较的两个操作数为数组的情况，会导致编译出错，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int arr1[5];
int arr2[5];
auto r = arr1 &lt;=&gt; arr2; // 编译失败</code></pre>

  <p class="zw">6．对于其中一个操作数为指针类型的情况，需要另一个操作数是同样类型的指针，或者是可以转换为相同类型的指针，比如数组到指针的转换、派生类指针到基类指针的转换等，最终比较结果为<code class="calibre10">std::strong_ordering</code>：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">char arr1[5];
char arr2[5];
char* ptr = arr2;
auto r = ptr &lt;=&gt; arr1;</code></pre>

  <p class="zw">上面的代码可以编译成功，若将代码中的<code class="calibre10">arr1</code>改写为<code class="calibre10">int arr1[5]</code>，则无法编译，因为<code class="calibre10">int [5]</code>无法转换为<code class="calibre10">char *</code>。如果将<code class="calibre10">char * ptr = arr2;</code>修改为<code class="calibre10">void * ptr = arr2;</code>，代码就可以编译成功了。</p>

  <h2 id="OEBPS/Text/chapter024.html.nav_point_181" class="sigil_not_in_toc">24.4　自动生成的比较运算符函数</h2>

  <p class="zw">标准库中提供了一个名为<code class="calibre10">std::rel_ops</code>的命名空间，在用户自定义类型已经提供了<code class="calibre10">==</code>运算符函数和&lt;运算符函数的情况下，帮助用户实现其他4种运算符函数，包括<code class="calibre10">!=</code>、<code class="calibre10">&gt;</code>、<code class="calibre10">&lt;=</code>和<code class="calibre10">&gt;=</code>，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;string&gt;
#include &lt;utility&gt;
class CIString2 {
public:
  CIString2(const char* s) : str_(s) {}

  bool operator &lt; (const CIString2&amp; b) const {
       return ci_compare(str_.c_str(), b.str_.c_str()) &lt; 0;
  }
private:
  std::string str_;
};

using namespace std::rel_ops;
CIString2 s1{ "hello" }, s2{ "world" };
bool r = s1 &gt;= s2;</code></pre>

  <p class="zw">不过因为C++20标准有了三向比较运算符的关系，所以不推荐上面这种做法了。C++20标准规定，如果用户为自定义类型声明了三向比较运算符，那么编译器会为其自动生成<code class="calibre10">&lt;</code>、<code class="calibre10">&gt;</code>、<code class="calibre10">&lt;=</code>和<code class="calibre10">&gt;=</code>这4种运算符函数。对于<code class="calibre10">CIString</code>我们可以直接使用这4种运算符函数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">CIString s1{ "hello" }, s2{ "world" };
bool r = s1 &gt;= s2;</code></pre>

  <p class="zw">那么这里就会产生一个疑问，很明显三向比较运算符能表达两个操作数是相等或者等价的含义，为什么标准只允许自动生成4种运算符函数，却不能自动生成==和=!这两个运算符函数呢？实际上这里存在一个严重的性能问题。在C++20标准拟定三向比较的早期，是允许通过三向比较自动生成6个比较运算符函数的，而三向比较的结果类型也不是3种而是5种，多出来的两种分别是<code class="calibre10">std::strong_ equality</code>和<code class="calibre10">std::weak_equality</code>。但是在提案文档p1190中提出了一个严重的性能问题。简单来说，假设有一个结构体：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct S {
    std::vector&lt;std::string&gt; names;
    auto operator&lt;=&gt;(const S &amp;) const = default;
};</code></pre>

  <p class="zw">它的三向比较运算符的默认实现这样的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;typename T&gt;
std::strong_ordering operator&lt;=&gt;(const std::vector&lt;T&gt;&amp; lhs, const std::vector&lt;T&gt; &amp; rhs) 
{
    size_t min_size = min(lhs.size(), rhs.size());
    for (size_t i = 0; i != min_size; ++i) {
        if (auto const cmp = std::compare_3way(lhs[i], rhs[i]); cmp != 0) {
            return cmp;
        }
    }
    return lhs.size() &lt;=&gt; rhs.size();
}</code></pre>

  <p class="zw">这个实现对于<code class="calibre10">&lt;</code>和<code class="calibre10">&gt;</code>这样的运算符函数没有问题，因为需要比较容器中的每个元素。但是<code class="calibre10">==</code>运算符就显得十分低效，对于<code class="calibre10">==</code>运算符高效的做法是先比较容器中的元素数量是否相等，如果元素数量不同，则直接返回<code class="calibre10">false</code>：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;typename T&gt;
bool operator==(const std::vector&lt;T&gt;&amp; lhs, const std::vector&lt;T&gt;&amp; rhs)
{
    const size_t size = lhs.size();
    if (size != rhs.size()) {
        return false;
    }

    for (size_t i = 0; i != size; ++i) {
        if (lhs[i] != rhs[i]) {
            return false;
        }
    }
    return true;
}</code></pre>

  <p class="zw">想象一下，如果标准允许用三向比较的算法自动生成<code class="calibre10">==</code>运算符函数会发生什么事情，很多旧代码升级编译环境后会发现运行效率下降了，尤其是在容器中元素数量众多且每个元素数据量庞大的情况下。很少有程序员会注意到三向比较算法的细节，导致这个性能问题难以排查。基于这种考虑，C++委员会修改了原来的三向比较提案，规定声明三向比较运算符函数只能够自动生成4种比较运算符函数。由于不需要负责判断是否相等，因此<code class="calibre10">std::strong_equality</code>和<code class="calibre10">std::weak_ equality</code>也退出了历史舞台。对于<code class="calibre10">==</code>和<code class="calibre10">!=</code>两种比较运算符函数，只需要多声明一个<code class="calibre10">==</code>运算符函数，<code class="calibre10">!=</code>运算符函数会根据前者自动生成：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class CIString {
public:
  CIString(const char* s) : str_(s) {}

  std::weak_ordering operator&lt;=&gt;(const CIString&amp; b) const {
       return ci_compare(str_.c_str(), b.str_.c_str()) &lt;=&gt; 0;
  }

  bool operator == (const CIString&amp; b) const {
       return ci_compare(str_.c_str(), b.str_.c_str()) == 0;
  }
private:
  std::string str_;
};

CIString s1{ "hello" }, s2{ "world" };
bool r1 = s1 &gt;= s2; // 调用operator&lt;=&gt;
bool r2 = s1 == s2; // 调用operator ==</code></pre>

  <h2 id="OEBPS/Text/chapter024.html.nav_point_182" class="sigil_not_in_toc">24.5　兼容旧代码</h2>

  <p class="zw">现在C++20标准已经推荐使用<code class="calibre10">&lt;=&gt;</code>和<code class="calibre10">==</code>运算符自动生成其他比较运算符函数，而使用<code class="calibre10">&lt;</code>、<code class="calibre10">==</code>以及<code class="calibre10">std::rel_ops</code>生成其他比较运算符函数则会因为<code class="calibre10">std::rel_ops</code>已经不被推荐使用而被编译器警告。那么对于老代码，我们是否需要去实现一套<code class="calibre10">&lt;=&gt;</code>和<code class="calibre10">==</code>运算符函数呢？其实大可不必，C++委员会在裁决这项修改的时候已经考虑到老代码的维护成本，所以做了兼容性处理，即在用户自定义类型中，实现了&lt;、==运算符函数的数据成员类型，在该类型的三向比较中将自动生成合适的比较代码。比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct Legacy {
  int n;
  bool operator==(const Legacy&amp; rhs) const
  {
       return n == rhs.n;
  }
  bool operator&lt;(const Legacy&amp; rhs) const
  {
       return n &lt; rhs.n;
  }
};

struct TreeWay {
  Legacy m;
  std::strong_ordering operator&lt;=&gt;(const TreeWay &amp;) const = default;
};

TreeWay t1, t2;
bool r = t1 &lt; t2;</code></pre>

  <p class="zw">在上面的代码中，结构体<code class="calibre10">TreeWay</code>的三向比较操作会调用结构体<code class="calibre10">Legacy</code>中的<code class="calibre10">&lt;</code>和<code class="calibre10">==</code>运算符来完成，其代码类似于：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct TreeWay {
  Legacy m;
  std::strong_ordering operator&lt;=&gt;(const TreeWay&amp; rhs) const {
       if (m &lt; rhs.m) return std::strong_ordering::less;
       if (m == rhs.m) return std::strong_ordering::equal;
       return std::strong_ordering::greater;
  }
};</code></pre>

  <p class="zw">需要注意的是，这里<code class="calibre10">operator&lt;=&gt;</code>必须显式声明返回类型为<code class="calibre10">std::strong_ ordering</code>，使用<code class="calibre10">auto</code>是无法通过编译的。</p>

  <h2 id="OEBPS/Text/chapter024.html.nav_point_183" class="sigil_not_in_toc">24.6　总结</h2>

  <p class="zw">本章介绍了C++20新增的三向比较特性，该特性的引入为实现比较运算提供了方便。我们只需要实现<code class="calibre10">==</code>和<code class="calibre10">&lt;=&gt;</code>两个运算符函数，剩下的4个运算符函数就可以交给编译器自动生成了。虽说<code class="calibre10">std::rel_ops</code>在实现了<code class="calibre10">==</code>和<code class="calibre10">&lt;</code>两个运算符函数以后也能自动提供剩下的4个运算符函数，但显然用三向比较更加便捷。另外，三向比较提供的3种结果类型也是<code class="calibre10">std::rel_ops</code>无法媲美的。进一步来说，由于三向比较的出现，<code class="calibre10">std::rel_ops</code>在C++20中已经不被推荐使用了。最后，C++委员会没有忘记兼容性问题，这让三向比较能够通过运算符函数<code class="calibre10">&lt;</code>和<code class="calibre10">==</code>来自动生成。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter024.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter025.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter025.html.nav_point_184" class="not-in-toc">第25章　线程局部存储（C++11）</h1>

  <h2 id="OEBPS/Text/chapter025.html.nav_point_185" class="sigil_not_in_toc">25.1　操作系统和编译器对线程局部存储的支持</h2>

  <p class="zw">线程局部存储是指对象内存在线程开始后分配，线程结束时回收且每个线程有该对象自己的实例，简单地说，线程局部存储的对象都是独立于各个线程的。实际上，这并不是一个新鲜的概念，虽然C++一直没有在语言层面支持它，但是很早之前操作系统就有办法支持线程局部存储了。</p>

  <p class="zw">由于线程本身是操作系统中的概念，因此线程局部存储这个功能是离不开操作系统支持的。而不同的操作系统对线程局部存储的实现也不同，以至于使用的系统API也有区别，这里主要以Windows和Linux为例介绍它们使用线程局部存储的方法。</p>

  <p class="zw">在Windows中可以通过调用API函数<code class="calibre10">TlsAlloc</code>来分配一个未使用的线程局部存储槽索引（TLS slot index），这个索引实际上是Windows内部线程环境块（TEB）中线程局部存储数组的索引。通过API函数<code class="calibre10">TlsGetValue</code>与<code class="calibre10">TlsSetValue</code>可以获取和设置线程局部存储数组对应于索引元素的值。API函数<code class="calibre10">TlsFree</code>用于释放线程局部存储槽索引。</p>

  <p class="zw">Linux使用了pthreads（POSIX threads）作为线程接口，在pthreads中我们可以调用<code class="calibre10">pthread_key_create</code>与<code class="calibre10">pthread_key_delete</code>创建与删除一个类型为<code class="calibre10">pthread_key_t</code>的键。利用这个键可以使用<code class="calibre10">pthread_setspecific</code>函数设置线程相关的内存数据，当然，我们随后还能够通过<code class="calibre10">pthread_getspecific</code>函数获取之前设置的内存数据。</p>

  <p class="zw">在C++11标准确定之前，各个编译器也用了自定义的方法支持线程局部存储。比如<code class="calibre10">gcc</code>和<code class="calibre10">clang</code>添加了关键字<code class="calibre10">__thread</code>来声明线程局部存储变量，而Visual Studio C++则是使用<code class="calibre10">__declspec(thread)</code>。虽然它们都有各自的方法声明线程局部存储变量，但是其使用范围和规则却存在一些区别，这种情况增加了C++的学习成本，也是C++标准委员会不愿意看到的。于是在C++11标准中正式添加了新的<code class="calibre10">thread_local</code>说明符来声明线程局部存储变量。</p>

  <h2 id="OEBPS/Text/chapter025.html.nav_point_186" class="sigil_not_in_toc">25.2　thread_local说明符</h2>

  <p class="zw"><code class="calibre10">thread_local</code>说明符可以用来声明线程生命周期的对象，它能与<code class="calibre10">static</code>或<code class="calibre10">extern</code>结合，分别指定内部或外部链接，不过额外的<code class="calibre10">static</code>并不影响对象的生命周期。换句话说，<code class="calibre10">static</code>并不影响其线程局部存储的属性：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct X {
  thread_local static int i;
};

thread_local X a;

int main()
{
  thread_local X b;
}</code></pre>

  <p class="zw">从上面的代码可以看出，声明一个线程局部存储变量相当简单，只需要在普通变量声明上添加<code class="calibre10">thread_local</code>说明符。被<code class="calibre10">thread_local</code>声明的变量在行为上非常像静态变量，只不过多了线程属性，当然这也是线程局部存储能出现在我们的视野中的一个关键原因，它能够解决全局变量或者静态变量在多线程操作中存在的问题，一个典型的例子就是<code class="calibre10">errno</code>。</p>

  <p class="zw"><code class="calibre10">errno</code>通常用于存储程序当中上一次发生的错误，早期它是一个静态变量，由于当时大多数程序是单线程的，因此没有任何问题。但是到了多线程时代，这种<code class="calibre10">errno</code>就不能满足需求了。设想一下，一个多线程程序的线程A在某个时刻刚刚调用过一个函数，正准备获取其错误码，也正是这个时刻，另外一个线程B在执行了某个函数后修改了这个错误码，那么线程A接下来获取的错误码自然不会是它真正想要的那个。这种线程间的竞争关系破坏了<code class="calibre10">errno</code>的准确性，导致不可确定的结果。为了规避由此产生的不确定性，POSIX将<code class="calibre10">errno</code>重新定义为线程独立的变量，为了实现这个定义就需要用到线程局部存储，直到C++11之前，<code class="calibre10">errno</code>都是一个静态变量，而从C++11开始<code class="calibre10">errno</code>被修改为一个线程局部存储变量。</p>

  <p class="zw">在了解了线程局部存储的意义之后，让我们回头仔细阅读其定义，会发现线程局部存储只是定义了对象的生命周期，而没有定义可访问性。也就是说，我们可以获取线程局部存储变量的地址并将其传递给其他线程，并且其他线程可以在其生命周期内自由使用变量。不过这样做除了用于诊断功能以外没有实际意义，而且其危险性过大，一旦没有掌握好目标线程的声明周期，就很可能导致内存访问异常，造成未定义的程序行为，通常情况下是程序崩溃。</p>

  <p class="zw">值得注意的是，使用取地址运算符<code class="calibre10">&amp;</code>取到的线程局部存储变量的地址是运行时被计算出来的，它不是一个常量，也就是说无法和<code class="calibre10">constexpr</code>结合：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">thread_local int tv;
static int sv;

int main()
{
  constexpr int *sp = &amp;sv;    // 编译成功，sv的地址在编译时确定
  constexpr int *tp = &amp;tv;    // 编译失败，tv的地址在运行时确定
}</code></pre>

  <p class="zw">在上面的代码中，由于<code class="calibre10">sv</code>是一个静态变量，因此在编译时可以获取其内存常量地址，并赋值到常量表达式<code class="calibre10">sp</code>。但是<code class="calibre10">tv</code>则不同，它在线程创建时才可能确定内存地址，所以这里会产生编译错误。</p>

  <p class="zw">最后来说明一下线程局部存储对象的初始化和销毁。在同一个线程中，一个线程局部存储对象只会初始化一次，即使在某个函数中被多次调用。这一点和单线程程序中的静态对象非常相似。相对应的，对象的销毁也只会发生一次，通常发生在线程退出的时刻。下面来看一个例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;

std::mutex g_out_lock;

struct RefCount {
  RefCount(const char* f) : i(0), func(f) {
       std::lock_guard&lt;std::mutex&gt; lock(g_out_lock);
       std::cout &lt;&lt; std::this_thread::get_id()
            &lt;&lt; "|" &lt;&lt; func
            &lt;&lt; " : ctor i(" &lt;&lt; i &lt;&lt; ")" &lt;&lt; std::endl;
  }

  ~RefCount() {
       std::lock_guard&lt;std::mutex&gt; lock(g_out_lock);
       std::cout &lt;&lt; std::this_thread::get_id()
            &lt;&lt; "|" &lt;&lt; func
            &lt;&lt; " : dtor i(" &lt;&lt; i &lt;&lt; ")" &lt;&lt; std::endl;
  }

  void inc()
  {
       std::lock_guard&lt;std::mutex&gt; lock(g_out_lock);
       std::cout &lt;&lt; std::this_thread::get_id()
            &lt;&lt; "|" &lt;&lt; func
            &lt;&lt; " : ref count add 1 to i(" &lt;&lt; i &lt;&lt; ")" &lt;&lt; std::endl;
       i++;
  }

  int i;
  std::string func;
};
RefCount *lp_ptr = nullptr;

void foo(const char* f)
{
  std::string func(f);
  thread_local RefCount tv(func.append("#foo").c_str());
  tv.inc();
}

void bar(const char* f)
{
  std::string func(f);
  thread_local RefCount tv(func.append("#bar").c_str());
  tv.inc();
}

void threadfunc1()
{
  const char* func = "threadfunc1";
  foo(func);
  foo(func);
  foo(func);
}

void threadfunc2()
{
  const char* func = "threadfunc2";
  foo(func);
  foo(func);
  foo(func);
}

void threadfunc3()
{
  const char* func = "threadfunc3";
  foo(func);
  bar(func);
  bar(func);
}

int main()
{
  std::thread t1(threadfunc1);
  std::thread t2(threadfunc2);
  std::thread t3(threadfunc3);

  t1.join();
  t2.join();
  t3.join();
}</code></pre>

  <p class="zw">上面的代码并发3个工作线程，前两个线程<code class="calibre10">threadfunc1</code>和<code class="calibre10">threadfunc2</code>分别调用了3次<code class="calibre10">foo</code>函数。而第三个线程<code class="calibre10">threadfunc3</code>调用了1次<code class="calibre10">foo</code>函数和2次<code class="calibre10">bar</code>函数。其中<code class="calibre10">foo</code>和<code class="calibre10">bar</code>函数的功能相似，它们分别声明并初始化了一个线程局部存储对象<code class="calibre10">tv</code>，并调用其自增函数<code class="calibre10">inc</code>，而<code class="calibre10">inc</code>函数会递增对象成员变量<code class="calibre10">i</code>。为了保证输出的日志不会受到线程竞争的干扰，在输出之前加了互斥锁。下面是在Windows上的运行结果：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">27300|threadfunc1#foo : ctor i(0)
27300|threadfunc1#foo : ref count add 1 to i(0)
27300|threadfunc1#foo : ref count add 1 to i(1)
27300|threadfunc1#foo : ref count add 1 to i(2)
25308|threadfunc3#foo : ctor i(0)
25308|threadfunc3#foo : ref count add 1 to i(0)
25308|threadfunc3#bar : ctor i(0)
25308|threadfunc3#bar : ref count add 1 to i(0)
25308|threadfunc3#bar : ref count add 1 to i(1)
10272|threadfunc2#foo : ctor i(0)
10272|threadfunc2#foo : ref count add 1 to i(0)
10272|threadfunc2#foo : ref count add 1 to i(1)
10272|threadfunc2#foo : ref count add 1 to i(2)
27300|threadfunc1#foo : dtor i(3)
25308|threadfunc3#bar : dtor i(2)
25308|threadfunc3#foo : dtor i(1)
10272|threadfunc2#foo : dtor i(3)</code></pre>

  <p class="zw">从结果可以看出，线程<code class="calibre10">threadfunc1</code>和<code class="calibre10">threadfunc2</code>分别只调用了一次构造和析构函数，而且引用计数的递增也不会互相干扰，也就是说两个线程中线程局部存储对象是独立存在的。对于线程<code class="calibre10">threadfunc3</code>，它进行了两次线程局部存储对象的构造和析构，这两次分别对应<code class="calibre10">foo</code>和<code class="calibre10">bar</code>函数里的线程局部存储对象<code class="calibre10">tv</code>。可以发现，虽然这两个对象具有相同的对象名，但是由于不在同一个函数中，因此也应该认为是相同线程中不同的线程局部存储对象，它们的引用计数的递增同样不会相互干扰。</p>

  <h2 id="OEBPS/Text/chapter025.html.nav_point_187" class="sigil_not_in_toc">25.3　总结</h2>

  <p class="zw">多线程已经成为现代程序应用中不可缺少的技术环节，但是在C++11标准出现之前，C++语言标准对多线程的支持是不完善的，无法创建线程局部存储对象就是其中的一个缺陷。幸好C++11的推出挽救了这种尴尬的局面。本章中介绍的<code class="calibre10">thread_ local</code>说明符终于让C++在语言层面统一了声明线程局部存储对象的方法。当然，想要透彻地理解线程局部存储，只是学习<code class="calibre10">thread_local</code>说明符的内容是不够的，还需要深入操作系统层面，探究系统处理线程局部存储的方法。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter025.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter026.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter026.html.nav_point_188" class="not-in-toc">第26章　扩展的inline说明符（C++17）</h1>

  <h2 id="OEBPS/Text/chapter026.html.nav_point_189" class="sigil_not_in_toc">26.1　定义非常量静态成员变量的问题</h2>

  <p class="zw">在C++17标准之前，定义类的非常量静态成员变量是一件让人头痛的事情，因为变量的声明和定义必须分开进行，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;

class X {
public:
  static std::string text;
};

std::string X::text{ "hello" };

int main()
{
  X::text += " world";
  std::cout &lt;&lt; X::text &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">在这里<code class="calibre10">static std::string text</code>是静态成员变量的声明，<code class="calibre10">std::string X::text{ "hello" }</code>是静态成员变量的定义和初始化。为了保证代码能够顺利地编译，我们必须保证静态成员变量的定义有且只有一份，稍有不慎就会引发错误，比较常见的错误是为了方便将静态成员变量的定义放在头文件中：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#ifndef X_H
#define X_H
class X {
public:
  static std::string text;
};

std::string X::text{ "hello" };
#endif</code></pre>

  <p class="zw">将上面的代码包含到多个CPP文件中会引发一个链接错误，因为<code class="calibre10">include</code>是单纯的宏替换，所以会存在多份<code class="calibre10">X::text</code>的定义导致链接失败。对于一些字面量类型，比如整型、浮点类型等，这种情况有所缓解，至少对于它们而言常量静态成员变量是可以一边声明一边定义的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;

class X {
public:
  static const int num{ 5 };
};

int main()
{
  std::cout &lt;&lt; X::num &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">不过有得有失，虽然常量性能让它们方便地声明和定义，但却丢失了修改变量的能力。对于<code class="calibre10">std::string</code>这种非字面量类型，这种方法是无能为力的。</p>

  <h2 id="OEBPS/Text/chapter026.html.nav_point_190" class="sigil_not_in_toc">26.2　使用inline说明符</h2>

  <p class="zw">为了解决上面这些问题，C++17标准中增强了<code class="calibre10">inline</code>说明符的能力，它允许我们内联定义静态变量，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;

class X {
public:
  inline static std::string text{"hello"};
};

int main()
{
  X::text += " world";
  std::cout &lt;&lt; X::text &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">上面的代码可以成功编译和运行，而且即使将类<code class="calibre10">X</code>的定义作为头文件包含在多个CPP中也不会有任何问题。在这种情况下，编译器会在类 <code class="calibre10">X</code>的定义首次出现时对内联静态成员变量进行定义和初始化。</p>

  <h2 id="OEBPS/Text/chapter026.html.nav_point_191" class="sigil_not_in_toc">26.3　总结</h2>

  <p class="zw">本章介绍的<code class="calibre10">inline</code>说明符的扩展特性解决了C++中定义静态成员变量烦琐且容易出错的问题，它让编译器能够聪明地选择首次出现的变量进行定义和初始化。这种能力也正是<code class="calibre10">inline</code>说明符的提案文档中的第一段话所提到的：“<code class="calibre10">inline</code>说明符可以应用于变量以及函数。声明为<code class="calibre10">inline</code>的变量与函数具有相同的语义：它们一方面可以在多个翻译单元中定义，另一方面又必须在每个使用它们的翻译单元中定义，并且程序的行为就像是同一个变量。”</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter026.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter027.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter027.html.nav_point_192" class="not-in-toc">第27章　常量表达式（C++11～C++20）</h1>

  <h2 id="OEBPS/Text/chapter027.html.nav_point_193" class="sigil_not_in_toc">27.1　常量的不确定性</h2>

  <p class="zw">在C++11标准以前，我们没有一种方法能够有效地要求一个变量或者函数在编译阶段就计算出结果。由于无法确保在编译阶段得出结果，导致很多看起来合理的代码却引来编译错误。这些场景主要集中在需要编译阶段就确定的值语法中，比如<code class="calibre10">case</code>语句、数组长度、枚举成员的值以及非类型的模板参数。让我们先看一看这些场景的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">const int index0 = 0;
#define index1 1

// case语句
switch (argc)
{
case  index0:
    std::cout &lt;&lt; "index0" &lt;&lt; std::endl;
    break;
case index1:
    std::cout &lt;&lt; "index1" &lt;&lt; std::endl;
    break;
default:
    std::cout &lt;&lt; "none" &lt;&lt; std::endl;
}

const int x_size = 5 + 8;
#define y_size 6 + 7
// 数组长度
char buffer[x_size][y_size] = { 0 };

// 枚举成员
enum {
    enum_index0 = index0,
    enum_index1 = index1,
};

std::tuple&lt;int, char&gt; tp = std::make_tuple(4, '3');
// 非类型的模板参数
int x1 = std::get&lt;index0&gt;(tp);
char x2 = std::get&lt;index1&gt;(tp);</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">const</code>定义的常量和宏都能在要求编译阶段确定值的语句中使用。其中宏在编译之前的预处理阶段就被替换为定义的文字。而对于<code class="calibre10">const</code>定义的常量，上面这种情况下编译器能在编译阶段确定它们的值，并在<code class="calibre10">case</code>语句以及数组长度等语句中使用。让人遗憾的是上面这些方法并不可靠。首先，C++程序员应该尽量少使用宏，因为预处理器对于宏只是简单的字符替换，完全没有类型检查，而且宏使用不当出现的错误难以排查。其次，对<code class="calibre10">const</code>定义的常量可能是一个运行时常量，这种情况下是无法在<code class="calibre10">case</code>语句以及数组长度等语句中使用的。让我们稍微修改一下上面的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int get_index0()
{
    return 0;
}

int get_index1()
{
    return 1;
}

int get_x_size()
{
    return 5 + 8;
}

int get_y_size()
{
    return 6 + 7;
}

const int index0 = get_index0();
#define index1 get_index1()

switch (argc)
{
case  index0:
    std::cout &lt;&lt; "index0" &lt;&lt; std::endl;
    break;
case index1:
    std::cout &lt;&lt; "index1" &lt;&lt; std::endl;
    break;
default:
    std::cout &lt;&lt; "none" &lt;&lt; std::endl;
}

const int x_size = get_x_size();
#define y_size get_y_size()
char buffer[x_size][y_size] = { 0 };

enum {
    enum_index0 = index0,
    enum_index1 = index1,
};

std::tuple&lt;int, char&gt; tp = std::make_tuple(4, '3');
int x1 = std::get&lt;index0&gt;(tp);
char x2 = std::get&lt;index1&gt;(tp);</code></pre>

  <p class="zw">我们这里做的修改仅仅是将宏定义为一个函数调用以及用一个函数将<code class="calibre10">const</code>变量进行初始化，但是编译这段代码时会发现已经无法通过编译了。因为，无论是宏定义的函数调用，还是通过函数返回值初始化<code class="calibre10">const</code>变量都是在运行时确定的。</p>

  <p class="zw">像上面这种尴尬的情况不仅可能出现在我们的代码中，实际上标准库中也有这样的情况，其中<code class="calibre10">&lt;limits&gt;</code>就是一个典型的例子。在C语言中存在头文件<code class="calibre10">&lt;limits.h&gt;</code>，在这个头文件中用宏定义了各种整型类型的最大值和最小值，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#define UCHAR_MAX     0xff  // unsigned char类型的最大值</code></pre>

  <p class="zw">我们可以用这些宏代替数字，让代码有更好的可读性。这其中就包括要求编译阶段必须确定值的语句，例如定义一个数组：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">char buffer[UCHAR_MAX] = { 0 };</code></pre>

  <p class="zw">代码编译起来没有任何障碍。但是正如上文中提到的，C++程序员应该尽量避开宏。标准库为我们提供了一个<code class="calibre10">&lt;limits&gt;</code>，使用它同样能获得<code class="calibre10">unsigned char</code>类型的最大值：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::numeric_limits&lt;unsigned char&gt;::max()</code></pre>

  <p class="zw">但是，如果想用它来声明数组的大小是无法编译成功的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">char buffer[std::numeric_limits&lt;unsigned char&gt;::max()] = {0};</code></pre>

  <p class="zw">原因和之前讨论过的一样，<code class="calibre10">std::numeric_limits&lt;unsigned char&gt;:: max()</code>函数的返回值必须在运行时计算。</p>

  <p class="zw">为了解决以上常量无法确定的问题，C++标准委员会决定在C++11标准中定义一个新的关键字<code class="calibre10">constexpr</code>，它能够有效地定义常量表达式，并且达到类型安全、可移植、方便库和嵌入式系统开发的目的。</p>

  <h2 id="OEBPS/Text/chapter027.html.nav_point_194" class="sigil_not_in_toc">27.2　constexpr值</h2>

  <p class="zw"><code class="calibre10">constexpr</code>值即常量表达式值，是一个用<code class="calibre10">constexpr</code>说明符声明的变量或者数据成员，它要求该值必须在编译期计算。另外，常量表达式值必须被常量表达式初始化。定义常量表达式值的方法非常简单，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">constexpr int x = 42;
char buffer[x] = { 0 };</code></pre>

  <p class="zw">以上代码定义了一个常量表达式值<code class="calibre10">x</code>，并将其初始化为<code class="calibre10">42</code>，然后用<code class="calibre10">x</code>作为数组长度定义了数组<code class="calibre10">buffer</code>。从这段代码来看，<code class="calibre10">constexpr</code>和<code class="calibre10">const</code>是没有区别的，我们将关键字替换为<code class="calibre10">const</code>同样能达到目的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">const int x = 42;
char buffer[x] = { 0 };</code></pre>

  <p class="zw">从结果来看确实如此，在使用常量表达式初始化的情况下<code class="calibre10">constexpr</code>和<code class="calibre10">const</code>拥有相同的作用。但是<code class="calibre10">const</code>并没有确保编译期常量的特性，所以在下面的代码中，它们会有不同的表现：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int x1 = 42;
const int x2 = x1;            // 定义和初始化成功
char buffer[x2] = { 0 };      // 编译失败，x2无法作为数组长度</code></pre>

  <p class="zw">在上面这段代码中，虽然<code class="calibre10">x2</code>初始化编译成功，但是编译器并不一定把它作为一个编译期需要确定的值，所以在声明<code class="calibre10">buffer</code>的时候会编译错误。注意，这里我说的是不一定，因为并没有人规定编译期应该怎么处理这种情况。比如在GCC中，这段代码可以编译成功，但是MSVC和CLang则会编译失败。如果把<code class="calibre10">const</code>替换为constexpr，会有不同的情况发生：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int x1 = 42;
constexpr int x2 = x1;        // 编译失败，x2无法用x1初始化
char buffer[x2] = { 0 };</code></pre>

  <p class="zw">修改后，编译器编译第二句代码的时候就会报错，因为常量表达式值必须由常量表达式初始化，而<code class="calibre10">x1</code>并不是常量，明确地违反了<code class="calibre10">constexpr</code>的规则，编译器自然就会报错。可以看出，<code class="calibre10">constexpr</code>是一个加强版的<code class="calibre10">const</code>，它不仅要求常量表达式是常量，并且要求是一个编译阶段就能够确定其值的常量。</p>

  <h2 id="OEBPS/Text/chapter027.html.nav_point_195" class="sigil_not_in_toc">27.3　constexpr函数</h2>

  <p class="zw"><code class="calibre10">constexpr</code>不仅能用来定义常量表达式值，还能定义一个常量表达式函数，即<code class="calibre10">constexpr</code>函数，常量表达式函数的返回值可以在编译阶段就计算出来。不过在定义常量表示函数的时候，我们会遇到更多的约束规则（在C++14和后续的标准中对这些规则有所放宽）。</p>

  <p class="zw">1．函数必须返回一个值，所以它的返回值类型不能是<code class="calibre10">void</code>。</p>

  <p class="zw">2．函数体必须只有一条语句：<code class="calibre10">return expr</code>，其中<code class="calibre10">expr</code>必须也是一个常量表达式。如果函数有形参，则将形参替换到<code class="calibre10">expr</code>中后，<code class="calibre10">expr</code>仍然必须是一个常量表达式。</p>

  <p class="zw">3．函数使用之前必须有定义。</p>

  <p class="zw">4．函数必须用<code class="calibre10">constexpr</code>声明。</p>

  <p class="zw">让我们来看一看下面这个例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">constexpr int max_unsigned_char()
{
  return 0xff;
}

constexpr int square(int x)
{
  return x * x;
}

constexpr int abs(int x)
{
  return x &gt; 0 ? x : -x;
}

int main()
{
  char buffer1[max_unsigned_char()] = { 0 };
  char buffer2[square(5)] = { 0 };
  char buffer3[abs(-8)] = { 0 };
}</code></pre>

  <p class="zw">上面的代码定义了3个常量表达式函数，由于它们的返回值能够在编译期计算出来，因此可以直接将这些函数的返回值使用在数组长度的定义上。需要注意的是<code class="calibre10">square</code>和<code class="calibre10">abs</code>两个函数，它们接受一个形参<code class="calibre10">x</code>，当<code class="calibre10">x</code>确定为一个常量时（这里分别是<code class="calibre10">5</code>和<code class="calibre10">−8</code>），其常量表达式函数也就成立了。我们通过<code class="calibre10">abs</code>可以发现一个小技巧，由于标准规定函数体中只能有一个表达式<code class="calibre10">return expr</code>，因此是无法使用<code class="calibre10">if</code>语句的，幸运的是用条件表达式也能完成类似的效果。</p>

  <p class="zw">接着让我们看一看反例：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">constexpr void foo()
{
}

constexpr int next(int x)
{
  return ++x;
}

int g()
{
  return 42;
}

constexpr int f()
{
  return g();
}

constexpr int max_unsigned_char2();
enum {
  max_uchar = max_unsigned_char2()
}

constexpr int abs2(int x)
{
  if (x &gt; 0) {
       return x;
  } else {
       return -x;
  }
}

constexpr int sum(int x)
{
  int result = 0;
  while (x &gt; 0)
  {
       result += x--;
  }
  return result;
}</code></pre>

  <p class="zw">以上<code class="calibre10">constexpr</code>函数都会编译失败。其中函数<code class="calibre10">foo</code>的返回值不能为<code class="calibre10">void</code>，<code class="calibre10">next</code>函数体中的<code class="calibre10">++x</code>和<code class="calibre10">f</code>中的<code class="calibre10">g()</code>都不是一个常量表达式，函数<code class="calibre10">max_unsigned_ char2</code>只有声明没有定义，函数<code class="calibre10">abs2</code>和<code class="calibre10">sum</code>不能有多条语句。我们注意到<code class="calibre10">abs2</code>中<code class="calibre10">if</code>语句可以用条件表达式替换，可是<code class="calibre10">sum</code>函数这样的循环结构有办法替换为单语句吗？答案是可以的，我们可以使用递归来完成循环的操作，现在就来重写<code class="calibre10">sum</code>函数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">constexpr int sum(int x)
{
  return x &gt; 0 ? x + sum(x - 1) : 0;
}</code></pre>

  <p class="zw">以上函数比较容易理解，当<code class="calibre10">x</code>大于<code class="calibre10">0</code>时，将<code class="calibre10">x</code>和<code class="calibre10">sum(x−1)</code>相加，直到<code class="calibre10">sum</code>的参数为<code class="calibre10">0</code>。由于这里<code class="calibre10">sum</code>本身被声明为常量表达式函数，因此整个返回语句也是一个常量表达式，遵守了常量表达式的规则。于是我们能通过递归调用<code class="calibre10">sum</code>函数完成循环计算的任务。有趣的是，在刚开始提出常量表达式函数的时候，有些C++专家认为这种函数不应该支持递归调用，但是最终标准还是确定支持了递归调用。</p>

  <p class="zw">需要强调一点的是，虽然常量表达式函数的返回值可以在编译期计算出来，但是这个行为并不是确定的。例如，当带形参的常量表达式函数接受了一个非常量实参时，常量表达式函数可能会退化为普通函数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">constexpr int square(int x)
{
  return x * x;
}

int x = 5;
std::cout &lt;&lt; square(x);</code></pre>

  <p class="zw">这里由于<code class="calibre10">x</code>不是一个常量，因此<code class="calibre10">square</code>的返回值也可能无法在编译期确定，但是它依然能成功编译运行，因为该函数退化成了一个普通函数。这种退化机制对于程序员来说是非常友好的，它意味着我们不用为了同时满足编译期和运行期计算而定义两个相似的函数。另外，这里也存在着不确定性，因为GCC依然能在编译阶段计算<code class="calibre10">square</code>的结果，但是MSVC和CLang则不行。</p>

  <p class="zw">有了常量表达式函数的支持，C++标准对STL也做了一些改进，比如在<code class="calibre10">&lt;limits&gt;</code>中增加了<code class="calibre10">constexpr</code>声明，正因如此下面的代码也可以顺利编译成功了：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">char buffer[std::numeric_limits&lt;unsigned char&gt;::max()] = { 0 };</code></pre>

  <h2 id="OEBPS/Text/chapter027.html.nav_point_196" class="sigil_not_in_toc">27.4　constexpr构造函数</h2>

  <p class="zw"><code class="calibre10">constexpr</code>可以声明基础类型从而获得常量表达式值，除此之外<code class="calibre10">constexpr</code>还能够声明用户自定义类型，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct X {
  int x1;
};

constexpr X x = { 1 };
char buffer[x.x1] = { 0 };</code></pre>

  <p class="zw">以上代码自定义了一个结构体<code class="calibre10">X</code>，并且使用<code class="calibre10">constexpr</code>声明和初始化了变量<code class="calibre10">x</code>。到目前为止一切顺利，不过有时候我们并不希望成员变量被暴露出来，于是修改了<code class="calibre10">X</code>的结构：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class X {
public:
  X() : x1(5) {}
  int get() const
  {
       return x1;
  }
private:
  int x1;
};

constexpr X x;                    // 编译失败，X不是字面类型
char buffer[x.get()] = { 0 };     // 编译失败，x.get()无法在编译阶段计算</code></pre>

  <p class="zw">经过修改的代码不能通过编译了，因为<code class="calibre10">constexpr</code>说明符不能用来声明这样的自定义类型。解决上述问题的方法很简单，只需要用<code class="calibre10">constexpr</code>声明<code class="calibre10">X</code>类的构造函数，也就是声明一个常量表达式构造函数，当然这个构造函数也有一些规则需要遵循。</p>

  <p class="zw">1．构造函数必须用<code class="calibre10">constexpr</code>声明。</p>

  <p class="zw">2．构造函数初始化列表中必须是常量表达式。</p>

  <p class="zw">3．构造函数的函数体必须为空（这一点基于构造函数没有返回值，所以不存在<code class="calibre10">return expr</code>）。</p>

  <p class="zw">根据以上规则让我们改写类<code class="calibre10">X</code>：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class X {
public:
  constexpr X() : x1(5) {}
  constexpr X(int i) : x1(i) {}
  constexpr int get() const
  {
       return x1;
  }
private:
  int x1;
};

constexpr X x;
char buffer[x.get()] = { 0 };</code></pre>

  <p class="zw">上面这段代码只是简单地给构造函数和<code class="calibre10">get</code>函数添加了<code class="calibre10">constexpr</code>说明符就可以编译成功，因为它们本身都符合常量表达式构造函数和常量表达式函数的要求，我们称这样的类为字面量类类型（literal class type）。其实代码中<code class="calibre10">constexpr int get()const</code>的<code class="calibre10">const</code>有点多余，因为在C++11中，<code class="calibre10">constexpr</code>会自动给函数带上<code class="calibre10">const</code>属性。请注意，常量表达式构造函数拥有和常量表达式函数相同的退化特性，当它的实参不是常量表达式的时候，构造函数可以退化为普通构造函数，当然，这么做的前提是类型的声明对象不能为常量表达式值：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int i = 8;
constexpr X x(i);     // 编译失败，不能使用constexpr声明
X y(i);               // 编译成功</code></pre>

  <p class="zw">由于<code class="calibre10">i</code>不是一个常量，因此<code class="calibre10">X</code>的常量表达式构造函数退化为普通构造函数，这时对象<code class="calibre10">x</code>不能用<code class="calibre10">constexpr</code>声明，否则编译失败。</p>

  <p class="zw">最后需要强调的是，使用<code class="calibre10">constexpr</code>声明自定义类型的变量，必须确保这个自定义类型的析构函数是平凡的，否则也是无法通过编译的。平凡析构函数必须满足下面3个条件。</p>

  <p class="zw">1．自定义类型中不能有用户自定义的析构函数。</p>

  <p class="zw">2．析构函数不能是虚函数。</p>

  <p class="zw">3．基类和成员的析构函数必须都是平凡的。</p>

  <h2 id="OEBPS/Text/chapter027.html.nav_point_197" class="sigil_not_in_toc">27.5　对浮点的支持</h2>

  <p class="zw">在<code class="calibre10">constexpr</code>说明符被引入之前，C++程序员经常使用<code class="calibre10">enum hack</code>来促使编译器在编译阶段计算常量表达式的值。但是因为<code class="calibre10">enum</code>只能操作整型，所以一直无法完成对于浮点类型的编译期计算。<code class="calibre10">constexpr</code>说明符则不同，它支持声明浮点类型的常量表达式值，而且标准还规定其精度必须至少和运行时的精度相同，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">constexpr double sum(double x)
{
  return x &gt; 0 ? x + sum(x - 1) : 0;
}

constexpr double x = sum(5);</code></pre>

  <h2 id="OEBPS/Text/chapter027.html.nav_point_198" class="sigil_not_in_toc">27.6　C++14标准对常量表达式函数的增强</h2>

  <p class="zw">C++11标准对常量表达式函数的要求可以说是非常的严格，这一点影响该特性的实用性。幸好这个问题在C++14中得到了非常巨大的改善，C++14标准对常量表达式函数的改进如下。</p>

  <p class="zw">1．函数体允许声明变量，除了没有初始化、<code class="calibre10">static</code>和<code class="calibre10">thread_local</code>变量。</p>

  <p class="zw">2．函数允许出现<code class="calibre10">if</code>和<code class="calibre10">switch</code>语句，不能使用<code class="calibre10">go</code>语句。</p>

  <p class="zw">3．函数允许所有的循环语句，包括<code class="calibre10">for</code>、<code class="calibre10">while</code>、<code class="calibre10">do-while</code>。</p>

  <p class="zw">4．函数可以修改生命周期和常量表达式相同的对象。</p>

  <p class="zw">5．函数的返回值可以声明为<code class="calibre10">void</code>。</p>

  <p class="zw">6．<code class="calibre10">constexpr</code>声明的成员函数不再具有<code class="calibre10">const</code>属性。</p>

  <p class="zw">因为这些改进的发布，在C++11中无法成功编译的常量表达式函数，在C++14中可以编译成功了：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">constexpr int abs(int x)
{
  if (x &gt; 0) {
      return x;
  } else {
      return -x;
  }
}

constexpr int sum(int x)
{
  int result = 0;
  while (x &gt; 0)
  {
      result += x--;
  }
  return result;
}

char buffer1[sum(5)] = { 0 };
char buffer2[abs(-5)] = { 0 };</code></pre>

  <p class="zw">以上代码中的<code class="calibre10">abs</code>和<code class="calibre10">sum</code>函数相比于前面使用条件表达式和递归方法实现的函数更加容易阅读和理解了。看到这里读者是否会有一些兴奋，但是别急，后面还有好戏：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">constexpr int next(int x)
{
  return ++x;
}

char buffer[next(5)] = { 0 };</code></pre>

  <p class="zw">这里我们惊喜地发现，原来由于<code class="calibre10">++x</code>不是常量表达式，因此无法编译通过的问题也消失了，这就是基于第4点规则。需要强调的是，对于常量表达式函数的增强同样也会影响常量表达式构造函数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

class X {
public:
  constexpr X() : x1(5) {}
  constexpr X(int i) : x1(0)
  {
      if (i &gt; 0) {
          x1 = 5;
      }
      else {
          x1 = 8;
      }
  }
  constexpr void set(int i)
  {
      x1 = i;
  }
  constexpr int get() const
  {
      return x1;
  }
private:
  int x1;
};

constexpr X make_x()
{
  X x;
  x.set(42);
  return x;
}

int main()
{
  constexpr X x1(-1);
  constexpr X x2 = make_x();
  constexpr int a1 = x1.get();
  constexpr int a2 = x2.get();
  std::cout &lt;&lt; a1 &lt;&lt; std::endl;
  std::cout &lt;&lt; a2 &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">请注意，<code class="calibre10">main</code>函数里的4个变量<code class="calibre10">x1</code>、<code class="calibre10">x2</code>、<code class="calibre10">a1</code>和<code class="calibre10">a2</code>都有<code class="calibre10">constexpr</code>声明，也就是说它们都是编译期必须确定的值。有了这个前提条件，我们再来分析这段代码的神奇之处。首先对于常量表达式构造函数，我们发现可以在其函数体内使用<code class="calibre10">if</code>语句并且对<code class="calibre10">x1</code>进行赋值操作了。可以看到返回类型为<code class="calibre10">void</code>的<code class="calibre10">set</code>函数也被声明为<code class="calibre10">constexpr</code>了，这也意味着该函数能够运用在<code class="calibre10">constexpr</code>声明的函数体内，<code class="calibre10">make_x</code>函数就是利用了这个特性。根据规则4和规则6，<code class="calibre10">set</code>函数也能成功地修改<code class="calibre10">x1</code>的值了。让我们来看一看GCC生成的中间代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">main ()
{
  int D.39319;

  {
    const struct X x1;
    const struct X x2;
    const int a1;
    const int a2;

    try
      {
        x1.x1 = 8;
        x2.x1 = 42;
        a1 = 8;
        a2 = 42;
        _1 = std::basic_ostream&lt;char&gt;::operator&lt;&lt; (&amp;cout, 8);
        std::basic_ostream&lt;char&gt;::operator&lt;&lt; (_1, endl);
        _2 = std::basic_ostream&lt;char&gt;::operator&lt;&lt; (&amp;cout, 42);
        std::basic_ostream&lt;char&gt;::operator&lt;&lt; (_2, endl);
      }
    finally
      {
        x1 = {CLOBBER};
        x2 = {CLOBBER};
      }
  }
  D.39319 = 0;
  return D.39319;
}</code></pre>

  <p class="zw">从上面的中间代码可以清楚地看到，编译器直接给<code class="calibre10">x1.x1</code>、<code class="calibre10">x2.x1</code>、<code class="calibre10">a1</code>、<code class="calibre10">a2</code>进行了赋值，并没有运行时的计算操作。</p>

  <p class="zw">最后需要指出的是，C++14标准除了在常量表达式函数特性方面做了增强，也在标准库方面做了增强，包括<code class="calibre10">&lt;complex&gt;</code>、<code class="calibre10">&lt;chrono&gt;</code>、<code class="calibre10">&lt;array&gt;</code>、<code class="calibre10">&lt;initializer_list&gt;</code>、<code class="calibre10">&lt;utility&gt;</code>和<code class="calibre10">&lt;tuple&gt;</code>。对于标准库的增强细节这里就不做介绍了，大家可以直接参阅STL源代码。</p>

  <h2 id="OEBPS/Text/chapter027.html.nav_point_199" class="sigil_not_in_toc">27.7　constexpr lambdas表达式</h2>

  <p class="zw">从C++17开始，<code class="calibre10">lambda</code>表达式在条件允许的情况下都会隐式声明为<code class="calibre10">constexpr</code>。这里所说的条件，即是上一节中提到的常量表达式函数的规则，本节里就不再重复论述。结合<code class="calibre10">lambda</code>的这个新特性，先看一个简单的例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">constexpr int foo()
{
  return []() { return 58; }();
}

auto get_size = [](int i) { return i * 2; };
char buffer1[foo()] = { 0 };
char buffer2[get_size(5)] = { 0 };</code></pre>

  <p class="zw">可以看到，以上代码定义的是一个“普通”的<code class="calibre10">lambda</code>表达式，但是在C++17标准中，这些“普通”的<code class="calibre10">lambda</code>表达式却可以用在常量表达式函数和数组长度中，可见该lambda表达式的结果在编译阶段已经计算出来了。实际上这里的<code class="calibre10">[](int i) { return i * 2; }</code>相当于：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class GetSize {
public:
  constexpr int operator() (int i) const {
       return i * 2;
  }
};</code></pre>

  <p class="zw">当<code class="calibre10">lambda</code>表达式不满足<code class="calibre10">constexpr</code>的条件时，<code class="calibre10">lambda</code>表达式也不会出现编译错误，它会作为运行时<code class="calibre10">lambda</code>表达式存在：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">// 情况1
int i = 5;
auto get_size = [](int i) { return i * 2; };
char buffer1[get_size(i)] = { 0 };          // 编译失败，get_size需要运行时调用
int a1 = get_size(i);

// 情况2
auto get_count = []() {
  static int x = 5;
  return x;
};
int a2 = get_count();</code></pre>

  <p class="zw">以上代码中情况1和常量表达式函数相同，<code class="calibre10">get_size</code>可能会退化为运行时<code class="calibre10">lambda</code>表达式对象。当这种情况发生的时候，<code class="calibre10">get_size</code>的返回值不再具有作为数组长度的能力，但是运行时调用<code class="calibre10">get_size</code>对象还是没有问题的。GCC在这种情况下依然能够在编译阶段求出<code class="calibre10">get_size</code>的值，MSVC和CLang则不行。对于情况2，由于<code class="calibre10">static</code>变量的存在，<code class="calibre10">lambda</code>表达式对象<code class="calibre10">get_count</code>不可能在编译期运算，因此它最终会在运行时计算。</p>

  <p class="zw">值得注意的是，我们也可以强制要求<code class="calibre10">lambda</code>表达式是一个常量表达式，用<code class="calibre10">constexpr</code>去声明它即可。这样做的好处是可以检查<code class="calibre10">lambda</code>表达式是否有可能是一个常量表达式，如果不能则会编译报错，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto get_size = [](int i) constexpr -&gt; int { return i * 2; };
char buffer2[get_size(5)] = { 0 };

auto get_count = []() constexpr -&gt; int {
  static int x = 5;                   // 编译失败，x是一个static变量
  return x;
};
int a2 = get_count();</code></pre>

  <h2 id="OEBPS/Text/chapter027.html.nav_point_200" class="sigil_not_in_toc">27.8　constexpr的内联属性</h2>

  <p class="zw">在C++17标准中，<code class="calibre10">constexpr</code>声明静态成员变量时，也被赋予了该变量的内联属性，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class X {
public:
  static constexpr int num{ 5 };
};</code></pre>

  <p class="zw">以上代码在C++17中等同于：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class X {
public:
  inline static constexpr int num{ 5 };
};</code></pre>

  <p class="zw">那么问题来了，自C++11标准推行以来<code class="calibre10">static constexpr int num{ 5 }</code>这种用法就一直存在了，那么同样的代码在C++11和C++17中究竟又有什么区别呢？</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class X {
public:
  static constexpr int num{ 5 };
};</code></pre>

  <p class="zw">代码中，<code class="calibre10">num</code>是只有声明没有定义的，虽然我们可以通过<code class="calibre10">std::cout &lt;&lt; X::num &lt;&lt; std::endl</code>输出其结果，但这实际上是编译器的一个小把戏，它将<code class="calibre10">X::num</code>直接替换为了<code class="calibre10">5</code>。如果将输出语句修改为<code class="calibre10">std::cout &lt;&lt; &amp;X::num &lt;&lt; std::endl</code>，那么链接器会明确报告<code class="calibre10">X::num</code>缺少定义。但是从C++17开始情况发生了变化，<code class="calibre10">static constexpr int num{5}</code>既是声明也是定义，所以在C++17标准中<code class="calibre10">std::cout &lt;&lt; &amp;X::num &lt;&lt; std::endl</code>可以顺利编译链接，并且输出正确的结果。值得注意的是，对于编译器而言为<code class="calibre10">X::num</code>产生定义并不是必需的，如果代码只是引用了<code class="calibre10">X::num</code>的值，那么编译器完全可以使用直接替换为值的技巧。只有当代码中引用到变量指针的时候，编译器才会为其生成定义。</p>

  <h2 id="OEBPS/Text/chapter027.html.nav_point_201" class="sigil_not_in_toc">27.9　if constexpr</h2>

  <p class="zw"><code class="calibre10">if constexpr</code>是C++17标准提出的一个非常有用的特性，可以用于编写紧凑的模板代码，让代码能够根据编译时的条件进行实例化。这里有两点需要特别注意。</p>

  <p class="zw">1．<code class="calibre10">if constexpr</code>的条件必须是编译期能确定结果的常量表达式。</p>

  <p class="zw">2．条件结果一旦确定，编译器将只编译符合条件的代码块。</p>

  <p class="zw">由此可见，该特性只有在使用模板的时候才具有实际意义，若是用在普通函数上，效果会非常尴尬，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void check1(int i)
{
  if constexpr (i &gt; 0) {                        // 编译失败，不是常量表达式
       std::cout &lt;&lt; "i &gt; 0" &lt;&lt; std::endl;
  }
  else {
       std::cout &lt;&lt; "i &lt;= 0" &lt;&lt; std::endl;
  }
}

void check2()
{
  if constexpr (sizeof(int) &gt; sizeof(char)) {
       std::cout &lt;&lt; "sizeof(int) &gt; sizeof(char)" &lt;&lt; std::endl;
  }
  else {
       std::cout &lt;&lt; "sizeof(int) &lt;= sizeof(char)" &lt;&lt; std::endl;
  }
}</code></pre>

  <p class="zw">对于函数<code class="calibre10">check1</code>，由于<code class="calibre10">if constexpr</code>的条件不是一个常量表达式，因此无法编译通过。而对于函数<code class="calibre10">check2</code>，这里的代码最后会被编译器省略为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void check2()
{
  std::cout &lt;&lt; "sizeof(int) &gt; sizeof(char)" &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">但是当<code class="calibre10">if constexpr</code>运用于模板时，情况将非常不同。来看下面的例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

template&lt;class T&gt; bool is_same_value(T a, T b)
{
  return a == b;
}

template&lt;&gt; bool is_same_value&lt;double&gt;(double a, double b)
{
  if (std::abs(a - b) &lt; 0.0001) {
       return true;
  }
  else {
       return false;
  }
}

int main()
{
  double x = 0.1 + 0.1 + 0.1 - 0.3;
  std::cout &lt;&lt; std::boolalpha;
  std::cout &lt;&lt; "is_same_value(5, 5)  : " &lt;&lt; is_same_value(5, 5) &lt;&lt; std::endl;
  std::cout &lt;&lt; "x == 0.0               : " &lt;&lt; (x == 0.) &lt;&lt; std::endl;
  std::cout &lt;&lt; "is_same_value(x, 0.) : " &lt;&lt; is_same_value(x, 0.) &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">计算结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">is_same_value(5, 5)    : true
x == 0.0               : false
is_same_value(x, 0.)   : true</code></pre>

  <p class="zw">我们知道浮点数的比较和整数是不同的，通常情况下它们的差小于某个阈值就认为两个浮点数相等。我们把<code class="calibre10">is_same_value</code>写成函数模板，并且对<code class="calibre10">double</code>类型进行特化。这里如果使用<code class="calibre10">if constexpr</code>表达式，代码会简化很多而且更加容易理解，让我们看一看简化后的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;type_traits&gt;
template&lt;class T&gt; bool is_same_value(T a, T b)
{
  if constexpr (std::is_same&lt;T, double&gt;::value) {
       if (std::abs(a - b) &lt; 0.0001) {
            return true;
       }
       else {
            return false;
       }
  }
  else {
       return a == b;
  }
}</code></pre>

  <p class="zw">在上面这段代码中，直接使用<code class="calibre10">if constexpr</code>判断模板参数是否为<code class="calibre10">double</code>，如果条件成立，则使用<code class="calibre10">double</code>的比较方式；否则使用普通的比较方式，代码变得简单明了。再次强调，这里的选择是编译期做出的，一旦确定了条件，那么就只有被选择的代码块才会被编译；另外的代码块则会被忽略。说到这里，需要提醒读者注意这样一种陷阱：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;type_traits&gt;
template&lt;class T&gt; auto minus(T a, T b)
{
  if constexpr (std::is_same&lt;T, double&gt;::value) {
       if (std::abs(a - b) &lt; 0.0001) {
            return 0.;
       }
       else {
            return a - b;
       }
  }
  else {
       return static_cast&lt;int&gt;(a - b);
  }
}

int main()
{
  std::cout &lt;&lt; minus(5.6, 5.11) &lt;&lt; std::endl;
  std::cout &lt;&lt; minus(5.60002, 5.600011) &lt;&lt; std::endl;
  std::cout &lt;&lt; minus(6, 5) &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">以上是一个带精度限制的减法函数，当参数类型为<code class="calibre10">double</code>且计算结果小于0.0001的时候，我们就可以认为计算结果为0。当参数类型为整型时，则不用对精度做任何限制。上面的代码编译运行没有任何问题，因为编译器根据不同的类型选择不同的分支进行编译。但是如果修改一下上面的代码，结果可能就很难预料了：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T&gt; auto minus(T a, T b)
{
  if constexpr (std::is_same&lt;T, double&gt;::value) {
       if (std::abs(a - b) &lt; 0.0001) {
            return 0.;
       }
       else {
            return a - b;
       }
  }
  return static_cast&lt;int&gt;(a - b);
}</code></pre>

  <p class="zw">上面的代码删除了<code class="calibre10">else</code>关键词而直接将else代码块提取出来，不过根据以往运行时<code class="calibre10">if</code>的经验，它并不会影响代码运行的逻辑。遗憾的是，这种写法有可能导致编译失败，因为它可能会导致函数有多个不同的返回类型。当实参为整型时一切正常，编译器会忽略<code class="calibre10">if</code>的代码块，直接编译<code class="calibre10">return static_cast&lt;int&gt;(a − b)</code>，这样返回类型只有<code class="calibre10">int</code>一种。但是当实参类型为<code class="calibre10">double</code>的时候，情况发生了变化。<code class="calibre10">if</code>的代码块会被正常地编译，代码块内部的返回结果类型为<code class="calibre10">double</code>，而代码块外部的<code class="calibre10">return static_cast&lt;int&gt;(a − b)</code>同样会照常编译，这次的返回类型为<code class="calibre10">int</code>。编译器遇到了两个不同的返回类型，只能报错。</p>

  <p class="zw">和运行时<code class="calibre10">if</code>的另一个不同点：<code class="calibre10">if constexpr</code>不支持短路规则。这在程序编写时往往也能成为一个陷阱：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;type_traits&gt;

template&lt;class T&gt; auto any2i(T t)
{
  if constexpr (std::is_same&lt;T, std::string&gt;::value &amp;&amp; T::npos == -1) {
       return atoi(t.c_str());
  }
  else {
       return t;
  }
}

int main()
{
  std::cout &lt;&lt; any2i(std::string("6")) &lt;&lt; std::endl;
  std::cout &lt;&lt; any2i(6) &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">上面的代码很好理解，函数模板<code class="calibre10">any2i</code>的实参如果是一个<code class="calibre10">std::string</code>，那么它肯定满足<code class="calibre10">std::is_same&lt;T, std::string&gt;::value &amp;&amp; T::npos == −1</code>的条件，所以编译器会编译<code class="calibre10">if</code>分支的代码。如果实参类型是一个<code class="calibre10">int</code>，那么<code class="calibre10">std::is_same&lt;T, std::string&gt;::value</code>会返回<code class="calibre10">false</code>，根据短路规则，<code class="calibre10">if</code>代码块不会被编译，而是编译<code class="calibre10">else</code>代码块的内容。一切看起来是那么简单直接，但是编译过后会发现，代码<code class="calibre10">std::cout &lt;&lt; any2i(std:: string("6")) &lt;&lt; std::endl</code>顺利地编译成功，<code class="calibre10">std::cout &lt;&lt; any2i(6) &lt;&lt; std::endl</code>则会编译失败，因为<code class="calibre10">if constexpr</code>不支持短路规则。当函数实参为int时，<code class="calibre10">std::is_same&lt;T, std::string&gt;::value</code>和<code class="calibre10">T::npos == −1</code>都会被编译，由于<code class="calibre10">int::npos</code>显然是一个非法的表达式，因此会造成编译失败。这里正确的写法是通过嵌套<code class="calibre10">if constexpr</code>来替换上面的操作：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T&gt; auto any2i(T t)
{
  if constexpr (std::is_same&lt;T, std::string&gt;::value) {
       if  constexpr(T::npos == -1) {
            return atoi(t.c_str());
       }
  }
  else {
       return t;
  }
}</code></pre>

  <h2 id="OEBPS/Text/chapter027.html.nav_point_202" class="sigil_not_in_toc">27.10　允许constexpr虚函数</h2>

  <p class="zw">在C++20标准之前，虚函数是不允许声明为<code class="calibre10">constexpr</code>的。看似有道理的规则其实并不合理，因为虚函数很多时候可能是无状态的，这种情况下它是有条件作为常量表达式被优化的，比如下面这个函数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct X
{
    virtual int f() const { return 1; }
};

 int main() {
    X x;
    int i = x.f();
 }</code></pre>

  <p class="zw">上面的代码会先执行<code class="calibre10">X::f</code>函数，然后将结果赋值给<code class="calibre10">i</code>，它的GIMPLE中间的代码如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">main ()
{
  int D.2137;

  {
    struct X x;
    int i;

    try
      {
        _1 = &amp;_ZTV1X + 16;
        x._vptr.X = _1;
        i = X::f (&amp;x); // 注意此处赋值
      }
    finally
      {
        x = {CLOBBER};
      }
  }
  D.2137 = 0;
  return D.2137;
}

X::f (const struct X * const this)
{
  int D.2139;

  D.2139 = 1;
  return D.2139;
}</code></pre>

  <p class="zw">观察上面的两份代码，虽然<code class="calibre10">X::f</code>是一个虚函数，但是它非常适合作为常量表达式进行优化。这样一来，<code class="calibre10">int i = x.f();</code>可以被优化为<code class="calibre10">int i = 1;</code>，减少一次函数的调用过程。可惜在C++17标准中不允许我们这么做，直到C++20标准明确允许在常量表达式中使用虚函数，所以上面的代码可以修改为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct X
{
  constexpr virtual int f() const { return 1; }
};

int main() {
  constexpr X x;
  int i = x.f();
}</code></pre>

  <p class="zw">它的中间代码也会优化为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">main ()
{
  int D.2138;

  {
    const struct X x;
    int i;

    try
      {
        _1 = &amp;_ZTV1X + 16;
        x._vptr.X = _1;
        i = 1; // 注意此处赋值
      }
    finally
      {
        x = {CLOBBER};
      }
  }
  D.2138 = 0;
  return D.2138;
}</code></pre>

  <p class="zw">从中间代码中可以看到，<code class="calibre10">i</code>被直接赋值为<code class="calibre10">1</code>，在此之前并没有调用<code class="calibre10">X::f</code>函数。另外值得一提的是，<code class="calibre10">constexpr</code>的虚函数在继承重写上并没有其他特殊的要求，<code class="calibre10">constexpr</code>的虚函数可以覆盖重写普通虚函数，普通虚函数也可以覆盖重写<code class="calibre10">constexpr</code>的虚函数，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct X1
{
    virtual int f() const = 0;
};

struct X2: public X1
{
    constexpr virtual int f() const { return 2; }
};

struct X3: public X2
{
    virtual int f() const { return 3; }
};

struct X4: public X3
{
    constexpr virtual int f() const { return 4; }
};

constexpr int (X1::*pf)() const = &amp;X1::f;

constexpr X2 x2;
static_assert( x2.f() == 2 );
static_assert( (x2.*pf)() == 2 );

constexpr X1 const&amp; r2 = x2;
static_assert( r2.f() == 2 );
static_assert( (r2.*pf)() == 2 );

constexpr X1 const* p2 = &amp;x2;
static_assert( p2-&gt;f() == 2 );
static_assert( (p2-&gt;*pf)() == 2 );

constexpr X4 x4;
static_assert( x4.f() == 4 );
static_assert( (x4.*pf)() == 4 );

constexpr X1 const&amp; r4 = x4;
static_assert( r4.f() == 4 );
static_assert( (r4.*pf)() == 4 );

constexpr X1 const* p4 = &amp;x4;
static_assert( p4-&gt;f() == 4 );
static_assert( (p4-&gt;*pf)() == 4 );</code></pre>

  <p class="zw">最后要说明的是，我在验证这条规则时，GCC无论在C++17还是C++20标准中都可以顺利编译通过，而CLang在C++17中会给出<code class="calibre10">constexpr</code>无法用于虚函数的错误提示。</p>

  <h2 id="OEBPS/Text/chapter027.html.nav_point_203" class="sigil_not_in_toc">27.11　允许在constexpr函数中出现Try-catch</h2>

  <p class="zw">在C++20标准以前<code class="calibre10">Try-catch</code>是不能出现在<code class="calibre10">constexpr</code>函数中的，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">constexpr int f(int x)
{
  try { return x + 1; }
  catch (…) { return 0; }
}</code></pre>

  <p class="zw">不过似乎编译器对此规则的态度都十分友好，当我们用C++17标准去编译这份代码时，编译器会编译成功并给出一个友好的警告，说明这条特性需要使用C++20标准。C++20标准允许<code class="calibre10">Try-catch</code>存在于<code class="calibre10">constexpr</code>函数，但是<code class="calibre10">throw</code>语句依旧是被禁止的，所以try语句是不能抛出异常的，这也就意味着<code class="calibre10">catch</code>永远不会执行。实际上，当函数被评估为常量表达式的时候<code class="calibre10">Try-catch</code>是没有任何作用的。</p>

  <h2 id="OEBPS/Text/chapter027.html.nav_point_204" class="sigil_not_in_toc">27.12　允许在constexpr中进行平凡的默认初始化</h2>

  <p class="zw">从C++20开始，标准允许在<code class="calibre10">constexpr</code>中进行平凡的默认初始化，这样进一步减少<code class="calibre10">constexpr</code>的特殊性。例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct X { 
  bool val;
};

void f() {
  X x;
}

f();</code></pre>

  <p class="zw">上面的代码非常简单，在任何环境下都可以顺利编译。不过如果将函数<code class="calibre10">f</code>改为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">constexpr void f() {
  X x;
}</code></pre>

  <p class="zw">那么在C++17标准的编译环境就会报错，提示<code class="calibre10">x</code>没有初始化，它需要用户提供一个构造函数。当然这个问题在C++17标准中也很容易解决，例如修改<code class="calibre10">X</code>为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct X { 
  bool val = false;
};</code></pre>

  <p class="zw">回头来看原始代码，它在C++20标准的编译器上是能够顺利编译的。值得一提的是，虽然标准放松了对<code class="calibre10">constexpr</code>上下文对象默认初始化的要求，但是我们依然应该养成声明对象时随手初始化的习惯，避免让代码出现未定义的行为。</p>

  <h2 id="OEBPS/Text/chapter027.html.nav_point_205" class="sigil_not_in_toc">27.13　允许在constexpr中更改联合类型的有效成员</h2>

  <p class="zw">在C++20标准之前对<code class="calibre10">constexpr</code>的另外一个限制就是禁止更改联合类型的有效成员，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">union Foo {
  int i;
  float f;
};
constexpr int use() {
  Foo foo{};
  foo.i = 3;
  foo.f = 1.2f; // C++20之前编译失败
  return 1;
}</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">foo</code>是一个联合类型对象，<code class="calibre10">foo.i = 3;</code>首次确定了有效成员为<code class="calibre10">i</code>，这没有问题，接下来代码<code class="calibre10">foo.f = 1.2f;</code>改变有效成员为<code class="calibre10">f</code>，这就违反了标准中关于不能更改联合类型的有效成员的规则，所以导致编译失败。现在C++20标准已经删除了这条规则，以上代码可以编译成功。实际编译过程中，只有CLang会在C++17标准中对以上代码报错，而GCC和MSVC均能用C++17和C++20标准编译成功。</p>

  <p class="zw">C++20标准对<code class="calibre10">constexpr</code>做了很多修改，除了上面提到的修改以外，还修改了一些并不常用的地方，包括允许<code class="calibre10">dynamic_cast</code>和<code class="calibre10">typeid</code>出现在常量表达式中；允许在<code class="calibre10">constexpr</code>函数使用未经评估的内联汇编。这些修改都没有需要详细介绍的特别之处，有兴趣的读者可以自己写点实验代码测试一下。</p>

  <h2 id="OEBPS/Text/chapter027.html.nav_point_206" class="sigil_not_in_toc">27.14　使用consteval声明立即函数</h2>

  <p class="zw">前面我们曾提到过，<code class="calibre10">constexpr</code>声明函数时并不依赖常量表达式上下文环境，在非常量表达式的环境中，函数可以表现为普通函数。不过有时候，我们希望确保函数在编译期就执行计算，对于无法在编译期执行计算的情况则让编译器直接报错。于是在C++20标准中出现了一个新的概念——立即函数，该函数需要使用<code class="calibre10">consteval</code>说明符来声明：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">consteval int sqr(int n) {
  return n*n;
}
constexpr int r = sqr(100);  // 编译成功
int x = 100;
int r2 = sqr(x);             // 编译失败</code></pre>

  <p class="zw">在上面的代码中<code class="calibre10">sqr(100);</code>是一个常量表达式上下文环境，可以编译成功。相反，因为<code class="calibre10">sqr(x);</code>中的<code class="calibre10">x</code>是可变量，不能作为常量表达式，所以编译器抛出错误。要让代码成功编译，只需要给<code class="calibre10">x</code>加上<code class="calibre10">const</code>即可。需要注意的是，如果一个立即函数在另外一个立即函数中被调用，则函数定义时的上下文环境不必是一个常量表达式，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">consteval int sqrsqr(int n) {
  return sqr(sqr(n));
}</code></pre>

  <p class="zw"><code class="calibre10">sqrsqr</code>是否能编译成功取决于如何调用，如果调用时处于一个常量表达式环境，那么就能通过编译：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int y = sqrsqr(100);</code></pre>

  <p class="zw">反之则编译失败：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int y = sqrsqr(x);</code></pre>

  <p class="zw"><code class="calibre10">lambda</code>表达式也可以使用<code class="calibre10">consteval</code>说明符：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto sqr = [](int n) consteval { return n * n; };
int r = sqr(100);</code></pre>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto f = sqr; // 编译失败，尝试获取立即函数的函数地址</code></pre>

  <h2 id="OEBPS/Text/chapter027.html.nav_point_207" class="sigil_not_in_toc">27.15　使用constinit检查常量初始化</h2>

  <p class="zw">在C++中有一种典型的错误叫作“Static Initialization Order Fiasco”，指的是因为静态初始化顺序错误导致的问题。因为这种错误往往发生在main函数之前，所以比较难以排查。举一个典型的例子，假设有两个静态对象<code class="calibre10">x</code>和<code class="calibre10">y</code>分别存在于两个不同的源文件中。其中一个对象<code class="calibre10">x</code>的构造函数依赖于对象<code class="calibre10">y</code>。没错，就是这样，现在我们有50%的可能性会出错，因为我们没有办法控制哪个对象先构造。如果对象<code class="calibre10">x</code>在<code class="calibre10">y</code>之前构造，那么就会引发一个未定义的结果。为了避免这种问题的发生，我们通常希望使用常量初始化程序去初始化静态变量。不幸的是，常量初始化的规则很复杂，需要一种方法帮助我们完成检查工作，当不符合常量初始化程序的时候可以在编译阶段报错。于是在C++20标准中引入了新的<code class="calibre10">constinit</code>说明符。</p>

  <p class="zw">正如上文所描述的<code class="calibre10">constinit</code>说明符主要用于具有静态存储持续时间的变量声明上，它要求变量具有常量初始化程序。首先，<code class="calibre10">constinit</code>说明符作用的对象是必须具有静态存储持续时间的，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">constinit int x = 11;              // 编译成功，全局变量具有静态存储持续
int main() {
  constinit static int y = 42;     // 编译成功，静态变量具有静态存储持续
  constinit int z = 7;             // 编译失败，局部变量是动态分配的
}</code></pre>

  <p class="zw">其次，<code class="calibre10">constinit</code>要求变量具有常量初始化程序：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">const char* f() { return "hello"; }
constexpr const char* g() { return "cpp"; }
constinit const char* str1 = f(); // 编译错误，f()不是一个常量初始化程序
constinit const char* str2 = g(); // 编译成功</code></pre>

  <p class="zw"><code class="calibre10">constinit</code>还能用于非初始化声明，以告知编译器<code class="calibre10">thread_local</code>变量已被初始化：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">extern thread_local constinit int x;
int f() { return x; }</code></pre>

  <p class="zw">最后值得一提的是，虽然<code class="calibre10">constinit</code>说明符一直在强调常量初始化，但是初始化的对象并不要求具有常量属性。</p>

  <h2 id="OEBPS/Text/chapter027.html.nav_point_208" class="sigil_not_in_toc">27.16　判断常量求值环境</h2>

  <p class="zw"><code class="calibre10">std::is_constant_evaluated</code>是C++20新加入标准库的函数，它用于检查当前表达式是否是一个常量求值环境，如果在一个明显常量求值的表达式中，则返回<code class="calibre10">true</code>；否则返回<code class="calibre10">false</code>。该函数包含在<code class="calibre10">&lt;type_traits&gt;</code>头文件中，虽然看上去像是一个标准库实现的函数，但实际上调用的是编译器内置函数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">constexpr inline bool is_constant_evaluated() noexcept
{ 
    return __builtin_is_constant_evaluated(); 
}</code></pre>

  <p class="zw">该函数通常会用于代码优化中，比如在确定为常量求值的环境时，使用<code class="calibre10">constexpr</code>能够接受的算法，让数值在编译阶段就得出结果。而对于其他环境则采用运行时计算结果的方法。提案文档中提供了一个很好的例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;cmath&gt;
#include &lt;type_traits&gt;
constexpr double power(double b, int x) {
  if (std::is_constant_evaluated() &amp;&amp; x &gt;= 0) {
    double r = 1.0, p = b;
    unsigned u = (unsigned)x;
    while (u != 0) {
      if (u &amp; 1) r *= p;
      u /= 2;
      p *= p;
    }
    return r;
  } else {
    return std::pow(b, (double)x);
  }
}

int main() 
{
  constexpr double kilo = power(10.0, 3);  // 常量求值
  int n = 3;
  double mucho = power(10.0, n);           // 非常量求值
  return 0;
}</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">power</code>函数根据<code class="calibre10">std::is_constant_evaluated()</code>和<code class="calibre10">x &gt;= 0</code>的结果选择不同的实现方式。其中，<code class="calibre10">kilo = power(10.0, 3);</code>是一个常量求值，所以<code class="calibre10">std::is_ constant_evaluated() &amp;&amp; x &gt;= 0</code>返回<code class="calibre10">true</code>，编译器在编译阶段求出结果。反之，<code class="calibre10">mucho = power(10.0, n)</code>则需要调用<code class="calibre10">std::pow</code>在运行时求值。让我们通过中间代码看一看编译器具体做了什么：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">main ()
{
  int D.25691;

  {
    const double kilo;
    int n;
    double mucho;

    kilo = 1.0e+3;             // 直接赋值
    n = 3;
    mucho = power (1.0e+1, n); // 运行时计算
    D.25691 = 0;
    return D.25691;
  }
  D.25691 = 0;
  return D.25691;
}

power (double b, int x)
{
  bool retval.0;
  bool iftmp.1;
  double D.25706;

  {
    _1 = std::is_constant_evaluated ();
    if (_1 != 0) goto &lt;D.25697&gt;; else goto &lt;D.25695&gt;;
    &lt;D.25697&gt;:
    if (x &gt;= 0) goto &lt;D.25698&gt;; else goto &lt;D.25695&gt;;
    &lt;D.25698&gt;:
    iftmp.1 = 1;
    goto &lt;D.25696&gt;;
    &lt;D.25695&gt;:
    iftmp.1 = 0;
    &lt;D.25696&gt;:
    retval.0 = iftmp.1;
    if (retval.0 != 0) goto &lt;D.25699&gt;; else goto &lt;D.25700&gt;;
    &lt;D.25699&gt;:
    {
      // … 这里省略power函数的相关算法，虽然算法生成代码了，但是并没有调用到
      return D.25706;
    }
    &lt;D.25700&gt;:
    _3 = (double) x;
    D.25706 = pow (b, _3);
    return D.25706;
  }
}

std::is_constant_evaluated ()
{
  bool D.25708;

  try
    {
      D.25708 = 0;
      return D.25708;
    }
  catch
    {
      &lt;&lt;&lt;eh_must_not_throw (terminate)&gt;&gt;&gt;
    }
}</code></pre>

  <p class="zw">观察上面的中间代码，首先让我们注意到的就是<code class="calibre10">main</code>函数中<code class="calibre10">kilo</code>和<code class="calibre10">mucho</code>赋值形式的不同。正如我们刚才讨论的那样，对于<code class="calibre10">kilo</code>的结果编译器在编译期已经计算完成，所以这里是直接为<code class="calibre10">1.0e+3</code>，而对于<code class="calibre10">mucho</code>则需要调用<code class="calibre10">std::power</code>函数。接着，我们可以观察<code class="calibre10">std::is_constant_evaluated()</code>这个函数的实现，很明显编译器让它直接返回<code class="calibre10">0</code>（也就是<code class="calibre10">false</code>），在代码中实现的<code class="calibre10">power</code>函数虽然有<code class="calibre10">std::is_constant_ evaluated()</code>结果为<code class="calibre10">true</code>时的算法实现，但是却永远不会被调用。因为当<code class="calibre10">std::is_ constant_evaluated()</code>为<code class="calibre10">true</code>时，编译器计算了函数结果；反之函数会交给<code class="calibre10">std::power</code>计算结果。</p>

  <p class="zw">在了解了<code class="calibre10">std::is_constant_evaluated()</code>的用途之后，我们还需要弄清楚何为明显常量求值。只有弄清楚这个概念，才可能合理运用<code class="calibre10">std::is_constant_ evaluated()</code>函数。明显常量求值在标准文档中列举了下面几个类别。</p>

  <p class="zw">1．常量表达式，这个类别包括很多种情况，比如数组长度、<code class="calibre10">case</code>表达式、非类型模板实参等。</p>

  <p class="zw">2．<code class="calibre10">if constexpr</code>语句中的条件。</p>

  <p class="zw">3．<code class="calibre10">constexpr</code>变量的初始化程序。</p>

  <p class="zw">4．立即函数调用。</p>

  <p class="zw">5．约束概念表达式。</p>

  <p class="zw">6．可在常量表达式中使用或具有常量初始化的变量初始化程序。</p>

  <p class="zw">下面我们通过几个标准文档中的例子来体会以上规则：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;bool&gt; struct X {};
X&lt;std::is_constant_evaluated()&gt; x; // 非类型模板实参，函数返回true，最终类型为
                                   // X&lt;true&gt;
int y;

constexpr int f() {
  const int n = std::is_constant_evaluated() ? 13 : 17; // n是13
  int m = std::is_constant_evaluated() ? 13 : 17;   // m可能是13或者17，取决
                                                    // 于函数环境
  char arr[n] = {}; // char[13]
  return m + sizeof(arr);
}
int p = f();        // m是13；p结果如下26
int q = p + f();    // m是17；q结果如下56</code></pre>

  <p class="zw">上面的代码中需要解释的是<code class="calibre10">int p = f();</code>和<code class="calibre10">int q = p + f();</code>的区别，对于前者，<code class="calibre10">std::is_ constant_evaluated() == true</code>时<code class="calibre10">p</code>一定是一个恒定值，它是明显常量求值，所以<code class="calibre10">p</code>的结果是<code class="calibre10">26</code>。相反，<code class="calibre10">std::is_constant_ evaluated() == true</code>时，<code class="calibre10">q</code>的结果会依赖<code class="calibre10">p</code>，所以明显常量求值的结论显然不成立，需要采用<code class="calibre10">std::is_constant_evaluated() == false</code>的方案，于是<code class="calibre10">f()</code>函数中的<code class="calibre10">m</code>为<code class="calibre10">17</code>，最终<code class="calibre10">q</code>的求值结果是<code class="calibre10">56</code>。另外，如果这里的<code class="calibre10">p</code>初始化改变为<code class="calibre10">const int p = f();</code>，那么<code class="calibre10">f()</code>函数中的<code class="calibre10">m</code>为<code class="calibre10">13</code>，<code class="calibre10">q</code>的求值结果也会改变为<code class="calibre10">52</code>。</p>

  <p class="zw">最后需要注意的是，如果当判断是否为明显常量求值时存在多个条件，那么编译器会试探<code class="calibre10">std::is_constant_evaluated()</code>两种情况求值，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int y;
const int a = std::is_constant_evaluated() ? y : 1; // 函数返回false，a运行时
                                                    // 初始化为1
const int b = std::is_constant_evaluated() ? 2 : y; // 函数返回true，b编译时
                                                    // 初始化为2</code></pre>

  <p class="zw">当对<code class="calibre10">a</code>求值时，编译器试探<code class="calibre10">std::is_constant_evaluated() == true</code>的情况，发现<code class="calibre10">y</code>会改变<code class="calibre10">a</code>的值，所以最后选择<code class="calibre10">std::is_constant_evaluated() == false</code>；当对<code class="calibre10">b</code>求值时，编译器同样试探<code class="calibre10">std::is_constant_evaluated() == true</code>的情况，发现<code class="calibre10">b</code>的结果恒定为<code class="calibre10">2</code>，于是直接在编译时完成初始化。</p>

  <h2 id="OEBPS/Text/chapter027.html.nav_point_209" class="sigil_not_in_toc">27.17　总结</h2>

  <p class="zw">本章重点介绍了常量表达式，我们可以通过<code class="calibre10">constexpr</code>说明符声明常量表达式函数以及常量表达式值，它们让程序在编译期做了更多的事情，从而提高程序的运行效率。特别是在C++14以后，常量表达式函数的定义更加自由，具有极高的实用性。除此之外，立即函数以及检查常量初始化方法的加入也进一步完善了常量表达式体系。</p>

  <p class="zw">虽然常量表达式有着非常不错的特性，并且对于追求程序运行效率的程序员来说有着非常大的吸引力，但是我们依旧需要小心谨慎地对待它，因为一旦将函数或者变量原本带有的<code class="calibre10">constexpr</code>说明符删除，可能就会导致大量代码的编译失败。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter027.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter028.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter028.html.nav_point_210" class="not-in-toc">第28章　确定的表达式求值顺序（C++17）</h1>

  <h2 id="OEBPS/Text/chapter028.html.nav_point_211" class="sigil_not_in_toc">28.1　表达式求值顺序的不确定性</h2>

  <p class="zw">在C++语言之父本贾尼·斯特劳斯特卢普的作品《C++程序设计语言（第4版）》中有一段这样的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void f2() {
  std::string s = "but I have heard it works even if you don't believe in it";
  s.replace(0, 4, "").replace(s.find("even"), 4, "only").replace(s.find (" don't"), 6, "");
  assert(s == "I have heard it works only if you believe in it"); // OK
}</code></pre>

  <p class="zw">这段代码的本意是描述<code class="calibre10">std::string</code>成员函数<code class="calibre10">replace</code>的用法，但令人意想不到的是，在C++17之前它隐含着一个很大的问题，该问题的根源是表达式求值顺序。具体来说，是指一个表达式中的子表达式的求值顺序，而这个顺序在C++17之前是没有具体说明的，所以编译器可以以任何顺序对子表达式进行求值。比如说<code class="calibre10">foo(a, b, c)</code>，这里的<code class="calibre10">foo</code>、<code class="calibre10">a</code>、<code class="calibre10">b</code>和<code class="calibre10">c</code>的求值顺序是没有确定的。回到上面的替换函数，如果这里的执行顺序为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">1． replace(0, 4, "")
2． tmp1 = find("even")
3． replace(tmp1, 4, "only")
4． tmp2 = find(" don't")
5． replace(tmp2, 6, "")</code></pre>

  <p class="zw">那结果肯定是“I have heard it works only if you believe in it”，没有任何问题。但是由于没有对表达式求值顺序的严格规定，因此其求值顺序可能会变成：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">1． tmp1 = find("even")
2． tmp2 = find(" don't")
3． replace(0, 4, "")
4． replace(tmp1, 4, "only")
5． replace(tmp2, 6, "")</code></pre>

  <p class="zw">相应的结果就不是那么正确了，我们会得到“I have heard it works evenonlyyou donieve in it”。</p>

  <p class="zw">为了证实这种问题发生的可能性，我找到了两个版本的GCC编译运行上面的代码，在最新GCC中可以得到期望的字符串，其中间代码GIMPLE也很好地描述了编译后表达式求值的顺序：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">_1 = std::__cxx11::basic_string&lt;char&gt;::replace (&amp;s, 0, 4, "");
_2 = std::__cxx11::basic_string&lt;char&gt;::find (&amp;s, "even", 0);
_3 = std::__cxx11::basic_string&lt;char&gt;::replace (_1, _2, 4, "only");
_4 = std::__cxx11::basic_string&lt;char&gt;::find (&amp;s, " don\'t", 0);
std::__cxx11::basic_string&lt;char&gt;::replace (_3, _4, 6, "");</code></pre>

  <p class="zw">但是在使用GCC5.4的时候，出现了“I have heard it works evenonlyyou donieve in it”的结果，查看GIMPLE以后会发现其表达式求值顺序发生了变化：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">D.22309 = std::__cxx11::basic_string&lt;char&gt;::find (&amp;s, " don\'t", 0);
D.22310 = std::__cxx11::basic_string&lt;char&gt;::find (&amp;s, "even", 0);
D.22311 = std::__cxx11::basic_string&lt;char&gt;::replace (&amp;s, 0, 4, "");
D.22312 = std::__cxx11::basic_string&lt;char&gt;::replace (D.22311, D.22310, 4,  "only");
std::__cxx11::basic_string&lt;char&gt;::replace (D.22312, D.22309, 6, "");</code></pre>

  <p class="zw">除了上述的例子之外，我们常用的&lt;&lt;操作符也面临同样的问题：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::cout &lt;&lt; f() &lt;&lt; g() &lt;&lt; h();</code></pre>

  <p class="zw">虽然我们认为上面的表达式应该按照<code class="calibre10">f()</code>、<code class="calibre10">g()</code>、<code class="calibre10">h()</code>顺序对表达式求值，但是编译器对此并不买单，在它看来这个顺序可以是任意的。</p>

  <h2 id="OEBPS/Text/chapter028.html.nav_point_212" class="sigil_not_in_toc">28.2　表达式求值顺序详解</h2>

  <p class="zw">从C++17开始，函数表达式一定会在函数的参数之前求值。也就是说在<code class="calibre10">foo(a, b, c)</code>中，<code class="calibre10">foo</code>一定会在<code class="calibre10">a</code>、<code class="calibre10">b</code>和<code class="calibre10">c</code>之前求值。但是请注意，参数之间的求值顺序依然没有确定，也就是说<code class="calibre10">a</code>、<code class="calibre10">b</code>和<code class="calibre10">c</code>谁先求值还是没有规定。对于这一点我和读者应该是同样的吃惊，因为从提案文档上看来，有充分的理由说明从左往右进行参数列表的表达式求值的可行性。我想一个可能的原因是求值顺序的改变影响到代码的优化路径，比如内联决策和寄存器分配方式，对于编译器实现来说也是不小的挑战吧。不过既然标准已经这么定下来了，我们就应该去适应标准。在函数的参数列表中，尽可能少地修改共享的对象，否则会很难确认实参的真实值。</p>

  <p class="zw">对于后缀表达式和移位操作符而言，表达式求值总是从左往右，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">E1[E2]
E1.E2
E1.*E2
E1-&gt;*E2
E1&lt;&lt;E2
E1&gt;&gt;E2</code></pre>

  <p class="zw">在上面的表达式中，子表达式求值<code class="calibre10">E1</code>总是优先于<code class="calibre10">E2</code>。而对于赋值表达式，这个顺序又正好相反，它的表达式求值总是从右往左，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">E1=E2
E1+=E2
E1-=E2
E1*=E2
E1/=E2
…</code></pre>

  <p class="zw">在上面的表达式中，子表达式求值<code class="calibre10">E2</code>总是优先于<code class="calibre10">E1</code>。这里虽然只列出了几种赋值表达式的形式，但实际上对于<code class="calibre10">E1@=E2</code>这种形式的表达式（其中<code class="calibre10">@</code>可以为<code class="calibre10">+</code>、<code class="calibre10">−</code>、*、<code class="calibre10">/</code>、<code class="calibre10">%</code>等）<code class="calibre10">E2</code>早于<code class="calibre10">E1</code>求值总是成立的。</p>

  <p class="zw">对于<code class="calibre10">new</code>表达式，C++17也做了规定。对于：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">new T(E)</code></pre>

  <p class="zw">这里<code class="calibre10">new</code>表达式的内存分配总是优先于<code class="calibre10">T</code>构造函数中参数<code class="calibre10">E</code>的求值。最后C++17还明确了一条规则：涉及重载运算符的表达式的求值顺序应由与之相应的内置运算符的求值顺序确定，而不是函数调用的顺序规则。</p>

  <h2 id="OEBPS/Text/chapter028.html.nav_point_213" class="sigil_not_in_toc">28.3　总结</h2>

  <p class="zw">表达式求值顺序的问题是很少有人会注意到的，但是通过本章的介绍我想读者应该已经感受到表达式求值顺序引起的问题的严重之处了，它可怕的地方是我们很难及时地甄别到这种错误，无论是C++的新手还是C++专家（除作者本人之外《C++程序设计语言》出版前可是有很多专家检查过的）。另外我可以告诉读者的是，这个问题已经持续了30多年了。之所以一直没有修改，应该是有C++的历史原因的，我们知道一门语言的出现是为了解决当时编程中所面临的挑战，我完全可以想象当时可能面临了很多问题，为了解决当时最主要的问题，所以放弃求值顺序的标准。不过现在，C++委员会的专家们似乎觉得是时候要发生点改变了。</p>

  <p class="zw">在经过C++17标准一系列对于表达式求值顺序的改善之后，《C++程序设计语言》中的那段代码就可以确保最终获得的字符串为：“I have heard it works only if you believe in it”。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter028.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter029.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter029.html.nav_point_214" class="not-in-toc">第29章　字面量优化（C++11～C++17）</h1>

  <h2 id="OEBPS/Text/chapter029.html.nav_point_215" class="sigil_not_in_toc">29.1　十六进制浮点字面量</h2>

  <p class="zw">从C++11开始，标准库中引入了<code class="calibre10">std::hexfloat</code>和<code class="calibre10">std::defaultfloat</code>来修改浮点输入和输出的默认格式化，其中<code class="calibre10">std::hexfloat</code>可以将浮点数格式化为十六进制的字符串，而<code class="calibre10">std::defaultfloat</code>可以将格式还原到十进制，以输出为例：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

int main()
{
  double float_array[]{ 5.875, 1000, 0.117 };
  for (auto elem : float_array) {
       std::cout &lt;&lt; std::hexfloat &lt;&lt; elem 
            &lt;&lt; " = " &lt;&lt; std::defaultfloat &lt;&lt; elem &lt;&lt; std::endl;
  }
}</code></pre>

  <p class="zw">上面的代码分别使用<code class="calibre10">std::hexfloat</code>和<code class="calibre10">std::defaultfloat</code>格式化输出了数组<code class="calibre10">x</code>里的元素，输出结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">0x1.780000p+2 = 5.875
0x1.f40000p+9 = 1000
0x1.df3b64p-4 = 0.117</code></pre>

  <p class="zw">这里有必要简单说明一下十六进制浮点数的表示方法，以<code class="calibre10">0x1.f40000p+9</code>为例：其中<code class="calibre10">0x1.f4</code>是一个十六进制的有效数，<code class="calibre10">p+9</code>是一个以<code class="calibre10">2</code>为底数，<code class="calibre10">9</code>为指数的幂。其中底数一定为<code class="calibre10">2</code>，指数使用的是十进制。也就是说<code class="calibre10">0x1.f40000p+9</code>可以表示为： <code class="calibre10">0x1.f4 * 2</code><sup class="calibre23"><code class="calibre10">9</code></sup>`。</p>

  <p class="zw">虽然C++11已经具备了在输入输出的时候将浮点数格式化为十六进制的能力，但遗憾的是我们并不能在源代码中使用十六进制浮点字面量来表示一个浮点数。幸运的是，这个问题在C++17标准中得到了解决：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

int main()
{
  double float_array[]{ 0x1.7p+2, 0x1.f4p+9, 0x1.df3b64p-4 };
  for (auto elem : float_array) {
       std::cout &lt;&lt; std::hexfloat &lt;&lt; elem 
            &lt;&lt; " = " &lt;&lt; std::defaultfloat &lt;&lt; elem &lt;&lt; std::endl;
  }
}</code></pre>

  <p class="zw">使用十六进制浮点字面量的优势显而易见，它可以更加精准地表示浮点数。例如，IEEE-754标准最小的单精度值很容易写为<code class="calibre10">0x1.0p−126</code>。当然了，十六进制浮点字面量的劣势也很明显，它不便于代码的阅读理解。总之，我们在C++17中可以根据实际需求选择浮点数的表示方法，当需要精确表示某个浮点数的时候可以采用十六进制浮点字面量，其他情况使用十进制浮点字面量即可。</p>

  <h2 id="OEBPS/Text/chapter029.html.nav_point_216" class="sigil_not_in_toc">29.2　二进制整数字面量</h2>

  <p class="zw">在C++14标准中定义了二进制整数字面量，正如十六进制（0x，0X）和八进制（0）都有固定前缀一样，二进制整数字面量也有前缀0b和0B。实际上GCC的扩展早已支持了二进制整数字面量，只不过到了C++14才作为标准引入：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto x = 0b11001101L + 0xcdl + 077LL + 42;
std::cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; ", sizeof(x) = " &lt;&lt; sizeof(x) &lt;&lt; std::endl;</code></pre>

  <h2 id="OEBPS/Text/chapter029.html.nav_point_217" class="sigil_not_in_toc">29.3　单引号作为整数分隔符</h2>

  <p class="zw">除了添加二进制整数字面量以外，C++14标准还增加了一个用单引号作为整数分隔符的特性，目的是让比较长的整数阅读起来更加容易。单引号整数分隔符对于十进制、八进制、十六进制、二进制整数都是有效的，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">constexpr int x = 123'456;
static_assert(x == 0x1e'240);
static_assert(x == 036'11'00);
static_assert(x == 0b11'110'001'001'000'000);</code></pre>

  <p class="zw">值得注意的是，由于单引号在过去有用于界定字符的功能，因此这种改变可能会引起一些代码的兼容性问题，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

#define M(x, …) __VA_ARGS__
int x[2] = { M(1'2,3'4) };

int main()
{
  std::cout &lt;&lt; "x[0] = "&lt;&lt; x[0] &lt;&lt; ", x[1] = " &lt;&lt; x[1] &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">上面的代码在C++11和C++14标准下编译运行的结果不同，在C++11标准下输出结果为<code class="calibre10">x[0] = 0, x[1] = 0</code>，而在C++14标准下输出结果为<code class="calibre10">x[0] = 34, x[1] = 0</code>。这个现象很容易解释，在C++11中<code class="calibre10">1'2,3'4</code>是一个参数，所以<code class="calibre10">__VA_ARGS__</code>为空，而在C++14中它是两个参数<code class="calibre10">12</code>和<code class="calibre10">34</code>，所以<code class="calibre10">__VA_ARGS__</code>为<code class="calibre10">34</code>。虽然会引起一点兼容性问题，但是读者不必过于担心，上面这种代码很少会出现在真实的项目中，大部分情况下我们还是可以放心地将编程环境升级到C++14或者更高标准的，只不过如果真的出现了编译错误，不妨留意一下是不是这个问题造成的。</p>

  <h2 id="OEBPS/Text/chapter029.html.nav_point_218" class="sigil_not_in_toc">29.4　原生字符串字面量</h2>

  <p class="zw">过去想在C++中嵌入一段带格式和特殊符号的字符串是一件非常令人头痛的事情，比如在程序中嵌入一份HTML代码，我们不得不写成这样：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">char hello_world_html[] =
  "&lt;!DOCTYPE html&gt;\r\n"
  "&lt;html lang = \"en\"&gt;\r\n"
  "  &lt;head&gt;\r\n"
  "  &lt;meta charset = \"utf-8\"&gt;\r\n"
  "  &lt;meta name = \"viewport\" content = \"width=device-width, initial-scale=1, user-scalable=yes\"&gt;\r\n"
  "    &lt;title&gt;Hello World!&lt;/title&gt;\r\n"
  "  &lt;/head&gt;\r\n"
  "  &lt;body&gt;\r\n"
  "    Hello World!\r\n"
  "  &lt;/body&gt;\r\n"
  "&lt;/html&gt;\r\n";</code></pre>

  <p class="zw">可以看到上面代码里的字符串非常难以阅读和维护，这是因为它包含的大量转义字符影响了阅读的流畅性。为了解决这种问题，C++11标准引入原生字符串字面量的概念。</p>

  <p class="zw">原生字符串字面量并不是一个新的概念，比如在Python中已经支持在字符串之前加R来声明原生字符串字面量了。使用原生字符串字面量的代码会在编译的时候被编译器直接使用，也就是说保留了字符串里的格式和特殊字符，同时它也会忽略转移字符，概括起来就是所见即所得。</p>

  <p class="zw">声明原生字符串字面量的语法很简单，即<code class="calibre10">prefix R"delimiter(raw_　characters)delimiter"</code>，这其中<code class="calibre10">prefix</code>和<code class="calibre10">delimiter</code>是可选部分，我们可以忽略它们，所以最简单的原生字符串字面量声明是<code class="calibre10">R"(raw_characters)"</code>。以上面的HTML字符串为例：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">char hello_world_html[] = R"(&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"&gt;
  &lt;title&gt;Hello World!&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
Hello World!
&lt;/body&gt;
&lt;/html&gt;
)";</code></pre>

  <p class="zw">从上面的代码可以看到，原生字符串中不需要<code class="calibre10">\r\n</code>，也不需要对引号使用转义字符，编译后字符串的内容和格式与代码里的一模一样。读者在这里可能会有一个疑问，如果在声明的字符串内部有一个字符组合正好是<code class="calibre10">)"</code>，这样原生字符串不就会被截断了吗？没错，如果出现这样的情况，编译会出错。不过，我们也不必担心这种情况，C++11标准已经考虑到了这个问题，所以有了<code class="calibre10">delimiter</code>（分隔符）这个元素。<code class="calibre10">delimiter</code>可以是由除括号、反斜杠和空格以外的任何源字符构成的字符序列，长度至多为16个字符。通过添加<code class="calibre10">delimiter</code>可以改变编译器对原生字符串字面量范围的判定，从而顺利编译带有<code class="calibre10">)"</code>的字符串，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">char hello_world_html[] = R"cpp(&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"&gt;
  &lt;title&gt;Hello World!&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
"(Hello World!)"
&lt; / body &gt;
&lt; / html&gt;
)cpp";</code></pre>

  <p class="zw">在上面的代码中，字符串虽然包含<code class="calibre10">"(Hello World!)"</code>这个比较特殊的子字符串，但是因为我们添加了<code class="calibre10">cpp</code>这个分隔符，所以编译器能正确地获取字符串的真实范围，从而顺利地通过编译。</p>

  <p class="zw">C++11标准除了让我们能够定义<code class="calibre10">char</code>类型的原生字符串字面量外，对于<code class="calibre10">wchar_t</code>、<code class="calibre10">char8_t</code>（C++20标准开始）、<code class="calibre10">char16_t</code>和<code class="calibre10">char32_t</code>类型的原生字符串字面量也有支持。要支持这4种字符类型，就需要用到另外一个可选元素<code class="calibre10">prefix</code>了。这里的<code class="calibre10">prefix</code>实际上是声明4个类型字符串的前缀<code class="calibre10">L</code>、<code class="calibre10">u</code>、<code class="calibre10">U</code>和<code class="calibre10">u8</code>。</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">char8_t utf8[] = u8R"(你好世界)"; // C++20标准开始
char16_t utf16[] = uR"(你好世界)";
char32_t utf32[] = UR"(你好世界)";
wchar_t wstr[] = LR"(你好世界)";</code></pre>

  <p class="zw">最后，关于原生字符串字面量的连接规则实际上和普通字符串字面量是一样的，唯一需要注意的是，原生字符串字面量除了能连接原生字符串字面量以外，还能连接普通字符串字面量。</p>

  <h2 id="OEBPS/Text/chapter029.html.nav_point_219" class="sigil_not_in_toc">29.5　用户自定义字面量</h2>

  <p class="zw">在C++11标准中新引入了一个用户自定义字面量的概念，程序员可以通过自定义后缀将整数、浮点数、字符和字符串转化为特定的对象。这个特性往往用在需要大量声明某个类型对象的场景中，它能够减少一些重复类型的书写，避免代码冗余。一个典型的例子就是不同单位对象的互相操作，比如长度、重量、时间等，举个例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

template&lt;int scale, char … unit_char&gt;
struct LengthUnit {
  constexpr static int value = scale;
  constexpr static char unit_str[sizeof…(unit_char) + 1] = { unit_char…,    '\0' };
};

template&lt;class T&gt;
class LengthWithUnit {
public:
  LengthWithUnit() : length_unit_(0) {}
  LengthWithUnit(unsigned long long length) : length_unit_(length * T::value) {}

  template&lt;class U&gt;
  LengthWithUnit&lt;std::conditional_t&lt;(T::value &gt; U::value), U, T&gt;&gt; operator+(const LengthWithUnit&lt;U&gt; &amp;rhs)
  {
       using unit_type = std::conditional_t&lt;(T::value &gt; U::value), U, T&gt;;
       return LengthWithUnit&lt;unit_type&gt;((length_unit_ + rhs.get_length()) / unit_type::value);
  }

  unsigned long long get_length() const { return length_unit_; }
  constexpr static const char* get_unit_str() { return T::unit_str; }

private:
  unsigned long long length_unit_;
};

template&lt;class T&gt;
std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const LengthWithUnit&lt;T&gt; &amp;unit)
{
  out &lt;&lt; unit.get_length() / T::value &lt;&lt; LengthWithUnit&lt;T&gt;::get_unit_str();
  return out;
}

using MMUnit = LengthUnit&lt;1, 'm', 'm'&gt;;
using CMUnit = LengthUnit&lt;10, 'c', 'm'&gt;;
using DMUnit = LengthUnit&lt;100, 'd', 'm'&gt;;
using MUnit = LengthUnit&lt;1000, 'm'&gt;;
using KMUnit = LengthUnit&lt;1000000, 'k', 'm'&gt;;

using LengthWithMMUnit = LengthWithUnit&lt;MMUnit&gt;;
using LengthWithCMUnit = LengthWithUnit&lt;CMUnit&gt;;
using LengthWithDMUnit = LengthWithUnit&lt;DMUnit&gt;;
using LengthWithMUnit = LengthWithUnit&lt;MUnit&gt;;
using LengthWithKMUnit = LengthWithUnit&lt;KMUnit&gt;;

int main()
{
  auto total_length = LengthWithCMUnit(1) + LengthWithMUnit(2) + LengthWithMMUnit(4);
  std::cout &lt;&lt; total_length;
}</code></pre>

  <p class="zw">上面的代码定义了两个类模板，一个是长度单位<code class="calibre10">LengthUnit</code>，另外一个是带单位的长度<code class="calibre10">LengthWithUnit</code>，然后基于这两个类模板生成了毫米、厘米、分米、米和千米单位类以及它们对应的带单位的长度类。为了不同单位的数据相加，我们在类模板<code class="calibre10">LengthWithUnit</code>中重载了加号运算符，函数中总是会将较大的单位转换到较小的单位进行求和，比如千米和厘米相加得到的结果单位为厘米。最后，我们在<code class="calibre10">main</code>函数中对不同单位的对象求和并且输出求和结果。类模板的编写用到了一些模板元编程的知识，我们暂时可以忽略它们，现在需要关注的是<code class="calibre10">main</code>函数里的代码。我们发现每增加一个求和的操作数就需要重复写一个类型<code class="calibre10">LengthWithXXUnit</code>，当操作数很多的时候代码会变得很长，难以阅读和维护。当遇到这种情况的时候，我们可以考虑使用用户自定义字面量来简化代码，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">LengthWithMMUnit operator "" _mm(unsigned long long length)
{
  return LengthWithMMUnit(length);
}

LengthWithCMUnit operator "" _cm(unsigned long long length)
{
  return LengthWithCMUnit(length);
}

LengthWithDMUnit operator "" _dm(unsigned long long length)
{
  return LengthWithDMUnit(length);
}

LengthWithMUnit operator "" _m(unsigned long long length)
{
  return LengthWithMUnit(length);
}

LengthWithKMUnit operator "" _km(unsigned long long length)
{
  return LengthWithKMUnit(length);
}

int main()
{
  auto total_length = 1_cm + 2_m + 4_mm;
  std::cout &lt;&lt; total_length;
}</code></pre>

  <p class="zw">上面的代码定义了5个字面量运算符函数，这些函数返回不同单位的长度对象，分别对应于毫米、厘米、分米、米和千米。字面量运算符函数的函数名会作为后缀应用于字面量。在<code class="calibre10">main</code>函数中，我们可以看到现在的代码省略了<code class="calibre10">LengthWithXXUnit</code>的类型声明，取而代之的是一个整型的字面量紧跟着一个以下画线开头的后缀<code class="calibre10">_cm</code>、<code class="calibre10">_m</code>或者<code class="calibre10">_mm</code>。在这里编译器会根据字面量的后缀去查找对应的字面量运算符函数，并根据函数形式对字面量做相应处理后调用该函数，如果编译器没有找到任何对应的函数，则会报错。所以这里的<code class="calibre10">1_cm</code>、<code class="calibre10">2_m</code>和<code class="calibre10">4_mm</code>分别等于调用了<code class="calibre10">LengthWithCM- Unit(1)</code>、<code class="calibre10">LengthWithMUnit(2)</code>和<code class="calibre10">LengthWithMMUnit(4)</code>。</p>

  <p class="zw">接下来让我们看一看字面量运算符函数的语法规则，字面量运算符函数的语法和其他运算符函数一样都是由返回类型、<code class="calibre10">operator</code>关键字、标识符以及函数形参组成的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">retrun_type operator "" identifier (params)</code></pre>

  <p class="zw">值得注意的是在C++11的标准中，双引号和紧跟的标识符中间必须有空格，不过这个规则在C++14标准中被去除。在C++14标准中，标识符不但可以紧跟在双引号后，而且还能使用C++的保留字作为标识符。标准中还建议用户定义的字面量运算符函数的标识符应该以下画线开始，把没有下画线开始的标识符保留给标准库使用。虽然标准并没有强制规定自定义的字面量运算符函数标识符必须以下画线开始，但是我们还是应该尽量遵循标准的建议。这一点编译器也会提示我们，如果使用了非下画线开始的标识符，它会给出明确的警告信息。</p>

  <p class="zw">上文曾提到，用户自定义字面量支持整数、浮点数、字符和字符串4种类型。虽然它们都通过字面量运算符函数来定义，但是对于不同的类型字面量运算符函数，语法在参数上有略微的区别。</p>

  <p class="zw">对于整数字面量运算符函数有3种不同的形参类型<code class="calibre10">unsigned long long</code>、<code class="calibre10">const char *</code>以及形参为空。其中<code class="calibre10">unsigned long long</code>和<code class="calibre10">const char *</code>比较简单，编译器会将整数字面量转换为对应的无符号<code class="calibre10">long long</code>类型或者常量字符串类型，然后将其作为参数传递给运算符函数。而对于无参数的情况则使用了模板参数，形如<code class="calibre10">operator "" identifier&lt;char</code>…<code class="calibre10">c&gt;()</code>，这个稍微复杂一些，我们在后面的例子中详细介绍。</p>

  <p class="zw">对于浮点数字面量运算符函数也有3种形参类型<code class="calibre10">long double</code>、<code class="calibre10">const char *</code>以及形参为空。和整数字面量运算符函数相比，除了将<code class="calibre10">unsigned long long</code>换成了<code class="calibre10">long double</code>，没有其他的区别。</p>

  <p class="zw">对于字符串字面量运算符函数目前只有一种形参类型列表<code class="calibre10">const char * str, size_t len</code>。其中<code class="calibre10">str</code>为字符串字面量的具体内容，<code class="calibre10">len</code>是字符串字面量的长度。</p>

  <p class="zw">对于字符字面量运算符函数也只有一种形参类型<code class="calibre10">char</code>，参数内容为字符字面量本身：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;string&gt;

unsigned long long operator "" _w1(unsigned long long n)
{
  return n;
}

const char * operator "" _w2(const char *str)
{
  return str;
}

unsigned long long operator "" _w3(long double n)
{
  return n;
}

std::string operator "" _w4(const char* str, size_t len)
{
  return str;
}

char operator "" _w5(char n)
{
  return n;
}

unsigned long long operator ""if(unsigned long long n)
{
  return n;
}

int main()
{
  auto x1 = 123_w1;
  auto x2_1 = 123_w2;
  auto x2_2 = 12.3_w2;
  auto x3 = 12.3_w3;
  auto x4 = "hello world"_w4;
  auto x5 = 'a'_w5;
  auto x6 = 123if;
}</code></pre>

  <p class="zw">在上面的代码中，根据字面量运算符函数的语法规则，后缀<code class="calibre10">_w1</code>和<code class="calibre10">_w2</code>可以用于整数，后缀<code class="calibre10">_w3</code>和<code class="calibre10">_w2</code>可以用于浮点数，而<code class="calibre10">_w4</code>和<code class="calibre10">_w5</code>分别用于字符串和字符。请注意最后一个<code class="calibre10">if</code>后缀，它必须用支持C++14标准的编译器才能编译成功。这个后缀有两点比较特殊，首先它使用保留关键字<code class="calibre10">if</code>作为后缀，其次它没有用下画线开头。前者能够这么做是因为C++14标准中字面量运算符函数双引号后紧跟的标识符允许使用保留字，而对于后者支持C++11标准的编译器通常允许这么做，只是会给出警告。</p>

  <p class="zw">最后来看一下字面量运算符函数使用模板参数的情况（关于可变参数模板的内容会在第35章详细介绍），在这种情况下函数本身没有任何形参，字面量的内容通过可变模板参数列表<code class="calibre10">&lt;char</code>…<code class="calibre10">&gt;</code>传到函数，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;string&gt;

template &lt;char…c&gt; std::string operator "" _w()
{
  std::string str;
  //(str.push_back(c), …);       // C++17的折叠表达式
  using unused = int[];
  unused{ (str.push_back(c), 0) … };
  return str;
}

int main()
{
  auto x = 123_w;
  auto y = 12.3_w;
}</code></pre>

  <p class="zw">上面这段代码展示了一个使用可变参数模板的字面量运算符函数，该函数通过声明数组展开参数包的技巧将<code class="calibre10">char</code>类型的模板参数<code class="calibre10">push_back</code>到<code class="calibre10">str</code>中。实际上，通常情况下很少会用到这种形式的字面量运算符函数，从易用性和可读性的角度来说它都不是一个好的选择，所以我建议还是采用上面提到的那些带有形参的字面量运算符函数。</p>

  <h2 id="OEBPS/Text/chapter029.html.nav_point_220" class="sigil_not_in_toc">29.6　总结</h2>

  <p class="zw">本章介绍了C++11到C++17中字面量方面的优化，其中二进制整数字面量和十六进制浮点字面量增强了字面量的表达能力，让单引号作为整数的分隔符优化了长整数的可读性，用户自定义字面量让代码库作者能够为客户提供更加简洁的调用对象的方法，最实用的应该要数原生字符串字面量了，它让我们摆脱了复杂字符串中转义字符的干扰，让字符串所见即所得，在类似代码或者正则表达式等字符串上十分有用。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter029.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter030.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter030.html.nav_point_221" class="not-in-toc">第30章　alignas和alignof（C++11 C++17）</h1>

  <h2 id="OEBPS/Text/chapter030.html.nav_point_222" class="sigil_not_in_toc">30.1　不可忽视的数据对齐问题</h2>

  <p class="zw">C++11中新增了<code class="calibre10">alignof</code>和<code class="calibre10">alignas</code>两个关键字，其中<code class="calibre10">alignof</code>运算符可以用于获取类型的对齐字节长度，<code class="calibre10">alignas</code>说明符可以用来改变类型的默认对齐字节长度。这两个关键字的出现解决了长期以来C++标准中无法对数据对齐进行处理的问题。</p>

  <p class="zw">在详细介绍这两个关键字之前，我们先来看一看下面这段代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

struct A
{
  char a1;
  int a2;
  double a3;
};

struct B
{
  short b1;
  bool b2;
  double b3;
};

int main()
{
  std::cout &lt;&lt; "sizeof(A::a1) + sizeof(A::a2) + sizeof(A::a3) = " 
       &lt;&lt; sizeof(A::a1) + sizeof(A::a2) + sizeof(A::a3) &lt;&lt; std::endl;
  std::cout &lt;&lt; "sizeof(B::b1) + sizeof(B::b2) + sizeof(B::b3) = " 
       &lt;&lt; sizeof(B::b1) + sizeof(B::b2) + sizeof(B::b3) &lt;&lt; std::endl;
  std::cout &lt;&lt; "sizeof(A) = " &lt;&lt; sizeof(A) &lt;&lt; std::endl;
  std::cout &lt;&lt; "sizeof(B) = " &lt;&lt; sizeof(B) &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">编译运行这段代码会得到以下结果：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">sizeof(A::a1) + sizeof(A::a2) + sizeof(A::a3) = 13
sizeof(B::b1) + sizeof(B::b2) + sizeof(B::b3) = 11
sizeof(A) = 16
sizeof(B) = 16</code></pre>

  <p class="zw">奇怪的事情发生了，<code class="calibre10">A</code>和<code class="calibre10">B</code>两个类的成员变量的数据长度之和分别为<code class="calibre10">13</code>字节和<code class="calibre10">11</code>字节，与它们本身的数据长度<code class="calibre10">16</code>字节不同。对比这两个类，它们在成员变量数据长度之和上明明不同，却在类整体数据长度上又相同。有经验的程序员应该一眼就能看出其中的原因。实际上，一个类型的属性除了其数据长度，还有一个重要的属性——数据对齐的字节长度。</p>

  <p class="zw">在上面的代码中，<code class="calibre10">char</code>以<code class="calibre10">1</code>字节对齐，<code class="calibre10">short</code>以<code class="calibre10">2</code>字节对齐，<code class="calibre10">int</code>以<code class="calibre10">4</code>字节对齐，<code class="calibre10">double</code>以<code class="calibre10">8</code>字节对齐，所以它们的实际数据结构应该是这样的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct A
{
  char a1;
  char a1_pad[3];
  int a2;
  double a3;
};</code></pre>

  <p class="zw">内存布局如表30-1所示。</p>

  <p class="zw">▼表30-1</p>

  <table border="1" width="90%" class="calibre11">
    <thead class="calibre12">
      <tr class="calibre13">
        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">偏移量</p>
        </th>

        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">元素</p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre15">
      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">0x0000</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">a1</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">0x0001</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">a1_pad[3]</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">0x0004</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">a2</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">0x0008</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">a3</p>
        </td>
      </tr>
    </tbody>
  </table>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct B
{
  short b1;
  bool b2;
  char b2_pad[5];
  double b3;
};</code></pre>

  <p class="zw">内存布局如表30-2所示。</p>

  <p class="zw">▼表30-2</p>

  <table border="1" width="90%" class="calibre11">
    <thead class="calibre12">
      <tr class="calibre13">
        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">偏移量</p>
        </th>

        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">元素</p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre15">
      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">0x0000</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">b1</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">0x0002</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">b2</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">0x0003</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">b2_pad[5]</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">0x0008</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">b3</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="zw">通过上述示例应该能够对数据对齐有比较直观的理解了。但是为什么我们需要数据对齐呢？原因说起来很简单，就是硬件需要。首当其冲的就是CPU了，CPU对数据对齐有着迫切的需求，一个好的对齐字节长度可以让CPU运行起来更加轻松快速。反过来说，不好的对齐字节长度则会让CPU运行速度减慢，甚至抛出错误。通常来说所谓好的对齐长度和CPU访问数据总线的宽度有关系，比如CPU访问32位宽度的数据总线，就会期待数据是按照32位对齐，也就是4字节。这样CPU读取4字节的数据只需要对总线访问一次，但是如果要访问的数据并没有按照4字节对齐，那么CPU需要访问数据总线两次，运算速度自然也就减慢了。另外，对于数据对齐问题引发错误的情况（Alignment Fault），通常会发生在ARM架构的计算机上。当然除了CPU之外，还有其他硬件也需要数据对齐，比如通过DMA访问硬盘，就会要求内存必须是4K对齐的。总的来说，配合现代编译器和CPU架构，可以让程序获得令人难以置信的性能，但这种良好的性能取决于某些编程实践，其中一种编程实践是正确的数据对齐。</p>

  <h2 id="OEBPS/Text/chapter030.html.nav_point_223" class="sigil_not_in_toc">30.2　C++11标准之前控制数据对齐的方法</h2>

  <p class="zw">在C++11标准之前我们没有一个标准方法来设定数据的对齐字节长度，只能依靠一些编程技巧和各种编译器自身提供的扩展功能来达到这一目的。</p>

  <p class="zw">首先让我们来看一看如何获得类型的对齐字节长度。在<code class="calibre10">alignof</code>运算符被引入之前，程序员常用<code class="calibre10">offsetof</code>来间接实现<code class="calibre10">alignof</code>的功能，其中一种实现方法如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#define ALIGNOF(type, result) \
  struct type##_alignof_trick{ char c; type member; }; \
  result = offsetof(type##_alignof_trick, member)

int x1 = 0;
ALIGNOF(int, x1);</code></pre>

  <p class="zw">以上代码用宏定义了一个结构体，其中用<code class="calibre10">type</code>定义了成员变量<code class="calibre10">member</code>，然后用<code class="calibre10">offsetof</code>获取<code class="calibre10">member</code>的偏移量，从而获取指定类型的对齐字节长度。该方法运用在大部分类型上没有问题，不过还是有些例外，比如函数指针类型：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int x1 = 0;
ALIGNOF(void(*)(), x1);       // 无法编译通过</code></pre>

  <p class="zw">当然了，我们可以用<code class="calibre10">typedef</code>来解决这个问题：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int x1 = 0;
typedef void (*f)();
ALIGNOF(f, x1);</code></pre>

  <p class="zw">实际上我们还有第二种更好的方案：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T&gt; struct alignof_trick { char c; T member; };
#define ALIGNOF(type) offsetof(alignof_trick&lt;type&gt;, member)

auto x1 = ALIGNOF(int);
auto x2 = ALIGNOF(void(*)());</code></pre>

  <p class="zw">上面的代码利用模板来构造结构体，这一点显然优于用宏构造。因为它不仅可以处理函数指针类型，还能够在表达式中构造结构体，从而让ALIGNOF写在表达式当中，这也让它更接近<code class="calibre10">alignof</code>运算符的用法。</p>

  <p class="zw">除用一些小技巧获取类型对齐字节长度之外，很多编译器还提供了一些扩展方法帮助我们获得类型的对齐字节长度，以MSVC和GCC为例，它们分别可以通过扩展关键字<code class="calibre10">__alignof</code>和<code class="calibre10">__alignof__</code>来获取数据类型的对齐字节长度：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">// MSVC
auto x1 = __alignof(int);
auto x2 = __alignof(void(*)());

// GCC
auto x3 = __alignof__(int);
auto x4 = __alignof__(void(*)());</code></pre>

  <p class="zw">相对于获取数据对齐的功能而言，设置数据对齐就没那么幸运了，在C++11之前，我们不得不依赖编译器给我们提供的扩展功能来设置数据对齐。幸好很多编译器也提供了这样的功能，还是以MSVC和GCC为例：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">// MSVC
short x1;
__declspec(align(8)) short x2;
std::cout &lt;&lt; "x1 = " &lt;&lt; __alignof(x1) &lt;&lt; std::endl;
std::cout &lt;&lt; "x2 = " &lt;&lt; __alignof(x2) &lt;&lt; std::endl;

// GCC
short x3;
__attribute__((aligned(8))) short x4;
std::cout &lt;&lt; "x3 = " &lt;&lt; __alignof__(x3) &lt;&lt; std::endl;
std::cout &lt;&lt; "x4 = " &lt;&lt; __alignof__(x4) &lt;&lt; std::endl;</code></pre>

  <p class="zw">上面的代码输出结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">x1 = 2
x2 = 8
x3 = 2
x4 = 8</code></pre>

  <p class="zw"><code class="calibre10">__declspec(align(8))</code>和<code class="calibre10">__attribute__((aligned(8)))</code>分别将<code class="calibre10">x2</code>和<code class="calibre10">x4</code>两个<code class="calibre10">short</code>类型的对齐长度从2字节扩展到8字节。</p>

  <p class="zw">不同的编译器需要采用不同的扩展功能来控制类型的对齐字节长度，这一点对于程序员来说很不友好。所以C++标准委员在C++11标准中新增了<code class="calibre10">alignof</code>和<code class="calibre10">alignas</code>两个关键字。</p>

  <h2 id="OEBPS/Text/chapter030.html.nav_point_224" class="sigil_not_in_toc">30.3　使用alignof运算符</h2>

  <p class="zw"><code class="calibre10">alignof</code>运算符和我们前面提到的编译器扩展关键字<code class="calibre10">__alignof</code>、<code class="calibre10">__alignof__</code>用法相同，都是获得类型的对齐字节长度，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto x1 = alignof(int);
auto x2 = alignof(void(*)());

int a = 0;
auto x3 = alignof(a);              // *C++标准不支持这种用法</code></pre>

  <p class="zw">请注意上面的第4句代码，<code class="calibre10">alignof</code>的计算对象并不是一个类型，而是一个变量。但是C++标准规定<code class="calibre10">alignof</code>必须是针对类型的。不过GCC扩展了这条规则，<code class="calibre10">alignof</code>除了能接受一个类型外还能接受一个变量，用GCC编译此段代码是可以编译通过的。阅读了第4章的读者可能会想到，我们只需要结合<code class="calibre10">decltype</code>，就能够扩展出类似这样的功能：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int a = 0;
auto x3 = alignof(decltype(a));</code></pre>

  <p class="zw">但实际情况是，这种做法只有在类型使用默认对齐的时候才是正确的，如果用在下面的情况中会产生错误的结果：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">alignas(8) int a = 0;
auto x3 = alignof(decltype(a));       // 错误的返回4，而并非设置的8</code></pre>

  <p class="zw">使用MSVC的读者如果想获得变量的对齐，不妨使用编译器的扩展关键字<code class="calibre10">__alignof</code>：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">alignas(8) int a = 0;
auto x3 = __alignof(a);       // 返回8</code></pre>

  <p class="zw">另外，我们还可以通过<code class="calibre10">alignof</code>获得类型<code class="calibre10">std::max_align_t</code>的对齐字节长度，这是一个非常重要的值。C++11定义了<code class="calibre10">std::max_align_t</code>，它是一个平凡的标准布局类型，其对齐字节长度要求至少与每个标量类型一样严格。也就是说，所有的标量类型都适应<code class="calibre10">std::max_align_t</code>的对齐字节长度。C++标准还规定，诸如<code class="calibre10">new</code>和<code class="calibre10">malloc</code>之类的分配函数返回的指针需要适合于任何对象，也就是说内存地址至少与<code class="calibre10">std::max_align_t</code>严格对齐。由于C++标准并没有定义<code class="calibre10">std::max_ align_t</code>对齐字节长度具体是什么样的，因此不同的平台会有不同的值，通常情况下是8字节和16字节。下面做一个小实验来验证一下刚刚的说法：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">for (int i = 0; i &lt; 100; i++) {
  auto *p = new char();
  auto addr = reinterpret_cast&lt;std::uintptr_t&gt;(p);
  std::cout &lt;&lt; addr % alignof(std::max_align_t) &lt;&lt; std::endl;
  delete p;
}</code></pre>

  <p class="zw">编译运行以上代码，会发现输出的都是0，也就是说即使我们分配的是1字节的内存，内存分配器也会将指针定位到与<code class="calibre10">std::max_align_t</code>对齐的地方。如果我们有自定义内存分配器的需要，请务必考虑到这个细节。</p>

  <h2 id="OEBPS/Text/chapter030.html.nav_point_225" class="sigil_not_in_toc">30.4　使用alignas说明符</h2>

  <p class="zw">接下来看一看<code class="calibre10">alignas</code>说明符的用法，该说明符可以接受类型或者常量表达式。特别需要注意的是，该常量表达式计算的结果必须是一个2的幂值，否则是无法通过编译的。具体用法如下（这里采用GCC编译器，因为其<code class="calibre10">alignof</code>可以查看变量的对齐字节长度）：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
struct X
{
  char a1;
  int a2;
  double a3;
};

struct X1
{
  alignas(16) char a1;
  alignas(double) int a2;
  double a3;
};

struct alignas(16) X2
{
  char a1;
  int a2;
  double a3;
};

struct alignas(16) X3
{
  alignas(8) char a1;
  alignas(double) int a2;
  double a3;
};

struct alignas(4) X4
{
  alignas(8) char a1;
  alignas(double) int a2;
  double a3;
};

#define COUT_ALIGN(s) std::cout &lt;&lt; "alignof(" #s ") = " &lt;&lt; alignof(s) &lt;&lt; std::endl

int main()
{
  X x;
  X1 x1;
  X2 x2;
  X3 x3;
  X4 x4;
  alignas(4) X3 x5;
  alignas(16) X4 x6;

  COUT_ALIGN(x);
  COUT_ALIGN(x1);
  COUT_ALIGN(x2);
  COUT_ALIGN(x3);
  COUT_ALIGN(x4);
  COUT_ALIGN(x5);
  COUT_ALIGN(x6);

  COUT_ALIGN(x5.a1);
  COUT_ALIGN(x6.a1);
}</code></pre>

  <p class="zw">输出结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">alignof(x) = 8
alignof(x1) = 16
alignof(x2) = 16
alignof(x3) = 16
alignof(x4) = 8
alignof(x5) = 4
alignof(x6) = 16
alignof(x5.a1) = 8
alignof(x6.a1) = 8</code></pre>

  <p class="zw">从上面的代码可以看出，<code class="calibre10">alignas</code>的使用非常灵活，例子中它既可以用于结构体，也可以用于结构体的成员变量。如果将<code class="calibre10">alignas</code>用于结构体类型，那么该结构体整体就会以<code class="calibre10">alignas</code>声明的对齐字节长度进行对齐，比如在例子中，<code class="calibre10">X</code>的类型对齐字节长度为8字节，而<code class="calibre10">X2</code>在使用了<code class="calibre10">alignas(16)</code>之后，对齐字节长度修改为了16字节。另外，如果修改结构体成员的对齐字节长度，那么结构体本身的对齐字节长度也会发生变化，因为结构体类型的对齐字节长度总是需要大于或者等于其成员变量类型的对齐字节长度。比如<code class="calibre10">X1</code>的成员变量<code class="calibre10">a1</code>类型的对齐字节长度修改为了16字节，所有<code class="calibre10">X1</code>类型也被修改为16字节对齐。同样的规则也适用于结构体<code class="calibre10">X3</code>，<code class="calibre10">X3</code>类型的对齐字节长度被指定为16字节，虽然其成员变量<code class="calibre10">a1</code>的类型对齐字节长度被指定为8字节，但是并不能改变<code class="calibre10">X3</code>类型的对齐字节长度。<code class="calibre10">X4</code>就恰恰相反，由于<code class="calibre10">X4</code>指定的对齐字节长度为4字节，明显小于其成员变量类型需要的对齐字节长度的字节数，因此这里<code class="calibre10">X4</code>的<code class="calibre10">alignas(4)</code>会被忽略。最后要说明的是，结构体类型的对齐字节长度，并不能影响声明变量时变量的对齐字节长度，比如<code class="calibre10">X5</code>、<code class="calibre10">X6</code>。不过在变量声明时指定对齐字节长度，也不影响变量内部成员变量类型的对齐字节长度，比如<code class="calibre10">x5.a1</code>、<code class="calibre10">x6.a1</code>。上面的代码用结构体作为例子，实际上对于类也是一样的。</p>

  <h2 id="OEBPS/Text/chapter030.html.nav_point_226" class="sigil_not_in_toc">30.5　其他关于对齐字节长度的支持</h2>

  <p class="zw">C++11标准除了提供了关键字<code class="calibre10">alignof</code>和<code class="calibre10">alignas</code>来支持对齐字节长度的控制以外，还提供了<code class="calibre10">std::alignment_of</code>、<code class="calibre10">std::aligned_storage</code>和<code class="calibre10">std::aligned_union</code>类模板型以及<code class="calibre10">std::align</code>函数模板来支持对于对齐字节长度的控制。下面简单地介绍一下它们的用法。</p>

  <p class="zw"><code class="calibre10">std::alignment_of</code>和<code class="calibre10">alignof</code>的功能差不多，可以获取类型的对齐字节长度，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::cout &lt;&lt; std::alignment_of&lt;int&gt;::value &lt;&lt; std::endl;       // 输出4
std::cout &lt;&lt; std::alignment_of&lt;int&gt;() &lt;&lt; std::endl;            // 输出4
std::cout &lt;&lt; std::alignment_of&lt;double&gt;::value &lt;&lt; std::endl;    // 输出8
std::cout &lt;&lt; std::alignment_of&lt;double&gt;() &lt;&lt; std::endl;         // 输出8</code></pre>

  <p class="zw"><code class="calibre10">std::aligned_storage</code>可以用来分配一块指定对齐字节长度和大小的内存，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::aligned_storage&lt;128, 16&gt;::type buffer;
std::cout &lt;&lt; sizeof(buffer) &lt;&lt; std::endl;          // 内存大小指定为128字节
std::cout &lt;&lt; alignof(buffer) &lt;&lt; std::endl;         // 对齐字节长度指定为16字节</code></pre>

  <p class="zw"><code class="calibre10">std::aligned_union</code>接受一个<code class="calibre10">std::size_t</code>作为分配内存的大小，以及不定数量的类型。<code class="calibre10">std::aligned_union</code>会获取这些类型中对齐字节长度最严格的（对齐字节数最大）作为分配内存的对齐字节长度，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::aligned_union&lt;64, double, int, char&gt;::type buffer;
std::cout &lt;&lt; sizeof(buffer) &lt;&lt; std::endl;        // 内存大小指定为64字节
std::cout &lt;&lt; alignof(buffer) &lt;&lt; std::endl;       // 对齐字节长度自动选择为
                                                 // double，8字节对齐</code></pre>

  <p class="zw">最后解释一下<code class="calibre10">std::align</code>函数模板，该函数接受一个指定大小的缓冲区空间的指针和一个对齐字节长度，返回一个该缓冲区中最近的能找到符合指定对齐字节长度的指针。通常来说，我们传入的缓冲区内存大小为预分配的缓冲区大小加上预指定对齐字节长度的字节数。下面会给出一个例子详解这个函数模板的用法，这个例子不仅说明了函数的用法，更重要的是，它证明了在CPU喜爱的对齐字节长度上做计算，CPU的工作效率会更高：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;chrono&gt;
static inline void *__movsb(void *d, const void *s, size_t n) {
  asm volatile ("rep movsb"
                : "=D" (d),
                  "=S" (s),
                  "=c" (n)
                : "0" (d),
                  "1" (s),
                  "2" (n)
                : "memory");
  return d;
}

int main(int argc, char *argv[])
{
  constexpr int align_size = 32;
  constexpr int alloc_size = 10001;
  constexpr int buff_size = align_size + alloc_size;
  char dest[buff_size]{0};
  char src[buff_size]{0};
  void *dest_ori_ptr = dest;
  void *src_ori_ptr = src;
  size_t dest_size = sizeof(dest);
  size_t src_size = sizeof(src);
  char *dest_ptr = static_cast&lt;char *&gt;(std::align(align_size, alloc_size,  dest_ori_ptr, dest_size));
  char *src_ptr = static_cast&lt;char *&gt;(std::align(align_size, alloc_size,   src_ori_ptr, src_size));

  if (argc == 2 &amp;&amp; argv[1][0] == '1') {
       ++dest_ptr;
       ++src_ptr;
  } 

  auto start = std::chrono::high_resolution_clock::now();
  for (int i = 0; i &lt; 10000000; i++) {
       __movsb(dest_ptr, src_ptr, alloc_size - 1);
  }

  auto end = std::chrono::high_resolution_clock::now();
  std::chrono::duration&lt;double&gt; diff = end - start;
  std::cout &lt;&lt; "elapsed time = " &lt;&lt; diff.count();
}</code></pre>

  <p class="zw">上面的代码用汇编语言实现了一个<code class="calibre10">memcpy</code>函数以确保复制内存函数都是通过汇编指令<code class="calibre10">movsb</code>完成的。然后我们预先分配了两个10001+32字节大小的内存作为目标缓冲区和源缓冲区。此后通过<code class="calibre10">std::align</code>找到两个缓冲区中按照32字节对齐的指针，该指针指向的内存大小至少为10001字节。最后我们用自己实现的内存复制函数进行内存复制。如果运行的时候不带任何参数，则使用32字节对齐的内存进行复制，否则用1字节对齐的内存进行内存复制，复制动作重复10000000次。在Intel(R) Core(TM) i7-7700 CPU @ 3.60GHz的机器上，两种方法的运行结果很有大差别：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">./aligntest
elapsed time = 0.951485
./aligntest 1
elapsed time = 1.36937</code></pre>

  <p class="zw">可以看到，32字节对齐的缓冲区复制时间比1字节对齐的缓冲区复制时间整整少了0.4s有余。在性能优化上来说是非常巨大的提升。</p>

  <h2 id="OEBPS/Text/chapter030.html.nav_point_227" class="sigil_not_in_toc">30.6　C++17中使用new分配指定对齐字节长度的对象</h2>

  <p class="zw">前面曾提到过内存分配器会按照<code class="calibre10">std::max_align_t</code>的对齐字节长度分配对象的内存空间。这一点在C++17标准中发生了改变，<code class="calibre10">new</code>运算符也拥有了根据对齐字节长度分配对象的能力。这个能力是通过让<code class="calibre10">new</code>运算符接受一个<code class="calibre10">std::align_ val_t</code>类型的参数来获得分配对象需要的对齐字节长度来实现的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void* operator new(std::size_t, std::align_val_t);
void* operator new[](std::size_t, std::align_val_t);</code></pre>

  <p class="zw">编译器会自动从类型对齐字节长度的属性中获取这个参数并且传参，不需要额外的代码介入。例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">// test_new.cpp
#include &lt;iostream&gt;
union alignas(256) X
{
  char a1;
  int a2;
  double a3;
};
int main(int argc, char *argv[])
{
  X *x = new X();
  std::cout &lt;&lt; "x = " &lt;&lt; x &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">通过GCC编译器将其编译为C++11和C++17两个版本，可以看到输出结果的区别：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">g++ -std=c++11 test_new.cpp -o cpp11
./cpp11
x = 0x1071620

g++ -std=c++17 test_new.cpp -o cpp17
./cpp17
x = 0x1d1700</code></pre>

  <p class="zw">我们发现在使用C++11标准的情况下，<code class="calibre10">new</code>分配的对象指针（0x1071620）并没有按照<code class="calibre10">X</code>指定的对齐字节长度（256字节）对齐，而在使用C++17标准的情况下，<code class="calibre10">new</code>分配的对象指针（0x1d1700）正好为<code class="calibre10">X</code>指定的对齐字节长度。</p>

  <h2 id="OEBPS/Text/chapter030.html.nav_point_228" class="sigil_not_in_toc">30.7　总结</h2>

  <p class="zw">类型的对齐字节长度是编程中极易忽略的一个属性，这是因为即使我们不关注类型的对齐字节长度，大多数情况下它也不会妨碍我们写出正确的程序。但是就如<code class="calibre10">std::align</code>的代码示例所呈现的，如果掌握了类型对齐的方法，它能让我们写出更加高效的程序，从而充分发挥硬件的最大功效。新的C++标准提供了多种优秀的方案让我们在控制类型对齐方面变得游刃有余，一个好的C++程序员应该借助新标准提供的这些特性让程序运行得更加高效。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter030.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter031.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter031.html.nav_point_229" class="not-in-toc">第31章　属性说明符和标准属性（C++11～C++20）</h1>

  <h2 id="OEBPS/Text/chapter031.html.nav_point_230" class="sigil_not_in_toc">31.1　GCC的属性语法</h2>

  <p class="zw">GCC从2.9.3版本开始支持GCC手册的属性语法，后来一些编译器为了兼容以GCC为基础编写的代码也纷纷支持了GCC的属性语法。GCC的属性语法如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">_attribute__((attribute-list))</code></pre>

  <p class="zw">请注意，GCC添加了一个扩展关键字<code class="calibre10">__attribute__</code>，这个关键字前后都有双下画线并且紧跟着两对括号，用如此烦琐的语法作为说明符的目的一方面是防止入侵C++标准，另一方面是避免和现有代码发生冲突。GCC的属性语法十分灵活，它能够用于结构体、类、联合类型、枚举类型、变量或者函数。比如前面介绍的设置对齐字节长度就是GCC的属性语法：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

#define PRINT_ALIGN(c, v)   \
  std::cout &lt;&lt; "alignof(" #c ") = " &lt;&lt; alignof(c) \
  &lt;&lt; ", alignof(" #v ") = " &lt;&lt; alignof(v) &lt;&lt; std::endl

__attribute__((aligned(16))) class X { int i; } a;
class __attribute__((aligned(16))) X1 { int i; } a1;
class X2 { int i; } __attribute__((aligned(16))) a2;
class X3 { int i; } a3 __attribute__((aligned(16)));

int main()
{
  PRINT_ALIGN(X, a);
  PRINT_ALIGN(X1, a1);
  PRINT_ALIGN(X2, a2);
  PRINT_ALIGN(X3, a3);
}</code></pre>

  <p class="zw">以上代码的输出结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">alignof(X) = 4, alignof(a) = 16
alignof(X1) = 16, alignof(a1) = 16
alignof(X2) = 16, alignof(a2) = 16
alignof(X3) = 4, alignof(a3) = 16</code></pre>

  <p class="zw">可以看出，根据<code class="calibre10">__attribute__((aligned(16)))</code>所在语句位置的不同，对类和对象的作用是不同的。首先，放置在用户定义类型开始处的属性是声明类型的变量，而非类型本身，所以<code class="calibre10">__attribute__((aligned(16))) class X { int i; } a;</code>中对象<code class="calibre10">a</code>的对齐字节长度为16字节，而类<code class="calibre10">X</code>的对齐字节长度为默认的4字节。然后，放置在<code class="calibre10">class</code>关键字或者整个类声明之后的属性声明的是类型本身，一旦类型的对齐字节长度确定下来，其对象的对齐字节长度也就确定了下来，所以在<code class="calibre10">class__attribute__((aligned(16))) X1 { int i; } a1;</code>和<code class="calibre10">class X2 { int i; } __attribute__((aligned (16))) a2;</code>中类<code class="calibre10">X1</code>、<code class="calibre10">X2</code>以及对象<code class="calibre10">a1</code>、<code class="calibre10">a2</code>的对齐字节长度都是16字节。最后，放置在声明对象之后的属性声明的是对象本身，所以<code class="calibre10">class X3 { int i; } a3 __attribute__((aligned (16)));</code>中对象<code class="calibre10">a3</code>的对齐字节长度为16字节，而类<code class="calibre10">X3</code>的对齐字节长度为默认的4字节。实际上属性描述的范围非常广，除了刚刚提到的类和对象以外，对联合类型、函数等都可以进行声明，它还有属性覆盖和组合的规则，有兴趣的读者可以阅读GCC手册中关于属性的内容，这里就不再展开介绍了。</p>

  <h2 id="OEBPS/Text/chapter031.html.nav_point_231" class="sigil_not_in_toc">31.2　MSVC的属性语法</h2>

  <p class="zw">MSVC的属性语法和GCC相似，它引入了一个<code class="calibre10">__declspec</code>扩展关键字，不过这个关键字没有以双下画线结尾，后面紧跟的是单对括号：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">__declspec(attribute-list)</code></pre>

  <p class="zw">相对于GCC复杂的属性语法规则，MSVC的属性语法规则就简单多了：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">__declspec(dllimport) class X {} varX;
class __declspec(dllimport) X {};</code></pre>

  <p class="zw">MSDN的文档中介绍，将<code class="calibre10">__declspec</code>放置在声明对象语句的开头，则属性描述的是对象本身<code class="calibre10">varX</code>，而不是类型<code class="calibre10">X</code>，如果没有声明对象，则忽略属性。而将<code class="calibre10">__declspec</code>放置在<code class="calibre10">class</code>和类型名之间，描述的则是类型。</p>

  <p class="zw">不管是GCC的属性语法还是MSVC的属性语法，它们都有一个共同的问题——属性声明过于烦琐。为了解决这个问题，以及用标准化的方法统一属性说明符的语法规则，C++11发布了标准的属性说明符语法。</p>

  <h2 id="OEBPS/Text/chapter031.html.nav_point_232" class="sigil_not_in_toc">31.3　标准属性说明符语法</h2>

  <p class="zw">C++11标准的属性表示方法是以双中括号开头、以反双中括号结尾，括号中是具体的属性：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">[[attr]] [[attr1, attr2, attr3(args)]] [[namespace::attr(args)]]</code></pre>

  <p class="zw">当需要多属性的时候可以在一个双中括号内用逗号分隔属性，也可以用多个双中括号来描述不同的属性。属性本身还支持命名空间，这样各个编译器或者扩展厂商就可以定义自己的属性命名空间以避免相互冲突。虽然使用双中括号包括属性的语法多多少少看起来有些奇怪，不过也正因如此，无论是编译器还是程序员都能很容易地识别出语句中的属性，方便了属性插入程序中的任何角落。除此之外，使用这样的语法也比GCC和MSVC的属性语法简洁很多。</p>

  <p class="zw">有了这种“奇怪”语法作为先决条件，C++11标准的属性说明符可用在C++程序中的几乎所有位置，而且可用于几乎所有实体：类型、变量、函数、代码块等。只不过不同的属性本身有特定的声明对象，比如<code class="calibre10">[[noreturn]]</code>只能用于声明函数。在声明中，属性可出现在整个声明之前或直接跟在被声明对象之后，在这种情况下它们将被组合起来。普遍的规则是，属性说明符总是声明位于其之前的对象，而在整个声明之前的属性则会声明语句中所有声明的对象：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">[[attr1]] class [[attr2]] X { int i; } a, b[[attr3]];</code></pre>

  <p class="zw">在上面的例子中，<code class="calibre10">attr1</code>声明了对象<code class="calibre10">a</code>和<code class="calibre10">b</code>，<code class="calibre10">attr2</code>声明了类型<code class="calibre10">X</code>，<code class="calibre10">X</code>的属性也会影响到对象<code class="calibre10">a</code>和<code class="calibre10">b</code>，最后<code class="calibre10">attr3</code>只声明了对象<code class="calibre10">b</code>。前面虽然说过，属性可以用于几乎所有的位置，不过到C++20为止，绝大部分标准属性在声明中使用，目前只有<code class="calibre10">fallthrough</code>属性可以用于<code class="calibre10">switch</code>语句。</p>

  <h2 id="OEBPS/Text/chapter031.html.nav_point_233" class="sigil_not_in_toc">31.4　使用using打开属性的命名空间</h2>

  <p class="zw">上文提到过，为了防止不同编译器厂商在扩展属性的时候发生冲突，标准属性的语法支持了命名空间，举个例子（这个例子请使用GCC9.1或者以上的版本编译）：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">[[gnu::always_inline]] [[gnu::hot]] [[gnu::const]] [[nodiscard]]
inline int f();</code></pre>

  <p class="zw">或者</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">[[gnu::always_inline, gnu::hot, gnu::const, nodiscard]]
inline int f();</code></pre>

  <p class="zw">在这个例子中，GCC命名空间虽然保护了其属性不会受到其他属性的影响，但是为了声明这些属性，程序员不得不重复指示命名空间，这造成了代码冗余。C++17标准对命名空间属性声明做了优化，它引入了<code class="calibre10">using</code>关键字打开属性命名空间，随后即可直接使用命名空间的属性从而减少代码冗余，其语法如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">[[ using attribute-namespace : attribute-list ]]</code></pre>

  <p class="zw">其中<code class="calibre10">attribute-namespace</code>是命名空间的名称，<code class="calibre10">attribute-list</code>是命名空间内的属性，它们直接使用冒号分隔，多属性之间使用逗号分隔。现在让我们进一步改写函数<code class="calibre10">f</code>的属性：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">[[using gnu: always_inline, hot, const]][[nodiscard]]
inline int f();</code></pre>

  <p class="zw">在这个版本中我们将属性分为了两块，一块是标准属性<code class="calibre10">nodiscard</code>，另一块是带有GCC命名空间的扩展属性<code class="calibre10">always_inline</code>、<code class="calibre10">hot</code>和<code class="calibre10">const</code>。可以看到使用新的语法不仅消除了命名空间的冗余问题，而且很好地对属性进行了分类，让属性的修改和阅读都变得更加方便了。C++17标准还规定，编译器应该忽略任何无法识别的属性。</p>

  <h2 id="OEBPS/Text/chapter031.html.nav_point_234" class="sigil_not_in_toc">31.5　标准属性</h2>

  <p class="zw">虽然从语法上来说属性可以出现在程序的任意位置，但是从C++11到C++20标准一共只定义了9种标准属性。这是因为C++标准委员会对于标准属性的定义非常谨慎。一方面他们需要考虑一个语言特性应该定义为关键字还是定义为属性，另一方面还需要谨慎考虑该属性是否是平台通用。举例来说，在标准属性确定之前对齐字节长度一直作为一个扩展属性出现在各种编译器中，但是C++标准并不认可这种情况，于是对齐字节长度作为语言本身的一部分出现在了新的标准当中。</p>

  <p class="zw">接下来就让我们看一看目前定义的9种标准属性。</p>

  <h3 id="OEBPS/Text/chapter031.html.nav_point_235" class="sigil_not_in_toc1">31.5.1　noreturn</h3>

  <p class="zw"><code class="calibre10">noreturn</code>是C++11标准引入的属性，该属性用于声明函数不会返回。注意，这里的所谓函数不返回和函数返回类型为<code class="calibre10">void</code>不同，返回类型为<code class="calibre10">void</code>说明函数还是会返回到调用者，只不过没有返回值；而用<code class="calibre10">noreturn</code>属性声明的函数编译器会认为在这个函数中执行流会被中断，函数不会返回到其调用者。举例来说：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void foo() {}
void bar() {}

int main()
{
    foo();
    bar();
}</code></pre>

  <p class="zw">在以上代码中<code class="calibre10">foo</code>函数的返回类型为<code class="calibre10">void</code>，但是没有指定<code class="calibre10">noreturn</code>属性，所以函数还是返回。反汇编二进制程序可以得到汇编代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">foo():
.LFB0:
        push    rbp
        mov     rbp, rsp
        nop
        pop     rbp
        ret
.LFE0:
bar():
.LFB1:
        push    rbp
        mov     rbp, rsp
        nop
        pop     rbp
        ret
.LFE1:
main:
.LFB2:
        push    rbp
        mov     rbp, rsp
        call    foo()
        call    bar()
        mov     eax, 0
        pop     rbp
        ret
.LFE2:</code></pre>

  <p class="zw">从汇编代码可以看到，在调用<code class="calibre10">foo</code>函数以后执行流会返回到<code class="calibre10">main</code>函数并且再调用bar函数，该流程没有中断。如果我们给<code class="calibre10">foo</code>函数添加<code class="calibre10">noreturn</code>属性，那么这个反汇编代码就会发生变化：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">[[noreturn]] void foo() {}
void bar() {}

int main()
{
    foo();
    bar();
}</code></pre>

  <p class="zw">反汇编代码如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">foo():
.LFB0:
        push    rbp
        mov     rbp, rsp
        nop
        pop     rbp
        ret
.LFE0:
bar():
.LFB1:
        push    rbp
        mov     rbp, rsp
        nop
        pop     rbp
        ret
.LFE1:
main:
.LFB2:
        push    rbp
        mov     rbp, rsp
        call    foo()
.LFE2:</code></pre>

  <p class="zw">观察上面的反汇编代码可以发现，在对<code class="calibre10">foo</code>添加<code class="calibre10">noreturn</code>属性以后，<code class="calibre10">main</code>函数中编译器不再为调用<code class="calibre10">foo</code>后面的过程生成代码了，它不仅忽略了对<code class="calibre10">bar</code>函数的调用，甚至干脆连<code class="calibre10">main</code>函数里的栈平衡以及返回代码都忽略了。因为编译器被告知，调用<code class="calibre10">foo</code>函数之后程序的执行流会被中断，所以生成的代码一定不会被执行，索性也不需要生成这些代码了。</p>

  <h3 id="OEBPS/Text/chapter031.html.nav_point_236" class="sigil_not_in_toc1">31.5.2　carries_dependency</h3>

  <p class="zw"><code class="calibre10">carries_dependency</code>是C++11标准引入的属性，该属性允许跨函数传递内存依赖项，它通常用于弱内存顺序架构平台上多线程程序的优化，避免编译器生成不必要的内存栅栏指令。所谓弱内存顺序架构，简单来说是指在多核心的情况下，一个核心看到共享内存中的值的变化与另一个核心写入它们的顺序不同。IBM的PowerPC就是这样的架构，而Intel和AMD的x86/64处理器系列则并不属于此类。</p>

  <p class="zw">该属性可以出现在两种情况中。</p>

  <p class="zw">1．作为函数或者<code class="calibre10">lambda</code>表达式参数的属性出现，这种情况表示调用者不用担心内存顺序，函数内部会处理好这个问题，编译器可以不生成内存栅栏指令。</p>

  <p class="zw">2．作为函数的属性出现，这种情况表示函数的返回值已经处理好内存顺序，不需要编译器在函数返回前插入内存栅栏指令。</p>

  <h3 id="OEBPS/Text/chapter031.html.nav_point_237" class="sigil_not_in_toc1">31.5.3　deprecated</h3>

  <p class="zw"><code class="calibre10">deprecated</code>是在C++14标准中引入的属性，带有此属性的实体被声明为弃用，虽然在代码中依然可以使用它们，但是并不鼓励这么做。当代码中出现带有弃用属性的实体时，编译器通常会给出警告而不是错误。</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">[[deprecated]] void foo() {}
class [[deprecated]] X {};
int main()
{
  X x;
  foo();
}</code></pre>

  <p class="zw">在上面的代码中，函数<code class="calibre10">foo</code>和类<code class="calibre10">X</code>带有<code class="calibre10">deprecated</code>属性，所以在<code class="calibre10">main</code>函数被编译的时候，调用<code class="calibre10">foo</code>以及实例化<code class="calibre10">X</code>的行为会被编译器警告。<code class="calibre10">deprecated</code>属性还能接受一个参数用来指示弃用的具体原因或者提示用户使用新的函数，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">[[deprecated("foo was deprecated, use bar instead")]] void foo() {}
void bar() {}
int main()
{
  foo();
}</code></pre>

  <p class="zw">以上代码用GCC编译时除了会给出常规的弃用警告，还会带上我们指定的字符串：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">test.cpp: In function 'int main()':
test.cpp:9:6: warning: 'void foo()' is deprecated: foo was deprecated, use bar instead [-Wdeprecated-declarations]
  foo();</code></pre>

  <p class="zw">实际上，<code class="calibre10">deprecated</code>这个属性的使用范围非常广泛，它不仅能用在类、结构体和函数上，在普通变量、别名、联合体、枚举类型甚至命名空间上都可以使用。</p>

  <h3 id="OEBPS/Text/chapter031.html.nav_point_238" class="sigil_not_in_toc1">31.5.4　fallthrough</h3>

  <p class="zw"><code class="calibre10">fallthrough</code>是C++17标准中引入的属性，该属性可以在<code class="calibre10">switch</code>语句的上下文中提示编译器直落行为是有意的，并不需要给出警告。比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void bar() {}
void foo(int a)
{
  switch (a)
  {
  case 0:
       break;
  case 1:
       bar();
        [[fallthrough]];
  case 2:
       bar();
       break;
  default:
       break;
  }
}

int main()
{
  foo(1);
}</code></pre>

  <p class="zw">在上面这段代码中，<code class="calibre10">foo</code>函数的<code class="calibre10">switch</code>语句里<code class="calibre10">case 1</code>到<code class="calibre10">case 2</code>存在着一个直落的行为，在有的编译器中这种行为会给出警告提示，通过声明<code class="calibre10">fallthrough</code>属性可以消除该警告。不过，在我做实验的编译器中并没有因为直落行为而发出警告的情况，包括GCC、MSVC和CLang都是如此，所以这个属性对于这些主流编译器是没有效果的。最后请注意，<code class="calibre10">fallthrough</code>属性必须出现在<code class="calibre10">case</code>或者<code class="calibre10">default</code>标签之前，上面例子中的<code class="calibre10">fallthrough</code>属性出现在<code class="calibre10">case 2</code>之前，所以没有问题。违反这个规则，GCC和MSVC会给出警告，CLang则是直接报错。</p>

  <h3 id="OEBPS/Text/chapter031.html.nav_point_239" class="sigil_not_in_toc1">31.5.5　nodiscard</h3>

  <p class="zw"><code class="calibre10">nodiscard</code>是在C++17标准中引入的属性，该属性声明函数的返回值不应该被舍弃，否则鼓励编译器给出警告提示。<code class="calibre10">nodiscard</code>属性也可以声明在类或者枚举类型上，但是它对类或者枚举类型本身并不起作用，只有当被声明为<code class="calibre10">nodiscard</code>属性的类或者枚举类型被当作函数返回值的时候才发挥作用：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class [[nodiscard]] X {};

[[nodiscard]] int foo() { return 1; }
X bar() { return X(); };

int main()
{
  X x;
  foo();
  bar();
}</code></pre>

  <p class="zw">在上面的代码中，函数<code class="calibre10">foo</code>带有<code class="calibre10">nodiscard</code>属性，所以在<code class="calibre10">main</code>函数中忽略<code class="calibre10">foo</code>函数的返回值会让编译器发出警告。类<code class="calibre10">X</code>也被声明为<code class="calibre10">nodiscard</code>，不过该属性对类本身没有任何影响，编译器不会给出警告。但是当类<code class="calibre10">X</code>作为<code class="calibre10">bar</code>函数的返回值时情况就不同了，这时候相当于声明了函数<code class="calibre10">[[nodiscard]] X bar()</code>。在<code class="calibre10">main</code>函数中，忽略<code class="calibre10">bar</code>函数返回值的行为也会引发一个警告。需要注意的是，<code class="calibre10">nodiscard</code>属性只适用于返回值类型的函数，对于返回引用的函数使用<code class="calibre10">nodiscard</code>属性是没有作用的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class[[nodiscard]] X{};
X&amp; bar(X &amp;x) { return x; };

int main()
{
  X x;
  bar(x);    // bar返回引用，nodiscard不起作用，不会引发警告
}</code></pre>

  <p class="zw"><code class="calibre10">nodiscard</code>属性有几个常用的场合。</p>

  <p class="zw">1．防止资源泄露，对于像<code class="calibre10">malloc</code>或者<code class="calibre10">new</code>这样的函数或者运算符，它们返回的内存指针是需要及时释放的，可以使用<code class="calibre10">nodiscard</code>属性提示调用者不要忽略返回值。</p>

  <p class="zw">2．对于工厂函数而言，真正有意义的是回返的对象而不是工厂函数，将<code class="calibre10">nodiscard</code>属性应用在工厂函数中也可以提示调用者别忘了使用对象，否则程序什么也不会做。</p>

  <p class="zw">3．对于返回值会影响程序运行流程的函数而言，<code class="calibre10">nodiscard</code>属性也是相当合适的，它告诉调用方其返回值应该用于控制后续的流程。</p>

  <p class="zw">从C++20标准开始，<code class="calibre10">nodiscard</code>属性支持将一个字符串字面量作为属性的参数，该字符串会包含在警告中，可以用于解释返回结果不应被忽略的理由：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">[[nodiscard("Memory leak!")]] char* foo() { return new char[100]; }</code></pre>

  <p class="zw">除了给出不该忽略返回值的理由外，也可以在信息中添加使用返回值的建议。总之对于库作者来说，这是一个非常实用的特性。</p>

  <p class="zw">另外在C++20标准中，<code class="calibre10">nodiscard</code>属性还能用于构造函数，它会在类型构建临时对象的时候让编译器发出警告，这一点非常有趣，请看下面的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class X {
public:
  [[nodiscard]] X() {}
  X(int a) {}
};

int main()
{
  X x;
  X{};
  X{ 42 };
}</code></pre>

  <p class="zw">观察上面代码中类<code class="calibre10">X</code>的定义，它有两个构造函数，其中一个有<code class="calibre10">nodicard</code>属性<code class="calibre10">[[nodiscard]] X() {}</code>，另一个则没有。表现在<code class="calibre10">main</code>函数中就是，因为<code class="calibre10">X x;</code>构造了非临时对象，所以不会有问题；而<code class="calibre10">X{}</code>构造了临时对象，于是编译器给出忽略<code class="calibre10">X::X()</code>返回值的警告；<code class="calibre10">X{ 42 };</code>不会产生编译警告，因为<code class="calibre10">X(int a) {}</code>没有<code class="calibre10">nodicard</code>属性。</p>

  <h3 id="OEBPS/Text/chapter031.html.nav_point_240" class="sigil_not_in_toc1">31.5.6　maybe_unused</h3>

  <p class="zw"><code class="calibre10">maybe_unused</code>是在C++17标准中引入的属性，该属性声明实体可能不会被应用以消除编译器警告。实际上，在我的实验环境中GCC、MSVC和CLang对于未使用的实例默认情况下都不会给出警告，除非有意设置了编译的相关参数，比如在GCC中添加<code class="calibre10">-Wunused-parameter</code>开关以打开对未使用参数的警告（CLang也使用<code class="calibre10">-Wunused-parameter</code>，MSVC则是将警告等级调整到W4或以上）：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int foo(int a, int b)
{
  return 5;
}

int main()
{
  foo(1, 2);
}</code></pre>

  <p class="zw">在上面的代码中，由于<code class="calibre10">foo</code>函数的形参<code class="calibre10">a</code>和<code class="calibre10">b</code>并未使用，因此在<code class="calibre10">-Wunused- parameter</code>开关的作用下GCC给出未使用警告。要消除这种情况下的警告，可以对形参<code class="calibre10">a</code>和<code class="calibre10">b</code>添加<code class="calibre10">maybe_unused</code>属性，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int foo(int a [[maybe_unused]], int b [[maybe_unused]])
{
  return 5;
}

int main()
{
  foo(1, 2);
}</code></pre>

  <p class="zw">请注意，<code class="calibre10">maybe_unused</code>属性除作为函数形参属性外，还可以用在很多地方，比如类、结构体、联合类型、枚举类型、函数、变量等，读者可以根据具体情况对代码添加属性。</p>

  <h3 id="OEBPS/Text/chapter031.html.nav_point_241" class="sigil_not_in_toc1">31.5.7　likely和unlikely</h3>

  <p class="zw"><code class="calibre10">likely</code>和<code class="calibre10">unlikely</code>是C++20标准引入的属性，两个属性都是声明在标签或者语句上的。其中<code class="calibre10">likely</code>属性允许编译器对该属性所在的执行路径相对于其他执行路径进行优化；而<code class="calibre10">unlikely</code>属性恰恰相反。通常，<code class="calibre10">likely</code>和<code class="calibre10">unlikely</code>被声明在<code class="calibre10">switch</code>语句：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int f(int i) {
    switch(i) {
    case 1: return 1;
    [[unlikely]] case 2: return 2;
    }
    return 3;
}</code></pre>

  <h3 id="OEBPS/Text/chapter031.html.nav_point_242" class="sigil_not_in_toc1">31.5.8　no_unique_address</h3>

  <p class="zw"><code class="calibre10">no_unique_address</code>是C++20标准引入的属性，该属性指示编译器该数据成员不需要唯一的地址，也就是说它不需要与其他非静态数据成员使用不同的地址。注意，该属性声明的对象必须是非静态数据成员且不为位域：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct Empty {};

struct X {
  int i;
  Empty e;
};

// main函数
std::cout &lt;&lt; "sizeof(X) = " &lt;&lt; sizeof(X) &lt;&lt; std::endl
  &lt;&lt; "X::i address = " &lt;&lt;  &amp;((X*)0)-&gt;i &lt;&lt; std::endl
  &lt;&lt; "X::e address = " &lt;&lt; &amp;((X*)0)-&gt;e;</code></pre>

  <p class="zw">以上代码的输出结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">sizeof(X) = 8
X::i address = 0
X::e address = 0x4</code></pre>

  <p class="zw">由此可见，即使结构体<code class="calibre10">Empty</code>为空，但是在<code class="calibre10">X</code>中依然也占据了唯一地址。现在让我们给<code class="calibre10">Empty e</code>添加<code class="calibre10">no_unique_address</code>属性：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct X {
  int i;
  [[no_unique_address ]]Empty e;
};</code></pre>

  <p class="zw">有了这个属性，编译器得知<code class="calibre10">e</code>不需要独立地址，于是将数据成员<code class="calibre10">i</code>和<code class="calibre10">e</code>编译在了同样的地址：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">sizeof(X) = 4
X::i address = 0
X::e address = 0</code></pre>

  <p class="zw">值得注意的是，如果存在两个相同的类型且它们都具有<code class="calibre10">no_unique_address</code>属性，那么编译器不会重复地将其堆在同一地址，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct X {
    int i;
    [[no_unique_address]] Empty e, e1;
};

std::cout &lt;&lt; "sizeof(X) = " &lt;&lt; sizeof(X) &lt;&lt; std::endl
  &lt;&lt; "X::i address = " &lt;&lt;  &amp;((X*)0)-&gt;i &lt;&lt; std::endl
  &lt;&lt; "X::e address = " &lt;&lt; &amp;((X*)0)-&gt;e &lt;&lt; std::endl
  &lt;&lt; "X::e1 address = " &lt;&lt; &amp;((X*)0)-&gt;e1 &lt;&lt; std::endl;</code></pre>

  <p class="zw">以上代码的输出结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">sizeof(X) = 8
X::i address = 0
X::e address = 0
X::e1 address = 0x4</code></pre>

  <p class="zw"><code class="calibre10">e</code>和<code class="calibre10">e1</code>虽然都是带有<code class="calibre10">no_unique_address</code>属性的<code class="calibre10">Empty</code>类型，但是无法使用同一地址。当然，如果<code class="calibre10">e</code>和<code class="calibre10">e1</code>不是同一类型，那么它们是可以共用同一地址的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct Empty {}; 
struct Empty1 {};

struct X {
  int i;
  [[no_unique_address]] Empty e;
  [[no_unique_address]] Empty1 e1;
};</code></pre>

  <p class="zw">输出结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">sizeof(X) = 4
X::i address = 0
X::e address = 0
X::e1 address = 0</code></pre>

  <p class="zw">最后解释一下<code class="calibre10">no_unique_address</code>这个属性的使用场景。读者一定写过无状态的类，这种类不需要有数据成员，唯一需要做的就是实现一些必要的函数，常见的是STL中一些算法函数所需的函数对象（仿函数）。而这种类作为数据成员加入其他类时，会占据独一无二的内存地址，实际上这是没有必要的。所以，在C++20的环境下，我们可以使用<code class="calibre10">no_unique_address</code>属性，让其不需要占用额外的内存地址空间。</p>

  <h2 id="OEBPS/Text/chapter031.html.nav_point_243" class="sigil_not_in_toc">31.6　总结</h2>

  <p class="zw">从1998年C++的第一个标准（我们常说的C++98标准）发布之后，C++标准的制定进入了一个冰川期，在长达十几年的时间里C++标准只是在2003年做过一个简单的修改（C++的第二个标准，C++03），这样的沉寂直到2011年才被C++11标准打破。C++标准缓慢的发展速度显然无法跟上计算机世界里日新月异的开发需求，于是各大编译器厂商在C++03标准的基础上开始添加自己的扩展功能以满足语言特性和平台的需求，而属性说明符和属性就是这些扩展中重要的一环，这导致为了兼容性对于跨平台项目不得不通过预处理宏编写繁多的适配代码。</p>

  <p class="zw">标准属性语法的出现在一定程度上给解决这类问题带来了希望，虽然它包含的属性远远达不到各大编译器厂商提供的属性功能，但是这给了这些厂商将属性加入标准扩展属性的机会，相信在不久的将来各大编译器厂商会将自己特有的属性添加到扩展属性当中。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter031.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter032.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter032.html.nav_point_244" class="not-in-toc">第32章　新增预处理器和宏（C++17 C++20）</h1>

  <h2 id="OEBPS/Text/chapter032.html.nav_point_245" class="sigil_not_in_toc">32.1　预处理器__has_include</h2>

  <p class="zw">C++17标准为预处理器增加了一个新特性<code class="calibre10">__has_include</code>，用于判断某个头文件是否能够被包含进来，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#if __has_include(&lt;optional&gt;)
#  include &lt;optional&gt;
#  define have_optional 1
#elif __has_include(&lt;experimental/optional&gt;)
#  include &lt;experimental/optional&gt;
#  define have_optional 1
#  define experimental_optional 1
#else
#  define have_optional 0
#endif</code></pre>

  <p class="zw">如果<code class="calibre10">__has_include(&lt;optional&gt;)</code>中的头文件<code class="calibre10">optional</code>可以被包含进来，那么表达式求值为1；否则求值为0。请注意，<code class="calibre10">__has_include</code>的实参必须和<code class="calibre10">#include</code>的实参具有同样的形式，否则会导致编译错误。另外，<code class="calibre10">__has_include</code>并不关心头文件是否已经被包含进来。</p>

  <h2 id="OEBPS/Text/chapter032.html.nav_point_246" class="sigil_not_in_toc">32.2　特性测试宏</h2>

  <p class="zw">C++20标准添加了一组用于测试功能特性的宏，这组宏可以帮助我们测试当前的编译环境对各种功能特性的支持程度。</p>

  <h3 id="OEBPS/Text/chapter032.html.nav_point_247" class="sigil_not_in_toc1">32.2.1　属性特性测试宏</h3>

  <p class="zw">属性测试宏（<code class="calibre10">__has_cpp_attribute</code>）可以指示编译环境是否支持某种属性，该属性可以是标准属性，也可以是编译环境厂商特有的属性。标准属性将被展开为该属性添加到标准时的年份和月份，而厂商特有的属性将被展开为一个非零的值：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::cout &lt;&lt; __has_cpp_attribute(deprecated); // 输出结果如下：201309</code></pre>

  <p class="zw">上面这句代码会输出201309，代表该属性在2013年9月加入标准，并且被当前编译环境支持。当前的标准属性如表32-1所示。</p>

  <p class="zw">▼表32-1</p>

  <table border="1" width="90%" class="calibre11">
    <thead class="calibre12">
      <tr class="calibre13">
        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">属性</p>
        </th>

        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">值</p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre15">
      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">carries_dependency</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">200809L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">deprecated</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201309L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">fallthrough</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201603L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">likely</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201803L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">maybe_unused</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201603L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">no_unique_address</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201803L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">nodiscard</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201603L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">noreturn</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">200809L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">unlikely</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201803L</p>
        </td>
      </tr>
    </tbody>
  </table>

  <h3 id="OEBPS/Text/chapter032.html.nav_point_248" class="sigil_not_in_toc1">32.2.2　语言功能特性测试宏</h3>

  <p class="zw">以下列表的宏代表编译环境所支持的语言功能特性，每个宏将被展开为该特性添加到标准时的年份和月份。请注意，这些宏展开的值会随着特性的变更而更新，如表32-2所示。</p>

  <p class="zw">▼表32-2</p>

  <table border="1" width="90%" class="calibre11">
    <thead class="calibre12">
      <tr class="calibre13">
        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">宏</p>
        </th>

        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">值</p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre15">
      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_aggregate_bases</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201603L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_aggregate_nsdmi</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201304L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_aggregate_paren_init</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201902L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_alias_templates</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">200704L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_aligned_new</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201606L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_attributes</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">200809L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_binary_literals</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201304L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_capture_star_this</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201603L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_char8_t</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201811L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_concepts</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_conditional_explicit</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201806L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_consteval</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201811L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_constexpr</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_constexpr_dynamic_alloc</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_constexpr_in_decltype</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201711L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_constinit</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_coroutines</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201902L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_decltype</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">200707L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_decltype_auto</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201304L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_deduction_guides</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_delegating_constructors</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">200604L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_designated_initializers</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201707L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_enumerator_attributes</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201411L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_fold_expressions</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201603L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_generic_lambdas</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201707L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_guaranteed_copy_elision</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201606L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_hex_float</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201603L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_if_constexpr</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201606L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_impl_coroutine</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201902L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_impl_destroying_delete</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201806L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_impl_three_way_comparison</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_inheriting_constructors</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201511L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_init_captures</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201803L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_initializer_lists</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">200806L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_inline_variables</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201606L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lambdas</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">200907L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_modules</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_namespace_attributes</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201411L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_noexcept_function_type</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201510L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_nontype_template_args</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201911L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_nontype_template_parameter_auto</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201606L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_nsdmi</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">200809L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_range_based_for</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201603L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_raw_strings</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">200710L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_ref_qualifiers</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">200710L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_return_type_deduction</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201304L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_rvalue_references</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">200610L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_sized_deallocation</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201309L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_static_assert</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">200410L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_structured_bindings</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201606L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_template_template_args</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201611L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_threadsafe_static_init</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">200806L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_unicode_characters</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">200704L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_unicode_literals</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">200710L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_user_defined_literals</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">200809L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_using_enum</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_variable_templates</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201304L</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_variadic_templates</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">200704L</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_variadic_using</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201611L</p>
        </td>
      </tr>
    </tbody>
  </table>

  <h3 id="OEBPS/Text/chapter032.html.nav_point_249" class="sigil_not_in_toc1">32.2.3　标准库功能特性测试宏</h3>

  <p class="zw">以下列表的宏代表编译环境所支持的标准库功能特性，它们通常包含在<code class="calibre10">&lt;version&gt;</code>头文件或者表中的任意对应头文件中。同样，每个宏将被展开为该特性添加到标准时的年份和月份。请注意，这些宏展开的值会随着特性的变更而更新，如表32-3所示。</p>

  <p class="zw">▼表32-3</p>

  <table border="1" width="90%" class="calibre11">
    <thead class="calibre12">
      <tr class="calibre13">
        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">宏</p>
        </th>

        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">值</p>
        </th>

        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">头文件</p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre15">
      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_addressof_constexpr</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201603L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;memory&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_allocator_traits_is_always_equal</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201411L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;memory&gt; &lt;scoped_allocator&gt; &lt;string&gt; &lt;deque&gt; &lt;forward_list&gt; &lt;list&gt; &lt;vector&gt; &lt;map&gt;&lt;set&gt; &lt;unordered_map&gt; &lt;unordered_set&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_any</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201606L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;any&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_apply</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201603L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;tuple&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_array_constexpr</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201811L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;iterator&gt; &lt;array&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_as_const</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201510L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;utility&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_assume_aligned</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201811L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;memory&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_atomic_flag_test</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;atomic&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_atomic_float</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201711L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;atomic&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_atomic_is_always_lock_free</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201603L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;atomic&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_atomic_lock_free_type_aliases</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;atomic&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_atomic_ref</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201806L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;atomic&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_atomic_shared_ptr</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201711L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;memory&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_atomic_value_initialization</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201911L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;atomic&gt; &lt;memory&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_atomic_wait</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;atomic&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_barrier</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;barrier&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_bind_front</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;functional&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_bit_cast</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201806L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;bit&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_bitops</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;bit&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_bool_constant</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201505L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;type_traits&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_bounded_array_traits</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201902L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;type_traits&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_boyer_moore_searcher</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201603L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;functional&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_byte</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201603L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;cstddef&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_char8_t</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;atomic&gt; &lt;filesystem&gt; &lt;istream&gt; &lt;limits&gt;&lt;locale&gt; &lt;ostream&gt; &lt;string&gt; &lt;string_view&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_chrono</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;chrono&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_chrono_udls</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201304L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;chrono&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_clamp</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201603L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;algorithm&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_complex_udls</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201309L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;complex&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_concepts</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">202002L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;concepts&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_constexpr_algorithms</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201806L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;algorithm&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_constexpr_complex</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201711L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;complex&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_constexpr_dynamic_alloc</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;memory&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_constexpr_functional</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;functional&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_constexpr_iterator</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201811L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;iterator&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_constexpr_memory</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201811L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;memory&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_constexpr_numeric</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201911L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;numeric&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_constexpr_string</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;string&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_constexpr_string_view</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201811L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;string_view&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_constexpr_tuple</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201811L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;tuple&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_constexpr_utility</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201811L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;utility&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_constexpr_vector</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;vector&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_coroutine</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201902L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;coroutine&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_destroying_delete</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201806L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;new&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_enable_shared_from_this</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201603L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;memory&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_endian</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;bit&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_erase_if</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">202002L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;string&gt; &lt;deque&gt; &lt;forward_list&gt; &lt;list&gt; &lt;vector&gt; &lt;map&gt; &lt;set&gt; &lt;unordered_map&gt; &lt;unordered_set&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_exchange_function</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201304L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;utility&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_execution</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201902L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;execution&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_filesystem</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201703L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;filesystem&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_format</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;format&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_gcd_lcm</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201606L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;numeric&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_generic_associative_lookup</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201304L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;map&gt; &lt;set&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_generic_unordered_lookup</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201811L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;unordered_map&gt; &lt;unordered_set&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_hardware_interference_size</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201703L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;new&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_has_unique_object_representations</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201606L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;type_traits&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_hypot</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201603L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;cmath&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_incomplete_container_elements</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201505L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;forward_list&gt; &lt;list&gt; &lt;vector&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_int_pow2</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">202002L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;bit&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_integer_comparison_functions</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">202002L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;utility&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_integer_sequence</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201304L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;utility&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_integral_constant_callable</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201304L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;type_traits&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_interpolate</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201902L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;cmath&gt; &lt;numeric&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_invoke</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201411L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;functional&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_is_aggregate</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201703L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;type_traits&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_is_constant_evaluated</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201811L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;type_traits&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_is_final</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201402L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;type_traits&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_is_invocable</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201703L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;type_traits&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_is_layout_compatible</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;type_traits&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_is_nothrow_convertible</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201806L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;type_traits&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_is_null_pointer</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201309L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;type_traits&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_is_pointer_interconvertible</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;type_traits&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_is_swappable</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201603L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;type_traits&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_jthread</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201911L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;stop_token&gt; &lt;thread&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_latch</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;latch&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_launder</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201606L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;new&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_list_remove_return_type</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201806L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;forward_list&gt; &lt;list&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_logical_traits</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201510L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;type_traits&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_make_from_tuple</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201606L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;tuple&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_make_reverse_iterator</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201402L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;iterator&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_make_unique</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201304L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;memory&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_map_try_emplace</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201411L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;map&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_math_constants</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;numbers&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_math_special_functions</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201603L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;cmath&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_memory_resource</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201603L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;memory_resource&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_node_extract</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201606L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;map&gt; &lt;set&gt; &lt;unordered_map&gt; &lt;unordered_set&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_nonmember_container_access</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201411L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;iterator&gt; &lt;array&gt; &lt;deque&gt; &lt;forward_list&gt; &lt;list&gt; &lt;map&gt; &lt;regex&gt; &lt;set&gt; &lt;string&gt; &lt;unordered_map&gt; &lt;unordered_set&gt; &lt;vector&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_not_fn</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201603L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;functional&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_null_iterators</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201304L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;iterator&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_optional</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201606L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;optional&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_parallel_algorithm</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201603L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;algorithm&gt; &lt;numeric&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_polymorphic_allocator</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201902L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;memory&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_quoted_string_io</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201304L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;iomanip&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_ranges</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201911L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;algorithm&gt; &lt;functional&gt; &lt;iterator&gt; &lt;memory&gt; &lt;ranges&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_raw_memory_algorithms</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201606L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;memory&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_remove_cvref</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201711L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;type_traits&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_result_of_sfinae</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201210L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;type_traits&gt; &lt;functional&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_robust_nonmodifying_seq_ops</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201304L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;algorithm&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_sample</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201603L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;algorithm&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_scoped_lock</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201703L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;mutex&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_semaphore</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;semaphore&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_shared_mutex</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201505L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;shared_mutex&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_shared_ptr_arrays</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201707L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;memory&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_shared_ptr_weak_type</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201606L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;memory&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_shared_timed_mutex</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201402L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;shared_mutex&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_shift</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201806L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;algorithm&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_smart_ptr_for_overwrite</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201811L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;memory&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_source_location</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;source_location&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_span</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">202002L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;span&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_ssize</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201902L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;iterator&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_starts_ends_with</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201711L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;string&gt; &lt;string_view&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_string_udls</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201304L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;string&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_string_view</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201803L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;string&gt; &lt;string_view&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_syncbuf</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201803L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;syncstream&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_three_way_comparison</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;compare&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_to_address</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201711L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;memory&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_to_array</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201907L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;array&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_to_chars</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201611L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;charconv&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_transformation_trait_aliases</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201304L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;type_traits&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_transparent_operators</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201510L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;memory&gt; &lt;functional&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_tuple_element_t</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201402L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;tuple&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_tuples_by_type</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201304L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;tuple&gt; &lt;utility&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_type_identity</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201806L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;type_traits&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_type_trait_variable_templates</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201510L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;type_traits&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_uncaught_exceptions</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201411L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;exception&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_unordered_map_try_emplace</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201411L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;unordered_map&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_unwrap_ref</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201811L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;functional&gt;</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_variant</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201606L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;variant&gt;</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__cpp_lib_void_t</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">201411L</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">&lt;type_traits&gt;</p>
        </td>
      </tr>
    </tbody>
  </table>

  <h2 id="OEBPS/Text/chapter032.html.nav_point_250" class="sigil_not_in_toc">32.3　新增宏<strong class="calibre24">VA_OPT</strong></h2>

  <p class="zw">从C99标准开始，C语言引入了可变参数宏<code class="calibre10">__VA_ARGS__</code>，而顺理成章的C++11标准也将其纳入标准当中。<code class="calibre10">__VA_ARGS__</code>常见的用法集中于打印日志上，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#define LOG(msg, …) printf("[" __FILE__ ":%d] " msg, __LINE__, __VA_ARGS__)
LOG("Hello %d", 2020);</code></pre>

  <p class="zw"><code class="calibre10">LOG</code>的使用和<code class="calibre10">printf</code>非常相似，并且可以很方便地将代码文件和行数记录到日志当中。不过它们也并非完全相同，因为对于函数<code class="calibre10">printf</code>来说，除了第一个参数以外的其他参数都是可选的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">printf("Hello 2020");    // 编译成功</code></pre>

  <p class="zw">而对于<code class="calibre10">LOG</code>宏来说，这种写法是非法的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">LOG("Hello 2020");</code></pre>

  <p class="zw">上面这句代码展开后应该是：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">printf("[" __FILE__ ":%d] " "Hello 2020", __LINE__, );</code></pre>

  <p class="zw">很明显，函数的最后多出了一个逗号，在GCC和CLang上编译都会报错。虽然在Visual Studio 2019上不会报错，但这并不具备通用性。实际上GCC和CLang也有类似扩展，只不过没有隐式地提供，我们可以使用##连接逗号和<code class="calibre10">__VA_ARGS__</code>：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#define LOG(msg, …) printf("[" __FILE__ ":%d] " msg, __LINE__, ##__VA_ARGS__)
LOG("Hello 2020"); // GCC和CLang编译成功</code></pre>

  <p class="zw">为了用更加标准的方法解决以上问题，C++20标准引入了一个新的宏<code class="calibre10">__VA_OPT__</code>令可变参数宏更易于在可变参数为空的情况下使用。还是以刚刚的<code class="calibre10">LOG</code>为例，我们将代码修改为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#define LOG(msg, …) printf("[" __FILE__ ":%d] " msg, __LINE__ __VA_OPT__ (,) __VA_ARGS__)</code></pre>

  <p class="zw">观察上面的代码可以发现，<code class="calibre10">__LINE__</code>后面的逗号被修改为<code class="calibre10">__VA_OPT__(,)</code>，这是告诉编译器这个逗号是可选的。当可变参数不为空的时候逗号才会被替换出来，否则就会忽略这个逗号。对于下面两句日志而言：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">LOG("Hello 2020");
LOG("Hello %d", 2020);</code></pre>

  <p class="zw">由于第一句代码中没有可变参数，所以被忽略，替换结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">printf("[" __FILE__ ":%d] " "Hello 2020", __LINE__);</code></pre>

  <p class="zw">第二句代码中存在可变参数，所以被替换出来，最后结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">printf("[" __FILE__ ":%d] " "Hello %d", __LINE__, 2020);</code></pre>

  <h2 id="OEBPS/Text/chapter032.html.nav_point_251" class="sigil_not_in_toc">32.4　总结</h2>

  <p class="zw">本章介绍了新标准增加的预处理器和宏，其中最主要的是特性测试宏。因为随着近十年来的C++标准更新速度的加快，在C++98标准沉浸十几年的C++程序员似乎并没有习惯标准这样的迭代速度，所以对编译环境支持哪些特性并没有深刻的认识。但是从C++20标准开始，我们可以通过这些宏来判断开发环境对新特性的支持程度，让程序员可以合理地利用更加优秀的C++特性。另外，对于代码库的作者也有不凡的意义，因为有了特性测试宏，他们可以根据客户端开发环境适配不同的功能代码，让自己的代码库能够高效地应用在更多的环境上。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter032.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter033.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter033.html.nav_point_252" class="not-in-toc">第33章　协程（C++20）</h1>

  <h2 id="OEBPS/Text/chapter033.html.nav_point_253" class="sigil_not_in_toc">33.1　协程的使用方法</h2>

  <p class="zw">协程并不是一个新鲜的概念，如果读者熟悉C#或者Python，可能或多或少对它有所了解。概括来讲，协程是一种可以被挂起和恢复的函数，它提供了一种创建异步代码的方法。</p>

  <p class="zw">事实上，C++中协程的概念早在2017年已经被提出，并且作为技术规范（Technical Specification）加入C++扩展中。不过协程迟迟没有加入C++标准中，因为很多专家质疑和反对这项新特性，他们认为协程过于复杂让人难以理解，并且有过多需要自定义的代码才能让其正常工作。所以这项提案直到2019年3月的C++标准委员会上才通过投票加入C++20标准中，并且最终采用了微软的实现方案。</p>

  <p class="zw">在我看来，协程的实现确实非常复杂，只想通过文字描述来理解协程有一定的困难，想要充分理解协程甚至可能需要深入汇编层面去观察其代码的生成详情。为了便于读者理解，我将本章分为两个部分，首先讨论协程的使用方法，由于C++20标准库提供了一系列的辅助代码，因此在协程的使用的理解上不会有太大难度。然后我们再去讨论协程的实现原理，这部分我会通过实现一套辅助代码的方法尽可能理清协程的实现原理。最后请注意，本章中的示例代码均采用MSVC进行编译。</p>

  <p class="zw">刚刚提到过，协程是一种可以被挂起和恢复的函数，那么究竟如何让函数挂起和恢复呢？请看下面的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;chrono&gt;
#include &lt;future&gt;

using namespace std::chrono_literals;

std::future&lt;int&gt; foo()
{
  std::cout &lt;&lt; "call foo\n";
    std::this_thread::sleep_for(3s);
    co_return 5;
}

std::future&lt;std::future&lt;int&gt;&gt; bar()
{
  std::cout &lt;&lt; "call bar\n";
  std::cout &lt;&lt; "before foo\n";
  auto n = co_await std::async(foo);       // 挂起点
  std::cout &lt;&lt; "after foo\n";
  co_return n;
}

int main()
{
  std::cout &lt;&lt; "before bar\n";
  auto i = bar();
  std::cout &lt;&lt; "after bar\n";
    i.wait();
  std::cout &lt;&lt; "result = " &lt;&lt; i.get().get();
}</code></pre>

  <p class="zw">编译运行以上代码，输出结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">before bar
call bar
before foo
after bar
call foo
after foo
result = 5</code></pre>

  <p class="zw">仔细观察输出结果就会发现，代码在输出<code class="calibre10">before foo</code>以后的运行流程不同寻常。普通情况下，即使异步调用<code class="calibre10">foo()</code>函数，<code class="calibre10">before foo</code>之后输出的应该也是<code class="calibre10">after foo</code>，但是真实结果输出的却是<code class="calibre10">after bar</code>。也就是说线程执行到<code class="calibre10">auto n = co_await std::async (foo);</code>之后跳出了<code class="calibre10">bar</code>函数，如同从函数中间<code class="calibre10">return</code>了一般，返回后执行了<code class="calibre10">std::cout &lt;&lt; "after bar\n";</code>，最后等待<code class="calibre10">std::future&lt;std::future&lt;int&gt;&gt;</code>的结果。实际上，我们看到的这个过程就是协程的挂起操作，而<code class="calibre10">auto n = co_await std::async(foo);</code>是协程的挂起点。观察这句代码我们会发现一个新的关键字<code class="calibre10">co_await</code>，读者暂时不需要理会它的具体功能，只需要将其当作是挂起点的标识即可。继续观察输出结果会看到<code class="calibre10">call foo</code>和紧随其后的<code class="calibre10">after foo</code>，说明函数<code class="calibre10">foo</code>执行结束之后，<code class="calibre10">bar</code>函数从当前的挂起点恢复了执行。进一步来说，<code class="calibre10">co_await</code>会触发一个挂起点，在触发挂起点后执行流程会返回到调用者继续执行，同时异步执行<code class="calibre10">co_await</code>所等待的对象，在等待对象执行完毕后，挂起点恢复执行流程继续执行后续代码。观察<code class="calibre10">foo</code>函数的代码，也会发现一个新的关键字<code class="calibre10">co_return</code>，我们暂时不需要关心它的详情，只需要知道它设置了返回值的结果，并且触发了挂起点的恢复，伪代码如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::cout &lt;&lt; "call foo\n";
std::this_thread::sleep_for(3s);
set_return_future_value(5);
set_future_ready();</code></pre>

  <p class="zw">需要说明的是，这里没有使用<code class="calibre10">&lt;&lt; std::endl</code>换行是因为异步执行会打乱输出，为了防止输出格式混乱，这里直接在字符串中使用<code class="calibre10">\n</code>换行。</p>

  <p class="zw">在理解<code class="calibre10">co_await</code>和<code class="calibre10">co_return</code>挂起和恢复协程之后，我们再来讨论另一种情况：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;experimental/generator&gt;

std::experimental::generator&lt;int&gt; foo()
{
  std::cout &lt;&lt; "begin" &lt;&lt; std::endl;
  for (int i = 0; i &lt; 10; i++) {
       co_yield i;
  }
  std::cout &lt;&lt; "end" &lt;&lt; std::endl;
}

int main()
{
  for (auto i : foo()) {
       std::cout &lt;&lt; i &lt;&lt; std::endl;
  }
}</code></pre>

  <p class="zw">编译运行以上代码，输出结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">begin
0
1
2
3
4
5
6
7
8
9
end</code></pre>

  <p class="zw">这次读者应该能猜到挂起点的位置了，就是<code class="calibre10">co_yield i;</code>。代码在执行到<code class="calibre10">for (auto i : foo())</code>的时候调用函数<code class="calibre10">foo()</code>，并且输出字符串<code class="calibre10">begin</code>。然后进入循环，当执行到<code class="calibre10">co_yield i;</code>时协程被挂起，并将<code class="calibre10">i</code>的值返回给调用者。对于第一次执行，<code class="calibre10">i</code>的值为0，紧跟在<code class="calibre10">begin</code>之后的输出为0。再次进入循环并调用<code class="calibre10">foo()</code>的时候，函数并不会从头开始执行，而是从上次执行的挂起点恢复执行，于是0之后不会再次输出<code class="calibre10">begin</code>，而是输出数字1。依此类推，执行到输出9后再次进入<code class="calibre10">foo</code>函数，从挂起点恢复后跳出循环并执行<code class="calibre10">std::cout &lt;&lt; "end" &lt;&lt; std::endl;</code>。</p>

  <p class="zw">上面的两个例子中出现了3个新关键字，分别是<code class="calibre10">co_await</code>、<code class="calibre10">co_return</code>和<code class="calibre10">co_yield</code>。C++20标准规定，具有以上3个关键字中任意一个的函数就是协程。请注意，因为<code class="calibre10">main</code>函数不能为协程，所以函数体中不能出现这3个关键字。通常情况下，建议将协程和标准库中的<code class="calibre10">future</code>、<code class="calibre10">generator</code>一起使用，因为协程辅助代码较为复杂，所以应该尽量避免自定义它们。</p>

  <p class="zw">请注意，协程虽然提供了一种异步代码的编写方法，但是并不会自动执行异步操作，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;chrono&gt;
#include &lt;future&gt;
using namespace std::chrono_literals;

std::packaged_task&lt;int()&gt; task(
  []() {
       std::cout &lt;&lt; "call task\n";
       std::this_thread::sleep_for(3s); 
       return 5; 
  }
);

std::future&lt;int&gt; bar()
{
  return task.get_future();
}

std::future&lt;void&gt; foo()
{
  std::cout &lt;&lt; "call foo\n";
  std::cout &lt;&lt; "before bar\n";
  auto i = co_await bar();
  std::cout &lt;&lt; "after bar\n";
  std::cout &lt;&lt; "result = " &lt;&lt; i;
}

int main()
{
  std::cout &lt;&lt; "before foo\n";
  auto w = foo();
  std::cout &lt;&lt; "after foo\n";
  w.wait();
}</code></pre>

  <p class="zw">在上面的代码中，虽然使用<code class="calibre10">auto i = co_await bar();</code>挂起了协程，但是并没有其他线程执行异步操作，造成的结果就是<code class="calibre10">w.wait();</code>一直等待。代码运行的结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">before foo
call foo
before bar
after foo</code></pre>

  <p class="zw">除了编写协程代码，我们还需要为协程创建异步执行环境，让我们修改上面代码的<code class="calibre10">bar</code>函数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::future&lt;int&gt; bar()
{
  std::future&lt;int&gt; r = task.get_future();
  std::thread t(std::move(task));
  t.detach();
  return r;
}</code></pre>

  <p class="zw">再次编译运行代码，可以获得正确的输出结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">before foo
call foo
before bar
after foo
call task
after bar
result = 5</code></pre>

  <h2 id="OEBPS/Text/chapter033.html.nav_point_254" class="sigil_not_in_toc">33.2　协程的实现原理</h2>

  <p class="zw">为了更容易地讨论协程的实现原理，我打算从协程的3个关键字入手，依次说明其背后的原理，最后就能呈现协程实现的整个面貌，让我们先从<code class="calibre10">co_await</code>开始吧。</p>

  <h3 id="OEBPS/Text/chapter033.html.nav_point_255" class="sigil_not_in_toc1">33.2.1　co_await运算符原理</h3>

  <p class="zw">从前面的代码示例，我们知道<code class="calibre10">co_await</code>运算符可以创建一个挂起点将协程挂起并等待协程恢复。那么<code class="calibre10">co_await</code>运算符所针对的操作数具体是什么呢？</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto n = co_await std::async(foo);</code></pre>

  <p class="zw">这句代码可以拆解分析：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::future&lt;std::future&lt;int&gt;&gt; expr = std::async(foo);
auto n = co_await expr;</code></pre>

  <p class="zw">这里我们将表达式<code class="calibre10">expr</code>命名为可等待体，顾名思义是指该对象是可以被等待的。请注意，并非所有对象都是可等待体，例如下面的代码就一定会报错：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">co_await std::string{ "hello" };</code></pre>

  <p class="zw">编译该代码编译器提示：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">error C3312: no callable 'await_resume' function found for type 'std::string'
error C3312: no callable 'await_ready' function found for type 'std::string'
error C3312: no callable 'await_suspend' function found for type 'std::string'</code></pre>

  <p class="zw">错误提示说<code class="calibre10">std::string</code>缺少3个函数，目标对象可被等待需要实现<code class="calibre10">await_resume</code>、<code class="calibre10">await_ready</code>和<code class="calibre10">await_suspen</code>这3个成员函数。具备这3个函数的对象可以称为等待器，也就是说等待器和可等待体可以是同一个对象。那么等待器是做什么的，为什么要给同一个对象两种命名呢？我们需要从以上的3个函数开始讨论。</p>

  <p class="zw">1．<code class="calibre10">await_ready</code>函数叫作<code class="calibre10">is_ready</code>或许更加容易理解，该函数用于判定可等待体是否已经准备好，也就是说可等待体是否已经完成了目标任务，如果已经完成，则返回<code class="calibre10">true</code>；否则返回<code class="calibre10">false</code>。</p>

  <p class="zw">2．<code class="calibre10">await_suspend</code>这个函数名则更加令人难以理解，命名为<code class="calibre10">schedule_ continuation</code>应该会更加清晰，它的作用就是调度协程的执行流程，比如异步等待可等待体的结果、恢复协程以及将执行的控制权返回调用者。</p>

  <p class="zw">3．<code class="calibre10">await_resume</code>实际上用于接收异步执行结果，可以叫作<code class="calibre10">retrieve_value</code>。</p>

  <p class="zw">了解了这3个函数的作用，现在就动手让<code class="calibre10">std::string</code>支持<code class="calibre10">co_await</code>：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class awaitable_string : public std::string {
public:
  using std::string::string;
  bool await_ready() const { return true; }
  void await_suspend(std::experimental::coroutine_handle&lt;&gt; h) const {}
  std::string await_resume() const { return *this; }
};

std::future&lt;std::string&gt; foo()
{
  auto str = co_await awaitable_string{ "hello" };
  co_return str;
}

int main()
{
  auto s = foo();
  std::cout &lt;&lt; s.get();
}</code></pre>

  <p class="zw">上面的代码可以编译成功并且输出字符串<code class="calibre10">hello</code>，因为我们实现的<code class="calibre10">awaitable_string</code>公有继承了<code class="calibre10">std::string</code>并且实现了<code class="calibre10">await_ready</code>、<code class="calibre10">await_suspend</code>和<code class="calibre10">await_resume</code>这3个函数。不过读者应该也猜到了，这个实现并没有异步功能。但这并不妨碍我们进一步理解它们，足够简单的代码反而更容易让人理解。</p>

  <p class="zw">1．<code class="calibre10">bool await_ready()</code>返回<code class="calibre10">true</code>表明目标对象已经准备好了，也就是说协程无须在此挂起，执行流会继续按照代码编写顺序同步执行后续代码，在这种情况下<code class="calibre10">await_suspend</code>会被忽略，直接执行<code class="calibre10">await_resume</code>函数获得结果。如果函数返回false，则标识目标对象没有准备好，需要执行后续操作。</p>

  <p class="zw">2．所谓的后续操作即调用<code class="calibre10">void await_suspend(std::experimental:: coroutine_handle &lt;&gt; h)</code>函数，这里有一个特殊的形参<code class="calibre10">coroutine_handle&lt;&gt;</code>，正如它的类型名所示，它是协程的句柄，可以用于控制协程的运行流程。读者不必了解其细节，只需要知道该句柄由编译器生成，其中包含协程挂起和恢复的上下文信息即可，<code class="calibre10">coroutine_ handle&lt;&gt;</code>有<code class="calibre10">operator()</code>和<code class="calibre10">resume()</code>函数，它们可以执行挂起点之后的代码。回到<code class="calibre10">await_suspend</code>函数本身，它可以借助<code class="calibre10">coroutine_handle&lt;&gt;</code>控制协程的执行流程。值得注意的是，<code class="calibre10">await_suspend</code>不一定返回<code class="calibre10">void</code>类型，还可以返回<code class="calibre10">bool</code>和<code class="calibre10">coroutine_handle</code>类型。</p>

  <p class="zw">1）返回<code class="calibre10">void</code>类型表示协程需要将执行流的控制权交给调用者，协程保持挂起状态。</p>

  <p class="zw">2）返回<code class="calibre10">bool</code>类型则又会出现两种情况，当返回值为<code class="calibre10">true</code>时，效果和返回类型与<code class="calibre10">void</code>相同；当返回<code class="calibre10">false</code>的时候，则恢复当前协程运行。</p>

  <p class="zw">3）返回<code class="calibre10">coroutine_handle</code>类型的时候，则会恢复该句柄对应的协程。</p>

  <p class="zw">值得注意的是，如果在<code class="calibre10">await_suspend</code>中捕获到了异常，那么协程也会恢复并且在协程中抛出该异常。</p>

  <p class="zw">3．<code class="calibre10">std::string await_resume()</code>实际上和恢复本身没有关系，可以看到它只是返回最终结果而已。</p>

  <p class="zw">了解了以上知识点之后，我们可以尝试让<code class="calibre10">await_ready</code>返回<code class="calibre10">false</code>，看一看会发生什么事情：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class awaitable_string : public std::string {
public:
  …
  bool await_ready() const { return false; }
  …
};</code></pre>

  <p class="zw">编译运行修改后的代码会发现程序被无限期挂起了，原因是虽然<code class="calibre10">awaitable_ string{ "hello" }</code>在构造的时候已经准备好了，但是由于<code class="calibre10">await_ready</code>返回<code class="calibre10">false</code>，因此编译器认为目标对象没有准备好，需要<code class="calibre10">await_suspend</code>来做协程的调度，但是这个函数什么也没做。这样就不会恢复协程的执行，<code class="calibre10">co_return str;</code>自然不会执行，程序在<code class="calibre10">std::cout &lt;&lt; s.get();</code>被无限期挂起了。要解决这个问题，我们需要实现一些<code class="calibre10">await_ suspend</code>的代码，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class awaitable_string : public std::string {
public:
  using std::string::string;
  bool await_ready() const { return false; }
  void await_suspend(std::experimental::coroutine_handle&lt;&gt; h) const {
       std::thread t{ [h] {
            // 模拟复杂操作，用时3s
            std::this_thread::sleep_for(3s);
            h(); }
       };
       t.detach();
  }
  std::string await_resume() const { return *this; }
};</code></pre>

  <p class="zw">修改代码后再次编译运行代码会发现，程序运行3s后输出<code class="calibre10">hello</code>字符串。这是因为<code class="calibre10">await_suspend</code>函数创建了新线程，并且在线程中等待3s后执行恢复流程，该恢复流程执行到<code class="calibre10">co_return str;</code>导致<code class="calibre10">s.get()</code>获得结果，最终输出<code class="calibre10">hello</code>字符串。</p>

  <h4 class="sigil_not_in_toc2">1．co_await运算符的重载</h4>

  <p class="zw">看到这里相信读者已经知道<code class="calibre10">co_await</code>运算符是干什么的了。但是我们还有一个问题没有解决，那就是为什么有可等待体和等待器两种名称，实际上我们在上文中看到的<code class="calibre10">awaitable_string</code>是一种特殊的情况，也就是可等待体和等待器是同一个对象，但是这不是必需的。我们可以重载<code class="calibre10">co_await</code>运算符，让它从可等待体转换为等待器，还是以<code class="calibre10">std::string</code>为例：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">awaitable_string operator co_await(std::string&amp;&amp; str)
{
  return awaitable_string{ str };
}

std::future&lt;std::string&gt; foo()
{
  auto str = co_await std::string{ "hello" };
  co_return str;
}</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">awaitable_string operator co_await(std:: string&amp;&amp; str)</code>是<code class="calibre10">co_await</code>的重载，它将<code class="calibre10">std::string</code>转换为<code class="calibre10">awaitable_ string</code>后返回，这样我们就可以在<code class="calibre10">foo</code>函数中直接使用<code class="calibre10">co_await std::string { "hello" };</code>，而不必担心编译报错了。</p>

  <p class="zw">除了使用非成员的方式重载<code class="calibre10">co_await</code>之外，还可以使用成员重载<code class="calibre10">co_await</code>。只不过对于<code class="calibre10">std::string</code>来说，修改STL的代码明显是不可行的，所以这里采用非成员方式。</p>

  <h4 class="sigil_not_in_toc2">2．可等待体和等待器的完整实现</h4>

  <p class="zw">最后让我们实现一个完整的可等待体和等待器来结束<code class="calibre10">co_await</code>的讨论：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;streambuf&gt;
#include &lt;future&gt;

class file_io_string {
public:
  file_io_string(const char* file_name) {
       t_ = std::thread{ [file_name, this]() mutable {
            std::ifstream f(file_name);
            std::string str((std::istreambuf_iterator&lt;char&gt;(f)),
            std::istreambuf_iterator&lt;char&gt;());
            result_ = str;
            ready_ = true;
       } };
  }
  bool await_ready() const { return ready_; }
  void await_suspend(std::experimental::coroutine_handle&lt;&gt; h) {
       std::thread r{ [h, t = std::move(t_)] () mutable {
            t.join();
            h(); }
       };
       r.detach();
  }
  std::string await_resume() const { return result_; }
private:
  bool ready_ = false;
  std::thread t_;
  std::string result_;
};

std::future&lt;std::string&gt; foo()
{
  auto str = co_await file_io_string{ "test.txt" };
  co_return str;
}

int main()
{
  auto s = foo();
  std::cout &lt;&lt; s.get();
}</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">file_io_string</code>既是一个可等待体也是一个等待器，它可以异步读取一个文件数据到<code class="calibre10">std::string</code>中。<code class="calibre10">file_io_string</code>在构造函数中创建新线程执行文件读取操作并且设置<code class="calibre10">ready_</code>为<code class="calibre10">true</code>。一般情况下，主线程的执行会比IO线程快，所以主线程调用<code class="calibre10">await_ready</code>的时候<code class="calibre10">ready_</code>更可能为<code class="calibre10">false</code>，这时代码会执行<code class="calibre10">await_suspend</code>函数，<code class="calibre10">await_suspend</code>函数创建新线程等待文件IO线程执行完毕，并且从挂起点恢复执行<code class="calibre10">foo</code>函数。</p>

  <h3 id="OEBPS/Text/chapter033.html.nav_point_256" class="sigil_not_in_toc1">33.2.2　co_yield运算符原理</h3>

  <p class="zw">为了弄清楚<code class="calibre10">co_yield</code>运算符的实现原理，我们还是得从一段代码开始：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct my_int_generator {};

my_int_generator foo()
{
  for (int i = 0; i &lt; 10; i++) {
       co_yield i;
  }
}</code></pre>

  <p class="zw">编译上面的代码会获得两条相同的错误提示：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">error C2039: 'promise_type': is not a member of 'std::experimental::coroutine_traits&lt;my_int_generator&gt;'</code></pre>

  <p class="zw">编译器表示<code class="calibre10">std::experimental::coroutine_traits&lt;my_int_generator&gt;</code>中没有<code class="calibre10">promise_type</code>成员类型。现在问题来了，我们的代码里并没有所谓的<code class="calibre10">promise_type</code>，更不知道<code class="calibre10">coroutine_traits</code>是什么了。解开这两个谜团，<code class="calibre10">co_yield</code>运算符的实现原理也就清晰了。</p>

  <h4 class="sigil_not_in_toc2">promise_type</h4>

  <p class="zw">现在让我们聚焦到<code class="calibre10">promise_type</code>类型上，这是一个非常关键的结构，实际上它不仅能影响<code class="calibre10">co_yield</code>的行为，<code class="calibre10">co_await</code>和<code class="calibre10">co_return</code>也会被其影响。简单来说，<code class="calibre10">promise_type</code>可以用于自定义协程自身行为，代码的编写者可以自定义协程的多种状态以及自定义协程中任何<code class="calibre10">co_await</code>、<code class="calibre10">co_return</code>或<code class="calibre10">co_yield</code>表达式的行为，比如挂起前和恢复后的处理、如何返回最终结果等。</p>

  <p class="zw">通常情况下<code class="calibre10">promise_type</code>会作为函数的嵌套类型存在，比如在<code class="calibre10">std::experimental:: generator</code>类模板中就存在嵌套类型<code class="calibre10">promise_type</code>。当然，我们不能期待所有已经存在的代码都有嵌套类型<code class="calibre10">promise_type</code>。所以C++标准提供了另外一种方式获取<code class="calibre10">promise_type</code>，那就是<code class="calibre10">std::experimental:: coroutine_traits&lt;T&gt;</code>。比如<code class="calibre10">std::future</code>就是这么做的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class _Ty, class… _ArgTypes&gt;
struct coroutine_traits&lt;future&lt;_Ty&gt;, _ArgTypes…&gt; {…}</code></pre>

  <p class="zw">说动手就动手，为了让上一节的代码正常编译，我们这就来实现一个<code class="calibre10">promise_type</code>：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct my_int_generator {
  struct promise_type {};
};

my_int_generator foo()
{
  for (int i = 0; i &lt; 10; i++) {
       co_yield i;
  }
}</code></pre>

  <p class="zw">编译上面的代码，编译器依然会报错。显然，<code class="calibre10">promise_type</code>不能是空结构体。让我们看一看错误提示：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">error C2039: 'yield_value': is not a member of 'my_int_generator::promise_ type'
message : see declaration of 'my_int_generator::promise_type'
error C3789: this function cannot be a coroutine: 'my_int_generator::promise_type' does not declare the member 'get_return_object()'</code></pre>

  <p class="zw">实际上，想要实现一个<code class="calibre10">generator</code>可用的<code class="calibre10">promise_type</code>，有几个成员函数是必须实现的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;experimental/resumable&gt;
using namespace std::experimental;
struct my_int_generator {
  struct promise_type {
       int* value_ = nullptr;

       my_int_generator get_return_object() {
            return my_int_generator{ *this };
       }
       auto initial_suspend() const noexcept {
            return suspend_always{};
       }
       auto final_suspend() const noexcept {
            return suspend_always{};
       }
       auto yield_value(int&amp; value) {
            value_ = &amp;value;
            return suspend_always{};
       }
       void return_void() {}
  };

  explicit my_int_generator(promise_type&amp; p) 
       : handle_(coroutine_handle&lt;promise_type&gt;::from_promise(p)) {}
  ~my_int_generator() {
       if (handle_) {
            handle_.destroy();
       }
  }
  coroutine_handle&lt;promise_type&gt; handle_;
};

my_int_generator foo()
{
  for (int i = 0; i &lt; 10; i++) {
       co_yield i;
  }
}

int main()
{
  auto obj = foo();
}</code></pre>

  <p class="zw">我知道上面这份代码不是那么容易理解，不过没关系，接下来我们来逐个讨论。</p>

  <p class="zw">1．<code class="calibre10">get_return_object</code>是一个非常关键的函数，理解这个函数名我们需要从调用者的角度来看问题。可以看到调用者是<code class="calibre10">main</code>函数，它使用<code class="calibre10">obj</code>接受<code class="calibre10">foo()</code>执行的返回值。那么问题来了，<code class="calibre10">foo()</code>函数并没有<code class="calibre10">return</code>任何值。这时协程需要<code class="calibre10">promise_type</code>帮助它返回一个对象，这个辅助函数就是<code class="calibre10">get_return_object</code>。现在就好理解了，<code class="calibre10">get_return_object</code>就是通过<code class="calibre10">my_int_generator</code>的构造函数创建了一个对象并且返回给调用者，其中构造函数的形参接受一个<code class="calibre10">promise_type</code>的引用类型，并将其转换为<code class="calibre10">coroutine_handle &lt;promise_ type&gt;</code>类型。前文已经讨论过，<code class="calibre10">coroutine_handle</code>的作用是控制协程执行流，这里也不例外，我们后面需要用它来恢复协程的执行。</p>

  <p class="zw">2．通常情况下我们不需要在意<code class="calibre10">initial_suspend</code>和<code class="calibre10">final_suspend</code>这两个函数，它们是C++标准给予代码库编写者在协程执行前后的挂起机会，程序员可以利用这些机会做一些额外的逻辑处理，大多数情况下是用不到的。值得注意的是，这两个函数的返回类型必须是一个等代器，为了代码编写的方便，标准为我们准备了两种等待器<code class="calibre10">suspend_always</code>和<code class="calibre10">suspend_never</code>，分别表示必然挂起和从不挂起：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct suspend_always {
  bool await_ready() noexcept {
       return false;
  }
  void await_suspend(coroutine_handle&lt;&gt;) noexcept {}
  void await_resume() noexcept {}
};
struct suspend_never {
  bool await_ready() noexcept {
       return true;
  }
  void await_suspend(coroutine_handle&lt;&gt;) noexcept {}
  void await_resume() noexcept {}
};</code></pre>

  <p class="zw">库的编写者可以根据实际情况选择返回类型。这里的<code class="calibre10">my_int_generator</code>选择返回<code class="calibre10">suspend_always</code>的具体原因后面会提到。</p>

  <p class="zw">3．<code class="calibre10">yield_value</code>的意思很简单，保存<code class="calibre10">co_yield</code>操作数的值并且返回等待器，<code class="calibre10">generator</code>通常返回<code class="calibre10">suspend_always</code>。事实上，<code class="calibre10">co_yield i;</code>可以等价于代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">co_await promise.yield_value(i);</code></pre>

  <p class="zw">4．<code class="calibre10">return_void</code>用于实现没有<code class="calibre10">co_return</code>的情况。<code class="calibre10">promise_type</code>中必须存在<code class="calibre10">return_void</code>或者<code class="calibre10">return_value</code>。</p>

  <p class="zw">现在代码已经可以顺利编译通过了，不过<code class="calibre10">my_int_generator</code>还没有任何<code class="calibre10">generator</code>的动作，这里我们需要操作协程句柄恢复执行协程代码并且返回生成值：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct my_int_generator {
  …
  int next() {
       if (!handle_) {
            return -1;
       }
       handle_();
       if (handle_.done()) {
            handle_.destroy();
            handle_ = nullptr;
            return -1;
       }
       return handle_.promise().value_;
  }
  …
};

int main()
{
  auto obj = foo();
  std::cout &lt;&lt; obj.next() &lt;&lt; std::endl;
  std::cout &lt;&lt; obj.next() &lt;&lt; std::endl;
  std::cout &lt;&lt; obj.next() &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">在上面的代码中，成员函数<code class="calibre10">next</code>先使用<code class="calibre10">if(!handle_)</code>检查协程句柄的有效性，然后执行恢复协程<code class="calibre10">handle_();</code>并通过<code class="calibre10">handle_.done()</code>检查协程是否执行完毕，如果执行完毕则销毁句柄，否则返回生成的值<code class="calibre10">handle_.promise().value_</code>。值得注意的是，这里需要先恢复协程，至于原因读者是否还记得<code class="calibre10">initial_suspend</code>和<code class="calibre10">final_suspend</code>返回的都是<code class="calibre10">suspend_always</code>，这个返回类型让协程在进入循环前就挂起了，所以需要让协程先恢复运行。运行以上代码，程序顺利输出：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">0
1
2</code></pre>

  <p class="zw">如果读者想让自己的<code class="calibre10">generator</code>支持基于范围的<code class="calibre10">for</code>循环：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">for (auto i : foo()) {
  std::cout &lt;&lt; i &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">可以回顾一下第17章，为<code class="calibre10">generator</code>实现一套迭代器即可。</p>

  <h3 id="OEBPS/Text/chapter033.html.nav_point_257" class="sigil_not_in_toc1">33.2.3　co_return运算符原理</h3>

  <p class="zw">理解了复杂的<code class="calibre10">co_await</code>和<code class="calibre10">co_yield</code>后，<code class="calibre10">co_return</code>运算符的原理就很容易理解了。和<code class="calibre10">co_yield</code>相同，<code class="calibre10">co_return</code>也需要<code class="calibre10">promise_type</code>的支持，请看下面的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct my_int_return {
  struct promise_type {
       int value_ = 0;
       my_int_return get_return_object() {
            return my_int_return{ *this };
       }

       auto initial_suspend() const noexcept {
            return suspend_never{};
       }
       auto final_suspend() const noexcept {
            return suspend_always{};
       }

       void return_value(int value) {
            value_ = value;
       }
  };

  explicit my_int_return(promise_type&amp; p)
       : handle_(coroutine_handle&lt;promise_type&gt;::from_promise(p)) {}

  ~my_int_return() {
       if (handle_) {
            handle_.destroy();
       }
  }

  int get() {
       if (!ready_) {
            value_ = handle_.promise().value_;
            ready_ = true;
            if (handle_.done()) {
                 handle_.destroy();
                 handle_ = nullptr;
            }
       }

       return value_;
  }

  coroutine_handle&lt;promise_type&gt; handle_;
  int value_ = 0;
  bool ready_ = false;
};

my_int_return foo()
{
  co_return 5;
}

int main()
{
  auto obj = foo();
  std::cout &lt;&lt; obj.get();
  std::cout &lt;&lt; obj.get();
  std::cout &lt;&lt; obj.get();
}</code></pre>

  <p class="zw">这段代码和上一节的代码示例非常相似，读者可以对比着去理解。唯一需要说明的是成员函数<code class="calibre10">void return_value(int value)</code>，函数<code class="calibre10">foo</code>中的<code class="calibre10">co_return 5</code>实际上就是调用的<code class="calibre10">return_value(5)</code>。如果<code class="calibre10">co_return</code>没有任何返回值，则需要用成员函数<code class="calibre10">void return_void()</code>代替<code class="calibre10">void return_value(int value)</code>。</p>

  <h3 id="OEBPS/Text/chapter033.html.nav_point_258" class="sigil_not_in_toc1">33.2.4　promise_type的其他功能</h3>

  <p class="zw"><code class="calibre10">promise_type</code>还有一个额外的功能，即可对<code class="calibre10">co_await</code>的操作数进行转换处理。为此我们需要给<code class="calibre10">promise_type</code>添加一个成员函数<code class="calibre10">await_transform</code>，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct promise_type {
    …
    awaitable await_transform(expr e) {
        return awaitable(e);
    }
};</code></pre>

  <p class="zw">这样做的结果是代码<code class="calibre10">co_await expr;</code>最终会转换为：<code class="calibre10">co_await promise.await_transform(expr);</code>。</p>

  <p class="zw">除此之外，<code class="calibre10">promise_type</code>还可以对异常进行处理，为此我们需要给<code class="calibre10">promise_type</code>添加一个成员函数<code class="calibre10">void set_exception</code>，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct promise_type {
    …
    void unhandled_exception() {
       eptr_ = std::current_exception();
  }
};</code></pre>

  <p class="zw">当协程运行过程中发生异常时，代码会捕获异常并且调用<code class="calibre10">unhandled_ exception</code>函数，这个过程代码类似于：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">co_await promise.initial_suspend();
try
{
  …
}
catch (…)
{
  promise.unhandled_exception();
}
FinalSuspend:
co_await promise.final_suspend();
}</code></pre>

  <p class="zw">捕获异常后我们可以选择在调用者上下文中重新抛出该异常。</p>

  <h2 id="OEBPS/Text/chapter033.html.nav_point_259" class="sigil_not_in_toc">33.3　总结</h2>

  <p class="zw">总的来说，协程的实现原理非常复杂，编译器为每个协程生成大量的代码，同时也需要程序员配合编写辅助代码才能正确使用。稍有疏忽就可能引发未定义的行为，尤其要注意协程上下文创建和销毁的时机、协程句柄的生命周期、运行的代码是否与线程强关联等。我的建议是，没有特别的需求，通常情况下应该使用成熟的协程库帮助我们完成协程函数的编写，比如STL、cppcoro等。最后还是提醒读者，在生产中使用协程编写代码请确保对协程机制和执行流有深入理解。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter033.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter034.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter034.html.nav_point_260" class="not-in-toc">第34章　基础特性的其他优化（C++11～C++20）</h1>

  <h2 id="OEBPS/Text/chapter034.html.nav_point_261" class="sigil_not_in_toc">34.1　显式自定义类型转换运算符（C++11）</h2>

  <p class="zw">C++是支持自定义类型转换运算符的，通过自定义转换运算符可以对原本没有关系的两个类型进行转换，可以说为类型转换提供了不少方便。不过一直以来C++专家对自定义类型转换都保持谨慎的态度，其原因是自定义类型转换可能让程序员更容易写出与实际期待不符的代码，而编译器无法给出有效的提示，请观察以下代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;vector&gt;

template&lt;class T&gt;
class SomeStorage {
public:
  SomeStorage() = default;
  SomeStorage(std::initializer_list&lt;T&gt; l) : data_(l) {};
  operator bool() const { return !data_.empty(); }
private:
  std::vector&lt;T&gt; data_;
};

int main()
{
  SomeStorage&lt;float&gt; s1{ 1., 2., 3. };
  SomeStorage&lt;int&gt; s2{ 1, 2, 3 };

  std::cout &lt;&lt; std::boolalpha;
  std::cout &lt;&lt; "s1 == s2 : " &lt;&lt; (s1 == s2) &lt;&lt; std::endl;
  std::cout &lt;&lt; "s1 + s2  : " &lt;&lt; (s1 + s2) &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">以上代码的编译运行结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">s1 == s2 : true
s1 + s2  : 2</code></pre>

  <p class="zw"><code class="calibre10">SomeStorage</code>是一个用于存储某类型数据的类模板。比如<code class="calibre10">SomeStorage &lt;int&gt;</code>用于存放整型数据，<code class="calibre10">SomeStorage&lt;float&gt;</code>用于存放浮点数据。正常逻辑下这两个类的实例<code class="calibre10">s1</code>和<code class="calibre10">s2</code>是不能相等的，但是编译运行代码后发现<code class="calibre10">s1 == s2</code>的输出为<code class="calibre10">true</code>。另外，这两个不相关的类居然还可以做加法运算，返回结果为2，乍看起来完全没有道理。事实上，这里忽略了自定义类型转换运算符<code class="calibre10">operator bool()</code>的影响。在<code class="calibre10">s1</code>和<code class="calibre10">s2</code>比较和相加的过程中，编译器会对它们做隐式的自定义类型转换以符合比较和相加的条件。由于这两个对象都不为空，因此它们的返回值都为<code class="calibre10">true</code>，<code class="calibre10">s1 == s2</code>的运算结果自然也为<code class="calibre10">true</code>，而求和运算会将<code class="calibre10">bool</code>转换为<code class="calibre10">int</code>，于是输出运算结果为2。可见，自定义类型转换运算符有时候就是这么不尽如人意。</p>

  <p class="zw">另外，类型转换问题不止存在于自定义类型转换运算符中，构造函数中也同样有问题，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string.h&gt;

class SomeString {
public:
  SomeString(const char * p) : str_(strdup(p)) {}
  SomeString(int alloc_size) : str_((char *)malloc(alloc_size)) {}
  ~SomeString() { free(str_); }
private:
  char *str_;
  friend void PrintStr(const SomeString&amp; str);
};

void PrintStr(const SomeString&amp; str)
{
  std::cout &lt;&lt; str.str_ &lt;&lt; std::endl;
}

int main()
{
  PrintStr("hello world");
  PrintStr(58);             // 代码写错，却编译成功
}</code></pre>

  <p class="zw"><code class="calibre10">SomeString</code>类重载了两个构造函数，其中<code class="calibre10">SomeString(const char * p)</code>接受一个字符串作为参数并且将字符串复制到对象中，<code class="calibre10">SomeString(int alloc_size)</code>接受一个整数用于分配字符串内存。函数<code class="calibre10">PrintStr</code>的意图是打印<code class="calibre10">SomeString</code>的字符串。<code class="calibre10">PrintStr("hello world")</code>编译成功是符合预期的，因为字符串会隐式构造<code class="calibre10">SomeString</code>对象。奇怪的是<code class="calibre10">PrintStr(58)</code>这个函数的调用，很明显这不是程序员写<code class="calibre10">PrintStr</code>函数的意图，真正的意图可能是<code class="calibre10">PrintStr("58")</code>，但由于粗心漏掉了引号。问题来了，编译器面对这样的代码不会给出任何错误或者警告提示。因为编译器会将58作为参数通过<code class="calibre10">SomeString(int alloc_size)</code>构造函数构造成<code class="calibre10">SomeString</code>对象。</p>

  <p class="zw">当然了，C++已经考虑到了构造函数面临的这种问题，我们可以使用<code class="calibre10">explicit</code>说明符将构造函数声明为显式，这样隐式的构造无法通过编译：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class SomeString {
public:
  SomeString(const char * p) : str_(_strdup(p)) {}
  explicit SomeString(int alloc_size) : str_((char *)malloc(alloc_size)) {}
  ~SomeString() { free(str_); }
private:
  char *str_;
  friend void PrintStr(const SomeString&amp; str);
};

int main()
{
  PrintStr("hello world");
  PrintStr(58);               // 编译失败
  PrintStr(SomeString(58));
}</code></pre>

  <p class="zw">以上代码用<code class="calibre10">explicit</code>说明符声明了<code class="calibre10">SomeString(int alloc_size)</code>，这样一来通过整数构造对象必须用显式的方式，所以<code class="calibre10">PrintStr(58)</code>会编译失败。</p>

  <p class="zw">借鉴显式构造函数的成功经验，C++11标准将<code class="calibre10">explicit</code>引入自定义类型转换中，称为显式自定义类型转换。语法上和显式构造函数如出一辙，只需在自定义类型转换运算符的函数前添加<code class="calibre10">explicit</code>说明符，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;vector&gt;

template&lt;class T&gt;
class SomeStorage {
public:
  SomeStorage() = default;
  SomeStorage(std::initializer_list&lt;T&gt; l) : data_(l) {};
  explicit operator bool() const { return !data_.empty(); }
private:
  std::vector&lt;T&gt; data_;
};

int main()
{
  SomeStorage&lt;float&gt; s1{ 1., 2., 3. };
  SomeStorage&lt;int&gt; s2{ 1, 2, 3 };

  std::cout &lt;&lt; std::boolalpha;
  std::cout &lt;&lt; "s1 == s2 : " &lt;&lt; (s1 == s2) &lt;&lt; std::endl;   // 编译失败
  std::cout &lt;&lt; "s1 + s2  : " &lt;&lt; (s1 + s2) &lt;&lt; std::endl;    // 编译失败
  std::cout &lt;&lt; "s1 : " &lt;&lt; static_cast&lt;bool&gt;(s1) &lt;&lt; std::endl;
  std::cout &lt;&lt; "s2 : " &lt;&lt; static_cast&lt;bool&gt;(s2) &lt;&lt; std::endl;
  if (s1) {
       std::cout &lt;&lt; "s1 is not empty" &lt;&lt; std::endl;
  }
}</code></pre>

  <p class="zw">以上代码给<code class="calibre10">operator bool()</code>添加了<code class="calibre10">explicit</code>说明符，将自定义类型转换运算符声明为显式的。于是，在编译<code class="calibre10">s1 == s2</code>和<code class="calibre10">s1 + s2</code>的时候我们收到了两条错误信息，因为现在已经无法隐式地调用自定义类型转换运算符函数了，而显式地转换<code class="calibre10">static_cast &lt;bool&gt;(s1)</code>和<code class="calibre10">static_cast&lt;bool&gt;(s2)</code>则可以编译成功。在这份代码中我们还发现了另外一个有趣的地方，<code class="calibre10">if</code>语句内的<code class="calibre10">s1</code>可以成功地调用显式自定义转换函数将其转换为<code class="calibre10">bool</code>类型而不会引发编译错误，这似乎和显式自定义类型转换运算符有些矛盾。实际上，这个“矛盾”恰好是C++11标准所允许的。</p>

  <p class="zw">为了做进一步解释，这里需要引入布尔转换，顾名思义就是将其他类型转换为<code class="calibre10">bool</code>。对于布尔转换，C++11标准为其准备了一些特殊规则以减少代码冗余：在某些期待上下文为<code class="calibre10">bool</code>类型的语境中，可以隐式执行布尔转换，即使这个转换被声明为显式。这些语境包括以下几种。</p>

  <p class="zw">　　<code class="calibre10">if</code>、<code class="calibre10">while</code>、<code class="calibre10">for</code>的控制表达式。</p>

  <p class="zw">　　内建逻辑运算符<code class="calibre10">!</code>、<code class="calibre10">&amp;&amp;</code>和<code class="calibre10">||</code>的操作数。</p>

  <p class="zw">　　条件运算符<code class="calibre10">?:</code>的首个操作数。</p>

  <p class="zw">　　<code class="calibre10">static_assert</code>声明中的<code class="calibre10">bool</code>常量表达式。</p>

  <p class="zw">　　<code class="calibre10">noexcept</code>说明符中的表达式。</p>

  <p class="zw">以上语境对类型进行布尔转换是非常自然的，并不会产生其他不良的影响，而且会让代码更加简练，容易理解。</p>

  <p class="zw">最后需要说明的是，新标准库也充分利用了显式自定义类型转换特性，比如<code class="calibre10">std::unique_ptr</code>定义了显式<code class="calibre10">bool</code>类型转换运算符来指示智能指针的内部指针是否为空，<code class="calibre10">std::ifstream</code>定义了显式<code class="calibre10">bool</code>类型转换运算符来指示是否成功打开了目标文件等。</p>

  <h2 id="OEBPS/Text/chapter034.html.nav_point_262" class="sigil_not_in_toc">34.2　关于std::launder()（C++17）</h2>

  <p class="zw"><code class="calibre10">std::launder()</code>是C++17标准库中新引入的函数，虽然本书并不打算介绍标准库中新增的内容，但是对于<code class="calibre10">std::launder()</code>还是有必要说明一下的，因为它想要解决的是C++语言的一个核心问题。让我们通过标准文档中的例子看一看这个问题到底是什么？</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct X { const int n; };
union U { X x; float f; };</code></pre>

  <p class="zw">请注意上面的代码片段中，结构体<code class="calibre10">X</code>的数据成员<code class="calibre10">n</code>是一个<code class="calibre10">const int</code>类型。接下来聚合初始化联合类型<code class="calibre10">U</code>：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">U u = {{ 1 }};</code></pre>

  <p class="zw">现在<code class="calibre10">const int</code>类型数据成员<code class="calibre10">n</code>被初始化为1，由于<code class="calibre10">n</code>的常量性，编译器可以总是认为<code class="calibre10">u.x.n</code>为1。接下来我们使用<code class="calibre10">replace new</code>的方法重写初始化这块内存区域：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">X *p = new (&amp;u.x) X {2};</code></pre>

  <p class="zw">新创建的<code class="calibre10">p-&gt;n</code>的值为2。现在问题来了，请读者想一想<code class="calibre10">u.x.n</code>的值应该是多少？如果只是从内存的角度来看，毫无疑问这里的结果是2，但是事情往往没那么简单，由于<code class="calibre10">u.x.n</code>是一个常量且初始化为1，因此编译器有理由认为<code class="calibre10">u.x.n</code>是无法被修改的，通过一些优化后<code class="calibre10">u.x.n</code>的结果有可能为1。实际上在标准看来，这个结果是未定义的。在经过<code class="calibre10">replace new</code>的操作后，我们不能直接使用<code class="calibre10">u.x.n</code>，只能通过<code class="calibre10">p</code>来访问<code class="calibre10">n</code>。</p>

  <p class="zw">具体来说，C++标准规定：如果新的对象在已被某个对象占用的内存上进行构建，那么原始对象的指针、引用以及对象名都会自动转向新的对象，除非对象是一个常量类型或对象中有常量数据成员或者引用类型。简单来说就是，如果数据结构<code class="calibre10">X</code>的数据成员<code class="calibre10">n</code>不是一个常量类型，那么<code class="calibre10">u.x.n</code>的结果一定是2。但是由于常量性的存在，从语法规则来说<code class="calibre10">x</code>已经不具备将原始对象的指针、引用以及对象名自动转向新对象的条件，因此结果是未定义的，要访问<code class="calibre10">n</code>就必须通过新对象的指针<code class="calibre10">p</code>。实际上，这并不是一个新的语法规则，不过好像大多数人对此不太了解。</p>

  <p class="zw">标准库引入<code class="calibre10">std::launder()</code>就是为了解决上述问题，标准文档的例子中：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">assert(*std::launder(&amp;u.x.n) == 2);</code></pre>

  <p class="zw">它是一个有定义的行为，而且获取<code class="calibre10">n</code>的值也保证为2。怎么理解<code class="calibre10">std::launder()</code>呢？在我看来不妨从字面意思理解，<code class="calibre10">launder</code>在英文中有清洗和刷洗的意思。而在这里不妨理解为洗内存，它的目的是防止编译器追踪到数据的来源以阻止编译器对数据的优化。最后要说一句，如果读者阅读<code class="calibre10">std::launder</code>的代码可能会感到惊讶，因为这个函数什么也没做，类似于：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;typename T&gt;
constexpr T*
launder(T* p) noexcept
{
  return p;
}</code></pre>

  <p class="zw">没错，到目前为止这个函数确实什么也没做。Botond Ballo曾在2016年芬兰奥卢的C++标准委员会会议报告中写到过关于<code class="calibre10">std::launder()</code>的体会。</p>

  <h2 id="OEBPS/Text/chapter034.html.nav_point_263" class="sigil_not_in_toc">34.3　返回值优化（C++11～C++17）</h2>

  <p class="zw">返回值优化是C++中的一种编译优化技术，它允许编译器将函数返回的对象直接构造到它们本来要存储的变量空间中而不产生临时对象。严格来说返回值优化分为RVO（Return Value Optimization）和NRVO（Named Return Value Optimization），不过在优化方法上的区别并不大，一般来说当返回语句的操作数为临时对象时，我们称之为RVO；而当返回语句的操作数为具名对象时，我们称之为NRVO。在C ++ 11标准中，这种优化技术被称为复制消除（copy elision）。如果使用GCC作为编译器，则这项优化技术是默认开启的，取消优化需要额外的编译参数“-fno-elide- constructors”。</p>

  <p class="zw">让我们从下面的例子开始对返回值优化技术进行探索：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
class X {
public:
  X() { std::cout &lt;&lt; "X ctor" &lt;&lt; std::endl; }
  X(const X&amp;x) { std::cout &lt;&lt; "X copy ctor" &lt;&lt; std::endl; }
  ~X() { std::cout &lt;&lt; "X dtor" &lt;&lt; std::endl; }
};

X make_x()
{
  X x1;
  return x1;
}

int main()
{
  X x2 = make_x();
}</code></pre>

  <p class="zw">可以看到函数<code class="calibre10">make_x()</code>返回了对象<code class="calibre10">x1</code>并赋值到<code class="calibre10">x2</code>上，理论上说这其中必定需要经过两次复制构造函数，第一次是<code class="calibre10">x1</code>复制到临时对象，第二次是临时对象复制到<code class="calibre10">x2</code>。现在让我们用GCC编译并且运行这份代码，会输出结果：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">X ctor
X dtor</code></pre>

  <p class="zw">令人吃惊的是，整个过程一次复制构造都没有调用，这就是NRVO的效果。如果这里将<code class="calibre10">make_x</code>函数改为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">X make_x()
{
  return X();
}</code></pre>

  <p class="zw">也会收到同样的效果，只不过优化技术名称从NRVO变成了RVO。</p>

  <p class="zw">接下来在编译命令行中添加开关“-fno-elide-constructors”，然后再次编译运行该代码，这时的输出结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">X ctor
X copy ctor
X dtor
X copy ctor
X dtor
X dtor</code></pre>

  <p class="zw">这才是我们刚刚预想的结果，一个默认构造函数和两个复制构造函数的调用。从结果可以看出返回值优化的效果特别理想，整整减少了两次复制构造和析构，这对于比较复杂或者占用内存很大的对象来说将是很重要的优化。</p>

  <p class="zw">但是请别高兴得太早，实际上返回值优化是很容易失效的，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;ctime&gt;

class X {
public:
  X() { std::cout &lt;&lt; "X ctor" &lt;&lt; std::endl; }
  X(const X&amp;x) { std::cout &lt;&lt; "X copy ctor" &lt;&lt; std::endl; }
  ~X() { std::cout &lt;&lt; "X dtor" &lt;&lt; std::endl; }
};

X make_x()
{
  X x1, x2;
  if (std::time(nullptr) % 50 == 0) {
       return x1;
  }
  else {
       return x2;
  }
}

int main()
{
  X x3 = make_x();
}</code></pre>

  <p class="zw">现在<code class="calibre10">make_x()</code>函数不确定会返回哪个对象了，如果继续在GCC中添加“-fno-elide-constructors”开关进行编译，则运行时依然会出现两次复制构造函数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">X ctor
X ctor
X copy ctor
X dtor
X dtor
X copy ctor
X dtor
X dtor</code></pre>

  <p class="zw">若删除“-fno-elide-constructors”开关是否会消除复制构造函数呢？答案是否定的，这时只能消除一次复制构造：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">X ctor
X ctor
X copy ctor
X dtor
X dtor
X dtor</code></pre>

  <p class="zw">原因其实很容易想到，由于以上代码中究竟由<code class="calibre10">x1</code>还是<code class="calibre10">x2</code>复制到<code class="calibre10">x3</code>是无法在编译期决定的，因此编译器无法在默认构造阶段就对<code class="calibre10">x3</code>进行构造，它需要分别将<code class="calibre10">x1</code>和<code class="calibre10">x2</code>构造后，根据运行时的结果将<code class="calibre10">x1</code>或者<code class="calibre10">x2</code>复制构造到<code class="calibre10">x3</code>，在这个过程中返回值优化技术也尽其所能地将中间的临时对象优化掉了，所以这里只会看到一次复制构造函数的调用。</p>

  <p class="zw">为了让读者更清晰地了解这部分的过程，我们让GCC生成中间代码GIMPLE，然后对比其中的区别。</p>

  <p class="zw">不带“-fno-elide-constructors”的中间代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">make_x ()
{
  struct X x1 [value-expr: *&lt;retval&gt;];

  X::X (&lt;retval&gt;);
  try
    {
      return &lt;retval&gt;;
    }
  catch
    {
      X::~X (&lt;retval&gt;);
    }
}
…
main ()
{
  int D.39995;

  {
    struct X x2;

    try
      {
        x2 = make_x (); [return slot optimization]
        try
          {

          }
        finally
          {
            X::~X (&amp;x2);
          }
      }
    finally
      {
        x2 = {CLOBBER};
      }
  }
  D.39995 = 0;
  return D.39995;
}</code></pre>

  <p class="zw">带“-fno-elide-constructors”的中间代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">make_x ()
{
  struct X x1;

  try
    {
      X::X (&amp;x1);
      try
        {
          X::X (&lt;retval&gt;, &amp;x1);
          return &lt;retval&gt;;
        }
      finally
        {
          X::~X (&amp;x1);
        }
    }
  finally
    {
      x1 = {CLOBBER};
    }
}
…
main ()
{
  struct X D.36509;
  int D.40184;

  {
    struct X x2;

    try
      {
        D.36509 = make_x (); [return slot optimization]
        try
          {
            try
              {
                X::X (&amp;x2, &amp;D.36509);
              }
            finally
              {
                try
                  {
                    X::~X (&amp;D.36509);
                  }
                catch
                  {
                    X::~X (&amp;x2);
                  }
              }
          }
        finally
          {
            D.36509 = {CLOBBER};
          }
        try
          {

          }
        finally
          {
            X::~X (&amp;x2);
          }
      }
    finally
      {
        x2 = {CLOBBER};
      }
  }
  D.40184 = 0;
  return D.40184;
}</code></pre>

  <p class="zw">读者看出其中的区别了吗？</p>

  <p class="zw">1．<code class="calibre10">make_x</code>函数中前者直接使用调用者的返回值构造<code class="calibre10">X::X (&lt;retval&gt;);</code>，而后者使用<code class="calibre10">x1</code>构造<code class="calibre10">X::X (&amp;x1);</code>，在构造结束之后再复制到返回值<code class="calibre10">X::X (&lt;retval&gt;, &amp;x1);</code>。</p>

  <p class="zw">2．在main函数中前者在<code class="calibre10">make_x</code>后没有任何复制动作，因为这时<code class="calibre10">x2</code>已经构建完成，而后者先调用<code class="calibre10">D.36509 = make_x ();</code>将返回值复制到临时对象，然后再通过<code class="calibre10">X::X (&amp;x2, &amp;D.36509);</code>复制到<code class="calibre10">x2</code>。</p>

  <p class="zw">另外值得注意的是，虽然返回值优化技术可以省略创建临时对象和复制构造的过程，但是C++11标准规定复制构造函数必须是存在且可访问的，否则程序是不符合语法规则的，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
class X {
public:
  X() { std::cout &lt;&lt; "X ctor" &lt;&lt; std::endl; }
  ~X() { std::cout &lt;&lt; "X dtor" &lt;&lt; std::endl; }
private:
  X(const X&amp;x) { std::cout &lt;&lt; "X copy ctor" &lt;&lt; std::endl; }
};

X make_x()
{
  return X();
}

int main()
{
  X x2 = make_x();
}</code></pre>

  <p class="zw">在上面的代码中，我们将类<code class="calibre10">X</code>的复制构造函数设置为私有。根据返回值优化的要求，复制构造函数必须是可访问的，所以上面的代码在C++11的编译环境下将会导致编译错误。</p>

  <p class="zw">C++14标准对返回值优化做了进一步的规定，规定中明确了对于常量表达式和常量初始化而言，编译器应该保证RVO，但是禁止NRVO。</p>

  <p class="zw">在C++17标准中提到了确保复制消除的新特性，它从另一个角度出发对C++进行了性能优化，而且也能达到RVO的效果。该特性指出，在传递临时对象或者从函数返回临时对象的情况下，编译器应该省略对象的复制和移动构造函数，即使这些复制和移动构造还有一些额外的作用，最终还是直接将对象构造到目标的存储变量上，从而避免临时对象的产生。标准还强调，这里的复制和移动构造函数甚至可以是不存在或者不可访问的。</p>

  <p class="zw">以上描述可以分为两个部分理解，首先对于临时对象强制省略对象的复制和移动构造函数，这一点实际上和RVO一样，只是对编译器提出了硬性要求。其次，也是最引人注意的一点，它允许复制和移动构造函数是不存在和不可访问的。在上面的例子中我们已经看到，返回值优化对于这一点是不允许的，现在我们不妨将上面代码的编译环境切换到C++17，读者一定会惊喜地发现代码编译成功了。另外，我们甚至可以更激进一些，显式删除复制构造函数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">X(const X&amp;x) = delete;</code></pre>

  <p class="zw">同样会发现，这份代码依然能正确地编译运行。这一点带来的最大好处是，所有类型都能使用工厂函数，即使该类型没有复制或者移动构造函数，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;atomic&gt;

template&lt;class T, class Arg&gt;
T create(Arg&amp;&amp; arg)
{
  return T(std::forward&lt;Arg&gt;(arg));
}

int main()
{
  std::atomic&lt;int&gt; x = create&lt;std::atomic&lt;int&gt;&gt;(11);
}</code></pre>

  <p class="zw">请注意上面的代码，由于std::atomic的复制构造函数被显式删除了，同时编译器也不会提供默认的移动构造函数，因此在C++17之前是无法编译成功的。而在C++17的标准下则不存在这个问题，代码能够顺利地编译运行。</p>

  <p class="zw">最后提醒读者一点，返回值优化虽然能够帮助我们减少返回对象的复制，但是作为程序员还是应该尽量减少对这些优化的依赖，因为不同的编译器对其的支持可能是不同的。面对传递对象的需求，我们可以尽量通过传递引用参数的方式完成，不要忘了C++11中支持的移动语义，它也能在一定程度上代替返回值优化的工作。</p>

  <h2 id="OEBPS/Text/chapter034.html.nav_point_264" class="sigil_not_in_toc">34.4　允许按值进行默认比较（C++20）</h2>

  <p class="zw">以下代码在C++20标准之前是无法编译成功的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct C {
  int i;
  friend bool operator==(C, C) = default;
};</code></pre>

  <p class="zw">因为在C++20之前的标准中，类的默认比较规则要求类<code class="calibre10">C</code>可以有一个参数为<code class="calibre10">const C&amp;</code>的非静态成员函数，或者有两个参数为<code class="calibre10">const C&amp;</code>的友元函数。而C++20标准对这一条规则做了适度的放宽，它规定类的默认比较运算符函数可以是一个参数为<code class="calibre10">const C&amp;</code>的非静态成员函数，或是两个参数为<code class="calibre10">const C&amp;</code>或<code class="calibre10">C</code>的友元函数。这里的区别在于允许按值进行默认比较，于是上面的代码可以顺利地通过编译。但是请注意，下面这两种情况依旧是标准不允许的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct A {
    friend bool operator==(A, const A&amp;) = default;
};

struct B {
    bool operator==(B) const = default;
};</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">A</code>因为混用<code class="calibre10">const A&amp;</code>和<code class="calibre10">A</code>而不符合标准要求，所以编译失败。另外，标准并没有放宽默认比较中对于非静态成员函数的要求，<code class="calibre10">B</code>依然无法通过编译。</p>

  <h2 id="OEBPS/Text/chapter034.html.nav_point_265" class="sigil_not_in_toc">34.5　支持new表达式推导数组长度（C++20）</h2>

  <p class="zw">一直以来，C++在声明数组的时候都支持通过初始化时的元素个数推导数组长度，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int x[]{ 1, 2, 3 };
char s[]{ "hello world" };</code></pre>

  <p class="zw">这种声明数组的方式非常方便，特别是对于字符串数组而言，将计算数组所需长度的任务交给编译器，省去了我们挨个数字符检查的烦恼。但遗憾的是，这个特性并不完整，因为在用<code class="calibre10">new</code>表达式声明数组的时候无法把推导数组长度的任务交给编译器，所以下面的代码就无法成功编译了：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int *x = new int[]{ 1, 2, 3 };
char *s = new char[]{ "hello world" };</code></pre>

  <p class="zw">好在C++20标准解决了以上问题。提案文档中强调在数组声明时根据初始化元素个数推导数组长度的特性应该是一致的，所以用以上方式声明数组理应是一个合法的语法规则。需要注意的是，到目前为止支持这一特性的编译器只有CLang，GCC和MSVC都是无法编译上面的代码的。</p>

  <h2 id="OEBPS/Text/chapter034.html.nav_point_266" class="sigil_not_in_toc">34.6　允许数组转换为未知范围的数组（C++20）</h2>

  <p class="zw">在C++20标准中允许数组转换为未知范围的数组，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void f(int(&amp;)[]) {}
int arr[1];

int main()
{
  f(arr);
  int(&amp;r)[] = arr;
}</code></pre>

  <p class="zw">以上代码在C++20标准下可以正常编译通过。对于重载函数的情况，编译器依旧会选择更为精准匹配的函数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void f(int(&amp;)[])
{
  std::cout &lt;&lt; "call f(int(&amp;)[])";
}
void f(int(&amp;)[1])
{
  std::cout &lt;&lt; "call f(int(&amp;)[1])";
}
int arr[1];

int main()
{
  f(arr);
}</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">void f(int(&amp;)[1])</code>明显更匹配<code class="calibre10">int arr[1];</code>，所以输出结果为<code class="calibre10">call f(int(&amp;)[1])</code>。需要注意的是，到目前为止只有GCC能够支持该特性。</p>

  <h2 id="OEBPS/Text/chapter034.html.nav_point_267" class="sigil_not_in_toc">34.7　在delete运算符函数中析构对象（C++20）</h2>

  <p class="zw">我们知道，通常情况下<code class="calibre10">delete</code>一个对象，编译器会先调用该对象的析构函数，之后才会调用<code class="calibre10">delete</code>运算符删除内存，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;new&gt;
struct X {
  X() {}
  ~X()
  {
       std::cout &lt;&lt; "call dtor" &lt;&lt; std::endl;
  }
  void* operator new(size_t s)
  {
       return ::operator new(s);
  }

  void operator delete(void* ptr)
  {
       std::cout &lt;&lt; "call delete" &lt;&lt; std::endl;
       ::operator delete(ptr);
  }
};

X* x = new X;
delete x;</code></pre>

  <p class="zw">以上代码的输出结果必然是：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">call dtor
call delete</code></pre>

  <p class="zw">在C++20标准以前，这个析构和释放内存的操作完全由编译器控制，我们无法将其分解开来。但是从C++20标准开始，这个过程可以由我们控制了，而且实现方法也非常简单：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct X {
  X() {}
  ~X()
  {
       std::cout &lt;&lt; "call dtor" &lt;&lt; std::endl;
  }
  void* operator new(size_t s)
  {
       return ::operator new(s);
  }

  void operator delete(X* ptr, std::destroying_delete_t)
  {
       std::cout &lt;&lt; "call delete" &lt;&lt; std::endl;
       ::operator delete(ptr);
  }
};</code></pre>

  <p class="zw">请注意在上面的代码中，<code class="calibre10">delete</code>运算符发生的两个变化：第一个参数类型由<code class="calibre10">void *</code>修改为<code class="calibre10">X *</code>；增加了一个类型为<code class="calibre10">std::destroying_delete_t</code>的形参，且我们并不会用到它。编译器会识别到<code class="calibre10">delete</code>运算符形参的变化，然后由我们去控制对象的析构。比如在上面的代码中，我们没有调用析构函数，于是输出的结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">call delete</code></pre>

  <p class="zw">在这种情况下，我们需要自己调用析构函数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">void operator delete(X* ptr, std::destroying_delete_t)
{
  ptr-&gt;~X();
  std::cout &lt;&lt; "call delete" &lt;&lt; std::endl;
  ::operator delete(ptr);
}</code></pre>

  <h2 id="OEBPS/Text/chapter034.html.nav_point_268" class="sigil_not_in_toc">34.8　调用伪析构函数结束对象声明周期（C++20）</h2>

  <p class="zw">C++20标准完善了调用伪析构函数结束对象声明周期的规则。在过去，调用伪析构函数会根据对象的不同执行不同的行为，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;typename T&gt; 
void destroy(T* p) { 
  p-&gt;~T(); 
}</code></pre>

  <p class="zw">在上面的代码中，当<code class="calibre10">T</code>是非平凡类型时，<code class="calibre10">p-&gt;~T();</code>会结束对象声明周期；相反当<code class="calibre10">T</code>为平凡类型时，比如<code class="calibre10">int</code>类型，<code class="calibre10">p-&gt;~T();</code>会被当成无效语句。C++20标准修补了这种行为不一致的规则，它规定伪析构函数的调用总是会结束对象的生命周期，即使对象是一个平凡类型。</p>

  <h2 id="OEBPS/Text/chapter034.html.nav_point_269" class="sigil_not_in_toc">34.9　修复const和默认复制构造函数不匹配造成无法编译的问题（C++20）</h2>

  <p class="zw">考虑这样一个类或者结构体，它编写复制构造函数的时候没有使用<code class="calibre10">const</code>：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct MyType {
  MyType() = default;
  MyType(MyType&amp;) {};
};</code></pre>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;typename T&gt;
struct Wrapper {
  Wrapper() = default;
  Wrapper(const Wrapper&amp;) = default;
  T t;
};
Wrapper&lt;MyType&gt; var;</code></pre>

  <p class="zw"><code class="calibre10">Wrapper</code>的复制构造函数的形参是<code class="calibre10">const</code>版本而其成员<code class="calibre10">MyType</code>不是，这种不匹配在C++17和以前的标准中是不被允许的。但仔细想想，这样的规定并不合理，因为代码并没有试图去调用复制构造函数。在C++20标准中修正了这一点，如果不发生复制动作，这样的写法是可以通过编译的。需要注意的是，就目前的编译器情况来看MSVC和GCC都对C++17标准做了优化，也就是说以上代码无论在C++17还是C++20标准上都可以编译通过，只有CLang严格遵照标准，在C++17的环境下会报错。当然：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">Wrapper&lt;MyType&gt; var1;
Wrapper&lt;MyType&gt; var2(var1);</code></pre>

  <p class="zw">这样的写法是无论如何都会编译失败的。</p>

  <h2 id="OEBPS/Text/chapter034.html.nav_point_270" class="sigil_not_in_toc">34.10　不推荐使用volatile的情况（C++20）</h2>

  <p class="zw"><code class="calibre10">volatile</code>是一个非常著名的关键字，用于表达易失性。它能够让编译器不要对代码做过多的优化，保证数据的加载和存储操作被多次执行，即使编译器知道这种操作是无用的，也无法对其进行优化。事实上，在现代的计算机环境中，<code class="calibre10">volatile</code>限定符的意义已经不大了。首先我们必须知道，该限定符并不能保证数据的同步，无法保证内存操作不被中断，它的存在不能代替原子操作。其次，虽然<code class="calibre10">volatile</code>操作的顺序不能相对于其他<code class="calibre10">volatile</code>操作改变，但是可以相对于非<code class="calibre10">volatile</code>操作改变。更进一步来说，即使从C++编译代码的层面上保证了操作执行的顺序，但是对于现代CPU而言这种操作执行顺序也是无法保证的。</p>

  <p class="zw">因为<code class="calibre10">volatile</code>限定符现实意义的减少以及部分程序员对此理解的偏差，C++20标准在部分情况中不推荐<code class="calibre10">volatile</code>的使用，这些情况包括以下几种。</p>

  <p class="zw">1．不推荐算术类型的后缀<code class="calibre10">++</code>和<code class="calibre10">--</code>表达式以及前缀<code class="calibre10">++</code>和<code class="calibre10">--</code>表达式使用<code class="calibre10">volatile</code>限定符：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">volatile int d = 5;
d++;
--d;</code></pre>

  <p class="zw">2．不推荐非类类型左操作数的赋值使用<code class="calibre10">volatile</code>限定符：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">// E1 op= E2
volatile int d = 5;
d += 2;
d *= 3;</code></pre>

  <p class="zw">3．不推荐函数形参和返回类型使用<code class="calibre10">volatile</code>限定符：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">volatile int f() { return 1; }
int g(volatile int v) { return v; }</code></pre>

  <p class="zw">4．不推荐结构化绑定使用<code class="calibre10">volatile</code>限定符：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct X {
  int a;
  short b;
};
X x{ 11, 7 };
volatile auto [a, b] = x;</code></pre>

  <p class="zw">以上4种情况在C++20标准的编译环境中编译都会给出<code class="calibre10">'volatile'- qualified type is deprecated</code>的警告信息。</p>

  <h2 id="OEBPS/Text/chapter034.html.nav_point_271" class="sigil_not_in_toc">34.11　不推荐在下标表达式中使用逗号运算符（C++20）</h2>

  <p class="zw">对于逗号运算符我们再熟悉不过了，它可以让多个表达式按照从左往右的顺序进行计算，整体的结果为系列中最后一个表达式的值，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int a[]{ 1,2,3 };
int x = 1, y = 2;
std::cout &lt;&lt; a[x, y];</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">std::cout &lt;&lt; a[x, y];</code>等同于<code class="calibre10">std::cout &lt;&lt; a[y];</code>，最后输出结果是3。不过从C++20标准开始，<code class="calibre10">std::cout &lt;&lt; a[x, y];</code>这句代码会被编译器提出警告，因为标准已经不推荐在下标表达式中使用逗号运算符了。该规则的提案文档明确地表示，希望<code class="calibre10">array[x,y]</code>这种表达方式能用在矩阵、视图、几何实体、图形API中。而对于老代码的维护者或者依旧想在下标表达式中使用逗号运算符的读者，可以在下标表达式外加上小括号来消除警告：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::cout &lt;&lt; a[(x, y)];</code></pre>

  <h2 id="OEBPS/Text/chapter034.html.nav_point_272" class="sigil_not_in_toc">34.12　模块（C++20）</h2>

  <p class="zw">模块（module）是C++20标准引入的一个新特性，它的主要用途是将大型工程中的代码拆分成独立的逻辑单元，以方便大型工程的代码管理。模块能够大大减少使用头文件带来的问题，例如在使用头文件时经常会遇到宏和函数的重定义，而模块则会好很多，因为宏和未导出名称对于导入模块是不可见的。使用模块也能大幅提升编译效率，因为编译后的模块信息会存储在一个二进制文件中，编译器对于它的处理速度要远快于单纯使用文本替换的头文件方法。可惜到目前为止并没有主流编译器完全支持该特性，所以这里只做简单介绍：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">// helloworld.ixx
export module helloworld;
import std.core;

export void hello() {
  std::cout &lt;&lt; "Hello world!\n";
}

// modules_test.cpp
import helloworld;
int main()
{
    hello();
}</code></pre>

  <p class="zw">上面的代码很容易理解，<code class="calibre10">helloworld.ixx</code>是接口文件，它将编译成一个名为<code class="calibre10">helloworld</code>的导出模块。在模块中使用<code class="calibre10">import</code>引入了<code class="calibre10">std.core</code>，<code class="calibre10">std.core</code>是一个STL模块，包含了STL中最主要的容器和算法。除此之外，模块还使用<code class="calibre10">export</code>导出了一个<code class="calibre10">hello</code>函数。编译器编译<code class="calibre10">helloworld.ixx</code>会生成一个<code class="calibre10">helloworld.ifc</code>，该文件包含了模块的元数据。<code class="calibre10">modules_test.cpp</code>可以通过<code class="calibre10">import helloworld;</code>导入<code class="calibre10">helloworld</code>模块，并且调用它的导出函数<code class="calibre10">hello</code>。</p>

  <p class="zw">在使用VS 2019进行编译时有两点需要注意。</p>

  <p class="zw">1．在安装VS 2019的C++环境时勾选模块（默认不勾选）。如果不做这一步，会导致<code class="calibre10">import std.core;</code>无法正确编译。</p>

  <p class="zw">2．编译选项开启<code class="calibre10">/experimental:module</code>。</p>

  <h2 id="OEBPS/Text/chapter034.html.nav_point_273" class="sigil_not_in_toc">34.13　总结</h2>

  <p class="zw">本章介绍了新标准中多个基础特性的优化，这些特性大部分是对现有C++功能的完善，虽然它们非常简单，但是有些却非常实用，比如支持显式自定义类型转换运算符、支持<code class="calibre10">new</code>表达式推导数组长度等。在这些特性当中影响最大的应该是返回值优化，虽然该特性对于程序员本身来说并无感知，但是编译器却做了相当多的工作，也正因为该特性的存在使代码在升级标准环境后可以有性能上的提升。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter034.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter035.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter035.html.nav_point_274" class="not-in-toc">第35章　可变参数模板（C++11 C++17 C++20）</h1>

  <h2 id="OEBPS/Text/chapter035.html.nav_point_275" class="sigil_not_in_toc">35.1　可变参数模板的概念和语法</h2>

  <p class="zw">可变参数模板是C++11标准引入的一种新特性，顾名思义就是类模板或者函数模板的形参个数是可变的。作为一个模板元编程的爱好者，刚看到这个特性的时候是非常激动的，因为这个特性能很大程度上加强模板的能力。举两个例子，熟悉C++标准库的读者肯定知道<code class="calibre10">std::bind1st</code>和<code class="calibre10">std::bind2nd</code>两个函数模板，两个函数能够绑定一个对象到函数或者函数对象，不过它们有一个很大的限制——只能绑定一个对象。为了解决这个问题，C++标准委员会在2005年的C++技术报告中(tr1)提出了新的函数模板<code class="calibre10">std::bind</code>，该函数可以将多个对象绑定到函数或者函数对象上，不过由于缺乏可变参数模板的支持，这里所谓的多个也是有限制的，比如在<code class="calibre10">boost</code>中最多是9个，后来GCC和Visual Studio C++的标准库沿用了这个设定。无独有偶，这份技术报告中还提出了<code class="calibre10">std::tuple</code>类型，该类型能够存储多种类型的对象，当然这里的多种类型的数量同样有限制，比如在<code class="calibre10">boost</code>中这个数量最多为10，后来GCC和Visual Studio C++的标准库也沿用了这个设定。可以看出这两个函数模板和类模板对于可变参数都有很强烈的需求，于是在C++11标准支持可变参数模板以后，<code class="calibre10">std::bind</code>和<code class="calibre10">std::tuple</code>就被改写为可以接受任意多个模板形参的版本了。</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class …Args&gt;
void foo(Args …args) {}

template&lt;class …Args&gt;
class bar {
public:
  bar(Args …args) {
       foo(args…);
  }
};</code></pre>

  <p class="zw">在上面的代码中<code class="calibre10">class …Args</code>是类型模板形参包，它可以接受零个或者多个类型的模板实参。<code class="calibre10">Args …args</code>叫作函数形参包，它出现在函数的形参列表中，可以接受零个或者多个函数实参。而<code class="calibre10">args…</code>是形参包展开，通常简称包展开。它将形参包展开为零个或者多个模式的列表，这个过程称为解包。这里所谓的模式是实参展开的方法，形参包的名称必须出现在这个方法中作为实参展开的依据，最简单的情况为解包后就是实参本身。</p>

  <p class="zw">以上这些语法概念看起来可能会有点复杂。不过没关系，结合下面的例子后读者会发现这些语法实际上非常自然：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class …Args&gt;
void foo(Args …args) {}

int main()
{
  unsigned int x = 8;
    foo();          // foo()
  foo(1);           // foo&lt;int&gt;(int)
  foo(1, 11.7);     // foo&lt;int,double&gt;(int,double)
  foo(1, 11.7, x);  // foo&lt;int,double,unsigned int&gt;(int,double,unsigned int)
}</code></pre>

  <p class="zw">以上是一个变参函数模板，它可以接受任意多个实参，编译器会根据实参的类型和个数推导出形参包的内容。另外，C++11标准中变参类模板虽然不能通过推导得出形参包的具体内容，但是我们可以直接指定它：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class …Args&gt;
class bar {};

int main()
{
  bar&lt;&gt; b1;
  bar&lt;int&gt; b2;
  bar&lt;int, double&gt; b3;
  bar&lt;int, double, unsigned int&gt; b4;
}</code></pre>

  <p class="zw">需要注意的是，无论是模板形参包还是函数形参包都可以与普通形参结合，但是对于结合的顺序有一些特殊要求。</p>

  <p class="zw">在类模板中，模板形参包必须是模板形参列表的最后一个形参：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class …Args, class T&gt;
class bar {};
bar&lt;int, double, unsigned int&gt; b1;     // 编译失败，形参包并非最后一个

template&lt;class T, class …Args&gt;
class baz {};
baz&lt;int, double, unsigned int&gt; b1;     // 编译成功</code></pre>

  <p class="zw">但是对于函数模板而言，模板形参包不必出现在最后，只要保证后续的形参类型能够通过实参推导或者具有默认参数即可，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class …Args, class T, class U = double&gt;
void foo(T, U, Args …args) {}

foo(1, 2, 11.7);    // 编译成功</code></pre>

  <p class="zw">虽然以上介绍的都是类型模板形参，但是实际上非类型模板形参也可以作为形参包，而且相对于类型形参包，非类型形参包则更加直观：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;int …Args&gt;
void foo1() {};

template&lt;int …Args&gt;
class bar1 {};

int main()
{
  foo1&lt;1, 2, 5, 7, 11&gt;();
  bar1&lt;1, 5, 8&gt; b;
}</code></pre>

  <h2 id="OEBPS/Text/chapter035.html.nav_point_276" class="sigil_not_in_toc">35.2　形参包展开</h2>

  <p class="zw">虽然上一节已经简单介绍了可变参数模板的基本语法，但是读者应该已经注意到，节中的例子并没有实际用途，无论是函数模板<code class="calibre10">foo</code>还是类模板<code class="calibre10">bar</code>，它们的主体都是空的。实际上，它们都缺少了一个最关键的环节，那就是形参包展开，简称包展开。只有结合了包展开，才能发挥变参模板的能力。需要注意的是，包展开并不是在所有情况下都能够进行的，允许包展开的场景包括以下几种。</p>

  <p class="zw">1．表达式列表。</p>

  <p class="zw">2．初始化列表。</p>

  <p class="zw">3．基类描述。</p>

  <p class="zw">4．成员初始化列表。</p>

  <p class="zw">5．函数参数列表。</p>

  <p class="zw">6．模板参数列表。</p>

  <p class="zw">7．动态异常列表（C++17已经不再使用）。</p>

  <p class="zw">8．<code class="calibre10">lambda</code>表达式捕获列表。</p>

  <p class="zw">9．<code class="calibre10">Sizeof…</code>运算符。</p>

  <p class="zw">10．对其运算符。</p>

  <p class="zw">11．属性列表。</p>

  <p class="zw">虽然这里列出的场景比较多，但是因为大多数是比较常见的场景，所以理解起来应该不会有什么难度。让我们通过几个例子来说明包展开的具体用法：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

template&lt;class T, class U&gt;
T baz(T t, U u)
{
  std::cout &lt;&lt; t &lt;&lt; ":" &lt;&lt; u &lt;&lt; std::endl;
  return t;
}

template&lt;class …Args&gt;
void foo(Args …args) {}

template&lt;class …Args&gt;
class bar {
public:
  bar(Args …args)
  {
       foo(baz(&amp;args, args) …);
  }
};

int main()
{
  bar&lt;int, double, unsigned int&gt; b(1, 5.0, 8);
}</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">baz</code>是一个普通的函数模板，它将实参通过<code class="calibre10">std::cout</code>输出到控制台上。<code class="calibre10">foo</code>是一个可变参数的函数模板，不过这个函数什么也不做。在<code class="calibre10">main</code>函数中，模板<code class="calibre10">bar</code>实例化了一个<code class="calibre10">bar&lt;int, double, unsigned int&gt;</code>类型并且构造了对象<code class="calibre10">b</code>，在它的构造函数里对形参包进行了展开，其中<code class="calibre10">baz(&amp;args, args)…</code>是包展开，而<code class="calibre10">baz(&amp;args, args)</code>就是模式，也可以理解为包展开的方法。所以这段代码相当于：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class bar {
public:
  bar(int a1, double a2, unsigned int a3)
  {
       foo(baz(&amp;a1, a1), baz(&amp;a2, a2), baz(&amp;a3, a3));
  }
};</code></pre>

  <p class="zw">为了让读者更加清晰地了解编译器对这段代码的处理，下面展示了GCC生成的GIMPLE中间代码的关键部分：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">main ()
{
  …
  struct bar b;
  …
  bar&lt;int, double, unsigned int&gt;::bar (&amp;b, 1, 5.0e+0, 8);
  …
}

bar&lt;int, double, unsigned int&gt;::bar (struct bar * const this, int args#0,  double args#1, unsigned int args#2)
{
  args_2.0_1 = args#2;
  _2 = baz&lt;unsigned int*, unsigned int&gt; (&amp;args#2, args_2.0_1);
  args_1.1_3 = args#1;
  _4 = baz&lt;double*, double&gt; (&amp;args#1, args_1.1_3);
  args_0.2_5 = args#0;
  _6 = baz&lt;int*, int&gt; (&amp;args#0, args_0.2_5);
  foo&lt;int*, double*, unsigned int*&gt; (_6, _4, _2);
}

baz&lt;unsigned int*, unsigned int&gt; (unsigned int * t, unsigned int u) {
  …
}

baz&lt;double*, double&gt; (double * t, double u) {
  …
}

baz&lt;int*, int&gt; (int * t, int u) {
  …
}
…</code></pre>

  <p class="zw">可以看到，在<code class="calibre10">bar</code>的构造函数中分别调用了3个不同的<code class="calibre10">baz</code>函数，然后将它们的计算结果作为参数传入<code class="calibre10">foo</code>函数中。接着，稍微修改一下这个例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class …T&gt;
int baz(T …t)
{
  return 0;
}

template&lt;class …Args&gt;
void foo(Args …args) {}

template&lt;class …Args&gt;
class bar {
public:
  bar(Args …args)
  {
       foo(baz(&amp;args…) + args…);
  }
};

int main()
{
  bar&lt;int, double, unsigned int&gt; b(1, 5.0, 8);
}</code></pre>

  <p class="zw">在上面这段代码中形参包又是怎么解包的？要理解这个解包过程，需要将其分为两个部分：第一个部分是对函数模板<code class="calibre10">baz(&amp;args</code>…<code class="calibre10">)</code>的解包，其中<code class="calibre10">&amp;args</code>…是包展开，<code class="calibre10">&amp;args</code>是模式，这部分会被展开为<code class="calibre10">baz(&amp;a1, &amp;a2, &amp;a3)</code>；第二部分是对<code class="calibre10">foo(baz(&amp;args</code>…<code class="calibre10">) + args</code>…<code class="calibre10">)</code>的解包，由于<code class="calibre10">baz(&amp;args</code>…<code class="calibre10">)</code>已经被解包，因此现在相当于解包的是<code class="calibre10">foo(baz(&amp;a1, &amp;a2, &amp;a3) + args</code>…<code class="calibre10">)</code>，其中<code class="calibre10">baz(&amp;a1, &amp;a2, &amp;a3) + args</code>…是包展开，<code class="calibre10">baz(&amp;a1, &amp;a2, &amp;a3) + args</code>是模式，最后的结果为<code class="calibre10">foo(baz(&amp;a1, &amp;a2, &amp;a3) + a1, baz(&amp;a1, &amp;a2, &amp;a3) + a2, baz(&amp;a1, &amp;a2, &amp;a3) + a3)</code>。</p>

  <p class="zw">在我们刚刚看到的这些例子中包展开的模式都还算是比较常规的，而实际上模式还可以更加灵活，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

int add(int a, int b) { return a + b; };
int sub(int a, int b) { return a - b; };

template&lt;class …Args&gt;
void foo(Args (*…args)(int, int))
{
  int tmp[] = {(std::cout &lt;&lt; args(7, 11) &lt;&lt; std::endl, 0) …};
}

int main()
{
  foo(add, sub);
}</code></pre>

  <p class="zw">这个例子比之前看到的都要复杂一些，首先函数模板<code class="calibre10">foo</code>的形参包不再是简单的<code class="calibre10">Args</code>…<code class="calibre10">args</code>，而是<code class="calibre10">Args (*…args)(int, int)</code>，从形式上看这个形参包解包后将是零个或者多个函数指针。为了让编译器能自动推导出所有函数的调用，在函数模板<code class="calibre10">foo</code>的函数体里使用了一个小技巧。函数体内定义了一个<code class="calibre10">int</code>类型的数组<code class="calibre10">tmp</code>，并且借用了逗号表达式的特性，在括号中用逗号分隔的表达式会以从左往右的顺序执行，最后返回最右表达式的结果。在这个过程中<code class="calibre10">std::cout &lt;&lt; args(7, 11) &lt;&lt; std::endl</code>得到了执行。<code class="calibre10">(std::cout &lt;&lt; args(7, 11) &lt;&lt; std::endl, 0)</code>…是一个包展开，而<code class="calibre10">(std::cout &lt;&lt; args(7, 11) &lt;&lt; std::endl, 0)</code>是包展开的模式。</p>

  <p class="zw">我们已经见识了很多函数模板中包展开的例子，但是这些并不是包展开的全部，接下来让我们了解一下在类的继承中形参包以及包展开是怎么使用的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

template&lt;class …Args&gt;
class derived : public Args…
{
public:
  derived(const Args&amp; …args) : Args(args) … {}
};

class base1
{
public:
  base1() {}
  base1(const base1&amp;) 
  {
       std::cout &lt;&lt; "copy ctor base1" &lt;&lt; std::endl;
  }
};

class base2
{
public:
  base2() {}
  base2(const base2&amp;)
  {
       std::cout &lt;&lt; "copy ctor base2" &lt;&lt; std::endl;
  }
};

int main()
{
  base1 b1;
  base2 b2;
  derived&lt;base1, base2&gt; d(b1, b2);
}</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">derived</code>是可变参数的类模板，有趣的地方是它将形参包作为自己的基类并且在其构造函数的初始化列表中对函数形参包进行了解包，其中<code class="calibre10">Args(args)</code>…是包展开，<code class="calibre10">Args(args)</code>是模式。</p>

  <p class="zw">到此为止读者应该对形参包和包展开有了一定的理解，现在是时候介绍另一种可变参数模板了，这种可变参数模板拥有一个模板形参包，请注意这里并没有输入或者打印错误，确实是模板形参包。之所以在前面没有提到这类可变参数模板，主要是因为它看起来过于复杂：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;template&lt;class …&gt; class …Args&gt;
class bar : public Args&lt;int, double&gt;… {
public:
  bar(const Args&lt;int, double&gt;&amp; …args) : Args&lt;int, double&gt;(args) … {}
};

template&lt;class …Args&gt;
class baz1 {};

template&lt;class …Args&gt;
class baz2 {};

int main()
{
  baz1&lt;int, double&gt; a1;
  baz2&lt;int, double&gt; a2;
  bar&lt;baz1, baz2&gt; b(a1, a2);
}</code></pre>

  <p class="zw">可以看到类模板<code class="calibre10">bar</code>的模板形参是一个模板形参包，也就是说其形参包是可以接受零个或者多个模板的模板形参。在这个例子中，<code class="calibre10">bar&lt;baz1, baz2&gt;</code>接受了两个类模板<code class="calibre10">baz1</code>和<code class="calibre10">baz2</code>。不过模板缺少模板实参是无法实例化的，所以<code class="calibre10">bar</code>实际上继承的不是<code class="calibre10">baz1</code>和<code class="calibre10">baz2</code>两个模板，而是它们的实例<code class="calibre10">baz1&lt;int, double&gt;</code>和<code class="calibre10">baz2&lt;int, double&gt;</code>。还有一个有趣的地方，<code class="calibre10">template&lt;template &lt;class</code>…<code class="calibre10">&gt; class</code>…<code class="calibre10">Args&gt;</code>似乎存在两个形参包，但事实并非如此。因为最里面的<code class="calibre10">template&lt;class</code>…<code class="calibre10">&gt;</code>只说明模板形参是一个变参模板，它不能在<code class="calibre10">bar</code>中被展开。</p>

  <p class="zw">但是这并不意味着两个形参包不能同时存在于同一个模式中，要做到这一点，只要满足包展开后的长度相同即可，让我们看一看提案文档中的经典例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class…&gt; struct Tuple {};
template&lt;class T1, class T2&gt; struct Pair {};
template&lt;class …Args1&gt;
struct zip {
  template&lt;class …Args2&gt;
  struct with {
       typedef Tuple&lt;Pair&lt;Args1, Args2&gt;…&gt; type;
  };
};

int main()
{
  zip&lt;short, int&gt;::with&lt;unsigned short, unsigned&gt;::type t1;  // 编译成功
  zip&lt;short&gt;::with&lt;unsigned short, unsigned&gt;::type t2;       // 编译失败，形参
                                                             // 包长度不同
}</code></pre>

  <p class="zw">在上面的例子中，可变参数模板<code class="calibre10">zip</code>的形参包<code class="calibre10">Args1</code>和<code class="calibre10">with</code>的形参包<code class="calibre10">Args2</code>同时出现在模式<code class="calibre10">Pair&lt;Args1, Args2&gt;</code>中，如果要对<code class="calibre10">Pair&lt;Args1, Args2&gt;</code>…进行解包，就要求<code class="calibre10">Args1</code>和<code class="calibre10">Args2</code>的长度相同。编译器能够成功编译<code class="calibre10">t1</code>，<code class="calibre10">t1</code>的类型为<code class="calibre10">Tuple&lt;Pair&lt;short, unsigned short&gt;, Pair&lt;int, unsigned&gt;&gt;</code>，但是编译器在编译<code class="calibre10">t2</code>时会提示编译失败，因为<code class="calibre10">Args1</code>形参包中只有一个实参，而<code class="calibre10">Args2</code>中有两个实参，它们的长度不同。</p>

  <p class="zw">现在回头看一看这些例子，我们会发现例子里包展开的场景基本上涵盖了常用的几种，包括表达式、初始化列表、基类描述、成员初始化列表、函数形参列表和模板形参列表等。在剩下没有涉及的几种场景中，还有一种可能会偶尔用到，那就是<code class="calibre10">lambda</code>表达式的捕获列表：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class …Args&gt; void foo(Args …args) {}

template&lt;class …Args&gt;
class bar
{
public:
  bar(Args …args) {
       auto lm = [args …]{ foo(&amp;args…); };
       lm();
  }
};

int main()
{
  bar&lt;int, double&gt; b2(5, 8.11);
}</code></pre>

  <p class="zw">在以上代码的<code class="calibre10">lambda</code>表达式<code class="calibre10">lm</code>的捕获列表里，<code class="calibre10">args</code>…是一个包展开，而args是模式。比较有趣的是，除了捕获列表里的包展开，在<code class="calibre10">lambda</code>表达式的函数体内<code class="calibre10">foo(&amp;args</code>…<code class="calibre10">)</code>还有一个包展开，而这里的包展开是<code class="calibre10">&amp;args</code>…，模式为<code class="calibre10">&amp;args</code>。接下来看一个实际生产中可能会用到的例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class F, class… Args&gt;
auto delay_invoke(F f, Args… args) {
    return [f, args…]() -&gt; decltype(auto) {
        return std::invoke(f, args…);
    };
}</code></pre>

  <p class="zw">上面这段代码实现了一个<code class="calibre10">delay_invoke</code>，目的是将函数对象和参数打包到一个<code class="calibre10">lambda</code>表达式中，等到需要的时候直接调用<code class="calibre10">lambda</code>表达式实例，而无须关心参数如何传递。</p>

  <p class="zw">最后值得强调一下的是函数模板推导的匹配顺序：在推导的形参同时满足定参函数模板和可变参数函数模板的时候，编译器将优先选择定参函数模板，因为它比可变参数函数模板更加精确，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

template&lt;class… Args&gt; void foo(Args… args)
{
  std::cout &lt;&lt; "foo(Args… args)" &lt;&lt; std::endl;
}

template&lt;class T1, class… Args&gt; void foo(T1 a1, Args… args)
{
  std::cout &lt;&lt; "foo(T1 a1, Args… args)" &lt;&lt; std::endl;
}

template&lt;class T1, class T2&gt; void foo(T1 a1, T2 a2)
{
  std::cout &lt;&lt; "foo(T1 a1, T2 a2)" &lt;&lt; std::endl;
}

int main()
{
  foo();
  foo(1, 2, 3);
  foo(1, 2);
}</code></pre>

  <p class="zw">上面的代码编译运行的结果是：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">foo(Args… args)
foo(T1 a1, Args… args)
foo(T1 a1, T2 a2)</code></pre>

  <p class="zw">可以看到，当<code class="calibre10">foo()</code>没有任何实参的时候，编译器使用<code class="calibre10">foo(Args</code>…<code class="calibre10">args)</code>来匹配，因为只有它支持零参数的情况。当<code class="calibre10">foo(1,2,3)</code>有3个实参的时候，编译器不再使用<code class="calibre10">foo(Args</code>…<code class="calibre10">args)</code>来匹配，虽然它能够匹配3个实参，但是它不如<code class="calibre10">foo (T1 a1, Args</code>…<code class="calibre10">args)</code>精确，所以编译器采用了<code class="calibre10">foo(T1 a1, Args</code>…<code class="calibre10">args)</code>来匹配3个参数。<code class="calibre10">foo(1,2)</code>有两个参数，编译器再次抛弃了<code class="calibre10">foo(T1 a1, Args</code>…<code class="calibre10">args)</code>，因为这时候有更加精确的定参函数模板<code class="calibre10">foo(T1 a1, T2 a2)</code>。</p>

  <h2 id="OEBPS/Text/chapter035.html.nav_point_277" class="sigil_not_in_toc">35.3　sizeof...运算符</h2>

  <p class="zw">我们知道<code class="calibre10">sizeof</code>运算符能获取某个对象类型的字节大小。不过当<code class="calibre10">sizeof</code>之后紧跟…时其含义就完全不同了。<code class="calibre10">sizeof</code>…是专门针对形参包引入的新运算符，目的是获取形参包中形参的个数，返回的类型是<code class="calibre10">std::size_t</code>，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

template&lt;class …Args&gt; void foo(Args …args)
{
  std::cout &lt;&lt; "foo sizeof…(args) = " &lt;&lt; sizeof…(args) &lt;&lt; std::endl;
}

template&lt;class …Args&gt;
class bar
{
public:
  bar() {
       std::cout &lt;&lt; "bar sizeof…(Args) = " &lt;&lt; sizeof…(Args) &lt;&lt; std::endl;
  }
};

int main()
{
  foo();
  foo(1,2,3);

  bar&lt;&gt; b1;
  bar&lt;int, double&gt; b2;
}</code></pre>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">foo sizeof…(args) = 0
foo sizeof…(args) = 3
bar sizeof…(Args) = 0
bar sizeof…(Args) = 2</code></pre>

  <h2 id="OEBPS/Text/chapter035.html.nav_point_278" class="sigil_not_in_toc">35.4　可变参数模板的递归计算</h2>

  <p class="zw">在C++11标准中，要对可变参数模板形参包的包展开进行逐个计算需要用到递归的方法，比如下面的求和函数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

template&lt;class T&gt;
T sum(T arg)
{
  return arg;
}

template&lt;class T1, class… Args&gt;
auto sum(T1 arg1, Args …args)
{
  return arg1 + sum(args…);
}

int main()
{
  std::cout &lt;&lt; sum(1, 5.0, 11.7) &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">在上面的代码中，当传入函数模板<code class="calibre10">sum</code>的实参数量等于1时，编译器会选择调用<code class="calibre10">T sum(T arg)</code>，该函数什么也没有做，只是返回实参本身。当传入的实参数量大于1时，编译器会选择调用<code class="calibre10">auto sum(T1 arg1, Args</code>…<code class="calibre10">args)</code>，注意，这里使用C++14的特性将<code class="calibre10">auto</code>作为返回类型的占位符，把返回类型的推导交给编译器。这个函数将除了第一个形参的其他形参作为实参递归调用了<code class="calibre10">sum</code>函数，然后将其结果与第一个形参求和。最终编译器生成的结果应该和下面的伪代码类似：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">sum(double arg)
{
  return arg;
}

sum(double arg0, double args1)
{
  return arg0 + sum(args1);
}

sum(int arg1, double args1, double args2)
{
  return arg1 + sum(args1, args2);;
}

int main()
{
  std::cout &lt;&lt; sum(1, 5.0, 11.7) &lt;&lt; std::endl;
}</code></pre>

  <h2 id="OEBPS/Text/chapter035.html.nav_point_279" class="sigil_not_in_toc">35.5　折叠表达式</h2>

  <p class="zw">在前面的例子中，我们提到了利用数组和递归的方式对形参包进行计算的方法。这些都是非常实用的技巧，解决了C++11标准中包展开方法并不丰富的问题。不过实话实说，递归计算的方式过于烦琐，数组和括号表达式的方法技巧性太强也不是很容易想到。为了用更加正规的方法完成包展开，C++委员会在C++17标准中引入了折叠表达式的新特性。让我们使用折叠表达式的特性改写递归的例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

template&lt;class… Args&gt;
auto sum(Args …args)
{
  return (args + …);
}

int main()
{
  std::cout &lt;&lt; sum(1, 5.0, 11.7) &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">如果读者是第一次接触折叠表达式，一定会为以上代码的简洁感到惊叹。在这份代码中，我们不再需要编写多个<code class="calibre10">sum</code>函数，然后通过递归的方式求和。需要做的只是按照折叠表达式的规则折叠形参包<code class="calibre10">(args +</code>…<code class="calibre10">)</code>。根据折叠表达式的规则，<code class="calibre10">(args +</code>…<code class="calibre10">)</code>会被折叠为<code class="calibre10">arg0 + (arg1 + arg2)</code>，即1 + (5.0 + 11.7)。</p>

  <p class="zw">到此为止，读者应该已经迫不及待地想了解折叠表达式的折叠规则了吧。那么接下来我们就来详细地讨论折叠表达式的折叠规则。</p>

  <p class="zw">在C++17的标准中有4种折叠规则，分别是一元向左折叠、一元向右折叠、二元向左折叠和二元向右折叠。上面的例子就是一个典型的一元向右折叠：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">( args op … )折叠为(arg0 op (arg1 op … (argN-1 op argN)))</code></pre>

  <p class="zw">对于一元向左折叠而言，折叠方向正好相反：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">( … op args )折叠为((((arg0 op arg1) op arg2) op …) op argN)</code></pre>

  <p class="zw">二元折叠总体上和一元相同，唯一的区别是多了一个初始值，比如二元向右折叠：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">( args op … op init )折叠为(arg0 op (arg1 op …(argN-1 op (argN op init)))</code></pre>

  <p class="zw">二元向左折叠也是只有方向上正好相反：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">( init op … op args )折叠为(((((init op arg0) op arg1) op arg2) op …) op argN)</code></pre>

  <p class="zw">虽然没有提前声明以上各部分元素的含义，但是读者也能大概看明白其中的意思。这其中，<code class="calibre10">args</code>表示的是形参包的名称，<code class="calibre10">init</code>表示的是初始化值，而<code class="calibre10">op</code>则代表任意一个二元运算符。值得注意的是，在二元折叠中，两个运算符必须相同</p>

  <p class="zw">在折叠规则中最重要的一点就是操作数之间的结合顺序。如果在使用折叠表达式的时候不能清楚地区分它们，可能会造成编译失败，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;

template&lt;class… Args&gt;
auto sum(Args …args)
{
  return (args + …);
}

int main()
{
  std::cout &lt;&lt; sum(std::string("hello "), "c++ ", "world") &lt;&lt; std::endl;     // 编译错误
}</code></pre>

  <p class="zw">上面的代码会编译失败，理由很简单，因为折叠表达式<code class="calibre10">(args +</code>…<code class="calibre10">)</code>向右折叠，所以翻译出来的实际代码是<code class="calibre10">(std::string("hello ") + ("c++ " + "world"))</code>。但是两个原生的字符串类型是无法相加的，所以编译一定会报错。要使这段代码通过编译，只需要修改一下折叠表达式即可：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class… Args&gt;
auto sum(Args …args)
{
  return (… + args);
}</code></pre>

  <p class="zw">这样翻译出来的代码将是<code class="calibre10">((std::string("hello ") + "c++ ") + "world")</code>。而<code class="calibre10">std::string</code>类型的字符串可以使用+将两个字符串连接起来，于是可以顺利地通过编译。</p>

  <p class="zw">最后让我们来看一个有初始化值的例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;

template&lt;class …Args&gt;
void print(Args …args)
{
  (std::cout &lt;&lt; … &lt;&lt; args) &lt;&lt; std::endl;
}

int main()
{
  print(std::string("hello "), "c++ ", "world");
}</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">print</code>是一个输出函数，它会将传入的实参输出到控制台上。该函数运用了二元向左折叠<code class="calibre10">(std::cout &lt;&lt;</code>…<code class="calibre10">&lt;&lt; args)</code>，其中<code class="calibre10">std::cout</code>是初始化值，编译器会将代码翻译为<code class="calibre10">(((std::cout &lt;&lt; std::string("hello ")) &lt;&lt; "c++ ") &lt;&lt; "world") &lt;&lt; std::endl;</code>。</p>

  <h2 id="OEBPS/Text/chapter035.html.nav_point_280" class="sigil_not_in_toc">35.6　一元折叠表达式中空参数包的特殊处理</h2>

  <p class="zw">一元折叠表达式对空参数包展开有一些特殊规则，这是因为编译器很难确定折叠表达式最终的求值类型，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;typename… Args&gt;
auto sum(Args… args)
{
  return (args + …);
}</code></pre>

  <p class="zw">在上面的代码中，如果函数模板<code class="calibre10">sum</code>的实参为空，那么表达式<code class="calibre10">args +</code>…是无法确定求值类型的。当然，二元折叠表达式不会有这种情况，因为它可以指定一个初始化值：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;typename… Args&gt;
auto sum(Args… args)
{
  return (args + … + 0);
}</code></pre>

  <p class="zw">这样即使参数包为空，表达式的求值结果类型依然可以确定，编译器可以顺利地执行编译。为了解决一元折叠表达式中参数包为空的问题，下面的规则是必须遵守的。</p>

  <p class="zw">1．只有<code class="calibre10">&amp;&amp;</code>、<code class="calibre10">||</code>和<code class="calibre10">,</code>运算符能够在空参数包的一元折叠表达式中使用。</p>

  <p class="zw">2．<code class="calibre10">&amp;&amp;</code>的求值结果一定为<code class="calibre10">true</code>。</p>

  <p class="zw">3．<code class="calibre10">||</code>的求值结果一定为<code class="calibre10">false</code>。</p>

  <p class="zw">4．<code class="calibre10">,</code>的求值结果为<code class="calibre10">void()</code>。</p>

  <p class="zw">5．其他运算符都是非法的。</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

template&lt;typename… Args&gt;
auto andop(Args… args)
{
  return (args &amp;&amp; …);
}

int main()
{
  std::cout &lt;&lt; std::boolalpha &lt;&lt; andop();
}</code></pre>

  <p class="zw">在上面的代码中，虽然函数模板<code class="calibre10">andop</code>的参数包为空，但是依然能成功地编译运行并且输出计算结果<code class="calibre10">true</code>。</p>

  <h2 id="OEBPS/Text/chapter035.html.nav_point_281" class="sigil_not_in_toc">35.7　using声明中的包展开</h2>

  <p class="zw">从C++17标准开始，包展开允许出现在<code class="calibre10">using</code>声明的列表内，这对于可变参数类模板派生于形参包的情况很有用，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;
#include &lt;string&gt;

template&lt;class T&gt;
class base {
public:
  base() {}
  base(T t) : t_(t) {}
private:
  T t_;
};

template&lt;class… Args&gt;
class derived : public base&lt;Args&gt;…
{
public:
  using base&lt;Args&gt;::base…;
};

int main()
{
  derived&lt;int, std::string, bool&gt; d1 = 11;
  derived&lt;int, std::string, bool&gt; d2 = std::string("hello");
  derived&lt;int, std::string, bool&gt; d3 = true;
}</code></pre>

  <p class="zw">在上面的代码中，可变参数类模板<code class="calibre10">derived</code>继承了通过它的形参包实例化的<code class="calibre10">base</code>类模板。<code class="calibre10">using base&lt;Args&gt;::base</code>…将实例化的<code class="calibre10">base</code>类模板的构造函数引入了派生类<code class="calibre10">derived</code>。于是我们可以看到，<code class="calibre10">derived&lt;int, std::string, bool&gt;</code>具有了<code class="calibre10">base&lt;int&gt;</code>、<code class="calibre10">base&lt;std::string&gt;</code>和<code class="calibre10">base&lt;bool&gt;</code>的构造函数。</p>

  <h2 id="OEBPS/Text/chapter035.html.nav_point_282" class="sigil_not_in_toc">35.8　lambda表达式初始化捕获的包展开</h2>

  <p class="zw">读者应该还记得，我们在介绍<code class="calibre10">lambda</code>表达式使用可变参数模板时列出了这样一个例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class F, class… Args&gt;
auto delay_invoke(F f, Args… args) {
    return [f, args…]() -&gt; decltype(auto) {
        return std::invoke(f, args…);
    };
}</code></pre>

  <p class="zw">当时留下了一个问题没有解决，那就是按值捕获的性能问题。假设该<code class="calibre10">delay_ invoke</code>传递的实参都是复杂的数据结构且数据量很大，那么这种按值捕获显然不是一个理想的解决方案。当然了，引用捕获更加不对，在<code class="calibre10">delay_invoke</code>的使用场景下很容易造成未定义的结果。那么我们该怎么办？其实有一个办法，它需要结合初始化捕获和移动语义，让我们将代码修改为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class F, class… Args&gt;
auto delay_invoke(F f, Args… args) {
  return[f = std::move(f), tup = std::make_tuple(std::move(args) …)]() 
        -&gt; decltype(auto) {
       return std::apply(f, tup);
  };
}</code></pre>

  <p class="zw">上面的代码首先使用了<code class="calibre10">std::make_tuple</code>和<code class="calibre10">std::move</code>将参数打包到<code class="calibre10">std::tuple</code>中，这个过程使用移动语义消除了对象的复制；接下来为了方便地展开<code class="calibre10">std::tuple</code>中的参数，需要将<code class="calibre10">std::invoke</code>修改为<code class="calibre10">std::apply</code>。虽然在这个例子中性能问题解决了，但事情还没完，尤其是当我们需要用<code class="calibre10">lambda</code>表达式调用确定的函数时，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class… Args&gt;
auto delay_invoke_foo(Args… args) {
    return [args…]() -&gt; decltype(auto) {
        return foo(args…);
    };
}</code></pre>

  <p class="zw">如果还是按照刚刚的办法使用<code class="calibre10">std::tuple</code>打包参数，那么代码会变得难以理解：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class… Args&gt;
auto delay_invoke_foo(Args… args) {
  return[tup = std::make_tuple(std::move(args) …)]() -&gt; decltype(auto) {
       return std::apply([](auto const&amp;… args) -&gt; decltype(auto) {
            return foo(args…);
            }, tup);
  };
}</code></pre>

  <p class="zw">幸运的是，在C++20标准中我们有了更好的解决方案，标准支持<code class="calibre10">lambda</code>表达式初始化捕获的包展开。以上代码可以修改为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class… Args&gt;
auto delay_invoke_foo(Args… args) {
    return […args=std::move(args)]() -&gt; decltype(auto) {
        return foo(args…);

    };
}</code></pre>

  <p class="zw">上面的代码变得非常简洁！需要注意的是，捕获列表中…的位置在<code class="calibre10">args</code>之前，这一点和简单的捕获列表是有区别的。</p>

  <p class="zw">回过头来看最初的示例代码，在C++20标准环境下我们可以将其修改为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class F, class… Args&gt;
auto delay_invoke(F f, Args… args) {
  return[f = std::move(f), …args = std::move(args)]() -&gt; decltype(auto) {
       return std::invoke(f, args…s);
  };
}</code></pre>

  <p class="zw">可以看出在省略了<code class="calibre10">std::tuple</code>以后代码也变得清晰了不少。</p>

  <h2 id="OEBPS/Text/chapter035.html.nav_point_283" class="sigil_not_in_toc">35.9　总结</h2>

  <p class="zw">本章详细介绍了可变参数模板特性，该特性可以说是新标准中最重要的模板相关的特性。熟悉模板元编程的读者应该很清楚，过去想实现一个可以处理多个模板形参的模板只能机械化地重复代码，为了减少这种机械的重复，有些代码库会使用C++宏编程的技巧，比如<code class="calibre10">boost</code>、<code class="calibre10">loki</code>等。但是众所周知，C++宏编程对于代码的编写和调试是非常不友好的，一旦出现问题很难排查出原因。可变参数模板的出现正好能解决这个问题，丰富的包展开和折叠表达式功能也让原本晦涩难懂的模板元编程代码变得更加容易理解。对于不用编写模板元编程的程序员来说，本章的内容也有重要的意义，因为在标准库中已经有很多地方使用了该特性，比如<code class="calibre10">std::tuple</code>、<code class="calibre10">std:: variant</code>、<code class="calibre10">std::bind</code>等。理解可变参数模板特性有助于正确地使用它们。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter035.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter036.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter036.html.nav_point_284" class="not-in-toc">第36章　typename优化（C++17 C++20）</h1>

  <h2 id="OEBPS/Text/chapter036.html.nav_point_285" class="sigil_not_in_toc">36.1　允许使用typename声明模板形参</h2>

  <p class="zw">在C++17标准之前，必须使用<code class="calibre10">class</code>来声明模板形参，而<code class="calibre10">typename</code>是不允许使用的，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;typename T&gt; struct A {};
template &lt;template &lt;typename&gt; class T&gt; struct B {};
int main()
{
  B&lt;A&gt; ba;
}</code></pre>

  <p class="zw">上面的代码可以顺利地编译通过，但是如果将B的定义修改为<code class="calibre10">template &lt;template &lt;typename&gt; typename T&gt; struct B {};</code>，则可能会发生编译错误。具体情况要根据编译器厂商和版本而定，比如在GCC新版本中这种写法都是允许的，而CLang的新版本也只会给出一个警告，只有在它们的老版本中才会给出错误提示。总之，在C++17之前<code class="calibre10">typename</code>的这种写法是不符合标准的。</p>

  <p class="zw">其实，这种严苛的规则在过去看来是顺理成章的。因为在过去，能作为模板形参的只有类模板，并没有其他可能性，所以规定必须使用<code class="calibre10">class</code>来声明模板形参是合情合理的。但是自从C++11标准诞生，随着别名模板的引入，类模板不再是模板形参的唯一选择了，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;typename T&gt; using A = int;
template &lt;template &lt;typename&gt; class T&gt; struct B {};
int main()
{
  B&lt;A&gt; ba;
}</code></pre>

  <p class="zw">可以看到，这里的<code class="calibre10">A</code>实际上就是<code class="calibre10">int</code>类型而不是一个类模板。很明显，现在已经没有必要强调必须使用<code class="calibre10">class</code>来声明模板形参了，删除这个规则可以让语言更加简单合理。所以在C++17标准中使用<code class="calibre10">typename</code>来声明模板形参已经不是问题了：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;typename T&gt; using A = int;
template &lt;template &lt;typename&gt; typename T&gt; struct B {};
int main()
{
  B&lt;A&gt; ba;
}</code></pre>

  <h2 id="OEBPS/Text/chapter036.html.nav_point_286" class="sigil_not_in_toc">36.2　减少typename使用的必要性</h2>

  <p class="zw">我们知道当使用未决类型的内嵌类型时，例如<code class="calibre10">X&lt;T&gt;::Y</code>，需要使用<code class="calibre10">typename</code>明确告知编译器<code class="calibre10">X&lt;T&gt;::Y</code>是一个类型，否则编译器会将其当作一个表达式的名称，比如一个静态数据成员或者静态成员函数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T&gt; void f(T::R);</code></pre>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T&gt; void f(typename T::R);</code></pre>

  <p class="zw">在C++20标准之前，只有两种情况例外，它们分别是指定基类和成员初始化，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct Impl {};

struct Wrap {
  using B = Impl;
};

template&lt;class T&gt;
struct D : T::B {
  D() : T::B() {}
};

D&lt;Wrap&gt; var;</code></pre>

  <p class="zw">在上面的代码中<code class="calibre10">struct D : T::B</code>和<code class="calibre10">D() : T::B() {}</code>都没有指定<code class="calibre10">typename</code>，但是编译器依然可以正确地识别程序意图。实际上，除了以上两种情况外，还有很多时候也可以从语义中明确地判断出<code class="calibre10">X&lt;T&gt;::Y</code>表示的是类型，比如使用<code class="calibre10">using</code>创建类型别名的时候，<code class="calibre10">using R = typename T::B;</code>中<code class="calibre10">typename</code>完全没有存在的必要。</p>

  <p class="zw">在C++20标准中，增加了一些情况可以让我们省略<code class="calibre10">typename</code>关键字。</p>

  <p class="zw">1．在上下文仅可能是类型标识的情况，可以忽略<code class="calibre10">typename</code>。</p>

  <p class="zw">　　<code class="calibre10">static_cast</code>、<code class="calibre10">const_cast</code>、<code class="calibre10">reinterpret_cast</code>或<code class="calibre10">dynamic_cast</code>等类型转换：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">static_cast&lt;T::B&gt;(p);</code></pre>

  <p class="zw">　　定义类型别名：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">using R = T::B;</code></pre>

  <p class="zw">　　后置返回类型：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto g() -&gt; T::B;</code></pre>

  <p class="zw">　　模板类型形参的默认参数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class R = T::B&gt; struct X;</code></pre>

  <p class="zw">2．还有一些声明的情况也可以忽略<code class="calibre10">typename</code>。</p>

  <p class="zw">　　全局或者命名空间中简单的声明或者函数的定义：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T&gt; T::R f();</code></pre>

  <p class="zw">　　结构体的成员：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T&gt;
struct D : T::B {
  D() : T::B() {}
  T::B b;    // 编译成功
};</code></pre>

  <p class="zw">　　作为成员函数或者<code class="calibre10">lambda</code>表达式形参声明：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T&gt;
struct D : T::B {
  D() : T::B() {}
  T::B f(T::B) { return T::B(); } // 编译成功
};</code></pre>

  <p class="zw">最后需要提出的是，到目前为止实现了这部分特性的编译器只有GCC而已，至于CLang和MSVC编译以上代码依然会报错，并且提示需要添加<code class="calibre10">typename</code>。</p>

  <h2 id="OEBPS/Text/chapter036.html.nav_point_287" class="sigil_not_in_toc">36.3　总结</h2>

  <p class="zw">本章的内容虽然比较简单，但是对于爱好模板元编程的读者来说却有一定意义。要知道模板元编程可以说是对类型的编程，所以在模板元编程的代码中总是会出现成堆的<code class="calibre10">typename</code>关键字，这些冗余的描述增加了无谓的代码量，非常影响代码的整洁。C++20标准减少<code class="calibre10">typename</code>声明的必要性无疑减轻了这种负担。允许使用<code class="calibre10">typename</code>声明模板形参也让模板声明体系显得更加合理了。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter036.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter037.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter037.html.nav_point_288" class="not-in-toc">第37章　模板参数优化（C++11 C++17 C++20）</h1>

  <h2 id="OEBPS/Text/chapter037.html.nav_point_289" class="sigil_not_in_toc">37.1　允许常量求值作为所有非类型模板的实参</h2>

  <p class="zw">熟悉模板编程的读者应该知道，相对于以类型为模板参数的模板而言，以非类型为模板参数的模板实例化规则更加严格。在C++17标准之前，这些规则包括以下几种。</p>

  <p class="zw">1．如果整型作为模板实参，则必须是模板形参类型的经转换常量表达式。所谓经转换常量表达式是指隐式转换到某类型的常量表达式，特点是隐式转换和常量表达式。这一点很好理解，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">constexpr char v = 42;
constexpr char foo() { return 42; }
template&lt;int&gt; struct X {};

int main()
{
  X&lt;v&gt; x1;
  X&lt;foo()&gt; x2;
}</code></pre>

  <p class="zw">在上面的代码中<code class="calibre10">constexpr char</code>到<code class="calibre10">int</code>的转换就满足隐式转换和常量表达式。</p>

  <p class="zw">2．如果对象指针作为模板实参，则必须是静态或者是有内部或者外部链接的完整对象。</p>

  <p class="zw">3．如果函数指针作为模板实参，则必须是有链接的函数指针。</p>

  <p class="zw">4．如果左值引用的形参作为模板实参，则必须也是有内部或者外部链接的。</p>

  <p class="zw">5．而对于成员指针作为模板实参的情况，必须是静态成员。</p>

  <p class="zw">请注意，以上提到的后4条规则都强调了两种特性：链接和静态。因为一旦代码满足了这些要求，就表明实参指引的内存地址固定了下来，对于编译器而言这是实例化模板的关键。比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;const char *&gt; struct Y {};
extern const char str1[] = "hello world";   // 外部链接
const char str2[] = "hello world";          // 内部链接

int main()
{
  Y&lt;str1&gt; y1;
  Y&lt;str2&gt; y2;
}</code></pre>

  <p class="zw">除了上面的规则以外，其他的实例化方式都是非法的，这其中也包括了一些合理场景，例如返回指针的常量表达式：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int v = 42;
constexpr int* foo() { return &amp;v; }
template&lt;const int*&gt; struct X {};

int main()
{
  X&lt;foo()&gt; x;
}</code></pre>

  <p class="zw">上面的代码在C++17之前是无法编译成功的，因为模板并不接受<code class="calibre10">foo()</code>的返回值类型，根据第一条规则它只会接受整型的经转换常量表达式。</p>

  <p class="zw">在C++17标准中，C++委员会对这套规则做了重新的梳理，一方面简化规则的描述，另一方面也允许常量求值作为所有非类型模板的实参。新的标准只强调了一条规则：非类型模板形参使用的实参可以是该模板形参类型的任何经转换常量表达式。其中经转换常量表达式的定义添加了对象、数组、函数等到指针的转换。这从另一个角度对以前的规则进行了兼容。</p>

  <p class="zw">在新规则的支持下，上面的代码可以编译成功，因为新规则不再强调经转换常量表达式的求值结果为整型。由于规则的修改，还带来了一个有趣的变化。仔细观察新规则会发现，现在对于指针不再要求是具有链接的，取而代之的是必须满足经转换常量表达式求值。这就是说，下面的代码可以顺利地编译通过：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;const char *&gt; struct Y {};
int main()
{
  static const char str[] = "hello world";
  Y&lt;str&gt; y;
}</code></pre>

  <p class="zw">在C++17以前，上面的代码会编译失败，给出的错误提示为<code class="calibre10">&amp;str</code>，而不是一个有效的模板实参，因为<code class="calibre10">str</code>没有链接。不过C++17不存在上述问题，代码能够顺利地编译通过。</p>

  <p class="zw">最后要强调的是，新规则并非万能，以下对象作为非类型模板实参依旧会造成编译器报错。</p>

  <p class="zw">1．对象的非静态成员对象。</p>

  <p class="zw">2．临时对象。</p>

  <p class="zw">3．字符串字面量。</p>

  <p class="zw">4．<code class="calibre10">typeid</code>的结果。</p>

  <p class="zw">5．预定义变量。</p>

  <h2 id="OEBPS/Text/chapter037.html.nav_point_290" class="sigil_not_in_toc">37.2　允许局部和匿名类型作为模板实参</h2>

  <p class="zw">在C++11标准之前，将局部或匿名类型作为模板实参是不被允许的，但是这个限制并没有什么道理，所以在C++11标准中允许了这样的行为，让我们看一个提案文档中的例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T&gt; class X { };
template &lt;class T&gt; void f(T t) { }
struct {} unnamed_obj;

int main()
{
  struct A { };
  enum { e1 };
  typedef struct {} B;
  B b;
  X&lt;A&gt;  x1;              // C++11编译成功，C++03编译失败
  X&lt;A*&gt; x2;              // C++11编译成功，C++03编译失败
  X&lt;B&gt;  x3;              // C++11编译成功，C++03编译失败
  f(e1);                 // C++11编译成功，C++03编译失败
  f(unnamed_obj);        // C++11编译成功，C++03编译失败
  f(b);                  // C++11编译成功，C++03编译失败
}</code></pre>

  <p class="zw">在上面的代码中，由于结构体<code class="calibre10">A</code>和<code class="calibre10">B</code>都是局部类型，因此<code class="calibre10">x1</code>、<code class="calibre10">x2</code>和<code class="calibre10">x3</code>在C++11之前会编译失败。另外，因为<code class="calibre10">e1</code>、<code class="calibre10">unnamed_obj</code>的类型为匿名类型，所以<code class="calibre10">f(e1)</code>和<code class="calibre10">f(unnamed_obj)</code>在C++11之前也会编译失败。最后，由于<code class="calibre10">b</code>的类型是局部类型，因此<code class="calibre10">f(b)</code>在C++11之前同样无法编译成功。当然，在C++11上就没有以上的编译问题了。</p>

  <h2 id="OEBPS/Text/chapter037.html.nav_point_291" class="sigil_not_in_toc">37.3　允许函数模板的默认模板参数</h2>

  <p class="zw">在C++11标准之前，与局部和匿名类型不能作为模板实参同样没有道理的还有函数模板不能有默认模板参数的规则。说这条规则没有道理，是因为类模板是可以有默认模板参数的，而函数模板却不能，但却找不到一条要这么限制函数模板的理由。正因如此，这条限制在C++11标准中也被解除了。在C++11中，我们可以自由地在函数模板中使用默认的模板参数，甚至在语法上比类模板更加灵活：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T = double&gt;
void foo()
{
  T t;
}

int main()
{
  foo();
}</code></pre>

  <p class="zw">在上面的代码中，函数模板<code class="calibre10">foo</code>有一个默认的模板参数<code class="calibre10">double</code>，所以在<code class="calibre10">main</code>函数中直接调用<code class="calibre10">foo</code>不会造成编译失败。因为在没有指定模板实参的时候它会使用默认的模板参数。值得注意的是，函数模板的默认模板参数是不会影响模板实参的推导的，也就是说推导出的类型的优先级高于默认参数，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T = double&gt;
void foo(T t) {}

int main()
{
  foo(5);
}</code></pre>

  <p class="zw">在上面的代码中，虽然函数模板<code class="calibre10">foo</code>的默认模板参数是<code class="calibre10">double</code>，但是由于函数模板会根据函数实参推导模板实参类型，而且其优先级高于默认模板参数，因此这里相当于调用了<code class="calibre10">foo(int)</code>函数。</p>

  <p class="zw">最后要说的是，函数模板的默认模板参数要比类模板的默认模板参数以及函数的默认参数都要灵活。我们知道无论是函数的默认参数还是类模板的默认模板参数，都必须保证从右往左定义默认值，否则无法通过编译，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T = double, class U, class R = double&gt;
struct X {};

void foo(int a = 0, int b, double c = 1.0) {}</code></pre>

  <p class="zw">以上代码由于模板参数<code class="calibre10">U</code>和参数<code class="calibre10">b</code>没有指定默认参数，破坏了必须从右往左定义默认值的规则，因此会编译失败。而函数模板就没有这个问题了：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T = double, class U, class R = double&gt;
void foo(U u) {}

int main()
{
  foo(5);
}</code></pre>

  <p class="zw">以上代码可以顺利地通过编译，其中<code class="calibre10">T</code>和<code class="calibre10">R</code>都有默认参数<code class="calibre10">double</code>，而<code class="calibre10">U</code>没有默认参数，不过<code class="calibre10">U</code>可以通过实参5推导出来。所以这里实际上调用的是<code class="calibre10">foo&lt;double, int, double&gt;(int)</code>函数。</p>

  <h2 id="OEBPS/Text/chapter037.html.nav_point_292" class="sigil_not_in_toc">37.4　函数模板添加到ADL查找规则</h2>

  <p class="zw">在C++20标准之前，ADL的查找规则是无法查找到带显式指定模板实参的函数模板的，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">namespace N {
  struct A {};
  template &lt;class T&gt; int f(T) { return 1; }
}

int x = f&lt;N::A&gt;(N::A());</code></pre>

  <p class="zw">MSVC会报错并提示找不到函数<code class="calibre10">f</code>，而GCC相对友好一些，它会报错并且询问是否要调用的是<code class="calibre10">N::f</code>。而CLang更加友好，它会编译成功，最后给出一条温馨的警告信息。</p>

  <p class="zw">从C++20标准开始以上问题得以解决，编译器可以顺利地找到命名空间<code class="calibre10">N</code>中的函数<code class="calibre10">f</code>。不过需要注意的是，有些情况仍会让编译器报错，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int h = 0;
void g() {}
namespace N {
  struct A {};
  template &lt;class T&gt; int f(T) { return 1; }
  template &lt;class T&gt; int g(T) { return 2; }
  template &lt;class T&gt; int h(T) { return 3; }
}
int x = f&lt;N::A&gt;(N::A());  // 编译成功，查找f没有找到任何定义，f被认为是模板
int y = g&lt;N::A&gt;(N::A());  // 编译成功，查找g找到一个函数，g被认为是模板
int z = h&lt;N::A&gt;(N::A());  // 编译失败</code></pre>

  <p class="zw">在上面的代码中<code class="calibre10">f</code>和<code class="calibre10">g</code>都编译成功，因为根据标准要求编译器查找<code class="calibre10">f</code>和<code class="calibre10">g</code>的结果分别是什么都没找到以及找到一个函数，在这种情况下可以猜测它们都是模板函数，并且尝试匹配到命名空间<code class="calibre10">N</code>的<code class="calibre10">f</code>和<code class="calibre10">g</code>两个函数模板。而<code class="calibre10">h</code>则不同，编译器可以找到一个<code class="calibre10">int</code>变量<code class="calibre10">h</code>，在这种情况下紧跟<code class="calibre10">h</code>之后的&lt;可以被认为是小于号，不符合标准要求，所以编译器仍会报错。</p>

  <h2 id="OEBPS/Text/chapter037.html.nav_point_293" class="sigil_not_in_toc">37.5　允许非类型模板形参中的字面量类类型</h2>

  <p class="zw">在C++20之前，非类型模板形参可以是整数类型、枚举类型、指针类型、引用类型和<code class="calibre10">std::nullptr_t</code>，但是类类型是无法作为非类型模板形参的，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct A {};

template &lt;A a&gt;
struct B {};

A a;
B&lt;a&gt; b; // 编译失败</code></pre>

  <p class="zw">不过从C++20开始，字面量类类型（literal class）可以作为形参在非类型模板形参列表中使用了。具体要求如下。</p>

  <p class="zw">1．所有基类和非静态数据成员都是公开且不可变的。</p>

  <p class="zw">2．所有基类和非静态数据成员的类型是标量类型、左值引用或前者的（可能是多维）数组。</p>

  <p class="zw">使用C++20的编译环境可以顺利编译上述代码，注意，到目前为止CLang还没有支持这项特性。</p>

  <p class="zw">不知道读者是否曾经为非类型模板形参不能使用字符串字面量而感到遗憾呢？比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;const char *&gt;
struct X {};

X&lt;"hello"&gt; x; // 编译失败</code></pre>

  <p class="zw">现在，我们可以利用字面量类类型以及其构造函数，让非类型模板形参间接地支持字符串字面量了，请看下面的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;typename T, std::size_t N&gt;
struct basic_fixed_string
{
  constexpr basic_fixed_string(const T(&amp;foo)[N + 1])
  {
       std::copy_n(foo, N + 1, data_);
  }

  T data_[N + 1];
};
template &lt;typename T, std::size_t N&gt;
basic_fixed_string(const T(&amp;str)[N])-&gt;basic_fixed_string&lt;T, N - 1&gt;;

template &lt;basic_fixed_string Str&gt;
struct X {
  X() {
       std::cout &lt;&lt; Str.data_;
  }
};

X&lt;"hello world"&gt; x;</code></pre>

  <p class="zw">以上代码是在提案文档的示例上稍作修改，其中<code class="calibre10">basic_fixed_string</code>是一个典型的字面量类类型，它的构造函数接受一个常量字符串数组并将该数组复制到数据成员<code class="calibre10">m_data</code>中，因为构造函数声明为<code class="calibre10">constexpr</code>，所以可以在编译期执行完毕。接下来，代码通过自定义推导指引（详情请见第39章）：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;typename CharT, std::size_t N&gt;
basic_fixed_string(const CharT(&amp;str)[N])-&gt;basic_fixed_string&lt;CharT, N - 1&gt;;</code></pre>

  <p class="zw">明确编译器通过构造函数推导模板实参的方法。然后将<code class="calibre10">basic_fixed_string</code>作为模板形参加入类模板<code class="calibre10">X</code>的模板形参列表中，这样编译器编译<code class="calibre10">X&lt;"hello world"&gt; x;</code>的时候就会根据<code class="calibre10">basic_fixed_string</code>的构造函数将<code class="calibre10">"hello world"</code>复制到<code class="calibre10">data_</code>中。最终，代码在运行期执行<code class="calibre10">X</code>的构造函数，输出字符串<code class="calibre10">hello world</code>。</p>

  <h2 id="OEBPS/Text/chapter037.html.nav_point_294" class="sigil_not_in_toc">37.6　扩展的模板参数匹配规则</h2>

  <p class="zw">一直以来，模板形参只能精确匹配实参列表，也就是说实参列表里的每一项必须和模板形参有着相同的类型。虽然这种匹配规则非常严谨且不易出错，但是却排除了很多合理的情况，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;template &lt;typename&gt; class T, class U&gt; void foo()
{
  T&lt;U&gt; n;
}
template &lt;class, class = int&gt; struct bar {};

int main()
{
  foo&lt;bar, double&gt;();
}</code></pre>

  <p class="zw">在上面的代码中，函数模板<code class="calibre10">foo</code>的模板形参列表接受一个模板实参，并且要求这个模板实参只有一个模板形参，巧的是类模板<code class="calibre10">bar</code>的模板形参列表中正好只有一个形参是需要指定的，而另外一个形参可以使用默认值。看起来<code class="calibre10">foo&lt;bar, double&gt;()</code>这种写法应该顺利地通过编译，但是事与愿违，这份代码在C++17之前是无法编译成功的。原因就是我们上文提到的：模板形参只能精确匹配实参列表，而这里类模板<code class="calibre10">bar</code>的模板形参数量与函数模板<code class="calibre10">foo</code>要求的模板实参的模板形参数量并不匹配，很明显这种匹配规则过于严苛了。</p>

  <p class="zw">另外，由于在C++17中非类型模板形参可以使用<code class="calibre10">auto</code>作为占位符，因此我们可以写出这样的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;template &lt;auto&gt; class T, auto N&gt; void foo() 
{ 
  T&lt;N&gt; n;
}
template &lt;auto&gt; struct bar {};

int main()
{
  foo&lt;bar, 5&gt;();
}</code></pre>

  <p class="zw">在上面的代码中，类型占位符<code class="calibre10">auto</code>最终都会被推导为<code class="calibre10">int</code>类型，于是模板形参和模板实参列表是匹配的，编译起来没有问题。但是修改一下函数模板<code class="calibre10">foo</code>，结果还是正确的吗？</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;template &lt;int&gt; class T, int N&gt; void foo() 
{ 
  T&lt;N&gt; n;
}</code></pre>

  <p class="zw">从推导的角度来看，类模板<code class="calibre10">bar</code>的模板形参中类型占位符<code class="calibre10">auto</code>被推导为<code class="calibre10">int</code>，这样一来整个推导过程似乎是顺理成章的，但是从匹配规则的角度来看又违反了必须精确匹配的要求，所以为了让以<code class="calibre10">auto</code>占位符作为非类型模板形参这个特性使用得更为广泛，也是时候对模板参数的匹配规则进行一些扩展了。</p>

  <p class="zw">在C++17标准中放宽了对模板参数的匹配规则，它要求模板形参至少和实参列表一样特化。换句话说，模板形参可以和实参列表精确匹配。另外，模板形参也可以比实参列表更加特化。在新的匹配规则下，让我们重新审视上面的代码。</p>

  <p class="zw">很显然，函数模板<code class="calibre10">foo</code>的模板形参<code class="calibre10">template &lt;typename&gt; class T</code>相较于实参<code class="calibre10">template &lt;class, class = int&gt; struct bar</code>更加特化。而模板形参<code class="calibre10">template &lt;int&gt; class T</code>相较于<code class="calibre10">template &lt;auto&gt; struct bar</code>也更加特化。这两份代码在C++17中都可以顺利地编译成功。</p>

  <h2 id="OEBPS/Text/chapter037.html.nav_point_295" class="sigil_not_in_toc">37.7　总结</h2>

  <p class="zw">本章介绍的都是和模板参数相关的内容，其中允许常量求值作为非类型模板实参、允许局部和匿名类型作为模板实参和允许非类型模板形参中的字面量类类型扩展了模板参数的匹配范围，而函数模板添加到ADL查找规则和扩展的模板参数匹配规则则是优化了模板参数的匹配规则。掌握了这些特性能够让模板代码的编写更加得心应手，让模板完成之前不可能完成的任务，比如让字符串字面量作为模板实参就是一个典型的例子。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter037.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter038.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter038.html.nav_point_296" class="not-in-toc">第38章　类模板的模板实参推导（C++17 C++20）</h1>

  <h2 id="OEBPS/Text/chapter038.html.nav_point_297" class="sigil_not_in_toc">38.1　通过初始化构造推导类模板的模板实参</h2>

  <p class="zw">在C++17标准之前，实例化类模板必须显式指定模板实参，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::tuple&lt;int, double, const char*&gt; v{5, 11.7, "hello world"};</code></pre>

  <p class="zw">可以看到这种写法十分冗长，幸运的是，由于函数模板可以通过函数的实参列表推导出模板实参，因此出现了<code class="calibre10">std::make_pair</code>和<code class="calibre10">std::make_tuple</code>这类函数，结合<code class="calibre10">auto</code>关键字，上面的代码可以简化为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto v = std::make_tuple(5, 11.7, "hello world");</code></pre>

  <p class="zw">虽然这种方法在一定程度上解决了问题，但是很明显在<code class="calibre10">std::tuple</code>的初始化阶段，编译器有条件通过<code class="calibre10">v{5, 11.7, "hello world"}</code>初始化列表中的实参推导出<code class="calibre10">std::tuple</code>的模板实参，这样就不必引入函数模板<code class="calibre10">std::make_tuple</code>了。</p>

  <p class="zw">C++17标准支持了类模板的模板实参推导，上面的代码可以进一步简化为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::tuple v{ 5, 11.7, "hello world" };</code></pre>

  <p class="zw">实例化类模板也不再需要显式地指定每个模板实参，编译器可以通过对象的初始化构造推导出缺失的模板实参。典型的使用例子还包括：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::mutex mx;
std::lock_guard lg{ mx };
std::complex c{ 3.5 };
std::vector v{ 5,7,9 };
auto v1 = new std::vector{ 1, 3, 5 };</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">lg</code>的类型被推导为<code class="calibre10">std::lock_guard&lt;std::mutex&gt;</code>，<code class="calibre10">c</code>和<code class="calibre10">v</code>的类型分别被推导为<code class="calibre10">std::complex&lt;double&gt;</code>和<code class="calibre10">std::vector&lt;int&gt;</code>。当然了，使用<code class="calibre10">new</code>表达式也能触发类模板的实参推导。除了以类型为模板形参的类模板，实参推导对非类型形参的类模板同样适用，下面的例子就是通过初始化，同时推导出类型模板实参<code class="calibre10">char</code>和非类型模板实参<code class="calibre10">6</code>的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

template&lt;class T, std::size_t N&gt;
struct MyCountOf
{
  MyCountOf(T(&amp;)[N]) {}
  std::size_t value = N;
};

int main()
{
  MyCountOf c("hello");
  std::cout &lt;&lt; c.value &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">对于非类型模板形参为<code class="calibre10">auto</code>占位符的情况也是支持推导的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T, auto N&gt;
struct X
{
  X(T(&amp;)[N]) {}
};

int main()
{
  X x("hello");
}</code></pre>

  <p class="zw">需要注意的是，不同于函数模板，类模板的模板实参是不允许部分推导的。比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T1, class T2&gt;
void foo(T1, T2) {}

int main()
{
  foo&lt;int&gt;(5, 6.8);
}</code></pre>

  <p class="zw">上面这段代码可以编译成功，虽然函数模板实例化的时候只显式指定了一个模板实参<code class="calibre10">T1</code>，但是由于模板实参<code class="calibre10">T2</code>可以通过函数实参列表推导，因此并不会影响编译器的正常工作，最终编译器正确将函数模板实例化为<code class="calibre10">foo&lt;int, double&gt;(int, double)</code>。但是这在类模板上是行不通的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T1, class T2&gt;
struct foo
{
  foo(T1, T2) {}
};

int main()
{
  foo v1(5, 6.8);                     // 编译成功
  foo&lt;&gt; v2(5, 6.8);                   // 编译错误
  foo&lt;int&gt; v3(5, 6.8);                // 编译错误
  foo&lt;int, double&gt; v4(5, 6.8);        // 编译成功
}</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">v1</code>和<code class="calibre10">v4</code>可以顺利通过编译，其中<code class="calibre10">v1</code>符合类模板实参的推导要求，而<code class="calibre10">v4</code>则显式指定了模板实参。<code class="calibre10">v2</code>和<code class="calibre10">v3</code>就没那么幸运了，它们都没有完整地指定模板实参，这是编译器不能接受的。</p>

  <h2 id="OEBPS/Text/chapter038.html.nav_point_298" class="sigil_not_in_toc">38.2　拷贝初始化优先</h2>

  <p class="zw">在类模板的模板实参推导过程中往往会出现这样两难的场景：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::vector v1{ 1, 3, 5 };
std::vector v2{ v1 };

std::tuple t1{ 5, 6.8, "hello" };
std::tuple t2{ t1 };</code></pre>

  <p class="zw">这里读者不妨猜测一下<code class="calibre10">v2</code>和<code class="calibre10">t2</code>的类型。<code class="calibre10">v2</code>是<code class="calibre10">std::vector&lt;int&gt;</code>类型还是<code class="calibre10">std::vector&lt;std::vector&lt;int&gt;&gt;</code>类型，<code class="calibre10">t2</code>是<code class="calibre10">std::tuple&lt;int, double, const char *&gt;</code>类型还是<code class="calibre10">std::tuple&lt;std::tuple&lt;int, double, const char *&gt;&gt;</code>类型？实际上，正如本节的标题所言，这里会优先解释为拷贝初始化。更明确地说，<code class="calibre10">v2</code>的类型为<code class="calibre10">std::vector&lt;int&gt;</code>，<code class="calibre10">t2</code>的类型为<code class="calibre10">std::tuple&lt;int, double, const char *&gt;</code>。</p>

  <p class="zw">同理，下面的类模板也都会被实例化为<code class="calibre10">std::vector&lt;int&gt;</code>类型：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::vector v3(v1);
std::vector v4 = {v1};
auto v5 = std::vector{v1};</code></pre>

  <p class="zw">请读者注意，使用列表初始化的时候，当且仅当初始化列表中只有一个与目标类模板相同的元素才会触发拷贝初始化，在其他情况下都会创建一个新的类型，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::vector v1{ 1, 3, 5 };
std::vector v3{ v1, v1 };

std::tuple t1{ 5, 6.8, "hello" };
std::tuple t3{ t1, t1 };</code></pre>

  <p class="zw">其中<code class="calibre10">v3</code>的类型为<code class="calibre10">std::vector&lt;std::vector&lt;int&gt;&gt;</code>，<code class="calibre10">t3</code>的类型为<code class="calibre10">std::tuple&lt;std::tuple&lt;int, double, const char *&gt;, std::tuple&lt;int, double, const char *&gt;&gt;</code>。最后值得一提的是，虽然C++17标准的编译器现在一致表现为优先拷贝初始化，但是真正在标准中明确的是C++20。该语法补充是在2017年7月提出的，可惜那时候C++17标准已经发布了。</p>

  <h2 id="OEBPS/Text/chapter038.html.nav_point_299" class="sigil_not_in_toc">38.3　lambda类型的用途</h2>

  <p class="zw">请读者思考一个问题，要将一个<code class="calibre10">lambda</code>表达式作为数据成员存储在某个对象中，应该如何编写这种类的代码？在C++17以前，大部分人想出的解决方案应该差不多是这样的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

template&lt;class T&gt;
struct LambdaWarp
{
  LambdaWarp(T t) : func(t) {}
  template&lt;class … Args&gt;
  void operator() (Args&amp;&amp; … arg)
  {
       func(std::forward&lt;Args&gt;(arg) …);
  }
  T func;
};

int main()
{
  auto l = [](int a, int b) { 
       std::cout &lt;&lt; a + b &lt;&lt; std::endl; 
  };

  LambdaWarp&lt;decltype(l)&gt; x(l);
  x(11, 7);
}</code></pre>

  <p class="zw">在这份代码中，最关键的步骤是使用<code class="calibre10">decltype</code>获取<code class="calibre10">lambda</code>表达式<code class="calibre10">l</code>的类型，只有通过这种方法才能准确地实例化类模板。在C++支持了类模板的模板实参推导以后，上面的代码可以进行一些优化：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

template&lt;class T&gt;
struct LambdaWarp
{
  LambdaWarp(T t) : func(t) {}

  template&lt;class … Args&gt;
  void operator() (Args&amp;&amp; … arg)
  {
       func(std::forward&lt;Args&gt;(arg) …);
  }
  T func;
};

int main()
{
  LambdaWarp x([](int a, int b) {
       std::cout &lt;&lt; a + b &lt;&lt; std::endl;
  });
  x(11, 7);
}</code></pre>

  <p class="zw">上面的代码不再显式指定<code class="calibre10">lambda</code>表达式类型，而是让编译器通过初始化构造自动推导出<code class="calibre10">lambda</code>表达式类型，简化了代码的同时也更加符合<code class="calibre10">lambda</code>表达式的使用习惯。</p>

  <h2 id="OEBPS/Text/chapter038.html.nav_point_300" class="sigil_not_in_toc">38.4　别名模板的类模板实参推导</h2>

  <p class="zw">C++20标准支持了别名模板的类模板实参推导，顾名思义该特性结合了别名模板和类模板实参推导的两种特性。让我们看一看提案文档提供的示例代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T, class U&gt; struct C {
  C(T, U) {}
};

template&lt;class V&gt;
using A = C&lt;V*, V*&gt;;

int i{};
double d{};
A a1(&amp;i, &amp;i);      // 编译成功，可以推导为A&lt;int&gt;
A a2(i, i);        // 编译失败，i无法推导为V*
A a3(&amp;i, &amp;d);      // 编译失败，(int *, double *)无法推导为(V*, V*)</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">A</code>是<code class="calibre10">C</code>的别名模板，它约束<code class="calibre10">C</code>的两个模板参数为相同类型的指针<code class="calibre10">V*</code>。在推导过程中，<code class="calibre10">A a1(&amp;i, &amp;i);</code>可以编译成功，因为构造函数推导出来的两个实参类型都是<code class="calibre10">int *</code>符合<code class="calibre10">V*</code>，最终推导为<code class="calibre10">A&lt;int&gt;</code>。而对于<code class="calibre10">A a2(i, i);</code>，由于实参推导出来的不是指针类型，因此推导失败无法编译。同样，<code class="calibre10">A a3(&amp;i, &amp;d);</code>虽然符合实参推导结果为指针的要求，但是却违反了两个指针类型必须相同的规则，结果也是无法编译的。最后需要说明的是，到目前为止只有GCC对该特性做了支持。</p>

  <h2 id="OEBPS/Text/chapter038.html.nav_point_301" class="sigil_not_in_toc">38.5　聚合类型的类模板实参推导</h2>

  <p class="zw">除了上一节提到的别名模板，C++20标准还规定聚合类型也可以进行类模板的实参推导。例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T&gt;
struct S {
  T x;
  T y;
};

S s1{ 1, 2 }; //编译成功 S&lt;int&gt;
S s2{ 1, 2u }; // 编译失败</code></pre>

  <p class="zw">编译器会根据初始化列表推导出模板实参，在上面的代码中，<code class="calibre10">S s1{ 1, 2 };</code>推导出的模板实参均为<code class="calibre10">int</code>类型，符合单一模板参数<code class="calibre10">T</code>，所以可以顺利编译。相反，<code class="calibre10">S s2{ 1, 2u };</code>由于初始化列表的两个元素推导出了不同的类型<code class="calibre10">int</code>和<code class="calibre10">unsigned int</code>，无法满足确定的模板参数<code class="calibre10">T</code>，因此编译失败。</p>

  <p class="zw">除了以上简单的聚合类型，嵌套聚合类型也可以进行类模板实参推导，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T, class U&gt;
struct X {
  S&lt;T&gt; s;
  U u;
  T t;
};

X x{ {1, 2}, 3u, 4 };</code></pre>

  <p class="zw">请注意，在上面的代码中模板形参<code class="calibre10">T</code>并不是被<code class="calibre10">{1, 2}</code>推导出来的，而是被初始化列表中最后一个元素<code class="calibre10">4</code>推导而来，<code class="calibre10">S&lt;T&gt; s;</code>不参与到模板实参的推导中。另外，如果显示指定<code class="calibre10">S&lt;T&gt;</code>的模板实参，则初始化列表的子括号可以忽略，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T, class U&gt;
struct X {
  S&lt;int&gt; s;
  U u;
  T t;
};

X x{ 1, 2, 3u, 4 };</code></pre>

  <p class="zw">以上这部分特性到目前为止只在GCC中实现。</p>

  <p class="zw">C++20标准还规定聚合类型中的数组也可以是推导对象，不过这部分特性至今还没有编译器实现，这里我们看一下提案文档的例子即可：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T, std::size_t N&gt;
struct A {
  T array[N];
};
A a{ {1, 2, 3} };

template &lt;typename T&gt;
struct B {
  T array[2];
};
B b = { 0, 1 };</code></pre>

  <p class="zw">在上面的代码中，类模板<code class="calibre10">A</code>需要推导数组类型和数组大小，根据初始化列表<code class="calibre10">array</code>被推导为<code class="calibre10">int array[3]</code>，注意，这里初始化列表中的子括号是必须存在的。而对于类模板<code class="calibre10">B</code>而言，数组大小是确定的，编译器只需要推导数组类型，这时候可以省略初始化列表中的子括号。</p>

  <h2 id="OEBPS/Text/chapter038.html.nav_point_302" class="sigil_not_in_toc">38.6　总结</h2>

  <p class="zw">本章主要介绍了类模板的模板实参推导，该特性让类模板可以像函数模板一样通过构造函数调用的实参推导出模板形参，比如，从前需要调用<code class="calibre10">std::make_pair</code>、<code class="calibre10">std::make_tuple</code>让编译器帮助我们推导<code class="calibre10">pair</code>和<code class="calibre10">tuple</code>的具体类型，现在已经可以直接初始化构造了，这让使用类模板的体验更好。另外，对于是否有必要用此方法替代<code class="calibre10">std::make_xxx</code>这一系列函数，我认为在现代编译器优化技术的保证下<code class="calibre10">std::make_xxx</code>一类函数并不会产生额外的开销，所以继续使用<code class="calibre10">std::make_xxx</code>这类函数能够给代码带来更大的兼容性。而对于没有历史包袱的项目而言，直接使用类模板的模板实参推导显然会让代码看起来更加简洁清晰。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter038.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter039.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter039.html.nav_point_303" class="not-in-toc">第39章　用户自定义推导指引（C++17）</h1>

  <h2 id="OEBPS/Text/chapter039.html.nav_point_304" class="sigil_not_in_toc">39.1　使用自定义推导指引推导模板实例</h2>

  <p class="zw">在第38章中，我们了解了一些关于类模板的模板实参推导的内容。不过，在介绍这部分内容的过程中我省略了一个重要的问题，为了解释这个问题我们首先需要实现一个自己的<code class="calibre10">std::pair</code>，由于标准库的<code class="calibre10">std::pair</code>比较烦琐，因此下面实现了一个精简版：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;typename T1, typename T2&gt;
struct MyPair {
  MyPair(const T1&amp; x, const T2&amp; y) 
      : first(x), second(y) {}
  T1 first;
  T2 second;
};</code></pre>

  <p class="zw">这份代码虽然非常简单，但已经能满足基本的要求。接下来，我们利用类模板的模板实参推导来实例化这个模板：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">MyPair p(5, 11.7);</code></pre>

  <p class="zw">代码顺利地通过编译，没有任何问题。我们再对代码做一点修改：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">MyPair p1(5, "hello");</code></pre>

  <p class="zw">编译出错了，编译器提示<code class="calibre10">T2</code>是一个<code class="calibre10">char [6]</code>类型。这一点和我们预测的结果有所不同，要知道使用<code class="calibre10">std::pair</code>或者<code class="calibre10">std::make_pair</code>推导出的<code class="calibre10">T2</code>都是<code class="calibre10">const char *</code>类型：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">auto p3 = std::make_pair(5, "hello");      // T2 = const char*
std::pair p4(5, "hello");                  // T2 = const char*</code></pre>

  <p class="zw">为什么会出现这种情况呢？读者首先能想到的应该是“数组类型衰退为指针”。没错，原因就是这个。由于<code class="calibre10">std::pair</code>和<code class="calibre10">MyPair</code>构造函数的形参都是引用类型，因此从构造函数的角度它们都无法触发数组类型的衰退。但无论是<code class="calibre10">std::make_pair</code>还是<code class="calibre10">std::pair</code>，都有自己的办法让数组类型衰退为指针。对于<code class="calibre10">std::make_pair</code>来说，从C++11开始它使用<code class="calibre10">std::decay</code>主动让数组类型衰退为指针，而在C++11之前，它用传值的办法来达到让数组类型衰退为指针的目的。当然，我们可以仿造<code class="calibre10">std::make_pair</code>写出自己的<code class="calibre10">make_mypair</code>：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;typename T1, typename T2&gt;
inline MyPair&lt;T1, T2&gt;
make_mypair(T1 x, T2 y)
{
  return MyPair&lt;T1, T2&gt;(x, y);
}

auto p5 = make_mypair(5, "hello");</code></pre>

  <p class="zw">接下来的问题是<code class="calibre10">std::pair</code>如何让数组类型衰退？我们在<code class="calibre10">std::pair</code>的实现代码中并不能发现任何一个按值传参的构造函数。</p>

  <p class="zw">想解决上面的问题就需要用到用户自定义推导指引了。仔细阅读标准库会发现这么一句简单的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;typename _T1, typename _T2&gt; pair(_T1, _T2) -&gt; pair&lt;_T1, _T2&gt;;</code></pre>

  <p class="zw">这是一条典型的用户自定义推导指引，其中<code class="calibre10">template&lt;typename _T1, typename _T2&gt; pair</code>是类模板名，<code class="calibre10">(_T1, _T2)</code>是形参声明，<code class="calibre10">pair&lt;_T1, _T2&gt;</code>是指引的目标类型。它在语法上有点类似函数的返回类型后置，只不过以类名代替了函数名。用户自定义推导指引的目的是告诉编译器如何进行推导，比如这条语句，它告诉编译器直接推导按值传递的实参，更直观地说，编译器按照<code class="calibre10">pair(_T1, _T2)</code>的形式推导<code class="calibre10">std::pair p4(5, "hello")</code>，由于<code class="calibre10">_T2</code>并非引用，因此<code class="calibre10">_T2</code>推导出的是<code class="calibre10">"hello"</code>经过衰退后的<code class="calibre10">const char*</code>，编译器最终推导出的类型为<code class="calibre10">pair&lt;int, const char*&gt;</code>。虽然<code class="calibre10">std::pair</code>的代码中没有按值传参的构造函数，但是用户自定义推导指引强行让编译器进行了这种推导。值得注意的是，用户自定义推导指引并不会改变类模板本身的定义，只是在模板的推导阶段起到引导作用，也就是说<code class="calibre10">std::pair</code>中依旧不会存在按值传参的构造函数。</p>

  <p class="zw">了解了这些之后，接下来的事情就容易多了，我们只需要给<code class="calibre10">MyPair</code>加上一句类似的用户自定义推导指引即可：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;typename T1, typename T2&gt; MyPair(T1, T2)-&gt;MyPair&lt;T1, T2&gt;;
MyPair p6(5, "hello");</code></pre>

  <p class="zw">实际上，用户自定义推导指引的用途并不局限于以上这一种，我们可以根据实际需要来灵活使用，请看下面的例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::vector v{ 1, 5u, 3.0 };</code></pre>

  <p class="zw">以上代码的目的很简单，它希望将<code class="calibre10">1</code>、<code class="calibre10">5u</code>和<code class="calibre10">3.0</code>都装进<code class="calibre10">std::vector</code>类型的容器中，但是显然<code class="calibre10">std::vector</code>的容器是无法满足需求的，因为初始化元素的类型不同。为了让上述代码能够合法使用，添加用户自定义推导指引是一个不错的方案：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">namespace std {
  template&lt;class … T&gt; vector(T&amp;&amp;…t)-&gt;vector&lt;std::common_type_t&lt;T…&gt;&gt;;
}
std::vector v{ 1, 5u, 3.0 };</code></pre>

  <p class="zw">在这条用户自定义推导指引的作用下，编译器将<code class="calibre10">1</code>、<code class="calibre10">5u</code>和<code class="calibre10">3.0</code>的类型<code class="calibre10">int</code>、<code class="calibre10">unsigned int</code>和<code class="calibre10">double</code>交给<code class="calibre10">std::common_type_t</code>处理，并使用计算结果作为模板实参实例化类模板。最终<code class="calibre10">v</code>的类型为<code class="calibre10">std::vector&lt;double&gt;</code>。</p>

  <p class="zw">上面的两个例子用户自定义推导指引的对象都是模板，但事实上用户自定义推导指引不一定是模板，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">MyPair(int, const char*)-&gt;MyPair&lt;long long, std::string&gt;;
MyPair p7(5, "hello");</code></pre>

  <p class="zw">在上面这段代码中，<code class="calibre10">p7</code>的类型为<code class="calibre10">MyPair&lt;long long, std::string&gt;</code>，因为初始化列表中<code class="calibre10">5</code>和<code class="calibre10">hello</code>符合指引的形参声明，所以按照自定义的规则该类模板应该被实例化为<code class="calibre10">MyPair&lt;long long, std::string&gt;</code>。</p>

  <p class="zw">值得注意的是，在语法上用户自定义推导指引还支持<code class="calibre10">explicit</code>说明符，作用和其他使用场景类似，都是要求对象显式构造：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">explicit MyPair(int, const char*)-&gt;MyPair&lt;long long, std::string&gt;;

MyPair p7_1(5, "hello");
MyPair p7_2{ 5, "hello" };
MyPair p7_3 = { 5, "hello" };</code></pre>

  <p class="zw">在<code class="calibre10">explicit</code>说明符的作用下<code class="calibre10">p7_3</code>无法编译成功，这是因为<code class="calibre10">p7_3</code>并非显式构造，所以无法触发用户自定义推导指引。</p>

  <p class="zw">通过上述这些例子读者应该能看出来，用户自定义推导指引声明的前半部分就如同一个构造函数声明，这就引发了一个新的问题，当类模板的构造函数和用户自定义推导指引同时满足实例化要求的时候编译器是如何选择的？接下来，我对<code class="calibre10">MyPair</code>的构造函数进行了一些修改以解答这个问题：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;typename T1, typename T2&gt;
struct MyPair {
  MyPair(T1 x, T2 y)
      : first(x), second(y) {}
  T1 first;
  T2 second;
};

MyPair(int, const char*)-&gt;MyPair&lt;long long, std::string&gt;;

MyPair p8(5u, "hello");
MyPair p9(5, "hello");</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">MyPair</code>的构造函数的形参被修改为按值传递的方式。最终代码能够顺利地编译通过，但是编译器对<code class="calibre10">p8</code>和<code class="calibre10">p9</code>的处理方式却不相同，对于<code class="calibre10">p8</code>，编译器使用了默认的推导规则，其推导类型为<code class="calibre10">MyPair&lt;unsigned int, const char *&gt;</code>；而对<code class="calibre10">p9</code>，编译器使用了用户自定义的推导规则<code class="calibre10">MyPair&lt;long long, std::string&gt;</code>。由此可见，当类模板的构造函数和用户自定义推导指引同时满足实例化要求的时候，编译器优先选择用户自定义推导指引。</p>

  <h2 id="OEBPS/Text/chapter039.html.nav_point_305" class="sigil_not_in_toc">39.2　聚合类型类模板的推导指引</h2>

  <p class="zw">在C++20标准发布之前聚合类型的类模板是无法进行模板实参推导的，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T&gt;
struct Wrap {
  T data;
};

Wrap w1{ 7 };
Wrap w2 = { 7 };</code></pre>

  <p class="zw">在上面的代码中<code class="calibre10">w1</code>和<code class="calibre10">w2</code>都会编译报错，错误信息提示<code class="calibre10">w1</code>和<code class="calibre10">w2</code>的类型推导失败。为了让代码顺利地通过编译，一种方法是显式地指定模板实参：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">Wrap&lt;int&gt; w1{ 7 };
Wrap&lt;int&gt; w2 = { 7 };</code></pre>

  <p class="zw">另一种方法就是为类模板<code class="calibre10">Wrap</code>编写一条用户自定义推导指引：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T&gt; Wrap(T)-&gt;Wrap&lt;T&gt;;</code></pre>

  <p class="zw">当然，如果代码的编译环境是C++20标准，那么上面这条用户自定义推导指引就不是必需的了。</p>

  <h2 id="OEBPS/Text/chapter039.html.nav_point_306" class="sigil_not_in_toc">39.3　总结</h2>

  <p class="zw">以往C++程序员是无法控制模板的推导过程的，而本章介绍的用户自定义推导指引改变了这种情况。用户能够通过用户自定义推导指引指定编译器的推导结果，实例化出更多的实例。现在C++标准库中已经有越来越多的模块使用到了用户自定义推导指引，包括<code class="calibre10">std::pair</code>、<code class="calibre10">std::array</code>、<code class="calibre10">std::string</code>、<code class="calibre10">std::regex</code>等，读者可以通过搜索特性测试宏<code class="calibre10">__cpp_deduction_guides</code>来找到这些代码的位置。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter039.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter040.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter040.html.nav_point_307" class="not-in-toc">第40章　SFINAE（C++11）</h1>

  <h2 id="OEBPS/Text/chapter040.html.nav_point_308" class="sigil_not_in_toc">40.1　替换失败和编译错误</h2>

  <p class="zw">SFINAE（Substitution Failure Is Not An Error，替换失败不是错误）主要是指在函数模板重载时，当模板形参替换为指定的实参或由函数实参推导出模板形参的过程中出现了失败，则放弃这个重载而不是抛出一个编译失败。它是模板推导的一个特性，虽然在C++03标准中没有明确禁止它，但是那时该特性并没有在标准中明确规定哪些符合SFINAE，哪些应该抛出编译错误。这样，也就很少有编译器会支持它，毕竟这个特性的开发代价可不小。有一些看起来顺理成章的代码却是无法通过编译的。比如提案文档中的这个例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;int I&gt; struct X {};

char foo(int);
char foo(float);

template &lt;class T&gt; X&lt;sizeof(foo((T)0))&gt; f(T)
{
  return X&lt;sizeof(foo((T)0))&gt;();
}

int main()
{
  f(1);
}</code></pre>

  <p class="zw">上面的代码在不支持C++11的编译器上很有可能是无法成功编译的（请注意，该例子要使用GCC4.3之前的版本编译，因为GCC4.3已经逐步开始支持C++0x）。主要原因是编译器无法推导像<code class="calibre10">sizeof(foo((T)0))</code>这样的表达式。虽然在我们看来这是一个简单的表达式，但是要让编译器处理它可不容易，何况当时还没有明确的标准。这种情况明显地限制了C++ 模板的推导能力，所以在C++11标准中明确规范了SFINAE规则，可以发现上面的代码在任何一个支持C++11的编译器中都能顺利地编译通过。</p>

  <h2 id="OEBPS/Text/chapter040.html.nav_point_309" class="sigil_not_in_toc">40.2　SFINAE规则详解</h2>

  <p class="zw">在 SFINAE 规则中，模板形参的替换有两个时机，首先是在模板推导的最开始阶段，当明确地指定替换模板形参的实参时进行替换；其次在模板推导的最后，模板形参会根据实参进行推导或使用默认的模板实参。这个替换会覆盖到函数模板和模板形参中的所有类型和表达式。</p>

  <p class="zw">以上这些都由编译器处理完成，程序员不必追溯太多细节。对于程序员而言，需要清楚的是哪些情况符合替换失败，而哪些情况会引发编译错误。实际上最初在区分替换失败和编译错误的时候有许多模糊不清的地方，后来标准委员会发现定义编译错误比替换失败更加容易，所以他们提出了编译错误的情况，而剩下的就是替换失败。</p>

  <p class="zw">标准中规定，在直接上下文中使用模板实参替换形参后，类型或者表达式不符合语法，那么替换失败；而替换后在非直接上下文中产生的副作用导致的错误则被当作编译错误，这其中就包括以下几种。</p>

  <p class="zw">1．处理表达式外部某些实体时发生的错误，比如实例化某模板或生成某隐式定义的成员函数等。</p>

  <p class="zw">2．由于实现限制导致的错误，关于这一点可以理解为，虽然我们写出的可能是正确的代码，但是编译器实现上的限制造成了错误甚至编译器崩溃都被认为是编译错误。</p>

  <p class="zw">3．由于访问违规导致的错误。</p>

  <p class="zw">4．由于同一个函数的不同声明的词法顺序不同，导致替换顺序不同或者根本无法替换产生的错误。</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T&gt;
T foo(T&amp; t)
{
  T tt(t);
  return tt;
}

void foo(…) {}

int main()
{
  double x = 7.0;
  foo(x);
  foo(5);
}</code></pre>

  <p class="zw">在上面的代码中，编译器会将<code class="calibre10">foo(x)</code>调用的函数模板推导为<code class="calibre10">double foo(double&amp;)</code>，而且推导出来的函数是符合语法的。另外，编译器也会尝试用<code class="calibre10">template&lt;class T&gt; T foo(T&amp; t)</code>来推导<code class="calibre10">foo(5)</code>，但是编译器很快发现无论怎么推导都无法满足语法规则，所以编译器无奈之下只能产生一次替换失败并将这个调用交给<code class="calibre10">void foo(</code>…<code class="calibre10">)</code>。可以看到，这份代码虽然经历了一次替换失败，但是还是能编译成功。现在我们在保持<code class="calibre10">foo</code>函数定义不变的情况下，改变<code class="calibre10">foo</code>函数的实参，让代码产生一个编译错误：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class bar
{
public:
  bar() {};
  bar(bar&amp;&amp;) {};
};

int main()
{
  bar b;
  foo(b);
}</code></pre>

  <p class="zw">在上面的代码中，编译器会尝试用<code class="calibre10">template&lt;class T&gt; T foo(T&amp; t)</code>来推导<code class="calibre10">foo(b)</code>，其结果为<code class="calibre10">bar foo(bar&amp;)</code>。请注意，这里在直接上下文中最终的替换结果是符合语法规范的，所以它并不会引发替换失败，更加不会让编译器调用<code class="calibre10">void foo(</code>…<code class="calibre10">)</code>，这个时候的编译器坚信这样替换是准确无误的。但问题是当替换完成并且进行下一步的编译工作时，编译器发现<code class="calibre10">bar</code>这个类根本无法生成隐式的复制构造函数，想使用替换失败为时已晚，只能抛出一个编译错误。继续看下面一条编译错误的例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T&gt;
T foo(T*)
{
  return T();
}

void foo(…) {}

class bar 
{
  bar() {};
};

int main()
{
  foo(static_cast&lt;bar *&gt;(nullptr));
}</code></pre>

  <p class="zw">上面的代码会编译报错，原因和上一个例子有些不同，这里的原因是访问违规。不过整体的推导过程非常相似，首先编译器会尝试用<code class="calibre10">template&lt;class T&gt; T foo(T*)</code>来推导<code class="calibre10">foo(static_cast&lt;bar *&gt;(nullptr))</code>，其结果为<code class="calibre10">bar foo(bar*)</code>，同样，这里的替换结果也符合语法规范，所以编译器顺利地进行下面的编译。但是由于类<code class="calibre10">bar</code>的构造函数是一个私有函数，以至于<code class="calibre10">foo</code>函数无法构造它，因此就造成了编译错误。最后，下面的例子展示了多个词法顺序不同的声明导致函数替换编译错误的情况：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T&gt; struct A { using X = typename T::X; };
template &lt;class T&gt; typename T::X foo(typename A&lt;T&gt;::X);
template &lt;class T&gt; void foo(…) { }
template &lt;class T&gt; auto bar(typename A&lt;T&gt;::X) -&gt; typename T::X;
template &lt;class T&gt; void bar(…) { }

int main()
{
  foo&lt;int&gt;(0);
  bar&lt;int&gt;(0);
}</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">foo&lt;int&gt;(0)</code>可以编译通过，<code class="calibre10">bar&lt;int&gt;(0)</code>则不行。因为在<code class="calibre10">foo&lt;int&gt; (0)</code>中<code class="calibre10">T::X</code>并不符合语法规范且这是一个直接上下文环境，所以在模板替换的时候会发生替换失败，最后使用<code class="calibre10">template &lt;class T&gt; void foo(</code>…<code class="calibre10">)</code>的函数版本。但是<code class="calibre10">bar&lt;int&gt;(0)</code>和<code class="calibre10">foo&lt;int&gt;(0)</code>不同，它的模板声明方法是一个返回类型后置，这样在推导和替换的时候会优先处理形参。而参数类型<code class="calibre10">A&lt;int&gt;::X</code>实例化了一个模板，它不是一个直接上下文环境，所以不会产生替换失败，编译器也就不会尝试重载另外一个<code class="calibre10">bar</code>的声明从而导致编译错误。</p>

  <p class="zw">到此为止我们花了很大篇幅来叙述替换导致编译错误，却很少提及SFINAE规则的用法，原因之前也提到过，但是这里有必要再重申一次：除了上述会导致编译错误的情况外，其他的错误均是替换失败。明确了编译错误的条件后，我们就可以自由地使用SFINAE规则了：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">struct X {};
struct Y { Y(X) {} }; // X 可以转化为 Y

X foo(Y, Y) { return X(); }

template &lt;class T&gt;
auto foo(T t1, T t2) -&gt; decltype(t1 + t2) {
  return t1 + t2;
}

int main()
{
  X x1, x2;
  X x3 = foo(x1, x2);
}</code></pre>

  <p class="zw">上面的代码是标准文档中的一个例子，在这个例子中<code class="calibre10">foo(x1, x2)</code>会优先使用<code class="calibre10">auto foo(T t1, T t2) -&gt; decltype(t1 + t2)</code>来推导，不过很明显，<code class="calibre10">x1 + x2</code>不符合语法规范，所以编译器产生一个替换失败继而使用重载的版本<code class="calibre10">X foo(Y, Y)</code>，而这个版本形参<code class="calibre10">Y</code>正好能由<code class="calibre10">X</code>转换得到，于是编译成功。再来看一个非类型替换的SFINAE例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

template &lt;int I&gt; void foo(char(*)[I % 2 == 0] = 0) {
  std::cout &lt;&lt; "I % 2 == 0" &lt;&lt; std::endl;
}
template &lt;int I&gt; void foo(char(*)[I % 2 == 1] = 0) {
  std::cout &lt;&lt; "I % 2 == 1" &lt;&lt; std::endl;
}

int main()
{
  char a[1];
  foo&lt;1&gt;(&amp;a);
  foo&lt;2&gt;(&amp;a);
  foo&lt;3&gt;(&amp;a);
}</code></pre>

  <p class="zw">在上面的代码中，函数模板<code class="calibre10">foo</code>针对<code class="calibre10">int</code>类型模板形参的奇偶性重载了两个声明。当模板实参满足条件<code class="calibre10">I % 2 == 0</code>或<code class="calibre10">I % 2 == 1</code>时，会替换出一个数量为<code class="calibre10">1</code>的<code class="calibre10">char</code>类型的数组指针<code class="calibre10">char(*)[1]</code>，这是符合语法规范的，相反，不满足条件时替换的形参为<code class="calibre10">char(*)[0]</code>，很明显这将产生一个替换失败。最终我们看到的结果是，编译器根据实参的奇偶性选择替换后语法正确的函数版本进行调用：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">I % 2 == 1
I % 2 == 0
I % 2 == 1</code></pre>

  <p class="zw">上面的两个例子非常简单，无法体现出SFINAE的实际价值，下面让我们结合<code class="calibre10">decltype</code>关键字来看一看SFINAE是怎么在实际代码中发挥作用的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

class SomeObj1 {
public:
  void Dump2File() const
  {
        std::cout &lt;&lt; "dump this object to file" &lt;&lt; std::endl;
  }
};

class SomeObj2 {
};

template&lt;class T&gt;
auto DumpObj(const T &amp;t)-&gt;decltype(((void)t.Dump2File()), void())
{
  t.Dump2File();
}

void DumpObj(…)
{
  std::cout &lt;&lt; "the object must have a member function Dump2File" &lt;&lt; std::endl;
}

int main()
{
  DumpObj(SomeObj1());
  DumpObj(SomeObj2());
}</code></pre>

  <p class="zw">以上代码的意图是检查对象类型是否有成员函数<code class="calibre10">Dump2File</code>，如果存在，则调用该函数；反之则输出警告信息。为了完成这样的功能，我们需要用到返回类型后置以及<code class="calibre10">decltype</code>关键字。之所以要用到返回类型后置的方法是因为这里需要参数先被替换，再根据参数推导返回值类型。而使用<code class="calibre10">decltype</code>关键字有两个目的，第一个目的当然是设置函数的返回值了，第二个目的是判断实参类型是否具有<code class="calibre10">Dump2File</code>成员函数。请注意这里的写法<code class="calibre10">decltype(((void)t.Dump2File()), void())</code>，在括号里利用逗号表达式让编译器从左往右进行替换和推导，逗号右边的是最终我们想设置的函数返回值类型，而逗号左边则检查了对象t的类型是否具有<code class="calibre10">Dump2File</code>成员函数。如果成员函数存在，即符合语法规则，可以顺利地调用模板版本的函数；反之则产生替换失败，调用另一个重载版本的<code class="calibre10">DumpObj</code>函数。于是以上代码的最终输出结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">dump this object to file
the object must have a member function Dump2File</code></pre>

  <p class="zw">如果我们继续发散一下上面采用的方法，就会发现该方法不仅能用在无参数的成员函数上，对于有参数的成员函数同样适用。至于具体怎么改进，这就留给读者自由发挥吧。</p>

  <h2 id="OEBPS/Text/chapter040.html.nav_point_310" class="sigil_not_in_toc">40.3　总结</h2>

  <p class="zw">虽然SFINAE的概念和规则描述起来多少有点复杂，但是我们发现其使用起来却十分自然，编译器基本上能按照我们预想的步骤进行编译。正如例子中看到的，SFINAE的引入使模板匹配更加精准，它能让某些实参享受特殊待遇的函数版本，让剩下的一部分使用通用的函数版本，毫无疑问，这样的特性对于C++的泛型能力来说是一个很大的增强。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter040.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter041.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter041.html.nav_point_311" class="not-in-toc">第41章　概念和约束（C++20）</h1>

  <h2 id="OEBPS/Text/chapter041.html.nav_point_312" class="sigil_not_in_toc">41.1　使用std::enable_if约束模板</h2>

  <p class="zw">在第40章中我们探讨了SFINAE规则，即替换失败不是错误。对于SFINAE规则，一个典型的应用就是标准库中的<code class="calibre10">std::enable_if</code>模板元函数，SFINAE规则使该模板元函数能辅助模板的开发者限定实例化模板的模板实参类型，举例来说：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T, class U = std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;&gt;
struct X {};

X&lt;int&gt; x1; // 编译成功
X&lt;std::string&gt; x2; // 编译失败</code></pre>

  <p class="zw">在上面的代码中，类模板<code class="calibre10">X</code>的模板形参<code class="calibre10">class U = std::enable_if_t　&lt;std::is_integral_v&lt;T&gt;&gt;</code>只是作为一个约束条件存在，当<code class="calibre10">T</code>的类型为整型时，<code class="calibre10">std::is_integral_v &lt;T&gt;</code>返回<code class="calibre10">true</code>，于是<code class="calibre10">std::enable_if_t&lt;std::is_ integral_v&lt;T&gt;&gt;</code>返回类型<code class="calibre10">void</code>，所以<code class="calibre10">X&lt;int&gt;</code>实际上是<code class="calibre10">X&lt;int, void&gt;</code>的一个合法类型。反之，对于<code class="calibre10">X&lt;std::string&gt;</code>来说，<code class="calibre10">T</code>的类型不为整型，<code class="calibre10">std:: enable_if</code>不存在嵌套类型<code class="calibre10">type</code>，于是<code class="calibre10">std::enable_if_t&lt;std::is_ integral_v&lt;T&gt;&gt;</code>无法符合语法规范，导致编译失败。</p>

  <p class="zw">以下是<code class="calibre10">enable_if</code>的一种实现方法：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;bool B, class T = void&gt;
struct enable_if {};

template&lt;class T&gt;
struct enable_if&lt;true, T&gt; { using type = T; };</code></pre>

  <p class="zw">可以看到<code class="calibre10">enable_if</code>的实现十分简单，而让它发挥如此大作用的幕后功臣就是SFINAE规则。不过使用<code class="calibre10">std::enable_if</code>作为模板实参约束也有一些硬伤，比如使用范围窄，需要加入额外的模板形参等。于是为了更好地对模板进行约束，C++20标准引入了概念（concept）。</p>

  <h2 id="OEBPS/Text/chapter041.html.nav_point_313" class="sigil_not_in_toc">41.2　概念的背景介绍</h2>

  <p class="zw">概念是对C++核心语言特性中模板功能的扩展。它在编译时进行评估，对类模板、函数模板以及类模板的成员函数进行约束：它限制了能被接受为模板形参的实参集。</p>

  <p class="zw">实际上概念并不是新鲜的特性，早在2008年“概念”已经被C++0x接受，只不过在2009年7月的法兰克福C++标准委员会会议上，通过投票表决删除了C++0x中的“概念”，原因是委员会需要限制新语法规则带来的风险并保证标准的实现进度。虽然在当时对于大多数程序员的影响不大，但是对于研究和意识到该特性的潜力的人来说确实是非常令人失望的。</p>

  <p class="zw">“概念”最早的实现要追溯到2016年的GCC6.1，在GCC6.1中我们可以使用-fconcepts开关来开启“概念”实验性特性，当时我们称其为“Concept TS”（Concepts Technical Specification）。但即使已经实现了“概念”特性，也没让它进入C++17标准，原因简单来说就是“还不够好”。就这样一直到2017的多伦多C++标准委员会会议，新的概念功能特性才被正式列入C++20标准中。</p>

  <p class="zw">所以在C++20中，上一节的例子可以改写为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class C&gt;
concept IntegerType = std::is_integral_v&lt;C&gt;;

template &lt;IntegerType T&gt;
struct X {};</code></pre>

  <p class="zw">上面的代码使用<code class="calibre10">concept</code>关键字定义了模板形参<code class="calibre10">T</code>的约束条件<code class="calibre10">IntegerType</code>，模板实参替换<code class="calibre10">T</code>之后必须满足<code class="calibre10">std::is_integral_v&lt;C&gt;</code>计算结果为<code class="calibre10">true</code>的条件，否则编译器会给出<code class="calibre10">IntegerType</code>约束失败的错误提示。这份代码还可以简化为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T&gt;
requires std::is_integral_v&lt;T&gt;
struct X {};</code></pre>

  <p class="zw"><code class="calibre10">requires</code>关键字可以直接约束模板形参<code class="calibre10">T</code>，从而达到相同的效果。<code class="calibre10">concept</code>和<code class="calibre10">requires</code>的详细用法将在后面的章节中讨论。现在我想让大家看一看用概念约束模板的另外一个优势，请对比下面的编译错误日志：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::enable_if:
In substitution of 'template&lt;bool _Cond, class _Tp&gt; using enable_if_t =    typename std::enable_if::type [with bool _Cond = false; _Tp = void]':
required from here
error: no type named 'type' in 'struct std::enable_if&lt;false, void&gt;'
 2554 |     using enable_if_t = typename enable_if&lt;_Cond, _Tp&gt;::type;
-------------------------------------------------------------------------------------
concept:
error: template constraint failure for 'template&lt;class T&gt;  requires  IntegerType&lt;T&gt; struct X'</code></pre>

  <p class="zw">显然，使用<code class="calibre10">concept</code>代码的错误日志更加简洁清晰，在错误日志中明确地提示用户<code class="calibre10">struct X</code>模板约束失败。</p>

  <h2 id="OEBPS/Text/chapter041.html.nav_point_314" class="sigil_not_in_toc">41.3　使用concept和约束表达式定义概念</h2>

  <p class="zw">我们可以使用<code class="calibre10">concept</code>关键字来定义概念，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class C&gt;
concept IntegerType = std::is_integral_v&lt;C&gt;;</code></pre>

  <p class="zw">其中<code class="calibre10">IntegerType</code>是概念名，这里的<code class="calibre10">std::is_integral_v&lt;C&gt;</code>称为约束表达式。</p>

  <p class="zw">约束表达式应该是一个<code class="calibre10">bool</code>类型的纯右值常量表达式，当实参替换形参后，如果表达式计算结果为<code class="calibre10">true</code>，那么该实参满足约束条件，概念的计算结果为<code class="calibre10">true</code>。反之，在实参替换形参后，如果表达式计算结果为<code class="calibre10">false</code>或者替换结果不合法，则该实参无法满足约束条件，概念的计算结果为<code class="calibre10">false</code>。</p>

  <p class="zw">请注意，这里所谓的计算都是编译期执行的，概念的最终结果是一个<code class="calibre10">bool</code>类型的纯右值：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T&gt; concept TestConcept = true;
static_assert(TestConcept&lt;int&gt;);</code></pre>

  <p class="zw">通过上面的代码可以看出，<code class="calibre10">TestConcept&lt;int&gt;</code>是一个<code class="calibre10">bool</code>类型的常量表达式，因为它能够作为<code class="calibre10">static_assert</code>的实参。</p>

  <p class="zw">约束表达式还支持一般的逻辑操作，包括合取和析取：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">// 合取
template &lt;class C&gt;
concept SignedIntegerType = std::is_integral_v&lt;C&gt; &amp;&amp; std::is_signed_v&lt;C&gt;;

// 析取
template &lt;class C&gt;
concept IntegerFloatingType = std::is_integral_v&lt;C&gt; || std::is_floating_point_v&lt;C&gt;;</code></pre>

  <p class="zw">观察上面的代码可知，约束的合取是通过逻辑与<code class="calibre10">&amp;&amp;</code>完成的，运算规则也与逻辑与相同，要求两个约束都为<code class="calibre10">true</code>，整个约束表达式才会为<code class="calibre10">true</code>，当左侧约束为<code class="calibre10">false</code>时，整个约束表达式遵循短路原则为<code class="calibre10">false</code>。同样，约束的析取是通过逻辑或||完成的，运算规则与逻辑或相同，只要任意约束为<code class="calibre10">true</code>，整个约束表达式就会为<code class="calibre10">true</code>，当左侧约束为<code class="calibre10">true</code>时，整个约束表达式遵循短路原则为<code class="calibre10">true</code>。让我们尝试用上面的两个概念约束模板实参：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;SignedIntegerType T&gt;
struct X {};

template &lt;IntegerFloatingType T&gt;
struct Y {};

X&lt;int&gt; x1;                // 编译成功
X&lt;unsigned int&gt; x2;       // 编译失败

Y&lt;int&gt; y1;                // 编译成功
Y&lt;double&gt; y2;             // 编译成功</code></pre>

  <p class="zw">在上面的代码中，只有<code class="calibre10">x2</code>会编译失败，因为<code class="calibre10">X</code>的模板形参的约束条件是一个有符号整型。</p>

  <p class="zw">除了逻辑操作的合取和析取之外，约束表达式还有一种特殊情况叫作原子约束，很明显原子约束中的表达式不能存在约束的合取或者析取。由于原子约束概念解释起来比较晦涩，而且需要配合<code class="calibre10">requires</code>子句示例做解释，因此将在后面详细讨论。</p>

  <h2 id="OEBPS/Text/chapter041.html.nav_point_315" class="sigil_not_in_toc">41.4　requires子句和约束检查顺序</h2>

  <p class="zw">除了使用<code class="calibre10">concept</code>关键字来定义概念，我们还可以使用<code class="calibre10">requires</code>子句直接约束模板实参，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T&gt;
requires std::is_integral_v&lt;T&gt; &amp;&amp; std::is_signed_v&lt;C&gt;
struct X {};</code></pre>

  <p class="zw">上面的代码同样能够限制类模板<code class="calibre10">X</code>的模板实参必须为有符号整型类型，其中<code class="calibre10">requires</code>紧跟的<code class="calibre10">std::is_integral_v&lt;T&gt;&amp;&amp; std::is_signed_v&lt;C&gt;</code>必须是一个类型为<code class="calibre10">bool</code>的常量表达式。<code class="calibre10">requires</code>子句对于该常量表达式还有一些额外的要求。</p>

  <p class="zw">1．是一个初等表达式或带括号的任意表达式。例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">constexpr bool bar() { return true; }

template &lt;class T&gt;
requires bar()
struct X {};</code></pre>

  <p class="zw">由于这里的<code class="calibre10">bar()</code>不是初等表达式，不符合语法规则，因此编译失败，需要修改为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">constexpr bool bar() { return true; }

template &lt;class T&gt;
requires (bar())
struct X {};</code></pre>

  <p class="zw">2．使用<code class="calibre10">&amp;&amp;</code>或者<code class="calibre10">||</code>运算符链接上述表达式：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">constexpr bool bar() { return true; }

template &lt;class T&gt;
requires (bar()) &amp;&amp; true || false
struct X {};</code></pre>

  <p class="zw"><code class="calibre10">requires</code>子句除了能出现在模板形参列表尾部，还可以出现在函数模板声明尾部，所以下面的用法都是正确的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T&gt; requires std::is_integral_v&lt;T&gt;
void foo();

template &lt;class T&gt;
void foo() requires std::is_integral_v&lt;T&gt;;</code></pre>

  <p class="zw">约束模板实参的方法很多，那么现在就有一个问题摆在我们面前——当一个模板同时具备多种约束时，如何确定优先级，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class C&gt;
concept ConstType = std::is_const_v&lt;C&gt;;

template &lt;class C&gt;
concept IntegralType = std::is_integral_v&lt;C&gt;;

template &lt;ConstType T&gt;
requires std::is_pointer_v&lt;T&gt;
void foo(IntegralType auto) requires std::is_same_v&lt;T, char * const&gt; {}</code></pre>

  <p class="zw">上面的代码分别使用概念<code class="calibre10">ConstType</code>、模板形参列表尾部<code class="calibre10">requires std:: is_pointer_v &lt;T&gt;</code>和函数模板声明尾部<code class="calibre10">requires std::is_ integral_v&lt;T&gt;</code>来约束模板实参，还使用概念<code class="calibre10">IntegralType</code>约束了<code class="calibre10">auto</code>占位符类型的函数形参。对于函数模板调用：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">foo&lt;int&gt;(1.5);</code></pre>

  <p class="zw">编译器究竟应该用什么顺序检查约束条件呢？事实上，标准文档给出了明确的答案，编译器应该按照以下顺序检查各个约束条件。</p>

  <p class="zw">1．模板形参列表中的形参的约束表达式，其中检查顺序就是形参出现的顺序。也就是说使用<code class="calibre10">concept</code>定义的概念约束的形参会被优先检查，放到刚刚的例子中<code class="calibre10">foo&lt;int&gt;();</code>最先不符合的是<code class="calibre10">ConstType</code>的约束表达式<code class="calibre10">std::is_const_v&lt;C&gt;</code>。</p>

  <p class="zw">2．模板形参列表之后的<code class="calibre10">requires</code>子句中的约束表达式。这意味着，如果<code class="calibre10">foo</code>的模板实参通过了前一个约束检查后将会面临<code class="calibre10">std::is_pointer_v&lt;T&gt;</code>的检查。</p>

  <p class="zw">3．简写函数模板声明中每个拥有受约束<code class="calibre10">auto</code>占位符类型的形参所引入的约束表达式。还是放到例子中看，如果前两个约束条件已经满足，编译器则会检查函数实参是否满足<code class="calibre10">IntegralType</code>的约束。</p>

  <p class="zw">4．函数模板声明尾部<code class="calibre10">requires</code>子句中的约束表达式。所以例子中最后检查的是<code class="calibre10">std::is_same_v&lt;T, char * const&gt;</code>。</p>

  <p class="zw">为了更好地理解约束的检查顺序，让我们来分别编译以下5句代码，看一看编译器输出日志（以GCC为例）：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">foo&lt;int&gt;(1.5);
foo&lt;const int&gt;(1.5);
foo&lt;int * const&gt;(1.5);
foo&lt;int * const&gt;(1);
foo&lt;char * const&gt;(1);</code></pre>

  <p class="zw">　　对于<code class="calibre10">foo&lt;int&gt;(1.5);</code>，不满足所有约束条件，编译器报错提示不满足<code class="calibre10">ConstType&lt;T&gt;</code>的约束。</p>

  <p class="zw">　　对于<code class="calibre10">foo&lt;const int&gt;(1.5);</code>，满足<code class="calibre10">ConstType&lt;T&gt;</code>，但是不满足其他条件，编译器报错提示不满足<code class="calibre10">std::is_pointer_v&lt;T&gt;</code>的约束。</p>

  <p class="zw">　　对于<code class="calibre10">foo&lt;int * const&gt;(1.5);</code>，满足前两个条件，但是不满足其他条件，编译器报错提示不满足<code class="calibre10">IntegralType&lt;auto&gt;</code>的约束。</p>

  <p class="zw">　　对于<code class="calibre10">foo&lt;int * const&gt;(1);</code>，满足前3个条件，但是不满足其他条件，编译器报错提示不满足<code class="calibre10">std::is_same_v&lt;T, char * const&gt;</code>的约束。</p>

  <p class="zw">　　<code class="calibre10">foo&lt;char * const&gt;(1);</code>满足所有条件，编译成功。</p>

  <h2 id="OEBPS/Text/chapter041.html.nav_point_316" class="sigil_not_in_toc">41.5　原子约束</h2>

  <p class="zw">现在让我们回头看一看什么是原子约束。原子约束是表达式和表达式中模板形参到模板实参映射的组合（简称为形参映射）。比较两个原子约束是否相同的方法很特殊，除了比较代码上是否有相同的表现，还需要比较形参映射是否相同，也就是说功能上相同的原子约束可能是不同的原子约束，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;int N&gt; constexpr bool Atomic = true;
template &lt;int N&gt; concept C = Atomic&lt;N&gt;;
template &lt;int N&gt; concept Add1 = C&lt;N + 1&gt;;
template &lt;int N&gt; concept AddOne = C&lt;N + 1&gt;;
template &lt;int M&gt; void f()
requires Add1&lt;2 * M&gt; {};
template &lt;int M&gt; void f()
requires AddOne&lt;2 * M&gt; &amp;&amp; true {};

f&lt;0&gt;(); // 编译成功</code></pre>

  <p class="zw">在上面的代码中，虽然概念<code class="calibre10">Add1</code>和<code class="calibre10">AddOne</code>使用了不同的名称，但是实际上是相同的，因为在这两个函数中概念<code class="calibre10">C</code>的原子约束都是<code class="calibre10">Atomic&lt;N&gt;</code>，其形参映射都为<code class="calibre10">N～2 * M + 1</code>。在两个函数都符合约束的情况下，编译器会选择约束更为复杂的<code class="calibre10">requires AddOne&lt;2 * M&gt; &amp;&amp; true</code>作为目标函数，因为<code class="calibre10">AddOne&lt;2 * M&gt; &amp;&amp; true</code>包含了<code class="calibre10">AddOne&lt;2 * M&gt;</code>。接下来让我们把形参映射改变一下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;int N&gt; void f2()
requires Add1&lt;2 * N&gt; {};
template &lt;int N&gt; void f2()
requires Add1&lt;N * 2&gt; &amp;&amp; true {};

f2&lt;0&gt;(); // 编译失败</code></pre>

  <p class="zw">上面的代码无法通过编译，虽然都是用了概念<code class="calibre10">Add1</code>，但是它们的形参映射不同，分别为<code class="calibre10">2 * N + 1</code>和<code class="calibre10">N * 2 + 1</code>，所以<code class="calibre10">Add1&lt;N * 2&gt; &amp;&amp; true</code>并不能包含<code class="calibre10">Add1　&lt;2 * N&gt;</code>，而对于<code class="calibre10">f2&lt;0&gt;();</code>而言，两个<code class="calibre10">f2</code>函数模板都满足约束，这里的二义性让编译器不知所措，导致编译失败。当然，如果将<code class="calibre10">requires Add1&lt;N * 2&gt; &amp;&amp; true</code>中的<code class="calibre10">true</code>改为<code class="calibre10">false</code>，就不会产生二义性，可以顺利地通过编译。</p>

  <p class="zw">当约束表达式中存在原子约束时，如果约束表达式结果相同，则约束表达式应该是相同的，否则会导致编译失败，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T&gt; concept sad = false;
template &lt;class T&gt; int f1(T) requires (!sad&lt;T&gt;) { return 1; };
template &lt;class T&gt; int f1(T) requires (!sad&lt;T&gt;) &amp;&amp; true {return 2; };

f1(0); // 编译失败</code></pre>

  <p class="zw">需要注意的是，逻辑否定表达式是一个原子约束。所以以上代码会产生二义性，原子约束表达式<code class="calibre10">!sad&lt;T&gt;</code>并不来自相同的约束表达式。为了让代码能成功编译，需要修改代码为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T&gt; concept not_sad = !sad&lt;T&gt;;
template &lt;class T&gt; int f2(T) requires (not_sad&lt;T&gt;) { return 3; };
template &lt;class T&gt; int f2(T) requires (not_sad&lt;T&gt;) &amp;&amp; true  { return 4; };

f2(0);</code></pre>

  <p class="zw">这样一来，原子约束表达式<code class="calibre10">!sad&lt;T&gt;</code>都来自概念<code class="calibre10">not_sad</code>。另外，因为<code class="calibre10">(not_sad&lt;T&gt;) &amp;&amp; true</code>包含了<code class="calibre10">not_sad&lt;T&gt;</code>，所以编译器选取约束表达式为<code class="calibre10">requires (not_sad&lt;T&gt;) &amp;&amp; true</code>的函数模板进行编译，最终函数返回4。再进一步：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T&gt; int f3(T) requires (not_sad&lt;T&gt; == true) { return 5; };
template &lt;class T&gt; int f3(T) requires (not_sad&lt;T&gt; == true) &amp;&amp; true  { return 6; };

f3(0);

template &lt;class T&gt; concept not_sad_is_true = !sad&lt;T&gt; == true;
template &lt;class T&gt; int f4(T) requires (not_sad_is_true&lt;T&gt;) { return 7; };
template &lt;class T&gt; int f4(T) requires (not_sad_is_true&lt;T&gt;) &amp;&amp; true  { return 8; };

f4(0);</code></pre>

  <p class="zw">同样的理由，<code class="calibre10">f3(0);</code>会因为二义性无法通过编译，而<code class="calibre10">f4(0)</code>可以编译成功并最后返回8。</p>

  <h2 id="OEBPS/Text/chapter041.html.nav_point_317" class="sigil_not_in_toc">41.6　requires表达式</h2>

  <p class="zw"><code class="calibre10">requires</code>关键字除了可以引入<code class="calibre10">requires</code>子句，还可以用来定义一个<code class="calibre10">requires</code>表达式，该表达式同样是一个纯右值表达式，表达式为<code class="calibre10">true</code>时表示满足约束条件，反之<code class="calibre10">false</code>表示不满足约束条件。需要特别说明的是<code class="calibre10">requires</code>表达式的判定标准，因为这个标准比较特殊，具体来说是对<code class="calibre10">requires</code>表达式进行模板实参的替换，如果替换之后<code class="calibre10">requires</code>表达式中出现无效类型或者表达式违反约束条件，则<code class="calibre10">requires</code>表达式求值为<code class="calibre10">false</code>，反之则<code class="calibre10">requires</code>表达式求值为<code class="calibre10">true</code>。例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T&gt;
concept Check = requires {
  T().clear();
};

template &lt;Check T&gt;
struct G {};

G&lt;std::vector&lt;char&gt;&gt; x;      // 编译成功
G&lt;std::string&gt; y;            // 编译成功
G&lt;std::array&lt;char, 10&gt;&gt; z;   // 编译失败</code></pre>

  <p class="zw">上面的代码使用<code class="calibre10">requires</code>表达式定义了概念<code class="calibre10">Check</code>，<code class="calibre10">Check</code>要求<code class="calibre10">T().clear();</code>是一个合法的表达式。因此<code class="calibre10">G&lt;std::vector&lt;char&gt;&gt; x;</code>和<code class="calibre10">G&lt;std::string&gt; y;</code>可以顺利通过编译，因为<code class="calibre10">std::vector&lt;char&gt;</code>和<code class="calibre10">std::string</code>都有成员函数<code class="calibre10">clear()</code>。而<code class="calibre10">std::array&lt;char, 10&gt;</code>中不存在成员函数<code class="calibre10">clear()</code>，导致编译失败。</p>

  <p class="zw">值得注意的是，<code class="calibre10">requires</code>表达式还支持形参列表，使用形参列表可以使<code class="calibre10">requires</code>表达式更加灵活清晰，比如在上面的例子中，我希望除了要求实参具备成员函数<code class="calibre10">clear()</code>以外还需要支持+运算符，那么我们可以将代码修改为：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T&gt;
concept Check = requires {
  T().clear();
  T() + T();
};</code></pre>

  <p class="zw">以上代码可以完成检查<code class="calibre10">+</code>运算符的工作，但通常我们并不这样做，因为存在更加清晰的方式：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T&gt;
concept Check = requires(T a, T b) {
  a.clear();
  a + b;
};</code></pre>

  <p class="zw">在上面的代码中，我们使用了<code class="calibre10">requires</code>表达式的形参列表，形参列表和普通函数的形参列表类似，不同的是这些形参并不存在生命周期和存储方式，只在编译期起作用，而且只有在<code class="calibre10">requires</code>表达式作用域内才是有效的。自然的，对于需要运行时计算实参数量的不定参数列表来说，<code class="calibre10">requires</code>表达式的形参列表也是不支持的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;typename T&gt;
concept C = requires(T t, …) { // 编译失败，requires表达式的形参列表不能使用…
  t;
};</code></pre>

  <p class="zw">回过头来看经过修改的概念，<code class="calibre10">Check</code>会将<code class="calibre10">G&lt;std::vector&lt;char&gt;&gt; x;</code>拒之门外，因为<code class="calibre10">std::vector&lt;char&gt;</code>的实例是无法使用+运算符的。另外，由于<code class="calibre10">std::string</code>支持用+运算符完成字符串的连接，因此<code class="calibre10">G&lt;std::string&gt; y;</code>能够编译成功。</p>

  <p class="zw">在上面的<code class="calibre10">requires</code>表达式中，<code class="calibre10">a.clear()</code>和<code class="calibre10">a + b</code>可以说是对模板实参的两个要求，这些要求在C++标准中称为要求序列（requirement-seq）。要求序列分为4种，包括简单要求、类型要求、复合要求以及嵌套要求，接下来就让我们详细讨论这4种要求。</p>

  <h3 id="OEBPS/Text/chapter041.html.nav_point_318" class="sigil_not_in_toc1">41.6.1　简单要求</h3>

  <p class="zw">简单要求是不以<code class="calibre10">requires</code>关键字开始的要求，它只断言表达式的有效性，并不做表达式的求值操作。如果表达式替换模板实参失败，则该要求的计算结果为false：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;typename T&gt; concept C =
requires (T a, T b) {
  a + b;
};</code></pre>

  <p class="zw">在上面的代码中<code class="calibre10">a + b</code>是一个简单要求，编译器会断言<code class="calibre10">a + b</code>的合法性，但不会计算其最终结果。不以<code class="calibre10">requires</code>关键字开始是简单表达式的重要特征，后面将提到的嵌套要求则正好相反，它要求以<code class="calibre10">requires</code>关键字开头。</p>

  <h3 id="OEBPS/Text/chapter041.html.nav_point_319" class="sigil_not_in_toc1">41.6.2　类型要求</h3>

  <p class="zw">类型要求是以<code class="calibre10">typename</code>关键字开始的要求，紧跟<code class="calibre10">typename</code>的是一个类型名，通常可以用来检查嵌套类型、类模板以及别名模板特化的有效性。如果模板实参替换失败，则要求表达式的计算结果为<code class="calibre10">false</code>：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;typename T, typename T::type = 0&gt; struct S;
template&lt;typename T&gt; using Ref = T&amp;;
template&lt;typename T&gt; concept C = requires {
  typename T::inner;           // 要求嵌套类型
  typename S&lt;T&gt;;               // 要求类模板特化
  typename Ref&lt;T&gt;;             // 要求别名模板特化
};

template &lt;C c&gt;
struct M {};

struct H {
  using type = int;
  using inner = double;
};

M&lt;H&gt; m;</code></pre>

  <p class="zw">在上面的代码中，概念<code class="calibre10">C</code>中有3个类型要求，分别为<code class="calibre10">T::inner</code>、<code class="calibre10">S&lt;T&gt;</code>和<code class="calibre10">Ref&lt;T&gt;</code>，它们各自对应的是对嵌套类型、类模板特化和别名模板特化的检查。请注意代码中的类模板声明<code class="calibre10">S</code>，它不是一个完整类型，缺少了类模板定义。但是编译器仍然可以编译成功，因为标准明确指出类型要求中的命名类模板特化不需要该类型是完整的。</p>

  <h3 id="OEBPS/Text/chapter041.html.nav_point_320" class="sigil_not_in_toc1">41.6.3　复合要求</h3>

  <p class="zw">相对于简洁的简单要求和类型要求，复合要求则稍微复杂一些，比如下面的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T&gt;
concept Check = requires(T a, T b) {
  {a.clear()} noexcept;
  {a + b} noexcept -&gt; std::same_as&lt;int&gt;;
};</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">{a.clear()} noexcept;</code>和<code class="calibre10">{a + b} noexcept -&gt; std::same_as&lt;int&gt;;</code>是需要断言的复合要求。复合要求可以由3个部分组成：<code class="calibre10">{}</code>中的表达式、<code class="calibre10">noexcept</code>以及<code class="calibre10">-&gt;</code>后的返回类型约束，其中<code class="calibre10">noexcept</code>和<code class="calibre10">-&gt;</code>后的返回类型约束是可选的。根据标准，断言一个复合要求需要按照以下顺序。</p>

  <p class="zw">1．替换模板实参到<code class="calibre10">{E}</code>中的表达式<code class="calibre10">E</code>，检测表达式的有效性。</p>

  <p class="zw">2．如果使用了<code class="calibre10">noexcept</code>，则需要检查并确保<code class="calibre10">{E}</code>中的表达式<code class="calibre10">E</code>不会有抛出异常的可能。</p>

  <p class="zw">3．如果使用了<code class="calibre10">-&gt;</code>后的返回类型约束，则需要将模板实参替换到返回类型约束中，并且确保表达式<code class="calibre10">E</code>的结果类型，即<code class="calibre10">decltype((E))</code>，满足返回类型约束。</p>

  <p class="zw">如果出现任何不符合以上检查规则的情况，则<code class="calibre10">requires</code>表达式判定为<code class="calibre10">false</code>。例如，在之前的代码中只有<code class="calibre10">G&lt;std::string&gt; y;</code>可以编译成功，因为<code class="calibre10">std::string</code>不仅存在成员函数<code class="calibre10">clear()</code>，也能够进行+操作。但是现在，<code class="calibre10">a + b</code>又多了两个约束，首先<code class="calibre10">noexcept</code>要求<code class="calibre10">a + b</code>不能有抛出异常的可能性，其次其结果类型必须满足概念<code class="calibre10">std::same_as&lt;int&gt;;</code>的约束。其中概念<code class="calibre10">std::same_as</code>的实现类似于：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt; class T, class U &gt;
concept same_as =  std::is_same_v&lt;T, U&gt; &amp;&amp; std::is_same_v&lt;U, T&gt;;</code></pre>

  <p class="zw"><code class="calibre10">a + b</code>的结果类型会作为第一个模板实参，实际编译代码类似于：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::same_as&lt;decltype((a + b)), int&gt;</code></pre>

  <p class="zw">显然，两个<code class="calibre10">std::string</code>相加的运算结果不可能是<code class="calibre10">int</code>类型，所以<code class="calibre10">G&lt;std::string&gt; y;</code>是不能通过编译的。最后如果我们给<code class="calibre10">std::vector&lt;char&gt;</code>添加以下声明：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">int operator+ (const std::vector&lt;char&gt;&amp;, const std::vector&lt;char&gt;&amp;) noexcept;</code></pre>

  <p class="zw">那么<code class="calibre10">G&lt;std::vector&lt;char&gt;&gt; x;</code>就可以编译成功了。值得注意的是，这里的<code class="calibre10">noexcept</code>是必不可少的，<code class="calibre10">operator+</code>不需要是完整的。</p>

  <h3 id="OEBPS/Text/chapter041.html.nav_point_321" class="sigil_not_in_toc1">41.6.4　嵌套要求</h3>

  <p class="zw">正如简单要求中提到的，嵌套要求是以<code class="calibre10">requires</code>开始的要求，它通常根据局部形参来指定其他额外的要求。例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T&gt;
concept Check = requires(T a, T b) {
  requires std::same_as&lt;decltype((a + b)), int&gt;;
};</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">requires std::same_as&lt;decltype((a + b)), int&gt;;</code>是一个嵌套要求，它要求表达式<code class="calibre10">a + b</code>的结果类型与<code class="calibre10">int</code>相同，可以等同于：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class T&gt;
concept Check = requires(T a, T b) {
  {a + b} -&gt; std::same_as&lt;int&gt;;
};</code></pre>

  <p class="zw">最后请注意，这里的局部形参不是可以参与运算的操作数，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;typename T&gt; concept C = requires (T a) {
  requires sizeof(a) == 4;  // 编译成功
  requires a == 0;          // 编译失败
};</code></pre>

  <p class="zw">这里<code class="calibre10">a == 0</code>中<code class="calibre10">a</code>的值是无法计算的。</p>

  <h2 id="OEBPS/Text/chapter041.html.nav_point_322" class="sigil_not_in_toc">41.7　约束可变参数模板</h2>

  <p class="zw">使用概念约束可变参数模板实际上就是将各个实参替换到概念的约束表达式后合取各个结果。例如下面的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T&gt; concept C1 = true;
template&lt;C1… T&gt; struct s1 {};</code></pre>

  <p class="zw"><code class="calibre10">s1</code>包展开后的约束为<code class="calibre10">(C1&lt;T&gt; &amp;&amp;</code>…<code class="calibre10">)</code>，具体来说对于<code class="calibre10">s1&lt;int, double, std::string&gt;</code>，其约束实际上为<code class="calibre10">(C1&lt;int&gt; &amp;&amp; C1&lt;double&gt; &amp;&amp; C1&lt;std:: string&gt;)</code>。以上代码比较容易理解，但是有时候代码会更加复杂一些，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class… Ts&gt; concept C2 = true;
template&lt;C2… T&gt; struct s2 {};</code></pre>

  <p class="zw">现在问题来了，<code class="calibre10">s2</code>包展开之后的结果应该是<code class="calibre10">(C2&lt;T&gt; &amp;&amp;</code>…<code class="calibre10">)</code>、<code class="calibre10">C2&lt;T</code>…<code class="calibre10">&gt;</code>还是<code class="calibre10">(C2&lt;T</code>…<code class="calibre10">&gt; &amp;&amp;</code>…<code class="calibre10">)</code>呢？是不是有点难以抉择，请记住，在这种情况下包展开的结果依然是<code class="calibre10">(C2&lt;T&gt; &amp;&amp;</code>…<code class="calibre10">)</code>。不得不说，<code class="calibre10">C2&lt;T</code>…<code class="calibre10">&gt;</code>曾经是正确的，但现在不是了。再次强调一下，包展开的结果是<code class="calibre10">(C2&lt;T&gt; &amp;&amp;</code>…<code class="calibre10">)</code>。</p>

  <p class="zw">接下来让我们更进一步，对于：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T, class U&gt; concept C3 = true;
template&lt;C3&lt;int&gt; T&gt; struct s3 {};</code></pre>

  <p class="zw">经过模板实参替换后实际的约束为<code class="calibre10">C&lt;T, int&gt;</code>，对比这个结果，下面的代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;C3&lt;int&gt;… T&gt; struct s3 {};</code></pre>

  <p class="zw">包展开后的约束应该是<code class="calibre10">(C3&lt;T, int&gt; &amp;&amp;</code>…<code class="calibre10">)</code>。</p>

  <h2 id="OEBPS/Text/chapter041.html.nav_point_323" class="sigil_not_in_toc">41.8　约束类模板特化</h2>

  <p class="zw">约束可以影响类模板特化的结果，在模板实例化的时候编译器会自动选择更满足约束条件的特化版本进行实例化，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;typename T&gt; concept C = true;
template&lt;typename T&gt; struct X {
  X() { std::cout &lt;&lt; "1.template&lt;typename T&gt; struct X" &lt;&lt; std::endl; }
};
template&lt;typename T&gt; struct X&lt;T*&gt; {
  X() { std::cout &lt;&lt; "2.template&lt;typename T&gt; struct X&lt;T*&gt;" &lt;&lt; std::endl; }
};
template&lt;C T&gt; struct X&lt;T&gt; {
  X() { std::cout &lt;&lt; "3.template&lt;C T&gt; struct X&lt;T&gt;" &lt;&lt; std::endl; }
}; 

X&lt;int*&gt; s1;
X&lt;int&gt; s2;</code></pre>

  <p class="zw">以上代码的输出结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">2．template&lt;typename T&gt; struct X&lt;T*&gt;
3．template&lt;C T&gt; struct X&lt;T&gt;</code></pre>

  <p class="zw">显然，对于<code class="calibre10">X&lt;int*&gt;</code>而言，匹配更精确的是<code class="calibre10">template&lt;typename T&gt; struct X&lt;T*&gt;</code>。而对于<code class="calibre10">X&lt;int&gt;</code>，由于<code class="calibre10">template&lt;C T&gt; struct X&lt;T&gt;</code>有概念约束，相对于<code class="calibre10">template&lt;typename T&gt; struct X</code>更加特殊，因此编译器选择前者进行实例化。</p>

  <p class="zw">上面的例子只是说明了约束对类模板特化的影响，实际上约束在类模板特化上可以发挥很大的作用，请看以下代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;typename T&gt; concept C = requires (T t) { t.f(); };
template&lt;typename T&gt; struct S {
  S() {
      std::cout &lt;&lt; "1.template&lt;typename T&gt; struct S" &lt;&lt; std::endl;
  }
};
template&lt;C T&gt; struct S&lt;T&gt; {
  S() {
      std::cout &lt;&lt; "2.template&lt;C T&gt; struct S&lt;T&gt;" &lt;&lt; std::endl;
  }
};
struct Arg { void f(); };

S&lt;int&gt; s1;
S&lt;Arg&gt; s2;</code></pre>

  <p class="zw">以上代码的输出结果如下：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">1．template&lt;typename T&gt; struct S
2．template&lt;C T&gt; struct S&lt;T&gt;</code></pre>

  <p class="zw">可以看出，由于<code class="calibre10">S&lt;int&gt;</code>中的<code class="calibre10">int</code>无法满足概念<code class="calibre10">C</code>的约束条件，因此编译器使用<code class="calibre10">template&lt;typename T&gt; struct S</code>对<code class="calibre10">s1</code>进行实例化。而对于<code class="calibre10">S&lt;Arg&gt;</code>，<code class="calibre10">Arg</code>满足概念<code class="calibre10">C</code>的约束，所以编译器选择更加特殊的<code class="calibre10">template&lt;C T&gt; struct S&lt;T&gt;</code>来实例化<code class="calibre10">s2</code>。值得注意的是，如果只是约束构造函数，区分不同类型的构造方法，那么有更简单的方式：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;typename T&gt; struct S {
  S() {
      std::cout &lt;&lt; "1.call S()" &lt;&lt; std::endl;
  }

  S() requires requires(T t) { t.f(); }  {
      std::cout &lt;&lt; "2.call S() requires requires(T t)" &lt;&lt; std::endl;
  }
};
struct Arg { void f(); };

S&lt;int&gt; s1;
S&lt;Arg&gt; s2;</code></pre>

  <h2 id="OEBPS/Text/chapter041.html.nav_point_324" class="sigil_not_in_toc">41.9　约束auto</h2>

  <p class="zw">上文曾介绍过使用概念约束简写函数模板中的<code class="calibre10">auto</code>占位符，事实上对<code class="calibre10">auto</code>和<code class="calibre10">decltype(auto)</code>的约束可以扩展到普遍情况，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template &lt;class C&gt;
concept IntegerType = std::is_integral_v&lt;C&gt;;

IntegerType auto i1 = 5.2;    // 编译失败
IntegerType auto i2 = 11;     // 编译成功

IntegerType decltype(auto) i3 = 4.8;       // 编译失败
IntegerType decltype(auto) i4 = 7;         // 编译成功

IntegerType auto foo1() { return 1.1; }    // 编译失败
IntegerType auto foo2() { return 0; }      // 编译成功

auto bar1 = []()-&gt;IntegerType auto  { return 1.0; };    // 编译失败
auto bar2 = []()-&gt;IntegerType auto  { return 10; };     // 编译成功</code></pre>

  <p class="zw">在上面的代码中，概念<code class="calibre10">IntegerType</code>约束<code class="calibre10">auto</code>的推导结果必须是一个整型，于是在声明并初始化<code class="calibre10">i1</code>和<code class="calibre10">i3</code>的时候会导致编译失败。同理，函数<code class="calibre10">foo1</code>返回值为浮点类型也会导致编译失败。对于<code class="calibre10">lambda</code>表达式也是一样，只不过需要显式声明返回类型和约束概念。</p>

  <p class="zw">最后需要注意的是，要约束的<code class="calibre10">auto</code>或<code class="calibre10">decltype(auto)</code>总是紧随约束之后。因此，<code class="calibre10">cv</code>限定符和概念标识符不能随意混合：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">const IntegerType auto i5 = 23;    // 编译成功
IntegerType auto const i6 = 8;     // 编译成功
IntegerType const auto i7 = 6;     // 编译失败</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">i5</code>和<code class="calibre10">i6</code>可以顺利通过编译，因为<code class="calibre10">auto</code>紧跟在<code class="calibre10">IntegerType</code>之后。反观<code class="calibre10">i7</code>的声明，<code class="calibre10">IntegerType</code>和<code class="calibre10">auto</code>之间存在<code class="calibre10">const</code>，导致编译失败。</p>

  <h2 id="OEBPS/Text/chapter041.html.nav_point_325" class="sigil_not_in_toc">41.10　总结</h2>

  <p class="zw">C++20标准中的概念和约束不同于以往的实验版本，它不仅仅是一个扩展，而是一套完备的语言特性。与模板语法的相似使它很容易被程序员理解和接受。很明显，概念和约束的推行能够很好地补充C++的类型检查机制，这对于通用代码库的作者来说无疑是一个很好的消息，而对于代码库的使用者来说编码的错误会更容易排查，并且在运行代码的时候不会有任何多余的开销。借用本贾尼·斯特劳斯特卢普的一句话：“尝试使用概念！它们将极大地改善读者的通用编程，并让当前使用的变通方法（例如<code class="calibre10">traits</code>类）和低级技术（例如基于<code class="calibre10">enable_if</code>的重载）感觉就像是容易出错和烦琐的汇编编程”。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter041.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/chapter042.html"><div class="calibre">

  <h1 id="OEBPS/Text/chapter042.html.nav_point_326" class="not-in-toc">第42章　模板特性的其他优化（C++11 C++14）</h1>

  <h2 id="OEBPS/Text/chapter042.html.nav_point_327" class="sigil_not_in_toc">42.1　外部模板（C++11）</h2>

  <p class="zw">读者对<code class="calibre10">extern</code>关键字应该不会陌生，它可以在声明变量和函数的时候使用，用于指定目标为外部链接，但其本身并不参与目标的定义，所以对目标的属性没有影响。<code class="calibre10">extern</code>最常被使用的场景是当一个变量需要在多份源代码中使用的时候，如果每份源代码都定义一个变量，那么在代码链接时会出错，正确的方法是在其中一个源代码中定义该变量，在其他的源代码中使用<code class="calibre10">extern</code>声明该变量为外部变量。</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">\\ src1.cpp
int x = 0;

\\ src2.cpp
extern int x;
x = 11;</code></pre>

  <p class="zw">由于在多份源代码中定义同一个变量会让链接报错，因此我们不得不使用<code class="calibre10">extern</code>来声明外部变量。但是外部模板又是怎么一回事呢？我们都知道，在多份源代码中对同一模板进行相同的实例化是不会有任何链接问题的，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">// header.h
template&lt;class T&gt; bool foo(T t) { return true; }

// src1.cpp
#include &lt;header.h&gt;
bool b = foo(7);

// src2.cpp
#include &lt;header.h&gt;
bool b = foo(11);</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">src1.cpp</code>和<code class="calibre10">src2.cpp</code>都会实例化一份相同的函数代码<code class="calibre10">bool foo&lt;int&gt;(int)</code>。不过它们并没有在链接的时候产生冲突，这是因为链接器对于模板有特殊待遇。编译器在编译每份源代码的时候会按照单个源代码的需要生成模板的实例，而链接器对于这些实例会进行一次去重操作，它将完全相同的实例删除，最后只留下一份实例。不过读者有没有发现，在整个过程中编译器生成各种模板实例，连接器却删除重复实例，中间的编译和连接时间完全被浪费了。如果只是一两份源代码中出现这种情况应该不会有太大影响，但是如果源代码数量达到上万的级别，那么编译和连接的过程将付出大量额外的时间成本。</p>

  <p class="zw">为了优化编译和连接的性能，C++11标准提出了外部模板的特性，这个特性保留了<code class="calibre10">extern</code>关键字的语义并扩展了关键字的功能，让它能够声明一个外部模板实例。在进一步说明外部模板之前，我们先回顾一下如何显式实例化一个模板：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">// header.h
template&lt;class T&gt; bool foo(T t) { return true; }

// src1.cpp
#include &lt;header.h&gt;
template bool foo&lt;double&gt;(double);

// src2.cpp
#include &lt;header.h&gt;
template bool foo&lt;double&gt;(double);</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">src1.cpp</code>和<code class="calibre10">src2.cpp</code>编译时分别显式实例化了同一份函数<code class="calibre10">bool foo&lt;double&gt;(double)</code>，而在连接时其中的一个副本被删除，这个过程和之前隐式实例化的代码是一样的。如果想在这里声明一个外部模板，只需要在其中一个显式实例化前加上<code class="calibre10">extern template</code>，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">// header.h
template&lt;class T&gt; bool foo(T t) { return true; }

// src1.cpp
#include &lt;header.h&gt;
extern template bool foo&lt;double&gt;(double);

// src2.cpp
#include &lt;header.h&gt;
template bool foo&lt;double&gt;(double);</code></pre>

  <p class="zw">这样编译器将不会对<code class="calibre10">src1.cpp</code>生成<code class="calibre10">foo</code>函数模板的实例，而是在链接的时候使用<code class="calibre10">src2.cpp</code>生成的<code class="calibre10">bool foo&lt;double&gt;(double)</code>函数。如此一来就省去了之前冗余的副本实例的生成和删除的过程，改善了软件构建的性能。另外，外部模板除了可以针对函数模板进行优化，对于类模板也同样适用，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">// header.h
template&lt;class T&gt; class bar {
public:
  void foo(T t) {};
};

// src1.cpp
#include &lt;header.h&gt;
extern template class bar&lt;int&gt;;
extern template void bar&lt;int&gt;::foo(int);

// src2.cpp
#include &lt;header.h&gt;
template class bar&lt;int&gt;;</code></pre>

  <p class="zw">从上面的代码可以看出，<code class="calibre10">extern template</code>不仅可以声明外部类模板实例<code class="calibre10">extern template class bar&lt;int&gt;</code>，还可以明确具体的外部实例函数<code class="calibre10">extern template void bar&lt;int&gt;::foo(int)</code>。</p>

  <p class="zw">最后需要说明一下，我并没有在大型的工程中使用外部模板提升工程的构建性能，所以无法给出一个明确的数据证明。但是从原理上来说，这种优化应该是非常有效的，因为对一个复杂的模板实例化确实需要不少的时间。如果有读者正在苦于项目工程的构建效率过低，并且有足够的精力对大量的源代码进行修改，不妨试一试外部模板这个特性。</p>

  <h2 id="OEBPS/Text/chapter042.html.nav_point_328" class="sigil_not_in_toc">42.2　连续右尖括号的解析优化（C++11）</h2>

  <p class="zw">从C++引入右尖括号开始直到C++11标准发布，C++一直存在这样一个问题，两个连续的右尖括号&gt;&gt;一定会被编译器解析为右移，这是因为编译器解析采用的是贪婪原则。但是在很多情况下，连续两个右尖括号并不是要表示右移，可能实例化模板时模板参数恰好也是一个类模板，又或者类型转换的目标类型是一个类模板。在这种情况下，过去我们被要求在两个尖括号之间用空格分隔，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;vector&gt;
typedef std::vector&lt;std::vector&lt;int&gt; &gt; Table;  // 编译成功
typedef std::vector&lt;std::vector&lt;bool&gt;&gt; Flags;  // 编译失败，&gt;&gt;被解析为右移</code></pre>

  <p class="zw">如果上面的代码使用GCC 4.1编译，会发现代码无法通过编译，同时编译器会给出具体的提示，要求将代码中的<code class="calibre10">'&gt;&gt;'</code>修改为<code class="calibre10">'&gt; &gt;'</code>。当然，类型转换<code class="calibre10">static_cast</code>、<code class="calibre10">const_cast</code>、<code class="calibre10">dynamic_cast</code>和<code class="calibre10">reinterpret_cast</code>也存在同样的问题。这个问题虽然不大，但是确实也挺让人厌烦的，所以在C++11中将连续右尖括号的解析进行了优化。</p>

  <p class="zw">在C++11标准中，编译器不再一味地使用贪婪原则将连续的两个右尖括号解析为右移，它会识别左尖括号激活状态并且将右尖括号优先匹配给激活的左尖括号。这样一来，我们就无须在两个右尖括号中插入空格了。</p>

  <p class="zw">还是编译上面的代码，只不过这一次我们采用新一点的编译器，比如GCC 8.1，代码就能够顺利地编译。</p>

  <p class="zw">这样就结束了吗？并不是，由于解析规则的修改会造成在老规则下编写的代码出现问题，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;int N&gt;
class X {};

X &lt;1 &gt;&gt; 3&gt; x;</code></pre>

  <p class="zw">上面的代码用GCC 4.1可以顺利编译，因为代码里的<code class="calibre10">1 &gt;&gt; 3</code>被优先处理，相当于<code class="calibre10">X &lt;(1 &gt;&gt; 3)&gt; x</code>。但是在新的编译器中，这段代码无法成功编译，因为连续两个右尖括号的第一个括号总是会跟开始的左尖括号匹配，相当于<code class="calibre10">(X &lt;1 &gt;)&gt; 3&gt; x</code>。无法兼容老代码的问题虽然看似严重，但其实要解决这个问题非常简单，只要将需要优先解析的内容用小括号包括起来即可，比如<code class="calibre10">X &lt;(1 &gt;&gt; 3)&gt; x</code>。</p>

  <p class="zw">故事到这里还没有结束，由于涉及模板编程，因此情况比我们想象得还要复杂一点，因此来看一看下面的例子：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

template&lt;int I&gt; struct X {
  static int const c = 2;
};
template&lt;&gt; struct X&lt;0&gt; {
  typedef int c;
};
template&lt;typename T&gt; struct Y {
  static int const c = 3;
};
static int const c = 4;
int main() {
  std::cout &lt;&lt; (Y&lt;X&lt;1&gt; &gt;::c &gt; ::c &gt; ::c) &lt;&lt; std::endl;
  std::cout &lt;&lt; (Y&lt;X&lt; 1&gt;&gt;::c &gt; ::c &gt; ::c) &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">上面的代码在新老编译器上都可以成功编译，但是输出结果却不相同，用GCC 4.1编译这份代码，运行后输出为0和3。但是在GCC 8.1或者以上版本的编译器上编译运行，得到的结果却是0和0。现在让我们看一看这是怎么发生的。</p>

  <p class="zw">　　对于GCC 8.1而言，<code class="calibre10">std::cout &lt;&lt; (Y&lt;X&lt;1&gt; &gt;::c &gt; ::c &gt; ::c) &lt;&lt; std::endl;</code>和<code class="calibre10">std::cout &lt;&lt; (Y&lt;X&lt; 1&gt;&gt;::c &gt; ::c &gt; ::c) &lt;&lt; std::endl;</code>的解析方式相同，都是先解析<code class="calibre10">X&lt;1&gt;</code>，接着解析<code class="calibre10">Y&lt;X&lt;1&gt;&gt;::c</code>，最后的代码相当于<code class="calibre10">std::cout &lt;&lt; (3 &gt; 4 &gt; 4) &lt;&lt; std::endl</code>，所以输出都为0。</p>

  <p class="zw">　　而对于GCC 4.1，两个语句有着截然不同的解析顺序。其中<code class="calibre10">std::cout &lt;&lt; (Y&lt;X&lt;1&gt; &gt;::c &gt; ::c &gt; ::c) &lt;&lt; std::endl;</code>和GCC 8.1的解析顺序相同，所以输出为<code class="calibre10">0</code>。但是<code class="calibre10">std::cout &lt;&lt; (Y&lt;X&lt; 1&gt;&gt;::c &gt; ::c &gt; ::c) &lt;&lt; std::endl;</code>的解析顺序则不同，先解析<code class="calibre10">1&gt;&gt;::c</code>得到结果<code class="calibre10">0</code>，接着解析<code class="calibre10">X&lt;0&gt;::c</code>得到结果为类型<code class="calibre10">int</code>，最后解析<code class="calibre10">Y&lt;int&gt; ::c</code>的结果为<code class="calibre10">3</code>，所以输出结果为<code class="calibre10">3</code>。</p>

  <p class="zw">对于同一份代码的运行结果不同，这是我们处理兼容问题时最不想看到的情况。值得庆幸的是，像上面这份“奇怪”的代码不太会出现在真实的开发环境中。不过在将老代码迁移到新编译环境中时还是应该小心谨慎，避免出现难以预测的问题。</p>

  <h2 id="OEBPS/Text/chapter042.html.nav_point_329" class="sigil_not_in_toc">42.3　friend声明模板形参（C++11）</h2>

  <p class="zw">友元在C++中一直是一个备受争议的特性，争议的焦点是一个类的友元可以忽略该类的访问属性（<code class="calibre10">public</code>、<code class="calibre10">protected</code>、<code class="calibre10">private</code>），对类成员进行直接访问，破坏了代码的封装性。不过，我却很喜欢这个特性，在我看来友元语法简单且使用方便，合理使用不会造成代码混乱、难以阅读甚至可以简化代码，它提供了一种语法上的可能性，让程序员更灵活地控制对类的访问。至于说破坏封装性的问题，我们大可以谨慎使用友元，保证编写的类不会被滥用即可。</p>

  <p class="zw">也许C++委员会也是出于我这样的想法，在C++标准中不但没有反对和删除这个特性，反而扩展了它在模板里的能力。介绍该能力之前，需要先介绍一个语法上的改进，在C++11标准中，将一个类声明为另外一个类的友元，可以忽略前者的<code class="calibre10">class</code>关键字。当然，忽略<code class="calibre10">class</code>关键字还有一个大前提，必须提前声明该类，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class C;

class X1 {
  friend class C;   // C++11前后都能编译成功
};

class X2 {
  friend C;         // C++11以前会编译错误，C++11以后编译成功
};</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">X1</code>可以在C++11以及之前标准的编译器中编译成功，而<code class="calibre10">X2</code>在C++11之前则可能会编译失败，因为<code class="calibre10">friend C</code>缺少<code class="calibre10">class</code>关键字。这里说可能，是因为在某些新版本的编译器中，例如GCC，即使指定了<code class="calibre10">-std=c++03</code>，<code class="calibre10">X2</code>也能够编译通过，而在另外一些新编译器中可能会给出警告，例如CLang，但也会编译成功。请注意，这里为了保证<code class="calibre10">X2</code>编译通过，<code class="calibre10">class C</code>的提前声明是必不可少的。</p>

  <p class="zw">引入忽略<code class="calibre10">class</code>关键字这个能力后，我们会发现<code class="calibre10">friend</code>多了一些事情可以做，比如用<code class="calibre10">friend</code>声明基本类型、用<code class="calibre10">friend</code>声明别名、用<code class="calibre10">friend</code>声明模板参数：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class C;
typedef C Ct;

class X1 {
  friend C;
  friend Ct;
  friend void;
  friend int;
};

template &lt;typename T&gt; class R {
  friend T;
};

R&lt;C&gt; rc;
R&lt;Ct&gt; rct;
R&lt;int&gt; ri;
R&lt;void&gt; rv;</code></pre>

  <p class="zw">以上代码中的<code class="calibre10">friend C</code>和<code class="calibre10">friend Ct</code>具有相同的含义，都是指定类<code class="calibre10">C</code>为类<code class="calibre10">X1</code>的友元。对于基本类型，<code class="calibre10">friend void</code>和<code class="calibre10">friend int</code>虽然也能编译成功，但是实际上编译器不会做任何事情，也就是说它们会被忽略。这个特性可以延伸到模板参数上，当模板参数为<code class="calibre10">C</code>或者<code class="calibre10">Ct</code>时，<code class="calibre10">C</code>为类<code class="calibre10">R&lt;C&gt;</code>的友元，当模板参数为<code class="calibre10">int</code>等内置类型时，<code class="calibre10">friend T</code>被忽略，类<code class="calibre10">R&lt;int&gt;</code>不存在友元。</p>

  <p class="zw">通过上面的示例可以发现，用模板参数结合友元可以让我们在使用友元的代码上进行切换而不需要多余的代码修改，例如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">class InnerVisitor { /*访问SomeDatabase内部数据*/ };

template &lt;typename T&gt; class SomeDatabase {
  friend T;
  // … 内部数据
public:
  // … 外部接口
};

typedef SomeDatabase&lt;InnerVisitor&gt; DiagDatabase;
typedef SomeDatabase&lt;void&gt; StandardDatabase;</code></pre>

  <p class="zw">这里<code class="calibre10">DiagDatabase</code>是一个对内的诊断数据库类，它设置<code class="calibre10">InnerVisitor</code>为友元，通过<code class="calibre10">InnerVisitor</code>对数据库数据进行诊断。而对外则使用类<code class="calibre10">StandardDatabase</code>，因为它的友元声明为<code class="calibre10">void</code>，所以不存在友元，外部需要通过标准方法访问数据库的数据。</p>

  <h2 id="OEBPS/Text/chapter042.html.nav_point_330" class="sigil_not_in_toc">42.4　变量模板（C++14）</h2>

  <p class="zw">请读者回答一个问题，如果想根据不同的类型去定义一个变量有哪些做法，根据以往的C++知识，读者应该能想到两种方法。</p>

  <p class="zw">在类模板定义静态数据成员：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

template&lt;class T&gt;
struct PI {
  static constexpr T value = static_cast&lt;T&gt;(3.1415926535897932385);
};

int main()
{
  std::cout &lt;&lt; PI&lt;float&gt;::value &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">使用函数模板返回所需的值：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

template&lt;class T&gt;
constexpr T PI()
{
  return static_cast&lt;T&gt;(3.1415926535897932385);
}

int main()
{
  std::cout &lt;&lt; PI&lt;int&gt;() &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">很明显，根据类型定义变量并不是一件有难度的事情，通过类模板和函数模板可以轻松达到这个目的。</p>

  <p class="zw">不过C++委员会似乎并不满足于此，在C++14的标准中引入了变量模板的特性，有了变量模板，我们不再需要冗余地定义类模板和函数模板，只需要专注要定义的变量即可，还是以变量<code class="calibre10">PI</code>为例：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

template&lt;class T&gt;
constexpr T PI = static_cast&lt;T&gt;(3.1415926535897932385L);
int main()
{
  std::cout &lt;&lt; PI&lt;float&gt; &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">在上面的代码中，<code class="calibre10">constexpr T PI = static_cast&lt;T&gt;(3.141592653589 7932385L);</code>是变量的声明和初始化，<code class="calibre10">template&lt;class T&gt;</code>是变量的模板形参。请注意，虽然这里的变量声明为常量，但是对于变量模板而言这不是必需的，同其他模板一样，变量模板的模板形参也可以是非类型的：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">#include &lt;iostream&gt;

template&lt;class T, int N&gt;
T PI = static_cast&lt;T&gt;(3.1415926535897932385L) * N;
int main()
{
  PI&lt;float, 2&gt; *= 5;
  std::cout &lt;&lt; PI&lt;float, 2&gt; &lt;&lt; std::endl;
}</code></pre>

  <p class="zw">在上面的代码中，变量模板<code class="calibre10">PI</code>不再是一个常量，我们可以在任意时候改变它的值。实际上，在C++14标准中变量模板给我们带来的最大便利是关于模板元编程的。举例来说，当比较两个类型是否相同时会用到：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">bool b = std::is_same&lt;int, std::size_t&gt;::value;</code></pre>

  <p class="zw">可以看到，类模板<code class="calibre10">std::is_same</code>使用常量静态成员变量的方法定义了<code class="calibre10">value</code>的值，显而易见，直接使用变量模板编写代码要简单得多，比如：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T1, class T2&gt;
constexpr bool is_same_v = std::is_same&lt;T1, T2&gt;::value;

bool b = is_same_v&lt;int, std::size_t&gt;;</code></pre>

  <p class="zw">有些令人尴尬的是，虽然C++14标准已经支持变量模板的特性并且也证明了可以简化代码的编写，但是在C++14的标准库中却没有对它的支持。我们不得不继续使用<code class="calibre10">std::is_same&lt;int, std::size_t&gt;::value</code>的方法来判断两个类型是否相同。这个尴尬的问题一直延续到C++17标准的发布才得到解决，在C++17标准库的<code class="calibre10">type_traits</code>中对类型特征采用了变量模板，比如对于<code class="calibre10">some_trait&lt;T&gt;:: value</code>，会增加与它等效的变量模板<code class="calibre10">some_trait_v&lt;T&gt;</code>，这里<code class="calibre10">_v</code>后缀表示该类型是一个变量模板。因此在C++17的环境下，判断两种类型是否相同就只需要编写一行代码即可：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">bool b = std::is_same_v&lt;int, std::size_t&gt;;</code></pre>

  <h2 id="OEBPS/Text/chapter042.html.nav_point_331" class="sigil_not_in_toc">42.5　explicit(bool)</h2>

  <p class="zw">C++20标准扩展了<code class="calibre10">explicit</code>说明符的功能，在新标准中它可以接受一个求值类型为bool的常量表达式，用于指定<code class="calibre10">explicit</code>的功能是否生效。为了解释这项新功能的目的，让我们先看一看提案文档中的示例代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">std::pair&lt;std::string, std::string&gt; safe() {
    return {"meow", "purr"};  // 编译成功
}

std::pair&lt;std::vector&lt;int&gt;, std::vector&lt;int&gt;&gt; unsafe() {
    return {11, 22};          // 编译失败
}</code></pre>

  <p class="zw">在上面的代码中<code class="calibre10">safe()</code>函数可以通过编译，<code class="calibre10">unsafe()</code>则会编译报错。这个结果符合预期，整型转换为<code class="calibre10">std::vector&lt;int&gt;</code>看上去都不可能是合理的。不过，让我们想一想这个差异是怎么发生的。因为<code class="calibre10">"meow"</code>和<code class="calibre10">"purr"</code>都可以构造<code class="calibre10">std::string</code>，所以<code class="calibre10">safe()</code>能编译成功，这没有问题。问题是整型也可以通过构造函数构造<code class="calibre10">std::vector&lt;int&gt;</code>，为何<code class="calibre10">unsafe()</code>函数编译失败了，有读者可能会想到<code class="calibre10">std::vector&lt;int&gt;</code>的构造函数使用了<code class="calibre10">explicit</code>说明符，所以整型需要显式构造<code class="calibre10">std::vector&lt;int&gt;</code>。知识点的确没错，但是这里<code class="calibre10">std::vector&lt;int&gt;</code>的构造函数使用<code class="calibre10">explicit</code>说明符无法阻止<code class="calibre10">std::pair</code>的构造，因为<code class="calibre10">std::pair</code>的实现类似于以下代码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T1, class T2&gt;
struct MyPair {
  template &lt;class U1, class U2&gt;
  MyPair(const U1&amp; u1, const U2&amp; u2) : first_(u1), second_(u2) {}

  T1 first_;
  T2 second_;
};

MyPair&lt;std::vector&lt;int&gt;, std::vector&lt;int&gt;&gt; unsafe() {
  return { 11, 22 };  // 编译成功
}</code></pre>

  <p class="zw">上面这段代码是可以通过编译的，这说明<code class="calibre10">std::vector&lt;int&gt;</code>的构造函数使用<code class="calibre10">explicit</code>说明符没有限制作用。仔细观察代码会发现，实际上<code class="calibre10">{11, 22}</code>并没有直接构造<code class="calibre10">std::vector&lt;int&gt;</code>，而是通过<code class="calibre10">first_(u1)</code>和<code class="calibre10">second_(u2)</code>间接构造<code class="calibre10">std::vector&lt;int&gt;</code>，这个过程显然是一个显式构造。要解决这个问题，我们需要对<code class="calibre10">MyPair</code>的构造函数使用<code class="calibre10">explicit</code>说明符。</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">template&lt;class T1, class T2&gt;
struct MyPair {
  template &lt;class U1, class U2&gt;
  explicit MyPair(const U1&amp; u1, const U2&amp; u2) : first_(u1), second_(u2) {}

  T1 first_;
  T2 second_;
};

MyPair&lt;std::vector&lt;int&gt;, std::vector&lt;int&gt;&gt; unsafe() {
  return { 11, 22 };          // 编译失败
}

MyPair&lt;std::string, std::string&gt; safe() {
  return { "meow", "purr" };  // 编译失败
}</code></pre>

  <p class="zw">但是这样一来又会导致<code class="calibre10">safe()</code>编译失败。为了解决这一系列的问题，标准库采用SFINAE和概念的方法实现了<code class="calibre10">std::pair</code>的构造函数，其代码类似于：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">// SFINAE版本
template &lt;typename T1, typename T2&gt;
struct pair {
    template &lt;typename U1=T1, typename U2=T2,
        std::enable_if_t&lt;
            std::is_constructible_v&lt;T1, U1&gt; &amp;&amp;
            std::is_constructible_v&lt;T2, U2&gt; &amp;&amp;
            std::is_convertible_v&lt;U1, T1&gt; &amp;&amp;
            std::is_convertible_v&lt;U2, T2&gt;
        , int&gt; = 0&gt;
    constexpr pair(U1&amp;&amp;, U2&amp;&amp; );

    template &lt;typename U1=T1, typename U2=T2,
        std::enable_if_t&lt;
            std::is_constructible_v&lt;T1, U1&gt; &amp;&amp;
            std::is_constructible_v&lt;T2, U2&gt; &amp;&amp;
            !(std::is_convertible_v&lt;U1, T1&gt; &amp;&amp;
              std::is_convertible_v&lt;U2, T2&gt;)
        , int&gt; = 0&gt;
    explicit constexpr pair(U1&amp;&amp;, U2&amp;&amp; );    
};

// 概念版本
template &lt;typename T1, typename T2&gt;
struct pair {
    template &lt;typename U1=T1, typename U2=T2&gt;
        requires std::is_constructible_v&lt;T1, U1&gt; &amp;&amp;
            std::is_constructible_v&lt;T2, U2&gt; &amp;&amp;
            std::is_convertible_v&lt;U1, T1&gt; &amp;&amp;
            std::is_convertible_v&lt;U2, T2&gt;
    constexpr pair(U1&amp;&amp;, U2&amp;&amp; );

    template &lt;typename U1=T1, typename U2=T2&gt;
        requires std::is_constructible_v&lt;T1, U1&gt; &amp;&amp;
            std::is_constructible_v&lt;T2, U2&gt;
    explicit constexpr pair(U1&amp;&amp;, U2&amp;&amp; );    
};</code></pre>

  <p class="zw">从上面的代码可以看出，标准库利用SFINAE和概念实现了两套构造函数，对于类型可以转换地（使用<code class="calibre10">std::is_convertible_v</code>判定）采用无<code class="calibre10">explicit</code>说明符的构造函数，而对于其他情况使用有<code class="calibre10">explicit</code>说明符的构造函数。</p>

  <p class="zw">尽管使用以上方法很好地解决了上述一系列问题，但是不得不说它的实现非常复杂。幸好<code class="calibre10">explicit(bool)</code>的引入有效地缩减了解决上述问题的编码：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">// SFINAE版本
template &lt;typename T1, typename T2&gt;
struct pair {
    template &lt;typename U1=T1, typename U2=T2,
        std::enable_if_t&lt;
            std::is_constructible_v&lt;T1, U1&gt; &amp;&amp;
            std::is_constructible_v&lt;T2, U2&gt;
        , int&gt; = 0&gt;
    explicit(!std::is_convertible_v&lt;U1, T1&gt; ||
        !std::is_convertible_v&lt;U2, T2&gt;)
    constexpr pair(U1&amp;&amp;, U2&amp;&amp; );   
};

// 概念版本
template &lt;typename T1, typename T2&gt;
struct pair {
    template &lt;typename U1=T1, typename U2=T2&gt;
        requires std::is_constructible_v&lt;T1, U1&gt; &amp;&amp;
            std::is_constructible_v&lt;T2, U2&gt;
    explicit(!std::is_convertible_v&lt;U1, T1&gt; ||
        !std::is_convertible_v&lt;U2, T2&gt;)
    constexpr pair(U1&amp;&amp;, U2&amp;&amp; );
};</code></pre>

  <p class="zw">观察上述代码可以发现，<code class="calibre10">std::pair</code>不再需要实现两套构造函数了。取而代之的是：</p>
  <pre class="dai_ma_wu_xing_hao"><code class="calibre10">explicit(!std::is_convertible_v&lt;U1, T1&gt; || !std::is_convertible_v&lt;U2, T2&gt;)</code></pre>

  <p class="zw">当<code class="calibre10">U1</code>、<code class="calibre10">U2</code>不能转换到<code class="calibre10">T1</code>和<code class="calibre10">T2</code>的时候，<code class="calibre10">!std::is_convertible_v&lt;U1, T1&gt; || !std::is_ convertible_v&lt;U2, T2&gt;</code>的求值为<code class="calibre10">true</code>，<code class="calibre10">explicit(true)</code>表示该构造函数为显式的。反之，当<code class="calibre10">U1</code>、<code class="calibre10">U2</code>可以转换到<code class="calibre10">T1</code>和<code class="calibre10">T2</code>时，最终结果为<code class="calibre10">explicit(false)</code>，<code class="calibre10">explicit</code>说明符被忽略，构造函数可以隐式执行。</p>

  <h2 id="OEBPS/Text/chapter042.html.nav_point_332" class="sigil_not_in_toc">42.6　总结</h2>

  <p class="zw">本章介绍了5个和模板密切相关的特性，其中连续右尖括号的解析优化，虽然看似改动很小，但却实打实地让我们在编写模板的时候舒心了不少。相对于前者，外部模板和<code class="calibre10">friend</code>声明模板形参在实用性上确实少了一些，但不可否认的是它们完善了模板机制。接着介绍变量模板，我认为是比较实用的新特性，很明显，相较于C++14标准库，在C++17标准库引入了变量模板特性之后，<code class="calibre10">type_traits</code>中的模板元函数使用起来更加简明了。最后，<code class="calibre10">explicit(bool)</code>虽然比较复杂但非常实用，它让<code class="calibre10">explicit</code>说明符可以根据指定类型来发挥作用，对于代码库的设计者来说，这无疑增加了编码的灵活性。</p>

  <p class="zw"><br class="calibre3" id="OEBPS/Text/chapter042.html.calibre_pb_1"></p>
</div></div>
<div id="OEBPS/Text/appendix.html"><div class="calibre">

  <h1 id="OEBPS/Text/appendix.html.nav_point_333" class="not-in-toc">附　录　特性章节对照表</h1>

  <p class="zw">特性章节对照表</p>

  <table border="1" width="90%" class="calibre11">
    <thead class="calibre12">
      <tr class="calibre13">
        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">特性</p>
        </th>

        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">标准</p>
        </th>

        <th class="calibre14">
          <p class="biao_tou_dan_yuan_ge">章节</p>
        </th>
      </tr>
    </thead>

    <tbody class="calibre15">
      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">[[carries_dependency]] attribute</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">31.5.2</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">[[deprecated]] attribute</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">14</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">31.5.3</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">[[fallthrough]] attribute</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">31.5.4</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">[[likely]] and [[unlikely]] attributes</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">31.5.7</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">[[maybe_unused]] attribute</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">31.5.6</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">[[no_unique_address]] attribute</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">31.5.8</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">[[nodiscard]] attribute</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">31.5.5</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">[[noreturn]] attribute</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">31.5.1</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__has_include</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">32.1</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">__VA_OPT__</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">32.3</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">add an rvalue reference</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">6</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">adding the constinit keyword</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">27.15</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">adding the long long type</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">1.1</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">adding u8 character literals</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">1.3</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">ADL and function templates that are not Visible</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">37.4</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">alignas</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">30.3</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">alignof</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">30.4</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">allow constant evaluation for all non-type template arguments</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">37.1</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">allow defaulting comparisons by value</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">34.4</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">allow initializing aggregates from a parenthesized list of values</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">15.5</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">allow pack expansion in lambda init-capture</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">35.8</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">allow structured bindings to accessible members</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20.5</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">allow typename in a template template parameter</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">36.1</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">array size deduction in new-expressions</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">34.5</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">attribute specifier sequence</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">31.3</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">auto</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">3</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">binary literals</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">14</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">29.2</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">changing the active member of a union inside constexpr</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">27.13</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">char8_t: a type for UTF-8 characters and strings</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">1.3</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">class template argument deduction for aggregates</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">38.5</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">class template argument deduction for alias templates</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">38.4</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">class types in non-type template parameters</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">37.5</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">concepts</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">41</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">consistent comparison</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">24</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">const mismatch with defaulted copy constructor</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">34.9</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">consteval</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">27.14</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">constexpr</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">27</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">constexpr if</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">27.9</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">construction rules for enum class values</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">14.3</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">copy elision</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">34.3</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">coroutines</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">33</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">declaring non-type template parameters with auto</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">3.6</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">decltype</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">4</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">default constructible and assignable stateless lambdas</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">7.4</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">default member initializers for bit-fields</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">8.2</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">defaulted and deleted functions</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">10</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">delegating constructors</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">12</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">deprecate implicit capture of this via [=]</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">7.9</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">deprecate uses of the comma operator in subscripting expressions</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">34.11</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">deprecating volatile</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">34.10</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">designated initialization</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">9.5</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">down with typename</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">36.2</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">explicit conversion operator</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">34.1</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">explicit virtual overrides</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">16</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">explicit(bool)</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">42.5</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">extended constexpr</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">14</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">27.6</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">extended friend declarations</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">42.3</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">extension to aggregate initialization</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">15.2</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">extern template</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">42.1</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">familiar template syntax for generic lambdas</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">7.10</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">folding expressions</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">35.5</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">generalized lambda-capture</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">14</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">7.6</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">generalizing the range-based for loop</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17.3</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">generic lambda expressions</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">14</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">7.7</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">hexadecimal floating literals</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">29.1</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">inheriting constructors</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">13</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">initializer list</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">9</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">inline namespace</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">2.1</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">inline variables</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">26</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">integrating feature-test macros</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">32.2</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">lambda capture of *this by value as [=,*this]</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">7.8</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">lambda expressions</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">7</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">local and unnamed types as template arguments</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">37.2</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">make exception specifications be part of the type system</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">21.6</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">matching of template template-arguments excludes compatible templates</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">37.6</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">nested inline namespaces</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">2.2</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">new character types</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">1.2</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">noexcept</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">21</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">non-static data member initializers</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">8.1</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">nullptr</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">23</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">pack expansions in using-declarations</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">35.7</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">permit conversions to arrays of unknown bound</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">34.6</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">permitting trivial default initialization in constexpr contexts</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">27.12</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">prohibit aggregates with user-declared constructors</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">15.4</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">range-based for loop</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">raw string literals</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">29.4</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">refining expression evaluation order</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">28</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">replacement of class objects containing reference members</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">34.2</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">return type deduction for normal functions</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">14</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">3.4</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">right angle brackets</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">42.2</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">selection statements with initializer</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">18</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">single-quotation-mark as a digit separator</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">29.3</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">solving the SFINAE problem for expressions</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">40</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">static_assert</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">19</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">std::is_constant_evaluated()</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">27.16</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">strongly typed enums</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">14</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">structured bindings</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">template argument deduction for class templates</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">38.1</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">template deduction guides</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">39</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">templates aliases</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">22.2</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">thread_local</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">25</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">trailing function return types</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">5</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">try-catch blocks in constexpr functions</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">27.11</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">unrestricted unions</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">user-defined literals</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">29.5</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">using attribute namespaces without repetition</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">17</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">31.4</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">using enum</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">14.4</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">variable templates</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">14</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">42.4</p>
        </td>
      </tr>

      <tr class="calibre13">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">variadic templates</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">11</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">35</p>
        </td>
      </tr>

      <tr class="calibre17">
        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">yet another approach for constrained declarations</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">20</p>
        </td>

        <td class="calibre16">
          <p class="biao_tou_dan_yuan_ge">41.9</p>
        </td>
      </tr>
    </tbody>
  </table>

  <p class="zw"><br class="calibre19"></p>
</div></div>
</div>
<div id="html-container"></div>

<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>
