<!DOCTYPE html><html><head>
<meta name="dc.identifier" content="res/84acd1097203da9851c1fffac125fe2554dd899c">


<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Thinking Functionally With Haskell.Bird2015</title>

<style>
.affiliation {
  display: block;
  font-size: 1em;
  font-weight: normal;
  text-align: center;
  text-indent: 0;
  margin: 0 0 10em;
}

.authorname {
  display: block;
  font-size: 1.41667em;
  font-weight: normal;
  line-height: 1.2;
  text-align: center;
  text-indent: 0;
  margin: 0;
}

.book-title {
  display: block;
  font-size: 2em;
  font-weight: normal;
  line-height: 1.2;
  text-align: center;
  text-indent: 0;
  margin: 1em 0 2em;
}

.calibre {
  display: block;
  font-size: 1em;
  padding-left: 0;
  padding-right: 0;
  text-align: justify;
  margin: 0 5pt;
}

.calibre1 {
  font-style: italic;
}

.calibre2 {
  height: auto;
  vertical-align: middle;
  width: auto;
}

.calibre3 {
  text-decoration: none;
}

.calibre4 {
  display: block;
}

.calibre5 {
  font-weight: bold;
  line-height: 1.2;
}

.calibre6 {
  line-height: 1.2;
  text-decoration: none;
}

.calibre7 {
  font-weight: bold;
}

.calibre8 {
  font-size: 0.75em;
  line-height: normal;
  vertical-align: super;
}

.calibre9 {
  display: block;
  list-style-type: disc;
  margin-bottom: 0.5em;
  margin-right: 0;
  margin-top: 0.5em;
}

.calibre10 {
  display: list-item;
  padding-bottom: 0.15em;
}

.calibre11 {
  font-size: 0.75em;
  line-height: normal;
  vertical-align: sub;
}

.calibre12 {
  border-collapse: separate;
  border-spacing: 2px;
  display: table;
  font-size: 1em;
  margin-bottom: 0;
  margin-top: 0;
  text-align: left;
  text-indent: 0;
}

.calibre13 {
  display: table-row;
  vertical-align: middle;
}

.calibre14 {
  display: table-cell;
  text-align: inherit;
  vertical-align: inherit;
  padding: 1px;
}

.calibre15 {
  font-size: 0.77778em;
  line-height: normal;
  vertical-align: super;
}

.calibre16 {
  font-style: italic;
  line-height: 1.2;
}

.calibre17 {
  font-size: 0.75em;
}

.calibre18 {
  font-size: 0.77778em;
  line-height: 1.2;
  vertical-align: super;
}

.calibre19 {
  font-size: 0.77778em;
  line-height: 1.2;
  vertical-align: sub;
}

.calibre20 {
  display: block;
  font-size: 1.125em;
  font-weight: bold;
  line-height: 1.2;
  margin: 1em 0;
}

.center {
  display: block;
  font-size: 1em;
  font-weight: normal;
  text-align: center;
  text-indent: 0;
  margin: 1em 0;
}

.chapter-number {
  display: block;
  font-size: 1.41667em;
  font-weight: normal;
  line-height: 1.2;
  padding-bottom: 0.25em;
  text-align: center;
  text-indent: 0;
  border-bottom: #000 solid 1px;
  margin: 2em 0 0.5em;
}

.chapter-title {
  display: block;
  font-size: 1.66667em;
  font-weight: normal;
  line-height: 1.2;
  text-align: center;
  text-indent: 0;
  margin: 0 0 3em;
}

.code {
  display: block;
  font-size: 1em;
  text-align: left;
  margin: 0 0 0.25em 2em;
  padding: 0;
}

.code1 {
  display: block;
  font-size: 1em;
  text-align: left;
  margin: 0 0 0.25em 7em;
  padding: 0;
}

.code2 {
  display: block;
  font-size: 1em;
  text-align: left;
  margin: 0 0 0.25em 3em;
  padding: 0;
}

.code3 {
  display: block;
  font-size: 1em;
  text-align: left;
  margin: 0 0 0.25em 6em;
  padding: 0;
}

.code4 {
  display: block;
  font-size: 1em;
  text-align: left;
  margin: 0 0 0.25em 11em;
  padding: 0;
}

.code5 {
  display: block;
  font-size: 1em;
  text-align: left;
  margin: 0 0 0.25em 12.5em;
  padding: 0;
}

.code6 {
  display: block;
  font-size: 1em;
  text-align: left;
  margin: 0 0 0.25em;
  padding: 0;
}

.code7 {
  display: block;
  font-size: 1em;
  text-align: left;
  margin: 1em 0 0.25em 2em;
  padding: 0;
}

.code8 {
  display: block;
  font-size: 1em;
  text-align: left;
  margin: 0.5em 0 0.5em 5em;
  padding: 0;
}

.code9 {
  display: block;
  font-size: 1em;
  text-align: left;
  margin: 0 0 0.25em 10em;
  padding: 0;
}

.code10 {
  display: block;
  font-size: 1em;
  text-align: left;
  margin: 0 0 0.25em 8em;
  padding: 0;
}

.code11 {
  display: block;
  font-size: 1em;
  text-align: left;
  margin: 0 0 0.25em 4em;
  padding: 0;
}

.code12 {
  display: block;
  font-size: 1em;
  text-align: left;
  margin: 0 0 0.25em 9em;
  padding: 0;
}

.code13 {
  display: block;
  font-size: 1em;
  text-align: left;
  margin: 0 0 0.25em 13.5em;
  padding: 0;
}

.code14 {
  display: block;
  font-size: 1em;
  text-align: left;
  margin: 0 0 0.25em 12em;
  padding: 0;
}

.code15 {
  border-collapse: separate;
  border-spacing: 2px;
  display: table;
  font-size: 1em;
  margin-bottom: 0;
  margin-left: 1em;
  margin-top: 0;
  text-align: left;
  text-indent: 0;
}

.code16 {
  display: block;
  font-size: 1em;
  text-align: left;
  margin: 0 0 0.25em 14em;
  padding: 0;
}

.code17 {
  display: block;
  font-size: 1em;
  text-align: left;
  margin: 0 0 0.25em 13em;
  padding: 0;
}

.copyright {
  display: block;
  font-size: 0.75em;
  font-weight: normal;
  text-align: left;
  text-indent: 0;
  margin: 0.8em 0 0;
}

.copyright-image {
  display: block;
  text-align: left;
  text-indent: 0;
  margin: 10% 0 0;
}

.copyright1 {
  display: block;
  font-size: 0.75em;
  font-weight: normal;
  text-align: left;
  text-indent: 0;
  margin: 1em 0 0;
}

.equationasimage {
  display: block;
  font-size: 1em;
  text-align: center;
  text-indent: 0;
  margin: 0.75em 0;
}

.figure {
  display: block;
  padding-bottom: 0.5em;
  text-align: left;
  text-indent: 0;
  border-bottom: black solid 1px;
  margin: 1.5em 0;
}

.fm_title {
  display: block;
  font-size: 1.41667em;
  font-weight: bold;
  line-height: 1.2;
  text-align: center;
  border-bottom: black solid 1px;
  margin: 0 0 2em;
  padding: 0.5em 0 0;
}

.fm_titlea {
  display: block;
  font-size: 1.41667em;
  line-height: 1.2;
  text-align: center;
  margin: 0 0 2em;
  padding: 0.5em 0 0;
}

.fm-title {
  display: block;
  font-size: 1.41667em;
  font-weight: bold;
  line-height: 1.2;
  text-align: center;
  text-indent: 0;
  border-bottom: #000 solid 1px;
  margin: 2em 0 2.5em;
}

.font {
  font-family: monospace;
}

.font1 {
  font-family: monospace;
  line-height: 1.2;
}

.footnote {
  display: block;
  font-size: 0.75em;
  text-align: justify;
  text-indent: -1.3em;
  margin: 0 0 0 1.3em;
}

.footnote1 {
  display: block;
  font-size: 0.75em;
  text-align: justify;
  text-indent: -1.3em;
  margin: 1em 0 0 1.3em;
}

.h {
  display: block;
  font-size: 1.41667em;
  font-weight: normal;
  line-height: 1.2;
  text-align: center;
  text-indent: 0;
  margin: 2em 0 0.5em;
}

.half_title {
  display: block;
  font-size: 1.41667em;
  font-weight: normal;
  line-height: 1.2;
  text-align: center;
  text-indent: 0;
  margin: 2em 0 1em;
  padding: 0.5em 0 0;
}

.image {
  display: block;
  font-size: 1em;
  font-weight: normal;
  text-align: center;
  text-indent: 0;
  margin: 0 0 1em;
}

.imagecaption {
  display: block;
  font-size: 1em;
  text-align: center;
  text-indent: 0;
  margin: 0;
}

.index {
  display: block;
  font-size: 0.75em;
  text-align: left;
  text-indent: 0;
  margin: 0;
}

.index1 {
  display: block;
  font-size: 0.75em;
  text-align: left;
  text-indent: 0;
  margin: 0 0 0 1em;
}

.indextitle {
  display: block;
  font-size: 0.75em;
  text-align: left;
  text-indent: 0;
  margin: 1em 0 0;
}

.logo {
  display: block;
  text-align: center;
  text-indent: 0;
  margin: 1em 0 0;
}

.number {
  display: block;
  font-size: 1em;
  font-weight: normal;
  text-align: justify;
  text-indent: -1.75em;
  margin: 0.25em 0 0.25em 2.5em;
}

.para {
  display: block;
  font-size: 1em;
  font-weight: normal;
  text-align: justify;
  text-indent: 0;
  margin: 0.75em 0;
}

.para1 {
  display: block;
  font-size: 1em;
  font-weight: normal;
  text-align: justify;
  text-indent: 0;
  margin: 0.5em 0 0;
}

.paraindent {
  display: block;
  font-size: 1em;
  font-weight: normal;
  text-align: justify;
  text-indent: 1.25em;
  margin: 0;
}

.right {
  display: block;
  font-size: 1em;
  font-weight: normal;
  text-align: right;
  text-indent: 0;
  margin: 0.5em 0 0.2em;
}

.space {
  padding-left: 1em;
}

.space-b {
  padding-left: 1.5em;
}

.space-r {
  padding-left: 0.65em;
}

.space-r1 {
  padding-left: 0.4em;
}

.space-toc {
  line-height: 1.2;
  padding-left: 1.25em;
}

.space-toc1 {
  padding-left: 1.25em;
}

.space-toc2 {
  padding-left: 0.75em;
}

.space-toc3 {
  line-height: 1.2;
  padding-left: 0.75em;
}

.space1 {
  display: block;
  margin-bottom: 0.7em;
  margin-top: 0.7em;
}

.space1a {
  padding-left: 2.25em;
}

.space1b {
  padding-left: 2.5em;
}

.space2 {
  padding-left: 4em;
}

.space3 {
  padding-left: 6em;
}

.space4 {
  padding-left: 3em;
}

.space5 {
  padding-left: 2em;
}

.space6 {
  padding-left: 10em;
}

.space7 {
  padding-left: 7em;
}

.space8 {
  padding-left: 5em;
}

.theorem {
  display: block;
  font-size: 1em;
  font-weight: normal;
  text-align: justify;
  text-indent: 0;
  margin: 1em 0 0.5em;
}

.toc-chapter {
  display: block;
  font-size: 1.125em;
  font-weight: normal;
  line-height: 1.2;
  text-align: left;
  text-indent: -1.8em;
  margin: 0.75em 0 0.15em 2.05em;
}

.toc-fm {
  display: block;
  font-size: 1em;
  font-style: italic;
  font-weight: normal;
  text-align: left;
  text-indent: 0;
  margin: 0.75em 0 0 2.3em;
}

.toc-fm1 {
  display: block;
  font-size: 1em;
  font-style: italic;
  font-weight: normal;
  text-align: left;
  text-indent: 0;
  margin: 0 0 0 2.3em;
}

.toc-section {
  display: block;
  font-size: 1em;
  font-weight: normal;
  text-align: left;
  text-indent: -2.5em;
  margin: 0.15em 0 0 4.8em;
}</style>
<style>
@page {
  margin-bottom: 5pt;
  margin-top: 5pt;
}</style>
<style>

</style>
<link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>
<body>
<div id="book-container"><div id="titlepage.xhtml"><div>

        <div>
            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="100%" height="100%" viewBox="0 0 453 648" preserveAspectRatio="none">
                <image width="453" height="648" xlink:href="data:image/jpeg;base64,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VWDY4IwfT1rzulqHh6bjyW0vcr20+bmvqenL8T9N0u3mXw54ZttPnlXBlLhsfgFBOOuCcV5vPcS3VxJcTO0ksrF3ZjksSckmoKKunShTu47sU6kp2T6CUUUVZmFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAf/2Q=="></image>
            </svg>
        </div>
    </div></div>
<div id="text/part0000.html"><div id="text/part0000.html.0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre">

<h1 class="half_title" id="text/part0000.html.calibre_pb_0">THINKING FUNCTIONALLY WITH HASKELL</h1>
<p class="para">Richard Bird is famed for the clarity and rigour of his writing. His new textbook, which introduces functional programming to students, emphasises fundamental techniques for reasoning mathematically about functional programs. By studying the underlying equational laws, the book enables students to apply calculational reasoning to their programs, both to understand their properties and to make them more efficient.</p>
<p class="paraindent">The book has been designed to fit a first- or second-year undergraduate course and is a thorough overhaul and replacement of his earlier textbooks. It features case studies in Sudoku and pretty-printing, and over 100 carefully selected exercises with solutions. This engaging text will be welcomed by students and teachers alike.</p>
</div></div>
<div id="text/part0001.html"><div id="text/part0001.html.UGI0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre">

<h1 class="book-title" id="text/part0001.html.calibre_pb_0">THINKING FUNCTIONALLY WITH HASKELL</h1>
<p class="authorname">RICHARD BIRD</p>
<p class="affiliation"><i class="calibre1">University of Oxford</i></p>
<p class="logo"><img src="data:image/jpeg;base64,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" alt="CAMBRIDGE UNIVERSITY PRESS" class="calibre2"></p>
</div></div>
<div id="text/part0002.html"><div id="text/part0002.html.1T140-0daaaafc8385457e8f80971b0d39bbf7" class="calibre">

<p class="copyright-image"><img src="data:image/jpeg;base64,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" alt="image" class="calibre2"></p>
<p class="copyright">University Printing House, Cambridge CB2 8BS, United Kingdom</p>
<p class="copyright1">Cambridge University Press is part of the University of Cambridge.</p>
<p class="copyright1">It furthers the University’s mission by disseminating knowledge in the pursuit of education, learning and research at the highest international levels of excellence.</p>
<p class="copyright"><a href="http://www.cambridge.org" class="calibre3">www.cambridge.org</a><br class="calibre4"><br>Information on this title: <a href="http://www.cambridge.org/9781107087200" class="calibre3">www.cambridge.org/9781107087200</a></p>
<p class="copyright1">© Richard Bird 2015</p>
<p class="copyright1">This publication is in copyright. Subject to statutory exception and to the provisions of relevant collective licensing agreements, no reproduction of any part may take place without the written permission of Cambridge University Press.</p>
<p class="copyright1">First published 2015</p>
<p class="copyright1">Printed in the United Kingdom by CPI Group Ltd, Croydon CR0 4YY</p>
<p class="copyright1"><i class="calibre1">A catalogue record for this publication is available from the British Library</i></p>
<p class="copyright1"><i class="calibre1">Library of Congress Cataloguing in Publication data</i></p>
<p class="copyright">Bird, Richard, 1943-<br class="calibre4"><br>Thinking functionally with Haskell / Richard Bird, University of Oxford.<br class="calibre4"><br>pages cm<br class="calibre4"><br>ISBN 978-1-107-08720-0 (hardback) – ISBN 978-1-107-45264-0 (paperback)<br class="calibre4"><br>1. Functional programming (Computer science) I. Title.<br class="calibre4"><br>QA76.62.B573 2014<br class="calibre4"><br>005.1′14–dc23<br class="calibre4"><br>2014024954</p>
<p class="copyright1">ISBN 978-1-107-08720-0 Hardback<br class="calibre4"><br>ISBN 978-1-107-45264-0 Paperback</p>
<p class="copyright1">Additional resources for this publication at <a href="http://www.cambridge.org/9781107087200" class="calibre3">www.cambridge.org/9781107087200</a></p>
<p class="copyright1">Cambridge University Press has no responsibility for the persistence or accuracy of URLs for external or third-party internet websites referred to in this publication, and does not guarantee that any content on such websites is, or will remain, accurate or appropriate.</p>
</div></div>
<div id="text/part0003.html"><div id="text/part0003.html.2RHM0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre">

<h2 class="fm-title" id="text/part0003.html.calibre_pb_0"><b class="calibre5">Contents</b></h2>
<p class="toc-fm"><a href="#text/part0004.html.3Q280-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3"><i class="calibre1">Preface</i></a></p>
<p class="toc-chapter"><a href="#text/part0005.html.4OIQ0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre6">1<span class="space-toc"></span>What is functional programming?</a></p>
<p class="toc-section"><a href="#text/part0005.html.head1-1" class="calibre3">1.1<span class="space-toc1"></span>Functions and types</a></p>
<p class="toc-section"><a href="#text/part0005.html.head1-2" class="calibre3">1.2<span class="space-toc1"></span>Functional composition</a></p>
<p class="toc-section"><a href="#text/part0005.html.head1-3" class="calibre3">1.3<span class="space-toc1"></span>Example: common words</a></p>
<p class="toc-section"><a href="#text/part0005.html.head1-4" class="calibre3">1.4<span class="space-toc1"></span>Example: numbers into words</a></p>
<p class="toc-section"><a href="#text/part0005.html.head1-5" class="calibre3">1.5<span class="space-toc1"></span>The Haskell Platform</a></p>
<p class="toc-section"><a href="#text/part0005.html.head1-6" class="calibre3">1.6<span class="space-toc1"></span>Exercises</a></p>
<p class="toc-section"><a href="#text/part0005.html.head1-7" class="calibre3">1.7<span class="space-toc1"></span>Answers</a></p>
<p class="toc-section"><a href="#text/part0005.html.head1-8" class="calibre3">1.8<span class="space-toc1"></span>Chapter notes</a></p>
<p class="toc-chapter"><a href="#text/part0006.html.5N3C0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre6">2<span class="space-toc"></span>Expressions, types and values</a></p>
<p class="toc-section"><a href="#text/part0006.html.head2-1" class="calibre3">2.1<span class="space-toc1"></span>A session with GHCi</a></p>
<p class="toc-section"><a href="#text/part0006.html.head2-2" class="calibre3">2.2<span class="space-toc1"></span>Names and operators</a></p>
<p class="toc-section"><a href="#text/part0006.html.head2-3" class="calibre3">2.3<span class="space-toc1"></span>Evaluation</a></p>
<p class="toc-section"><a href="#text/part0006.html.head2-4" class="calibre3">2.4<span class="space-toc1"></span>Types and type classes</a></p>
<p class="toc-section"><a href="#text/part0006.html.head2-5" class="calibre3">2.5<span class="space-toc1"></span>Printing values</a></p>
<p class="toc-section"><a href="#text/part0006.html.head2-6" class="calibre3">2.6<span class="space-toc1"></span>Modules</a></p>
<p class="toc-section"><a href="#text/part0006.html.head2-7" class="calibre3">2.7<span class="space-toc1"></span>Haskell layout</a></p>
<p class="toc-section"><a href="#text/part0006.html.head2-8" class="calibre3">2.8<span class="space-toc1"></span>Exercises</a></p>
<p class="toc-section"><a href="#text/part0006.html.head2-9" class="calibre3">2.9<span class="space-toc1"></span>Answers</a></p>
<p class="toc-section"><a href="#text/part0006.html.head2-10" class="calibre3">2.10<span class="space-toc2"></span>Chapter notes</a></p>
<p class="toc-chapter"><a href="#text/part0007.html.6LJU0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre6">3<span class="space-toc"></span>Numbers</a></p>
<p class="toc-section"><a href="#text/part0007.html.head3-1" class="calibre3">3.1<span class="space-toc1"></span>The type class <span class="font">Num</span></a></p>
<p class="toc-section"><a href="#text/part0007.html.head3-2" class="calibre3">3.2<span class="space-toc1"></span>Other numeric type classes</a></p>
<p class="toc-section"><a href="#text/part0007.html.head3-3" class="calibre3">3.3<span class="space-toc1"></span>Computing floors</a></p>
<p class="toc-section"><a href="#text/part0007.html.head3-4" class="calibre3">3.4<span class="space-toc1"></span>Natural numbers</a></p>
<p class="toc-section"><a href="#text/part0007.html.head3-5" class="calibre3">3.5<span class="space-toc1"></span>Exercises</a></p>
<p class="toc-section"><a href="#text/part0007.html.head3-6" class="calibre3">3.6<span class="space-toc1"></span>Answers</a></p>
<p class="toc-section"><a href="#text/part0007.html.head3-7" class="calibre3">3.7<span class="space-toc1"></span>Chapter notes</a></p>
<p class="toc-chapter"><a href="#text/part0008.html.7K4G0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre6">4<span class="space-toc"></span>Lists</a></p>
<p class="toc-section"><a href="#text/part0008.html.head4-1" class="calibre3">4.1<span class="space-toc1"></span>List notation</a></p>
<p class="toc-section"><a href="#text/part0008.html.head4-2" class="calibre3">4.2<span class="space-toc1"></span>Enumerations</a></p>
<p class="toc-section"><a href="#text/part0008.html.head4-3" class="calibre3">4.3<span class="space-toc1"></span>List comprehensions</a></p>
<p class="toc-section"><a href="#text/part0008.html.head4-4" class="calibre3">4.4<span class="space-toc1"></span>Some basic operations</a></p>
<p class="toc-section"><a href="#text/part0008.html.head4-5" class="calibre3">4.5<span class="space-toc1"></span>Concatenation</a></p>
<p class="toc-section"><a href="#text/part0008.html.head4-6" class="calibre3">4.6<span class="space-toc1"></span><span class="font">concat</span>, <span class="font">map</span> and <span class="font">filter</span></a></p>
<p class="toc-section"><a href="#text/part0008.html.head4-7" class="calibre3">4.7<span class="space-toc1"></span><span class="font">zip</span> and <span class="font">zipWith</span></a></p>
<p class="toc-section"><a href="#text/part0008.html.head4-8" class="calibre3">4.8<span class="space-toc1"></span>Common words, completed</a></p>
<p class="toc-section"><a href="#text/part0008.html.head4-9" class="calibre3">4.9<span class="space-toc1"></span>Exercises</a></p>
<p class="toc-section"><a href="#text/part0008.html.head4-10" class="calibre3">4.10<span class="space-toc2"></span>Answers</a></p>
<p class="toc-section"><a href="#text/part0008.html.head4-11" class="calibre3">4.11<span class="space-toc2"></span>Chapter notes</a></p>
<p class="toc-chapter"><a href="#text/part0009.html.8IL20-0daaaafc8385457e8f80971b0d39bbf7" class="calibre6">5<span class="space-toc"></span>A simple Sudoku solver</a></p>
<p class="toc-section"><a href="#text/part0009.html.head5-1" class="calibre3">5.1<span class="space-toc1"></span>Specification</a></p>
<p class="toc-section"><a href="#text/part0009.html.head5-2" class="calibre3">5.2<span class="space-toc1"></span>Lawful program construction</a></p>
<p class="toc-section"><a href="#text/part0009.html.head5-3" class="calibre3">5.3<span class="space-toc1"></span>Pruning the matrix of choices</a></p>
<p class="toc-section"><a href="#text/part0009.html.head5-4" class="calibre3">5.4<span class="space-toc1"></span>Expanding a single cell</a></p>
<p class="toc-section"><a href="#text/part0009.html.head5-5" class="calibre3">5.5<span class="space-toc1"></span>Exercises</a></p>
<p class="toc-section"><a href="#text/part0009.html.head5-6" class="calibre3">5.6<span class="space-toc1"></span>Answers</a></p>
<p class="toc-section"><a href="#text/part0009.html.head5-7" class="calibre3">5.7<span class="space-toc1"></span>Chapter notes</a></p>
<p class="toc-chapter"><a href="#text/part0010.html.9H5K0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre6">6<span class="space-toc"></span>Proofs</a></p>
<p class="toc-section"><a href="#text/part0010.html.head6-1" class="calibre3">6.1<span class="space-toc1"></span>Induction over natural numbers</a></p>
<p class="toc-section"><a href="#text/part0010.html.head6-2" class="calibre3">6.2<span class="space-toc1"></span>Induction over lists</a></p>
<p class="toc-section"><a href="#text/part0010.html.head6-3" class="calibre3">6.3<span class="space-toc1"></span>The function <span class="font">foldr</span></a></p>
<p class="toc-section"><a href="#text/part0010.html.head6-4" class="calibre3">6.4<span class="space-toc1"></span>The function <span class="font">foldl</span></a></p>
<p class="toc-section"><a href="#text/part0010.html.head6-5" class="calibre3">6.5<span class="space-toc1"></span>The function <span class="font">scanl</span></a></p>
<p class="toc-section"><a href="#text/part0010.html.head6-6" class="calibre3">6.6<span class="space-toc1"></span>The maximum segment sum</a></p>
<p class="toc-section"><a href="#text/part0010.html.head6-7" class="calibre3">6.7<span class="space-toc1"></span>Exercises</a></p>
<p class="toc-section"><a href="#text/part0010.html.head6-8" class="calibre3">6.8<span class="space-toc1"></span>Answers</a></p>
<p class="toc-section"><a href="#text/part0010.html.head6-9" class="calibre3">6.9<span class="space-toc1"></span>Chapter notes</a></p>
<p class="toc-chapter"><a href="#text/part0011.html.AFM60-0daaaafc8385457e8f80971b0d39bbf7" class="calibre6">7<span class="space-toc"></span>Efficiency</a></p>
<p class="toc-section"><a href="#text/part0011.html.head7-1" class="calibre3">7.1<span class="space-toc1"></span>Lazy evaluation</a></p>
<p class="toc-section"><a href="#text/part0011.html.head7-2" class="calibre3">7.2<span class="space-toc1"></span>Controlling space</a></p>
<p class="toc-section"><a href="#text/part0011.html.head7-3" class="calibre3">7.3<span class="space-toc1"></span>Controlling time</a></p>
<p class="toc-section"><a href="#text/part0011.html.head7-4" class="calibre3">7.4<span class="space-toc1"></span>Analysing time</a></p>
<p class="toc-section"><a href="#text/part0011.html.head7-5" class="calibre3">7.5<span class="space-toc1"></span>Accumulating parameters</a></p>
<p class="toc-section"><a href="#text/part0011.html.head7-6" class="calibre3">7.6<span class="space-toc1"></span>Tupling</a></p>
<p class="toc-section"><a href="#text/part0011.html.head7-7" class="calibre3">7.7<span class="space-toc1"></span>Sorting</a></p>
<p class="toc-section"><a href="#text/part0011.html.head7-8" class="calibre3">7.8<span class="space-toc1"></span>Exercises</a></p>
<p class="toc-section"><a href="#text/part0011.html.head7-9" class="calibre3">7.9<span class="space-toc1"></span>Answers</a></p>
<p class="toc-section"><a href="#text/part0011.html.head7-10" class="calibre3">7.10<span class="space-toc2"></span>Chapter notes</a></p>
<p class="toc-chapter"><a href="#text/part0012.html.BE6O0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre6">8<span class="space-toc"></span>Pretty-printing</a></p>
<p class="toc-section"><a href="#text/part0012.html.head8-1" class="calibre3">8.1<span class="space-toc1"></span>Setting the scene</a></p>
<p class="toc-section"><a href="#text/part0012.html.head8-2" class="calibre3">8.2<span class="space-toc1"></span>Documents</a></p>
<p class="toc-section"><a href="#text/part0012.html.head8-3" class="calibre3">8.3<span class="space-toc1"></span>A direct implementation</a></p>
<p class="toc-section"><a href="#text/part0012.html.head8-4" class="calibre3">8.4<span class="space-toc1"></span>Examples</a></p>
<p class="toc-section"><a href="#text/part0012.html.head8-5" class="calibre3">8.5<span class="space-toc1"></span>The best layout</a></p>
<p class="toc-section"><a href="#text/part0012.html.head8-6" class="calibre3">8.6<span class="space-toc1"></span>A term representation</a></p>
<p class="toc-section"><a href="#text/part0012.html.head8-7" class="calibre3">8.7<span class="space-toc1"></span>Exercises</a></p>
<p class="toc-section"><a href="#text/part0012.html.head8-8" class="calibre3">8.8<span class="space-toc1"></span>Answers</a></p>
<p class="toc-section"><a href="#text/part0012.html.head8-9" class="calibre3">8.9<span class="space-toc1"></span>Chapter notes</a></p>
<p class="toc-chapter"><a href="#text/part0013.html.CCNA0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre6">9<span class="space-toc"></span>Infinite lists</a></p>
<p class="toc-section"><a href="#text/part0013.html.head9-1" class="calibre3">9.1<span class="space-toc1"></span>Review</a></p>
<p class="toc-section"><a href="#text/part0013.html.head9-2" class="calibre3">9.2<span class="space-toc1"></span>Cyclic lists</a></p>
<p class="toc-section"><a href="#text/part0013.html.head9-3" class="calibre3">9.3<span class="space-toc1"></span>Infinite lists as limits</a></p>
<p class="toc-section"><a href="#text/part0013.html.head9-4" class="calibre3">9.4<span class="space-toc1"></span>Paper–rock–scissors</a></p>
<p class="toc-section"><a href="#text/part0013.html.head9-5" class="calibre3">9.5<span class="space-toc1"></span>Stream-based interaction</a></p>
<p class="toc-section"><a href="#text/part0013.html.head9-6" class="calibre3">9.6<span class="space-toc1"></span>Doubly-linked lists</a></p>
<p class="toc-section"><a href="#text/part0013.html.head9-7" class="calibre3">9.7<span class="space-toc1"></span>Exercises</a></p>
<p class="toc-section"><a href="#text/part0013.html.head9-8" class="calibre3">9.8<span class="space-toc1"></span>Answers</a></p>
<p class="toc-section"><a href="#text/part0013.html.head9-9" class="calibre3">9.9<span class="space-toc1"></span>Chapter notes</a></p>
<p class="toc-chapter"><a href="#text/part0014.html.DB7S0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre6">10<span class="space-toc3"></span>Imperative functional programming</a></p>
<p class="toc-section"><a href="#text/part0014.html.head10-1" class="calibre3">10.1<span class="space-toc2"></span>The <span class="font">IO</span> monad</a></p>
<p class="toc-section"><a href="#text/part0014.html.head10-2" class="calibre3">10.2<span class="space-toc2"></span>More monads</a></p>
<p class="toc-section"><a href="#text/part0014.html.head10-3" class="calibre3">10.3<span class="space-toc2"></span>The <span class="font">State</span> monad</a></p>
<p class="toc-section"><a href="#text/part0014.html.head10-4" class="calibre3">10.4<span class="space-toc2"></span>The <span class="font">ST</span> monad</a></p>
<p class="toc-section"><a href="#text/part0014.html.head10-5" class="calibre3">10.5<span class="space-toc2"></span>Mutable arrays</a></p>
<p class="toc-section"><a href="#text/part0014.html.head10-6" class="calibre3">10.6<span class="space-toc2"></span>Immutable arrays</a></p>
<p class="toc-section"><a href="#text/part0014.html.head10-7" class="calibre3">10.7<span class="space-toc2"></span>Exercises</a></p>
<p class="toc-section"><a href="#text/part0014.html.head10-8" class="calibre3">10.8<span class="space-toc2"></span>Answers</a></p>
<p class="toc-section"><a href="#text/part0014.html.head10-9" class="calibre3">10.9<span class="space-toc2"></span>Chapter notes</a></p>
<p class="toc-chapter"><a href="#text/part0015.html.E9OE0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre6">11<span class="space-toc3"></span>Parsing</a></p>
<p class="toc-section"><a href="#text/part0015.html.head11-1" class="calibre3">11.1<span class="space-toc2"></span>Parsers as monads</a></p>
<p class="toc-section"><a href="#text/part0015.html.head11-2" class="calibre3">11.2<span class="space-toc2"></span>Basic parsers</a></p>
<p class="toc-section"><a href="#text/part0015.html.head11-3" class="calibre3">11.3<span class="space-toc2"></span>Choice and repetition</a></p>
<p class="toc-section"><a href="#text/part0015.html.head11-4" class="calibre3">11.4<span class="space-toc2"></span>Grammars and expressions</a></p>
<p class="toc-section"><a href="#text/part0015.html.head11-5" class="calibre3">11.5<span class="space-toc2"></span>Showing expressions</a></p>
<p class="toc-section"><a href="#text/part0015.html.head11-6" class="calibre3">11.6<span class="space-toc2"></span>Exercises</a></p>
<p class="toc-section"><a href="#text/part0015.html.head11-7" class="calibre3">11.7<span class="space-toc2"></span>Answers</a></p>
<p class="toc-section"><a href="#text/part0015.html.head11-8" class="calibre3">11.8<span class="space-toc2"></span>Chapter notes</a></p>
<p class="toc-chapter"><a href="#text/part0016.html.F8900-0daaaafc8385457e8f80971b0d39bbf7" class="calibre6">12<span class="space-toc3"></span>A simple equational calculator</a></p>
<p class="toc-section"><a href="#text/part0016.html.head12-1" class="calibre3">12.1<span class="space-toc2"></span>Basic considerations</a></p>
<p class="toc-section"><a href="#text/part0016.html.head12-2" class="calibre3">12.2<span class="space-toc2"></span>Expressions</a></p>
<p class="toc-section"><a href="#text/part0016.html.head12-3" class="calibre3">12.3<span class="space-toc2"></span>Laws</a></p>
<p class="toc-section"><a href="#text/part0016.html.head12-4" class="calibre3">12.4<span class="space-toc2"></span>Calculations</a></p>
<p class="toc-section"><a href="#text/part0016.html.head12-5" class="calibre3">12.5<span class="space-toc2"></span>Rewrites</a></p>
<p class="toc-section"><a href="#text/part0016.html.head12-6" class="calibre3">12.6<span class="space-toc2"></span>Matchings</a></p>
<p class="toc-section"><a href="#text/part0016.html.head12-7" class="calibre3">12.7<span class="space-toc2"></span>Substitutions</a></p>
<p class="toc-section"><a href="#text/part0016.html.head12-8" class="calibre3">12.8<span class="space-toc2"></span>Testing the calculator</a></p>
<p class="toc-section"><a href="#text/part0016.html.head12-9" class="calibre3">12.9<span class="space-toc2"></span>Exercises</a></p>
<p class="toc-section"><a href="#text/part0016.html.head12-10" class="calibre3">12.10<span class="space-toc2"></span>Answers</a></p>
<p class="toc-section"><a href="#text/part0016.html.head12-11" class="calibre3">12.11<span class="space-toc2"></span>Chapter notes</a></p>
<p class="toc-fm1"><a href="#text/part0017.html.G6PI0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3"><i class="calibre1">Index</i></a></p>
</div></div>
<div id="text/part0004.html"><div id="text/part0004.html.3Q280-0daaaafc8385457e8f80971b0d39bbf7" class="calibre">

<h2 class="fm_title" id="text/part0004.html.calibre_pb_0"><a id="text/part0004.html.page_ix" class="calibre6"></a>Preface</h2>
<p class="para">The present book is a completely rewritten version of the second edition of my <i class="calibre1">Introduction to Functional Programming using Haskell</i> (Prentice Hall). The main changes are: a reorganisation of some introductory material to reflect the needs of a one or two term lecture course; a fresh set of case studies; and a collection of over 100 exercises that now actually contain answers. As before, no knowledge of computers or programming is assumed, so the material is suitable as a first course in computing.</p>
<p class="para">Every author has his or her own drum to beat when writing a textbook, and the present one is no different. While there are now numerous books, tutorials, articles and blogs devoted to Haskell, few of them emphasise what seems to me the main reason why functional programming is the best thing since sliced bread: the ability to think mathematically about functional programs. And the mathematics involved is neither new nor difficult. Any student who has come to grips with, say, high-school trigonometry and has applied simple trigonometric laws and identities to simplify expressions involving sines and cosines (a typical example: express sin 3<i class="calibre1">α</i> in terms of sin <i class="calibre1">α</i>) will quickly appreciate that a similar activity is being proposed for programming problems. And the payoff is there at the terminal: faster computations. Even after 30 years I still get a great deal of pleasure from writing down a simple, obvious, but inefficient way to solve a problem, applying some well-known equational laws, and coming up with another solution that is ten times faster. Well, if I’m lucky.</p>
<p class="para">If the message of the last paragraph turns you off, if you are perpetually running away from the Mordor of Mathematics, then the present book is probably not for you. Probably, but not necessarily so (nobody likes to lose customers). There is still pleasure to be gained in learning a novel and exciting way to write programs. Even programmers who for one reason or another do not or cannot use Haskell <a id="text/part0004.html.page_x" class="calibre3"></a>in their daily work, and certainly do not have the time to spend calculating better answers to their problems, have still been inspired by the enjoyment of learning Haskell and are hugely appreciative of its ability to express computational ideas and methods simply and briefly. In fact, the ability to express programming ideas in a purely functional style has been slowly incorporated into mainstream imperative programming languages, such as Python, Visual Basic, and C#.</p>
<p class="para">One final but important point: Haskell is a large language and this book by no means covers all of it. It is not a reference guide to Haskell. Although details of the language appear on almost every page, especially in the earlier chapters, my primary intention is to convey the essence of functional programming, the idea of thinking functionally about programs, not to dwell too much on the particulars of one specific language. But over the years Haskell has absorbed and codified most of the ideas of functional programming expressed in earlier functional languages, such as SASL, KRC, Miranda, Orwell and Gofer, and it is difficult to resist the temptation to explain everything in terms of this one super-cool language.</p>
<p class="para">Most of the programs recorded in this book can be found on the website</p>
<p class="center"><span class="font"><a href="http://www.cs.ox.ac.uk/publications/books/functional" class="calibre3">www.cs.ox.ac.uk/publications/books/functional</a></span></p>
<p class="para">It is hoped to add more exercises (and answers), suggestions for projects, and so on, in due course. For more information about Haskell, the site <span class="font"><a href="http://www.haskell.org" class="calibre3">www.haskell.org</a></span> should be your first port of call.</p>
<p class="fm_titlea">Acknowledgements</p>
<p class="para">The present book arose out of lecture notes I prepared based on the second edition. It has benefited enormously from the comments and suggestions by tutors and students. Others have emailed me with constructive comments and criticisms, or simply to point out typos and silly mistakes. These include: Nils Andersen, Ani Calinescu, Franklin Chen, Sharon Curtis, Martin Filby, Simon Finn, Jeroen Fokker, Maarten Fokkinga, Jeremy Gibbons, Robert Giegerich, Kevin Hammond, Ralf Hinze, Gerard Huet, Michael Hinchey, Tony Hoare, Iain Houston, John Hughes, Graham Hutton, Cezar Ionescu, Stephen Jarvis, Geraint Jones, Mark Jones, John Launchbury, Paul Licameli, David Lester, Iain MacCullum, Ursula Martin, Lambert Meertens, Erik Meijer, Quentin Miller, Oege de Moor, Chris Okasaki, Oskar Permvall, Simon Peyton Jones, Mark Ramaer, Hamilton Richards, Dan Russell, Don Sannella, Antony Simmons, Deepak D’Souza, John Spanondakis, Mike Spivey, Joe Stoy, Bernard Sufrin, Masato Takeichi, Peter Thiemann, David Turner, Colin Watson, and Stephen Wilson. In particular, Jeremy Gibbons, Bernard Sufrin <a id="text/part0004.html.page_xi" class="calibre3"></a>and José Pedro Magalhǎes have read drafts of the manuscript and suggested a number of corrections.</p>
<p class="para">I would also like to thank David Tranah, my editor at CUP, for continued advice and support. My status now is emeritus professor at the Department of Computer Science at Oxford, and I would like to thank the department and its head, Bill Roscoe, for continuing to make facilities available.</p>
<p class="right">Richard Bird</p>
<p class="center"><b class="calibre7">Exercises</b></p>
<p class="theorem"><b class="calibre7">Exercise A</b></p>
<p class="para">Express sin 3<i class="calibre1">α</i> in terms of sin <i class="calibre1">α</i>.</p>
<p class="center"><b class="calibre7">Answers</b></p>
<p class="theorem"><b class="calibre7">Answer to Exercise A</b></p>
<p class="code"><span class="space"></span>sin 3<i class="calibre1">α</i></p>
<p class="code">=<span class="space"></span>{arithmetic}</p>
<p class="code"><span class="space"></span>sin(2<i class="calibre1">α</i> + <i class="calibre1">α</i>)</p>
<p class="code">=<span class="space"></span>{since sin(<i class="calibre1">α</i> + <i class="calibre1">β</i>) =sin <i class="calibre1">α</i> cos <i class="calibre1">β</i> + cos <i class="calibre1">α</i> sin <i class="calibre1">β</i>}</p>
<p class="code"><span class="space"></span>sin 2<i class="calibre1">α</i> cos <i class="calibre1">α</i> + cos 2<i class="calibre1">α</i> sin <i class="calibre1">α</i></p>
<p class="code">=<span class="space"></span>{since sin 2<i class="calibre1">α</i> = 2 sin <i class="calibre1">α</i> cos <i class="calibre1">α</i>}</p>
<p class="code"><span class="space"></span>2 sin <i class="calibre1">α</i> cos<sup class="calibre8">2</sup> <i class="calibre1">α</i> + cos 2<i class="calibre1">α</i> sin <i class="calibre1">α</i></p>
<p class="code">=<span class="space"></span>{since cos 2<i class="calibre1">α</i> = cos<sup class="calibre8">2</sup> <i class="calibre1">α −</i> sin<sup class="calibre8">2</sup> <i class="calibre1">α</i>}</p>
<p class="code"><span class="space"></span>2 sin <i class="calibre1">α</i> cos<sup class="calibre8">2</sup> <i class="calibre1">α</i> +(cos<sup class="calibre8">2</sup> <i class="calibre1">α −</i> sin<sup class="calibre8">2</sup> <i class="calibre1">α</i>)sin <i class="calibre1">α</i></p>
<p class="code">=<span class="space"></span>{since sin<sup class="calibre8">2</sup> <i class="calibre1">α</i> + cos<sup class="calibre8">2</sup> <i class="calibre1">α</i> = 1}</p>
<p class="code"><span class="space"></span>sin <i class="calibre1">α</i>(3 <i class="calibre1">−</i> 4 sin<sup class="calibre8">2</sup> <i class="calibre1">α</i>)</p>
<p class="para">The above proof format was, I believe, invented by Wim Feijen. It will be used throughout the book.</p>
</div></div>
<div id="text/part0005.html"><div id="text/part0005.html.4OIQ0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre">

<h2 class="chapter-number" id="text/part0005.html.calibre_pb_0"><a id="text/part0005.html.page_1" class="calibre6"></a>Chapter 1</h2>
<h2 class="chapter-title">What is functional programming?</h2>
<p class="para">In a nutshell:</p>
<ul class="calibre9">
<li class="calibre10">Functional programming is a method of program construction that emphasises functions and their application rather than commands and their execution.</li>
<li class="calibre10">Functional programming uses simple mathematical notation that allows problems to be described clearly and concisely.</li>
<li class="calibre10">Functional programming has a simple mathematical basis that supports equational reasoning about the properties of programs.</li>
</ul>
<p class="para">Our aim in this book is to illustrate these three key points, using a specific functional language called Haskell.</p>
<h3 class="h" id="text/part0005.html.head1-1">1.1 Functions and types</h3>
<p class="para">We will use the Haskell notation</p>
<p class="code"><span class="font">f :: X -&gt; Y</span></p>
<p class="para">to assert that <span class="font">f</span> is a function taking arguments of type <span class="font">X</span> and returning results of type <span class="font">Y</span>. For example,</p>
<div class="space1">
<p class="code"><span class="font">sin</span><span class="space2"></span><span class="font">:: Float -&gt; Float</span></p>
<p class="code"><span class="font">age</span><span class="space2"></span><span class="font">:: Person -&gt; Int</span></p>
<p class="code"><span class="font">add</span><span class="space2"></span><span class="font">:: (Integer,Integer) -&gt; Integer</span></p>
<p class="code"><span class="font">logBase</span><span class="space"></span><span class="space-r"></span><span class="font">:: Float -&gt; (Float -&gt; Float)</span></p>
</div>
<p class="para"><span class="font">Float</span> is the type of floating-point numbers, things like 3.14159, and <span class="font">Int</span> is the type of limited-precision integers, integers <i class="calibre1">n</i> that lie in a restricted range such as <a id="text/part0005.html.page_2" class="calibre3"></a>−2<sup class="calibre8">29</sup> ≤ <i class="calibre1">n</i> &lt; 2<sup class="calibre8">29</sup>. The restriction is lifted with the type <span class="font">Integer</span>, which is the type of unlimited-precision integers. As we will see in <a href="#text/part0007.html.6LJU0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 3</a>, numbers in Haskell come in many flavours.</p>
<p class="para">In mathematics one usually writes <i class="calibre1">f</i> (<i class="calibre1">x</i>) to denote the application of the function <i class="calibre1">f</i> to the argument <i class="calibre1">x</i>. But we also write, for example, sin <i class="calibre1">θ</i> rather than sin(<i class="calibre1">θ</i>). In Haskell we can always write <span class="font">f x</span> for the application of <span class="font">f</span> to the argument <span class="font">x</span>. The operation of application can be denoted using a space. If there are no parentheses the space is necessary to avoid confusion with multi-letter names: <span class="font">latex</span> is a name but <span class="font">late x</span> denotes the application of a function <span class="font">late</span> to an argument <span class="font">x</span>.</p>
<p class="para">As examples, <span class="font">sin 3.14</span> or <span class="font">sin (3.14)</span> or <span class="font">sin(3.14)</span> are three legitimate ways of writing the application of the function <span class="font">sin</span> to the argument <span class="font">3.14</span>.</p>
<p class="para">Similarly, <span class="font">logBase 2 10</span> or <span class="font">(logBase 2) 10</span> or <span class="font">(logBase 2)(10)</span> are all legitimate ways of writing the logarithm to base 2 of the number 10. But the expression <span class="font">logBase (2 10)</span> is incorrect. Parentheses are needed in writing <span class="font">add (3,4)</span> for the sum of 3 and 4 because the argument of <span class="font">add</span> is declared above as a pair of integers and pairs are expressed with parentheses and commas.</p>
<p class="para">Look again at the type of <span class="font">logBase</span>. It takes a floating point number as argument, and returns a function as result. At first sight that might seem strange, but at second sight it shouldn’t: the mathematical functions log<sub class="calibre11">2</sub> and log<sub class="calibre11"><i class="calibre1">e</i></sub> are exactly what is provided by <span class="font">logBase 2</span> and <span class="font">logBase e</span>.</p>
<p class="para">In mathematics one can encounter expressions like logsin <i class="calibre1">x</i>. To the mathematician that means log(sin <i class="calibre1">x</i>), since the alternative (log sin) <i class="calibre1">x</i> doesn’t make sense. But in Haskell one has to say what one means, and one has to write <span class="font">log (sin x)</span> because <span class="font">log sin x</span> is read by Haskell as <span class="font">(log sin) x</span>. Functional application in Haskell <i class="calibre1">associates</i> to the left in expressions and also has the highest <i class="calibre1">binding power</i>. (By the way, <span class="font">log</span> is the Haskell abbreviation for <span class="font">logBase e</span>.)</p>
<p class="para">Here is another example. In trigonometry one can write</p>
<p class="equationasimage">sin 2<i class="calibre1">θ</i> = 2 sin <i class="calibre1">θ</i> cos <i class="calibre1">θ</i>.</p>
<p class="para">In Haskell one has to write</p>
<p class="code"><span class="font">sin (2*theta) = 2 * sin theta * cos theta</span></p>
<p class="para">Not only do we have to make the multiplications explicit, we also have to put in parentheses to say exactly what we mean. We could have added a couple more and written <a id="text/part0005.html.page_3" class="calibre3"></a>but the additional parentheses are not necessary because functional application binds tighter than multiplication.</p>
<p class="code"><span class="font">sin (2*theta) = 2 * (sin theta) * (cos theta)</span></p>
<h3 class="h" id="text/part0005.html.head1-2">1.2 Functional composition</h3>
<p class="para">Suppose <span class="font">f :: Y -&gt; Z</span> and <span class="font">g :: X -&gt; Y</span> are two given functions. We can combine them into a new function</p>
<p class="code"><span class="font">f . g :: X -&gt; Z</span></p>
<p class="para">that first applies <span class="font">g</span> to an argument of type <span class="font">X</span>, giving a result of type <span class="font">Y</span>, and then applies <span class="font">f</span> to this result, giving a final result of type <span class="font">Z</span>. We always say that functions take <i class="calibre1">arguments</i> and return <i class="calibre1">results</i>. In fact we have</p>
<p class="code"><span class="font">(f . g) x = f (g x)</span></p>
<p class="para">The order of composition is from right to left because we write functions to the left of the arguments to which they are applied. In English we write ‘green pig’ and interpret adjectives such as ‘green’ as functions taking noun phrases to noun phrases. Of course, in French . . .</p>
<h3 class="h" id="text/part0005.html.head1-3">1.3 Example: common words</h3>
<p class="para">Let us illustrate the importance of functional composition by solving a problem. What are the 100 most common words in <i class="calibre1">War and Peace</i>? What are the 50 most common words in <i class="calibre1">Love’s Labours Lost</i>? We will write a functional program to find out. Well, perhaps we are not yet ready for a complete program, but we can construct enough of one to capture the essential spirit of functional programming.</p>
<p class="para">What is given? Answer: a <i class="calibre1">text</i>, which is a list of characters, containing visible characters like <span class="font">'B'</span> and <span class="font">','</span>, and blank characters like spaces and newlines (<span class="font">' '</span> and <span class="font">'\n'</span>). Note that individual characters are denoted using single quotes. Thus <span class="font">'f'</span> is a character, while <span class="font">f</span> is a name. The Haskell type <span class="font">Char</span> is the type of characters, and the type of lists whose elements are of type <span class="font">Char</span> is denoted by <span class="font">[Char]</span>. This notation is not special to characters, so <span class="font">[Int]</span> denotes a list of integers, and <span class="font">[Float -&gt; Float]</span> a list of functions.</p>
<p class="para">What is wanted as output? Answer: something like</p>
<div class="space1">
<p class="code"><span class="font">the: 154</span></p>
<p class="code"><span class="font">of: 50</span></p>
<p class="code"><a id="text/part0005.html.page_4" class="calibre3"></a><span class="font">a: 18</span></p>
<p class="code"><span class="font">and: 12</span></p>
<p class="code"><span class="font">in: 11</span></p>
</div>
<p class="para">This display is also a list of characters, in fact it is the list</p>
<p class="code"><span class="font">" the: 154\n of: 50\n a: 18\n and: 12\n in: 11\n"</span></p>
<p class="para">Lists of characters are denoted using double quotes. More on this in the exercises.</p>
<p class="para">So we want to design a function, <span class="font">commonWords</span> say, with type</p>
<p class="code"><span class="font">commonWords :: Int -&gt; [Char] -&gt; [Char]</span></p>
<p class="para">The function <span class="font">commonWords n</span> takes a list of characters and returns a list of the <span class="font">n</span> most common words in the list as a <i class="calibre1">string</i> (another name for a list of characters) in the form described above. The type of <span class="font">commonWords</span> is written without parentheses, though we can put them in:</p>
<p class="code"><span class="font">commonWords :: Int -&gt; ([Char] -&gt; [Char])</span></p>
<p class="para">Whenever two <span class="font">-&gt;</span> signs are adjacent in a type, the order of association is from right to left, exactly the opposite convention of functional application. So <span class="font">A -&gt; B -&gt; C</span> means <span class="font">A -&gt; (B -&gt; C)</span>. If you want to describe the type <span class="font">(A -&gt; B) -&gt; C</span> you have to put in the parentheses. More on this in the next chapter.</p>
<p class="para">Having understood precisely what is given and what is wanted, different people come up with different ways of solving the problem, and express different worries about various parts of the problem. For example, what is a ‘word’ and how do you convert a list of characters into a list of words? Are the words <span class="font">"Hello"</span>, <span class="font">"hello"</span> and <span class="font">"Hello!"</span> distinct words or the same word? How do you count words? Do you count all the words or just the most common ones? And so on. Some find these details daunting and overwhelming. Most seem to agree that at some intermediate point in the computation we have to come up with a list of words and their frequencies, but how do we get from there to the final destination? Do we go through the list <span class="font">n</span> times, extracting the word with the next highest frequency at each pass, or is there something better?</p>
<p class="para">Let’s start with what a word is, and just assert that a word is a maximal sequence of characters not containing spaces or newline characters. That allows words like <span class="font">"Hello!"</span>, or <span class="font">"3*4"</span> or <span class="font">"Thelma&amp;Louise"</span> but never mind. In a text a word is identified by being surrounded by blank characters, so <span class="font">"Thelma and Louise"</span> contains three words.</p>
<p class="para"><a id="text/part0005.html.page_5" class="calibre3"></a>We are not going to worry about how to split a text up into a list of its component words. Instead we just assume the existence of a function</p>
<p class="code"><span class="font">words :: [Char] -&gt; [[Char]]</span></p>
<p class="para">that does the job. Types like <span class="font">[[Char]]</span> can be difficult to comprehend, but in Haskell we can always introduce <i class="calibre1">type synonyms</i>:</p>
<div class="space1">
<p class="code"><span class="font">type Text = [Char]</span></p>
<p class="code"><span class="font">type Word = [Char]</span></p>
</div>
<p class="para">So now we have <span class="font">words :: Text -&gt; [Word]</span>, which is much easier on the brain. Of course, a text is different from a word in that the former can contain blank characters and the latter cannot, but type synonyms in Haskell do not support such subtle distinctions. In fact, <span class="font">words</span> is a library function in Haskell, so we don’t have to define it ourselves.</p>
<p class="para">There is still the issue of whether <span class="font">"The"</span> and <span class="font">"the"</span> denote the same or different words. They really should be the same word, and one way of achieving this is to convert all the letters in the text to lowercase, leaving everything else unchanged. To this end, we need a function <span class="font">toLower :: Char -&gt; Char</span> that converts uppercase letters to lowercase and leaves everything else unchanged. In order to apply this function to every character in the text we need a general function</p>
<p class="code"><span class="font">map :: (a -&gt; b) -&gt; [a] -&gt; [b]</span></p>
<p class="para">such that <span class="font">map f</span> applied to a list applies <span class="font">f</span> to every element of the list. So, converting everything to lowercase is done by the function</p>
<p class="code"><span class="font">map toLower :: Text -&gt; Text</span></p>
<p class="para">Good. At this point we have <span class="font">words . map toLower</span> as the function which converts a text into a list of words in lowercase. The next task is to count the number of occurrences of each word. We could go through the list of words, checking to see whether the next word is new or has been seen before, and either starting a new count for a new word or incrementing the count for an existing word. But there is a conceptually simpler method, namely to <i class="calibre1">sort</i> the list of words into alphabetical order, thereby bringing all duplicated words together in the list. Humans would not do it this way, but the idea of sorting a list to make information available is probably the single most important algorithmic idea in computing. So, let us assume the existence of a function</p>
<p class="code"><span class="font">sortWords :: [Word] -&gt; [Word]</span></p>
<p class="para">that sorts the list of words into alphabetical order. For example,</p>
<p class="code"><a id="text/part0005.html.page_6" class="calibre3"></a><span class="font">sortWords ["to","be","or","not","to","be"]</span></p>
<p class="code1"><span class="font">= ["be","be","not","or","to","to"]</span></p>
<p class="para">Now we want to count the runs of adjacent occurrences of each word in the sorted list. Suppose we have a function</p>
<p class="code"><span class="font">countRuns :: [Word] -&gt; [(Int,Word)]</span></p>
<p class="para">that counts the words. For example,</p>
<p class="code"><span class="font">countRuns ["be","be","not","or","to","to"]</span></p>
<p class="code2"><span class="font">= [(2,"be"),(1,"not"),(1,"or"),(2,"to")]</span></p>
<p class="para">The result is a list of words and their counts in alphabetical order of the words.</p>
<p class="para">Now comes the key idea: we want the information in the list to be ordered not by word, but by decreasing order of count. Rather than thinking of something more clever, we see that this is just another version of sorting. As we said above, sorting is a <i class="calibre1">really</i> useful method in programming. So suppose we have a function</p>
<p class="code"><span class="font">sortRuns :: [(Int,Word)] -&gt; [(Int,Word)]</span></p>
<p class="para">that sorts the list of runs into descending order of count (the first component of each element). For example,</p>
<p class="code"><span class="font">sortRuns [(2,"be"),(1,"not"),(1,"or"),(2,"to")]</span></p>
<p class="code3"><span class="font">= [(2,"be"),(2,"to"),(1,"not"),(1,"or")]</span></p>
<p class="para">The next step is simply to take the first <span class="font">n</span> elements of the result. For this we need a function</p>
<p class="code"><span class="font">take :: Int -&gt; [a] -&gt; [a]</span></p>
<p class="para">so that <span class="font">take n</span> takes the first <span class="font">n</span> elements of a list of things. As far as <span class="font">take</span> is concerned it doesn’t matter what a ‘thing’ is, which is why there is an <span class="font">a</span> in the type signature rather than <span class="font">(Int,Word)</span>. We will explain this idea in the next chapter.</p>
<p class="para">The final steps are just tidying up. We first need to convert each element into a string so that, for example, <span class="font">(2,"be")</span> is replaced by <span class="font">"be 2\n"</span>. Call this function</p>
<p class="code"><span class="font">showRun :: (Int,Word) -&gt; String</span></p>
<p class="para">The type <span class="font">String</span> is a predeclared Haskell type synonym for <span class="font">[Char]</span>. That means</p>
<p class="code"><span class="font">map showRun :: [(Int,Word)] -&gt; [String]</span></p>
<p class="para">is a function that converts a list of runs into a list of strings.</p>
<p class="para">The final step is to use a function</p>
<p class="code"><a id="text/part0005.html.page_7" class="calibre3"></a><span class="font">concat :: [[a]] -&gt; [a]</span></p>
<p class="para">that concatenates a list of lists of things together. Again, it doesn’t matter what the ‘thing’ is as far as concatenation is concerned, which is why there is an <span class="font">a</span> in the type signature.</p>
<p class="para">Now we can define</p>
<div class="space1">
<p class="code"><span class="font">commonWords :: Int -&gt; Text -&gt; String</span></p>
<p class="code"><span class="font">commonWords n = concat . map showRun . take n .</span></p>
<p class="code4"><span class="space-r"></span><span class="font">sortRuns . countRuns . sortWords .</span></p>
<p class="code4"><span class="space-r"></span><span class="font">words . map toLower</span></p>
</div>
<p class="para">The definition of <span class="font">commonWords</span> is given as a pipeline of eight component functions glued together by functional composition. Not every problem can be decomposed into component tasks in quite such a straightforward manner, but when it can, the resulting program is simple, attractive and effective.</p>
<p class="para">Notice how the process of decomposing the problem was governed by the declared types of the subsidiary functions. Lesson Two (Lesson One being the importance of functional composition) is that deciding on the type of a function is the very first step in finding a suitable definition of the function.</p>
<p class="para">We said above that we were going to write a <i class="calibre1">program</i> for the common words problem. What we actually did was to write a functional definition of <span class="font">commonWords</span>, using subsidiary definitions that we either can construct ourselves or else import from a suitable Haskell library. A list of definitions is called a <i class="calibre1">script</i>, so what we constructed was a script. The order in which the functions are presented in a script is not important. We could place the definition of <span class="font">commonWords</span> first, and then define the subsidiary functions, or else define all these functions first, and end up with the definition of the main function of interest. In other words we can tell the story of the script in any order we choose. We will see how to compute with scripts later on.</p>
<h3 class="h" id="text/part0005.html.head1-4">1.4 Example: numbers into words</h3>
<p class="para">Here is another example, one for which we will provide a complete solution. The example demonstrates another fundamental aspect of problem solving, namely that a good way to solve a tricky problem is to first simplify the problem and then see how to solve the simpler problem.</p>
<p class="para">Sometimes we need to write numbers as words. For instance</p>
<div class="space1">
<p class="code"><a id="text/part0005.html.page_8" class="calibre3"></a><span class="font">convert 308000 = "three hundred and eight thousand"</span></p>
<p class="code"><span class="font">convert 369027 = "three hundred and sixty-nine thousand and</span></p>
<p class="code5"><span class="font">twenty-seven"</span></p>
<p class="code"><span class="font">convert 369401 = "three hundred and sixty-nine thousand</span></p>
<p class="code5"><span class="font">four hundred and one"</span></p>
</div>
<p class="para">Our aim is to design a function</p>
<p class="code"><span class="font">convert :: Int -&gt; String</span></p>
<p class="para">that, given a nonnegative number less than one million, returns a string that represents the number in words. As we said above, <span class="font">String</span> is a predeclared type synonym in Haskell for <span class="font">[Char]</span>.</p>
<p class="para">We will need the names of the component numbers. One way is to give these as three lists of strings:</p>
<p class="code6"><span class="font">&gt; units, teens, tens :: [String]</span></p>
<p class="code6"><span class="font">&gt; units = ["zero","one","two","three","four","five",</span></p>
<p class="code6"><span class="font">&gt;</span><span class="space3"></span><span class="font">"six","seven","eight","nine"]</span></p>
<p class="code6"><span class="font">&gt; teens = ["ten","eleven","twelve","thirteen","fourteen",</span></p>
<p class="code6"><span class="font">&gt;</span><span class="space3"></span><span class="font">"fifteen","sixteen","seventeen","eighteen",</span></p>
<p class="code6"><span class="font">&gt;</span><span class="space3"></span><span class="font">"nineteen"]</span></p>
<p class="code6"><span class="font">&gt; tens = ["twenty","thirty","forty","fifty","sixty",</span></p>
<p class="code6"><span class="font">&gt;</span><span class="space3"></span><span class="font">"seventy","eighty","ninety"]</span></p>
<p class="para">Oh, what is the <span class="font">&gt;</span> character doing at the beginning of each line above? The answer is that, in a script, it indicates a line of Haskell code, not a line of comment. In Haskell, a file ending with the suffix <span class="font">.lhs</span> is called a <i class="calibre1">Literate Haskell Script</i> and the convention is that every line in such a script is interpreted as a comment unless it begins with a <span class="font">&gt;</span> sign, when it is interpreted as a line of program. Program lines are not allowed next to comments, so there has to be at least one blank line separating the two. In fact, the whole chapter you are now reading forms a legitimate <span class="font">.lhs</span> file, one that can be loaded into a Haskell system and interacted with. We won’t carry on with this convention in subsequent chapters (apart from anything else, it would force us to use different names for each version of a function that we may want to define) but the present chapter does illustrate <i class="calibre1">literate</i> programming in which we can present and discuss the definitions of functions in any order we wish.</p>
<p class="para">Returning to the task in hand, a good way to tackle tricky problems is to solve a simpler problem first. The simplest version of our problem is when the given number <i class="calibre1">n</i> contains only one digit, so 0 ≤ <i class="calibre1">n</i> &lt; 10. Let <span class="font">convert1</span> deal with this version. We can immediately define</p>
<p class="code6"><a id="text/part0005.html.page_9" class="calibre3"></a><span class="font">&gt; convert1 :: Int -&gt; String</span></p>
<p class="code6"><span class="font">&gt; convert1 n = units!!n</span></p>
<p class="para">This definition uses the list-indexing operation <span class="font">(!!)</span>. Given a list <span class="font">xs</span> and an index <span class="font">n</span>, the expression <span class="font">xs!!n</span> returns the element of <span class="font">xs</span> at position <span class="font">n</span>, counting from 0. In particular, <span class="font">units!!0 = "zero"</span>. And, yes, <span class="font">units!!10</span> is undefined because <span class="font">units</span> contains just ten elements, indexed from 0 to 9. In general, the functions we define in a script are <i class="calibre1">partial</i> functions that may not return well-defined results for each argument.</p>
<p class="para">The next simplest version of the problem is when the number <i class="calibre1">n</i> has up to two digits, so 0 ≤ <i class="calibre1">n</i> &lt; 100. Let <span class="font">convert2</span> deal with this case. We will need to know what the digits are, so we first define</p>
<p class="code6"><span class="font">&gt; digits2 :: Int -&gt; (Int,Int)</span></p>
<p class="code6"><span class="font">&gt; digits2 n = (div n 10, mod n 10)</span></p>
<p class="para">The number <span class="font">div n k</span> is the whole number of times <span class="font">k</span> divides into <span class="font">n</span>, and <span class="font">mod n k</span> is the remainder. We can also write</p>
<p class="code"><span class="font">digits2 n = (n `div` 10, n `mod` 10)</span></p>
<p class="para">The operators <span class="font">`div`</span> and <span class="font">`mod`</span> are infix versions of <span class="font">div</span> and <span class="font">mod</span>, that is, they come between their two arguments rather than before them. This device is useful for improving readability. For instance a mathematician would write <i class="calibre1">x</i> div <i class="calibre1">y</i> and <i class="calibre1">x</i> mod <i class="calibre1">y</i> for these expressions. Note that the back-quote symbol <span class="font">`</span> is different from the single quote symbol <span class="font">'</span> used for describing individual characters.</p>
<p class="para">Now we can define</p>
<p class="code6"><span class="font">&gt; convert2 :: Int -&gt; String</span></p>
<p class="code6"><span class="font">&gt; convert2 = combine2 . digits2</span></p>
<p class="para">The definition of <span class="font">combine2</span> uses the Haskell syntax for <i class="calibre1">guarded equations</i>:</p>
<p class="code6"><span class="font">&gt; combine2 :: (Int,Int) -&gt; String</span></p>
<p class="code6"><span class="font">&gt; combine2 (t,u)</span></p>
<p class="code6"><span class="font">&gt;</span><span class="space"></span><span class="space"></span><span class="font">| t==0</span><span class="space3"></span><span class="font">= units!!u</span></p>
<p class="code6"><span class="font">&gt;</span><span class="space"></span><span class="space"></span><span class="font">| t==1</span><span class="space3"></span><span class="font">= teens!!u</span></p>
<p class="code6"><span class="font">&gt;</span><span class="space"></span><span class="space"></span><span class="font">| 2&lt;=t &amp;&amp; u==0</span><span class="space"></span><span class="font">= tens!!(t-2)</span></p>
<p class="code6"><span class="font">&gt;</span><span class="space"></span><span class="space"></span><span class="font">| 2&lt;=t &amp;&amp; u/=0</span><span class="space"></span><span class="font">= tens!!(t-2) ++ "-" ++ units!!u</span></p>
<p class="para">To understand this code you need to know that the Haskell symbols for equality and comparison tests are as follows:</p>
<div class="space1">
<p class="code"><a id="text/part0005.html.page_10" class="calibre3"></a><span class="font">==</span> (equals to)</p>
<p class="code"><span class="font">/=</span> (not equals to)</p>
<p class="code"><span class="font">&lt;=</span> (less than or equal to)</p>
</div>
<p class="para">These functions have well-defined types that we will give later on.</p>
<p class="para">You also need to know that the conjunction of two tests is denoted by <span class="font">&amp;&amp;</span>. Thus <span class="font">a &amp;&amp; b</span> returns the boolean value <span class="font">True</span> if both <span class="font">a</span> and <span class="font">b</span> do, and <span class="font">False</span> otherwise. In fact</p>
<p class="code"><span class="font">(&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool</span></p>
<p class="para">The type <span class="font">Bool</span> will be described in more detail in the following chapter.</p>
<p class="para">Finally, <span class="font">(++)</span> denotes the operation of concatenating two lists. It doesn’t matter what the type of the list elements is, so</p>
<p class="code"><span class="font">(++) :: [a] -&gt; [a] -&gt; [a]</span></p>
<p class="para">For example, in the equation</p>
<p class="code"><span class="font">[sin,cos] ++ [tan] = [sin,cos,tan]</span></p>
<p class="para">we are concatenating two lists of functions (each of type <span class="font">Float -&gt; Float</span>), while in</p>
<p class="code"><span class="font">"sin cos" ++ " tan" = "sin cos tan"</span></p>
<p class="para">we are concatenating two lists of characters.</p>
<p class="para">The definition of <span class="font">combine2</span> is arrived at by carefully considering all the possible cases that can arise. A little reflection shows that there are three main cases, namely when the tens part <span class="font">t</span> is 0, 1 or greater than 1. In the first two cases we can give the answer immediately, but the third case has to be divided into two subcases, namely when the units part <span class="font">u</span> is 0 or not 0. The order in which we write the cases, that is, the order of the individual guarded equations, is unimportant as the guards are disjoint from one another (that is, no two guards can be true) and together they cover all cases.</p>
<p class="para">We could also have written <a id="text/part0005.html.page_11" class="calibre3"></a>but now the order in which we write the equations is crucial. The guards are evaluated from top to bottom, taking the right-hand side corresponding to the first guard that evaluates to <span class="font">True</span>. The identifier <span class="font">otherwise</span> is just a synonym for <span class="font">True</span>, so the last clause captures all the remaining cases.</p>
<div class="space1">
<p class="code"><span class="font">combine2 :: (Int,Int) -&gt; String</span></p>
<p class="code"><span class="font">combine2 (t,u)</span></p>
<p class="code2"><span class="font">| t==0</span><span class="space3"></span><span class="font">= units!!u</span></p>
<p class="code2"><span class="font">| t==1</span><span class="space3"></span><span class="font">= teens!!u</span></p>
<p class="code2"><span class="font">| u==0</span><span class="space3"></span><span class="font">= tens!!(t-2)</span></p>
<p class="code2"><span class="font">| otherwise</span><span class="space4"></span><span class="font">= tens!!(t-2) ++ "-" ++ units!!u</span></p>
</div>
<p class="para">There is yet another way of writing <span class="font">convert2</span>:</p>
<div class="space1">
<p class="code"><span class="font">convert2 :: Int -&gt; String</span></p>
<p class="code"><span class="font">convert2 n</span></p>
<p class="code2"><span class="font">| t==0</span><span class="space3"></span><span class="font">= units!!u</span></p>
<p class="code2"><span class="font">| t==1</span><span class="space3"></span><span class="font">= teens!!u</span></p>
<p class="code2"><span class="font">| u==0</span><span class="space3"></span><span class="font">= tens!!(t-2)</span></p>
<p class="code2"><span class="font">| otherwise</span><span class="space5"></span><span class="space"></span><span class="font">= tens!!(t-2) ++ "-" ++ units!!u</span></p>
<p class="code2"><span class="font">where (t,u)</span><span class="space5"></span><span class="space"></span><span class="font">= (n `div` 10, n `mod` 10)</span></p>
</div>
<p class="para">This makes use of a <span class="font">where</span> <i class="calibre1">clause</i>. Such a clause introduces a <i class="calibre1">local</i> definition or definitions whose <i class="calibre1">context</i> or <i class="calibre1">scope</i> is the whole of the right-hand side of the definition of <span class="font">convert2</span>. Such clauses are very useful in structuring definitions and making them more readable. In the present example, the <span class="font">where</span> clause obviates the need for an explicit definition of <span class="font">digits2</span>.</p>
<p class="para">That was reasonably easy, so now let us consider <span class="font">convert3</span> which takes a number <i class="calibre1">n</i> in the range 0 ≤ <i class="calibre1">n</i> &lt; 1000, so <i class="calibre1">n</i> has up to three digits. The definition is</p>
<p class="code6"><span class="font">&gt; convert3 :: Int -&gt; String</span></p>
<p class="code6"><span class="font">&gt; convert3 n</span></p>
<p class="code6"><span class="font">&gt;</span><span class="space"></span><span class="space"></span><span class="font">| h==0</span><span class="space3"></span><span class="font">= convert2 t</span></p>
<p class="code6"><span class="font">&gt;</span><span class="space"></span><span class="space"></span><span class="font">| n==0</span><span class="space3"></span><span class="font">= units!!h ++ " hundred"</span></p>
<p class="code6"><span class="font">&gt;</span><span class="space"></span><span class="space"></span><span class="font">| otherwise</span><span class="space4"></span><span class="font">= units!!h ++ " hundred and " ++ convert2 t</span></p>
<p class="code6"><span class="font">&gt;</span><span class="space"></span><span class="space"></span><span class="font">where (h,t)</span><span class="space4"></span><span class="font">= (n `div` 100, n `mod` 100)</span></p>
<p class="para">We break up the number in this way because we can make use of <span class="font">convert2</span> for numbers that are less than 100.</p>
<p class="para">Now suppose <i class="calibre1">n</i> lies in the range 0 ≤ <i class="calibre1">n</i> &lt; 1, 000, 000, so <i class="calibre1">n</i> can have up to six digits. Following exactly the same pattern as before, we can define</p>
<p class="code6"><span class="font">&gt; convert6 :: Int -&gt; String</span></p>
<p class="code6"><span class="font">&gt; convert6 n</span></p>
<p class="code6"><span class="font">&gt;</span><span class="space"></span><span class="space"></span><span class="font">| m==0</span><span class="space3"></span><span class="font">= convert3 h</span></p>
<p class="code6"><span class="font">&gt;</span><span class="space"></span><span class="space"></span><span class="font">| h==0</span><span class="space3"></span><span class="font">= convert3 m ++ " thousand"</span></p>
<p class="code6"><span class="font">&gt;</span><span class="space"></span><span class="space"></span><span class="font">| otherwise</span><span class="space4"></span><span class="font">= convert3 m ++ " thousand" ++ link h ++</span></p>
<p class="code6"><span class="font">&gt;</span><span class="space6"></span><span class="space4"></span><span class="font">convert3 h</span></p>
<p class="code6"><span class="font">&gt;</span><span class="space"></span><span class="space"></span><span class="font">where (m,h)</span><span class="space4"></span><span class="font">= (n `div` 1000,n `mod` 1000)</span></p>
<p class="para"><a id="text/part0005.html.page_12" class="calibre3"></a>There will be a connecting word ‘and’ between the words for <i class="calibre1">m</i> and <i class="calibre1">h</i> just in the case that 0 &lt; <i class="calibre1">m</i> and 0 &lt; <i class="calibre1">h</i> &lt; 100. Thus</p>
<p class="code6"><span class="font">&gt; link :: Int -&gt; String</span></p>
<p class="code6"><span class="font">&gt; link h = if h &lt; 100 then " and " else " "</span></p>
<p class="para">This definition makes use of a conditional expression</p>
<p class="code"><span class="font">if &lt;test&gt; then &lt;expr1&gt; else &lt;expr2&gt;</span></p>
<p class="para">We could also have used guarded equations:</p>
<p class="code"><span class="font">link h | h &lt; 100 = " and "</span></p>
<p class="code"><span class="space2"></span><span class="font">| otherwise = " "</span></p>
<p class="para">Sometimes one is more readable, sometimes the other. The names <span class="font">if</span>, <span class="font">then</span> and <span class="font">else</span>, along with some others, are <i class="calibre1">reserved words</i> in Haskell, which means that we cannot use them as names for things we want to define.</p>
<p class="para">Notice how the definition of <span class="font">convert6</span> has been constructed in terms of the simpler function <span class="font">convert3</span>, which in turn has been defined in terms of the even simpler function <span class="font">convert2</span>. That is often the way with function definitions. In this example consideration of the simpler cases is not wasted because these simple cases can be used in the final definition.</p>
<p class="para">One more thing: we have now named the function we are after as <span class="font">convert6</span>, but we started off by saying the name should be <span class="font">convert</span>. No problem:</p>
<p class="code6"><span class="font">&gt; convert :: Int -&gt; String</span></p>
<p class="code6"><span class="font">&gt; convert = convert6</span></p>
<p class="para">What we would like to do now is actually use the computer to apply <span class="font">convert</span> to some arguments. How?</p>
<h3 class="h" id="text/part0005.html.head1-5">1.5 The Haskell Platform</h3>
<p class="para">If you visit the site <span class="font"><a href="http://www.haskell.org" class="calibre3">www.haskell.org</a></span>, you will see how to download <i class="calibre1">The Haskell Platform</i>. This is a large collection of tools and packages that can be used to run Haskell scripts. The platform comes in three versions, one for each of Windows, Mac and Linux. We deal only with the Windows version, the others being similar.</p>
<p class="para">One of the tools is an interactive calculator, called GHCi. This is short for <i class="calibre1">Glasgow Haskell Compiler Interpreter</i>. The calculator is available as a Windows system called WinGHCi. If you open this window, you will get something like</p>
<p class="code6"><a id="text/part0005.html.page_13" class="calibre3"></a><span class="font">GHCi, version 7.6.3: <a href="http://http://www.haskell.org/ghc/" class="calibre3">http://www.haskell.org/ghc/</a> :? for help</span></p>
<p class="code6"><span class="font">Loading package ghc-prim ... linking ... done.</span></p>
<p class="code6"><span class="font">Loading package integer-gmp ... linking ... done.</span></p>
<p class="code6"><span class="font">Loading package base ... linking ... done.</span></p>
<p class="code6"><span class="font">Prelude&gt;</span></p>
<p class="para">The prompt <span class="font">Prelude&gt;</span> means that the standard library of prelude functions, predeclared types and other values is loaded. You can now use GHCi as a supercalculator:</p>
<p class="code6"><span class="font">Prelude&gt; 3^5</span></p>
<p class="code6"><span class="font">243</span></p>
<p class="code6"><span class="font">Prelude&gt; import Data.Char</span></p>
<p class="code6"><span class="font">Prelude Data.Char&gt; map toLower "HELLO WORLD!"</span></p>
<p class="code6"><span class="font">"hello world!"</span></p>
<p class="code6"><span class="font">Prelude Data.Char&gt;</span></p>
<p class="para">The function <span class="font">toLower</span> resides in the library <span class="font">Data.Char</span>. After importing this library you have access to the functions defined in the library. Note that the prompt changes and now indicates the libraries that have been loaded. Such prompts can grow in size very quickly. But we can always change the prompt:</p>
<p class="code6"><span class="font">Prelude&gt; :set prompt ghci&gt;</span></p>
<p class="code6"><span class="font">ghci&gt;</span></p>
<p class="para">For brevity we will use this prompt throughout the book.</p>
<p class="para">You can load a script, <span class="font">Numbers2Words.lhs</span> say, that contains the definition of <span class="font">convert</span> as follows:</p>
<p class="code6"><span class="font">ghci&gt; :load "Numbers2Words.lhs"</span></p>
<p class="code6"><span class="font">[1 of 1] Compiling Main ( Numbers2Words.lhs, interpreted )</span></p>
<p class="code6"><span class="font">Ok, modules loaded: Main.</span></p>
<p class="code6"><span class="font">ghci&gt;</span></p>
<p class="para">We will explain what modules are in the next chapter. Now you can type, for example,</p>
<p class="code6"><span class="font">ghci&gt; convert 301123</span></p>
<p class="code6"><span class="font">"three hundred and one thousand one hundred and twenty-three" ghci&gt;</span></p>
<p class="para">We end the chapter with some exercises. These contain additional points of interest <a id="text/part0005.html.page_14" class="calibre3"></a>and should be regarded as an integral part of the text. The same is true for all subsequent chapters, so please read the questions even if you do not answer them. The answers are given afterwards.</p>
<h3 class="h" id="text/part0005.html.head1-6">1.6 Exercises</h3>
<p class="theorem"><b class="calibre7">Exercise A</b></p>
<p class="para">Consider the function</p>
<div class="space1">
<p class="code"><span class="font">double :: Integer -&gt; Integer</span></p>
<p class="code"><span class="font">double x = 2*x</span></p>
</div>
 
<p class="para">that doubles an integer. What are the values of the following expressions?</p>
<div class="space1">
<p class="code"><span class="font">map double [1,4,4,3]</span></p>
<p class="code"><span class="font">map (double . double) [1,4,4,3]</span></p>
<p class="code"><span class="font">map double []</span></p>
</div>
 
<p class="para">Suppose <span class="font">sum :: [Integer] -&gt; Integer</span> is a function that sums a list of integers. Which of the following assertions are true and why?</p>
<div class="space1">
<p class="code"><span class="font">sum . map double</span><span class="space"></span><span class="font">= double . sum</span></p>
<p class="code"><span class="font">sum . map sum</span><span class="space5"></span><span class="space-r"></span><span class="font">= sum . concat</span></p>
<p class="code"><span class="font">sum . sort</span><span class="space4"></span><span class="space"></span><span class="space-r"></span><span class="font">= sum</span></p>
</div>
<p class="para">You will need to recall what the function <span class="font">concat</span> does. The function <span class="font">sort</span> sorts a list of numbers into ascending order.</p>
<p class="theorem"><b class="calibre7">Exercise B</b></p>
<p class="para">In Haskell, functional application takes precedence over every other operator, so <span class="font">double 3+4</span> means <span class="font">(double 3)+4</span>, not <span class="font">double (3+4)</span>. Which of the following expressions is a rendering of sin<sup class="calibre8">2</sup> <i class="calibre1">θ</i> into Haskell?</p>
<p class="code"><span class="font">sin^2 theta</span><span class="space2"></span><span class="font">sin theta^2</span><span class="space2"></span><span class="font">(sin theta)^2</span></p>
<p class="para">(Exponentiation is denoted by <span class="font">(^)</span>.) How would you express sin 2<i class="calibre1">θ</i>/2<i class="calibre1">π</i> as a wellformed Haskell expression?</p>
<p class="theorem"><b class="calibre7">Exercise C</b></p>
<p class="para">As we said in the text, a character, i.e. an element of <span class="font">Char</span>, is denoted using single quotes, and a string is denoted using double quotes. In particular the string <span class="font">"Hello World!"</span> is just a much shorter way of writing the list</p>
<p class="code"><a id="text/part0005.html.page_15" class="calibre3"></a><span class="font">['H','e','l','l','o',' ','W','o','r','l','d','!']</span></p>
<p class="para">General lists can be written with brackets and commas. (By the way, parentheses are round, brackets are square, and braces are curly.) The expressions <span class="font">'H'</span> and <span class="font">"H"</span> therefore have different types. What are they? What is the difference between <span class="font">2001</span> and <span class="font">"2001"</span>?</p>
<p class="para">The operation <span class="font">++</span> concatenates two lists. Simplify</p>
<div class="space1">
<p class="code"><span class="font">[1,2,3] ++ [3,2,1]</span></p>
<p class="code"><span class="font">"Hello" ++ " World!"</span></p>
<p class="code"><span class="font">[1,2,3] ++ []</span></p>
<p class="code"><span class="font">"Hello" ++ "" ++ "World!"</span></p>
</div>
<p class="theorem"><b class="calibre7">Exercise D</b></p>
<p class="para">In the common words example we started off by converting every letter in the text to lowercase, and then we computed the words in the text. An alternative is to do things the other way round, first computing the words and then converting each letter in each word to lowercase. The first method is expressed by <span class="font">words . map toLower</span>. Give a similar expression for the second method.</p>
<p class="theorem"><b class="calibre7">Exercise E</b></p>
<p class="para">An operator ⊕ is said to be <i class="calibre1">associative</i> if <i class="calibre1">x</i> ⊕ (<i class="calibre1">y</i> ⊕ <i class="calibre1">z</i>) = (<i class="calibre1">x</i> ⊕ <i class="calibre1">y</i>) ⊕ <i class="calibre1">z</i>. Is numerical addition associative? Is list concatenation associative? Is functional composition associative? Give an example of an operator on numbers that is not associative.</p>
<p class="para">An element <i class="calibre1">e</i> is said to be an <i class="calibre1">identity element</i> of ⊕ if <i class="calibre1">x</i>⊕<i class="calibre1">e</i> = <i class="calibre1">e</i>⊕<i class="calibre1">x</i> = <i class="calibre1">x</i> for all <i class="calibre1">x</i>. What are the identity elements of addition, concatenation and functional composition?</p>
<p class="theorem"><b class="calibre7">Exercise F</b></p>
<p class="para">My wife has a book with the title</p>
<p class="equationasimage"><i class="calibre1">EHT CDOORRSSW AAAGMNR ACDIINORTY</i>.</p>
<p class="para">It contains lists of entries like this:</p>
<div class="space1">
<p class="code"><span class="font">6-letter words</span></p>
<p class="code">--------------</p>
<p class="code"><span class="font">...</span></p>
<p class="code"><span class="font">eginor: ignore,region</span></p>
<p class="code"><span class="font">eginrr: ringer</span></p>
<p class="code"><span class="font">eginrs: resign,signer,singer</span></p>
<p class="code"><span class="font">...</span></p>
</div>
<p class="para"><a id="text/part0005.html.page_16" class="calibre3"></a>Yes, it is an anagram dictionary. The letters of the anagrams are sorted and the results are stored in dictionary order. Associated with each anagram are the English words with the same letters. Describe how you would go about designing a function</p>
<p class="code"><span class="font">anagrams :: Int -&gt; [Word] -&gt; String</span></p>
<p class="para">so that <span class="font">anagrams n</span> takes a list of English words in alphabetical order, extracts just the <i class="calibre1">n</i>-letter words and produces a string that, when displayed, gives a list of the anagram entries for the <i class="calibre1">n</i>-letter words. You are not expected to be able to define the various functions; just give suitable names and types and describe what each of them is supposed to do.</p>
<p class="theorem"><b class="calibre7">Exercise G</b></p>
<p class="para">Let’s end with a song:</p>
<div class="space1">
<p class="code"><span class="font">One man went to mow</span></p>
<p class="code"><span class="font">Went to mow a meadow</span></p>
<p class="code"><span class="font">One man and his dog</span></p>
<p class="code"><span class="font">Went to mow a meadow</span></p>
<p class="code7"><span class="font">Two men went to mow</span></p>
<p class="code"><span class="font">Went to mow a meadow</span></p>
<p class="code"><span class="font">Two men, one man and his dog</span></p>
<p class="code"><span class="font">Went to mow a meadow</span></p>
<p class="code7"><span class="font">Three men went to mow</span></p>
<p class="code"><span class="font">Went to mow a meadow</span></p>
<p class="code"><span class="font">Three men, two men, one man and his dog</span></p>
<p class="code"><span class="font">Went to mow a meadow</span></p>
</div>
<p class="para">Write a Haskell function <span class="font">song :: Int -&gt; String</span> so that <span class="font">song n</span> is the song when there are <span class="font">n</span> men. Assume <span class="font">n&lt;10</span>.</p>
<p class="para">To print the song, type for example</p>
<p class="code6"><span class="font">ghci&gt; putStrLn (song 5)</span></p>
<p class="para">The function <span class="font">putStrLn</span> will be explained in the following chapter. I suggest starting with</p>
<div class="space1">
<p class="code"><span class="font">song n = if n==0 then ""</span></p>
<p class="code1"><span class="space-r"></span><span class="font">else song (n-1) ++ "\n" ++ verse n</span></p>
<p class="code"><span class="font">verse n = line1 n ++ line2 n ++ line3 n ++ line4 n</span></p>
</div>
<p class="para"><a id="text/part0005.html.page_17" class="calibre3"></a>This defines <span class="font">song</span> <i class="calibre1">recursively</i>.</p>
<h3 class="h" id="text/part0005.html.head1-7">1.7 Answers</h3>
<p class="theorem"><b class="calibre7">Answer to Exercise A</b></p>
<table class="calibre12">
<tbody><tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">map double [1,4,4,3]</span></td><td class="calibre14"><span class="font">= [2,8,8,6]</span></td></tr>
<tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">map (double . double) [1,4,4,3]</span></td><td class="calibre14"><span class="font">= [4,16,16,12]</span></td></tr>
<tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">map double []</span></td><td class="calibre14"><span class="font">= []</span></td></tr>
</tbody></table>
<p class="para">You will gather from this that <span class="font">[]</span> denotes the empty list.</p>
<p class="para">All the following equations hold:</p>
<table class="calibre12">
<tbody><tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">sum . map double</span></td><td class="calibre14"><span class="font">= double . sum</span></td></tr>
<tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">sum . map sum</span></td><td class="calibre14"><span class="font">= sum . concat</span></td></tr>
<tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">sum . sort</span></td><td class="calibre14"><span class="font">= sum</span></td></tr>
</tbody></table>
<p class="para">In fact, each of these three equations are consequences of the three simpler laws:</p>
<table class="calibre12">
<tbody><tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">a*(x+y)</span></td><td class="calibre14"><span class="font">= a*x + a*y</span></td></tr>
<tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">x+(y+z)</span></td><td class="calibre14"><span class="font">= (x+y)+z</span></td></tr>
<tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">x+y</span></td><td class="calibre14"><span class="font">= y+x</span></td></tr>
</tbody></table>
<p class="para">Of course, we don’t know yet how to <i class="calibre1">prove</i> that the equations hold. (By the way, to avoid fuss we will often use a typewriter <span class="font">=</span> sign to denote the equality of two Haskell expressions written in typewriter font. But a mathematical = sign is used in equations such as sin 2<i class="calibre1">θ</i> = 2 sin <i class="calibre1">θ</i> cos <i class="calibre1">θ</i>.)</p>
<p class="theorem"><b class="calibre7">Answer to Exercise B</b></p>
<p class="para">Both <span class="font">sin theta^2</span> and <span class="font">(sin theta)^2</span> are okay, but not <span class="font">sin^2 theta</span>.</p>
<p class="para">Here is the rendering of sin 2<i class="calibre1">θ</i>/2<i class="calibre1">π</i> in Haskell:</p>
<p class="code"><span class="font">sin (2*theta) / (2*pi)</span></p>
<p class="para">Note that</p>
<p class="code"><span class="font">sin (2*theta) / 2 * pi = (sin (2*theta) / 2) * pi</span></p>
<p class="para">which is not what we want. The reason is that operators such as <span class="font">/</span> and <span class="font">*</span> at the same level of precedence associate to the left in expressions. More on this in the next chapter.</p>
<p class="theorem"><a id="text/part0005.html.page_18" class="calibre3"></a><b class="calibre7">Answer to Exercise C</b></p>
<table class="calibre12">
<tbody><tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">'H'</span></td><td class="calibre14"><span class="font">:: Char</span></td></tr>
<tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">"H"</span></td><td class="calibre14"><span class="font">:: [Char]</span></td></tr>
<tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">2001</span></td><td class="calibre14"><span class="font">:: Integer</span></td></tr>
<tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">"2001"</span></td><td class="calibre14"><span class="font">:: [Char]</span></td></tr>
</tbody></table>
<p class="para">By the way, <span class="font">'\'</span> is used as an <i class="calibre1">escape</i> character, so <span class="font">'\n'</span> is the newline character, and <span class="font">'\t'</span> is the tab character. Also, <span class="font">'\\'</span> is the backslash character, and <span class="font">"\\n"</span> is a list of two characters, a backslash and the letter <span class="font">n</span>. As a consequence, the file path <span class="font">C:\firefox\stuff</span> is written as the Haskell string <span class="font">"C:\\firefox\\stuff"</span>.</p>
<table class="calibre12">
<tbody><tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">[1,2,3] ++ [3,2,1]</span></td><td class="calibre14"><span class="font">= [1,2,3,3,2,1]</span></td></tr>
<tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">"Hello" ++ " World!"</span></td><td class="calibre14"><span class="font">= "Hello World!"</span></td></tr>
<tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">[1,2,3] ++ []</span></td><td class="calibre14"><span class="font">= [1,2,3]</span></td></tr>
<tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">"Hello" ++ "" ++"World!"</span></td><td class="calibre14"><span class="font">= "HelloWorld!"</span></td></tr>
</tbody></table>
<p class="para">If you got the last two right, you will have appreciated that <span class="font">[]</span> is an empty list of anything, but <span class="font">""</span> is an empty list of characters.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise D</b></p>
<p class="para">The clue is in the phrase ‘converting each letter in each word to lowercase’. Converting each letter in a single word is expressed by <span class="font">map toLower</span>, so the answer is <span class="font">map (map toLower) . words</span>. That means the following equation holds:</p>
<p class="code"><span class="font">words . map toLower = map (map toLower) . words</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise E</b></p>
<p class="para">Numerical addition, list concatenation and functional composition are all associative. But of course, numerical subtraction isn’t. Nor is exponentiation. The identity element of addition is 0, the identity element of concatenation is the empty list, and the identity element of functional composition is the identity function:</p>
<div class="space1">
<p class="code"><span class="font">id :: a -&gt; a</span></p>
<p class="code"><span class="font">id x = x</span></p>
</div>
<p class="theorem"><b class="calibre7">Answer to Exercise F</b></p>
<p class="para">This exercise follows <a href="#text/part0005.html.head1-3" class="calibre3">Section 1.3</a> quite closely. One way of computing the function <span class="font">anagrams n</span> is as follows:</p>
<p class="number">1.<span class="space"></span>Extract the words of length <i class="calibre1">n</i>, using a function</p>
<p class="code8"><span class="font">getWords :: Int -&gt; [Word] -&gt; [Word]</span></p>
<p class="number">2.<a id="text/part0005.html.page_19" class="calibre3"></a><span class="space"></span>Take each word and add a label to it. The label consists of the characters of the word, sorted into alphabetical order. For example, <span class="font">word</span> is turned into the pair <span class="font">("dorw","word")</span> This labelling is achieved by the function</p>
<p class="code8"><span class="font">addLabel :: Word -&gt; (Label,Word)</span></p>
<p class="number"><span class="space5"></span>where</p>
<p class="code8"><span class="font">type Label = [Char]</span></p>
<p class="number">3.<span class="space"></span>Sort the list of labelled words into alphabetical order of label, using the function</p>
<p class="code8"><span class="font">sortLabels :: [(Label,Word)] -&gt; [(Label,Word)]</span></p>
<p class="number">4.<span class="space"></span>Replace each group of adjacent labelled words with the same label with a single entry consisting of a pair in which the first component is the common label and the second component is a list of words with that label. This uses a function</p>
<p class="code8"><span class="font">groupByLabel :: [(Label,Word)] -&gt; [(Label,[Word])]</span></p>
<p class="number">5.<span class="space"></span>Replace each entry by a string using a function</p>
<p class="code8"><span class="font">showEntry :: [(Label,[Word])] -&gt; String</span></p>
<p class="number"><span class="space5"></span>and concatenate the results.</p>
<p class="para">That gives</p>
<p class="code"><span class="font">anagrams n = concat . map showEntry . groupByLabel .</span></p>
<p class="code9"><span class="font">sortLabels . map addLabel . getWords n</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise G</b></p>
<p class="para">One possible solution:</p>
<div class="space1">
<p class="code"><span class="font">song n = if n==0 then ""</span></p>
<p class="code10"><span class="font">else song (n-1) ++ "\n" ++ verse n</span></p>
<p class="code"><span class="font">verse n = line1 n ++ line2 n ++ line3 n ++ line4 n</span></p>
<p class="para1"></p>
<p class="code"><span class="font">line1 n = if n==1 then</span></p>
<p class="code10"><span class="font">"One man went to mow\n"</span></p>
<p class="code10"><span class="font">else</span></p>
<p class="code10"><span class="font">numbers!!(n-2) ++ " men went to mow\n"</span></p>
<p class="code"><span class="font">line2 n = "Went to mow a meadow\n"</span></p>
<p class="code"><span class="font">line3 n = if n==1 then</span></p>
<p class="code10"><span class="font">"One man and his dog\n"</span></p>
<p class="code10"><span class="font">else</span></p>
<p class="code10"><a id="text/part0005.html.page_20" class="calibre3"></a><span class="font">numbers!!(n-2) ++ " men, " ++ count (n-2)</span></p>
<p class="code10"><span class="font">++ "one man and his dog\n"</span></p>
<p class="code"><span class="font">line4 n = "Went to mow a meadow\n\n"</span></p>
<p class="para1"></p>
<p class="code"><span class="font">count n = if n==0 then ""</span></p>
<p class="code10"><span class="font">else</span></p>
<p class="code10"><span class="font">numbs!!(n-1) ++ " men, " ++ count (n-1)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">numbers = ["Two", "Three", "Four", "Five", "Six",</span></p>
<p class="code10"><span class="font">"Seven", "Eight", "Nine"]</span></p>
<p class="code"><span class="font">numbs = ["two", "three", "four", "five", "six",</span></p>
<p class="code10"><span class="font">"seven", "eight"]</span></p>
</div>
<p class="para">Notice that we have omitted to declare the types of the component functions and values in this script. Although Haskell will infer the correct types, it is usually a good idea to put them in for all functions and other values, however simple the types may be. Scripts with explicit type signatures are clearer to read and provide a useful check on the validity of definitions.</p>
<h3 class="h" id="text/part0005.html.head1-8">1.8 Chapter notes</h3>
<p class="para">If you are interested in the origins of Haskell, you should definitely read <i class="calibre1">The History of Haskell</i>, a copy of which is obtainable at</p>
<p class="code"><span class="font"><a href="http://research.microsoft.com/~simonpj/papers/history-of-haskell" class="calibre3">research.microsoft.com/~simonpj/papers/history-of-haskell</a></span></p>
<p class="para">One of the abiding strengths of Haskell is that it wasn’t designed to be a closed language, and researchers were encouraged to implement novel programming ideas and techniques by building language extensions or libraries. Consequently, Haskell is a large language and there are numerous books, tutorials and papers devoted to various aspects of the subject, including the recent <i class="calibre1">Parallel and Concurrent Programming in Haskell</i> by Simon Marlow (O’Reilly, 2013). Pointers to much of the material can be found at <span class="font"><a href="http://www.haskell.org" class="calibre3">www.haskell.org</a></span>. But three books in particular were open on my desk while writing this text. The first is <i class="calibre1">Haskell 98, Languages and Libraries, The Revised Report</i> (Cambridge University Press, 2003), edited by Simon Peyton Jones. This is an indispensable aid in understanding the nitty-gritty of the first standard version of Haskell, called Haskell 98. An online version of the report is available at</p>
<p class="code"><span class="font"><a href="http://www.haskell.org/onlinereport" class="calibre3">www.haskell.org/onlinereport</a></span></p>
<p class="para"><a id="text/part0005.html.page_21" class="calibre3"></a>The present book mostly follows this standard, though it does not cover the whole language by any means.</p>
<p class="para">Since then a new standard, Haskell 2010, has been released; see</p>
<p class="code"><span class="font"><a href="http://haskell.org/onlinereport/haskell2010/" class="calibre3">haskell.org/onlinereport/haskell2010/</a></span></p>
<p class="para">One change is that module names are now hierarchical, so we write <span class="font">Data.List</span> rather than just <span class="font">List</span> for the library of list utilities.</p>
<p class="para">The second two are textbooks: <i class="calibre1">Real World Haskell</i> (O’Reilly, 2009) by Bryan O’Sullivan, John Goerzen and Don Stewart; and <i class="calibre1">Programming in Haskell</i> (Cambridge, 2007) by Graham Hutton. As its name implies, the former deals mostly with highly practical applications, while the latter is another introductory text. Graham Hutton did suggest to me, albeit with a grin, that my book should be called <i class="calibre1">Ivory Tower Haskell</i>.</p>
<p class="para">There is a fascinating history concerning the common words problem. Jon Bentley invited one programmer, Don Knuth, to write a literate WEB program for the problem, and another programmer, Doug McIlroy, to write a literary review of it. The result was published in Bentley’s <i class="calibre1">Programming Pearls</i> column in <i class="calibre1">Communications of the ACM</i>, vol. 29, no. 6 (June 1986).</p>
</div></div>
<div id="text/part0006.html"><div id="text/part0006.html.5N3C0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre">

<h2 class="chapter-number" id="text/part0006.html.calibre_pb_0"><a id="text/part0006.html.page_22" class="calibre6"></a>Chapter 2</h2>
<h2 class="chapter-title">Expressions, types and values</h2>
<p class="para">In Haskell every <i class="calibre1">well-formed</i> expression has, by definition, a well-formed <i class="calibre1">type</i>. Each well-formed expression has, by definition, a <i class="calibre1">value</i>. Given an expression for evaluation,</p>
<ul class="calibre9">
<li class="calibre10">GHCi checks that the expression is <i class="calibre1">syntactically</i> correct, that is, it conforms to the rules of syntax laid down by Haskell.</li>
<li class="calibre10">If it is, GHCi infers a type for the expression, or checks that the type supplied by the programmer is correct.</li>
<li class="calibre10">Provided the expression is well-typed, GHCi evaluates the expression by reducing it to its simplest possible form to produce a value. Provided the value is printable, GHCi then prints it at the terminal.</li>
</ul>
<p class="para">In this chapter we continue the study of Haskell by taking a closer look at these processes.</p>
<h3 class="h" id="text/part0006.html.head2-1">2.1 A session with GHCi</h3>
<p class="para">One way of finding out whether or not an expression is well-formed is of course to use GHCi. There is a command <span class="font">:type expr</span> which, provided <span class="font">expr</span> is wellformed, will return its type. Here is a session with GHCi (with some of GHCi’s responses abbreviated):</p>
<p class="code6"><span class="font">ghci&gt; 3 +4)</span></p>
<p class="code6"><span class="font">&lt;interactive&gt;:1:5: parse error on input `)'</span></p>
<p class="para">GHCi is complaining that on line 1 the character <span class="font">')'</span> at position 5 is unexpected; in other words, the expression is not syntactically correct.</p>
<p class="code6"><a id="text/part0006.html.page_23" class="calibre3"></a><span class="font">ghci&gt; :type 3+4</span></p>
<p class="code6"><span class="font">3+4 :: Num a =&gt; a</span></p>
<p class="para">GHCi is asserting that the type of <span class="font">3+4</span> is a number. More on this below.</p>
<p class="code6"><span class="font">ghci&gt; :type if 1==0 then 'a' else "a"</span></p>
<p class="code6"><span class="font">&lt;interactive&gt;:1:23:</span></p>
<p class="code6"><span class="font">Couldn't match expected type `Char' with actual type `[Char]'</span></p>
<p class="code6"><span class="font">In the expression: "a"</span></p>
<p class="code6"><span class="font">In the expression: if 1 == 0 then 'a' else "a"</span></p>
<p class="para">GHCi expects the types of <span class="font">expr1</span> and <span class="font">expr2</span> in a conditional expression</p>
<p class="code"><span class="font">if test then expr1 else expr2</span></p>
<p class="para">to be the same. But a character is not a list of characters so the conditional expression, though conforming to the rules of Haskell syntax, is not well-formed.</p>
<p class="code6"><span class="font">ghci&gt; sin sin 0.5</span></p>
<p class="code6"><span class="font">&lt;interactive&gt;:1:1:</span></p>
<p class="code6"><span class="font">No instance for (Floating (a0 -&gt; a0))</span></p>
<p class="code6"><span class="font">arising from a use of `sin'</span></p>
<p class="code6"><span class="font">Possible fix: add an instance declaration for</span></p>
<p class="code"><span class="font">(Floating (a0 -&gt; a0))</span></p>
<p class="code6"><span class="font">In the expression: sin sin 0.5</span></p>
<p class="code6"><span class="font">In an equation for `it': it = sin sin 0.5</span></p>
<p class="para">GHCi gives a rather opaque error message, complaining that the expression is not well-formed.</p>
<p class="code6"><span class="font">ghci&gt; sin (sin 0.5)</span></p>
<p class="code6"><span class="font">0.4612695550331807</span></p>
<p class="para">Ah, GHCi is happy with this one.</p>
<p class="code6"><span class="font">ghci&gt; :type map</span></p>
<p class="code6"><span class="font">map :: (a -&gt; b) -&gt; [a] -&gt; [b]</span></p>
<p class="para">GHCi returns the type of the function <span class="font">map</span>.</p>
<p class="code6"><span class="font">ghci&gt; map</span></p>
<p class="code6"><span class="font">&lt;interactive&gt;:1:1:</span></p>
<p class="code6"><span class="font">No instance for (Show ((a0 -&gt; b0) -&gt; [a0] -&gt; [b0]))</span></p>
<p class="code6"><span class="font">arising from a use of `print'</span></p>
<p class="code6"><span class="font">Possible fix:</span></p>
<p class="code6"><span class="font">add an instance declaration for</span></p>
<p class="code"><a id="text/part0006.html.page_24" class="calibre3"></a><span class="font">(Show ((a0 -&gt; b0) -&gt; [a0] -&gt; [b0]))</span></p>
<p class="code6"><span class="font">In a stmt of an interactive GHCi command: print it</span></p>
<p class="para">GHCi is saying that it doesn’t know how to print a function.</p>
<p class="code6"><span class="font">ghci&gt; :type 1 `div` 0</span></p>
<p class="code6"><span class="font">1 `div` 0 :: Integral a =&gt; a</span></p>
<p class="para">GHCi is asserting that the type of <span class="font">1 `div` 0</span> is an integral number. The expression</p>
<p class="code6"><span class="font">1 `div` 0</span> is therefore well-formed and possesses a value.</p>
<p class="code6"><span class="font">ghci&gt; 1 `div` 0</span></p>
<p class="code6"><span class="font">*** Exception: divide by zero</span></p>
<p class="para">GHCi returns an error message. So what is the value of <span class="font">1 `div` 0</span>? The answer is that it is a special value, written mathematically as ⊥ and pronounced ‘bottom’. In fact, Haskell provides a predeclared name for this value, except that it is called <span class="font">undefined</span>, not bottom.</p>
<p class="code6"><span class="font">ghci&gt; :type undefined</span></p>
<p class="code6"><span class="font">undefined :: a</span></p>
<p class="code6"><span class="font">ghci&gt; undefined</span></p>
<p class="code6"><span class="font">*** Exception: Prelude.undefined</span></p>
<p class="para">Haskell is not expected to produce the value ⊥. It may return with an error message, or remain perpetually silent, computing an infinite loop, until we interrupt the computation. It may even cause GHCi to crash. Oh, yes.</p>
<p class="code6"><span class="font">ghci&gt; x*x where x = 3</span></p>
<p class="code6"><span class="font">&lt;interactive&gt;:1:5: parse error on input `where'</span></p>
<p class="para1"></p>
<p class="code6"><span class="font">ghci&gt; let x = 3 in x*x</span></p>
<p class="code6"><span class="font">9</span></p>
<p class="para">A <span class="font">where</span> clause does <i class="calibre1">not</i> qualify an expression in Haskell, but the whole of the right-hand side of a definition. Thus the first example is not a well-formed expression. On the other hand, a <span class="font">let</span> expression</p>
<p class="code"><span class="font">let &lt;defs&gt; in &lt;expr&gt;</span></p>
<p class="para">is well-formed, at least assuming the definitions in <span class="font">&lt;defs&gt;</span> are and the expression <span class="font">&lt;expr&gt;</span> is. Let-expressions appear infrequently in what follows, but occasionally they can be useful.</p>
<h3 class="h" id="text/part0006.html.head2-2">2.2 Names and operators</h3>
<p class="para"><a id="text/part0006.html.page_25" class="calibre3"></a>As we have seen, a script is a collection of names and their definitions. Names for functions and values begin with a lowercase letter, except for data constructors (see later on) which begin with an uppercase letter. Types (e.g. <span class="font">Int</span>), type classes (e.g. <span class="font">Num</span>) and modules (e.g. <span class="font">Prelude</span> or <span class="font">Data.Char</span>) also begin with an uppercase letter.</p>
<p class="para">An operator is a special kind of function name that appears between its (two) arguments, such as the <span class="font">+</span> in <span class="font">x + y</span> or the <span class="font">++</span> in <span class="font">xs ++ ys</span>. Operator names begin with a symbol. Any (non-symbolic) function of two arguments can be converted into an operator by enclosing it in back quotes, and any operator can be converted to a prefix name by enclosing it in parentheses. For example,</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">3 + 4</span></td>
<td class="calibre14">is the same as</td>
<td class="calibre14"><span class="font">(+) 3 4</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">div 3 4</span></td>
<td class="calibre14">is the same as</td>
<td class="calibre14"><span class="font">3 `div` 4</span></td>
</tr>
</tbody></table>
<p class="para">Operators have different levels of precedence (binding power). For example,</p>
<div class="space1">
<p class="code"><span class="font">3 * 4 + 2</span><span class="space2"></span>means<span class="space"></span><span class="font">(3 * 4) + 2</span></p>
<p class="code"><span class="font">xs ++ yss !! 3</span><span class="space"></span>means<span class="space"></span><span class="font">xs ++ (yss !! 3)</span></p>
</div>
<p class="para">If in any doubt, add parentheses to remove possible ambiguity. By the way, we can use any names we like for lists, including <span class="font">x</span>, <span class="font">y</span>, <span class="font">goodylist</span>, and so on. But a simple aid to memory is to use <span class="font">x</span> for things, <span class="font">xs</span> for lists of things, and <span class="font">xss</span> for lists of lists of things. That explains why we wrote <span class="font">yss</span> in the expression <span class="font">yss !! 3</span> in the last line above.</p>
<p class="para">Operators with the same level of precedence normally have an order of association, either to the left or right. For example, the usual arithmetic operators associate to the left:</p>
<div class="space1">
<p class="code"><span class="font">3 - 4 - 2</span><span class="space"></span>means<span class="space"></span><span class="font">(3 - 4) - 2</span></p>
<p class="code"><span class="font">3 - 4 + 2</span><span class="space"></span>means<span class="space"></span><span class="font">(3 - 4) + 2</span></p>
<p class="code"><span class="font">3 / 4 * 5</span><span class="space"></span>means<span class="space"></span><span class="font">(3 / 4) * 5</span></p>
</div>
<p class="para">Functional application, which has higher precedence than any other operator, also associates to the left:</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">eee</span></td>
<td class="calibre14"><span class="font">bah</span></td>
<td class="calibre14"><span class="font">gum</span></td>
<td class="calibre14"><span class="font">means</span></td>
<td class="calibre14"><span class="font">(eee bah) gum</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">eee</span></td>
<td class="calibre14"><span class="font">bah</span></td>
<td class="calibre14"><span class="font">gum*2</span></td>
<td class="calibre14"><span class="font">means</span></td>
<td class="calibre14"><span class="font">((eee bah) gum)*2</span></td>
</tr>
</tbody></table>
<p class="para">Some operators associate to the right:</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font"><a id="text/part0006.html.page_26" class="calibre3"></a>(a -&gt; b) -&gt; [a] -&gt; [b]</span></td>
<td class="calibre14"><span class="space5"></span><span class="font">means</span></td>
<td class="calibre14"><span class="space5"></span><span class="font">(a -&gt; b) -&gt; ([a] -&gt; [b])</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="space5"></span><span class="font">x ^ y ^ z</span></td>
<td class="calibre14"><span class="space5"></span><span class="font">means</span></td>
<td class="calibre14"><span class="space5"></span><span class="font">x ^ (y ^ z)</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">eee . bah . gum</span></td>
<td class="calibre14"><span class="space5"></span><span class="font">means</span></td>
<td class="calibre14"><span class="space5"></span><span class="font">eee . (bah . gum)</span></td>
</tr>
</tbody></table>
<p class="para">Of course, if an operator, such as functional composition, is associative the order has no effect on meaning (i.e. the value is the same). Again, one can always add parentheses to remove possible ambiguity.</p>
<p class="para">We can declare new operators; for example:</p>
<div class="space1">
<p class="code"><span class="font">(+++) :: Int -&gt; Int -&gt; Int</span></p>
<p class="code"><span class="font">x +++ y = if even x then y else x + y</span></p>
</div>
<p class="para">The conditional expression has low binding power, so the expression above means</p>
<p class="code"><span class="font">if even x then y else (x + y)</span></p>
<p class="para">not <span class="font">(if even x then y else x) + y</span>. Again, one can always use parentheses to group differently.</p>
<p class="para">If we like we can declare a precedence level and an order of association for <span class="font">(+++)</span>, but we won’t spell out how.</p>
<p class="center"><i class="calibre1">Sections and lambda expressions</i></p>
<p class="para">It is a matter of style, but in the main we prefer to write scripts in which all the little helper functions are named explicitly. Thus if we need a function that adds 1 to a number, or doubles a number, then we might choose to name such functions explicitly:</p>
<div class="space1">
<p class="code"><span class="font">succ, double :: Integer -&gt; Integer</span></p>
<p class="code"><span class="font">succ</span><span class="space5"></span><span class="font">n = n+1</span></p>
<p class="code"><span class="font">double n = 2*n</span></p>
</div>
<p class="para">However, Haskell provides alternative ways of naming these two functions, namely <span class="font">(+1)</span> and <span class="font">(2*)</span>. The device is called a <i class="calibre1">section</i>. In a section one of the arguments of an operator is included along with the operator. Thus</p>
<div class="space1">
<p class="code"><span class="font">(+1) n = n+1</span></p>
<p class="code"><span class="font">(0&lt;) n = 0&lt;n</span></p>
<p class="code"><span class="font">(&lt;0) n = n&lt;0</span></p>
<p class="code"><span class="font">(1/) x = 1/x</span></p>
</div>
<p class="para"><a id="text/part0006.html.page_27" class="calibre3"></a>Sections are certainly attractive ways of naming simple helper functions and we henceforth accept them onto our list of Good Things to Use in Moderation.</p>
<p class="para">There is one important caveat about sections: although <span class="font">(+1)</span> is the section that adds 1 to a number, <span class="font">(-1)</span> is <i class="calibre1">not</i> the section that subtracts 1. Instead <span class="font">(-1)</span> is just the number −1. Haskell uses the minus sign both as the binary operation of subtraction and as a prefix to denote negative numbers.</p>
<p class="para">Now suppose we want a function that doubles a number and then adds 1 to the answer. This function is captured by the composition <span class="font">(+1) . (*2)</span> of two sections. But the result is unsatisfying because it looks a little abstruse; anyone reading it would have to pause for a moment to see what it meant. The alternative seems to be to give the function a name, but what would be a suitable name? Nothing helpful really comes to mind.</p>
<p class="para">The alternative is to use a <i class="calibre1">lambda expression</i> <span class="font">\n -&gt; 2*n+1</span>. It is called a lambda expression because mathematically the function would be written as λ<i class="calibre1">n.</i>2∗<i class="calibre1">n</i>+1. Read the expression as ‘that function of <i class="calibre1">n</i> which returns 2∗<i class="calibre1">n</i>+1’. For example,</p>
<p class="code6"><span class="font">ghci&gt; map (\n -&gt; 2*n+1) [1..5]</span></p>
<p class="code6"><span class="font">[3,5,7,9,11]</span></p>
<p class="para">Once in a while a lambda expression seems the best way to describe some function, but only once in a while and we will take them out of the box only on rare occasions.</p>
<h3 class="h" id="text/part0006.html.head2-3">2.3 Evaluation</h3>
<p class="para">Haskell evaluates an expression by reducing it to its simplest possible form and printing the result. For example, suppose we have defined</p>
<div class="space1">
<p class="code"><span class="font">sqr :: Integer -&gt; Integer</span></p>
<p class="code"><span class="font">sqr x = x*x</span></p>
</div>
<p class="para">There are basically two ways to reduce the expression <span class="font">sqr (3+4)</span> to its simplest possible form, namely <span class="font">49</span>. Either we can evaluate <span class="font">3+4</span> first, or else apply the definition of <span class="font">sqr</span> first:</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="space"></span><span class="font">sqr (3+4)</span></td>
<td class="calibre14"><span class="space"></span><span class="font">sqr (3+4)</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="font">= sqr 7</span></td>
<td class="calibre14"><span class="font">= let x = 3+4 in x*x</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="font">= let x = 7 in x*x</span></td>
<td class="calibre14"><span class="font">= let x = 7 in x*x</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="font">= 7*7</span></td>
<td class="calibre14"><span class="font">= 7*7</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="font">= 49</span></td>
<td class="calibre14"><span class="font">= 49</span></td>
</tr>
</tbody></table>
<p class="para"><a id="text/part0006.html.page_28" class="calibre3"></a>The number of reduction steps is the same in each case, but the order of the reduction steps is slightly different. The method on the left is called <i class="calibre1">innermost reduction</i> and also <i class="calibre1">eager evaluation</i>; the one on the right is called <i class="calibre1">outermost reduction</i> or <i class="calibre1">lazy evaluation</i>. With eager evaluation arguments are always evaluated before a function is applied. With lazy evaluation the definition of a function is installed at once and only when they are needed are the arguments to the function evaluated.</p>
<p class="para">Doesn’t seem much of a difference, does it? But consider the following (slightly abbreviated) evaluation sequences concerning the function <span class="font">fst</span> that returns the first element of a pair, so <span class="font">fst (x,y) = x</span>:</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="space"></span><span class="font">fst (sqr 1,sqr 2)</span></td>
<td class="calibre14"><span class="space"></span><span class="font">fst (sqr 1,sqr 2)</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">= fst (1*1,sqr 2)</span></td>
<td class="calibre14"><span class="font">= let p = (sqr 1,sqr 2)</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">= fst (1,sqr 2)</span></td>
<td class="calibre14"><span class="space"></span><span class="font">in fst p</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">= fst (1,2*2)</span></td>
<td class="calibre14"><span class="font">= sqr 1</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">= fst (1,4)</span></td>
<td class="calibre14"><span class="font">= 1*1</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">= 1</span></td>
<td class="calibre14"><span class="font">= 1</span></td>
</tr>
</tbody></table>
<p class="para">The point here is that under eager evaluation the value <span class="font">sqr 2</span> is computed, while under lazy evaluation that value is not needed and is not computed.</p>
<p class="para">Now suppose we add the definitions</p>
<div class="space1">
<p class="code"><span class="font">infinity :: Integer</span></p>
<p class="code"><span class="font">infinity = 1 + infinity</span></p>
<p class="para1"></p>
<p class="code"><span class="font">three :: Integer -&gt; Integer</span></p>
<p class="code"><span class="font">three x = 3</span></p>
</div>
<p class="para">Evaluating <span class="font">infinity</span> will cause GHCi to go into a long, silent think trying to compute <span class="font">1 + (1 + (1 + (1 + (1 + ....</span> until eventually it runs out of space and returns an error message. The value of <span class="font">infinity</span> is ⊥.</p>
<p class="para">Again there are two ways to evaluate <span class="font">three infinity</span>:</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="space"></span><span class="font">three infinity</span></td>
<td class="calibre14"><span class="space"></span><span class="font">three infinity</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">= three (1+infinity)</span></td>
<td class="calibre14"><span class="font">= let x = infinity in 3</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">= three (1+(1+infinity))</span></td>
<td class="calibre14"><span class="font">= 3</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">= ...</span></td>
</tr>
</tbody></table>
<p class="para">Here eager evaluation gets stuck in a loop trying to evaluate <span class="font">infinity</span>, while lazy evaluation returns the answer 3 at once. We don’t need to evaluate the argument of <span class="font">three</span> in order to return <span class="font">3</span>.</p>
<p class="para">One more definition, a version of the factorial function:</p>
<div class="space1">
<p class="code"><a id="text/part0006.html.page_29" class="calibre3"></a><span class="font">factorial :: Integer -&gt; Integer</span></p>
<p class="code"><span class="font">factorial n = fact (n,1)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">fact :: (Integer,Integer) -&gt; Integer</span></p>
<p class="code"><span class="font">fact (x,y) = if x==0 then y else fact (x-1,x*y)</span></p>
</div>
<p class="para">This is another example of a <i class="calibre1">recursive definition</i> (the definition of <span class="font">infinity</span> was also recursive, and so was the function <span class="font">song</span> in the previous chapter). Expressions involving recursive functions are evaluated like any other definition.</p>
<p class="para">Here the two evaluation schemes result in the following sequence of reduction steps (we hide the steps involving simplification of the conditional expression to make another point):</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="space"></span><span class="font">factorial 3</span></td>
<td class="calibre14"><span class="space5"></span><span class="space"></span><span class="font">factorial 3</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">= fact (3,1)</span></td>
<td class="calibre14"><span class="space5"></span><span class="font">= fact (3,1)</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">= fact (3-1,3*1)</span></td>
<td class="calibre14"><span class="space5"></span><span class="font">= fact (3-1,3*1)</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">= fact (2,3)</span></td>
<td class="calibre14"><span class="space5"></span><span class="font">= fact (2-1,2*(3*1))</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">= fact (2-1,2*3)</span></td>
<td class="calibre14"><span class="space5"></span><span class="font">= fact (1-1,1*(2*(3*1)))</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">= fact (1,6)</span></td>
<td class="calibre14"><span class="space5"></span><span class="font">= 1*(2*(3*1))</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">= fact (1-1,1*6)</span></td>
<td class="calibre14"><span class="space5"></span><span class="font">= 1*(2*3)</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">= fact (0,6)</span></td>
<td class="calibre14"><span class="space5"></span><span class="font">= 1*6</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">= 6</span></td>
<td class="calibre14"><span class="space5"></span><span class="font">= 6</span></td>
</tr>
</tbody></table>
<p class="para">The point to appreciate is that, while the number of reduction steps is basically the same, lazy evaluation requires much more space to achieve the answer. The expression <span class="font">1*(2*(3*1))</span> is built up in memory before being evaluated.</p>
<p class="para">The pros and cons of lazy evaluation are briefly as follows. On the plus side, lazy evaluation terminates whenever <i class="calibre1">any</i> reduction order terminates; it never takes more steps than eager evaluation, and sometimes infinitely fewer. On the minus side, it can require a lot more space and it is more difficult to understand the precise order in which things happen.</p>
<p class="para">Haskell uses lazy evaluation. ML (another popular functional language) uses eager evaluation. Exercise D explores why lazy evaluation is a Good Thing. Lazy evaluation is considered further in <a href="#text/part0011.html.AFM60-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 7</a>.</p>
<p class="para">A Haskell function <span class="font">f</span> is said to be <i class="calibre1">strict</i> if <span class="font">f undefined = undefined</span>, and <i class="calibre1">nonstrict</i> otherwise. The function <span class="font">three</span> is non-strict, while <span class="font">(+)</span> is strict in both arguments. Because Haskell uses lazy evaluation we can define non-strict functions. That is why Haskell is referred to as a <i class="calibre1">non-strict</i> functional language.</p>
<p class="para"><a id="text/part0006.html.page_30" class="calibre3"></a>Haskell has built-in (or primitive) types such as <span class="font">Int</span>, <span class="font">Float</span> and <span class="font">Char</span>. The type <span class="font">Bool</span> of boolean values is defined in the standard prelude:</p>
<p class="code"><span class="font">data Bool = False | True</span></p>
<p class="para">This is an example of a <i class="calibre1">data declaration</i>. The type <span class="font">Bool</span> is declared to have two data <i class="calibre1">constructors</i>, <span class="font">False</span> and <span class="font">True</span>. The type <span class="font">Bool</span> has three values, not two: <span class="font">False</span>, <span class="font">True</span> and <span class="font">undefined :: Bool</span>. Why do we need that last value? Well, consider the function</p>
<div class="space1">
<p class="code"><span class="font">to :: Bool -&gt; Bool</span></p>
<p class="code"><span class="font">to b = not (to b)</span></p>
</div>
<p class="para">The prelude definition of <span class="font">not</span> is</p>
<div class="space1">
<p class="code"><span class="font">not :: Bool -&gt; Bool</span></p>
<p class="code"><span class="font">not True</span><span class="space"></span><span class="font">= False</span></p>
<p class="code"><span class="font">not False = True</span></p>
</div>
<p class="para">The definition of <span class="font">to</span> is perfectly well-formed, but evaluating <span class="font">to True</span> causes GHCi to go into an infinite loop, so its value is ⊥ of type <span class="font">Bool</span>. We will have much more to say about data declarations in future chapters.</p>
<p class="para">Haskell has built-in compound types, such as</p>
<div class="space1">
<p class="code"><span class="font">[Int]</span><span class="space7"></span>a list of elements, all of type <span class="font">Int</span></p>
<p class="code"><span class="font">(Int,Char)</span><span class="space2"></span>a pair consisting of an <span class="font">Int</span> and a <span class="font">Char</span></p>
<p class="code"><span class="font">(Int,Char,Bool)</span><span class="space"></span>a triple</p>
<p class="code"><span class="font">()</span><span class="space7"></span><span class="space5"></span>an empty tuple</p>
<p class="code"><span class="font">Int -&gt; Int</span><span class="space2"></span>a function from <span class="font">Int</span> to <span class="font">Int</span></p>
</div>
<p class="para">The sole inhabitant of the type <span class="font">()</span> is also denoted by <span class="font">()</span>. Actually, there is a second member of <span class="font">()</span>, namely <span class="font">undefined :: ()</span>. Now we can appreciate that there is a value ⊥ for every type.</p>
<p class="para">As we have already said, when defining values or functions it is always a good idea to include the type signature as part of the definition.</p>
<p class="para">Consider next the function <span class="font">take n</span> that takes the first <span class="font">n</span> elements of a list. This function made its appearance in the previous chapter. For example,</p>
<table class="calibre12">
<tbody><tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">take 3 [1,2,3,4,5]</span></td><td class="calibre14"><span class="font">= [1,2,3]</span></td></tr>
<tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">take 3 "category"</span></td><td class="calibre14"><span class="font">= "cat"</span></td></tr>
<tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">take 3 [sin,cos]</span></td><td class="calibre14"><span class="font">= [sin,cos]</span></td></tr>
</tbody></table>
<h3 class="h" id="text/part0006.html.head2-4">2.4 Types and type classes</h3>
<p class="para"><a id="text/part0006.html.page_31" class="calibre3"></a>What type should we assign to <span class="font">take</span>? It doesn’t matter what the type of the elements of the list is, so <span class="font">take</span> is what is called a <i class="calibre1">polymorphic</i> function and we denote its type by</p>
<p class="code"><span class="font">take :: Int -&gt; [a] -&gt; [a]</span></p>
<p class="para">The <span class="font">a</span> is a <i class="calibre1">type variable</i>. Type variables begin with a lowercase letter. Type variables can be instantiated to any type.</p>
<p class="para">Similarly,</p>
<div class="space1">
<p class="code"><span class="font">(++) :: [a] -&gt; [a] -&gt; [a]</span></p>
<p class="code"><span class="font">map</span><span class="space"></span><span class="font">:: (a -&gt; b) -&gt; [a] -&gt; [b]</span></p>
<p class="code"><span class="font">(.)</span><span class="space"></span><span class="font">:: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</span></p>
</div>
<p class="para">The last line declares the polymorphic type of functional composition.</p>
<p class="para">Next, what is the type of <span class="font">(+)</span>? Here are some suggestions:</p>
<div class="space1">
<p class="code"><span class="font">(+) :: Int -&gt; Int -&gt; Int</span></p>
<p class="code"><span class="font">(+) :: Float -&gt; Float -&gt; Float</span></p>
<p class="code"><span class="font">(+) :: a -&gt; a -&gt; a</span></p>
</div>
<p class="para">The first two types seem too specific, while the last seems too general: we can’t add two functions or two characters or two booleans, at least not in any obvious way.</p>
<p class="para">The answer is to introduce <i class="calibre1">type classes</i>:</p>
<p class="code"><span class="font">(+) :: Num a =&gt; a -&gt; a -&gt; a</span></p>
<p class="para">This declaration asserts that <span class="font">(+)</span> is of type <span class="font">a -&gt; a -&gt; a</span> for any <i class="calibre1">number type</i> <span class="font">a</span>. A type class, such as <span class="font">Num</span>, has a collection of named methods, such as <span class="font">(+)</span>, which can be defined differently for each instance of the type class. Type classes therefore provide for <i class="calibre1">overloaded</i> functions, functions with the same name but different definitions. Overloading is another kind of polymorphism.</p>
<p class="para">Numbers are rather complicated, and are explained in more detail in the following chapter, so we illustrate type classes with a simpler type class</p>
<div class="space1">
<p class="code"><span class="font">class Eq a where</span></p>
<p class="code"><span class="space"></span><span class="font">(==),(/=) :: a -&gt; a -&gt; Bool</span></p>
<p class="code"><span class="space"></span><span class="font">x /= y = not (x == y)</span></p>
</div>
<p class="para">This introduces the Equality type class, members of which can use one and the same equality test <span class="font">(==)</span> and inequality test <span class="font">(/=)</span>. There is a <i class="calibre1">default</i> definition of <span class="font">(/=)</span> as part of the class, so we only have to provide a definition of <span class="font">(==)</span>.</p>
<p class="para"><a id="text/part0006.html.page_32" class="calibre3"></a>To become a member of the <span class="font">Eq</span> club we have to define an <i class="calibre1">instance</i>. For example,</p>
<div class="space1">
<p class="code"><span class="font">instance Eq Bool where</span></p>
<p class="code"><span class="space"></span><span class="font">x == y = if x then y else not y</span></p>
<p class="para1"></p>
<p class="code"><span class="font">instance Eq Person where</span></p>
<p class="code"><span class="space"></span><span class="font">x == y = (pin x == pin y)</span></p>
</div>
<p class="para">If <span class="font">pin :: Person -&gt; Pin</span> then we need <span class="font">Eq Pin</span> for the last instance to be correct. Of course, we don’t have to make <span class="font">Person</span> a member of the Equality club; we can always define</p>
<div class="space1">
<p class="code"><span class="font">samePerson :: Person -&gt; Person -&gt; Bool</span></p>
<p class="code"><span class="font">samePerson x y = (pin x == pin y)</span></p>
</div>
<p class="para">But we can’t use <span class="font">(==)</span> instead of <span class="font">samePerson</span> unless we make an instance declaration.</p>
<p class="para">Here are simplified versions of two other type classes, <span class="font">Ord</span> and <span class="font">Show</span>:</p>
<div class="space1">
<p class="code"><span class="font">class (Eq a) =&gt; Ord a where</span></p>
<p class="code"><span class="space"></span><span class="font">(&lt;),(&lt;=),(&gt;=),(&gt;) :: a -&gt; a -&gt; Bool</span></p>
<p class="code"><span class="space"></span><span class="font">x &lt; y = not (x &gt;= y)</span></p>
<p class="code"><span class="space"></span><span class="font">x &lt;= y = x == y || x &lt; y</span></p>
<p class="code"><span class="space"></span><span class="font">x &gt;= y = x == y || x &gt; y</span></p>
<p class="code"><span class="space"></span><span class="font">x &gt; y = not (x &lt;= y)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">class Show a where</span></p>
<p class="code"><span class="space"></span><span class="font">show :: a -&gt; String</span></p>
</div>
<p class="para">The boolean operator <span class="font">(||)</span> denotes disjunction: <span class="font">a || b</span> is true only if at least one of <span class="font">a</span> and <span class="font">b</span> is true. We can define this operator by</p>
<div class="space1">
<p class="code"><span class="font">(||) :: Bool -&gt; Bool -&gt; Bool</span></p>
<p class="code"><span class="font">a || b = if a then True else b</span></p>
</div>
<p class="para">The default definitions of the <span class="font">Ord</span> methods are mutually dependent, so one has to provide a specific definition of at least one of them in any instance to break the dependency (unlike <span class="font">Eq</span> where only <span class="font">(/=)</span> was given a default definition). The type class <span class="font">Ord</span> needs <span class="font">Eq</span> as a <i class="calibre1">superclass</i> because it makes use of <span class="font">(==)</span> in the default definitions of the four comparison operations.</p>
<p class="para">The type class <span class="font">Show</span> is used for displaying results. Haskell cannot display the result of a computation unless the type of the result is a member of <span class="font">Show</span>. Let us explain this in a little more detail.</p>
<p class="para"><a id="text/part0006.html.page_33" class="calibre3"></a>We begin with a mystery:</p>
<h3 class="h" id="text/part0006.html.head2-5">2.5 Printing values</h3>
<p class="code6"><span class="font">ghci&gt; "Hello ++"\n"++ "young" ++"\n"++ "lovers"</span></p>
<p class="code6"><span class="font">"Hello\nyoung\nlovers"</span></p>
<p class="para">Oh. What we wanted was</p>
<p class="code6"><span class="font">Hello</span></p>
<p class="code6"><span class="font">young</span></p>
<p class="code6"><span class="font">lovers</span></p>
<p class="para">Why didn’t Haskell print that?</p>
<p class="para">The reason is that after evaluating a well-formed expression to produce a value, Haskell applies <span class="font">show</span> to the value to produce a string that can be printed at the terminal. Applying <span class="font">show</span> to a value <span class="font">v</span> produces a string that when printed looks exactly like <span class="font">v</span>: Thus,</p>
<table class="calibre12">
<tbody><tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">show 42</span></td><td class="calibre14"><span class="font">= "42"</span></td></tr>
<tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">show 42.3</span></td><td class="calibre14"><span class="font">= "42.3"</span></td></tr>
<tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">show 'a'</span></td><td class="calibre14"><span class="font">= "'a'"</span></td></tr>
<tr class="calibre13"><td class="calibre14"><span class="space5"></span><span class="font">show "hello\n"</span></td><td class="calibre14"><span class="font">= "\"hello\\n\""</span></td></tr>
</tbody></table>
<p class="para">Printing the result involves the use of a Haskell <i class="calibre1">command</i></p>
<p class="code"><span class="font">putStrLn :: String -&gt; IO ()</span></p>
<p class="para">The type <span class="font">IO a</span> is a special type, the type of input–output computations that when executed have some interaction with the outside world and return a value of type <span class="font">a</span>. If the return value is uninteresting, as with <span class="font">putStrLn</span>, we use the null-tuple value <span class="font">()</span>.</p>
<p class="para">So, Haskell uniformly applies a show-and-put strategy to print values. Since the greeting above is already a string, we really want to miss out the show step and go straight to the put:</p>
<p class="code6"><span class="font">ghci&gt; putStrLn ("Hello ++"\n"++ "young" ++"\n"++ "lovers")</span></p>
<p class="code6"><span class="font">Hello</span></p>
<p class="code6"><span class="font">young</span></p>
<p class="code6"><span class="font">lovers</span></p>
<p class="para">Haskell provides many more commands for input–output, for reading and writing to files, for displaying graphics, and so on. Such commands have to be sequenced</p>
<p class="para"><a id="text/part0006.html.page_34" class="calibre3"></a>correctly, and for this Haskell provides a special notation, called <span class="font">do</span>-notation. Commands are the subject of <a href="#text/part0014.html.DB7S0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 10</a>, and what follows is simply a foretaste of things to come.</p>
<p class="para">To see an example, consider the common words problem of the previous chapter. There we defined a function</p>
<p class="code"><span class="font">commonWords :: Int -&gt; String -&gt; String</span></p>
<p class="para">such that <span class="font">commonWords n</span> took a text string and returned a string giving a table of the <span class="font">n</span> most common words in the text. The following program reads the text from a file, and writes the output to a file. The type <span class="font">FilePath</span> is another synonym for a list of characters:</p>
<div class="space1">
<p class="code"><span class="font">cwords :: Int -&gt; FilePath -&gt; FilePath -&gt; IO()</span></p>
<p class="code"><span class="font">cwords n infile outfile</span></p>
<p class="code2"><span class="font">= do {text &lt;- readFile infile;</span></p>
<p class="code3"><span class="font">writeFile outfile (commonWords n text);</span></p>
<p class="code3"><span class="font">putStrLn "cwords done!"}</span></p>
</div>
<p class="para">Evaluating, for example</p>
<p class="code6"><span class="font">ghci&gt; cwords 100 "c:\\WarAndPeace" "c:\\Results"</span></p>
<p class="para">on a Windows platform will cause the file <span class="font">c:\WarAndPeace</span> to be read, and the results printed to <span class="font">c:\Results</span>. The program also prints a message to the terminal. The two component functions of the definition above have types</p>
<div class="space1">
<p class="code"><span class="font">readFile</span><span class="space"></span><span class="font">:: FilePath -&gt; IO String</span></p>
<p class="code"><span class="font">writeFile :: FilePath -&gt; String -&gt; IO ()</span></p>
</div>
<p class="para">Suppose that we didn’t want to call <span class="font">cwords</span> from within an interactive session, but to use it as a stand-alone program. Here is one way. We need to define a value for an identifier <span class="font">main</span> of type <span class="font">IO ()</span>. Here is such a program:</p>
<div class="space1">
<p class="code"><span class="font">main</span></p>
<p class="code2"><span class="font">= do {putStrLn "Take text from where:";</span></p>
<p class="code1"><span class="font">infile &lt;- getLine;</span></p>
<p class="code1"><span class="font">putStrLn "How many words:";</span></p>
<p class="code1"><span class="font">n &lt;- getLine;</span></p>
<p class="code1"><span class="font">putStrLn "Put results where:";</span></p>
<p class="code1"><span class="font">outfile &lt;- getLine;</span></p>
<p class="code1"><span class="font">text &lt;- readFile infile;</span></p>
<p class="code1"><span class="font">writeFile outfile (commonWords (read n) text);</span></p>
<p class="code1"><span class="font">putStrLn "cwords done!" }</span></p>
</div>
<p class="para"><a id="text/part0006.html.page_35" class="calibre3"></a>For an explanation of <span class="font">read</span> see Exercise H. Suppose the common words script is stored in the file <span class="font">cwords.lhs</span>. We can compile it with GHC, the Glasgow Haskell Compiler:</p>
<p class="code6"><span class="font">$ ghc cwords.lhs</span></p>
<p class="para">The compiled program will be stored in the file <span class="font">cwords.exe</span>. To run the program under Windows, type</p>
<p class="code6"><span class="font">$ cwords</span></p>
<p class="para">and follow the instructions.</p>
<h3 class="h" id="text/part0006.html.head2-6">2.6 Modules</h3>
<p class="para">Suppose we thought that the function <span class="font">commonWords</span> was sufficiently useful that we wanted to incorporate it into other scripts. The way to do this is to turn the common words script into a <i class="calibre1">module</i>. First, we rewrite the script in the following way:</p>
<div class="space1">
<p class="code"><span class="font">module CommonWords (commonWords) where</span></p>
<p class="code"><span class="font">import Data.Char (toLower)</span></p>
<p class="code"><span class="font">import Data.List (sort,words)</span></p>
<p class="code"><span class="font">...</span></p>
<p class="code"><span class="font">commonWords :: Int -&gt; String -&gt; String</span></p>
<p class="code"><span class="font">...</span></p>
</div>
<p class="para">The <span class="font">module</span> declaration is followed by the name of the module, which must begin with a capital letter. Furthermore, the script has to be stored in a file called <span class="font">CommonWords.lhs</span> to enable Haskell to find the module (at least, if you are using literate scripts; otherwise it would be <span class="font">CommonWords.hs</span>). Following the name of the module is a list of <i class="calibre1">exports</i>, the functions, types and other values you want to be able to export to other scripts. The list of exports has to be enclosed in parentheses. Here we just export one function, <span class="font">commonWords</span>. The exports are the only things defined in the module that are visible in other modules. Omitting the export list, and the surrounding parentheses, means that everything in the module is exported.</p>
<p class="para">We can then compile the module using GHC and then import it into other scripts with the declaration</p>
<p class="code"><span class="font">import CommonWords (commonWords)</span></p>
<p class="para">There are two major advantages of Haskell modules. One is we can structure our scripts into bite-sized chunks, separating out little groups of related functions into <a id="text/part0006.html.page_36" class="calibre3"></a>separate modules. The other advantage is that the functions in a compiled module are much faster to evaluate because their definitions are compiled into machinespecific code, leading to a much slicker reduction process. GHCi is an <i class="calibre1">interpreter</i> rather than a compiler; it evaluates internal forms of expression that are much closer to the source language of Haskell.</p>
<h3 class="h" id="text/part0006.html.head2-7">2.7 Haskell layout</h3>
<p class="para">The examples of <span class="font">do</span>-notation used braces (<span class="font">{</span> and <span class="font">}</span>) and semicolons; these are examples of <i class="calibre1">explicit layout</i>. Braces and semicolons are used only to control layout and have no meaning as part of the language of Haskell expressions. We can use them in other places too:</p>
<div class="space1">
<p class="code"><span class="font">roots :: (Float,Float,Float) -&gt; (Float,Float)</span></p>
<p class="code"><span class="font">roots (a,b,c)</span></p>
<p class="code2"><span class="font">| a == 0</span><span class="space5"></span><span class="space-r"></span><span class="font">= error "not quadratic"</span></p>
<p class="code2"><span class="font">| disc &lt; 0</span><span class="space-toc1"></span><span class="font">= error "complex roots"</span></p>
<p class="code2"><span class="font">| otherwise = ((-b-r)/e, (-b+r)/e)</span></p>
<p class="code2"><span class="font">where {disc = b*b - 4*a*c; r = sqrt d; e = 2*a}</span></p>
</div>
<p class="para">Here the <span class="font">where</span> clause uses explicit braces and semicolons rather than appealing to Haskell’s layout rules. Instead, we could have written</p>
<div class="space1">
<p class="code"><span class="font">where disc = b*b - 4*a*c</span></p>
<p class="code3"><span class="font">r</span><span class="space5"></span><span class="font">= sqrt d</span></p>
<p class="code3"><span class="font">e</span><span class="space5"></span><span class="font">= 2*a</span></p>
</div>
<p class="para">But we couldn’t have written</p>
<div class="space1">
<p class="code"><span class="font">where disc = b*b - 4*a*c</span></p>
<p class="code1"><span class="font">r</span><span class="space-toc1"></span><span class="font">= sqrt d</span></p>
<p class="code1"><span class="font">e</span><span class="space-toc1"></span><span class="font">= 2*a</span></p>
</div>
<p class="para">The layout (or <i class="calibre1">offside</i>) rule takes effect whenever the opening brace is omitted after the keyword <span class="font">where</span> or <span class="font">do</span> (and also after <span class="font">let</span>). When this happens the indentation of the next item, whether or not on a new line, is remembered. For each subsequent line, if it is indented more, then the previous line is continued; if it is indented the same amount, then a new item begins; and if it is indented less, then the layout list is ended. At least, that’s roughly the offside rule.</p>
<p class="para">The offside rule explains why there is an indentation in the declarations of type classes and instances:</p>
<div class="space1">
<p class="code"><a id="text/part0006.html.page_37" class="calibre3"></a><span class="font">class Foo a where</span></p>
<p class="code2"><span class="space"></span><span class="font">I am part of the class declaration.</span></p>
<p class="code2"><span class="space"></span><span class="font">So am I.</span></p>
<p class="code"><span class="font">Now the class declaration has ended.</span></p>
</div>
<p class="para">You can always put in braces and semicolons if in any doubt. Actually the offside rule can still cause confusion when used with <span class="font">do</span>-notation. So the recommendation is belts, braces and semicolons.</p>
<p class="para">And you thought the football offside rule was complicated.</p>
<h3 class="h" id="text/part0006.html.head2-8">2.8 Exercises</h3>
<p class="theorem"><b class="calibre7">Exercise A</b></p>
<p class="para">On the subject of precedence, this question comes from Chris Maslanka’s puzzle page in the <i class="calibre1">Guardian</i> newspaper:</p>
<p class="center">‘Is a half of two plus two equal to two or three?’</p>
<p class="theorem"><b class="calibre7">Exercise B</b></p>
<p class="para">Some of the following expressions are not syntactically correct, while others are syntactically correct but do not have sensible types. Some are well-formed. Which is which? In the case of a well-formed expression, give a suitable type. Assume <span class="font">double :: Int -&gt; Int</span>. I suggest you don’t use a computer to check your answers, but if you do, be prepared for some strange error messages.</p>
<p class="para">The expressions are:</p>
<div class="space1">
<p class="code"><span class="font">[0,1)</span></p>
<p class="code"><span class="font">double -3</span></p>
<p class="code"><span class="font">double (-3)</span></p>
<p class="code"><span class="font">double double 0</span></p>
<p class="code"><span class="font">if 1==0 then 2==1</span></p>
<p class="code"><span class="font">"++" == "+" ++ "+"</span></p>
<p class="code"><span class="font">[(+),(-)]</span></p>
<p class="code"><span class="font">[[],[[]],[[[]]]]</span></p>
<p class="code"><span class="font">concat ["tea","for",'2']</span></p>
<p class="code"><span class="font">concat ["tea","for","2"]</span></p>
</div>
<p class="theorem"><a id="text/part0006.html.page_38" class="calibre3"></a><b class="calibre7">Exercise C</b></p>
<p class="para">In the good old days, one could write papers with titles such as</p>
<p class="center">‘The morphology of prex – an essay in meta-algorithmics’</p>
<p class="para">These days, journals seem to want all words capitalised:</p>
<p class="center">‘The Morphology Of Prex – An Essay In Meta-algorithmics’</p>
<p class="para">Write a function <span class="font">modernise :: String -&gt; String</span> which ensures that paper titles are capitalised as above. Here are some helpful questions to answer first:</p>
<p class="number">1.<span class="space"></span>The function <span class="font">toLower :: Char -&gt; Char</span> converts a letter to lowercase. What do you think is the name of the prelude function that converts a letter to uppercase?</p>
<p class="number">2.<span class="space"></span>The function <span class="font">words :: String -&gt; [Word]</span> was used in the previous chapter. What do you think the prelude function</p>
<p class="code11"><span class="font">unwords :: [Word] -&gt; String</span></p>
<p class="number"><span class="space5"></span>does? Hint: which, if either, of the following equations should hold?</p>
<p class="code11"><span class="font">words . unwords = id</span></p>
<p class="code11"><span class="font">unwords . words = id</span></p>
<p class="number">3.<span class="space"></span>The function <span class="font">head :: [a] -&gt; a</span> returns the head of a nonempty list, and <span class="font">tail :: [a] -&gt; [a]</span> returns the list that remains when the head is removed. Suppose a list has head <span class="font">x</span> and tail <span class="font">xs</span>. How would you reconstruct the list?</p>
<p class="theorem"><b class="calibre7">Exercise D</b></p>
<p class="para">Beaver is an eager evaluator, while Susan is a lazy one.<a id="text/part0006.html.fn_1" href="#text/part0006.html.fn-1" class="calibre3"><sup class="calibre8">1</sup></a> How many times would Beaver evaluate <span class="font">f</span> in computing <span class="font">head (map f xs)</span> when <span class="font">xs</span> is a list of length <i class="calibre1">n</i>? How many times would Susan? What alternative to <span class="font">head . map f</span> would Beaver prefer?</p>
<p class="para">The function <span class="font">filter p</span> filters a list, retaining only those elements that satisfy the boolean test <span class="font">p</span>. The type of <span class="font">filter</span> is</p>
<p class="code"><span class="font">filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</span></p>
<p class="para">Susan would happily use <span class="font">head . filter p</span> for a function that finds the first element of a list satisfying <span class="font">p</span>. Why would Beaver not use the same expression?</p>
<p class="para">Instead, Beaver would probably define something like</p>
<div class="space1">
<p class="code"><a id="text/part0006.html.page_39" class="calibre3"></a><span class="font">first :: (a -&gt; Bool) -&gt; [a] -&gt; a</span></p>
<p class="code"><span class="font">first p xs | null xs = error "Empty list"</span></p>
<p class="code10"><span class="space-r"></span><span class="font">| p x = ...</span></p>
<p class="code10"><span class="space-r"></span><span class="font">| otherwise = ...</span></p>
<p class="code10"><span class="space-r"></span><span class="font">where x = head xs</span></p>
</div>
<p class="para">The function <span class="font">null</span> returns <span class="font">True</span> on an empty list, and <span class="font">False</span> otherwise. When evaluated, the expression <span class="font">error message</span> stops execution and prints the string <span class="font">message</span> at the terminal, so its value is ⊥. Complete the right-hand side of Beaver’s definition.</p>
<p class="para">What alternative might Beaver prefer to <span class="font">head . filter p . map f</span>?</p>
<p class="theorem"><b class="calibre7">Exercise E</b></p>
<p class="para">The type <span class="font">Maybe</span> is declared in the standard prelude as follows:</p>
<p class="code"><span class="font">data Maybe a = Nothing | Just a</span></p>
<p class="code4"><span class="font"> deriving (Eq, Ord)</span></p>
<p class="para">This declaration uses a <span class="font">deriving</span> clause. Haskell can automatically generate instances of some standard type classes for some data declarations. In the present case the deriving clause means that we don’t have to go through the tedium of writing</p>
<div class="space1">
<p class="code"><span class="font">instance (Eq a) =&gt; Eq (Maybe a)</span></p>
<p class="code2"><span class="font">Nothing == Nothing = True</span></p>
<p class="code2"><span class="font">Nothing == Just y</span><span class="space"></span><span class="font">= False</span></p>
<p class="code2"><span class="font">Just x == Nothing</span><span class="space"></span><span class="font">= False</span></p>
<p class="code2"><span class="font">Just x == Just y</span><span class="space"></span><span class="space-r"></span><span class="font">= (x == y)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">instance (Ord a) =&gt; Ord (Maybe a)</span></p>
<p class="code2"><span class="font">Nothing &lt;= Nothing = True</span></p>
<p class="code2"><span class="font">Nothing &lt;= Just y</span><span class="space"></span><span class="font">= True</span></p>
<p class="code2"><span class="font">Just x &lt;= Nothing</span><span class="space"></span><span class="font">= False</span></p>
<p class="code2"><span class="font">Just x &lt;= Just y</span><span class="space"></span><span class="space-r"></span><span class="font">= (x &lt;= y)</span></p>
</div>
<p class="para">The reason why <span class="font">Nothing</span> is declared to be less than <span class="font">Just y</span> is simply because the constructor <span class="font">Nothing</span> comes before the constructor <span class="font">Just</span> in the data declaration for <span class="font">Maybe</span>.</p>
<p class="para">The reason why the <span class="font">Maybe</span> type is useful is that it provides a systematic way of handling failure. Consider again the function</p>
<p class="code"><a id="text/part0006.html.page_40" class="calibre3"></a><span class="font">first p = head . filter p</span></p>
<p class="para">of the previous exercise. Both Eager Beaver and Lazy Susan produced versions of this function that stopped execution and returned an error message when <span class="font">first p</span> was applied to the empty list. That’s not very satisfactory. Much better is to define</p>
<p class="code"><span class="font">first :: (a -&gt; Bool) -&gt; [a] -&gt; Maybe a</span></p>
<p class="para">Now failure is handled gracefully by returning <span class="font">Nothing</span> if there is no element of the list that satisfies the test.</p>
<p class="para">Give a suitable definition of this version of <span class="font">first</span>.</p>
<p class="para">Finally, count the number of functions with type <span class="font">Maybe a -&gt; Maybe a</span>.</p>
<p class="theorem"><b class="calibre7">Exercise F</b></p>
<p class="para">Here is a function for computing <i class="calibre1">x</i> to the power <i class="calibre1">n</i>, where <i class="calibre1">n</i> ≥ 0:</p>
<div class="space1">
<p class="code"><span class="font">exp :: Integer -&gt; Integer -&gt; Integer</span></p>
<p class="code"><span class="font">exp x n | n == 0</span><span class="space5"></span><span class="space-r"></span><span class="font">= 1</span></p>
<p class="code1"><span class="font">| n == 1</span><span class="space5"></span><span class="space-r"></span><span class="font">= x</span></p>
<p class="code1"><span class="font">| otherwise = x*exp x (n-1)</span></p>
</div>
<p class="para">How many multiplications does it take to evaluate <span class="font">exp x n</span>? Dick, a clever programmer, claims he can compute <span class="font">exp x n</span> with far fewer multiplications:</p>
<div class="space1">
<p class="code"><span class="font">exp x n | n == 0</span><span class="space-r"></span><span class="font">= 1</span></p>
<p class="code1"><span class="font">| n == 1 = x</span></p>
<p class="code1"><span class="font">| even n = ...</span></p>
<p class="code1"><span class="font">| odd n</span><span class="space"></span><span class="font">= ...</span></p>
</div>
<p class="para">Fill in the dots and say how many multiplications it takes to evaluate the expression <span class="font">exp x n</span> by Dick’s method, assuming 2<sup class="calibre8"><i class="calibre1">p</i></sup> ≤ <i class="calibre1">n &lt;</i> 2<sup class="calibre8"><i class="calibre1">p</i>+1</sup>.</p>
<p class="theorem"><b class="calibre7">Exercise G</b></p>
<p class="para">Suppose a date is represented by three integers (<i class="calibre1">day, month, year</i>). Define a function <span class="font">showDate :: Date -&gt; String</span> so that, for example,</p>
<div class="space1">
<p class="code"><span class="font">showDate (10,12,2013) = "10th December, 2013"</span></p>
<p class="code"><span class="font">showDate (21,11,2020) = "21st November, 2020"</span></p>
</div>
<p class="para">You need to know that <span class="font">Int</span> is a member of the type class <span class="font">Show</span>, so that <span class="font">show n</span> produces a string that is the decimal representation of the integer <span class="font">n</span>.</p>
<p class="theorem"><a id="text/part0006.html.page_41" class="calibre3"></a><b class="calibre7">Exercise H</b></p>
<p class="para">The credit card company Foxy issues cards with ten-digit card-identification numbers (CINs). The first eight digits are arbitrary but the number formed from the last two digits is a checksum equal to the sum of the first eight digits. For example, “6324513428” is a valid CIN because the sum of the first eight digits is 28.</p>
<p class="para">Construct a function <span class="font">addSum :: CIN -&gt; CIN</span> that takes a string consisting of eight digits and returns a string of ten digits that includes the checksum. Thus <span class="font">CIN</span> is a type synonym for <span class="font">String</span>, though restricted to strings of digits. (Note that Haskell type synonyms cannot enforce type constraints such as this.) You will need to convert between a digit character and the corresponding number. One direction is easy: just use <span class="font">show</span>. The other direction is also fairly easy:</p>
<div class="space1">
<p class="code"><span class="font">getDigit :: Char -&gt; Int</span></p>
<p class="code"><span class="font">getDigit c = read [c]</span></p>
</div>
<p class="para">The function <span class="font">read</span> is a method of the type class <span class="font">Read</span> and has type</p>
<p class="code"><span class="font">read :: Read a =&gt; String -&gt; a</span></p>
<p class="para">The type class <span class="font">Read</span> is dual to <span class="font">Show</span> and <span class="font">read</span> is dual to <span class="font">show</span>. For example,</p>
<p class="code6"><span class="font">ghci&gt; read "123" :: Int</span></p>
<p class="code6"><span class="font">123</span></p>
<p class="code6"><span class="font">ghci&gt; read "123" :: Float</span></p>
<p class="code6"><span class="font">123.0</span></p>
<p class="para">The function <span class="font">read</span> has to be supplied with the type of the result. One can always add <i class="calibre1">type annotations</i> to expressions in this way.</p>
<p class="para">Now construct a function <span class="font">valid :: CIN -&gt; Bool</span> that checks whether an identification number is valid. The function <span class="font">take</span> might prove useful.</p>
<p class="theorem"><b class="calibre7">Exercise I</b></p>
<p class="para">By definition a <i class="calibre1">palindrome</i> is a string that, ignoring punctuation symbols, blank characters and whether or not a letter is in lowercase or uppercase, reads the same forwards and backwards. Write an interactive program</p>
<p class="code"><span class="font">palindrome :: IO ()</span></p>
<p class="para">which, when run, conducts an interactive session, such as</p>
<p class="code6"><span class="font">ghci&gt; palindrome</span></p>
<p class="code6"><span class="font">Enter a string:</span></p>
<p class="code6"><a id="text/part0006.html.page_42" class="calibre3"></a><span class="font">Madam, I'm Adam</span></p>
<p class="code6"><span class="font">Yes!</span></p>
<p class="para1"></p>
<p class="code6"><span class="font">ghci&gt; palindrome</span></p>
<p class="code6"><span class="font">Enter a string:</span></p>
<p class="code6"><span class="font">A Man, a plan, a canal - Suez!</span></p>
<p class="code6"><span class="font">No!</span></p>
<p class="para1"></p>
<p class="code6"><span class="font">ghci&gt; palindrome</span></p>
<p class="code6"><span class="font">Enter a string:</span></p>
<p class="code6"><span class="font">Doc, note I dissent. A fast never prevents a fatness.</span></p>
<p class="code6"><span class="font">I diet on cod.</span></p>
<p class="code6"><span class="font">Yes!</span></p>
<p class="para">The function <span class="font">isAlpha :: Char -&gt; Bool</span> tests whether a character is a letter, and <span class="font">reverse :: [a] -&gt; [a]</span> reverses a list. The function <span class="font">reverse</span> is provided in the standard prelude and <span class="font">isAlpha</span> can be imported from the library <span class="font">Data.Char</span>.</p>
<h3 class="h" id="text/part0006.html.head2-9">2.9 Answers</h3>
<p class="theorem"><b class="calibre7">Answer to Exercise A</b></p>
<p class="para">The answer to Maslanka’s puzzle is ‘Yes!’ This little puzzle has fooled a number of distinguished computer scientists.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise B</b></p>
<p class="para">My GHCi session produced (with explanations added):</p>
<p class="code6"><span class="font">ghci&gt; :type [0,1)</span></p>
<p class="code6"><span class="font">&lt;interactive&gt;:1:5: parse error on input `)'</span></p>
<p class="para">GHCi knows that <span class="font">')'</span> is wrong, though it is not smart enough to suggest <span class="font">']'</span>.</p>
<p class="code6"><span class="font">ghci&gt; :type double -3</span></p>
<p class="code6"><span class="font">&lt;interactive&gt;:1:9:</span></p>
<p class="code6"><span class="font">No instance for (Num (Int -&gt; Int))</span></p>
<p class="code6"><span class="font">arising from the literal `3'</span></p>
<p class="code6"><span class="font">Possible fix: add an instance declaration for</span></p>
<p class="code6"><span class="space"></span><span class="font">(Num (Int -&gt; Int))</span></p>
<p class="code6"><a id="text/part0006.html.page_43" class="calibre3"></a><span class="font">In the second argument of `(-)', namely `3'</span></p>
<p class="code6"><span class="font">In the expression: double - 3</span></p>
<p class="para">The explanation of the error message is that numerical subtraction <span class="font">(-)</span> has type <span class="font">Num a =&gt; a -&gt; a</span>. For <span class="font">double - 3</span> to be well-formed (yes, it was typed as <span class="font">double -3</span> but the spaces are not significant here), <span class="font">double</span> has to be a number, so the class instance <span class="font">Num (Int -&gt; Int)</span> is required. But there isn’t one: you cannot sensibly subtract a number from a function.</p>
<p class="code6"><span class="font">ghci&gt; double (-3)</span></p>
<p class="code6"><span class="font">-6</span></p>
<p class="code6"><span class="font">ghci&gt; double double 0</span></p>
<p class="code6"><span class="font">&lt;interactive&gt;:1:1:</span></p>
<p class="code6"><span class="font">The function `double' is applied to two arguments,</span></p>
<p class="code6"><span class="font">but its type `Int -&gt; Int' has only one</span></p>
<p class="code6"><span class="font">In the expression: double double 0</span></p>
<p class="code6"><span class="font">In an equation for `it': it = double double 0</span></p>
<p class="para">Most of GHCi’s error message is clear.</p>
<p class="code6"><span class="font">ghci&gt; if 1==0 then 2==1</span></p>
<p class="code6"><span class="font">&lt;interactive&gt;:1:18: parse error (possibly incorrect indentation)</span></p>
<p class="para">Conditional expressions are incomplete without an ‘else’ clause.</p>
<p class="code6"><span class="font">ghci&gt; "++" == "+" ++ "+"</span></p>
<p class="code6"><span class="font">True</span></p>
<p class="para">Both sides are well-formed and denote the same list.</p>
<p class="code6"><span class="font">ghci&gt; [(+),(-)]</span></p>
<p class="code6"><span class="font">&lt;interactive&gt;:1:1:</span></p>
<p class="code6"><span class="font">No instance for (Show (a0 -&gt; a0 -&gt; a0))</span></p>
<p class="code6"><span class="font">arising from a use of `print'</span></p>
<p class="code6"><span class="font">Possible fix:</span></p>
<p class="code6"><span class="font">add an instance declaration for</span></p>
<p class="code6"><span class="space"></span><span class="font">(Show (a0 -&gt; a0 -&gt; a0))</span></p>
<p class="code6"><span class="font">In a stmt of an interactive GHCi command: print it</span></p>
<p class="para">To display the value <span class="font">[(+),(-)]</span> we have to be able to show its elements. But no way of showing functions has been provided.</p>
<p class="code6"><span class="font">ghci&gt; :type [[],[[]],[[[]]]]</span></p>
<p class="code6"><a id="text/part0006.html.page_44" class="calibre3"></a><span class="font">[[],[[]],[[[]]]] :: [[[[a]]]]</span></p>
<p class="para">To explain, let the main list have type <span class="font">[b]</span>. The first element is a list, so <span class="font">b=[c]</span>. The second element is a list of lists, so <span class="font">c=[d]</span>. The third element is a list of lists of lists, so <span class="font">d=[a]</span>.</p>
<p class="code6"><span class="font">ghci&gt; concat ["tea","for",'2']</span></p>
<p class="code6"><span class="font">&lt;interactive&gt;:1:21:</span></p>
<p class="code6"><span class="font">Couldn't match expected type `[Char]'</span></p>
<p class="code6"><span class="font">with actual type `Char'</span></p>
<p class="code6"><span class="font">In the expression: '2'</span></p>
<p class="code6"><span class="font">In the first argument of `concat',</span></p>
<p class="code6"><span class="font">namely `["tea", "for", '2']'</span></p>
<p class="code6"><span class="font">In the expression: concat ["tea", "for", '2']</span></p>
<p class="para">The first two elements of the list have type <span class="font">[Char]</span>, but the last has type <span class="font">Char</span> and that is not allowed.</p>
<p class="code6"><span class="font">ghci&gt; concat ["tea","for","2"]</span></p>
<p class="code6"><span class="font">"teafor2"</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise C</b></p>
<p class="number">1.<span class="space"></span><span class="font">toUpper</span>, of course.</p>
<p class="number">2.<span class="space"></span>Concatenates the words, putting a single space between them. We have</p>
<p class="code11"><span class="font">words . unwords = id</span></p>
<p class="code2">but not <span class="font">unwords . words = id</span>.</p>
<p class="number">3.<span class="space"></span><span class="font">[x] ++ xs</span>.</p>
<div class="space1">
<p class="code11"><span class="font">modernise :: String -&gt; String</span></p>
<p class="code11"><span class="font">modernise = unwords . map capitalise . words</span></p>
<p class="para1"></p>
<p class="code11"><span class="font">capitalise :: Word -&gt; Word</span></p>
<p class="code11"><span class="font">capitalise xs = [toUpper (head xs)] ++ tail xs</span></p>
</div>
<p class="para">We will see another way of writing <span class="font">capitalise</span> in <a href="#text/part0008.html.7K4G0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 4</a>.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise D</b></p>
<p class="para">Computing <span class="font">head (map f xs)</span> takes <i class="calibre1">n</i> evaluations of <span class="font">f</span> under eager evaluation, but only one under lazy evaluation. Beaver would have to exploit the identity <span class="font">head . map f = f . head</span>.</p>
<p class="para"><a id="text/part0006.html.page_45" class="calibre3"></a>Instead of defining <span class="font">first p = head . filter p</span>, Beaver might define</p>
<div class="space1">
<p class="code"><span class="font">first :: (a -&gt; Bool) -&gt; [a] -&gt; a</span></p>
<p class="code"><span class="font">first p xs | null xs = error "Empty list"</span></p>
<p class="code10"><span class="space-r"></span><span class="font">| p x = x</span></p>
<p class="code10"><span class="space-r"></span><span class="font">| otherwise = first p (tail xs)</span></p>
<p class="code10"><span class="space-r"></span><span class="font">where x = head xs</span></p>
</div>
<p class="para">Instead of defining <span class="font">first p f = head . filter p . map f</span>, Beaver might define</p>
<div class="space1">
<p class="code"><span class="font">first :: (b -&gt; Bool) -&gt; (a -&gt; b) -&gt; [a] -&gt; b</span></p>
<p class="code"><span class="font">first p f xs | null xs = error "Empty list"</span></p>
<p class="code12"><span class="space-r"></span><span class="font">| p x = x</span></p>
<p class="code12"><span class="space-r"></span><span class="font">| otherwise = first p f (tail xs)</span></p>
<p class="code12"><span class="space-r"></span><span class="font">where x = f (head xs)</span></p>
</div>
<p class="para">The point is that with eager evaluation most functions have to be defined using explicit recursion, not in terms of useful component functions like <span class="font">map</span> and <span class="font">filter</span>.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise E</b></p>
<p class="para">Lazy Susan would probably write</p>
<div class="space1">
<p class="code"><span class="font">first p xs = if null ys then Nothing</span></p>
<p class="code9"><span class="font">else Just (head ys)</span></p>
<p class="code9"><span class="font">where ys = filter p xs</span></p>
</div>
<p class="para">As to the number of functions of type <span class="font">Maybe a -&gt; Maybe a</span>, there are just six. Applied to <span class="font">Nothing</span> the function can only return <span class="font">Nothing</span> or <span class="font">undefined</span>. Applied to <span class="font">Just x</span> the function can only return <span class="font">Nothing</span> or <span class="font">Just x</span> or <span class="font">undefined</span>. The point is that we know absolutely nothing about the underlying type, so no new values can be invented. That makes six possible functions in all.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise F</b></p>
<p class="para">It takes <span class="font">n-1</span> multiplications to evaluate <span class="font">exp x n</span>. Dick’s method is to exploit the identities <i class="calibre1">x</i><sup class="calibre8">2<i class="calibre1">m</i></sup> =(<i class="calibre1">x</i><sup class="calibre8">2</sup>)<sup class="calibre8"><i class="calibre1">m</i></sup> and <i class="calibre1">x</i><sup class="calibre8">2<i class="calibre1">m</i>+1</sup> = <i class="calibre1">x</i>(<i class="calibre1">x</i><sup class="calibre8">2</sup>)<sup class="calibre8"><i class="calibre1">m</i></sup> to obtain a recursive definition:</p>
<div class="space1">
<p class="code"><span class="font">exp x n | n == 0 = 1</span></p>
<p class="code1"><span class="font">| n == 1 = x</span></p>
<p class="code1"><span class="font">| even n = exp (x*x) m</span></p>
<p class="code1"><span class="font">| odd n</span><span class="space"></span><span class="font">= x*exp (x*x) (m-1)</span></p>
<p class="code1"><span class="font">where m = n `div` 2</span></p>
</div>
<p class="para"><a id="text/part0006.html.page_46" class="calibre3"></a>This is an example of a <i class="calibre1">divide and conquer</i> algorithm. Dick’s program takes <i class="calibre1">p</i> multiplications, where 2<sup class="calibre8"><i class="calibre1">p</i></sup> ≤ <i class="calibre1">n &lt;</i> 2<sup class="calibre8"><i class="calibre1">p</i>+1</sup>. Thus <i class="calibre1">p</i> = ⌊log<i class="calibre1">n</i>⌋, where ⌊<i class="calibre1">x</i>⌋ returns the <i class="calibre1">floor</i> of a number, the greatest integer no bigger than the number. We will consider the floor function in more detail in the following chapter.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise G</b></p>
<div class="space1">
<p class="code"><span class="font">showDate :: Date -&gt; String</span></p>
<p class="code"><span class="font">showDate (d,m,y) = show d ++ suffix d ++ " " ++</span></p>
<p class="code13"><span class="font">months !! (m-1) ++ ", " ++ show y</span></p>
</div>
<p class="para">The function <span class="font">suffix</span> computes the right suffix:</p>
<div class="space1">
<p class="code"><span class="font">suffix d = if d==1 || d==21 || d==31 then "st" else</span></p>
<p class="code10"><span class="space-r"></span><span class="font">if d==2 || d==22 then "nd" else</span></p>
<p class="code10"><span class="space-r"></span><span class="font">if d==3 || d==23 then "rd" else</span></p>
<p class="code10"><span class="space-r"></span><span class="font">"th"</span></p>
<p class="para1"></p>
<p class="code"><span class="font">months = ["January",.......]</span></p>
</div>
<p class="para">If you indulged in clever arithmetic to compute <span class="font">suffix</span>, then you should realise that Sometimes a Simple Solution is Best.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise H</b></p>
<p class="para">One solution is as follows:</p>
<div class="space1">
<p class="code"><span class="font">addSum :: CIN -&gt; CIN</span></p>
<p class="code"><span class="font">addSum cin =</span></p>
<p class="code2"><span class="font">cin ++ show (n `div` 10) ++ show (n `mod` 10)</span></p>
<p class="code2"><span class="font">where n = sum (map fromDigit cin)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">valid :: CIN -&gt; Bool</span></p>
<p class="code"><span class="font">valid cin = cin == addSum (take 8 cin)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">fromDigit :: Char -&gt; Int</span></p>
<p class="code"><span class="font">fromDigit c = read [c]</span></p>
</div>
<p class="para">The function <span class="font">fromDigit</span> will return a numerical digit given a digit character.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise I</b></p>
<p class="para">Here is one solution:</p>
<div class="space1">
<p class="code"><a id="text/part0006.html.page_47" class="calibre3"></a><span class="font">import Data.Char (toLower,isAlpha)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">palindrome :: IO()</span></p>
<p class="code"><span class="font">palindrome</span></p>
<p class="code"><span class="space-r"></span><span class="font">= do {putStrLn "Enter a string:";</span></p>
<p class="code3"><span class="font">xs &lt;- getLine;</span></p>
<p class="code3"><span class="font">if isPalindrome xs then putStrLn "Yes!"</span></p>
<p class="code3"><span class="font">else putStrLn "No!"}</span></p>
<p class="para1"></p>
<p class="code"><span class="font">isPalindrome :: String -&gt; Bool</span></p>
<p class="code"><span class="font">isPalindrome xs = (ys == reverse ys)</span></p>
<p class="code2"><span class="font">where ys = map toLower (filter isAlpha xs)</span></p>
</div>
<h3 class="h" id="text/part0006.html.head2-10">2.10 Chapter notes</h3>
<p class="para">The chapter has referred a number of times to the Haskell ‘standard prelude’. This is a collection of basic types, type classes, functions and other values that are indispensible in many programming tasks. For a complete description of the standard prelude, see <a href="#text/part0012.html.BE6O0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 8</a> of the Haskell report; alternatively, visit</p>
<p class="code"><span class="font"><a href="http://www.haskell.org/onlinereport/standard-prelude.html" class="calibre3">www.haskell.org/onlinereport/standard-prelude.html</a></span></p>
<p class="para">See <span class="font"><a href="http://www.haskell.org" class="calibre3">www.haskell.org</a></span> for more information on the implementation of functional languages and of Haskell in particular. An older book, <i class="calibre1">The Implementation of Functional Programming Languages</i> (Prentice Hall, 1987) by Simon Peyton Jones, is no longer in print, but an online version can be found at</p>
<p class="code"><span class="font"><a href="http://research.microsoft.com/~simonpj/papers/slpj-book-1987" class="calibre3">research.microsoft.com/~simonpj/papers/slpj-book-1987</a></span></p>
<p class="para">Apart from GHC there are other maintained compilers for Haskell, including UHC, the Utrecht Haskell Compiler. See the home page <span class="font"><a href="http://cs.uu.nl/wiki/UHC" class="calibre3">cs.uu.nl/wiki/UHC</a></span>.</p>
<p class="para">On the eager-versus-lazy evaluation debate, read Bob Harper’s blog article <i class="calibre1">The point of laziness</i>, which can be found at</p>
<p class="code"><span class="font"><a href="http://existentialtype.wordpress.com/2011/04/24/" class="calibre3">existentialtype.wordpress.com/2011/04/24/</a></span></p>
<p class="para">In the blog Harper enumerates some of the reasons why he prefers a strict language. But also read Lennart Augustsson’s reply to the post. Augustsson’s main point, emphasised in Exercise D, is that under strict evaluation you are forced for efficiency reasons to define most functions by explicit recursion, and therefore lose the ability to build definitions out of simple standard functions. That undercuts our <a id="text/part0006.html.page_48" class="calibre3"></a>ability to reason about functions by applying general laws about their component functions.</p>
<p class="para">Bob Harper is one of the authors of <i class="calibre1">The Definition of Standard ML (Revised)</i> (MIT Press, 1989). ML is a strict functional language. You can find an introduction to ML at</p>
<p class="code"><span class="font"><a href="http://www.cs.cmu.edu/~rwh/smlbook/book.pdf" class="calibre3">www.cs.cmu.edu/~rwh/smlbook/book.pdf</a></span></p>
<p class="para">Another increasingly popular language is Agda, which is both a dependently-typed functional language and also a proof assistant; see the Agda home page</p>
<p class="code"><span class="font"><a href="http://wiki.portal.chalmers.se/agda/pmwiki.php" class="calibre3">wiki.portal.chalmers.se/agda/pmwiki.php</a></span></p>
<p class="para">Chris Maslanka writes a regular column in the Saturday edition of the <i class="calibre1">Guardian</i> newspaper.</p>
<p class="footnote"><a id="text/part0006.html.fn-1" href="#text/part0006.html.fn_1" class="calibre3"><sup class="calibre15">1</sup></a><span class="space-r"></span>If you don’t know, google ‘lazy susan’ to discover what a lazy susan is.</p>
</div></div>
<div id="text/part0007.html"><div id="text/part0007.html.6LJU0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre">

<h2 class="chapter-number" id="text/part0007.html.calibre_pb_0"><a id="text/part0007.html.page_49" class="calibre6"></a>Chapter 3</h2>
<h2 class="chapter-title">Numbers</h2>
<p class="para">Numbers in Haskell are complicated because in the Haskell world there are many different kinds of number, including:</p>
<div class="space1">
<p class="code"><span class="font">Int</span><span class="space8"></span>limited-precision integers in at least the range</p>
<p class="code10"><span class="space"></span>[−2<sup class="calibre8">29</sup>, 2<sup class="calibre8">29</sup>). Integer overflow is not detected.</p>
<p class="code"><span class="font">Integer</span><span class="space5"></span><span class="space"></span>arbitrary-precision integers</p>
<p class="code"><span class="font">Rational</span><span class="space"></span><span class="space"></span>arbitrary-precision rational numbers</p>
<p class="code"><span class="font">Float</span><span class="space4"></span><span class="space"></span>single-precision floating-point numbers</p>
<p class="code"><span class="font">Double</span><span class="space4"></span>double-precision floating-point numbers</p>
<p class="code"><span class="font">Complex</span><span class="space5"></span><span class="space-r"></span>complex numbers (defined in <span class="font">Data.Complex</span>)</p>
</div>
<p class="para">Most programs make use of numbers in one way or another, so we have to get at least a working idea of what Haskell offers us and how to convert between the different kinds. That is what the present chapter is about.</p>
<h3 class="h" id="text/part0007.html.head3-1">3.1 The type class <span class="font1">Num</span></h3>
<p class="para">In Haskell all numbers are instances of the type class <span class="font">Num</span>:</p>
<div class="space1">
<p class="code"><span class="font">class (Eq a, Show a) =&gt; Num a where</span></p>
<p class="code2"><span class="font">(+),(-),(*) :: a -&gt; a -&gt; a</span></p>
<p class="code2"><span class="font">negate :: a -&gt; a</span></p>
<p class="code2"><span class="font">abs, signum :: a -&gt; a</span></p>
<p class="code2"><span class="font">fromInteger :: Integer -&gt; a</span></p>
</div>
<p class="para">The class <span class="font">Num</span> is a subclass of both <span class="font">Eq</span> and <span class="font">Show</span>. That means every number can be printed and any two numbers can be compared for equality. Any number can be added to, subtracted from or multiplied by another number. Any number can be <a id="text/part0007.html.page_50" class="calibre3"></a>negated. Haskell allows <span class="font">-x</span> to denote <span class="font">negate x</span>; this is the only prefix operator in Haskell.</p>
<p class="para">The functions <span class="font">abs</span> and <span class="font">signum</span> return the absolute value of a number and its sign. If ordering operations were allowed in <span class="font">Num</span> (and they aren’t because, for example, complex numbers cannot be ordered), we could define</p>
<div class="space1">
<p class="code"><span class="font">abs x</span><span class="space5"></span><span class="space-r"></span><span class="font">= if x &lt; 0 then -x else x</span></p>
<p class="code"><span class="font">signum x | x &lt; 0 = -1</span></p>
<p class="code1"><span class="space-r1"></span><span class="font">| x == 0 = 0</span></p>
<p class="code1"><span class="space-r1"></span><span class="font">| x &gt; 0 = 1</span></p>
</div>
<p class="para">The function <span class="font">fromInteger</span> is a conversion function. An integer literal such as <span class="font">42</span> represents the application of <span class="font">fromInteger</span> to the appropriate value of type <span class="font">Integer</span>, so such literals have type <span class="font">Num a =&gt; a</span>. This choice is explained further below after we have considered some other classes of number and the conversion functions between them.</p>
<h3 class="h" id="text/part0007.html.head3-2">3.2 Other numeric type classes</h3>
<p class="para">The <span class="font">Num</span> class has two subclasses, the real numbers and the fractional numbers:</p>
<div class="space1">
<p class="code"><span class="font">class (Num a,Ord a) =&gt; Real a where</span></p>
<p class="code2"><span class="font">toRational :: a -&gt; Rational</span></p>
<p class="para1"></p>
<p class="code"><span class="font">class (Num a) =&gt; Fractional a where</span></p>
<p class="code2"><span class="font">(/) :: a -&gt; a -&gt; a</span></p>
<p class="code2"><span class="font">fromRational :: Rational -&gt; a</span></p>
</div>
<p class="para">Real numbers can be ordered. The only new method in the class <span class="font">Real</span>, apart from the comparison operations which are inherited from the superclass <span class="font">Ord</span>, is a conversion function from elements in the class to elements of <span class="font">Rational</span>. The type <span class="font">Rational</span> is essentially a synonym for pairs of integers. The real number <i class="calibre1">π</i> is not rational, so <span class="font">toRational</span> can only convert to an approximate rational number:</p>
<p class="code6"><span class="font">ghci&gt; toRational pi</span></p>
<p class="code6"><span class="font">884279719003555 % 281474976710656</span></p>
<p class="para">Not quite as memorable as <span class="font">22 % 7</span>, but more accurate. The symbol <span class="font">%</span> is used to separate the numerator and denominator of a rational number.</p>
<p class="para"><a id="text/part0007.html.page_51" class="calibre3"></a>The fractional numbers are those on which division is defined. A complex number cannot be real but it can be fractional. A floating-point literal such as <span class="font">3.149</span> represents the application of <span class="font">fromRational</span> to an appropriate rational number. Thus</p>
<p class="code"><span class="font">3.149 :: Fractional a =&gt; a</span></p>
<p class="para">This type and the earlier type <span class="font">Num a =&gt; a</span> for <span class="font">42</span> explains why we can form a legitimate expression such as <span class="font">42 + 3.149</span>, adding an integer to a floating-point number. Both types are members of the <span class="font">Num</span> class and all numbers can be added. Consideration of</p>
<p class="code6"><span class="font">ghci&gt; :type 42 + 3.149</span></p>
<p class="code6"><span class="font">42 + 3.149 :: Fractional a =&gt; a</span></p>
<p class="para">shows that the result of the addition is also a fractional number.</p>
<p class="para">One of the subclasses of the real numbers is the integral numbers. A simplified version of this class is:</p>
<div class="space1">
<p class="code"><span class="font">class (Real a, Enum a) =&gt; Integral a where</span></p>
<p class="code2"><span class="font">divMod :: a -&gt; a -&gt; (a,a)</span></p>
<p class="code2"><span class="font">toInteger :: a -&gt; Integer</span></p>
</div>
<p class="para">The class <span class="font">Integral</span> is a subclass of <span class="font">Enum</span>, those types whose elements can be enumerated in sequence. Every integral number can be converted into an <span class="font">Integer</span> through the conversion function <span class="font">toInteger</span>. That means we can convert an integral number into any other type of number in two steps:</p>
<div class="space1">
<p class="code"><span class="font">fromIntegral :: (Integral a, Num b) =&gt; a -&gt; b</span></p>
<p class="code"><span class="font">fromIntegral = fromInteger . toInteger</span></p>
</div>
<p class="para">Application of <span class="font">divMod</span> returns two values:</p>
<div class="space1">
<p class="code"><span class="font">x `div` y = fst (x `divMod` y)</span></p>
<p class="code"><span class="font">x `mod` y = snd (x `divMod` y)</span></p>
</div>
<p class="para">The standard prelude functions <span class="font">fst</span> and <span class="font">snd</span> return the first and second components of a pair:</p>
<div class="space1">
<p class="code"><span class="font">fst :: (a,b) -&gt; a</span></p>
<p class="code"><span class="font">fst (x,y) = x</span></p>
<p class="para1"></p>
<p class="code"><span class="font">snd :: (a,b) -&gt; b</span></p>
<p class="code"><span class="font">snd (x,y) = y</span></p>
</div>
<p class="para"><a id="text/part0007.html.page_52" class="calibre3"></a>Mathematically, <i class="calibre1">x</i> div <i class="calibre1">y</i> = ⌊<i class="calibre1">x</i>/<i class="calibre1">y</i>⌋. We will see how to compute ⌊<i class="calibre1">x</i>⌋ in the following section. And <i class="calibre1">x</i> mod <i class="calibre1">y</i> is defined by</p>
<p class="equationasimage"><i class="calibre1">x</i> =(<i class="calibre1">x</i> div <i class="calibre1">y</i>) ∗ <i class="calibre1">y</i> + <i class="calibre1">x</i> mod <i class="calibre1">y</i></p>
<p class="para">For positive <i class="calibre1">x</i> and <i class="calibre1">y</i> we have 0 ≤ <i class="calibre1">x</i> mod <i class="calibre1">y</i> &lt; <i class="calibre1">x</i>.</p>
<p class="para">Recall the function <span class="font">digits2</span> from the first chapter, where we defined</p>
<p class="code"><span class="font">digits2 n = (n `div` 10, n `mod` 10)</span></p>
<p class="para">It is more efficient to say <span class="font">digits2 n = n `divMod` 10</span> because then only one invocation of <span class="font">divMod</span> is required. Even more briefly, we can use a section and write <span class="font">digits2 = (`divMod` 10)</span>.</p>
<p class="para">There are also other numeric classes, including the subclass <span class="font">Floating</span> of the class <span class="font">Fractional</span> that contains, among others, the logarithmic and trigonometric functions. But enough is enough.</p>
<h3 class="h" id="text/part0007.html.head3-3">3.3 Computing floors</h3>
<p class="para">The value ⌊<i class="calibre1">x</i>⌋, the <i class="calibre1">floor</i> of <i class="calibre1">x</i>, is defined to be the largest integer <i class="calibre1">m</i> such that <i class="calibre1">m</i> ≤ <i class="calibre1">x</i>. We define a function <span class="font">floor :: Float -&gt; Integer</span> for computing floors. Haskell provides such a function in the standard prelude, but it is instructive to consider our own version.</p>
<p class="para">One student, call him Clever Dick, to whom this task was given came up with the following solution:</p>
<div class="space1">
<p class="code"><span class="font">floor :: Float -&gt; Integer</span></p>
<p class="code"><span class="font">floor = read . takeWhile (/= '.') . show</span></p>
</div>
<p class="para">In words, the number is shown as a string, the string is truncated by taking only the digits up to the decimal point, and the result is read again as an integer. We haven’t met <span class="font">takeWhile</span> yet, though Clever Dick evidently had. Clever Dick’s solution is wrong on a number of counts, and Exercise D asks you to list them.</p>
<p class="para">Instead we will find the floor of a number with the help of an explicit search, and for that we will need a loop:</p>
<div class="space1">
<p class="code"><span class="font">until :: (a -&gt; Bool) -&gt; (a -&gt; a) -&gt; a -&gt; a</span></p>
<p class="code"><span class="font">until p f x = if p x then x else until p f (f x)</span></p>
</div>
<p class="para">The function <span class="font">until</span> is also provided in the standard prelude. Here is an example:</p>
<p class="code6"><a id="text/part0007.html.page_53" class="calibre3"></a><span class="font">ghci&gt; until (&gt;100) (*7) 1</span></p>
<p class="code6"><span class="font">343</span></p>
<p class="para">Essentially <span class="font">until f p x</span> computes the first element <span class="font">y</span> in the infinite list</p>
<p class="code"><span class="font">[x, f x, f (f x), f (f (f x)), ...]</span></p>
<p class="para">for which <span class="font">p y = True</span>. See the following chapter where this interpretation of <span class="font">until</span> is made precise.</p>
<p class="para">Thinking now about the design of <span class="font">floor</span> it is tempting to start off with a case analysis, distinguishing between the cases <i class="calibre1">x</i> &lt; 0 and <i class="calibre1">x</i> ≥ 0. In the case <i class="calibre1">x</i> &lt; 0 we have to find the first number <i class="calibre1">m</i> in the sequence −1, −2, . . . for which <i class="calibre1">m</i> ≤ <i class="calibre1">x</i>. That leads to – in the case of a negative argument –</p>
<p class="code"><span class="font">floor x = until (`leq` x) (subtract 1) (-1)</span></p>
<p class="code10"><span class="font">where m `leq` x = fromInteger m &lt;= x</span></p>
<p class="para">There are a number of instructive points about this definition. Firstly, note the use of the prelude function <span class="font">subtract</span> whose definition is</p>
<p class="code"><span class="font">subtract x y = y-x</span></p>
<p class="para">We have to use <span class="font">subtract 1</span> because <span class="font">(-1)</span> is <i class="calibre1">not</i> a section but the number −1 (look at the third argument of <span class="font">until</span>).</p>
<p class="para">Secondly, why have we used <span class="font">`leq`</span> when the alternative <span class="font">(&lt;=)</span> seems perfectly adequate? The answer is that <span class="font">(&lt;=)</span> has the type</p>
<p class="code"><span class="font">(&lt;=) :: Num a =&gt; a -&gt; a -&gt; Bool</span></p>
<p class="para">In particular the two arguments of <span class="font">(&lt;=)</span> have to have the same type. But we want</p>
<p class="code"><span class="font">leq :: Integer -&gt; Float -&gt; Bool</span></p>
<p class="para">and the two arguments have different numeric types. We therefore need to convert integers to floats using <span class="font">fromInteger</span>. Appreciation of the need for conversion functions in some situations is one of the key points to understand about Haskell arithmetic.</p>
<p class="para">Finally, note that <span class="font">(`leq` x)</span> is not the same as <span class="font">(leq x)</span>:</p>
<div class="space1">
<p class="code"><span class="font">(leq x) y = leq x y</span></p>
<p class="code"><span class="font">(`leq` x) y = y `leq` x = leq y x</span></p>
</div>
<p class="para">It is easy to make this mistake.</p>
<p class="para">If you don’t like the subsidiary definition, you can always write</p>
<p class="code"><a id="text/part0007.html.page_54" class="calibre3"></a><span class="font">floor x = until ((&lt;=x) . fromInteger) (subtract 1) (-1)</span></p>
<p class="para">In this version we have <i class="calibre1">inlined</i> the definition of <span class="font">(`leq` x)</span>.</p>
<p class="para">We still have to deal with the case <i class="calibre1">x</i> ≥ 0. In this case we have to look for the first integer <i class="calibre1">n</i> such that <i class="calibre1">x</i> &lt; <i class="calibre1">n</i>+1. We can do this by finding the first integer <i class="calibre1">n</i> such that <i class="calibre1">x</i> &lt; <i class="calibre1">n</i> and subtracting 1 from the answer. That leads to</p>
<div class="space1">
<p class="code"><span class="font">floor x = until (x `lt` ) (+1) 1 - 1</span></p>
<p class="code10"><span class="font">where x `lt` n = x &lt; fromInteger n</span></p>
</div>
<p class="para">Putting the two pieces together, we obtain</p>
<div class="space1">
<p class="code"><span class="font">floor x = if x &lt; 0</span></p>
<p class="code10"><span class="font">then until (`leq` x) (subtract 1) (-1)</span></p>
<p class="code10"><span class="font">else until (x `lt`) (+1) 1 - 1</span></p>
</div>
<p class="para">(Question: why do we not have to write <span class="font">x &lt; fromInteger 0</span> in the first line?) The real problem with this definition, apart from the general ugliness of a case distinction and the asymmetry of the two cases, is that it is very slow: it takes about |<i class="calibre1">x</i>| steps (|<i class="calibre1">x</i>| is the mathematician’s way of writing <span class="font">abs x</span>) to deliver the result.</p>
<p class="equationasimage"><i class="calibre1">Binary search</i></p>
<p class="para">A better method for computing <span class="font">floor</span> is to first find integers <i class="calibre1">m</i> and <i class="calibre1">n</i> such that <i class="calibre1">m</i> ≤ <i class="calibre1">x</i> &lt; <i class="calibre1">n</i> and then shrink the interval (<i class="calibre1">m</i>, <i class="calibre1">n</i>) to a unit interval (one with <i class="calibre1">m</i>+1 = <i class="calibre1">n</i>) that contains <i class="calibre1">x</i>. Then the left-hand bound of the interval can be returned as the result. That leads to</p>
<div class="space1">
<p class="code"><span class="font">floor :: Float -&gt; Integer</span></p>
<p class="code"><span class="font">floor x = fst (until unit (shrink x) (bound x))</span></p>
<p class="code10"><span class="font">where unit (m,n) = (m+1 == n)</span></p>
</div>
<p class="para">The value <span class="font">bound x</span> is some pair (<i class="calibre1">m</i>, <i class="calibre1">n</i>) of integers such that <i class="calibre1">m</i> ≤ <i class="calibre1">x</i> &lt; <i class="calibre1">n</i>. If (<i class="calibre1">m</i>, <i class="calibre1">n</i>) is not a unit interval, then <span class="font">shrink x (m,n)</span> returns a new interval of strictly smaller size that still bounds <i class="calibre1">x</i>.</p>
<p class="para">Let us first consider how to shrink a non-unit interval (<i class="calibre1">m</i>, <i class="calibre1">n</i>) containing <i class="calibre1">x</i>, so <i class="calibre1">m</i> ≤ <i class="calibre1">x</i> &lt; <i class="calibre1">n</i>. Suppose <i class="calibre1">p</i> is any integer that satisfies <i class="calibre1">m</i> &lt; <i class="calibre1">p</i> &lt; <i class="calibre1">n</i>. Such a <i class="calibre1">p</i> exists since (<i class="calibre1">m</i>, <i class="calibre1">n</i>) is not a unit interval. Then we can define</p>
<div class="space1">
<p class="code"><span class="font">type Interval = (Integer,Integer)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">shrink :: Float -&gt; Interval -&gt; Interval</span></p>
<p class="para1"></p>
<p class="code"><a id="text/part0007.html.page_55" class="calibre3"></a><span class="font">shrink x (m,n) = if p `leq` x then (p,n) else (m,p)</span></p>
<p class="code5"><span class="font">where p = choose (m,n)</span></p>
</div>
<p class="para">How should we define <span class="font">choose</span>?</p>
<p class="para">Two possible choices are <span class="font">choose (m,n) = m+1</span> or <span class="font">choose (m,n) = n-1</span> for both reduce the size of an interval. But a better choice is</p>
<div class="space1">
<p class="code"><span class="font">choose :: Interval -&gt; Integer</span></p>
<p class="code"><span class="font">choose (m,n) = (m+n) `div` 2</span></p>
</div>
<p class="para">With this choice the size of the interval is halved at each step rather than reduced by 1.</p>
<p class="para">However, we need to check that <i class="calibre1">m</i> &lt; (<i class="calibre1">m</i> + <i class="calibre1">n</i>) div 2 &lt; <i class="calibre1">n</i> in the case <i class="calibre1">m</i> + 1 ≠ <i class="calibre1">n</i>. The reasoning is:</p>
<p class="code4"><span class="space"></span><i class="calibre1">m</i> &lt; (<i class="calibre1">m</i> + <i class="calibre1">n</i>) div 2 &lt; <i class="calibre1">n</i></p>
<p class="code4">≡<span class="space5"></span>{ordering on integers}</p>
<p class="code4"><span class="space"></span><i class="calibre1">m</i> + 1 ≤ (<i class="calibre1">m</i> + <i class="calibre1">n</i>) div 2 &lt; <i class="calibre1">n</i></p>
<p class="code4">≡<span class="space5"></span>{since (<i class="calibre1">m</i> + <i class="calibre1">n</i>) div 2 = ⌊(<i class="calibre1">m</i> + <i class="calibre1">n</i>)/2⌋}</p>
<p class="code4"><span class="space"></span><i class="calibre1">m</i> + 1 ≤ (<i class="calibre1">m</i> + <i class="calibre1">n</i>)/2 &lt; <i class="calibre1">n</i></p>
<p class="code4">≡<span class="space5"></span>{arithmetic}</p>
<p class="code4"><span class="space"></span><i class="calibre1">m</i> + 2 ≤ <i class="calibre1">n</i> ∧ <i class="calibre1">m</i> &lt; <i class="calibre1">n</i></p>
<p class="code4">≡<span class="space5"></span>{arithmetic}</p>
<p class="code4"><span class="space"></span><i class="calibre1">m</i> + 1 &lt; <i class="calibre1">n</i></p>
<p class="para">Finally, how should we define <span class="font">bound</span>? We can start off by defining</p>
<div class="space1">
<p class="code"><span class="font">bound :: Float -&gt; Interval</span></p>
<p class="code"><span class="font">bound x = (lower x, upper x)</span></p>
</div>
<p class="para">The value <span class="font">lower x</span> is some integer less than or equal to <span class="font">x</span>, and <span class="font">upper x</span> some integer greater than <span class="font">x</span>. Instead of using linear search to discover these values, it is better to use</p>
<div class="space1">
<p class="code"><span class="font">lower :: Float -&gt; Integer</span></p>
<p class="code"><span class="font">lower x = until (`leq` x) (*2) (-1)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">upper :: Float -&gt; Integer</span></p>
<p class="code"><span class="font">upper x = until (x `lt`) (*2) 1</span></p>
</div>
<p class="para"><a id="text/part0007.html.page_56" class="calibre3"></a>For a fast version of <span class="font">bound</span> it is better to double at each step rather than increase or decrease by 1. For example, with <i class="calibre1">x</i> = 17.3 it takes only seven comparisons to compute the surrounding interval (−1, 32), which is then reduced to (17, 18) in a further five steps. In fact, evaluating both the upper and lower bounds takes time proportional to log|<i class="calibre1">x</i>| steps, and the whole algorithm takes at most twice this time. An algorithm that takes logarithmic time is much faster than one that takes linear time.</p>
<p class="para">The standard prelude defines <span class="font">floor</span> in the following way:</p>
<div class="space1">
<p class="code"><span class="font">floor x = if r &lt; 0 then n-1 else n</span></p>
<p class="code10"><span class="font">where (n,r) = properFraction x</span></p>
</div>
<p class="para">The function <span class="font">properFraction</span> is a method in the <span class="font">RealFrac</span> type class (a class we haven’t discussed and whose methods deal with truncating and rounding numbers). It splits a number <i class="calibre1">x</i> into its integer part <i class="calibre1">n</i> and its fractional part <i class="calibre1">r</i>, so <i class="calibre1">x</i> = <i class="calibre1">n</i>+<i class="calibre1">r</i>. Now you know.</p>
<h3 class="h" id="text/part0007.html.head3-4">3.4 Natural numbers</h3>
<p class="para">Haskell does not provide a type for the natural numbers, that is, the nonnegative integers. But we can always define such a type ourselves:</p>
<p class="code"><span class="font">data Nat = Zero | Succ Nat</span></p>
<p class="para">This is an example of a <i class="calibre1">data declaration</i>. The declaration says that <span class="font">Zero</span> is a value of <span class="font">Nat</span> and that <span class="font">Succ n</span> is also a value of <span class="font">Nat</span> whenever <span class="font">n</span> is. Both <span class="font">Zero</span> and <span class="font">Succ</span> are called <i class="calibre1">data constructors</i> and begin with a capital letter. The type of <span class="font">Zero</span> is <span class="font">Nat</span> and the type of <span class="font">Succ</span> is <span class="font">Nat -&gt; Nat</span>. Thus each of</p>
<p class="code"><span class="font">Zero, Succ Zero, Succ (Succ Zero), Succ (Succ (Succ Zero))</span></p>
<p class="para">is an element of <span class="font">Nat</span>.</p>
<p class="para">Let us see how to program the basic arithmetical operations by making <span class="font">Nat</span> a fully paid-up member of the <span class="font">Num</span> class. First, we have to make <span class="font">Nat</span> an instance of <span class="font">Eq</span> and <span class="font">Show</span>:</p>
<div class="space1">
<p class="code"><span class="font">instance Eq Nat where</span></p>
<p class="code"><span class="space"></span><span class="font">Zero == Zero</span><span class="space4"></span><span class="font">= True</span></p>
<p class="code"><span class="space"></span><span class="font">Zero == Succ n</span><span class="space5"></span><span class="font">= False</span></p>
<p class="code"><span class="space"></span><span class="font">Succ m == Zero</span><span class="space5"></span><span class="font">= False</span></p>
<p class="code"><span class="space"></span><span class="font">Succ m == Succ n</span><span class="space"></span><span class="font">= (m == n)</span></p>
</div>
<div class="space1">
<p class="code"><a id="text/part0007.html.page_57" class="calibre3"></a><span class="font">instance Show Nat where</span></p>
<p class="code"><span class="space"></span><span class="font">show Zero</span><span class="space7"></span><span class="font">= "Zero"</span></p>
<p class="code"><span class="space"></span><span class="font">show (Succ Zero)</span><span class="space4"></span><span class="font">= "Succ Zero"</span></p>
<p class="code"><span class="space"></span><span class="font">show (Succ (Succ n)) = "Succ (" ++ show (Succ n) ++ ")"</span></p>
</div>
<p class="para">These definitions make use of <i class="calibre1">pattern matching</i>. In particular, the definition of <span class="font">show</span> makes use of three patterns, <span class="font">Zero</span>, <span class="font">Succ Zero</span> and <span class="font">Succ (Succ n)</span>. These patterns are different from one another and together cover all the elements of <span class="font">Nat</span> apart from ⊥.</p>
<p class="para">Alternatively, we could have declared</p>
<p class="code"><span class="font">data Nat = Zero | Succ Nat deriving (Eq,Ord,Show)</span></p>
<p class="para">As we said in Exercise E of the previous chapter, Haskell is smart enough to construct automatically instances of some standard classes, including <span class="font">Eq</span>, <span class="font">Ord</span> and <span class="font">Show</span>.</p>
<p class="para">Now we can install <span class="font">Nat</span> as a numeric type:</p>
<div class="space1">
<p class="code"><span class="font">instance Num Nat where</span></p>
<p class="code2"><span class="font">m + Zero</span><span class="space5"></span><span class="font">= m</span></p>
<p class="code2"><span class="font">m + Succ n = Succ (m+n)</span></p>
<p class="para1"></p>
<p class="code2"><span class="font">m * Zero</span><span class="space4"></span><span class="font">= Zero</span></p>
<p class="code2"><span class="font">m * (Succ n) = m * n + m</span></p>
<p class="para1"></p>
<p class="code2"><span class="font">abs n</span><span class="space3"></span><span class="space-r1"></span><span class="font">= n</span></p>
<p class="code2"><span class="font">signum Zero</span><span class="space4"></span><span class="font">= Zero</span></p>
<p class="code2"><span class="font">signum (Succ n) = Succ Zero</span></p>
<p class="para1"></p>
<p class="code2"><span class="font">m - Zero</span><span class="space8"></span><span class="font">= m</span></p>
<p class="code2"><span class="font">Zero - Succ n</span><span class="space5"></span><span class="font">= Zero</span></p>
<p class="code2"><span class="font">Succ m - Succ n = m - n</span></p>
<p class="para1"></p>
<p class="code2"><span class="font">fromInteger x</span></p>
<p class="code2"><span class="space"></span><span class="font">| x &lt;= 0</span><span class="space5"></span><span class="space-r1"></span><span class="font">= Zero</span></p>
<p class="code2"><span class="space"></span><span class="font">| otherwise = Succ (fromInteger (x-1))</span></p>
</div>
<p class="para">We have defined subtraction as a total operation: <i class="calibre1">m</i>−<i class="calibre1">n</i> = 0 if <i class="calibre1">m</i> ≤ <i class="calibre1">n</i>. Of course, the arithmetic operations on <span class="font">Nat</span> are horribly slow. And each number takes up a lot of space.</p>
<h3 class="h"><i class="calibre16">Partial numbers</i></h3>
<p class="para"><a id="text/part0007.html.page_58" class="calibre3"></a>We have said that there is a value ⊥ of every type. Thus <span class="font">undefined :: a</span> for all types <span class="font">a</span>. Since <span class="font">Succ</span> is, by definition, a non-strict function, the values</p>
<p class="code"><span class="font">undefined, Succ undefined, Succ (Succ undefined), ...</span></p>
<p class="para">are all different and all members of <span class="font">Nat</span>. To be honest, these partial numbers are not very useful, but they are there. You can think of <span class="font">Succ undefined</span> as being a number about which we know only that it is at least 1:</p>
<p class="code6"><span class="font">ghci&gt; Zero == Succ undefined</span></p>
<p class="code6"><span class="font">False</span></p>
<p class="code6"><span class="font">ghci&gt; Succ Zero == Succ undefined</span></p>
<p class="code6"><span class="font">*** Exception: Prelude.undefined</span></p>
<p class="para">There is also one further number in <span class="font">Nat</span>:</p>
<div class="space1">
<p class="code"><span class="font">infinity :: Nat</span></p>
<p class="code"><span class="font">infinity = Succ infinity</span></p>
</div>
<p class="para">Thus</p>
<p class="code6"><span class="font">ghci&gt; Zero == infinity</span></p>
<p class="code6"><span class="font">False</span></p>
<p class="code6"><span class="font">ghci&gt; Succ Zero == infinity</span></p>
<p class="code6"><span class="font">False</span></p>
<p class="para">and so on.</p>
<p class="para">In summary, the elements of <span class="font">Nat</span> consist of the finite numbers, the partial numbers and the infinite numbers (of which there is only one). We shall see that this is true of other data types: there are the finite elements of the type, the partial elements and the infinite elements.</p>
<p class="para">We could have chosen to make the constructor <span class="font">Succ</span> strict. This is achieved by declaring</p>
<p class="code"><span class="font">data Nat = Zero | Succ !Nat</span></p>
<p class="para">The annotation <span class="font">!</span> is known as <i class="calibre1">strictness flag</i>. With such a declaration, we have for example</p>
<p class="code6"><span class="font">ghci&gt; Zero == Succ undefined</span></p>
<p class="code6"><span class="font">*** Exception: Prelude.undefined</span></p>
<p class="para"><a id="text/part0007.html.page_59" class="calibre3"></a>This time, evaluating the equality test forces the evaluation of both sides, and the evaluation of <span class="font">Succ undefined</span> raises an error message. Making <span class="font">Succ</span> strict collapses the natural numbers into just the finite numbers and one undefined number.</p>
<h3 class="h" id="text/part0007.html.head3-5">3.5 Exercises</h3>
<p class="theorem"><b class="calibre7">Exercise A</b></p>
<p class="para">Which of the following expressions denote 1?</p>
<p class="code"><span class="font">-2 + 3, 3 + -2, 3 + (-2), subtract 2 3, 2 + subtract 3</span></p>
<p class="para">In the standard prelude there is a function <span class="font">flip</span> defined by</p>
<p class="code"><span class="font">flip f x y = f y x</span></p>
<p class="para">Express <span class="font">subtract</span> using <span class="font">flip</span>.</p>
<p class="theorem"><b class="calibre7">Exercise B</b></p>
<p class="para">Haskell provides no fewer than three ways to define exponentiation:</p>
<div class="space1">
<p class="code"><span class="font">(^)</span><span class="space"></span><span class="space-r1"></span><span class="font">:: (Num a, Integral b) =&gt; a -&gt; b -&gt; a</span></p>
<p class="code"><span class="font">(^^) :: (Fractional a, Integral b) =&gt; a -&gt; b -&gt; a</span></p>
<p class="code"><span class="font">(**) :: (Floating a) =&gt; a -&gt; a -&gt; a</span></p>
</div>
<p class="para">The operation <span class="font">(^)</span> raises any number to a nonnegative integral power; <span class="font">(^^)</span> raises any number to any integral power (including negative integers); and <span class="font">(**)</span> takes two fractional arguments. The definition of <span class="font">(^)</span> basically follows Dick’s method of the previous chapter (see Exercise E). How would you define <span class="font">(^^)</span>?</p>
<p class="theorem"><b class="calibre7">Exercise C</b></p>
<p class="para">Could you define <span class="font">div</span> in the following way?</p>
<div class="space1">
<p class="code"><span class="font">div :: Integral a =&gt; a -&gt; a -&gt; a</span></p>
<p class="code"><span class="font">div x y = floor (x/y)</span></p>
</div>
<p class="theorem"><b class="calibre7">Exercise D</b></p>
<p class="para">Consider again Clever Dick’s solution for computing <span class="font">floor</span>:</p>
<div class="space1">
<p class="code"><span class="font">floor :: Float -&gt; Integer</span></p>
<p class="code"><span class="font">floor = read . (takeWhile (/= '.') . show</span></p>
</div>
<p class="para"><a id="text/part0007.html.page_60" class="calibre3"></a>Why doesn’t it work?</p>
<p class="para">Consider the following mini-interaction with GHCi:</p>
<p class="code6"><span class="font">ghci&gt; 12345678.0 :: Float</span></p>
<p class="code6"><span class="font">1.2345678e7</span></p>
<p class="para">Haskell allows the use of so-called <i class="calibre1">scientific notation</i>, also called <i class="calibre1">exponent notation</i>, to describe certain floating-point numbers. For example the number above denotes 1.2345678 ∗ 10<sup class="calibre8">7</sup>. When the number of digits of a floating-point number is sufficiently large, the number is printed in this notation. Now give another reason why Clever Dick’s solution doesn’t work.</p>
<p class="theorem"><b class="calibre7">Exercise E</b></p>
<p class="para">The function <span class="font">isqrt :: Float -&gt; Integer</span> returns the floor of the square root of a (nonnegative) number. Following the strategy of <a href="#text/part0007.html.head3-3" class="calibre3">Section 3.3</a>, construct an implementation of <span class="font">isqrt x</span> that takes time proportional to log<i class="calibre1">x</i> steps.</p>
<p class="theorem"><b class="calibre7">Exercise F</b></p>
<p class="para">Haskell provides a function <span class="font">sqrt :: Floating a =&gt; a -&gt; a</span> that gives a reasonable approximation to the square root of a (nonnegative) number. But, let’s define our own version. If <i class="calibre1">y</i> is an approximation to 
<img src="data:image/gif;base64,R0lGODlhGwAVAOcAACMfICMfOiYfPDcfIC0fXz4fWSMiYyMkeCNEcEcfL1gfIEwiMUoyI28kJWU/Km8yI3xoVSMuiSZKiSNFmiZOmyZWoCh0ujxttT57v286hEdXpTyBw2+JtkaU0FCf2Fml2n2QxmCq3miq23+m0m+15XW66ZU7LII6dY9KLJVNLJpFPLZtOJVFZpVHdqVXWqF0WbZtWpqNWr+PdMSBRtKUWtaaVtaaWtqffd6lZuKqaOq1dfG/fpqvmbqEi7+bg6OWu5rIxYLE7Y/N8pjM7pXR86Xe+KzZ9bbq+7ru/M2ilua+h+G2lefInPLEhPfRlfvRlPzWmv7epf3eqfvir/7qtcHR4cPq+8Ty/cn4/trr+NX599b8/973/tr6/t79/+ba0+PW4fvn0P/yw//zyv/2zv7z0v/50P/80f/81f/92+b7/ujz8+r+/+7+//7z6v/64P/75P/+5f/+5v/76f//7fH///L+//T+//vw8P//8///9f//9vn///r/////+P//+/3//////f7//gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAAAAP8ALAAAAAAbABUAAAjnAAUJHEiwoMGDCBMqXCgFgMOHDhcazEPjAyCJC6lkuIJR4R4bHi52RCjmxJGRCP3g6MDnjQ8HFLQoWRBipJkWJwUF2kGAx4gvWTr+0bHBzsAoCip0STgniRGCZlgUIXjGREiEZV4wsNBGYKAmGOoQnPKAK0I3a2oYmCoojQsiBOX0iBEBC547CKk0YPn1AhuBYaosGfKkAJAfauDI4MCFIJ0ZB5DEgSFEoJ8cAkT0IZNCghVBY1AEKFEQSoIPTjR4wbjnBlyCcVYggBAEox8mILoS/DpgwhaMesAYNYhGBQmUyJMrJxgQADsAAA==" alt="image" class="calibre2"> then so is <i class="calibre1">x</i>/<i class="calibre1">y</i>. Moreover, either <img src="data:image/jpeg;base64,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" alt="image" class="calibre2"> What is a better approximation to <img src="data:image/gif;base64,R0lGODlhGgAXAOcAACMfICMfJSYfPDUfOigfUi0fXz4fWSMiY1gfIEwiMW8kJWU/Km8yI0ckdEZ4eHVVRyMuiSZKiSZOmyZWoCZXpSh0ujxttWk6hG89j1lFlUdXpUlttTyBw0ea1VCf2Fmf2Fml22Cq3miq23+m0m+15XW66Xy/64I0I5U7LJVNLJpFJZpFX5VFZqVXWrZtVZqNWsSBRsSBVcSBWdKUWtaaVt+qb+KqaOq1dPG/fpqvmbqEi7+bg6KMr6OWu5rIxYLE7ZjM7pXR86Xe7KDa97bq++a+h+G2lfLEhPnRlfvRlPzWmvPVpP3epf7epfvir/7qtcHR4cPq+8Ty/cn4/s34/trr+NX599L5/tr5/tr6/t79/+ba0/vqyvvn0P/yw//2zvP81f/50P/80f/81f/92+b7/ur+/+7///Po6v/64P/+5f/+5v//7fL///T+//vw8P//9vr/////+P//+/z//////P7//gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAAAAP8ALAAAAAAaABcAAAjVAO0IHEiwoMGDCBMqXMiwocOGcmp8oPPwYBgWADJqzPhwzg0ObSoaHLNiiMiCdY5YMHOSIJkWQeyk2bFAgpUiCUI4RLKBpZ06OArkGLGlSkM1Ln4QbIJgQhaEXHhgIYhEgxaCYlB4oIhyyYMBJQaykWGioBMGFc4YrIMGjAoKV+0wyXCF4BodLyBMeePGoEcCMdnEIDGwCxQjQJIY8NGjzEEvJ9I+wUBFoBwbAkTE+ZIiQhSEcGgcEDIDBNeTTxQ4uCClpUA2MAJ0ON1SSQMirnPrLhgQADs=" alt="image" class="calibre2"> than either <i class="calibre1">y</i> or <i class="calibre1">x</i>/<i class="calibre1">y</i>? (Yes, you have just rediscovered Newton’s method for finding square roots.)</p>
<p class="para">The only remaining problem is to decide when an approximation <i class="calibre1">y</i> is good enough. One possible test is |<i class="calibre1">y</i><sup class="calibre8">2</sup> −<i class="calibre1">x</i>| &lt; <i class="calibre1">ε</i>, where |<i class="calibre1">x</i>| returns the absolute value of <i class="calibre1">x</i> and <i class="calibre1">ε</i> is a suitably small number. This test guarantees an <i class="calibre1">absolute</i> error of at most <i class="calibre1">ε</i>. Another test is |<i class="calibre1">y</i><sup class="calibre8">2</sup> −<i class="calibre1">x</i>| &lt; <i class="calibre1">ε</i> ∗<i class="calibre1">x</i>, which guarantees a <i class="calibre1">relative</i> error of at most <i class="calibre1">ε</i>. Assuming that numbers of type <span class="font">Float</span> are accurate only to six significant figures, which of these two is the more sensible test, and what is a sensible value for <i class="calibre1">ε</i>?</p>
<p class="para">Hence construct a definition of <span class="font">sqrt</span>.</p>
<p class="theorem"><b class="calibre7">Exercise G</b></p>
<p class="para">Give an explicit instance of <span class="font">Nat</span> as a member of the type class <span class="font">Ord</span>. Hence construct a definition of</p>
<p class="code"><span class="font">divMod :: Nat -&gt; Nat -&gt; (Nat,Nat)</span></p>
<h3 class="h" id="text/part0007.html.head3-6">3.6 Answers</h3>
<p class="theorem"><a id="text/part0007.html.page_61" class="calibre3"></a><b class="calibre7">Answer to Exercise A</b></p>
<p class="para">All except <span class="font">2 + -3</span> and <span class="font">2 + subtract 3</span>, neither of which are well-formed. We have <span class="font">subtract = flip (-)</span>.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise B</b></p>
<p class="code"><span class="font">x ^^ n = if 0 &lt;= n then x^n else 1/(x ^ (negate n))</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise C</b></p>
<p class="para">No. You would have to write</p>
<div class="space1">
<p class="code"><span class="font">div :: Integral a =&gt; a -&gt; a -&gt; a</span></p>
<p class="code"><span class="font">div x y = floor (fromInteger x / fromInteger y)</span></p>
</div>
<p class="theorem"><b class="calibre7">Answer to Exercise D</b></p>
<p class="para">Clever Dick’s function gives <span class="font">floor (-3.1) = -3</span> when the answer should be <span class="font">-4</span>. And if you tried to repair his solution by subtracting 1 if the solution was negative, you would have <span class="font">floor (-3.0) = -4</span> when the answer should be <span class="font">-3</span>. Ugh!</p>
<p class="para">Also, Clever Dick’s solution has <span class="font">floor 12345678.0 = 1</span> because the argument is shown as <span class="font">1.2345678e7</span>.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise E</b></p>
<div class="space1">
<p class="code"><span class="font">isqrt :: Float -&gt; Integer</span></p>
<p class="code"><span class="font">isqrt x = fst (until unit (shrink x) (bound x))</span></p>
<p class="code10"><span class="font">where unit (m,n) = (m+1 == n)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">shrink :: Float -&gt; Interval -&gt; Interval</span></p>
<p class="code"><span class="font">shrink x (m,n) = if (p*p) `leq` x then (p,n) else (m,p)</span></p>
<p class="code10"><span class="font">where p = (m+n) `div` 2</span></p>
<p class="para1"></p>
<p class="code"><span class="font">bound :: Float -&gt; Interval</span></p>
<p class="code"><span class="font">bound x = (0,until above (*2) 1)</span></p>
<p class="code10"><span class="font">where above n = x `lt` (n*n)</span></p>
</div>
<p class="para">The functions <span class="font">`leq`</span> and <span class="font">`lt`</span> were defined in <a href="#text/part0007.html.head3-3" class="calibre3">Section 3.3</a>. Note the parentheses in the expressions <span class="font">(p*p) `leq` x</span> and <span class="font">x `lt` (n*n)</span>. We didn’t state an order of association for <span class="font">`leq`</span> and <span class="font">`lt`</span>, so without parentheses these two expressions</p>
<p class="para"><a id="text/part0007.html.page_62" class="calibre3"></a>would have been interpreted as the ill-formed expressions <span class="font">p * (p `leq` x)</span> and <span class="font">(x `lt` n) * n</span>. (I made just this mistake when first typing in the solution.)</p>
<p class="theorem"><b class="calibre7">Answer to Exercise F</b></p>
<p class="para">A better approximation to <img src="data:image/gif;base64,R0lGODlhGgAXAOcAACMfICMfJSYfPDUfOigfUi0fXz4fWSMiY1gfIEwiMW8kJWU/Km8yI0ckdEZ4eHVVRyMuiSZKiSZOmyZWoCZXpSh0ujxttWk6hG89j1lFlUdXpUlttTyBw0ea1VCf2Fmf2Fml22Cq3miq23+m0m+15XW66Xy/64I0I5U7LJVNLJpFJZpFX5VFZqVXWrZtVZqNWsSBRsSBVcSBWdKUWtaaVt+qb+KqaOq1dPG/fpqvmbqEi7+bg6KMr6OWu5rIxYLE7ZjM7pXR86Xe7KDa97bq++a+h+G2lfLEhPnRlfvRlPzWmvPVpP3epf7epfvir/7qtcHR4cPq+8Ty/cn4/s34/trr+NX599L5/tr5/tr6/t79/+ba0/vqyvvn0P/yw//2zvP81f/50P/80f/81f/92+b7/ur+/+7///Po6v/64P/+5f/+5v//7fL///T+//vw8P//9vr/////+P//+/z//////P7//gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAAAAP8ALAAAAAAaABcAAAjVAO0IHEiwoMGDCBMqXMiwocOGcmp8oPPwYBgWADJqzPhwzg0ObSoaHLNiiMiCdY5YMHOSIJkWQeyk2bFAgpUiCUI4RLKBpZ06OArkGLGlSkM1Ln4QbIJgQhaEXHhgIYhEgxaCYlB4oIhyyYMBJQaykWGioBMGFc4YrIMGjAoKV+0wyXCF4BodLyBMeePGoEcCMdnEIDGwCxQjQJIY8NGjzEEvJ9I+wUBFoBwbAkTE+ZIiQhSEcGgcEDIDBNeTTxQ4uCClpUA2MAJ0ON1SSQMirnPrLhgQADs=" alt="image" class="calibre2"> than either <i class="calibre1">y</i> or <i class="calibre1">x</i>/<i class="calibre1">y</i> is (<i class="calibre1">y</i>+<i class="calibre1">x</i>/<i class="calibre1">y</i>)/2. The relative-error test is the more sensible one, and the program is</p>
<div class="space1">
<p class="code"><span class="font">sqrt :: Float -&gt; Float</span></p>
<p class="code"><span class="font">sqrt x = until goodenough improve x</span></p>
<p class="code10"><span class="font">where goodenough y = abs (y*y-x) &lt; eps*x</span></p>
<p class="code14"><span class="font">improve y</span><span class="space5"></span><span class="font">= (y+x/y)/2</span></p>
<p class="code14"><span class="font">eps</span><span class="space8"></span><span class="space-r"></span><span class="font">= 0.000001</span></p>
</div>
<p class="theorem"><b class="calibre7">Answer to Exercise G</b></p>
<p class="para">It is sufficient to define <span class="font">(&lt;)</span>:</p>
<div class="space1">
<p class="code"><span class="font">instance Ord Nat where</span></p>
<p class="code2"><span class="font">Zero &lt; Zero</span><span class="space4"></span><span class="space-r1"></span><span class="font">= False</span></p>
<p class="code2"><span class="font">Zero &lt; Succ n</span><span class="space5"></span><span class="font">= True</span></p>
<p class="code2"><span class="font">Succ m &lt; Zero</span><span class="space5"></span><span class="font">= False</span></p>
<p class="code2"><span class="font">Succ m &lt; Succ n</span><span class="space"></span><span class="font">= (m &lt; n)</span></p>
</div>
<p class="para">Now we can define</p>
<div class="space1">
<p class="code"><span class="font">divMod :: Nat -&gt; Nat -&gt; (Nat,Nat)</span></p>
<p class="code"><span class="font">divMod x y = if x &lt; y then (Zero,x)</span></p>
<p class="code10"><span class="font">else (Succ q,r)</span></p>
<p class="code10"><span class="font">where (q,r) = divMod (x-y) y</span></p>
</div>
<h3 class="h" id="text/part0007.html.head3-7">3.7 Chapter notes</h3>
<p class="para">The primary source book for computer arithmetic is <i class="calibre1">The Art of Computer Programming, Volume 2: Semi-numerical Algorithms</i> (Addison-Wesley, 1998) by Don Knuth. The arithmetic of floors and other simple numerical functions is studied in depth in <i class="calibre1">Concrete Mathematics</i> (Addison-Wesley, 1989) by Don Knuth, Ronald Graham and Oren Patashnik.</p>
</div></div>
<div id="text/part0008.html"><div id="text/part0008.html.7K4G0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre">

<h2 class="chapter-number" id="text/part0008.html.calibre_pb_0"><a id="text/part0008.html.page_63" class="calibre6"></a>Chapter 4</h2>
<h2 class="chapter-title">Lists</h2>
<p class="para">Lists are the workhorses of functional programming. They can be used to fetch and carry data from one function to another; they can be taken apart, rearranged and combined with other lists to make new lists. Lists of numbers can be summed and multiplied; lists of characters can be read and printed; and so on. The list of useful operations on lists is a long one. This chapter describes some of the operations that occur most frequently, though one particularly important class will be introduced only in <a href="#text/part0010.html.9H5K0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 6</a>.</p>
<h3 class="h" id="text/part0008.html.head4-1">4.1 List notation</h3>
<p class="para">As we have seen, the type <span class="font">[a]</span> denotes lists of elements of type <span class="font">a</span>. The empty list is denoted by <span class="font">[]</span>. We can have lists over any type but we cannot mix different types in the same list. As examples,</p>
<table class="code15">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="font">[undefined,undefined]</span></td>
<td class="calibre14"><span class="font">::</span></td>
<td class="calibre14"><span class="font">[a]</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="font">[sin,cos,tan]</span></td>
<td class="calibre14"><span class="font">::</span></td>
<td class="calibre14"><span class="font">Floating a =&gt; [a -&gt; a]</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="font">[[1,2,3],[4,5]]</span></td>
<td class="calibre14"><span class="font">::</span></td>
<td class="calibre14"><span class="font">Num a =&gt; [[a]]</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="font">["tea","for",2]</span></td>
<td class="calibre14"></td>
<td class="calibre14"><span class="font">not valid</span></td>
</tr>
</tbody></table>
<p class="para">List notation, such as <span class="font">[1,2,3]</span>, is in fact an abbreviation for a more basic form</p>
<p class="code"><span class="font">1:2:3:[]</span></p>
<p class="para">The operator <span class="font">(:) :: a -&gt; [a] -&gt; [a]</span>, pronounced ‘cons’, is a constructor for lists. It associates to the right so there is no need for parentheses in the above expression. It has no associated definition, which is why it is a constructor. In other words, there are no rules for simplifying an expression such as <span class="font">1:2:[]</span>. The <a id="text/part0008.html.page_64" class="calibre3"></a>operator <span class="font">(:)</span> is non-strict in both arguments – more precisely, it is non-strict and returns a non-strict function. The expression</p>
<p class="code"><span class="font">undefined : undefined</span></p>
<p class="para">may not be very interesting, but we do know it is not the empty list. In fact, that is the only thing we do know about it. Note that the two occurrences of <span class="font">undefined</span> have different types in this expression.</p>
<p class="para">The empty list <span class="font">[]</span> is also a constructor. Lists can be introduced as a Haskell data type with the declaration</p>
<p class="code"><span class="font">data List a = Nil | Cons a (List a)</span></p>
<p class="para">The only difference is that <span class="font">List a</span> is written <span class="font">[a]</span>, <span class="font">Nil</span> is written <span class="font">[]</span> and <span class="font">Cons</span> is written <span class="font">(:)</span>.</p>
<p class="para">According to this declaration, every list of type <span class="font">[a]</span> takes one of three forms:</p>
<ul class="calibre9">
<li class="calibre10">The undefined list <span class="font">undefined :: [a]</span>;</li>
<li class="calibre10">The empty list <span class="font">[] :: [a]</span>;</li>
<li class="calibre10">A list of the form <span class="font">x:xs</span> where <span class="font">x :: a</span> and <span class="font">xs :: [a]</span>.</li>
</ul>
<p class="para">As a result there are three kinds of list:</p>
<ul class="calibre9">
<li class="calibre10">A <i class="calibre1">finite</i> list, which is built from <span class="font">(:)</span> and <span class="font">[]</span>; for example, <span class="font">1:2:3:[]</span></li>
<li class="calibre10">A <i class="calibre1">partial</i> list, which is built from <span class="font">(:)</span> and <span class="font">undefined</span>; for example, the list <span class="font">filter (&lt;4) [1..]</span> is the partial list <span class="font">1:2:3:undefined</span>. We know there is no integer after 3 that is less than 4, but Haskell is an evaluator, not a theorem prover, so it ploughs away without success looking for more answers.</li>
<li class="calibre10">An <i class="calibre1">infinite</i> list, which is built from <span class="font">(:)</span> alone; for example, <span class="font">[1..]</span> is the infinite list of the nonnegative integers.</li>
</ul>
<p class="para">All three kinds of list arise in everyday programming. <a href="#text/part0013.html.CCNA0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 9</a> is devoted to exploring the world of infinite lists and their uses. For example, the prelude function <span class="font">iterate</span> returns an infinite list:</p>
<div class="space1">
<p class="code"><span class="font">iterate :: (a -&gt; a) -&gt; a -&gt; [a]</span></p>
<p class="code"><span class="font">iterate f x = x:iterate f (f x)</span></p>
</div>
<p class="para">In particular, <span class="font">iterate (+1) 1</span> is an infinite list of the positive integers, a value we can also write as <span class="font">[1..]</span> (see the following section).</p>
<p class="para">As another example,</p>
<div class="space1">
<p class="code"><a id="text/part0008.html.page_65" class="calibre3"></a><span class="font">head (filter perfect [1..])</span></p>
<p class="code2"><span class="font">where perfect n = (n == sum (divisors n))</span></p>
</div>
<p class="para">returns the first perfect number, namely 6, even though nobody currently knows whether <span class="font">filter perfect [1..]</span> is an infinite or partial list.</p>
<p class="para">Finally, we can define</p>
<p class="code"><span class="font">until p f = head . filter p . iterate f</span></p>
<p class="para">The function <span class="font">until</span> was used to compute floors in the previous chapter. As this example demonstrates, functions that seem basic in programming are often composed of even simpler functions. A bit like protons and quarks.</p>
<h3 class="h" id="text/part0008.html.head4-2">4.2 Enumerations</h3>
<p class="para">Haskell provides useful notation for enumerating lists of integers. When <i class="calibre1">m</i> and <i class="calibre1">n</i> are integers we can write</p>
<table class="code15">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="font">[m..n]</span></td>
<td class="calibre14">for the list [<i class="calibre1">m</i>, <i class="calibre1">m</i>+1, . . . , <i class="calibre1">n</i>]</td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="font">[m..]</span></td>
<td class="calibre14">for the infinite list [<i class="calibre1">m</i>, <i class="calibre1">m</i>+1, <i class="calibre1">m</i>+2, . . .]</td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="font">[m,n..p]</span></td>
<td class="calibre14">for the list [<i class="calibre1">m</i>, <i class="calibre1">m</i>+(<i class="calibre1">n</i>−<i class="calibre1">m</i>), <i class="calibre1">m</i>+2(<i class="calibre1">n</i>−<i class="calibre1">m</i>), . . . , <i class="calibre1">p</i>]</td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="font">[m,n..]</span></td>
<td class="calibre14">for the infinite list [<i class="calibre1">m</i>, <i class="calibre1">m</i>+(<i class="calibre1">n</i>−<i class="calibre1">m</i>), <i class="calibre1">m</i>+2(<i class="calibre1">n</i>−<i class="calibre1">m</i>), . . .]</td>
</tr>
</tbody></table>
<p class="para">The first two notations crop up frequently in practice, the second two less so. As examples,</p>
<p class="code6"><span class="font">ghci&gt; [0,2..11]</span></p>
<p class="code6"><span class="font">[0,2,4,6,8,10]</span></p>
<p class="code6"><span class="font">ghci&gt; [1,3..]</span></p>
<p class="code6"><span class="font">[1,3,5,7,9,11 {Interrupted}</span></p>
<p class="para">In the first example the enumeration stops at 10 because 11 isn’t even. In the second example we quickly interrupted the evaluation of an infinite list.</p>
<p class="para">As a matter of fact, enumerations are not restricted to integers, but to members of yet another type class <span class="font">Enum</span>. We won’t elaborate more on this class, except to say that <span class="font">Char</span> is also a member:</p>
<p class="code6"><span class="font">ghci&gt; ['a'..'z']</span></p>
<p class="code6"><span class="font">"abcdefghijklmnopqrstuvwxyz"</span></p>
<h3 class="h" id="text/part0008.html.head4-3">4.3 List comprehensions</h3>
<p class="para"><a id="text/part0008.html.page_66" class="calibre3"></a>Haskell provides another useful and very attractive piece of notation, called <i class="calibre1">list comprehensions</i>, for constructing lists out of other lists. We illustrate with a few examples:</p>
<p class="code6"><span class="font">ghci&gt; [x*x | x &lt;- [1..5]]</span></p>
<p class="code6"><span class="font">[1,4,9,16,25]</span></p>
<p class="code6"><span class="font">ghci&gt; [x*x | x &lt;- [1..5], isPrime x]</span></p>
<p class="code6"><span class="font">[4,9,25]</span></p>
<p class="code6"><span class="font">ghci&gt; [(i,j) | i &lt;- [1..5], even i, j &lt;- [i..5]]</span></p>
<p class="code6"><span class="font">[(2,2),(2,3),(2,4),(2,5),(4,4),(4,5)]</span></p>
<p class="code6"><span class="font">ghci&gt; [x | xs &lt;- [[(3,4)],[(5,4),(3,2)]], (3,x) &lt;- xs]</span></p>
<p class="code6"><span class="font">[4,2]</span></p>
<p class="para">Here is another example. Suppose we wanted to generate all Pythagorean triads in a given range. These are triples of numbers (<i class="calibre1">x</i>, <i class="calibre1">y</i>, <i class="calibre1">z</i>) such that <i class="calibre1">x</i><sup class="calibre8">2</sup> + <i class="calibre1">y</i><sup class="calibre8">2</sup> = <i class="calibre1">z</i><sup class="calibre8">2</sup> and 1 ≤ <i class="calibre1">x</i>, <i class="calibre1">y</i>, <i class="calibre1">z</i> ≤ <i class="calibre1">n</i> for some given <i class="calibre1">n</i>. We can define</p>
<div class="space1">
<p class="code"><span class="font">triads :: Int -&gt; [(Int,Int,Int)]</span></p>
<p class="code"><span class="font">triads n = [(x,y,z) | x &lt;- [1..n], y &lt;- [1..n], z &lt;- [1..n], x*x+y*y==z*z]</span></p>
</div>
<p class="para">Hence</p>
<p class="code6"><span class="font">ghci&gt; triads 15</span></p>
<p class="code6"><span class="font">[(3,4,5),(4,3,5),(5,12,13),(6,8,10), (8,6,10),(9,12,15),(12,5,13),(12,9,15)]</span></p>
<p class="para">That’s probably not what we want: each essentially distinct triad is generated in two different ways. Moreover, the list contains redundant triads consisting of multiples of basic triads. To improve the definition of <span class="font">triad</span> we can restrict <i class="calibre1">x</i> and <i class="calibre1">y</i> so that <i class="calibre1">x</i> &lt; <i class="calibre1">y</i> and <i class="calibre1">x</i> and <i class="calibre1">y</i> are coprime, meaning they have no divisors in common. As mathematicians we know that 2<i class="calibre1">x</i><sup class="calibre8">2</sup> cannot be the square of an integer, so the first restriction is valid. The divisors of a number can be computed by</p>
<p class="code"><span class="font">divisors x = [d | d &lt;- [2..x-1], x `mod` d == 0]</span></p>
<p class="para">Hence</p>
<p class="code"><span class="font">coprime x y = disjoint (divisors x) (divisors y)</span></p>
<p class="para">We will leave the definition of <span class="font">disjoint</span> as an exercise.</p>
<p class="para"><a id="text/part0008.html.page_67" class="calibre3"></a>That means we can define</p>
<p class="code"><span class="font">triads n = [(x,y,z) | x &lt;- [1..n], y &lt;- [x+1..n],</span></p>
<p class="code16"><span class="space"></span><span class="font">coprime x y,</span></p>
<p class="code16"><span class="space"></span><span class="font">z &lt;- [y+1..n], x*x+y*y==z*z]</span></p>
<p class="para">This definition is better than before, but let us try to make it a little faster, mainly to illustrate an important point. Since 2<i class="calibre1">x</i><sup class="calibre8">2</sup> &lt; <i class="calibre1">x</i><sup class="calibre8">2</sup> + <i class="calibre1">y</i><sup class="calibre8">2</sup> = <i class="calibre1">z</i><sup class="calibre8">2</sup> ≤ <i class="calibre1">n</i><sup class="calibre8">2</sup> we see that <img src="data:image/jpeg;base64,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" alt="image" class="calibre2"> So <img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEBLAEsAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAaAF8DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6porA8ceJU8JaDJrFzaS3FlA6C5aJgDDGzBTJg9QM5OOwNXdF1GfUhcySafPaW6yYt5JXU/aI8A+YFBJUZzw2Dx0oA0qK4yTxddaxq17pHhO0he7s5DFc3OosYY4iCMlYv9ZKOcAgKh7Ma3dB0u70/wA+XUdWutSup9u8yKscSYzxHGvCjnnJJPc0AabTRpKkTyIskmSiFgC2OuB3xT65TXgD8QfCZIGRDe4P/AY6ydd+J1ppP/CVBtJvZz4dMf2jY8eHVlD5UluysvBwSTgDg0Aeg0yGWOeJZIJEkjboyMCD+IrF8ZalNYeGriSyyt/cBba0UnB86UhE/Itk+wNMhvtE8JwaFoM15FbyTBbOyjfhpWVfbudp5PU+9AG+7rGjO7BUUZLE4AHqa5Cx8V6vqdrHe6Z4Vu57Ccb7eaS7hiMsZ+6+0nIDDkZ5wRU3jt3v0sfDduWEmruUuGU4MdomDM2e2QVjHvIPSue+J3ha0fw/rWtajqmpW01hbM+l/YbqS3WzKp8gREIDuz4HzA5yqjGKAO606/nk043Or2g0twxDRyzo4AzgHcpxzTNL8P6ZpWoX19YWvk3V82+5kDsTKw6E5OM9vpxXJ+LP7Qk+DK/2+q/2qbK1N4ABjzsx7/b72a9AoA43x5pGreKrDVfDiwRWukXdkym/8/LySMGHleXtyoB2ktk5GQB3G14Q/tf/AIR2xHiKKGHU1iRZkhk8wbgoBO7Azkgn2zj3rYooA4TxNrPgXUrow6xfWq31o5RZkLxz27g87ZFwy4PocVoeBNQhvBew2niT+3baApsMkQE0IIPDuAA+ccHAPXJNdXRQBy2ugn4geFcDpDe/+gx1xVz4F1xvCd7C1taXGp6z4kTU9UiafCm2WcMsYfbyAkcQxju1L+0Uxh0nRriEmO4S4kVJVOGUGM5APUZwPyr0fwgzP4U0ZnYszWcJJJySdgoAy7sPqnjXS7OUq0ekwG/uNo+QzuDHEMHkYHnN/wB80/4keHH8T+EL6xs3EOpptubCfgGK5ibfE2e3zAA+xNaWlQxJrGtSpGiySTR73CgFsRJjJ74rVoA4f4ay3fiGF/F2r2M1heX8KQQWk6bXtoU+8CDyC0hdv93Z6VB4vt/Gd14khl0rSNDvdItAslul7fyRM0/XzGVY2B29FB6HLdcY7+igDhvHI1E/Cy9OtfZv7RMcbTrbZMSt5qkqpPJA6ZOM4zgV019Pqya7pkVlZ20ukyCX7bPJMVkhIUeXsXHzZOQeRgV498YZHk+JuiWkjs1rIltvhY5R/wB+eq9DXulAH//ZAAA=" alt="image" class="calibre2"> That suggests we can write</p>
<p class="code6"><span class="font">triads n = [(x,y,z) | x &lt;- [1..m], y &lt;- [x+1..n],</span></p>
<p class="code17"><span class="font">coprime x y,</span></p>
<p class="code17"><span class="font">z &lt;- [y+1..n], x*x+y*y==z*z]</span></p>
<p class="code1"><span class="font">where m = floor (n / sqrt 2)</span></p>
<p class="para">But the expression for <span class="font">m</span> is incorrect: <span class="font">n</span> is an <span class="font">Int</span> and we cannot divide integers. We need an explicit conversion function, and the one to use is <span class="font">fromIntegral</span> (not <span class="font">fromInteger</span> because <span class="font">n</span> is an <span class="font">Int</span> not an <span class="font">Integer</span>). We need to replace the definition of <span class="font">m</span> by <span class="font">m = floor (fromIntegral n / sqrt 2)</span>. Once again we have to be careful about what kinds of number we are dealing with and aware of the available conversion functions between them.</p>
<p class="para">List comprehensions can be used to define some common functions on lists. For example,</p>
<div class="space1">
<p class="code"><span class="font">map f xs</span><span class="space5"></span>&nbsp;&nbsp;<span class="font">= [f x | x &lt;- xs]</span></p>
<p class="code"><span class="font">filter p xs</span><span class="space"></span><span class="font">= [x | x &lt;- xs, p x]</span></p>
<p class="code"><span class="font">concat xss</span><span class="space"></span>&nbsp;&nbsp;<span class="font">= [x | xs &lt;- xss, x &lt;- xs]</span></p>
</div>
<p class="para">Actually, in Haskell it is the other way around: list comprehensions are translated into equivalent definitions in terms of <span class="font">map</span>, and <span class="font">concat</span>. The translation rules are:</p>
<div class="space1">
<p class="code"><span class="font">[e |True]</span><span class="space8"></span><span class="font">= [e]</span></p>
<p class="code"><span class="font">[e | q]</span><span class="space3"></span><span class="font">= [e | q, True]</span></p>
<p class="code"><span class="font">[e | b, Q]</span><span class="space2"></span><span class="font">= if b then [e | Q] else []</span></p>
<p class="code"><span class="font">[e | p &lt;- xs, Q] = let ok p = [e | Q]</span></p>
<p class="code16"><span class="font">ok _ = []</span></p>
<p class="code13"><span class="font">in concat (map ok xs)</span></p>
</div>
<p class="para">The definition of <span class="font">ok</span> in the fourth rule uses a <i class="calibre1">don’t care</i> pattern, also called a <i class="calibre1">wild card</i>. The <span class="font">p</span> in the fourth rule is a pattern, and the definition of <span class="font">ok</span> says that the empty list is returned on any argument that doesn’t match the pattern <span class="font">p</span>.</p>
<p class="para">Another useful rule is</p>
<p class="code"><a id="text/part0008.html.page_68" class="calibre3"></a><span class="font">[e | Q1, Q2] = concat [[e | Q2] | Q1]</span></p>
<h3 class="h" id="text/part0008.html.head4-4">4.4 Some basic operations</h3>
<p class="para">We can define functions over lists by pattern matching. For example,</p>
<div class="space1">
<p class="code"><span class="font">null :: [a] -&gt; Bool</span></p>
<p class="code"><span class="font">null []</span><span class="space4"></span><span class="font">= True</span></p>
<p class="code"><span class="font">null (x:xs) = False</span></p>
</div>
<p class="para">The patterns <span class="font">[]</span> and <span class="font">x:xs</span> are disjoint and exhaustive, so we can write the two equations for <span class="font">null</span> in either order. The function <span class="font">null</span> is strict because Haskell has to know which equation to apply and that requires evaluation of the argument, at least to the extent of discovering whether it is the empty list or not. (A question: why not simply define <span class="font">null = (==[])</span>?) We could also have written</p>
<div class="space1">
<p class="code"><span class="font">null [] = True</span></p>
<p class="code"><span class="font">null _</span><span class="space"></span><span class="font">= False</span></p>
<p class="para">This definition uses a don’t care pattern.</p>
<p class="para">Here are two other definitions using pattern matching:</p>
<div class="space1">
<p class="code"><span class="font">head :: [a] -&gt; a</span></p>
<p class="code"><span class="font">head (x:xs) = x</span></p>
<p class="para1"></p>
<p class="code"><span class="font">tail :: [a] -&gt; [a]</span></p>
<p class="code"><span class="font">tail (x:xs) = xs</span></p>
</div>
<p class="para">There is no equation for the pattern <span class="font">[]</span>, so Haskell reports an error if we try to evaluate <span class="font">head []</span> or <span class="font">tail []</span>.</p>
<p class="para">We can use <span class="font">[x]</span> as shorthand for <span class="font">x:[]</span> in a pattern:</p>
<div class="space1">
<p class="code"><span class="font">last :: [a] -&gt; a</span></p>
<p class="code"><span class="font">last [x]</span><span class="space4"></span><span class="font">&nbsp;= x</span></p>
<p class="code"><span class="font">last (x:y:ys) = last (y:ys)</span></p>
</div>
<p class="para">The first equation has a pattern that matches a singleton list; the second has a pattern that matches a list that contains at least two elements. The standard prelude definition of <span class="font">last</span> is slightly different:</p>
<div class="space1">
<p class="code"><span class="font">last [x]</span>&nbsp;<span class="space5"></span><span class="font">= x</span></p>
<p class="code"><span class="font">last (_:xs) = last xs</span></p>
</div>
<p class="para"><a id="text/part0008.html.page_69" class="calibre3"></a>This definition uses a don’t care pattern. The two equations have to be written in this order because <span class="font">x:[]</span> matches both patterns.</p>
<h3 class="h" id="text/part0008.html.head4-5">4.5 Concatenation</h3>
<p class="para">Here is the definition of <span class="font">(++)</span>, the concatenation operation:</p>
<div class="space1">
<p class="code"><span class="font">(++) :: [a] -&gt; [a] -&gt; [a]</span></p>
<p class="code"><span class="font">[] ++ ys</span><span class="space4"></span><span class="font">= ys</span></p>
<p class="code"><span class="font">(x:xs) ++ ys = x:(xs ++ ys)</span></p>
</div>
<p class="para">The definition uses pattern matching on the first argument but not on the second. The second equation for <span class="font">(++)</span> is very succinct and requires some thought, but once you have got it, you have understood a lot about how lists work in functional programming. Here is a simple evaluation sequence:</p>
<div class="space1">
<p class="code1"><span class="font">[1,2] ++ [3,4,5]</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{notation}</p>
<p class="code1"><span class="font">(1:(2:[])) ++ (3:(4:(5:[])))</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{second equation for <span class="font">++</span>}</p>
<p class="code1"><span class="font">1:((2:[]) ++ (3:(4:(5:[]))))</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{and again}</p>
<p class="code1"><span class="font">1:(2:([] ++ (3:(4:(5:[])))))</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{first equation for <span class="font">++</span>}</p>
<p class="code1"><span class="font">1:(2:(3:(4:(5:[]))))</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{notation}</p>
<p class="code1"><span class="font">[1,2,3,4,5]</span></p>
</div>
<p class="para">As this example suggests, the cost of evaluating <span class="font">xs++ys</span> is proportional to the length of <span class="font">xs</span>, where</p>
<div class="space1">
<p class="code"><span class="font">length :: [a] -&gt; Int</span></p>
<p class="code"><span class="font">length []</span><span class="space4"></span><span class="font">= 0</span></p>
<p class="code"><span class="font">length (x:xs) = 1 + length xs</span></p>
</div>
<p class="para">Note also that</p>
<div class="space1">
<p class="code"><span class="font">undefined ++ [1,2] = undefined</span></p>
<p class="code"><span class="font">[1,2] ++ undefined = 1:2:undefined</span></p>
</div>
<p class="para"><a id="text/part0008.html.page_70" class="calibre3"></a>We know nothing about the first list, but we do know that the second list begins with <span class="font">1</span> followed by <span class="font">2</span>.</p>
<p class="para">Concatenation is an associative operation. Thus</p>
<p class="code"><span class="font">(xs ++ ys) ++ zs = xs ++ (ys ++ zs)</span></p>
<p class="para">for <i class="calibre1">all</i> lists <span class="font">xs</span>, <span class="font">ys</span> and <span class="font">zs</span>. We will see how to prove assertions like these in <a href="#text/part0010.html.9H5K0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 6</a>.</p>
<h3 class="h" id="text/part0008.html.head4-6">4.6 <span class="font1">concat</span>, <span class="font1">map</span> and <span class="font1">filter</span></h3>
<p class="para">Three very useful list operations that we have met already are <span class="font">concat</span>, <span class="font">map</span> and <span class="font">filter</span>. Here are their definitions using pattern matching:</p>
<div class="space1">
<p class="code"><span class="font">concat :: [[a]] -&gt; [a]</span></p>
<p class="code"><span class="font">concat []</span><span class="space2"></span><span class="font">= []</span></p>
<p class="code"><span class="font">concat (xs:xss) = xs ++ concat xss</span></p>
<p class="para1"></p>
<p class="code"><span class="font">map :: (a -&gt; b) -&gt; [a] -&gt; [b]</span></p>
<p class="code"><span class="font">map f []</span><span class="space4"></span><span class="font">= []</span></p>
<p class="code"><span class="font">map f (x:xs) = f x:map f xs</span></p>
<p class="para1"></p>
<p class="code"><span class="font">filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</span></p>
<p class="code"><span class="font">filter p</span><span class="space4"></span><span class="font">[] = []</span></p>
<p class="code"><span class="font">filter p (x:xs) = if p x then x:filter p xs</span></p>
<p class="code5"><span class="font">else filter p xs</span></p>
</div>
<p class="para">There is a common theme underlying these definitions that we will identify and exploit in <a href="#text/part0010.html.9H5K0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 6</a>. An alternative definition of <span class="font">filter</span> is</p>
<div class="space1">
<p class="code"><span class="font">filter p = concat . map (test p)</span></p>
<p class="code"><span class="font">test p x = if p x then [x] else []</span></p>
</div>
<p class="para">With this definition, <span class="font">filter p</span> is implemented by converting each element of the list into a singleton list if it satisfies <span class="font">p</span>, and the empty list otherwise. The results are then concatenated.</p>
<p class="para">Two basic facts about <span class="font">map</span> are that</p>
<div class="space1">
<p class="code"><span class="font">map id</span><span class="space4"></span><span class="font">&nbsp;= id</span></p>
<p class="code"><span class="font">map (f . g) = map f . map g</span></p>
</div>
<p class="para"><a id="text/part0008.html.page_71" class="calibre3"></a>The first equation says that applying the identity function to each element of a list leaves the list unchanged. The two occurrence of <span class="font">id</span> in this law have different types: on the left it is <span class="font">a -&gt; a</span> and on the right it is <span class="font">[a] -&gt; [a]</span>. The second equation says that applying <span class="font">g</span> to every element of a list, and then applying <span class="font">f</span> to every element of the result, gives the same list as applying <span class="font">f . g</span> to every element. Read from right to left, the equation says that two traversals of a list can be replaced by one, with a corresponding gain in efficiency.</p>
<p class="para">The two facts have a name: they are called the <i class="calibre1">functor</i> laws of <span class="font">map</span>. The name is borrowed from a branch of mathematics called Category Theory. In fact, Haskell provides a type class <span class="font">Functor</span>, whose definition is</p>
<div class="space1">
<p class="code"><span class="font">class Functor f where</span></p>
<p class="code2"><span class="font">fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span></p>
</div>
<p class="para">The method <span class="font">fmap</span> is expected to satisfy exactly the same laws as <span class="font">map</span>. The reason for this type class is that the idea of mapping a function over a list can be generalised to one of mapping a function over an arbitrary data structure, such as trees of various kinds. For example, consider the type</p>
<p class="code"><span class="font">data Tree a = Tip a | Fork (Tree a) (Tree a)</span></p>
<p class="para">of binary trees with labels in their tips. Tree-structured data arise in a number of places, for example with the syntax of expressions of various kinds. We can define a mapping function over trees, but rather than calling it <span class="font">mapTree</span> we can call it <span class="font">fmap</span> by making trees a member of the <span class="font">Functor</span> class:</p>
<div class="space1">
<p class="code"><span class="font">instance Functor Tree where</span></p>
<p class="code2"><span class="font">fmap f (Tip x) = Tip (f x)</span></p>
<p class="code2"><span class="font">fmap f (Fork u v) = Fork (fmap f u) (fmap f v)</span></p>
</div>
<p class="para">In fact <span class="font">map</span> is just a synonym for the instance <span class="font">fmap</span> for lists:</p>
<p class="code6"><span class="font">ghci&gt; fmap (+1) [2,3,4]</span></p>
<p class="code6"><span class="font">[3,4,5]</span></p>
<p class="para">We mention the <span class="font">Functor</span> type class here primarily to show that if ever you think some function on lists can be usefully generalised to other kinds of data structure, the chances are good that the designers of Haskell have already spotted it and introduced an appropriate type class. As we will see later on, and especially in <a href="#text/part0016.html.F8900-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 12</a>, the functor laws of <span class="font">map</span> appear in many calculations.</p>
<p class="para">There is another group of laws that involve <span class="font">map</span>, all of which have a common theme. Consider the equations</p>
<a id="text/part0008.html.page_72" class="calibre3"></a>
<div class="space1">
<p class="code"><span class="font">f . head</span><span class="space2"></span><span class="font">= head . map f</span></p>
<p class="code"><span class="font">map f . tail</span><span class="space5"></span><span class="font">= tail . map f</span></p>
<p class="code"><span class="font">map f . concat = concat . map (map f)</span></p>
</div>
<p class="para">The first equation holds only if <span class="font">f</span> is a strict function, but the others hold for arbitrary <span class="font">f</span>. If we apply both sides of the equation to the empty list, we get</p>
<p class="code"><span class="font">f (head []) = head (map f []) = head []</span></p>
<p class="para">Since the head of an empty list is undefined, we require <span class="font">f</span> to be strict to make the equation true.</p>
<p class="para">Each of the laws has a simple interpretation. In each case you can apply the operation (<span class="font">head</span>, <span class="font">tail</span>, and so on) to a list and then change each element, or you can change each element first and then apply the operation. The common theme lies in the types of the operations involved:</p>
<div class="space1">
<p class="code"><span class="font">head</span><span class="space5"></span><span class="font">:: [a] -&gt; a</span></p>
<p class="code"><span class="font">tail</span><span class="space5"></span><span class="font">:: [a] -&gt; [a]</span></p>
<p class="code"><span class="font">concat :: [[a]] -&gt; [a]</span></p>
<p class="para">The point about the operations is that they do not depend in any way on the nature of the list elements; they are simply functions that shuffle, discard or extract elements from lists. That is why they have polymorphic types. And functions with polymorphic types all satisfy some law that says you can change values before or after applying the function. In mathematics such functions are called <i class="calibre1">natural transformations</i> and the associated laws, <i class="calibre1">naturality</i> laws.</p>
<p class="para">As another example, since <span class="font">reverse :: [a] -&gt; [a]</span> we would expect that</p>
<p class="code"><span class="font">map f . reverse = reverse . map f</span></p>
<p class="para">Indeed this is the case. Of course, this naturality law still has to be proved. Another law is</p>
<p class="code"><span class="font">concat . map concat = concat . concat</span></p>
<p class="para">The two sides assert that two ways of concatenating a list of lists of lists (either do the inner concatenations first, or do the outer concatenations first) give the same result.</p>
<p class="para">Finally, here is just one property of <span class="font">filter</span>:</p>
<p class="code"><span class="font">filter p . map f = map f . filter (p . f)</span></p>
<p class="para"><a id="text/part0008.html.page_73" class="calibre3"></a>We can prove this law by simple equational reasoning:</p>
<div class="space1">
<p class="code1"><span class="font">filter p . map f</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{second definition of <span class="font">filter</span>}</p>
<p class="code1"><span class="font">concat . map (test p) . map f</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{functor property of <span class="font">map</span>}</p>
<p class="code1"><span class="font">concat . map (test p . f)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{since <span class="font">test p . f = map f . test (p . f)</span>}</p>
<p class="code1"><span class="font">concat . map (map f . test (p . f))</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{functor property of <span class="font">map</span>}</p>
<p class="code1"><span class="font">concat . map (map f) . map (test (p . f))</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{naturality of <span class="font">concat</span>}</p>
<p class="code1"><span class="font">map f . concat . map (test (p . f))</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{second definition of <span class="font">filter</span>}</p>
<p class="code1"><span class="font">map f . filter (p . f)</span></p>
</div>
<p class="para">Laws like those above are not just of academic interest, but are deployed in finding new and better ways of expressing definitions. That’s why functional programming is the best thing since sliced bread.</p>
<h3 class="h" id="text/part0008.html.head4-7">4.7 <span class="font1">zip</span> and <span class="font1">zipWith</span></h3>
<p class="para">Finally, to complete a simple toolbox of useful operations, we consider the functions <span class="font">zip</span> and <span class="font">zipWith</span>. The definitions in the standard prelude are:</p>
<div class="space1">
<p class="code"><span class="font">zip :: [a] -&gt; [b] -&gt; [(a,b)]</span></p>
<p class="code"><span class="font">zip (x:xs) (y:ys) = (x,y): zip xs ys</span></p>
<p class="code"><span class="font">zip _ _</span><span class="space3"></span><span class="font">&nbsp;= []</span></p>
<p class="para1"></p>
<p class="code"><span class="font">zipWith :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</span></p>
<p class="code"><span class="font">zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys</span></p>
<p class="code"><span class="font">zipWith f _ _</span><span class="space3"></span><span class="font">&nbsp;= []</span></p>
</div>
<p class="para">A caring programmer (one who doesn’t like ‘don’t care’ patterns) would have written</p>
<div class="space1">
<p class="code"><span class="font">zip [] ys</span><span class="space2"></span><span class="font">&nbsp;&nbsp;= []</span></p>
<p class="code"><span class="font">zip (x:xs) []</span><span class="space4"></span><span class="font">= []</span></p>
<p class="code"><a id="text/part0008.html.page_74" class="calibre3"></a><span class="font">zip (x:xs) (y:ys) = (x,y):zip xs ys</span></p>
</div>
<p class="para">Both definitions use pattern matching on both arguments. You have to know that pattern matching is applied from top to bottom and from left to right. Thus</p>
<div class="space1">
<p class="code"><span class="font">zip [] undefined = []</span></p>
<p class="code"><span class="font">zip undefined [] = undefined</span></p>
</div>
<p class="para">The definition of <span class="font">zip</span> can be given another way:</p>
<p class="code"><span class="font">zip = zipWith (,)</span></p>
<p class="para">The operation <span class="font">(,)</span> is a constructor for pairs: <span class="font">(,) a b = (a,b)</span>.</p>
<p class="para">Here is one example of the use of <span class="font">zipWith</span>. Suppose we want to determine whether a list is in nondecreasing order. A direct definition would have:</p>
<div class="space1">
<p class="code"><span class="font">nondec :: (Ord a) =&gt; [a] -&gt; Bool</span></p>
<p class="code"><span class="font">nondec []</span><span class="space2"></span><span class="font">= True</span></p>
<p class="code"><span class="font">nondec [x]</span><span class="space4"></span><span class="font">&nbsp;= True</span></p>
<p class="code"><span class="font">nondec (x:y:xs) = (x &lt;= y) &amp;&amp; nondec (y:xs)</span></p>
</div>
<p class="para">But another, equivalent and shorter definition is</p>
<p class="code"><span class="font">nondec xs = and (zipWith (&lt;=) xs (tail xs))</span></p>
<p class="para">The function <span class="font">and</span> is yet another useful function in the standard prelude. It takes a list of booleans and returns <span class="font">True</span> if all the elements are <span class="font">True</span>, and <span class="font">False</span> otherwise:</p>
<div class="space1">
<p class="code"><span class="font">and :: [Bool] -&gt; Bool</span></p>
<p class="code"><span class="font">and []</span><span class="space4"></span><span class="font">= True</span></p>
<p class="code"><span class="font">and (x:xs) = x &amp;&amp; and xs</span></p>
</div>
<p class="para">One final example. Consider the task of building a function <span class="font">position</span> that takes a value <span class="font">x</span> and a finite list <span class="font">xs</span> and returns the first position in <span class="font">xs</span> (counting positions from 0) at which <span class="font">x</span> occurs. If <span class="font">x</span> does not occur in the list, then −1 is returned. We can define</p>
<div class="space1">
<p class="code"><span class="font">position :: (Eq a) =&gt; a -&gt; [a] -&gt; Int</span></p>
<p class="code"><span class="font">position x xs</span></p>
<p class="code2"><span class="font">= head ([j | (j,y) &lt;- zip [0..] xs, y==x] ++ [-1])</span></p>
</div>
<p class="para">The expression <span class="font">zip [0..] xs</span> pairs each element of <span class="font">xs</span> with its position in <span class="font">xs</span>. Although the first argument of <span class="font">zip</span> is an infinite list, the result is a finite list whenever <span class="font">xs</span> is. Observe that the problem is solved by first computing the list of <i class="calibre1">all</i> positions at which <span class="font">x</span> is found, and then taking the first element. Under lazy evaluation it is not necessary to construct the value of every element of the list in order <a id="text/part0008.html.page_75" class="calibre3"></a>to calculate the head of the list, so there is no great loss of efficiency in solving the problem this way. And there is a great deal of simplicity in defining one search result in terms of all search results.</p>
<h3 class="h" id="text/part0008.html.head4-8">4.8 Common words, completed</h3>
<p class="para">Let’s now return to <a href="#text/part0005.html.head1-3" class="calibre3">Section 1.3</a> and complete the definition of <span class="font">commonWords</span>. Recall that we finished with</p>
<div class="space1">
<p class="code"><span class="font">commonWords :: Int -&gt; [Char] -&gt; [Char]</span></p>
<p class="code"><span class="font">commonWords n = concat . map showRun . take n .</span></p>
<p class="code4"><span class="font">sortRuns . countRuns . sortWords .</span></p>
<p class="code4"><span class="font">words . map toLower</span></p>
</div>
<p class="para">The only functions we have still to give definitions for are</p>
<p class="code"><span class="font">showRun countRuns sortRuns sortWords</span></p>
<p class="para">All the others, including <span class="font">words</span>, are provided in the standard Haskell libraries.</p>
<p class="para">The first one is easy:</p>
<div class="space1">
<p class="code"><span class="font">showRun :: (Int,Word) -&gt; [Char]</span></p>
<p class="code"><span class="font">showRun (n,w) = w ++ ": " ++ show n ++ "\n"</span></p>
</div>
<p class="para">The second one can be defined by</p>
<div class="space1">
<p class="code"><span class="font">countRuns :: [Word] -&gt; [(Int,Word)]</span></p>
<p class="code"><span class="font">countRuns []</span><span class="space4"></span><span class="font">= []</span></p>
<p class="code"><span class="font">countRuns (w:ws) = (1+length us,w):countRuns vs</span></p>
<p class="code13"><span class="font">where (us,vs) = span (==w) ws</span></p>
</div>
<p class="para">The prelude function <span class="font">span p</span> splits a list into two, the first being the longest prefix of the list all of whose elements satisfy the test <span class="font">p</span>, and the second being the suffix that remains. Here is the definition:</p>
<p class="code"><span class="font">span :: (a -&gt; Bool) -&gt; [a] -&gt; ([a],[a])</span></p>
<p class="code"><span class="font">span p []</span><span class="space4"></span><span class="font">= ([],[])</span></p>
<p class="code"><span class="font">span p (x:xs) = if p x then (x:ys,zs)</span></p>
<p class="code4"><span class="font">else ([],x:xs)</span></p>
<p class="code4"><span class="font">where (ys,zs) = span p xs</span></p>
</div>
<p class="para">That leaves <span class="font">sortRuns</span> and <span class="font">sortWords</span>. We can import the function <span class="font">sort</span> from <span class="font">Data.List</span> by the command</p>
<p class="code"><a id="text/part0008.html.page_76" class="calibre3"></a><span class="font">import Data.List (sort)</span></p>
<p class="para">Since <span class="font">sort :: (Ord a) =&gt; [a] -&gt; [a]</span> we can then define</p>
<div class="space1">
<p class="code"><span class="font">sortWords :: [Word] -&gt; [Word]</span></p>
<p class="code"><span class="font">sortWords = sort</span></p>
<p class="para1"></p>
<p class="code"><span class="font">sortRuns :: [(Int,Word)] -&gt; [(Int,Word)]</span></p>
<p class="code"><span class="font">sortRuns = reverse . sort</span></p>
</div>
<p class="para">To understand the second definition you have to know that Haskell automatically defines the comparison operation <span class="font">(&lt;=)</span> on pairs by</p>
<p class="code"><span class="font">(x1,y1) &lt;= (x2,y2) = (x1 &lt; x2) || (x1 == x2 &amp;&amp; y1 &lt;= y2)</span></p>
<p class="para">You also have to know that <span class="font">sort</span> sorts into ascending order. Since we want the codes in descending order of count, we just sort into ascending order and reverse the result. That, by the way, is why we defined frequency counts by having the count before the word rather than afterwards.</p>
<p class="para">Instead of relying on the library function for sorting, let us end by programming a sorting function ourselves. One good way to sort is to use a <i class="calibre1">divide and conquer</i> strategy: if the list has length at most one then it is already sorted; otherwise we can divide the list into two equal halves, sort each half by using the sorting algorithm recursively, and then merge the two sorted halves together. That leads to</p>
<div class="space1">
<p class="code"><span class="font">sort :: (Ord a) =&gt; [a] -&gt; [a]</span></p>
<p class="code"><span class="font">sort []</span><span class="space"></span><span class="font">= []</span></p>
<p class="code"><span class="font">sort [x] = [x]</span></p>
<p class="code"><span class="font">sort xs</span><span class="space"></span><span class="font">= merge (sort ys) (sort zs)</span></p>
<p class="code10"><span class="font">&nbsp;where (ys,zs) = halve xs</span></p>
<p class="para1"></p>
<p class="code"><span class="font">halve xs = (take n xs, drop n xs)</span></p>
<p class="code12"><span class="font">where n = length xs `div` 2</span></p>
</div>
<p class="para">That leaves us with the definition of <span class="font">merge</span>, which merges two sorted lists together into one sorted list:</p>
<div class="space1">
<p class="code"><span class="font">merge :: (Ord a) =&gt; [a] -&gt; [a] -&gt; [a]</span></p>
<p class="code"><span class="font">merge [] ys = ys</span></p>
<p class="code"><span class="font">merge xs [] = xs</span></p>
<p class="code"><span class="font">merge (x:xs) (y:ys)</span></p>
<p class="code2"><span class="font">| x &lt;= y</span><span class="space1a"></span><span class="font">= x:merge xs (y:ys)</span></p>
<p class="code2"><span class="font">| otherwise = y:merge (x:xs) ys</span></p>
</div>
<p class="para"><a id="text/part0008.html.page_77" class="calibre3"></a>In fact, many Haskell programmers wouldn’t write the last clause of <span class="font">merge</span> in quite this way. Instead they would write</p>
<div class="space1">
<p class="code"><span class="font">merge xs'@(x:xs) ys'@(y:ys)</span></p>
<p class="code2"><span class="font">| x &lt;= y</span><span class="space4"></span><span class="font">= x:merge xs ys'</span></p>
<p class="code2"><span class="font">| otherwise</span><span class="space-toc1"></span><span class="font">= y:merge xs' ys</span></p>
</div>
<p class="para">This definition uses an <i class="calibre1">as-pattern</i>. You can see the point: rather than deconstructing a list and then reconstructing it again (a cheap but not free operation), it is better to reuse the value that we matched with. True, but it does obscure a simple mathematical equation, and we will use such patterns only very sparingly in this book.</p>
<p class="para">Both <span class="font">sort</span> and <span class="font">merge</span> are defined recursively and it is worthwhile pointing out why the two recursions terminate. In the case of <span class="font">merge</span> you have to see that one or other of the two arguments of <span class="font">merge</span> decreases in size at each recursive call. Hence one of the base cases will eventually be reached. In the case of <span class="font">sort</span> the critical observation is that if <span class="font">xs</span> has length at least two, then both <span class="font">ys</span> and <span class="font">zs</span> have length strictly less than <span class="font">xs</span>, and the same argument applies. But see what happens if we had omitted the clause <span class="font">sort [x] = [x]</span>. Since 1 div 2 = 0 we would have,</p>
<p class="code"><span class="font">sort [x] = merge (sort []) (sort [x])</span></p>
<p class="para">That means evaluation of <span class="font">sort [x]</span> requires evaluation of <span class="font">sort [x]</span>, and the whole definition of <span class="font">sort</span> spins off into an infinite loop for nonempty arguments. Checking that you have all the necessary base cases is one of the most important parts of constructing a recursive function.</p>
<h3 class="h" id="text/part0008.html.head4-9">4.9 Exercises</h3>
<p class="theorem"><b class="calibre7">Exercise A</b></p>
<p class="para">Which of the following equations are true for all <span class="font">xs</span> and which are false?</p>
<div class="space1">
<p class="code"><span class="font">[]:xs = xs</span></p>
<p class="code"><span class="font">[]:xs = [[],xs]</span></p>
<p class="code"><span class="font">xs:[] = xs</span></p>
<p class="code"><span class="font">xs:[] = [xs]</span></p>
<p class="code"><span class="font">xs:xs = [xs,xs]</span></p>
<p class="code"><span class="font">[[]] ++ xs = xs</span></p>
<p class="code"><span class="font">[[]] ++ xs = [[],xs]</span></p>
<p class="code"><span class="font">[[]] ++ [xs] = [[],xs]</span></p>
<p class="code"><a id="text/part0008.html.page_78" class="calibre3"></a><span class="font">[xs] ++ [] = [xs]</span></p>
</div>
<p class="para">By the way, why didn’t we define <span class="font">null = (==[])</span>?</p>
<p class="theorem"><b class="calibre7">Exercise B</b></p>
<p class="para">You want to produce an infinite list of all distinct pairs (<i class="calibre1">x</i>, <i class="calibre1">y</i>) of natural numbers. It doesn’t matter in which order the pairs are enumerated, as long as they all are there. Say whether or not the definition</p>
<p class="code"><span class="font">allPairs = [(x,y) | x &lt;- [0..], y &lt;- [0..]]</span></p>
<p class="para">does the job. If you think it doesn’t, can you give a version that does?</p>
<p class="theorem"><b class="calibre7">Exercise C</b></p>
<p class="para">Give a definition of the function</p>
<p class="code"><span class="font">disjoint :: (Ord a) =&gt; [a] -&gt; [a] -&gt; Bool</span></p>
<p class="para">that takes two lists in ascending order, and determines whether or not they have an element in common.</p>
<p class="theorem"><b class="calibre7">Exercise D</b></p>
<p class="para">Under what conditions do the following two list comprehensions deliver the same result?</p>
<div class="space1">
<p class="code"><span class="font">[e | x &lt;- xs, p x, y &lt;- ys]</span></p>
<p class="code"><span class="font">[e | x &lt;- xs, y &lt;- ys, p x]</span></p>
</div>
<p class="para">Compare the costs of evaluating the two expressions.</p>
<p class="theorem"><b class="calibre7">Exercise E</b></p>
<p class="para">When the great Indian mathematician Srinivasan Ramanujan was ill in a London hospital, he was visited by the English mathematician G.H. Hardy. Trying to find a subject of conversation, Hardy remarked that he had arrived in a taxi with the number 1729, a rather boring number it seemed to him. Not at all, Ramanujan instantly replied, it is the first number that can be expressed as two cubes in essentially different ways: 1<sup class="calibre8">3</sup> + 12<sup class="calibre8">3</sup> = 9<sup class="calibre8">3</sup> + 10<sup class="calibre8">3</sup> = 1729. Write a program to find the second such number.</p>
<p class="para">In fact, define a function that returns a list of all essentially different quadruples (<i class="calibre1">a</i>, <i class="calibre1">b</i>, <i class="calibre1">c</i>, <i class="calibre1">d</i>) in the range 0 &lt; <i class="calibre1">a</i>, <i class="calibre1">b</i>, <i class="calibre1">c</i>, <i class="calibre1">d</i> ≤ <i class="calibre1">n</i> such that <i class="calibre1">a</i><sup class="calibre8">3</sup> +<i class="calibre1">b</i><sup class="calibre8">3</sup> = <i class="calibre1">c</i><sup class="calibre8">3</sup> +<i class="calibre1">d</i><sup class="calibre8">3</sup>. I suggest using a list comprehension, but only after thinking carefully about what it means to say <a id="text/part0008.html.page_79" class="calibre3"></a>two quadruples are essentially different. After all, <i class="calibre1">a</i><sup class="calibre8">3</sup> + <i class="calibre1">b</i><sup class="calibre8">3</sup> = <i class="calibre1">c</i><sup class="calibre8">3</sup> + <i class="calibre1">d</i><sup class="calibre8">3</sup> can be written in eight different ways.</p>
<p class="theorem"><b class="calibre7">Exercise F</b></p>
<p class="para">The dual view of lists is to construct them by adding elements to the end of the list:</p>
<p class="code"><span class="font">data List a = Nil | Snoc (List a) a</span></p>
<p class="para"><span class="font">Snoc</span> is, of course, <span class="font">Cons</span> backwards. With this view of lists [1, 2, 3] would be represented by</p>
<p class="code"><span class="font">Snoc (Snoc (Snoc Nil 1) 2) 3</span></p>
<p class="para">Exactly the same information is provided by the two views but it is organised differently. Give the definitions of <span class="font">head</span> and <span class="font">last</span> for the snoc-view of lists, and define two functions</p>
<div class="space1">
<p class="code"><span class="font">toList :: [a] -&gt; List a</span></p>
<p class="code"><span class="font">fromList :: List a -&gt; [a]</span></p>
</div>
<p class="para">for converting efficiently from one view of lists to the other. (Hint: <span class="font">reverse</span> is efficient, taking linear time to reverse a list.)</p>
<p class="theorem"><b class="calibre7">Exercise G</b></p>
<p class="para">How much space is required to evaluate <span class="font">length xs</span>? Consider the following alternative definition of <span class="font">length</span>:</p>
<div class="space1">
<p class="code"><span class="font">length :: [a] -&gt; Int</span></p>
<p class="code"><span class="font">length xs = loop (0,xs)</span></p>
<p class="code2"><span class="font">where loop (n,[]) = n</span></p>
<p class="code3"><span class="space-r"></span><span class="font">loop (n,x:xs) = loop (n+1,xs)</span></p>
</div>
<p class="para">Does the space requirement change? Does it change if we switched to eager evaluation? These questions are taken up in much more detail in <a href="#text/part0011.html.AFM60-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 7</a>.</p>
<p class="theorem"><b class="calibre7">Exercise H</b></p>
<p class="para">The prelude function <span class="font">take n</span> takes the first <span class="font">n</span> elements of a list, while <span class="font">drop n</span> drops the first <span class="font">n</span> elements. Give recursive definitions for these functions. What are the values of</p>
<p class="code"><span class="font">take 0 undefined take undefined []</span></p>
<p class="para">according to your definition? A more tricky question: can you find a definition in which both the above expressions have the value <span class="font">[]</span>? If not, why not?</p>
<p class="para"><a id="text/part0008.html.page_80" class="calibre3"></a>Which of the following equations are valid for all integers <i class="calibre1">m</i> and <i class="calibre1">n</i>? You don’t have to justify your answers, just try to understand what they claim to say.</p>
<div class="space1">
<p class="code"><span class="font">take n xs ++ drop n xs = xs</span></p>
<p class="code"><span class="font">take m . drop n = drop n . take (m+n)</span></p>
<p class="code"><span class="font">take m . take n = take (m `min` n)</span></p>
<p class="code"><span class="font">drop m . drop n = drop (m+n)</span></p>
</div>
<p class="para">The standard prelude function <span class="font">splitAt n</span> can be defined by</p>
<p class="code"><span class="font">splitAt n xs = (take n xs,drop n xs)</span></p>
<p class="para">Though clear, the above definition is maybe a little inefficient as it involves processing <span class="font">xs</span> twice. Give a definition of <span class="font">splitAt</span> that traverses the list only once.</p>
<p class="theorem"><b class="calibre7">Exercise I</b></p>
<p class="para">Which of the following statements about the equation</p>
<p class="code"><span class="font">map (f . g) xs = map f (map g xs)</span></p>
<p class="para">do you agree with, and which do you disagree with (again, no justification is required)?</p>
<p class="number">1.<span class="space"></span>It’s not true for all <span class="font">xs</span>; it depends on whether <span class="font">xs</span> is a finite list or not.</p>
<p class="number">2.<span class="space"></span>It’s not true for all <span class="font">f</span> and <span class="font">g</span>; it depends on whether <span class="font">f</span> and <span class="font">g</span> are strict functions or not.</p>
<p class="number">3.<span class="space"></span>It’s true for all lists <span class="font">xs</span>, finite, partial or infinite, and for all <span class="font">f</span> and <span class="font">g</span> of the appropriate type. In fact <span class="font">map (f . g) = map f . map g</span> is a much neater alternative.</p>
<p class="number">4.<span class="space"></span>It looks true, but it has to be proved so from the definition of <span class="font">map</span> and the definition of functional composition.</p>
<p class="number">5.<span class="space"></span>Used right-to-left, it expresses a program optimisation: two traversals of a list are replaced by one.</p>
<p class="number">6.<span class="space"></span>It’s not an optimisation under lazy evaluation because <span class="font">map g xs</span> is not computed in its entirety before evaluation of <span class="font">map f</span> on the result begins.</p>
<p class="number">7.<span class="space"></span>Whether or not it is computed in pieces or as a whole, the right-hand side does produce an intermediate list, while the left-hand side doesn’t. It is a rule for optimising a program even under lazy evaluation.</p>
<p class="theorem"><a id="text/part0008.html.page_81" class="calibre3"></a><b class="calibre7">Exercise J</b></p>
<p class="para">Here are some equations; at least one of them is false. Which are the true ones, and which are false? Once again, you do not have to provide any justification for your answers, the aim is just to look at some equations and appreciate what they are saying.</p>
<div class="space1">
<p class="code"><span class="font">map f . take n</span><span class="space-b"></span><span class="font">= take n . map f</span></p>
<p class="code"><span class="font">map f . reverse</span><span class="space"></span><span class="font">= reverse . map f</span></p>
<p class="code"><span class="font">map f . sort</span><span class="space4"></span><span class="font">= sort . map f</span></p>
<p class="code"><span class="font">map f . filter p = map fst . filter snd . map (fork (f,p))</span></p>
<p class="code"><span class="font">filter (p . g)</span><span class="space5"></span><span class="font">= map (invertg) . filter p . map g</span></p>
<p class="code"><span class="font">reverse . concat</span><span class="space"></span><span class="font">= concat . reverse . map reverse</span></p>
<p class="code"><span class="font">filter p . concat = concat . map (filter p)</span></p>
</div>
<p class="para">In the fifth equation assume <span class="font">invertg</span> satisfies <span class="font">invertg . g = id</span>. The function <span class="font">fork</span> in the fourth equation is defined by</p>
<div class="space1">
<p class="code"><span class="font">fork :: (a -&gt; b,a -&gt; c) -&gt; a -&gt; (b,c)</span></p>
<p class="code"><span class="font">fork (f,g) x = (f x, g x)</span></p>
</div>
<p class="theorem"><b class="calibre7">Exercise K</b></p>
<p class="para">Define <span class="font">unzip</span> and <span class="font">cross</span> by</p>
<div class="space1">
<p class="code"><span class="font">unzip = fork (map fst, map snd)</span></p>
<p class="code"><span class="font">cross (f,g) = fork (f . fst, g . snd)</span></p>
</div>
<p class="para">What are the types of these functions?</p>
<p class="para">Prove by simple equational reasoning that</p>
<p class="code6"><span class="font">cross (map f, map g) . unzip = unzip . map (cross (f,g))</span></p>
<p class="para">You can use the functor laws of <span class="font">map</span> and the following rules:</p>
<div class="space1">
<p class="code"><span class="font">cross (f,g) . fork (h,k) = fork (f . h,g . k)</span></p>
<p class="code"><span class="font">fork (f,g) . h</span><span class="space3"></span><span class="space-r"></span><span class="font">= fork (f . h,g . h)</span></p>
<p class="code"><span class="font">fst . cross (f,g)</span><span class="space8"></span><span class="font">= f . fst</span></p>
<p class="code"><span class="font">snd . cross (f,g)</span><span class="space8"></span><span class="font">= g . snd</span></p>
</div>
<p class="theorem"><b class="calibre7">Exercise L</b></p>
<p class="para">Continuing from the previous exercise, prove that</p>
<p class="code"><span class="font">cross (f,g) . cross (h,k) = cross (f . h,g . k)</span></p>
<p class="para"><a id="text/part0008.html.page_82" class="calibre3"></a>We also have <span class="font">cross (id,id) = id</span> (Why?). So it looks like <span class="font">cross</span> has functorlike properties, except that it takes a pair of functions. Yes, it’s a <i class="calibre1">bifunctor</i>. That suggests a generalisation:</p>
<div class="space1">
<p class="code"><span class="font">class Bifunctor p where</span></p>
<p class="code2"><span class="font">bimap :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; p a c -&gt; p b d</span></p>
</div>
<p class="para">The arguments to <span class="font">bimap</span> are given one by one rather than paired. Express <span class="font">cross</span> in terms of <span class="font">bimap</span> for the instance <span class="font">Pair</span> of <span class="font">Bifunctor</span>, where</p>
<p class="code"><span class="font">type Pair a b = (a,b)</span></p>
<p class="para">Now consider the data type</p>
<p class="code"><span class="font">data Either a b = Left a | Right b</span></p>
<p class="para">Construct the instance <span class="font">Either</span> of <span class="font">Bifunctor</span>.</p>
<h3 class="h" id="text/part0008.html.head4-10">4.10 Answers</h3>
<p class="theorem"><b class="calibre7">Answer to Exercise A</b></p>
<p class="para">Only the following three equations are true:</p>
<div class="space1">
<p class="code"><span class="font">xs:[] = [xs]</span></p>
<p class="code"><span class="font">[[]] ++ [xs] = [[],xs]</span></p>
<p class="code"><span class="font">[xs] ++ [] = [xs]</span></p>
</div>
<p class="para">If we defined <span class="font">null</span> by <span class="font">null = (==[])</span>, then its type would have to be the more restrictive</p>
<p class="code"><span class="font">null :: (Eq a) =&gt; [a] -&gt; Bool</span></p>
<p class="para">That means you can only use an equality test on lists if the list elements can be compared for equality. Of course, the empty list contains no elements, so <span class="font">(==)</span> is not needed.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise B</b></p>
<p class="para">No, <span class="font">allPairs</span> produces the infinite list</p>
<p class="code"><span class="font">allPairs = [(0,y) | y &lt;- [0..]]</span></p>
<p class="para">One alternative, which lists the pairs in ascending order of their sum, is</p>
<p class="code"><span class="font">allPairs = [(x,d-x) | d &lt;- [0..], x &lt;- [0..d]]</span></p>
<p class="theorem"><a id="text/part0008.html.page_83" class="calibre3"></a><b class="calibre7">Answer to Exercise C</b></p>
<p class="para">The definition is</p>
<div class="space1">
<p class="code"><span class="font">disjoint xs [] = True</span></p>
<p class="code"><span class="font">disjoint [] ys = True</span></p>
<p class="code"><span class="font">disjoint xs'@(x:xs) ys'@(y:ys)</span></p>
<p class="code2"><span class="font">| x &lt; y</span><span class="space-toc1"></span><span class="font">= disjoint xs ys'</span></p>
<p class="code2"><span class="font">| x == y = False</span></p>
<p class="code2"><span class="font">| x &gt; y</span><span class="space-toc1"></span><span class="font">= disjoint xs' ys</span></p>
</div>
<p class="para">We used an as-pattern, just to be clever.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise D</b></p>
<p class="para">They deliver the same result only if <span class="font">ys</span> is a finite list:</p>
<p class="code6"><span class="font">ghci&gt; [1 | x &lt;- [1,3], even x, y &lt;- undefined]</span></p>
<p class="code6"><span class="font">[]</span></p>
<p class="code6"><span class="font">ghci&gt; [1 | x &lt;- [1,3], y &lt;- undefined, even x]</span></p>
<p class="code6"><span class="font">*** Exception: Prelude.undefined</span></p>
<p class="code6"><span class="font">ghci&gt; [1 | x &lt;- [1,3], even x, y &lt;- [1..]]</span></p>
<p class="code6"><span class="font">[]</span></p>
<p class="code6"><span class="font">Prelude&gt; [1 | x &lt;- [1,3], y &lt;- [1..], even x]</span></p>
<p class="code6"><span class="font">{Interrupted}</span></p>
</div>
<p class="para">When they do deliver the same result, the former is more efficient.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise E</b></p>
<p class="para">One way of generating essentially different quadruples is to restrict the quadruple (<i class="calibre1">a</i>, <i class="calibre1">b</i>, <i class="calibre1">c</i>, <i class="calibre1">d</i>) to values satisfying <i class="calibre1">a</i> ≤ <i class="calibre1">b</i> and <i class="calibre1">c</i> ≤ <i class="calibre1">d</i> and <i class="calibre1">a</i> &lt; <i class="calibre1">c</i>. Hence</p>
<div class="space1">
<p class="code"><span class="font">quads n = [(a,b,c,d) | a &lt;- [1..n], b &lt;- [a..n],</span></p>
<p class="code16"><span class="space-b"></span><span class="font">c &lt;- [a+1..n],d &lt;- [c..n],</span></p>
<p class="code16"><span class="space-b"></span><span class="font">a^3 + b^3 == c^3 + d^3]</span></p>
</div>
<p class="para">The second such number is 4104 = 2<sup class="calibre8">3</sup> + 16<sup class="calibre8">3</sup> = 9<sup class="calibre8">3</sup> + 15<sup class="calibre8">3</sup>.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise F</b></p>
<div class="space1">
<p class="code"><span class="font">head :: List a -&gt; a</span></p>
<p class="code"><span class="font">head (Snoc Nil x) = x</span></p>
<p class="code"><span class="font">head (Snoc xs x) = head xs</span></p>
<p class="code"><a id="text/part0008.html.page_84" class="calibre3"></a><span class="font">last :: List a -&gt; a</span></p>
<p class="code"><span class="font">last (Snoc xs x) = x</span></p>
<p class="para1"></p>
<p class="code"><span class="font">toList :: [a] -&gt; List a</span></p>
<p class="code"><span class="font">toList = convert . reverse</span></p>
<p class="code2"><span class="font">where convert []</span><span class="space-b"></span><span class="font">= Nil</span></p>
<p class="code8"><span class="font">convert (x:xs) = Snoc (convert xs) x</span></p>
<p class="code"><span class="font">fromList :: List a -&gt; [a]</span></p>
<p class="code"><span class="font">fromList = reverse . convert</span></p>
<p class="code2"><span class="font">where convert Nil</span><span class="space4"></span><span class="space-r"></span><span class="font">= []</span></p>
<p class="code8"><span class="font">convert (Snoc xs x) = x:convert xs</span></p>
</div>
<p class="theorem"><b class="calibre7">Answer to Exercise G</b></p>
<p class="para">It requires a linear amount of space since the expression</p>
<p class="code"><span class="font">1 + (1 + (1 + ... (1 + 0)))</span></p>
<p class="para">is built up in memory. The space requirement for the second definition of length does not change under lazy evaluation since the expression</p>
<p class="code"><span class="font">loop ((((0 + 1) + 1) + 1 ... +1),[])</span></p>
<p class="para">is built up in memory. But under eager evaluation the length of a list can be computed using constant extra space.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise H</b></p>
<div class="space1">
<p class="code"><span class="font">take, drop :: Int -&gt; [a] -&gt; [a]</span></p>
<p class="code"><span class="font">take n []</span><span class="space4"></span><span class="font">= []</span></p>
<p class="code"><span class="font">take n (x:xs) = if n==0 then [] else x:take (n-1) xs</span></p>
<p class="para1"></p>
<p class="code"><span class="font">drop n []</span><span class="space4"></span><span class="font">= []</span></p>
<p class="code"><span class="font">drop n (x:xs) = if n==0 then x:xs else drop (n-1) xs</span></p>
</div>
<p class="para">With this definition of <span class="font">take</span> we have</p>
<p class="code"><span class="font">take undefined [] = [] take 0 undefined = undefined</span></p>
<div class="space1">
<p class="para">With the alternative</p>
<p class="code"><span class="font">take n xs | n==0 = []</span></p>
<p class="code2"><span class="space2"></span><span class="space"></span><span class="font">| null xs = []</span></p>
<p class="code2"><span class="space2"></span><span class="space"></span><span class="font">| otherwise = head xs: take (n-1) (tail xs)</span></p>
</div>
<p class="para">we have</p>
<p class="code"><a id="text/part0008.html.page_85" class="calibre3"></a><span class="font">take undefined [] = undefined take 0 undefined = []</span></p>
<p class="para">The answer to the tricky question is: no. Either argument <span class="font">n</span> or argument <span class="font">xs</span> has to be examined and, whichever happens first, ⊥ is the result if ⊥ is the value of thaargument.</p>
<p class="para">All four equations are valid for all lists <i class="calibre1">xs</i> and for all <i class="calibre1">m</i>, <i class="calibre1">n</i> ≠⊥, under either definition.</p>
<p class="para">The function <span class="font">splitAt n</span> can be defined by</p>
<div class="space1">
<p class="code"><span class="font">splitAt :: Int -&gt; [a] -&gt; ([a],[a])</span></p>
<p class="code"><span class="font">splitAt n [] = ([],[])</span></p>
<p class="code"><span class="font">splitAt n (x:xs) = if n==0 then ([],x:xs) else (x:ys,zs)</span></p>
<p class="code13"><span class="font">where (ys,zs) = splitAt (n-1) xs</span></p>
</div>
<p class="theorem"><b class="calibre7">Answer to Exercise I</b></p>
<p class="para">I would agree with (3), (4), (5) and (7).</p>
<p class="theorem"><b class="calibre7">Answer to Exercise J</b></p>
<p class="para">The only false equation is <span class="font">map f . sort = sort . map f</span> which is true only i<i class="calibre1">f</i> is order-preserving, i.e. <i class="calibre1">x</i> ≤ <i class="calibre1">y</i> ≡ <i class="calibre1">f x</i> ≤ <i class="calibre1">f y</i>.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise K</b></p>
<div class="space1">
<p class="code"><span class="font">unzip :: [(a,b)] -&gt; ([a],[b])</span></p>
<p class="code"><span class="font">cross :: (a -&gt; b, c -&gt; d) -&gt; (a,c) -&gt; (b,d)</span></p>
</div>
<p class="para">The calculation is</p>
<div class="space1">
<p class="code1"><span class="font">cross (map f, map g) . unzip</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">unzip</span>}</p>
<p class="code1"><span class="font">cross (map f, map g) . fork (map fst, map snd)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{law of <span class="font">cross</span> and <span class="font">fork</span>}</p>
<p class="code1"><span class="font">fork (map f . map fst, map g . map snd)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{law of <span class="font">map</span>}</p>
<p class="code1"><span class="font">fork (map (f . fst), map (g . snd))</span></p>
</div>
<p class="para"><a id="text/part0008.html.page_86" class="calibre3"></a>We seem to be stuck, as no law applies. Try the right-hand side:</p>
<p class="code1"><span class="font">unzip . map (cross (f,g))</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">unzip</span>}</p>
<p class="code1"><span class="font">fork (map fst, map snd) . map (cross (f,g))</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{law of <span class="font">fork</span>}</p>
<p class="code1"><span class="font">fork (map fst . map (cross (f,g)),</span></p>
<p class="code4"><span class="font">map snd . map (cross (f,g)))</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{law of <span class="font">map</span>}</p>
<p class="code1"><span class="font">fork (map (fst . cross (f,g)),</span></p>
<p class="code4"><span class="font">map (snd . cross (f,g)))</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{laws of <span class="font">fst</span> and <span class="font">snd</span>}</p>
<p class="code1"><span class="font">fork (map (f . fst), map (g . snd))</span></p>
<p class="para">Phew. Both sides have reduced to the same expression. That is often the way with calculations: one side doesn’t always lead easily to the other, but both sides reduce to the same result.</p>
<p class="para">The calculations we have seen so far have all been carried out at the function level. Such a style of definition and proof is called <i class="calibre1">point-free</i> (and also <i class="calibre1">pointless</i> by some jokers). Point-free proofs are what the automatic calculator of <a href="#text/part0016.html.F8900-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 12</a> produces. The point-free style is very slick, but it does necessitate the use of various <i class="calibre1">plumbing combinators</i>, such as <span class="font">fork</span> and <span class="font">cross</span>, to pass arguments to functions. Plumbing combinators push values around, duplicate them and even eliminate them. As an example of the last kind,</p>
<p class="code"><span class="font">const :: a -&gt; b -&gt; a</span></p>
<p class="code"><span class="font">const x y = x</span></p>
<p class="para">This little combinator is in the standard prelude and can be quite useful on occasion.</p>
<p class="para">Two more plumbing combinators, also defined in the standard prelude, are <span class="font">curry</span> and <span class="font">uncurry</span>:</p>
<p class="code"><span class="font">curry :: ((a, b) -&gt; c) -&gt; a -&gt; b -&gt; c</span></p>
<p class="code"><span class="font">curry f x y = f (x,y)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">uncurry :: (a -&gt; b -&gt; c) -&gt; (a,b) -&gt; c</span></p>
<p class="code"><span class="font">uncurry f (x,y) = f x y</span></p>
<p class="para">A <i class="calibre1">curried</i> function is a function that takes its arguments one at a time, while a non-curried function takes a single, tupled argument. The key advantage of curried <a id="text/part0008.html.page_87" class="calibre3"></a>functions is that they can be <i class="calibre1">partially applied</i>. For instance, <span class="font">take n</span> is a perfectly valid function in its own right, and so is <span class="font">map f</span>. That is why we have used curried functions from the start.</p>
<p class="para">By the way, curried functions are named after Haskell B. Curry, an American logician. And, yes, that is where Haskell got its name.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise L</b></p>
<div class="space1">
<p class="code1"><span class="font">cross (f,g) . cross (h,k)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">cross</span>}</p>
<p class="code1"><span class="font">cross (f,g) . fork (h . fst, k . snd)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{law of <span class="font">cross</span> and <span class="font">fork</span>}</p>
<p class="code1"><span class="font">fork (f . h . fst,g . k . snd)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">cross</span>}</p>
<p class="code1"><span class="font">cross (f . h, g . k)</span></p>
</div>
<p class="para">We have <span class="font">cross = uncurry bimap</span>, where <span class="font">uncurry</span> was defined in the previous answer.</p>
<p class="para">Here is the instance of <span class="font">Either</span>:</p>
<div class="space1">
<p class="code"><span class="font">instance Bifunctor Either where</span></p>
<p class="code2"><span class="font">bimap f g (Left x) = Left (f x)</span></p>
<p class="code2"><span class="font">bimap f g (Right y) = Right (g y)</span></p>
</div>
<h3 class="h" id="text/part0008.html.head4-11">4.11 Chapter notes</h3>
<p class="para">Most of the functions introduced in this chapter can be found in the Haskell standard prelude. Functors, bifunctors, and natural transformations are explained in books about Category Theory. Two such are <i class="calibre1">Basic Category Theory for Computer Scientists</i> (MIT Press, 1991) by Benjamin Pierce, and <i class="calibre1">The Algebra of Programming</i> (Prentice Hall, 1997) by Richard Bird and Oege de Moor.</p>
<p class="para">Also on the subject of laws, read Phil Wadler’s influential article <i class="calibre1">Theorems for free!</i> which can be found at</p>
<p class="code"><span class="font"><a href="http://homepages.inf.ed.ac.uk/wadler/papers/free/" class="calibre3">homepages.inf.ed.ac.uk/wadler/papers/free/</a></span></p>
<p class="para"><a id="text/part0008.html.page_88" class="calibre3"></a>In mathematics, the so-called taxicab number taxicab(<i class="calibre1">n</i>) is the smallest number that can be expressed as the sum of two positive cubes in <i class="calibre1">n</i> distinct ways. So 1729 = taxicab(2). Google ‘taxicab numbers’ for more information.</p>
</div></div>
<div id="text/part0009.html"><div id="text/part0009.html.8IL20-0daaaafc8385457e8f80971b0d39bbf7" class="calibre">

<h2 class="chapter-number" id="text/part0009.html.calibre_pb_0"><a id="text/part0009.html.page_89" class="calibre6"></a>Chapter 5</h2>
<h2 class="chapter-title">A simple Sudoku solver</h2>
<p class="right">H<small class="calibre17">OW TO PLAY</small>: Fill in the grid so that every row,<br class="calibre4"><br>every column and every 3 × 3 box contains the<br class="calibre4"><br>digits 1–9. There’s no maths involved. You<br class="calibre4"><br>solve the puzzle with reasoning and logic.<br class="calibre4"><br><i class="calibre1">Advice on how to play Sudoku, the</i> Independent</p>
<p class="para">This chapter is devoted to an extended exercise in the use of lists to solve problems, and in the use of equational reasoning to reason about them and to improve efficiency.</p>
<p class="para">The game of Sudoku is played on a 9 by 9 grid, though other sizes are also possible. Given a matrix, such as that in <a href="#text/part0009.html.fig5-1" class="calibre3">Figure 5.1</a>, the idea is to fill in the empty cells with the digits 1 to 9 so that each row, column and 3×3 box contains the numbers 1 to 9. In general there may be any number of solutions, though in a good Sudoku puzzle there should always be a unique solution. Our aim is to construct a program to solve Sudoku puzzles. Specifically, we will define a function <span class="font">solve</span> for computing a list of all the ways a given grid may be completed. If only one solution is wanted, then we can take the head of the list. Lazy evaluation means that only the first result will then be computed.</p>
<div class="figure">
<p class="image"><a id="text/part0009.html.page_90" class="calibre3"></a><img src="data:image/jpeg;base64,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" alt="image" class="calibre2"></p>
<p class="imagecaption" id="text/part0009.html.fig5-1">Figure 5.1 A Sudoku grid</p>
</div>
<p class="para">We begin with a specification, then use equational reasoning to calculate a more efficient version. There’s no maths involved, just reasoning and logic!</p>
<h3 class="h" id="text/part0009.html.head5-1">5.1 Specification</h3>
<p class="para">Here are the basic data types of interest, starting with matrices:</p>
<p class="code"><span class="font">type Matrix a = [Row a]</span></p>
<p class="code"><span class="font">type Row a = [a]</span></p>
<p class="para">The two type synonyms say nothing more than that <span class="font">Matrix a</span> is a synonym for <span class="font">[[a]]</span>. But the way it is said emphasises that a matrix is a list of <i class="calibre1">rows</i>; more precisely, a <i class="calibre1">m</i> × <i class="calibre1">n</i> matrix is a list of <i class="calibre1">m</i> rows in which each row is a list with the same length <i class="calibre1">n</i>. Haskell type synonyms cannot enforce such constraints, though there are languages, called <i class="calibre1">dependently-typed</i> languages, that can.</p>
<p class="para">A grid is a 9 × 9 matrix of digits:</p>
<div class="space1">
<p class="code"><span class="font">type Grid</span><span class="space-toc1"></span><span class="font">= Matrix Digit</span></p>
<p class="code"><span class="font">type Digit = Char</span></p>
</div>
<p class="para">The valid digits are 1 to 9 with 0 standing for a blank:</p>
<div class="space1">
<p class="code"><span class="font">digits :: [Char]</span></p>
<p class="code"><span class="font">digits = ['1' .. '9']</span></p>
<p class="para1"></p>
<p class="code"><span class="font">blank :: Digit -&gt; Bool</span></p>
<p class="code"><span class="font">blank = (== '0')</span></p>
</div>
<p class="para">Recall that <span class="font">Char</span> is also an instance of the type class <span class="font">Enum</span>, so <span class="font">['1' .. '9']</span> is a valid expression and does indeed return the list of nonzero digits.</p>
<p class="para">We will suppose for simplicity that the input grid contains only digits and blanks, so we do not have to check for the input being well-formed. But should we also insist that no non-blank digit is repeated in any row, column or box? If there were such repetitions there would be no solution. We postpone this decision until after we see how the rest of the algorithm pans out.</p>
<p class="para"><a id="text/part0009.html.page_91" class="calibre3"></a>Now for the specification. The aim is to write down the simplest and clearest specification without regard to how efficient the result might be. That’s a key difference between functional programming and other forms of program construction: we can always begin with a clear and simple, though possibly extremely inefficient definition of <span class="font">solve</span>, and then use the laws of functional programming to massage the computation into one that takes acceptable time and space.</p>
<p class="para">One possibility is first to construct a list of all possible correctly filled grids, a vastly long but still finite list, and then to test the given grid against each of them to identify those whose entries match the given non-blank ones. Certainly that approach takes the idea of an inefficient specification to the extreme. Another reasonable alternative is to start with the given grid and to complete it by filling in every possible choice for the blank entries. The result will be a list of filled grids. Then we can filter this list for those that don’t contain duplicates in any row, box or column. This specification is implemented by</p>
<div class="space1">
<p class="code"><span class="font">solve :: Grid -&gt; [Grid]</span></p>
<p class="code"><span class="font">solve = filter valid . completions</span></p>
</div>
<p class="para">where the subsidiary functions have types</p>
<div class="space1">
<p class="code"><span class="font">completions :: Grid -&gt; [Grid]</span></p>
<p class="code"><span class="font">valid :: Grid -&gt; Bool</span></p>
</div>
<p class="para">Let us work on <span class="font">completions</span> first and consider <span class="font">valid</span> afterwards. One way of defining <span class="font">completions</span> is by a two-step process:</p>
<p class="code"><span class="font">completions = expand . choices</span></p>
<p class="para">where</p>
<div class="space1">
<p class="code"><span class="font">choices :: Grid -&gt; Matrix [Digit]</span></p>
<p class="code"><span class="font">expand</span><span class="space-toc1"></span><span class="font">:: Matrix [Digit] -&gt; [Grid]</span></p>
</div>
<p class="para">The function <span class="font">choices</span> installs the available digits for each cell:</p>
<p class="code"><span class="font">choices</span><span class="space-toc1"></span><span class="font">= map (map choice)</span></p>
<p class="code"><span class="font">choice d = if blank d then digits else [d]</span></p>
<p class="para">If the cell is blank, then all digits are installed as possible choices; otherwise there is only one choice and a singleton is returned. If we want to apply <span class="font">f</span> to every element of a matrix, then <span class="font">map (map f)</span> is the function to use because, after all, a matrix is just a list of lists.</p>
<p class="para">After applying <span class="font">choices</span> we obtain a matrix each of whose entries is a list of digits. What we want to do next is to define <span class="font">expand</span> to convert this matrix into a list of <a id="text/part0009.html.page_92" class="calibre3"></a>grids by installing all the choices in all possible ways. That seems a little difficult to think about, so let’s consider a simpler problem first, namely when instead of a 9 × 9 matrix we have a list of length 3. Suppose we want to convert</p>
<p class="code"><span class="font">[[1,2,3],[2],[1,3]]</span></p>
<p class="para">into the list</p>
<p class="code"><span class="font">[[1,2,1],[1,2,3],[2,2,1],[2,2,3],[3,2,1],[3,2,3]]</span></p>
<p class="para">The second list of lists arises by taking, in all possible ways, one element from the first list, one element from the second list and one element from the third list. Let us call the function that does this <span class="font">cp</span> (short for ‘cartesian product’, which is exactly what a mathematician would call it). There doesn’t seem to be any clever way of computing <span class="font">cp</span> in terms of other functions, so we adopt the default strategy of defining this function by breaking up its argument list into two possibilities, the empty list <span class="font">[]</span> and a nonempty list <span class="font">xs:xss</span>. You might guess the definition of <span class="font">cp []</span> but you would probably be wrong; the better alternative is to think about the second case first. Suppose we assume</p>
<p class="code"><span class="font">cp [[2],[1,3]] = [[2,1],[2,3]]</span></p>
<p class="para">How can we extend this definition to one for <span class="font">cp ([1,2,3]:[[2],[1,3]])</span>? The answer is to prefix <span class="font">1</span> to every element of <span class="font">cp [[2],[1,3]]</span>, then to prefix <span class="font">2</span> to every element of the same list, and finally to prefix <span class="font">3</span> to every element. That process can be expressed neatly using a list comprehension:</p>
<p class="code"><span class="font">cp (xs:xss) = [x:ys | x &lt;- xs, ys &lt;- cp xss]</span></p>
<p class="para">In words, prefix every element of <span class="font">xs</span> to every element of <span class="font">cp xss</span> in all possible ways.</p>
<p class="para">If your nose is good at sniffing out inefficiencies, you might suspect that this oneliner is not the best possible, and you would be right. We will return to this point in <a href="#text/part0011.html.head7-3" class="calibre3">Section 7.3</a>, but let’s just say that a more efficient definition is</p>
<div class="space1">
<p class="code"><span class="font">cp (xs:xss) = [x:ys | x &lt;- xs, ys &lt;- yss]</span></p>
<p class="code9"><span class="font">where yss = cp xss</span></p>
</div>
<p class="para">This version guarantees that <span class="font">cp xss</span> is computed just once.</p>
<p class="para">Now, what is <span class="font">cp []</span>? The answer is not <span class="font">[]</span> but <span class="font">[[]]</span>. To see why the first is wrong, consider a little calculation:</p>
<div class="space1">
<p class="code"><span class="font">cp [xs] = cp (xs:[])</span></p>
<p class="code3"><span class="space-r"></span><span class="font">= [x:ys | x &lt;- xs, ys &lt;- cp []]</span></p>
<p class="code3"><span class="space-r"></span><a id="text/part0009.html.page_93" class="calibre3"></a><span class="font">= [x:ys | x &lt;- xs, ys &lt;- []]</span></p>
<p class="code3"><span class="space-r"></span><span class="font">= []</span></p>
</div>
<p class="para">In fact with <span class="font">cp [] = []</span> we can show that <span class="font">cp xss = []</span> for all lists <span class="font">xss</span>. So that definition is clearly wrong. You can check that the second alternative, <span class="font">[[]]</span>, does give what is wanted.</p>
<p class="para">Summarising, we can define <span class="font">cp</span> by</p>
<div class="space1">
<p class="code"><span class="font">cp :: [[a]] -&gt; [[a]]</span></p>
<p class="code"><span class="font">cp []</span><span class="space2"></span><span class="font">= [[]]</span></p>
<p class="code"><span class="font">cp (xs:xss) = [x:ys | x &lt;- xs, ys &lt;- yss]</span></p>
<p class="code9"><span class="space-r"></span><span class="font">where yss = cp xss</span></p>
</div>
<p class="para">For example,</p>
<p class="code"><span class="font">ghci&gt; cp [[1],[2],[3]]</span></p>
<p class="code"><span class="font">[[1,2,3]]</span></p>
<p class="para1"></p>
<p class="code"><span class="font">ghci&gt; cp [[1,2],[],[4,5]]</span></p>
<p class="code"><span class="font">[]</span></p>
<p class="para">In the second example there is no possible choice from the middle list, so the empty list is returned.</p>
<p class="para">But what about matrices and <span class="font">expand</span>, which does the same thing on matrices as <span class="font">cp</span> does on lists? You will have to think a bit before seeing that what is wanted is</p>
<div class="space1">
<p class="code"><span class="font">expand :: Matrix [Digit] -&gt; [Grid]</span></p>
<p class="code"><span class="font">expand = cp . map cp</span></p>
</div>
<p class="para">That looks a little cryptic, but <span class="font">map cp</span> returns a list of all possible choices for each row, and so applying <span class="font">cp</span> to the result installs each choice for the rows in all possible ways. The general type of the right-hand side is</p>
<p class="code"><span class="font">cp . map cp :: [[[a]]] -&gt; [[[a]]]</span></p>
<p class="para">and the declared type of <span class="font">expand</span> is just a restricted version of this type. Note that <span class="font">expand</span> returns the empty list if any element in any row is the empty list.</p>
<p class="para">Finally, a valid grid is one in which no row, column or box contains duplicates:</p>
<div class="space1">
<p class="code"><span class="font">valid :: Grid -&gt; Bool</span></p>
<p class="code"><span class="font">valid g = all nodups (rows g) &amp;&amp;</span></p>
<p class="code10"><span class="font">all nodups (cols g) &amp;&amp;</span></p>
<p class="code10"><span class="font">all nodups (boxs g)</span></p>
</div>
<p class="para"><a id="text/part0009.html.page_94" class="calibre3"></a>The prelude function <span class="font">all</span> is defined by</p>
<p class="code"><span class="font">all p = and . map p</span></p>
<p class="para">Applied to a finite list <span class="font">xs</span> the function <span class="font">all p</span> returns <span class="font">True</span> if all elements of <span class="font">xs</span> satisfy <span class="font">p</span>, and <span class="font">False</span> otherwise. The function <span class="font">nodups</span> can be defined by</p>
<div class="space1">
<p class="code"><span class="font">nodups :: (Eq a) =&gt; [a] -&gt; Bool</span></p>
<p class="code"><span class="font">nodups</span><span class="space4"></span><span class="font">[] = True</span></p>
<p class="code"><span class="font">nodups (x:xs) = all (/=x) xs &amp;&amp; nodups xs</span></p>
</div>
<p class="para">Evaluation of <span class="font">nodups</span> on a list of length <i class="calibre1">n</i> takes time proportional to <i class="calibre1">n</i><sup class="calibre8">2</sup>. As an alternative we could sort the list and check that it is strictly increasing. Sorting can be done in time proportional to <i class="calibre1">n</i>log<i class="calibre1">n</i> steps. That seems a big saving over <i class="calibre1">n</i><sup class="calibre8">2</sup>. However, with <i class="calibre1">n</i> = 9, it is not clear that using an efficient sorting algorithm is worthwhile. What would you prefer: 2<i class="calibre1">n</i><sup class="calibre8">2</sup> steps or 100<i class="calibre1">n</i>log<sub class="calibre11"><sup class="calibre18">2</sup></sub> <i class="calibre1">n</i> steps?</p>
<p class="para">It remains to define <span class="font">rows</span>, <span class="font">cols</span> and <span class="font">boxs</span>. If a matrix is given by a list of its rows, then <span class="font">rows</span> is just the identity function on matrices:</p>
<div class="space1">
<p class="code"><span class="font">rows :: Matrix a -&gt; Matrix a</span></p>
<p class="code"><span class="font">rows = id</span></p>
</div>
<p class="para">The function <span class="font">cols</span> computes the transpose of a matrix. Thus if a matrix consists of <i class="calibre1">m</i> rows, where each row has length <i class="calibre1">n</i>, the transpose is a list of <i class="calibre1">n</i> rows, where each row has length <i class="calibre1">m</i>. Assuming both <i class="calibre1">m</i> and <i class="calibre1">n</i> are not zero, we can define</p>
<div class="space1">
<p class="code"><span class="font">cols :: Matrix a -&gt; Matrix a</span></p>
<p class="code"><span class="font">cols [xs]</span><span class="space4"></span><span class="font">= [[x] | x &lt;- xs]</span></p>
<p class="code"><span class="font">cols (xs:xss) = zipWith (:) xs (cols xss)</span></p>
</div>
<p class="para">It is usual in matrix algebra to suppose that the matrix is nonempty, and that certainly suffices here, but it is interesting to consider what happens if we allow <i class="calibre1">m</i> or <i class="calibre1">n</i> to be zero. This point is taken up in the exercises.</p>
<p class="para">The function <span class="font">boxs</span> is a little more interesting. We give the definition first and explain it afterwards:</p>
<div class="space1">
<p class="code"><span class="font">boxs :: Matrix a -&gt; Matrix a</span></p>
<p class="code"><span class="font">boxs = map ungroup . ungroup .</span></p>
<p class="code3"><span class="font">map cols .</span></p>
<p class="code3"><span class="font">group . map group</span></p>
</div>
<p class="para">The function <span class="font">group</span> splits a list into groups of three:</p>
<p class="code"><span class="font">group :: [a] -&gt; [[a]]</span></p>
<p class="code"><a id="text/part0009.html.page_95" class="calibre3"></a><span class="font">group [] = []</span></p>
<p class="code"><span class="font">group xs = take 3 xs:group (drop 3 xs)</span></p>
<p class="para">The function <span class="font">ungroup</span> takes a grouped list and ungroups it:</p>
<div class="space1">
<p class="code"><span class="font">ungroup :: [[a]] -&gt; [a]</span></p>
<p class="code"><span class="font">ungroup = concat</span></p>
</div>
<p class="para">The action of <span class="font">boxs</span> in the 4 × 4 case, when <span class="font">group</span> splits a list into groups of two rather than three, is illustrated by the picture</p>
<p class="equationasimage"><img src="data:image/jpeg;base64,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" alt="image" class="calibre2"></p>
<p class="para">Grouping produces a list of matrices; transposing each matrix and ungrouping yields the boxes, as a matrix whose rows are the boxes of the original matrix.</p>
<h3 class="h" id="text/part0009.html.head5-2">5.2 Lawful program construction</h3>
<p class="para">Observe that instead of thinking about matrices in terms of indices, and doing arithmetic on indices to identify the rows, columns and boxes, we have gone for definitions of these functions that treat the matrix as a complete entity in itself. This style has aptly been called <i class="calibre1">wholemeal programming</i>. Wholemeal programming is good for you: it helps to prevent a disease called indexitis, and encourages lawful program construction.</p>
<p class="para">For example, here are three laws that are valid on Sudoku grids:</p>
<div class="space1">
<p class="code"><span class="font">rows . rows = id</span></p>
<p class="code"><span class="font">cols . cols = id</span></p>
<p class="code"><span class="font">boxs . boxs = id</span></p>
</div>
<p class="para">In other words, all three functions are involutions. The first two are valid on all matrices, and the third is valid on arbitrary <i class="calibre1">n</i><sup class="calibre8">2</sup> × <i class="calibre1">n</i><sup class="calibre8">2</sup> matrices (provided we change <a id="text/part0009.html.page_96" class="calibre3"></a>the definition of <span class="font">group</span> to group by <i class="calibre1">n</i>). Two are easy to prove, but one is more difficult. The difficult law is not the one about <span class="font">boxs</span>, as you might expect, but the involution property of <span class="font">cols</span>. Though it is intuitively obvious that transposing a matrix twice gets you back to the original matrix, proving it from the definition of <span class="font">cols</span> is a little tricky and we won’t go into details, basically because we haven’t yet discussed the tools available to do the job.</p>
<p class="para">By contrast, here is the proof of the involution property of <span class="font">boxs</span>. The proof is by simple equational reasoning. It makes use of various laws, including the functor laws of <span class="font">map</span>, the fact that <span class="font">id</span> is the identity element of composition, and the facts that</p>
<div class="space1">
<p class="code"><span class="font">ungroup . group = id</span></p>
<p class="code"><span class="font">group . ungroup = id</span></p>
</div>
<p class="para">The second equation is valid only on grouped lists, but that will be the case in the calculation to come.</p>
<p class="para">We will talk through the proof rather than lay everything out in a long chain. The starting point is to use the definition of <span class="font">boxs</span> to rewrite <span class="font">boxs . boxs</span>:</p>
<div class="space1">
<p class="code"><span class="font">map ungroup . ungroup . map cols . group . map group .</span></p>
<p class="code"><span class="font">map ungroup . ungroup . map cols . group . map group</span></p>
</div>
<p class="para">The middle expression <span class="font">map group . map ungroup</span> simplifies to <span class="font">id</span> using the functor law of <span class="font">map</span> and the property that <span class="font">group</span> and <span class="font">ungroup</span> are inverses. That gives</p>
<div class="space1">
<p class="code"><span class="font">map ungroup . ungroup . map cols . group .</span></p>
<p class="code"><span class="font">ungroup . map cols . group . map group</span></p>
</div>
<p class="para">An appeal to <span class="font">group . ungroup = id</span> gets us to</p>
<div class="space1">
<p class="code"><span class="font">map ungroup . ungroup . map cols .</span></p>
<p class="code"><span class="font">map cols . group . map group</span></p>
</div>
<p class="para">The functor law of <span class="font">map</span> and the involution property of <span class="font">cols</span> now gets us to</p>
<p class="code"><span class="font">map ungroup . ungroup . group . map group</span></p>
<p class="para">And the proof is finished off using <span class="font">ungroup . group = id</span> twice more. As you can see, it’s a very simple calculation.</p>
<p class="para">Here are three more laws, valid on <i class="calibre1">N</i><sup class="calibre8">2</sup> × <i class="calibre1">N</i><sup class="calibre8">2</sup> matrices of choices:</p>
<p class="code"><span class="font">map rows . expand = expand . rows</span></p>
<p class="code"><span class="font">map cols . expand = expand . cols</span></p>
<p class="code"><a id="text/part0009.html.page_97" class="calibre3"></a><span class="font">map boxs . expand = expand . boxs</span></p>
<p class="para">We will make use of these laws in a short while.</p>
<p class="para">Finally, here are two laws about <span class="font">cp</span>:</p>
<div class="space1">
<p class="code"><span class="font">map (map f) . cp</span><span class="space1a"></span><span class="font">= cp . map (map f)</span></p>
<p class="code"><span class="font">filter (all p) . cp = cp . map (filter p)</span></p>
</div>
<p class="para">The first law, a naturality law, is suggested solely by the type of <span class="font">cp</span>; we saw similar laws in the previous chapter. The second law says that as an alternative to taking the cartesian product of a list of lists, and then retaining only those lists all of whose elements satisfy <span class="font">p</span>, we can first filter the original lists to retain only those elements that satisfy <span class="font">p</span> and then take the cartesian product. As the previous sentence illustrates, one equation can be worth a thousand words.</p>
<h3 class="h" id="text/part0009.html.head5-3">5.3 Pruning the matrix of choices</h3>
<p class="para">Summarising what we have at the moment,</p>
<div class="space1">
<p class="code"><span class="font">solve :: Grid -&gt; [Grid]</span></p>
<p class="code"><span class="font">solve = filter valid . expand . choices</span></p>
</div>
<p class="para">Though executable in theory, this definition of <span class="font">solve</span> is hopeless in practice. Assuming about 20 of the 81 entries are fixed initially, there are about 9<sup class="calibre8">61</sup>, or</p>
<p class="code6"><span class="font">ghci&gt; 9^61</span></p>
<p class="code6"><span class="font">16173092699229880893718618465586445357583280647840659957609</span></p>
<p class="para">grids to check! We therefore need a better approach.</p>
<p class="para">To make a more efficient solver, an obvious idea is to remove any choices from a cell <i class="calibre1">c</i> that already occur as singleton entries in the row, column and box containing <i class="calibre1">c</i>. A singleton entry corresponds to a fixed choice. We therefore seek a function</p>
<p class="code"><span class="font">prune :: Matrix [Digit] -&gt; Matrix [Digit]</span></p>
<p class="para">so that</p>
<p class="code"><span class="font">filter valid . expand = filter valid . expand . prune</span></p>
<p class="para">How can we define <span class="font">prune</span>? Well, since a matrix is a list of rows, a good place to start is by pruning a single row. The function <span class="font">pruneRow</span> is defined by</p>
<div class="space1">
<p class="code"><span class="font">pruneRow :: Row [Digit] -&gt; Row [Digit]</span></p>
<p class="code"><span class="font">pruneRow row = map (remove fixed) row</span></p>
</div>
<p class="code"><a id="text/part0009.html.page_98" class="calibre3"></a><span class="font">where fixed = [d | [d] &lt;- row]</span></p>
<p class="para">The fixed choices are the singleton entries in each row. The definition of <span class="font">fixed</span> uses a list comprehension involving a pattern: all elements of <span class="font">row</span> that are not singletons are discarded.</p>
<p class="para">The function <span class="font">remove</span> removes the fixed choices from any choice that is not fixed:</p>
<p class="code"><span class="font">remove :: [Digit] -&gt; [Digit] -&gt; [Digit]</span></p>
<p class="code"><span class="font">remove ds [x] = [x]</span></p>
<p class="code"><span class="font">remove ds xs</span><span class="space-toc1"></span><span class="font">= filter (`notElem` ds) xs</span></p>
<p class="para">The standard prelude function <span class="font">notElem</span> is defined by</p>
<div class="space1">
<p class="code"><span class="font">notElem :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool</span></p>
<p class="code"><span class="font">notElem x xs = all (/= x) xs</span></p>
</div>
<p class="para">Here are a couple of examples of the use of <span class="font">pruneRow</span>:</p>
<p class="code6"><span class="font">ghci&gt; pruneRow [[6],[1,2],[3],[1,3,4],[5,6]]</span></p>
<p class="code6"><span class="font">[[6],[1,2],[3],[1,4],[5]]</span></p>
<p class="para1"></p>
<p class="code6"><span class="font">ghci&gt; pruneRow [[6],[3,6],[3],[1,3,4],[4]]</span></p>
<p class="code6"><span class="font">[[6],[],[3],[1],[4]]</span></p>
<p class="para">In the first example, <span class="font">[6]</span> and <span class="font">[3]</span> are the fixed choices; removing these choices from the other entries reduces the last entry to a fixed choice. In the second example, removing the fixed choices reduces the second entry to the empty list of choices.</p>
<p class="para">The function <span class="font">pruneRow</span> satisfies the equation</p>
<p class="code"><span class="font">filter nodups . cp = filter nodups . cp . pruneRow</span></p>
<p class="para">In words, this equation says that pruning a row will not throw away any list that contains no duplicates. We will also make use of this law in a short while.</p>
<p class="para">We are now nearly ready for a calculation that will determine the function <span class="font">prune</span>. Nearly, but not quite because we are going to need two more laws: If <span class="font">f . f = id</span>, then</p>
<div class="space1">
<p class="code"><span class="font">filter (p . f) = map f . filter p . map f</span></p>
<p class="code"><span class="font">filter (p . f) . map f = map f . filter p</span></p>
</div>
<p class="para"><a id="text/part0009.html.page_99" class="calibre3"></a>The second law follows from the first (Why?). Here is the proof of the first law:</p>
<div class="space1">
<p class="code2"><span class="font">map f . filter p . map f</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{we proved in the previous chapter that</p>
<p class="code3"><span class="font">filter p . map f = map f . filter (p . f)</span>}</p>
<p class="code2"><span class="font">map f . map f . filter (p . f)</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{functor law of <span class="font">map</span> and <span class="font">f . f = id</span>}</p>
<p class="code"><span class="font">filter (p . f)</span></p>
</div>
<p class="para">Now for the main calculation. The starting point is to use the definition of <span class="font">valid</span> to rewrite the expression <span class="font">filter valid . expand</span> in the form</p>
<div class="space1">
<p class="code"><span class="font">filter valid . expand</span></p>
<p class="code2"><span class="font">= filter (all nodups . boxs) .</span></p>
<p class="code11"><span class="font">filter (all nodups . cols) .</span></p>
<p class="code11"><span class="font">filter (all nodups . rows) . expand</span></p>
</div>
<p class="para">The order in which the filters appear on the right is not important. The plan of attack is to send each of these filters into battle with <span class="font">expand</span>. For example, in the <span class="font">boxs</span> case we can calculate:</p>
<div class="space1">
<p class="code1"><span class="font">filter (all nodups . boxs) . expand</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{above law of <span class="font">filter</span>, since <span class="font">boxs . boxs = id</span>}</p>
<p class="code1"><span class="font">map boxs . filter (all nodups) . map boxs . expand</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{since <span class="font">map boxs . expand = expand . boxs</span>}</p>
<p class="code1"><span class="font">map boxs . filter (all nodups) . expand . boxs</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">expand</span>}</p>
<p class="code1"><span class="font">map boxs . filter (all nodups) . cp . map cp . boxs</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{since <span class="font">filter (all p) . cp = cp . map (filter p)</span>}</p>
<p class="code1"><span class="font">map boxs . cp . map (filter nodups) . map cp . boxs</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{functor law of <span class="font">map</span>}</p>
<p class="code1"><span class="font">map boxs . cp . map (filter nodups . cp) . boxs</span></p>
</div>
<p class="para">Now we use the property</p>
<p class="code"><span class="font">filter nodups . cp = filter nodups . cp . pruneRow</span></p>
<p class="para">to rewrite the final expression in the form</p>
<p class="code"><span class="font">map boxs . cp . map (filter nodups . cp . pruneRow) . boxs</span></p>
<p class="para"><a id="text/part0009.html.page_100" class="calibre3"></a>The remaining steps essentially repeat the calculation above, but in the reverse direction:</p>
<div class="space1">
<p class="code1"><span class="font">map boxs . cp . map (filter nodups . cp . pruneRow) . boxs</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{functor law of <span class="font">map</span>}</p>
<p class="code1"><span class="font">map boxs . cp . map (filter nodups) .</span></p>
<p class="code1"><span class="font">map (cp . pruneRow) . boxs</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{since <span class="font">cp . map (filter p) = filter (all p) . cp</span>}</p>
<p class="code1"><span class="font">map boxs . filter (all nodups) . cp .</span></p>
<p class="code1"><span class="font">map (cp . pruneRow) . boxs</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{functor law of <span class="font">map</span>}</p>
<p class="code1"><span class="font">map boxs . filter (all nodups) .</span></p>
<p class="code1"><span class="font">cp . map cp . map pruneRow . boxs</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">expand</span>}</p>
<p class="code1"><span class="font">map boxs . filter (all nodups) .</span></p>
<p class="code1"><span class="font">expand . map pruneRow . boxs</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{law of <span class="font">filter</span> since <span class="font">boxs . boxs = id</span>}</p>
<p class="code1"><span class="font">filter (all nodups . boxs) . map boxs .</span></p>
<p class="code1"><span class="font">expand . map pruneRow . boxs</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{since <span class="font">map boxs . expand = expand . boxs</span>}</p>
<p class="code1"><span class="font">filter (all nodups . boxs) . expand .</span></p>
<p class="code1"><span class="font">boxs . map pruneRow . boxs</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{introducing <span class="font">pruneBy f = f . pruneRow . f</span>}</p>
<p class="code1"><span class="font">filter (all nodups . boxs) . expand . pruneBy boxs</span></p>
</div>
<p class="para">We have shown that</p>
<p class="code"><span class="font">filter (all nodups . boxs) . expand</span></p>
<p class="code2"><span class="font">= filter (all nodups . boxs) . expand . pruneBy boxs</span></p>
<p class="para">where <span class="font">pruneBy f = f . map pruneRow . f</span>. Repeating the same calculation for rows and columns, we obtain</p>
<p class="code"><span class="font">filter valid . expand = filter valid . expand . prune</span></p>
<p class="para">where</p>
<p class="code"><span class="font">prune = pruneBy boxs . pruneBy cols . pruneBy rows</span></p>
<p class="para"><a id="text/part0009.html.page_101" class="calibre3"></a>In conclusion, the previous definition of <span class="font">solve</span> can now be replaced with a new one:</p>
<p class="code"><span class="font">solve = filter valid . expand . prune . choices</span></p>
<p class="para">In fact, rather than have just one <span class="font">prune</span> we can have as many prunes as we like. This is sensible because after one round of pruning some choices may be resolved into singleton choices and another round of pruning may remove still more impossible choices.</p>
<p class="para">So, let us define</p>
<div class="space1">
<p class="code"><span class="font">many :: (Eq a) =&gt; (a -&gt; a) -&gt; a -&gt; a</span></p>
<p class="code"><span class="font">many f x = if x == y then x else many f y</span></p>
<p class="code12"><span class="font">where y = f x</span></p>
</div>
<p class="para">and redefine <span class="font">solve</span> once again to read</p>
<p class="code"><span class="font">solve = filter valid . expand . many prune . choices</span></p>
<p class="para">The simplest Sudoku problems are solved just by repeatedly pruning the matrix of choices until only singleton choices are left.</p>
<h3 class="h" id="text/part0009.html.head5-4">5.4 Expanding a single cell</h3>
<p class="para">The result of <span class="font">many prune . choices</span> is a matrix of choices that can be put into one of three classes:</p>
<p class="number">1.<span class="space"></span>A <i class="calibre1">complete</i> matrix in which every entry is a singleton choice. In this case <span class="font">expand</span> will extract a single grid that can be checked for validity.</p>
<p class="number">2.<span class="space"></span>A matrix that contains the empty choice somewhere. In this case <span class="font">expand</span> will produce the empty list.</p>
<p class="number">3.<span class="space"></span>A matrix that does not contain the empty choice but does contain some entry with two or more choices.</p>
<p class="para">The problem is what to do in the third case. Rather than carry out full expansion, a more sensible idea is to make use of a partial expansion that installs the choices for just one of the entries, and to start the pruning process again on each result. The hope is that mixing pruning with single-cell expansions can lead to a solution more quickly. Our aim therefore is to construct a partial function</p>
<p class="code"><span class="font">expand1 :: Matrix [Digit] -&gt; [Matrix [Digit]]</span></p>
<p class="para"><a id="text/part0009.html.page_102" class="calibre3"></a>that expands the choices for one cell only. This function will return well-defined results only for incomplete matrices, and on such matrices is required to satisfy</p>
<p class="code"><span class="font">expand = concat . map expand . expand1</span></p>
<p class="para">Actually this equality between two lists is too strong. We want to ensure that no possible choice is lost by partial expansion, but do not really care about the precise order in which the two sides deliver their results. So we will interpret the equation as asserting the equality of the two sides up to some permutation of the answers.</p>
<p class="para">Which cell should we perform expansion on? The simplest answer is to find the first cell in the matrix with a non-singleton entry. Think of a matrix <span class="font">rows</span> broken up as follows:</p>
<div class="space1">
<p class="code"><span class="font">rows = rows1 ++ [row] ++ rows2</span></p>
<p class="code"><span class="font">row = row1 ++ [cs] ++ row2</span></p>
</div>
<p class="para">The cell <span class="font">cs</span> is a non-singleton list of choices in the middle of <span class="font">row</span>, which in turn is in the middle of the matrix <span class="font">rows</span>.</p>
<p class="para">Then we can define</p>
<div class="space1">
<p class="code"><span class="font">expand1 :: Matrix [Digit] -&gt; [Matrix [Digit]]</span></p>
<p class="code"><span class="font">expand1 rows</span></p>
<p class="code2"><span class="font">= [rows1 ++ [row1 ++ [c]:row2] ++ rows2 | c &lt;- cs]</span></p>
</div>
<p class="para">To break up the matrix in this way, we use the prelude function <span class="font">break</span>:</p>
<p class="code"><span class="font">break :: (a -&gt; Bool) -&gt; [a] -&gt; ([a],[a])</span></p>
<p class="code"><span class="font">break p = span (not . p)</span></p>
<p class="para">The function <span class="font">span</span> was defined in <a href="#text/part0008.html.head4-8" class="calibre3">Section 4.8</a>. For example,</p>
<p class="code6"><span class="font">ghci&gt; break even [1,3,7,6,2,3,5]</span></p>
<p class="code6"><span class="font">([1,3,7],[6,2,3,5])</span></p>
<p class="para">We also need the standard prelude function <span class="font">any</span>, defined by</p>
<div class="space1">
<p class="code"><span class="font">any :: (a -&gt; Bool) -&gt; [a] -&gt; Bool</span></p>
<p class="code"><span class="font">any p = or . map p</span></p>
</div>
<p class="para">where <span class="font">or</span> takes a list of booleans and returns <span class="font">True</span> if any element is <span class="font">True</span>, and <span class="font">False</span> otherwise:</p>
<div class="space1">
<p class="code"><span class="font">or :: [Bool] -&gt; Bool</span></p>
<p class="code"><span class="font">or []</span><span class="space4"></span><span class="font">= False</span></p>
<p class="code"><span class="font">or (x:xs) = x || or xs</span></p>
</div>
<p class="para"><a id="text/part0009.html.page_103" class="calibre3"></a>Finally, the <span class="font">single</span> test is defined (using don’t care patterns) by</p>
<div class="space1">
<p class="code"><span class="font">single :: [a] -&gt; Bool</span></p>
<p class="code"><span class="font">single [_] = True</span></p>
<p class="code"><span class="font">single _</span><span class="space-b"></span><span class="font">= False</span></p>
</div>
<p class="para">Now we can define</p>
<div class="space1">
<p class="code"><span class="font">expand1 :: Matrix [Digit] -&gt; [Matrix [Digit]]</span></p>
<p class="code"><span class="font">expand1 rows</span></p>
<p class="code"><span class="font">= [rows1 ++ [row1 ++ [c]:row2] ++ rows2 | c &lt;- cs]</span></p>
<p class="code"><span class="space-toc1"></span><span class="font">where</span></p>
<p class="code"><span class="space-toc1"></span><span class="font">(rows1,row:rows2) = break (any (not . single)) rows</span></p>
<p class="code"><span class="space-toc1"></span><span class="font">(row1,cs:row2) = break (not . single) row</span></p>
</div>
<p class="para">The first <span class="font">where</span> clause breaks a matrix into two lists of rows with the row at the head of the second list being one that contains a non-singleton choice. A second appeal to <span class="font">break</span> then breaks this row into two lists, with the head of the second list being the first non-singleton element. If the matrix contains only singleton entries, then</p>
<p class="code"><span class="font">break (any (not . single)) rows = [rows,[]]</span></p>
<p class="para">and execution of <span class="font">expand1</span> returns an error message.</p>
<p class="para">The problem with this definition of <span class="font">expand1</span> is that it can lead to wasted work. If the first non-singleton entry found in this way happens to be the empty list, then <span class="font">expand1</span> will return the empty list, but if such a list is buried deep in the matrix, then <span class="font">expand1</span> will do a lot of useless calculation trying to find a solution that isn’t there. It is arguable that a better choice of cell on which to perform expansion is one with the <i class="calibre1">smallest</i> number of choices (not equal to 1 of course). A cell with no choices means that the puzzle is unsolvable, so identifying such a cell quickly is a good idea.</p>
<p class="para">The change to <span class="font">expand1</span> to implement this idea is as follows:</p>
<div class="space1">
<p class="code"><span class="font">expand1 :: Matrix [Digit] -&gt; [Matrix [Digit]]</span></p>
<p class="code"><span class="font">expand1 rows</span></p>
<p class="code2"><span class="font">= [rows1 ++ [row1 ++ [c]:row2] ++ rows2 | c &lt;- cs]</span></p>
<p class="code11"><span class="space-r"></span><span class="font">where</span></p>
<p class="code11"><span class="space-r"></span><span class="font">(rows1,row:rows2) = break (any smallest) rows</span></p>
<p class="code11"><span class="space-r"></span><span class="font">(row1,cs:row2)</span><span class="space1a"></span><span class="font">= break smallest row</span></p>
<p class="code11"><span class="space-r"></span><span class="font">smallest cs</span><span class="space2"></span><span class="font">= length cs == n</span></p>
<p class="code11"><span class="space-r"></span><span class="font">n</span><span class="space6"></span><span class="font">= minimum (counts rows)</span></p>
</div>
<p class="para"><a id="text/part0009.html.page_104" class="calibre3"></a>The function <span class="font">counts</span> is defined by</p>
<p class="code"><span class="font">counts = filter (/= 1) . map length . concat</span></p>
<p class="para">The value <span class="font">n</span> is the smallest number of choices, not equal to 1, in any cell of the matrix of choices. We will leave the definition of <span class="font">minimum</span> as an exercise. The value of <span class="font">n</span> will be 0 if the matrix has an empty choice entry anywhere, and in this case <span class="font">expand1</span> will return the empty list. On the other hand, if the matrix of choices contains only singleton choices, then <span class="font">n</span> is the minimum of the empty list, which is the undefined value ⊥. In this case <span class="font">expand1</span> will also return ⊥, so we had better ensure that <span class="font">expand1</span> is applied only to incomplete matrices. A matrix is incomplete if it does not satisfy <span class="font">complete</span>:</p>
<div class="space1">
<p class="code"><span class="font">complete :: Matrix [Digit] -&gt; Bool</span></p>
<p class="code"><span class="font">complete = all (all single)</span></p>
</div>
<p class="para">We can also usefully generalise <span class="font">valid</span> to a test on matrices of choices. Suppose we define <span class="font">safe</span> by</p>
<div class="space1">
<p class="code"><span class="font">safe :: Matrix [Digit] -&gt; Bool</span></p>
<p class="code"><span class="font">safe m = all ok (rows cm) &amp;&amp;</span></p>
<p class="code1"><span class="font">all ok (cols cm) &amp;&amp;</span></p>
<p class="code1"><span class="font">all ok (boxs cm)</span></p>
<p class="code"><span class="font">ok row = nodups [x | [x] &lt;- row]</span></p>
</div>
<p class="para">A matrix is safe if none of the singleton choices in any row, column or box contain duplicates. But a safe matrix may contain non-singleton choices. Pruning can turn a safe matrix into an unsafe one, but if a matrix is safe after pruning it has to be safe beforehand. In symbols, <span class="font">safe . prune = safe</span>. A complete and safe matrix yields a solution to the Sudoku problem, and this solution can be extracted by a simplified version of <span class="font">expand</span>:</p>
<div class="space1">
<p class="code"><span class="font">extract :: Matrix [Digit] -&gt; Grid</span></p>
<p class="code"><span class="font">extract = map (map head)</span></p>
</div>
<p class="para">Hence on a safe and complete matrix <span class="font">m</span> we have</p>
<p class="code"><span class="font">filter valid (expand m) = [extract m]</span></p>
<p class="para">On a safe but incomplete matrix we have</p>
<div class="space1">
<p class="code2"><span class="font">filter valid . expand</span></p>
<p class="code"><span class="font">= filter valid . concat . map expand . expand1</span></p>
</div>
<p class="para">up to permutation of each side. Since</p>
<p class="code"><a id="text/part0009.html.page_105" class="calibre3"></a><span class="font">filter p . concat = concat . map (filter p)</span></p>
<p class="para">we obtain that <span class="font">filter valid . expand</span> simplifies to</p>
<p class="code"><span class="font">concat . map (filter p . expand) . expand1</span></p>
<p class="para">And now we can insert a single <span class="font">prune</span> to obtain</p>
<p class="code"><span class="font">concat . map (filter p . expand . prune) . expand1</span></p>
<p class="para">Hence, introducing</p>
<p class="code"><span class="font">search = filter valid . expand . prune</span></p>
<p class="para">we have, on safe but incomplete matrices, that</p>
<p class="code"><span class="font">search = concat . map search . expand1 . prune</span></p>
<p class="para">And now we can replace <span class="font">solve</span> by a third version:</p>
<div class="space1">
<p class="code"><span class="font">solve = search . choices</span></p>
<p class="code"><span class="font">search cm</span></p>
<p class="code2"><span class="font">| not (safe pm) = []</span></p>
<p class="code2"><span class="font">| complete pm</span><span class="space5"></span><span class="font">= [extract pm]</span></p>
<p class="code2"><span class="font">| otherwise</span><span class="space4"></span><span class="font">= concat (map search (expand1 pm))</span></p>
<p class="code2"><span class="font">where pm = prune cm</span></p>
</div>
<p class="para">This is our final simple Sudoku solver. We could replace <span class="font">prune</span> in the last line by <span class="font">many prune</span>. Sometimes many prunes work faster than one prune; sometimes not. Note that the very first safety test occurs immediately after one round of pruning on the installed choices; consequently flawed input is detected quickly.</p>
<h3 class="h" id="text/part0009.html.head5-5">5.5 Exercises</h3>
<p class="theorem"><b class="calibre7">Exercise A</b></p>
<p class="para">How would you add 1 to every element in a given matrix of integers? How would you sum the elements of a matrix? The function <span class="font">zipWith (+)</span> adds two rows, but what function would add two matrices? How would you define matrix multiplication?</p>
<p class="theorem"><b class="calibre7">Exercise B</b></p>
<p class="para">What are the dimensions of the matrix <span class="font">[[],[]]</span>? Of the matrix <span class="font">[]</span>?</p>
<p class="para">The function <span class="font">cols</span> (here renamed as <span class="font">transpose</span>) was defined by</p>
<div class="space1">
<p class="code"><a id="text/part0009.html.page_106" class="calibre3"></a><span class="font">transpose :: [[a]] -&gt; [[a]]</span></p>
<p class="code"><span class="font">transpose [xs]</span><span class="space4"></span><span class="font">= [[x] | x &lt;- xs]</span></p>
<p class="code"><span class="font">transpose (xs:xss) = zipWith (:) xs (transpose xss)</span></p>
</div>
<p class="para">Fill in the dots that would enable you to replace the first clause by</p>
<p class="code"><span class="font">transpose [] = ...</span></p>
<p class="para">The above definition of <span class="font">transpose</span> proceeds row by row. Here is part of a definition that proceeds column by column:</p>
<p class="code"><span class="font">transpose xss = map head xss:transpose (map tail xss)</span></p>
<p class="para">Complete this definition.</p>
<p class="theorem"><b class="calibre7">Exercise C</b></p>
<p class="para">Which of the following equations are true (no justification is necessary):</p>
<div class="space1">
<p class="code"><span class="font">any p = not . all (not p)</span></p>
<p class="code"><span class="font">any null = null . cp</span></p>
</div>
<p class="theorem"><b class="calibre7">Exercise D</b></p>
<p class="para">Given a function <span class="font">sort :: (Ord a) =&gt; [a] -&gt; [a]</span> that sorts a list, construct a definition of</p>
<p class="code"><span class="font">nodups :: (Ord a) =&gt; [a] -&gt; Bool</span></p>
<p class="theorem"><b class="calibre7">Exercise E</b></p>
<p class="para">The function <span class="font">nub :: (Eq a) =&gt; [a] -&gt; [a]</span> removes duplicates from a list (a version of this function is available in the library <span class="font">Data.List</span>). Define <span class="font">nub</span>. Assuming the order of the elements in the result is not important, define</p>
<p class="code"><span class="font">nub :: (Ord a) =&gt; [a] -&gt; [a]</span></p>
<p class="para">so that the result is a more efficient function.</p>
<p class="theorem"><b class="calibre7">Exercise F</b></p>
<p class="para">The functions <span class="font">takeWhile</span> and <span class="font">dropWhile</span> satisfy</p>
<p class="code"><span class="font">span p xs = (takeWhile p xs,dropWhile p xs)</span></p>
<p class="para">Give direct recursive definitions of <span class="font">takeWhile</span> and <span class="font">dropWhile</span>.</p>
<p class="para">Assuming <span class="font">whiteSpace :: Char -&gt; Bool</span> is a test for whether a character is <a id="text/part0009.html.page_107" class="calibre3"></a>white space (such as a space, a tab or a newline) or a visible character, construct a definition of</p>
<p class="code"><span class="font">words :: String -&gt; [Word]</span></p>
<p class="para">that breaks a string up into a list of words.</p>
<p class="theorem"><b class="calibre7">Exercise G</b></p>
<p class="code">Define <span class="font">minimum :: Ord a =&gt; [a] -&gt; a</span>.</p>
<p class="theorem"><b class="calibre7">Exercise H</b></p>
<p class="para">Why didn’t we define <span class="font">solve</span> By The Following?</p>
<div class="space1">
<p class="code"><span class="font">solve = search . choices</span></p>
<p class="code"><span class="font">search m</span></p>
<p class="code2"><span class="font">| not (safe m)</span><span class="space"></span><span class="font">= []</span></p>
<p class="code2"><span class="font">| complete m</span><span class="space5"></span><span class="font">= [extract m]</span></p>
<p class="code2"><span class="font">| otherwise</span><span class="space1b"></span><span class="font">= process m</span></p>
<p class="code2"><span class="font">where process = concat . map search . expand1 . prune</span></p>
</div>
<h3 class="h" id="text/part0009.html.head5-6">5.6 Answers</h3>
<p class="theorem"><b class="calibre7">Answer to Exercise A</b></p>
<p class="para">Adding 1 to every matrix element is defined by <span class="font">map (map (+1))</span>.</p>
<p class="para">Summing a matrix is defined by <span class="font">sum . map sum</span>, where <span class="font">sum</span> sums a list of numbers. Alternatively, we could use <span class="font">sum . concat</span>.</p>
<p class="para">Matrix addition is defined by <span class="font">zipWith (zipWith (+))</span>.</p>
<p class="para">For matrix multiplication we first define</p>
<div class="space1">
<p class="code"><span class="font">scalarMult :: Num a =&gt; [a] -&gt; [a] -&gt; a</span></p>
<p class="code"><span class="font">scalarMult xs ys = sum (zipwith (*) xs ys)</span></p>
</div>
<p class="para">Then we have</p>
<div class="space1">
<p class="code"><span class="font">matMult :: Num a =&gt; Matrix a -&gt; Matrix a -&gt; Matrix a</span></p>
<p class="code"><span class="font">matMult ma mb = [map (scalarMult row) mbt | row &lt;- ma]</span></p>
<p class="code14"><span class="font">where mbt = transpose mb</span></p>
</div>
<p class="theorem"><a id="text/part0009.html.page_108" class="calibre3"></a><b class="calibre7">Answer to Exercise B</b></p>
<p class="para">The matrix <span class="font">[[],[]]</span> has dimensions 2 × 0. The matrix <span class="font">[]</span> has dimensions 0 × <i class="calibre1">n</i> for every <i class="calibre1">n</i>. The transpose of such a matrix therefore has to have dimensions <i class="calibre1">n</i> × 0 for every <i class="calibre1">n</i>. The only reasonable possibility is to let <i class="calibre1">n</i> be infinite:</p>
<div class="space1">
<p class="code"><span class="font">transpose :: [[a]] -&gt; [[a]]</span></p>
<p class="code"><span class="font">transpose []</span><span class="space2"></span><span class="font">= repeat []</span></p>
<p class="code"><span class="font">transpose (xs:xss) = zipWith (:) xs (transpose xss)</span></p>
</div>
<p class="para">where <span class="font">repeat x</span> gives an infinite list of repetitions of <span class="font">x</span>. Note that</p>
<div class="space1">
<p class="code"><span class="font">transpose [xs] = zipWith (:) xs (repeat [])</span></p>
<p class="code9"><span class="space-r"></span><span class="font">= [[x] | x &lt;- xs]</span></p>
</div>
<p class="para">The alternative definition is</p>
<div class="space1">
<p class="code"><span class="font">transpose ([]:xss) = []</span></p>
<p class="code"><span class="font">transpose xss = map head xss:transpose (map tail xss)</span></p>
</div>
<p class="para">The assumption in the first line is that if the first row is empty, then all the rows are empty and the transpose is the empty matrix.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise C</b></p>
<p class="para">Both the equations are true.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise D</b></p>
<div class="space1">
<p class="code"><span class="font">nodups :: (Ord a) =&gt; [a] -&gt; Bool</span></p>
<p class="code"><span class="font">nodups xs = and (zipWith (/=) ys (tail ys))</span></p>
<p class="code12"><span class="font">where ys = sort xs</span></p>
</div>
<p class="theorem"><b class="calibre7">Answer to Exercise E</b></p>
<div class="space1">
<p class="code"><span class="font">nub :: (Eq a) =&gt; [a] -&gt; [a]</span></p>
<p class="code"><span class="font">nub []</span><span class="space4"></span><span class="font">= []</span></p>
<p class="code"><span class="font">nub (x:xs) = x:nub (filter (/= x) xs)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">nub :: (Ord a) =&gt; [a] -&gt; [a]</span></p>
<p class="code"><span class="font">nub = remdups . sort</span></p>
<p class="para1"></p>
<p class="code"><span class="font">remdups []</span><span class="space4"></span><span class="font">= []</span></p>
<p class="code"><span class="font">remdups (x:xs) = x:remdups (dropWhile (==x) xs)</span></p>
</div>
<p class="para">The function <span class="font">dropWhile</span> is defined in the next exercise.</p>
<p class="theorem"><a id="text/part0009.html.page_109" class="calibre3"></a><b class="calibre7">Answer to Exercise F</b></p>
<div class="space1">
<p class="code"><span class="font">takeWhile, dropWhile :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</span></p>
<p class="code"><span class="font">takeWhile p [] = []</span></p>
<p class="code"><span class="font">takeWhile p (x:xs)</span></p>
<p class="code12"><span class="font">= if p x then x:takeWhile p xs else []</span></p>
<p class="code"><span class="font">dropWhile p [] = []</span></p>
<p class="code"><span class="font">dropWhile p (x:xs)</span></p>
<p class="code12"><span class="font">= if p x then dropWhile p xs else x:xs</span></p>
<p class="para">The definition of <span class="font">words</span> is</p>
<p class="code"><span class="font">words :: String -&gt; [Word]</span></p>
<p class="code"><span class="font">words xs | null ys = []</span></p>
<p class="code1">&nbsp;<span class="font">| otherwise = w:words zs</span></p>
<p class="code1"><span class="space-r"></span><span class="font">where ys = dropWhile whiteSpace xs</span></p>
<p class="code4"><span class="font">(w,zs) = break whiteSpace ys</span></p>
</div>
<p class="theorem"><b class="calibre7">Answer to Exercise G</b></p>
<p class="code"><span class="font">minimum :: Ord a =&gt; [a] -&gt; a</span></p>
<p class="code"><span class="font">minimum [x]</span><span class="space1b"></span><span class="font">= x</span></p>
<p class="code"><span class="font">minimum (x:xs) = x `min` minimum xs</span></p>
<p class="para">Note that the minimum of the empty list is undefined.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise H</b></p>
<p class="para">The suggested definition of <span class="font">solve</span> would return the undefined value if the matrix becomes complete after one round of pruning.</p>
<h3 class="h" id="text/part0009.html.head5-7">5.7 Chapter notes</h3>
<p class="para">The <i class="calibre1">Independent</i> newspaper no longer uses the rubric for Sudoku quoted at the start of the chapter. The presentation follows that in my book <i class="calibre1">Pearls of Functional Algorithm Design</i> (Cambridge, 2010). The site</p>
<p class="code"><span class="font"><a href="http://haskell.org/haskellwiki/Sudoku" class="calibre3">haskell.org/haskellwiki/Sudoku</a></span></p>
<p class="para">contains about 20 Haskell implementations of Sudoku, many of which use arrays and/or monads. We will meet arrays and monads in <a href="#text/part0014.html.DB7S0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 10</a>.</p>
</div></div>
<div id="text/part0010.html"><div id="text/part0010.html.9H5K0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre">

<h2 class="chapter-number" id="text/part0010.html.calibre_pb_0"><a id="text/part0010.html.page_110" class="calibre6"></a>Chapter 6</h2>
<h2 class="chapter-title">Proofs</h2>
<p class="para">We have seen a lot of laws in the previous two chapters, though perhaps the word ‘law’ is a little inappropriate because it suggests something that is given to us from on high and which does not have to be proved. At least the word has the merit of being short. All of the laws we have encountered so far assert the equality of two functional expressions, possibly under subsidiary conditions; in other words, laws have been equations or <i class="calibre1">identities</i> between functions, and calculations have been point-free calculations (see <a href="#text/part0008.html.7K4G0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 4</a>, and the answer to Exercise K for more on the point-free style). Given suitable laws to work with, we can then use equational reasoning to prove other laws. Equational logic is a simple but powerful tool in functional programming because it can guide us to new and more efficient definitions of the functions and other values we have constructed. Efficiency is the subject of the following chapter. This one is about another aspect of equational reasoning, proof by induction. We will also show how to shorten proofs by introducing a number of <i class="calibre1">higher-order</i> functions that capture common patterns of computations. Instead of proving properties of similar functions over and over again, we can prove more general results about these higher-order functions, and appeal to them instead.</p>
<h3 class="h" id="text/part0010.html.head6-1">6.1 Induction over natural numbers</h3>
<p class="para">Consider the following definition of the exponential function:</p>
<p class="code"><span class="font">exp :: Num a =&gt; a -&gt; Nat -&gt; a</span></p>
<p class="code"><span class="font">exp x Zero = 1</span></p>
<p class="code"><span class="font">exp x (Succ n) = x * exp x n</span></p>
<p class="para">In the old days we could have written</p>
<p class="code"><a id="text/part0010.html.page_111" class="calibre3"></a><span class="font">exp :: Num a =&gt; a -&gt; Int -&gt; a</span></p>
<p class="code"><span class="font">exp x 0 = 1</span></p>
<p class="code"><span class="font">exp x (n+1) = x * exp x n</span></p>
<p class="para">but this precise form of definition using a <span class="font">(n+1)</span>-pattern is no longer allowed in the current standard version of Haskell, Haskell 2010.</p>
<p class="para">Anyway, we would expect that the equation</p>
<p class="code"><span class="font">exp x (m+n) = exp x m * exp x n</span></p>
<p class="para">is true for all <span class="font">m</span> and <span class="font">n</span>. After all, <i class="calibre1">x</i><sup class="calibre8"><i class="calibre1">m</i>+<i class="calibre1">n</i></sup> = <i class="calibre1">x</i><sup class="calibre8"><i class="calibre1">m</i></sup> <i class="calibre1">x</i><sup class="calibre8"><i class="calibre1">n</i></sup> is a true equation of mathematics. But how can we prove this 
law?</p>
<p class="para">The answer, of course, is by <i class="calibre1">induction</i>. Every natural number is either <span class="font">Zero</span> or of the form <span class="font">Succ n</span> for some natural number <span class="font">n</span>. That is exactly what the definition</p>
<p class="code"><span class="font">data Nat = Zero | Succ Nat</span></p>
<p class="para">of the data type <span class="font">Nat</span> tells us. So to prove that <i class="calibre1">P</i>(<i class="calibre1">n</i>) holds for all natural numbers <i class="calibre1">n</i>, we can prove</p>
<p class="number">1.<span class="space"></span><i class="calibre1">P</i>(0) holds;</p>
<p class="number">2.<span class="space"></span>For all natural numbers <i class="calibre1">n</i>, that <i class="calibre1">P</i>(<i class="calibre1">n</i> + 1) holds assuming that <i class="calibre1">P</i>(<i class="calibre1">n</i>) does.</p>
<p class="para">We have reverted to writing 0 for <span class="font">Zero</span> and <i class="calibre1">n</i>+1 for <span class="font">Succ n</span>, and we shall continue to do so. In the second proof we can assume <i class="calibre1">P</i>(<i class="calibre1">n</i>) and use this assumption to prove <i class="calibre1">P</i>(<i class="calibre1">n</i> + 1).</p>
<p class="para">As an example we prove that</p>
<p class="code"><span class="font">exp x (m+n) = exp x m * exp x n</span></p>
<p class="para">for all <i class="calibre1">x</i>, <i class="calibre1">m</i> and <i class="calibre1">n</i> by induction on <i class="calibre1">m</i>. We could also prove it by induction on <i class="calibre1">n</i> but that turns out to be more complicated. Here is the proof:</p><p class="theorem"><b class="calibre7">Case</b> 0</p>
<p class="code2"><span class="font">exp x (0 + n)</span><span class="space4"></span><span class="font">exp x 0 * exp x n</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{since <span class="font">0 + n = n</span>}<span class="space"></span><span class="font">=</span><span class="space5"></span>{<span class="font">exp.1</span>}</p>
<p class="code2"><span class="font">exp x n</span><span class="space3"></span><span class="space-r"></span><span class="font">1 * exp x n</span></p>
<p class="code5"><span class="font">=</span><span class="space5"></span>{since <span class="font">1 * x = x</span>}</p>
<p class="code17"><span class="space-r"></span><span class="font">exp x n</span></p>
<p class="theorem"><a id="text/part0010.html.page_112" class="calibre3"></a><b class="calibre7">Case</b> <span class="font">m+1</span></p>
<p class="code2"><span class="font">exp x ((m + 1) + n))</span><span class="space2"></span><span class="font">exp x (m+1) * exp x n</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{arithmetic}<span class="space6"></span><span class="font">=</span><span class="space"></span>{<span class="font">exp.2</span>}</p>
<p class="code2"><span class="font">exp x ((m + n) + 1</span><span class="space8"></span><span class="font">(x * exp x m) * exp x n</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">exp.2</span>}<span class="space6"></span><span class="space"></span><span class="font">=</span><span class="space"></span>{since <span class="font">*</span> is associative}</p>
<p class="code2"><span class="font">x * exp x (m + n)</span><span class="space3"></span><span class="font">x * (exp x m * exp x n)</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{induction}</p>
<p class="code2"><span class="font">x * (exp x m * exp x n)</span></p>
<p class="para">The above format will be used in all induction proofs. The proof breaks into two cases, the <i class="calibre1">base case</i> 0 and the <i class="calibre1">inductive case n</i> + 1. Each case is laid out in two columns, one for the left-hand side of the equation, and one for the right-hand side. (When there is not enough space for two columns, we display one after the other.) Each side is simplified until one can go no further, and the proof of each case is completed by observing that each side simplifies to the same result. The hints <span class="font">exp.1</span> and <span class="font">exp.2</span> refer to the first and second equations defining <span class="font">exp</span>.</p>
<p class="para">Finally, observe that the proof depends on three further laws, namely that</p>
<p class="code"><span class="font">(m + 1) + n = (m + n) + 1</span></p>
<p class="code"><span class="font">1 * x</span><span class="space2"></span><span class="font">= x</span></p>
<p class="code"><span class="font">(x * y) * z = x * (y * z)</span></p>
<p class="para">If we were recreating all of arithmetic from scratch – and that would be a tedious thing to do – we would also have to prove these laws. In fact, only the first can be proved because it is entirely about natural numbers and we have defined the operation of addition on natural numbers. The second two rely on the implementation of multiplication prescribed by Haskell for the various instances of the type class <span class="font">Num</span>.</p>
<p class="para">In fact, the associative law breaks down for floating-point numbers:</p>
<p class="code6"><span class="font">ghci&gt; (9.9e10 * 0.5e-10) * 0.1e-10 :: Float</span></p>
<p class="code6"><span class="font">4.95e-11</span></p>
<p class="code6"><span class="font">ghci&gt; 9.9e10 * (0.5e-10 * 0.1e-10) :: Float</span></p>
<p class="code6"><span class="font">4.9499998e-11</span></p>
<p class="para">Recall that in scientific notation <span class="font">9.9e10</span> means <span class="font">9.9 * 10^10</span>. So, although our proof was correct mathematically, one of the provisos in it wasn’t, at least in Haskell.</p>
<h3 class="h" id="text/part0010.html.head6-2"><a id="text/part0010.html.page_113" class="calibre6"></a>6.2 Induction over lists</h3>
<p class="para">We have seen that every finite list is either the empty list <span class="font">[]</span> or of the form <span class="font">x:xs</span> where <span class="font">xs</span> is a finite list. Hence, to prove that <i class="calibre1">P</i>(<i class="calibre1">xs</i>) holds for all finite lists <i class="calibre1">xs</i>, we can prove:</p>
<p class="number">1.<span class="space"></span><i class="calibre1">P</i>(<span class="font">[]</span>) holds;</p>
<p class="number">2.<span class="space"></span>For all <span class="font">x</span> and for all finite lists <span class="font">xs</span>, that <i class="calibre1">P</i>(<span class="font">x:xs</span>) holds assuming <i class="calibre1">P</i>(<span class="font">xs</span>) does.</p>
<p class="para">As an example, recall the definition of concatenation <span class="font">(++)</span>:</p>
<p class="code"><span class="font">[] ++ ys = ys</span></p>
<p class="code"><span class="font">(x:xs) ++ ys = x : (xs ++ ys)</span></p>
<p class="para">We prove that <span class="font">++</span> is associative:</p>
<p class="code"><span class="font">(xs ++ ys) ++ zs = xs ++ (ys ++ zs)</span></p>
<p class="para">for all finite lists <span class="font">xs</span> and for all lists <span class="font">ys</span> and <span class="font">zs</span> (note that neither of the last two is required to be a finite list), by induction on <span class="font">xs</span>:</p>
<p class="theorem"><b class="calibre7">Case</b> <span class="font">[]</span></p>
<p class="code"><span class="space"></span><span class="font">([] ++ ys) ++</span><span class="space2"></span><span class="font">zs [] ++ (ys ++ zs)</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">++.1</span>}<span class="space7"></span><span class="font">=</span><span class="space5"></span>{<span class="font">++.1</span>}</p>
<p class="code"><span class="space"></span><span class="font">ys ++ zs</span><span class="space7"></span><span class="font">ys ++ zs</span></p>
<p class="theorem"><b class="calibre7">Case</b> <span class="font">x:xs</span></p>
<p class="code2"><span class="font">((x:xs) ++ ys) ++ zs</span><span class="space4"></span><span class="font">(x:xs) ++ (ys ++ zs)</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">++.2</span>}<span class="space6"></span><span class="space"></span><span class="font">=</span><span class="space"></span>{<span class="font">++.2</span>}</p>
<p class="code2"><span class="font">(x:(xs ++ ys)) ++ zs</span><span class="space4"></span><span class="font">x:(xs ++ (ys ++ zs))</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">++.2</span>}<span class="space6"></span><span class="space"></span><span class="font">=</span><span class="space"></span>{induction}</p>
<p class="code2"><span class="font">x:((xs ++ ys) ++ zs)</span><span class="space4"></span><span class="font">x:((xs ++ ys) ++ zs)</span></p>
<p class="para">As another example, given the definition</p>
<p class="code"><span class="font">reverse []</span><span class="space4"></span><span class="font">= []</span></p>
<p class="code"><span class="font">reverse (x:xs) = reverse xs ++ [x]</span></p>
<p class="para">We prove that <span class="font">reverse</span> is an involution:</p>
<p class="code"><span class="font">reverse (reverse xs) = xs</span></p>
<p class="para">for all finite lists <span class="font">xs</span>. The base case is easy and the inductive case proceeds:</p>
<p class="theorem"><a id="text/part0010.html.page_114" class="calibre3"></a><b class="calibre7">Case</b> <span class="font">x:xs</span></p>
<p class="code2"><span class="font">reverse (reverse (x:xs))</span></p>
<p class="code"><span class="font">=</span><span class="space"></span>{<span class="font">reverse.2</span>}</p>
<p class="code2"><span class="font">reverse (reverse xs ++ [x])</span></p>
<p class="code"><span class="font">=</span><span class="space"></span>{????}</p>
<p class="code2"><span class="font">x:reverse (reverse xs)</span></p>
<p class="code"><span class="font">=</span><span class="space"></span>{induction}</p>
<p class="code2"><span class="font">x:xs</span></p>
<p class="para">The right-hand column is omitted in this example, since it consists solely of <span class="font">x:xs</span>. But we got stuck in the proof halfway through. We need an auxiliary result, namely that</p>
<p class="code"><span class="font">reverse (ys ++ [x]) = x:reverse ys</span></p>
<p class="para">for all finite lists <span class="font">ys</span>. This auxiliary result is also proved by induction:</p>
<p class="theorem"><b class="calibre7">Case</b> <span class="font">[]</span></p>
<p class="code2"><span class="font">reverse ([] ++ [x])</span><span class="space5"></span><span class="space-r"></span><span class="font">x:reverse []</span></p>
<p class="code"><span class="font">=</span><span class="space"></span>{<span class="font">++.1</span>}<span class="space7"></span><span class="space1a"></span><span class="font">=</span><span class="space"></span>{<span class="font">reverse.1</span>}</p>
<p class="code2"><span class="font">reverse [x]</span><span class="space3"></span><span class="space"></span><span class="font">[x]</span></p>
<p class="code"><span class="font">=</span><span class="space"></span>{<span class="font">reverse.2</span>}</p>
<p class="code2"><span class="font">reverse [] ++ [x]</span></p>
<p class="code"><span class="font">=</span><span class="space"></span>{<span class="font">reverse.1</span> and <span class="font">++.1</span>}</p>
<p class="code2"><span class="font">[x]</span></p>
<p class="theorem"><b class="calibre7">Case</b> <span class="font">y:ys</span></p>
<p class="code2"><span class="font">reverse ((y:ys) ++ [x])</span><span class="space5"></span><span class="font">x:reverse (y:ys)</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">++.2</span>}<span class="space6"></span><span class="font">=</span><span class="space"></span>{<span class="font">reverse.2</span>}</p>
<p class="code2"><span class="font">reverse (y:(ys ++ [x]))</span><span class="space5"></span><span class="font">x:(reverse ys ++ [y])</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">reverse.2</span>}</p>
<p class="code2"><span class="font">reverse (ys ++ [x]) ++ [y]</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{induction}</p>
<p class="code2"><span class="font">(x:reverse ys) ++ [y]</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">++.2</span>}</p>
<p class="code2"><span class="font">x:(reverse ys ++ [y])</span></p>
<p class="para"><a id="text/part0010.html.page_115" class="calibre3"></a>The auxiliary result holds, and therefore so does the main result.</p>
<p class="center"><i class="calibre1">Induction over partial lists</i></p>
<p class="para">Every partial list is either the undefined list or of the form <span class="font">x:xs</span> for some <span class="font">x</span> and some partial list <span class="font">xs</span>. Hence, to prove that <i class="calibre1">P</i>(<i class="calibre1">xs</i>) holds for all partial lists <i class="calibre1">xs</i> we can prove that</p>
<p class="number">1.<span class="space"></span><i class="calibre1">P</i>(<span class="font">undefined</span>) holds;</p>
<p class="number">2.<span class="space"></span><i class="calibre1">P</i>(<span class="font">x:xs</span>) holds assuming <i class="calibre1">P</i>(<span class="font">xs</span>) does, for all <span class="font">x</span> and all partial lists <span class="font">xs</span>.</p>
<p class="para">As an example, we prove that</p>
<p class="code"><span class="font">xs ++ ys = xs</span></p>
<p class="para">for all partial lists <span class="font">xs</span> and all lists <span class="font">ys</span>:</p>
<p class="theorem"><b class="calibre7">Case</b> <span class="font">undefined</span></p>
<p class="code2"><span class="font">undefined ++ ys</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">++.0</span>}</p>
<p class="code2"><span class="font">undefined</span></p>
<p class="theorem"><b class="calibre7">Case</b> <span class="font">x:xs</span></p>
<p class="code2"><span class="font">(x:xs) ++ ys</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">++.2</span>}</p>
<p class="code2"><span class="font">x:(xs ++ ys)</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{induction}</p>
<p class="code2"><span class="font">x:xs</span></p>
<p class="para">In each case the trivial right-hand column is omitted. The hint <span class="font">(++).0</span> refers to the failing clause in the definition of <span class="font">(++)</span>: since concatenation is defined by pattern matching on the left-hand argument, the result is undefined if the left-hand argument is.</p>
<p class="center"><i class="calibre1">Induction over infinite lists</i></p>
<p class="para">Proving that something is true of all infinite lists requires a bit of background that we will elaborate on in a subsequent chapter. Basically an infinite list can <a id="text/part0010.html.page_116" class="calibre3"></a>be thought of as the limit of a sequence of partial lists. For example, <span class="font">[0..]</span> is the limit of the sequence</p>
<p class="code"><span class="font">undefined, 0:undefined, 0:1:undefined, 0:1:2:undefined,</span></p>
<p class="para">and so on. A property <i class="calibre1">P</i> is called <i class="calibre1">chain complete</i> if whenever <i class="calibre1">xs</i><sub class="calibre11">0</sub><i class="calibre1">, xs</i><sub class="calibre11">1</sub> <i class="calibre1">,</i> . . . is a sequence of partial lists with limit <i class="calibre1">xs</i>, and <i class="calibre1">P</i>(<i class="calibre1">xs</i><sub class="calibre11"><sup class="calibre18"><i class="calibre1">n</i></sup></sub>) holds for all <i class="calibre1">n</i>, then <i class="calibre1">P</i>(<i class="calibre1">xs</i>) also holds.</p>
<p class="para">In other words, if <i class="calibre1">P</i> is a chain complete property that holds for all partial lists (and possibly all finite lists too), then it holds for all infinite lists.</p>
<p class="para">Many properties are chain complete; for instance:</p>
<ul class="calibre9">
<li class="calibre10">All equations <i class="calibre1">e</i>1 = <i class="calibre1">e</i>2, where <i class="calibre1">e</i>1 and <i class="calibre1">e</i>2 are Haskell expressions involving universally quantified free variables, are chain complete.</li>
<li class="calibre10">If <i class="calibre1">P</i> and <i class="calibre1">Q</i> are chain complete, then so is their conjunction <i class="calibre1">P</i> ∧ <i class="calibre1">Q</i>.</li>
</ul>
<p class="para">But inequalities <i class="calibre1">e</i>1 ≠ <i class="calibre1">e</i>2 are not necessarily chain complete, and neither are properties involving existential quantification. For example, consider the assertion</p>
<p class="code"><span class="font">drop n xs = undefined</span></p>
<p class="para">for some integer <span class="font">n</span>. This property is obviously true for all partial lists, and equally obviously not true for any infinite list.</p>
<p class="para">Here is an example proof. Earlier we proved that</p>
<p class="code"><span class="font">(xs ++ ys) ++ zs = xs ++ (ys ++ zs)</span></p>
<p class="para">for all finite lists <span class="font">xs</span> and for all lists <span class="font">ys</span> and <span class="font">zs</span>. We can extend this chain complete property to <i class="calibre1">all</i> lists <span class="font">xs</span> by proving</p>
<p class="theorem"><b class="calibre7">Case</b> <span class="font">undefined</span></p>
<p class="code2"><span class="font">(undefined ++ ys) ++ zs</span><span class="space5"></span><span class="font">undefined ++ (ys ++ zs)</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">++.0</span>}<span class="space6"></span><span class="font">=</span><span class="space5"></span>{<span class="font">++.0</span>}</p>
<p class="code2"><span class="font">undefined ++ zs</span><span class="space7"></span><span class="font">undefined</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">++.0</span>}</p>
<p class="code2"><span class="font">undefined</span></p>
<p class="para">Thus <span class="font">++</span> is a truly associative operation on lists, independent of whether the lists are finite, partial or infinite.</p>
<p class="para">But we have to be careful. Earlier we proved</p>
<p class="code"><a id="text/part0010.html.page_117" class="calibre3"></a><span class="font">reverse (reverse xs) = xs</span></p>
<p class="para">for all finite lists <span class="font">xs</span>. Can we extend this property to all lists by proving the following additional case?</p>
<p class="theorem"><b class="calibre7">Case</b> <span class="font">undefined</span></p>
<p class="code2"><span class="font">reverse (reverse undefined)</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">reverse.0</span>}</p>
<p class="code2"><span class="font">undefined</span></p>
<p class="para">That goes through but something is wrong: as a Haskell equation we have</p>
<p class="code"><span class="font">reverse (reverse xs) = undefined</span></p>
<p class="para">for all partial lists <span class="font">xs</span>. What did we miss?</p>
<p class="para">The answer is that in proving the involution property of <span class="font">reverse</span> we made use of an auxiliary result:</p>
<p class="code"><span class="font">reverse (ys ++ [x]) = x:reverse ys</span></p>
<p class="para">for all finite lists <span class="font">ys</span>. This result is not true for all lists, indeed not true for any partial list <span class="font">ys</span>.</p>
<p class="para">It follows that <span class="font">reverse . reverse</span> is not the identity function on lists, A functional equation <span class="font">f = g</span> over lists asserts that <span class="font">f xs = g xs</span> for <i class="calibre1">all</i> lists <span class="font">xs</span>, finite, partial and infinite. If the equation is true only for finite lists, we have to say so explicitly.</p>
<h3 class="h" id="text/part0010.html.head6-3">6.3 The function <span class="font1">foldr</span></h3>
<p class="para">All the following functions have a common pattern:</p>
<p class="code"><span class="font">sum []</span><span class="space2"></span><span class="space4"></span><span class="space-r1"></span><span class="font">= 0</span></p>
<p class="code"><span class="font">sum (x:xs)</span><span class="space"></span><span class="space-r"></span><span class="space4"></span><span class="space-r1"></span><span class="font">= x + sum xs</span></p>
<p class="para1"></p>
<p class="code"><span class="font">concat []</span><span class="space2"></span><span class="space"></span><span class="space-r1"></span><span class="font">= []</span></p>
<p class="code"><span class="font">concat (xs:xss)</span><span class="space"></span><span class="space-r"></span><span class="font">= xs ++ concat xss</span></p>
<p class="para1"></p>
<p class="code"><span class="font">filter p []</span><span class="space2"></span><span class="font">= []</span></p>
<p class="code"><span class="font">filter p (x:xs)</span><span class="space"></span><span class="space-r"></span><span class="font">= if p x then x:filter p xs</span></p>
<p class="code5"><span class="space"></span><span class="font">else filter p xs</span></p>
<p class="code"><a id="text/part0010.html.page_118" class="calibre3"></a><span class="font">map f []</span><span class="space8"></span><span class="space"></span><span class="font">= []</span></p>
<p class="code"><span class="font">map f (x:xs)</span><span class="space5"></span><span class="space"></span><span class="space-r1"></span><span class="font">= f x:map f xs</span></p>
<p class="para">Similarly, the proofs by induction of the following laws all have a common pattern:</p>
<p class="code"><span class="font">sum (xs ++ ys)</span><span class="space8"></span><span class="font">= sum xs + sum ys</span></p>
<p class="code"><span class="font">concat (xss ++ yss)</span><span class="space5"></span><span class="font">= concat xss ++ concat yss</span></p>
<p class="code"><span class="font">filter p (xs ++ ys)</span><span class="space5"></span><span class="font">= filter p xs ++ filter p ys</span></p>
<p class="code"><span class="font">map f (xs ++ ys)</span><span class="space2"></span><span class="font">= map f xs ++ map f ys</span></p>
<p class="para">Can we not ensure that the functions above are defined as instances of a more general function, and the laws above as instances of a more general law? That would save a lot of repetitive effort.</p>
<p class="para">The function <span class="font">foldr</span> (fold from the right) is defined by</p>
<p class="code"><span class="font">foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</span></p>
<p class="code"><span class="font">foldr f e []</span><span class="space4"></span><span class="font">= e</span></p>
<p class="code"><span class="font">foldr f e (x:xs) = f x (foldr f e xs)</span></p>
<p class="para">To appreciate this definition, consider</p>
<p class="code"><span class="font">foldr (@) e [x,y,z] = x @ (y @ (z @ e))</span></p>
<p class="code12"><span class="font">[x,y,z] = x : (y : (z : []))</span></p>
<p class="para">In other words, <span class="font">foldr (@) e</span> applied to a list replaces the empty list by <span class="font">e</span>, and <span class="font">(:)</span> by <span class="font">(@)</span> and evaluates the result. The parentheses group from the right, whence the name.</p>
<p class="para">It follows at once that <span class="font">foldr (:) []</span> is the identity function on lists. Furthermore,</p>
<p class="code"><span class="font">sum</span><span class="space8"></span><span class="font">= foldr (+) 0</span></p>
<p class="code"><span class="font">concat</span><span class="space4"></span><span class="font">= foldr (++) []</span></p>
<p class="code"><span class="font">filter p</span><span class="space5"></span><span class="font">= foldr (\x xs -&gt; if p x then x:xs else xs) []</span></p>
<p class="code"><span class="font">map f</span><span class="space2"></span><span class="font">= foldr ((:) . f) []</span></p>
<p class="para">The following fact captures all the identities mentioned above:</p>
<p class="code"><span class="font">foldr f e (xs ++ ys) = foldr f e xs @ foldr f e ys</span></p>
<p class="para">for some operation <span class="font">(@)</span> satisfying various properties. We prove this equation by induction on <span class="font">xs</span>. Along the way, we discover what properties of <span class="font">f</span>, <span class="font">e</span> and <span class="font">(@)</span> we need.</p>
<p class="theorem"><a id="text/part0010.html.page_119" class="calibre3"></a><b class="calibre7">Case</b> <span class="font">[]</span></p>
<p class="code2"><span class="font">foldr f e ([] ++ ys)</span><span class="space5"></span><span class="font">foldr f e [] @ foldr f e ys</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">++.1</span>}<span class="space7"></span><span class="space"></span><span class="font">=</span><span class="space5"></span>{<span class="font">foldr.1</span>}</p>
<p class="code2"><span class="font">foldr f e ys</span><span class="space3"></span><span class="space"></span><span class="font">e @ foldr f e ys</span></p>
<p class="para">Hence we need <span class="font">e @ x = x</span> for all <span class="font">x</span>.</p>
<p class="theorem"><b class="calibre7">Case</b> <span class="font">x:xs</span></p>
<p class="code1"><span class="font">foldr f e ((x:xs) ++ ys)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{<span class="font">++.2</span>}</p>
<p class="code1"><span class="font">foldr f e (x:(xs ++ ys)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{<span class="font">foldr.2</span>}</p>
<p class="code1"><span class="font">f x (foldr f e (xs ++ ys))</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{induction}</p>
<p class="code1"><span class="font">f x (foldr f e xs @ foldr f e ys)</span></p>
<p class="para">The right-hand side in this case simplifies to</p>
<p class="code"><span class="font">f x (foldr f e xs) @ foldr f e ys</span></p>
<p class="para">So, in summary, we require that</p>
<p class="code"><span class="font">e @ x = x</span></p>
<p class="code"><span class="font">f x (y @ z) = f x y @ z</span></p>
<p class="para">for all <span class="font">x</span>, <span class="font">y</span> and <span class="font">z</span>. In particular the two requirements are met if <span class="font">f = (@)</span> and <span class="font">(@)</span> is associative with identity <span class="font">e</span>. That immediately proves</p>
<p class="code"><span class="font">sum (xs ++ ys) = sum xs + sum ys</span></p>
<p class="code"><span class="font">concat (xss ++ yss) = concat xss ++ concat yss</span></p>
<p class="para">For the <span class="font">map</span> law, we require that</p>
<p class="code"><span class="font">[] ++ xs = xs</span></p>
<p class="code"><span class="font">f x:(xs ++ ys) = (f x:ys) ++ ys</span></p>
<p class="para">Both immediately follow from the definition of concatenation.</p>
<p class="para">For the law of <span class="font">filter</span> we require that</p>
<p class="code"><span class="font">if p x then x:(ys ++ zs) else ys ++ zs</span></p>
<p class="code2"><span class="font">= (if p x then x:ys else ys) ++ zs</span></p>
<p class="para"><a id="text/part0010.html.page_120" class="calibre3"></a>This is immediate from the definitions of concatenation and conditional expressions.</p>
<p class="center"><i class="calibre1">Fusion</i></p>
<p class="para">The most important property of <span class="font">foldr</span> is the <i class="calibre1">fusion law</i>, which asserts that</p>
<p class="code"><span class="font">f . foldr g a = foldr h b</span></p>
<p class="para">provided certain properties of the ingredients hold. As two simple examples,</p>
<p class="code"><span class="font">double . sum</span><span class="space5"></span><span class="space-r"></span><span class="font">= foldr ((+) . double) 0</span></p>
<p class="code"><span class="font">length . concat = foldr ((+) . length) 0</span></p>
<p class="para">In fact, many of the laws we have seen already are instances of the fusion law for <span class="font">foldr</span>. In a word, the fusion law is a ‘pre-packaged’ form of induction over lists.</p>
<p class="para">To find out what properties we need, we carry out an induction proof of the fusion law. The law is expressed as a functional equation, so we have to show that it holds for all finite and all partial lists:</p>
<p class="theorem"><b class="calibre7">Case</b> <span class="font">undefined</span></p>
<p class="code2"><span class="font">f (foldr g a undefined)</span><span class="space5"></span><span class="font">foldr h b undefined</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">foldr.0</span>}<span class="space7"></span><span class="space-r"></span><span class="font">=</span><span class="space5"></span>{<span class="font">foldr.0</span>}</p>
<p class="code2"><span class="font">f undefined</span><span class="space7"></span><span class="space5"></span><span class="font">undefined</span></p>
<p class="para">So the first condition is that <span class="font">f</span> is a strict function.</p>
<p class="theorem"><b class="calibre7">Case</b> <span class="font">[]</span></p>
<p class="code2"><span class="font">f (foldr g a [])</span><span class="space4"></span><span class="font">foldr h b []</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">foldr.1</span>}<span class="space8"></span><span class="font">=</span><span class="space5"></span>{<span class="font">foldr.1</span>}</p>
<p class="code2"><span class="font">f a</span><span class="space6"></span><span class="space"></span><span class="font">b</span></p>
<p class="para">The second condition is that <span class="font">f a = b</span>.</p>
<p class="theorem"><b class="calibre7">Case</b> <span class="font">x:xs</span></p>
<p class="code2"><span class="font">f (foldr g a (x:xs))</span><span class="space2"></span><span class="font">foldr h b (x:xs)</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">foldr.2</span>}<span class="space7"></span><span class="space-r"></span><span class="font">=</span><span class="space5"></span>{<span class="font">foldr.2</span>}</p>
<p class="code2"><span class="font">f (g x (foldr g a xs))</span><span class="space4"></span><span class="font">h x (foldr h b xs)</span></p>
<p class="code16"><span class="space4"></span><span class="space-r"></span><span class="font">=</span><span class="space5"></span>{induction}</p>
<p class="code16"><span class="space8"></span><span class="font">h x (f (foldr g a xs))</span></p>
<p class="para"><a id="text/part0010.html.page_121" class="calibre3"></a>The third condition is met by <span class="font">f (g x y) = h x (f y)</span> for all <span class="font">x</span> and <span class="font">y</span>.</p>
<p class="para">Let us apply the fusion law to show that</p>
<p class="code"><span class="font">foldr f a . map g = foldr h a</span></p>
<p class="para">Recall that <span class="font">map g = foldr ((:) . g) []</span>. Looking at the conditions of the fusion law we have that</p>
<p class="code"><span class="font">foldr f a undefined = undefined</span></p>
<p class="code"><span class="font">foldr f a []</span><span class="space8"></span><span class="font">= a</span></p>
<p class="para">So the first two fusion conditions are satisfied. The third one is</p>
<p class="code"><span class="font">foldr f a (g x:xs) = h x (foldr f a xs)</span></p>
<p class="para">The left-hand side simplifies to</p>
<p class="code"><span class="font">f (g x) (foldr f a xs)</span></p>
<p class="para">so we can define <span class="font">h x y = f (g x) y</span>. More briefly, <span class="font">h = f . g</span>. Hence we have the useful rule:</p>
<p class="code"><span class="font">foldr f a . map g = foldr (f . g) a</span></p>
<p class="para">In particular,</p>
<p class="code"><span class="font">double . sum = sum . map double</span></p>
<p class="code9"><span class="font">= foldr ((+) . double) 0</span></p>
<p class="para1"></p>
<p class="code"><span class="font">length . concat = sum . map length</span></p>
<p class="code14"><span class="font">= foldr ((+) . length) 0</span></p>
<p class="para">Other simple consequences of the fusion law are explored in the exercises.</p>
<p class="center"><i class="calibre1">A variant</i></p>
<p class="para">Sometimes having the empty list around is a pain. For example, what is the minimum element in an empty list? For this reason, Haskell provides a variant on <span class="font">foldr</span>, called <span class="font">foldr1</span>, restricted to nonempty lists. The Haskell definition of this function is</p>
<p class="code"><span class="font">foldr1 :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; a</span></p>
<p class="code"><span class="font">foldr1 f [x]</span><span class="space5"></span><span class="space-r1"></span><span class="font">= x</span></p>
<p class="code"><span class="font">foldr1 f (x:xs) = f x (foldr1 f xs)</span></p>
<p class="para"><a id="text/part0010.html.page_122" class="calibre3"></a>So we can define</p>
<p class="code"><span class="font">minimum, maximum :: Ord a =&gt; [a] -&gt; a</span></p>
<p class="code"><span class="font">minimum = foldr1 min</span></p>
<p class="code"><span class="font">maximum = foldr1 max</span></p>
<p class="para">and avoid two other explicit recursions. Actually the Haskell definition of <span class="font">foldr1</span> is not as general as it should be, but we will leave that discussion to an exercise.</p>
<h3 class="h" id="text/part0010.html.head6-4">6.4 The function <span class="font1">foldl</span></h3>
<p class="para">Recall that</p>
<p class="code"><span class="font">foldr (@) e [w,x,y,z] = w @ (x @ (y @ (z @ e)))</span></p>
<p class="para">Sometimes a more convenient pattern for the right-hand side is</p>
<p class="code"><span class="font">(((e @ w) @ x) @ y) @ z</span></p>
<p class="para">This pattern is encapsulated by a function <span class="font">foldl</span> (fold from the left):</p>
<p class="code"><span class="font">foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</span></p>
<p class="code"><span class="font">foldl f e [] = e</span></p>
<p class="code"><span class="font">foldl f e (x:xs) = foldl f (f e x) xs</span></p>
<p class="para">As an example, suppose we are given a string, such as <span class="font">1234.567</span>, representing a real number and we want to compute its integer part and fractional part. We could define</p>
<p class="code"><span class="font">ipart :: String -&gt; Integer</span></p>
<p class="code"><span class="font">ipart xs = read (takeWhile (/= '.') xs) :: Integer</span></p>
<p class="para1"></p>
<p class="code"><span class="font">fpart :: String -&gt; Float</span></p>
<p class="code"><span class="font">fpart xs = read ('0':dropWhile (/= '.' xs) :: Float</span></p>
<p class="para">This uses the function <span class="font">read</span> of the type class <span class="font">Read</span>. Note by the way that <span class="font">.567</span> is not a well-formed literal in Haskell. It is necessary to include at least one digit before and after the decimal point to ensure that the decimal point cannot be mistaken for functional composition. For example,</p>
<p class="code6"><span class="font">ghci&gt; :t 3 . 4</span></p>
<p class="code6"><span class="font">3 . 4 :: (Num (b -&gt; c), Num (a -&gt; b)) =&gt; a -&gt; c</span></p>
<p class="para">As an alternative, we can define</p>
<p class="code"><a id="text/part0010.html.page_123" class="calibre3"></a><span class="font">parts :: String -&gt; (Integer,Float)</span></p>
<p class="code"><span class="font">parts ds</span><span class="space"></span><span class="font">= (ipart es,fpart fs)</span></p>
<p class="code12"><span class="font">where (es,d:fs) = break (== '.') ds</span></p>
<p class="code"><span class="font">ipart</span><span class="space4"></span><span class="font">= foldl shiftl 0 . map toDigit</span></p>
<p class="code12"><span class="font">where shiftl n d = n*10 + d</span></p>
<p class="code"><span class="font">fpart</span><span class="space4"></span><span class="font">= foldr shiftr 0 . map toDigit</span></p>
<p class="code12"><span class="font">where shiftr d x = (d + x)/10</span></p>
<p class="code"><span class="font">toDigit d = fromIntegral (fromEnum d - fromEnum '0')</span></p>
<p class="para">We have</p>
<p class="code"><span class="font">1234</span><span class="space5"></span><span class="space-r"></span><span class="font">= 1*1000 + 2*100 + 3*10 + 4</span></p>
<p class="code3"><span class="space"></span><span class="font">= (((0*10 + 1)*10 + 2)*10 + 3)*10 + 4</span></p>
<p class="code"><span class="font">0.567</span><span class="space5"></span><span class="font">= 5/10 + 6/100 + 7/1000</span></p>
<p class="code3"><span class="space"></span><span class="font">= (5 + (6 + (7 + 0)/10)/10)/10</span></p>
<p class="para">so use of <span class="font">foldl</span> for the integer part and <span class="font">foldr</span> for the fractional part are both indicated.</p>
<p class="para">Here is another example. The function <span class="font">reverse</span> was defined above by the equations</p>
<p class="code"><span class="font">reverse []</span><span class="space4"></span><span class="font">= []</span></p>
<p class="code"><span class="font">reverse (x:xs) = reverse xs ++ [x]</span></p>
<p class="para">We are wiser now and would now write</p>
<p class="code"><span class="font">reverse = foldr snoc []</span></p>
<p class="code10"><span class="font">where snoc x xs = xs ++ [x]</span></p>
<p class="para">But a little learning is a dangerous thing: both definitions of <span class="font">reverse</span> are terrible because they take of the order of <i class="calibre1">n</i><sup class="calibre8">2</sup> steps to reverse a list of length <i class="calibre1">n</i>. Much better is to define</p>
<p class="code"><span class="font">reverse = foldl (flip (:)) []</span></p>
<p class="para">where <span class="font">flip f x y = f y x</span>. The new version reverses a list in linear time:</p>
<p class="code2"><span class="font">foldl (flip (:)) [] [1,2,3]</span></p>
<p class="code"><span class="font">= foldl (flip (:)) (1:[]) [2,3]</span></p>
<p class="code"><span class="font">= foldl (flip (:)) (2:1:[]) [3]</span></p>
<p class="code"><span class="font">= foldl (flip (:)) (3:2:1:[]) []</span></p>
<p class="code"><span class="font">= 3:2:1:[]</span></p>
<p class="para">That seems a bit of a trick, but there is a sound principle at work behind this new definition that we will take up in the following chapter.</p>
<p class="para"><a id="text/part0010.html.page_124" class="calibre3"></a>As this example suggests, there are the following relationships between <span class="font">foldr</span> and <span class="font">foldl</span>: for all finite lists <span class="font">xs</span> we have</p>
<p class="code"><span class="font">foldl f e xs = foldr (flip f) e (reverse xs)</span></p>
<p class="code"><span class="font">foldr f e xs = foldl (flip f) e (reverse xs)</span></p>
<p class="para">Proofs are left as an exercise. Note the restriction to finite lists, even though both sides reduce to ⊥ when <span class="font">xs</span> is ⊥. That means the proofs have to rely on a subsidiary result that is true only for finite lists.</p>
<p class="para">Here is another relationship between the two folds:</p>
<p class="code"><span class="font">foldl (@) e xs = foldr (&lt;&gt;) e xs</span></p>
<p class="para">for all finite lists <span class="font">xs</span>, provided that</p>
<p class="code"><span class="font">(x &lt;&gt; y) @ z = x &lt;&gt; (y @ z)</span></p>
<p class="code"><span class="font">e @ x = x &lt;&gt; e</span></p>
<p class="para">Again, the proof is left as an exercise. As one instructive application of this law, suppose <span class="font">(&lt;&gt;) = (@)</span> and <span class="font">(@)</span> is associative with identity <span class="font">e</span>. Then the two provisos are satisfied and we can conclude that</p>
<p class="code"><span class="font">foldr (@) e xs = foldl (@) e xs</span></p>
<p class="para">for all finite lists <span class="font">xs</span> whenever <span class="font">(@)</span> is associative with identity <span class="font">e</span>. In particular,</p>
<p class="code"><span class="font">concat xss = foldr (++) [] xss = foldl (++) [] xss</span></p>
<p class="para">for all finite lists <span class="font">xss</span>. The two definitions are <i class="calibre1">not</i> the same if <span class="font">xss</span> is an infinite list:</p>
<p class="code6"><span class="font">ghci&gt; foldl (++) [] [[i] | i &lt;- [1..]]</span></p>
<p class="code6"><span class="font">Interrupted.</span></p>
<p class="code6"><span class="font">ghci&gt; foldr (++) [] [[i] | i &lt;- [1..]]</span></p>
<p class="code6"><span class="font">[1,2,3,4,{Interrupted}</span></p>
<p class="para">In response to the first expression, GHCi went into a long silence that was interrupted by pressing the ‘Stop program execution’ button. In response to the second, GHCi started printing an infinite list.</p>
<p class="para">OK, so the definition in terms of <span class="font">foldr</span> works on infinite lists, but the other one doesn’t. But maybe the definition of <span class="font">concat</span> in terms of <span class="font">foldl</span> leads to a more efficient computation when all the lists are finite? To answer this question, observe that</p>
<p class="code"><span class="font">foldr (++) [] [xs,ys,us,vs]</span></p>
<p class="code10"><span class="font">= xs ++ (ys ++ (us ++ (vs ++ [])))</span></p>
<p class="code"><a id="text/part0010.html.page_125" class="calibre3"></a><span class="font">foldl (++) [] [xs,ys,us,vs]</span></p>
<p class="code10"><span class="font">= (((([] ++ xs) ++ ys) ++ us) ++ vs)</span></p>
<p class="para">Let all the component lists have length <i class="calibre1">n</i>. The first expression on the right takes 4<i class="calibre1">n</i> steps to perform all the concatenations, while the second takes 0 + <i class="calibre1">n</i> +(<i class="calibre1">n</i> + <i class="calibre1">n</i>) + (<i class="calibre1">n</i> + <i class="calibre1">n</i> + <i class="calibre1">n</i>) =6<i class="calibre1">n</i> steps. Enough said, at least for now.</p>
<h3 class="h" id="text/part0010.html.head6-5">6.5 The function <span class="font1">scanl</span></h3>
<p class="para">The function <span class="font">scanl f e</span> applies <span class="font">foldl f e</span> to each initial segment of a list. For example</p>
<p class="code6"><span class="font">ghci&gt; scanl (+) 0 [1..10]</span></p>
<p class="code6"><span class="font">[0,1,3,6,10,15,21,28,36,45,55]</span></p>
<p class="para">The expression computes the <i class="calibre1">running sums</i> of the first ten positive numbers:</p>
<p class="code"><span class="font">[0, 0+1, (0+1)+2, ((0+1)+2)+3, (((0+1)+2)+3)+4, ...]</span></p>
<p class="para">The specification of <span class="font">scanl</span> is</p>
<p class="code"><span class="font">scanl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b]</span></p>
<p class="code"><span class="font">scanl f e = map (foldl f e) . inits</span></p>
<p class="para1"></p>
<p class="code"><span class="font">inits :: [a] -&gt; [[a]]</span></p>
<p class="code"><span class="font">inits [] = [[]]</span></p>
<p class="code"><span class="font">inits (x:xs) = [] : map (x:) (inits xs)</span></p>
<p class="para">For example</p>
<p class="code6"><span class="font">ghci&gt; inits "barbara"</span></p>
<p class="code6"><span class="font">["","b","ba","bar","barb","barba","barbar","barbara"]</span></p>
<p class="para">The function <span class="font">inits</span> is in the library <span class="font">Data.List</span>.</p>
<p class="para">But this definition of <span class="font">scanl f</span> involves evaluating <span class="font">f</span> a total of</p>
<p class="equationasimage">0 + 1 + 2 + · · · + <i class="calibre1">n</i> = <i class="calibre1">n</i>(<i class="calibre1">n</i> + 1)/2</p>
<p class="para">times on a list of length <i class="calibre1">n</i>. Can we do better?</p>
<p class="para">Yes, we can calculate a better definition by doing a kind of induction proof, except that we don’t know what it is we are proving!</p>
<p class="theorem"><a id="text/part0010.html.page_126" class="calibre3"></a><b class="calibre7">Case</b> <span class="font">[]</span></p>
<p class="code10"><span class="font">scanl f e []</span></p>
<p class="code1"><span class="font">=</span><span class="space5"></span>{definition}</p>
<p class="code10"><span class="font">map (foldl f e) (inits [])</span></p>
<p class="code1"><span class="font">=</span><span class="space5"></span>{<span class="font">inits.1</span>}</p>
<p class="code10"><span class="font">map (foldl f e) [[]]</span></p>
<p class="code1"><span class="font">=</span><span class="space5"></span>{<span class="font">map.1</span> and <span class="font">map.2</span>}</p>
<p class="code10"><span class="font">[foldl f e []]</span></p>
<p class="code1"><span class="font">=</span><span class="space5"></span>{<span class="font">foldl.1</span>}</p>
<p class="code10"><span class="font">[e]</span></p>
<p class="para">Hence we have shown that <span class="font">scanl f e [] = [e]</span></p>
<p class="theorem"><b class="calibre7">Case</b> <span class="font">x:xs</span></p>
<p class="code10"><span class="font">scanl f e (x:xs)</span></p>
<p class="code1"><span class="font">=</span><span class="space5"></span>{definition}</p>
<p class="code10"><span class="font">map (foldl f e) (inits (x:xs))</span></p>
<p class="code1"><span class="font">=</span><span class="space5"></span>{<span class="font">inits.2</span>}</p>
<p class="code10"><span class="font">map (foldl f e) ([]:map (x:) (inits xs))</span></p>
<p class="code1"><span class="font">=</span><span class="space5"></span>{<span class="font">map.1</span> and <span class="font">map.2</span>}</p>
<p class="code10"><span class="font">foldl f e []:map (foldl f e . (x:)) (inits xs)</span></p>
<p class="code1"><span class="font">=</span><span class="space5"></span>{<span class="font">foldl.1</span>}</p>
<p class="code10"><span class="font">e:map (foldl f e . (x:)) (inits xs)</span></p>
<p class="code1"><span class="font">=</span><span class="space5"></span>{claim: <span class="font">foldl f e . (x:) = foldl f (f e x)</span>}</p>
<p class="code10"><span class="font">e:map (foldl f (f e x)) (inits xs)</span></p>
<p class="code1"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">scanl</span>}</p>
<p class="code10"><span class="font">e:scanl f (f e x)</span></p>
<p class="para">The claim is an easy consequence of the definition of <span class="font">foldl</span>. Hence, in summary, we have shown</p>
<p class="code"><span class="font">scanl f e []</span><span class="space4"></span><span class="font">= [e]</span></p>
<p class="code"><span class="font">scanl f e (x:xs) = e:scanl f (f e x) xs</span></p>
<p class="para">This definition evaluates <span class="font">f</span> only a linear number of times.</p>
<p class="para"><a id="text/part0010.html.page_127" class="calibre3"></a>What we have just done is an example of optimising a function by <i class="calibre1">program calculation</i>. One of the exciting things about Haskell is that you can do this without fuss. There is no need to bring in a totally different logical language to reason about programs.</p>
<p class="para">However, the prelude definition of <span class="font">scanl</span> is a little different:</p>
<p class="code"><span class="font">scanl f e xs = e : (case xs of</span></p>
<p class="code5"><span class="font">[] -&gt; []</span></p>
<p class="code5"><span class="font">x:xs -&gt; scanl f (f e x) xs)</span></p>
<p class="para">Whereas for our version <span class="font">scanl f e undefined = undefined</span>, the prelude version has</p>
<p class="code"><span class="font">scanl f e undefined = e:undefined.</span></p>
<p class="para">The reason is that the right-hand sides of the two clauses defining <span class="font">scanl</span> are both lists that begin with <span class="font">e</span>. We do not have to know anything about the left-hand sides to determine this fact, and laziness dictates that we don’t ask.</p>
<p class="para">The prelude version also uses a <span class="font">case</span> expression. We won’t go into details since such expressions are used rarely in this book. Haskell allows us many ways to say the same thing.</p>
<h3 class="h" id="text/part0010.html.head6-6">6.6 The maximum segment sum</h3>
<p class="para">Here is another example of program calculation. The <i class="calibre1">maximum segment sum</i> problem is a famous one and its history is described in J. Bentley’s <i class="calibre1">Programming Pearls</i> (1987). Given is a sequence of integers and it is required to compute the maximum of the sums of all <i class="calibre1">segments</i> in the sequence. A segment is also called a <i class="calibre1">contiguous subsequence</i>. For example, the sequence</p>
<p class="code"><span class="font">[-1,2,-3,5,-2,1,3,-2,-2,-3,6]</span></p>
<p class="para">has maximum sum 7, the sum of the segment <span class="font">[5,-2,1,3]</span>. On the other hand, the sequence <span class="font">[-1,-2,-3]</span> has a maximum segment sum of zero, since the empty sequence is a segment of every list and its sum is zero. It follows that the maximum segment sum is always nonnegative.</p>
<p class="para">Our problem is specified by</p>
<p class="code"><span class="font">mss :: [Int] -&gt; Int</span></p>
<p class="code"><span class="font">mss = maximum . map sum . segments</span></p>
<p class="para"><a id="text/part0010.html.page_128" class="calibre3"></a>where <span class="font">segments</span> returns a list of all segments of a list. This function can be defined in a number of ways, including</p>
<p class="code"><span class="font">segments = concat . map inits . tails</span></p>
<p class="para">where <span class="font">tails</span> is dual to <span class="font">inits</span> and returns all the tail segments of a list:</p>
<p class="code"><span class="font">tails :: [a] -&gt; [[a]]</span></p>
<p class="code"><span class="font">tails []</span><span class="space4"></span><span class="font">= [[]]</span></p>
<p class="code"><span class="font">tails (x:xs) = (x:xs):tails xs</span></p>
<p class="para">The definition of <span class="font">segments</span> describes the process of taking all the initial segments of all the tail segments. For example,</p>
<p class="code6"><span class="font">ghci&gt; segments "abc"</span></p>
<p class="code6"><span class="font">["","a","ab","abc","","b","bc","","c",""]</span></p>
<p class="para">The empty sequence appears four times in this list, once for every tail segment.</p>
<p class="para">Direct evaluation of <span class="font">mss</span> will take a number of steps proportional to <i class="calibre1">n</i><sup class="calibre8">3</sup> on a list of length <i class="calibre1">n</i>. There are about <i class="calibre1">n</i><sup class="calibre8">2</sup> segments, and summing each of them will take <i class="calibre1">n</i> steps, so in total it will take <i class="calibre1">n</i><sup class="calibre8">3</sup> steps. It is not obvious that we can do better than cubic time for this problem.</p>
<p class="para">However, let’s see where some program calculation leads us. We can start by installing the definition of <span class="font">segments</span>:</p>
<p class="code"><span class="font">maximum . map sum . concat . map inits . tails</span></p>
<p class="para">Searching for a law we can apply, we spot that</p>
<p class="code"><span class="font">map f . concat = concat . map (map f)</span></p>
<p class="para">applies to the subterm <span class="font">map sum . concat</span>. That gives</p>
<p class="code"><span class="font">maximum . concat . map (map sum) . map inits . tails</span></p>
<p class="para">Now we can use the law <span class="font">map f . map g = map (f . g)</span> to give</p>
<p class="code"><span class="font">maximum . concat . map (map sum . inits) . tails</span></p>
<p class="para">Oh, we can also use the law</p>
<p class="code"><span class="font">maximum . concat = maximum . map maximum</span></p>
<p class="para">can’t we? No, not unless the argument to <span class="font">concat</span> is a nonempty list of nonempty lists, because the maximum of the empty list is undefined. In the present example the rule is valid because both <span class="font">inits</span> and <span class="font">tails</span> return nonempty lists. That leads to</p>
<p class="code"><a id="text/part0010.html.page_129" class="calibre3"></a><span class="font">maximum . map (maximum . map sum . inits) . tails</span></p>
<p class="para">The next step is to use the property of <span class="font">scanl</span> described in the previous section, namely</p>
<p class="code"><span class="font">map sum . inits = scanl (+) 0</span></p>
<p class="para">That leads to</p>
<p class="code"><span class="font">maximum . map (maximum . scanl (+) 0) . tails</span></p>
<p class="para">Already we have reduced a <i class="calibre1">n</i><sup class="calibre8">3</sup> algorithm to a <i class="calibre1">n</i><sup class="calibre8">2</sup> one, so we are making progress. But now we appear stuck since there is no law in our armoury that seems to help.</p>
<p class="para">The next step obviously concerns <span class="font">maximum . scanl (+) 0</span>. So, let’s see what we can prove about</p>
<p class="code"><span class="font">foldr1 max . scanl (+) 0</span></p>
<p class="para">This looks like a fusion rule, but can <span class="font">scanl (+) 0</span> be expressed as a <span class="font">foldr</span>? Well, we do have, for instance,</p>
<p class="code2"><span class="font">scanl (+) 0 [x,y,z]</span></p>
<p class="code"><span class="font">= [0,0+x,(0+x)+y,((0+x)+y)+z]</span></p>
<p class="code"><span class="font">= [0,x,x+y,x+y+z]</span></p>
<p class="code"><span class="font">= 0:map (x+) [0,y,y+z]</span></p>
<p class="code"><span class="font">= 0:map (x+) (scanl (+) 0 [y,z])</span></p>
<p class="para">This little calculation exploits the associativity of <span class="font">(+)</span> and the fact that <span class="font">0</span> is the identity element of <span class="font">(+)</span>. The result suggests, more generally, that</p>
<p class="code"><span class="font">scanl (@) e = foldr f [e]</span></p>
<p class="code2"><span class="font">where f x xs = e:map (x@) xs</span></p>
<p class="para">provided that <span class="font">(@)</span> is associative with identity <span class="font">e</span>. Let us take this on trust and move on to the conditions under which</p>
<p class="code"><span class="font">foldr1 (&lt;&gt;) . foldr f [e] = foldr h b</span></p>
<p class="code2"><span class="font">where f x xs = e:map (x@) xs</span></p>
<p class="para">It is immediate that <span class="font">foldr1 (&lt;&gt;)</span> is strict and <span class="font">foldr1 (&lt;&gt;) [e] = e</span>, so we have <span class="font">b = e</span>. It remains to check the third proviso of the fusion rule: we require <span class="font">h</span> to satisfy</p>
<p class="code"><span class="font">foldr1 (&lt;&gt;) (e:map (x@) xs) = h x (foldr1 (&lt;&gt;) xs)</span></p>
<p class="para">for all <i class="calibre1">x</i> and <i class="calibre1">xs</i>. The left-hand side simplifies to</p>
<p class="code"><a id="text/part0010.html.page_130" class="calibre3"></a><span class="font">e &lt;&gt; (foldr1 (&lt;&gt;) (map (x@) xs))</span></p>
<p class="para">Taking the singleton case <span class="font">xs = [y]</span>, we find that</p>
<p class="code"><span class="font">h x y = e &lt;&gt; (x @ y)</span></p>
<p class="para">That gives us our definition of <span class="font">h</span>, but we still have to check that</p>
<p class="code"><span class="font">foldr1 (&lt;&gt;) (e:map (x@) xs) = e &lt;&gt; (x @ foldr1 (&lt;&gt;) xs)</span></p>
<p class="para">Simplifying both sides, this equation holds provided</p>
<p class="code"><span class="font">foldr1 (&lt;&gt;) . map (x@) = (x@) . foldr1 (&lt;&gt;)</span></p>
<p class="para">This final equation holds provided <span class="font">(@)</span> <i class="calibre1">distributes</i> over <span class="font">(&lt;&gt;)</span>; that is</p>
<p class="code"><span class="font">x @ (y &lt;&gt; z) = (x @ y) &lt;&gt; (x @ z)</span></p>
<p class="para">The proof is left as an exercise.</p>
<p class="para">Does addition distribute over (binary) maximum? Yes:</p>
<p class="code"><span class="font">x + (y `max` z) = (x + y) `max` (x + z)</span></p>
<p class="code"><span class="font">x + (y `min` z) = (x + y) `min` (x + z)</span></p>
<p class="para">Back to the maximum segment sum. We have arrived at</p>
<p class="code"><span class="font">maximum . map (foldr (@) 0) . tails</span></p>
<p class="code"><span class="font">where x @ y = 0 `max` (x + y)</span></p>
<p class="para">What we have left looks very like an instance of the <span class="font">scanl</span> rule of the previous section, except that we have a <span class="font">foldr</span> not a <span class="font">foldl</span> and a <span class="font">tails</span> not an <span class="font">inits</span>. But a similar calculation to the one about <span class="font">scanl</span> reveals</p>
<p class="code"><span class="font">map (foldr f e) . tails = scanr f e</span></p>
<p class="para">where</p>
<p class="code"><span class="font">scanr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b]</span></p>
<p class="code"><span class="font">scanr f e []</span><span class="space4"></span><span class="font">= [e]</span></p>
<p class="code"><span class="font">scanr f e (x:xs) = f x (head ys):ys</span></p>
<p class="code17"><span class="font">where ys</span> <span class="font">= scanr f e xs</span></p>
<p class="para">The function <span class="font">scanr</span> is also defined in the standard prelude. In summary,</p>
<p class="code"><span class="font">mss = maximum . scanr (@) 0</span></p>
<p class="code3"><span class="font">where x @ y = 0 `max` (x + y)</span></p>
<p class="para">The result is a linear-time program for the maximum segment sum.</p>
<h3 class="h" id="text/part0010.html.head6-7"><a id="text/part0010.html.page_131" class="calibre6"></a>6.7 Exercises</h3>
<p class="theorem"><b class="calibre7">Exercise A</b></p>
<p class="para">In <a href="#text/part0007.html.6LJU0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 3</a> we defined multiplication on natural numbers. The following definition is slightly different:</p>
<p class="code"><span class="font">mult :: Nat -&gt; Nat -&gt; Nat</span></p>
<p class="code"><span class="font">mult Zero y = Zero</span></p>
<p class="code"><span class="font">mult (Succ x) = mult x y + y</span></p>
<p class="para">Prove that <span class="font">mult (x+y) z = mult x z + mult y z</span>. You can use only the facts that <span class="font">x+0 = x</span> and that <span class="font">(+)</span> is associative. That means a long think about which variable <span class="font">x</span>, <span class="font">y</span> or <span class="font">z</span> is the best one on which to do the induction.</p>
<p class="theorem"><b class="calibre7">Exercise B</b></p>
<p class="para">Prove that</p>
<p class="code"><span class="font">reverse (xs ++ ys) = reverse ys ++ reverse xs</span></p>
<p class="para">for all finite lists <span class="font">xs</span> and <span class="font">ys</span>. You may assume that <span class="font">(++)</span> is associative.</p>
<p class="theorem"><b class="calibre7">Exercise C</b></p>
<p class="para">Recall our friends Eager Beaver and Lazy Susan from Exercise D in <a href="#text/part0006.html.5N3C0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 2</a>. Susan happily used the expression <span class="font">head . map f</span>, while Beaver would probably prefer <span class="font">f . head</span>. Wait a moment! Are these two expressions equal? Carry out an induction proof to check.</p>
<p class="theorem"><b class="calibre7">Exercise D</b></p>
<p class="para">Recall the cartesian product function <span class="font">cp :: [[a]] -&gt; [[a]]</span> from the previous chapter. Give a definition of the form <span class="font">cp = foldr f e</span> for suitable <span class="font">f</span> and <span class="font">e</span>. You can use a list comprehension for the definition of <span class="font">f</span> if you like.</p>
<p class="para">The rest of this exercise concerns the proof of the identity</p>
<p class="code"><span class="font">length . cp = product . map length</span></p>
<p class="para">where <span class="font">product</span> returns the result of multiplying a list of numbers.</p>
<p class="number">1.<span class="space"></span>Using the fusion theorem, express <span class="font">length.cp</span> as an instance of <span class="font">foldr</span>.</p>
<p class="number">2.<span class="space"></span>Express <span class="font">map length</span> as an instance of <span class="font">foldr</span>.</p>
<p class="number"><a id="text/part0010.html.page_132" class="calibre3"></a>3.<span class="space"></span>Using the fusion theorem again, express <span class="font">product . map length</span> as an instance of <span class="font">foldr</span>.</p>
<p class="number">4.<span class="space"></span>Check that the two results are identical. If they aren’t, your definition of <span class="font">cp</span> was wrong.</p>
<p class="theorem"><b class="calibre7">Exercise E</b></p>
<p class="para">The first two arguments of <span class="font">foldr</span> are replacements for the constructors</p>
<p class="code"><span class="font">(:) :: a -&gt; [a] -&gt; [a]</span></p>
<p class="code"><span class="font">[]</span><span class="space"></span><span class="font">:: [a]</span></p>
<p class="para">of lists. A fold function can be defined for any data type: just give replacements for the constructors of the data type. For example, consider</p>
<p class="code"><span class="font">data Either a b = Left a | Right b</span></p>
<p class="para">To define a fold for <span class="font">Either</span> we have to give replacements for</p>
<p class="code"><span class="font">Left :: a -&gt; Either a b</span></p>
<p class="code"><span class="font">Right :: b -&gt; Either a b</span></p>
<p class="para">That leads to</p>
<p class="code"><span class="font">foldE :: (a -&gt; c) -&gt; (b -&gt; c) -&gt; Either a b -&gt; c</span></p>
<p class="code"><span class="font">foldE f g (Left x) = f x</span></p>
<p class="code"><span class="font">foldE f g (Right x) = g x</span></p>
<p class="para">The type <span class="font">Either</span> is not a recursive data type and <span class="font">foldE</span> is not a recursive function. In fact <span class="font">foldE</span> is a standard prelude function, except that it is called <span class="font">either</span> not <span class="font">foldE</span>.</p>
<p class="para">Now define fold functions for</p>
<p class="code"><span class="font">data Nat = Zero | Succ Nat</span></p>
<p class="code"><span class="font">data NEList a = One a | Cons a (NEList a)</span></p>
<p class="para">The second declaration introduces nonempty lists.</p>
<p class="para">What is wrong with the Haskell definition of <span class="font">foldr1</span>?</p>
<p class="theorem"><b class="calibre7">Exercise F</b></p>
<p class="para">Prove that</p>
<p class="code"><span class="font">foldl f e xs = foldr (flip f) e (reverse xs)</span></p>
<p class="para">for all finite lists <span class="font">xs</span>. Also prove that</p>
<p class="code"><a id="text/part0010.html.page_133" class="calibre3"></a><span class="font">foldl (@) e xs = foldr (&lt;&gt;) e xs</span></p>
<p class="para">for all finite lists <span class="font">xs</span>, provided that</p>
<p class="code"><span class="font">(x &lt;&gt; y) @ z = x &lt;&gt; (y @ z)</span></p>
<p class="code"><span class="font">e @ x = x &lt;&gt; e</span></p>
<p class="theorem"><b class="calibre7">Exercise G</b></p>
<p class="para">Using</p>
<p class="code"><span class="font">foldl f e (xs ++ ys) = foldl f (foldl f e xs) ys</span></p>
<p class="code"><span class="font">foldr f e (xs ++ ys) = foldr f (foldr f e ys) xs</span></p>
<p class="para">prove that</p>
<p class="code"><span class="font">foldl f e . concat = foldl (foldl f) e</span></p>
<p class="code"><span class="font">foldr f e . concat = foldr (flip (foldr f)) e</span></p>
<p class="theorem"><b class="calibre7">Exercise H</b></p>
<p class="para">Mathematically speaking, what is the value of</p>
<p class="code"><span class="font">sum (scanl (/) 1 [1..]) ?</span></p>
<p class="theorem"><b class="calibre7">Exercise I</b></p>
<p class="para">Calculate the efficient definition of <span class="font">scanr</span> from the specification</p>
<p class="code"><span class="font">scan r f e = map (foldr f e) . tails</span></p>
<p class="theorem"><b class="calibre7">Exercise J</b></p>
<p class="para">Consider the problem of computing</p>
<p class="code"><span class="font">mss :: [Int] -&gt; Int</span></p>
<p class="code"><span class="font">mss = maximum . map sum . subseqs</span></p>
<p class="para">where <span class="font">subseqs</span> returns all the subsequences of a finite list, including the list itself:</p>
<p class="code"><span class="font">subseqs :: [a] -&gt; [[a]]</span></p>
<p class="code"><span class="font">subseqs []</span><span class="space4"></span><span class="font">= [[]]</span></p>
<p class="code"><span class="font">subseqs (x:xs) = xss ++ map (x:) xss</span></p>
<p class="code5"><span class="font">where xss = subseqs xs</span></p>
<p class="para">Find a more efficient alternative for <span class="font">mss</span>.</p>
<p class="theorem"><a id="text/part0010.html.page_134" class="calibre3"></a><b class="calibre7">Exercise K</b></p>
<p class="para">This question is in pieces.</p>
<p class="number">1.<span class="space"></span>The function <span class="font">takePrefix p</span> applied to a list <i class="calibre1">xs</i> returns the longest initial segment of <i class="calibre1">xs</i> that satisfies <i class="calibre1">p</i>. Hence</p>
<p class="code11"><span class="font">takePrefix :: ([a] -&gt; Bool) -&gt; [a] -&gt; [a]</span></p>
<p class="para"><span class="space5"></span>What are the values of the following expressions?</p>
<p class="code11"><span class="font">takePrefix nondec [1,3,7,6,8,9]</span></p>
<p class="code11"><span class="font">takePrefix (all even) [2,4,7,8]</span></p>
<p class="para"><span class="space5"></span>Complete the right-hand side of</p>
<p class="code11"><span class="font">takePrefix (all p) = ...</span></p>
<p class="para1"></p>
<p class="code">Give a definition of <span class="font">takePrefix</span> in terms of standard functions, including <span class="font">inits</span>. We will return to <span class="font">takePrefix</span> in the final part of this question.</p>
<p class="para1"></p>
<p class="number">2.<span class="space"></span>The functions <span class="font">one</span> and <span class="font">none</span> are defined by the equations</p>
<p class="code11"><span class="font">one x</span><span class="space"></span><span class="space-r1"></span><span class="font">= [x]</span></p>
<p class="code11"><span class="font">none x = []</span></p>
<p class="code">Complete the right-hand side of the following identities:</p>
<p class="code11"><span class="font">none . f</span><span class="space4"></span><span class="font">= ...</span></p>
<p class="code11"><span class="font">map f . none = ...</span></p>
<p class="code11"><span class="font">map f . one</span><span class="space"></span><span class="font">= ...</span></p>
<p class="number">3.<span class="space"></span>Recall that <span class="font">fork (f,g) x = (f x,g x)</span>. Complete the identities</p>
<p class="code11"><span class="font">fst . fork (f,g) = ...</span></p>
<p class="code11"><span class="font">snd . fork (f,g) = ...</span></p>
<p class="code11"><span class="font">fork (f,g) . h</span><span class="space"></span><span class="space-r1"></span><span class="font">= ...</span></p>
<p class="number">4.<span class="space"></span>Define</p>
<p class="code11"><span class="font">test p (f,g) x = if p x then f x else g x</span></p>
<p class="para1"></p>
<p class="code">Complete the right-hand sides of</p>
<p class="code11"><span class="font">test p (f,g) . h = ...</span></p>
<p class="code11"><span class="font">h . test p (f,g) = ...</span></p>
<p class="para"><span class="space5"></span>The function <span class="font">filter</span> can be defined by</p>
<p class="code11"><a id="text/part0010.html.page_135" class="calibre3"></a><span class="font">filter p = concat . map (test p (one,none))</span></p>
<p class="para1"></p>
<p class="code">Using the identities above, together with other standard identities, prove using equational reasoning that</p>
<p class="para1"></p>
<p class="code11"><span class="font">filter p = map fst . filter snd . map (fork (id,p))</span></p>
<p class="para1"></p>
<p class="code">(<i class="calibre1">Hint</i>: as always in calculations, start with the more complicated side.)</p>
<p class="para1"></p>
<p class="number">5.<span class="space"></span>Recall the standard prelude functions <span class="font">curry</span> and <span class="font">uncurry</span> from the answer to Exercise K in <a href="#text/part0008.html.7K4G0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 4</a>:</p>
<p class="code11"><span class="font">curry :: ((a,b) -&gt; c) -&gt; a -&gt; b -&gt; c</span></p>
<p class="code11"><span class="font">curry f x y = f (x,y)</span></p>
<p class="para1"></p>
<p class="code11"><span class="font">uncurry :: (a -&gt; b -&gt; c) -&gt; (a,b) -&gt; c</span></p>
<p class="code11"><span class="font">uncurry f (x,y) = f x y</span></p>
<p class="para"><span class="space5"></span>Complete the right-hand side of</p>
<p class="code11"><span class="font">map (fork (f,g)) = uncurry zip . (??)</span></p>
<p class="para1"></p>
<p class="number">6.<span class="space"></span>Returning to <span class="font">takePrefix</span>, use equational reasoning to calculate an efficient program for the expression</p>
<p class="code11"><span class="font">takePrefix (p . foldl f e)</span></p>
<p class="para"><span class="space5"></span>that requires only a linear number of applications of <i class="calibre1">f</i> .</p>
<h3 class="h" id="text/part0010.html.head6-8">6.8 Answers</h3>
<p class="theorem"><b class="calibre7">Answer to Exercise A</b></p>
<p class="para">The proof is by induction on <i class="calibre1">y</i>:</p>
<p class="theorem"><b class="calibre7">Case</b> 0</p>
<p class="code2"><span class="font">mult (x+0) z</span><span class="space3"></span><span class="font">mult x z + mult 0 z</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{since <span class="font">x + 0=x</span>}<span class="space4"></span><span class="font">=</span><span class="space5"></span>{<span class="font">mult.1</span>}</p>
<p class="code2"><span class="font">mult x z</span><span class="space7"></span><span class="space"></span><span class="space-r"></span><span class="font">mult x z + 0</span></p>
<p class="code16"><span class="space"></span><span class="font">=</span><span class="space5"></span>{since <span class="font">x + 0 = x</span>}</p>
<p class="code16"><span class="space5"></span><span class="font">mult x z</span></p>
<p class="theorem"><a id="text/part0010.html.page_136" class="calibre3"></a><b class="calibre7">Case</b> <span class="font">y+1</span></p>
<p class="code2"><span class="font">mult (x+(y+1)) z</span><span class="space3"></span><span class="font">mult x z + mult (y+1) z</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{as <span class="font">(+)</span> is associative}<span class="space4"></span><span class="font">=</span><span class="space5"></span>{<span class="font">mult.2</span>}</p>
<p class="code2"><span class="font">mult ((x+y)+1) z</span><span class="space3"></span><span class="font">mult x z + (mult y z + z)</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">mult.2</span>}<span class="space6"></span><span class="font">=</span><span class="space5"></span>{since <span class="font">(+)</span> is associative}</p>
<p class="code2"><span class="font">mult (x+y) z + z</span><span class="space3"></span><span class="font">(mult x z + mult y z) + z</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{induction}</p>
<p class="code2"><span class="font">(mult x z + mult y z) + z</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise B</b></p>
<p class="para">The proof is by induction on <i class="calibre1">xs</i>:</p>
<p class="theorem"><b class="calibre7">Case</b> <span class="font">[]</span></p>
<p class="code2"><span class="font">reverse ([]++ys)</span><span class="space4"></span><span class="space-r"></span><span class="font">reverse ys ++ reverse []</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">++.1</span>}<span class="space7"></span><span class="font">=</span><span class="space5"></span>{<span class="font">reverse.1</span>}</p>
<p class="code2"><span class="font">reverse ys</span><span class="space7"></span><span class="font">reverse ys ++ []</span></p>
<p class="code13"><span class="space"></span><span class="space-r"></span><span class="font">=</span><span class="space5"></span>{since <span class="font">xs ++ [] = xs</span>}</p>
<p class="code13"><span class="space5"></span><span class="space-r"></span><span class="font">reverse ys</span></p>
<p class="theorem"><b class="calibre7">Case</b> <span class="font">x:xs</span></p>
<p class="code2"><span class="font">reverse ((x:xs)++ys)</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">++.2</span>}</p>
<p class="code2"><span class="font">reverse (x:(xs++ys))</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">reverse.2</span>}</p>
<p class="code2"><span class="font">reverse (xs++ys) ++ [x]</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{induction}</p>
<p class="code2"><span class="font">(reverse ys ++ reverse xs) ++ [x]</span></p>
<p class="para">and</p>
<p class="code2"><span class="font">reverse ys ++ reverse (x:xs)</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">reverse.2</span>}</p>
<p class="code2"><span class="font">reverse ys ++ (reverse xs ++ [x])</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{since <span class="font">(++)</span> is associative}</p>
<p class="code2"><span class="font">(reverse ys ++ reverse xs) ++ [x]</span></p>
<p class="theorem"><a id="text/part0010.html.page_137" class="calibre3"></a><b class="calibre7">Answer to Exercise C</b></p>
<p class="para">We have to prove that</p>
<p class="code"><span class="font">head (map f xs) = f (head xs)</span></p>
<p class="para">for all lists <i class="calibre1">xs</i>, finite, partial or infinite. The case <span class="font">undefined</span> and the inductive case <span class="font">x:xs</span> are okay, but the case <span class="font">[]</span> gives</p>
<p class="code"><span class="font">head (map f []) = head [] = undefined</span></p>
<p class="code"><span class="font">f (head [])</span><span class="space4"></span><span class="font">= f undefined</span></p>
<p class="para">Hence the law holds only if <span class="font">f</span> is a strict function. Eager Beaver is not bothered by this since he can only construct strict functions.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise D</b></p>
<p class="para">We have</p>
<p class="code"><span class="font">cp = foldr op [[]]</span></p>
<p class="code"><span class="space-r"></span><span class="font">where op xs xss = [x:ys | x &lt;- xs, ys &lt;- xss]</span></p>
<p class="number">1.<span class="space"></span><span class="font">length . cp = foldr h b</span> provided <span class="font">length</span> is strict (it is) and</p>
<p class="code11"><span class="font">length [[]] = b</span></p>
<p class="code11"><span class="font">length (op xs xss) = h xs (length xss)</span></p>
<p class="para"><span class="space5"></span><span class="space-r1"></span>The first equation gives <span class="font">b = 1</span> and as</p>
<p class="code11"><span class="font">length (op xs xss) = length xs * length xss</span></p>
<p class="para"><span class="space5"></span><span class="space-r1"></span>the second equation gives <span class="font">h = (*) . length</span>.</p>
<p class="number">2.<span class="space"></span><span class="font">map length = foldr f []</span>, where <span class="font">f xs ns = length xs:ns</span>. A shorter definition is <span class="font">f = (:) . length</span>.</p>
<p class="number">3.<span class="space"></span><span class="font">product . map length = foldr h b</span> provided <span class="font">product</span> is strict (it is) and</p>
<p class="code11"><span class="font">product [] = b</span></p>
<p class="code11"><span class="font">product (length xs:ns) = h xs (product ns)</span></p>
<p class="para"><span class="space5"></span><span class="space-r1"></span>The first equation gives <span class="font">b = 1</span>, and as</p>
<p class="code11"><span class="font">product (length xs:ns) = length xs * product ns</span></p>
<p class="para"><span class="space5"></span><span class="space-r1"></span>the second equation gives <span class="font">h = (*) . length</span>.</p>
<p class="number">4.<span class="space"></span>The two definitions of <span class="font">h</span> and <span class="font">b</span> are identical.</p>
<p class="theorem"><a id="text/part0010.html.page_138" class="calibre3"></a><b class="calibre7">Answer to Exercise E</b></p>
<p class="para">The definition of <span class="font">foldN</span> is straightforward:</p>
<p class="code"><span class="font">foldN :: (a -&gt; a) -&gt; a -&gt; Nat -&gt; a</span></p>
<p class="code"><span class="font">foldN f e Zero = e</span></p>
<p class="code"><span class="font">foldN f e (Succ n) = f (foldN f e n)</span></p>
<p class="para">In particular,</p>
<p class="code"><span class="font">m+n = foldN Succ m n</span></p>
<p class="code"><span class="font">m*n = foldN (+m) Zero n</span></p>
<p class="code"><span class="font">m^n = foldN (*m) (Succ Zero) n</span></p>
<p class="para">For nonempty lists, the definition of <span class="font">foldNE</span> is:</p>
<p class="code"><span class="font">foldNE :: (a -&gt; b -&gt; b) -&gt; (a -&gt; b) -&gt; NEList a -&gt; b</span></p>
<p class="code"><span class="font">foldNE f g (One x) = g x</span></p>
<p class="code"><span class="font">foldNE f g (Cons x xs) = f x (foldNE f g xs)</span></p>
<p class="para">To be a proper fold over nonempty lists, the correct definition of <span class="font">foldr1</span> should have been</p>
<p class="code"><span class="font">foldr1 :: (a -&gt; b -&gt; b) -&gt; (a -&gt; b) -&gt; [a] -&gt; b</span></p>
<p class="code"><span class="font">foldr1 f g [x] = g x</span></p>
<p class="code"><span class="font">foldr1 f g (x:xs) = f x (foldr1 f g xs)</span></p>
<p class="para">The Haskell definition of <span class="font">foldr1</span> restricts <span class="font">g</span> to be the identity function.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise F</b></p>
<p class="para">Write <span class="font">g = flip f</span> for brevity. We prove that</p>
<p class="code"><span class="font">foldl f e xs = foldr g e (reverse xs)</span></p>
<p class="para">for all finite lists <span class="font">xs</span> by induction:</p>
<p class="theorem"><b class="calibre7">Case</b> <span class="font">[]</span></p>
<p class="code2"><span class="font">foldl f e []</span><span class="space8"></span><span class="font">foldl g e (reverse [])</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">foldl.1</span>}<span class="space2"></span><span class="font">=</span><span class="space5"></span>{<span class="font">reverse.1</span>}</p>
<p class="code2"><span class="font">e</span><span class="space6"></span><span class="space"></span><span class="space-r"></span><span class="font">foldl g e []</span></p>
<p class="code13"><span class="space-r"></span><span class="font">=</span><span class="space5"></span>{<span class="font">foldl.1</span>}</p>
<p class="code16"><span class="space"></span><span class="font">e</span></p>
<p class="theorem"><a id="text/part0010.html.page_139" class="calibre3"></a><b class="calibre7">Case</b> <span class="font">x:xs</span></p>
<p class="code1"><span class="font">foldl f e (x:xs)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{<span class="font">foldl.2</span>}</p>
<p class="code1"><span class="font">foldl f (f e x) xs</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{induction}</p>
<p class="code1"><span class="font">foldr g (f e x) (reverse xs)</span></p>
<p class="para">and</p>
<p class="code3"><span class="font">foldr g e (reverse (x:xs))</span></p>
<p class="code8"><span class="font">=</span><span class="space5"></span>{<span class="font">reverse.2</span>}</p>
<p class="code3"><span class="font">foldr g e (reverse xs ++ [x])</span></p>
<p class="code8"><span class="font">=</span><span class="space5"></span>{claim: see below}</p>
<p class="code3"><span class="font">foldr g (foldr g e [x]) (reverse xs)</span></p>
<p class="code8"><span class="font">=</span><span class="space5"></span>{since <span class="font">foldr (flip f) e [x] = f e x</span>}</p>
<p class="code3"><span class="font">foldr g (f e x) (reverse xs)</span></p>
<p class="para">The claim is that</p>
<p class="code"><span class="font">foldr f e (xs ++ ys) = foldr f (foldr f e ys) xs</span></p>
<p class="para">We leave the proof to the reader. By the way, we have the companion result that</p>
<p class="code"><span class="font">foldl f e (xs ++ ys) = foldl f (foldl f e xs) ys</span></p>
<p class="para">Again, the proof is left to you.</p>
<p class="para">We prove</p>
<p class="code"><span class="font">foldl (@) e xs = foldr (&lt;&gt;) e xs</span></p>
<p class="para">for all finite lists <span class="font">xs</span> by induction. The base case is trivial. For the inductive case:</p>
<p class="theorem"><b class="calibre7">Case</b> <span class="font">x:xs</span></p>
<p class="code2"><span class="font">foldl (@) e (x:xs)</span><span class="space6"></span><span class="font">foldr (&lt;&gt;) e (x:xs)</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{<span class="font">foldl.2</span>}<span class="space6"></span><span class="space4"></span><span class="font">=</span><span class="space5"></span>{<span class="font">foldr.2</span>}</p>
<p class="code2"><span class="font">foldl (@) (e @ x) xs</span><span class="space7"></span><span class="space"></span><span class="space-r"></span><span class="font">x &lt;&gt; foldr (&lt;&gt;) e xs</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{given that <span class="font">e @ x = x &lt;&gt; e</span>}<span class="space2"></span><span class="space-r"></span><span class="font">=</span><span class="space5"></span>{induction}</p>
<p class="code2"><span class="font">foldl (@) (x &lt;&gt; e) xs</span><span class="space7"></span><span class="space"></span><span class="font">x &lt;&gt; foldl (@) e xs</span></p>
<p class="para"><a id="text/part0010.html.page_140" class="calibre3"></a>The two sides have simplified to different results. We need another induction hypothesis:</p>
<p class="code"><span class="font">foldl (@) (x &lt;&gt; y) xs = x &lt;&gt; foldl (@) y xs</span></p>
<p class="para">The base case is trivial. For the inductive case</p>
<p class="theorem"><b class="calibre7">Case</b> <span class="font">z:zs</span></p>
<p class="code1"><span class="font">foldl (@) (x &lt;&gt; y) (z:zs)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{<span class="font">foldl.2</span>}</p>
<p class="code1"><span class="font">foldl (@) ((x &lt;&gt; y) @ z) zs</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{since <span class="font">(x &lt;&gt; y) @ z = x &lt;&gt; (y @ z)</span>}</p>
<p class="code1"><span class="font">foldl (@) (x &lt;&gt; (y @ z)) zs</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{induction}</p>
<p class="code1"><span class="font">x &lt;&gt; foldl (@) (y @ z) zs</span></p>
<p class="para">and</p>
<p class="code10"><span class="font">x &lt;&gt; foldl (@) y (z:zs)</span></p>
<p class="code1"><span class="font">=</span><span class="space5"></span>{<span class="font">foldl.2</span>}</p>
<p class="code10"><span class="font">x &lt;&gt; foldl (@) (y @ z) zs</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise G</b></p>
<p class="para">The proofs are by induction. The base cases are easy and the inductive cases are</p>
<p class="code1"><span class="font">foldl f e (concat (xs:xss))</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">concat</span>}</p>
<p class="code1"><span class="font">foldl f e (xs ++ concat xss)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{given property of <span class="font">foldl</span>}</p>
<p class="code1"><span class="font">foldl f (foldl f e xs) (concat xss)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{induction}</p>
<p class="code1"><span class="font">foldl (foldl f) (foldl f e xs) xss</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">foldl</span>}</p>
<p class="code1"><span class="font">foldl (foldl f) e (xs:xss)</span></p>
<p class="para"><a id="text/part0010.html.page_141" class="calibre3"></a>and</p>
<p class="code1"><span class="font">foldr f e (concat (xs:xss))</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">concat</span>}</p>
<p class="code1"><span class="font">foldr f e (xs ++ concat xss)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{given property of <span class="font">foldr</span>}</p>
<p class="code1"><span class="font">foldr f (foldr f e (concat xss)) xs</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{using <span class="font">flip</span>}</p>
<p class="code1"><span class="font">flip (foldr f) xs (foldr f e (concat xss))</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{induction}</p>
<p class="code1"><span class="font">flip (foldr f) xs (foldr (flip (foldr f)) e xss)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">foldr</span>}</p>
<p class="code1"><span class="font">foldr (flip (foldr f)) e (xs:xss)</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise H</b></p>
<p class="para">Mathematically speaking,</p>
<p class="code"><span class="font">sum (scanl (/) 1 [1..]) = e</span></p>
<p class="para">since&nbsp;<img src="data:image/jpeg;base64,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" alt="image" class="calibre2"> Computationally speaking, replacing <span class="font">[1..]</span> by a finite list <span class="font">[1..n]</span> gives an approximation to <i class="calibre1">e</i>. For example,</p>
<p class="code6"><span class="font">ghci&gt; sum (scanl (/) 1 [1..20])</span></p>
<p class="code6"><span class="font">2.7182818284590455</span></p>
<p class="code6"><span class="font">ghci&gt; exp 1</span></p>
<p class="code6"><span class="font">2.718281828459045</span></p>
<p class="para">The standard prelude function <span class="font">exp</span> takes a number <i class="calibre1">x</i> and returns <i class="calibre1">e</i><sup class="calibre8"><i class="calibre1">x</i></sup> . By the way, the prelude function <span class="font">log</span> takes a number <i class="calibre1">x</i> and returns log<sub class="calibre11"><i class="calibre1">e</i></sub> <i class="calibre1">x</i>. If you want logarithms in another base, use <span class="font">logBase</span> whose type is</p>
<p class="code"><span class="font">logBase :: Floating a =&gt; a -&gt; a -&gt; a</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise I</b></p>
<p class="para">We synthesise a more efficient definition by cases. The base case yields</p>
<p class="code"><span class="font">scanr f e [] = [e]</span></p>
<p class="para"><a id="text/part0010.html.page_142" class="calibre3"></a>and the inductive case <span class="font">x:xs</span> is:</p>
<p class="code1"><span class="font">scanr f e (x:xs)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{specification}</p>
<p class="code1"><span class="font">map (foldr f e) (tails (x:xs))</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{<span class="font">tails.2</span>}</p>
<p class="code1"><span class="font">map (foldr f e) ((x:xs):tails xs)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">map</span>}</p>
<p class="code1"><span class="font">foldr f e (x:xs):map (foldr f e) (tails xs)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{<span class="font">foldr.2</span> and specification}</p>
<p class="code1"><span class="font">f x (foldr f e xs):scan f e xs</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{claim: <span class="font">foldr f e xs = head (scanr f e xs)</span>}</p>
<p class="code1"><span class="font">f x (head ys):ys where ys = scanr f e xs</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise J</b></p>
<p class="para">Firstly,</p>
<p class="code"><span class="font">subseqs = foldr op [[]]</span></p>
<p class="code"><span class="font">where op x xss = xss ++ map (x:) xss</span></p>
<p class="para">Appeal to the fusion law yields</p>
<p class="code"><span class="font">map sum . subseqs = foldr op [0]</span></p>
<p class="code"><span class="font">where op x xs = xs ++ map (x+) xs</span></p>
<p class="para">A second appeal to fusion yields</p>
<p class="code"><span class="font">maximum . map sum . subseqs = foldr op 0</span></p>
<p class="code"><span class="font">where op x y = y `max` (x+y)</span></p>
<p class="para">That will do nicely. Of course, <span class="font">sum . filter (&gt;0)</span> also does the job.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise K</b></p>
<p class="number">1.<span class="space"></span>We have</p>
<p class="code11"><span class="font">takePrefix nondec [1,3,7,6,8,9] = [1,3,7]</span></p>
<p class="code11"><span class="font">takePrefix (all even) [2,4,7,8] = [2,4]</span></p>
<p class="para"><span class="space5"></span><span class="space-r1"></span>The identity is</p>
<p class="code11"><span class="font">takePrefix (all p) = takeWhile p</span></p>
<p class="para"><span class="space5"></span><span class="space-r1"></span><a id="text/part0010.html.page_143" class="calibre3"></a>The specification is</p>
<p class="code11"><span class="font">takePrefix p = last . filter p . inits</span></p>
<p class="number">2.<span class="space"></span>We have</p>
<p class="code11"><span class="font">none . f = none</span></p>
<p class="code11"><span class="font">map f . none = none</span></p>
<p class="code11"><span class="font">map f . one = one . f</span></p>
<p class="number">3.<span class="space"></span>We have</p>
<p class="code11"><span class="font">fst . fork (f,g) = f</span></p>
<p class="code11"><span class="font">snd . fork (f,g) = g</span></p>
<p class="code11"><span class="font">fork (f,g) . h = fork (f.h,g.h)</span></p>
<p class="number">4.<span class="space"></span>We have</p>
<p class="code11"><span class="font">test p (f,g) . h = test (p.h) (f . h, g . h)</span></p>
<p class="code11"><span class="font">h . test p (f,g) = test p (h . f, h . g)</span></p>
<p class="para"><span class="space5"></span><span class="space-r1"></span>The reasoning is:</p>
<p class="code8"><span class="font">map fst . filter snd . map (fork (id,p))</span></p>
<p class="code11"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">filter</span>}</p>
<p class="code8"><span class="font">map fst . concat . map (test snd (one,none)) .</span></p>
<p class="code8"><span class="font">map (fork (id,p))</span></p>
<p class="code11"><span class="font">=</span><span class="space5"></span>{since <span class="font">map f . concat = concat . map (map f)</span>}</p>
<p class="code8"><span class="font">concat . map (map fst . test snd (one,none) .</span></p>
<p class="code8"><span class="font">fork (id,p))</span></p>
<p class="code11"><span class="font">=</span><span class="space5"></span>{second law of <span class="font">test</span>; laws of <span class="font">one</span> and <span class="font">none</span>}</p>
<p class="code8"><span class="font">concat . map (test snd (one . fst,none) .</span></p>
<p class="code8"><span class="font">fork (id,p))</span></p>
<p class="code11"><span class="font">=</span><span class="space5"></span>{first law of <span class="font">test</span>; laws of <span class="font">fork</span>}</p>
<p class="code8"><span class="font">concat . map (test p (one . id, none . fork (id,p)))</span></p>
<p class="code11"><span class="font">=</span><span class="space5"></span>{laws of <span class="font">id</span> and <span class="font">none</span>}</p>
<p class="code8"><span class="font">concat . map (test p (one,none))</span></p>
<p class="code11"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">filter</span>}</p>
<p class="code8"><span class="font">filter p</span></p>
<p class="number">5.<span class="space"></span>We have</p>
<p class="code11"><a id="text/part0010.html.page_144" class="calibre3"></a><span class="font">map (fork (f,g)) = uncurry zip . fork (map f,map g)</span></p>
<p class="number">6.<span class="space"></span>We have</p>
<p class="code8"><span class="font">filter (p . foldl f e) . inits</span></p>
<p class="code11"><span class="font">=</span><span class="space5"></span>{derived law of <span class="font">filter</span>}</p>
<p class="code8"><span class="font">map fst . filter snd .</span></p>
<p class="code8"><span class="font">map (fork (id, p . foldl f e)) . inits</span></p>
<p class="code11"><span class="font">=</span><span class="space5"></span>{law of <span class="font">zip</span>}</p>
<p class="code8"><span class="font">map fst . filter snd . uncurry zip .</span></p>
<p class="code8"><span class="font">fork (id, map (p . foldl f e)) . inits</span></p>
<p class="code11"><span class="font">=</span><span class="space5"></span>{law of <span class="font">fork</span>}</p>
<p class="code8"><span class="font">map fst . filter snd . uncurry zip .</span></p>
<p class="code8"><span class="font">fork (inits, map (p . foldl f e) . inits)</span></p>
<p class="code11"><span class="font">=</span><span class="space5"></span>{<span class="font">scan lemma</span>}</p>
<p class="code8"><span class="font">map fst . filter snd . uncurry zip .</span></p>
<p class="code8"><span class="font">fork (inits, map p . scanl f e)</span></p>
<p class="para"><span class="space5"></span><span class="space-r1"></span>Hence</p>
<p class="code8"><span class="font">takePrefix (p.foldl f e)</span></p>
<p class="code3"><span class="font">= fst . last . filter snd . uncurry zip .</span></p>
<p class="code3"><span class="font">fork (inits,map p . scanl f e)</span></p>
<h3 class="h" id="text/part0010.html.head6-9">6.9 Chapter notes</h3>
<p class="para">Gofer, an earlier version of Haskell designed by Mark Jones, was so named because it was GOod For Equational Reasoning. HUGS (The Haskell Users Gofer System) was an earlier alternative to GHCi, and used in the second edition of the book on which the current one is based, but is no longer maintained.</p>
<p class="para">Many people have contributed to the understanding of the laws of functional programming, too many to list. The Haskellwiki page</p>
<p class="code"><span class="font"><a href="http://haskell.org/haskellwiki/Equational_reasoning_examples" class="calibre3">haskell.org/haskellwiki/Equational_reasoning_examples</a></span></p>
<p class="para">contains examples of equational reasoning and links to various discussions about the subject.</p>
<p class="para">The fascinating history of the maximum segment sum problem is discussed in Jon Bentley’s <i class="calibre1">Programming Pearls</i> (second edition) (Addison-Wesley, 2000).</p>
</div></div>
<div id="text/part0011.html"><div id="text/part0011.html.AFM60-0daaaafc8385457e8f80971b0d39bbf7" class="calibre">

<h2 class="chapter-number" id="text/part0011.html.calibre_pb_0"><a id="text/part0011.html.page_145" class="calibre6"></a>Chapter 7</h2>
<h2 class="chapter-title">Efficiency</h2>
<p class="para">The question of efficiency has been an ever-present undercurrent in recent discussions, and the time has come to bring this important subject to the surface. The best way to achieve efficiency is, of course, to find a decent algorithm for the problem. That leads us into the larger topic of Algorithm Design, which is not the primary focus of this book. Nevertheless we will touch on some fundamental ideas later on. In the present chapter we concentrate on a more basic question: functional programming allows us to construct elegant expressions and definitions, but do we know what it costs to evaluate them? Alan Perlis, a US computer scientist, once inverted Oscar Wilde’s definition of a cynic to assert that a functional programmer was someone who knew the value of everything and the cost of nothing.</p>
<h3 class="h" id="text/part0011.html.head7-1">7.1 Lazy evaluation</h3>
<p class="para">We said in <a href="#text/part0006.html.5N3C0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 2</a> that, under lazy evaluation, an expression such as</p>
<p class="code"><span class="font">sqr (sqr (3+4))</span></p>
<p class="para">where <span class="font">sqr x = x*x</span>, is reduced to its simplest possible form by applying reduction steps from the outside in. That means the definition of the function <span class="font">sqr</span> is installed first, and its argument is evaluated only when needed. The following evaluation sequence follows this prescription, but is <i class="calibre1">not</i> lazy evaluation:</p>
<div class="space1">
<p class="code2"><span class="font">sqr (sqr (3+4))</span></p>
<p class="code"><span class="font">= sqr (3+4) * sqr (3+4)</span></p>
<p class="code"><span class="font">= ((3+4)*(3+4)) * ((3+4)*(3+4))</span></p>
<p class="code"><span class="font">= ...</span></p>
<p class="code"><span class="font">= 2401</span></p>
</div>
<p class="para"><a id="text/part0011.html.page_146" class="calibre3"></a>The ellipsis in the penultimate line hides no fewer than four evaluations of <span class="font">3+4</span> and two of <span class="font">7*7</span>. Clearly the simple policy of substituting argument expressions into function expressions is a very inefficient way of carrying out reduction.</p>
<p class="para">Instead, lazy evaluation guarantees that when the value of an argument is needed, it is evaluated <i class="calibre1">only once</i>. Under lazy evaluation, the reduction sequence would unfold basically as follows:</p>
<div class="space1">
<p class="code2"><span class="font">sqr (sqr (3+4))</span></p>
<p class="code"><span class="font">= let x = sqr (3+4) in x*x</span></p>
<p class="code"><span class="font">= let y = 3+4 in</span></p>
<p class="code2"><span class="font">let x = y*y in x*x</span></p>
<p class="code"><span class="font">= let y = 7 in</span></p>
<p class="code2"><span class="font">let x = y*y in x*x</span></p>
<p class="code"><span class="font">= let x = 49 in x*x</span></p>
<p class="code"><span class="font">= 2401</span></p>
</div>
<p class="para">The expression <span class="font">3+4</span> is evaluated only once (and so is <span class="font">7*7</span>). The names <span class="font">x</span> and <span class="font">y</span> have been <i class="calibre1">bound</i> to expressions using <span class="font">let</span>, though in the implementation of Haskell these names are anonymous <i class="calibre1">pointers</i> to expressions. When an expression is reduced to a value, the pointer then points to the value and that value can then be <i class="calibre1">shared</i>.</p>
<p class="para">Even then, the headline ‘Under lazy evaluation arguments are evaluated only when needed and then only once!’ doesn’t tell the full story. Consider evaluation of <span class="font">sqr (head xs)</span>. In order to evaluate <span class="font">sqr</span> we have to evaluate its argument, but in order to evaluate <span class="font">head xs</span> we do not have to evaluate <span class="font">xs</span> all the way, but only to the point where it becomes an expression of the form <span class="font">y:ys</span>. Then <span class="font">head xs</span> can return <span class="font">y</span> and <span class="font">sqr (head xs)</span> can return <span class="font">y*y</span>. More generally, an expression is said to be in <i class="calibre1">head normal form</i> if it is a function (such as <span class="font">sqr</span>) or if it takes the form of a data constructor (such as <span class="font">(:)</span>) applied to its arguments. Every expression in normal form (i.e. in fully reduced form) is in head normal form but not vice versa. For example, <span class="font">(e1,e2)</span> is in head normal form (because it is equivalent to <span class="font">(,) e1 e2</span>, where <span class="font">(,)</span> is the data constructor for pairs), but is in normal form only if both <span class="font">e1</span> and <span class="font">e2</span> are. Of course, for numbers or booleans there is no distinction between the two kinds of normal form.</p>
<p class="para">‘Under lazy evaluation arguments are evaluated only when needed and then only once, and then maybe only to head normal form’ is not as catchy a headline as before, but it does tell a better story.</p>
<p class="para">Next, consider the following two definitions of the inductive case of the function <span class="font">subseqs</span> that returns all the subsequences of a list:</p>
<div class="space1">
<p class="code"><a id="text/part0011.html.page_147" class="calibre3"></a><span class="font">subseqs (x:xs) = subseqs xs ++ map (x:) (subseqs xs)</span></p>
<p class="code"><span class="font">subseqs (x:xs) = xss ++ map (x:) xss</span></p>
<p class="code14"><span class="font">where xss = subseqs xs</span></p>
</div>
<p class="para">In the first definition the expression <span class="font">subseqs xs</span> appears twice on the right-hand side, so it is evaluated twice when the subsequences of a given list are required. In the second definition this duplication of effort has been recognised by the programmer and a <span class="font">where</span> clause has been used to ensure that <span class="font">subseqs xs</span> is evaluated only once (we could also have used a <span class="font">let</span> expression).</p>
<p class="para">The important point is that you, the programmer, are in control of which definition you want. It is quite possible for Haskell to recognise the double occurrence and to <i class="calibre1">abstract</i> it away using the equivalent of an internal <span class="font">let</span> expression. This is a well-known technique called <i class="calibre1">common subexpression elimination</i>. But Haskell doesn’t do this, and for a very good reason: it can cause a <i class="calibre1">space leak</i>. The second definition of <span class="font">subseqs (x:xs)</span> has the following problem: the list <span class="font">subseqs xs</span> is constructed only once, but it is retained in its entirety in memory because its value is used again, namely in the second expression <span class="font">map (x:) xss</span>.</p>
<p class="para">Look at it this way: the first definition takes longer because computation is duplicated; the second definition is faster (though still exponential) but can rapidly run out of available space. After all, there are 2<sup class="calibre8"><i class="calibre1">n</i></sup> subsequences of a list of length <i class="calibre1">n</i>. There is a fundamental dichotomy in programming we can never get away from: to avoid doing something twice you have to use up space to store the result of doing it once.</p>
<p class="para">Here is a related example. Consider the following two definitions in a script:</p>
<div class="space1">
<p class="code"><span class="font">foo1 n = sum (take n primes)</span></p>
<p class="code2"><span class="font">where</span></p>
<p class="code2"><span class="font">primes</span><span class="space4"></span><span class="font">= [x | x &lt;- [2..], divisors x == [x]]</span></p>
<p class="code2"><span class="font">divisors x = [d | d &lt;- [2..x], x `mod` d == 0]</span></p>
<p class="para1"></p>
<p class="code"><span class="font">foo2 n = sum (take n primes)</span></p>
<p class="code2"><span class="font">primes</span><span class="space4"></span><span class="font">= [x | x &lt;- [2..], divisors x == [x]]</span></p>
<p class="code2"><span class="font">divisors x = [d | d &lt;- [2..x], x `mod` d == 0]</span></p>
</div>
<p class="para">The programmer who wrote <span class="font">foo1</span> decided to structure their script by making the definitions of both <span class="font">primes</span> and <span class="font">divisors</span> local to the definition of <span class="font">foo1</span>, presumably because neither definition was used elsewhere in the script. The programmer who wrote <span class="font">foo2</span> decided to allow these two subsidiary definitions to float to the status of a global or <i class="calibre1">top-level</i> definition. You might think that doesn’t make any <a id="text/part0011.html.page_148" class="calibre3"></a>difference to the efficiency, but consider the following interaction with GHCi. (The command <span class="font">:set +s</span> turns on some statistics which are printed after an expression is evaluated.)</p>
<p class="code6"><span class="font">ghci&gt; :set +s</span></p>
<p class="code6"><span class="font">ghci&gt; foo1 1000</span></p>
<p class="code6"><span class="font">3682913</span></p>
<p class="code6"><span class="font">(4.52 secs, 648420808 bytes)</span></p>
<p class="code6"><span class="font">ghci&gt; foo1 1000</span></p>
<p class="code6"><span class="font">3682913</span></p>
<p class="code6"><span class="font">(4.52 secs, 648412468 bytes)</span></p>
<p class="code6"><span class="font">ghci&gt; foo2 1000</span></p>
<p class="code6"><span class="font">3682913</span></p>
<p class="code6"><span class="font">(4.51 secs, 647565772 bytes)</span></p>
<p class="code6"><span class="font">ghci&gt; foo2 1000</span></p>
<p class="code6"><span class="font">3682913</span></p>
<p class="code6"><span class="font">(0.02 secs, 1616096 bytes)</span></p>
<p class="para">Why was the second evaluation of <span class="font">foo2 1000</span> so much faster than the first, while the two evaluations of <span class="font">foo1 1000</span> took the same time?</p>
<p class="para">The answer is that in the definition of <span class="font">foo2</span> the first 1000 elements of the list <span class="font">primes</span> is demanded, so after evaluation <span class="font">primes</span> now points to a list in which the first 1000 primes appear explicitly. The second evaluation of <span class="font">foo 1000</span> does not require these primes to be computed again. Internally, the script has grown in size because <span class="font">primes</span> now occupies at least 1000 units of space.</p>
<p class="para">Programmer Three chooses to write <span class="font">foo</span> in the following way:</p>
<div class="space1">
<p class="code"><span class="font">foo3 = \n -&gt; sum (take n primes)</span></p>
<p class="code2"><span class="font">where</span></p>
<p class="code2"><span class="font">primes</span><span class="space4"></span><span class="font">= [x | x &lt;- [2..], divisors x == [x]]</span></p>
<p class="code2"><span class="font">divisors x = [d | d &lt;- [2..x], x `mod` d == 0]</span></p>
</div>
<p class="para">This uses a lambda expression to express <span class="font">foo3</span> at the function level, but otherwise the definition is exactly the same as that of <span class="font">foo1</span>. The alternative</p>
<p class="code"><span class="font">foo3 = sum . flip take primes</span></p>
<p class="para">also works but seems a little obscure. Now we have</p>
<p class="code6"><span class="font">ghci&gt; foo3 1000</span></p>
<p class="code6"><span class="font">3682913</span></p>
<p class="code6"><span class="font">(3.49 secs, 501381112 bytes)</span></p>
<p class="code6"><a id="text/part0011.html.page_149" class="calibre3"></a><span class="font">ghci&gt; foo3 1000</span></p>
<p class="code6"><span class="font">3682913</span></p>
<p class="code6"><span class="font">(0.02 secs, 1612136 bytes)</span></p>
<p class="para">Again, the second evaluation is much faster than the first. Why is that?</p>
<p class="para">To see what is going on, we can rewrite the two functions in the form</p>
<div class="space1">
<p class="code"><span class="font">foo1 n = let primes = ... in</span></p>
<p class="code10"><span class="font">sum (take n primes)</span></p>
<p class="code"><span class="font">foo3</span><span class="space5"></span><span class="font">= let primes = ... in</span></p>
<p class="code10"><span class="font">\n -&gt; sum (take n primes)</span></p>
</div>
<p class="para">Now you can appreciate that in the first definition <span class="font">primes</span> is re-evaluated every time <span class="font">foo1 1000</span> is called because it is bound to an application of <span class="font">foo1</span> not to the function itself. It is theoretically possible that the local definitions in the first definition depend on <span class="font">n</span>, so any such definitions have to be re-evaluated for each <span class="font">n</span>. In the second definition the local definitions are bound to the function itself (and can’t possibly depend on any argument to the function); consequently, they are evaluated only once. Of course, after evaluating <span class="font">foo3 1000</span>, the local definition of <span class="font">primes</span> will be expanded to an explicit list of 1000 elements followed by a recipe for evaluating the rest.</p>
<h3 class="h" id="text/part0011.html.head7-2">7.2 Controlling space</h3>
<p class="para">Suppose we define <span class="font">sum</span> by <span class="font">sum = foldl (+) 0</span>. Under lazy evaluation the expression <span class="font">sum [1..1000]</span> is reduced as follows</p>
<div class="space1">
<p class="code2"><span class="font">sum [1..1000]</span></p>
<p class="code"><span class="font">= foldl (+) 0 [1..1000]</span></p>
<p class="code"><span class="font">= foldl (+) (0+1) [2..1000]</span></p>
<p class="code"><span class="font">= foldl (+) ((0+1)+2) [3..1000]</span></p>
<p class="code"><span class="font">= ...</span></p>
<p class="code"><span class="font">= foldl (+) (..((0+1)+2)+ ... +1000) []</span></p>
<p class="code"><span class="font">= (..((0+1)+2)+ ... +1000)</span></p>
<p class="code"><span class="font">= ...</span></p>
<p class="code"><span class="font">= 500500</span></p>
</div>
<p class="para">It requires 1000 units of space just to build up the arithmetic expression that sums the first 1000 numbers before it pops to the surface and is finally evaluated.</p>
<p class="para">Much better is to use a mixture of lazy and eager evaluation:</p>
<p class="code2"><a id="text/part0011.html.page_150" class="calibre3"></a><span class="font">sum [1..1000]</span></p>
<p class="code"><span class="font">= foldl (+) 0 [1..1000]</span></p>
<p class="code"><span class="font">= foldl (+) (0+1) [2..1000]</span></p>
<p class="code"><span class="font">= foldl (+) 1 [2..1000]</span></p>
<p class="code"><span class="font">= foldl (+) (1+2) [3..1000]</span></p>
<p class="code"><span class="font">= foldl (+) 3 [3..1000]</span></p>
<p class="code"><span class="font">= ...</span></p>
<p class="code"><span class="font">= foldl (+) 500500 []</span></p>
<p class="code"><span class="font">= 500500</span></p>
<p class="para">While the list expression <span class="font">[1..1000]</span> is evaluated lazily, the second argument of <span class="font">foldl</span>, the accumulated sum, is evaluated eagerly. The result of interleaving lazy and eager evaluation steps is a sequence that uses a constant amount of space.</p>
<p class="para">This suggests that it would be useful to have some way of controlling the reduction order. Such a method is provided by a primitive function <span class="font">seq</span> with type</p>
<p class="code"><span class="font">seq :: a -&gt; b -&gt; b</span></p>
<p class="para">Evaluation of <span class="font">x `seq` y</span> proceeds by first evaluating <span class="font">x</span> (to head normal form) and then returning the result of evaluating <span class="font">y</span>. If evaluation of <span class="font">x</span> does not terminate, then neither does <span class="font">x `seq` y</span>. It’s not possible to define <span class="font">seq</span> in Haskell; instead Haskell provides it as a primitive function.</p>
<p class="para">Now consider the following version <span class="font">foldl'</span> of <span class="font">foldl</span> that evaluates its second argument strictly:</p>
<div class="space1">
<p class="code"><span class="font">foldl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</span></p>
<p class="code"><span class="font">foldl' f e [] = e</span></p>
<p class="code"><span class="font">foldl' f e (x:xs) = y `seq` foldl' f y xs</span></p>
<p class="code16"><span class="font">where y = f e x</span></p>
</div>
<p class="para">Haskell provides the function <span class="font">foldl'</span> in the standard prelude (yes, with just this unimaginative name). Now we can define <span class="font">sum = foldl' (+) 0</span>, with the consequence that evaluation proceeds in constant space. In fact, <span class="font">sum</span> is another prelude function with essentially this definition.</p>
<p class="para">Is it the case that <span class="font">foldl</span> is now redundant and can be replaced by the new improved <span class="font">foldl'</span>? The answer is in practice yes, but in theory no. It is possible to construct <span class="font">f</span>, <span class="font">e</span> and <span class="font">xs</span> such that</p>
<p class="center"><span class="font">foldl f e xs</span> ≠ <span class="font">foldl' f e xs</span></p>
<p class="para">However, when <span class="font">f</span> is strict (recall that <i class="calibre1">f</i> is strict if <i class="calibre1">f</i> ⊥=⊥) the two expressions do return the same result. The exercises go into details.</p>
<p class="center"><a id="text/part0011.html.page_151" class="calibre3"></a><i class="calibre1">Taking the mean</i></p>
<p class="para">Armed with the above information, let’s now consider a very instructive example: how to compute the average or <i class="calibre1">mean</i> of a list of numbers. Surely that is an easy problem, you might think, just divide the sum of the list by the length of the list:</p>
<div class="space1">
<p class="code"><span class="font">mean :: [Float] -&gt; Float</span></p>
<p class="code"><span class="font">mean xs = sum xs / length xs</span></p>
</div>
<p class="para">There are lots of things wrong with this definition, not the least of which is that the expression on the right is not well-formed! The function <span class="font">length</span> in Haskell has type <span class="font">[a] -&gt; Int</span> and we can’t divide a <span class="font">Float</span> by an <span class="font">Int</span> without performing an explicit conversion.</p>
<p class="para">There is a function in the standard prelude that comes to our aid:</p>
<div class="space1">
<p class="code"><span class="font">fromIntegral :: (Integral a, Num b) =&gt; a -&gt; b</span></p>
<p class="code"><span class="font">fromIntegral = fromInteger . toInteger</span></p>
</div>
<p class="para">Recall from <a href="#text/part0007.html.6LJU0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 3</a> the two conversion functions</p>
<div class="space1">
<p class="code"><span class="font">toInteger</span><span class="space5"></span><span class="font">:: (Integral a) =&gt; a -&gt; Integer</span></p>
<p class="code"><span class="font">fromInteger :: (Num a) =&gt; Integer -&gt; a</span></p>
</div>
<p class="para">The first converts any integral type to an integer, and the second converts an integer to a number. Their composition converts an integral number, such as <span class="font">Int</span>, to a more general kind of number, such as <span class="font">Float</span>.</p>
<p class="para">We can now rewrite <span class="font">mean</span> to read</p>
<div class="space1">
<p class="code"><span class="font">mean :: [Float] -&gt; Float</span></p>
<p class="code"><span class="font">mean xs = sum xs / fromIntegral (length xs)</span></p>
</div>
<p class="para">The second thing wrong with this definition is that it silently ignores the case of the empty list. What is <span class="font">0/0</span>? Either we should identify the failing case with an explicit error message, or else adopt one common convention, which is to agree that the mean of the empty list should be zero:</p>
<div class="space1">
<p class="code"><span class="font">mean [] = 0</span></p>
<p class="code"><span class="font">mean xs = sum xs / fromIntegral (length xs)</span></p>
</div>
<p class="para">Now we are ready to see what is <i class="calibre1">really</i> wrong with <span class="font">mean</span>: it has a space leak. Evaluating <span class="font">mean [1..1000]</span> will cause the list to be expanded and retained in memory after summing because there is a <i class="calibre1">second pointer</i> to it, namely in the computation of its length.</p>
<p class="para"><a id="text/part0011.html.page_152" class="calibre3"></a>We can replace the two traversals of the list by one, using a strategy of program optimisation called <i class="calibre1">tupling</i>. The idea is simple enough in the present example: define <span class="font">sumlen</span> by</p>
<div class="space1">
<p class="code"><span class="font">sumlen :: [Float] -&gt; (Float,Int)</span></p>
<p class="code"><span class="font">sumlem xs = (sum xs,length xs)</span></p>
</div>
<p class="para">and then calculate an alternative definition that avoids the two traversals. It is easy to carry out the calculation and we just state the result:</p>
<div class="space1">
<p class="code"><span class="font">sumlen []</span><span class="space4"></span><span class="font">= (0,0)</span></p>
<p class="code"><span class="font">sumlen (x:xs) = (s+x,n+1) where (s,n) = sumlen xs</span></p>
</div>
<p class="para">The pattern of the definition of <span class="font">sumlen</span> should be familiar by now. An alternative definition is</p>
<p class="code"><span class="font">sumlen = foldr f (0,0) where f x (s,n) = (s+x,n+1)</span></p>
<p class="para">Even better, we can replace <span class="font">foldr f</span> by <span class="font">foldl g</span>, where</p>
<p class="code"><span class="font">g (s,n) x = (s+x,n+1)</span></p>
<p class="para">The justification of this step is the law in the previous chapter that said</p>
<p class="code"><span class="font">foldr f e xs = foldl g e xs</span></p>
<p class="para">for all finite lists <span class="font">xs</span>, provided</p>
<div class="space1">
<p class="code"><span class="font">f x (g y z) = g (f x y) z</span></p>
<p class="code"><span class="font">f x e = g e x</span></p>
</div>
<p class="para">The verification of these two conditions is left as an exercise.</p>
<p class="para">And that means we can use <span class="font">foldl'</span>:</p>
<p class="code"><span class="font">sumlen = foldl' g (0,0) where g (s,n) x = (s+x,n+1)</span></p>
<p class="para">Now we can replace our heavily criticised definition of <span class="font">mean</span> by</p>
<div class="space1">
<p class="code"><span class="font">mean [] = 0</span></p>
<p class="code"><span class="font">mean xs = s / fromIntegral n</span></p>
<p class="code10"><span class="font">where (s,n) = sumlen xs</span></p>
</div>
<p class="para">Surely we have now achieved our goal of a constant-space computation for <span class="font">mean</span>?</p>
<p class="para">Unfortunately not. The problem is with <span class="font">sumlen</span> and it is a little tricky to spot. Expanding the definition out a little, we find</p>
<div class="space1">
<p class="code"><a id="text/part0011.html.page_153" class="calibre3"></a><span class="font">foldl' f (s,n) (x:xs) = y `seq` foldl' f y xs</span></p>
<p class="code16"><span class="space5"></span><span class="font">where y = (s+x,n+1)</span></p>
</div>
<p class="para">Ah, but <span class="font">y `seq` z</span> reduces <span class="font">y</span> to head normal form and the expression <span class="font">(s+x,n+1)</span> is already in head normal form. Its two components are not evaluated until the end of the computation. That means we have to dig deeper with our <span class="font">seq</span>s and rewrite <span class="font">sumlen</span> in the following way:</p>
<div class="space1">
<p class="code"><span class="font">sumlen = foldl' f (0,0)</span></p>
<p class="code2"><span class="font">where f (s,n) x = s `seq` n `seq` (s+x,n+1)</span></p>
</div>
<p class="para">Finally, everything in the garden is rosy and we have a computation that runs in constant space.</p>
<p class="center"><i class="calibre1">Two more application operators</i></p>
<p class="para">Function application is the only operation not denoted by any visible sign. However, Haskell provides two more application operators, <span class="font">($)</span> and <span class="font">($!)</span>:</p>
<div class="space1">
<p class="code"><span class="font">infixr 0 $,$!</span></p>
<p class="code"><span class="font">($),($!) :: (a -&gt; b) -&gt; a -&gt; b</span></p>
<p class="code"><span class="font">f $ x = f x</span></p>
<p class="code"><span class="font">f $! x = x `seq` f x</span></p>
</div>
<p class="para">The only difference between <span class="font">f x</span> and <span class="font">f $! x</span> is that in the second expression the argument <span class="font">x</span> is evaluated <i class="calibre1">before</i> <span class="font">f</span> is applied. The only difference between <span class="font">f x</span> and <span class="font">f $ x</span> is that <span class="font">($)</span> (and also <span class="font">($!)</span>) is declared to have the lowest binding power of 0 and to associate to the right in expressions. That is exactly what the <i class="calibre1">fixity</i> declaration in the first line provides. Why do we want that?</p>
<p class="para">The answer is that we can now write, for example</p>
<p class="code"><span class="font">process1 $ process2 $ process3 input</span></p>
<p class="para">instead of having to write either of</p>
<div class="space1">
<p class="code"><span class="font">process1 (process2 (process3 x))</span></p>
<p class="code"><span class="font">(process1 . process2 . process3) x</span></p>
</div>
<p class="para">It is undeniable that <span class="font">($)</span> can be quite useful on occasions, especially when submitting expressions for evaluation with GHCi, so it’s worth mentioning its existence. And the strict application operator <span class="font">($!)</span> is useful for the reasons discussed above.</p>
<h3 class="h" id="text/part0011.html.head7-3"><a id="text/part0011.html.page_154" class="calibre6"></a>7.3 Controlling time</h3>
<p class="para">We have seen that having an ‘eager’ button on our dashboard is a very simple way of controlling the space involved in driving a computation, but what about time? Unfortunately there is no analogous button for speeding up computations; instead we have to understand some of the things that can unintentionally slow down a computation. The Haskell platform comes with documentation on GHC, which contains useful advice on how to make your program run more quickly. The documentation makes three key points:</p>
<ul class="calibre9">
<li class="calibre10">Make use of GHC’s <i class="calibre1">profiling</i> tools. There is no substitute for finding out where your program’s time and space is really being used up. We will not discuss profiling in this book, but it is important to mention that such tools are available.</li>
<li class="calibre10">The best way to improve a program’s performance is to use a better algorithm. We mentioned this point at the beginning of the chapter.</li>
<li class="calibre10">It is far better to use library functions that have been Seriously Tuned by Someone Else, than to craft your own. You might be able to write a better sorting algorithm than the one provided in <span class="font">Data.List</span>, but it will take you longer than just writing <span class="font">import Data.List (sort)</span>. This is particularly true when you use GHCi because GHCi loads <i class="calibre1">compiled</i> versions of the functions in its standard libraries. Compiled functions typically run about an order of magnitude faster than interpreted ones.</li>
</ul>
<p class="para">Much of the detailed advice in the GHC documentation is beyond the scope of this book, but two tips can be explained here. Firstly, the management of lazy evaluation involves more overheads than eager evaluation, so that if you know that a function’s value will be needed, it is better to push the eager button. As the documentation says: ‘Strict functions are your dear friends’.</p>
<p class="para">The second piece of advice is about types. Firstly, <span class="font">Int</span> arithmetic is faster than <span class="font">Integer</span> arithmetic because Haskell has to perform more work in handling potentially very large numbers. So, use <span class="font">Int</span> rather than <span class="font">Integer</span> whenever it is safe to do so. Secondly, there is less housekeeping work for Haskell if you tailor the type of your function to the instance you want. For example, consider the type of <span class="font">foo1</span>, defined in <a href="#text/part0011.html.head7-1" class="calibre3">Section 7.1</a>. There we did not provide a type signature for <span class="font">foo1</span> (or indeed for any of the other related functions) and that was a mistake. It turns out that</p>
<p class="code"><span class="font">foo1 :: Integral a =&gt; Int -&gt; a</span></p>
<p class="para"><a id="text/part0011.html.page_155" class="calibre3"></a>If we are really interested in the sum of the first <i class="calibre1">n</i> prime numbers, it is better to declare the type of <span class="font">foo1</span> to be (say)</p>
<p class="code"><span class="font">foo1 :: Int -&gt; Integer</span></p>
<p class="para">With this more specialised definition Haskell does not have to carry around a dictionary of the methods and instances of the type class <span class="font">Integral</span>, and that lightens the load.</p>
<p class="para">These pieces of advice can help shave off constant amounts of time and do not affect <i class="calibre1">asymptotic</i> time complexity, the order of magnitude of the timing function. But sometimes we can write code that is inadvertently less efficient asymptotically than we intended. Here is an instructive example. Consider the cartesian product function <span class="font">cp</span> discussed in <a href="#text/part0009.html.8IL20-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 5</a>:</p>
<div class="space1">
<p class="code"><span class="font">cp [] = [[]]</span></p>
<p class="code"><span class="font">cp (xs:xss) = [x:ys | x &lt;- xs, ys &lt;- cp xss]</span></p>
</div>
<p class="para">Pretty and clear enough you would think, but compare it with</p>
<div class="space1">
<p class="code"><span class="font">cp' = foldr op [[]]</span></p>
<p class="code2"><span class="font">where op xs yss = [x:ys | x &lt;- xs, ys &lt;- yss]</span></p>
</div>
<p class="para">The first version is a direct recursive definition, while the second uses <span class="font">foldr</span> to encapsulate the pattern of the recursion. The two ‘algorithms’ are the same, aren’t they? Well,</p>
<p class="code6"><span class="font">ghci&gt; sum $ map sum $ cp [[1..10] | j &lt;- [1..6]]</span></p>
<p class="code6"><span class="font">33000000</span></p>
<p class="code6"><span class="font">(12.11 secs, 815874256 bytes)</span></p>
<p class="code6"><span class="font">ghci&gt; sum $ map sum $ cp' [[1..10] | j &lt;- [1..6]]</span></p>
<p class="code6"><span class="font">33000000</span></p>
<p class="code6"><span class="font">(4.54 secs, 369640332 bytes)</span></p>
<p class="para">The expression <span class="font">sum $ map sum</span> is there just to force complete evaluation of the cartesian product. Why is the first computation three times slower than the second?</p>
<p class="para">To answer this question, look at the translation that eliminates the list comprehension in the first definition:</p>
<div class="space1">
<p class="code"><span class="font">cp [] = [[]]</span></p>
<p class="code"><span class="font">cp (xs:xss) = concat (map f xs)</span></p>
<p class="code8"><span class="font">where f x = [x:ys | ys &lt;- cp xss]</span></p>
</div>
<p class="para">Now we can see that <span class="font">cp xss</span> is evaluated <i class="calibre1">each time</i> <span class="font">f</span> is applied to elements of <span class="font">xs</span>. That means, in the examples above, that <span class="font">cp</span> is evaluated many more times in <a id="text/part0011.html.page_156" class="calibre3"></a>the first example than in the second. We cannot be more precise at this point, but will be below when we develop a little calculus for estimating running times. But the issue should be clear enough: the simple recursive definition of <span class="font">cp</span> has led us inadvertently into a situation in which more evaluations are carried out than we intended.</p>
<p class="para">One other way to get a more efficient cartesian product is to just write</p>
<div class="space1">
<p class="code"><span class="font">cp []</span><span class="space2"></span><span class="font">= [[]]</span></p>
<p class="code"><span class="font">cp (xs:xss) = [x:ys | x &lt;- xs, ys &lt;- yss]</span></p>
<p class="code9"><span class="font">where yss = cp xss</span></p>
</div>
<p class="para">This definition has exactly the same efficiency as the one in terms of <span class="font">foldr</span>. The lesson here is that innocent-looking list comprehensions can hide the fact that some expressions, though only written once, are evaluated multiple times.</p>
<h3 class="h" id="text/part0011.html.head7-4">7.4 Analysing time</h3>
<p class="para">Given the definition of a function <span class="font">f</span> we will write <i class="calibre1">T</i>(<span class="font">f</span>)(<i class="calibre1">n</i>) to denote an asymptotic estimate of the number of reduction steps required to evaluate <span class="font">f</span> on an argument of ‘size’ <i class="calibre1">n</i> in the worst case. Moreover, for reasons explained in a moment, we will assume eager, not lazy, evaluation as the reduction strategy involved in defining <i class="calibre1">T</i>.</p>
<p class="para">The definition of <i class="calibre1">T</i> requires some amplification. Firstly, <i class="calibre1">T</i>(<span class="font">f</span>) refers to the complexity of a given <i class="calibre1">definition</i> of <span class="font">f</span>. Time complexity is a property of an expression, not of the value of that expression.</p>
<p class="para">Secondly, the number of reduction steps does not correspond exactly to the elapsed time between submitting an expression for evaluation and waiting for the answer. No account is taken of the time to find the next subexpression to be reduced in a possibly large and complicated expression. For this reason the statistics facility of GHCi does not count reduction steps, but produces a measure of elapsed time.</p>
<p class="para">Thirdly, we do not formalise the notion of size, since different measures are appropriate in different situations. For example, the cost of evaluating <span class="font">xs++ys</span> is best measured in terms of (<i class="calibre1">m</i>, <i class="calibre1">n</i>), a pair describing the lengths of the two lists. In the case of <span class="font">concat xss</span> we could take the length of <span class="font">concat xss</span> as a measure of size, but if <span class="font">xss</span> is a list of length <i class="calibre1">m</i> consisting of lists all of length <i class="calibre1">n</i>, then (<i class="calibre1">m</i>, <i class="calibre1">n</i>) might be a more suitable measure.</p>
<p class="para">The fourth and crucial remark is that <i class="calibre1">T</i>(<span class="font">f</span>)(<i class="calibre1">n</i>) is determined under an <i class="calibre1">eager</i> evaluation model of reduction. The reason is simply that estimating the number of <a id="text/part0011.html.page_157" class="calibre3"></a>reduction steps under lazy evaluation is difficult. To illustrate, consider the definition <span class="font">minimum = head . sort</span>. Under eager evaluation, the time to evaluate the minimum on a list of length <i class="calibre1">n</i> under this definition is given by</p>
<p class="equationasimage"><i class="calibre1">T</i>(<span class="font">minimum</span>)(<i class="calibre1">n</i>) = <i class="calibre1">T</i>(<span class="font">sort</span>)(<i class="calibre1">n</i>) + <i class="calibre1">T</i>(<span class="font">head</span>)(<i class="calibre1">n</i>).</p>
<p class="para">In other words we first have to completely sort a list of length <i class="calibre1">n</i> and then take the head of the result (presumably a constant-time operation). This equation does not hold under lazy evaluation, since the number of reduction steps required to find the head of <span class="font">sort xs</span> requires only that <span class="font">sort xs</span> be reduced to head normal form. How long that takes depends on the precise algorithm used for <span class="font">sort</span>. Timing analysis under eager reduction is simpler because it is <i class="calibre1">compositional</i>. Since lazy evaluation never requires more reduction steps than eager evaluation, any upper bound for <i class="calibre1">T</i>(<span class="font">f</span>)(<i class="calibre1">n</i>) will also be an upper bound under lazy evaluation. Furthermore, in many cases of interest, a lower bound will also be a lower bound under lazy evaluation.</p>
<p class="para">In order to give some examples of timing analyses we have to introduce a little order notation. So far, we have used the awkward phrase ‘taking a number of steps proportional to’ whenever efficiency is discussed. It is time to replace it by something shorter. Given two functions <i class="calibre1">f</i> and <i class="calibre1">g</i> on the natural numbers, we say that <i class="calibre1">f</i> is of order <i class="calibre1">g</i>, and write <i class="calibre1">f</i> = Θ(<i class="calibre1">g</i>) if there are positive constants <i class="calibre1">C</i><sub class="calibre11">1</sub> and <i class="calibre1">C</i><sub class="calibre11">2</sub> and a natural number <i class="calibre1">n</i><sub class="calibre11">0</sub> such that <i class="calibre1">C</i><sub class="calibre11">1</sub><i class="calibre1">g</i>(<i class="calibre1">n</i>) ≤ <i class="calibre1">f</i> (<i class="calibre1">n</i>) ≤ <i class="calibre1">C</i><sub class="calibre11">2</sub><i class="calibre1">g</i>(<i class="calibre1">n</i>) for all <i class="calibre1">n</i> &gt; <i class="calibre1">n</i><sub class="calibre11">0</sub>. In other words, <i class="calibre1">f</i> is bounded above and below by some constant times <i class="calibre1">g</i> for all sufficiently large arguments.</p>
<p class="para">The notation is abused to the extent that one conventionally writes, for example, <i class="calibre1">f</i> (<i class="calibre1">n</i>) = Θ(<i class="calibre1">n</i><sup class="calibre8"><sub class="calibre19">2</sub></sup>) rather than the more correct <i class="calibre1">f</i> = Θ(λ<i class="calibre1">n</i>.<i class="calibre1">n</i><sub class="calibre11">2</sub>). Similarly, one writes <i class="calibre1">f</i> (<i class="calibre1">n</i>) = Θ(<i class="calibre1">n</i>) rather than <i class="calibre1">f</i> = Θ(<i class="calibre1">id</i>). The main use of Θ-notation is to hide constants; for example, we can write</p>
<p class="equationasimage"><img src="data:image/jpeg;base64,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" alt="image" class="calibre2"></p>
<p class="para">without bothering about the exact constants involved. When Θ(<i class="calibre1">g</i>) appears in a formula it stands for some unnamed function <i class="calibre1">f</i> satisfying <i class="calibre1">f</i> = Θ(<i class="calibre1">g</i>). In particular, Θ(1) denotes an anonymous constant.</p>
<p class="para">With that behind us, we give three examples of how to analyse the running time of a computation. Consider first the following two definitions of <span class="font">concat</span>:</p>
<div class="space1">
<p class="code"><span class="font">concat xss</span><span class="space-toc1"></span><span class="font">= foldr (++) [] xss</span></p>
<p class="code"><span class="font">concat' xss = foldl (++) [] xss</span></p>
</div>
<p class="para">The two definitions are equivalent provided <span class="font">xss</span> is a finite list. Suppose <span class="font">xss</span> is a</p>
<p class="para"><a id="text/part0011.html.page_158" class="calibre3"></a>list of length <i class="calibre1">m</i> of lists all of length <i class="calibre1">n</i>. Then the first definition gives</p>
<p class="code1"><i class="calibre1">T</i>(<span class="font">concat</span>)(<i class="calibre1">m</i>, <i class="calibre1">n</i>) = <i class="calibre1">T</i>(<span class="font">foldr (++) []</span>)(<i class="calibre1">m</i>, <i class="calibre1">n</i>),</p>
<p class="code2">&nbsp;<i class="calibre1">T</i>(<span class="font">foldr (++) []</span>)(0, <i class="calibre1">n</i>) = Θ(1),</p>
<p class="code"><i class="calibre1">T</i>(<span class="font">foldr (++) []</span>)(<i class="calibre1">m</i>+1, <i class="calibre1">n</i>) = <i class="calibre1">T</i>(<span class="font">++</span>)(<i class="calibre1">n</i>, <i class="calibre1">mn</i>) +</p>
<p class="code16"><span class="space"></span><i class="calibre1">T</i>(<span class="font">foldr (++) []</span>)(<i class="calibre1">m</i>, <i class="calibre1">n</i>).</p>
<p class="para">The estimate <i class="calibre1">T</i>(<span class="font">++</span>)(<i class="calibre1">n</i>, <i class="calibre1">mn</i>) arises because a list of length <i class="calibre1">n</i> is concatenated with a list of length <i class="calibre1">mn</i>. Since <i class="calibre1">T</i>(<span class="font">++</span>)(<i class="calibre1">n</i>, <i class="calibre1">m</i>) = Θ(<i class="calibre1">n</i>), we obtain</p>
<p class="equationasimage"><img src="data:image/jpeg;base64,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" alt="image" class="calibre2"></p>
<p class="para">For the second definition of <span class="font">concat</span> we have</p>
<p class="code1"><i class="calibre1">T</i>(<span class="font">concat'</span>)(<i class="calibre1">m</i>, <i class="calibre1">n</i>) = <i class="calibre1">T</i>(<span class="font">foldl (++)</span>)(0, <i class="calibre1">m</i>, <i class="calibre1">n</i>),</p>
<p class="code11">&nbsp;<i class="calibre1">T</i>(<span class="font">foldl (++)</span>)(<i class="calibre1">k</i>, 0, <i class="calibre1">n</i>) = <i class="calibre1">O</i>(1),</p>
<p class="code2"><i class="calibre1">T</i>(<span class="font">foldl (++)</span>)(<i class="calibre1">k</i>, <i class="calibre1">m</i>+1, <i class="calibre1">n</i>) = <i class="calibre1">T</i>(<span class="font">++</span>)(<i class="calibre1">k</i>, <i class="calibre1">n</i>) +</p>
<p class="code16"><span class="space-toc1"></span><i class="calibre1">T</i>(<span class="font">foldl (++)</span>)(<i class="calibre1">k</i>+<i class="calibre1">n</i>, <i class="calibre1">m</i>, <i class="calibre1">n</i>).</p>
<p class="para">The additional argument <i class="calibre1">k</i> refers to the length of the accumulated list in the second argument of <span class="font">foldl</span>. This time we obtain</p>
<p class="equationasimage"><img src="data:image/jpeg;base64,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" alt="image" class="calibre2"></p>
<p class="para">Hence <i class="calibre1">T</i>(<span class="font">concat'</span>)(<i class="calibre1">m</i>, <i class="calibre1">n</i>) = Θ(<i class="calibre1">m</i><sub class="calibre11">2</sub> <i class="calibre1">n</i>). The conclusion, which was anticipated in the previous chapter, is that using <span class="font">foldr</span> rather than <span class="font">foldl</span> in the definition of <span class="font">concat</span> leads to an asymptotically faster program.</p>
<p class="para">For the second example let us time the two programs for <span class="font">subseqs</span> discussed in <a href="#text/part0011.html.head7-1" class="calibre3">Section 7.1</a>, where we had either of the following two possibilities: </p>
<div class="space1">
<p class="code"><span class="font">subseqs (x:xs)</span><span class="space-toc1"></span><span class="font">= subseqs xs ++ map (x:) (subseqs xs)</span></p>
<p class="code"><span class="font">subseqs' (x:xs) = xss ++ map (x:) xss</span></p>
<p class="code5"><span class="font">where xss = subseqs' xs</span></p>
</div>
<p class="para">Bearing in mind that (i) if <span class="font">xs</span> has length <i class="calibre1">n</i>, then <span class="font">subseqs xs</span> has length 2<sup class="calibre8"><i class="calibre1">n</i></sup>; and (ii) the time for both the concatenation and for applying <span class="font">map (x:)</span> is therefore Θ(2<sup class="calibre8"><i class="calibre1">n</i></sup>), the two timing analyses give</p>
<p class="center"><span class="space-r"></span><i class="calibre1">T</i>(<span class="font">subseqs</span>)(<i class="calibre1">n</i>+1) = 2<i class="calibre1">T</i>(<span class="font">subseqs</span>)(<i class="calibre1">n</i>) +Θ(2<sup class="calibre8"><i class="calibre1">n</i></sup>),</p>
<p class="center"><i class="calibre1">T</i>(<span class="font">subseqs'</span>)(<i class="calibre1">n</i>+1) = <i class="calibre1">T</i>(<span class="font">subseqs'</span>)(<i class="calibre1">n</i>) +Θ(2<sup class="calibre8"><i class="calibre1">n</i></sup>)</p>
<p class="para"><a id="text/part0011.html.page_159" class="calibre3"></a>together with <i class="calibre1">T</i>(<span class="font">subseqs</span>)(0) = Θ(1). We will just state the two solutions (which can be proved by a simple induction argument):</p>
<p class="center"><span class="space-r"></span><i class="calibre1">T</i>(<span class="font">subseqs</span>)(<i class="calibre1">n</i>) = Θ(<i class="calibre1">n</i>2<sup class="calibre8"><i class="calibre1">n</i></sup>),</p>
<p class="center"><i class="calibre1">T</i>(<span class="font">subseqs'</span>)(<i class="calibre1">n</i>) = Θ(2<sup class="calibre8"><i class="calibre1">n</i></sup>).</p>
<p class="para">The latter is therefore asymptotically faster than the former by a logarithmic factor.</p>
<p class="para">For the third example, let us time the two programs for <span class="font">cp</span> discussed at the beginning of this section. The first one was</p>
<div class="space1">
<p class="code"><span class="font">cp []</span><span class="space2"></span><span class="font">= [[]]</span></p>
<p class="code"><span class="font">cp (xs:xss) = [x:ys | x &lt;- xs, ys &lt;- cp xss]</span></p>
</div>
<p class="para">Suppose once again that <span class="font">xss</span> is a list of length <i class="calibre1">m</i> of lists all of length <i class="calibre1">n</i>. Then the length of <span class="font">cp xss</span> is <i class="calibre1">n</i><sup class="calibre8"><i class="calibre1">m</i></sup>. Then we have</p>
<p class="center">&nbsp;<i class="calibre1">T</i>(<span class="font">cp</span>)(0, <i class="calibre1">n</i>) = Θ(1),</p>
<p class="center"><i class="calibre1">T</i>(<span class="font">cp</span>)(<i class="calibre1">m</i>+1, <i class="calibre1">n</i>) = <i class="calibre1">nT</i>(<span class="font">cp</span>)(<i class="calibre1">m</i>, <i class="calibre1">n</i>) +Θ(<i class="calibre1">n</i><sup class="calibre8"><i class="calibre1">m</i></sup>).</p>
<p class="para">because it takes Θ(<i class="calibre1">n</i><sup class="calibre8"><i class="calibre1">m</i></sup>) steps to apply <span class="font">(x:)</span> to every subsequence. The solution is</p>
<p class="center"><i class="calibre1">T</i>(<span class="font">cp</span>)(<i class="calibre1">m</i>, <i class="calibre1">n</i>) = Θ(<i class="calibre1">mn</i><sup class="calibre8"><i class="calibre1">m</i></sup>).</p>
<p class="para">On the other hand, the definition of <span class="font">cp</span> in terms for <span class="font">foldr</span> gives</p>
<p class="center">&nbsp;<i class="calibre1">T</i>(<span class="font">cp</span>)(0, <i class="calibre1">n</i>) = Θ(1),</p>
<p class="center"><i class="calibre1">T</i>(<span class="font">cp</span>)(<i class="calibre1">m</i>+1, <i class="calibre1">n</i>) = <i class="calibre1">T</i>(<span class="font">cp</span>)(<i class="calibre1">m</i>, <i class="calibre1">n</i>) +Θ(<i class="calibre1">n</i><sup class="calibre8"><i class="calibre1">m</i></sup>).</p>
<p class="para">with solution <i class="calibre1">T</i>(<span class="font">cp</span>)(<i class="calibre1">m</i>, <i class="calibre1">n</i>) = Θ(<i class="calibre1">n</i><sup class="calibre8"><i class="calibre1">m</i></sup>). The second version is therefore asymptotically faster, again by a logarithmic factor.</p>
<h3 class="h" id="text/part0011.html.head7-5">7.5 Accumulating parameters</h3>
<p class="para">Sometimes we can improve the running time of a computation by adding an extra argument, called an <i class="calibre1">accumulating parameter</i>, to a function. The canonical example is the function <span class="font">reverse</span>:</p>
<div class="space1">
<p class="code"><span class="font">reverse []</span><span class="space4"></span><span class="font">= []</span></p>
<p class="code"><span class="font">reverse (x:xs) = reverse xs ++ [x]</span></p>
</div>
<p class="para">With this definition we have <i class="calibre1">T</i>(<span class="font">reverse</span>)(<i class="calibre1">n</i>) = Θ(<i class="calibre1">n</i><sub class="calibre11">2</sub>). In search of a linear-time program, suppose we define</p>
<div class="space1">
<p class="code"><a id="text/part0011.html.page_160" class="calibre3"></a><span class="font">revcat :: [a] -&gt; [a] -&gt; [a]</span></p>
<p class="code"><span class="font">revcat xs ys = reverse xs ++ ys</span></p>
</div>
<p class="para">It is clear that <span class="font">reverse xs</span> = <span class="font">revcat xs []</span>, so if we can obtain an efficient version of <span class="font">revcat</span> we can obtain an efficient version of <span class="font">reverse</span>. To this end we calculate a recursive definition of <span class="font">revcat</span>. The base case <span class="font">revcat [] ys = ys</span> is left as an exercise, and the inductive case is as follows:</p>
<p class="code9"><span class="font">revcat (x:xs) ys</span></p>
<p class="code12">=<span class="space"></span>{definition of <span class="font">revcat</span>}</p>
<p class="code9"><span class="font">reverse (x:xs) ++ ys</span></p>
<p class="code12">=<span class="space"></span>{definition of <span class="font">reverse</span>}</p>
<p class="code9"><span class="font">(reverse xs ++ [x]) ++ ys</span></p>
<p class="code12">=<span class="space"></span>{associativity of <span class="font">(++)</span>}</p>
<p class="code9"><span class="font">reverse xs ++ ([x] ++ ys)</span></p>
<p class="code12">=<span class="space"></span>{definition of <span class="font">(:)</span>}</p>
<p class="code9"><span class="font">reverse xs ++ (x:ys)</span></p>
<p class="code12">=<span class="space"></span>{definition of <span class="font">revcat</span>}</p>
<p class="code9"><span class="font">revcat xs (x:ys)</span></p>
<p class="para">Hence</p>
<div class="space1">
<p class="code"><span class="font">revcat [] ys</span><span class="space4"></span><span class="font">= ys</span></p>
<p class="code"><span class="font">revcat (x:xs) ys = revcat xs (x:ys)</span></p>
</div>
<p class="para">As to the running time, <i class="calibre1">T</i>(<span class="font">revcat</span>)(<i class="calibre1">m</i>, <i class="calibre1">n</i>) = Θ(<i class="calibre1">m</i>). In particular,</p>
<p class="equationasimage"><i class="calibre1">T</i>(<span class="font">reverse</span>(<i class="calibre1">n</i>) = <i class="calibre1">T</i>(<span class="font">revcat</span>(<i class="calibre1">n</i>, 0) = Θ(<i class="calibre1">n</i>)</p>
<p class="para">That gives a linear-time computation for reversing a list.</p>
<p class="para">Here is another example. The function <span class="font">length</span> is defined by</p>
<div class="space1">
<p class="code"><span class="font">length :: [a] -&gt; Int</span></p>
<p class="code"><span class="font">length []</span><span class="space4"></span><span class="font">= 0</span></p>
<p class="code"><span class="font">length (x:xs) = length xs + 1</span></p>
</div>
<p class="para">We have <i class="calibre1">T</i>(<span class="font">length</span>)(<i class="calibre1">n</i>) = Θ(<i class="calibre1">n</i>), so there is no time advantage in calculating another definition. Nevertheless, define <span class="font">lenplus</span> by</p>
<div class="space1">
<p class="code"><span class="font">lenplus :: [a] -&gt; Int -&gt; Int</span></p>
<p class="code"><span class="font">lenplus xs n = length xs + n</span></p>
</div>
<p class="para"><a id="text/part0011.html.page_161" class="calibre3"></a>If we go through exactly the same calculation for <span class="font">lenplus</span> as we did for <span class="font">revcat</span>, we arrive at</p>
<div class="space1">
<p class="code"><span class="font">lenplus [] n</span><span class="space4"></span><span class="font">= n</span></p>
<p class="code"><span class="font">lenplus (x:xs) n = lenplus xs (1+n)</span></p>
</div>
<p class="para">The reason the calculation goes through is that <span class="font">(+)</span>, like <span class="font">(++)</span>, is an associative operation. The advantage of defining</p>
<p class="code"><span class="font">length xs = lenplus xs 0 = foldl (\n x -&gt; 1+n) 0 xs</span></p>
<p class="para">is that, by using <span class="font">foldl'</span> in place of <span class="font">foldl</span>, the length of a list can be computed in constant space. That indeed is how <span class="font">length</span> is defined in Haskell’s prelude.</p>
<p class="para">As the really astute reader might have spotted, there is actually no need to go through the calculations above. Both the examples are, in fact, instances of a law already described in the previous chapter, namely that</p>
<p class="code"><span class="font">foldr (&lt;&gt;) e xs = foldl (@) e xs</span></p>
<p class="para">for all finite lists <span class="font">xs</span> provided</p>
<p class="equationasimage"><span class="font">x &lt;&gt; (y @ z) = (x &lt;&gt; y) @ z</span></p>
<p class="equationasimage"><span class="font">x &lt;&gt; e = e @ x</span></p>
<p class="para">The two instances are:</p>
<div class="space1">
<p class="code"><span class="font">foldr (\x n -&gt; n+1) 0 xs = foldl (\n x -&gt; 1+n) 0 xs</span></p>
<p class="code"><span class="font">foldr (\x xs -&gt; xs++[x]) [] xs</span></p>
<p class="code16"><span class="space4"></span><span class="font">= foldl (\xs x -&gt; [x]++xs) [] xs</span></p>
</div>
<p class="para">We leave the detailed verification of these equations as an exercise.</p>
<p class="para">For a final demonstration of the accumulating parameter technique we move from lists to trees. Consider the data declaration</p>
<p class="code"><span class="font">data GenTree a = Node a [GenTree a]</span></p>
<p class="para">An element of this type is a tree consisting of a node with a label and a list of subtrees. Such trees arise in problems that can be formulated in terms of positions and moves. The label of a node specifies the current position, and the number of subtrees corresponds to the number of possible moves in the current position. Each subtree has a label that specifies the result of making the move, and its subtrees describe the moves that can be made from the new position. And so on.</p>
<p class="para">Here is a function for computing the list of labels in a tree:</p>
<div class="space1">
<p class="code"><a id="text/part0011.html.page_162" class="calibre3"></a><span class="font">labels :: GenTree a -&gt; [a]</span></p>
<p class="code"><span class="font">labels (Node x ts) = x:concat (map labels ts)</span></p>
</div>
<p class="para">The method is simple enough: compute the labels of each subtree, concatenate the results, and stick the label of the tree at the front of the final list.</p>
<p class="para">Let us analyse the running time of this program on a tree <i class="calibre1">t</i>. To keep things simple, suppose that <i class="calibre1">t</i> is a <i class="calibre1">perfect k</i>-ary tree of height <i class="calibre1">h</i>. What that means is that if <i class="calibre1">h</i> = 1 then <i class="calibre1">t</i> has no subtrees, while if <i class="calibre1">h</i> &gt; 1 then <i class="calibre1">t</i> has exactly <i class="calibre1">k</i> subtrees, each with height <i class="calibre1">h</i>−1. The number <i class="calibre1">s</i>(<i class="calibre1">h</i>, <i class="calibre1">k</i>) of labels in such a tree satisfies</p>
<p class="equationasimage"><i class="calibre1">s</i>(1, <i class="calibre1">t</i>) = 1,</p>
<p class="equationasimage"><i class="calibre1">s</i>(<i class="calibre1">h</i>+1, <i class="calibre1">k</i>) = 1 + <i class="calibre1">ks</i>(<i class="calibre1">h</i>, <i class="calibre1">k</i>),</p>
<p class="para">with solution <i class="calibre1">s</i>(<i class="calibre1">h</i>, <i class="calibre1">k</i>) = Θ(<i class="calibre1">k</i><sup class="calibre8"><i class="calibre1">h</i></sup>). Now we have</p>
<div class="space1">
<p class="code"><span class="space"></span><i class="calibre1">T</i>(<span class="font">labels</span>)(1, <i class="calibre1">k</i>) = Θ(1),</p>
<p class="code"><i class="calibre1">T</i>(<span class="font">labels</span>)(<i class="calibre1">h</i>+1, <i class="calibre1">k</i>) = Θ(1) +<i class="calibre1">T</i>(<span class="font">concat</span>)(<i class="calibre1">k</i>, <i class="calibre1">s</i>) +<i class="calibre1">T</i>(<span class="font">map labels</span>)(<i class="calibre1">h</i>, <i class="calibre1">k</i>),</p>
</div>
<p class="para">where <i class="calibre1">s</i> = <i class="calibre1">s</i>(<i class="calibre1">h</i>, <i class="calibre1">k</i>). The term <i class="calibre1">T</i>(<span class="font">map labels</span>)(<i class="calibre1">h</i>, <i class="calibre1">k</i>) estimates the running time of applying <span class="font">map labels</span> to a list of length <i class="calibre1">k</i> of trees all of height <i class="calibre1">h</i>. In general, given a list of length <i class="calibre1">k</i> consisting of elements each of size <i class="calibre1">n</i>, we have</p>
<p class="equationasimage"><i class="calibre1">T</i>(<span class="font">map f</span>)(<i class="calibre1">k</i>, <i class="calibre1">n</i>) = <i class="calibre1">kT</i>(<span class="font">f</span>)(<i class="calibre1">n</i>) +Θ(<i class="calibre1">k</i>).</p>
<p class="para">Furthermore <i class="calibre1">T</i>(<span class="font">concat</span>)(<i class="calibre1">k</i>, <i class="calibre1">s</i>) = Θ(<i class="calibre1">ks</i>) = Θ(<i class="calibre1">k</i><sup class="calibre8"><i class="calibre1">h</i>+1</sup>). Hence</p>
<p class="equationasimage"><i class="calibre1">T</i>(<span class="font">labels</span>)(<i class="calibre1">h</i>+1, <i class="calibre1">k</i>) = Θ(<i class="calibre1">k</i><sup class="calibre8"><i class="calibre1">h</i>+1</sup>) +<i class="calibre1">kT</i>(<span class="font">labels</span>)(<i class="calibre1">h</i>, <i class="calibre1">k</i>)</p>
<p class="para">since Θ(1) +Θ(<i class="calibre1">k</i>) = Θ(<i class="calibre1">k</i>). The solution is given by</p>
<p class="equationasimage"><i class="calibre1">T</i>(<span class="font">labels</span>)(<i class="calibre1">h</i>, <i class="calibre1">k</i>) = Θ(<i class="calibre1">hk</i><sup class="calibre8"><i class="calibre1">h</i></sup>) = Θ(<i class="calibre1">s</i>log<i class="calibre1">s</i>).</p>
<p class="para">In words, computing the labels of a tree using the definition above takes time that is asymptotically greater than the size of the tree by a logarithmic factor.</p>
<p class="para">Let us now see what an accumulating parameter can do. Define <span class="font">labcat</span> by</p>
<div class="space1">
<p class="code"><span class="font">labcat :: [GenTree a] -&gt; [a] -&gt; [a]</span></p>
<p class="code"><span class="font">labcat ts xs = concat (map labels ts) ++ xs</span></p>
</div>
<p class="para">As well as adding in a list <span class="font">xs</span> we have also generalised the first argument from a tree to a list of trees. We have <span class="font">labels t = labcat [t] []</span>, so any improvement on <span class="font">labcat</span> leads to a corresponding improvement on <span class="font">labels</span>.</p>
<p class="para">We now synthesise an alternative definition for <span class="font">labcat</span>. For the base case we obtain</p>
<p class="code"><span class="font">labcat [] xs = xs</span></p>
<p class="para"><a id="text/part0011.html.page_163" class="calibre3"></a>For the inductive case we reason:</p>
<div class="space1">
<p class="code2"><span class="font">labcat (Node x us:vs) xs</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{definition}</p>
<p class="code2"><span class="font">concat (map labels (Node x us:vs)) ++ xs</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{definitions}</p>
<p class="code2"><span class="font">labels (Node x us) ++ concat (map labels vs) ++ xs</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{definition}</p>
<p class="code2"><span class="font">x:concat (map labels us) ++ concat (map labels vs) ++ xs</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">labcat</span>}</p>
<p class="code2"><span class="font">x:concat (map labels us) ++ labcat vs xs</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">labcat</span> (again)}</p>
<p class="code2"><span class="font">labcat us (labcat vs xs)</span></p>
</div>
<p class="para">The result of this calculation is the following program for <span class="font">labels</span>:</p>
<div class="space1">
<p class="code"><span class="font">labels t = labcat [t] []</span></p>
<p class="code"><span class="font">labcat [] xs</span><span class="space3"></span><span class="font">= xs</span></p>
<p class="code"><span class="font">labcat (Node x us:vs) = x:labcat us (labcat vs xs)</span></p>
</div>
<p class="para">For the timing analysis, let <i class="calibre1">T</i>(<span class="font">labcat</span>)(<i class="calibre1">h</i>, <i class="calibre1">k</i>, <i class="calibre1">n</i>) estimate the running time of</p>
<p class="code"><span class="font">labcat ts xs</span></p>
<p class="para">when <span class="font">ts</span> is a list of length <i class="calibre1">n</i> of trees, each of which is a perfect <i class="calibre1">k</i>-ary tree of height <i class="calibre1">h</i> (the size of <span class="font">xs</span> is ignored since it doesn’t affect the estimate). Then</p>
<p class="code1"><span class="space5"></span><i class="calibre1">T</i>(<span class="font">labcat</span>)(<i class="calibre1">h</i>, <i class="calibre1">k</i>, 0) = Θ(1),</p>
<p class="code1"><span class="space"></span><i class="calibre1">T</i>(<span class="font">labcat</span>)(1, <i class="calibre1">k</i>, <i class="calibre1">n</i>+1) = Θ(1) + <i class="calibre1">T</i>(<span class="font">labcat</span>)(1, <i class="calibre1">k</i>, <i class="calibre1">n</i>)),</p>
<p class="code1"><i class="calibre1">T</i>(<span class="font">labcat</span>)(<i class="calibre1">h</i>+1, <i class="calibre1">k</i>, <i class="calibre1">n</i>+1) = Θ(1) + <i class="calibre1">T</i>(<span class="font">labcat</span>)(<i class="calibre1">h</i>, <i class="calibre1">k</i>, <i class="calibre1">k</i>) +</p>
<p class="code16"><span class="space2"></span><i class="calibre1">T</i>(<span class="font">labcat</span>)(<i class="calibre1">h</i>+1, <i class="calibre1">k</i>, <i class="calibre1">n</i>).</p>
<p class="para">Solving the first two equations gives <i class="calibre1">T</i>(<span class="font">labcat</span>)(1, <i class="calibre1">k</i>, <i class="calibre1">n</i>) = Θ(<i class="calibre1">n</i>). An induction argument now shows <i class="calibre1">T</i>(<span class="font">labcat</span>)(<i class="calibre1">h</i>, <i class="calibre1">k</i>, <i class="calibre1">n</i>) = Θ(<i class="calibre1">k</i><sup class="calibre8"><i class="calibre1">h</i></sup> <i class="calibre1">n</i>). Hence</p>
<p class="equationasimage"><i class="calibre1">T</i>(<span class="font">labels</span>)(<i class="calibre1">h</i>, <i class="calibre1">k</i>) = <i class="calibre1">T</i>(<span class="font">labcat</span>)(<i class="calibre1">h</i>, <i class="calibre1">k</i>, 1) =Θ(<i class="calibre1">k</i><sup class="calibre8"><i class="calibre1">h</i></sup>) = Θ(<i class="calibre1">s</i>).</p>
<p class="para">That means we can compute the labels of a tree in time proportional to the size of the tree, a logarithmic improvement over our first version.</p>
<h3 class="h" id="text/part0011.html.head7-6"><a id="text/part0011.html.page_164" class="calibre6"></a>7.6 Tupling</h3>
<p class="para">We met the idea of tupling two functions in the discussion of the function <span class="font">mean</span>. Tupling is sort of dual to the method of accumulating parameters: we generalise a function not by including an extra argument but by including an extra result.</p>
<p class="para">The canonical example of the power of tupling is the Fibonacci function:</p>
<div class="space1">
<p class="code"><span class="font">fib :: Int -&gt; Integer</span></p>
<p class="code"><span class="font">fib 0 = 0</span></p>
<p class="code"><span class="font">fib 1 = 1</span></p>
<p class="code"><span class="font">fib n = fib (n-1) + fib (n-2)</span></p>
</div>
<p class="para">The time to evaluate <span class="font">fib</span> by these three equations is given by</p>
<div class="space1">
<p class="code8"><i class="calibre1">T</i>(<span class="font">fib</span>)(0) = Θ(1),</p>
<p class="code8"><i class="calibre1">T</i>(<span class="font">fib</span>)(1) = Θ(1),</p>
<p class="code8"><i class="calibre1">T</i>(<span class="font">fib</span>)(<i class="calibre1">n</i>) = <i class="calibre1">T</i>(<span class="font">fib</span>)(<i class="calibre1">n</i>−1) +<i class="calibre1">T</i>(<span class="font">fib</span>)(<i class="calibre1">n</i>−2) +Θ(1).</p>
</div>
<p class="para">The timing function therefore satisfies equations very like that of <span class="font">fib</span> itself. In fact <i class="calibre1">T</i>(<span class="font">fib</span>)(<i class="calibre1">n</i>) = Θ(<i class="calibre1">ϕ</i><sup class="calibre8"><i class="calibre1">n</i></sup>), where <i class="calibre1">ϕ</i> is the golden ratio <i class="calibre1">ϕ</i> = (1 + √5)/2. That means that the running time to compute <span class="font">fib</span> on an input <i class="calibre1">n</i> is exponential in <i class="calibre1">n</i>.</p>
<p class="para">Now consider the function <span class="font">fib2</span> defined by</p>
<p class="code"><span class="font">fib2 n = (fib n,fib (n+1))</span></p>
<p class="para">Clearly <span class="font">fib n = fst (fib2 n)</span>. Synthesis of a direct recursive definition of <span class="font">fib2</span> yields</p>
<div class="space1">
<p class="code"><span class="font">fib2 0 = (0,1)</span></p>
<p class="code"><span class="font">fib2 n = (b,a+b) where (a,b) = fib2 (n-1)</span></p>
</div>
<p class="para">This program takes linear time. In this example the tupling strategy leads to a dramatic increase in efficiency, from exponential time to linear time.</p>
<p class="para">It’s great fun to formulate general laws that encapsulate gains in efficiency. One such law concerns the computation of</p>
<p class="code"><span class="font">(foldr f a xs, foldr g b xs)</span></p>
<p class="para">As expressed above, the two applications of <span class="font">foldr</span> involve two traversals of the list <span class="font">xs</span>. There is a modest time advantage, and possibly a greater space advantage, in formulating a version that traverses the list only once. In fact</p>
<p class="code"><span class="font">(foldr f a xs, foldr g b xs) = foldr h (a,b) xs</span></p>
<p class="para"><a id="text/part0011.html.page_165" class="calibre3"></a>where</p>
<p class="code"><span class="font">h x (y,z) = (f x y,g x z)</span></p>
<p class="para">The result can be proved by induction and we leave details as an easy exercise.</p>
<p class="para">As one more example, we again move from lists to trees. But this time we have a different kind of tree, a <i class="calibre1">leaf-labelled binary tree</i>:</p>
<p class="code"><span class="font">data BinTree a = Leaf a | Fork (BinTree a) (BinTree a)</span></p>
<p class="para">In contrast to a <span class="font">GenTree</span> discussed above, a <span class="font">BinTree</span> is either a leaf, with an associated label, or a fork of two subtrees.</p>
<p class="para">Suppose we wanted to build such a tree with a given list as the labels. More precisely, we want to define a function <span class="font">build</span> satisfying</p>
<p class="code"><span class="font">labels (build xs) = xs</span></p>
<p class="para">for all finite nonempty lists <span class="font">xs</span>, where <span class="font">labels</span> returns the labels of a binary tree:</p>
<div class="space1">
<p class="code"><span class="font">labels :: BinTree a -&gt; [a]</span></p>
<p class="code"><span class="font">labels (Leaf x)</span><span class="space"></span>&nbsp;&nbsp;&nbsp;<span class="font">= [x]</span></p>
<p class="code"><span class="font">labels (Fork u v) = labels u ++ labels v</span></p>
</div>
<p class="para">We are attuned now to possible optimisations, and the definition of <span class="font">labels</span> suggest that it could be improved with an accumulating parameter. So it can, but that is not our primary interest here, and we leave the optimisation as an exercise.</p>
<p class="para">One way to build a tree is to arrange that half the list goes into the left subtree, and the other half into the right subtree:</p>
<div class="space1">
<p class="code"><span class="font">build :: [a] -&gt; BinTree a</span></p>
<p class="code"><span class="font">build [x] = Leaf x</span></p>
<p class="code"><span class="font">build xs</span><span class="space"></span><span class="font">= Fork (build ys) (build zs)</span></p>
<p class="code12"><span class="font">where (ys,zs) = halve xs</span></p>
</div>
<p class="para">The function <span class="font">halve</span> made an appearance in <a href="#text/part0008.html.head4-8" class="calibre3">Section 4.8</a>:</p>
<div class="space1">
<p class="code"><span class="font">halve xs = (take m xs,drop m xs)</span></p>
<p class="code12"><span class="font">where m = length xs `div` 2</span></p>
</div>
<p class="para">Thus <span class="font">halve</span> splits a list into two approximately equal halves. The definition of <span class="font">halve</span> involves a traversal of the list to find its length, and two further (partial) traversals to compute the two components. It is therefore a prime candidate for applying the tupling strategy to get something better. But as with <span class="font">labels</span> we are going to ignore that particular optimisation for now. And we are also going to <a id="text/part0011.html.page_166" class="calibre3"></a>ignore the proof that this definition of <span class="font">build</span> meets its specification. That’s three calculations we are leaving as exercises in order to concentrate on a fourth.</p>
<p class="para">Let’s time <span class="font">build</span>:</p>
<div class="space1">
<p class="code8"><i class="calibre1">T</i>(<span class="font">build</span>)(1) = Θ(1),</p>
<p class="code8"><i class="calibre1">T</i>(<span class="font">build</span>)(<i class="calibre1">n</i>) = <i class="calibre1">T</i>(<span class="font">build</span>)(<i class="calibre1">m</i>) +<i class="calibre1">T</i>(<span class="font">build</span>)(<i class="calibre1">n</i>−<i class="calibre1">m</i>) +Θ(<i class="calibre1">n</i>)</p>
<p class="code14"><b class="calibre7">where</b>. <i class="calibre1">m</i> = <i class="calibre1">n</i> div 2</p>
</div>
<p class="para">It takes Θ(<i class="calibre1">n</i>) steps to halve a list of length <i class="calibre1">n</i>, and then we recursively build two subtrees from lists of length <i class="calibre1">m</i> and <i class="calibre1">n</i> − <i class="calibre1">m</i>, respectively. The solution is</p>
<p class="equationasimage"><i class="calibre1">T</i>(<span class="font">build</span>)(<i class="calibre1">n</i>) = Θ(<i class="calibre1">n</i>log<i class="calibre1">n</i>).</p>
<p class="para">In words, building a tree by the above method takes longer than the length of the list by a logarithmic factor.</p>
<p class="para">Having established this fact, let us define <span class="font">build2</span> by</p>
<div class="space1">
<p class="code"><span class="font">build2 :: Int -&gt; [a] -&gt; (BinTree a,[a])</span></p>
<p class="code"><span class="font">build2 n xs = (build (take n xs),drop n xs)</span></p>
</div>
<p class="para">This builds a tree from the first <i class="calibre1">n</i> elements, but also returns the list that is left. We have</p>
<p class="code"><span class="font">build xs = fst (build2 (length xs) xs)</span></p>
<p class="para">so our original function can be determined from the tupled version.</p>
<p class="para">Our aim now is to construct a direct recursive definition of <span class="font">build2</span>. First of all, it is clear that</p>
<p class="code"><span class="font">build2 1 xs = (Leaf (head xs),tail xs)</span></p>
<p class="para">For the recursive case we start with</p>
<div class="space1">
<p class="code"><span class="font">build2 n xs = (Fork (build (take m (take n xs)))</span></p>
<p class="code5"><span class="font">(build (drop m (take n xs))),</span></p>
<p class="code4"><span class="font">drop n xs) where m = n `div` 2</span></p>
</div>
<p class="para">This equation is obtained by substituting in the recursive case of <span class="font">build</span>. It suggests that the next step is to use some properties of <span class="font">take</span> and <span class="font">drop</span>. Here they are: if <span class="font">m &lt;= n</span> then</p>
<div class="space1">
<p class="code"><span class="font">take m . take n = take m</span></p>
<p class="code"><span class="font">drop m . take n = take (n-m) . drop m</span></p>
</div>
<p class="para">That leads to</p>
<div class="space1">
<p class="code"><a id="text/part0011.html.page_167" class="calibre3"></a><span class="font">build2 n xs = (Fork (build (take m xs))</span></p>
<p class="code5"><span class="font">(build (take (n-m) (drop m xs))),</span></p>
<p class="code4"><span class="font">drop n xs) where m = n `div` 2</span></p>
</div>
<p class="para">Using the definition of <span class="font">build2</span> we can rewrite the above as follows:</p>
<div class="space1">
<p class="code"><span class="font">build2 n xs = (Fork u v, drop n xs)</span></p>
<p class="code4"><span class="font">where (u,xs') = build2 m xs</span></p>
<p class="code16"><span class="font">(v,xs'') = build2 (n-m) xs'</span></p>
<p class="code16"><span class="font">m</span><span class="space2"></span><span class="font">&nbsp;= n `div` 2</span></p>
</div>
<p class="para">But as a final step, observe that</p>
<div class="space1">
<p class="code"><span class="font">xs'' = drop (n-m) xs'</span></p>
<p class="code2"><span class="space5"></span><span class="font">= drop (n-m) (drop m xs)</span></p>
<p class="code2"><span class="space5"></span><span class="font">= drop n xs</span></p>
</div>
<p class="para">Hence we can rewrite <span class="font">build2</span> once again to read</p>
<div class="space1">
<p class="code"><span class="font">build2 1 xs = (Leaf (head xs),tail xs)</span></p>
<p class="code"><span class="font">build2 n xs = (Fork u v, xs'')</span></p>
<p class="code9"><span class="font">&nbsp;where (u,xs')</span><span class="space5"></span><span class="font">= build2 m xs</span></p>
<p class="code13"><span class="space"></span><span class="font">&nbsp;(v,xs'') = build2 (n-m) xs'</span></p>
<p class="code13"><span class="space"></span><span class="font">&nbsp;m</span><span class="space2"></span><span class="space-r"></span><span class="font">= n `div` 2</span></p>
</div>
<p class="para">Timing this program yields</p>
<div class="space1">
<p class="code"><i class="calibre1">T</i>(<span class="font">build2</span>)(1) = Θ(1),</p>
<p class="code"><i class="calibre1">T</i>(<span class="font">build2</span>)(<i class="calibre1">n</i>) = <i class="calibre1">T</i>(<span class="font">build2</span>)(<i class="calibre1">m</i>) +<i class="calibre1">T</i>(<span class="font">build2</span>)(<i class="calibre1">n</i>−<i class="calibre1">m</i>) +Θ(1).</p>
</div>
<p class="para">with solution <i class="calibre1">T</i>(<span class="font">build2</span>)(<i class="calibre1">n</i>) = Θ(<i class="calibre1">n</i>). Using <span class="font">build2</span> as a subsidiary function has therefore improved the running time of <span class="font">build</span> by a logarithmic factor.</p>
<h3 class="h" id="text/part0011.html.head7-7">7.7 Sorting</h3>
<p class="para">Sorting is a big topic and one can spend many happy hours tinkering with different algorithms. Knuth devotes about 400 pages to the subject in Volume 3 of his series <i class="calibre1">The Art of Computer Programming</i>. Even then some of his conclusions have to be reformulated when sorting is considered in a purely functional setting. Here we briefly consider two sorting algorithms, keeping an eye out for possible optimisations.</p>
<p class="center"><a id="text/part0011.html.page_168" class="calibre3"></a><i class="calibre1">Mergesort</i></p>
<p class="para">The sorting method called <i class="calibre1">Mergesort</i> made an appearance in <a href="#text/part0008.html.head4-8" class="calibre3">Section 4.8</a>:</p>
<div class="space1">
<p class="code"><span class="font">sort :: (Ord a) =&gt; [a] -&gt; [a]</span></p>
<p class="code"><span class="font">sort []</span><span class="space-toc1"></span><span class="font">= []</span></p>
<p class="code"><span class="font">sort [x]</span><span class="space-r"></span><span class="font">= [x]</span></p>
<p class="code"><span class="font">sort xs</span><span class="space-toc1"></span><span class="font">= merge (sort ys) (sort zs)</span></p>
<p class="code10"><span class="space-r1"></span><span class="font">where (ys,zs) = halve xs</span></p>
<p class="code"><span class="font">halve xs = (take m xs,drop m xs)</span></p>
<p class="code10"><span class="space-r1"></span><span class="font">where m = length xs `div` 2</span></p>
</div>
<p class="para">In fact there are a number of variants for sorting by merging, and the standard prelude function <span class="font">sort</span> uses a different variant than the one above.</p>
<p class="para">As we said above, the definition of <span class="font">halve</span> looks fairly inefficient in that it involves multiple traversals of its argument. One way to improve matters is to make use of the standard prelude function <span class="font">splitAt</span>, whose specification is</p>
<div class="space1">
<p class="code"><span class="font">splitAt :: Int -&gt; [a] -&gt; ([a],[a])</span></p>
<p class="code"><span class="font">splitAt n xs = (take n xs,drop n xs)</span></p>
</div>
<p class="para">The prelude version of this function is the result of a tupling transformation:</p>
<div class="space1">
<p class="code"><span class="font">splitAt 0 xs</span><span class="space4"></span><span class="font">= ([],xs)</span></p>
<p class="code"><span class="font">splitAt n []</span><span class="space4"></span><span class="font">= ([],[])</span></p>
<p class="code"><span class="font">splitAt n (x:xs) = (x:ys,zs)</span></p>
<p class="code13"><span class="font">where (ys,zs) = splitAt (n-1) xs</span></p>
</div>
<p class="para">It is easy enough to calculate this definition using the two facts that</p>
<div class="space1">
<p class="code"><span class="font">take n (x:xs) = x:take (n-1) xs</span></p>
<p class="code"><span class="font">drop n (x:xs) = drop (n-1) xs</span></p>
</div>
<p class="para">provided <span class="font">0 &lt; n</span>. Now we have</p>
<p class="code"><span class="font">halve xs = splitAt (length xs `div` 2) xs</span></p>
<p class="para">There are still two traversals here of course.</p>
<p class="para">Another way to improve <span class="font">sort</span> is to define</p>
<p class="code"><span class="font">sort2 n xs = (sort (take n xs),drop n xs)</span></p>
<p class="para">We have <span class="font">sort xs = fst (sort2 (length xs) xs)</span>, so our original sorting function can be retrieved from the general one. An almost exactly similar calculation to the one in the previous section leads to</p>
<div class="space1">
<p class="code"><a id="text/part0011.html.page_169" class="calibre3"></a><span class="font">sort2 0 xs = ([],xs)</span></p>
<p class="code"><span class="font">sort2 1 xs = ([head xs],tail xs)</span></p>
<p class="code"><span class="font">sort2 n xs = (merge ys zs, xs'')</span></p>
<p class="code9"><span class="font">where (ys,xs')</span><span class="space"></span><span class="font">= sort2 m xs</span></p>
<p class="code13"><span class="font">(zs,xs'') = sort2 (n-m) xs'</span></p>
<p class="code16"><span class="font">m</span><span class="space8"></span><span class="font">= n `div` 2</span></p>
</div>
<p class="para">With this definition there are no length calculations and no multiple traversals of <span class="font">xs</span>.</p>
<p class="para">Another way to optimise <span class="font">halve</span> is to realise that no human would split up a list in this way if forced to do so by hand. If asked to divide a list into two, you and I would surely just deal out the elements into two piles:</p>
<div class="space1">
<p class="code"><span class="font">halve []</span><span class="space2"></span><span class="font">= ([],[])</span></p>
<p class="code"><span class="font">halve [x]</span><span class="space4"></span><span class="space-r"></span><span class="font">= ([x],[])</span></p>
<p class="code"><span class="font">halve (x:y:xs) = (x:ys,y:zs)</span></p>
<p class="code5"><span class="font">where (ys,zs) = halve xs</span></p>
</div>
<p class="para">Of course, this definition returns a different result than the previous one, but the order of the elements in the two lists does not matter if the result is to be sorted; what is important is that the elements are all there.</p>
<p class="para">That is a total of three ways to improve the performance of <span class="font">sort</span>. However, it turns out that none of them makes that much difference to the total running time. A few per cent perhaps, but nothing substantial. Furthermore, if we are using GHCi as our functional evaluator, none of the versions compares in performance to the library function <span class="font">sort</span> because that function is given to us in a compiled form, and compiled versions of functions are usually about ten times faster. We can always compile our functions using GHC of course.</p>
<p class="center"><i class="calibre1">Quicksort</i></p>
<p class="para">Our second sorting algorithm is a famous one called <i class="calibre1">Quicksort</i>. It can be expressed in just two lines of Haskell:</p>
<div class="space1">
<p class="code"><span class="font">sort :: (Ord a) =&gt; [a] -&gt; [a]</span></p>
<p class="code"><span class="font">sort []</span><span class="space4"></span><span class="font">= []</span></p>
<p class="code"><span class="font">sort (x:xs) = sort [y | y &lt;- xs, y &lt; x] ++ [x] ++</span></p>
<p class="code9"><span class="font">sort [y | y &lt;- xs, x &lt;= y]</span></p>
</div>
<p class="para"><a id="text/part0011.html.page_170" class="calibre3"></a>That’s very pretty and a testament to the expressive power of Haskell. But the prettiness comes at a cost: the program can be very inefficient in its use of space. The situation is the same as with the program for <span class="font">mean</span> seen earlier.</p>
<p class="para">Before plunging into ways the code can be optimised, let’s compute <i class="calibre1">T</i>(<span class="font">sort</span>). Suppose we want to sort a list of length <i class="calibre1">n</i>+1. The first list comprehension can return a list of any length <i class="calibre1">k</i> from 0 to <i class="calibre1">n</i>. The length of the result of the second list comprehension is therefore <i class="calibre1">n</i>−<i class="calibre1">k</i>. Since our timing function is an estimate of the worst-case running time, we have to take the maximum of these possibilities:</p>
<p class="code11"><i class="calibre1">T</i>(<span class="font">sort</span>)(<i class="calibre1">n</i>+1)</p>
<p class="code11">= max [<i class="calibre1">T</i>(<span class="font">sort</span>)(<i class="calibre1">k</i>) +<i class="calibre1">T</i>(<span class="font">sort</span>)(<i class="calibre1">n</i>−<i class="calibre1">k</i>) | <i class="calibre1">k</i> ← [0 .. <i class="calibre1">n</i>]] + Θ(<i class="calibre1">n</i>).</p>
<p class="para">The Θ(<i class="calibre1">n</i>) term accounts for both the time to evaluate the two list comprehensions and the time to perform the concatenations. Note, by the way, the use of a list comprehension in a mathematical expression rather than a Haskell one. If list comprehensions are useful notations in programming, they are useful in mathematics too.</p>
<p class="para">Although not immediately obvious, the worst case occurs when <i class="calibre1">k</i> = 0 or <i class="calibre1">k</i> = <i class="calibre1">n</i>. Hence</p>
<p class="code8"><i class="calibre1">T</i>(<span class="font">sort</span>)(0) = Θ(1),</p>
<p class="code11"><i class="calibre1">T</i>(<span class="font">sort</span>)(<i class="calibre1">n</i>+1) = <i class="calibre1">T</i>(<span class="font">sort</span>)(<i class="calibre1">n</i>) +Θ(<i class="calibre1">n</i>),</p>
<p class="para">with solution <i class="calibre1">T</i>(<span class="font">sort</span>)(<i class="calibre1">n</i>) = Θ(<i class="calibre1">n</i><sub class="calibre11">2</sub>). Thus Quicksort is a quadratic algorithm in the worst case. This fact is intrinsic to the algorithm and has nothing to do with the Haskell expression of it. Quicksort achieved its fame for two other reasons, neither of which hold in a purely functional setting. Firstly, when Quicksort is implemented in terms of arrays rather than lists, the partitioning phase can be performed <i class="calibre1">in place</i> without using any additional space. Secondly, the <i class="calibre1">average case</i> performance of Quicksort, under reasonable assumptions about the input, is Θ(<i class="calibre1">n</i>log<i class="calibre1">n</i>) with a smallish constant of proportionality. In a functional setting this constant is not so small and there are better ways to sort than Quicksort.</p>
<p class="para">With this warning, let us now see what we can do to optimise the algorithm without changing it in any essential way (i.e. to a completely different sorting algorithm). To avoid the two traversals of the list in the partitioning process, define</p>
<p class="code"><span class="font">partition p xs = (filter p xs, filter (not . p) xs)</span></p>
<p class="para">This is another example of tupling two definitions to save on a traversal. Since <span class="font">filter p</span> can be expressed as an instance of <span class="font">foldr</span> we can appeal to the tupling law of <span class="font">foldr</span> to arrive at</p>
<div class="space1">
<p class="code"><a id="text/part0011.html.page_171" class="calibre3"></a><span class="font">partition p = foldr op ([],[])</span></p>
<p class="code2"><span class="font">where op x (ys,zs) | p x = (x:ys,zs)</span></p>
<p class="code16"><span class="space-r1"></span><span class="font">| otherwise = (ys,x:zs)</span></p>
</div>
<p class="para">Now we can write</p>
<div class="space1">
<p class="code"><span class="font">sort</span><span class="space4"></span><span class="font">[] = []</span></p>
<p class="code"><span class="font">sort (x:xs) = sort ys ++ [x] ++ sort zs</span></p>
<p class="code9"><span class="font">where (ys,zs) = partition (&lt;x) xs</span></p>
</div>
<p class="para">But this program still contains a space leak. To see why, let us write the recursive case in the equivalent form</p>
<div class="space1">
<p class="code"><span class="font">sort (x:xs) = sort (fst p) ++ [x] ++ sort (snd p)</span></p>
<p class="code9"><span class="space-r"></span><span class="font">where p = partition (&lt;x) xs</span></p>
</div>
<p class="para">Suppose <span class="font">x:xs</span> has length <i class="calibre1">n</i>+1 and is in strictly decreasing order, so <span class="font">x</span> is the largest element in the list and <span class="font">p</span> is a pair of lists of length <i class="calibre1">n</i> and 0, respectively. Evaluation of <span class="font">p</span> is triggered by displaying the results of the first recursive call, but the <i class="calibre1">n</i> units of space occupied by the first component of <i class="calibre1">p</i> cannot be reclaimed because there is another reference to <span class="font">p</span> in the second recursive call. Between these two calls further pairs of lists are generated and retained. All in all, the total space required to evaluate <span class="font">sort</span> on a strictly decreasing list of length <i class="calibre1">n</i>+1 is Θ(<i class="calibre1">n</i><sub class="calibre11">2</sub>) units. In practice this means that evaluation of <span class="font">sort</span> on some large inputs can abort owing to lack of sufficient space.</p>
<p class="para">The solution is to force evaluation of <span class="font">partition</span> and, equally importantly, to bind <span class="font">ys</span> and <span class="font">zs</span> to the components of the pair, not to <span class="font">p</span> itself.</p>
<p class="para">One way of bringing about a happy outcome is to introduce two accumulating parameters. Define <span class="font">sortp</span> by</p>
<div class="space1">
<p class="code"><span class="font">sortp x xs us vs = sort (us ++ ys) ++ [x] ++</span></p>
<p class="code17"><span class="space-r"></span><span class="font">sort (vs ++ zs)</span></p>
<p class="code17"><span class="space-r"></span><span class="font">where (ys,zs) = partition (&lt;x) xs</span></p>
</div>
<p class="para">Then we have</p>
<p class="code"><span class="font">sort (x:xs) = sortp x xs [] []</span></p>
<p class="para">We now synthesise a direct recursive definition of <span class="font">sortp</span>. The base case is</p>
<p class="code"><span class="font">sortp x [] us vs = sort us ++ [x] ++ sort vs</span></p>
<p class="para"><a id="text/part0011.html.page_172" class="calibre3"></a>For the recursive case <span class="font">y:xs</span> let us assume that <span class="font">y &lt; x</span>. Then</p>
<div class="space1">
<p class="code11"><span class="font">sortp x (y:xs) us vs</span></p>
<p class="code2"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">sortp</span> with <span class="font">(ys,zs) = partition (&lt;x) xs</span>}</p>
<p class="code11"><span class="font">sort (us ++ y:ys) ++ [x] ++ sort (vs ++ zs)</span></p>
<p class="code2"><span class="font">=</span><span class="space"></span>{claim (see below)}</p>
<p class="code11"><span class="font">sort (y:us ++ ys) ++ [x] ++ sort (vs ++ zs)</span></p>
<p class="code2"><span class="font">=</span><span class="space"></span>{definition of <span class="font">sortp</span>}</p>
<p class="code11"><span class="font">sortp x (y:us) vs</span></p>
</div>
<p class="para">The claim is that if <span class="font">as</span> is any permutation of <span class="font">bs</span> then <span class="font">sort as</span> and <span class="font">sort bs</span> return the same result. The claim is intuitively obvious: sorting a list depends only on the elements in the input not on their order. A formal proof is omitted.</p>
<p class="para">Carrying out a similar calculation in the case that <span class="font">x &lt;= y</span> and making <span class="font">sortp</span> local to the definition of <span class="font">sort</span>, we arrive at the final program</p>
<div class="space1">
<p class="code"><span class="font">sort []</span><span class="space4"></span><span class="font">= []</span></p>
<p class="code"><span class="font">sort (x:xs) = sortp xs [] []</span></p>
<p class="code2"><span class="font">where</span></p>
<p class="code2"><span class="font">sortp [] us vs</span><span class="space4"></span><span class="font">= sort us ++ [x] ++ sort vs</span></p>
<p class="code2"><span class="font">sortp (y:xs) us vs = if y &lt; x</span></p>
<p class="code16"><span class="space5"></span><span class="font">then sortp xs (y:us) vs</span></p>
<p class="code16"><span class="space5"></span><span class="font">else sortp xs us (y:vs)</span></p>
</div>
<p class="para">Not quite as pretty as before, but at least the result has Θ(<i class="calibre1">n</i>) space complexity.</p>
<h3 class="h" id="text/part0011.html.head7-8">7.8 Exercises</h3>
<p class="theorem"><b class="calibre7">Exercise A</b></p>
<p class="para">One simple definition of <span class="font">sort</span> is</p>
<div class="space1">
<p class="code"><span class="font">sort []</span><span class="space4"></span><span class="font">= []</span></p>
<p class="code"><span class="font">sort (x:xs) = insert x (sort xs)</span></p>
<p class="code"><span class="font">insert x [] = [x]</span></p>
<p class="code"><span class="font">insert x (y:ys)</span></p>
<p class="code8"><span class="font">= if x &lt;= y then x:y:ys else y:insert x ys</span></p>
</div>
<p class="para">This method is called <i class="calibre1">insertion sort</i>. Reduce <span class="font">sort [3,4,2,1]</span> to head normal <a id="text/part0011.html.page_173" class="calibre3"></a>form under lazy evaluation. Now answer the following questions: (i) How long, as a function of <i class="calibre1">n</i>, does it take to compute <span class="font">head . sort</span> when applied to a list of length <i class="calibre1">n</i>? (ii) How long does it take under eager evaluation? (iii) Does insertion sort, evaluated lazily, carry out exactly the same sequence of comparisons as the following <i class="calibre1">selection sort</i> algorithm?</p>
<div class="space1">
<p class="code"><span class="font">sort [] = []</span></p>
<p class="code"><span class="font">sort xs = y:sort ys where (y,ys) = select xs</span></p>
<p class="para1"></p>
<p class="code"><span class="font">select [x]</span><span class="space1a"></span><span class="font">= (x,[])</span></p>
<p class="code"><span class="font">select (x:xs) | x &lt;= y = (x,y:ys)</span></p>
<p class="code9"><span class="space-r1"></span><span class="font">| otherwise = (y,x:ys)</span></p>
<p class="code9"><span class="space-r1"></span><span class="font">where (y,ys) = select xs</span></p>
</div>
<p class="theorem"><b class="calibre7">Exercise B</b></p>
<p class="para">Write down a definition of <span class="font">length</span> that evaluates in constant space. Write a second definition of <span class="font">length</span> that evaluates in constant space but does not make use of the primitive <span class="font">seq</span> (either directly or indirectly).</p>
<p class="theorem"><b class="calibre7">Exercise C</b></p>
<p class="para">Construct <span class="font">f</span>, <span class="font">e</span> and <span class="font">xs</span> so that</p>
<p class="equationasimage"><span class="font">foldl f e xs</span> ≠ <span class="font">foldl' f e xs</span></p>
<p class="theorem"><b class="calibre7">Exercise D</b></p>
<p class="para">Would</p>
<div class="space1">
<p class="code2"><span class="font">cp []</span><span class="space2"></span><span class="font">= [[]]</span></p>
<p class="code2"><span class="font">cp (xs:xss) = [x:ys | ys &lt;- cp xss, x &lt;- xs]</span></p>
</div>
<p class="para">be an alternative way of defining the function <span class="font">cp</span> that is as efficient as the definition in terms of <span class="font">foldr</span>? Yes, No or Maybe?</p>
<p class="para">Time for a calculation. Use the fusion law of <span class="font">foldr</span> to calculate an efficient alternative to</p>
<p class="code"><span class="font">fcp = filter nondec . cp</span></p>
<p class="para">See <a href="#text/part0008.html.head4-7" class="calibre3">Section 4.7</a> for a definition of <span class="font">nondec</span>.</p>
<p class="theorem"><a id="text/part0011.html.page_174" class="calibre3"></a><b class="calibre7">Exercise E</b></p>
<p class="para">Suppose</p>
<p class="code3"><i class="calibre1">T</i>(1) = Θ(1),</p>
<p class="code3"><i class="calibre1">T</i>(<i class="calibre1">n</i>) = <i class="calibre1">T</i>(<i class="calibre1">n</i> div 2) +<i class="calibre1">T</i>(<i class="calibre1">n</i> − <i class="calibre1">n</i> div 2) +Θ(<i class="calibre1">n</i>)</p>
<p class="para">for 2 ≤ <i class="calibre1">n</i>. Prove that <i class="calibre1">T</i>(2<sup class="calibre8"><i class="calibre1">k</i></sup> ) = Θ(<i class="calibre1">k</i>2<sup class="calibre8"><i class="calibre1">k</i></sup> ). Hence prove <i class="calibre1">T</i>(<i class="calibre1">n</i>) = Θ(<i class="calibre1">n</i>log<i class="calibre1">n</i>).</p>
<p class="theorem"><b class="calibre7">Exercise F</b></p>
<p class="para">Prove that</p>
<div class="space1">
<p class="code"><span class="font">foldr (\x n -&gt; n+1) 0 xs = foldl (\n x -&gt; 1+n) 0 xs</span></p>
<p class="code"><span class="font">foldr (\x xs -&gt; xs++[x]) [] xs</span></p>
<p class="code16"><span class="space4"></span><span class="font">= foldl (\xs x -&gt; [x]++xs) [] xs</span></p>
</div>
<p class="theorem"><b class="calibre7">Exercise G</b></p>
<p class="para">Prove that if <span class="font">h x (y,z) = (f x y,g x z)</span>, then</p>
<p class="code"><span class="font">(foldr f a xs,foldr g b xs) = foldr h (a,b) xs</span></p>
<p class="para">for all finite lists <span class="font">xs</span>. A tricky question: does the result hold for <i class="calibre1">all</i> lists <span class="font">xs</span>?</p>
<p class="para">Now find a definition of <span class="font">h</span> such that</p>
<p class="code"><span class="font">(foldl f a xs,foldl g b xs) = foldl h (a,b) xs</span></p>
<p class="theorem"><b class="calibre7">Exercise H</b></p>
<p class="para">Recall that</p>
<p class="code"><span class="font">partition p xs = (filter p xs, filter (not . p) xs)</span></p>
<p class="para">Express the two components of the result as instances of <span class="font">foldr</span>. Hence use the result of the previous exercise to calculate another definition of <span class="font">partition</span>.</p>
<p class="para">Define</p>
<div class="space1">
<p class="code"><span class="font">part p xs us vs = (filter p xs ++ us,</span></p>
<p class="code17"><span class="font">filter (not . p) xs ++ vs)</span></p>
</div>
<p class="para">Calculate another definition of <span class="font">partition</span> that uses <span class="font">part</span> as a local definition.</p>
<p class="theorem"><b class="calibre7">Exercise I</b></p>
<p class="para">Recall that</p>
<div class="space1">
<p class="code"><a id="text/part0011.html.page_175" class="calibre3"></a><span class="font">labels :: BinTree a -&gt; [a]</span></p>
<p class="code"><span class="font">labels (Leaf x)</span><span class="space5"></span><span class="font">= [x]</span></p>
<p class="code"><span class="font">labels (Fork u v) = labels u ++ labels v</span></p>
</div>
<p class="para">Compute <i class="calibre1">T</i>(<span class="font">labels</span>)(<i class="calibre1">n</i>), where <i class="calibre1">n</i> is the number of leaves in the tree. Now use the accumulating parameter technique to find a faster way of computing <span class="font">labels</span>. Prove that <span class="font">labels (build xs) = xs</span> for all finite nonempty lists <span class="font">xs</span>.</p>
<p class="theorem"><b class="calibre7">Exercise J</b></p>
<p class="para">Define <span class="font">select k = (!!k) . sort</span>, where <span class="font">sort</span> is the original Quicksort. Thus <span class="font">select k</span> selects the <i class="calibre1">k</i>th smallest element of a nonempty finite list of elements, the 0th smallest being the smallest element, the 1st smallest being the next smallest element, and so on. Calculate a more efficient definition of <span class="font">select</span> and estimate its running time.</p>
<h3 class="h" id="text/part0011.html.head7-9">7.9 Answers</h3>
<p class="theorem"><b class="calibre7">Answer to Exercise A</b></p>
<div class="space1">
<p class="code2"><span class="font">sort [3,4,1,2]</span></p>
<p class="code"><span class="font">= insert 3 (sort [4,1,2])</span></p>
<p class="code"><span class="font">= ...</span></p>
<p class="code"><span class="font">= insert 3 (insert 4 (insert 1 (insert 2 [])))</span></p>
<p class="code"><span class="font">= insert 3 (insert 4 (insert 1 (2:[])))</span></p>
<p class="code"><span class="font">= insert 3 (insert 4 (1:2:[]))</span></p>
<p class="code"><span class="font">= insert 3 (1:insert 4 (2:[]))</span></p>
<p class="code"><span class="font">= 1:insert 3 (insert 4 (2:[]))</span></p>
</div>
<p class="para">It takes Θ(<i class="calibre1">n</i>) steps to compute <span class="font">head . sort</span> on a list of length <i class="calibre1">n</i>. Under eager evaluation it takes about <i class="calibre1">n</i><sub class="calibre11">2</sub> steps. As to part (iii), the answer is yes. You may think we have defined sorting by insertion, but under lazy evaluation it turns out to be selection sort. The lesson here is that, under lazy evaluation, you don’t always get what you think you are getting.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise B</b></p>
<p class="para">For the first part, the following does the job:</p>
<p class="code"><span class="font">length = foldl' (\n x -&gt; n+1) 0</span></p>
<p class="para">For the second part, one solution is</p>
<div class="space1">
<p class="code"><a id="text/part0011.html.page_176" class="calibre3"></a><span class="font">length</span><span class="space3"></span><span class="font">&nbsp;= length2 0</span></p>
<p class="code"><span class="font">length2 n []</span><span class="space4"></span><span class="font">= n</span></p>
<p class="code"><span class="font">length2 n (x:xs) = if n==0 then length2 1 xs</span></p>
<p class="code13"><span class="font">else length2 (n+1) xs</span></p>
</div>
<p class="para">The test <span class="font">n==0</span> forces evaluation of the first argument.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise C</b></p>
<p class="para">Take <span class="font">f n x = if x==0 then undefined else 0</span>. Then</p>
<div class="space1">
<p class="code"><span class="font">foldl f 0 [0,2]</span><span class="space-toc1"></span><span class="font">= 0</span></p>
<p class="code"><span class="font">foldl' f 0 [0,2] = undefined</span></p>
</div>
<p class="theorem"><b class="calibre7">Answer to Exercise D</b></p>
<p class="para">The answer is: maybe! Although the given version of <span class="font">cp</span> is efficient, it returns the component lists in a different order than any of the definitions in the text. That probably doesn’t matter if we are only interested in the <i class="calibre1">set</i> of results, but it might affect the running time and result of any program that searched <span class="font">cp</span> to find some list satisfying a given property.</p>
<p class="para">According to the fusion rule we have to find a function <span class="font">g</span> so that</p>
<p class="code"><span class="font">filter nondec (f xs yss) = g xs (filter nondec yss)</span></p>
<p class="para">where <span class="font">f xs yss = [x:ys | x &lt;- xs, ys &lt;- yss]</span>. Then we would have</p>
<div class="space1">
<p class="code"><span class="font">filter nondec . cp</span></p>
<p class="code2"><span class="font">= filter nondec . foldr f [[]]</span></p>
<p class="code2"><span class="font">= foldr g [[]]</span></p>
</div>
<p class="para">Now</p>
<p class="code"><span class="font">nondec (x:ys) = null ys || (x &lt;= head ys &amp;&amp; nondec ys)</span></p>
<p class="para">That leads to</p>
<p class="code"><span class="font">g xs [[]] = [[x] | x &lt;- xs]</span></p>
<p class="code"><span class="font">g xs yss</span><span class="space-toc1"></span><span class="font">= [x:ys | x &lt;- xs, ys &lt;- yss, x &lt;= head ys]</span></p>
<p class="para"><b class="calibre7">Answer to Exercise E</b></p>
<p class="para">For the first part, we have</p>
<p class="equationasimage"><i class="calibre1">T</i>(2<sup class="calibre8"><i class="calibre1">k</i></sup>) = 2<i class="calibre1">T</i>(2<sup class="calibre8"><i class="calibre1">k</i>−1</sup>) +Θ(2<sup class="calibre8"><i class="calibre1">k</i></sup>).</p>
<p class="para"><a id="text/part0011.html.page_177" class="calibre3"></a>By induction we can show&nbsp;<img src="data:image/jpeg;base64,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" alt="image" class="calibre2"> The induction step is</p>
<p class="equationasimage"><img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEBLAEsAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCACkAOADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6poqJriBXZGmjDqMlSwyB60G5gEDTmaPyUUs0m4bQByST0xQBLRVQanZfZLe6a6hS3uNvkvIwQPuGRjOOtY3i/wAQS6Jc6JDB9nJvLpln87P7u3SJ5JZBjuAo692FAHSUVTg1OznmghjmHmzw/aIkYFWaPjkA+mRkdRkZq5QAUUUUAFeXeONZ2/E3SLbzltYbK1MZv22tHaXNy22PepPJZIZFXtlxnqM+li7tzdtai4hNyq7zCHG8L67euK574iayvhjwlqWtrox1ZbZVlnt0KqzRqRl+Qc7R834UAW77U9YgunitdAlu4FxtnF1Em/j+6TkVznxRnab4fw3GpWqWdwNRsGEUkiuY2+2RDhhxnGenrWf4T+I+v+LtCt9Z8P8Ag6O50+fIVjrESspBIKsu35Tx0+lamm+KNRv/ABTa+H/FXhL+zhdQSXNtO93HdRSGMruXgcMA4PPvigDu6KAMDA6VVtNSsb2WSKzvba4lj++kUquV+oB4oAtUVBe3lvZJG11MsQkkWJN3V3Y4CgdyaV7u3S6S2eeJbmQFkiLgOwHUgdSKAJqK5d/Exj8cXGkymAWENvAPMCsZDdSs+2PjjGyMseOMjJrqKACiuc1vXrrT/GXhvSI4IXtdUFz5srMd6GKMMu0dMHnOTW5DeW811cW0UqtcW+3zY+6hhlSfY4PPsfSgCeiiigAooqraalY3sskVne21xLH99IpVcr9QDxQBaoqvd3lvaNAtzKsbTyCGIHq7nJwB9AT9Aacbu3F2LU3EIuSu8Q7xvK+u3rigCaiuXfxMY/HNxpEpgFhFbwDzAGMhupmfbHxxjZGWPHGRk10NpeW94sptZUk8qRoZNp5R1PKn0NAHj/jXwxpEvxC8FeG7OwgY3OoT6/qczIGklEQJXzGxlg0jgYPGFA6Cuk8UaJp+l/2ZoelW8dtbeIdcWW9iRQqyKsRkkUAdAwgUEdwT61p2XhO7i+JN54su7+CfzrJdPhthAVNvEHL8PuOSzYJ4HQVN8QrSc2el6taI8kujXyXzRxrl3i2tHKFHc7JGOO+3FAFXx54b8M3VnqmseLrGPVIEtfKSK4jEnkr/AHYR/DI7EDI+YnaAeBXL6N8PvEFz4X8IvqmrCPWtE05Rb+arP5d0XRj5hDDeuxRER7kg5xXS+KNB13xFqen6loXieystPhiElvDJpgu1aQ8ibcZF52nC8cAk9Tx0nhyyv7DSo4dX1M6pf7maW58kQqxJ4CoCdoAwMZPTrQBz3xQlbTfDFvrnH23SLqC5Vk4yDIqSr67WR3GPp6V1t9O9taSzR281y6DIhh2739huIH5kVy/xFh/tm0s/DcK+ZLqNxE84H/LK2jkV5HPpnaEHqXHvXT6hZQajZTWl2rPBKNrqrlCR9QQR+BoAyP7fu/8AoWta/wDJf/47Wtp11JeWgmltLizckjyrjbvGD1O1iP1rD/4Qbw//AM+k/wD4GTf/ABdbWlada6VZLa2MbJApLBWkZzknJ5Yk0AeX+MfBOl22reFI9BtV/wCEr/tWO8fUwP8ASTArbriSaQcspU7NrHGXUAY6esTxR3EEkM6LJFIpR0YZDKRggivPl8HeMV1W8vE8bWkf2yXdLs0RfMWLPESSGU4CjIBweSSck13880VpayTXEixwQoXeR24VQMkkn0HegD52+EEk/wAL/jNrXw7u/MOj6qxvdJc5IB2kgfiilSfWMetfRbxRvKkjxo0kedjFQSueuD2ry74XQyeMfE2o/EbUInW3uENhoUUikGOzVjmUg9GkbJ9dvHQ16Lq+sWOkC0+3zrG13cJawJ1aSVzgKB37k+gBPQUAcD8abuee78HeGxNLBp+u6qtvfPE5RpIVUuYdw5AfABxyRkdzXBeOta8/wc+saZ4OvPCeq6JZjU7HUWhjiQlZY0MK7Dlo3VzlXC5GPlr2nxx4VtPFujx2lzLLbXNvOl3Z3kOPMtZ0OUkXPBxyCD1BIrG1fwjq/im0ttN8XalYzaPFKktxBZWzRm/KEMqyFmbam4AlVznH3gOCALpd4+vfEK2knXbDpujQ3SQn+Ce5ZwT9QkRUf7zetc78WPBemTaG4sLVJvGupX0bafqJGbqObzA24OOVjjQE4HyhV6ZPPWX0TaR8RbbU34sNUs106RgOEnjdni3ezB5FHuFHcVnan4T8YT+Ib/VNO8Y2Nn5/7uBH0VZ2touyK5lGcn5iccnHYAUAWrHwhf2Xji68SQ6jCZb2Z1u4Wjba1sERYlUbsB0KH5sch2B7VqTeC9Cmkkkks5C0jFmP2mUZJOT0at20iaC1hieV5nRApkf7zkDqfc1LQBzOreHZrnxR4X1G1lhjtNHE6tE+4vIJIwgwe2MZ5zn261U8YyDTPFfhLVIjta4vG0qcAf6yOWN3XJ/2XjUj6t612Ncj4gjOteM9BsIQHt9KlOp3b9kfy2SFM/3iXZseie4oA6DU9Y03SjH/AGnf2tp5udnnyqm7HXGTz1Fcr4U8YaS39sfbtfsWI1OdIfMuk4jBG0Lz09K7dkVsblBx6isPwxpc1h/a32tI/wDSdRmuY8Hd8jYwT6HigDj/AI03c8934O8NiaWDT9d1Vbe+eJyjSQqpcw7hyA+ADjkjI7muC8da15/g59Y0zwdeeE9V0SzGp2OotDHEhKyxoYV2HLRurnKuFyMfLXtPjjwraeLdIjtLmWW2ubedLuzvIceZazocpIueDjkEHqCRWNq/hHV/FNpbab4v1Kxm0eKVJbiCytmjN+UIZVkLM21NwBKrnOPvAcEATw1ff8JD4/vbu4Qr/ZemWqwxHkRyXAaSRvY7VjXPoD61z3xF8E6asGlJpFureM7zVYZ7fVdo+0ptlDzSO458tYty7fu8ooHIrrRD/YnxHnunXbZa7axQiTstzCXwp7Dej8epjI7isu58IeMZNav9QtvGlnbm6Yqo/sVZHgh/hiRzL0HJzjliSR2oAu6f4Pv7HxvdeJItSiaW9ndbuJo22tbBEWJVG7AdCn3sch2B7VPIx034p28cZCwa1psjyoB1mt3jAf6lJsH/AHV9K62JPLiRNzPtUDcxyTjufeuUtY21f4jS6igzY6RZvYo/Z7iV0aTae+1Y0B92I7GgDraKKKAERFRQqKFUdABgCloooATau/ftG7GM45x6UtFFABRRRQAVyvxM0WHxH4Sn0a7uNUgtb6WKCZtNjDSlGcAg5BwnTcccLntmuqrlPFlhe6h4r8ICK3lfTbW6mu7mVGC7GWFljDcgkFnJxz90UAeaL+zR4cVQq+I/E6qBgAXSAAegGyq+ifDjwb8PPGh1k6l4h1O60K2+1T+e6SxWscu5A7YUHOA7YHICk+leoyaPrBkcqYsFiR/xNbscZ9B0rnNc8OavCfGkVtZtdv4i0mC1hdZdyxzLG8Lh2b5toDK+49cN3wCAenqwZQykFSMgjoaWq2mWosNNtLQOXFvEkQY9W2gDP6VZoAR0V12uoZfQjNLRRQAUUUUAFIFVSxVQCxySB1paKACiiigAooooARlVgAyggEEZHeloooAKRFVF2ooUegGKWigAooooAKKKKACiiigAooooAKK81+GfiBb9PEOpRStPYtqNzNMWMjyQqCFiSOPBJUom/I4y/APOOxtvEunXNxFBF9t8yRtq7rCdRn3JQAfUmgDZorj9Glm/4Wl4nhe4nktxp9jIkLyEpGxacNsXoM7VzjriuwoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiq+o3tvp1lNeXsnlW8K7nfBOB9BzQBYpHUOjI2drDBwcVzX/CeeG/+gmP+/Mn/wATW1pOpWmrWS3enzedbsSofaV5BweCAaAOAv8AxP4F8D+MLXRvs91ba69lDbW9va2k8pmgXPlhQoIYj5hn73UZrZb4h6aqlm0nxOFAyT/YV1wP++K4j9qDwlcan4TtvFGibo9c8OSfa45Ix85iBBb/AL5ID/8AAT613/ww8X2/jnwRpmu2+1Xnj23EY/5ZTLw6/n09iDQBL4PuNB8Qq3i7QGkl/tKIQNO29C6xO6hSjfd2tv7A8mulqppmm2ulwyxWMXlRyzSXDKCSN7sWY89MsSce9eRXnjaxvfFWv3XizVrrTfC+lakNDtYLd3jWa58syPJM0fznptUA7RjkZOaAPaKTcN23I3YzivIPh941RPGb6RFqV1qXhnUtLbWtKubwlpoEWQpJEzH5mXjcpbLAcEnt0vha01HWvBSanHdtZanrxW7nuVwXhgc5VI8ggFYiAM5AYluSaAO4nkEMMkjFQqKWJY4AAHc9qzPC+tx6/wCH7DVFhe1F3Ck4glYb0V+Vzg45GD+NeXzaXr9p4g8XeFfD+qajq+nXGjxMf7TuzM9lcTSGMhZW5wYt0m0k4IGPvV2nhDw7NF4avtH1+zi8zcbZryMoGvIkG2KXC/cYIEGP4SvHGDQB2VFc38PdTudT8NqNRkEmoWU81hcuP45IZGjLf8CChvxq14n1K4046T9m2f6TqEVtJvXPyNnOPQ8UAbVFBIAJPQV4HpHxB0XUdIbxL4+1vULK21ZruTSbO1lmhjgtreTy+PKILTE/MWY9wBgCgD3ykDAk4IODg47V494a8e32kaV4607Vbl9SuvDUcU9ldTqBJcwTxb4Fl24BcEhWYYz1xnJPa/8ACLXZ8P2GkpqtzaoxMupXVtIUubmQjLbZOq7n5JHIUAAigDY8Va1F4d8O6hq9xE00dnEZTGhAZ8dFGeMk8D3rQgmWWNCSFc8FNwJVscrx3FeM2WjeJNZ0/wAR+F7HWLm80iz1yGG31S+cTTRxpGs0iksP3uyYInOTywJ4ruBpF9efD4RSWSaVr0aG6QQurbLxcnzNw4IZs5zyVYg9TQB2dFZfhbVl17w1pWrIoQXtrHcbR/CWUEj8CcVqUAFFFFABRRRQAUUUUAFQX0MtxaSxW9y9rKwws0aqzIfUBgQfxFT0UAc//Yur/wDQ06h/4DW3/wAbrW023ntbRYrq9lvZQSTNKiKx56YQAcfSrVFAHJ/FDxTB4S8IXV49ul5eXBFnZWTDP2q4k+VI8dwep9gar/CDwVF4C8DWWkDY142bi8kQYDzvgtj/AGRwo9lFcd8VfAni7xf4706/0HxTpmljSIvMs7dkMksbvkNKy8jJwVBx0HHOay/+Fe/GT/op8H/gKP8A4mgD3VJ4nnkhSVGmjALoGBZQc4JHbOD+VefQeGdS8L+OtV1jR7GLVdJ1iZbqe18xY57O6CFGliLYVldT8wLAg9MjinfBnRJtF0vU/wC1vENv4g128uvtF3exvuJXaEjXn+EBTjHHUCvQ6APO9B8F3F54p1bxJrtvBYSXNgdLsdPt2Di1tyxZ2dhhTI7kk7eAOMtkmrHhO81aH4U2cGj2UFxr+nW4042s03lok8WIzvbnA+XdjuCPXNd5VeCyt4Lu5uoYlSe52+cw/jKjAJ98cZ9APQUAcX4Ci8U210bfV9B0/TbRt9xc3a6kbua7mOBkjy0C/XkAKqgY6d1LIkMTySuqRoCzOxwFA6knsKdVe/s7fULOS1vIhLbyDDxt0YZzg+o9u9AHMfDC2ZfDU99LG0f9rX1zqSxt1VJZWZPzTafxrM8UeBNHB0f7BpLv/wATOFptkkjbY/myT83A969CAwMDgUUAZmiaDpuiCYaXbCDziDJ87NuxnHUn1NcL4W8M6n4GOo6VZaNFrehSPNJYOk0cc1ukrb3t5A+AU3EkMCevIr02igDyWb4e3/8Awhnje6uxA/iPXwLgwW2TFCIVH2e3QkDdgKBuwMkngCur8Q6trWqeELO88EWkN3NfqjbpboQeVERliG2t8/8ACOODyemD19V7Gyt7FJUtIliSSRpWVem5jliB2yeeO5J70Ac34BTXILZ7XVdC0/Q7C2QJbW9tem7aQkks7PsXHbqCSSST67XiXU49F0C/1GXkW8LOF7u2PlUe5OAPc1pVXvLK3vDAbqJZfIlE0Yborjo2PUZ49DzQBleA9Jl0LwVoel3AxPaWcUUoBzhwo3frmt2iigAooooAKKKKACiiigAooooAKKKKAPPtM1e8vNa8W39oUkW1v49MgEdiJZlWOMNIG2lWK+Y7YyeMHjmpdYvde1DQ9Xs7ZLoXM1hcJCf7NaH94Ym2fOZDg7sdq7tVVc7QBk5OB1NLQB5d4OMNx4o8GPpC4gt/DDR3e1eEUtAIo29GBSXg8jDV6jTUjSMsURVLHLEDGT6mnUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUADEKpLEADkk9q474ZeILrX9Bjub1pZ3nL3KzeWqxrG0r+VFleriMKTx355q34k13w7cabqWl3niTTbCSWOS1kb7ZEkkJZSp4J4YZ796xfCl94L8MG7h0zxZo6adMyvFZfboBHAwUKxTBz820MQeM5I6mgD0CimxSJLEkkTq8bgMrKchgehB9KdQAUUUUAFFUtW1Wz0mKCXUJvKSeeO2jO0tukdgqLwD1JAq7QAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABQSAMkgD1NFUddtXvdIuraKCzuJJEwIrxSYW56MB2oAueYn99fzpwIYZUgj2rz3/hEtQ/6F/wV/wB+H/8Aia67w1Yy6dpKW89rp9q4ZiYrBSsQyc5AIHPr70AfPvxw0yH4e/FrQ/iFHZQz6LqL/ZNWhaEOucYLYIxkqMjuWjPrXuk/hbwvrWkNG2jaVPZXkPDLbJh0YcEHHocg1y37Q0ljN8NLzSbq2N5f6tJHZabbJje90zDyyvptI3E+gI711Xw98PP4U8E6LoUt093JY2ywvMxzuYdcf7IJwB2AAoAlh+yeDPBSfa7h2sNGsAHmYfMY4o+uPXC1xeia74i8R+HV1tdf0rRLm4SKe20yWASpDHL/AKhZ2LByzgrkrtxnABxz3Xi3RY/EfhbVtGmcxpf2slsXAzt3qRn8M5ryPw7o2hWuk2J8ceGL1/Gekw29sjQ2kk7Tm1x5T2sijbhsAnlcEkNgDNAHWaZ8RJNX+Hw1S3tFtdee9/sc2crblivvMEZUnuoJ3/7o7GtrWLHxO8FrpegapFZCKDfNqt5b/ankkzgII9ygZ5JPQDAA9PP9P8M6j4a8HaJf64kcV/ceKk1vUokcMluZ3ZNu7oQu9MkcZBxxzXc/EbxHdaPb29jYadrlxLeBhJdaZYPcm1QdTxxvOcL6Hk8DBAOEufEfiPxH4e8OXs+lRzXGl3t5c6i1orNG/wBkcwb4QQdzEuZFQ9TGeuK73xDqDaBoGma5a3V1Jp9n5a3a3BZmmt3KqZDkZ3rkPnjgMD14t/Dy5tp/DsUOm6JqGjadaH7PbwX8BglYKBlih5wSTyeWOT3ya3xdJPw312BFLzXUH2SFB1aSVhGgH/AmFAHX0VmDU2TX4tI+wX7KbQ3P27yx9nBDBfLLZzvOc4x0B5rToAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA+fvHEHxPufiwPEGjeD7W/0/S43tdKS9u4wilsB7gKJAQzYwM9FxxmrreK/jttOPAegg44P2of/AB6u18P+KGbSpdVW3tgmoX9z5fn6ntV0ifyldBJ90MEztXgZz3qn468UXFz4N1NbeS3tGL2sTzWt+krpFJcRxyN8vK4Rm+agDofhjY61ZeD7VvFTs2vXTyXV6C4YRyOxOxcEgKq7VABxxXVVxfhR2tviB4s0u3c/2dBDZXEcQPywyyLIHVR2yI42x6knvXaUAV9RsrbUrC4sr6JZrWdDHJG3RlIwRRp1u9pYwW8lxLctEoTzpSC746Fj3Pv3qxRQAVnahpMGoahYXN0zOlk5lihONnm4wHI7lQTj0Jz1xjRooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAKWkaTY6Np0NhplrHbWcWdkSDhcnJ6+5qW9sra+s5rS8gintpkMckTqCrqeoIoooAZp+m2mnGc2kIR53EkrklmkYAKCzHJOAAOewq3RRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAH/2Q==" alt="image" class="calibre2"></p>
<p class="para">Hence <i class="calibre1">T</i>(2<sup class="calibre8"><i class="calibre1">k</i></sup>) = Θ(<i class="calibre1">k</i>2<sup class="calibre8"><i class="calibre1">k</i></sup>). Now suppose 2<sup class="calibre8"><i class="calibre1">k</i></sup> ≤ <i class="calibre1">n</i> &lt; 2<sup class="calibre8"><i class="calibre1">k</i>+1</sup>, so</p>
<p class="equationasimage">Θ(<i class="calibre1">k</i>2<sup class="calibre8"><i class="calibre1">k</i></sup>) = <i class="calibre1">T</i>(2<sup class="calibre8"><i class="calibre1">k</i></sup>) ≤ <i class="calibre1">T</i>(<i class="calibre1">n</i>) ≤ <i class="calibre1">T</i>(2<sup class="calibre8"><i class="calibre1">k</i>+1</sup>) = Θ((<i class="calibre1">k</i>+1)2<sup class="calibre8"><i class="calibre1">k</i>+1</sup>) = Θ(<i class="calibre1">k</i>2<sup class="calibre8"><i class="calibre1">k</i></sup>).</p>
<p class="para">Hence <i class="calibre1">T</i>(<i class="calibre1">n</i>) = Θ(<i class="calibre1">k</i>2<sup class="calibre8"><i class="calibre1">k</i></sup>) = Θ(<i class="calibre1">n</i>log<i class="calibre1">n</i>).</p>
<p class="theorem"><b class="calibre7">Answer to Exercise F</b></p>
<p class="para">Define <span class="font">x &lt;&gt; n = n+1</span> and <span class="font">n @ x = 1+n</span>. We have</p>
<p class="code"><span class="font">(x &lt;&gt; n) @ y = 1+(n+1) = (1+n)+1 = x &lt;&gt; (n @ y)</span></p>
<p class="para">The second proof is similar.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise G</b></p>
<p class="para">The induction step is</p>
<div class="space1">
<p class="code2"><span class="font">(foldr f a (x:xs),foldr g b (x:xs)</span></p>
<p class="code"><span class="font">= (f x (foldr f a xs),g x (foldr g b xs))</span></p>
<p class="code"><span class="font">= h x (foldr f a xs,foldr g b xs)</span></p>
<p class="code"><span class="font">= h x (foldr h (a,b) xs</span></p>
<p class="code"><span class="font">= foldr h (a,b) (x:xs)</span></p>
</div>
<p class="para">The answer to the tricky question is No. The values (⊥, ⊥) and ⊥ are different in Haskell. For example, suppose we define <span class="font">foo (x,y) = 1</span>. Then <span class="font">foo undefined = undefined foo (undefined,undefined) = 1</span></p>
<p class="para">For the last part, the definition of <span class="font">h</span> is that</p>
<p class="code"><span class="font">h (y,z) x = (f y x,g z x)</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise H</b></p>
<p class="para">We have <span class="font">filter p = foldr (op p) []</span>, where</p>
<p class="code"><a id="text/part0011.html.page_178" class="calibre3"></a><span class="font">op p x xs = if p x then x:xs else xs</span></p>
<p class="para">Now</p>
<div class="space1">
<p class="code"><span class="font">(op p x ys,op (not . p) x zs)</span></p>
<p class="code"><span class="font">= if p x then (x:ys,zs) else (ys,x:zs)</span></p>
</div>
<p class="para">Hence</p>
<div class="space1">
<p class="code"><span class="font">partition p xs = foldr f ([],[]) xs</span></p>
<p class="code"><span class="font">where f x (ys,zs) = if p x</span></p>
<p class="code16"><span class="font">then (x:ys,zs)</span></p>
<p class="code16"><span class="font">else (ys,x:zs)</span></p>
</div>
<p class="para">For the last part we obtain</p>
<div class="space1">
<p class="code"><span class="font">partition p xs = part p xs [] []</span></p>
<p class="code"><span class="font">part p [] ys zs = (ys,zs)</span></p>
<p class="code"><span class="font">part p (x:xs) ys zs = if p x</span></p>
<p class="code16"><span class="font">then part p xs (x:ys) zs</span></p>
<p class="code16"><span class="font">else part p xs ys (z:zs)</span></p>
</div>
<p class="theorem"><b class="calibre7">Answer to Exercise I</b></p>
<p class="para">Remember that <i class="calibre1">T</i> estimates the <i class="calibre1">worst case</i> running time. The worst case for <span class="font">labels</span> arises when every right subtree of the tree is a leaf. Then we have</p>
<p class="equationasimage"><i class="calibre1">T</i>(<span class="font">labels</span>)(<i class="calibre1">n</i>) = <i class="calibre1">T</i>(<span class="font">labels</span>)(<i class="calibre1">n</i>−1) +Θ(<i class="calibre1">n</i>),</p>
<p class="para">where Θ(<i class="calibre1">n</i>) accounts for the time to concatenate a list of length <i class="calibre1">n</i>−1 with a list of length 1. Hence</p>
<p class="equationasimage"><img src="data:image/jpeg;base64,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" alt="Image" class="calibre2"></p>
<p class="para">The accumulating parameter method yields</p>
<div class="space1">
<p class="code"><span class="font">labels t</span><span class="space3"></span><span class="space5"></span><span class="font">= labels2 t []</span></p>
<p class="code"><span class="font">labels2 (Leaf x) xs</span><span class="space-b"></span><span class="font">= x:xs</span></p>
<p class="code"><span class="font">labels2 (Fork u v) xs = labels2 u (labels2 v xs)</span></p>
</div>
<p class="para">and <i class="calibre1">T</i>(<span class="font">labels2</span>)(<i class="calibre1">n</i>) = Θ(<i class="calibre1">n</i>). This improves the running time of <span class="font">labels</span> from quadratic to linear time.</p>
<p class="para">The induction step in the proof that <span class="font">labels (build xs) = xs</span> is to assume the <a id="text/part0011.html.page_179" class="calibre3"></a>hypothesis for all lists strictly shorter than <span class="font">xs</span>:</p>
<div class="space1">
<p class="code2"><span class="font">labels (build xs)</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{assume <span class="font">xs</span> has length at least two</p>
<p class="code2">and let <span class="font">(ys,zs) = halve xs</span>}</p>
<p class="code2"><span class="font">labels (Fork (build ys) (build zs))</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">labels</span>}</p>
<p class="code2"><span class="font">labels (build ys) ++ labels (build zs)</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{induction, since <span class="font">ys</span> and <span class="font">zs</span> are strictly shorter than <span class="font">xs</span>}</p>
<p class="code2"><span class="font">ys ++ zs</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">halve xs</span>}</p>
<p class="code2"><span class="font">xs</span></p>
</div>
<p class="para">The induction here is <i class="calibre1">general induction</i>: in order to prove <i class="calibre1">P</i>(<span class="font">xs</span>) for all finite lists <span class="font">xs</span> it is sufficient to prove that: (i) <i class="calibre1">P</i>(<span class="font">[]</span>); and (ii) <i class="calibre1">P</i>(<span class="font">xs</span>) holds under the assumption that <i class="calibre1">P</i> holds for all lists of length strictly less than <span class="font">xs</span>.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise J</b></p>
<p class="para">One key property is that</p>
<div class="space1">
<p class="code"><span class="font">(xs ++ [x] ++ ys)!!k | k &lt; n = xs!!k</span></p>
<p class="code16">&nbsp;<span class="space-r1"></span><span class="font">| k==n = x</span></p>
<p class="code16">&nbsp;<span class="space-r1"></span><span class="font">| k &gt; n = ys!!(n-k)</span></p>
<p class="code16">&nbsp;<span class="space-r1"></span><span class="font">where n = length xs</span></p>
</div>
<p class="para">The other key property is that sorting a list does not change the length of the list. Hence</p>
<div class="space1">
<p class="code"><span class="font">select k []</span><span class="space4"></span><span class="font">= error "list too short"</span></p>
<p class="code"><span class="font">select k (x:xs) | k &lt; n = select k ys</span></p>
<p class="code4">&nbsp;<span class="space-r1"></span><span class="font">| k==n = x</span></p>
<p class="code4">&nbsp;<span class="space-r1"></span><span class="font">| otherwise = select (n-k) zs</span></p>
<p class="code4">&nbsp;<span class="space-r1"></span><span class="font">where ys = [y | y &lt;- xs, y &lt; x]</span></p>
<p class="code14">&nbsp;<span class="space4"></span><span class="font">zs = [z | z &lt;- xs, x &lt;= z]</span></p>
<p class="code14">&nbsp;<span class="space4"></span><span class="font">n = length ys</span></p>
</div>
<p class="para">The worst-case running time for a list of length <i class="calibre1">n</i> occurs when <i class="calibre1">k</i> = 0 and the length of <span class="font">ys</span> is <i class="calibre1">n</i>−1, i.e. when <span class="font">x:xs</span> is in strictly decreasing order. Thus</p>
<p class="equationasimage"><i class="calibre1">T</i>(<span class="font">select</span>)(0, <i class="calibre1">n</i>) = <i class="calibre1">T</i>(<span class="font">select</span>)(0, <i class="calibre1">n</i>−1) +Θ(<i class="calibre1">n</i>),</p>
<p class="para">with solution <i class="calibre1">T</i>(<span class="font">select</span>)(0, <i class="calibre1">n</i>) = Θ(<i class="calibre1">n</i><sub class="calibre11">2</sub>). But, assuming a reasonable distribution</p>
<p class="para"><a id="text/part0011.html.page_180" class="calibre3"></a>in which each permutation of the sorted result is equally likely as input, we have <i class="calibre1">T</i>(<span class="font">select</span>)(<i class="calibre1">k</i>, <i class="calibre1">n</i>) = Θ(<i class="calibre1">n</i>).</p>
<h3 class="h" id="text/part0011.html.head7-10">7.10 Chapter notes</h3>
<p class="para">There are many books on algorithm design, but two that concentrate on functional programming are <i class="calibre1">Algorithms: A Functional Programming Approach</i> (second edition) (Addison-Wesley, 1999) by Fethi Rabbi and Guy Lapalme, and my own <i class="calibre1">Pearls of Functional Algorithm Design</i> (Cambridge, 2010).</p>
<p class="para">Information about profiling tools comes with the documentation on the Haskell Platform. The source book on sorting is Don Knuth’s <i class="calibre1">The Art of Computer Programming, Volume 3: Sorting and Searching</i> (second edition) (Addison-Wesley, 1998).</p>
</div></div>
<div id="text/part0012.html"><div id="text/part0012.html.BE6O0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre">

<h2 class="chapter-number" id="text/part0012.html.calibre_pb_0"><a id="text/part0012.html.page_181" class="calibre6"></a>Chapter 8</h2>
<h2 class="chapter-title">Pretty-printing</h2>
<p class="para">This chapter is devoted to an example of how to build a small library in Haskell. A library is an organised collection of types and functions made available to users for carrying out some task. The task we have chosen to discuss is <i class="calibre1">pretty-printing</i>, the idea of taking a piece of text and laying it out over a number of lines in such a way as to make the content easier to view and understand. We will ignore many of the devices for improving the readability of a piece of text, devices such as a change of colour or size of font. Instead we concentrate only on where to put the line breaks and how to indent the contents of a line. The library won’t help you to lay out bits of mathematics, but it can help in presenting tree-shaped information, or in displaying lists of words as paragraphs.</p>
<h3 class="h" id="text/part0012.html.head8-1">8.1 Setting the scene</h3>
<p class="para">Let’s begin with the problem of displaying conditional expressions. In this book we have used three ways of displaying such expressions:</p>
<div class="space1">
<p class="code"><span class="font">if p then expr1 else expr2</span></p>
<p class="para1"></p>
<p class="code"><span class="font">if p then expr1</span></p>
<p class="code"><span class="font">else expr2</span></p>
<p class="para1"></p>
<p class="code"><span class="font">if p</span></p>
<p class="code"><span class="font">then expr1</span></p>
<p class="code"><span class="font">else expr2</span></p>
</div>
<p class="para">These three layouts, which occupy one, two or three lines, respectively, are considered acceptable, but the following two are not:</p>
<div class="space1">
<p class="code"><a id="text/part0012.html.page_182" class="calibre3"></a><span class="font">if p then</span></p>
<p class="code"><span class="font">expr1 else expr2</span></p>
<p class="para1"></p>
<p class="code"><span class="font">if p</span></p>
<p class="code"><span class="font">then expr1 else expr2</span></p>
</div>
<p class="para">The decision as to what is or is not acceptable is down to me, the author. You may disagree with my choices (some do), and a flexible library should provide you with the ability to make your own reasonable choices. In any case, two basic questions have to be answered. Firstly, how can we describe the acceptable alternatives while rejecting the unacceptable ones? Secondly, how do we choose between the acceptable alternatives?</p>
<p class="para">A quick answer to the second question is that the choice depends on the permitted line width. For instance we might choose a layout with the fewest lines, subject to the condition that each line fits within the allotted line width. Much more on this later.</p>
<p class="para">As to the first question, one answer is just to write out all the acceptable alternatives. That’s going to involve a lot of writing. A better alternative is to provide the user with a suitable <i class="calibre1">layout description language</i>. As a rough and ready guide we might write something like</p>
<div class="space1">
<p class="code"><span class="font">if p &lt;0&gt; then expr1 (&lt;0&gt; + &lt;1&gt;) else expr2 +</span></p>
<p class="code"><span class="font">if p &lt;1&gt; then expr1 &lt;1&gt; else expr2</span></p>
</div>
<p class="para">where <span class="font">&lt;0&gt;</span> means a single space, <span class="font">&lt;1&gt;</span> means a line break and <span class="font">+</span> means ‘or’. The expression above yields our three layouts described earlier. However, the danger with providing the user with an unfettered choice of alternatives is that it becomes difficult to make a decision about the best layout without exploring every possible alternative, and that could take a long time.</p>
<p class="para">Another possibility is to allow only restricted choice by forcing the user to describe layouts in terms of certain functions and operations provided by the library. For example, consider the description</p>
<p class="code"><span class="font">group (group (if p &lt;1&gt; then expr1) &lt;&gt; &lt;1&gt; else expr2)</span></p>
<p class="para">where <span class="font">group</span> augments a set of layouts with one additional layout in which every <span class="font">&lt;1&gt;</span> is replaced by <span class="font">&lt;0&gt;</span>, thereby flattening the layout to just one line, and <span class="font">(&lt;&gt;)</span> means concatenation lifted to sets of alternatives. For example,</p>
<div class="space1">
<p class="code"><span class="font">group (if p &lt;1&gt; then expr1)</span></p>
<p class="code11"><span class="font">= {if p &lt;0&gt; then expr1, if p &lt;1&gt; then expr1}</span></p>
<p class="code"><a id="text/part0012.html.page_183" class="calibre3"></a><span class="font">group (if p &lt;1&gt; then expr1) &lt;&gt; &lt;1&gt; else expr2</span></p>
<p class="code11"><span class="font">= {if p &lt;0&gt; then expr1 &lt;1&gt; else expr2,</span></p>
<p class="code8"><span class="space"></span><span class="font">if p &lt;1&gt; then expr1 &lt;1&gt; else expr2}</span></p>
<p class="code"><span class="font">group (group (if p &lt;1&gt; then expr1) &lt;&gt; &lt;1&gt; else expr2)</span></p>
<p class="code11"><span class="font">= {if p &lt;0&gt; then expr1 &lt;0&gt; else expr2,</span></p>
<p class="code8"><span class="space"></span><span class="font">if p &lt;0&gt; then expr1 &lt;1&gt; else expr2,</span></p>
<p class="code8"><span class="space"></span><span class="font">if p &lt;1&gt; then expr1 &lt;1&gt; else expr2}</span></p>
</div>
<p class="para">Thus our set of three acceptable layouts is captured by the above description which contains two occurrences of <span class="font">group</span>.</p>
<p class="para">There is another aspect to the problem of displaying conditional expressions. What if <span class="font">expr1</span> or <span class="font">expr2</span> are themselves conditional expressions? Here we might want to allow a layout like</p>
<div class="space1">
<p class="code"><span class="font">if p</span></p>
<p class="code"><span class="font">then if q</span></p>
<p class="code11"><span class="font">then expr1</span></p>
<p class="code11"><span class="font">else expr2</span></p>
<p class="code"><span class="font">else expr3</span></p>
</div>
<p class="para">The point is that we should allow for <i class="calibre1">indentation</i> in our description language. Indentation means putting in a suitable number of spaces after each line break. This idea can be captured by providing a function <span class="font">nest</span> so that <span class="font">nest i x</span> is a layout in which <i class="calibre1">each</i> line break in layout <span class="font">x</span> is followed by <span class="font">i</span> spaces.</p>
<h3 class="h" id="text/part0012.html.head8-2">8.2 Documents</h3>
<p class="para">For the sake of a name let us agree to call a <i class="calibre1">document</i> some entity that represents the set of possible layouts of a piece of text. Documents are given as elements of the type <span class="font">Doc</span> whose definition is left for later on. On the other hand, a layout is simply a string:</p>
<p class="code"><span class="font">type Layout = String</span></p>
<p class="para">We are deliberately being cagey about what a document actually is because we want to consider two representations of <span class="font">Doc</span>. For now we concentrate on the operations on documents that our library might provide.</p>
<p class="para">The first operation is a function <a id="text/part0012.html.page_184" class="calibre3"></a>that takes a given line width and a document, and returns the best layout. How to define this function efficiently is really the main concern of the chapter.</p>
<p class="code"><span class="font">pretty :: Int -&gt; Doc -&gt; Layout</span></p>
<p class="para">The second operation is a function</p>
<p class="code"><span class="font">layouts :: Doc -&gt; [Layout]</span></p>
<p class="para">that returns the set of possible layouts as a list. Why should we want such a function when we have <span class="font">pretty</span>? Well, it takes a little experimentation to find the definitions that describe the layouts we regard as acceptable. The way to experiment is to formulate an initial definition and then rework it after inspecting all the resulting layouts on a small number of examples. That way we can see whether some layouts should be excluded or others added. So, whatever our final representation of documents turns out to be, we should provide <span class="font">layouts</span> as a sensible diagnostic tool for the user.</p>
<p class="para">The remaining operations deal with constructing documents. First up is the operation of concatenating two documents to give a new one:</p>
<p class="code"><span class="font">(&lt;&gt;) :: Doc -&gt; Doc -&gt; Doc</span></p>
<p class="para">Document concatenation should surely be an associative operation so we require of any implementation of <span class="font">(&lt;&gt;)</span> that</p>
<p class="code"><span class="font">(x &lt;&gt; y) &lt;&gt; z) = x &lt;&gt; (y &lt;&gt; z)</span></p>
<p class="para">for all documents <span class="font">x</span>, <span class="font">y</span> and <span class="font">z</span>.</p>
<p class="para">Whenever there is an associative operation there is usually an identity element, so we also provide an empty document</p>
<p class="code"><span class="font">nil :: Doc</span></p>
<p class="para">We require <span class="font">nil &lt;&gt; x = x</span> and <span class="font">x &lt;&gt; nil = x</span> for all documents <span class="font">x</span>.</p>
<p class="para">The next operation is a function</p>
<p class="code"><span class="font">text :: String -&gt; Doc</span></p>
<p class="para">that takes a string not containing newlines into a document. To provide for documents containing more than one line, we can provide another basic document</p>
<p class="code"><span class="font">line :: Doc</span></p>
<p class="para">For example, <a id="text/part0012.html.page_185" class="calibre3"></a>is a document with a single layout that consists of two lines. You might think that <span class="font">line</span> is unnecessary because we could always allow newline characters in text strings, but to indent a document we would then have to inspect the contents of every <span class="font">text</span>. Far better is to have an explicit newline document; that way we know where line breaks are.</p>
<p class="code"><span class="font">text "Hello" &lt;&gt; line &lt;&gt; text "World!"</span></p>
<p class="para">Next, the function</p>
<p class="code"><span class="font">nest :: Int -&gt; Doc -&gt; Doc</span></p>
<p class="para">provides a way of nesting documents: <span class="font">nest i</span> indents a document by inserting <span class="font">i</span> spaces <i class="calibre1">after</i> every newline. Note the emphasis: indentation is not done at the beginning of a document unless it begins with a newline. The reason for this choice is explained below.</p>
<p class="para">Finally, to complete a library of eight operations, we have the function</p>
<p class="code"><span class="font">group :: Doc -&gt; Doc</span></p>
<p class="para">This is the function that produces multiple layouts. The function <span class="font">group</span> takes a document and adds an extra layout, one that consists of a single line of text with no line breaks.</p>
<p class="para">We have named eight operations and given informal descriptions of what they are intended to mean, but can we be more precise about their properties and the relationships between them? An even more fundamental question is whether these operations are sufficiently flexible to allow for a reasonable class of layouts.</p>
<p class="para">Let’s first concentrate on what equational laws we might want. Finding such laws can boost our confidence that we have in hand an adequate and smoothly integrated box of tools, and that there isn’t some crucial gadget we have missed. Such laws can also influence the meanings of operations and guide implementations. We have already asserted that <span class="font">(&lt;&gt;)</span> should be associative with identity element <span class="font">nil</span>, but what else should we require?</p>
<p class="para">Well, for <span class="font">text</span> we want the following properties:</p>
<div class="space1">
<p class="code"><span class="font">text (s ++ t) = text s &lt;&gt; text t</span></p>
<p class="code"><span class="font">text "" = nil</span></p>
</div>
<p class="para">In mathematical language this asserts that <span class="font">text</span> is a <i class="calibre1">homomorphism</i> from string concatenation to document concatenation. An impressive (and possibly intimidating) name for something quite simple. Note that the associativity of string concatenation implies the associativity of document concatenation, at least for <span class="font">text</span> documents.</p>
<p class="para"><a id="text/part0012.html.page_186" class="calibre3"></a>For <span class="font">nest</span> we require the following equations to hold:</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">nest i (x &lt;&gt; y)</span></td>
<td class="calibre14"><span class="font">= nest i x &lt;&gt; nest i y</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">nest i nil</span></td>
<td class="calibre14"><span class="font">= nil</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">nest i (text s)</span></td>
<td class="calibre14"><span class="font">= text s</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">nest i line</span></td>
<td class="calibre14"><span class="font">= line &lt;&gt; text (replicate i ' ')</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">nest i (nest j x)</span></td>
<td class="calibre14"><span class="font">= nest (i+j) x</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">nest 0 x</span></td>
<td class="calibre14"><span class="font">= x</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">nest i (group x)</span></td>
<td class="calibre14"><span class="font">= group (nest i x)</span></td>
</tr>
</tbody></table>
<p class="para">All very reasonable (except possibly for the last), and we could give some of them mathematical names (<span class="font">nest i</span> distributes through concatenation, <span class="font">nest</span> is a homomorphism from numerical addition to functional composition and <span class="font">nest i</span> commutes with <span class="font">group</span>). The third law fails if <span class="font">nest</span> were to indent from the beginning of a document; and it would also fail if we allowed text strings to contain newline characters. The last law holds because grouping adds a layout with no line breaks, and nesting has no effect on such a layout. See Exercise D for a more precise argument.</p>
<p class="para">Turning to the properties of <span class="font">layouts</span>, we require that</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">layouts (x &lt;&gt; y)</span></td>
<td class="calibre14"><span class="font">= layouts x &lt;++&gt; layouts y</span></td>
</tr><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">layouts nil</span></td>
<td class="calibre14"><span class="font">= [""]</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">layouts (text s)</span></td>
<td class="calibre14"><span class="font">= [s]</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">layouts line</span></td>
<td class="calibre14"><span class="font">= ["\n"]</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">layouts (nest i x)</span></td>
<td class="calibre14"><span class="font">= map (nestl i) (layouts x)</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">layouts (group x)</span></td>
<td class="calibre14"><span class="font">= layouts (flatten x) ++ layouts x</span></td>
</tr>
</tbody></table>
<p class="para">The operation <span class="font">(&lt;++&gt;)</span> is lifted concatenation:</p>
<p class="code"><span class="font">xss &lt;++&gt; yss = [xs ++ ys | xs &lt;- xss, ys &lt;- yss]</span></p>
<p class="para">The function <span class="font">nestl :: Int -&gt; Layout -&gt; Layout</span> is defined by</p>
<div class="space1">
<p class="code"><span class="font">nestl i</span><span class="space5"></span><span class="space-r"></span><span class="font">= concat (map indent i)</span></p>
<p class="code"><span class="font">indent i c = if c=='\n' then c:replicate i ' ' else [c]</span></p>
</div>
<p class="para">Finally, <span class="font">flatten :: Doc -&gt; Doc</span> is the function that converts a document into one with a single layout in which each newline and its associated indentation is replaced by a single space. This function is not provided in the public interface of our documents library, though it will be needed internally. It is a missing gadget in the sense that we need it to complete the description of the algebraic laws.</p>
<p class="para">We require that <span class="font">flatten</span> should satisfy the following conditions:</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><a id="text/part0012.html.page_187" class="calibre3"></a><span class="font">flatten (x &lt;&gt; y)</span></td>
<td class="calibre14"><span class="font">= flatten x &lt;&gt; flatten y</span></td>
</tr><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">flatten nil</span></td>
<td class="calibre14"><span class="font">= nil</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">flatten (text s)</span></td>
<td class="calibre14"><span class="font">= text s</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">flatten line</span></td>
<td class="calibre14"><span class="font">= text " "</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">flatten (nest i x)</span></td>
<td class="calibre14"><span class="font">= flatten x</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">flatten (group x)</span></td>
<td class="calibre14"><span class="font">= flatten x</span></td>
</tr>
</tbody></table>
<p class="para">That makes 24 laws in total (one for <span class="font">&lt;&gt;</span>, two each for <span class="font">nil</span> and <span class="font">text</span>, seven for <span class="font">nest</span> and six each for <span class="font">layouts</span> and <span class="font">flatten</span>). Many of the laws look like constructive Haskell definitions of functions over a data type in which <span class="font">nil</span>, <span class="font">text</span> and so on are constructors. More on this is in <a href="#text/part0012.html.head8-6" class="calibre3">Section 8.6</a>.</p>
<p class="para">The eight operations certainly seem reasonable enough, but do they give us sufficient flexibility to describe the layouts we might want? The proof of the pudding is in the eating, so in a moment we will pause to consider three examples. Before doing so, some implementation of documents, however quick and dirty, will be needed to test the examples.</p>
<h3 class="h" id="text/part0012.html.head8-3">8.3 A direct implementation</h3>
<p class="para">One obvious choice of representation is to identify a document with its list of layouts:</p>
<p class="code"><span class="font">type Doc = [Layout]</span></p>
<p class="para">Such a representation is called a <i class="calibre1">shallow embedding</i>. With a shallow embedding, the library functions are implemented directly in terms of the values of interest (here, <span class="font">layouts</span>). Later on we will abandon this representation in favour of a more structured alternative, but it is the obvious one to try first.</p>
<p class="para">Here are the definitions of the operations above (we will leave <span class="font">pretty</span> until later):</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">layouts</span></td>
<td class="calibre14"><span class="font">= id</span></td>
</tr><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">x &lt;&gt; y</span></td>
<td class="calibre14"><span class="font">= x &lt;++&gt; y</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">nil</span></td>
<td class="calibre14"><span class="font">= [""]</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">line</span></td>
<td class="calibre14"><span class="font">= ["\n"]</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">text s</span></td>
<td class="calibre14"><span class="font">= [s]</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">nest i</span></td>
<td class="calibre14"><span class="font">= map (nestl i)</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">group x</span></td>
<td class="calibre14"><span class="font">= flatten x ++ x</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">flatten x</span></td>
<td class="calibre14"><span class="font">= [flattenl (head x)]</span></td>
</tr>
</tbody></table>
<p class="para">We have already defined <span class="font">nestl</span>, and <span class="font">flattenl</span> is defined by</p>
<div class="space1">
<p class="code"><a id="text/part0012.html.page_188" class="calibre3"></a><span class="font">flattenl :: Layout -&gt; Layout</span></p>
<p class="code"><span class="font">flattenl [] = []</span></p>
<p class="code"><span class="font">flattenl (c:cs)</span></p>
<p class="code2"><span class="font">| c=='\n' = ' ':flattenl (dropWhile (== ' ') cs)</span></p>
<p class="code2"><span class="font">| otherwise = c:flattenl cs</span></p>
</div>
<p class="para">Do the 24 laws hold for this implementation? Well, let’s go through them. Lifted concatentation <span class="font">&lt;++&gt;</span> is associative with <span class="font">[[]]</span> as identity element, so the first three laws are okay. The two laws of <span class="font">text</span> are easy to check, and the six laws of <span class="font">layouts</span> are immediate. All but two laws of <span class="font">nest</span> are routine. The remaining two, namely</p>
<div class="space1">
<p class="code"><span class="font">nest i . nest j = nest (i+j)</span></p>
<p class="code"><span class="font">nest i . group = group . nest i</span></p>
</div>
<p class="para">involve a bit of work (see Exercises C and D). That leaves the laws of <span class="font">flatten</span>. Three are easy, and one can show</p>
<div class="space1">
<p class="code"><span class="font">flatten . nest i = flatten</span></p>
<p class="code"><span class="font">flatten . group = flatten</span></p>
</div>
<p class="para">with a bit of work (see Exercises E and F). But the stumbling block is the law</p>
<p class="code"><span class="font">flatten (x &lt;&gt; y) = flatten x &lt;&gt; flatten y</span></p>
<p class="para">This one is false. Take <span class="font">x = line</span> and <span class="font">y = text " hello"</span>. Then</p>
<div class="space1">
<p class="code"><span class="font">flatten (x &lt;&gt; y) = ["hello"]</span></p>
<p class="code"><span class="font">flatten x &lt;&gt; flatten y = [" hello"]</span></p>
</div>
<p class="para">and the two results are different. The reason is that <span class="font">flatten</span> removes the effect of nesting, but does not remove spaces after newlines if they are present in an unnested document. On the other hand, <span class="font">flattenl</span> removes spaces after every newline in the document.</p>
<p class="para">Rather than try to fix up this deficiency, we can accept the less than perfect implementation and move on. One can show that all layouts of a document flatten to the same string (see the Answer to Exercise E). The shallow embedding also possesses another property that we will exploit in the definition of <span class="font">pretty</span>. To see what it is, consider the function <span class="font">shape</span> that returns the shape of a layout:</p>
<div class="space1">
<p class="code"><span class="font">shape :: Layout -&gt; [Int]</span></p>
<p class="code"><span class="font">shape = map length . lines</span></p>
</div>
<p class="para">The prelude function <span class="font">lines</span> breaks up a string on newline characters, returning a list of strings without newlines. Thus the shape of a layout is the list of lengths of the lines that make up the layout. The crucial property of <span class="font">layouts</span> is that the list <a id="text/part0012.html.page_189" class="calibre3"></a>of shapes of the layouts of a document is in lexicographically decreasing order. For example, one of the documents described in the following section has 13 possible layouts whose shapes are given by</p>
<div class="space1">
<p class="code"><span class="font">[[94],[50,43],[50,28,19],[50,15,17,19],[10,39,43],</span></p>
<p class="code"><span class="font">[10,39,28,19],[10,39,15,17,19],[10,28,15,43],</span></p>
<p class="code"><span class="font">[10,28,15,28,19],[10,28,15,15,17,19],[10,13,19,15,43],</span></p>
<p class="code"><span class="font">[10,13,19,15,28,19],[10,13,19,15,15,17,19]]</span></p>
</div>
<p class="para">This list is in decreasing lexicographic order. The reason the property holds is that <span class="font">layouts (group x)</span> puts the flattened layout at the head of the list of layouts of document <span class="font">x</span>, and a flattened layout consists of a single line. Exercise G goes into more details.</p>
<h3 class="h" id="text/part0012.html.head8-4">8.4 Examples</h3>
<p class="para">Our first example deals with laying out conditional expressions. For present purposes a conditional expression can be represented as an element of the data type <span class="font">CExpr</span>, where</p>
<p class="code"><span class="font">data CExpr = Expr String | If String CExpr CExpr</span></p>
<p class="para">Here is a function <span class="font">cexpr</span> that specifies the acceptable layouts described earlier:</p>
<div class="space1">
<p class="code"><span class="font">cexpr :: CExpr -&gt; Doc</span></p>
<p class="code"><span class="font">cexpr (Expr p) = text p</span></p>
<p class="code"><span class="font">cexpr (If p x y)</span></p>
<p class="code2"><span class="font">= group (group (text "if " &lt;&gt; text p &lt;&gt;</span></p>
<p class="code17"><span class="font">line &lt;&gt; text "then " &lt;&gt;</span></p>
<p class="code17"><span class="font">nest 5 (cexpr x)) &lt;&gt;</span></p>
<p class="code11"><span class="font">line &lt;&gt; text "else " &lt;&gt;</span></p>
<p class="code11"><span class="font">nest 5 (cexpr y))</span></p>
</div>
<p class="para">This definition is similar to our previous version, except for the nesting of the subexpressions.</p>
<p class="para">For example, two of the 13 possible layouts for one particular expression are as follows:</p>
<div class="space1">
<p class="code"><span class="font">if wealthy</span></p>
<p class="code"><span class="font">then if happy then lucky you else tough</span></p>
<p class="code"><span class="font">else if in love then content else miserable</span></p>
<p class="code"><a id="text/part0012.html.page_190" class="calibre3"></a><span class="font">if wealthy</span></p>
<p class="code"><span class="font">then if happy</span></p>
<p class="code2"><span class="font">then lucky you</span></p>
<p class="code2"><span class="font">else tough</span></p>
<p class="code"><span class="font">else if in love</span></p>
<p class="code2"><span class="font">then content</span></p>
<p class="code2"><span class="font">else miserable</span></p>
</div>
<p class="para">You can see from the last expression why we have chosen an indentation of five spaces. The 13 possible layouts for this particular conditional expression have the shapes displayed in the previous section.</p>
<p class="para">The second example concerns how to lay out general trees, trees with an arbitrary number of subtrees:</p>
<p class="code"><span class="font">data GenTree a = Node a [GenTree a]</span></p>
<p class="para">Here is an example tree, laid out in two different ways:</p>
<div class="space1">
<p class="code"><span class="font">Node 1</span></p>
<p class="code2"><span class="font">[Node 2</span></p>
<p class="code11"><span class="font">[Node 7 [],</span></p>
<p class="code11"><span class="space-r"></span><span class="font">Node 8 []],</span></p>
<p class="code2"><span class="font">Node 3</span></p>
<p class="code11"><span class="font">[Node 9</span></p>
<p class="code8"><span class="font">[Node 10 [],</span></p>
<p class="code8"><span class="space-r"></span><span class="font">Node 11 []]],</span></p>
<p class="code2"><span class="font">Node 4 [],</span></p>
<p class="code2"><span class="font">Node 5</span></p>
<p class="code11"><span class="font">[Node 6 []]]</span></p>
<p class="para1"></p>
<p class="code"><span class="font">Node 1</span></p>
<p class="code2"><span class="font">[Node 2 [Node 7 [], Node 8 []],</span></p>
<p class="code2"><span class="space-r"></span><span class="font">Node 3 [Node 9 [Node 10 [], Node 11 []]],</span></p>
<p class="code2"><span class="space-r"></span><span class="font">Node 4 [],</span></p>
<p class="code2"><span class="space-r"></span><span class="font">Node 5 [Node 6 []]]</span></p>
</div>
<p class="para">The function <span class="font">gtree</span> that produced these trees (coincidentally, also among a total of 13 different ways) was defined as follows:</p>
<div class="space1">
<p class="code"><span class="font">gtree :: Show a =&gt; GenTree a -&gt; Doc</span></p>
<p class="code"><span class="font">gtree (Node x [])</span></p>
<p class="code2"><span class="font">= text ("Node " ++ show x ++ " []")</span></p>
<p class="code"><a id="text/part0012.html.page_191" class="calibre3"></a><span class="font">gtree (Node x ts)</span></p>
<p class="code2"><span class="font">= text ("Node " ++ show x) &lt;&gt;</span></p>
<p class="code2"><span class="font">group (nest 2 (line &lt;&gt; bracket ts))</span></p>
</div>
<p class="para">The first clause says that a tree with no subtrees is always displayed on a single line; the second clause says that a tree with at least one subtree is displayed either on a single line or has its subtrees each displayed on a new line with an indentation of two units. The function <span class="font">bracket</span> is defined by</p>
<div class="space1">
<p class="code"><span class="font">bracket :: Show a =&gt; [GenTree a] -&gt; Doc</span></p>
<p class="code"><span class="font">bracket ts = text "[" &lt;&gt; nest 1 (gtrees ts) &lt;&gt; text "]"</span></p>
<p class="para1"></p>
<p class="code"><span class="font">gtrees [t] = gtree t</span></p>
<p class="code"><span class="font">gtrees (t:ts) = gtree t &lt;&gt; text "," &lt;&gt; line &lt;&gt; gtrees ts</span></p>
</div>
<p class="para">To be honest, it took a little time and experimentation to find the definitions above (for which the function <span class="font">layouts</span> proved indispensable), and the result is certainly not the only way to lay out trees. Finally, here is a way of laying out a piece of text (a string of characters containing spaces and newlines, not a document <span class="font">text</span>) as a single paragraph:</p>
<div class="space1">
<p class="code"><span class="font">para :: String -&gt; Doc</span></p>
<p class="code"><span class="font">para = cvt . map text . words</span></p>
<p class="para1"></p>
<p class="code"><span class="font">cvt [] = nil</span></p>
<p class="code"><span class="font">cvt (x:xs)</span></p>
<p class="code11"><span class="font">= x &lt;&gt; foldr (&lt;&gt;) nil [group (line &lt;&gt; x) | x &lt;- xs]</span></p>
</div>
<p class="para">First, the words of the text are computed using the standard library function <span class="font">words</span>, a function we have encountered a number of times before. Then each word is converted into a document using <span class="font">text</span>. Finally, each word, apart from the first, is laid out either on the same line or on a new line. If there are <i class="calibre1">n</i>+1 words in the text, and so <i class="calibre1">n</i> inter-word spaces, the code above describes 2<sup class="calibre8"><i class="calibre1">n</i></sup> possible layouts. We certainly don’t want to examine all these layouts in computing one that will fit within a given line width.</p>
<h3 class="h" id="text/part0012.html.head8-5">8.5 The best layout</h3>
<p class="para">As we said above, the best layout depends on the maximum permitted line width. That’s a simple decision, but not the only one. In general a pretty layout of a nested document will consist of a ribbon of text snaking across the page, and it is arguable <a id="text/part0012.html.page_192" class="calibre3"></a>that the width of the ribbon should also play a part in determining the best layout. After all, is the best layout on an infinitely wide page one in which everything is placed on one line? However, for simplicity we will ignore this very reasonable refinement and take only the line width as the deciding factor.</p>
<p class="para">There is also another decision to be made. Suppose we choose the best layout, according to some criterion, among those layouts all of whose lines fit within the given line width. That’s fine if there is at least one such layout, but what if there isn’t? The two options are either to abandon the formatting process with a suitable error message, or else to do the best we can, accepting that the width may be exceeded.</p>
<p class="para">Psychologically and practically the second option seems the better one, so let us explore what it entails. We can start by comparing the first lines, ℓ<sub class="calibre11">1</sub> and ℓ<sub class="calibre11">2</sub>, of two layouts. We can decide that line ℓ<sub class="calibre11">1</sub> is better than ℓ<sub class="calibre11">2</sub> if: (i) both lines fit into width <i class="calibre1">w</i> and ℓ<sub class="calibre11">1</sub> is longer than ℓ<sub class="calibre11">2</sub>; (ii) ℓ<sub class="calibre11">1</sub> fits <i class="calibre1">w</i> but ℓ<sub class="calibre11">2</sub> doesn’t; or (iii) neither fits <i class="calibre1">w</i> and ℓ<sub class="calibre11">1</sub> is shorter than ℓ<sub class="calibre11">2</sub>. The decision is a reasonable one because it should be capable of being implemented by a <i class="calibre1">greedy</i> strategy: fill up the first line as much as possible without exceeding the line width; and if that is not possible, stop as soon as the width is exceeded.</p>
<p class="para">The comparison test above doesn’t determine what should happen if the two lines have the same length. But it is a consequence of the fact that all layouts flatten to the same string that two first lines with the same length will be the <i class="calibre1">same</i> line. Consequently, the first line is fixed and the comparison can pass to the second pair of lines. And so on.</p>
<p class="para">The second property about decreasing shapes can be used to simplify the comparison test slightly because if layout <i class="calibre1">lx</i> precedes layout <i class="calibre1">ly</i> in the list of layouts, then the first line of <i class="calibre1">lx</i> is known to be at least as long as the first line of <i class="calibre1">ly</i>. And if the two lines are equally long, then the same statement is true of the second lines. And so on.</p>
<p class="para">Given our shallow embedding of documents, here is a simple implementation of the function <span class="font">pretty</span> that finds the best layout:</p>
<div class="space1">
<p class="code"><span class="font">pretty :: Int -&gt; Doc -&gt; Layout</span></p>
<p class="code"><span class="font">pretty w = fst . foldr1 choose . map augment</span></p>
<p class="code"><span class="space-r"></span><span class="font">where</span></p>
<p class="code"><span class="space-r"></span><span class="font">augment lx = (lx,shape lx)</span></p>
<p class="code"><span class="space-r"></span><span class="font">choose alx aly</span></p>
<p class="code"><span class="space-r"></span><span class="font">= if better (snd alx) (snd aly) then alx else aly</span></p>
<p class="code"><span class="space-r"></span><span class="font">better [] ks</span><span class="space8"></span><span class="space-r"></span><span class="font">= True</span></p>
<p class="code"><a id="text/part0012.html.page_193" class="calibre3"></a><span class="space-r"></span><span class="font">better js []</span><span class="space8"></span><span class="space-r"></span><span class="font">= False</span></p>
<p class="code"><span class="space-r"></span><span class="font">better (j:js) (k:ks) | j == k = better js ks</span></p>
<p class="code16"><span class="space-r"></span><span class="space-r"></span><span class="font">| otherwise = (j &lt;= w)</span></p>
</div>
<p class="para">Each layout is augmented with shape information to guide the choice of layout, which is then determined by a simple search. The test <span class="font">better</span> implements the comparison operation described above. Finally, shape information is discarded.</p>
<p class="para">This definition of <span class="font">pretty</span> is hopelessly inefficient because every layout is computed and examined. If there are <i class="calibre1">n</i> possible choices of whether to have a line break or not, there are 2<sup class="calibre8"><i class="calibre1">n</i></sup> layouts to be examined and pretty-printing will be very slow indeed. For example,</p>
<div class="space1">
<p class="code6"><span class="font">ghci&gt; putStrLn $ pretty 30 $ para pg</span></p>
<p class="code6"><span class="font">This is a fairly short</span></p>
<p class="code6"><span class="font">paragraph with just twenty-two</span></p>
<p class="code6"><span class="font">words. The problem is that</span></p>
<p class="code6"><span class="font">pretty-printing it takes time,</span></p>
<p class="code6"><span class="font">in fact 31.32 seconds.</span></p>
<p class="code6"><span class="font">(31.32 secs, 17650013284 bytes)</span></p>
</div>
<p class="para">Ouch! What is worse, pretty-printing a longer paragraph will cause GHCi to crash with an ‘out of memory’ message. An exponential time and space algorithm is not acceptable.</p>
<p class="para">What is wanted is an algorithm for <span class="font">pretty</span> that can decide on which first line to choose without looking ahead more than <i class="calibre1">w</i> characters. The algorithm should also be efficient, taking linear time in the size of the document being pretty-printed. Ideally the running time should be independent of <i class="calibre1">w</i>, but a running time that does depend on <i class="calibre1">w</i> is acceptable if a faster one means a much more complicated program.</p>
<h3 class="h" id="text/part0012.html.head8-6">8.6 A term representation</h3>
<p class="para">The problem with identifying a document with its list of possible layouts is that useful structure is lost. Rather than bring all the alternatives to the top level as a list, we really want to bury them as deep as possible. For example, consider the following two expressions for a document:</p>
<div class="space1">
<p class="code"><span class="font">A&lt;0&gt;B&lt;0&gt;D + A&lt;0&gt;B&lt;1&gt;D + A&lt;1&gt;C&lt;0&gt;E + A&lt;1&gt;C&lt;1&gt;E</span></p>
<p class="code"><span class="font">A(&lt;0&gt;B(&lt;0&gt;D + &lt;1&gt;D) + &lt;1&gt;C(&lt;0&gt;E + &lt;1&gt;E))</span></p>
</div>
<p class="para"><a id="text/part0012.html.page_194" class="calibre3"></a>As before, <span class="font">&lt;0&gt;</span> denotes a single space and <span class="font">&lt;1&gt;</span> a single line break. The five letters denote five nonempty texts. Since all four alternatives have to flatten to the same document, we require that <span class="font">B&lt;0&gt;D = C&lt;0&gt;E</span>. In the first expression (which is essentially what is given by representing a document by its list of layouts) we have four layouts to compare. In the second expression we can shortcut some of the comparisons. For example, if we know that the common prefix <span class="font">A</span> cannot fit in the given width, the first two layouts can be thrown away without further comparisons. Even better, if we choose between alternatives from the innermost to the outermost, we can base the comparison test on just the first lines of layouts. For instance, if we choose the better of <span class="font">C&lt;0&gt;E</span> and <span class="font">C&lt;1&gt;E</span> first, then that choice is not changed by subsequent choices.</p>
<p class="para">The way to maintain the structure of documents is to represent a document as a tree:</p>
<div class="space1">
<p class="code"><span class="font">data Doc = Nil</span></p>
<p class="code1"><span class="space-r"></span><span class="font">| Line</span></p>
<p class="code1"><span class="space-r"></span><span class="font">| Text String</span></p>
<p class="code1"><span class="space-r"></span><span class="font">| Nest Int Doc</span></p>
<p class="code1"><span class="space-r"></span><span class="font">| Group Doc</span></p>
<p class="code1"><span class="space-r"></span><span class="font">| Doc :&lt;&gt;: Doc</span></p>
</div>
<p class="para">Note the use of an infix constructor in the last line. Haskell allows infix operators as constructors, but they have to begin with a colon. They do not have to end with a colon as well, but it seems more attractive if they do. This tree is called an <i class="calibre1">abstract syntax tree</i>; each operation of the library is represented by its own constructor. An implementation in terms of abstract syntax trees is known as a <i class="calibre1">deep embedding</i>.</p>
<p class="para">We will <i class="calibre1">not</i> provide the user with the details of the data type <span class="font">Doc</span>, just its name. To explain why not, it is useful to insert a short digression about Haskell data types. In Haskell the effect of a <span class="font">data</span> declaration is to introduce a new data type by describing how its values are constructed. Each value is named by an expression built only from the constructors of the data type, in other words a <i class="calibre1">term</i>. Moreover, different terms denote different values (provided there are no strictness flags). We can define functions on the data type by pattern matching on the constructors. There is therefore no need to state what the operations on the data type are – we can just define them. Types in which the values are described, but the operations are not, are called <i class="calibre1">concrete</i> types.</p>
<p class="para">The situation is exactly the reverse with <i class="calibre1">abstract</i> data types. Here the operations are named, but not how the values are constructed, at least not publicly. For example, <span class="font">Float</span> is an abstract data type; we are given the names of the primitive arithmetic <a id="text/part0012.html.page_195" class="calibre3"></a>and comparison operations, and also a way of displaying floating-point numbers, but it is not stated how such numbers are actually represented. We cannot define functions on these numbers by pattern matching, but only in terms of the given operations. What can and should be stated publicly are intended meanings and the algebraic properties of the operations. However, Haskell provides no means for such descriptions beyond informal comments.</p>
<p class="para">As it stands, <span class="font">Doc</span> is a concrete type. But in our understanding of this type, different terms do not denote different values. For instance, we intend each constructor to be a replacement for the corresponding operation. Thus</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">nil</span></td>
<td class="calibre14"><span class="font">= Nil</span></td>
</tr><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">line</span></td>
<td class="calibre14"><span class="font">= Line</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">text s</span></td>
<td class="calibre14"><span class="font">= Text s</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">nest i x</span></td>
<td class="calibre14"><span class="font">= Nest i x</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">group x</span></td>
<td class="calibre14"><span class="font">= Group x</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">x &lt;&gt; y</span></td>
<td class="calibre14"><span class="font">= x :&lt;&gt;: y</span></td>
</tr>
</tbody></table>
<p class="para">We also want to keep the algebraic properties of these operations, so equations such as</p>
<div class="space1">
<p class="code"><span class="font">(x :&lt;&gt;: y) :&lt;&gt;: z = x :&lt;&gt;: (y :&lt;&gt;: z)</span></p>
<p class="code"><span class="font">Nest i (Nest j x) = Nest (i+j) x</span></p>
</div>
<p class="para">should hold. But of course they do not. The solution is to use the module structure to hide the constructors of <span class="font">Doc</span> from the user and insist only that the laws are ‘observably’ true. For instance we require</p>
<p class="code"><span class="font">layouts ((x :&lt;&gt;: y) :&lt;&gt;: z) = layouts (x :&lt;&gt;: (y :&lt;&gt;: z))</span></p>
<p class="para">The only way we can observe documents is through <span class="font">layouts</span>; from the user’s point of view if two documents produce the same layouts, then they are essentially the same document.</p>
<p class="para">Let’s get back to programming. Here is one definition of <span class="font">layouts</span>. It is just the laws of <span class="font">layouts</span> that we saw earlier, but now expressed as a proper Haskell definition:</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">layouts :: Doc -&gt; [Layout]</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">layouts (x :&lt;&gt;: y)</span></td>
<td class="calibre14"><span class="font">= layouts x &lt;++&gt; layouts y</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">layouts Nil</span></td>
<td class="calibre14"><span class="font">= [""]</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">layouts Line</span></td>
<td class="calibre14"><span class="font">= ["\n"]</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">layouts (Text s)</span></td>
<td class="calibre14"><span class="font">= [s]</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">layouts (Nest i x)</span></td>
<td class="calibre14"><span class="font">= map (nestl i) (layouts x)</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">layouts (Group x)</span></td>
<td class="calibre14"><span class="font">= layouts (flatten x) ++ layouts x</span></td>
</tr>
</tbody></table>
<p class="para"><a id="text/part0012.html.page_196" class="calibre3"></a>The function <span class="font">flatten</span> is similarly defined by</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">flatten :: Doc -&gt; Doc</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">flatten (x :&lt;&gt;: y)</span></td>
<td class="calibre14"><span class="font">= flatten x :&lt;&gt;: flatten y</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">flatten Nil</span></td>
<td class="calibre14"><span class="font">= Nil</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">flatten Line</span></td>
<td class="calibre14"><span class="font">= Text " "</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">flatten (Text s)</span></td>
<td class="calibre14"><span class="font">= Text s</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">flatten (Nest i x)</span></td>
<td class="calibre14"><span class="font">= flatten x</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">flatten (Group x)</span></td>
<td class="calibre14"><span class="font">= flatten x</span></td>
</tr>
</tbody></table>
<p class="para">With these definitions, our 24 laws are either true by definition, or are observably true in the sense above.</p>
<p class="para">The definition of <span class="font">layouts</span> is simple enough, but it is unnecessarily inefficient. There are two separate reasons why this is so. First, consider the function <span class="font">egotist</span> defined by</p>
<div class="space1">
<p class="code"><span class="font">egotist :: Int -&gt; Doc</span></p>
<p class="code"><span class="font">egotist n | n==0 = nil</span></p>
<p class="code10"><span class="font">| otherwise = egotist (n-1) &lt;&gt; text "me"</span></p>
</div>
<p class="para">The document <span class="font">egotist n</span> is a very boring one, and its sole layout consists of a string of <span class="font">n</span> repetitions of <span class="font">me</span>. By the way, we could have expressed the definition using <span class="font">Nil</span>, <span class="font">(:&lt;&gt;:)</span> and <span class="font">Text</span> but, as we have said, we are not going to make these constructors public. As it stands, the definition of <span class="font">egotist</span> could have been made by a user of the library. Anyway, back to the main point, which is that the association of the <span class="font">(&lt;&gt;)</span> operations is to the left, and it takes Θ(<i class="calibre1">n</i><sup class="calibre8"><sub class="calibre19">2</sub></sup>) steps to compute its layout(s). The <span class="font">(++)</span> operations pile up to the left. The situation is entirely analogous to the fact that <span class="font">concat</span> defined in terms of <span class="font">foldl</span> is an order of magnitude less efficient than one defined in terms of <span class="font">foldr</span>.</p>
<p class="para">The second source of inefficiency concerns nesting. For example, consider the function <span class="font">egoist</span> defined by</p>
<div class="space1">
<p class="code"><span class="font">egoist :: Int -&gt; Doc</span></p>
<p class="code"><span class="font">egoist n | n==0 = nil</span></p>
<p class="code1"><span class="space-r"></span><span class="font">| otherwise = nest 1 (text "me" &lt;&gt; egoist (n-1))</span></p>
</div>
<p class="para">There are no line breaks in sight, so <span class="font">egoist n</span> describes the same boring document as <span class="font">egotist n</span>. But although the concatenation associates to the right, it still takes quadratic time to construct the layout. Each nesting operation is carried out by running through the entire document. Try it and see.</p>
<p class="para"><a id="text/part0012.html.page_197" class="calibre3"></a>The way to solve the first problem is to delay concatenation, representing a concatenated document by a list of its component documents. The way to solve the second problem is to delay nesting, representing a nested document by a pair consisting of an indentation to be applied only when necessary and the document it is to be applied to. Combining both solutions, we represent a document by a list of indentation-document pairs. Specifically, consider the function <span class="font">toDoc</span> defined by</p>
<div class="space1">
<p class="code"><span class="font">toDoc :: [(Int,Doc)] -&gt; Doc</span></p>
<p class="code"><span class="font">toDoc ids = foldr (:&lt;&gt;:) Nil [Nest i x | (i,x) &lt;- ids]</span></p>
</div>
<p class="para">We can now calculate a definition of a function <span class="font">layr</span> such that</p>
<p class="code"><span class="font">layr = layouts . toDoc</span></p>
<p class="para">and then define a new version of <span class="font">layouts</span> based on <span class="font">layr</span>. We leave the details as an exercise, but here is the result:</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="space5"></span><span class="font">layouts x = layr [(0,x)]</span></td>
<td class="calibre14"></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="space5"></span><span class="font">layr []</span></td>
<td class="calibre14"><span class="font">= [""]</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="space5"></span><span class="font">layr ((i,x :&lt;&gt;: y):ids)</span></td>
<td class="calibre14"><span class="font">= layr ((i,x):(i,y):ids)</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="space5"></span><span class="font">layr ((i,Nil):ids)</span></td>
<td class="calibre14"><span class="font">= layr ids</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="space5"></span><span class="font">layr ((i,Line):ids)</span></td>
<td class="calibre14"><span class="font">= ['\n':replicate i ' ' ++ ls</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space"></span><span class="space5"></span></td>
<td class="calibre14"><span class="space"></span><span class="font">| ls &lt;- layr ids]</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space2"></span><span class="font">layr ((i,Text s):ids)</span></td>
<td class="calibre14"><span class="font">= [s ++ ls | ls &lt;- layr ids]</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space2"></span><span class="font">layr ((i,Nest j x):ids)</span></td>
<td class="calibre14"><span class="font">= layr ((i+j,x):ids)</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space2"></span><span class="font">layr ((i,Group x):ids)</span></td>
<td class="calibre14"><span class="font">= layr ((i,flatten x):ids) ++</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"></td>
<td class="calibre14"><span class="space"></span><span class="font">layr ((i,x):ids)</span></td>
</tr>
</tbody></table>
<p class="para">This definition takes linear time for each layout. Exactly the same template is used for the function <span class="font">pretty</span>, which chooses a single best layout:</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">pretty w x = best w [(0,x)]</span></td>
<td class="calibre14"></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="space-r"></span><span class="font">where</span></td>
<td class="calibre14"></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="space-r"></span><span class="font">best r []</span></td>
<td class="calibre14"><span class="font">= ""</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="space-r"></span><span class="font">best r ((i,x :&lt;&gt;: y):ids)</span></td>
<td class="calibre14"><span class="font">= best r ((i,x):(i,y):ids)</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="space-r"></span><span class="font">best r ((i,Nil):ids)</span></td>
<td class="calibre14"><span class="font">= best r ids</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="space-r"></span><span class="font">best r ((i,Line):ids)</span></td>
<td class="calibre14"><span class="font">= '\n':replicate i ' ' ++</span></td>
</tr>
<tr class="calibre13"><td class="calibre14"></td><td class="calibre14"><span class="space5"></span><span class="font">best (w-i) ids</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="space-r"></span><span class="font">best r ((i,Text s):ids)</span></td>
<td class="calibre14"><span class="font">= s ++ best (r-length s) ids</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="space-r"></span><span class="font">best r ((i,Nest j x):ids)</span></td>
<td class="calibre14"><span class="font">= best r ((i+j,x):ids)</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="space-r"></span><span class="font">best r ((i,Group x):ids)</span></td>
<td class="calibre14"><span class="font">= better r</span></td>
</tr>
<tr class="calibre13"><td class="calibre14"></td><td class="calibre14"><span class="space5"></span><span class="font">(best r ((i,flatten x):ids))</span></td>
</tr>
<tr class="calibre13"><td class="calibre14"></td><td class="calibre14"><span class="space5"></span><span class="font">(best r ((i,x):ids))</span></td>
</tr>
</tbody></table>
<p class="para"><a id="text/part0012.html.page_198" class="calibre3"></a>The first argument of <span class="font">best</span> is the remaining space available on the current line. This function is made local to the definition of <span class="font">pretty</span> to avoid having to carry around the maximum line width <span class="font">w</span> as an additional argument.</p>
<p class="para">That leaves us with the problem of computing <span class="font">better r lx ly</span>. Here we can make use of the fact that the first line of <span class="font">lx</span> is guaranteed to be at least as long as the first line of <span class="font">ly</span>. Thus it suffices to compare the length of the first line of <span class="font">lx</span> with <span class="font">r</span>. If the former fits within the latter, we choose <span class="font">lx</span>; otherwise we choose <span class="font">ly</span>. We therefore define</p>
<p class="code"><span class="font">better r lx ly = if fits r lx then lx else ly</span></p>
<p class="para">But we don’t want to compute the length of the whole of the first line of <span class="font">lx</span> since that looks ahead too far. Instead, we take a more miserly approach:</p>
<div class="space1">
<p class="code"><span class="font">fits r _ | r&lt;0</span><span class="space4"></span><span class="font">= False</span></p>
<p class="code"><span class="font">fits r []</span><span class="space3"></span><span class="font">= True</span></p>
<p class="code"><span class="font">fits r (c:cs)</span><span class="space4"></span><span class="space-r"></span><span class="font">= if c == '\n' then True</span></p>
<p class="code16"><span class="space"></span><span class="font">else fits (r-1) cs</span></p>
</div>
<p class="para">For exactly the same reason it is essential that the second and third arguments to <span class="font">better</span> are computed lazily, that is, the two layouts are evaluated just enough to determine which is the better one, and no further.</p>
<p class="para">Let’s revisit our troublesome paragraph:</p>
<p class="code6"><span class="font">ghci&gt; putStrLn $ pretty 30 $ para pg</span></p>
<p class="code6"><span class="font">This is a fairly short</span></p>
<p class="code6"><span class="font">paragraph with just twenty-two</span></p>
<p class="code6"><span class="font">words. The problem is that</span></p>
<p class="code6"><span class="font">pretty-printing it takes time,</span></p>
<p class="code6"><span class="font">in fact 31.32 seconds.</span></p>
<p class="code6"><span class="font">(0.00 secs, 1602992 bytes)</span></p>
<p class="para">Much better. Exercise L discusses what we can say about the running time of <span class="font">pretty</span>.</p>
<p class="para">The final task is to put our small library together as a module. Here is the main declaration:</p>
<div class="space1">
<p class="code"><span class="font">module Pretty</span></p>
<p class="code2"><span class="font">(Doc, Layout,</span></p>
<p class="code2"><span class="font">nil, line, text,</span></p>
<p class="code2"><span class="font">nest, (&lt;&gt;), group,</span></p>
<p class="code2"><span class="font">layouts, pretty, layout) where</span></p>
</div>
<p class="para"><a id="text/part0012.html.page_199" class="calibre3"></a>The module name is <span class="font">Pretty</span> and the file containing the above declaration and the definitions of the library functions has to be saved in a file called <span class="font">Pretty.lhs</span>.</p>
<p class="para">The module exports 11 entities. Firstly, there is the name <span class="font">Doc</span> of the abstract type of documents. The constructors of this type are not exported. (By the way, if we did want to export all the constructors we can write <span class="font">Doc ()</span> in the export list, and if we wanted just, say, <span class="font">Nil</span> and <span class="font">Text</span>, we can write <span class="font">Doc (Nil, Text)</span>.) Secondly, there is the name <span class="font">Layout</span> which is just a synonym for <span class="font">String</span>. The next eight constants and functions are the ones we have defined above. The final function <span class="font">layout</span> is used for printing a layout:</p>
<div class="space1">
<p class="code"><span class="font">layout :: Layout -&gt; IO ()</span></p>
<p class="code"><span class="font">layout = putStrLn</span></p>
</div>
<p class="para">And that’s it. Of course, in a really useful library a number of additional combinators could be provided. For example, we could provide</p>
<div class="space1">
<p class="code"><span class="font">(&lt;+&gt;),(&lt;|&gt;) :: Doc -&gt; Doc -&gt; Doc</span></p>
<p class="code"><span class="font">x &lt;+&gt; y = x &lt;&gt; text " " &lt;&gt; y</span></p>
<p class="code"><span class="font">x &lt;|&gt; y = x &lt;&gt; line &lt;&gt; y</span></p>
<p class="para1"></p>
<p class="code"><span class="font">spread,stack :: [Doc] -&gt; Doc</span></p>
<p class="code"><span class="font">spread = foldr (&lt;+&gt;) nil</span></p>
<p class="code"><span class="font">stack = foldr (&lt;|&gt;) nil</span></p>
</div>
<p class="para">No doubt the reader can think of many others.</p>
<h3 class="h" id="text/part0012.html.head8-7">8.7 Exercises</h3>
<p class="theorem"><b class="calibre7">Exercise A</b></p>
<p class="para">A picky user of the library wants just three layouts for a certain document:</p>
<div class="space1">
<p class="code"><span class="font">A B C</span><span class="space3"></span><span class="font">A B</span><span class="space4"></span><span class="font">A</span></p>
<p class="code4"><span class="font">C B</span><span class="space4"></span><span class="font">C</span></p>
</div>
<p class="para">Can the user do it with the given functions?</p>
<p class="theorem"><b class="calibre7">Exercise B</b></p>
<p class="para">The layouts of a document are given as a list. But are they all different? Either prove that they are or give a counterexample.</p>
<p class="para"><a id="text/part0012.html.page_200" class="calibre3"></a>By the way, is it obvious from the laws that each document has a nonempty set of layouts?</p>
<p class="theorem"><b class="calibre7">Exercise C</b></p>
<p class="para">The next four exercises refer to the shallow embedding of <a href="#text/part0012.html.head8-3" class="calibre3">Section 8.3</a>. Prove, by equational reasoning, that</p>
<p class="code"><span class="font">nest i . nest j = nest (i + j)</span></p>
<p class="para">You will need a subsidiary result about <span class="font">nestl</span>, which you don’t have to prove.</p>
<p class="theorem"><b class="calibre7">Exercise D</b></p>
<p class="para">Continuing on from the previous question, prove that</p>
<p class="code"><span class="font">nest i (group x) = group (nest i x)</span></p>
<p class="para">by equational reasoning (at the point level). Again, you will need a subsidiary result.</p>
<p class="theorem"><b class="calibre7">Exercise E</b></p>
<p class="para">Continuing on, prove that <span class="font">flatten . group = flatten</span>. You will need a subsidiary result.</p>
<p class="theorem"><b class="calibre7">Exercise F</b></p>
<p class="para">The final law is <span class="font">flatten . nest i = flatten</span>. And, yes, you will need yet another subsidiary result.</p>
<p class="theorem"><b class="calibre7">Exercise G</b></p>
<p class="para">We said in the text that the prelude function <span class="font">lines</span> breaks up a string on newline characters. In fact, <span class="font">lines</span> treats a newline as a terminator character, so both <span class="font">lines "hello"</span> and <span class="font">lines "hello\n"</span> return the same result. It is arguable that a better definition treats newlines as <i class="calibre1">separator</i> characters, so there is always one more line than there are newlines. Define a function <span class="font">lines</span> that has this behaviour. We will need the new definition below.</p>
<p class="para">Now, the proof that <span class="font">map shape</span> applied to the layouts of a document returns a lexicographically decreasing sequence of list of integers can be structured into the following steps. First, define</p>
<div class="space1">
<p class="code"><span class="font">msl</span><span class="space5"></span><span class="font">= map shape . layouts</span></p>
<p class="code"><span class="font">shape = map length . lines</span></p>
</div>
<p class="para"><a id="text/part0012.html.page_201" class="calibre3"></a>where <span class="font">lines</span> refers to the revised version above. We have to prove that <span class="font">msl</span> returns a decreasing sequence on every document. To this end, we can define functions <span class="font">nesty</span> and <span class="font">groupy</span> so that</p>
<div class="space1">
<p class="code"><span class="font">nesty i . msl = msl . nest i</span></p>
<p class="code"><span class="font">groupy . msl = msl . group</span></p>
</div>
<p class="para">and an operation <span class="font">&lt;+&gt;</span> so that</p>
<p class="code"><span class="font">msl x &lt;+&gt; msl y = msl (x &lt;&gt; y)</span></p>
<p class="para">(It is this equation that requires the revised definition of <span class="font">lines</span>.) The proof is then completed by showing that if <span class="font">xs</span> and <span class="font">ys</span> are decreasing, then so are <span class="font">nesty i xs</span> and <span class="font">groupy xs</span> and <span class="font">xs &lt;+&gt; ys</span>. All this exercise asks though is that you construct definitions of <span class="font">nesty</span>, <span class="font">groupy</span> and <span class="font">&lt;+&gt;</span>.</p>
<p class="theorem"><b class="calibre7">Exercise H</b></p>
<p class="para">Write a function <span class="font">doc :: Doc -&gt; Doc</span> that describes how to lay out elements of <span class="font">Doc</span> where <span class="font">Doc</span> is the abstract syntax tree representation in <a href="#text/part0012.html.head8-6" class="calibre3">Section 8.6</a>.</p>
<p class="theorem"><b class="calibre7">Exercise I</b></p>
<p class="para">Consider a function <span class="font">prettybad</span> that chooses a best layout from the list <span class="font">layouts</span> by taking the first layout all of whose lines fit within the given width, and the last layout if this is not possible. Does <span class="font">prettybad</span> always compute the same layout as <span class="font">pretty</span>? (Hint: think about paragraphs.)</p>
<p class="theorem"><b class="calibre7">Exercise J</b></p>
<p class="para">Using the algebraic properties of the constructors of <span class="font">Doc</span>, calculate the efficient version of <span class="font">layouts</span>.</p>
<p class="theorem"><b class="calibre7">Exercise K</b></p>
<p class="para">We have designed <span class="font">pretty w</span> to be <i class="calibre1">optimal</i>, meaning that it chooses line breaks to avoid overflowing lines if at all possible. We also have that <span class="font">pretty w</span> is <i class="calibre1">bounded</i>, meaning that it can make the choice about the next line break without looking at more than the next <span class="font">w</span> characters of the input. Given that, what do you expect GHCi’s response would be to the commands</p>
<div class="space1">
<p class="code"><span class="font">layout $ pretty 5 $ para pg</span></p>
<p class="code"><span class="font">layout $ pretty 10 $ cexpr ce</span></p>
</div>
<p class="para">where</p>
<div class="space1">
<p class="code"><a id="text/part0012.html.page_202" class="calibre3"></a><span class="font">pg = "Hello World!" ++ undefined</span></p>
<p class="code"><span class="font">ce = If "happy" (Expr "great") undefined</span></p>
</div>
<p class="theorem"><b class="calibre7">Exercise L</b></p>
<p class="para">We cannot relate the cost of <span class="font">pretty w x</span> to the size of <span class="font">x</span> without saying what the size of a document is. Here is a reasonable measure:</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">size :: Doc -&gt; Int</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">size Nil</span></td>
<td class="calibre14"><span class="font">= 1</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">size Line</span></td>
<td class="calibre14"><span class="font">= 1</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">size (Text s)</span></td>
<td class="calibre14"><span class="font">= 1</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">size (Nest i x)</span></td>
<td class="calibre14"><span class="font">= 1 + size x</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">size (x :&lt;&gt;: y)</span></td>
<td class="calibre14"><span class="font">= 1 + size x + size y</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">size (Group x)</span></td>
<td class="calibre14"><span class="font">= 1 + size x</span></td>
</tr>
</tbody></table>
<p class="para">Under this definition both the documents</p>
<div class="space1">
<p class="code"><span class="font">nest 20 (line &lt;&gt; text "!")</span></p>
<p class="code"><span class="font">nest 40 (line &lt;&gt; text "!")</span></p>
</div>
<p class="para">have size two. But it takes twice as long to produce the second layout, so the cost of <span class="font">pretty</span> cannot be linear in the document size.</p>
<p class="para">Instead of having <span class="font">pretty</span> produce the final layout, a string, we can interpose an additional data type of layouts:</p>
<div class="space1">
<p class="code"><span class="font">data Layout = Empty</span></p>
<p class="code12"><span class="font">| String String Layout</span></p>
<p class="code12"><span class="font">| Break Int Layout</span></p>
</div>
<p class="para">and define <span class="font">layout :: Layout -&gt; String</span> by</p>
<div class="space1">
<p class="code"><span class="font">layout Empty</span><span class="space2"></span><span class="space"></span><span class="font">= ""</span></p>
<p class="code"><span class="font">layout (String s x) = s ++ layout x</span></p>
<p class="code"><span class="font">layout (Break i x)</span><span class="space"></span><span class="space-r1"></span><span class="font">= '\n':replicate i ' ' ++ layout x</span></p>
</div>
<p class="para">We have</p>
<p class="code"><span class="font">pretty w = layout . prettyl w</span></p>
<p class="para">where the new function <span class="font">prettyl</span> produces a <span class="font">Layout</span> rather than a string. Define <span class="font">prettyl</span>.</p>
<p class="para">A fairer question to ask is whether <span class="font">prettyl w x</span> takes linear time in the size of <span class="font">x</span>. Does it?</p>
<h3 class="h" id="text/part0012.html.head8-8"><a id="text/part0012.html.page_203" class="calibre6"></a>8.8 Answers</h3>
<p class="theorem"><b class="calibre7">Answer to Exercise A</b></p>
<p class="para">No. There is no way of allowing both <span class="font">A&lt;0&gt;B&lt;1&gt;C</span> and <span class="font">A&lt;1&gt;B&lt;0&gt;C</span> without also having both of <span class="font">A&lt;0&gt;B&lt;0&gt;C</span> and <span class="font">A&lt;1&gt;B&lt;1&gt;C</span>. These four are given by the expression</p>
<p class="code"><span class="font">group (A &lt;&gt; line &lt;&gt; B) &lt;&gt; group (line &lt;&gt; C)</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise B</b></p>
<p class="para">The layouts of a document are not necessarily all different. For example</p>
<p class="code"><span class="font">layouts (group (text "hello")) = ["hello","hello"]</span></p>
<p class="para">Yes, it is obvious that each document has a nonempty set of layouts. Look at the laws of <span class="font">layouts</span>. The basic documents have a nonempty list of layouts and this property is preserved by the other operations.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise C</b></p>
<p class="para">The calculation is:</p>
<div class="space1">
<p class="code1"><span class="font">nest i . nest j</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">nest</span>}</p>
<p class="code1"><span class="font">map (nestl i) . map (nestl j)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{functor law of <span class="font">map</span>}</p>
<p class="code1"><span class="font">map (nestl i . nestl j)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{claim}</p>
<p class="code1"><span class="font">map (nestl (i+j))</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">nest</span>}</p>
<p class="code1"><span class="font">nest (i+j)</span></p>
</div>
<p class="para">The claim is that <span class="font">nestl i . nestl j = nestl (i+j)</span>, which follows – after a short calculation – from</p>
<p class="code"><span class="font">indent (i+j) = concat . map (indent i) . indent j</span></p>
<p class="para">We omit the proof.</p>
<p class="theorem"><a id="text/part0012.html.page_204" class="calibre3"></a><b class="calibre7">Answer to Exercise D</b></p>
<p class="para">We reason:</p>
<div class="space1">
<p class="code1"><span class="font">nest i (group x)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">group</span>}</p>
<p class="code1"><span class="font">nest i (flatten x ++ x)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{since <span class="font">nest i = map (nestl i)</span>}</p>
<p class="code1"><span class="font">nest i (flatten x) ++ nest i x</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{claim}</p>
<p class="code1"><span class="font">flatten (nest i x) ++ nest i x</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">group</span>}</p>
<p class="code1"><span class="font">group (nest i x)</span></p>
</div>
<p class="para">The claim follows from</p>
<div class="space1">
<p class="code3"><span class="font">nest i . flatten</span></p>
<p class="code8"><span class="font">=</span><span class="space5"></span>{since there are no newlines in <span class="font">flatten x</span>}</p>
<p class="code3"><span class="font">flatten</span></p>
<p class="code8"><span class="font">=</span><span class="space5"></span>{since <span class="font">flatten . nest i = flatten</span> (Exercise F)}</p>
<p class="code3"><span class="font">flatten . nest i</span></p>
</div>
<p class="theorem"><b class="calibre7">Answer to Exercise E</b></p>
<p class="para">We reason:</p>
<div class="space1">
<p class="code1"><span class="font">flatten . group</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">flatten</span> and <span class="font">group</span>}</p>
<p class="code1"><span class="font">one . flattenl . flattenl . head</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{claim}</p>
<p class="code1"><span class="font">one . flattenl . head</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">flatten</span>}</p>
<p class="code1"><span class="font">flatten</span></p>
</div>
<p class="para">The claim is that <span class="font">flattenl</span> is <i class="calibre1">idempotent</i>:</p>
<p class="code"><span class="font">flattenl . flattenl = flattenl</span></p>
<p class="para">This follows because <span class="font">flattenl</span> returns a layout with no newlines.</p>
<p class="para"><a id="text/part0012.html.page_205" class="calibre3"></a>By the way, it is the idempotence of <span class="font">flattenl</span> that ensures all layouts of a document flatten to the same string. The only function that introduces multiple layouts is <span class="font">group</span>, whose definition is</p>
<p class="code"><span class="font">group x = flatten x ++ x</span></p>
<p class="para">We have therefore to show that flattening the first element of this list gives the same string as flattening the second element. Thus we need to show</p>
<p class="code"><span class="font">flattenl . head . flatten = flattenl . head</span></p>
<p class="para">This follows at once from the definition of <span class="font">flatten</span> and the idempotence of the function <span class="font">flattenl</span>.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise F</b></p>
<p class="para">We reason:</p>
<div class="space1">
<p class="code1"><span class="font">flatten . nest i</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definitions}</p>
<p class="code1"><span class="font">one . flattenl . head . map (nestl i)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{since <span class="font">head . map f = f . head</span>}</p>
<p class="code1"><span class="font">one . flattenl . nestl i . head</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{claim}</p>
<p class="code1"><span class="font">one . flattenl . head</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">flatten</span>}</p>
<p class="code1"><span class="font">flatten</span></p>
</div>
<p class="para">The claim is that <span class="font">flattenl . nestl i = flattenl</span>.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise G</b></p>
<p class="para">We can define</p>
<div class="space1">
<p class="code"><span class="font">lines xs = if null zs then [ys]</span></p>
<p class="code12"><span class="font">else ys:lines (tail zs)</span></p>
<p class="code12"><span class="font">where (ys,zs) = break (=='\n') xs</span></p>
</div>
<p class="para">The function <span class="font">groupy</span> is defined by</p>
<div class="space1">
<p class="code"><span class="font">groupy :: [[Int]] -&gt; [[Int]]</span></p>
<p class="code"><span class="font">groupy (xs:xss) = [sum xs + length xs - 1]:xs:xss</span></p>
</div>
<p class="para">The function <span class="font">nesty</span> is defined by</p>
<div class="space1">
<p class="code"><a id="text/part0012.html.page_206" class="calibre3"></a><span class="font">nesty :: :: Int -&gt; [[Int]] -&gt; [[Int]]</span></p>
<p class="code"><span class="font">nesty i = map (add i)</span></p>
<p class="code10"><span class="font">where add i (x:xs) = x:[i+x | x &lt;- xs]</span></p>
</div>
<p class="para">The function <span class="font">(&lt;+&gt;)</span> is defined by</p>
<div class="space1">
<p class="code"><span class="font">(&lt;+&gt;) :: [[Int]] -&gt; [[Int]] -&gt; [[Int]]</span></p>
<p class="code"><span class="font">xss &lt;+&gt; yss = [glue xs ys | xs &lt;- xss, ys &lt;- yss]</span></p>
<p class="code"><span class="space-r"></span><span class="font">where glue xs ys = init xs ++ [last xs + head ys] ++</span></p>
<p class="code16"><span class="font">tail ys</span></p>
</div>
<p class="theorem"><b class="calibre7">Answer to Exercise H</b></p>
<p class="para">One possibility, which no doubt can be improved on:</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">doc :: Doc -&gt; Doc</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">doc Nil</span></td>
<td class="calibre14"><span class="font">= text "Nil"</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">doc Line</span></td>
<td class="calibre14"><span class="font">= text "Line"</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">doc (Text s)</span></td>
<td class="calibre14"><span class="font">= text ("Text " ++ show s)</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">doc (Nest i x)</span></td>
<td class="calibre14"><span class="font">= text ("Nest " ++ show i) &lt;&gt;</span></td>
</tr>
<tr class="calibre13"><td class="calibre14"></td><td class="calibre14"><span class="space"></span><span class="font">group (nest 2 (line &lt;&gt; paren (doc x)))</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">doc (x :&lt;&gt;: y)</span></td>
<td class="calibre14"><span class="font">= doc x &lt;&gt; text " :&lt;&gt;:" &lt;&gt;</span></td>
</tr>
<tr class="calibre13"><td class="calibre14"></td><td class="calibre14"><span class="space"></span><span class="font">group (line &lt;&gt; nest 3 (doc y))</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">doc (Group x)</span></td>
<td class="calibre14"><span class="font">= text "Group " &lt;&gt;</span></td>
</tr>
<tr class="calibre13"><td class="calibre14"></td><td class="calibre14"><span class="space"></span><span class="font">group (nest 2 (line &lt;&gt; paren (doc x)))</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">paren x</span></td>
<td class="calibre14"><span class="font">= text "(" &lt;&gt; nest 1 x &lt;&gt; text ")"</span></td>
</tr>
</tbody></table>
<p class="theorem"><b class="calibre7">Answer to Exercise I</b></p>
<p class="para">No. Consider a paragraph whose longest word is one character longer than the line width. In this case, <span class="font">prettybad</span> will lay out each word on a single line, while <span class="font">pretty</span> will still fill lines with groups of words provided they fit. For example:</p>
<p class="code6"><span class="font">ghci&gt; putStrLn $ pretty 11 $ para pg4</span></p>
<p class="code6"><span class="font">A lost and</span></p>
<p class="code6"><span class="font">lonely</span></p>
<p class="code6"><span class="font">hippopotamus</span></p>
<p class="code6"><span class="font">went into a</span></p>
<p class="code6"><span class="font">bar.</span></p>
<p class="theorem"><a id="text/part0012.html.page_207" class="calibre3"></a><b class="calibre7">Answer to Exercise J</b></p>
<p class="para">First we show <span class="font">layouts x = layr [(0,x)]</span>:</p>
<div class="space1">
<p class="code1"><span class="font">layr [(0,x)]</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">layr</span>}</p>
<p class="code1"><span class="font">layouts (toDoc [(0,x)])</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">toDoc</span>}</p>
<p class="code1"><span class="font">layouts (Nest 0 x :&lt;&gt;: Nil)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{laws of <span class="font">Doc</span>}</p>
<p class="code1"><span class="font">layouts x</span></p>
</div>
<p class="para">It remains to give a recursive definition of <span class="font">layr</span>. We will just give two clauses:</p>
<div class="space1">
<p class="code1"><span class="font">toDoc ((i,Nest j x):ids)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">toDoc</span>}</p>
<p class="code1"><span class="font">Nest i (Nest j x) :&lt;&gt;: toDoc ids</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{laws}</p>
<p class="code1"><span class="font">Nest (i+j) x :&lt;&gt;: toDoc ids</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">toDoc</span>}</p>
<p class="code1"><span class="font">toDoc ((i+j x):ids)</span></p>
</div>
<p class="para">Hence <span class="font">layr ((i,Nest j x):ids) = layr ((i+j x):ids)</span>. Next:</p>
<div class="space1">
<p class="code1"><span class="font">toDoc ((i,x:&lt;&gt;:y):ids)</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">toDoc</span>}</p>
<p class="code1"><span class="font">Nest i (x :&lt;&gt;: y) &lt;&gt; toDoc ids</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{laws}</p>
<p class="code1"><span class="font">Nest i x :&lt;&gt;: Nest i y :&lt;&gt;: toDoc ids</span></p>
<p class="code3"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">toDoc</span>}</p>
<p class="code1"><span class="font">toDoc ((i,x):(i,y):ids)</span></p>
</div>
<p class="para">Hence <span class="font">layr ((i,x:&lt;&gt;:y):ids) = layr ((i,x):(i,y):ids)</span>.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise K</b></p>
<p class="code6"><span class="font">ghci&gt; layout $ pretty 5 $ para pg</span></p>
<p class="code6"><span class="font">Hello</span></p>
<p class="code6"><span class="font">World1*** Exception: Prelude.undefined</span></p>
<p class="code6"><a id="text/part0012.html.page_208" class="calibre3"></a><span class="font">ghci&gt; layout $ pretty 10 $ cexpr ce</span></p>
<p class="code6"><span class="font">if happy</span></p>
<p class="code6"><span class="font">then great</span></p>
<p class="code6"><span class="font">else *** Exception: Prelude.undefined</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise L</b></p>
<p class="para">The definition is</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="font">prettyl :: Int -&gt; Doc -&gt; Layout</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="font">prettyl w x = best w [(0,x)]</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space-r"></span><span class="font">where</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space-r"></span><span class="font">best r []</span></td>
<td class="calibre14"><span class="font">= Empty</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space-r"></span><span class="font">best r ((i,Nil):ids)</span></td>
<td class="calibre14"><span class="font">= best r ids</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space-r"></span><span class="font">best r ((i,Line):ids)</span></td>
<td class="calibre14"><span class="font">= Break i (best (w-i) ids)</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space-r"></span><span class="font">best r ((i,Text s):ids)</span></td>
<td class="calibre14"><span class="font">= String s (best (r-length s) ids)</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space-r"></span><span class="font">best r ((i,Nest j x):ids)</span></td>
<td class="calibre14"><span class="font">= best r ((i+j,x):ids)</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space-r"></span><span class="font">best r ((i,x :&lt;&gt;: y):ids)</span></td>
<td class="calibre14"><span class="font">= best r ((i,x):(i,y):ids)</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space-r"></span><span class="font">best r ((i,Group x):ids)</span></td>
<td class="calibre14"><span class="font">= better r</span></td>
</tr>
<tr class="calibre13"><td class="calibre14"></td><td class="calibre14"><span class="space5"></span><span class="font">(best r ((i,flatten x):ids))</span></td>
</tr>
<tr class="calibre13"><td class="calibre14"></td><td class="calibre14"><span class="space5"></span><span class="font">(best r ((i,x):ids))</span></td>
</tr>
</tbody></table>
<p class="para">where <span class="font">better</span> is changed to read</p>
<p class="code"><span class="font">better r lx ly = if fits r (layout lx) then lx else ly</span></p>
<p class="para">The number of steps required to evaluate <span class="font">better r</span> is proportional to <span class="font">r</span> and thus at most <span class="font">w</span>. Now, <span class="font">prettyl</span> takes linear time if <span class="font">best</span> does. The second argument of <span class="font">best</span> is a list of indentation-document pairs, and we can define the size of this list by</p>
<p class="code"><span class="font">isize ids = sum [size x | (i,x) &lt;- ids]</span></p>
<p class="para">For each of the inner five clauses in the definition of <span class="font">best</span>, the size decreases by 1. For instance</p>
<div class="space1">
<p class="code"><span class="font">isize ((i,x :&lt;&gt;: y):ids)</span></p>
<p class="code"><span class="font">= size (x :&lt;&gt; y) + isize ids</span></p>
<p class="code"><span class="font">= 1 + size x + size y + isize ids</span></p>
<p class="code"><span class="font">= 1 + isize ((i,x):(i,y):ids)</span></p>
</div>
<p class="para">It follows that if we let <i class="calibre1">T</i>(<i class="calibre1">s</i>) denote the running time of <span class="font">best r</span> on an input of size <i class="calibre1">s</i>, then <i class="calibre1">T</i>(0) =Θ(1) from the first clause of <span class="font">best</span>, and <i class="calibre1">T</i>(<i class="calibre1">s</i>+1) =Θ(1) +<i class="calibre1">T</i>(<i class="calibre1">s</i>) for each of the five inner clauses, and</p>
<p class="equationasimage"><a id="text/part0012.html.page_209" class="calibre3"></a><i class="calibre1">T</i>(<i class="calibre1">s</i>+1) =Θ(<i class="calibre1">w</i>) +<i class="calibre1">maximum</i> [<i class="calibre1">T</i>(<i class="calibre1">k</i>) +<i class="calibre1">T</i>(<i class="calibre1">s</i>−<i class="calibre1">k</i>)|<i class="calibre1">k ←</i> [1 .. <i class="calibre1">s</i>−1]]</p>
<p class="para">for the last clause. And now we can deduce that <i class="calibre1">T</i>(<i class="calibre1">s</i>) =Θ(<i class="calibre1">ws</i>).</p>
<p class="para">In conclusion, our algorithm for <span class="font">pretty</span> is linear, though not independently of <i class="calibre1">w</i>.</p>
<h3 class="h" id="text/part0012.html.head8-9">8.9 Chapter notes</h3>
<p class="para">We referred to pretty-printing as a library, but another name for it is an <i class="calibre1">embedded domain specific language</i> (EDSL). It is a language for pretty-printing documents embedded in the host language Haskell. Many people believe that the growing success of Haskell is due to its ability to host a variety of EDSLs without fuss.</p>
<p class="para">The detailed material in this chapter has been based closely on work by Philip Wadler, see ‘A prettier printer’, <a href="#text/part0015.html.E9OE0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 11</a> in <i class="calibre1">The Fun of Programming</i> in <i class="calibre1">Cornerstones of Computing Series</i> (Palgrave MacMillan, 2003). The main difference is that Wadler used an explicit alternation operator in the term representation of <span class="font">Doc</span> (though it was hidden from the user) rather than the constructor <span class="font">Group</span>. Jeremy Gibbons suggested that the latter was a better fit with the idea of a deep embedding.</p>
<p class="para">An earlier functional pretty-printing library based on a different set of combinators was described by John Hughes, ‘The design of a pretty-printer library’, in Johan Jeuring and Erik Meijer, editors, <i class="calibre1">Advanced Functional Programming</i>, volume 925 of <i class="calibre1">LNCS</i>, Springer, 1995. Hughes’ library was later reworked by Simon Peyton Jones and installed as a Haskell library</p>
<p class="code"><span class="font">Text.PrettyPrint.HughesPJ</span></p>
<p class="para">Another pretty-printing library, in an imperative rather than functional style, was constructed 30 years ago by Derek Oppen, ‘Pretty-printing’. <i class="calibre1">ACM Transactions on Programming Languages and Systems</i> 2(4), 465–483, 1980 and is widely used as the basis of pretty-printing facilities in a number of languages. More recently, efficient pretty-printing algorithms in a functional style have been described by Olaf Chitil, ‘Pretty printing with lazy dequeues’, <i class="calibre1">ACM Transactions on Programming Languages and Systems</i> 27(1),163–184, 2005, and by Olaf Chitil and Doaitse Swierstra, ‘Linear, bounded, functional pretty-printing’, <i class="calibre1">Journal of Functional Programming</i> 19(1), 1–16, 2009. These algorithms are considerably more complicated than the one described in the text.</p>
</div></div>
<div id="text/part0013.html"><div id="text/part0013.html.CCNA0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre">

<h2 class="chapter-number" id="text/part0013.html.calibre_pb_0"><a id="text/part0013.html.page_210" class="calibre6"></a>Chapter 9</h2>
<h2 class="chapter-title">Infinite lists</h2>
<p class="para">We have already met infinite lists in <a href="#text/part0008.html.7K4G0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 4</a> and even given an induction principle for reasoning about them in <a href="#text/part0010.html.9H5K0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 6</a>. But we haven’t really appreciated what can be done with them. In this chapter we want to explain in more detail exactly what an infinite list is, and how they can be represented by <i class="calibre1">cyclic</i> structures. We also describe another useful method for reasoning about infinite lists, and discuss a number of intriguing examples in which infinite and cyclic lists can be used to good effect.</p>
<h3 class="h" id="text/part0013.html.head9-1">9.1 Review</h3>
<p class="para">Recall that <span class="font">[m..]</span> denotes the infinite list of all integers from <span class="font">m</span> onwards:</p>
<p class="code6"><span class="font">ghci&gt; [1..]</span></p>
<p class="code6"><span class="font">[1,2,3,4,5,6,7,{Interrupted}</span></p>
<p class="code6"><span class="font">ghci&gt; zip [1..] "hallo"</span></p>
<p class="code6"><span class="font">[(1,'h'),(2,'a'),(3,'l'),(4,'l'),(5,'o')]</span></p>
<p class="para">It would take forever to print <span class="font">[1..]</span>, so we interrupt the first computation. The second example illustrates a simple but typical use of infinite lists in finite computations.</p>
<p class="para">In Haskell, the arithmetic expression <span class="font">[m..]</span> is translated into <span class="font">enumFrom m</span>, where <span class="font">enumFrom</span> is a method in the <span class="font">Enum</span> class, and defined by</p>
<div class="space1">
<p class="code"><span class="font">enumFrom :: Integer -&gt; [Integer]</span></p>
<p class="code"><span class="font">enumFrom m = m:enumFrom (m+1)</span></p>
</div>
<p class="para"><a id="text/part0013.html.page_211" class="calibre3"></a>Thus <span class="font">[m..]</span> is defined as an instance of a recursively defined function. The computation makes progress because <span class="font">(:)</span> is non-strict in its second argument.</p>
<p class="para">It is important to bear in mind that infinite lists in computing do not have the same properties as infinite sets do in mathematics. For example, in set theory</p>
<p class="equationasimage">{<i class="calibre1">x</i> | <i class="calibre1">x</i> ∈{1, 2, 3, . . .}, <i class="calibre1">x</i><sup class="calibre8">2</sup> &lt; 10}</p>
<p class="para">denotes the set {1, 2, 3}, but</p>
<p class="code6"><span class="font">ghci&gt; [x | x &lt;- [1..], x*x &lt; 10]</span></p>
<p class="code6"><span class="font">[1,2,3</span></p>
<p class="para">After printing the first three values the computer gets stuck in an infinite loop looking for the next number after 3 whose square is less than 10. The value of the expression above is the partial list <span class="font">1:2:3:undefined</span>.</p>
<p class="para">It is possible to have an infinite list of infinite lists. For example,</p>
<p class="code"><span class="font">multiples = [map (n*) [1..] | n &lt;- [2..]]</span></p>
<p class="para">defines an infinite list of infinite lists of numbers, the first three being</p>
<p class="code"><span class="font">[2,4,6,8,...] [3,6,9,12,...] [4,8,12,16,...]</span></p>
<p class="para">Suppose we ask whether the above list of lists can be merged back into a single list, namely <span class="font">[2..]</span>. We can certainly merge two infinite lists:</p>
<div class="space1">
<p class="code"><span class="font">merge :: Ord a =&gt; [a] -&gt; [a] -&gt; [a]</span></p>
<p class="code"><span class="font">merge (x:xs) (y:ys) | x&lt;y = x:merge xs (y:ys)</span></p>
<p class="code16"><span class="font">| x==y = x:merge xs ys</span></p>
<p class="code16"><span class="font">| x&gt;y = y:merge (x:xs) ys</span></p>
</div>
<p class="para">This version of <span class="font">merge</span> removes duplicates: if the two arguments are in strictly increasing order, so is the result. Note the absence of any clauses of <span class="font">merge</span> mentioning the empty list. Now it seems that, if we define</p>
<p class="code"><span class="font">mergeAll = foldr1 merge</span></p>
<p class="para">then <span class="font">mergeAll multiples</span> will return the infinite list <span class="font">[2..]</span>. But it doesn’t. What happens is that the computer gets stuck in an infinite loop attempting to compute the first element of the result, namely</p>
<p class="code"><span class="font">minimum (map head multiples)</span></p>
<p class="para">It is simply not possible to compute the minimum element in an infinite list. Instead we have to make use of the fact that <span class="font">map head multiples</span> is in strictly increasing order, and define</p>
<div class="space1">
<p class="code"><a id="text/part0013.html.page_212" class="calibre3"></a><span class="font">mergeAll = foldr1 xmerge</span></p>
<p class="code"><span class="font">xmerge (x:xs) ys = x:merge xs ys</span></p>
</div>
<p class="para">With this definition, <span class="font">mergeAll multiples</span> does indeed return <span class="font">[2..]</span>.</p>
<p class="para">Finally, recall the induction principle described in <a href="#text/part0010.html.9H5K0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 6</a> for proving facts about infinite lists. Provided <i class="calibre1">P</i> is a chain-complete assertion, we can prove that <i class="calibre1">P</i>(<span class="font">xs</span>) holds for all infinite lists <span class="font">xs</span> by showing that: (i) <i class="calibre1">P</i>(<span class="font">undefined</span>) holds; and (ii) <i class="calibre1">P</i>(<span class="font">xs</span>) implies <i class="calibre1">P</i>(<span class="font">x:xs</span>) for all <span class="font">x</span> and <span class="font">xs</span>. Using this principle, we proved in <a href="#text/part0010.html.9H5K0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 6</a> that <span class="font">xs++ys</span> = <span class="font">xs</span> for all infinite lists <span class="font">xs</span>. But it’s not immediately clear how induction can be used to prove, for example,</p>
<p class="code"><span class="font">map fact [0..] = scanl (*) 1 [1..]</span></p>
<p class="para">The obvious result to prove is</p>
<p class="code"><span class="font">map fact [0..n] = scanl (*) 1 [1..n]</span></p>
<p class="para">for all <span class="font">n</span>, but can one then assert the first identity holds?</p>
<h3 class="h" id="text/part0013.html.head9-2">9.2 Cyclic lists</h3>
<p class="para">Data structures, like functions, can be defined recursively. For instance</p>
<div class="space1">
<p class="code"><span class="font">ones :: [Int]</span></p>
<p class="code"><span class="font">ones = 1:ones</span></p>
</div>
<p class="para">This is an example of a <i class="calibre1">cyclic</i> list, a list whose definition is recursive. Contrast this definition with <span class="font">ones = repeat 1</span>, where</p>
<p class="code"><span class="font">repeat x = x:repeat x</span></p>
<p class="para">This definition of <span class="font">ones</span> creates an infinite, not a cyclic list. We could define</p>
<p class="code"><span class="font">repeat x = xs where xs = x:xs</span></p>
<p class="para">Now the function <span class="font">repeat</span> is defined in terms of a cyclic list. The second definition (call it <span class="font">repeat2</span>) is faster to evaluate than the first (call it <span class="font">repeat1</span>) because there is less overhead:</p>
<p class="code6"><span class="font">ghci&gt; last $ take 10000000 $ repeat1 1</span></p>
<p class="code6"><span class="font">1</span></p>
<p class="code6"><span class="font">(2.95 secs, 800443676 bytes)</span></p>
<p class="code6"><span class="font">ghci&gt; last $ take 10000000 $ repeat2 1</span></p>
<p class="code6"><span class="font">1</span></p>
<p class="code6"><a id="text/part0013.html.page_213" class="calibre3"></a><span class="font">(0.11 secs, 280465164 bytes)</span></p>
<p class="para">As another example, consider the following three definitions of the standard prelude function <span class="font">iterate</span>:</p>
<div class="space1">
<p class="code"><span class="font">iterate1 f x = x:iterate1 f (f x)</span></p>
<p class="code"><span class="font">iterate2 f x = xs where xs = x:map f xs</span></p>
<p class="code"><span class="font">iterate3 f x = x:map f (iterate3 f x)</span></p>
</div>
<p class="para">All three functions have type <span class="font">(a -&gt; a) -&gt; a -&gt; [a]</span> and produce an infinite list of the iterates of <span class="font">f</span> applied to <span class="font">x</span>. The three functions are equal, but the induction principle reviewed earlier doesn’t seem to be applicable in proving this assertion because there is no obvious argument on which to perform the induction. More on this later. The first definition is the one used in the standard prelude, but it does not create a cyclic list. The second definition does, and the third is obtained from the second by eliminating the <span class="font">where</span> clause. Assuming <span class="font">f x</span> can be computed in constant time, the first definition takes Θ(<i class="calibre1">n</i>) steps to compute the first <i class="calibre1">n</i> elements of the result, but the third takes Θ(<i class="calibre1">n</i><sup class="calibre8">2</sup>) steps:</p>
<p class="code6"><span class="space"></span><span class="font">iterate3 (2*) 1</span></p>
<p class="code6"><span class="font">= 1:map (2*) (iterate3 (2*1))</span></p>
<p class="code6"><span class="font">= 1:2:map (2*) (map (2*) (iterate3 (2*1)))</span></p>
<p class="code6"><span class="font">= 1:2:4:map (2*) (map (2*) (map (2*) (iterate3 (2*1))))</span></p>
<p class="para">Evaluating the <i class="calibre1">n</i>th element requires <i class="calibre1">n</i> applications of <span class="font">(2*)</span>, so it takes Θ(<i class="calibre1">n</i><sup class="calibre8">2</sup>) to produce the first <i class="calibre1">n</i> elements.</p>
<p class="para">That leaves the second definition. Does it take linear or quadratic time? The evaluation of <span class="font">iterate2 (2*) 1</span> proceeds as follows:</p>
<p class="code6"><span class="space"></span><span class="font">xs where xs = 1:map (2*) xs</span></p>
<p class="code6"><span class="font">= 1:ys where ys = map (2*) (1:ys)</span></p>
<p class="code6"><span class="font">= 1:2:zs where zs = map (2*) (2:zs)</span></p>
<p class="code6"><span class="font">= 1:2:4:ts where ts = map (2*) (4:ts)</span></p>
<p class="para">Each element of the result is produced in constant time, so <span class="font">iterate2 (2*) 1</span> takes Θ(<i class="calibre1">n</i>) steps to produce <i class="calibre1">n</i> elements.</p>
<p class="para">Let us now develop a cyclic list to generate an infinite list of all the primes. To start with we define</p>
<div class="space1">
<p class="code"><span class="font">primes = [2..] \\ composites</span></p>
<p class="code"><span class="font">composites = mergeAll multiples</span></p>
<p class="code"><span class="font">multiples = [map (n*) [n..] | n &lt;- [2..]]</span></p>
</div>
<p class="para"><a id="text/part0013.html.page_214" class="calibre3"></a>where <span class="font">(\\)</span> subtracts one strictly increasing list from another:</p>
<div class="space1">
<p class="code"><span class="font">(x:xs) \\ (y:ys) | x&lt;y = x:(xs \\ (y:ys))</span></p>
<p class="code14"><span class="font">| x==y = xs \\ ys</span></p>
<p class="code14"><span class="font">| x&gt;y = (x:xs) \\ ys</span></p>
</div>
<p class="para">Here, <span class="font">multiples</span> consists of the list of all multiples of 2 from 4 onwards, all multiples of 3 from 9 onwards, all multiples of 4 from 16 onwards, and so on. Merging the list gives the infinite list of all the composite numbers, and taking its complement with respect to <span class="font">[2..]</span> gives the primes. We saw the definition of <span class="font">mergeAll</span> in the previous section.</p>
<p class="para">So far, so good. But the algorithm can be made many times faster by observing that too many multiples are being merged. For instance, having constructed the multiples of 2 there is no need to construct the multiples of 4, or of 6, and so on. What we really would like to do is just to construct the multiples of the primes. That leads to the idea of ‘tying the recursive knot’ and defining</p>
<div class="space1">
<p class="code"><span class="font">primes = [2..] \\ composites</span></p>
<p class="code"><span class="space-r"></span><span class="font">where</span></p>
<p class="code"><span class="space-r"></span><span class="font">composites = mergeAll [map (p*) [p..] | p &lt;- primes]</span></p>
</div>
<p class="para">What we have here is a cyclic definition of <span class="font">primes</span>. It looks great, but does it work? Unfortunately, it doesn’t: <span class="font">primes</span> produces the undefined list. In order to determine the first element of <span class="font">primes</span> the computation requires the first element of <span class="font">composites</span>, which in turn requires the first element of <span class="font">primes</span>. The computation gets stuck in an infinite loop. To solve the problem we have to pump-prime (!) the computation by giving the computation the first prime explicitly. We have to rewrite the definition as</p>
<div class="space1">
<p class="code"><span class="font">primes = 2:([3..] \\ composites)</span></p>
<p class="code"><span class="space-r"></span><span class="font">where</span></p>
<p class="code"><span class="space-r"></span><span class="font">composites = mergeAll [map (p*) [p..] | p &lt;- primes]</span></p>
</div>
<p class="para">But this still doesn’t produce the primes! The reason is a subtle one and is quite hard to spot. It has to do with the definition</p>
<p class="code"><span class="font">mergeAll = foldr1 xmerge</span></p>
<p class="para">The culprit is the function <span class="font">foldr1</span>. Recall the Haskell definition:</p>
<div class="space1">
<p class="code"><span class="font">foldr1 :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; a</span></p>
<p class="code"><span class="font">foldr1 f [x] = x</span></p>
<p class="code"><span class="font">foldr1 f (x:xs) = f x (foldr1 xs)</span></p>
</div>
<p class="para"><a id="text/part0013.html.page_215" class="calibre3"></a>The order of the two defining equations is significant. In particular,</p>
<p class="code"><span class="font">foldr1 f (x:undefined) = undefined</span></p>
<p class="para">because the list argument is first matched against <span class="font">x:[]</span>, causing the result to be undefined. That means</p>
<p class="code"><span class="font">mergeAll [map (p*) [p..] | p &lt;- 2:undefined] = undefined</span></p>
<p class="para">What we wanted was</p>
<p class="code"><span class="font">mergeAll [map (p*) [p..] | p &lt;- 2:undefined] = 4:undefined</span></p>
<p class="para">To effect this change we have to define <span class="font">mergeAll</span> differently:</p>
<p class="code"><span class="font">mergeAll (xs:xss) = xmerge xs (mergeAll xss)</span></p>
<p class="para">Now we have</p>
<p class="code6"><span class="space"></span><span class="font">mergeAll [map (p*) [p..] | p &lt;- 2:undefined]</span></p>
<p class="code6"><span class="font">= xmerge (map (2*) [2..]) undefined</span></p>
<p class="code6"><span class="font">= xmerge (4:map (2*) [3..]) undefined</span></p>
<p class="code6"><span class="font">= 4:merge (map (2*) [3..]) undefined</span></p>
<p class="code6"><span class="font">= 4:undefined</span></p>
<p class="para">This version of <span class="font">mergeAll</span> behaves differently on finite lists from the previous one. Why?</p>
<p class="para">With this final change we claim that <span class="font">primes</span> does indeed get into gear and produces the primes. But how can the claim be proved? To answer this question we need to know something about the semantics of recursively defined functions and other values in Haskell, and how infinite lists are defined as limits of their partial approximations.</p>
<h3 class="h" id="text/part0013.html.head9-3">9.3 Infinite lists as limits</h3>
<p class="para">In mathematics, certain values are defined as <i class="calibre1">limits</i> of infinite sequences of approximations of simpler values. For example, the irrational number</p>
<p class="equationasimage"><i class="calibre1">π</i> = 3.14159265358979323846· · ·</p>
<p class="para">can be defined as the limit of the infinite sequence of rational approximations</p>
<p class="equationasimage">3, 3.1, 3.14, 3.141, 3.1415, . . .</p>
<p class="para"><a id="text/part0013.html.page_216" class="calibre3"></a>The first element of the sequence, 3, is a fairly crude approximation to <i class="calibre1">π</i>. The next element, 3.1, is a little better; 3.14 is better still, and so on.</p>
<p class="para">Similarly, an infinite list can also be regarded as the limit of a sequence of approximations. For example, the infinite list [1..] is the limit of the infinite sequence of partial lists</p>
<p class="equationasimage">⊥, 1 :⊥, 1 : 2 :⊥, 1 : 2 : 3 :⊥, . . .</p>
<p class="para">Again, the sequence consists of better and better approximations to the intended limit. The first term, ⊥, is the undefined element, and thus a very crude approximation: it tells us nothing about the limit. The next term, 1 :⊥, is a slightly better approximation: it tells us that the limit is a list whose first element is 1, but says nothing about the rest of the list. The following term, 1 : 2 :⊥, is a little better still, and so on. Each successively better approximation is derived by replacing ⊥ with a more defined value, and thus gives more information about the limit.</p>
<p class="para">Here is another sequence of approximations whose limit is [1..]:</p>
<p class="equationasimage">⊥, 1 : 2 :⊥, 1 : 2 : 3 : 4 :⊥, 1 : 2 : 3 : 4 : 5 : 6 :⊥, . . .</p>
<p class="para">This sequence is a subsequence of the one above but it converges to the same limit.</p>
<p class="para">Here is a sequence of approximations that does not converge to a limit:</p>
<p class="equationasimage">⊥, 1 :⊥, 2 : 1 :⊥, 3 : 2 : 1 :⊥, . . .</p>
<p class="para">The problem with this sequence is that it gives conflicting information: the second term says that the limit begins with 1. However, the third term says that the limit begins with 2, and the fourth term says that it begins with 3, and so on. No approximation tells us anything about the intended limit and the sequence does not converge.</p>
<p class="para">It should not be thought that the limit of a sequence of lists is necessarily infinite. For example, the sequence</p>
<p class="equationasimage">⊥, 1 :⊥, 1 : [ ], 1 : [ ], . . .</p>
<p class="para">in which every element after the first two is [1], is a perfectly valid sequence with limit [1]. Similarly,</p>
<p class="equationasimage">⊥, 1 :⊥, 1 : 2 :⊥, 1 : 2 :⊥, . . .</p>
<p class="para">is a sequence with limit 1 : 2 :⊥. Finite and partial lists are limits of sequences possessing only a finite number of distinct elements.</p>
<p class="para">The way to formalise the property that an infinite sequence of partial lists converges to a limit is to introduce the notion of an <i class="calibre1">approximation ordering</i> ⊑ on the <a id="text/part0013.html.page_217" class="calibre3"></a>elements of each type. The assertion <i class="calibre1">x</i> ⊑ <i class="calibre1">y</i> means that <i class="calibre1">x</i> is an approximation to <i class="calibre1">y</i>. The ordering ⊑ will be reflexive (<i class="calibre1">x</i> ⊑ <i class="calibre1">x</i>), transitive (<i class="calibre1">x</i> ⊑ <i class="calibre1">y</i> and <i class="calibre1">y</i> ⊑ <i class="calibre1">z</i> implies <i class="calibre1">x</i> ⊑ <i class="calibre1">z</i>), and anti-symmetric (<i class="calibre1">x</i> ⊑ <i class="calibre1">y</i> and <i class="calibre1">y</i> ⊑ <i class="calibre1">x</i> implies <i class="calibre1">x</i> = <i class="calibre1">y</i>). However, it is not the case that every pair of elements have to be comparable by ⊑. Thus ⊑ is what is known as a <i class="calibre1">partial</i> ordering. Note that ⊑ is a mathematical operator (like =), and not a Haskell operator returning boolean results.</p>
<p class="para">The approximation ordering for numbers, booleans, characters and any other enumerated type, is defined by</p>
<p class="equationasimage"><i class="calibre1">x</i> ⊑ <i class="calibre1">y</i> ≡ (<i class="calibre1">x</i> =⊥) ∨ (<i class="calibre1">x</i> = <i class="calibre1">y</i>).</p>
<p class="para">The first clause says that ⊥ is an approximation to everything. In other words, ⊥ is the <i class="calibre1">bottom</i> element of the ordering. This explains why ⊥ is pronounced ‘bottom’. The value ⊥ is the bottom element of ⊑ for every type. The above ordering is <i class="calibre1">flat</i>. With a flat ordering one either knows everything there is to know about a value, or one knows absolutely nothing.</p>
<p class="para">The approximation ordering on the type (<i class="calibre1">a</i>, <i class="calibre1">b</i>) is defined by ⊥⊑ (<i class="calibre1">x</i>, <i class="calibre1">y</i>) and</p>
<p class="equationasimage">(<i class="calibre1">x</i>, <i class="calibre1">y</i>) ⊑ (<i class="calibre1">x</i><sup class="calibre8">′</sup> , <i class="calibre1">y</i><sup class="calibre8">′</sup> ) ≡ (<i class="calibre1">x</i> ⊑ <i class="calibre1">x</i><sup class="calibre8">′</sup> ) ∧ (<i class="calibre1">y</i> ⊑ <i class="calibre1">y</i><sup class="calibre8">′</sup> ).</p>
<p class="para">The occurrences of ⊑ on the right refer to the orderings on the types <i class="calibre1">a</i> and <i class="calibre1">b</i>, respectively. The ordering ⊑ on (<i class="calibre1">a</i>, <i class="calibre1">b</i>) is not flat, even when the component orderings are. For example, in <span class="font">(Bool,Bool)</span> we have the following chain of distinct elements:</p>
<p class="equationasimage">⊥⊑ (⊥, ⊥) ⊑ (⊥, <span class="font">False</span>) ⊑ (<span class="font">True</span>, <span class="font">False</span>).</p>
<p class="para">Note that in Haskell the pair (⊥, ⊥) is distinct from ⊥:</p>
<p class="code6"><span class="font">ghci&gt; let f (a,b) = 1</span></p>
<p class="code6"><span class="font">ghci&gt; f (undefined,undefined)</span></p>
<p class="code6"><span class="font">1</span></p>
<p class="code6"><span class="font">ghci&gt; f undefined</span></p>
<p class="code6"><span class="font">*** Exception: Prelude.undefined</span></p>
<p class="para">The ordering ⊑ on <span class="font">[a]</span> is defined by ⊥⊑ <i class="calibre1">xs</i> and <span class="font">(x:xs)</span> ⋢ <span class="font">[]</span> and</p>
<p class="equationasimage"><span class="font">[]</span> ⊑ <span class="font">xs</span> ≡ <span class="font">xs</span> = <span class="font">[]</span>,</p>
<p class="equationasimage"><span class="font">(x:xs)</span> ⊑ <span class="font">(y:ys)</span> ≡ (<span class="font">x</span> ⊑ <span class="font">y</span>) ∧ (<span class="font">xs</span> ⊑ <span class="font">ys</span>).</p>
<p class="para">These equations should be read as an inductive definition of a mathematical assertion, not as a Haskell definition. The second condition says that <span class="font">[]</span> approximates only itself, and the third condition says that <span class="font">(x:xs)</span> is an approximation to <span class="font">(y:ys)</span> if and only if <span class="font">x</span> is an approximation to <span class="font">y</span> and <span class="font">xs</span> is an approximation to <span class="font">ys</span>. The first <a id="text/part0013.html.page_218" class="calibre3"></a>occurrence of ⊑ on the right-hand side refers to the approximation ordering on the type <span class="font">a</span>.</p>
<p class="para">As two examples, we have</p>
<p class="equationasimage">[1, ⊥, 3] ⊑ [1, 2, 3] and 1 : 2 :⊥⊑ [1, 2, 3].</p>
<p class="para">However, 1 : 2 :⊥ and [1, ⊥, 3] are not related by ⊑.</p>
<p class="para">The approximation ordering for each type <i class="calibre1">T</i> is assumed to have another property in addition to those described above: each <i class="calibre1">chain</i> of approximations <i class="calibre1">x</i><sub class="calibre11">0</sub> ⊑ <i class="calibre1">x</i><sub class="calibre11">1</sub> ⊑. . . has to possess a limit which is also a member of <i class="calibre1">T</i>. The limit, which we denote by lim<sub class="calibre11"><i class="calibre1">n</i>→∞</sub> <i class="calibre1">x</i><sub class="calibre11"><i class="calibre1">n</i></sub>, is defined by two conditions:</p>
<p class="number">1.<span class="space"></span><i class="calibre1">x</i><sub class="calibre11"><i class="calibre1">n</i></sub> ⊑ lim<sub class="calibre11"><i class="calibre1">n</i>→∞</sub> <i class="calibre1">x</i><sub class="calibre11"><i class="calibre1">n</i></sub> for all <i class="calibre1">n</i>. This condition states that the limit is an <i class="calibre1">upper bound</i> on the sequence of approximations.</p>
<p class="number">2.<span class="space"></span>If <i class="calibre1">x</i><sub class="calibre11"><i class="calibre1">n</i></sub> ⊑ <i class="calibre1">y</i> for all <i class="calibre1">n</i>, then lim<sub class="calibre11"><i class="calibre1">n</i>→∞</sub> <i class="calibre1">x</i><sub class="calibre11"><i class="calibre1">n</i></sub> ⊑ <i class="calibre1">y</i>. This condition states that the limit is the <i class="calibre1">least</i> upper bound.</p>
<p class="para">The definition of the limit of a chain of approximations applies to every type. Partial orderings possessing this property are called <i class="calibre1">complete</i>, and every Haskell type is a complete partial ordering (CPO for short). In particular, the property, introduced in <a href="#text/part0010.html.9H5K0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 6</a>, of a mathematical assertion <i class="calibre1">P</i> being chain complete can now be formalised as</p>
<p class="equationasimage"><img src="data:image/jpeg;base64,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" alt="image" class="calibre2"></p>
<p class="para">In words, <i class="calibre1">P</i> holds in the limit if it holds for each approximation to the limit.</p>
<p class="para">For lists there is a useful Haskell function <span class="font">approx</span>, which produces approximations to a given list. The definition is</p>
<div class="space1">
<p class="code"><span class="font">approx :: Integer -&gt; [a] -&gt; [a]</span></p>
<p class="code"><span class="font">approx n []</span><span class="space4"></span><span class="font">| n&gt;0 = []</span></p>
<p class="code"><span class="font">approx n (x:xs) | n&gt;0 = x:approx (n-1) xs</span></p>
</div>
<p class="para">The definition of <span class="font">approx</span> is very similar to that of <span class="font">take</span> except that, by case exhaustion, we have <span class="font">approx 0 xs = undefined</span> for all <span class="font">xs</span>. For example,</p>
<div class="space1">
<p class="code"><span class="font">approx 0 [1] = undefined</span></p>
<p class="code"><span class="font">approx 1 [1] = 1:undefined</span></p>
<p class="code"><span class="font">approx 2 [1] = 1:[]</span></p>
</div>
<p class="para">The crucial property of <span class="font">approx</span> is that</p>
<p class="equationasimage"><img src="data:image/jpeg;base64,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" alt="image" class="calibre2"></p>
<p class="para"><a id="text/part0013.html.page_219" class="calibre3"></a>for all lists <span class="font">xs</span>, finite, partial or infinite. The proof, an induction on <span class="font">xs</span>, is left as an exercise.</p>
<p class="para">It follows that if <span class="font">approx n xs</span> = <span class="font">approx n ys</span> for all natural numbers <span class="font">n</span>, then <span class="font">xs</span> = <span class="font">ys</span>. Thus we can prove that</p>
<p class="code"><span class="font">iterate f x = x:map f (iterate f x)</span></p>
<p class="para">by showing</p>
<p class="code"><span class="font">approx n (iterate f x) = approx n (x:map f (iterate f x))</span></p>
<p class="para">for all natural numbers <span class="font">n</span>. And, of course, we can use induction over the natural numbers to establish this fact. The details are left as an easy exercise.</p>
<p class="para">As another example, consider the value <span class="font">primes</span> defined in the previous section. Suppose we define</p>
<p class="code"><span class="font">prs n = approx n primes</span></p>
<p class="para">We would like to show that <span class="font">prs n</span> = <i class="calibre1">p</i><sub class="calibre11">1</sub> : <i class="calibre1">p</i><sub class="calibre11"><sup class="calibre18">2</sup></sub> : · · · <i class="calibre1">p</i><sub class="calibre11"><i class="calibre1">n</i></sub> :⊥, where <i class="calibre1">p</i><sub class="calibre11"><i class="calibre1">j</i></sub> is the <i class="calibre1">j</i>th prime. We claim that</p>
<div class="space1">
<p class="code"><span class="font">prs n = approx n (2:([3..] \\ crs n))</span></p>
<p class="code"><span class="font">crs n = mergeAll [map (p*) [p..] | p &lt;- prs n]</span></p>
</div>
<p class="para">Given this, it is sufficient to show that <span class="font">crs n</span> = <i class="calibre1">c</i><sub class="calibre11">1</sub> : <i class="calibre1">c</i><sup class="calibre8">2</sup> : · · · <i class="calibre1">c</i><sub class="calibre11"><i class="calibre1">m</i></sub> :⊥, where <i class="calibre1">c</i><sub class="calibre11"><i class="calibre1">j</i></sub> is the <i class="calibre1">j</i>th composite number (so <i class="calibre1">c</i><sub class="calibre11">1</sub> = 4) and <img src="data:image/gif;base64,R0lGODlhOAAXAOcAACMfICMfIyMfODwfOiMiOiMfUCYfUi8fUC8fYSMiRiMpfiMyaiM/dDMibihHWy1RZ04fKlAfI1gfPkEiIEEiI0oiI0wiIGUfIG4iIG4iOmc9L0cfTUcfUlgfTVIwR0EiaHwpQnwpVnwwfnxbOnVeSWVjZGVjZmdjZCMsgyM0gSM4hj4sgyNOjiNCkCNElSNFmiNOkiZKkiNOnyhElS1SgTNVkiNjryhmrCh0qjdmpjVutFtulS+AsS+BxDOOzU6CvFCevUaU0F+UxlqUzlCf1FCf2HCf0W+l02iq22+15W615nC143W66X+14Xy/6oIsIIIsKo86I486KoM/P4kuSYlVNZpFPpBVL6BOKqVWLKVXL6teP7BmM7ZsNbBoPLp0Or97Po91daBPX5h9o7+CWMSBR8OIRsODUtaaVtaaWdqfW9qfXsOUacKWcd+lYdWlctaqeuOqZ+avbu66eImvqpquo6+kkrSumoGx3oqx2I224beiwJ3M2YLE7Y/N8Y/N8pXR85rV9JrW9qLM2aHV8KXe+KjV8K/W8Lvl2Kvi+bDm67Li97vm+L/u/L/x/cORmMmimdavitWnmOa6gea6iu6/hNu7wOnDiefEnu7NnfXEg/jNj/LEk/zRlPrWm/zWmv3an/7epf/nr//qtf7xv8fAzc3Nzc3S48nu/MTx/MT1/s3z/c32/tb47tXz/NL5/tb8/9r3/tr9/976/uva0Pvqxf7uwv/1xP7zzv/4yP/4zP/81fv92P/92P/92//+3Ofs+Ob98OL7/ub7/ub+/+r7/ur+///74f/75P/94P/+4v//5v/+6P//6///7vP+//X///b////+8P//8v//9f//9vv/+Pn///r///3/+v//+P//+v3//////P7//gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAAAAP8ALAAAAAA4ABcAAAj+AL0JHEiwoMGDCBMqXMiwocOHECMSRMZmQoIjzyRqZNiNUxNrkz4k2kgSYTVLs7zlovKnpEuEpEQ4eklzYLdKQ6LVrIlrjKudNJk9YqRwWiQSDRTBqaAj2BsKOoht3IZpRAE6VQLUQCVNkiFvx/YYQ8jsC4w7g8ywsMPHzAtYJKupISCkmCcIRC5ZAABAQJKEuqI80MMLiwM8hXtAG7iN0okSkCNDNmFE58BlXVqw8ibqgg9sDkFFiDoKww1hozIwKXkLShFu3jYNWN1wmxwDgLxpOuBHN4JCJT9xyE0tTYpGDpuBkSGrGhoXr5y/aAWMsWPJkilb9qbNDQpV3myeTUECuqEuKUGu/cqiWBkXHpAWbSxrgxgyMj+GdcukAUgbD314w8wZOcQyUCgdtEQKCE5444sWCxBC0i1PMFBHGHlk5M0uVuyAyBZKeJOMFzGsAhRCn2zQUkGhSLAEKSEIcuJC3SkwE0HdzDHDK52sAN6MCdVyhQqpFORMGUVkEwcOpUgFpEHa0GKKKadoKFAvYgRSzRo0HPLkl2BKFBAAOw==" alt="image" class="calibre2"> Then the proof is completed by using the fact that&nbsp;<img src="data:image/jpeg;base64,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" alt="image" class="calibre2"> which is a non-trivial result in Number Theory. Details are in the exercises.</p>
<p class="center"><i class="calibre1">Computable functions and recursive definitions</i></p>
<p class="para">One can describe many functions in mathematics, but only some of them are computable. There are two properties of computable functions not shared by arbitrary functions. Firstly, a computable function <i class="calibre1">f</i> is <i class="calibre1">monotonic</i> with respect to the approximation ordering. In symbols,</p>
<p class="equationasimage"><i class="calibre1">x</i> ⊑ <i class="calibre1">y</i> ⇒ <i class="calibre1">f</i> (<i class="calibre1">x</i>) ⊑ <i class="calibre1">f</i> (<i class="calibre1">y</i>)</p>
<p class="para">for all <i class="calibre1">x</i> and <i class="calibre1">y</i>. Roughly speaking, monotonicity states that the more information you supply about the argument, the more information you get as a result. Secondly, a computable function <i class="calibre1">f</i> is <i class="calibre1">continuous</i>, which means that</p>
<p class="equationasimage"><img src="data:image/jpeg;base64,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" alt="image" class="calibre2"></p>
<p class="para"><a id="text/part0013.html.page_220" class="calibre3"></a>for all chains of approximations <i class="calibre1">x</i><sub class="calibre11">0</sub> ⊑ <i class="calibre1">x</i><sub class="calibre11">1</sub> ⊑ . . .. Roughly speaking, continuity states that there are no surprises on passing to the limit.</p>
<p class="para">Continuity appears similar to chain completeness but differs in two respects. One is that the chain completeness of <i class="calibre1">P</i> does not imply the converse property that if <i class="calibre1">P</i> is false for all approximations, then <i class="calibre1">P</i> is false for the limit. In other words, it does not imply that ¬<i class="calibre1">P</i> is chain complete. Secondly, <i class="calibre1">P</i> is a mathematical assertion, not a Haskell function returning a boolean value.</p>
<p class="para">Although we won’t prove it, every monotonic and continuous function <i class="calibre1">f</i> has a <i class="calibre1">least fixed point</i>. A fixed point of a function <i class="calibre1">f</i> is a value <i class="calibre1">x</i> such that <i class="calibre1">f</i> (<i class="calibre1">x</i>) = <i class="calibre1">x</i>. And <i class="calibre1">x</i> is a least fixed point if <i class="calibre1">x</i> ⊑ <i class="calibre1">y</i> for any other fixed point <i class="calibre1">y</i>. The least fixed point of a monotonic and continuous function <i class="calibre1">f</i> is given by lim<sub class="calibre11"><i class="calibre1">n</i>→∞</sub> <i class="calibre1">x</i><sub class="calibre11"><i class="calibre1">n</i></sub> where <i class="calibre1">x</i><sub class="calibre11">0</sub> =⊥ and <i class="calibre1">x</i><sub class="calibre11"><i class="calibre1">n</i>+1</sub> = <i class="calibre1">f</i> (<i class="calibre1">x</i><sub class="calibre11"><i class="calibre1">n</i></sub>). In functional programming, recursive definitions are interpreted as least fixed points.</p>
<p class="para">Here are three examples. Consider the definition <span class="font">ones = 1:ones</span>. This definition asserts that <span class="font">ones</span> is a fixed point of the function <span class="font">(1:)</span>. Haskell interprets it as the least fixed point, so <span class="font">ones</span> = lim<sub class="calibre11"><i class="calibre1">n</i>→∞</sub> <span class="font">ones</span><sub class="calibre11"><i class="calibre1">n</i></sub>, where <span class="font">ones</span><sub class="calibre11">0</sub> =⊥ and <span class="font">ones</span><sub class="calibre11"><i class="calibre1">n</i>+1</sub> = <span class="font">1:ones</span><sub class="calibre11"><i class="calibre1">n</i></sub>. It is easy to see that <span class="font">ones</span><sub class="calibre11"><i class="calibre1">n</i></sub> is the partial list consisting of <i class="calibre1">n</i> ones, so the limit is indeed an infinite list of ones.</p>
<p class="para">Second, consider the factorial function</p>
<p class="code"><span class="font">fact n = if n==0 then 1 else n*fact (n-1)</span></p>
<p class="para">We can rewrite this definition in the equivalent form</p>
<p class="code"><span class="font">fact = (\f n -&gt; if n==0 then 1 else n*f(n-1)) fact</span></p>
<p class="para">Again, this definition asserts that <span class="font">fact</span> is a fixed point of a function. Here we have</p>
<div class="space1">
<p class="code1"><span class="font">fact</span><sub class="calibre11">0</sub> <span class="font">n =</span> ⊥</p>
<p class="code1"><span class="font">fact</span><sub class="calibre11">1</sub> <span class="font">n = if n==0 then 1 else</span> ⊥</p>
<p class="code1"><span class="font">fact</span><sup class="calibre8">2</sup> <span class="font">n = if n&lt;=1 then 1 else</span> ⊥</p>
</div>
<p class="para">and so on. The value of <span class="font">fact</span><sub class="calibre11"><i class="calibre1">k</i></sub> <span class="font">n</span> is the factorial of <span class="font">n</span> if <span class="font">n</span> is less than <i class="calibre1">k</i>, and ⊥ otherwise.</p>
<p class="para">Finally, consider the list <span class="font">primes</span> once again. Here we have</p>
<div class="space1">
<p class="code"><span class="font">primes</span><sub class="calibre11">0</sub> <span class="font">=</span> ⊥</p>
<p class="code"><span class="font">primes</span><sub class="calibre11"><i class="calibre1">n</i>+1</sub> <span class="font">= 2:([3..]</span> \\</p>
<p class="code10"><span class="font">mergeAll [map (p*) [p..] | p &lt;- primes</span><sub class="calibre11"><i class="calibre1">n</i></sub><span class="font">])</span></p>
</div>
<p class="para"><a id="text/part0013.html.page_221" class="calibre3"></a>It is not the case that <span class="font">primes</span><sub class="calibre11"><i class="calibre1">n</i></sub> = <span class="font">approx n primes</span>. In fact,</p>
<div class="space1">
<p class="code4"><span class="font">primes</span><sub class="calibre11">1</sub> <span class="font">=</span> 2 :⊥</p>
<p class="code4"><span class="font">primes</span><sup class="calibre8">2</sup> <span class="font">=</span> 2 : 3 :⊥</p>
<p class="code4"><span class="font">primes</span><sub class="calibre11">3</sub> <span class="font">=</span> 2 : 3 : 5 : 7 :⊥</p>
<p class="code4"><span class="font">primes</span><sub class="calibre11">4</sub> <span class="font">=</span> 2 : 3 : 5 : 7 : · · · : 47 :⊥</p>
</div>
<p class="para">The partial list <span class="font">primes</span><sup class="calibre8">2</sup> produces all the primes less than 4, <span class="font">primes</span><sub class="calibre11">3</sub> all the primes less than 9, and <span class="font">primes</span><sub class="calibre11">4</sub> all the primes less than 49. And so on.</p>
<h3 class="h" id="text/part0013.html.head9-4">9.4 Paper–rock–scissors</h3>
<p class="para">Our next example of infinite lists is entertaining as well as instructive. Not only does it introduce the idea of using potentially infinite lists to model a sequence of interactions between processes, it also provides another concrete illustration of the necessity for formal analysis.</p>
<p class="para">The paper–rock–scissors game is a familiar one to children, though it is known by different names in different places. The game is played by two people facing one another. Behind their backs, each player forms a hand in the shape of either a rock (a clenched fist), a piece of paper (a flat palm) or a pair of scissors (two fingers extended). At a given instant, both players bring their hidden hand forward. The winner is determined by the rule ‘paper wraps rock, rock blunts scissors, and scissors cut paper’. Thus, if player 1 produces a rock and player 2 produces a pair of scissors, then player 1 wins because rock blunts scissors. If both players produce the same object, then the game is a tie and neither wins. The game continues in this fashion for a fixed number of rounds agreed in advance.</p>
<p class="para">Our objective in this section is to write a program to play and score the game. We begin by introducing the types</p>
<div class="space1">
<p class="code"><span class="font">data Move</span><span class="space"></span><span class="font">= Paper | Rock | Scissors</span></p>
<p class="code"><span class="font">type Round = (Move,Move)</span></p>
</div>
<p class="para">To score a round we define</p>
<div class="space1">
<p class="code"><span class="font">score :: Round -&gt; (Int,Int)</span></p>
<p class="code"><span class="font">score (x,y) | x `beats` y = (1,0)</span></p>
<p class="code12"><span class="font">| y `beats` x = (0,1)</span></p>
<p class="code12"><span class="font">| otherwise = (0,0)</span></p>
</div>
<p class="para">where</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><a id="text/part0013.html.page_222" class="calibre3"></a><span class="space5"></span><span class="font">Paper `beats` Rock</span></td>
<td class="calibre14"><span class="font">= True</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">Rock `beats` Scissors</span></td>
<td class="calibre14"><span class="font">= True</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">Scissors `beats` Paper</span></td>
<td class="calibre14"><span class="font">= True</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">_ `beats` _</span></td>
<td class="calibre14"><span class="font">= False</span></td>
</tr>
</tbody></table>
<p class="para">Each player in the game will be represented by a certain strategy. For instance, one simple strategy is, after the first round, always to produce what the opposing player showed in the previous round. This strategy will be called <span class="font">copy</span>. Another strategy, which we will call <span class="font">smart</span>, is to determine a move by analysing the number of times the opponent has produced each of the three possible objects, and calculating an appropriate response based on probabilities.</p>
<p class="para">We will consider the details of particular strategies, and how they can be represented, in a moment. For now, suppose the type <span class="font">Strategy</span> is given in some way. The function</p>
<p class="code"><span class="font">rounds :: (Strategy,Strategy) -&gt; [Round]</span></p>
<p class="para">takes a pair of strategies and returns the infinite list of rounds that ensue when each player follows his or her assigned strategy. The function</p>
<div class="space1">
<p class="code"><span class="font">match :: Int -&gt; (Strategy,Strategy) -&gt; (Int,Int)</span></p>
<p class="code"><span class="font">match n = total . map score . take n . rounds</span></p>
<p class="code"><span class="space"></span><span class="font">where total rs = (sum (map fst rs),sum (map snd rs))</span></p>
</div>
<p class="para">determines the total score after playing a given number of rounds.</p>
<p class="para">The instructive aspect of the game is how to represent strategies. We are going to consider two ways, calling them <span class="font">Strategy1</span> and <span class="font">Strategy2</span>. The obvious idea is to take</p>
<p class="code"><span class="font">type Strategy1 = [Move] -&gt; Move</span></p>
<p class="para">Here, a strategy is a function which takes the (finite) list of moves made by the opponent so far and returns an appropriate move for the subsequent round. For efficiency in processing lists, we suppose that the list of moves is given in reverse order, with the last move first.</p>
<p class="para">For example, the <span class="font">copy1</span> strategy is implemented by</p>
<div class="space1">
<p class="code"><span class="font">copy1 :: Strategy1</span></p>
<p class="code"><span class="font">copy1 ms = if null ms then Rock else head ms</span></p>
</div>
<p class="para">The first move is an arbitrary choice of <span class="font">Rock</span>, The second strategy <span class="font">smart1</span> is implemented by</p>
<div class="space1">
<p class="code"><a id="text/part0013.html.page_223" class="calibre3"></a><span class="font">smart1 :: Strategy1</span></p>
<p class="code"><span class="font">smart1 ms = if null ms then Rock</span></p>
<p class="code12"><span class="font">else pick (foldr count (0,0,0) ms)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">count :: Move -&gt; (Int,Int,Int) -&gt; (Int,Int,Int)</span></p>
<p class="code"><span class="font">count Paper (p,r,s)</span><span class="space4"></span><span class="font">= (p+1,r,s)</span></p>
<p class="code"><span class="font">count Rock (p,r,s)</span><span class="space4"></span><span class="space-r"></span><span class="font">= (p,r+1,s)</span></p>
<p class="code"><span class="font">count Scissors (p,r,s)</span><span class="space"></span><span class="font">= (p,r,s+1)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">pick :: (Int,Int,Int) -&gt; Move</span></p>
<p class="code"><span class="font">pick (p,r,s)</span></p>
<p class="code8"><span class="font">| m &lt; p</span><span class="space4"></span><span class="font">= Scissors</span></p>
<p class="code8"><span class="font">| m &lt; p+r</span><span class="space5"></span><span class="font">= Paper</span></p>
<p class="code8"><span class="font">| otherwise = Rock</span></p>
<p class="code8"><span class="font">where m = rand (p+r+s)</span></p>
</div>
<p class="para">This strategy counts the number of times each move has been made, and uses the results to pick a move. The value of <span class="font">rand</span> applied to <i class="calibre1">n</i> is some integer <i class="calibre1">m</i> in the range 0 ≤ <i class="calibre1">m</i> &lt; <i class="calibre1">n</i>. (Note that <span class="font">rand</span> is never applied to the same integer.) Thus the choice of move depends on whether <i class="calibre1">m</i> falls in one of the three ranges</p>
<p class="equationasimage">0 ≤ <i class="calibre1">m</i> &lt; <i class="calibre1">p</i> or <i class="calibre1">p</i> ≤ <i class="calibre1">m</i> &lt; <i class="calibre1">p</i> + <i class="calibre1">r</i> or <i class="calibre1">p</i> + <i class="calibre1">r</i> ≤ <i class="calibre1">m</i> &lt; <i class="calibre1">p</i> + <i class="calibre1">r</i> + <i class="calibre1">s</i>.</p>
<p class="para">For example, if <i class="calibre1">p</i> is large, then <span class="font">Scissors</span> will be chosen with high probability (because scissors cuts paper); and if <i class="calibre1">r</i> is large, then <span class="font">Paper</span> will be chosen with high probability (because paper wraps rock); and so on. To define <span class="font">rand</span> we can make use of two functions in the library <span class="font">System.Random</span>:</p>
<div class="space1">
<p class="code"><span class="font">rand :: Int -&gt; Int</span></p>
<p class="code"><span class="font">rand n = fst $ randomR (0,n-1) (mkStdGen n)</span></p>
</div>
<p class="para">The function <span class="font">mkStdGen</span> takes an integer and returns a random number generator, likely to be different for different integers. The choice of argument to <span class="font">mkStdGen</span> is arbitrary, and we have simply chosen <span class="font">n</span>. The function <span class="font">randomR</span> takes a range (<i class="calibre1">a</i>, <i class="calibre1">b</i>) and a random number generator, and returns a pseudo-random integer <i class="calibre1">r</i> in the range <i class="calibre1">a</i> ≤ <i class="calibre1">r</i> ≤ <i class="calibre1">b</i> and a new random number generator.</p>
<p class="para">We can now define <span class="font">rounds1</span>:</p>
<div class="space1">
<p class="code"><span class="font">rounds1 :: (Strategy1,Strategy1) -&gt; [Round]</span></p>
<p class="code"><span class="font">rounds1 (p1,p2)</span></p>
<p class="code1"><span class="font">= map head $ tail $ iterate (extend (p1,p2)) []</span></p>
<p class="code"><span class="font">extend (p1,p2) rs = (p1 (map snd rs),p2 (map fst rs)):rs</span></p>
</div>
<p class="para"><a id="text/part0013.html.page_224" class="calibre3"></a>The function <span class="font">extend</span> adds a new pair of moves to the front of the list of existing rounds, and <span class="font">rounds1</span> generates the infinite list of rounds by repeatedly applying <span class="font">extend</span> to the initially empty list. It is more efficient to add something to the front of a list than to the end, which is why we keep the list of moves in reverse order.</p>
<p class="para">Nevertheless <span class="font">rounds1</span> is inefficient. Suppose a strategy takes time proportional to the length of its input to compute the next move. It follows that <span class="font">extend</span> takes Θ(<i class="calibre1">n</i>) steps to update a game of <i class="calibre1">n</i> rounds with a new round. Therefore, it takes Θ(<i class="calibre1">N</i><sup class="calibre8">2</sup>) steps to compute a game of <i class="calibre1">N</i> rounds.</p>
<p class="para">For comparison, let’s consider another way we might reasonably represent strategies. This time we take</p>
<p class="code"><span class="font">type Strategy2 = [Move] -&gt; [Move]</span></p>
<p class="para">In the new representation, a strategy is a function that takes the potentially infinite list of moves made by the opponent and returns the potentially infinite list of replies. For example, the copy strategy is now implemented by</p>
<div class="space1">
<p class="code"><span class="font">copy2 :: Strategy2</span></p>
<p class="code"><span class="font">copy2 ms = Rock:ms</span></p>
</div>
<p class="para">This strategy returns <span class="font">Rock</span> the first time, and thereafter returns just the move made by the opponent in the previous round. The smart strategy is reprogrammed as</p>
<div class="space1">
<p class="code"><span class="font">smart2 :: Strategy2</span></p>
<p class="code"><span class="font">smart2 ms = Rock:map pick (stats ms)</span></p>
<p class="code"><span class="space-r"></span><span class="font">where stats = tail . scanl (flip count) (0,0,0)</span></p>
</div>
<p class="para">The function <span class="font">stats</span> computes the running counts of the three possible moves. This strategy, like <span class="font">copy2</span>, is also efficient in that it produces each successive output with constant delay.</p>
<p class="para">With this new model of strategies we can redefine the function <span class="font">rounds</span>:</p>
<div class="space1">
<p class="code"><span class="font">rounds2 :: (Strategy2,Strategy2) -&gt; [Round]</span></p>
<p class="code"><span class="font">rounds2 (p1,p2) = zip xs ys</span></p>
<p class="code17"><span class="font">where xs = p1 ys</span></p>
<p class="code16"><span class="space5"></span><span class="space-r"></span><span class="font">ys = p2 xs</span></p>
</div>
<p class="para">Here, <span class="font">xs</span> is the list of replies computed by the first player in response to the list <span class="font">ys</span> which, in turn, is the list of replies made by the second player in response to the list of moves <span class="font">xs</span>. Thus <span class="font">rounds2</span> is defined by two cyclic lists and we are obliged to show that it does indeed generate an infinite list of well-defined moves. More on this below. If the two players do encapsulate legitimate strategies, then <a id="text/part0013.html.page_225" class="calibre3"></a><span class="font">rounds2</span> computes the first <i class="calibre1">n</i> moves of the game in Θ(<i class="calibre1">n</i>) steps, assuming that both players compute each new move with constant delay. Thus the second method for modelling strategies leads to a more efficient program than the earlier one.</p>
<p class="para">Unfortunately, there is a crucial flaw with the second representation of strategies: it offers no protection against someone who cheats! Consider the strategy</p>
<div class="space1">
<p class="code"><span class="font">cheat ms = map trump ms</span></p>
<p class="para1"></p>
<p class="code"><span class="font">trump Paper</span><span class="space5"></span><span class="space-r"></span><span class="font">= Scissors</span></p>
<p class="code"><span class="font">trump Rock</span><span class="space4"></span><span class="font">= Paper</span></p>
<p class="code"><span class="font">trump Scissors = Rock</span></p>
</div>
<p class="para">The first reply of <span class="font">cheat</span> is the move guaranteed to beat the opponent’s first move; similarly for subsequent moves. To see that <span class="font">cheat</span> cannot be prevented from subverting the game, consider a match in which it is played against <span class="font">copy2</span>, and let <span class="font">xs = cheat ys</span> and <span class="font">ys = copy2 xs</span>. The lists <span class="font">xs</span> and <span class="font">ys</span> are the limits of the two chains {<span class="font">xs</span><sub class="calibre11"><i class="calibre1">n</i></sub> | 0 ≤ <i class="calibre1">n</i>} and {<span class="font">ys</span><sub class="calibre11"><i class="calibre1">n</i></sub> | 0 ≤ <i class="calibre1">n</i>}, where <span class="font">xs</span><sub class="calibre11">0</sub> <span class="font">=</span> ⊥ and <span class="font">xs</span><sub class="calibre11"><i class="calibre1">n</i>+1</sub> <span class="font">= cheat ys</span><sub class="calibre11"><i class="calibre1">n</i></sub>, and <span class="font">ys</span><sub class="calibre11">0</sub> <span class="font">=</span> ⊥ and <span class="font">ys</span><sub class="calibre11"><i class="calibre1">n</i>+1</sub> <span class="font">= copy2 xs</span><sub class="calibre11"><i class="calibre1">n</i></sub>. Now, we have</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="space3"><span class="font">xs</span><sub class="calibre11">1</sub></span></td>
<td class="calibre14"><span class="font">=</span></td>
<td class="calibre14"><span class="font">cheat</span> ⊥</td>
<td class="calibre14"><span class="font">=</span></td>
<td class="calibre14">⊥</td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space3"><span class="font">ys</span><sub class="calibre11">1</sub></span></td>
<td class="calibre14"><span class="font">=</span></td>
<td class="calibre14"><span class="font">copy2</span> ⊥</td>
<td class="calibre14"><span class="font">=</span></td>
<td class="calibre14"><span class="font">Rock:</span> ⊥</td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space3"><span class="font">xs</span><sup class="calibre8">2</sup></span></td>
<td class="calibre14"><span class="font">=</span></td>
<td class="calibre14"><span class="font">cheat (Rock:</span> ⊥ <span class="font">)</span></td>
<td class="calibre14"><span class="font">=</span></td>
<td class="calibre14"><span class="font">Paper:</span> ⊥</td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space3"><span class="font">ys</span><sup class="calibre8">2</sup></span></td>
<td class="calibre14"><span class="font">=</span></td>
<td class="calibre14"><span class="font">copy2</span> ⊥</td>
<td class="calibre14"><span class="font">=</span></td>
<td class="calibre14"><span class="font">Rock:</span> 0⊥</td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space3"><span class="font">xs</span><sub class="calibre11">3</sub></span></td>
<td class="calibre14"><span class="font">=</span></td>
<td class="calibre14"><span class="font">cheat (Rock:</span> ⊥ <span class="font">)</span></td>
<td class="calibre14"><span class="font">=</span></td>
<td class="calibre14"><span class="font">Paper:</span> ⊥</td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space3"><span class="font">ys</span><sub class="calibre11">3</sub></span></td>
<td class="calibre14"><span class="font">=</span></td>
<td class="calibre14"><span class="font">copy2 (Paper:</span> ⊥ <span class="font">)</span></td>
<td class="calibre14"><span class="font">=</span></td>
<td class="calibre14"><span class="font">Rock:Paper:</span> ⊥</td>
</tr>
</tbody></table>
<p class="para">Continuing in this way, we see that the limits of these sequences are indeed infinite lists of well-defined moves. Moreover, <span class="font">cheat</span> always triumphs. Another cheating strategy is given by</p>
<p class="code"><span class="font">devious :: Int -&gt; Strategy2</span></p>
<p class="code"><span class="font">devious n ms = take n (copy2 ms) ++ cheat (drop n ms)</span></p>
<p class="para">This strategy behaves like copy for <span class="font">n</span> moves then starts to cheat.</p>
<p class="para">Can we find a way to protect against cheats? To answer this question, we need to take a closer look at what constitutes an honest strategy. Informally speaking, a strategy is honest if its first move is computed in the absence of any information about the opponent’s first move, the second move is computed without any information about the opponent’s second move, and so on. Moreover, each of these moves should be well-defined, given that the opponent’s moves are well-defined. More precisely, let <i class="calibre1">wdf</i> (<i class="calibre1">n</i>, <i class="calibre1">ms</i>) denote the assertion that the first <i class="calibre1">n</i> elements in the <a id="text/part0013.html.page_226" class="calibre3"></a>(possibly partial) list of moves <i class="calibre1">ms</i> are well-defined. Then a strategy <i class="calibre1">f</i> is <i class="calibre1">honest</i> if</p>
<p class="equationasimage"><i class="calibre1">wdf</i> (<i class="calibre1">n</i>, <i class="calibre1">ms</i>) ⇒ <i class="calibre1">wdf</i> (<i class="calibre1">n</i>+1, <i class="calibre1">f</i> (<i class="calibre1">ms</i>))</p>
<p class="para">for all <i class="calibre1">n</i> and <i class="calibre1">ms</i>. It is easy to show that <span class="font">copy2</span> is honest. On the other hand, <span class="font">cheat</span> is not honest because <i class="calibre1">wdf</i> (0, ⊥) is true but <i class="calibre1">wdf</i> (1, <span class="font">cheat</span> ⊥) is false. The strategy <span class="font">dozy</span>, where</p>
<p class="code"><span class="font">dozy ms = repeat undefined</span></p>
<p class="para">is also dishonest according to this definition although it doesn’t actually cheat.</p>
<p class="para">Having identified the source of criminal or lackadaisical behaviour, can we ensure that only honest strategies are admitted to the game? The answer is a qualified yes: although it is not possible for a mechanical evaluator to recognise cheating (in the same way that it is not possible to recognise ⊥, or strategies that do not return well-defined moves), it is possible to define a function <span class="font">police</span> so that if <span class="font">p</span> is an honest player and <span class="font">ms</span> is an infinite sequence of well-defined moves, then <span class="font">police p ms = p ms</span>. On the other hand, if <span class="font">p</span> is dishonest at some point, then the game ends at that point in ⊥. Operationally speaking, <span class="font">police</span> works by forcing <span class="font">p</span> to return the first (well-defined!) element of its output before it gives <span class="font">p</span> the first element of its input. Similarly for the other elements. The definition is</p>
<div class="space1">
<p class="code"><span class="font">police p ms = ms' where ms' = p (synch ms ms')</span></p>
<p class="code"><span class="font">synch (x:xs) (y:ys) = (y `seq` x):synch xs ys</span></p>
</div>
<p class="para">Recall from <a href="#text/part0011.html.AFM60-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 7</a> that <span class="font">x `seq` y</span> evaluates <span class="font">x</span> before returning the value of <span class="font">y</span>. The proof that this implementation meets its specification is rather involved, so we are not going into details. It follows from the above analysis that to prevent cheating we must rewrite the definition of <span class="font">rounds2</span> to read</p>
<div class="space1">
<p class="code"><span class="font">rounds2 (p1,p2) = zip xs ys</span></p>
<p class="code5"><span class="space-r"></span><span class="font">where xs = police p1 ys</span></p>
<p class="code16"><span class="space4"></span><span class="font">ys = police p2 xs</span></p>
</div>
<h3 class="h" id="text/part0013.html.head9-5">9.5 Stream-based interaction</h3>
<p class="para">In the paper–rock–scissors game we modelled interaction by a function that took an infinite list of moves and returned a similar list. The same idea can be used to provide a simple model of input–output interaction. It’s called <i class="calibre1">stream-based</i> interaction because infinite lists are also called streams. Haskell provides a function</p>
<p class="code"><span class="font">interact :: ([Char] -&gt; [Char]) -&gt; IO ()</span></p>
<p class="para"><a id="text/part0013.html.page_227" class="calibre3"></a>for interacting with the world. The argument to <span class="font">interact</span> is a function that takes a potentially infinite list of characters from the standard input channel, and returns a potentially infinite list of characters to be typed on the standard output channel.</p>
<p class="para">For example,</p>
<p class="code6"><span class="font">ghci&gt; import Data.Char</span></p>
<p class="code6"><span class="font">ghci&gt; interact (map toUpper)</span></p>
<p class="code6"><span class="font">hello world!</span></p>
<p class="code6"><span class="font">HELLO WORLD!</span></p>
<p class="code6"><span class="font">Goodbye, cruel world!</span></p>
<p class="code6"><span class="font">GOODBYE, CRUEL WORLD!</span></p>
<p class="code6"><span class="font">{Interrupted}</span></p>
<p class="para">We imported the library <span class="font">Data.Char</span> to make <span class="font">toUpper</span> available, and then created an interaction that capitalised each letter. Each time a line of input was typed (and echoed) the interaction produced the same line in capital letters. The process continues until we interrupt it.</p>
<p class="para">We can also design an interactive program that terminates. For example,</p>
<p class="code"><span class="font">interact (map toUpper . takeWhile (/= '.'))</span></p>
<p class="para">will interact as above but terminate as soon as a line containing a period is typed:</p>
<p class="code6"><span class="font">ghci&gt; interact (map toUpper . takeWhile (/= '.'))</span></p>
<p class="code6"><span class="font">Goodbye. Forever</span></p>
<p class="code6"><span class="font">GOODBYE</span></p>
<p class="para">Finally, here is a stand-alone program that takes a literate Haskell file as input and returns a file in which all nonempty lines not beginning with <span class="font">&gt;</span> are removed. The remaining lines are modified by removing the <span class="font">&gt;</span> character, so the result is a legitimate <span class="font">.hs</span> file (a Haskell script not using the literate style):</p>
<div class="space1">
<p class="code"><span class="font">main</span><span class="space5"></span><span class="space-r"></span><span class="font">= interact replace</span></p>
<p class="code"><span class="font">replace = unlines . map cleanup . filter code . lines</span></p>
<p class="code"><span class="font">code xs = null xs || head xs == '&gt;'</span></p>
<p class="code"><span class="font">cleanup xs = if null xs then [] else tail xs</span></p>
</div>
<p class="para">The program is the computation associated with the identifier <span class="font">main</span>, and there always has to be a definition associated with this name if we want to compile a program. The function <span class="font">lines</span> splits a text into lines, and <span class="font">unlines</span> reassembles the text by putting a single newline between lines. If we store the program in <span class="font">lhs2hs.lhs</span>, we can compile it and then run it:</p>
<p class="code6"><a id="text/part0013.html.page_228" class="calibre3"></a><span class="font">$ ghc lhs2hs.lhs</span></p>
<p class="code6"><span class="font">$ lhs2hs &lt;myscript.lhs &gt;myscript.hs</span></p>
<p class="para">In the second line, the input is taken from <span class="font">myscript.lhs</span> and the output is directed to <span class="font">myscript.hs</span>.</p>
<p class="para">Stream-based interaction was the main method for interacting with the outside world in early versions of Haskell. However, the model presented above is too simple for most practical purposes. In a serious application one wants to do other things than reading and printing characters to a screen. For example, one also wants to open and read files, to write to or delete files, and in general to interact with all the mechanisms that are available in the world outside the confines of a functional programming language. Interaction takes place in time, and the order in which events occur has to be managed correctly by the programmer. In the stream-based approach, this ordering of events is represented by the order of the elements in a list; in other words, it is represented in the data and not reflected primarily in the way the program is composed. In the following chapter we will consider another approach to interaction, indeed, a general method for writing programs that have to control an orderly sequence of events. In this approach, the order is made explicit in the way the program is composed.</p>
<h3 class="h" id="text/part0013.html.head9-6">9.6 Doubly-linked lists</h3>
<p class="para">We end with another application of cyclic lists. Imagine reading a book consisting of a nonempty list of pages. To navigate around the book we need some way of moving on to the next page and moving back to the previous page. Other navigation tools would be useful, but we’ll stick with these two. Here is an interactive session with a particularly boring book <span class="font">book</span> consisting of three pages:</p>
<p class="code6"><span class="font">ghci&gt; start book</span></p>
<p class="code6"><span class="font">"Page 1"</span></p>
<p class="code6"><span class="font">ghci&gt; next it</span></p>
<p class="code6"><span class="font">"Page 2"</span></p>
<p class="code6"><span class="font">ghci&gt; prev it</span></p>
<p class="code6"><span class="font">"Page 1"</span></p>
<p class="code6"><span class="font">ghci&gt; next it</span></p>
<p class="code6"><span class="font">"Page 2"</span></p>
<p class="code6"><span class="font">ghci&gt; next it</span></p>
<p class="code6"><span class="font">"Page 3"</span></p>
<p class="para"><a id="text/part0013.html.page_229" class="calibre3"></a>In GHCi the variable <span class="font">it</span> is bound to the expression just typed at the prompt. We started a book and what was printed was the first page. We turned to the next page, and then returned to the previous one. The interesting question is what should happen when we turn to the next page after the last one. Should the navigation report an error, just deliver the last page again or go to the first page? Suppose we decide on the last alternative, namely that the next page after the last one should be the first page, and the previous page before the first one should be the last page. In other words, our book is an instance of a <i class="calibre1">cyclic doubly-linked list</i>.</p>
<p class="para">Here is the relevant datatype declaration:</p>
<div class="space1">
<p class="code"><span class="font">data DList a = Cons a (DList a) (DList a)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">elem :: DList a -&gt; a</span></p>
<p class="code"><span class="font">elem (Cons a p n) = a</span></p>
<p class="para1"></p>
<p class="code"><span class="font">prev,next :: DList a -&gt; DList a</span></p>
<p class="code"><span class="font">prev (Cons a p n) = p</span></p>
<p class="code"><span class="font">next (Cons a p n) = n</span></p>
</div>
<p class="para">We print a doubly-linked list by displaying the current entry:</p>
<div class="space1">
<p class="code"><span class="font">instance Show a =&gt; Show (DList a)</span></p>
<p class="code"><span class="font">where show d = show (elem d)</span></p>
</div>
<p class="para">Our book is then a list <span class="font">[p1,p2,p3]</span> of three pages, where</p>
<div class="space1">
<p class="code"><span class="font">p1 = Cons "Page 1" p3 p2</span></p>
<p class="code"><span class="font">p2 = Cons "Page 2" p1 p3</span></p>
<p class="code"><span class="font">p3 = Cons "Page 3" p2 p1</span></p>
</div>
<p class="para">This example suggests that the function <span class="font">mkCDList :: [a] -&gt; DList a</span> for converting a (nonempty) list <span class="font">as</span> into a doubly-linked list can be specified as the first element in a finite list <span class="font">xs</span> of doubly-linked lists satisfying the following three properties:</p>
<div class="space1">
<p class="code"><span class="font">map elem xs = as</span></p>
<p class="code"><span class="font">map prev xs = rotr xs</span></p>
<p class="code"><span class="font">map next xs = rotl xs</span></p>
</div>
<p class="para">Here, <span class="font">rotr</span> and <span class="font">rotl</span> (short for <i class="calibre1">rotate right</i> and <i class="calibre1">rotate left</i>), are defined by</p>
<div class="space1">
<p class="code"><span class="font">rotr xs = [last xs] ++ init xs</span></p>
<p class="code"><span class="font">rotl xs = tail xs ++ [head xs]</span></p>
</div>
<p class="para"><a id="text/part0013.html.page_230" class="calibre3"></a>Observe now that for any list <span class="font">xs</span> of doubly-linked lists we have</p>
<div class="space1">
<p class="code"><span class="font">xs = zipWith3 Cons</span></p>
<p class="code8"><span class="font">(map elem xs) (map prev xs) (map next xs)</span></p>
</div>
<p class="para">where <span class="font">zipWith3</span> is like <span class="font">zipWith</span> except that it takes three lists instead of two. The standard prelude definition is:</p>
<div class="space1">
<p class="code"><span class="font">zipWith3 f (x:xs) (y:ys) (z:zs)</span></p>
<p class="code11"><span class="font">= f x y z : zipWith3 f xs ys zs</span></p>
<p class="code"><span class="font">zipWith3 _ _ _ _ = []</span></p>
</div>
<p class="para">We will see another definition in a moment. We can prove the claim above by induction. It clearly holds for the undefined and empty lists. For the inductive case we reason:</p>
<div class="space1">
<p class="code11"><span class="font">x:xs</span></p>
<p class="code2"><span class="font">=</span><span class="space5"></span>{since <span class="font">xs</span> is a doubly-linked list}</p>
<p class="code11"><span class="font">Cons (elem x) (prev x) (next x):xs</span></p>
<p class="code2"><span class="font">=</span><span class="space5"></span>{induction}</p>
<p class="code11"><span class="font">Cons (elem x) (prev x) (next x):</span></p>
<p class="code11"><span class="font">(zipWith3 Cons</span></p>
<p class="code11"><span class="font">(map elem xs) (map prev xs) (map next xs))</span></p>
<p class="code2"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">zipWith3</span> and <span class="font">map</span>}</p>
<p class="code11"><span class="font">zipWith3 Cons</span></p>
<p class="code11"><span class="font">(map elem (x:xs)) (map prev (x:xs)) (map next (x:xs)</span></p>
</div>
<p class="para">Putting this result together with our specification of doubly-linked lists, we arrive at</p>
<div class="space1">
<p class="code"><span class="font">mkCDList as = head xs</span></p>
<p class="code2"><span class="font">where xs = zipWith3 Cons as (rotr xs) (rotl xs)</span></p>
</div>
<p class="para">This definition involves a cyclic list <span class="font">xs</span>. Does it work? The answer is: No, it doesn’t. The reason is that <span class="font">zipWith3</span> as defined above is too eager. We need to make it lazier by not demanding the values of the second two lists until they are really needed:</p>
<div class="space1">
<p class="code"><span class="font">zipWith3 f (x:xs) ys zs</span></p>
<p class="code11"><span class="font">= f x (head ys) (head zs):</span></p>
<p class="code8"><span class="font">zipWith3 f xs (tail ys) (tail zs)</span></p>
<p class="code"><span class="font">zipWith3 _ _ _ _ = []</span></p>
</div>
<p class="para"><a id="text/part0013.html.page_231" class="calibre3"></a>An equivalent way to define this function is to make use of Haskell’s <i class="calibre1">irrefutable patterns</i>:</p>
<div class="space1">
<p class="code"><span class="font">zipWith3 f (x:xs) ~(y:ys) ~(z:zs)</span></p>
<p class="code11"><span class="font">= f x y z : zipWith3 f xs ys zs</span></p>
<p class="code"><span class="font">zipWith3 _ _ _ _ = []</span></p>
</div>
<p class="para">An irrefutable pattern is introduced using a tilde, and <span class="font">~(x:xs)</span> is matched lazily, meaning that no matching is actually performed until either <span class="font">x</span> or <span class="font">xs</span> is needed. Just to convince ourselves that the above definition of <span class="font">mkCDList</span> with the revised definition of <span class="font">zipWith3</span> does make progress, let <span class="font">xs</span><sub class="calibre11">0</sub> =⊥ and</p>
<p class="code"><span class="font">xs</span><sub class="calibre11"><i class="calibre1">n</i>+1</sub> <span class="font">= zipWith3 Cons "A" (rotr xs</span><sub class="calibre11"><i class="calibre1">n</i></sub><span class="font">) (rotl xs</span><sub class="calibre11"><i class="calibre1">n</i></sub><span class="font">)</span></p>
<p class="para">Then <span class="font">xs</span><sub class="calibre11">1</sub> is given by</p>
<div class="space1">
<p class="code11"><span class="font">zipWith3 Cons "A"</span> ⊥ ⊥</p>
<p class="code2"><span class="font">= [Cons ’A’</span> ⊥ ⊥<span class="font">]</span></p>
</div>
<p class="para">and <span class="font">xs</span><sup class="calibre8">2</sup> by</p>
<div class="space1">
<p class="code2"><span class="font">zipWith3 Cons "A"</span></p>
<p class="code2"><span class="font">[Cons ’A’</span> ⊥ ⊥<span class="font">] [Cons ’A’</span> ⊥ ⊥<span class="font">]</span></p>
<p class="code"><span class="font">= [Cons ’A’ (Cons ’A’</span> ⊥ ⊥<span class="font">) (Cons ’A’</span> ⊥ ⊥<span class="font">)]</span></p>
</div>
<p class="para">and so on.</p>
<h3 class="h" id="text/part0013.html.head9-7">9.7 Exercises</h3>
<p class="theorem"><b class="calibre7">Exercise A</b></p>
<p class="para">Given three lists <span class="font">xs</span>, <span class="font">ys</span> and <span class="font">zs</span> in strictly increasing order, we have</p>
<p class="code"><span class="font">merge (merge xs ys) zs} = merge xs (merge ys zs)</span></p>
<p class="para">Thus <span class="font">merge</span> is associative. Assuming in addition that the first elements of <span class="font">xs</span>, <span class="font">ys</span> and <span class="font">zs</span> are in strictly increasing order, we also have</p>
<p class="code"><span class="font">xmerge (xmerge xs ys) zs = xmerge xs (xmerge ys zs)</span></p>
<p class="para">Does it follow that in the expression <span class="font">foldr1 xmerge multiples</span> we could replace <span class="font">foldr1</span> by <span class="font">foldl1</span>?</p>
<p class="theorem"><a id="text/part0013.html.page_232" class="calibre3"></a><b class="calibre7">Exercise B</b></p>
<p class="para">The standard prelude function <span class="font">cycle :: [a] -&gt; [a]</span> takes a list <span class="font">xs</span> and returns a list consisting of an infinite number of repetitions of the elements of <span class="font">xs</span>. If <span class="font">xs</span> is the empty list, then <span class="font">cycle []</span> returns an error message. For instance</p>
<p class="code"><span class="font">cycle "hallo" = "hallohallohallo...</span></p>
<p class="para">Define <span class="font">cycle</span> using a cyclic list. Ensure that your definition works on empty, finite and infinite lists.</p>
<p class="theorem"><b class="calibre7">Exercise C</b></p>
<p class="para">The fibonacci function is defined by</p>
<div class="space1">
<p class="code"><span class="font">fib 0 = 0</span></p>
<p class="code"><span class="font">fib 1 = 1</span></p>
<p class="code"><span class="font">fib n = fib (n-1) + fib (n-2)</span></p>
</div>
<p class="para">Write down a one-line definition of the list <span class="font">fibs</span> that produces the infinite list of Fibonacci numbers.</p>
<p class="theorem"><b class="calibre7">Exercise D</b></p>
<p class="para">A well-known problem, due to the mathematician W.R. Hamming, is to write a program that produces an infinite list of numbers with the following properties: (i) the list is in strictly increasing order; (ii) the list begins with the number 1; (iii) if the list contains the number <i class="calibre1">x</i>, then it also contains the numbers 2<i class="calibre1">x</i>, 3<i class="calibre1">x</i> and 5<i class="calibre1">x</i>; (iv) the list contains no other numbers. Thus, the required list begins with the numbers</p>
<p class="equationasimage">1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, . . .</p>
<p class="para">Write a definition of <span class="font">hamming</span> that produces this list.</p>
<p class="theorem"><b class="calibre7">Exercise E</b></p>
<p class="para">Prove that <span class="font">approx n xs</span> ⊑ <span class="font">xs</span> for all <span class="font">n</span>. Now prove that if <span class="font">approx n xs</span> ⊑ <span class="font">ys</span> for all <span class="font">n</span>, then <span class="font">xs</span> ⊑ <span class="font">ys</span>. Hence conclude that</p>
<p class="equationasimage"><img src="data:image/jpeg;base64,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" alt="image" class="calibre2"></p>
<p class="theorem"><b class="calibre7">Exercise F</b></p>
<p class="para">Give a counter-example to the claim that <span class="font">xs=ys</span> if <span class="font">xs!!n=ys!!n</span> for all <span class="font">n</span>.</p>
<p class="theorem"><a id="text/part0013.html.page_233" class="calibre3"></a><b class="calibre7">Exercise G</b></p>
<p class="para">Prove that <span class="font">iterate f x = x: map f (iterate f x)</span>.</p>
<p class="theorem"><b class="calibre7">Exercise H</b></p>
<p class="para">In the definition of <span class="font">primes</span> as a cyclic list, could we have defined</p>
<p class="code"><span class="font">mergeAll = foldr xmerge []</span></p>
<p class="para">as an alternative to the definition in the text?</p>
<p class="theorem"><b class="calibre7">Exercise I</b></p>
<p class="para">Recall that</p>
<div class="space1">
<p class="code"><span class="font">prs n = approx n (2:([3..] \\ crs n))</span></p>
<p class="code"><span class="font">crs n = mergeAll [map (p*) [p..] | p &lt;- prs n]</span></p>
</div>
<p class="para">Given that <span class="font">prs n=</span><i class="calibre1">p</i><sub class="calibre11">1</sub> : <i class="calibre1">p</i><sup class="calibre8">2</sup> : · · · <i class="calibre1">p</i><sub class="calibre11"><i class="calibre1">n</i></sub> :⊥, where <i class="calibre1">p</i><sub class="calibre11"><i class="calibre1">j</i></sub> is the <i class="calibre1">j</i>th prime, sketch how to show that <span class="font">crs n=</span><i class="calibre1">c</i><sub class="calibre11">1</sub> : <i class="calibre1">c</i><sup class="calibre8">2</sup> : · · · <i class="calibre1">c</i><sub class="calibre11"><i class="calibre1">m</i></sub> :⊥, where <i class="calibre1">c</i><sub class="calibre11"><i class="calibre1">j</i></sub> is the <i class="calibre1">j</i>th composite number (so <i class="calibre1">c</i><sub class="calibre11">1</sub> <span class="font">=</span>4) and Hence show that <span class="font">primes</span> does produce the infinite list of primes. We said in the text that it is not the case that the <i class="calibre1">n</i>th approximation <span class="font">primes</span><sub class="calibre11"><i class="calibre1">n</i></sub> of <span class="font">primes</span> is equal to <span class="font">approx n primes</span>. In fact &nbsp;<img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEBLAEsAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAYADIDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6porxbxrr19H4n+IV7HqV9b6LoOiRwvHDOyhrx1aRQmPutgxAsOeccZNS6CfEUfi3RNMv9W1KXULPwu0+oRJcLtkuJCqQqAw2eYDHK29gST144oA9korxzSrfxyuo2TXMPjryfOTzPO1DR2QLuGdwVNxXGc7ecdOazvE2oXlxYfFHWU1jVore3uF0vRra3u5EIvUjVcoFOTumkC7RwdpyD2AO68ZW+tQa3pN5pes3Qu5b+KGPTkVfs722R5xkUjcSE3tvBGDtA6891XEf8Iq13dWuoav4i1a31RoLeO6gtrxY4WdQMqF25AZs5wRnP0rtVdCzIrKWXGVB5HpmgB1FFFAGNP4W0S4tNQtZ9Nt5Le/uVvLpGBImmUqQ7epBRP8AvkVOmhaYmvy62tnGNVlhWB7jncUXOB6cZPPXmiigC/cNIkEjQxiWUKSiFtu444Ge31riPht4M/sbw5YDxBbwza7Hcz3s8okMifaJZGZpEzwDhsZwDj9SigDI8ReC9T1XxDquoy2lvMl7qOnwqjSAGOytyJGcH++0hYY6helegWWiadY6vqOq2lpHFqGo+X9rnXO6by12pn6AkUUUAaNFFFAH/9k=" alt="image" class="calibre2"></p>
<p class="equationasimage"><span class="font">primes</span><sub class="calibre11">4</sub> <span class="font">=</span> 2 : 3 : 5 : 7 : · · · : 47 :⊥</p>
<p class="para">What list does <span class="font">primes</span><sub class="calibre11">5</sub> produce?</p>
<p class="theorem"><b class="calibre7">Exercise J</b></p>
<p class="para">Another way of generating the primes is known as the <i class="calibre1">Sieve of Sundaram</i>, after its discoverer S.P. Sundaram in 1934:</p>
<div class="space1">
<p class="code"><span class="font">primes = 2:[2*n+1 | n &lt;- [1..] \\ sundaram]</span></p>
<p class="code"><span class="font">sundaram = mergeAll [[i+j+2*i*j | j &lt;- [i..]] | i &lt;- [1..]]</span></p>
</div>
<p class="para">To show that the list comprehension in the definition of <span class="font">primes</span> generates exactly the odd primes, it is sufficient to prove that the term <span class="font">2*n+1</span> is never composite, which is to say that it never factorises into <span class="font">(2*i+1)*(2*j+1)</span> for positive integers <span class="font">i</span> and <span class="font">j</span>. Why is this so?</p>
<p class="theorem"><b class="calibre7">Exercise K</b></p>
<p class="para">Is the function <i class="calibre1">f</i> , defined by <i class="calibre1">f</i> (⊥) =0 and <i class="calibre1">f</i> (<i class="calibre1">x</i>) =1 for <i class="calibre1">x</i> ≠⊥, computable? How about the function that returns ⊥ on all finite or partial lists, and 1 on all infinite lists?</p>
<p class="theorem"><a id="text/part0013.html.page_234" class="calibre3"></a><b class="calibre7">Exercise L</b></p>
<p class="para">By definition, a <i class="calibre1">torus</i> is a doubly-cyclic, doubly-doubly-linked list. It is a cyclic doubly-linked list in the left/right direction, and also in the up/down direction. Given a matrix represented as a list of length <i class="calibre1">m</i> of lists, all of length <i class="calibre1">n</i>, construct a definition of</p>
<p class="code"><span class="font">mkTorus :: Matrix a -&gt; Torus a</span></p>
<p class="para">where</p>
<div class="space1">
<p class="code"><span class="font">data Torus a = Cell a (Torus a) (Torus a)</span></p>
<p class="code16"><span class="space"></span><span class="font">(Torus a) (Torus a)</span></p>
<p class="code"><span class="font">elem (Cell a u d l r) = a</span></p>
<p class="code"><span class="font">up (Cell a u d l r) = u</span></p>
<p class="code"><span class="font">down (Cell a u d l r) = d</span></p>
<p class="code"><span class="font">left (Cell a u d l r) = l</span></p>
<p class="code"><span class="font">right (Cell a u d l r) = r</span></p>
</div>
<p class="para">That looks tricky, but the answer is short enough to be tweeted.</p>
<h3 class="h" id="text/part0013.html.head9-8">9.8 Answers</h3>
<p class="theorem"><b class="calibre7">Answer to Exercise A</b></p>
<p class="para">No, since <span class="font">foldl1 f xs = undefined</span> for any infinite list <span class="font">xs</span>.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise B</b></p>
<p class="para">The definition is</p>
<div class="space1">
<p class="code"><span class="font">cycle [] = error "empty list"</span></p>
<p class="code"><span class="font">cycle xs = ys where ys = xs ++ ys</span></p>
</div>
<p class="para">Note that if <span class="font">xs</span> is infinite, then <span class="font">xs ++ ys</span> = <span class="font">xs</span>, so <span class="font">cycle</span> is the identity function on infinite lists.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise C</b></p>
<p class="para">The one-liner is:</p>
<div class="space1">
<p class="code"><span class="font">fibs :: [Integer]</span></p>
<p class="code"><span class="font">fibs = 0:1:zipWith (+) fibs (tail fibs)</span></p>
</div>
<p class="theorem"><a id="text/part0013.html.page_235" class="calibre3"></a><b class="calibre7">Answer to Exercise D</b></p>
<div class="space1">
<p class="code"><span class="font">hamming :: [Integer]</span></p>
<p class="code"><span class="font">hamming = 1: merge (map (2*) hamming)</span></p>
<p class="code12"><span class="space"></span><span class="font">(merge (map (3*) hamming)</span></p>
<p class="code16"><span class="font">(map (5*) hamming))</span></p>
</div>
<p class="theorem"><b class="calibre7">Answer to Exercise E</b></p>
<p class="para">The proof of <span class="font">approx n xs</span> ⊑ <span class="font">xs</span> is by induction on <span class="font">n</span>. The base case is easy but the induction step involves a sub-induction over <span class="font">xs</span>. The base cases (the empty list and the undefined list) of the sub-induction are easy and the inductive case is</p>
<div class="space1">
<p class="code10"><span class="font">approx (n+1) (x:xs)</span></p>
<p class="code1"><span class="font">=</span><span class="space5"></span>{definition}</p>
<p class="code10"><span class="font">x:approx n xs</span></p>
<p class="code1">⊑<span class="space5"></span>{induction and monotonicity of <span class="font">(x:)</span>}</p>
<p class="code10"><span class="font">x:xs</span>.</p>
</div>
<p class="para">The proof of</p>
<p class="equationasimage">(∀<span class="font">n</span> : <span class="font">approx n xs</span> ⊑ <span class="font">ys</span>) ⇒ <span class="font">xs</span> ⊑ <span class="font">ys</span></p>
<p class="para">is by induction on <span class="font">xs</span>. The claim is immediate for the undefined and empty lists, and for the inductive case we have</p>
<p class="equationasimage">(∀<span class="font">n</span> : <span class="font">approx n (x:xs)</span> ⊑ <span class="font">ys</span>)</p>
<p class="equationasimage">⇒ <span class="font">xs</span> ⊑ <span class="font">head ys</span> ∧ (∀<span class="font">n</span> : <span class="font">approx n xs</span> ⊑ <span class="font">tail ys</span>)</p>
<p class="para">by the definitions of <span class="font">approx</span> and the approximation ordering on lists. By induction we therefore have</p>
<p class="equationasimage"><span class="font">x:xs</span> ⊑ <span class="font">head ys:tail ys</span> = <span class="font">ys</span>.</p>
<p class="para">It follows that</p>
<p class="equationasimage"><img src="data:image/jpeg;base64,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" alt="image" class="calibre2"></p>
<p class="para">by the definition of limit.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise F</b></p>
<p class="para">The two lists <span class="font">repeat undefined</span> and <span class="font">undefined</span> are not equal, but</p>
<p class="equationasimage"><span class="font">(repeat undefined)!!n = undefined!!n</span></p>
<p class="para">for all <span class="font">n</span> because both sides are ⊥.</p>
<p class="theorem"><a id="text/part0013.html.page_236" class="calibre3"></a><b class="calibre7">Answer to Exercise G</b></p>
<p class="para">We have to show that</p>
<p class="code"><span class="font">approx n (iterate f x) = approx n (x:map f (iterate f x))</span></p>
<p class="para">for all natural numbers <span class="font">n</span>. This claim follows from</p>
<p class="code"><span class="font">approx n (iterate f (f x))</span></p>
<p class="code16"><span class="font">= approx n (map f (iterate f x))</span></p>
<p class="para">which we establish by induction on <span class="font">n</span>. For the inductive step we simplify each side. For the left-hand side:</p>
<div class="space1">
<p class="code3"><span class="font">approx (n+1) (iterate f (f x))</span></p>
<p class="code8"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">iterate</span>}</p>
<p class="code3"><span class="font">approx (n+1) (f x:iterate f (f (f x)))</span></p>
<p class="code8"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">approx</span>}</p>
<p class="code3"><span class="font">f x: approx n (iterate f (f (f x)))</span></p>
<p class="code8"><span class="font">=</span><span class="space5"></span>{induction}</p>
<p class="code3"><span class="font">f x: approx n (map f (iterate f (f x)))</span></p>
</div>
<p class="para">For the right-hand side:</p>
<p class="code3"><span class="font">approx (n+1) (map f (iterate f x))</span></p>
<p class="code8"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">iterate</span> and <span class="font">map</span>}</p>
<p class="code3"><span class="font">approx (n+1) (f x:map f (iterate f (f x)))</span></p>
<p class="code8"><span class="font">=</span><span class="space5"></span>{definition of <span class="font">approx</span>}</p>
<p class="code3"><span class="font">f x: approx n (map f (iterate f (f x)))</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise H</b></p>
<p class="para">Yes, since</p>
<p class="code"><span class="font">foldr xmerge [] (xs:undefined) = xmerge xs undefined</span></p>
<p class="para">and the right-hand side begins with the first element of <span class="font">xs</span>.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise I</b></p>
<p class="para">The proof is by induction. We have first to show that <span class="font">crs (n+1)</span> is the result of merging <i class="calibre1">c</i><sub class="calibre11">1</sub> : <i class="calibre1">c</i><sup class="calibre8">2</sup> : · · · <i class="calibre1">c</i><sub class="calibre11"><i class="calibre1">m</i></sub> :⊥, where&nbsp;<img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEBLAEsAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAaAEIDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6poorz+7+KWl2sOpyyWGoeVpuqJpVy4CYR2ZF3/e5UM4HHzcNxgUAegUVz3hvxVba7rOt6bDaXdvPpTQiQzqAHEqb1K4JI45wcEAjI5q5rPiDTdGlij1GaSN5VLKEgkkyB7qpx+NAGrRXOR+NtBkkRFupyzsFH+hzDknA/gromJCkgFiBwB3oAUkAEk4ArnNG8Y6Vq2tyaVb/AGuO6ERnhNxbPEl1ECAzwsww6gsuceoPQ5rA0z4oWF/a6JdtpOpQ6bq2oPpcV1IIyi3AZ1UEBiSrFGAYAjOAan0TU49Z8bLdz6RrdvLbwy2tp9p094YYo9wLuXYY3OUTAH8Kj1OADu6KKKAEYkKSoyQOB615Jo/w91UaR4SstVjtXI1qbXtddJM+ZOfMeNQMfOA7Rg9OIxXrlFAHG/D7RtV0vUPFN1rEUKPqWrTXUbrJvZ4sKkX+6BGijHJzmuh1XTZ76SNodVv7EICCtt5eG9zvRv0rRooAwU0G7V1Y+JNZYAg7T9nwfY/uulR/ETW/+Eb8C69q6ttltbOR4veXbhB+LFR+NdFWB42srXUNIS2v7aC6t2mUtFPGHQkZIJB44IB+ooA5Lwx4IvBaeCrHU4I7TSvDMEcq2wcO1zeiPZ5jEcBV3SMOclmB4A5veEfHF94g1TTYlsLZbO8F9IJUmYt5MEwjjlCkfdcnoee4yK7EcaLx/wA+/wD7LXH+GbC0t/Enh8wWsERj8PJGhSMLtQMnyjA4HtQB3tFFFAH/2Q==" alt="image" class="calibre2"> with the infinite list of multiples <a id="text/part0013.html.page_237" class="calibre3"></a><i class="calibre1">p</i><sub class="calibre11"><i class="calibre1">n</i>+1</sub> <i class="calibre1">p</i><sub class="calibre11"><i class="calibre1">n</i>+1</sub>, <i class="calibre1">p</i><sub class="calibre11"><i class="calibre1">n</i>+1</sub> (<i class="calibre1">p</i><sub class="calibre11"><i class="calibre1">n</i>+1</sub> +1), . . . of <i class="calibre1">p</i><sub class="calibre11"><i class="calibre1">n</i>+1</sub>. That gives the partial list of all composite numbers up to&nbsp;<img src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEBLAEsAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAaACcDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD6prifiW+v2ek3Oo6Hq32Oa2VPslolukv2yctgRSbgTtbhRsIIyTnjFZmvXE9/8VZrM6te2OhaXobXWpeTcNGhaSQiPJH3SFjkbcMHGKz/AIf6N4k8SeBfDWq6j4m1SyvVgkaLfBBK7RvI3lSvvQ/vPK2DPue5JoA9YQsUUuAGxyAc4NLUKtHaW8KTTZA2xB5WGXY4AyfUn9TVTxFrVj4d0e41TVpWhsrcAyOqM5GSAOFBPUigDRooooA898O+EJb3XvGOo+KrAbdVvYvKgM++OS1hjCxB1Bwfm3sVOR83eqHxKtNevNT1iXTIdSNnaaKbaGO2d1+0XM8mNyhTz5Sru45+b616jRQByniS11NbOxWC9h8lbq0VRPbtJJkSKMswcAnPJ4/xql8UbPUrn4Ya9a7TqF/NFtjjtLdgz/MuAFyxJ6967iigDJ1TQdL1q90vUL+2M1xp7PJaOXdPLLoUY4BGcqSOQcUVrUUAf//ZAAA=" alt="image" class="calibre2"> Finally, we need the result that&nbsp;<img src="data:image/jpeg;base64,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" alt="image" class="calibre2"> The partial list <span class="font">primes</span><sub class="calibre11">5</sub> produces all the primes smaller than 2209 = 47 × 47.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise J</b></p>
<p class="para">Because an odd integer is excluded from the final list if it takes the form 2<i class="calibre1">n</i> + 1 where <i class="calibre1">n</i> is of the form <i class="calibre1">i</i>+<i class="calibre1">j</i>+2<i class="calibre1">ij</i>. But</p>
<p class="equationasimage">2(<i class="calibre1">i</i>+<i class="calibre1">j</i>+2<i class="calibre1">ij</i>)+1 =(2<i class="calibre1">i</i>+1)(2<i class="calibre1">j</i>+1).</p>
<p class="theorem"><b class="calibre7">Answer to Exercise K</b></p>
<p class="para">No, <i class="calibre1">f</i> is not monotonic: ⊥⊑ 1 but <i class="calibre1">f</i> (⊥) ⋢ <i class="calibre1">f</i> (1). For the second function (call it <i class="calibre1">g</i>) we have <span class="font">xs</span> ⊑ <span class="font">ys</span> implies <i class="calibre1">g</i>(<span class="font">xs</span>) ⊑ <i class="calibre1">g</i>(<span class="font">ys</span>), so <i class="calibre1">g</i> is monotonic. But <i class="calibre1">g</i> is not continuous, so it’s not computable.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise L</b></p>
<p class="para">The definition is</p>
<div class="space1">
<p class="code"><span class="font">mkTorus ass = head (head xss)</span></p>
<p class="code"><span class="space"></span><span class="font">where xss = zipWith5 (zipWith5 Cell)</span></p>
<p class="code9"><span class="font">ass (rotr xss) (rotl xss)</span></p>
<p class="code9"><span class="font">(map rotr xss) (map rotl xss)</span></p>
</div>
<p class="para">Whereas <span class="font">rotr</span> and <span class="font">rotl</span> rotate the rows of a matrix, <span class="font">map rotr</span> and <span class="font">map rotl</span> rotate the columns. The definition of <span class="font">zipWith5</span> has to be made non-strict in its last four arguments.</p>
<h3 class="h" id="text/part0013.html.head9-9">9.9 Chapter notes</h3>
<p class="para">Melissa O’Neill has written a nice pearl on sieve methods for generating primes; see ‘The genuine sieve of Eratosthenes’, <i class="calibre1">Journal of Functional Programming</i> 19 (1), 95–106, 2009. Ben Sijtsma’s thesis <i class="calibre1">Verification and derivation of infinite-list programs</i> (University of Groningen, the Netherlands, 1988) studies various aspects of infinite-list programs and gives a number of techniques for reasoning about them. One chapter is devoted to the proof of fairness in the paper–rock–scissors game.</p>
<p class="para">My paper, ‘On building cyclic and shared data structures in Haskell’, <i class="calibre1">Formal Aspects of Computing</i> 24(4–6), 609–621, July 2012, contains more examples of the uses of infinite and cyclic lists. See also the article on ‘Tying the knot’ at</p>
<p class="code"><a id="text/part0013.html.page_238" class="calibre3"></a><span class="font"><a href="http://haskell.org/haskellwiki/Tying_the_Knot" class="calibre3">haskell.org/haskellwiki/Tying_the_Knot</a></span></p>
<p class="para">Hamming’s problem has been used as an illustration of cyclic programs since the early days of functional programming.</p>
</div></div>
<div id="text/part0014.html"><div id="text/part0014.html.DB7S0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre">

<h2 class="chapter-number" id="text/part0014.html.calibre_pb_0">Chapter 10<a id="text/part0014.html.page_239" class="calibre6"></a></h2>
<h2 class="chapter-title">Imperative functional programming</h2>
<p class="para">Back in <a href="#text/part0006.html.5N3C0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 2</a> we described the function <span class="font">putStrLn</span> as being a Haskell <i class="calibre1">command</i>, and <span class="font">IO a</span> as being the type of input–output <i class="calibre1">computations</i> that interact with the outside world and deliver values of type <span class="font">a</span>. We also mentioned some syntax, called <span class="font"><i class="calibre1">do</i></span><i class="calibre1">-notation</i>, for sequencing commands. This chapter explores what is really meant by these words, and introduces a new style of programming called <i class="calibre1">monadic</i> programming. Monadic programs provide a simple and attractive way to describe interaction with the outside world, but are also capable of much more: they provide a simple sequencing mechanism for solving a range of problems, including exception handling, destructive array updates, parsing and state-based computation. In a very real sense, a monadic style enables us to write functional programs that mimic the kind of imperative programs one finds in languages such as Python or C.</p>
<h3 class="h" id="text/part0014.html.head10-1">10.1 The <span class="font1">IO</span> monad</h3>
<p class="para">The type <span class="font">IO a</span> is an abstract type in the sense described in the previous chapter, so we are not told how its values, which are called <i class="calibre1">actions</i> or commands, are represented. But you can think of this type as being</p>
<p class="code"><span class="font">type IO a = World -&gt; (a,World)</span></p>
<p class="para">Thus an action is a function that takes a world and delivers a value of type <span class="font">a</span> and a new world. The new world is then used as the input for the next action. Having changed the world with an input–output action, you can’t go back to the old world. You can’t duplicate the world or inspect its components. All you can do is operate on the world with given primitive actions, and put such actions together in a sequence.</p>
<p class="para"><a id="text/part0014.html.page_240" class="calibre3"></a>One primitive action is to print a character:</p>
<p class="code"><span class="font">putChar :: Char -&gt; IO ()</span></p>
<p class="para">When executed, this action prints a character on the standard output channel, usually the computer screen. For example,</p>
<p class="code6"><span class="font">ghci&gt; putChar 'x'</span></p>
<p class="code6"><span class="font">xghci&gt;</span></p>
<p class="para">The character <span class="font">x</span> is printed, but nothing else, so the next GHCi prompt follows without additional spaces or newlines. Performing this action produces no value of interest, so the return value is the null tuple <span class="font">()</span>.</p>
<p class="para">Another primitive action is <span class="font">done :: IO ()</span>, which does nothing. It leaves the world unchanged and also returns the null tuple <span class="font">()</span>.</p>
<p class="para">One simple operation to sequence actions is denoted by <span class="font">(&gt;&gt;)</span> and has type</p>
<p class="code"><span class="font">(&gt;&gt;) :: IO () -&gt; IO () -&gt; IO ()</span></p>
<p class="para">Given actions <span class="font">p</span> and <span class="font">q</span>, the action <span class="font">p &gt;&gt; q</span> first performs action <span class="font">p</span> and then performs action <span class="font">q</span>. For example,</p>
<p class="code6"><span class="font">ghci&gt; putChar 'x' &gt;&gt; putChar '\n'</span></p>
<p class="code6"><span class="font">x</span></p>
<p class="code6"><span class="font">ghci&gt;</span></p>
<p class="para">This time a newline is printed. Using <span class="font">(&gt;&gt;)</span> we can define the function <span class="font">putStrLn</span>:</p>
<div class="space1">
<p class="code"><span class="font">putStrLn :: String -&gt; IO ()</span></p>
<p class="code"><span class="font">putStrLn xs = foldr (&gt;&gt;) done (map putChar xs) &gt;&gt;</span></p>
<p class="code9"><span class="space-r"></span><span class="font">putChar '\n'</span></p>
</div>
<p class="para">This action prints all the characters in a string, and then finishes up with an additional newline character. Note that <span class="font">map putChar xs</span> is a list of actions. We are still in the universe of functional programming and its full expressive power, including uses of <span class="font">map</span> and <span class="font">foldr</span>, is still available to us.</p>
<p class="para">Here is another primitive action:</p>
<p class="code"><span class="font">getChar :: IO Char</span></p>
<p class="para">When performed, this operation reads a character from the standard input channel. This channel is fed by you typing at the keyboard, so <span class="font">getChar</span> returns the first character you type. For example,</p>
<p class="code6"><a id="text/part0014.html.page_241" class="calibre3"></a><span class="font">ghci&gt; getChar</span></p>
<p class="code6"><span class="font">x</span></p>
<p class="code6"><span class="font">'x'</span></p>
<p class="para">After typing <span class="font">getChar</span> and pressing return, GHCi waits for you to type a character. We typed the character <span class="font">'x'</span> (and what we typed was echoed), and then that character was read and printed.</p>
<p class="para">The generalisation of <span class="font">done</span> is an action that does nothing and returns a named value:</p>
<p class="code"><span class="font">return :: a -&gt; IO a</span></p>
<p class="para">In particular, <span class="font">done = return ()</span>. The generalisation of <span class="font">(&gt;&gt;)</span> has type</p>
<p class="code"><span class="font">(&gt;&gt;) :: IO a -&gt; IO b -&gt; IO b</span></p>
<p class="para">Given actions <span class="font">p</span> and <span class="font">q</span>, the action <span class="font">p &gt;&gt; q</span> first does <span class="font">p</span>, and then throws the return value away, and then does <span class="font">q</span>. For example,</p>
<p class="code6"><span class="font">ghci&gt; return 1 &gt;&gt; return 2</span></p>
<p class="code6"><span class="font">2</span></p>
<p class="para">It is clear that this action is useful only when the value returned by <span class="font">p</span> is not interesting since there is no way that <span class="font">q</span> can depend on it. What is really wanted is a more general operator <span class="font">(&gt;&gt;=)</span> with type</p>
<p class="code"><span class="font">(&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b</span></p>
<p class="para">The combination <span class="font">p &gt;&gt;= f</span> is an action that, when performed, first does <span class="font">p</span>, returning a value <span class="font">x</span> of type <span class="font">a</span>, then does action <span class="font">f x</span> returning a final value <span class="font">y</span> of type <span class="font">b</span>. It is easy to define <span class="font">(&gt;&gt;)</span> in terms of <span class="font">(&gt;&gt;=)</span> and we leave this as an exercise. The operator <span class="font">(&gt;&gt;=)</span> is often referred to as <i class="calibre1">bind</i>, though one can also pronounce it as ‘then apply’.</p>
<p class="para">Using <span class="font">(&gt;&gt;=)</span>, we can define a function <span class="font">getLine</span> for reading a line of input, more precisely, the list of characters up to but not including the first newline character:</p>
<div class="space1">
<p class="code"><span class="font">getLine :: IO String</span></p>
<p class="code"><span class="font">getLine = getChar &gt;&gt;= f</span></p>
<p class="code10"><span class="font">where f x = if x == '\n' then return []</span></p>
<p class="code5"><span class="font">else getLine &gt;&gt;= g</span></p>
<p class="code5"><span class="font">where g xs = return (x:xs)</span></p>
</div>
<p class="para">This has a straightforward reading: get the first character <span class="font">x</span>; stop if <span class="font">x</span> is a newline and return the empty list; otherwise get the rest of the line and add <span class="font">x</span> to the front. Though the reading is straightforward, the use of nested <span class="font">where</span> clauses makes the <a id="text/part0014.html.page_242" class="calibre3"></a>definition a little clumsy. One way to make the code smoother is to use anonymous lambda expressions and instead write:</p>
<div class="space1">
<p class="code"><span class="font">getLine = getChar &gt;&gt;= \x -&gt;</span></p>
<p class="code10"><span class="font">if x == '\n'</span></p>
<p class="code10"><span class="font">then return []</span></p>
<p class="code10"><span class="font">else getLine &gt;&gt;= \xs -&gt;</span></p>
<p class="code4"><span class="font">return (x:xs)</span></p>
<p class="para">Another, arguably superior solution is to use <span class="font">do</span>-notation:</p>
<div class="space1">
<p class="code"><span class="font">getLine = do x &lt;- getChar</span></p>
<p class="code10"><span class="font">if x == '\n'</span></p>
<p class="code10"><span class="font">then return []</span></p>
<p class="code10"><span class="font">else do xs &lt;- getLine</span></p>
<p class="code4"><span class="font">return (x:xs)</span></p>
<p class="para">The right-hand side makes use of the Haskell layout convention. Note especially the indentation of the conditional expression, and the last <span class="font">return</span> to show it is part of the inner <span class="font">do</span>. Better in our opinion is to use braces and semicolons to control the layout explicitly:</p>
<div class="space1">
<p class="code"><span class="font">getLine = do {x &lt;- getChar;</span></p>
<p class="code10"><span class="font">if x == '\n'</span></p>
<p class="code10"><span class="font">then return []</span></p>
<p class="code10"><span class="font">else do {xs &lt;- getLine;</span></p>
<p class="code4"><span class="font">return (x:xs)}}</span></p>
<p class="para">We return to <span class="font">do</span>-notation below.</p>
<p class="para">The Haskell library <span class="font">System.IO</span> provides many more actions than just <span class="font">putChar</span> and <span class="font">getChar</span>, including actions to open and read files, to write and close files, to buffer output in various ways and so on. We will not go into details in this book. But perhaps two more things need to be said. Firstly, there is no function of type <span class="font">IO a -&gt; a</span> <sup class="calibre8"><a id="text/part0014.html.fn_1" href="#text/part0014.html.fn1" class="calibre3">1</a></sup>. Once you are in a room performing input–output actions, you stay in the room and can’t come out of it. To see one reason this has to be the case, suppose there is such a function, <span class="font">runIO</span> say, and consider</p>
<div class="space1">
<p class="code"><span class="font">int :: Int</span></p>
<p class="code"><span class="font">int = x - y</span></p>
<p class="code8"><span class="space-r"></span><span class="font">where x = runIO readInt</span></p>
<p class="code12"><span class="space-r1"></span><span class="font">y = runIO readInt</span></p>
<p class="code"><a id="text/part0014.html.page_243" class="calibre3"></a><span class="font">readInt = do {xs &lt;- getLine; return (read xs :: Int)}</span></p>
</div>
<p class="para">The action <span class="font">readInt</span> reads a line of input and, provided the line consists entirely of digits, interprets it as an integer. Now, what is the value of <span class="font">int</span>? The answer depends entirely on which of <span class="font">x</span> and <span class="font">y</span> gets evaluated first. Haskell does not prescribe whether or not <span class="font">x</span> is evaluated before <span class="font">y</span> in the expression <span class="font">x-y</span>. Put it this way: input– output actions have to be sequenced in a deterministic fashion, and Haskell is a lazy functional language in which it is difficult to determine the order in which things happen. Of course, an expression such as <span class="font">x-y</span> is a very simple example (and exactly the same undesirable phenomenon arises in imperative languages) but you can imagine all sorts of confusion that would ensue if we were provided with <span class="font">runIO</span>.</p>
<p class="para">The second thing that perhaps should be said is in response to a reader who casts a lazy eye over an expression such as</p>
<p class="code"><span class="font">undefined &gt;&gt; return 0 :: IO Int</span></p>
<p class="para">Does this code raise an error or return zero? The answer is: an error. IO is <i class="calibre1">strict</i> in the sense that IO actions are performed in order, even though subsequent actions may take no heed of their results.</p>
<p class="para">To return to the main theme, let us summarise. The type <span class="font">IO a</span> is an abstract type on which the following operations, at least, are available:</p>
<div class="space1">
<p class="code"><span class="font">return :: a -&gt; IO a</span></p>
<p class="code"><span class="space-r"></span><span class="font">(&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b</span></p>
<p class="para"></p>
<p class="code"><span class="font">putChar :: Char -&gt; IO ()</span></p>
<p class="code"><span class="font">getChar :: IO Char</span></p>
</div>
<p class="para">The second two functions are specific to input and output, but the first two are not. Indeed they are general sequencing operations that characterise the class of types called <i class="calibre1">monads</i>:</p>
<div class="space1">
<p class="code"><span class="font">class Monad m where</span></p>
<p class="code2"><span class="font">return :: a -&gt; m a</span></p>
<p class="code2"><span class="space-r"></span><span class="font">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span></p>
</div>
<p class="para">The two monad operations are required to satisfy certain laws, which we will come to in due course. As to the reason for the name ‘monad’, it is stolen from philosophy, in particular from Leibniz, who in turn borrowed it from Greek philosophy. Don’t read anything into the name.</p>
<a id="text/part0014.html.page_244" class="calibre3"></a>
<h3 class="h" id="text/part0014.html.head10-2">10.2 More monads</h3>
<p class="para">If that’s all a monad is, then surely lots of things form a monad? Yes, indeed. In particular, the humble list type forms a monad:</p>
<div class="space1">
<p class="code"><span class="font">instance Monad [] where</span></p>
<p class="code2"><span class="font">return x = [x]</span></p>
<p class="code2"><span class="font">xs &gt;&gt;= f = concat (map f xs)</span></p>
</div>
<p class="para">Of course, we don’t yet know what the laws governing the monad operations are, so maybe this instance isn’t correct (it is), but at least the operations have the right types. Since <span class="font">do</span>-notation can be used with any monad we can, for example, define the cartesian product function <span class="font">cp :: [[a]] -&gt; [[a]]</span> (see <a href="#text/part0011.html.head7-3" class="calibre3">Section 7.3</a>) using the new notation:</p>
<div class="space1">
<p class="code"><span class="font">cp []</span><span class="space2"></span><span class="space-r1"></span><span class="font">= return []</span></p>
<p class="code"><span class="font">cp (xs:xss) = do {x &lt;- xs;</span></p>
<p class="code4"><span class="font">ys &lt;- cp xss;</span></p>
<p class="code4"><span class="font">return (x:ys)}</span></p>
</div>
<p class="para">Comparing the right-hand side of the second clause to the list comprehension</p>
<p class="code"><span class="font">[x:ys | x &lt;- xs, ys &lt;- cp xss]</span></p>
<p class="para">one can appreciate that the two notations are very similar; the only real difference is that with <span class="font">do</span>-notation the result appears at the end rather than at the beginning. If monads and <span class="font">do</span>-notation had been made part of Haskell before list comprehensions, then maybe the latter wouldn’t have been needed.</p>
<p class="para">Here is another example. The <span class="font">Maybe</span> type is a monad:</p>
<div class="space1">
<p class="code"><span class="font">instance Monad Maybe where</span></p>
<p class="code2"><span class="font">return x</span><span class="space4"></span><span class="space"></span><span class="font">= Just x</span></p>
<p class="code2"><span class="font">Nothing &gt;&gt;= f</span><span class="space"></span><span class="font">= Nothing</span></p>
<p class="code2"><span class="font">Just x &gt;&gt;= f</span><span class="space-b"></span><span class="font">= f x</span></p>
</div>
<p class="para">To appreciate what this monad can bring to the table, consider the Haskell library function</p>
<p class="code"><span class="font">lookup :: Eq a =&gt; a -&gt; [(a,b)] -&gt; Maybe b</span></p>
<p class="para">The value of <span class="font">lookup x alist</span> is <span class="font">Just y</span> if <span class="font">(x,y)</span> is the first pair in <span class="font">alist</span> with first component <span class="font">x</span>, and <span class="font">Nothing</span> if there is no such pair. Imagine looking up <span class="font">x</span> in <span class="font">alist</span>, then looking up the result <span class="font">y</span> in a second list <span class="font">blist</span>, and then looking up the result <span class="font">z</span> in yet a third list <span class="font">clist</span>. If any of these lookups return <span class="font">Nothing</span>, then</p>
<p class="para"><a id="text/part0014.html.page_245" class="calibre3"></a><span class="font">Nothing</span> is the final result. To define such a function we would have to write its defining expression as something like</p>
<p class="code"><span class="font">case lookup x alist of</span></p>
<p class="code2"><span class="font">Nothing -&gt; Nothing</span></p>
<p class="code2"><span class="font">Just y</span><span class="space"></span><span class="font">-&gt; case lookup y blist of</span></p>
<p class="code9"><span class="font">Nothing -&gt; Nothing</span></p>
<p class="code9"><span class="font">Just z</span><span class="space"></span><span class="font">-&gt; lookup z clist</span></p>
</div>
<p class="para">With a monad we can write</p>
<p class="code"><span class="font">do {y &lt;- lookup x alist;</span></p>
<p class="code11"><span class="space-r1"></span><span class="font">z &lt;- lookup y blist;</span></p>
<p class="code11"><span class="font">return (lookup z clist)}</span></p>
<p class="para">Rather than having to write an explicit chain of computations, each of which may return <span class="font">Nothing</span>, and explicitly passing <span class="font">Nothing</span> back up the chain, we can write a simple monadic expression in which handling <span class="font">Nothing</span> is done implicitly under a monadic hood.</p>
<p class="center"><i class="calibre1">do-notation</i></p>
<p class="para">Just as list comprehensions can be translated into expressions involving <span class="font">map</span> and <span class="font">concat</span>, so <span class="font">do</span>-expressions can be translated into expressions involving return and bind. The three main translation rules are:</p>
<p class="code"><span class="font">do {p}</span><span class="space3"></span><span class="space-toc1"></span><span class="font">= p</span></p>
<p class="code"><span class="font">do {p;stmts}</span><span class="space4"></span><span class="space-r"></span><span class="font">= p &gt;&gt; do {stmts}</span></p>
<p class="code"><span class="font">do {x &lt;- p;stmts} = p &gt;&gt; = \x -&gt; do {stmts}</span></p>
<p class="para">In these rules <span class="font">p</span> denotes an action, so the first rule says that a <span class="font">do</span> round a single action can be removed. In the second and third rules <span class="font">stmts</span> is a <i class="calibre1">nonempty</i> sequence of statements, each of which is either an action or a statement of the form <span class="font">x &lt;- p</span>. The latter is <i class="calibre1">not</i> an action; consequently an expression such as</p>
<p class="code"><span class="font">do {x &lt;- getChar}</span></p>
<p class="para">is not syntactically correct. Nor, by the way, is an empty <span class="font">do</span>-expression <span class="font">do { }</span>. The last statement in a <span class="font">do</span>-expression must be an action.</p>
<p class="para">On the other hand, the following two expressions are both fine:</p>
<p class="code"><span class="font">do {putStrLn "hello "; name &lt;- getLine; putStrLn name}</span></p>
<p class="code"><span class="font">do {putStrLn "hello "; getLine; putStrLn "there"}</span></p>
<p class="para"><a id="text/part0014.html.page_246" class="calibre3"></a>The first example prints a greeting, reads a name and completes the greeting. The second prints a greeting, reads a name but immediately forgets it, and then completes the greeting with a ‘there’. A bit like being introduced to someone in real life.</p>
<p class="para">Finally, there are two rules that can be proved from the translation rules above:</p>
<div class="space1">
<p class="code"><span class="font">do {do {stmts}} = do {stmts}</span></p>
<p class="code"><span class="font">do {stmts1; do {stmts2}} = do {stmts1; stmts2}</span></p>
</div>
<p class="para">But one has to be careful; the nested <span class="font">do</span>s in</p>
<div class="space1">
<p class="code"><span class="font">do {stmts1;</span></p>
<p class="code11"><span class="font">if p</span></p>
<p class="code11"><span class="font">then do {stmts2}</span></p>
<p class="code11"><span class="font">else do {stmts3}}</span></p>
</div>
<p class="para">are necessary if <span class="font">stmts2</span> and <span class="font">stmts3</span> contain more than one action.</p>
<p class="center"><i class="calibre1">Monad laws</i></p>
<p class="para">The monad laws say nothing much more than that expressions involving <span class="font">return</span> and <span class="font">(&gt;&gt;=)</span> simplify in just the way one would expect. There are three laws and we are going to state them in three different ways. The first law states that <span class="font">return</span> is a right identity element of <span class="font">(&gt;&gt;=)</span>:</p>
<p class="code"><span class="font">(p &gt;&gt;= return) = p</span></p>
<p class="para">In <span class="font">do</span>-notation the law reads:</p>
<p class="code"><span class="font">do {x &lt;- p; return x} = do {p}</span></p>
<p class="para">The second law says that <span class="font">return</span> is also a kind of left identity element:</p>
<p class="code"><span class="font">(return e &gt;&gt;= f) = f e</span></p>
<p class="para">In <span class="font">do</span>-notation the law reads:</p>
<p class="code"><span class="font">do {x &lt;- return e; f x} = do {f e}</span></p>
<p class="para">The third law says that <span class="font">(&gt;&gt;=)</span> is kind of associative:</p>
<p class="code"><span class="font">((p &gt;&gt;= f) &gt;&gt;= g) = p &gt;&gt;= (\x -&gt; (f x &gt;&gt;= g))</span></p>
<p class="para">In <span class="font">do</span>-notation the law reads:</p>
<div class="space1">
<p class="code2"><span class="space-r1"></span><a id="text/part0014.html.page_247" class="calibre3"></a><span class="font">do {y &lt;- do {x &lt;- p; f x}; g y}</span></p>
<p class="code"><span class="font">= do {x &lt;- p; do {y &lt;- f x; g y}}</span></p>
<p class="code"><span class="font">= do {x &lt;- p; y &lt;- f x; g y}</span></p>
</div>
<p class="para">The last line makes use of the un-nesting property of <span class="font">do</span>-notation.</p>
<p class="para">For the third way of stating the monad laws, consider the operator <span class="font">(&gt;=&gt;)</span> defined by</p>
<div class="space1">
<p class="code"><span class="font">(&gt;=&gt;) :: Monad m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; (a -&gt; m c)</span></p>
<p class="code"><span class="font">(f &gt;=&gt; g) x = f x &gt;&gt;= g</span></p>
</div>
<p class="para">This operator is just like function composition except that the component functions each have type <span class="font">x -&gt; m y</span> for appropriate <span class="font">x</span> and <span class="font">y</span>, and the order of composition is from left to right rather than from right to left. This operator, which is called <i class="calibre1">(left to right) Kleisli composition</i>, is defined in the Haskell library <span class="font">Control.Monad</span>. There is a dual version, <i class="calibre1">(right to left) Kleisli composition</i>,</p>
<p class="code"><span class="font">(&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; (a -&gt; m c)</span></p>
<p class="para">whose definition we leave as an easy exercise.</p>
<p class="para">The point is that we can define <span class="font">(&gt;&gt;=)</span> in terms of <span class="font">(&gt;=&gt;)</span>:</p>
<p class="code"><span class="font">(p &gt;&gt;= f) = (id &gt;=&gt; f) p</span></p>
<p class="para">More briefly, <span class="font">(&gt;&gt;=) = flip (id &gt;=&gt;)</span>. We also have the <i class="calibre1">leapfrog</i> rule:</p>
<p class="code"><span class="font">(f &gt;=&gt; g) . h = (f . h) &gt;=&gt; g</span></p>
<p class="para">The proof is left as an exercise.</p>
<p class="para">In terms of <span class="font">(&gt;=&gt;)</span> the three monad laws say simply that <span class="font">(&gt;=&gt;)</span> is associative with identity <span class="font">return</span>. Any set of values with an associative binary operation and an identity element is called a <i class="calibre1">monoid</i>, and the word ‘monad’ was probably adopted because of the pun with monoid. Be that as it may, this is certainly the shortest way of stating the monad laws.</p>
<p class="para">One additional and instructive way of describing the monad laws is considered in the exercises.</p>
<h3 class="h" id="text/part0014.html.head10-3">10.3 The <span class="font1">State</span> monad</h3>
<p class="para">If it wasn’t for the problem of how to sequence input–output actions correctly, monads probably wouldn’t have appeared in Haskell. But once it was appreciated <a id="text/part0014.html.page_248" class="calibre3"></a>what they could do, all kinds of other uses quickly followed. We have seen with the <span class="font">Maybe</span> monad how chains of computations that involve passing information back up the chain can be simplified with monadic notation. Another primary use of monads is a way to handle <i class="calibre1">mutable</i> structures, such as arrays, that rely for their efficiency on being able to update their values, destroying the original structure in the process.</p>
<p class="para">Mutable structures are introduced through the State-Thread monad <span class="font">ST s</span> which we will consider in a subsequent section. Before getting on to the particular properties of this monad, we start by considering a simpler monad, called <span class="font">State s</span>, for manipulating an explicit state <span class="font">s</span>. You can think of the type <span class="font">State s a</span> as being</p>
<p class="code"><span class="font">type State s a = s -&gt; (a,s)</span></p>
<p class="para">An action of type <span class="font">State s a</span> takes an initial state and returns a value of type <span class="font">a</span> and a new state. It is tempting, but wrong, to think of <span class="font">IO a</span> as synonymous with <span class="font">State World a</span>. The state component <span class="font">s</span> in <span class="font">State s a</span> can be exposed and manipulated, but we can’t expose and manipulate the world.</p>
<p class="para">Specifically, as well as the monad operations <span class="font">return</span> and <span class="font">(&gt;&gt;=)</span>, five other functions are provided for working with the state monad:</p>
<p class="code"><span class="font">put</span><span class="space2"></span><span class="font">:: s -&gt; State s ()</span></p>
<p class="code"><span class="font">get</span><span class="space2"></span><span class="font">:: State s s</span></p>
<p class="code"><span class="font">state</span><span class="space5"></span><span class="space-r"></span><span class="font">:: (s -&gt; (a,s)) -&gt; State s a</span></p>
<p class="code"><span class="font">runState</span><span class="space"></span><span class="font">:: State s a -&gt; (s -&gt; (a,s))</span></p>
<p class="code"><span class="font">evalState :: State s a -&gt; s -&gt; a</span></p>
<p class="para">The function <span class="font">put</span> puts the state into a given configuration, while <span class="font">get</span> returns the current state. Each of these two operations can be defined in terms of <span class="font">state</span>:</p>
<p class="code"><span class="font">put s = state (\_ -&gt; ((),s))</span></p>
<p class="code"><span class="font">get</span><span class="space5"></span><span class="font">= state (\s -&gt; (s,s))</span></p>
<p class="para">On the other hand, <span class="font">state</span> can also be defined using <span class="font">put</span> and <span class="font">get</span>:</p>
<p class="code"><span class="font">state f = do {s &lt;- get; let (a,s') = f s;</span></p>
<p class="code10"><span class="font">put s'; return a}</span></p>
<p class="para">Haskell permits an abbreviated form of <span class="font">let</span> expressions in <span class="font">do</span> expressions (and also in list comprehensions). We have</p>
<p class="code"><span class="font">do {let decls; stmts} = let decls in do {stmts}</span></p>
<p class="para">The function <span class="font">runState</span> is the inverse of <span class="font">state</span>: it takes both an action and an <a id="text/part0014.html.page_249" class="calibre3"></a>initial state and returns the final value and the final state after performing the action (something the <span class="font">IO</span> monad cannot do). The function <span class="font">evalState</span> is defined by</p>
<p class="code"><span class="font">evalState m s = fst (runState m s)</span></p>
<p class="para">and returns just the value of the stateful computation.</p>
<p class="para">Here is an example of the use of <span class="font">State</span>. In <a href="#text/part0011.html.head7-6" class="calibre3">Section 7.6</a> we constructed the following program for building a binary tree out of a given nonempty list of values:</p>
<div class="space1">
<p class="code"><span class="font">build :: [a] -&gt; BinTree a</span></p>
<p class="code"><span class="font">build xs = fst (build2 (length xs) xs)</span></p>
<p class="code"><span class="font">build2 1 xs = (Leaf (head xs),tail xs)</span></p>
<p class="code"><span class="font">build2 n xs = (Fork u v, xs'')</span></p>
<p class="code4"><span class="font">where (u,xs') = build2 m xs</span></p>
<p class="code4"><span class="font">(v,xs'')</span><span class="space4"></span><span class="space-r"></span><span class="font">= build2 (n-m) xs'</span></p>
<p class="code4"><span class="font">m</span><span class="space3"></span><span class="space5"></span><span class="font">= n `div` 2</span></p>
</div>
<p class="para">The point to appreciate here is that <span class="font">build2</span> is essentially a function that manipulates a state of type <span class="font">[a]</span>, returning elements of <span class="font">BinTree a</span> as its result. Another way of writing <span class="font">build</span> is as follows:</p>
<div class="space1">
<p class="code"><span class="font">build xs = evalState (build2 (length xs)) xs</span></p>
<p class="para1"></p>
<p class="code"><span class="font">build2 :: Int -&gt; State [a] (BinTree a)</span></p>
<p class="code"><span class="font">build2 1 = do {x:xs &lt;- get;</span></p>
<p class="code4"><span class="font">put xs;</span></p>
<p class="code4"><span class="font">return (Leaf x)}</span></p>
<p class="code"><span class="font">build2 n = do {u &lt;- build2 m;</span></p>
<p class="code4"><span class="font">v &lt;- build2 (n-m);</span></p>
<p class="code4"><span class="font">return (Fork u v)}</span></p>
<p class="code12"><span class="font">where m = n `div` 2</span></p>
</div>
<p class="para">All the work in manipulating the state explicitly is done when building a leaf. The state is accessed and its first element is chosen as the label associated with a <span class="font">Leaf</span>; the remaining list then is installed as the new state. Whereas the first version of <span class="font">build2 n</span> threads the state explicitly, the second version hides this machinery under a monadic hood.</p>
<p class="para">Notice in the first line of <span class="font">build2</span> we have a statement <span class="font">x:xs &lt;- get</span> in which the left-hand side is a <i class="calibre1">pattern</i> rather than a simple variable. If the current state happens to be the empty list, the action fails with a suitable error message. For example,</p>
<p class="code6"><span class="font">ghci&gt; runState (do {x:xs &lt;- get; return x}) ""</span></p>
<p class="code6"><a id="text/part0014.html.page_250" class="calibre3"></a><span class="font">*** Exception: Pattern match failure in do expression ...</span></p>
<p class="para">Of course this behaviour cannot arise with <span class="font">build2 1</span> because the definition only applies when the state is a singleton list. We leave it as an exercise to say what <span class="font">build []</span> does.</p>
<p class="para">As another example, consider the problem of producing a pseudo-random integer in a specified interval. Imagine we have a function</p>
<p class="code"><span class="font">random :: (Int,Int) -&gt; Seed -&gt; (Int,Seed)</span></p>
<p class="para">that takes a pair of integers as the specified interval and then a seed, and calculates a random integer and a new seed. The new seed is used for obtaining further random values. Rather than be explicit about what a seed is, suppose there is a function</p>
<p class="code"><span class="font">mkSeed :: Int -&gt; Seed</span></p>
<p class="para">that makes a seed from a given integer. Now if we wanted to roll a pair of dice, we could write</p>
<div class="space1">
<p class="code"><span class="font">diceRoll :: Int -&gt; (Int,Int)</span></p>
<p class="code"><span class="font">diceRoll n = (x,y)</span></p>
<p class="code9"><span class="font">where (x,s1) = random (1,6) (mkSeed n)</span></p>
<p class="code13"><span class="font">(y,s2) = random (1,6) s1</span></p>
</div>
<p class="para">But we could also write</p>
<div class="space1">
<p class="code"><span class="font">diceRoll n = evalState (</span></p>
<p class="code9"><span class="font">do {x &lt;- randomS (1,6);</span></p>
<p class="code14"><span class="font">y &lt;- randomS (1,6);</span></p>
<p class="code14"><span class="font">return (x,y)}</span></p>
<p class="code9"><span class="font">) (mkSeed n)</span></p>
<p class="code9"><span class="font">where randomS = state . random</span></p>
</div>
<p class="para">The function <span class="font">randomS :: (Int,Int) -&gt; State Seed Int</span> takes an interval and returns an action. The second version of <span class="font">diceRoll</span> is a little longer than the first, but is arguably more easy to write. Imagine that instead of two dice we had five, as in liar dice. The first method would involve a chain of where-clauses expressing the linkage between five values and five seeds, something that would be easy to mistype, but the second version is easily extended and harder to get wrong.</p>
<p class="para">One final point. Consider</p>
<p class="code"><span class="font">evalState (do {undefined; return 0}) 1</span></p>
<p class="para">Does this raise an exception, or does it return zero? In other words, is the monad</p>
<p class="para"><a id="text/part0014.html.page_251" class="calibre3"></a><span class="font">State</span> strict, as the <span class="font">IO</span> monad is, or is it lazy? The answer is that it can be both. There are two variants of the state monad, one of which is lazy and the other of which is strict. The difference lies in how the operation <span class="font">(&gt;&gt;=)</span> is implemented. Haskell provides the lazy variant by default, in <span class="font">Control.Monad.State.Lazy</span>, but you can ask for the strict variant, in <span class="font">Control.Monad.State.Strict</span> if you want.</p>
<h3 class="h" id="text/part0014.html.head10-4">10.4 The <span class="font1">ST</span> monad</h3>
<p class="para">The state-thread monad, which resides in the library <span class="font">Control.Monad.ST</span>, is a different kettle of fish entirely from the state monad, although the kettle itself looks rather similar. Like <span class="font">State s a</span> you can think of this monad as the type</p>
<p class="code"><span class="font">type ST s a = s -&gt; (a,s)</span></p>
<p class="para">but with one very important difference: the type variable <span class="font">s</span> cannot be instantiated to specific states, such as <span class="font">Seed</span> or <span class="font">[Int]</span>. Instead it is there only to <i class="calibre1">name</i> the state. Think of <span class="font">s</span> as a label that identifies one particular state <i class="calibre1">thread</i>. All mutable types are tagged with this thread, so that actions can only affect mutable values in their own state thread.</p>
<p class="para">One kind of mutable value is a <i class="calibre1">program variable</i>. Unlike variables in Haskell, or mathematics for that matter, program variables in imperative languages can change their values. They can be thought of as <i class="calibre1">references</i> to other values, and in Haskell they are entities of type <span class="font">STRef s a</span>. The <span class="font">s</span> means that the reference is local to the state thread <span class="font">s</span> (and no other), and the <span class="font">a</span> is the type of value being referenced. There are operations, defined in <span class="font">Data.STRef</span>, to create, read from and write to references:</p>
<div class="space1">
<p class="code"><span class="font">newSTRef</span><span class="space5"></span><span class="font">:: a -&gt; ST s (STRef s a)</span></p>
<p class="code"><span class="font">readSTRef</span><span class="space-r1"></span><span class="space"></span><span class="font">:: STRef s a -&gt; ST s a</span></p>
<p class="code"><span class="font">writeSTRef :: STRef s a -&gt; a -&gt; ST s ()</span></p>
</div>
<p class="para">Here is an example. Recall <a href="#text/part0011.html.head7-6" class="calibre3">Section 7.6</a> where we gave the following definition of the Fibonacci function:</p>
<div class="space1">
<p class="code"><span class="font">fib :: Int -&gt; Integer</span></p>
<p class="code"><span class="font">fib n</span><span class="space-toc1"></span><span class="font">= fst (fib2 n)</span></p>
<p class="code"><span class="font">fib2 0 = (0,1)</span></p>
<p class="code"><span class="font">fib2 n = (b,a+b) where (a,b) = fib2 (n-1)</span></p>
</div>
<p class="para"><a id="text/part0014.html.page_252" class="calibre3"></a>Evaluating <span class="font">fib</span> takes linear time, but the space involved is not constant (even ignoring the fact that arbitrarily large integers cannot be stored in constant space): each recursive call involves fresh variables <span class="font">a</span> and <span class="font">b</span>. By contrast, here is a definition of <span class="font">fib</span> in the imperative language Python:</p>
<div class="space1">
<p class="code"><span class="font">def fib (n):</span></p>
<p class="code11"><span class="space-r"></span><span class="font">a,b = 0,1</span></p>
<p class="code11"><span class="space-r"></span><span class="font">for i in range (0,n):</span></p>
<p class="code1"><span class="font">a,b = b,a+b</span></p>
<p class="code11"><span class="space-r"></span><span class="font">return a</span></p>
</div>
<p class="para">The definition manipulates two program variables <span class="font">a</span> and <span class="font">b</span>, and runs in constant space (at least, for small integers). We can translate the Python code almost directly into Haskell:</p>
<div class="space1">
<p class="code"><span class="font">fibST :: Int -&gt; ST s Integer</span></p>
<p class="code"><span class="font">fibST n = do {a &lt;- newSTRef 0;</span></p>
<p class="code9"><span class="font">b &lt;- newSTRef 1;</span></p>
<p class="code9"><span class="font">repeatFor n</span></p>
<p class="code4"><span class="font">(do {x &lt;- readSTRef a;</span></p>
<p class="code13"><span class="font">y &lt;- readSTRef b;</span></p>
<p class="code13"><span class="font">writeSTRef a y;</span></p>
<p class="code13"><span class="font">writeSTRef b $! (x+y)});</span></p>
<p class="code9"><span class="font">readSTRef a}</span></p>
</div>
<p class="para">Note the use of the strict application operator <span class="font">($!)</span> to force evaluation of the sum. The action <span class="font">repeatFor</span> repeats an action a given number of times:</p>
<div class="space1">
<p class="code"><span class="font">repeatFor :: Monad m =&gt; Int -&gt; m a -&gt; m ()</span></p>
<p class="code"><span class="font">repeatFor n = foldr (&gt;&gt;) done . replicate n</span></p>
</div>
<p class="para">All well and good, but we end up with an action <span class="font">ST s Integer</span> when what we really want is an integer. How do we escape from the monad back into the world of Haskell values?</p>
<p class="para">The answer is to provide a function similar to <span class="font">runState</span> for the state monad, Here it is, with its type:</p>
<p class="code"><span class="font">runST :: (forall s. ST s a) -&gt; a</span></p>
<p class="para">This type is unlike any other Haskell type we have met so far. It is what is called a <i class="calibre1">rank 2 polymorphic type</i>, while all previous polymorphic types have had rank 1. What it says is that the argument of <span class="font">runST</span> must be universal in <span class="font">s</span>, so it can’t <a id="text/part0014.html.page_253" class="calibre3"></a>depend on any information about <span class="font">s</span> apart from its name. In particular, every <span class="font">STRef</span> declared in the action has to carry the same thread name <span class="font">s</span>.</p>
<p class="para">To amplify a little on rank 2 types, consider the difference between the two lists</p>
<div class="space1">
<p class="code"><span class="font">list1 :: forall a. [a -&gt; a]</span></p>
<p class="code"><span class="font">list2 :: [forall a. a -&gt; a]</span></p>
</div>
<p class="para">The type of <span class="font">list1</span> is just what we would have previously written as <span class="font">[a -&gt; a]</span> because in ordinary rank 1 types universal quantification at the outermost level is assumed. For example, <span class="font">[sin,cos,tan]</span> is a possible value of <span class="font">list1</span> with the instantiation <span class="font">Float</span> for <span class="font">a</span>. But there are only two functions that can be elements of <span class="font">list2</span>, namely <span class="font">id</span> and the undefined function <span class="font">undefined</span>, because these are the only two functions with type <span class="font">forall a. a -&gt; a</span>. If you give me an element <span class="font">x</span> of a type <span class="font">a</span> about which absolutely nothing is known, the only things I can do if I have to give you back an element of <span class="font">a</span>, is either to give you <span class="font">x</span> or ⊥.</p>
<p class="para">Why have a rank 2 type for <span class="font">runST</span>? Well, it prevents us from defining things like</p>
<div class="space1">
<p class="code"><span class="font">let v = runST (newSTRef True)</span></p>
<p class="code"><span class="font">in runST (readSTRef v)</span></p>
</div>
<p class="para">This code is not well-typed because</p>
<p class="code"><span class="font">newSTRef True :: ST s (STref s Bool)</span></p>
<p class="para">and in the expression <span class="font">runST (newSTRef Bool)</span> the Haskell type checker cannot match <span class="font">STRef s a</span> with <span class="font">a</span>, the expected result type of <span class="font">runST</span>. Values of type <span class="font">STRef s a</span> cannot be exported from <span class="font">ST s</span>, but only entities whose types do not depend on <span class="font">s</span>. If the code were allowed, then the reference allocated in the first <span class="font">runST</span> would be usable inside the second <span class="font">runST</span>. That would enable reads in one thread to be used in another, and hence the result would depend on the evaluation order used to execute the threads, leading to mayhem and confusion. It is just the same problem that we prevented from occurring in the <span class="font">IO</span> monad.</p>
<p class="para">But we can safely define</p>
<div class="space1">
<p class="code"><span class="font">fib :: Int -&gt; Integer</span></p>
<p class="code"><span class="font">fib n = runST (fibST n)</span></p>
</div>
<p class="para">This version of <span class="font">fib</span> runs in constant space.</p>
<p class="para">For our purposes the main use of the <span class="font">ST</span> monad resides in its ability to handle mutable arrays. The whole question of arrays deserves a section to itself.</p>
<a id="text/part0014.html.page_254" class="calibre3"></a>
<h3 class="h" id="text/part0014.html.head10-5">10.5 Mutable arrays</h3>
<p class="para">It sometimes surprises imperative programmers who meet functional programming for the first time that the emphasis is on lists as the fundamental data structure rather than arrays. The reason is that most uses of arrays (though not all) depend for their efficiency on the fact that updates are destructive. Once you update the value of an array at a particular index the old array is lost. But in functional programming, data structures are <i class="calibre1">persistent</i> and any named structure continues to exist. For instance, <span class="font">insert x t</span> may insert a new element <span class="font">x</span> into a tree <span class="font">t</span>, but <span class="font">t</span> continues to refer to the original tree, so it had better not be overwritten.</p>
<p class="para">In Haskell a mutable array is an entity of type <span class="font">STArray s i e</span>. The <span class="font">s</span> names the state thread, <span class="font">i</span> the index type and <span class="font">e</span> the element type. Not every type can be an index; legitimate indices are members of the type class <span class="font">Ix</span>. Instances of this class include <span class="font">Int</span> and <span class="font">Char</span>, things that can be mapped into a contiguous range of integers.</p>
<p class="para">Like <span class="font">STRefs</span> there are operations to create, read from and write to arrays. Without more ado we consider an example, explaining the actions as we go along. Recall the Quicksort algorithm from <a href="#text/part0011.html.head7-7" class="calibre3">Section 7.7</a>:</p>
<div class="space1">
<p class="code"><span class="font">qsort :: (Ord a) =&gt; [a] -&gt; [a]</span></p>
<p class="code"><span class="font">qsort []</span><span class="space4"></span><span class="font">= []</span></p>
<p class="code"><span class="font">qsort (x:xs) = qsort [y | y &lt;- xs, y &lt; x] ++ [x] ++</span></p>
<p class="code4"><span class="font">qsort [y | y &lt;- xs, x &lt;= y]</span></p>
</div>
<p class="para">There we said that when Quicksort is implemented in terms of arrays rather than lists, the partitioning phase can be performed <i class="calibre1">in place</i> without using any additional space. We now have the tools to write just such an algorithm. We begin with</p>
<div class="space1">
<p class="code"><span class="font">qsort :: (Ord a) =&gt; [a] -&gt; [a]</span></p>
<p class="code"><span class="font">qsort xs = runST $</span></p>
<p class="code12"><span class="font">do {xa &lt;- newListArray (0,n-1) xs;</span></p>
<p class="code4"><span class="font">qsortST xa (0,n);</span></p>
<p class="code4"><span class="font">getElems xa}</span></p>
<p class="code12"><span class="font">where n = length xs</span></p>
</div>
<p class="para">First we create a mutable array with bounds <span class="font">(0,n-1)</span> and fill it with the elements of <span class="font">xs</span>. Sorting the array is done with the action <span class="font">qsortST xa (0,n)</span>. At the end, the list of elements of the sorted array is returned. In the code above, the action <span class="font">newListArray</span> has type</p>
<p class="code"><span class="font">Ix i =&gt; (i, i) -&gt; [e] -&gt; ST s (STArray s i e)</span></p>
<p class="para"><a id="text/part0014.html.page_255" class="calibre3"></a>and <span class="font">getElems</span> has type</p>
<p class="code"><span class="font">Ix i =&gt; STArray s i e -&gt; ST s [e]</span></p>
<p class="para">The first constructs a mutable array from a list of elements, and the second returns a list of the elements in a mutable array.</p>
<p class="para">The purpose of <span class="font">qsortST xa (a,b)</span> is to sort the elements in the sub-array of <span class="font">xa</span> in the interval <span class="font">(a,b)</span>, where by definition such an interval includes the lower bound but excludes the upper bound; in other words <span class="font">[a .. b-1]</span>. Choosing intervals that are closed on the left but open on the right is almost always the best policy when processing arrays. Here is the definition of <span class="font">qsortST</span>:</p>
<div class="space1">
<p class="code"><span class="font">qsortST :: Ord a =&gt; STArray s Int a -&gt;</span></p>
<p class="code10"><span class="font">(Int,Int) -&gt; ST s ()</span></p>
<p class="code"><span class="font">qsortST xa (a,b)</span></p>
<p class="code8"><span class="font">| a == b</span><span class="space5"></span><span class="font">= return ()</span></p>
<p class="code8"><span class="font">| otherwise = do {m &lt;- partition xa (a,b);</span></p>
<p class="code16"><span class="space"></span><span class="font">qsortST xa (a,m);</span></p>
<p class="code16"><span class="space"></span><span class="font">qsortST xa (m+1,b)}</span></p>
</div>
<p class="para">If <span class="font">a==b</span> we have an empty interval and there is nothing to do. Otherwise we rearrange the array so that for some suitable element <span class="font">x</span> in the array all elements in the interval <span class="font">(a,m)</span> are less than <span class="font">x</span>, and all elements in the interval <span class="font">(m+1,b)</span> are at least <span class="font">x</span>. The element <span class="font">x</span> itself is placed in the array at position <span class="font">m</span>. Sorting is then completed by sorting both sub-intervals.</p>
<p class="para">It remains to define <span class="font">partition</span>. The <i class="calibre1">only</i> way to find a suitable definition is by formal development using pre- and post-conditions and loop invariants. But this is a book on functional programming, not on the formal development of imperative programs, so we are going to cop out and just record one version:</p>
<div class="space1">
<p class="code"><span class="font">partition xa (a,b)</span></p>
<p class="code2"><span class="font">= do {x &lt;- readArray xa a;</span></p>
<p class="code3"><span class="font">let loop (j,k)</span></p>
<p class="code10"><span class="font">= if j==k</span></p>
<p class="code12"><span class="font">then do {swap xa a (k-1);</span></p>
<p class="code16"><span class="font">return (k-1)}</span></p>
<p class="code12"><span class="font">else do {y &lt;- readArray xa j;</span></p>
<p class="code16"><span class="font">if y &lt; x then loop (j+1,k)</span></p>
<p class="code16"><span class="font">else do {swap xa j (k-1);</span></p>
<p class="code16"><span class="space"></span><span class="space2"></span><span class="font">loop (j,k-1)}}</span></p>
<p class="code3"><span class="font">in loop (a+1,b)}</span></p>
</div>
<p class="para"><a id="text/part0014.html.page_256" class="calibre3"></a>The action <span class="font">swap</span> is defined by</p>
<p class="code"><span class="font">swap :: STArray s Int a -&gt; Int -&gt; Int -&gt; ST s ()</span></p>
<p class="code"><span class="font">swap xa i j = do {v &lt;- readArray xa i;</span></p>
<p class="code5"><span class="font">w &lt;- readArray xa j;</span></p>
<p class="code5"><span class="font">writeArray xa i w;</span></p>
<p class="code5"><span class="font">writeArray xa j v}</span></p>
<p class="para">Here is a brief and certainly inadequate explanation of how <span class="font">partition</span> works. We begin by taking the first element <span class="font">x</span> in the interval <span class="font">(a,b)</span> as pivot. We then enter a loop that processes the remaining interval <span class="font">(a+1,b)</span>, stopping when the interval becomes empty. We pass over elements that are less than <span class="font">x</span>, shrinking the interval from the left. Encountering a <span class="font">y</span> not less than <span class="font">x</span>, we swap it with the element at the rightmost position in the interval, shrinking the interval from the right. When the interval becomes empty, we place the pivot in its final position, returning that position as a result.</p>
<p class="para">Note that <span class="font">loop</span> is defined as a local procedure within the monad. We could have defined it as a global procedure, though we would have had to add three extra parameters, namely the array <span class="font">xa</span>, the pivot <span class="font">x</span> and the starting position <span class="font">a</span>.</p>
<p class="center"><i class="calibre1">Hash tables</i></p>
<p class="para">A purely functional Quicksort has the same asymptotic time efficiency as one based on mutable arrays, but there are one or two places where mutable arrays seem to play a crucial role in achieving an asymptotically faster algorithm. One such place is the use of hash tables for an efficient representation of sets.</p>
<p class="para">But let us approach the use of hash tables in the context of a particular problem. Consider a typical puzzle defined in terms of two finite sets, a set of <i class="calibre1">positions</i> and a set of <i class="calibre1">moves</i>. Given are the following functions:</p>
<div class="space1">
<p class="code"><span class="font">moves</span><span class="space"></span><span class="space-r1"></span><span class="font">:: Position -&gt; [Move]</span></p>
<p class="code"><span class="font">move</span><span class="space5"></span><span class="font">:: Position -&gt; Move -&gt; Position</span></p>
<p class="code"><span class="font">solved :: Position -&gt; Bool</span></p>
<p class="para">The function <span class="font">moves</span> describes the set of possible moves that can be made in a given position, <span class="font">move</span> makes a move, and <span class="font">solved</span> determines those positions that are a solution to the puzzle. Solving the puzzle means finding some sequence of moves, preferably a shortest such sequence, that leads from a given starting position to a solved position:</p>
<p class="code"><a id="text/part0014.html.page_257" class="calibre3"></a><span class="font">solve :: Position -&gt; Maybe [Move]</span></p>
<p class="para">The value <span class="font">solve p</span> is <span class="font">Nothing</span> if there is no sequence of moves starting in position <span class="font">p</span> that leads to a solved position, and <span class="font">Just ms</span> otherwise, where</p>
<p class="code"><span class="font">solved (foldl move p ms)</span></p>
<p class="para">We are going to implement <span class="font">solve</span> by carrying out a <i class="calibre1">breadth-first</i> search. What this means is that we examine all positions one move away from the starting position to see if there is a solution, then all positions two moves away, and so on. Breadthfirst will therefore find a shortest solution if one exists. To implement the search we need</p>
<div class="space1">
<p class="code"><span class="font">type Path</span><span class="space4"></span><span class="font">= ([Move],Position)</span></p>
<p class="code"><span class="font">type Frontier = [Path]</span></p>
<p class="para">A path consists of a sequence of moves made from the starting position (in reverse order), and the position that results after making the moves. A frontier is a list of paths waiting to be extended into longer paths. A breadth-first search is then implemented by</p>
<div class="space1">
<p class="code"><span class="font">solve p = bfs [] [([],p)]</span></p>
<p class="para1"></p>
<p class="code"><span class="font">bfs :: [Position] -&gt; Frontier -&gt; Maybe [Move]</span></p>
<p class="code"><span class="font">bfs ps [] = Nothing</span></p>
<p class="code"><span class="font">bfs ps ((ms,p):mps)</span></p>
<p class="code2"><span class="font">| solved p</span><span class="space4"></span><span class="font">= Just (reverse ms)</span></p>
<p class="code2"><span class="font">| p `elem` ps &nbsp;= bfs ps mps</span></p>
<p class="code2"><span class="font">| otherwise</span><span class="space5"></span>&nbsp;<span class="font">= bfs (p:ps) (mps ++ succs (ms,p))</span></p>
<p class="para1"></p>
<p class="code"><span class="font">succs :: Path -&gt; [Path]</span></p>
<p class="code"><span class="font">succs (ms,p) = [(m:ms,move p m) | m &lt;- moves p]</span></p>
</div>
<p class="para">The first argument <span class="font">ps</span> of <span class="font">bfs</span> represents the set of positions that have already been explored. The second argument is the frontier, which is managed in a queue-like fashion to ensure that paths of the same length are inspected before their successors. Inspecting a path means accepting it if the final position is a solution, rejecting it if the end position has already been explored, and otherwise adding its successors to the end of the current frontier for future exploration. The moves in a successful path are reversed before being returned as the final result of <span class="font">bfs</span> simply because, for efficiency, <span class="font">succs</span> adds a new move to the front of the list rather than at the end.</p>
<p class="para">There are two major sources of inefficiency with <span class="font">bfs</span>, one concerning the use of <a id="text/part0014.html.page_258" class="calibre3"></a><span class="font">(++)</span> and the other concerning <span class="font">elem</span>. Firstly, the size of a frontier can grow exponentially and so concatenating successors to the end of the frontier is slow. Better is the following alternative to <span class="font">bfs</span>:</p>
<div class="space1">
<p class="code"><span class="font">bfs :: [Position] -&gt; Frontier -&gt; Frontier -&gt;</span></p>
<p class="code1"><span class="font">Maybe [Move]</span></p>
<p class="code"><span class="font">bfs ps [] []</span><span class="space-toc1"></span><span class="font">= Nothing</span></p>
<p class="code"><span class="font">bfs ps [] mqs = bfs ps mqs []</span></p>
<p class="code"><span class="font">bfs ps ((ms,p):mps) mqs</span></p>
<p class="code2"><span class="font">| solved p</span><span class="space5"></span>&nbsp;<span class="font">= Just (reverse ms)</span></p>
<p class="code2"><span class="font">| p `elem` ps = bfs ps mps mqs</span></p>
<p class="code2"><span class="font">| otherwise</span><span class="space5"></span><span class="font">= bfs (p:ps) mps (succs (ms,p) ++ mqs)</span></p>
</div>
<p class="para">The additional argument is a temporary frontier used to store successors. When the first frontier is exhausted the contents of the temporary frontier are installed as the new frontier. Adding successors to the front of the temporary frontier takes time proportional to the number of successors, not to the size of the frontier, and that leads to a faster algorithm. On the other hand, the new version of <span class="font">bfs</span> is not the same as the old one because successive frontiers are traversed alternately from left to right and from right to left. Nevertheless a shortest solution will still be found if one exists.</p>
<p class="para">The second source of inefficiency is the membership test. Use of a list to store previously explored positions is slow because the membership test can take time proportional to the number of currently explored positions. It would all be easier if positions were integers in the range [0 .. <i class="calibre1">n</i>−1] for some <i class="calibre1">n</i>, for then we could use a boolean array with bounds (0, <i class="calibre1">n</i>−1) to tick off positions as they arise. The membership test would then consist of a single array lookup.</p>
<p class="para">One can imagine coding positions as integers, but not as integers in an initial segment of the natural numbers. For instance, a Sudoku position (see <a href="#text/part0009.html.8IL20-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 5</a>) can be expressed as an integer consisting of 81 digits. So suppose we have a function</p>
<p class="code"><span class="font">encode :: Position -&gt; Integer</span></p>
<p class="para">that encodes positions as integers. To reduce the range we can define</p>
<div class="space1">
<p class="code"><span class="font">hash :: Position -&gt; Int</span></p>
<p class="code"><span class="font">hash p = fromInteger (encode p) `mod` n</span></p>
</div>
<p class="para">for some suitable <span class="font">n :: Int</span>. The result of <span class="font">hash</span> is then an integer in the range <span class="font">[0..n-1]</span>.</p>
<p class="para">The one hitch, and it’s a big one, is that two distinct positions may hash to the <a id="text/part0014.html.page_259" class="calibre3"></a>same integer. To solve this problem we abandon the idea of having an array of booleans, and instead have an array of lists of positions. The positions in the array at index <i class="calibre1">k</i> are all those whose hash value is <i class="calibre1">k</i>. There is no guarantee that any of this will improve efficiency in the worst case, but if we allow <i class="calibre1">n</i> to be reasonably large, and trust that the hash function assigns integers to positions in a reasonably evenly distributed way, then the complexity of a membership test is reduced by a factor of <i class="calibre1">n</i>.</p>
<p class="para">With this hashing scheme the revised code for <span class="font">solve</span> is:</p>
<div class="space1">
<p class="code"><span class="font">solve :: Maybe [Move]</span></p>
<p class="code"><span class="font">solve = runST $</span></p>
<p class="code1"><span class="font">do {pa &lt;- newArray (0,n-1) [];</span></p>
<p class="code12"><span class="font">bfs pa [([],start)] []}</span></p>
<p class="para1"></p>
<p class="code"><span class="font">bfs :: STArray s Int [Position] -&gt; Frontier -&gt;</span></p>
<p class="code3"><span class="font">Frontier -&gt; ST s (Maybe [Move])</span></p>
<p class="code"><span class="font">bfs pa [] [] = return Nothing</span></p>
<p class="code"><span class="font">bfs pa [] mqs = bfs pa mqs []</span></p>
<p class="code"><span class="font">bfs pa ((ms,p):mps) mqs</span></p>
<p class="code2"><span class="font">= if solved p then return (Just (reverse ms))</span></p>
<p class="code11"><span class="font">else do {ps &lt;- readArray pa k;</span></p>
<p class="code12"><span class="font">if p `elem` ps</span></p>
<p class="code12"><span class="font">then bfs pa mps mqs</span></p>
<p class="code12"><span class="font">else</span></p>
<p class="code12"><span class="font">do {writeArray pa k (p:ps);</span></p>
<p class="code4"><span class="font">bfs pa mps (succs (ms,p) ++ mqs)}}</span></p>
<p class="code2"><span class="font">where k = hash p</span></p>
</div>
<h3 class="h" id="text/part0014.html.head10-6">10.6 Immutable arrays</h3>
<p class="para">We cannot leave the subject of arrays without mentioning a very nice Haskell library <span class="font">Data.Array</span> that provides purely functional operations on immutable arrays. The operations are implemented using mutable arrays, but the interface is purely functional.</p>
<p class="para">The type <span class="font">Array i e</span> is an abstract type of arrays with indices of type <span class="font">i</span> and elements of type <span class="font">e</span>. One basic operation for constructing arrays is</p>
<p class="code"><span class="font">array :: Ix i =&gt; (i,i) -&gt; [(i,e)] -&gt; Array i e</span></p>
<p class="para"><a id="text/part0014.html.page_260" class="calibre3"></a>This function take a pair of bounds, the lowest and highest indices in the array, and a list of index-element pairs specifying the array entries. The result is an array with the given bounds and entries. Any entry missing from the association list is deemed to be the undefined entry. If two entries have the same index, or one of the indices is out of bounds, the undefined array is returned. Because of these checks, array construction is strict in the indices, though lazy in the elements. Building the array takes linear time in the number of entries.</p>
<p class="para">A simple variant of <span class="font">array</span> is <span class="font">listArray</span> which takes just a list of elements:</p>
<div class="space1">
<p class="code"><span class="font">listArray :: Ix i =&gt; (i,i) -&gt; [e] -&gt; Array i e</span></p>
<p class="code"><span class="font">listArray (l,r) xs = array (l,r) (zip [l..r] xs)</span></p>
</div>
<p class="para">Finally, there is another way of building arrays called <span class="font">accumArray</span> whose type appears rather daunting:</p>
<p class="code"><span class="font">Ix i =&gt; (e -&gt; v -&gt; e) -&gt; e -&gt; (i,i) -&gt; [(i,v)] -&gt; Array i e</span></p>
<p class="para">The first argument is an ‘accumulating’ function for transforming array entries and new values into new entries. The second argument is an initial entry for each index. The third argument is a pair of bounds, and the fourth and final argument is an association list of index–value pairs. The result is an array built by processing the association list from left to right, combining entries and values into new entries using the accumulating function. The process takes linear time in the length of the association list, assuming the accumulating function takes constant time.</p>
<p class="para">That’s what <span class="font">accumArray</span> does in words. In symbols,</p>
<p class="code"><span class="font">elems (accumArray f e (l,r) ivs)</span></p>
<p class="code2"><span class="font">= [foldl f e [v | (i,v) &lt;- ivs, i==j] | j &lt;- [l..r]]</span></p>
<p class="para">where <span class="font">elems</span> returns the list of elements of an array in index order. Well, the identity above is not quite true: there is an additional restriction on <span class="font">ivs</span>, namely that every index should lie in the specified range. If this condition is not met, then the left-hand side returns an error while the right-hand side does not.</p>
<p class="para">Complicated as <span class="font">accumArray</span> seems, it turns out to be a very useful tool for solving certain kinds of problem. Here are two examples. First, consider the problem of representing directed graphs. Directed graphs are usually described in mathematics in terms of a set of <i class="calibre1">vertices</i> and a set of <i class="calibre1">edges</i>. An edge is an ordered pair (<i class="calibre1">j</i>, <i class="calibre1">k</i>) of vertices signifying that the edge is directed from <i class="calibre1">j</i> to <i class="calibre1">k</i>. We say that <i class="calibre1">k</i> is <i class="calibre1">adjacent</i> to <i class="calibre1">j</i>. We will suppose that vertices are named by integers in the range 1 to <i class="calibre1">n</i> for some <i class="calibre1">n</i>. Thus</p>
<p class="code"><span class="font">type Vertex = Int</span></p>
<p class="code"><a id="text/part0014.html.page_261" class="calibre3"></a><span class="font">type Edge</span><span class="space5"></span><span class="font">= (Vertex,Vertex)</span></p>
<p class="code"><span class="font">type Graph</span><span class="space-toc1"></span><span class="font">= ([Vertex],[Edge])</span></p>
<p class="para1"></p>
<p class="code"><span class="font">vertices g = fst g</span></p>
<p class="code"><span class="font">edges g</span><span class="space5"></span><span class="font">&nbsp;= snd g</span></p>
</div>
<p class="para">In computing, directed graphs are often described in terms of adjacency lists:</p>
<div class="space1">
<p class="code"><span class="font">adjs :: Graph -&gt; Vertex -&gt; [Vertex]</span></p>
<p class="code"><span class="font">adjs g v = [k | (j,k) &lt;- edges g, j==v]</span></p>
</div>
<p class="para">The problem with this definition of <span class="font">adjs</span> is that it takes time proportional to the number of edges to compute the adjacency list of any particular vertex. Better is to implement <span class="font">adjs</span> as an array:</p>
<p class="code"><span class="font">adjArray :: Graph -&gt; Array Vertex [Vertex]</span></p>
<p class="para">Then we have</p>
<p class="code"><span class="font">adjs g v = (adjArray g)!v</span></p>
<p class="para">where <span class="font">(!)</span> denotes the operation of array-indexing. For reasonably sized arrays this operation takes constant time.</p>
<p class="para">The specification of <span class="font">adjArray</span> is that</p>
<p class="code"><span class="font">elems (adjArray g)</span></p>
<p class="code"><span class="space-r"></span><span class="font">= [[k | (j,k) &lt;- edges g, j==v] | v &lt;- vertices g]</span></p>
<p class="para">Using this specification we can calculate a direct definition of <span class="font">adjArray</span>. To keep each line short, abbreviate <span class="font">edges g</span> to <span class="font">es</span> and <span class="font">vertices g</span> to <span class="font">vs</span>, so</p>
<p class="code"><span class="font">elems (adjArray g) = [[k | (j,k) &lt;- es, j==v] | v &lt;- vs]</span></p>
<p class="para">Concentrating on the right-hand side, the first step is to rewrite it using the law <span class="font">foldr (:) [] = id</span>. That gives the expression</p>
<p class="code"><span class="font">[foldr (:) [] [k | (j,k) &lt;- es, j==v] | v &lt;- vs]</span></p>
<p class="para">Next we use the law <span class="font">foldr f e xs = foldl (flip f) e (reverse xs)</span> for all finite lists <span class="font">xs</span>. Abbreviating <span class="font">flip (:)</span> to <span class="font">(@)</span>, we obtain</p>
<p class="code"><span class="font">[foldl (@) [] (reverse [k | (j,k) &lt;- es, j==v]) | v &lt;- vs]</span></p>
<p class="para">Distributing <span class="font">reverse</span> we obtain the expression</p>
<p class="code"><span class="font">[foldl (@) [] [k | (j,k) &lt;- reverse es, j==v] | v &lt;- vs]</span></p>
<p class="para">Next we use <span class="font">swap (j,k) = (k,j)</span> to obtain</p>
<p class="code"><a id="text/part0014.html.page_262" class="calibre3"></a><span class="font">[foldl (@) [] [j | (k,j) &lt;- es', j==v] | v &lt;- vs]</span></p>
<p class="para">where <span class="font">es' = map swap (reverse es)</span>. Finally, using <span class="font">n = length vs</span> and the specification of <span class="font">accumArray</span>, we obtain</p>
<div class="space1">
<p class="code2"><span class="font">elems (adjArray g)</span></p>
<p class="code"><span class="font">= elems (accumArray (flip (:)) [] (1,n) es')</span></p>
</div>
<p class="para">That means we can define</p>
<p class="code"><span class="font">adjArray g = accumArray (flip (:)) [] (1,n) es</span></p>
<p class="code9"><span class="font">where n = length (vertices g)</span></p>
<p class="code17"><span class="font">es = map swap (reverse (edges g))</span></p>
</div>
<p class="para">This definition of <span class="font">adjArray g</span> computes the successors in time proportional to the number of edges.</p>
<p class="para">Here is the second example of the use of <span class="font">accumArray</span>. Suppose we are given a list of <i class="calibre1">n</i> integers, all in the range (0, <i class="calibre1">m</i>) for some <i class="calibre1">m</i>. We can sort this list in Θ(<i class="calibre1">m</i>+<i class="calibre1">n</i>) steps by counting the number of times each element occurs:</p>
<div class="space1">
<p class="code"><span class="font">count :: [Int] -&gt; Array Int Int</span></p>
<p class="code"><span class="font">count xs = accumArray (+) 0 (0,m) (zip xs (repeat 1))</span></p>
</div>
<p class="para">The value <span class="font">repeat 1</span> is an infinite list of <span class="font">1</span>s. Counting takes Θ(<i class="calibre1">n</i>) steps. Having counted the elements, we can now sort them:</p>
<p class="code"><span class="font">sort xs = concat [replicate c x</span></p>
<p class="code5"><span class="font">| (x,c) &lt;- assocs (count xa)]</span></p>
<p class="para">The function <span class="font">assocs</span> is yet another library function and returns the list of index– element pairs of an array in index order. The sorting is completed in Θ(<i class="calibre1">m</i>) steps.</p>
<p class="para">As well as the above operations <span class="font">Data.Array</span> contains one or two more, including the update operation <span class="font">(//)</span>:</p>
<p class="code"><span class="font">(//) :: Ix i =&gt; Array i e -&gt; [(i,e)] -&gt; Array i e</span></p>
<p class="para">For example, if <span class="font">xa</span> is an <i class="calibre1">n</i> × <i class="calibre1">n</i> matrix, then</p>
<p class="code"><span class="font">xa // [((i,i),0) | i &lt;- [1..n]]</span></p>
<p class="para">is the same matrix except with zeros along the diagonal. The downside of <span class="font">(//)</span> is that it takes time proportional to the size of the array, even for an update involving a single element. The reason is that a completely new array has to be constructed because the old array <span class="font">xa</span> continues to exist.</p>
<p class="para">We have ended the chapter back in the world of pure functional programming, <a id="text/part0014.html.page_263" class="calibre3"></a>where equational reasoning can be used both to calculate definitions and to optimise them. Although the monadic style is attractive to programmers who are used to imperative programming, there remains the problem of how to reason about monadic programs. True, equational reasoning is still possible in certain situtations (see Exercise F for an example), but it is not so widely applicable as it is in the pure functional world (witness the correctness of the partition phase of Quicksort). Imperative programmers have the same problem, which they solve (if they bother to) by using predicate calculus, preconditions, postconditions and loop invariants. How to reason directly with monadic code is still a topic of ongoing research.</p>
<p class="para">Our best advice is to use the monadic style sparingly and only when it is really useful; otherwise the most important aspect of functional programming, the ability to reason mathematically about its constructs, is lost.</p>
<h3 class="h" id="text/part0014.html.head10-7">10.7 Exercises</h3>
<p class="theorem"><b class="calibre7">Exercise A</b></p>
<p class="para">Recall that</p>
<p class="code"><span class="font">putStr = foldr (&gt;&gt;) done . map putChar</span></p>
<p class="para">What does</p>
<p class="code"><span class="font">foldl (&gt;&gt;) done . map putChar</span></p>
<p class="para">do? Justify your answer by expressing <span class="font">(&gt;&gt;)</span> in terms of <span class="font">(&gt;&gt;=)</span> and appealing to the monad laws.</p>
<p class="theorem"><b class="calibre7">Exercise B</b></p>
<p class="para">Using a pattern-matching style, define a function</p>
<p class="code"><span class="font">add3 :: Maybe Int -&gt; Maybe Int -&gt; Maybe Int -&gt; Maybe Int</span></p>
<p class="para">that adds three numbers, provided all of them exist. Now rewrite <span class="font">add3</span> using the <span class="font">Maybe</span> monad.</p>
<p class="theorem"><b class="calibre7">Exercise C</b></p>
<p class="para">The monadic definition of <span class="font">cp</span> in <a href="#text/part0014.html.head10-1" class="calibre3">Section 10.1</a> is still inefficient. We might prefer to write</p>
<p class="code"><a id="text/part0014.html.page_264" class="calibre3"></a><span class="font">cp (xs:xss) = do {ys &lt;- cp xss;</span></p>
<p class="code5"><span class="font">x &lt;- xs;</span></p>
<p class="code5"><span class="font">return (x:ys)}</span></p>
<p class="para">By definition a <i class="calibre1">commutative</i> monad is one in which the equation</p>
<div class="space1">
<p class="code2"><span class="font">do {x &lt;- p; y &lt;- q; f x y}</span></p>
<p class="code"><span class="font">= do {y &lt;- q; x &lt;- p; f x y}</span></p>
</div>
<p class="para">holds. The <span class="font">IO</span> monad is certainly not commutative, while some other monads are. Is the <span class="font">Maybe</span> monad commutative?</p>
<p class="theorem"><b class="calibre7">Exercise D</b></p>
<p class="para">Every monad is a functor. Complete the definition</p>
<div class="space1">
<p class="code"><span class="font">instance Monad m =&gt; Functor m where</span></p>
<p class="code2"><span class="font">fmap :: (a -&gt; b) -&gt; m a -&gt; m b</span></p>
<p class="code2"><span class="font">fmap f = ...</span></p>
</div>
<p class="para">Currently Haskell does not insist that the <span class="font">Monad</span> class should be a subclass of <span class="font">Functor</span>, though there are plans to change this in future releases. Instead, Haskell provides a function <span class="font">liftM</span> equivalent to <span class="font">fmap</span> for monads. Give a definition of <span class="font">liftM</span> in terms of <span class="font">return</span> and <span class="font">&gt;&gt;=</span>.</p>
<p class="para">The function <span class="font">join :: m (m a) -&gt; m a</span> flattens two layers of monadic structure into one. Define <span class="font">join</span> in terms of <span class="font">&gt;&gt;=</span>. What familiar functions do <span class="font">join</span> and <span class="font">liftM</span> give for the list monad?</p>
<p class="para">Finally, using <span class="font">join</span> and <span class="font">liftM</span>, define <span class="font">(&gt;&gt;=)</span>. It follows that instead of defining monads in terms of <span class="font">return</span> and <span class="font">&gt;&gt;=</span>, we can also define them in terms of <span class="font">return</span>, <span class="font">liftM</span> and <span class="font">join</span>.</p>
<p class="theorem"><b class="calibre7">Exercise E</b></p>
<p class="para">A number of useful monadic functions are provided in the <span class="font">Control.Monad</span> library. For instance:</p>
<div class="space1">
<p class="code"><span class="font">sequence_ :: Monad m =&gt; [m a] -&gt; m ()</span></p>
<p class="code"><span class="font">sequence_ = foldr (&gt;&gt;) done</span></p>
</div>
<p class="para">(The underscore convention is used in a number of places in Haskell to signify that the result of the action is the null tuple.) Define the related function</p>
<p class="code"><span class="font">sequence :: Monad m =&gt; [m a] -&gt; m [a]</span></p>
<p class="para">Using these two functions, define</p>
<a id="text/part0014.html.page_265" class="calibre3"></a>
<div class="space1">
<p class="code"><span class="font">mapM_ :: Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m ()</span></p>
<p class="code"><span class="font">mapM :: Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]</span></p>
</div>
<p class="para">Also, define</p>
<p class="code"><span class="font">foldM :: Monad m =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; [a] -&gt; m b</span></p>
<p class="para">In the text we made use of a function <span class="font">repeatFor n</span> that repeated an action <span class="font">n</span> times. Generalise this function to</p>
<p class="code"><span class="font">for_ :: Monad m =&gt; [a] -&gt; (a -&gt; m b) -&gt; m ()</span></p>
<p class="theorem"><b class="calibre7">Exercise F</b></p>
<p class="para">Here is an exercise in monadic equational reasoning. Consider the function</p>
<div class="space1">
<p class="code"><span class="font">add :: Int -&gt; State Int ()</span></p>
<p class="code"><span class="font">add n = do {m &lt;- get; put (m+n)}</span></p>
</div>
<p class="para">The task is to prove that</p>
<p class="code"><span class="font">sequence_ . map add = add . sum</span></p>
<p class="para">where <span class="font">sequence_</span> was defined in the previous exercise and <span class="font">sum</span> sums a list of integers. You will need the fusion law of <span class="font">foldr</span>, some simple laws of <span class="font">put</span> and <span class="font">get</span>, and the monad law</p>
<p class="code"><span class="font">do {stmts1} &gt;&gt; do {stmts2} = do {stmts1;stmts2}</span></p>
<p class="para">which is valid provided the variables in <span class="font">stmts1</span> and <span class="font">stmts2</span> are disjoint.</p>
<p class="theorem"><b class="calibre7">Exercise G</b></p>
<p class="para">Prove the leapfrog rule: <span class="font">(f &gt;=&gt; g) . h = (f . h) &gt;=&gt; g</span>. Using this rule, prove: <span class="font">(return . h) &gt;=&gt; g = g . h</span>.</p>
<p class="theorem"><b class="calibre7">Exercise H</b></p>
<p class="para">Prove that</p>
<div class="space1">
<p class="code"><span class="font">liftM f = id &gt;=&gt; (return . f)</span></p>
<p class="code"><span class="font">join = id &gt;=&gt; id</span></p>
</div>
<p class="para">A fourth way of describing the monad laws is in terms of the two functions <span class="font">liftM</span> and <span class="font">join</span> of Exercise D. There are seven laws governing these two functions, all of which have a familiar ring:</p>
<div class="space1">
<p class="code"><a id="text/part0014.html.page_266" class="calibre3"></a><span class="font">liftM id</span><span class="space4"></span><span class="space-r"></span><span class="font">= id</span></p>
<p class="code"><span class="font">liftM (f . g) = liftM f . liftM g</span></p>
<p class="para1"></p>
<p class="code"><span class="font">liftM f . return = return . f</span></p>
<p class="code"><span class="font">liftM f . join</span><span class="space5"></span><span class="font">= join . liftM (liftM f)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">join . return</span><span class="space2"></span><span class="font">= id</span></p>
<p class="code"><span class="font">join . liftM return = id</span></p>
<p class="code"><span class="font">join . liftM join</span><span class="space5"></span><span class="font">= join . join</span></p>
</div>
<p class="para">Prove the fourth rule.</p>
<p class="theorem"><b class="calibre7">Exercise I</b></p>
<p class="para">What does <span class="font">build []</span> do (see <a href="#text/part0014.html.head10-3" class="calibre3">Section 10.3</a>)?</p>
<p class="theorem"><b class="calibre7">Exercise J</b></p>
<p class="para">Write an interactive program to play hangman. An example session:</p>
<p class="code6"><span class="font">ghci&gt; hangman</span></p>
<p class="code6"><span class="font">I am thinking of a word:</span></p>
<p class="code6"><span class="font">-----</span></p>
<p class="code6"><span class="font">Try and guess it.</span></p>
<p class="code6"><span class="font">guess: break</span></p>
<p class="code6"><span class="font">-a---</span></p>
<p class="code6"><span class="font">guess: parties</span></p>
<p class="code6"><span class="font">Wrong number of letters!</span></p>
<p class="code6"><span class="font">guess: party</span></p>
<p class="code6"><span class="font">-appy</span></p>
<p class="code6"><span class="font">guess: happy</span></p>
<p class="code6"><span class="font">You got it!</span></p>
<p class="code6"><span class="font">Play again? (yes or no)</span></p>
<p class="code6"><span class="font">no</span></p>
<p class="code6"><span class="font">Bye!</span></p>
<p class="para">Assume that a list of secret words is stored in a file called <span class="font">Words</span>, so that the action <span class="font">xs &lt;- readFile "Words"</span> reads the file as a list of characters. By the way, <span class="font">readFile</span> is lazy in that its contents are read on demand.</p>
<p class="theorem"><b class="calibre7">Exercise K</b></p>
<p class="para">Write another version of <span class="font">fib</span> in terms of a <span class="font">fibST</span> that uses a single <span class="font">STRef</span>.</p>
<p class="theorem"><a id="text/part0014.html.page_267" class="calibre3"></a><b class="calibre7">Exercise L</b></p>
<p class="para">One way of defining the greatest common divisor (<span class="font">gcd</span>) of two positive integers is:</p>
<div class="space1">
<p class="code"><span class="font">gcd (x,y) | x==y = x</span></p>
<p class="code10"><span class="font">| x&lt;y = gcd (x,y-x)</span></p>
<p class="code10"><span class="font">| x&gt;y = gcd (x-y,y)</span></p>
</div>
<p class="para">Translate this definition into two other programs, one of which uses the <span class="font">State</span> monad and the other the <span class="font">ST</span> monad.</p>
<p class="theorem"><b class="calibre7">Exercise M</b></p>
<p class="para">Here is a concrete puzzle you can solve using breadth-first search. A cut-down version of Sam Loyd’s famous 15 puzzle is the 8 puzzle. You are given a 3 × 3 array containing tiles numbered from 1 to 8 and one blank space. You move by sliding an adjacent tile into the blank space. Depending on where the blank space is, you can slide tiles upwards, downwards, to the left or to the right. At the start the blank space is in the top left corner and the tiles read from 1 to 8. At the end the blank space is in the bottom right corner, but the tiles are still neatly arranged in the order 1 to 8.</p>
<p class="para">Your mission, should you choose to accept it, is to settle on a suitable representation of positions and moves, and to define the functions <span class="font">moves</span>, <span class="font">move</span>, <span class="font">solved</span> and <span class="font">encode</span>.</p>
<h3 class="h" id="text/part0014.html.head10-8">10.8 Answers</h3>
<p class="theorem"><b class="calibre7">Answer to Exercise A</b></p>
<p class="para">We claim that <span class="font">(&gt;&gt;) :: IO () -&gt; IO () -&gt; IO ()</span> is associative with identity element <span class="font">done</span>. That means</p>
<p class="code"><span class="font">putStr xs = foldl (&gt;&gt;) done (map putChar xs)</span></p>
<p class="para">for all finite strings <span class="font">xs</span></p>
<p class="para">We concentrate on the proof of associativity. Firstly, for actions in <span class="font">IO ()</span> we have</p>
<p class="code"><span class="font">p &gt;&gt; q = p &gt;&gt;= const q</span></p>
<p class="para"><a id="text/part0014.html.page_268" class="calibre3"></a>where <span class="font">const x y = x</span>. Now we can reason:</p>
<div class="space1">
<p class="code10"><span class="font">(p &gt;&gt; q) &gt;&gt; r</span></p>
<p class="code1"><span class="font">=</span><span class="space"></span>{definition of <span class="font">(&gt;&gt;)</span>}</p>
<p class="code10"><span class="font">(p &gt;&gt;= const q) &gt;&gt;= const r</span></p>
<p class="code1"><span class="font">=</span><span class="space"></span>{third monad law}</p>
<p class="code10"><span class="font">p &gt;&gt;= const (q &gt;&gt;= const r)</span></p>
<p class="code1"><span class="font">=</span><span class="space"></span>{definition of <span class="font">(&gt;&gt;)</span>}</p>
<p class="code10"><span class="font">p &gt;&gt;= const (q &gt;&gt; r)</span></p>
<p class="code1"><span class="font">=</span><span class="space"></span>{definition of <span class="font">(&gt;&gt;)</span>}</p>
<p class="code10"><span class="font">p &gt;&gt; (q &gt;&gt; r)</span></p>
</div>
<p class="theorem"><b class="calibre7">Answer to Exercise B</b></p>
<p class="para">The direct version uses pattern matching with a wild-card:</p>
<div class="space1">
<p class="code"><span class="font">add3 Nothing _ _</span><span class="space3"></span><span class="space4"></span><span class="space-r"></span><span class="font">= Nothing</span></p>
<p class="code"><span class="font">add3 (Just x) Nothing _</span><span class="space8"></span><span class="space-r1"></span><span class="font">= Nothing</span></p>
<p class="code"><span class="font">add3 (Just x) (Just y) Nothing</span><span class="space-toc1"></span><span class="font">= Nothing</span></p>
<p class="code"><span class="font">add3 (Just x) (Just y) (Just z) = Just (x+y+z)</span></p>
</div>
<p class="para">This definition ensures that <span class="font">add Nothing undefined = Nothing</span>.</p>
<p class="para">The monadic version reads:</p>
<div class="space1">
<p class="code"><span class="font">add3 mx my mz</span></p>
<p class="code"><span class="font">= do {x &lt;- mx; y &lt;- my; z &lt;- mz;</span></p>
<p class="code8"><span class="font">return (x + y + z)}</span></p>
</div>
<p class="theorem"><b class="calibre7">Answer to Exercise C</b></p>
<p class="para">Yes. The commutative law states that</p>
<div class="space1">
<p class="code2"><span class="font">p &gt;&gt;= \x -&gt; q &gt;&gt;= \y -&gt; f x y</span></p>
<p class="code"><span class="font">= q &gt;&gt;= \y -&gt; p &gt;&gt;= \x -&gt; f x y</span></p>
</div>
<p class="para">In the <span class="font">Maybe</span> monad there are four possible cases to check. For example, both sides simplify to <span class="font">Nothing</span> if <span class="font">p = Nothing</span> and <span class="font">q = Just y</span>, . The other cases are similar.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise D</b></p>
<p class="para">We have</p>
<a id="text/part0014.html.page_269" class="calibre3"></a>
<div class="space1">
<p class="code"><span class="font">fmap f p = p &gt;&gt;= (return . f)</span></p>
<p class="code"><span class="font">join p = p &gt;&gt;= id</span></p>
</div>
<p class="para">For the list monad we have <span class="font">liftM = map</span> and <span class="font">join = concat</span>.</p>
<p class="para">In the other direction</p>
<p class="code"><span class="font">p &gt;&gt;= f = join (liftM f p)</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise E</b></p>
<p class="para">The function <span class="font">sequence</span> is defined by</p>
<div class="space1">
<p class="code"><span class="font">sequence :: Monad m =&gt; [m a] -&gt; m [a]</span></p>
<p class="code"><span class="font">sequence = foldr k (return [])</span></p>
<p class="code2"><span class="font">where k p q = do {x &lt;- p; xs &lt;- q; return (x:xs)}</span></p>
</div>
<p class="para">The two new map functions are:</p>
<div class="space1">
<p class="code"><span class="font">mapM_ f = sequence_ . map f</span></p>
<p class="code"><span class="font">mapM f</span><span class="space"></span><span class="font">= sequence . map f</span></p>
</div>
<p class="para">The function <span class="font">foldM</span> is defined by</p>
<div class="space1">
<p class="code"><span class="font">foldM :: Monad m =&gt; (b -&gt; a -&gt; m b) -&gt;</span></p>
<p class="code10"><span class="font">b -&gt; [a] -&gt; m b</span></p>
<p class="code"><span class="font">foldM f e []</span><span class="space4"></span><span class="font">= return e</span></p>
<p class="code"><span class="font">foldM f e (x:xs) = do {y &lt;- f e x; foldM f y xs}</span></p>
</div>
<p class="para">Note that <span class="font">foldM</span> is analogous to <span class="font">foldl</span> in that it works from left to right. Finally <span class="font">for = flip mapM_</span>.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise F</b></p>
<p class="para">The first thing to note is that</p>
<div class="space1">
<p class="code2"><span class="font">sequence_ . map add</span></p>
<p class="code"><span class="font">= foldr (&gt;&gt;) done . map add</span></p>
<p class="code"><span class="font">= foldr ((&gt;&gt;) . add) done</span></p>
</div>
<p class="para">using the fusion law of <span class="font">foldr</span> and <span class="font">map</span> given in <a href="#text/part0010.html.head6-3" class="calibre3">Section 6.3</a>. Moreover,</p>
<p class="code"><span class="font">((&gt;&gt;) . add) n p = add n &gt;&gt; p</span></p>
<p class="para">Since <span class="font">sum = foldr (+) 0</span> that means we have to prove</p>
<p class="code"><span class="font">foldr (\ n p -&gt; add n &gt;&gt; p) = add . foldr (+) 0</span></p>
<p class="para"><a id="text/part0014.html.page_270" class="calibre3"></a>That looks like an instance of the fusion law of <span class="font">foldr</span>. We therefore have to show that <span class="font">add</span> is strict (which it is), and</p>
<div class="space1">
<p class="code"><span class="font">add 0 = done</span></p>
<p class="code"><span class="font">add (n + n') = add n &gt;&gt; add n'</span></p>
</div>
<p class="para">Here goes:</p>
<div class="space1">
<p class="code1"><span class="font">add 0</span></p>
<p class="code3"><span class="font">=</span><span class="space"></span>{definition}</p>
<p class="code1"><span class="font">do</span> {<span class="font">m &lt;- get; put (m+0)</span>}</p>
<p class="code3"><span class="font">=</span><span class="space"></span>{arithmetic}</p>
<p class="code1"><span class="font">do</span> {<span class="font">m &lt;- get; put m</span>}</p>
<p class="code3"><span class="font">=</span><span class="space"></span>{simple law of <span class="font">put</span> and <span class="font">get</span>}</p>
<p class="code1"><span class="font">done</span></p>
</div>
<p class="para">That disposes of the first condition. For the second we start with the more complicated side and reason:</p>
<div class="space1">
<p class="code8"><span class="font">add n &gt;&gt; add n’</span></p>
<p class="code11"><span class="font">=</span><span class="space"></span>{definition}</p>
<p class="code8"><span class="font">do</span> {<span class="font">l &lt;- get; put (l + n)</span> } <span class="font">&gt;&gt;</span></p>
<p class="code8"><span class="font">do</span> {<span class="font">m &lt;- get; put (m + n’)</span>}</p>
<p class="code11"><span class="font">=</span><span class="space"></span>{monad law}</p>
<p class="code8"><span class="font">do</span> {<span class="font">l &lt;- get; put (l + n); m &lt;- get; put (m + n’)</span>}</p>
<p class="code11"><span class="font">=</span><span class="space"></span>{simple law of <span class="font">put</span> and <span class="font">get</span>}</p>
<p class="code8"><span class="font">do</span> {<span class="font">l &lt;- get; put ((l + n) + n’)</span>}</p>
<p class="code11"><span class="font">=</span><span class="space"></span>{associativity of <span class="font">(+); definition of add</span>}</p>
<p class="code8"><span class="font">add (n + n’)</span></p>
</div>
<p class="theorem"><b class="calibre7">Answer to Exercise G</b></p>
<p class="para">We can reason:</p>
<div class="space1">
<p class="code9"><span class="font">(f &gt;=&gt; g) (h x)</span></p>
<p class="code12"><span class="font">=</span><span class="space"></span>{definition of <span class="font">(&gt;=&gt;)</span>}</p>
<p class="code9"><span class="font">f (h x) &gt;&gt;= g</span></p>
<p class="code12"><span class="font">=</span><span class="space"></span>{definition of <span class="font">(&gt;=&gt;)</span>}</p>
<p class="code9"><span class="font">(f . h &gt;=&gt; g) x</span></p>
</div>
<p class="para"><a id="text/part0014.html.page_271" class="calibre3"></a>For the second part:</p>
<div class="space1">
<p class="code9"><span class="font">(return . h) &gt;=&gt; g</span></p>
<p class="code12"><span class="font">=</span><span class="space"></span>{leapfrog rule}</p>
<p class="code9"><span class="font">(return &gt;=&gt; g) . h</span></p>
<p class="code12"><span class="font">=</span><span class="space"></span>{monad law}</p>
<p class="code9"><span class="font">g . h</span></p>
</div>
<p class="theorem"><b class="calibre7">Answer to Exercise H</b></p>
<p class="para">For the fourth rule we simplify both sides. For the left-hand side:</p>
<div class="space1">
<p class="code1"><span class="font">liftM f . join</span></p>
<p class="code3"><span class="font">=</span><span class="space"></span>{definitions}</p>
<p class="code1"><span class="font">(id &gt;=&gt; (return . f)) . (id &gt;=&gt; id)</span></p>
<p class="code3"><span class="font">=</span><span class="space"></span>{leapfrog rule and <span class="font">id . f = f</span>}</p>
<p class="code1"><span class="font">(id &gt;=&gt; id) &gt;=&gt; (return . f)</span></p>
</div>
<p class="para">For the right-hand side:</p>
<div class="space1">
<p class="code2"><span class="font">join . liftM (liftM f)</span></p>
<p class="code"><span class="font">=</span><span class="space"></span>{definitions}</p>
<p class="code2"><span class="font">(id &gt;=&gt; id) . (id &gt;=&gt; return . (id &gt;=&gt; (return . f)))</span></p>
<p class="code"><span class="font">=</span><span class="space"></span>{leapfrog rule, and associativity of <span class="font">(&gt;=&gt;)</span>}</p>
<p class="code2"><span class="font">id &gt;=&gt; (return . (id &gt;=&gt; (return . f))) &gt;=&gt; id</span></p>
<p class="code"><span class="font">=</span><span class="space"></span>{since <span class="font">(return . h) &gt;=&gt; g = g . h</span>}</p>
<p class="code2"><span class="font">id &gt;=&gt; id &gt;=&gt; (return . f)</span></p>
</div>
<p class="para">The two sides are equal because <span class="font">(&gt;=&gt;)</span> is associative.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise I</b></p>
<p class="para"><span class="font">build []</span> causes an infinite loop, so its value is ⊥.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise J</b></p>
<p class="para">For the main function we can define</p>
<div class="space1">
<p class="code"><span class="font">hangman :: IO ()</span></p>
<p class="code"><span class="font">hangman = do {xs &lt;- readFile "Words";</span></p>
<p class="code9"><span class="font">play (words xs)}</span></p>
</div>
<p class="para"><a id="text/part0014.html.page_272" class="calibre3"></a>The function <span class="font">play</span> plays as many rounds of the game as desired with different words from the file (which we quietly suppose always has enough words):</p>
<div class="space1">
<p class="code"><span class="font">play (w:ws)</span></p>
<p class="code"><span class="font">= do {putStrLn "I am thinking of a word:";</span></p>
<p class="code8"><span class="space-r"></span><span class="font">putStrLn (replicate (length w) '-');</span></p>
<p class="code8"><span class="space-r"></span><span class="font">putStrLn "Try and guess it.";</span></p>
<p class="code8"><span class="space-r"></span><span class="font">guess w ws}</span></p>
</div>
<p class="para">The function <span class="font">guess</span> deals with a single guess, but keeps the remaining words for any subsequent round of play:</p>
<div class="space1">
<p class="code"><span class="font">guess w ws</span></p>
<p class="code"><span class="font">= do {putStr "guess: ";</span></p>
<p class="code3"><span class="font">w' &lt;- getLine;</span></p>
<p class="code3"><span class="font">if length w' /= length w then</span></p>
<p class="code3"><span class="font">do {putStrLn "Wrong number of letters!";</span></p>
<p class="code10"><span class="font">guess w ws}</span></p>
<p class="code3"><span class="font">else if w' == w</span></p>
<p class="code3"><span class="font">then</span></p>
<p class="code3"><span class="font">do {putStrLn "You got it!";</span></p>
<p class="code10"><span class="font">putStrLn "Play again? (yes or no)";</span></p>
<p class="code10"><span class="font">ans &lt;- getLine;</span></p>
<p class="code10"><span class="font">if ans == "yes"</span></p>
<p class="code10"><span class="font">then play ws</span></p>
<p class="code10"><span class="font">else putStrLn "Bye!"}</span></p>
<p class="code3"><span class="font">else do {putStrLn (match w' w);</span></p>
<p class="code4"><span class="font">guess w ws}}</span></p>
</div>
<p class="para">Finally we program <span class="font">match</span>:</p>
<p class="code"><span class="font">match w' w = map check w</span></p>
<p class="code2"><span class="font">where</span></p>
<p class="code2"><span class="font">check x = if x `elem` w' then x else '-'</span></p>
</div>
<p class="theorem"><b class="calibre7">Answer to Exercise K</b></p>
<p class="para">The following program is correct but doesn’t run in constant space:</p>
<p class="code"><span class="font">fib n = fst $ runST (fibST n)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">fibST :: Int -&gt; ST s (Integer,Integer)</span></p>
<p class="code"><span class="font">fibST n = do {ab &lt;- newSTRef (0,1);</span></p>
<p class="code2"><a id="text/part0014.html.page_273" class="calibre3"></a><span class="font">repeatFor n</span></p>
<p class="code11"><span class="font">(do {(a,b) &lt;- readSTRef ab;</span></p>
<p class="code1"><span class="font">writeSTRef ab $! (b,a+b)});</span></p>
<p class="code2"><span class="font">readSTRef ab}</span></p>
<p class="para">The reason is that <span class="font">(b,a+b)</span> is already in head-normal form, so strict-apply has no effect. The penultimate line needs to be changed to</p>
<p class="code"><span class="font">b `seq` (a+b) `seq` writeSTRef ab (b,a+b)</span></p>
<p class="para">in order to force evaluation of the components.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise L</b></p>
<p class="para">The version that uses the <span class="font">State</span> monad:</p>
<p class="code"><span class="font">gcd (x,y) = fst $ runState loop (x,y)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">loop :: State (Int,Int) Int</span></p>
<p class="code"><span class="font">loop = do {(x,y) &lt;- get;</span></p>
<p class="code10"><span class="font">if x == y</span></p>
<p class="code10"><span class="font">then return x</span></p>
<p class="code10"><span class="font">else if x &lt; y</span></p>
<p class="code10"><span class="font">then do {put (x,y-x); loop}</span></p>
<p class="code10"><span class="font">else do {put (x-y,y); loop}}</span></p>
</div>
<p class="para">The version that uses the <span class="font">ST</span> monad:</p>
<p class="code"><span class="font">gcd (x,y) = runST $</span></p>
<p class="code12"><span class="font">do {a &lt;- newSTRef x;</span></p>
<p class="code4"><span class="font">b &lt;- newSTRef y;</span></p>
<p class="code4"><span class="font">loop a b}</span></p>
<p class="para1"></p>
<p class="code"><span class="font">loop :: STRef s Int -&gt; STRef s Int -&gt; ST s Int</span></p>
<p class="code"><span class="font">loop a b</span></p>
<p class="code"><span class="font">= do {x &lt;- readSTRef a;</span></p>
<p class="code8"><span class="font">y &lt;- readSTRef b;</span></p>
<p class="code8"><span class="font">if x==y</span></p>
<p class="code8"><span class="font">then return x</span></p>
<p class="code8"><span class="font">else if x&lt;y</span></p>
<p class="code8"><span class="font">then do {writeSTRef b (y-x);loop a b}</span></p>
<p class="code8"><span class="font">else do {writeSTRef a (x-y);loop a b}}</span></p>
<p class="theorem"><a id="text/part0014.html.page_274" class="calibre3"></a><b class="calibre7">Answer to Exercise M</b></p>
<p class="para">There are, of course, many possible answers. The one I chose was to represent the array of tiles by a list of nine digits [0 .. 8] with zero representing the space. To avoid recalculation, a position is represented by a pair (<i class="calibre1">j</i>,<i class="calibre1">ks</i>) with <i class="calibre1">j</i> as the position of the zero in <i class="calibre1">ks</i>, where <i class="calibre1">ks</i> was some permutation of [0 .. 8]. Thus:</p>
<div class="space1">
<p class="code"><span class="font">type Position = (Int,[Int])</span></p>
<p class="code"><span class="font">data Move</span><span class="space4"></span><span class="font">= Up | Down | Left | Right</span></p>
<p class="para1"></p>
<p class="code"><span class="font">encode :: Position -&gt; Integer</span></p>
<p class="code"><span class="font">encode (j,ks) = foldl op 0 ks</span></p>
<p class="code2"><span class="font">where op x d = 10*x + fromIntegral d</span></p>
<p class="para1"></p>
<p class="code"><span class="font">start :: Position</span></p>
<p class="code"><span class="font">start = (0,[0..8])</span></p>
</div>
<p class="para">The function <span class="font">moves</span> can be defined by</p>
<p class="code"><span class="font">moves :: Position -&gt; [Move]</span></p>
<p class="code"><span class="font">moves (j,ks)</span></p>
<p class="code2"><span class="font">= [Up</span><span class="space5"></span><span class="font">| j `notElem` [6,7,8]] ++</span></p>
<p class="code11"><span class="font">[Down</span><span class="space"></span><span class="font">| j `notElem` [0,1,2]] ++</span></p>
<p class="code11"><span class="font">[Left</span><span class="space"></span><span class="font">| j `notElem` [2,5,8]] ++</span></p>
<p class="code11"><span class="font">[Right | j `notElem` [0,3,6]]</span></p>
<p class="para">Up moves are allowed except for a blank in the bottom row; down moves except for a blank in the top row, left moves except for a blank in the rightmost column, and right moves except for a blank in the leftmost column.</p>
<p class="para">The function <span class="font">move</span> can be defined by:</p>
<div class="space1">
<p class="code"><span class="font">move :: Position -&gt; Move -&gt; Position</span></p>
<p class="code"><span class="font">move (j,ks) Up</span><span class="space5"></span><span class="font">= (j+3,swap (j,j+3) ks)</span></p>
<p class="code"><span class="font">move (j,ks) Down = (j-3,swap (j-3,j) ks)</span></p>
<p class="code"><span class="font">move (j,ks) Left = (j+1,swap (j,j+1) ks)</span></p>
<p class="code"><span class="font">move (j,ks) Right = (j-1,swap (j-1,j) ks)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">swap (j,k) ks = ks1 ++ y:ks3 ++ x:ks4</span></p>
<p class="code"><span class="space-r"></span><span class="font">where (ks1,x:ks2) = splitAt j ks</span></p>
<p class="code3"><span class="font">(ks3,y:ks4) = splitAt (k-j-1) ks2</span></p>
</div>
<p class="para">Finally,</p>
<p class="code"><a id="text/part0014.html.page_275" class="calibre3"></a><span class="font">solved :: Position -&gt; Bool</span></p>
<p class="code"><span class="font">solved p = p == (8,[1,2,3,4,5,6,7,8,0])</span></p>
<p class="para">My computer produced:</p>
<p class="code6"><span class="font">ghci&gt; solve start</span></p>
<p class="code6"><span class="font">Just [Left,Up,Right,Up,Left,Left,Down,</span></p>
<p class="code8"><span class="font">Right,Right,Up,Left,Down,Down,Left,</span></p>
<p class="code8"><span class="font">Up,Up,Right,Right,Down,Left,Left,Up]</span></p>
<p class="code6"><span class="font">(4.84 secs, 599740496 bytes)</span></p>
<h3 class="h" id="text/part0014.html.head10-9">10.9 Chapter notes</h3>
<p class="para">Read <i class="calibre1">The History of Haskell</i> to see how monads came to be an integral part of Haskell, and why this idea has been mainly responsible for the increasing use of Haskell in the real world. Monads are used to structure GHC, which itself is written in Haskell. Each phase of the compiler uses a monad for book-keeping information. For instance, the type checker uses a monad that combines state (to maintain a current substitution), a name supply (for fresh type variable names) and exceptions.</p>
<p class="para">Use of <span class="font">do</span>-notation in preference to <span class="font">(&gt;&gt;=)</span> was suggested by John Launchbury in 1993 and was first implemented by Mark Jones in Gofer.</p>
<p class="para">The number of tutorials on monads has increased steadily over the years; see</p>
<p class="code"><span class="font"><a href="http://haskell.org/haskellwiki/Monad_tutorials" class="calibre3">haskell.org/haskellwiki/Monad_tutorials</a></span></p>
<p class="para">for a reasonably comprehensive list.</p>
<p class="para">The example (in Exercise F) of monadic equational reasoning can be found in the paper ‘Unifying theories of programming with monads’, (UTP Symposium, August 2012) by Jeremy Gibbons. For additional material on reasoning equationally with monads, read ‘Just <span class="font">do</span> it: simple monadic equational reasoning’ by Jeremy Gibbons and Ralf Hinze, which appeared in the proceedings of the 2011 International Conference of Functional Programming. Both papers can be found at</p>
<p class="code"><span class="font"><a href="http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/" class="calibre3">www.cs.ox.ac.uk/people/jeremy.gibbons/publications/</a></span></p>
<p class="footnote1"><sup class="calibre15"><a id="text/part0014.html.fn1" href="#text/part0014.html.fn_1" class="calibre3">1</a></sup> Actually there is, and it’s called <span class="font">unsafePerformIO</span>, but it is a very unsafe function.</p>
</div></div>
<div id="text/part0015.html"><div id="text/part0015.html.E9OE0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre">

<h2 class="chapter-number" id="text/part0015.html.calibre_pb_0"><a id="text/part0015.html.page_276" class="calibre6"></a>Chapter 11</h2>
<h2 class="chapter-title">Parsing</h2>
<p class="para">A <i class="calibre1">parser</i> is a function that analyses a piece of text to determine its logical structure. The text is a string of characters describing some value of interest, such as an arithmetic expression, a poem or a spreadsheet. The output of a parser is a representation of the value, such as a tree of some kind for an arithmetic expression, a list of verses for a poem, or something more complicated for a spreadsheet. Most programming tasks involve decoding the input in some way, so parsing is a pervasive component of computer programming. In this chapter we will describe a monadic approach to parsing, mainly designing simple parsers for expressions of various kinds. We will also say a little more about the converse process of encoding the output as a string; in other words, more about the type class <span class="font">Show</span>. This material will be used in the final chapter.</p>
<h3 class="h" id="text/part0015.html.head11-1">11.1 Parsers as monads</h3>
<p class="para">Parsers return different values of interest, so as a first cut we can think of a parser as a function that takes a string and returns a value:</p>
<p class="code"><span class="font">type Parser a = String -&gt; a</span></p>
<p class="para">This type is basically the same as that of the standard prelude function</p>
<p class="code"><span class="font">read :: Read a =&gt; String -&gt; a</span></p>
<p class="para">Indeed, <span class="font">read</span> is a parser, though not a very flexible one. One reason is that all the input must be consumed. Thus:</p>
<p class="code6"><span class="font">ghci&gt; read "123" :: Int 123</span></p>
<p class="code6"><a id="text/part0015.html.page_277" class="calibre3"></a><span class="font">ghci&gt; read "123+51" :: Int</span></p>
<p class="code6"><span class="font">*** Exception: Prelude.read: no parse</span></p>
<p class="para">With <span class="font">read</span> there is no obvious way of reading two or more things in sequence. For example, in a parser for arithmetic expressions we may want to look in the input stream for a numeral, then an operator and then another numeral. The first parser for a numeral will consume some prefix of the input, the parser for an operator some prefix of the remaining input, and the third parser yet more input. A better idea is to define a parser as a function that consumes a prefix of the input and returns both a value of interest and the unconsumed suffix:</p>
<p class="code"><span class="font">type Parser a = String -&gt; (a,String)</span></p>
<p class="para">We are not quite there yet. It can happen that a parser may <i class="calibre1">fail</i> on some input. It is not a mistake to construct parsers that can fail. For example, in a parser for arithmetic expressions, we may want to look for either a numeral or an opening parenthesis. One or either of these subsidiary parsers will certainly fail. Failure should not be thought of as an error that terminates the parsing process; rather it acts like an identity element for an operation that chooses between alternatives. More generally, a parser may find a number of different ways that some prefix of the input can be structured. Failure then corresponds to the particular case of the empty sequence of parses. In order to handle these various possibilities, we change our definition yet again and define</p>
<p class="code"><span class="font">type Parser a = String -&gt; [(a,String)]</span></p>
<p class="para">The standard prelude provides exactly this type synonym, except that it is called <span class="font">ReadS</span>, not <span class="font">Parser</span>. And it also provides a function</p>
<p class="code"><span class="font">reads :: Read a =&gt; ReadS a</span></p>
<p class="para">as a subsidiary method in the type class <span class="font">Read</span>. For example,</p>
<p class="code6"><span class="font">ghci&gt; reads "-123+51" :: [(Int,String)]</span></p>
<p class="code6"><span class="font">[(-123,"+51")]</span></p>
<p class="code6"><span class="font">ghci&gt; reads "+51" :: [(Int,String)]</span></p>
<p class="code6"><span class="font">[]</span></p>
<p class="para">As with the function <span class="font">read</span> you have to tell <span class="font">reads</span> the type you are expecting. The second example fails, returning no parses, because a Haskell integer can be preceded by an optional minus sign but not by an optional plus sign. By definition, a parser is <i class="calibre1">deterministic</i> if it returns an empty or singleton list of parses in all possible cases. In particular, instances of <span class="font">reads</span> ought to be deterministic parsers.</p>
<p class="para"><a id="text/part0015.html.page_278" class="calibre3"></a>There is one further change we have to make to the definition of <span class="font">Parser</span>. We would like to install this type as an instance of the <span class="font">Monad</span> class, but that is not possible. The reason is that <span class="font">Parser</span> is declared as a type synonym, and type synonyms cannot be made members of any type class: they inherit whatever instances are declared for the underlying type. A type synonym is there simply to improve readability in type declarations; no new types are involved and we cannot construct two different type class instances for what is essentially the same type.</p>
<p class="para">One way to construct a new type is by a data declaration:</p>
<p class="code"><span class="font">data Parser a = Parser (String -&gt; [(a,String)])</span></p>
<p class="para">The identifier <span class="font">Parser</span> on the right is a constructor, while on the left it is the name of a new type. Most people are happy with the pun; others would rename the constructor as something like <span class="font">MkParser</span> or just <span class="font">P</span>.</p>
<p class="para">There is a better way to create a new type for <span class="font">Parser</span> and that is to use a <span class="font">newtype</span> declaration:</p>
<p class="code"><span class="font">newtype Parser a = Parser (String -&gt; [(a,String)])</span></p>
<p class="para">We have not needed <span class="font">newtype</span> declarations up to now, so let us digress a little to explain them. The price paid for using a <span class="font">data</span> declaration for <span class="font">Parser</span> is that operations to examine parsers have to be constantly unwrapped and rewrapped with the constructor <span class="font">Parser</span>, and this adds to the running time of parser operations. In addition there is an unwanted element of <span class="font">Parser</span>, namely <span class="font">Parser undefined</span>. In other words, <span class="font">Parser a</span> and <span class="font">String -&gt; [(a,String)]</span> are not <i class="calibre1">isomorphic</i> types. Recognising this, Haskell allows a <span class="font">newtype</span> declaration for types defined with a <i class="calibre1">single</i> constructor taking a <i class="calibre1">single</i> argument. It differs from a type synonym in that it creates a genuinely new type whose values must be expressed using the <span class="font">Parser</span> wrapper. But these coercions, though they have to appear in the program text, do not add to the execution time of the program because the Haskell compiler eliminates them before evaluation begins. The values of the new type are systematically replaced by the values in the underlying type. Consequently, <span class="font">Parser a</span> and <span class="font">String -&gt; [(a,String)]</span> describe isomorphic types, and <span class="font">Parser undefined</span> and <span class="font">undefined</span> are isomorphic values sharing the same representation. New types, as distinct from synonym types, can be made members of type classes in different ways from the underlying type.</p>
<p class="para">With either kind of declaration we have to provide some way of applying the parsing function, so we define</p>
<p class="code"><span class="font">apply :: Parser a -&gt; String -&gt; [(a,String)]</span></p>
<p class="code"><span class="font">apply (Parser p) s = p s</span></p>
<p class="para"><a id="text/part0015.html.page_279" class="calibre3"></a>The functions <span class="font">apply</span> and <span class="font">Parser</span> are mutual inverses and witness the isomorphism.</p>
<p class="para">We also define</p>
<p class="code"><span class="font">parse :: Parser a -&gt; String -&gt; a</span></p>
<p class="code"><span class="font">parse p = fst . head . apply p</span></p>
<p class="para">The function <span class="font">parse p</span> returns the first object of the first parse, causing an error if the parser <span class="font">p</span> fails. This is the only place an error might occur.</p>
<p class="para">Now we can define</p>
<p class="code"><span class="font">instance Monad Parser where</span></p>
<p class="code2"><span class="font">return x = Parser (\s -&gt; [(x,s)])</span></p>
<p class="code2"><span class="font">p &gt;&gt;= q = Parser (\s -&gt; [(y,s'')</span></p>
<p class="code5"><span class="space2"></span><span class="space-r"></span><span class="font">| (x,s') &lt;- apply p s,</span></p>
<p class="code5"><span class="space3"></span><span class="font">(y,s'') &lt;- apply (q x) s'])</span></p>
<p class="para">In the definition of <span class="font">p &gt;&gt;= q</span> the parser <span class="font">p</span> is applied to an input string, producing a list of possible parses each of which is paired with the corresponding unconsumed portion of the input. The parser <span class="font">q</span> is then applied to each parse to produce a list of results whose concatenation provides the final answer. One should also show that the three monad laws hold, a task we will leave as an exercise.</p>
<h3 class="h" id="text/part0015.html.head11-2">11.2 Basic parsers</h3>
<p class="para">Perhaps the simplest basic parser is</p>
<p class="code"><span class="font">getc :: Parser Char</span></p>
<p class="code"><span class="font">getc = Parser f</span></p>
<p class="code3"><span class="font">where f [] = []</span></p>
<p class="code12"><span class="space-r"></span><span class="font">f (c:cs) = [(c,cs)]</span></p>
<p class="para">This parser returns the first character of the input if there is one. It plays exactly the same role for parsers as <span class="font">getChar</span> does for the input–output monad of the previous chapter.</p>
<p class="para">Next, here is a parser for recognising a character that satisfies a given condition:</p>
<p class="code"><span class="font">sat :: (Char -&gt; Bool) -&gt; Parser Char</span></p>
<p class="code"><span class="font">sat p = do {c &lt;- getc;</span></p>
<p class="code3"><span class="font">if p c then return c</span></p>
<p class="code3"><span class="font">else fail}</span></p>
<p class="para"><a id="text/part0015.html.page_280" class="calibre3"></a>where <span class="font">fail</span> is defined by</p>
<p class="code"><span class="font">fail = Parser (\s -&gt; [])</span></p>
<p class="para">The parser <span class="font">fail</span> is another basic parser that returns no parses. The parser <span class="font">sat p</span> reads a character and, if it satisfies <span class="font">p</span>, returns the character as the result. The definition of <span class="font">sat</span> can be written more briefly by using a little combinator called <span class="font">guard</span>:</p>
<p class="code"><span class="font">sat p = do {c &lt;- getc; guard (p c); return c}</span></p>
<p class="code"><span class="font">guard :: Parser ()</span></p>
<p class="code"><span class="font">guard True = return ()</span></p>
<p class="code"><span class="font">guard False = fail</span></p>
<p class="para">To see that these two definitions are the same, observe that if <span class="font">p c</span> is false, then</p>
<p class="code"><span class="font">guard (p c) &gt;&gt; return c = fail &gt;&gt; return c = fail</span></p>
<p class="para">Note the use of the law <span class="font">fail &gt;&gt; p = fail</span>, whose proof we leave as an exercise. If <span class="font">p c</span> is true, then</p>
<p class="code"><span class="space"></span><span class="font">guard (p c) &gt;&gt; return c</span></p>
<p class="code"><span class="font">= return () &gt;&gt; return c</span></p>
<p class="code"><span class="font">= return c</span></p>
<p class="para">Using <i class="calibre1">sat</i> we can define a number of other parsers; for instance</p>
<p class="code"><span class="font">char :: Char -&gt; Parser ()</span></p>
<p class="code"><span class="font">char x = do {c &lt;- sat (==x); return ()}</span></p>
<p class="para1"></p>
<p class="code"><span class="font">string :: String -&gt; Parser ()</span></p>
<p class="code"><span class="font">string [] = return ()</span></p>
<p class="code"><span class="font">string (x:xs) = do {char x; string xs; return ()}</span></p>
<p class="para1"></p>
<p class="code"><span class="font">lower :: Parser Char</span></p>
<p class="code"><span class="font">lower = sat isLower</span></p>
<p class="para1"></p>
<p class="code"><span class="font">digit :: Parser Int</span></p>
<p class="code"><span class="font">digit = do {d &lt;- sat isDigit; return (cvt d)}</span></p>
<p class="code3"><span class="font">where cvt d = fromEnum d - fromEnum '0'</span></p>
<p class="para">The parser <span class="font">char x</span> looks for the specific character <span class="font">x</span> as the next item in the input string, while <span class="font">string xs</span> looks for a specific string; both parsers return <span class="font">()</span> if successful. For example,</p>
<p class="code6"><a id="text/part0015.html.page_281" class="calibre3"></a><span class="font">ghci&gt; apply (string "hell") "hello"</span></p>
<p class="code6"><span class="font">[((),"o")]</span></p>
<p class="para">The parser <span class="font">digit</span> looks for a digit character and returns the corresponding integer if successful. The parser <span class="font">lower</span> looks for a lowercase letter, returning such a letter if found.</p>
<h3 class="h" id="text/part0015.html.head11-3">11.3 Choice and repetition</h3>
<p class="para">In order to define more sophisticated parsers we need operations for choosing between alternative parsers and for repeating parsers. One such alternation operator is <span class="font">(&lt;|&gt;)</span>, defined by</p>
<p class="code"><span class="font">(&lt;|&gt;) :: Parser a -&gt; Parser a -&gt; Parser a</span></p>
<p class="code"><span class="font">p &lt;|&gt; q = Parser f</span></p>
<p class="code3"><span class="font">where f s = let ps = apply p s in</span></p>
<p class="code4"><span class="space5"></span><span class="font">if null ps then apply q s</span></p>
<p class="code4"><span class="space5"></span><span class="font">else ps</span></p>
<p class="para">Thus <span class="font">p &lt;|&gt; q</span> returns the same parses as <span class="font">p</span> unless <span class="font">p</span> fails, in which case the parses of <span class="font">q</span> are returned. If both <span class="font">p</span> and <span class="font">q</span> are deterministic, then so is <span class="font">p &lt;|&gt; q</span>. For another choice of <span class="font">&lt;|&gt;</span> see the exercises. We claim that <span class="font">&lt;|&gt;</span> is associative with <span class="font">fail</span> as its identity element, but again we relegate the proof as an exercise.</p>
<p class="para">Here is a parser for recognising a string of lowercase letters:</p>
<p class="code"><span class="font">lowers :: Parser String</span></p>
<p class="code"><span class="font">lowers = do {c &lt;- lower; cs &lt;- lowers; return (c:cs)}</span></p>
<p class="code1"><span class="font">&lt;|&gt; return ""</span></p>
<p class="para">To see how this parser works, suppose the input is the string ‘Upper’. In this case the parser on the left of <span class="font">&lt;|&gt;</span> fails because ‘U’ is not a lowercase letter. However, the parser on the right succeeds, so</p>
<p class="code6"><span class="font">ghci&gt; apply lowers "Upper"</span></p>
<p class="code6"><span class="font">[("","Upper")]</span></p>
<p class="para">With input string ‘isUpper’, the left-hand parser succeeds, so</p>
<p class="code6"><span class="font">ghci&gt; apply lowers "isUpper"</span></p>
<p class="code6"><span class="font">[("is","Upper")]</span></p>
<p class="para"><a id="text/part0015.html.page_282" class="calibre3"></a>Use of the choice operator <span class="font">&lt;|&gt;</span> requires care. For example, consider a very simple form of arithmetic expression that consists of either a single digit or a digit followed by a plus sign followed by another digit. Here is a possible parser:</p>
<p class="code"><span class="font">wrong :: Parser Int</span></p>
<p class="code"><span class="font">wrong = digit &lt;|&gt; addition</span></p>
<p class="para1"></p>
<p class="code"><span class="font">addition :: Parser Int</span></p>
<p class="code"><span class="font">addition = do {m &lt;- digit; char '+'; n &lt;- digit;</span></p>
<p class="code12"><span class="font">return (m+n)}</span></p>
<p class="para">We have</p>
<p class="code6"><span class="font">ghci&gt; apply wrong "1+2"</span></p>
<p class="code6"><span class="font">[(1,"+2")]</span></p>
<p class="para">The parser <span class="font">digit</span> succeeds, so <span class="font">addition</span> is not invoked. But what we really wanted was to return <span class="font">[(3,"")]</span>, absorbing as much of the input as possible. One way to correct <span class="font">wrong</span> is to rewrite it in the form</p>
<p class="code"><span class="font">better = addition &lt;|&gt; digit</span></p>
<p class="para">Then on <span class="font">1+2</span> the parser <span class="font">addition</span> succeeds, returning the result we want. What is wrong with <span class="font">better</span> is that it is inefficient: applied to the input <span class="font">1</span> it parses the digit but fails to find a subsequent plus sign, so parser <span class="font">addition</span> fails. As a result <span class="font">digit</span> is invoked and the input is parsed again from scratch. Not really a problem with a single digit, but the repetition of effort could be costly if we were parsing for a numeral that could contain many digits.</p>
<p class="para">The best solution is to <i class="calibre1">factor</i> the parser for digits out of the two component parsers:</p>
<p class="code"><span class="font">best = digit &gt;&gt;= rest</span></p>
<p class="code"><span class="font">rest m = do {char '+'; n &lt;- digit; return (m+n)}</span></p>
<p class="code1"><span class="font">&lt;|&gt; return m</span></p>
<p class="para">The argument to <span class="font">rest</span> is just an accumulating parameter. We saw essentially the same solution in the chapter on pretty-printing. Factoring parsers to bring out common prefixes is a Good Idea to improve efficiency.</p>
<p class="para">Generalising from the definition of <span class="font">lowers</span>, we can define a parser combinator that repeats a parser zero or more times:</p>
<p class="code"><span class="font">many :: Parser a -&gt; Parser [a]</span></p>
<p class="code"><span class="font">many p = do {x &lt;- p; xs &lt;- many p; return (x:xs)}</span></p>
<p class="code1"><span class="font">&lt;|&gt; none</span></p>
<p class="code"><a id="text/part0015.html.page_283" class="calibre3"></a><span class="font">none = return []</span></p>
<p class="para">The value <span class="font">none</span> is different from <span class="font">fail</span> (why?). We can now define</p>
<p class="code"><span class="font">lowers = many lower</span></p>
<p class="para">In many applications, so-called <i class="calibre1">white space</i> (sequences of space, newline and tab characters) can appear between <i class="calibre1">tokens</i> (identifiers, numbers, opening and closing parentheses, and so on) just to make the text easier to read. The parser <span class="font">space</span> recognises white space:</p>
<p class="code"><span class="font">space :: Parser ()</span></p>
<p class="code"><span class="font">space = many (sat isSpace) &gt;&gt; return ()</span></p>
<p class="para">The function <span class="font">isSpace</span> is defined in the library <span class="font">Data.Char</span>. The function</p>
<p class="code"><span class="font">symbol :: String -&gt; Parser ()</span></p>
<p class="code"><span class="font">symbol xs = space &gt;&gt; string xs</span></p>
<p class="para">ignores white space before recognising a given string. More generally we can define</p>
<p class="code"><span class="font">token :: Parser a -&gt; Parser a</span></p>
<p class="code"><span class="font">token p = space &gt;&gt; p</span></p>
<p class="para">for ignoring white space before invoking a parser. Note that</p>
<p class="code"><span class="font">token p &lt;|&gt; token q = token (p &lt;|&gt; q)</span></p>
<p class="para">but the right-hand parser is more efficient as it does not look for white space twice if the first parser fails.</p>
<p class="para">Sometimes we want to repeat a parser one or more times rather than zero or more times. This can be done by a combinator which we will call <span class="font">some</span> (it is also called <span class="font">many1</span> in some parser libraries):</p>
<p class="code"><span class="font">some :: Parser a -&gt; Parser [a]</span></p>
<p class="code"><span class="font">some p = do {x &lt;- p; xs &lt;- many p; return (x:xs)}</span></p>
<p class="para">This definition repeats that of the first parser in the definition of <span class="font">many</span>, a fact we can take into account by redefining <span class="font">many</span> in terms of <span class="font">some</span>:</p>
<p class="code"><span class="font">many :: Parser a -&gt; Parser [a]</span></p>
<p class="code"><span class="font">many p = optional (some p)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">optional :: Parser [a] -&gt; Parser [a]</span></p>
<p class="code"><span class="font">optional p = p &lt;|&gt; none</span></p>
<p class="para"><a id="text/part0015.html.page_284" class="calibre3"></a>The parsers <span class="font">many</span> and <span class="font">some</span> are now mutually recursive.</p>
<p class="para">Here is a parser for natural numbers, one that allows white space before the number:</p>
<p class="code"><span class="font">natural :: Parser Int</span></p>
<p class="code"><span class="font">natural = token nat</span></p>
<p class="code"><span class="font">nat = do {ds &lt;- some digit;</span></p>
<p class="code1"><span class="font">return (foldl1 shiftl ds)}</span></p>
<p class="code11"><span class="font">where shiftl m n = 10*m+n</span></p>
<p class="para">The subsidiary parser <span class="font">nat</span> does not allow white space before the number.</p>
<p class="para">Consider now how to define a parser for an <i class="calibre1">integer</i> numeral, which by definition is a nonempty string of digits possibly prefixed by a minus sign. You might think that the parser</p>
<p class="code"><span class="font">int :: Parser Int</span></p>
<p class="code"><span class="font">int = do {symbol "-"; n &lt;- natural; return (-n)}</span></p>
<p class="code3"><span class="font">&lt;|&gt; natural</span></p>
<p class="para">does the job, but it is inefficient (see Exercise H) and may or may not be what we want. For example,</p>
<p class="code6"><span class="font">ghci&gt; apply int " -34"</span></p>
<p class="code6"><span class="font">[(-34,"")]</span></p>
<p class="code6"><span class="font">ghci&gt; apply int " - 34"</span></p>
<p class="code6"><span class="font">[(-34,"")]</span></p>
<p class="para">Whereas we are quite happy with white space before a numeral, we may not want any white space to appear between the minus sign and the ensuing digits. If that is the case, then the above parser will not do. It is easy to modify the given definition of <span class="font">int</span> to give what we want:</p>
<p class="code"><span class="font">int :: Parser Int</span></p>
<p class="code"><span class="font">int = do {symbol "-"; n &lt;- nat; return (-n)}</span></p>
<p class="code8"><span class="font">&lt;|&gt; natural</span></p>
<p class="para">This parser is still inefficient, and a better alternative is to define</p>
<p class="code"><span class="font">int :: Parser Int</span></p>
<p class="code"><span class="font">int = do {space; f &lt;- minus; n &lt;- nat; return (f n)}</span></p>
<p class="code"><span class="space"></span><span class="font">where</span></p>
<p class="code"><span class="space"></span><span class="font">minus = (char '-' &gt;&gt; return negate) &lt;|&gt; return id</span></p>
<p class="para">The parser <span class="font">minus</span> returns a function, either <span class="font">negate</span> if the first symbol is a minus sign, or the identity function otherwise.</p>
<p class="para"><a id="text/part0015.html.page_285" class="calibre3"></a>Next, let us parse a list of integers, separated by commas and enclosed in square brackets. White space is allowed before and after commas and brackets though not of course between the digits of the integers. Here is a very short definition:</p>
<p class="code"><span class="font">ints :: Parser [Int]</span></p>
<p class="code"><span class="font">ints = bracket (manywith (symbol ",") int)</span></p>
<p class="para">The subsidiary parser <span class="font">bracket</span> deals with the brackets:</p>
<p class="code"><span class="font">bracket :: Parser a -&gt; Parser a</span></p>
<p class="code"><span class="font">bracket p = do {symbol "[";</span></p>
<p class="code12"><span class="font">x &lt;- p;</span></p>
<p class="code12"><span class="font">symbol "]";</span></p>
<p class="code12"><span class="font">return x}</span></p>
<p class="para">The function <span class="font">manywith sep p</span> acts a bit like <span class="font">many p</span> but differs in that the instances of <span class="font">p</span> are separated by instances of <span class="font">sep</span> whose results are ignored. The definition is</p>
<p class="code"><span class="font">manywith :: Parser b -&gt; Parser a -&gt; Parser [a]</span></p>
<p class="code"><span class="font">manywith q p = optional (somewith q p)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">somewith :: Parser b -&gt; Parser a -&gt; Parser [a]</span></p>
<p class="code"><span class="font">somewith q p = do {x &lt;- p;</span></p>
<p class="code9"><span class="font">xs &lt;- many (q &gt;&gt; p);</span></p>
<p class="code9"><span class="font">return (x:xs)}</span></p>
<p class="para">For example,</p>
<p class="code6"><span class="font">ghci&gt; apply ints "[2, -3, 4]"</span></p>
<p class="code6"><span class="font">[([2,-3,4],"")]</span></p>
<p class="code6"><span class="font">ghci&gt; apply ints "[2, -3, +4]"</span></p>
<p class="code6"><span class="font">[]</span></p>
<p class="code6"><span class="font">ghci&gt; apply ints "[]"</span></p>
<p class="code6"><span class="font">[([],"")]</span></p>
<p class="para">Integers cannot be preceded by a plus sign, so parsing the second expression fails.</p>
<h3 class="h" id="text/part0015.html.head11-4">11.4 Grammars and expressions</h3>
<p class="para">The combinators described so far are sufficiently powerful for translating a structural description of what is required directly into a functional parser. Such a struc<a id="text/part0015.html.page_286" class="calibre3"></a>tural description is provided by a <i class="calibre1">grammar</i>. We will illustrate some typical grammars by looking at parsers for various kinds of arithmetic expression.</p>
<p class="para">Let us start by building a parser for the type <span class="font">Expr</span>, defined by</p>
<p class="code"><span class="font">data Expr</span><span class="space"></span><span class="font">= Con Int | Bin Op Expr Expr</span></p>
<p class="code"><span class="font">data Op</span><span class="space5"></span><span class="font">= Plus | Minus</span></p>
<p class="para">Here is a grammar for fully parenthesised expressions, expressed in what is known as <i class="calibre1">Backus-Naur form</i>, or BNF for short:</p>
<p class="code"><span class="font">expr ::= nat | '(' expr op expr ')'</span></p>
<p class="code"><span class="font">op ::= '+' | '-'</span></p>
<p class="code"><span class="font">nat ::= {digit}+</span></p>
<p class="code"><span class="font">digit ::= '0' | '1' | ... | '9'</span></p>
<p class="para">This grammar defines four <i class="calibre1">syntactic categories</i>. Symbols enclosed in quotes are called <i class="calibre1">terminal</i> symbols and describe themselves; these are symbols that actually occur in the text. There are ten possible characters for a digit, and a <span class="font">nat</span> is defined as a sequence of one or more digits. The meta-symbol <span class="font">{-}+</span> describes a non-zero repetition of a syntactic category. Note that we do not allow an optional minus sign before a sequence of digits, so constants are natural numbers, not arbitrary integers. The grammar states that an expression is either a natural number or else a compound expression consisting of an opening parenthesis, followed by an expression, followed by either a plus or minus sign, followed by another expression, and finally followed by a closing parenthesis. It is implicitly understood in the description that white space is ignored between terminal symbols except between the digits of a number. The grammar translates directly into a parser for expressions:</p>
<p class="code"><span class="font">expr :: Parser Expr</span></p>
<p class="code"><span class="font">expr = token (constant &lt;|&gt; paren binary)</span></p>
<p class="code"><span class="font">constant = do {n &lt;- nat; return (Con n)}</span></p>
<p class="code"><span class="font">binary = do {e1 &lt;- expr;</span></p>
<p class="code12"><span class="font">p &lt;- op;</span></p>
<p class="code12"><span class="font">e2 &lt;- expr;</span></p>
<p class="code12"><span class="font">return (Bin p e1 e2)}</span></p>
<p class="code"><span class="font">op = (symbol "+" &gt;&gt; return Plus) &lt;|&gt;</span></p>
<p class="code2"><span class="font">(symbol "-" &gt;&gt; return Minus)</span></p>
<p class="para">For readability we have made use of a subsidiary parser <span class="font">binary</span>; the parser <span class="font">paren</span> is left as an exercise.</p>
<p class="para">Now suppose we want a parser that also works for expressions that are not fully parenthesised, things like <span class="font">6-2-3</span> and <span class="font">6-(2-3)</span> and <span class="font">(6-2)-3</span>. In such a case, <span class="font">(+)</span> <a id="text/part0015.html.page_287" class="calibre3"></a>and <span class="font">(-)</span> should associate to the left in expressions, as is normal with arithmetic. One way to express such a grammar in BNF is to write</p>
<p class="code"><span class="font">expr ::= expr op term | term</span></p>
<p class="code"><span class="font">term ::= nat | '(' expr ')'</span></p>
<p class="para">This grammar says that an expression is a sequence of one or more terms separated by operators. A term is either a number or a parenthesised expression. In particular, <span class="font">6-2-3</span> will be parsed as the expression <span class="font">6-2</span> followed by a minus operator, followed by the term <span class="font">3</span>. In other words, the same as <span class="font">(6-2)-3</span>, as required. This grammar also translates directly into a parser:</p>
<p class="code"><span class="font">expr = token (binary &lt;|&gt; term)</span></p>
<p class="code"><span class="font">binary = do {e1 &lt;- expr;</span></p>
<p class="code12"><span class="font">p &lt;- op;</span></p>
<p class="code12"><span class="font">e2 &lt;- term;</span></p>
<p class="code12"><span class="font">return (Bin p e1 e2)}</span></p>
<p class="code"><span class="font">term = token (constant &lt;|&gt; paren expr)</span></p>
<p class="para">However, there is a fatal flaw with this parser: it falls into an infinite loop. After ignoring initial white space the first action of <span class="font">expr</span> is to invoke the parser <span class="font">binary</span>, whose first action is to invoke the parser <span class="font">expr</span> again. Whoops!</p>
<p class="para">Furthermore, it will not do to rewrite <span class="font">expr</span> as</p>
<p class="code"><span class="font">expr = token (term &lt;|&gt; binary)</span></p>
<p class="para">because, for example,</p>
<p class="code6"><span class="font">Main*&gt; apply expr "3+4"</span></p>
<p class="code6"><span class="font">[(Con 3,"+4")]</span></p>
<p class="para">Only the first term is parsed. The problem is called the <i class="calibre1">left recursion</i> problem and is a difficulty with all recursive parsers, functional or otherwise.</p>
<p class="para">One solution is to rewrite the grammar in the following equivalent form:</p>
<p class="code"><span class="font">expr ::= term {op term}*</span></p>
<p class="para">The meta-symbol <span class="font">{-}*</span> indicates a syntactic category that can be repeated zero or more times. The new parser then takes the form</p>
<p class="code"><span class="font">expr = token (term &gt;&gt;= rest)</span></p>
<p class="code"><span class="font">rest e1 = do {p &lt;- op;</span></p>
<p class="code9"><span class="font">e2 &lt;- term;</span></p>
<p class="code9"><span class="font">rest (Bin p e1 e2)} &lt;|&gt; return e1</span></p>
<p class="para"><a id="text/part0015.html.page_288" class="calibre3"></a>The parser <span class="font">rest</span> corresponds to the category <span class="font">{op term}*</span> and takes an argument (an accumulating parameter) whose value is the expression parsed so far.</p>
<p class="para">Finally, let us design a parser for arithmetic expressions that may contain multiplication and division, changing the definition of <span class="font">Op</span> to</p>
<p class="code"><span class="font">data Op = Plus | Minus | Mul | Div</span></p>
<p class="para">The usual rules apply in that multiplication and division take precedence over addition and subtraction, and operations of the same precedence associate to the left. Here is a grammar:</p>
<p class="code"><span class="font">expr ::= term {addop term}*</span></p>
<p class="code"><span class="font">term ::= factor {mulop factor}*</span></p>
<p class="code"><span class="font">factor ::= nat | '(' expr ')'</span></p>
<p class="code"><span class="font">addop ::= '+' | '-'</span></p>
<p class="code"><span class="font">mulop ::= '*' | '/'</span></p>
<p class="para">And here is the parser:</p>
<p class="code"><span class="font">expr = token (term &gt;&gt;= rest)</span></p>
<p class="code"><span class="font">rest e1 = do {p &lt;- addop;</span></p>
<p class="code9"><span class="font">e2 &lt;- term;</span></p>
<p class="code9"><span class="font">rest (Bin p e1 e2)}</span></p>
<p class="code10"><span class="font">&lt;|&gt; return e1</span></p>
<p class="code"><span class="font">term = token (factor &gt;&gt;= more)</span></p>
<p class="code"><span class="font">more e1 = do {p &lt;- mulop;</span></p>
<p class="code9"><span class="font">e2 &lt;- factor;</span></p>
<p class="code9"><span class="font">more (Bin p e1 e2)}</span></p>
<p class="code10"><span class="font">&lt;|&gt; return e1</span></p>
<p class="code"><span class="font">factor = token (constant &lt;|&gt; paren expr)</span></p>
<p class="para">The definitions of <span class="font">addop</span> and <span class="font">mulop</span> are left as exercises.</p>
<h3 class="h" id="text/part0015.html.head11-5">11.5 Showing expressions</h3>
<p class="para">Our final question is: how can we install <span class="font">Expr</span> as a member of the type class <span class="font">Show</span> so that the function <span class="font">show</span> is the inverse of parsing? More precisely, we want to define <span class="font">show</span> so that</p>
<p class="code"><span class="font">parse expr (show e) = e</span></p>
<p class="para">Recall that <span class="font">parse p</span> extracts the first parse returned by <span class="font">apply p</span>.</p>
<p class="para"><a id="text/part0015.html.page_289" class="calibre3"></a>As a warm-up, here is the instance of <span class="font">Show</span> when <span class="font">expr</span> is the parser for fully parenthesised expressions involving addition and subtraction only:</p>
<p class="code"><span class="font">instance Show Expr where</span></p>
<p class="code2"><span class="font">show (Con n) = show n</span></p>
<p class="code2"><span class="font">show (Bin op e1 e2) =</span></p>
<p class="code11"><span class="font">= "(" ++ show e1 ++</span></p>
<p class="code8"><span class="font">" " ++ showop op ++</span></p>
<p class="code8"><span class="font">" " ++ show e2 ++ ")"</span></p>
<p class="code"><span class="font">showop Plus = "+"</span></p>
<p class="code"><span class="font">showop Minus = "-"</span></p>
<p class="para">Clear enough, but there is a problem with efficiency. Because <span class="font">(++)</span> has time complexity linear in the length of its left argument, the cost of evaluating <span class="font">show</span> is, in the worst case, quadratic in the size of the expression.</p>
<p class="para">The solution, yet again, is to use an accumulating parameter. Haskell provides a type synonym <span class="font">ShowS</span>:</p>
<p class="code"><span class="font">type ShowS = String -&gt; String</span></p>
<p class="para">and also the following subsidiary functions</p>
<p class="code"><span class="font">showChar</span><span class="space5"></span><span class="font">:: Char -&gt; ShowS</span></p>
<p class="code"><span class="font">showString</span><span class="space5"></span><span class="font">:: String -&gt; ShowS</span></p>
<p class="code"><span class="font">showParen :: Bool -&gt; ShowS -&gt; ShowS</span></p>
<p class="para">These functions are defined by</p>
<p class="code"><span class="font">showChar</span><span class="space2"></span><span class="font">= (:)</span></p>
<p class="code"><span class="font">showString</span><span class="space5"></span><span class="space-r"></span><span class="font">= (++)</span></p>
<p class="code"><span class="font">showParen p x = if b then</span></p>
<p class="code4"><span class="font">showChar '(' . p . showChar ')'</span></p>
<p class="code4"><span class="font">else p</span></p>
<p class="para">Now we can define <span class="font">show</span> for expressions by</p>
<p class="code"><span class="font">show e = shows e ""</span></p>
<p class="code2"><span class="font">where</span></p>
<p class="code2"><span class="font">shows (Con n) = showString (show n)</span></p>
<p class="code2"><span class="font">shows (Bin op e1 e2)</span></p>
<p class="code11"><span class="font">= showParen True (shows e1 . showSpace .</span></p>
<p class="code8"><span class="font">showsop op . showSpace . shows e2)</span></p>
<p class="code"><span class="font">showsop Plus = showChar '+'</span></p>
<p class="code"><span class="font">showsop Minus = showChar '-'</span></p>
<p class="code"><a id="text/part0015.html.page_290" class="calibre3"></a><span class="font">showSpace = showChar ' '</span></p>
<p class="para">This version, which contains no explicit concatenation operations, takes linear time in the size of the expression.</p>
<p class="para">Now suppose we want to display expressions that are not fully parenthesised. There is no need for parentheses around left-hand expressions, but we do need parentheses around right-hand expressions. That leads to</p>
<p class="code"><span class="font">show = shows False e ""</span></p>
<p class="code2"><span class="font">where</span></p>
<p class="code2"><span class="font">shows b (Con n) = showString (show n)</span></p>
<p class="code2"><span class="font">shows b (Bin op e1 e2)</span></p>
<p class="code11"><span class="font">= showParen p (shows False e1 . showSpace .</span></p>
<p class="code8"><span class="font">showsop op . showSpace . shows True e2)</span></p>
<p class="para">This definition takes no account of associativity; for example, <span class="font">1+(2+3)</span> is not shown as <span class="font">1+2+3</span>.</p>
<p class="para">Finally, let’s tackle expressions involving all four arithmetic operations. The difference here is that:</p>
<p class="number">1.<span class="space"></span>With expressions <span class="font">e1 + e2</span> or <span class="font">e1 - e2</span> we will never need parentheses around <span class="font">e1</span> (just as above), nor will we need parentheses around <span class="font">e2</span> if <span class="font">e2</span> is a compound expression with a multiplication or division at the root.</p>
<p class="number">2.<span class="space"></span>On the other hand, with expressions <span class="font">e1 * e2</span> or <span class="font">e1 / e2</span> we will need parentheses around <span class="font">e1</span> if <span class="font">e1</span> is a compound expression with a plus or minus at the root, and we will always need parentheses around <span class="font">e2</span>.</p>
<p class="para">One way to codify these rules is to introduce precedence levels (for another way, see Exercise L). Define</p>
<p class="code"><span class="font">prec :: Op -&gt; Int</span></p>
<p class="code"><span class="font">prec Mul</span><span class="space5"></span><span class="font">= 2</span></p>
<p class="code"><span class="font">prec Div</span><span class="space5"></span><span class="font">= 2</span></p>
<p class="code"><span class="font">prec Plus</span><span class="space"></span><span class="space-r1"></span><span class="font">= 1</span></p>
<p class="code"><span class="font">prec Minus</span><span class="space-r"></span><span class="font">= 1</span></p>
<p class="para">Consider now how to define a function <span class="font">showsPrec</span> with type</p>
<p class="code"><span class="font">showsPrec :: Int -&gt; Expr -&gt; ShowS</span></p>
<p class="para">such that <span class="font">showsPrec p e</span> shows the expression <span class="font">e</span> assuming that the parent of <span class="font">e</span> is a compound expression with an operator of precedence <span class="font">p</span>. We will define <span class="font">show</span> by</p>
<p class="code"><a id="text/part0015.html.page_291" class="calibre3"></a><span class="font">show e = showsPrec 0 e ""</span></p>
<p class="para">so the enclosing <i class="calibre1">context</i> of <span class="font">e</span> is an operator with fictitious precedence <span class="font">0</span>. We can at once define</p>
<p class="code"><span class="font">showsPrec p (Con n) = showString (show n)</span></p>
<p class="para">because constants are never enclosed in parentheses. The interesting case is when we have a compound expression. We give the definition first and explain it afterwards:</p>
<p class="code"><span class="font">showsPrec p (Bin op e1 e2)</span></p>
<p class="code2"><span class="font">= showParen (p&gt;q) (showsPrec q e1 . showSpace .</span></p>
<p class="code11"><span class="font">showsop op . showSpace . showsPrec (q+1) e2)</span></p>
<p class="code11"><span class="font">where q = prec op</span></p>
<p class="para">We put parentheses around an expression if the parent operator has greater precedence than the current one. To display the expression <span class="font">e1</span> it is therefore sufficient to pass the current precedence as the new parent precedence. But we need parentheses around <span class="font">e2</span> if the root operator of <span class="font">e2</span> has precedence less than <i class="calibre1">or equal to</i> <span class="font">q</span>; sowe have to increment <span class="font">q</span> in the second call.</p>
<p class="para">Admittedly, the above definition of <span class="font">showsPrec</span> requires a little thought, but there is a payoff. The type class <span class="font">Show</span> has a <i class="calibre1">second</i> method in it, namely <span class="font">showsPrec</span>. Moreover, the default definition of <span class="font">show</span> is just the one above. So to install expressions as a member of <span class="font">Show</span> we merely have to give the definition of <span class="font">showsPrec</span>.</p>
<h3 class="h" id="text/part0015.html.head11-6">11.6 Exercises</h3>
<p class="theorem"><b class="calibre7">Exercise A</b></p>
<p class="para">Consider the synonym</p>
<p class="code"><span class="font">type Angle = Float</span></p>
<p class="para">Suppose we want to define equality on angles to be equality modulo a multiple of 2<i class="calibre1">π</i>. Why can’t we use <span class="font">(==)</span> for this test? Now consider</p>
<p class="code"><span class="font">newtype Angle = Angle Float</span></p>
<p class="para">Install <span class="font">Angle</span> as a member of <span class="font">Eq</span>, thereby allowing <span class="font">(==)</span> as an equality test between angles.</p>
<p class="theorem"><a id="text/part0015.html.page_292" class="calibre3"></a><b class="calibre7">Exercise B</b></p>
<p class="para">We could have defined</p>
<p class="code"><span class="font">newtype Parser a = Parser (String -&gt; Maybe (a,String))</span></p>
<p class="para">Give the monad instance of this kind of parser.</p>
<p class="theorem"><b class="calibre7">Exercise C</b></p>
<p class="para">Prove that <span class="font">fail &gt;&gt; p = fail</span>.</p>
<p class="theorem"><b class="calibre7">Exercise D</b></p>
<p class="para">Could we have defined <span class="font">&lt;|&gt;</span> in the following way?</p>
<p class="code"><span class="font">p &lt;|&gt; q = Parser (\s -&gt; parse p s ++ parse q s)</span></p>
<p class="para">When is the result a deterministic parser? Define a function</p>
<p class="code"><span class="font">limit :: Parser a -&gt; Parser a</span></p>
<p class="para">such that <span class="font">limit (p &lt;|&gt; q)</span> is a deterministic parser, even if <span class="font">p</span> and <span class="font">q</span> are not.</p>
<p class="theorem"><b class="calibre7">Exercise E</b></p>
<p class="para">Parsers are not only instances of monads, they can also be made instances of a more restricted class, called <span class="font">MonadPlus</span>, a class we could have introduced in the previous chapter. Basically, these are monads that support choice and failure. The Haskell definition is</p>
<p class="code"><span class="font">class Monad m =&gt; MonadPlus m where</span></p>
<p class="code2"><span class="font">mzero :: m a</span></p>
<p class="code2"><span class="font">mplus :: m a -&gt; m a -&gt; m a</span></p>
<p class="para">As examples, both <span class="font">[]</span> and <span class="font">Maybe</span> can be made members of <span class="font">MonadPlus</span>:</p>
<p class="code"><span class="font">instance MonadPlus [] where</span></p>
<p class="code2"><span class="font">mzero = []</span></p>
<p class="code2"><span class="font">mplus = (++)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">instance MonadPlus Maybe where</span></p>
<p class="code2"><span class="font">mzero = Nothing</span></p>
<p class="code2"><span class="font">Nothing `mplus` y = y</span></p>
<p class="code2"><span class="font">Just x `mplus` y = Just x</span></p>
<p class="para">Install <span class="font">Parser</span> as an instance of <span class="font">MonadPlus</span>.</p>
<p class="theorem"><a id="text/part0015.html.page_293" class="calibre3"></a><b class="calibre7">Exercise F</b></p>
<p class="para">Continuing from the previous exercise, the new methods <span class="font">mzero</span> and <span class="font">mplus</span> are expected to satisfy some equational laws, as is usually the case with the methods of a type class. But currently the precise set of rules that these methods should obey is not agreed on by the Haskell designers! Uncontroversial are the laws that <span class="font">mplus</span> should be associative with identity element <span class="font">mzero</span>. That’s three equations. Another reasonable law is the <i class="calibre1">left-zero</i> law</p>
<p class="code"><span class="font">mzero &gt;&gt;= f = mzero</span></p>
<p class="para">The corresponding <i class="calibre1">right-zero</i> law, namely</p>
<p class="code"><span class="font">p &gt;&gt; mzero = mzero</span></p>
<p class="para">can also be imposed. Does the <span class="font">MonadPlus</span> instance of the list monad satisfy these five laws? How about the <span class="font">Maybe</span> monad?</p>
<p class="para">Finally, the really contentious law is the following one:</p>
<p class="code"><span class="font">(p `mplus` q) &gt;&gt;= f = (p &gt;&gt;= f) `mplus` (q &gt;&gt;= f)</span></p>
<p class="para">This law is call the <i class="calibre1">left-distribution</i> law. Why can’t <span class="font">Maybe</span> be installed as a member of <span class="font">MonadPlus</span> if the left-distribution is imposed?</p>
<p class="theorem"><b class="calibre7">Exercise G</b></p>
<p class="para">Design a parser for recognising Haskell floating-point numbers. Bear in mind that <span class="font">.314</span> is not a legitimate number (no digits before the decimal point) and that <span class="font">3 . 14</span> is not legitimate either (because no spaces are allowed before or after the decimal point).</p>
<p class="theorem"><b class="calibre7">Exercise H</b></p>
<p class="para">Why are the first and second definitions of <span class="font">int</span> given in the text inefficient, compared to the third definition?</p>
<p class="theorem"><b class="calibre7">Exercise I</b></p>
<p class="para">Is <span class="font">"(3)"</span> a fully parenthesised expression? Is it a non-fully parenthesised expression? Haskell allows parenthesised constants:</p>
<p class="code6"><span class="font">ghci&gt; (3)+4</span></p>
<p class="code6"><span class="font">7</span></p>
<p class="para">Design a parser for fully parenthesised expressions that allows parentheses around constants.</p>
<p class="theorem"><a id="text/part0015.html.page_294" class="calibre3"></a><b class="calibre7">Exercise J</b></p>
<p class="para">Consider the grammar <span class="font">expr ::= term {op term}*</span>. Define <span class="font">pair</span> and <span class="font">shunt</span> so that the following parser is legitimate:</p>
<p class="code"><span class="font">expr = do {e1 &lt;- term;</span></p>
<p class="code10"><span class="font">pes &lt;- many (pair op term);</span></p>
<p class="code10"><span class="font">return (foldl shunt e1 pes)}</span></p>
<p class="theorem"><b class="calibre7">Exercise K</b></p>
<p class="para">Define the parsers <span class="font">addop</span> and <span class="font">mulop</span>.</p>
<p class="theorem"><b class="calibre7">Exercise L</b></p>
<p class="para">Consider again the showing of expressions with all four arithmetic operations. The rules for putting in parentheses come down to: we need parentheses around <span class="font">e1</span> in <span class="font">e1 op e2</span> if <span class="font">op</span> is a multiplication operator, and the root of <span class="font">e1</span> isn’t. Dually we will need parentheses around <span class="font">e2</span> if either <span class="font">op</span> is a multiplication operator or the root of <span class="font">e2</span> isn’t. Defining</p>
<p class="code"><span class="font">isMulOp Mul = True</span></p>
<p class="code"><span class="font">isMulOp Div = True</span></p>
<p class="code"><span class="font">isMulOp _</span><span class="space"></span><span class="space-r"></span><span class="font">= False</span></p>
<p class="para">construct an alternative definition of <span class="font">show</span> involving a subsidiary function</p>
<p class="code"><span class="font">showsF :: (Op -&gt; Bool) -&gt; Expr -&gt; ShowS</span></p>
<h3 class="h" id="text/part0015.html.head11-7">11.7 Answers</h3>
<p class="theorem"><b class="calibre7">Answer to Exercise A</b></p>
<p class="para">Because <span class="font">(==)</span> is the equality test on floating-point numbers, and different numbers cannot be equal.</p>
<p class="code6"><span class="font">instance Eq Angle where</span></p>
<p class="code"><span class="font">Angle x == Angle y = reduce x == reduce y</span></p>
<p class="code"><span class="font">where</span></p>
<p class="code"><span class="font">reduce x | x&lt;0 = reduce (x + r)</span></p>
<p class="code1"><span class="space-r1"></span><span class="font">| x&gt;r = reduce (x - r)</span></p>
<p class="code1"><span class="space-r1"></span><span class="font">| otherwise = x</span></p>
<p class="code1"><span class="space-r1"></span><span class="font">where r = 2*pi</span></p>
<p class="theorem"><a id="text/part0015.html.page_295" class="calibre3"></a><b class="calibre7">Answer to Exercise B</b></p>
<p class="code6"><span class="font">instance Monad Parser where</span></p>
<p class="code"><span class="font">return x = Parser (\s -&gt; Just (x,s))</span></p>
<p class="code"><span class="font">P &gt;&gt;= q = Parser (\s -&gt; case apply p s of</span></p>
<p class="code17"><span class="space4"></span><span class="font">Nothing -&gt; apply q s</span></p>
<p class="code17"><span class="space4"></span><span class="font">Just (x,s') -&gt; Just (x,s'))</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise C</b></p>
<p class="code2"><span class="font">fail &gt;&gt; p</span></p>
<p class="code"><span class="font">= fail &gt;&gt;= const p</span></p>
<p class="code"><span class="font">= fail</span></p>
<p class="para">The fact that <span class="font">fail &gt;&gt;= p = fail</span> is immediate from the definition of <span class="font">fail</span> and the definition of <span class="font">p &gt;&gt;= q</span>.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise D</b></p>
<p class="para">Yes, but the result is only a deterministic parser when either <span class="font">p</span> or <span class="font">q</span> is <span class="font">fail</span>. The function <span class="font">limit</span> can be defined by</p>
<p class="code"><span class="font">limit p = Parser (take 1 . apply p)</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise E</b></p>
<p class="code"><span class="font">mzero = fail</span></p>
<p class="code"><span class="font">mplus = (&lt;|&gt;)</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise F</b></p>
<p class="para">Yes, both the list monad and the <span class="font">Maybe</span> monad satisfy the five laws. For example, in the list monad</p>
<p class="code"><span class="font">mzero &gt;&gt;= f = concat (map f []) = [] = mzero</span></p>
<p class="code"><span class="font">xs &gt;&gt; mzero = concat (map (const []) xs) = [] = mzero</span></p>
<p class="para">With <span class="font">Maybe</span> the left-distribution law doesn’t hold. We have</p>
<p class="code2"><span class="font">(Just x `mplus` q) &gt;&gt;= (\x -&gt; Nothing)</span></p>
<p class="code"><span class="font">= Just x &gt;&gt;= (\x -&gt; Nothing)</span></p>
<p class="code"><span class="font">= Nothing</span></p>
<p class="para">but</p>
<p class="code2"><a id="text/part0015.html.page_296" class="calibre3"></a><span class="font">(Just x &gt;&gt; \x -&gt; Nothing) `mplus`</span></p>
<p class="code2"><span class="font">(q &gt;&gt;= \x -&gt; Nothing)</span></p>
<p class="code"><span class="font">= Nothing `mplus` (q &gt;&gt;= \x -&gt; Nothing)</span></p>
<p class="code"><span class="font">= q &gt;&gt;= \x -&gt; Nothing</span></p>
<p class="para">The two resulting expressions are not equal (take <span class="font">q = undefined</span>).</p>
<p class="theorem"><b class="calibre7">Answer to Exercise G</b></p>
<p class="code"><span class="font">float :: Parser Float</span></p>
<p class="code"><span class="font">float = do {ds &lt;- some digit;</span></p>
<p class="code12"><span class="font">char '.';</span></p>
<p class="code12"><span class="font">fs &lt;- some digit;</span></p>
<p class="code12"><span class="font">return (foldl shiftl 0 ds +</span></p>
<p class="code17"><span class="font">foldr shiftr 0 fs)}</span></p>
<p class="code3"><span class="font">where shiftl n d = 10*n + fromIntegral d</span></p>
<p class="code12"><span class="font">shiftr f x = (fromIntegral f+x)/10</span></p>
<p class="para">The parser <span class="font">digit</span> returns an <span class="font">Int</span>, which has to be converted to a number (in this case a <span class="font">Float</span>).</p>
<p class="theorem"><b class="calibre7">Answer to Exercise H</b></p>
<p class="para">White space is parsed twice. For example, calling the first version <span class="font">int1</span> and the third <span class="font">int3</span> we have</p>
<p class="code6"><span class="font">ghci&gt; apply int3 $ replicate 100000 ' ' ++ "3"</span></p>
<p class="code6"><span class="font">[(3,"")]</span></p>
<p class="code6"><span class="font">(1.40 secs, 216871916 bytes)</span></p>
<p class="code6"><span class="font">ghci&gt; apply int1 $ replicate 100000 ' ' ++ "3"</span></p>
<p class="code6"><span class="font">[(3,"")]</span></p>
<p class="code6"><span class="font">(2.68 secs, 427751932 bytes)</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise I</b></p>
<p class="para">No, according to the first grammar for <span class="font">expr</span>, only binary expressions can be parenthesised. Yes, according to the second grammar as arbitrary expressions can be parenthesised.</p>
<p class="para">The revised grammar is</p>
<p class="code"><span class="font">expr ::= term | '(' expr op expr ')'</span></p>
<p class="code"><span class="font">term ::= nat | '(' expr ')'</span></p>
<p class="para">The corresponding parser is</p>
<p class="code"><a id="text/part0015.html.page_297" class="calibre3"></a><span class="font">expr = token (term &lt;|&gt; paren binary)</span></p>
<p class="code2"><span class="font">where</span></p>
<p class="code2"><span class="font">term = token (constant &lt;|&gt; paren expr)</span></p>
<p class="code2"><span class="font">binary = do {e1 &lt;- expr;</span></p>
<p class="code9"><span class="font">p &lt;- op;</span></p>
<p class="code9"><span class="font">e2 &lt;- expr;</span></p>
<p class="code9"><span class="font">return (Bin p e1 e2)}</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise J</b></p>
<p class="code"><span class="font">pair :: Parser a -&gt; Parser b -&gt; Parser (a,b)</span></p>
<p class="code"><span class="font">pair p q = do {x &lt;- p; y &lt;- q; return (x,y)}</span></p>
<p class="para1"></p>
<p class="code"><span class="font">shunt e1 (p,e2) = Bin p e1 e2</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise K</b></p>
<p class="code"><span class="font">addop = (symbol "+" &gt;&gt; return Plus) &lt;|&gt;</span></p>
<p class="code1"><span class="font">(symbol "-" &gt;&gt; return Minus)</span></p>
<p class="code"><span class="font">mulop = (symbol "*" &gt;&gt; return Mul) &lt;|&gt;</span></p>
<p class="code1"><span class="font">(symbol "/" &gt;&gt; return Div)</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise L</b></p>
<p class="code"><span class="font">show e = showsF (const False) e ""</span></p>
<p class="code2"><span class="font">where</span></p>
<p class="code2"><span class="font">showsF f (Con n) = showString (show n)</span></p>
<p class="code2"><span class="font">showsF f (Bin op e1 e2)</span></p>
<p class="code11"><span class="font">= showParen (f op) (showsF f1 e1 . showSpace .</span></p>
<p class="code8"><span class="font">showsop op . showSpace . showsF f2 e2)</span></p>
<p class="code8"><span class="font">where f1 x = isMulOp op &amp;&amp; not (isMulOp x)</span></p>
<p class="code10"><span class="font">f2 x = isMulOp op || not (isMulOp x)</span></p>
<h3 class="h" id="text/part0015.html.head11-8">11.8 Chapter notes</h3>
<p class="para">The design of functional parsers in a monadic setting has long been a favourite application of functional programming. Our presentation follows that of ‘Monadic parsing in Haskell’ by Graham Hutton and Erik Meijer, which appears in <i class="calibre1">The Journal of Functional Programming</i> 8(4), 437–144, 1998.</p>
</div></div>
<div id="text/part0016.html"><div id="text/part0016.html.F8900-0daaaafc8385457e8f80971b0d39bbf7" class="calibre">

<h2 class="chapter-number" id="text/part0016.html.calibre_pb_0"><a id="text/part0016.html.page_298" class="calibre6"></a>Chapter 12</h2>
<h2 class="chapter-title">A simple equational calculator</h2>
<p class="para">This final chapter is devoted to a single programming project, the design and implementation of a simple calculator for carrying out point-free equational proofs. Although the calculator provides only a small subset of the facilities one might want in an automatic proof assistant, and is highly restrictive in a number of other ways, it will nevertheless be powerful enough to prove many of the point-free laws described in previous chapters – well, provided we are prepared to give it a nudge in the right direction if necessary. The project is also a case study in the use of modules. Each component of the calculator, its associated types and functions, is defined in an appropriate module and linked to other modules through explicit import and export lists.</p>
<h3 class="h" id="text/part0016.html.head12-1">12.1 Basic considerations</h3>
<p class="para">The basic idea is to construct a single function <span class="font">calculate</span> with type</p>
<p class="code"><span class="font">calculate :: [Law] -&gt; Expr -&gt; Calculation</span></p>
<p class="para">The first argument of <span class="font">calculate</span> is a list of laws that may be applied. Each law consists of a descriptive name and an equation. The second argument is an expression and the result is a calculation. A calculation consists of a starting expression and a sequence of steps. Each step consists of the name of a law and the expression that results by applying the left-hand side of the law to the current expression. The calculation ends when no more laws can be applied, and the final expression is the conclusion. The entire process is automatic, requiring no intervention on the part of the user.</p>
<p class="para"><a id="text/part0016.html.page_299" class="calibre3"></a>Laws, expressions and calculations are each elements of appropriate data types to be defined in the following sections. But for now let us plunge straight in with an example to show the framework we have in mind.</p>
<p class="para">Here are some laws (we use a smaller font to avoid breaking lines):</p>
<p class="code"><span class="font">definition filter: filter p = concat . map (box p)</span></p>
<p class="code"><span class="font">definition box: box p = if p one nil</span></p>
<p class="para1"></p>
<p class="code"><span class="font">if after dot: if p f g . h = if (p . h) (f . h) (g . h)</span></p>
<p class="code"><span class="font">dot after if: h . if p f g = if p (h . f) (h . g)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">nil constant: nil . f = nil</span></p>
<p class="code"><span class="font">map after nil: map f . nil = nil</span></p>
<p class="code"><span class="font">map after one: map f . one = one . f</span></p>
<p class="para1"></p>
<p class="code"><span class="font">map after concat: map f . concat = concat . map (map f)</span></p>
<p class="para1"></p>
<p class="code"><span class="font">map functor: map f . map g = map (f . g)</span></p>
<p class="code"><span class="font">map functor: map id = id</span></p>
<p class="para">Each law consists of a name and an equation. The name of the law is terminated by a colon sign, and an equation consists of two expressions separated by an equals sign. Each expression describes a function; our calculator will be one that simplifies functional expressions only (yes, it’s a pointless calculator). Expressions are built from constants, like <span class="font">one</span> and <span class="font">map</span>, and variables, like <span class="font">f</span> and <span class="font">g</span>. The precise syntax will be given in due course. Note that there are no conditional laws, equations that are valid only if some subsidiary conditions are met. That will limit what we can do with the calculator, but it still leaves enough to be interesting.</p>
<p class="para">Suppose we want to simplify the expression <span class="font">filter p . map f</span>. Here is one possible calculation:</p>
<p class="code2"><span class="font">filter p . map f</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span><span class="font">{definition filter}</span></p>
<p class="code2"><span class="font">concat . map (box p) . map f</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span><span class="font">{map functor}</span></p>
<p class="code2"><span class="font">concat . map (box p . f)</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span><span class="font">{definition box}</span></p>
<p class="code2"><span class="font">concat . map (if p one nil . f)</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span><span class="font">{if after dot}</span></p>
<p class="code2"><span class="font">concat . map (if (p . f) (one . f) (nil . f))</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span><span class="font">{nil constant}</span></p>
<p class="code2"><span class="font">concat . map (if (p . f) (one . f) nil)</span></p>
<p class="para">The steps of the calculation are displayed in the conventional format with the name of the law being invoked printed in braces between the two expressions to which <a id="text/part0016.html.page_300" class="calibre3"></a>it applies. No more laws apply to the final expression, so that is the result of the calculation. It is certainly not simpler than the expression we started out with.</p>
<p class="para">The calculator could have applied some of the laws in a different order; for example, the definition of <span class="font">box</span> could have been applied at the second step rather than at the third. But the conclusion would have been the same. It is also possible, though not with this particular set of laws, that an expression could be simplified to different conclusions by different calculations. However, at the outset we make the decision that <span class="font">calculate</span> returns just one calculation, not a tree of possible calculations.</p>
<p class="para">Notice what is happening at each step. Some left-hand side of some law is <i class="calibre1">matched</i> against some subexpression of the current expression. If a match is successful the result is a <i class="calibre1">substitution</i> for the variables occurring in the law. For example, in the second step, the subexpression <span class="font">map (box p) . map f</span> is successfully matched with the first map functor law, resulting in a substitution in which the variable <span class="font">f</span> of the functor law is bound to the expression <span class="font">box p</span>, and the variable <span class="font">g</span> is bound to <span class="font">f</span>. The result of the step involves <i class="calibre1">rewriting</i> the subexpression with the corresponding instance of the right-hand side of the law in which each variable is replaced by its binding expression. Matching, substitutions and rewriting are all fundamental components of the calculator.</p>
<p class="para">Now suppose that with the same set of laws as above we want to simplify the expression <span class="font">map f . filter (p . f)</span>. Here is the calculation:</p>
<p class="code2"><span class="font">map f . filter (p . f)</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span><span class="font">{definition filter}</span></p>
<p class="code2"><span class="font">map f . concat . map (box (p . f))</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span><span class="font">{map after concat}</span></p>
<p class="code2"><span class="font">concat . map (map f) . map (box (p . f))</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span><span class="font">{map functor}</span></p>
<p class="code2"><span class="font">concat . map (map f . box (p . f))</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span><span class="font">{definition box}</span></p>
<p class="code2"><span class="font">concat . map (map f . if (p . f) one nil)</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span><span class="font">{dot after if}</span></p>
<p class="code2"><span class="font">concat . map (if (p . f) (map f . one) (map f . nil))</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span><span class="font">{map after nil}</span></p>
<p class="code2"><span class="font">concat . map (if (p . f) (map f . one) nil)</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span><span class="font">{map after one}</span></p>
<p class="code2"><span class="font">concat . map (if (p . f) (one . f) nil)</span></p>
<p class="para">Again, some of the laws could have been applied in a different order. No more laws apply to the final expression so that is the result of the calculation.</p>
<p class="para">The point about these two calculations is that the two final expressions are the same, so we have proved</p>
<p class="code"><a id="text/part0016.html.page_301" class="calibre3"></a><span class="font">filter p . map f = map f . filter (p . f)</span></p>
<p class="para">This is the way we will conduct equational proofs, simplifying both sides to the same conclusion. Rather than show two calculations, one after the other, the two results can be <i class="calibre1">pasted</i> together by recording the first calculation and then appending the steps of the second calculation in reverse. The main advantage of this scheme is simplicity; we do not have to invent a new format for proofs, and we do not have to apply laws from right to left in order to reach the desired goal. Accordingly, we will also define a function</p>
<p class="code"><span class="font">prove :: [Law] -&gt; Equation -&gt; Calculation</span></p>
<p class="para">for proving equations.</p>
<p class="center"><i class="calibre1">Further considerations</i></p>
<p class="para">It is a basic constraint of our calculator that laws are applied in one direction only, namely from left to right. This is primarily to prevent calculations from looping. If laws could be applied in both directions, then the calculator could oscillate by applying a law in one direction and then immediately applying it in the reverse direction.</p>
<p class="para">Even with a left-to-right rule, some laws can lead to infinite calculations. Typically, these laws are the definitions of recursive functions. For example, consider the definition of <span class="font">iterate</span>:</p>
<p class="code"><span class="font">defn iterate: iterate f = cons . fork id (iterate f . f)</span></p>
<p class="para">This is the definition of <span class="font">iterate</span> expressed in point-free form. The functions <span class="font">cons</span> and <span class="font">fork</span> are defined by</p>
<p class="code"><span class="font">cons (x,xs) = x:xs</span></p>
<p class="code"><span class="font">fork f g x = (f x,g x)</span></p>
<p class="para">We have met <span class="font">fork</span> before in the exercises in Chapters 4 and 6, except that we wrote <span class="font">fork (f,g)</span> instead of <span class="font">fork f g</span>. In what follows, all our functions will be curried. The appearance of the term <span class="font">iterate f</span> on both sides of the law means that any calculation that can apply the definition of <span class="font">iterate</span> once can, potentially, apply it infinitely often. But not necessarily. Here is a calculation (produced by the calculator) that avoids infinite regress:</p>
<p class="code2"><span class="font">head . iterate f</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span><span class="font">{defn iterate}</span></p>
<p class="code2"><span class="font">head . cons . fork id (iterate f . f)</span></p>
<p class="code"><a id="text/part0016.html.page_302" class="calibre3"></a><span class="font">=</span><span class="space5"></span><span class="font">{head after cons}</span></p>
<p class="code2"><span class="font">fst . fork id (iterate f . f)</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span><span class="font">{fst after fork}</span></p>
<p class="code2"><span class="font">id</span></p>
<p class="para">The calculation makes use of the two laws:</p>
<p class="code"><span class="font">head after cons: head . cons = fst</span></p>
<p class="code"><span class="font">fst after fork: first . fork f g = f</span></p>
<p class="para">The reason non-termination is avoided is that these two laws are given preference over definitions in calculations, a wrinkle that we will elaborate on below.</p>
<p class="para">In order to appreciate just what the calculator can and cannot do, here is another example of rendering a recursive definition into point-free form. Consider the definition of concatenation:</p>
<p class="code"><span class="font">[] ++ ys = ys</span></p>
<p class="code"><span class="font">(x:xs) ++ ys = x:(xs ++ ys)</span></p>
<p class="para">We will use <span class="font">cat</span> to stand for <span class="font">(++)</span>. We will also need <span class="font">nil</span>, <span class="font">cons</span> and the function <span class="font">cross (f,g)</span>, which we will now write as <span class="font">f * g</span>. Thus,</p>
<p class="code"><span class="font">(f * g) (x,y) = (f x, g y)</span></p>
<p class="para">Finally we will need a combinator <span class="font">assocr</span> (short for ‘associate-right’), defined by</p>
<p class="code"><span class="font">assocr ((x,y),z) = (x,(y,z))</span></p>
<p class="para">Here are the translations of the two defining equations of <span class="font">cat</span> in point-free form:</p>
<p class="code"><span class="font">cat . (nil * id) = snd</span></p>
<p class="code"><span class="font">cat . (cons * id) = cons . (id * cat) . assocr</span></p>
<p class="para">We cannot prove that <span class="font">cat</span> is associative with our calculator, for that would involve a proof by induction, but we can state it as a law:</p>
<p class="code"><span class="font">cat associative: cat . (cat * id) = cat . (id * cat) . assocr</span></p>
<p class="para">Continuing with this example for a bit longer, here are the two bifunctor laws of <span class="font">(*)</span>:</p>
<p class="code"><span class="font">bifunctor *: id * id = id</span></p>
<p class="code"><span class="font">bifunctor *: (f * g) . (h * k) = (f . h) * (g . k)</span></p>
<p class="para">And here is a law about <span class="font">assocr</span>:</p>
<p class="code"><span class="font">assocr law: assocr . ((f * g) * h) = (f * (g * h)) . assocr</span></p>
<p class="para"><a id="text/part0016.html.page_303" class="calibre3"></a>Now for the point of the example: our calculator <i class="calibre1">cannot</i> perform the following valid calculation:</p>
<p class="code"><span class="font">cat . ((cat . (f * g)) * h)</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{identity law, in backwards direction}</span></p>
<p class="code"><span class="font">cat . ((cat . (f * g)) * (id . h))</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{bifunctor *, in backwards direction}</span></p>
<p class="code"><span class="font">cat . (cat * id) . ((f * g) * h)</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{cat associative}</span></p>
<p class="code"><span class="font">cat . (id * cat) . assocr . ((f * g) * h)</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{assoc law}</span></p>
<p class="code"><span class="font">cat . (id * cat) . (f * (g * h)) . assocr</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{bifunctor *}</span></p>
<p class="code"><span class="font">cat . ((id . f) * (cat . (g * h))) . assocr</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{identity law}</span></p>
<p class="code"><span class="font">cat . (f * (cat . (g * h))) . assocr</span></p>
<p class="para">The problem here is that we have to apply the identity and bifunctor laws in <i class="calibre1">both</i> directions, and the calculator is simply not up to the task. Observe that the essence of the proof is the simplification of the expression</p>
<p class="code"><span class="font">cat . (id * cat) . assocr . ((f * g) * h)</span></p>
<p class="para">in two different ways, one by using the associativity of <span class="font">cat</span>, written in the form</p>
<p class="code"><span class="font">cat associative: cat . (id * cat) . assocr = cat . (cat * id)</span></p>
<p class="para">and one by using the <span class="font">assocr</span> law. Even if we generalised <span class="font">calculate</span> to return a tree of possible calculations, it would not be obvious what expression we would have to start out with in order to achieve the calculation above, so we abandon any attempt to get the calculator to produce it.</p>
<p class="para">It is not just the functor laws that sometimes have to be applied in both directions. For an example, see <a href="#text/part0016.html.head12-8" class="calibre3">Section 12.8</a>. Sometimes we can get around the problem by stating a law in a more general form than necessary, sometimes by using a hack, and sometimes not at all. As we said at the outset, our calculator is a limited one.</p>
<p class="para">In the scheme of automatic calculation that we are envisaging there are only two degrees of freedom: the choice of which law to apply, and the choice of which subexpression to be changed. The first degree of freedom can be embodied in the order in which laws are presented to the calculator: if two different laws are applicable, then the one earlier in the list is chosen.</p>
<p class="para">Certainly some laws should be tried before others; these are laws that reduce the complexity of intermediate expressions. Good examples are the laws <span class="font">f.id = f</span> and <span class="font">id.f = f</span>. The naive definition of complexity is that there are fewer compositions on the right than on the left. It is unlikely to be a mistake to apply these</p>
<p class="para"><a id="text/part0016.html.page_304" class="calibre3"></a>laws as soon as the opportunity arises. Indeed the fact that <span class="font">id</span> is the identity element of composition can and will be built into the calculator, so the two identity laws will be taken care of automatically. Similarly, early application of laws like <span class="font">nil.f = nil</span> and <span class="font">map f.nil = nil</span> (and indeed the two laws used in the calculation about <span class="font">iterate</span>), all of which reduce the number of compositions, help to reduce the sizes of intermediate expressions. For the sake of a word, let us call these the <i class="calibre1">simple</i> laws.</p>
<p class="para">On the other hand, some laws should be applied only as a last resort. Typically, these laws are definitions, such as the definition of <span class="font">filter</span> or <span class="font">iterate</span>. For example, in the expression</p>
<p class="code"><span class="font">map f . concat . map (filter p)</span></p>
<p class="para">we really don’t want to apply the definition of <span class="font">filter</span> too early; rather we would prefer to apply the <span class="font">map</span> after <span class="font">concat</span> law first, and only apply the definition of <span class="font">filter</span> later on if and when it becomes necessary. Apart from anything else, intermediate expressions will be shorter.</p>
<p class="para">In summary it looks sensible to sort our laws into the simple laws, followed the non-simple laws that are not definitions, followed by the definitions. The second degree of freedom is represented by the order in which the subexpressions of a given expression are presented as candidates for instances of laws: if laws are applicable to two different subexpressions, then the subexpression coming earlier in the enumeration is chosen.</p>
<p class="para">That still leaves open the decision whether to give preference to laws or to subexpressions in calculations. Do we start with a subexpression and try every law in turn, or start with a law and see if it applies anywhere? Does it really matter which of these alternatives is chosen? While it is true that, having applied some law at some subexpression, the next law to be applied is likely to be at a ‘nearby’ expression, it is not clear how to formalise this notion of nearness, nor is it clear whether it would contribute significantly to the efficiency of calculations, either in the computation time or in the length of the result.</p>
<h3 class="h" id="text/part0016.html.head12-2">12.2 Expressions</h3>
<p class="para">At the heart of the calculator is the data type <span class="font">Expr</span> of expressions. Most of the components of the calculator are concerned with analysing and manipulating expressions in one way or the other. Expressions are built from (function) variables <a id="text/part0016.html.page_305" class="calibre3"></a>and constants, using functional composition as the basic combining form. Variables take no arguments, but constants can take any number of arguments, which are themselves expressions. We will suppose all functions are curried and there are no tuples; for example we write <span class="font">pair f g</span> instead of <span class="font">pair (f,g)</span>. There is no particular reason for avoiding tuples, it is just that most functions we have discussed in the book are curried and we don’t really need both.</p>
<p class="para">To compensate, we will also allow ourselves binary infix operators, writing, for example, <span class="font">f * g</span> instead of <span class="font">cross f g</span>. Except for functional composition we will not assume any order of precedence or association between binary operators, insisting that expressions involving such operators be fully parenthesised. That still leaves open the question of the precedence of composition. Does <span class="font">f * g . h</span> mean <span class="font">(f * g) . h</span> or <span class="font">f * (g . h)</span>? Haskell puts composition at a high level of precedence and we will adopt the same convention. Thus <span class="font">f * g . h</span> will be parsed as <span class="font">f * (g . h)</span>. But we will always write such expressions using parentheses to avoid ambiguity.</p>
<p class="para">Here is the proposed BNF grammar for expressions:</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">expr</span></td>
<td class="calibre14"><span class="font">::= simple {op simple}</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">simple</span></td>
<td class="calibre14"><span class="font">::= term {'.' term}*</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">term</span></td>
<td class="calibre14"><span class="font">::= var | con {arg}* | '(' expr ')'</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">arg</span></td>
<td class="calibre14"><span class="font">::= var | con | '(' expr ')'</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">var</span></td>
<td class="calibre14"><span class="font">::= letter {digit}</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">con</span></td>
<td class="calibre14"><span class="font">::= letter letter {letter | digit}*</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">op</span></td>
<td class="calibre14"><span class="font">::= {symbol}+</span></td>
</tr>
</tbody></table>
<p class="para">Variable names consist of single letters only, possibly followed by a single digit. Thus <span class="font">f</span> and <span class="font">f1</span> are legitimate variable names. Constant names are sequences of at least two alphanumeric characters beginning with two letters, such as <span class="font">map</span> or <span class="font">lhs2tex</span>, while operator names are nonempty sequences of non-alphanumeric symbols, such as <span class="font">*</span> and <span class="font">&lt;+&gt;</span>. The first line says that an expression is a simple expression, possibly followed by an operator and another simple expression. Simple expressions are compositions of terms. The remaining lines are, we trust, selfexplanatory.</p>
<p class="para">Here is the definition of <span class="font">Expr</span> we will use:</p>
<p class="code"><span class="font">newtype Expr</span><span class="space"></span><span class="font">= Compose [Atom] deriving Eq</span></p>
<p class="code"><span class="font">data Atom</span><span class="space5"></span><span class="space-r"></span><span class="font">= Var VarName | Con ConName [Expr]</span></p>
<p class="code4"><span class="font">deriving Eq</span></p>
<p class="code"><span class="font">type VarName = String</span></p>
<p class="code"><span class="font">type ConName = String</span></p>
<p class="para"><a id="text/part0016.html.page_306" class="calibre3"></a>Expressions and atoms are declared to be members of the class <span class="font">Eq</span> because we will need to test expressions for equality. Later on we will install expressions as an instance of <span class="font">Show</span> for printing them at the terminal.</p>
<p class="para">Here are some examples of expressions and their representations:</p>
<table class="calibre12">
<tbody><tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">f . g . h</span></td>
<td class="calibre14"><span class="font">=&gt; Compose [Var "f",Var "g",Var "h"]</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">id</span></td>
<td class="calibre14"><span class="font">=&gt; Compose []</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">fst</span></td>
<td class="calibre14"><span class="font">=&gt; Compose [Con "fst" []]</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">fst . f</span></td>
<td class="calibre14"><span class="font">=&gt; Compose [Con "fst" [],Var "f"]</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">(f * g) . h</span></td>
<td class="calibre14"><span class="font">=&gt; Compose [Con "*" [Var "f",Var "g"],Var "h"]</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"><span class="space5"></span><span class="font">f * g . h</span></td>
<td class="calibre14"><span class="font">=&gt; Compose [Con "*" [Compose [Var "f"],</span></td>
</tr>
<tr class="calibre13">
<td class="calibre14"></td>
<td class="calibre14"><span class="space6"></span><span class="space5"></span><span class="font">Compose [Var "g",Var "h"]]]</span></td>
</tr>
</tbody></table>
<p class="para">The fact that composition is an associative operation is built into the design of <span class="font">Expr</span>. The particular constant <span class="font">id</span> is reserved and will always be interpreted as the identity element of composition.</p>
<p class="para">The parsing combinators described in the previous chapter enable us to parse expressions. Following the BNF, we start with</p>
<p class="code"><span class="font">expr :: Parser Expr</span></p>
<p class="code"><span class="font">expr = simple &gt;&gt;= rest</span></p>
<p class="code"><span class="space-r"></span><span class="font">where</span></p>
<p class="code"><span class="space-r"></span><span class="font">rest s1 = do {op &lt;- operator;</span></p>
<p class="code4"><span class="font">s2 &lt;- simple;</span></p>
<p class="code4"><span class="font">return (Compose [Con op [s1,s2]])}</span></p>
<p class="code12"><span class="font">&lt;|&gt; return s1</span></p>
<p class="para">An operator is a sequence of one or more operator symbols, as long as it is neither the composition operator nor an equals sign:</p>
<p class="code"><span class="font">operator :: Parser String</span></p>
<p class="code"><span class="font">operator = do {op &lt;- token (some (sat symbolic));</span></p>
<p class="code4"><span class="font">Parsing.guard (op /= "." &amp;&amp; op /= "=");</span></p>
<p class="code4"><span class="font">return op}</span></p>
<p class="para1"></p>
<p class="code"><span class="font">symbolic = (`elem` opsymbols)</span></p>
<p class="code"><span class="font">opsymbols = "!@#$%&amp;*+./&lt;=&gt;?\\^|:-~"</span></p>
<p class="para">The function <span class="font">Parsing.guard</span> is an example of a <i class="calibre1">qualified</i> name. The Haskell Prelude also provides a function <span class="font">guard</span>, but we want the function of the same name from a module <span class="font">Parsing</span> that includes all our parsing functions. A qualified name consists of a module name followed by a period followed by the name of the qualified value.</p>
<p class="para"><a id="text/part0016.html.page_307" class="calibre3"></a>A simple expression is a sequence of one or more terms separated by composition:</p>
<p class="code"><span class="font">simple :: Parser Expr</span></p>
<p class="code"><span class="font">simple = do {es &lt;- somewith (symbol ".") term;</span></p>
<p class="code9"><span class="font">return (Compose (concatMap deCompose es))}</span></p>
<p class="para">The function <span class="font">concatMap f</span> as an alternative to <span class="font">concat . map f</span> is provided in the standard prelude, and <span class="font">deCompose</span> is defined by</p>
<p class="code"><span class="font">deCompose :: Expr -&gt; [Atom]</span></p>
<p class="code"><span class="font">deCompose (Compose as) = as</span></p>
<p class="para">Next, a term is an identifier, either a variable or a constant, possibly with arguments, or a parenthesised expression:</p>
<p class="code"><span class="font">term :: Parser Expr</span></p>
<p class="code"><span class="font">term = ident args &lt;|&gt; paren expr</span></p>
<p class="code"><span class="font">args = many (ident none &lt;|&gt; paren expr)</span></p>
<p class="para">The parser <span class="font">ident</span> takes a parser for a list of expressions and returns a parser for expressions:</p>
<p class="code"><span class="font">ident :: Parser [Expr] -&gt; Parser Exp</span></p>
<p class="code"><span class="font">ident args</span></p>
<p class="code"><span class="font">= do {x &lt;- token (some (sat isAlphaNum));</span></p>
<p class="code8"><span class="font">Parsing.guard (isAlpha (head x));</span></p>
<p class="code8"><span class="font">if isVar x</span></p>
<p class="code8"><span class="font">then return (Compose [Var x])</span></p>
<p class="code8"><span class="font">else if (x == "id")</span></p>
<p class="code8"><span class="font">then return (Compose [])</span></p>
<p class="code8"><span class="font">else</span></p>
<p class="code8"><span class="font">do {as &lt;- args;</span></p>
<p class="code1"><span class="font">return (Compose [Con x as])}}</span></p>
<p class="para">The test for being a variable is implemented by</p>
<p class="code"><span class="font">isVar [x]</span><span class="space5"></span><span class="font">= True</span></p>
<p class="code"><span class="font">isVar [x,d] = isDigit d</span></p>
<p class="code"><span class="font">isVar _</span><span class="space4"></span><span class="font">= False</span></p>
<p class="para">Note that any identifier consisting entirely of alphanumeric characters and beginning with a letter and which is not a variable is a constant.</p>
<p class="para">Next, we make <span class="font">Expr</span> and <span class="font">Atom</span> instances of <span class="font">Show</span>. As in the previous chapter we <a id="text/part0016.html.page_308" class="calibre3"></a>will do this by defining <span class="font">showsPrec p</span> for each type. A little thought reveals that we need three values for <span class="font">p</span>:</p>
<ul class="calibre9">
<li class="calibre10">At top level, there is no need for parentheses. For example, we write all of <span class="font">map f . map g</span>, <span class="font">foo * baz</span>, and <span class="font">bar bie doll</span> without parentheses. We assign <span class="font">p=0</span> to this case.</li>
<li class="calibre10">When an expression is a composition of terms, or an operator expression, occurring as an argument to a constant, we need to parenthesise it. For example, parentheses are necessary in the expression</li>
</ul>
<p class="para1"></p>
<p class="code11"><span class="font">map (f . g) . foo f g . (bar * bar)</span></p>
<p class="para"><span class="space"></span>But we don’t have to parenthesise the middle term. We assign <span class="font">p=1</span> to this case.</p>
<ul class="calibre9">
<li class="calibre10">Finally, <span class="font">p=2</span> means we should parenthesise compositions of terms, operator expressions and curried functions of at least one argument, as in</li>
</ul>
<p class="code"><span class="font">map (f . g) . foo (foldr f e) g . (bar * bar)</span></p>
<p class="para">Here goes. We start with</p>
<p class="code"><span class="font">instance Show Expr where</span></p>
<p class="code"><span class="space"></span><span class="space-r1"></span><span class="font">showsPrec p (Compose []) = showString "id"</span></p>
<p class="code"><span class="space-r"></span><span class="font">showsPrec p (Compose [a]) = showsPrec p a</span></p>
<p class="code"><span class="space-r"></span><span class="font">showsPrec p (Compose as)</span></p>
<p class="code"><span class="space5"></span><span class="font">= showParen (p&gt;0) (showSep " . " (showsPrec 1) as)</span></p>
<p class="para">The last line makes use of the function <span class="font">showSep</span>, defined by</p>
<p class="code"><span class="font">showSep :: String -&gt; (a -&gt; ShowS) -&gt; [a] -&gt; ShowS</span></p>
<p class="code"><span class="font">showSep sep f</span></p>
<p class="code"><span class="space"></span><span class="font">= compose . intersperse (showString sep) . map f</span></p>
<p class="para">The utility function <span class="font">compose</span> is defined by <span class="font">compose = foldr (.) id</span>. The function <span class="font">intersperse :: a -&gt; [a] -&gt; [a]</span> can be found in <span class="font">Data.List</span> and intersperses its first argument between elements of its second. For example,</p>
<p class="code"><span class="font">intersperse ',' "abcde" == "a,b,c,d,e"</span></p>
<p class="para">The two occurrences of <span class="font">showsPrec</span> on the right-hand sides of the second two clauses of <span class="font">showsPrec</span> refer to the corresponding function for atoms:</p>
<p class="code"><span class="font">instance Show Atom where</span></p>
<p class="code6"><span class="space5"></span><span class="space-r"></span><span class="font">showsPrec p (Var v) = showString v</span></p>
<p class="code"><span class="space-r"></span><span class="font">showsPrec p (Con f []) = showString f</span></p>
<p class="code"><span class="space-r"></span><span class="font">showsPrec p (Con f [e1,e2])</span></p>
<p class="code"><span class="space-r"></span><a id="text/part0016.html.page_309" class="calibre3"></a><span class="font">| isOp f = showParen (p&gt;0) (showsPrec 1 e1 . showSpace .</span></p>
<p class="code4"><span class="space-r"></span><span class="font">showString f . showSpace . showsPrec 1 e2)</span></p>
<p class="code"><span class="font">showsPrec p (Con f es)</span></p>
<p class="code"><span class="space-r"></span><span class="font">= showParen (p&gt;1) (showString f . showSpace .</span></p>
<p class="code11"><span class="space-r"></span><span class="font">showSep " " (showsPrec 2) es)</span></p>
<p class="code"><span class="font">isOp f = all symbolic f</span></p>
<p class="para">The value <span class="font">p=2</span> is needed in the final clause because we want parentheses in, for example, <span class="font">foo (bar bie) doll</span>. Variables and nullary constants never need parentheses.</p>
<p class="center"><i class="calibre1">A module structure</i></p>
<p class="para">The final step is to install these definitions, and possibly others, in a module for expressions. Such a module will include all the functions specifically related to expressions.</p>
<p class="para">Creating such a module is not immediate because we do not yet know what other functions on expressions we may need in other modules, modules that deal with laws, calculations and so on. But for the moment we declare</p>
<p class="code"><span class="font">module Expressions</span></p>
<p class="code2"><span class="font">(Expr (Compose), Atom (Var,Con),</span></p>
<p class="code2"><span class="font">VarName, ConName, deCompose, expr)</span></p>
<p class="code"><span class="font">where</span></p>
<p class="code"><span class="font">import Parsing</span></p>
<p class="code"><span class="font">import Data.List (intersperse)</span></p>
<p class="code"><span class="font">import Utilities (compose)</span></p>
<p class="code"><span class="font">import Data.Char (isAlphaNum,isAlpha,isDigit)</span></p>
<p class="para">The module <span class="font">Expressions</span> has to be stored in a file <span class="font">Expressions.lhs</span> to enable Haskell to find out where it resides. It exports the types <span class="font">Expr</span> and <span class="font">Atom</span> along with their constructors. It also exports the type synonyms <span class="font">VarName</span> and <span class="font">ConName</span>, as well as the functions <span class="font">deCompose</span> and <span class="font">expr</span>, all of which are likely to be needed in the module that deals with laws. Later on we might add more functions on expressions to this export list.</p>
<p class="para">Next comes the imports. We import the module <span class="font">Parsing</span> that contains the parsing functions, and also some functions from <span class="font">Data.List</span> and <span class="font">Data.Char</span>. We will also set up a module <span class="font">Utilities</span> containing general utility functions. A good example <a id="text/part0016.html.page_310" class="calibre3"></a>of a utility function is <span class="font">compose</span>, defined above. It is not specific to expressions and may be needed in other places, so we put it into the utilities module.</p>
<h3 class="h" id="text/part0016.html.head12-3">12.3 Laws</h3>
<p class="para">We define laws in the following way:</p>
<p class="code"><span class="font">data Law</span><span class="space2"></span><span class="font">= Law LawName Equation</span></p>
<p class="code"><span class="font">type LawName</span><span class="space-r"></span><span class="space"></span><span class="font">= String</span></p>
<p class="code"><span class="font">type Equation</span><span class="space-r1"></span><span class="space-r"></span><span class="font">= (Expr,Expr)</span></p>
<p class="para">A law consists of a descriptive name and an equation. To parse a law we define:</p>
<p class="code"><span class="font">law :: Parser Law</span></p>
<p class="code"><span class="font">law = do {name &lt;- upto ':';</span></p>
<p class="code1"><span class="font">eqn &lt;- equation;</span></p>
<p class="code1"><span class="font">return (Law name eqn)}</span></p>
<p class="para">The parsing function <span class="font">upto c</span> returns the string up to but not including the character <span class="font">c</span>, and then discards <span class="font">c</span> if found. It wasn’t included among the parsing functions of the previous chapter, but we will put it into the module <span class="font">Parsing</span> to avoid breaking the parser abstraction. One definition is:</p>
<p class="code"><span class="font">upto :: Char -&gt; Parser String</span></p>
<p class="code"><span class="font">upto c</span></p>
<p class="code"><span class="font">= Parser (\s -&gt;</span></p>
<p class="code10"><span class="font">let (xs,ys) = break (==c) s in</span></p>
<p class="code10"><span class="font">if null ys then []</span></p>
<p class="code10"><span class="font">else [(xs,tail ys)])</span></p>
<p class="para">The parser <span class="font">equation</span> is defined by</p>
<p class="code"><span class="font">equation :: Parser Equation</span></p>
<p class="code"><span class="font">equation = do {e1 &lt;- expr;</span></p>
<p class="code9"><span class="font">symbol "=";</span></p>
<p class="code9"><span class="font">e2 &lt;- expr;</span></p>
<p class="code9"><span class="font">return (e1,e2)}</span></p>
<p class="para">We probably don’t need to show laws, but here is the definition anyway:</p>
<p class="code"><span class="font">instance Show Law where</span></p>
<p class="code2"><span class="font">showsPrec _ (Law name (e1,e2))</span></p>
<p class="code1"><span class="font">= showString name .</span></p>
<p class="code1"><a id="text/part0016.html.page_311" class="calibre3"></a><span class="font">showString ": " .</span></p>
<p class="code1"><span class="font">shows e1 .</span></p>
<p class="code1"><span class="font">showString " = " .</span></p>
<p class="code1"><span class="font">shows e2</span></p>
<p class="para">The precedence number is not needed to define <span class="font">showPrec</span> so it is made a don’t care pattern. Recall that <span class="font">shows</span> takes a printable value, here an expression, and returns a function of type <span class="font">ShowS</span>, a synonym for <span class="font">String -&gt; String</span>.</p>
<p class="para">Finally we sort the laws:</p>
<p class="code"><span class="font">sortLaws :: [Law] -&gt; [Law]</span></p>
<p class="code"><span class="font">sortLaws laws = simple ++ others ++ defns</span></p>
<p class="code"><span class="font">where</span></p>
<p class="code"><span class="font">(simple,nonsimple) = partition isSimple laws</span></p>
<p class="code"><span class="font">(defns,others) = partition isDefn nonsimple</span></p>
<p class="para">This definition makes use of a <span class="font">Data.List</span> function <span class="font">partition</span> that partitions a list:</p>
<p class="code"><span class="font">partition p xs = (filter p xs, filter (not . p) xs)</span></p>
<p class="para">The various tests are defined by</p>
<p class="code"><span class="font">isSimple (Law _ (Compose as1,Compose as2))</span></p>
<p class="code1"><span class="space-r"></span><span class="font">= length as1 &gt; length as2</span></p>
<p class="code"><span class="font">isDefn (Law _ (Compose [Con f es], _))</span></p>
<p class="code1"><span class="space-r"></span><span class="font">= all isVar es</span></p>
<p class="code"><span class="font">isDefn _ = False</span></p>
<p class="code"><span class="font">isVar (Compose [Var _]) = True</span></p>
<p class="code"><span class="font">isVar _ = False</span></p>
<p class="para">The test <span class="font">isVar</span> also appears in the module <span class="font">Expressions</span> though with a different definition. There is no problem though since that function is not exported from the expressions module.</p>
<p class="para">Here is the module declaration for laws:</p>
<p class="code"><span class="font">module Laws</span></p>
<p class="code2"><span class="font">(Law (Law), LawName, law, sortLaws,</span></p>
<p class="code2"><span class="font">Equation, equation)</span></p>
<p class="code"><span class="font">where</span></p>
<p class="code"><span class="font">import Expressions</span></p>
<p class="code"><span class="font">import Parsing</span></p>
<p class="code"><span class="font">import Data.List (partition)</span></p>
<p class="para"><a id="text/part0016.html.page_312" class="calibre3"></a>Having shown how to parse and print expressions and laws, we can now define two functions, one a version of <span class="font">calculate</span> that consumes strings rather than laws and expressions:</p>
<p class="code"><span class="font">simplify :: [String] -&gt; String -&gt; Calculation</span></p>
<p class="code"><span class="font">simplify strings string</span></p>
<p class="code"><span class="space-r"></span><span class="font">= let laws = map (parse law) strings</span></p>
<p class="code3"><span class="font">e = parse expr string</span></p>
<p class="code2"><span class="space"></span><span class="font">in calculate laws e</span></p>
<p class="para">In a similar vein we can define</p>
<p class="code"><span class="font">prove :: [String] -&gt; String -&gt; Calculation</span></p>
<p class="code"><span class="font">prove strings string</span></p>
<p class="code"><span class="font">= let laws = map (parse law) strings</span></p>
<p class="code2"><span class="font">(e1,e2) = parse equation string</span></p>
<p class="code"><span class="font">in paste (calculate laws e1) (calculate laws e2)</span></p>
<p class="para">These two functions can be put in a module <span class="font">Main</span>. We put <span class="font">paste</span> and <span class="font">calculate</span> into a module concerned solely with calculations, and we turn to this module next.</p>
<h3 class="h" id="text/part0016.html.head12-4">12.4 Calculations</h3>
<p class="para">Calculations are defined by</p>
<p class="code"><span class="font">data Calculation = Calc Expr [Step]</span></p>
<p class="code"><span class="font">type Step</span><span class="space2"></span><span class="space"></span><span class="font">= (LawName,Expr)</span></p>
<p class="para">Let’s begin with the key definition of the calculator, that of <span class="font">calculate</span>:</p>
<p class="code"><span class="font">calculate :: [Law] -&gt; Expr -&gt; Calculation</span></p>
<p class="code"><span class="font">calculate laws e = Calc e (manyStep rws e)</span></p>
<p class="code"><span class="space-r"></span><span class="font">where rws e = [(name,e')</span></p>
<p class="code4"><span class="font">| Law name eqn &lt;- sortedlaws,</span></p>
<p class="code14"><span class="font">e' &lt;- rewrites eqn e,</span></p>
<p class="code14"><span class="font">e' /= e]</span></p>
<p class="code10"><span class="font">sortedlaws = sortLaws laws</span></p>
<p class="para">The function <span class="font">rewrites :: Equation -&gt; Expr -&gt; [Expr]</span> returns a list of all the possible ways of rewriting an expression using a given equation, a function that will be defined in a separate module. It may be the case that an expression can be rewritten to itself (see Exercise H), but such rewrites are disallowed because they would lead to infinite calculations. The function <span class="font">rws :: Expr -&gt; [Step]</span> <a id="text/part0016.html.page_313" class="calibre3"></a>returns a list of all the single steps, leading to new expressions, that can arise by using the laws in all possible ways. This list is defined by taking each law in turn and generating all the rewrites associated with the law. That means we give preference to laws over subexpressions in calculations, resolving one of the issues we worried about in the first section. Only experimentation will show if we have made the right decision.</p>
<p class="para">The function <span class="font">manyStep</span> uses <span class="font">rws</span> to construct as many steps as possible:</p>
<p class="code"><span class="font">manyStep :: (Expr -&gt; [Step]) -&gt; Expr -&gt; [Step]</span></p>
<p class="code"><span class="font">manyStep rws e</span></p>
<p class="code2"><span class="font">= if null steps then []</span></p>
<p class="code11"><span class="font">else step : manyStep rws (snd step)</span></p>
<p class="code11"><span class="font">where steps = rws e</span></p>
<p class="code10"><span class="font">step = head steps</span></p>
<p class="para">The calculation ends if <span class="font">rws e</span> is the empty list; otherwise the head of the list is used to continue the calculation.</p>
<p class="para">The remaining functions of the calculations module deal with showing and pasting calculations. We show a calculation as follows:</p>
<p class="code"><span class="font">instance Show Calculation where</span></p>
<p class="code"><span class="space-r"></span><span class="font">showsPrec _ (Calc e steps)</span></p>
<p class="code11"><span class="font">= showString "\n " .</span></p>
<p class="code8"><span class="font">shows e .</span></p>
<p class="code8"><span class="font">showChar '\n' .</span></p>
<p class="code8"><span class="font">compose (map showStep steps)</span></p>
<p class="para">Each individual step is shown as follows:</p>
<p class="code"><span class="font">showStep :: Step -&gt; ShowS</span></p>
<p class="code"><span class="font">showStep (why,e)</span></p>
<p class="code"><span class="space-r"></span><span class="font">= showString "= {" .</span></p>
<p class="code11"><span class="font">showString why .</span></p>
<p class="code11"><span class="font">showString "}\n " .</span></p>
<p class="code11"><span class="font">shows e .</span></p>
<p class="code11"><span class="font">showChar '\n'</span></p>
<p class="para">In order to paste two calculations together we have to reverse the steps of a calculation. For example, the calculation</p>
<p class="code"><span class="font">Calc e0 [(why1,e1),(why2,e2),(why3,e3)]</span></p>
<p class="para">has to be turned into</p>
<p class="code"><a id="text/part0016.html.page_314" class="calibre3"></a><span class="font">Calc e3 [(why3,e2),(why2,e1),(why1,e0)]</span></p>
<p class="para">In particular, the conclusion of a calculation is the first expression in the reversed calculation. Here is how to reverse a calculation:</p>
<p class="code"><span class="font">reverseCalc :: Calculation -&gt; Calculation</span></p>
<p class="code"><span class="font">reverseCalc (Calc e steps)</span></p>
<p class="code2"><span class="font">= foldl shunt (Calc e []) steps</span></p>
<p class="code11"><span class="font">where shunt (Calc e1 steps) (why,e2)</span></p>
<p class="code3"><span class="font">= Calc e2 ((why,e1):steps)</span></p>
<p class="para">In order to paste two calculations together we first have to check that their conclusions are the same. If they are not, then we go ahead and paste the calculations anyway with an indication of failure:</p>
<p class="code2"><span class="font">conc1</span></p>
<p class="code"><span class="font">=</span><span class="space5"></span><span class="font">{... ??? ...}</span></p>
<p class="code2"><span class="font">conc2</span></p>
<p class="para">If the two conclusions are the same, we can be a little smarter than just stitching the calculations together. If the penultimate conclusion of one calculation also matches the penultimate conclusion of the other, then we can cut out the final steps altogether. And so on. Here, then, is how we paste two calculations:</p>
<p class="code"><span class="font">paste :: Calculation -&gt; Calculation -&gt; Calculation</span></p>
<p class="code"><span class="font">paste calc1@(Calc e1 steps1) calc2</span></p>
<p class="code2"><span class="font">= if conc1 == conc2</span></p>
<p class="code11"><span class="font">then Calc e1 (prune conc1 rsteps1 rsteps2)</span></p>
<p class="code11"><span class="font">else Calc e1 (steps1 ++ (gap,conc2):rsteps2)</span></p>
<p class="code11"><span class="font">where Calc conc1 rsteps1 = reverseCalc calc1</span></p>
<p class="code1"><span class="font">Calc conc2 rsteps2 = reverseCalc calc2</span></p>
<p class="code1"><span class="font">gap = "... ??? ..."</span></p>
<p class="para">The function <span class="font">prune</span> is defined by:</p>
<p class="code"><span class="font">prune :: Expr -&gt; [Step] -&gt; [Step] -&gt; [Step]</span></p>
<p class="code"><span class="font">prune e ((_,e1):steps1) ((_,e2):steps2)</span></p>
<p class="code2"><span class="font">| e1==e2 = prune e1 steps1 steps2</span></p>
<p class="code"><span class="font">prune e steps1 steps2 = rsteps ++ steps2</span></p>
<p class="code2"><span class="font">where Calc _ rsteps = reverseCalc (Calc e steps1)</span></p>
<p class="para">Finally, here is the module declaration of <span class="font">Calculations</span>:</p>
<p class="code"><span class="font">module Calculations</span></p>
<p class="code2"><span class="font">(Calculation (Calc), Step, calculate, paste)</span></p>
<p class="code"><a id="text/part0016.html.page_315" class="calibre3"></a><span class="font">where</span></p>
<p class="code"><span class="font">import Expressions</span></p>
<p class="code"><span class="font">import Laws</span></p>
<p class="code"><span class="font">import Rewrites</span></p>
<p class="code"><span class="font">import Utilities (compose)</span></p>
<p class="para">The exports are those types and functions needed to define <span class="font">simplify</span> and <span class="font">prove</span> in the main module.</p>
<h3 class="h" id="text/part0016.html.head12-5">12.5 Rewrites</h3>
<p class="para">The sole purpose of the module <span class="font">Rewrites</span> is to provide a definition of the function <span class="font">rewrites</span> that appears in the definition of <span class="font">calculate</span>. Recall that the expression <span class="font">rewrites eqn e</span> returns a list of all expressions that can arise by matching some subexpression of <span class="font">e</span> against the left-hand expression of <span class="font">eqn</span> and replacing the subexpression with the appropriate instance of the right-hand expression of <span class="font">eqn</span>.</p>
<p class="para">The fun is in figuring out how to define <span class="font">rewrites</span>. Suppose we construct a list of all possible subexpressions of an expression. We can match the given equation against each subexpression, get the substitutions that do the matching (of which there may be none, one or more than one; see the section on matching below) and compute the new subexpressions. But how do we replace an old subexpression with a new one in the original expression? The simple answer is that we can’t, at least not without determining alongside each subexpression its <i class="calibre1">context</i> or <i class="calibre1">location</i> in the original expression. The new subexpression can then be inserted at this location.</p>
<p class="para">Rather than introducing contexts explicitly, we take another approach. The idea is to burrow into an expression, applying a rewrite to some subexpression at some point, and then to build the rewritten expression as we climb back out of the burrow. We will need a utility function <span class="font">anyOne</span> that takes a function yielding a choice of alternatives, and a list, and installs a single choice for one of the elements. The definition is</p>
<p class="code"><span class="font">anyOne :: (a -&gt; [a]) -&gt; [a] -&gt; [[a]]</span></p>
<p class="code"><span class="font">anyOne f []</span><span class="space4"></span><span class="font">= []</span></p>
<p class="code"><span class="font">anyOne f (x:xs) = [x':xs | x' &lt;- f x] ++</span></p>
<p class="code5"><span class="font">[x:xs' | xs' &lt;- anyOne f xs]</span></p>
<p class="para">For example, if <span class="font">f 1 = [-1,-2]</span> and <span class="font">f 2 = [-3,-4]</span>, then</p>
<p class="code"><span class="font">anyOne f [1,2] = [[-1,2],[-2,2],[1,-3],[1,-4]]</span></p>
<p class="para"><a id="text/part0016.html.page_316" class="calibre3"></a>Either one of the choices for the first element is installed, or one of the choices for the second, but not both at the same time.</p>
<p class="para">Here is our definition of <span class="font">rewrites</span>:</p>
<p class="code"><span class="font">rewrites :: Equation -&gt; Expr -&gt; [Expr]</span></p>
<p class="code"><span class="font">rewrites eqn (Compose as) = map Compose (</span></p>
<p class="code2"><span class="font">rewritesSeg eqn as ++ anyOne (rewritesA eqn) as)</span></p>
<p class="code"><span class="font">rewritesA eqn (Var v) = []</span></p>
<p class="code"><span class="font">rewritesA eqn (Con k es)</span></p>
<p class="code2"><span class="font">= map (Con k) (anyOne (rewrites eqn) es)</span></p>
<p class="para">In the first line we concatenate the rewrites for a <i class="calibre1">segment</i> of the current expression with the rewrites for any one of its proper subexpressions. Only constants with arguments have subexpressions. Note that the two uses of <span class="font">anyOne</span> have different types, one taking a list of atoms, and one taking a list of expressions.</p>
<p class="para">It remains to define <span class="font">rewritesSeg</span>:</p>
<p class="code"><span class="font">rewritesSeg :: Equation -&gt; [Atom] -&gt; [[Atom]]</span></p>
<p class="code"><span class="font">rewritesSeg (e1,e2) as</span></p>
<p class="code2"><span class="font">= [as1 ++ deCompose (apply sub e2) ++ as3</span></p>
<p class="code11"><span class="font">| (as1,as2,as3) &lt;- segments as,</span></p>
<p class="code8"><span class="font">sub &lt;- match (e1,Compose as2)]</span></p>
<p class="para">The function <span class="font">segments</span> splits a list into segments:</p>
<p class="code"><span class="font">segments as = [(as1,as2,as3)</span></p>
<p class="code12"><span class="space"></span><span class="font">| (as1,bs) &lt;- splits as,</span></p>
<p class="code4"><span class="space-r1"></span><span class="font">(as2,as3) &lt;- splits bs]</span></p>
<p class="para">The utility function <span class="font">splits</span> splits a list in all possible ways:</p>
<p class="code"><span class="font">splits :: [a] -&gt; [([a],[a])]</span></p>
<p class="code"><span class="font">splits []</span><span class="space4"></span><span class="font">= [([],[])]</span></p>
<p class="code"><span class="font">splits (a:as) = [([],a:as)] ++</span></p>
<p class="code4"><span class="space-r"></span><span class="font">[(a:as1,as2) | (as1,as2) &lt;- splits as]</span></p>
<p class="para">For example,</p>
<p class="code6"><span class="font">ghci&gt; splits "abc"</span></p>
<p class="code6"><span class="font">[("","abc"),("a","bc"),("ab","c"),("abc","")]</span></p>
<p class="para">The remaining functions <span class="font">apply</span> and <span class="font">match</span> have types</p>
<p class="code"><span class="font">apply :: Subst -&gt; Expr -&gt; Expr</span></p>
<p class="code"><a id="text/part0016.html.page_317" class="calibre3"></a><span class="font">match :: (Expr,Expr) -&gt; [Subst]</span></p>
<p class="para">Each will be defined in their own modules, <span class="font">Substitutions</span> and <span class="font">Matchings</span>. Finally, here is the module declaration for <span class="font">Rewrites</span>:</p>
<p class="code"><span class="font">module Rewrites (rewrites)</span></p>
<p class="code"><span class="font">where</span></p>
<p class="code"><span class="font">import Expressions</span></p>
<p class="code"><span class="font">import Laws (Equation)</span></p>
<p class="code"><span class="font">import Matchings (match)</span></p>
<p class="code"><span class="font">import Substitutions (apply)</span></p>
<p class="code"><span class="font">import Utilities (anyOne, segments)</span></p>
<h3 class="h" id="text/part0016.html.head12-6">12.6 Matchings</h3>
<p class="para">The sole purpose of the module <span class="font">Matchings</span> is to define the function <span class="font">match</span>. This function takes two expressions and returns a list of substitutions under which the first expression can be transformed into the second. Matching two expressions produces no substitutions if they don’t match, but possibly many if they do. Consider matching the expression <span class="font">foo (f . g)</span> against <span class="font">foo (a . b . c)</span>. There are four substitutions that do the trick: <span class="font">f</span> may be bound to any of the expressions</p>
<p class="code"><span class="font">id, a, a . b, a . b . c</span></p>
<p class="para">with four corresponding bindings for <span class="font">g</span>. Although the calculator will select a single substitution at each step, it is important to take account of multiple substitutions in the process of obtaining the valid matchings. For example, in matching <span class="font">foo (f . g) . bar g</span> against <span class="font">foo (a . b . c) . bar c</span>, the subexpression <span class="font">f . g</span> is matched against <span class="font">a . b . c</span>, resulting in four possible substitutions. Only when <span class="font">bar g</span> is matched against <span class="font">bar c</span> are three of the substitutions rejected. A premature commitment to a single substitution for the first match may result in a successful match being missed.</p>
<p class="para">The most straightforward way of defining <span class="font">match (e1,e2)</span> is to first line up the atoms of <span class="font">e1</span> with a partition of the atoms of <span class="font">e2</span>; the first atom is associated with the first segment of the partition, the second with the second segment, and so on. The function <span class="font">alignments</span> has type</p>
<p class="code"><span class="font">alignments :: (Expr,Expr) -&gt; [[(Atom,Expr)]]</span></p>
<p class="para">and does the alignments. To define it we need a function <span class="font">parts</span> that partitions a list into a given number of segments:</p>
<p class="code"><a id="text/part0016.html.page_318" class="calibre3"></a><span class="font">parts :: Int -&gt; [a] -&gt; [[[a]]]</span></p>
<p class="code"><span class="font">parts 0 [] = [[]]</span></p>
<p class="code"><span class="font">parts 0 as = []</span></p>
<p class="code"><span class="font">parts n as = [bs:bss</span></p>
<p class="code12"><span class="space-r"></span><span class="font">| (bs,cs) &lt;- splits as,</span></p>
<p class="code4"><span class="space-r1"></span><span class="font">bss &lt;- parts (n-1) cs]</span></p>
<p class="para">The interesting clauses are the first two: there is one partition of the empty list into 0 segments, namely the empty partition, but there are no partitions of a nonempty list into 0 segments. For example,</p>
<p class="code6"><span class="font">ghci&gt; parts 3 "ab"</span></p>
<p class="code6"><span class="font">[["","","ab"],["","a","b"],["","ab",""],</span></p>
<p class="code6"><span class="space-r"></span><span class="font">["a","","b"],["a","b",""],["ab","",""]]</span></p>
<p class="para">Now we can define</p>
<p class="code"><span class="font">alignments (Compose as,Compose bs)</span></p>
<p class="code"><span class="space-r"></span><span class="font">= [zip as (map Compose bss) | bss &lt;- parts n bs]</span></p>
<p class="code"><span class="space5"></span><span class="font">where n = length as</span></p>
<p class="para">Having aligned each atom with a subexpression, we define <span class="font">matchA</span> that matches atoms with expressions:</p>
<p class="code"><span class="font">matchA :: (Atom,Expr) -&gt; [Subst]</span></p>
<p class="code"><span class="font">matchA (Var v,e) = [unitSub v e]</span></p>
<p class="code"><span class="font">matchA (Con k1 es1,Compose [Con k2 es2])</span></p>
<p class="code2"><span class="font">| k1==k2 = combine (map match (zip es1 es2))</span></p>
<p class="code"><span class="font">matchA _ = []</span></p>
<p class="para">Matching a variable always succeeds and results in a single substitution. Matching two constants succeeds only if the two constants are the same. In all other cases <span class="font">matchA</span> returns an empty list of substitutions. The function <span class="font">matchA</span> depends on <span class="font">match</span>, which we can now define by</p>
<p class="code"><span class="font">match :: (Expr,Expr) -&gt; [Subst]</span></p>
<p class="code"><span class="font">match = concatMap (combine . map matchA) . alignments</span></p>
<p class="para">The final ingredient is the function <span class="font">combine :: [[Subst]] -&gt; [Subst]</span>. Each component list of substitutions in the argument of <span class="font">combine</span> represents alternatives, so <span class="font">combine</span> has to combine alternatives by selecting, in all possible ways, one substitution from each list and then unifying the result. We will return to this function in the module for substitutions. This completes the definition of <span class="font">matches</span>. The module declaration is</p>
<p class="code"><a id="text/part0016.html.page_319" class="calibre3"></a><span class="font">module Matchings (match)</span></p>
<p class="code"><span class="font">where</span></p>
<p class="code"><span class="font">import Expressions</span></p>
<p class="code"><span class="font">import Substitutions (Subst, unitSub, combine)</span></p>
<p class="code"><span class="font">import Utilities (parts)</span></p>
<p class="para">We place <span class="font">parts</span> in the utilities module because it is not specific to expressions.</p>
<h3 class="h" id="text/part0016.html.head12-7">12.7 Substitutions</h3>
<p class="para">A substitution is a finite mapping associating variables with expressions. A simple representation as an association list suffices:</p>
<p class="code"><span class="font">type Subst = [(VarName,Expr)]</span></p>
<p class="para">The empty and unit substitutions are then defined by</p>
<p class="code"><span class="font">emptySub = []</span></p>
<p class="code"><span class="font">unitSub v e = [(v,e)]</span></p>
<p class="para">We can apply a substitution to an expression to get another expression by defining</p>
<p class="code"><span class="font">apply :: Subst -&gt; Expr -&gt; Expr</span></p>
<p class="code"><span class="font">apply sub (Compose as)</span></p>
<p class="code8"><span class="font">= Compose (concatMap (applyA sub) as)</span></p>
<p class="code"><span class="font">applyA sub (Var v) = deCompose (binding sub v)</span></p>
<p class="code"><span class="font">applyA sub (Con k es) = [Con k (map (apply sub) es)]</span></p>
<p class="para">The function <span class="font">binding</span> looks up a nonempty substitution for the binding for a variable:</p>
<p class="code"><span class="font">binding :: Subst -&gt; VarName -&gt; Expr</span></p>
<p class="code"><span class="font">binding sub v = fromJust (lookup v sub)</span></p>
<p class="para">The function <span class="font">lookup</span> is supplied in the Haskell Prelude and returns <span class="font">Nothing</span> if no binding is found, and <span class="font">Just e</span> if <span class="font">v</span> is bound to <span class="font">e</span>. The function <span class="font">fromJust</span> is in the library <span class="font">Data.Maybe</span> and removes the wrapper <span class="font">Just</span>.</p>
<p class="para">Next we tackle <span class="font">combine</span>. This function has to combine alternative substitutions by selecting, in all possible ways, one substitution from each component list and then unifying each resulting list of substitutions:</p>
<p class="code"><span class="font">combine = concatMap unifyAll . cp</span></p>
<p class="para"><a id="text/part0016.html.page_320" class="calibre3"></a>The utility function <span class="font">cp</span>, which we have seen many times before, computes the cartesian product of a list of lists.</p>
<p class="para">The function <span class="font">unifyAll</span> takes a list of substitutions and unifies them. To define it we first show how to unify two substitutions. The result of unification is either the union of the two substitutions if they are compatible, or no substitution if they are incompatible. To handle the possibility of failure, we can use the <span class="font">Maybe</span> type, or simply return either an empty list or a singleton list. We choose the latter simply because in the following section we are going to calculate another version of the calculator, and it is simplest to stick with list-based functions:</p>
<p class="code"><span class="font">unify :: Subst -&gt; Subst -&gt; [Subst]</span></p>
<p class="code"><span class="font">unify sub1 sub2 = if compatible sub1 sub2</span></p>
<p class="code5"><span class="font">then [union sub1 sub2]</span></p>
<p class="code5"><span class="font">else []</span></p>
<p class="para">In order to define <span class="font">compatible</span> and <span class="font">union</span> we will suppose that substitutions are maintained as lists in lexicographic order of variable name. Two substitutions are incompatible if they associate different expressions with one and the same variable:</p>
<p class="code"><span class="font">compatible [] sub2 = True</span></p>
<p class="code"><span class="font">compatible sub1 [] = True</span></p>
<p class="code"><span class="font">compatible sub1@((v1,e1):sub1') sub2@((v2,e2):sub2')</span></p>
<p class="code11"><span class="font">| v1&lt;v2 = compatible sub1' sub2</span></p>
<p class="code11"><span class="font">| v1==v2 = if e1==e2 then compatible sub1' sub2'</span></p>
<p class="code9"><span class="font">else False</span></p>
<p class="code11"><span class="font">| v1&gt;v2 = compatible sub1 sub2'</span></p>
<p class="para">The union operation is defined in a similar style:</p>
<p class="code"><span class="font">union [] sub2 = sub2</span></p>
<p class="code"><span class="font">union sub1 [] = sub1</span></p>
<p class="code"><span class="font">union sub1@((v1,e1):sub1') sub2@((v2,e2):sub2')</span></p>
<p class="code2"><span class="font">| v1&lt;v2</span><span class="space"></span><span class="space-r1"></span><span class="font">= (v1,e1):union sub1' sub2</span></p>
<p class="code2"><span class="font">| v1==v2 = (v1,e1):union sub1' sub2'</span></p>
<p class="code2"><span class="font">| v1&gt;v2</span><span class="space"></span><span class="space-r1"></span><span class="font">= (v2,e2):union sub1 sub2'</span></p>
<p class="para">The function <span class="font">unifyAll</span> returns either an empty list or a singleton list:</p>
<p class="code"><span class="font">unifyAll :: [Subst] -&gt; [Subst]</span></p>
<p class="code"><span class="font">unifyAll = foldr f [emptySub]</span></p>
<p class="code11"><span class="font">where f sub subs = concatMap (unify sub) subs</span></p>
<p class="para">That completes the definitions we need. Here is the module declaration:</p>
<p class="code"><a id="text/part0016.html.page_321" class="calibre3"></a><span class="font">module Substitutions</span></p>
<p class="code2"><span class="font">(Subst, unitSub, combine, apply)</span></p>
<p class="code"><span class="font">where</span></p>
<p class="code"><span class="font">import Expressions</span></p>
<p class="code"><span class="font">import Utilities (cp)</span></p>
<p class="code"><span class="font">import Data.Maybe (fromJust)</span></p>
<p class="para">That makes nine modules in total for our calculator.</p>
<h3 class="h" id="text/part0016.html.head12-8">12.8 Testing the calculator</h3>
<p class="para">How useful is the calculator in practice? The only way to answer this question is to try it out on some examples. We are going to record just two. The first is the calculation we performed in <a href="#text/part0009.html.8IL20-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 5</a> about pruning the matrix of choices in Sudoku. In effect we want to prove</p>
<p class="code"><span class="font">filter (all nodups . boxs) . expand . pruneBy boxs</span></p>
<p class="code3"><span class="font">= filter (all nodups . boxs) . expand</span></p>
<p class="para">from the laws</p>
<p class="code"><span class="font">defn pruneBy: pruneBy f = f . map pruneRow . f</span></p>
<p class="code"><span class="font">expand after boxs: expand . boxs = map boxs . expand</span></p>
<p class="code"><span class="font">filter with boxs: filter (p . boxs)</span></p>
<p class="code5"><span class="font">= map boxs . filter p . map boxs</span></p>
<p class="code"><span class="font">boxs involution: boxs . boxs = id</span></p>
<p class="code"><span class="font">map functor: map f . map g = map (f.g)</span></p>
<p class="code"><span class="font">map functor: map id = id</span></p>
<p class="code"><span class="font">defn expand: expand = cp . map cp</span></p>
<p class="code"><span class="font">filter after cp: filter (all p) . cp = cp . map (filter p)</span></p>
<p class="code"><span class="font">law of pruneRow: filter nodups . cp . pruneRow</span></p>
<p class="code5"><span class="font">= filter nodups . cp</span></p>
<p class="para">Here is the calculation exactly as performed by the calculator, except that we have broken some expressions across two lines, a task that should be left to a prettyprinter. Don’t bother to study it in detail, just note the important bit towards the end:</p>
<p class="code"><span class="font">filter (all nodups . boxs) . expand . pruneBy boxs</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{filter with boxs}</span></p>
<p class="code"><span class="font">map boxs . filter (all nodups) . map boxs . expand .</span></p>
<p class="code"><span class="font">pruneBy boxs</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn pruneBy}</span></p>
<p class="code"><span class="font">map boxs . filter (all nodups) . map boxs . expand .</span></p>
<p class="code"><span class="font">boxs . map pruneRow . boxs</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{expand after boxs}</span></p>
<p class="code"><a id="text/part0016.html.page_322" class="calibre3"></a><span class="font">map boxs . filter (all nodups) . map boxs . map boxs .</span></p>
<p class="code"><span class="font">expand . map pruneRow . boxs</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{map functor}</span></p>
<p class="code"><span class="font">map boxs . filter (all nodups) . map (boxs . boxs) . expand .</span></p>
<p class="code"><span class="font">map pruneRow . boxs</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{boxs involution}</span></p>
<p class="code"><span class="font">map boxs . filter (all nodups) . map id . expand .</span></p>
<p class="code"><span class="font">map pruneRow . boxs</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{map functor}</span></p>
<p class="code"><span class="font">map boxs . filter (all nodups) . expand . map pruneRow . boxs</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn expand}</span></p>
<p class="code"><span class="font">map boxs . filter (all nodups) . cp . map cp . map pruneRow . boxs</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{map functor}</span></p>
<p class="code"><span class="font">map boxs . filter (all nodups) . cp . map (cp . pruneRow) . boxs</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{filter after cp}</span></p>
<p class="code"><span class="font">map boxs . cp . map (filter nodups) . map (cp . pruneRow) . boxs</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{map functor}</span></p>
<p class="code"><span class="font">map boxs . cp . map (filter nodups . cp . pruneRow) . boxs</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{law of pruneRow}</span></p>
<p class="code"><span class="font">map boxs . cp . map (filter nodups . cp) . boxs</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{... ??? ...}</span></p>
<p class="code"><span class="font">map boxs . filter (all nodups) . map boxs . cp . map cp</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn expand}</span></p>
<p class="code"><span class="font">map boxs . filter (all nodups) . map boxs . expand</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{filter with boxs}</span></p>
<p class="code"><span class="font">filter (all nodups . boxs) . expand</span></p>
<p class="para">Yes, the calculation fails. The reason is not hard to spot: we need to apply the law</p>
<p class="code"><span class="font">expand after boxs: expand . boxs = map boxs . expand</span></p>
<p class="para">in both directions, and the calculator simply cannot do that.</p>
<p class="para">The solution is a hack. We add in the extra law</p>
<p class="code"><span class="font">hack: map boxs . cp . map cp = cp . map cp . boxs</span></p>
<p class="para">which is just the <span class="font">expand</span> after <span class="font">boxs</span> law written in the opposite direction and with <span class="font">expand</span> replaced by its definition. Then the calculator is happy, producing the conclusion</p>
<p class="code6"><span class="font">....</span></p>
<p class="code"><span class="font">map boxs . cp . map (filter nodups . cp) . boxs</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{map functor}</span></p>
<p class="code"><span class="font">map boxs . cp . map (filter nodups) . map cp . boxs</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{filter after cp}</span></p>
<p class="code"><span class="font">map boxs . filter (all nodups) . cp . map cp . boxs</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{hack}</span></p>
<p class="code"><span class="font">map boxs . filter (all nodups) . map boxs . cp . map cp</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn expand}</span></p>
<p class="code"><span class="font">map boxs . filter (all nodups) . map boxs . expand</span></p>
<p class="code6"><a id="text/part0016.html.page_323" class="calibre3"></a><span class="font">=</span><span class="space5"></span><span class="font">{filter with boxs}</span></p>
<p class="code"><span class="font">filter (all nodups . boxs) . expand</span></p>
<p class="para">In both cases the calculations were performed in a fraction of a second, so efficiency does not seem to be an issue. And, apart from the hack, the calculations pass muster, being almost exactly what a good human calculator would produce.</p>
<p class="center"><i class="calibre1">Improving the calculator</i></p>
<p class="para">Our second example is more ambitious: we are going to use the calculator to derive another version of the calculator. Look again at the definition of <span class="font">match</span>. This relies on <span class="font">combine</span>, which in turn involves a messy appeal to the unification of two substitutions, with all the paraphernalia of having to test them for compatibility and computing the union. A better idea is to compute the union of two substitutions only when one of them is a unit substitution. Then everything becomes simpler and probably faster. And the technique which describes this optimisation? Yes, it’s another example of accumulating parameters. Just as an accumulating parameter can avoid expensive uses of <span class="font">++</span> operations, our hope is to avoid expensive <span class="font">unify</span> operations.</p>
<p class="para">First of all, here is the definition of <span class="font">match</span> again, written with a couple of new subsidiary functions:</p>
<p class="code"><span class="font">match = concatMap matchesA . alignments</span></p>
<p class="code"><span class="font">matchesA = combine . map matchA</span></p>
<p class="code"><span class="font">matchA (Var v,e) = [unitSub v e]</span></p>
<p class="code"><span class="font">matchA (Con k1 es1,Compose [Con k2 es2])</span></p>
<p class="code11"><span class="font">| k1==k2 = matches (zip es1 es2)</span></p>
<p class="code"><span class="font">matchA _ = []</span></p>
<p class="code"><span class="font">matches = combine . map match</span></p>
<p class="para">Note the cycle of dependencies of these functions:</p>
<p class="code"><span class="font">match --&gt; matchesA --&gt; matchA --&gt; matches --&gt; match</span></p>
<p class="para">These four functions are generalised as follows:</p>
<p class="code"><span class="font">xmatch sub</span><span class="space4"></span><span class="font">= concatMap (unify sub) . match</span></p>
<p class="code"><span class="font">xmatchA sub</span><span class="space5"></span><span class="font">= concatMap (unify sub) . matchA</span></p>
<p class="code"><span class="font">xmatches sub</span><span class="space"></span><span class="space-r"></span><span class="font">= concatMap (unify sub) . matches</span></p>
<p class="code"><span class="font">xmatchesA sub = concatMap (unify sub) . matchesA</span></p>
<p class="para">The additional argument in each case is an accumulating parameter. Our aim will <a id="text/part0016.html.page_324" class="calibre3"></a>be to obtain new versions of these definitions, whose cycle of dependencies is the same as the one above:</p>
<p class="para">For the first calculation, we want to rewrite <span class="font">match</span> in terms of <span class="font">xmatch</span>, thereby linking the two groups of definitions. To save a lot of ink, we henceforth abbreviate <span class="font">concatMap</span> to <span class="font">cmap</span>. The three laws we need are</p>
<p class="code"><span class="font">defn xmatch:</span><span class="space3"></span><span class="font">xmatch s = cmap (unify s) . match</span></p>
<p class="code"><span class="font">unify of empty:</span><span class="space2"></span><span class="font">unify emptySub = one</span></p>
<p class="code"><span class="font">cmap of one:</span><span class="space3"></span><span class="font">cmap one = id</span></p>
<p class="para">In the first law we have to write <span class="font">s</span> rather than <span class="font">sub</span> (why?); the second two laws are the pointless versions of the facts that</p>
<p class="code"><span class="font">unify emptySub sub = [sub]</span></p>
<p class="code"><span class="font">cmap one xs = concat [[x] | x &lt;- xs] = xs</span></p>
<p class="para">The calculator is hardly stretched to give:</p>
<p class="code"><span class="font">xmatch emptySub</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn xmatch}</span></p>
<p class="code"><span class="font">cmap (unify emptySub) . match</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{unify of empty}</span></p>
<p class="code"><span class="font">cmap one . match</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{cmap of one}</span></p>
<p class="code"><span class="font">match</span></p>
<p class="para">Let us next deal with <span class="font">xmatchA</span>. Because of the awkward pattern-matching style of definition of <span class="font">matchA</span>, we simply record the following result of an easy (human) calculation:</p>
<p class="code"><span class="font">xmatchA sub (Var v,e) = concat [unify sub (unitSub v e)]</span></p>
<p class="code"><span class="font">xmatchA sub (Con k1 es1,Compose [Con k2 es2])</span></p>
<p class="code11"><span class="font">| k1==k2 = xmatches sub (zip es1 es2)</span></p>
<p class="code"><span class="font">xmatchA _ = []</span></p>
<p class="para">If we introduce</p>
<p class="code6"><span class="font">extend sub v e = concat [unify sub (unitSub v e)]</span></p>
<p class="para">then it is easy to derive</p>
<p class="code"><span class="font">extend sub v e</span></p>
<p class="code"><span class="space-r"></span><span class="font">= case lookup v sub of</span></p>
<p class="code8"><span class="font">Nothing -&gt; [(v,e):sub]</span></p>
<p class="code8"><span class="font">Just e' -&gt; if e==e' then [sub]</span></p>
<p class="code14"><span class="font">else []</span></p>
<p class="para"><a id="text/part0016.html.page_325" class="calibre3"></a>No elaborate compatibility test, and no general union of two substitutions. Instead, as we promised earlier, we unify substitutions only with unit substitutions.</p>
<p class="para">Having disposed of <span class="font">xmatchA</span> we concentrate on the other three members of the quartet. Just as <span class="font">xmatchA</span> is defined in terms of <span class="font">xmatches</span>, so <span class="font">xmatch</span> can be defined in terms of <span class="font">xmatchesA</span>. Specifically, we want to prove that</p>
<p class="code"><span class="font">xmatch s = cmap (xmatchesA s) . alignments</span></p>
<p class="para">Here are the laws we need:</p>
<p class="code"><span class="font">defn match:</span><span class="space3"></span><span class="font">match = cmap matchesA . alignments</span></p>
<p class="code"><span class="font">defn xmatch:</span><span class="space8"></span><span class="font">xmatch s = cmap (unify s) . match</span></p>
<p class="code"><span class="font">defn xmatchesA:</span><span class="space4"></span><span class="font">xmatchesA s = cmap (unify s) . matchesA</span></p>
<p class="code"><span class="font">cmap after cmap:</span><span class="space5"></span><span class="space-r"></span><span class="font">cmap f . cmap g = cmap (cmap f . g)</span></p>
<p class="para">The last, purely combinatorial law is new; we leave verification as an exercise. The calculator produces:</p>
<p class="code"><span class="font">xmatch s</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn xmatch}</span></p>
<p class="code"><span class="font">cmap (unify s) . match</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn match}</span></p>
<p class="code"><span class="font">cmap (unify s) . cmap matchesA . alignments</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{cmap after cmap}</span></p>
<p class="code"><span class="font">cmap (cmap (unify s) . matchesA) . alignments</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn xmatchesA}</span></p>
<p class="code"><span class="font">cmap (xmatchesA s) . alignments</span></p>
<p class="para">So far, so good. That leaves us with the two remaining members of the quartet, <span class="font">xmatches</span> and <span class="font">xmatchesA</span>. In each case we want to obtain recursive definitions, ones that do not involve <span class="font">unify</span>. The two functions are defined in a very similar way, and it is likely that any calculation about one can be adapted immediately to the other. This kind of meta-calculational thought is, of course, beyond the reaches of the calculator.</p>
<p class="para">Let us concentrate on <span class="font">xmatchesA</span>. We first make <span class="font">xmatchesA</span> entirely pointless, removing the parameter <span class="font">s</span> in the definition above. The revised definition is:</p>
<p class="code"><span class="font">xmatchesA :: (Subst,[(Atom,Expr)]) -&gt; Subst</span></p>
<p class="code"><span class="font">xmatchesA = cup . (one * matchesA)</span></p>
<p class="code"><span class="font">cup = cmap unify . cpp</span></p>
<p class="para">where the combinator <span class="font">cpp</span> is defined by</p>
<p class="code"><span class="font">cpp (xs,ys) = [(x,y) | x &lt;- xs, y &lt;- ys]</span></p>
<p class="para">Thus</p>
<p class="code6"><span class="space"></span><a id="text/part0016.html.page_326" class="calibre3"></a><span class="font">xmatchesA (sub,aes)</span></p>
<p class="code6"><span class="font">= cup ([sub],aes)</span></p>
<p class="code6"><span class="font">= concat [unify (s,ae) | s &lt;- [sub],ae &lt;- matchesA aes]</span></p>
<p class="code6"><span class="font">= concat [unify (sub,ae) | ae &lt;- matchesA aes]</span></p>
<p class="para">Apart from the fact that <span class="font">unify</span> is now assumed to be a non-curried function, this is a faithful rendition of the definition of <span class="font">xmatchesA</span> in pointless form.</p>
<p class="para">The new function <span class="font">cup</span> has type <span class="font">[Subst] -&gt; [Subst] -&gt; [Subst]</span>. Later on we will exploit the fact that <span class="font">cup</span> is an associative function, something that <span class="font">unify</span> could never be (why not?). As we saw in <a href="#text/part0011.html.AFM60-0daaaafc8385457e8f80971b0d39bbf7" class="calibre3">Chapter 7</a> the accumulating parameter technique depends on the operation of interest being associative.</p>
<p class="para">The first thing to check is that the previous calculation is still valid with the new definitions. Suppose we set up the laws</p>
<p class="code"><span class="font">defn match:</span><span class="space3"></span><span class="space-r"></span><span class="font">match = cmap matchesA . alignments</span></p>
<p class="code"><span class="font">defn xmatch:</span><span class="space3"></span><span class="font">xmatch = cup . (one * match)</span></p>
<p class="code"><span class="font">defn xmatchesA:</span><span class="space2"></span><span class="font">xmatchesA = cup . (one * matchesA)</span></p>
<p class="para">The calculator then produces</p>
<p class="code"><span class="font">xmatch</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn xmatch}</span></p>
<p class="code"><span class="font">cup . (one * match)</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn match}</span></p>
<p class="code"><span class="font">cup . (one * (cmap matchesA . alignments))</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{... ??? ...}</span></p>
<p class="code"><span class="font">cmap (cup . (one * matchesA)) . cpp . (one * alignments)</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn xmatchesA}</span></p>
<p class="code"><span class="font">cmap xmatchesA . cpp . (one * alignments)</span></p>
<p class="para">Ah, it doesn’t go through. Inspecting the gap in the calculation, it seems we need both the bifunctor law of <span class="font">*</span> and a claim relating <span class="font">cmap</span> and <span class="font">cup</span>:</p>
<p class="code"><span class="font">cross bifunctor: (f * g) . (h * k) = (f . h) * (g . k)</span></p>
<p class="code"><span class="font">cmap-cup: cmap (cup . (one * g)) . cpp = cup . (id * cmap g)</span></p>
<p class="para">The calculator is then happy:</p>
<p class="code"><span class="font">xmatch</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn xmatch}</span></p>
<p class="code"><span class="font">cup . (one * match)</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn match}</span></p>
<p class="code"><span class="font">cup . (one * (cmap matchesA . alignments))</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{cross bifunctor}</span></p>
<p class="code"><span class="font">cup . (id * cmap matchesA) . (one * alignments)</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{cmap-cup}</span></p>
<p class="code"><span class="font">cmap (cup . (one * matchesA)) . cpp . (one * alignments)</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn xmatchesA}</span></p>
<p class="code"><a id="text/part0016.html.page_327" class="calibre3"></a><span class="font">cmap xmatchesA . cpp . (one * alignments)</span></p>
<p class="para">That still leaves us with the claim; apart from the fact that it works we have no reason to suppose it is true. However, we can get the calculator to prove it by using another law that is not specific to matching. We leave the proof as Exercise M. Define the additional laws</p>
<p class="code"><span class="font">defn cup: cup = cmap unify . cpp</span></p>
<p class="code"><span class="font">cmap-cpp: cmap (cpp . (one * f)) . cpp = cpp . (id * cmap f)</span></p>
<p class="para">The calculator then produces</p>
<p class="code"><span class="font">cmap (cup . (one * g)) . cpp</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn cup}</span></p>
<p class="code"><span class="font">cmap (cmap unify . cpp . (one * g)) . cpp</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{cmap after cmap}</span></p>
<p class="code"><span class="font">cmap unify . cmap (cpp . (one * g)) . cpp</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{cmap-cpp}</span></p>
<p class="code"><span class="font">cmap unify . cpp . (id * cmap g)</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn cup}</span></p>
<p class="code"><span class="font">cup . (id * cmap g)</span></p>
<p class="para">Good. It seems that the <span class="font">cmap-cup</span> law is valid, and it even might be useful again later on. Now let us return to the main point, which is to express <span class="font">xmatchesA</span> recursively by two equations of the form</p>
<p class="code"><span class="font">xmatchesA . (id * nil) = ...</span></p>
<p class="code"><span class="font">xmatchesA . (id * cons) = ...</span></p>
<p class="para">The hope is that such a definition will not involve <span class="font">unify</span>. It is not at all clear what laws we need for this purpose. Instead, we will write down every law we can think of that might prove useful. The first group consists of our main definitions:</p>
<p class="code"><span class="font">defn match:</span><span class="space2"></span><span class="font">match = cmap matchesA . alignments</span></p>
<p class="code"><span class="font">defn matchesA:</span><span class="space5"></span><span class="font">matchesA = combine . map matchA</span></p>
<p class="code"><span class="font">defn xmatch:</span><span class="space4"></span><span class="font">xmatch = cup . (one * match)</span></p>
<p class="code"><span class="font">defn xmatchesA:</span><span class="space"></span><span class="space-r"></span><span class="font">xmatchesA = cup . (one * matchesA)</span></p>
<p class="code"><span class="font">defn xmatchA:</span><span class="space5"></span><span class="space-r"></span><span class="font">xmatchA = cup . (one * matchA)</span></p>
<p class="code"><span class="font">defn combine:</span><span class="space5"></span><span class="space-r"></span><span class="font">combine = cmap unifyAll . cp</span></p>
<p class="para">The second group are some new laws about <span class="font">cmap</span>:</p>
<p class="code"><span class="font">cmap after map:</span><span class="space4"></span><span class="font">cmap f . map g = cmap (f . g)</span></p>
<p class="code"><span class="font">cmap after concat:</span><span class="space"></span><span class="font">cmap f . concat = cmap (cmap f)</span></p>
<p class="code"><span class="font">cmap after nil:</span><span class="space4"></span><span class="font">cmap f . nil = nil</span></p>
<p class="code"><span class="font">cmap after one:</span><span class="space4"></span><span class="font">cmap f . one = f</span></p>
<p class="para">The third group are some new laws about <span class="font">map</span>:</p>
<p class="code"><a id="text/part0016.html.page_328" class="calibre3"></a><span class="font">map after nil: map f . nil = nil</span></p>
<p class="code"><span class="font">map after one: map f . one = one . f</span></p>
<p class="code"><span class="font">map after cons: map f . cons = cons . (f * map f)</span></p>
<p class="code"><span class="font">map after concat: map f . concat = concat . map (map f)</span></p>
<p class="para">The fourth group concerns <span class="font">cup</span>:</p>
<p class="code"><span class="font">cup assoc: cup . (id * cup) = cup . (cup * id) . assocl</span></p>
<p class="code"><span class="font">cup ident: cup . (f * (one . nil)) = f . fst</span></p>
<p class="code"><span class="font">cup ident: cup . ((one . nil) * g) = g . snd</span></p>
<p class="code"><span class="font">assocl: assocl. (f * (g * h)) = ((f * g) * h) . assocl</span></p>
<p class="para">Finally we add in various other definitions and laws:</p>
<p class="code"><span class="font">cross bifunctor: (f * g) . (h * k) = (f . h) * (g . k)</span></p>
<p class="code"><span class="font">cross bifunctor: (id * id) = id</span></p>
<p class="code"><span class="font">defn cp: cp . nil = one . nil</span></p>
<p class="code"><span class="font">defn cp: cp . cons = map cons . cpp . (id * cp)</span></p>
<p class="code"><span class="font">defn unifyAll: unifyAll . nil = one . nil</span></p>
<p class="code"><span class="font">defn unifyAll: unifyAll . cons = cup . (one * unifyAll)</span></p>
<p class="code"><span class="font">unify after nil: unify . (id * nil) = one . fst</span></p>
<p class="para">That’s a total of 30 laws (including the two <span class="font">map</span> functor laws and three laws about <span class="font">cmap</span> that we haven’t repeated). We cross our fingers and hope:</p>
<p class="code"><span class="font">xmatchesA . (id * nil)</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn xmatchesA}</span></p>
<p class="code"><span class="font">cup . (one * matchesA) . (id * nil)</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{cross bifunctor}</span></p>
<p class="code"><span class="font">cup . (one * (matchesA . nil))</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn matchesA}</span></p>
<p class="code"><span class="font">cup . (one * (combine . map matchA . nil))</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{map after nil}</span></p>
<p class="code"><span class="font">cup . (one * (combine . nil))</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn combine}</span></p>
<p class="code"><span class="font">cup . (one * (cmap unifyAll . cp . nil))</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn cp}</span></p>
<p class="code"><span class="font">cup . (one * (cmap unifyAll . one . nil))</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{cmap after one}</span></p>
<p class="code"><span class="font">cup . (one * (unifyAll . nil))</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn unifyAll}</span></p>
<p class="code"><span class="font">cup . (one * (one . nil))</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{cup ident}</span></p>
<p class="code"><span class="font">one . fst</span></p>
<p class="para">That’s gratifying. We have shown that <span class="font">xmatchesA sub [] = [sub]</span>. However, the recursive case cannot be established so easily. Instead we have to guess the result and then try to prove it. Here is the desired result, first expressed in pointed form and then in pointless form:</p>
<p class="code"><span class="font">xmatchesA sub (ae:aes)</span></p>
<p class="code"><span class="space"></span><a id="text/part0016.html.page_329" class="calibre3"></a><span class="font">= concat [xmatchesA sub' aes | sub' &lt;- xmatchA sub ae]</span></p>
<p class="code"><span class="font">xmatchesA . (id * cons)</span></p>
<p class="code"><span class="space"></span><span class="font">= cmap xmatchesA . cpp . (xmatchA * one) . assocl</span></p>
<p class="para">We can perform simplification with the right-hand side (we temporarily remove the definitions of <span class="font">xmatchA</span> and <span class="font">matchesA</span> from <span class="font">laws2</span>):</p>
<p class="code"><span class="font">cmap xmatchesA . cpp . (xmatchA * one) . assocl</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn xmatchesA}</span></p>
<p class="code"><span class="font">cmap (cup . (one * matchesA)) . cpp . (xmatchA * one) . assocl</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{cmap-cup}</span></p>
<p class="code"><span class="font">cup . (id * cmap matchesA) . (xmatchA * one) . assocl</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{cross bifunctor}</span></p>
<p class="code"><span class="font">cup . (xmatchA * (cmap matchesA . one)) . assocl</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{cmap after one}</span></p>
<p class="code"><span class="font">cup . (xmatchA * matchesA) . assocl</span></p>
<p class="para">Now we would like to show</p>
<p class="code"><span class="font">xmatchesA . (id * cons)</span></p>
<p class="code11"><span class="font">= cup . (xmatchA * matchesA) . assocl</span></p>
<p class="para">But unfortunately the calculator can’t quite make it. The gap appears here:</p>
<p class="code"><span class="font">cup . ((cup . (one * matchA)) * matchesA)</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{... ??? ...}</span></p>
<p class="code"><span class="font">cup . (one * (cup . (matchA * matchesA))) . assocl</span></p>
<p class="para">The gap is easily eliminable by hand:</p>
<p class="code"><span class="font">cup . ((cup . (one * matchA)) * matchesA)</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{cross bifunctor (backwards)}</span></p>
<p class="code"><span class="font">cup . (cup * id) . ((one * matchA) * matchesA)</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{cup assoc}</span></p>
<p class="code"><span class="font">cup . (id * cup) . assocl . ((one * matchA) * matchesA)</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{assocl}</span></p>
<p class="code"><span class="font">cup . (id * cup) . (one * (matchA * matchesA)) . assocl</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{cross bifunctor}</span></p>
<p class="code"><span class="font">cup . (one * (cup . (matchA * matchesA))) . assocl</span></p>
<p class="para">Once again, the inability to apply laws in both directions is the culprit. Instead of trying to force the laws into a form that would be acceptable to the calculator, we leave it here with the comment ‘A hand-finished product!’.</p>
<p class="para">To round off the example, here is the program we have calculated:</p>
<p class="code"><span class="font">match = xmatch emptySub</span></p>
<p class="code"><span class="font">xmatch sub (e1,e2)</span></p>
<p class="code"><span class="space"></span><span class="font">= concat [xmatchesA sub aes | aes &lt;- alignments (e1,e2)]</span></p>
<p class="para1"></p>
<p class="code"><a id="text/part0016.html.page_330" class="calibre3"></a><span class="font">xmatchesA sub [] = [sub]</span></p>
<p class="code"><span class="font">xmatchesA sub (ae:aes)</span></p>
<p class="code"><span class="space"></span><span class="font">= concat [xmatchesA sub' aes | sub' &lt;- xmatchA sub ae]</span></p>
<p class="para1"></p>
<p class="code"><span class="font">xmatchA sub (Var v,e) = extend sub v e</span></p>
<p class="code"><span class="font">xmatchA sub (Con k1 es1,Compose [Con k2 es2])</span></p>
<p class="code11"><span class="font">| k1==k2 = xmatches sub (zip es1 es2)</span></p>
<p class="code"><span class="font">xmatchA _ = []</span></p>
<p class="para">The missing definition is that of <span class="font">xmatches</span>. But exactly the same treatment for <span class="font">xmatchesA</span> goes through for <span class="font">matches</span>, and we end up with</p>
<p class="code"><span class="font">xmatches sub [] = [sub]</span></p>
<p class="code"><span class="font">xmatches sub ((e1,e2):es)</span></p>
<p class="code"><span class="space-r"></span><span class="font">= concat [xmatches sub' es | sub' &lt;- xmatch sub (e1,e2)]</span></p>
<h3 class="calibre20"><i class="calibre16">Conclusions</i></h3>
<p class="para">The positive conclusion of these two exercises is that one can indeed get the calculator to assist in the construction of formal proofs. But there remains the need for substantial human input to the process, to set up appropriate laws, to identify subsidiary claims and to control the order in which calculations are carried out. The major negative conclusion is that it is a significant failing of the calculator to be unable to apply laws in both directions. The functor laws are the major culprits, but there are others as well (see the exercises for some examples). The calculator can be improved in a number of ways, but we leave further discussion to the exercises.</p>
<p class="para">There are three other aspects worth mentioning about the calculator. Firstly, the complete calculator is only about 450 lines of Haskell, and the improved version is even shorter. That alone is a testament to the expressive power of functional programming. Secondly, it does seem a viable approach to express laws as purely functional equations and to use a simple equational logic for conducting proofs. To be sure, some work has to be done to express definitions in point-free form, but once this is achieved, equational logic can be surprisingly effective.</p>
<p class="para">The third aspect is that, apart from parsing, no monadic code appears in the calculator. In fact, earlier versions of the calculator did use monads, but gradually they were weeded out. One reason was that we found the code became simpler without monads, without significant loss of efficiency; another was that we wanted to set things up for the extended exercise in improving the calculator. Monads are <a id="text/part0016.html.page_331" class="calibre3"></a>absolutely necessary for many applications involving interacting with the world, but they can be overused in places where a purely functional approach would be smoother.</p>
<p class="para">On that note, we end.</p>
<h3 class="h" id="text/part0016.html.head12-9">12.9 Exercises</h3>
<p class="theorem"><b class="calibre7">Exercise A</b></p>
<p class="para">Suppose we did want <span class="font">calculate</span> to return a tree of possible calculations. What would be a suitable tree to use?</p>
<p class="theorem"><b class="calibre7">Exercise B</b></p>
<p class="para">Why should the laws</p>
<p class="code"><span class="font">map (f . g) = map f . map g</span></p>
<p class="code"><span class="font">cmap (f . g) = cmap f . map g</span></p>
<p class="para"><i class="calibre1">never</i> be used in calculations, at least if they are given in the form above?</p>
<p class="theorem"><b class="calibre7">Exercise C</b></p>
<p class="para">Here is a calculation, as recorded by the calculator</p>
<p class="code"><span class="font">map f . map g h</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{map functor}</span></p>
<p class="code"><span class="font">map (f . g)</span></p>
<p class="para">Explain this strange and clearly nonsensical result. What simple change to the calculator would prevent the calculation from being valid?</p>
<p class="theorem"><b class="calibre7">Exercise D</b></p>
<p class="para">On the same general theme as the previous question, one serious criticism of the calculator is that error messages are totally opaque. For example, both</p>
<p class="code"><span class="font">parse law "map f . map g = map (f . g)"</span></p>
<p class="code"><span class="font">parse law "map functor: map f . map g map (f . g)"</span></p>
<p class="para">cause the same cryptic error message. What is it? What would be the effect of using the law</p>
<p class="code"><span class="font">strange: map f . map g = map h</span></p>
<p class="para"><a id="text/part0016.html.page_332" class="calibre3"></a>in a calculation?</p>
<p class="para">Again, what change to the calculator would prevent such a law from being acceptable?</p>
<p class="theorem"><b class="calibre7">Exercise E</b></p>
<p class="para">The definition of <span class="font">showsPrec</span> for atoms makes use of a fact about Haskell that we haven’t needed before. And the same device is used in later calculator functions that mix a pattern-matching style with guarded equations. What is the fact?</p>
<p class="theorem"><b class="calibre7">Exercise F</b></p>
<p class="para">Define</p>
<p class="code"><span class="font">e1 = foo (f . g) . g</span></p>
<p class="code"><span class="font">e2 = bar f . baz g</span></p>
<p class="para">List the expressions that <span class="font">rewrites (e1,e2)</span> produces when applied to the expression <span class="font">foo (a . b . c) . c</span>. Which one would the calculator pick?</p>
<p class="theorem"><b class="calibre7">Exercise G</b></p>
<p class="para">Can the calculator successfully match <span class="font">foo f . foo f</span> with the expression</p>
<p class="code"><span class="font">foo (bar g h) . foo (bar (daz a) b) ?</span></p>
<p class="theorem"><b class="calibre7">Exercise H</b></p>
<p class="para">It was claimed in the text that it is possible to apply a perfectly valid non-trivial law that will leave some expressions unchanged. Give an example of such a law and an expression that is rewritten to itself.</p>
<p class="theorem"><b class="calibre7">Exercise I</b></p>
<p class="para">The function <span class="font">anyOne</span> used in the definition of <span class="font">rewrites</span> installs a single choice, but why not use <span class="font">everyOne</span> that installs every choice at the same time? Thus if <span class="font">f 1 = [-1,-2]</span> and <span class="font">f 2 = [-3,-4]</span>, then</p>
<p class="code"><span class="font">everyOne f [1,2] = [[-1,-3],[-1,-4],[-2,-3],[-3,-4]]</span></p>
<p class="para">Using <span class="font">everyOne</span> instead of <span class="font">anyOne</span> would mean that a rewrite would be applied to every possible subexpression that matches a law. Give a definition of <span class="font">everyOne</span>.</p>
<p class="theorem"><a id="text/part0016.html.page_333" class="calibre3"></a><b class="calibre7">Exercise J</b></p>
<p class="para">How many segments of a list of length <i class="calibre1">n</i> are there? The definition of <span class="font">rewritesSeg</span> is inefficient because the empty segment appears <i class="calibre1">n</i>+1 times as the middle component of the segments of a list of length <i class="calibre1">n</i>. That means matching with <span class="font">id</span> is performed <i class="calibre1">n</i>+1 times instead of just once. How would you rewrite <span class="font">segments</span> to eliminate these duplicates?</p>
<p class="theorem"><b class="calibre7">Exercise K</b></p>
<p class="para">Prove that <span class="font">cmap f . cmap g = cmap (cmap f . g)</span>. The laws needed are:</p>
<p class="code"><span class="font">defn cmap:</span><span class="space8"></span><span class="font">cmap f = concat . map f</span></p>
<p class="code"><span class="font">map functor:</span><span class="space2"></span><span class="font">map f . map g = map (f.g)</span></p>
<p class="code"><span class="font">map after concat:</span><span class="space"></span><span class="font">map f . concat = concat . map (map f)</span></p>
<p class="code"><span class="font">concat twice:</span><span class="space4"></span><span class="font">concat . concat = concat . map concat</span></p>
<p class="theorem"><b class="calibre7">Exercise L</b></p>
<p class="para">The <span class="font">cmap-cpp</span> law is as follows:</p>
<p class="code6"><span class="font">cmap (cpp . (one * f)) . cpp = cpp . (id * cmap f)</span></p>
<p class="para">Prove it from the laws</p>
<p class="code"><span class="font">cmap after cmap:</span><span class="space5"></span><span class="font">cmap f . map g = cmap (f . g)</span></p>
<p class="code"><span class="font">cmap after cpp:</span><span class="space5"></span><span class="space-r"></span><span class="font">cmap cpp . cpp = cpp . (concat * concat)</span></p>
<p class="code"><span class="font">cross bifunctor:</span><span class="space5"></span><span class="font">(f * g) . (h * k) = (f . h) * (g . k)</span></p>
<p class="code"><span class="font">map after cpp:</span><span class="space4"></span><span class="space-r"></span><span class="font">map (f * g) . cpp = cpp . (map f * map g)</span></p>
<p class="code"><span class="font">defn cmap:</span><span class="space8"></span><span class="space-r"></span><span class="font">cmap f = concat . map f</span></p>
<p class="code"><span class="font">concat after id:</span><span class="space5"></span><span class="font">concat . map one = id</span></p>
<p class="para">Can a calculator conduct the proof?</p>
<h3 class="h" id="text/part0016.html.head12-10">12.10 Answers</h3>
<p class="theorem"><b class="calibre7">Answer to Exercise A</b></p>
<p class="para">We would want expressions as labels of nodes and law names as labels of edges. That gives</p>
<p class="code"><span class="font">type Calculation = Tree Expr LawName</span></p>
<p class="code"><span class="font">data Tree a b = Node a [(b,Tree a b)]</span></p>
<p class="theorem"><a id="text/part0016.html.page_334" class="calibre3"></a><b class="calibre7">Answer to Exercise B</b></p>
<p class="para">They would both cause the calculator to spin off into an infinite calculation. For example,</p>
<p class="code"><span class="font">map foo</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{map functor}</span></p>
<p class="code"><span class="font">map foo . map id</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{map functor}</span></p>
<p class="code"><span class="font">map foo . map id . map id</span></p>
<p class="para">and so on.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise C</b></p>
<p class="para">The expression <span class="font">map f . map g h</span> is perfectly valid by the rules of syntax, but of course it shouldn’t be. The evaluator does not force the restriction that each appearance of one and the same constant should possess the same number of arguments. The reason the functor law can be matched successfully against the expression is that in the definition of <span class="font">matchA</span> the function <span class="font">zip</span> truncates the two arguments to the second <span class="font">map</span> to one. A better calculator should check that each constant has a fixed arity.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise D</b></p>
<p class="para">The cryptic message is ‘head of empty list’. The first parse fails because the law is missing its name, and the second is missing an equals sign. Use of the strange law would cause the calculator to fall over because pattern-matching with the left-hand side would not bind <span class="font">h</span> to any expression, causing an error when the binding for <span class="font">h</span> is requested. The calculator should have checked that every variable on the right-hand side of a law appears somewhere on the left-hand side.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise E</b></p>
<p class="para">The code for <span class="font">showsPrec</span> takes the form</p>
<p class="code"><span class="font">showsPrec p (Con f [e1,e2])</span></p>
<p class="code2"><span class="font">| isOp f = expression1 e1 e2</span></p>
<p class="code"><span class="font">showsPrec p (Con f es)</span></p>
<p class="code2"><span class="font">= expression2 es</span></p>
<p class="para">A more ‘mathematical’ style would have been to write</p>
<p class="code"><span class="font">showsPrec p (Con f [e1,e2])</span></p>
<p class="code2"><span class="font">| isOp f = expression1 e1 e2</span></p>
<p class="code2"><span class="font">| otherwise = expression2 [e1,e2]</span></p>
<p class="code"><a id="text/part0016.html.page_335" class="calibre3"></a><span class="font">showsPrec p (Con f es) = expression2 es</span></p>
<p class="para">The point is this: in a given clause if a pattern does not match the argument, or if it does but the guard fails to be true, the clause is abandoned and the next clause is chosen.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise F</b></p>
<p class="para">There are two rewrites, not one:</p>
<p class="code"><span class="font">bar (a . b . c) . baz id . c</span></p>
<p class="code"><span class="font">bar (a . b) . baz c</span></p>
<p class="para">The calculator would pick the first subexpression that matches, and that means the first rewrite is chosen. Perhaps it would be better to arrange that <span class="font">rewritesSeg</span> is applied to longer segments before shorter ones.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise G</b></p>
<p class="para">No, not with our definition of <span class="font">match</span>. They can be matched by binding <span class="font">f</span> to the expression <span class="font">bar (daz a) b</span> provided <span class="font">g</span> is bound to <span class="font">daz a</span> and <span class="font">h</span> to <span class="font">b</span>, but our definition of <span class="font">match</span> does not perform full unification.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise H</b></p>
<p class="para">To take just one example out of many, consider the law</p>
<p class="code"><span class="font">if p f g . h = if (p . h) (f . h) (g . h)</span></p>
<p class="para">The left-hand side matches <span class="font">if a b c</span> with <span class="font">h</span> bound to <span class="font">id</span>, and the result is again the same expression.</p>
<p class="theorem"><b class="calibre7">Answer to Exercise I</b></p>
<p class="para">The temptation is to define</p>
<p class="code"><span class="font">everyOne f = cp . map f</span></p>
<p class="para">but that doesn’t work if <span class="font">f</span> returns no alternatives for some element. Instead we have to define</p>
<p class="code"><span class="font">everyOne :: (a -&gt; [a]) -&gt; [a] -&gt; [[a]]</span></p>
<p class="code"><span class="font">everyOne f = cp . map (possibly f)</span></p>
<p class="code"><span class="font">possibly f x = if null xs then [x] else xs</span></p>
<p class="code4"><span class="font">where xs = f x</span></p>
<p class="para">In this version, <span class="font">f</span> returns a nonempty list of alternatives.</p>
<p class="theorem"><a id="text/part0016.html.page_336" class="calibre3"></a><b class="calibre7">Answer to Exercise J</b></p>
<p class="para">There are (<i class="calibre1">n</i>+1)(<i class="calibre1">n</i>+2)/2 segments of a list of length <i class="calibre1">n</i>. The improved definition is</p>
<p class="code"><span class="font">segments xs = [([],[],xs] ++</span></p>
<p class="code9"><span class="space-r"></span><span class="font">[(as,bs,cs)</span></p>
<p class="code9"><span class="space-r"></span><span class="font">| (as,ys) &lt;- splits xs,</span></p>
<p class="code4"><span class="font">(bs,cs) &lt;- tail (splits ys)]</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise K</b></p>
<p class="para">The calculator produced:</p>
<p class="code"><span class="font">cmap f . cmap g</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn cmap}</span></p>
<p class="code"><span class="font">concat . map f . cmap g</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn cmap}</span></p>
<p class="code"><span class="font">concat . map f . concat . map g</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{map after concat}</span></p>
<p class="code"><span class="font">concat . concat . map (map f) . map g</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{map functor}</span></p>
<p class="code"><span class="font">concat . concat . map (map f . g)</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{concat after concat}</span></p>
<p class="code"><span class="font">concat . map concat . map (map f . g)</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{map functor}</span></p>
<p class="code"><span class="font">concat . map (concat . map f . g)</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn cmap}</span></p>
<p class="code"><span class="font">concat . map (cmap f . g)</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn cmap}</span></p>
<p class="code"><span class="font">cmap (cmap f . g)</span></p>
<p class="theorem"><b class="calibre7">Answer to Exercise L</b></p>
<p class="para">The human proof is:</p>
<p class="code"><span class="font">cmap (cpp . (one * g)) . cpp</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{cmap after cmap (backwards)}</span></p>
<p class="code"><span class="font">cmap cpp . map (one * g) . cpp</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{map after cpp}</span></p>
<p class="code"><span class="font">cmap cpp . cpp . (map one * map g)</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{cmap after cpp}</span></p>
<p class="code"><span class="font">cpp . (concat * concat) . (map one * map g)</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{cross bifunctor}</span></p>
<p class="code"><span class="font">cpp . ((concat . map one) * concat (map g))</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{defn cmap (backwards)}</span></p>
<p class="code"><span class="font">cpp . ((concat . map one) * cmap g)</span></p>
<p class="code6"><span class="font">=</span><span class="space5"></span><span class="font">{concat after id}</span></p>
<p class="code"><span class="font">cpp . (id * cmap g)</span></p>
<p class="para">No, the calculation cannot be performed automatically. The <span class="font">cmap after cmap</span></p>
<p class="para"><a id="text/part0016.html.page_337" class="calibre3"></a>law cannot be installed in the backwards direction without causing the calculator to loop (see Exercise B).</p>
<h3 class="h" id="text/part0016.html.head12-11">12.11 Chapter notes</h3>
<p class="para">The calculator in this chapter is based on an undocumented theorem prover by Mike Spivey, a colleague at Oxford. Ross Paterson of City University, London, has produced a version with built-in functor laws that can be applied in both directions when necessary.</p>
<p class="para">One state-of-the-art proof assistant is Coq; see <span class="font"><a href="http://coq.inria.fr/" class="calibre3">http://coq.inria.fr/</a></span>.</p>
</div></div>
<div id="text/part0017.html"><div id="text/part0017.html.G6PI0-0daaaafc8385457e8f80971b0d39bbf7" class="calibre">

<h2 class="fm_title" id="text/part0017.html.calibre_pb_0">Index</h2>
<p class="indextitle">Θ asymptotic notation, <a href="#text/part0011.html.page_157" class="calibre3">157</a></p>
<p class="index">⌊−⌋ floor function, <a href="#text/part0006.html.page_46" class="calibre3">46</a>, <a href="#text/part0007.html.page_52" class="calibre3">52</a>, <a href="#text/part0007.html.page_62" class="calibre3">62</a></p>
<p class="index" id="text/part0017.html.link6">⊥ undefined value, <a href="#text/part0006.html.page_24" class="calibre3">24</a>, <a href="#text/part0006.html.page_28" class="calibre3">28</a>, <a href="#text/part0006.html.page_30" class="calibre3">30</a>, <a href="#text/part0009.html.page_104" class="calibre3">104</a>, <a href="#text/part0011.html.page_177" class="calibre3">177</a>, <a href="#text/part0013.html.page_215" class="calibre3">215</a>, <a href="#text/part0013.html.page_217" class="calibre3">217</a>, <a href="#text/part0013.html.page_226" class="calibre3">226</a>, <a href="#text/part0013.html.page_233" class="calibre3">233</a></p>
<p class="index"><i class="calibre1">π</i>, <a href="#text/part0007.html.page_50" class="calibre3">50</a>, <a href="#text/part0013.html.page_215" class="calibre3">215</a></p>
<p class="index">⊑ approximation ordering, <a href="#text/part0013.html.page_217" class="calibre3">217</a></p>
<p class="index"><span class="font">(%)</span> integral ratio, <a href="#text/part0007.html.page_50" class="calibre3">50</a></p>
<p class="index"><span class="font">""</span> empty list of characters, <a href="#text/part0005.html.page_18" class="calibre3">18</a></p>
<p class="index"><span class="font">"</span> double quotes, <a href="#text/part0005.html.page_4" class="calibre3">4</a></p>
<p class="index"><span class="font">'</span> single quote, <a href="#text/part0005.html.page_3" class="calibre3">3</a></p>
<p class="index" id="text/part0017.html.link19"><span class="font">(!!)</span> list-indexing operation, <a href="#text/part0005.html.page_9" class="calibre3">9</a></p>
<p class="index"><span class="font">(!)</span> array-indexing operation, <a href="#text/part0014.html.page_261" class="calibre3">261</a></p>
<p class="index"><span class="font">($!)</span> strict application operator, <a href="#text/part0011.html.page_153" class="calibre3">153</a>, <a href="#text/part0014.html.page_252" class="calibre3">252</a></p>
<p class="index"><span class="font">($)</span> application operator, <a href="#text/part0011.html.page_153" class="calibre3">153</a></p>
<p class="index" id="text/part0017.html.link4"><span class="font">(&amp;&amp;)</span> boolean conjunction, <a href="#text/part0005.html.page_10" class="calibre3">10</a></p>
<p class="index" id="text/part0017.html.link21"><span class="font">()</span> null tuple, <a href="#text/part0006.html.page_30" class="calibre3">30</a>, <a href="#text/part0006.html.page_33" class="calibre3">33</a>, <a href="#text/part0014.html.page_240" class="calibre3">240</a></p>
<p class="index"><span class="font">(**)</span> exponentiation, <a href="#text/part0007.html.page_59" class="calibre3">59</a></p>
<p class="index"><span class="font">(,)</span> pair constructor, <a href="#text/part0008.html.page_74" class="calibre3">74</a>, <a href="#text/part0011.html.page_146" class="calibre3">146</a></p>
<p class="index"><span class="font">(-)</span> subtraction operator, <a href="#text/part0006.html.page_27" class="calibre3">27</a></p>
<p class="index" id="text/part0017.html.link12"><span class="font">(-&gt;)</span> function type, <a href="#text/part0005.html.page_1" class="calibre3">1</a></p>
<p class="index" id="text/part0017.html.link10"><span class="font">(.)</span> function composition, <a href="#text/part0005.html.page_3" class="calibre3">3</a>, <a href="#text/part0005.html.page_15" class="calibre3">15</a>, <a href="#text/part0006.html.page_31" class="calibre3">31</a></p>
<p class="index"><span class="font">(//)</span> array update operation, <a href="#text/part0014.html.page_262" class="calibre3">262</a></p>
<p class="index"><span class="font">(/=)</span> inequality test, <a href="#text/part0005.html.page_9" class="calibre3">9</a></p>
<p class="index"><span class="font">(:)</span> cons, list constructor, <a href="#text/part0008.html.page_64" class="calibre3">64</a></p>
<p class="index"><span class="font">(&lt;=)</span> comparison test, <a href="#text/part0005.html.page_9" class="calibre3">9</a>, <a href="#text/part0008.html.page_76" class="calibre3">76</a></p>
<p class="index"><span class="font">(&lt;=&lt;)</span> right-to-left Kleisli composition, <a href="#text/part0014.html.page_247" class="calibre3">247</a></p>
<p class="index"><span class="font">(==)</span> equality test, <a href="#text/part0005.html.page_9" class="calibre3">9</a></p>
<p class="index"><span class="font">(&gt;=&gt;)</span> left-to-right Kleisli composition, <a href="#text/part0014.html.page_247" class="calibre3">247</a></p>
<p class="index"><span class="font">(&gt;&gt;)</span> sequence operation, <a href="#text/part0014.html.page_240" class="calibre3">240</a></p>
<p class="index"><span class="font">(&gt;&gt;=)</span> monadic bind, <a href="#text/part0014.html.page_241" class="calibre3">241</a>, <a href="#text/part0015.html.page_279" class="calibre3">279</a></p>
<p class="index"><span class="font">(^)</span> exponentiation, <a href="#text/part0007.html.page_59" class="calibre3">59</a></p>
<p class="index"><span class="font">(^^)</span> exponentiation, <a href="#text/part0007.html.page_59" class="calibre3">59</a></p>
<p class="index" id="text/part0017.html.link5"><span class="font">(||)</span> boolean disjunction, <a href="#text/part0006.html.page_32" class="calibre3">32</a></p>
<p class="index"><span class="font">.hs</span> Haskell script, <a href="#text/part0006.html.page_35" class="calibre3">35</a>, <a href="#text/part0013.html.page_227" class="calibre3">227</a></p>
<p class="index"><span class="font">.lhs</span> literate Haskell script, <a href="#text/part0005.html.page_8" class="calibre3">8</a>, <a href="#text/part0006.html.page_35" class="calibre3">35</a>, <a href="#text/part0013.html.page_227" class="calibre3">227</a></p>
<p class="index"><span class="font">:load</span> instruction, <a href="#text/part0005.html.page_13" class="calibre3">13</a></p>
<p class="index"><span class="font">:set</span> instruction, <a href="#text/part0005.html.page_13" class="calibre3">13</a>, <a href="#text/part0011.html.page_148" class="calibre3">148</a></p>
<p class="index"><span class="font">:type</span> instruction, <a href="#text/part0006.html.page_22" class="calibre3">22</a></p>
<p class="index"><span class="font">@</span> as patterns, <i class="calibre1">see</i> <a href="#text/part0017.html.link1" class="calibre3">patterns</a></p>
<p class="index" id="text/part0017.html.link8"><span class="font">[]</span> empty list, <a href="#text/part0005.html.page_17" class="calibre3">17</a>, <a href="#text/part0008.html.page_63" class="calibre3">63</a>, <a href="#text/part0008.html.page_64" class="calibre3">64</a>, <a href="#text/part0009.html.page_104" class="calibre3">104</a>, <a href="#text/part0010.html.page_121" class="calibre3">121</a>, <a href="#text/part0011.html.page_151" class="calibre3">151</a></p>
<p class="index"><span class="font">\</span> escape character, <a href="#text/part0005.html.page_18" class="calibre3">18</a></p>
<p class="index" id="text/part0017.html.link20"><span class="font">\n</span> newline character, <a href="#text/part0005.html.page_3" class="calibre3">3</a>, <a href="#text/part0005.html.page_18" class="calibre3">18</a></p>
<p class="index"><span class="font">\t</span> tab character, <a href="#text/part0005.html.page_18" class="calibre3">18</a></p>
<p class="index"><span class="font">`</span> back-quote, <a href="#text/part0005.html.page_9" class="calibre3">9</a>, <a href="#text/part0006.html.page_25" class="calibre3">25</a></p>
<p class="index" id="text/part0017.html.link18"><span class="font">(++)</span> list concatenation, <a href="#text/part0005.html.page_10" class="calibre3">10</a>, <a href="#text/part0005.html.page_15" class="calibre3">15</a>, <a href="#text/part0008.html.page_69" class="calibre3">69</a>, <a href="#text/part0010.html.page_113" class="calibre3">113</a></p>
<p class="index"><span class="font">n+k</span> patterns, <a href="#text/part0010.html.page_111" class="calibre3">111</a></p>
<p class="indextitle" id="text/part0017.html.link2"><span class="font">abs</span>, <a href="#text/part0007.html.page_50" class="calibre3">50</a>, <a href="#text/part0007.html.page_54" class="calibre3">54</a></p>
<p class="index">absolute value, <i class="calibre1">see</i> <a href="#text/part0017.html.link2" class="calibre3"><span class="font">abs</span></a></p>
<p class="index">abstract data types, <a href="#text/part0012.html.page_194" class="calibre3">194</a>, <a href="#text/part0014.html.page_239" class="calibre3">239</a>, <a href="#text/part0014.html.page_259" class="calibre3">259</a></p>
<p class="index">abstract syntax trees, <a href="#text/part0012.html.page_201" class="calibre3">201</a></p>
<p class="index"><span class="font">accumArray</span>, <a href="#text/part0014.html.page_260" class="calibre3">260</a></p>
<p class="index">accumulating functions, <a href="#text/part0014.html.page_260" class="calibre3">260</a></p>
<p class="index">accumulating parameters, <a href="#text/part0011.html.page_159" class="calibre3">159</a>, <a href="#text/part0011.html.page_171" class="calibre3">171</a>, <a href="#text/part0015.html.page_288" class="calibre3">288</a>, <a href="#text/part0015.html.page_289" class="calibre3">289</a>, <a href="#text/part0016.html.page_323" class="calibre3">323</a></p>
<p class="index">actions, <a href="#text/part0014.html.page_239" class="calibre3">239</a></p>
<p class="index">Agda, <a href="#text/part0006.html.page_48" class="calibre3">48</a></p>
<p class="index">Algorithm Design, <a href="#text/part0011.html.page_145" class="calibre3">145</a>, <a href="#text/part0011.html.page_154" class="calibre3">154</a></p>
<p class="index"><span class="font">all</span>, <a href="#text/part0009.html.page_94" class="calibre3">94</a></p>
<p class="index">alphabetical order, <a href="#text/part0005.html.page_5" class="calibre3">5</a>, <a href="#text/part0005.html.page_19" class="calibre3">19</a></p>
<p class="index"><span class="font">anagrams</span>, <a href="#text/part0005.html.page_16" class="calibre3">16</a></p>
<p class="index"><span class="font">and</span>, <a href="#text/part0008.html.page_74" class="calibre3">74</a></p>
<p class="index">anti-symmetric relation, <a href="#text/part0013.html.page_217" class="calibre3">217</a></p>
<p class="index"><span class="font">any</span>, <a href="#text/part0009.html.page_102" class="calibre3">102</a></p>
<p class="index"><span class="font">approx</span>, <a href="#text/part0013.html.page_218" class="calibre3">218</a></p>
<p class="index"><span class="font">Array</span>, <a href="#text/part0014.html.page_259" class="calibre3">259</a></p>
<p class="index"><span class="font">array</span>, <a href="#text/part0014.html.page_259" class="calibre3">259</a></p>
<p class="index">arrays</p>
<p class="index1">immutable, <a href="#text/part0014.html.page_259" class="calibre3">259</a></p>
<p class="index1">mutable, <a href="#text/part0014.html.page_254" class="calibre3">254</a></p>
<p class="index">associative operations, <a href="#text/part0005.html.page_15" class="calibre3">15</a>, <a href="#text/part0006.html.page_26" class="calibre3">26</a>, <a href="#text/part0008.html.page_70" class="calibre3">70</a>, <a href="#text/part0010.html.page_112" class="calibre3">112</a>, <a href="#text/part0010.html.page_113" class="calibre3">113</a>, <a href="#text/part0010.html.page_119" class="calibre3">119</a>, <a href="#text/part0010.html.page_124" class="calibre3">124</a>, <a href="#text/part0010.html.page_129" class="calibre3">129</a>, <a href="#text/part0012.html.page_184" class="calibre3">184</a>, <a href="#text/part0013.html.page_231" class="calibre3">231</a>, <a href="#text/part0014.html.page_246" class="calibre3">246</a>, <a href="#text/part0014.html.page_247" class="calibre3">247</a>, <a href="#text/part0015.html.page_281" class="calibre3">281</a>, <a href="#text/part0016.html.page_326" class="calibre3">326</a></p>
<p class="index"><span class="font">assocs</span>, <a href="#text/part0014.html.page_262" class="calibre3">262</a></p>
<p class="index">asymptotic complexity, <a href="#text/part0011.html.page_155" class="calibre3">155</a></p>
<p class="index">Augustsson, L., <a href="#text/part0006.html.page_47" class="calibre3">47</a></p>
<p class="index">auxiliary results, <a href="#text/part0010.html.page_114" class="calibre3">114</a>, <a href="#text/part0010.html.page_117" class="calibre3">117</a>, <a href="#text/part0010.html.page_140" class="calibre3">140</a></p>
<p class="indextitle">base cases, <i class="calibre1">see</i> <a href="#text/part0017.html.link3" class="calibre3">induction</a></p>
<p class="index">Bentley, J., <a href="#text/part0005.html.page_21" class="calibre3">21</a>, <a href="#text/part0010.html.page_127" class="calibre3">127</a>, <a href="#text/part0010.html.page_144" class="calibre3">144</a></p>
<p class="index"><span class="font">Bifunctor</span>, <a href="#text/part0008.html.page_82" class="calibre3">82</a></p>
<p class="index">bifunctors, <a href="#text/part0008.html.page_82" class="calibre3">82</a>, <a href="#text/part0008.html.page_87" class="calibre3">87</a>, <a href="#text/part0016.html.page_302" class="calibre3">302</a>, <a href="#text/part0016.html.page_326" class="calibre3">326</a></p>
<p class="index">binary operators, <a href="#text/part0006.html.page_25" class="calibre3">25</a></p>
<p class="index">binary search, <a href="#text/part0007.html.page_54" class="calibre3">54</a></p>
<p class="index">binary trees, <a href="#text/part0011.html.page_165" class="calibre3">165</a>, <a href="#text/part0014.html.page_249" class="calibre3">249</a></p>
<p class="index">binding power, <a href="#text/part0005.html.page_2" class="calibre3">2</a>, <a href="#text/part0005.html.page_14" class="calibre3">14</a>, <a href="#text/part0006.html.page_25" class="calibre3">25</a></p>
<p class="index">Bird, R., <a href="#text/part0008.html.page_87" class="calibre3">87</a>, <a href="#text/part0011.html.page_180" class="calibre3">180</a></p>
<p class="index">blank characters, <a href="#text/part0005.html.page_3" class="calibre3">3</a></p>
<p class="index">BNF (Backus-Naur form), <a href="#text/part0015.html.page_286" class="calibre3">286</a>, <a href="#text/part0016.html.page_305" class="calibre3">305</a></p>
<p class="index"><span class="font">Bool</span>, <a href="#text/part0005.html.page_10" class="calibre3">10</a>, <a href="#text/part0006.html.page_30" class="calibre3">30</a></p>
<p class="index">boolean</p>
<p class="index1">conjunction, <i class="calibre1">see</i> <a href="#text/part0017.html.link4" class="calibre3"><span class="font">(&amp;&amp;)</span></a></p>
<p class="index1">disjunction, <i class="calibre1">see</i> <a href="#text/part0017.html.link5" class="calibre3"><span class="font">(||)</span></a></p>
<p class="index">bottom, <i class="calibre1">see</i> <a href="#text/part0017.html.link6" class="calibre3">⊥ undefined value</a></p>
<p class="index">braces, <a href="#text/part0005.html.page_15" class="calibre3">15</a>, <a href="#text/part0006.html.page_36" class="calibre3">36</a>, <a href="#text/part0014.html.page_242" class="calibre3">242</a></p>
<p class="index">brackets, <a href="#text/part0005.html.page_15" class="calibre3">15</a></p>
<p class="index">breadth-first search, <a href="#text/part0014.html.page_257" class="calibre3">257</a></p>
<p class="index"><span class="font">break</span>, <a href="#text/part0009.html.page_102" class="calibre3">102</a></p>
<p class="indextitle">C, <a href="#text/part0014.html.page_239" class="calibre3">239</a></p>
<p class="index">C#, <a href="#text/part0004.html.page_x" class="calibre3">x</a></p>
<p class="index"><span class="font">case</span> expression, <i class="calibre1">see</i> <a href="#text/part0017.html.link7" class="calibre3">expressions</a></p>
<p class="index">case analysis, <a href="#text/part0005.html.page_10" class="calibre3">10</a>, <a href="#text/part0007.html.page_53" class="calibre3">53</a></p>
<p class="index">Category Theory, <a href="#text/part0008.html.page_71" class="calibre3">71</a>, <a href="#text/part0008.html.page_87" class="calibre3">87</a></p>
<p class="index">chain completeness, <a href="#text/part0010.html.page_116" class="calibre3">116</a>, <a href="#text/part0013.html.page_212" class="calibre3">212</a>, <a href="#text/part0013.html.page_220" class="calibre3">220</a></p>
<p class="index">chain of approximations, <a href="#text/part0013.html.page_215" class="calibre3">215</a>, <a href="#text/part0013.html.page_218" class="calibre3">218</a>, <a href="#text/part0013.html.page_225" class="calibre3">225</a></p>
<p class="index"><span class="font">Char</span>, <a href="#text/part0005.html.page_3" class="calibre3">3</a>, <a href="#text/part0006.html.page_30" class="calibre3">30</a>, <a href="#text/part0009.html.page_90" class="calibre3">90</a>, <a href="#text/part0014.html.page_254" class="calibre3">254</a></p>
<p class="index">Chitil, O., <a href="#text/part0012.html.page_209" class="calibre3">209</a></p>
<p class="index">comment convention, <a href="#text/part0005.html.page_8" class="calibre3">8</a></p>
<p class="index">common subexpression elimination, <a href="#text/part0011.html.page_147" class="calibre3">147</a></p>
<p class="index"><span class="font">commonWords</span>, <a href="#text/part0005.html.page_3" class="calibre3">3</a>, <a href="#text/part0005.html.page_4" class="calibre3">4</a>, <a href="#text/part0006.html.page_34" class="calibre3">34</a>, <a href="#text/part0008.html.page_75" class="calibre3">75</a></p>
<p class="index">comparison operations, <a href="#text/part0006.html.page_32" class="calibre3">32</a></p>
<p class="index">compiled functions, <a href="#text/part0011.html.page_154" class="calibre3">154</a></p>
<p class="index">compilers, <a href="#text/part0006.html.page_36" class="calibre3">36</a>, <a href="#text/part0011.html.page_154" class="calibre3">154</a></p>
<p class="index">complete partial orderings, <a href="#text/part0013.html.page_218" class="calibre3">218</a></p>
<p class="index" id="text/part0017.html.link22"><span class="font">Complex</span>, <a href="#text/part0007.html.page_49" class="calibre3">49</a></p>
<p class="index"><span class="font">concat</span>, <a href="#text/part0005.html.page_6" class="calibre3">6</a>, <a href="#text/part0008.html.page_67" class="calibre3">67</a>, <a href="#text/part0008.html.page_70" class="calibre3">70</a>, <a href="#text/part0011.html.page_157" class="calibre3">157</a></p>
<p class="index"><span class="font">concatMap</span>, <a href="#text/part0016.html.page_307" class="calibre3">307</a></p>
<p class="index">concrete data types, <a href="#text/part0012.html.page_194" class="calibre3">194</a></p>
<p class="index">conditional expressions, <a href="#text/part0012.html.page_189" class="calibre3">189</a></p>
<p class="index"><span class="font">const</span>, <a href="#text/part0008.html.page_86" class="calibre3">86</a></p>
<p class="index">context, <a href="#text/part0005.html.page_11" class="calibre3">11</a></p>
<p class="index"><span class="font">Control.Monad</span>, <a href="#text/part0014.html.page_247" class="calibre3">247</a>, <a href="#text/part0014.html.page_264" class="calibre3">264</a></p>
<p class="index"><span class="font">Control.Monad.ST</span>, <a href="#text/part0014.html.page_251" class="calibre3">251</a></p>
<p class="index"><span class="font">Control.Monad.State.Lazy</span>, <a href="#text/part0014.html.page_251" class="calibre3">251</a></p>
<p class="index"><span class="font">Control.Monad.State.Strict</span>, <a href="#text/part0014.html.page_251" class="calibre3">251</a></p>
<p class="index">conversion functions, <a href="#text/part0007.html.page_53" class="calibre3">53</a></p>
<p class="index">coprime numbers, <a href="#text/part0008.html.page_66" class="calibre3">66</a></p>
<p class="index">Coq, <a href="#text/part0016.html.page_337" class="calibre3">337</a></p>
<p class="index">cosine function, <a href="#text/part0004.html.page_ix" class="calibre3">ix</a></p>
<p class="index"><span class="font">cp</span> cartesian product, <a href="#text/part0009.html.page_92" class="calibre3">92</a>, <a href="#text/part0009.html.page_93" class="calibre3">93</a>, <a href="#text/part0009.html.page_97" class="calibre3">97</a>, <a href="#text/part0010.html.page_131" class="calibre3">131</a>, <a href="#text/part0011.html.page_155" class="calibre3">155</a>, <a href="#text/part0014.html.page_244" class="calibre3">244</a>, <a href="#text/part0016.html.page_320" class="calibre3">320</a></p>
<p class="index"><span class="font">cross</span>, <a href="#text/part0008.html.page_81" class="calibre3">81</a>, <a href="#text/part0016.html.page_301" class="calibre3">301</a></p>
<p class="index"><span class="font">curry</span>, <a href="#text/part0008.html.page_86" class="calibre3">86</a>, <a href="#text/part0010.html.page_135" class="calibre3">135</a></p>
<p class="index">Curry, H.B, <a href="#text/part0008.html.page_87" class="calibre3">87</a></p>
<p class="index"><span class="font">cycle</span>, <a href="#text/part0013.html.page_232" class="calibre3">232</a></p>
<p class="index">cyclic lists, <a href="#text/part0013.html.page_212" class="calibre3">212</a></p>
<p class="indextitle">data constructors, <a href="#text/part0006.html.page_25" class="calibre3">25</a>, <a href="#text/part0007.html.page_56" class="calibre3">56</a></p>
<p class="index">data type declarations, <a href="#text/part0006.html.page_30" class="calibre3">30</a>, <a href="#text/part0007.html.page_56" class="calibre3">56</a>, <a href="#text/part0012.html.page_189" class="calibre3">189</a>, <a href="#text/part0012.html.page_194" class="calibre3">194</a>, <a href="#text/part0012.html.page_202" class="calibre3">202</a>, <a href="#text/part0013.html.page_229" class="calibre3">229</a></p>
<p class="index"><span class="font">Data.Array</span>, <a href="#text/part0014.html.page_259" class="calibre3">259</a></p>
<p class="index"><span class="font">Data.Char</span>, <a href="#text/part0005.html.page_13" class="calibre3">13</a>, <a href="#text/part0006.html.page_42" class="calibre3">42</a>, <a href="#text/part0013.html.page_227" class="calibre3">227</a>, <a href="#text/part0015.html.page_283" class="calibre3">283</a></p>
<p class="index"><span class="font">Data.Complex</span>, <a href="#text/part0007.html.page_49" class="calibre3">49</a></p>
<p class="index"><span class="font">Data.List</span>, <a href="#text/part0008.html.page_75" class="calibre3">75</a>, <a href="#text/part0009.html.page_106" class="calibre3">106</a>, <a href="#text/part0010.html.page_125" class="calibre3">125</a>, <a href="#text/part0011.html.page_154" class="calibre3">154</a>, <a href="#text/part0016.html.page_311" class="calibre3">311</a></p>
<p class="index"><span class="font">Data.Maybe</span>, <a href="#text/part0016.html.page_319" class="calibre3">319</a></p>
<p class="index"><span class="font">Data.STRef</span>, <a href="#text/part0014.html.page_251" class="calibre3">251</a></p>
<p class="index">de Moor, O., <a href="#text/part0008.html.page_87" class="calibre3">87</a></p>
<p class="index">deep embeddings, <a href="#text/part0012.html.page_194" class="calibre3">194</a></p>
<p class="index">default definitions, <a href="#text/part0006.html.page_31" class="calibre3">31</a></p>
<p class="index">dependently-typed languages, <a href="#text/part0006.html.page_48" class="calibre3">48</a>, <a href="#text/part0009.html.page_90" class="calibre3">90</a></p>
<p class="index"><span class="font">deriving</span> clauses, <a href="#text/part0006.html.page_39" class="calibre3">39</a>, <a href="#text/part0007.html.page_57" class="calibre3">57</a></p>
<p class="index">directed graphs, <a href="#text/part0014.html.page_260" class="calibre3">260</a></p>
<p class="index">distributive operations, <a href="#text/part0010.html.page_130" class="calibre3">130</a></p>
<p class="index"><span class="font">div</span>, <a href="#text/part0005.html.page_9" class="calibre3">9</a>, <a href="#text/part0006.html.page_24" class="calibre3">24</a>, <a href="#text/part0007.html.page_59" class="calibre3">59</a></p>
<p class="index">divide and conquer algorithm, <a href="#text/part0006.html.page_46" class="calibre3">46</a>, <a href="#text/part0008.html.page_76" class="calibre3">76</a></p>
<p class="index"><span class="font">divMod</span>, <a href="#text/part0007.html.page_51" class="calibre3">51</a></p>
<p class="index"><span class="font">do</span>-notation, <a href="#text/part0006.html.page_34" class="calibre3">34</a>, <a href="#text/part0006.html.page_36" class="calibre3">36</a>, <a href="#text/part0014.html.page_239" class="calibre3">239</a>, <a href="#text/part0014.html.page_242" class="calibre3">242</a>, <a href="#text/part0014.html.page_245" class="calibre3">245</a></p>
<p class="index"><span class="font">done</span>, <a href="#text/part0014.html.page_240" class="calibre3">240</a></p>
<p class="index" id="text/part0017.html.link24"><span class="font">Double</span>, <a href="#text/part0007.html.page_49" class="calibre3">49</a></p>
<p class="index"><span class="font">drop</span>, <a href="#text/part0008.html.page_79" class="calibre3">79</a></p>
<p class="index"><span class="font">dropWhile</span>, <a href="#text/part0009.html.page_106" class="calibre3">106</a></p>
<p class="indextitle"><span class="font">e</span>, <a href="#text/part0010.html.page_141" class="calibre3">141</a></p>
<p class="index">echoing, <a href="#text/part0014.html.page_241" class="calibre3">241</a></p>
<p class="index">efficiency, <a href="#text/part0004.html.page_ix" class="calibre3">ix</a>, <a href="#text/part0011.html.page_145" class="calibre3">145</a></p>
<p class="index"><span class="font">Either</span>, <a href="#text/part0008.html.page_82" class="calibre3">82</a>, <a href="#text/part0010.html.page_132" class="calibre3">132</a></p>
<p class="index"><span class="font">either</span>, <a href="#text/part0010.html.page_132" class="calibre3">132</a></p>
<p class="index"><span class="font">else</span>, <a href="#text/part0005.html.page_12" class="calibre3">12</a></p>
<p class="index">embedded domain-specific language, <a href="#text/part0012.html.page_209" class="calibre3">209</a></p>
<p class="index">empty list, <i class="calibre1">see</i> <a href="#text/part0017.html.link8" class="calibre3"><span class="font">[]</span></a></p>
<p class="index"><span class="font">Enum</span>, <a href="#text/part0008.html.page_65" class="calibre3">65</a>, <a href="#text/part0009.html.page_90" class="calibre3">90</a>, <a href="#text/part0013.html.page_211" class="calibre3">211</a></p>
<p class="index">enumerations, <a href="#text/part0008.html.page_65" class="calibre3">65</a>, <a href="#text/part0013.html.page_210" class="calibre3">210</a>, <a href="#text/part0013.html.page_217" class="calibre3">217</a></p>
<p class="index"><span class="font">enumFrom</span>, <a href="#text/part0013.html.page_211" class="calibre3">211</a></p>
<p class="index"><span class="font">Eq</span>, <a href="#text/part0006.html.page_31" class="calibre3">31</a>, <a href="#text/part0007.html.page_56" class="calibre3">56</a></p>
<p class="index">equality operations, <a href="#text/part0006.html.page_31" class="calibre3">31</a></p>
<p class="index">equational reasoning, <a href="#text/part0004.html.page_ix" class="calibre3">ix</a>, <a href="#text/part0005.html.page_1" class="calibre3">1</a>, <a href="#text/part0008.html.page_73" class="calibre3">73</a>, <a href="#text/part0008.html.page_81" class="calibre3">81</a>, <a href="#text/part0009.html.page_89" class="calibre3">89</a>, <a href="#text/part0009.html.page_96" class="calibre3">96</a>, <a href="#text/part0009.html.page_99" class="calibre3">99</a>, <a href="#text/part0010.html.page_110" class="calibre3">110</a>, <a href="#text/part0010.html.page_135" class="calibre3">135</a>, <a href="#text/part0016.html.page_298" class="calibre3">298</a></p>
<p class="index"><span class="font">error</span>, <a href="#text/part0006.html.page_36" class="calibre3">36</a>, <a href="#text/part0006.html.page_39" class="calibre3">39</a>, <a href="#text/part0011.html.page_179" class="calibre3">179</a></p>
<p class="index">error messages, <a href="#text/part0006.html.page_23" class="calibre3">23</a>, <a href="#text/part0006.html.page_24" class="calibre3">24</a>, <a href="#text/part0006.html.page_39" class="calibre3">39</a>, <a href="#text/part0006.html.page_43" class="calibre3">43</a>, <a href="#text/part0009.html.page_103" class="calibre3">103</a>, <a href="#text/part0011.html.page_151" class="calibre3">151</a>, <a href="#text/part0012.html.page_192" class="calibre3">192</a>, <a href="#text/part0014.html.page_250" class="calibre3">250</a>, <a href="#text/part0015.html.page_279" class="calibre3">279</a></p>
<p class="index" id="text/part0017.html.link17">evaluation</p>
<p class="index1">eager, <a href="#text/part0006.html.page_28" class="calibre3">28</a>, <a href="#text/part0011.html.page_154" class="calibre3">154</a>, <a href="#text/part0011.html.page_157" class="calibre3">157</a></p>
<p class="index1">innermost, <a href="#text/part0006.html.page_28" class="calibre3">28</a></p>
<p class="index1">lazy, <a href="#text/part0006.html.page_28" class="calibre3">28</a>, <a href="#text/part0008.html.page_75" class="calibre3">75</a>, <a href="#text/part0008.html.page_80" class="calibre3">80</a>, <a href="#text/part0009.html.page_89" class="calibre3">89</a>, <a href="#text/part0011.html.page_145" class="calibre3">145</a>, <a href="#text/part0011.html.page_154" class="calibre3">154</a>, <a href="#text/part0011.html.page_175" class="calibre3">175</a>, <a href="#text/part0012.html.page_198" class="calibre3">198</a>, <a href="#text/part0014.html.page_243" class="calibre3">243</a></p>
<p class="index1">outermost, <a href="#text/part0006.html.page_28" class="calibre3">28</a></p>
<p class="index1">to normal form, <a href="#text/part0006.html.page_22" class="calibre3">22</a>, <a href="#text/part0006.html.page_27" class="calibre3">27</a>, <a href="#text/part0011.html.page_146" class="calibre3">146</a>, <a href="#text/part0011.html.page_156" class="calibre3">156</a></p>
<p class="index">exception handling, <a href="#text/part0014.html.page_239" class="calibre3">239</a></p>
<p class="index"><span class="font">exp</span>, <a href="#text/part0006.html.page_40" class="calibre3">40</a>, <a href="#text/part0010.html.page_110" class="calibre3">110</a>, <a href="#text/part0010.html.page_141" class="calibre3">141</a></p>
<p class="index">explicit layout, <a href="#text/part0014.html.page_242" class="calibre3">242</a></p>
<p class="index">exponentiation, <a href="#text/part0006.html.page_40" class="calibre3">40</a>, <a href="#text/part0007.html.page_59" class="calibre3">59</a>, <a href="#text/part0010.html.page_110" class="calibre3">110</a></p>
<p class="index">export declarations, <i class="calibre1">see</i> <a href="#text/part0017.html.link9" class="calibre3">modules</a></p>
<p class="index" id="text/part0017.html.link7">expressions</p>
<p class="index1">case, <a href="#text/part0010.html.page_127" class="calibre3">127</a>, <a href="#text/part0014.html.page_245" class="calibre3">245</a></p>
<p class="index1">conditional, <a href="#text/part0005.html.page_12" class="calibre3">12</a>, <a href="#text/part0006.html.page_23" class="calibre3">23</a>, <a href="#text/part0012.html.page_181" class="calibre3">181</a></p>
<p class="index1">lambda, <a href="#text/part0006.html.page_26" class="calibre3">26</a>, <a href="#text/part0011.html.page_148" class="calibre3">148</a>, <a href="#text/part0014.html.page_242" class="calibre3">242</a></p>
<p class="index1">let, <a href="#text/part0006.html.page_24" class="calibre3">24</a>, <a href="#text/part0011.html.page_146" class="calibre3">146</a>, <a href="#text/part0011.html.page_147" class="calibre3">147</a>, <a href="#text/part0014.html.page_248" class="calibre3">248</a></p>
<p class="index1">well-formed, <a href="#text/part0006.html.page_22" class="calibre3">22</a></p>
<p class="indextitle">factorial function, <a href="#text/part0006.html.page_28" class="calibre3">28</a>, <a href="#text/part0013.html.page_220" class="calibre3">220</a></p>
<p class="index">factoring parsers, <a href="#text/part0015.html.page_282" class="calibre3">282</a></p>
<p class="index">failure, <a href="#text/part0006.html.page_39" class="calibre3">39</a></p>
<p class="index">Feijen, W., <a href="#text/part0004.html.page_xi" class="calibre3">xi</a></p>
<p class="index">Fibonacci function, <a href="#text/part0011.html.page_164" class="calibre3">164</a>, <a href="#text/part0013.html.page_232" class="calibre3">232</a>, <a href="#text/part0014.html.page_251" class="calibre3">251</a>, <a href="#text/part0014.html.page_266" class="calibre3">266</a></p>
<p class="index"><span class="font">FilePath</span>, <a href="#text/part0006.html.page_34" class="calibre3">34</a></p>
<p class="index"><span class="font">filter</span>, <a href="#text/part0006.html.page_38" class="calibre3">38</a>, <a href="#text/part0008.html.page_67" class="calibre3">67</a>, <a href="#text/part0008.html.page_70" class="calibre3">70</a>, <a href="#text/part0008.html.page_72" class="calibre3">72</a>, <a href="#text/part0009.html.page_97" class="calibre3">97</a>, <a href="#text/part0009.html.page_98" class="calibre3">98</a>, <a href="#text/part0010.html.page_119" class="calibre3">119</a>, <a href="#text/part0010.html.page_134" class="calibre3">134</a>, <a href="#text/part0016.html.page_299" class="calibre3">299</a></p>
<p class="index">flat ordering, <a href="#text/part0013.html.page_217" class="calibre3">217</a></p>
<p class="index"><span class="font">flip</span>, <a href="#text/part0007.html.page_59" class="calibre3">59</a>, <a href="#text/part0010.html.page_123" class="calibre3">123</a>, <a href="#text/part0011.html.page_148" class="calibre3">148</a></p>
<p class="index" id="text/part0017.html.link23"><span class="font">Float</span>, <a href="#text/part0005.html.page_2" class="calibre3">2</a>, <a href="#text/part0006.html.page_30" class="calibre3">30</a>, <a href="#text/part0007.html.page_49" class="calibre3">49</a></p>
<p class="index"><span class="font">Floating</span>, <a href="#text/part0007.html.page_52" class="calibre3">52</a></p>
<p class="index">floating-point literal, <a href="#text/part0007.html.page_51" class="calibre3">51</a></p>
<p class="index">floating-point numbers, <a href="#text/part0010.html.page_112" class="calibre3">112</a>, <a href="#text/part0015.html.page_293" class="calibre3">293</a></p>
<p class="index"><span class="font">floor</span>, <a href="#text/part0006.html.page_46" class="calibre3">46</a>, <a href="#text/part0007.html.page_52" class="calibre3">52</a>, <a href="#text/part0007.html.page_60" class="calibre3">60</a></p>
<p class="index"><span class="font">fmap</span>, <a href="#text/part0008.html.page_71" class="calibre3">71</a></p>
<p class="index"><span class="font">foldl</span>, <a href="#text/part0010.html.page_122" class="calibre3">122</a>, <a href="#text/part0011.html.page_150" class="calibre3">150</a>, <a href="#text/part0011.html.page_152" class="calibre3">152</a>, <a href="#text/part0014.html.page_260" class="calibre3">260</a></p>
<p class="index"><span class="font">foldl'</span>, <a href="#text/part0011.html.page_150" class="calibre3">150</a>, <a href="#text/part0011.html.page_152" class="calibre3">152</a></p>
<p class="index"><span class="font">foldl1</span>, <a href="#text/part0013.html.page_231" class="calibre3">231</a></p>
<p class="index"><span class="font">foldr</span>, <a href="#text/part0010.html.page_117" class="calibre3">117</a>, <a href="#text/part0011.html.page_152" class="calibre3">152</a>, <a href="#text/part0011.html.page_164" class="calibre3">164</a></p>
<p class="index"><span class="font">foldr1</span>, <a href="#text/part0010.html.page_121" class="calibre3">121</a>, <a href="#text/part0013.html.page_231" class="calibre3">231</a></p>
<p class="index"><span class="font">forall</span>, <a href="#text/part0014.html.page_253" class="calibre3">253</a></p>
<p class="index"><span class="font">fork</span>, <a href="#text/part0008.html.page_81" class="calibre3">81</a>, <a href="#text/part0010.html.page_134" class="calibre3">134</a>, <a href="#text/part0016.html.page_301" class="calibre3">301</a></p>
<p class="index"><span class="font">Fractional</span>, <a href="#text/part0007.html.page_50" class="calibre3">50</a></p>
<p class="index"><span class="font">fromInteger</span>, <a href="#text/part0007.html.page_50" class="calibre3">50</a>, <a href="#text/part0008.html.page_67" class="calibre3">67</a>, <a href="#text/part0011.html.page_151" class="calibre3">151</a></p>
<p class="index"><span class="font">fromIntegral</span>, <a href="#text/part0007.html.page_51" class="calibre3">51</a>, <a href="#text/part0008.html.page_67" class="calibre3">67</a>, <a href="#text/part0011.html.page_151" class="calibre3">151</a></p>
<p class="index"><span class="font">fromJust</span>, <a href="#text/part0016.html.page_319" class="calibre3">319</a></p>
<p class="index"><span class="font">fst</span>, <a href="#text/part0006.html.page_28" class="calibre3">28</a>, <a href="#text/part0007.html.page_51" class="calibre3">51</a></p>
<p class="index">function, <a href="#text/part0005.html.page_1" class="calibre3">1</a></p>
<p class="index1">application, <a href="#text/part0005.html.page_2" class="calibre3">2</a>, <a href="#text/part0005.html.page_4" class="calibre3">4</a>, <a href="#text/part0005.html.page_14" class="calibre3">14</a></p>
<p class="index1">arguments, <a href="#text/part0005.html.page_1" class="calibre3">1</a>, <a href="#text/part0005.html.page_3" class="calibre3">3</a></p>
<p class="index1">composition, <i class="calibre1">see</i> <a href="#text/part0017.html.link10" class="calibre3"><span class="font">(.)</span></a></p>
<p class="index1">computable, <a href="#text/part0013.html.page_219" class="calibre3">219</a></p>
<p class="index1">continuous, <a href="#text/part0013.html.page_219" class="calibre3">219</a></p>
<p class="index1">conversion, <a href="#text/part0007.html.page_50" class="calibre3">50</a></p>
<p class="index1">higher-order, <a href="#text/part0010.html.page_110" class="calibre3">110</a></p>
<p class="index1">identity, <i class="calibre1">see</i> <a href="#text/part0017.html.link11" class="calibre3"><span class="font">id</span></a></p>
<p class="index1">monotonic, <a href="#text/part0013.html.page_219" class="calibre3">219</a></p>
<p class="index1">non-strict, <a href="#text/part0006.html.page_29" class="calibre3">29</a>, <a href="#text/part0007.html.page_58" class="calibre3">58</a></p>
<p class="index1">overloaded, <a href="#text/part0006.html.page_31" class="calibre3">31</a></p>
<p class="index1">partial, <a href="#text/part0005.html.page_9" class="calibre3">9</a></p>
<p class="index1">polymorphic, <a href="#text/part0006.html.page_31" class="calibre3">31</a>, <a href="#text/part0008.html.page_72" class="calibre3">72</a></p>
<p class="index1">primitive, <a href="#text/part0011.html.page_150" class="calibre3">150</a></p>
<p class="index1">recursive, <a href="#text/part0005.html.page_17" class="calibre3">17</a>, <a href="#text/part0013.html.page_219" class="calibre3">219</a></p>
<p class="index1">results, <a href="#text/part0005.html.page_1" class="calibre3">1</a>, <a href="#text/part0005.html.page_3" class="calibre3">3</a></p>
<p class="index1">strict, <a href="#text/part0006.html.page_29" class="calibre3">29</a>, <a href="#text/part0007.html.page_59" class="calibre3">59</a>, <a href="#text/part0008.html.page_72" class="calibre3">72</a>, <a href="#text/part0010.html.page_120" class="calibre3">120</a>, <a href="#text/part0010.html.page_137" class="calibre3">137</a>, <a href="#text/part0011.html.page_150" class="calibre3">150</a>, <a href="#text/part0011.html.page_154" class="calibre3">154</a></p>
<p class="index1">type, <i class="calibre1">see</i> <a href="#text/part0017.html.link12" class="calibre3"><span class="font">-&gt;</span></a></p>
<p class="index1">values, <a href="#text/part0011.html.page_145" class="calibre3">145</a></p>
<p class="index"><span class="font">Functor</span>, <a href="#text/part0008.html.page_71" class="calibre3">71</a>, <a href="#text/part0014.html.page_264" class="calibre3">264</a></p>
<p class="index">functors, <a href="#text/part0008.html.page_87" class="calibre3">87</a>, <a href="#text/part0014.html.page_264" class="calibre3">264</a></p>
<p class="indextitle"><span class="font">getChar</span>, <a href="#text/part0014.html.page_240" class="calibre3">240</a></p>
<p class="index"><span class="font">getLine</span>, <a href="#text/part0014.html.page_241" class="calibre3">241</a></p>
<p class="index">GHC, <a href="#text/part0006.html.page_35" class="calibre3">35</a>, <a href="#text/part0006.html.page_36" class="calibre3">36</a>, <a href="#text/part0011.html.page_154" class="calibre3">154</a>, <a href="#text/part0011.html.page_169" class="calibre3">169</a>, <a href="#text/part0014.html.page_275" class="calibre3">275</a></p>
<p class="index">GHCi, <a href="#text/part0005.html.page_12" class="calibre3">12</a>, <a href="#text/part0006.html.page_22" class="calibre3">22</a>, <a href="#text/part0006.html.page_36" class="calibre3">36</a>, <a href="#text/part0011.html.page_154" class="calibre3">154</a></p>
<p class="index">Gibbons, J., <a href="#text/part0012.html.page_209" class="calibre3">209</a>, <a href="#text/part0014.html.page_275" class="calibre3">275</a></p>
<p class="index">global definition, <i class="calibre1">see</i> <a href="#text/part0017.html.link13" class="calibre3">top-level definition</a></p>
<p class="index">Goerzen, J., <a href="#text/part0005.html.page_21" class="calibre3">21</a></p>
<p class="index">Gofer, <a href="#text/part0004.html.page_x" class="calibre3">x</a>, <a href="#text/part0014.html.page_275" class="calibre3">275</a></p>
<p class="index">golden ratio, <a href="#text/part0011.html.page_164" class="calibre3">164</a></p>
<p class="index">Graham, R., <a href="#text/part0007.html.page_62" class="calibre3">62</a></p>
<p class="index">grammars, <a href="#text/part0015.html.page_286" class="calibre3">286</a></p>
<p class="index">greedy algorithms, <a href="#text/part0012.html.page_192" class="calibre3">192</a></p>
<p class="index"><span class="font">guard</span>, <a href="#text/part0016.html.page_306" class="calibre3">306</a></p>
<p class="index">guarded equations, <a href="#text/part0005.html.page_9" class="calibre3">9</a>, <a href="#text/part0005.html.page_12" class="calibre3">12</a>, <a href="#text/part0016.html.page_332" class="calibre3">332</a></p>
<p class="index">guards, <a href="#text/part0005.html.page_10" class="calibre3">10</a></p>
<p class="index">Hamming, W.R., <a href="#text/part0013.html.page_232" class="calibre3">232</a></p>
<p class="index">Hangman, <a href="#text/part0014.html.page_266" class="calibre3">266</a></p>
<p class="index">Hardy, G.H., <a href="#text/part0008.html.page_78" class="calibre3">78</a></p>
<p class="index">Harper, B., <a href="#text/part0006.html.page_47" class="calibre3">47</a></p>
<p class="index">hash tables, <a href="#text/part0014.html.page_256" class="calibre3">256</a></p>
<p class="index">Haskell, <a href="#text/part0004.html.page_x" class="calibre3">x</a>, <a href="#text/part0005.html.page_1" class="calibre3">1</a></p>
<p class="index1">1998 online report, <a href="#text/part0005.html.page_21" class="calibre3">21</a></p>
<p class="index1">2010 online report, <a href="#text/part0005.html.page_21" class="calibre3">21</a>, <a href="#text/part0010.html.page_111" class="calibre3">111</a></p>
<p class="index1">commands, <a href="#text/part0005.html.page_1" class="calibre3">1</a>, <a href="#text/part0006.html.page_33" class="calibre3">33</a>, <a href="#text/part0006.html.page_34" class="calibre3">34</a>, <a href="#text/part0014.html.page_239" class="calibre3">239</a></p>
<p class="index1">layout, <a href="#text/part0006.html.page_36" class="calibre3">36</a></p>
<p class="index1">libraries, <a href="#text/part0005.html.page_7" class="calibre3">7</a>, <a href="#text/part0012.html.page_181" class="calibre3">181</a></p>
<p class="index1">numbers, <a href="#text/part0005.html.page_2" class="calibre3">2</a>, <a href="#text/part0010.html.page_112" class="calibre3">112</a></p>
<p class="index1">Platform, <a href="#text/part0005.html.page_12" class="calibre3">12</a>, <a href="#text/part0011.html.page_154" class="calibre3">154</a></p>
<p class="index1">reserved words, <a href="#text/part0005.html.page_12" class="calibre3">12</a></p>
<p class="index1">standard prelude, <i class="calibre1">see</i> <a href="#text/part0017.html.link14" class="calibre3">standard prelude</a></p>
<p class="index1">syntax, <a href="#text/part0006.html.page_22" class="calibre3">22</a></p>
<p class="index1">values, <a href="#text/part0006.html.page_22" class="calibre3">22</a></p>
<p class="index1">well-formed literals, <a href="#text/part0010.html.page_122" class="calibre3">122</a></p>
<p class="index"><span class="font">head</span>, <a href="#text/part0006.html.page_38" class="calibre3">38</a>, <a href="#text/part0008.html.page_68" class="calibre3">68</a>, <a href="#text/part0008.html.page_72" class="calibre3">72</a></p>
<p class="index">head normal form, <a href="#text/part0011.html.page_146" class="calibre3">146</a>, <a href="#text/part0011.html.page_157" class="calibre3">157</a>, <a href="#text/part0011.html.page_172" class="calibre3">172</a></p>
<p class="index">helper functions, <a href="#text/part0006.html.page_26" class="calibre3">26</a></p>
<p class="index">Hinze, R., <a href="#text/part0014.html.page_275" class="calibre3">275</a></p>
<p class="index"><i class="calibre1">History of Haskell</i>, <a href="#text/part0005.html.page_20" class="calibre3">20</a></p>
<p class="index">homomorphisms, <i class="calibre1">see</i> <a href="#text/part0017.html.link15" class="calibre3">laws</a></p>
<p class="index">Hughes, J., <a href="#text/part0012.html.page_209" class="calibre3">209</a></p>
<p class="index">Hutton, G., <a href="#text/part0005.html.page_21" class="calibre3">21</a>, <a href="#text/part0015.html.page_297" class="calibre3">297</a></p>
<p class="indextitle" id="text/part0017.html.link11"><span class="font">id</span>, <a href="#text/part0005.html.page_18" class="calibre3">18</a>, <a href="#text/part0008.html.page_70" class="calibre3">70</a>, <a href="#text/part0008.html.page_71" class="calibre3">71</a>, <a href="#text/part0009.html.page_94" class="calibre3">94</a>, <a href="#text/part0009.html.page_96" class="calibre3">96</a>, <a href="#text/part0014.html.page_253" class="calibre3">253</a></p>
<p class="index">idempotence, <a href="#text/part0012.html.page_205" class="calibre3">205</a>, <i class="calibre1">see</i> <a href="#text/part0017.html.link15" class="calibre3">laws</a></p>
<p class="index">identities, <i class="calibre1">see</i> <a href="#text/part0017.html.link15" class="calibre3">laws</a></p>
<p class="index">identity elements, <a href="#text/part0005.html.page_15" class="calibre3">15</a>, <a href="#text/part0009.html.page_96" class="calibre3">96</a>, <a href="#text/part0012.html.page_184" class="calibre3">184</a>, <a href="#text/part0014.html.page_247" class="calibre3">247</a>, <a href="#text/part0015.html.page_281" class="calibre3">281</a></p>
<p class="index">identity function, <i class="calibre1">see</i> <a href="#text/part0017.html.link11" class="calibre3"><span class="font">id</span></a></p>
<p class="index"><span class="font">if</span>, <a href="#text/part0005.html.page_12" class="calibre3">12</a></p>
<p class="index">imperative languages, <a href="#text/part0004.html.page_x" class="calibre3">x</a></p>
<p class="index">import declarations, <i class="calibre1">see</i> <a href="#text/part0017.html.link9" class="calibre3">modules</a></p>
<p class="index">in-place algorithms, <a href="#text/part0011.html.page_170" class="calibre3">170</a>, <a href="#text/part0014.html.page_254" class="calibre3">254</a></p>
<p class="index">indexitis, <a href="#text/part0009.html.page_95" class="calibre3">95</a></p>
<p class="index" id="text/part0017.html.link3">induction, <a href="#text/part0010.html.page_110" class="calibre3">110</a>, <a href="#text/part0010.html.page_111" class="calibre3">111</a></p>
<p class="index1">base case, <a href="#text/part0008.html.page_77" class="calibre3">77</a>, <a href="#text/part0010.html.page_111" class="calibre3">111</a></p>
<p class="index1">general, <a href="#text/part0011.html.page_179" class="calibre3">179</a></p>
<p class="index1">inductive case, <a href="#text/part0008.html.page_77" class="calibre3">77</a>, <a href="#text/part0010.html.page_111" class="calibre3">111</a></p>
<p class="index1">over lists, <a href="#text/part0010.html.page_113" class="calibre3">113</a></p>
<p class="index1">over numbers, <a href="#text/part0010.html.page_110" class="calibre3">110</a></p>
<p class="index1">pre-packaged, <a href="#text/part0010.html.page_120" class="calibre3">120</a></p>
<p class="index">inductive cases, <i class="calibre1">see</i> <a href="#text/part0017.html.link3" class="calibre3">induction</a></p>
<p class="index">infinite loops, <a href="#text/part0006.html.page_24" class="calibre3">24</a>, <a href="#text/part0006.html.page_28" class="calibre3">28</a>, <a href="#text/part0006.html.page_30" class="calibre3">30</a>, <a href="#text/part0008.html.page_77" class="calibre3">77</a>, <a href="#text/part0010.html.page_124" class="calibre3">124</a>, <a href="#text/part0013.html.page_211" class="calibre3">211</a></p>
<p class="index">infix data constructors, <a href="#text/part0012.html.page_194" class="calibre3">194</a></p>
<p class="index">infix operations, <a href="#text/part0005.html.page_9" class="calibre3">9</a></p>
<p class="index"><span class="font">infixr</span> fixity declaration, <a href="#text/part0011.html.page_153" class="calibre3">153</a></p>
<p class="index"><span class="font">inits</span>, <a href="#text/part0010.html.page_125" class="calibre3">125</a></p>
<p class="index">inlining, <a href="#text/part0007.html.page_54" class="calibre3">54</a></p>
<p class="index">insertion sort, <i class="calibre1">see</i> <a href="#text/part0017.html.link16" class="calibre3">sorting</a></p>
<p class="index"><span class="font">instance</span> declarations, <a href="#text/part0006.html.page_32" class="calibre3">32</a></p>
<p class="index" id="text/part0017.html.link25"><span class="font">Int</span>, <a href="#text/part0005.html.page_2" class="calibre3">2</a>, <a href="#text/part0006.html.page_30" class="calibre3">30</a>, <a href="#text/part0007.html.page_49" class="calibre3">49</a>, <a href="#text/part0011.html.page_155" class="calibre3">155</a>, <a href="#text/part0014.html.page_254" class="calibre3">254</a></p>
<p class="index" id="text/part0017.html.link26"><span class="font">Integer</span>, <a href="#text/part0005.html.page_2" class="calibre3">2</a>, <a href="#text/part0007.html.page_49" class="calibre3">49</a>, <a href="#text/part0011.html.page_155" class="calibre3">155</a></p>
<p class="index">integer literals, <a href="#text/part0007.html.page_50" class="calibre3">50</a></p>
<p class="index"><span class="font">Integral</span>, <a href="#text/part0007.html.page_51" class="calibre3">51</a>, <a href="#text/part0011.html.page_155" class="calibre3">155</a></p>
<p class="index"><span class="font">interact</span>, <a href="#text/part0013.html.page_227" class="calibre3">227</a></p>
<p class="index">interaction, <a href="#text/part0013.html.page_221" class="calibre3">221</a></p>
<p class="index">interactive programs, <a href="#text/part0013.html.page_227" class="calibre3">227</a></p>
<p class="index">interpreters, <a href="#text/part0006.html.page_36" class="calibre3">36</a></p>
<p class="index">involutions, <i class="calibre1">see</i> <a href="#text/part0017.html.link15" class="calibre3">laws</a></p>
<p class="index"><span class="font">IO</span>, <a href="#text/part0006.html.page_33" class="calibre3">33</a>, <a href="#text/part0014.html.page_239" class="calibre3">239</a></p>
<p class="index"><span class="font">isAlpha</span>, <a href="#text/part0006.html.page_42" class="calibre3">42</a></p>
<p class="index"><span class="font">isSpace</span>, <a href="#text/part0015.html.page_283" class="calibre3">283</a></p>
<p class="index"><span class="font">it</span>, <a href="#text/part0013.html.page_229" class="calibre3">229</a></p>
<p class="index"><span class="font">iterate</span>, <a href="#text/part0008.html.page_64" class="calibre3">64</a>, <a href="#text/part0013.html.page_213" class="calibre3">213</a>, <a href="#text/part0016.html.page_301" class="calibre3">301</a></p>
<p class="index"><span class="font">Ix</span>, <a href="#text/part0014.html.page_254" class="calibre3">254</a>, <a href="#text/part0014.html.page_255" class="calibre3">255</a></p>
<p class="indextitle">Jeuring, J., <a href="#text/part0012.html.page_209" class="calibre3">209</a></p>
<p class="index"><span class="font">join</span>, <a href="#text/part0014.html.page_264" class="calibre3">264</a></p>
<p class="index">Jones, M., <a href="#text/part0010.html.page_144" class="calibre3">144</a>, <a href="#text/part0014.html.page_275" class="calibre3">275</a></p>
<p class="index"><span class="font">Just</span>, <a href="#text/part0014.html.page_244" class="calibre3">244</a></p>
<p class="indextitle">Knuth, D.E., <a href="#text/part0005.html.page_21" class="calibre3">21</a>, <a href="#text/part0007.html.page_62" class="calibre3">62</a>, <a href="#text/part0011.html.page_167" class="calibre3">167</a></p>
<p class="index">KRC, <a href="#text/part0004.html.page_x" class="calibre3">x</a></p>
<p class="indextitle">Lapalme, G., <a href="#text/part0011.html.page_180" class="calibre3">180</a></p>
<p class="index"><span class="font">last</span>, <a href="#text/part0008.html.page_68" class="calibre3">68</a></p>
<p class="index">Launchbury, J., <a href="#text/part0014.html.page_275" class="calibre3">275</a></p>
<p class="index" id="text/part0017.html.link15">laws</p>
<p class="index1">arithmetic, <a href="#text/part0005.html.page_17" class="calibre3">17</a></p>
<p class="index1">bifunctor, <a href="#text/part0016.html.page_302" class="calibre3">302</a></p>
<p class="index1">commutative, <a href="#text/part0012.html.page_186" class="calibre3">186</a></p>
<p class="index1">distributive, <a href="#text/part0012.html.page_186" class="calibre3">186</a></p>
<p class="index1">equational, <a href="#text/part0004.html.page_ix" class="calibre3">ix</a></p>
<p class="index1">functor, <a href="#text/part0008.html.page_71" class="calibre3">71</a>, <a href="#text/part0008.html.page_81" class="calibre3">81</a>, <a href="#text/part0016.html.page_303" class="calibre3">303</a>, <a href="#text/part0016.html.page_330" class="calibre3">330</a></p>
<p class="index1">fusion, <a href="#text/part0010.html.page_120" class="calibre3">120</a>, <a href="#text/part0010.html.page_131" class="calibre3">131</a>, <a href="#text/part0011.html.page_176" class="calibre3">176</a></p>
<p class="index1">homomorphisms, <a href="#text/part0012.html.page_185" class="calibre3">185</a>, <a href="#text/part0012.html.page_186" class="calibre3">186</a></p>
<p class="index1">idempotence, <a href="#text/part0012.html.page_204" class="calibre3">204</a></p>
<p class="index1">identities, <a href="#text/part0004.html.page_ix" class="calibre3">ix</a>, <a href="#text/part0010.html.page_110" class="calibre3">110</a></p>
<p class="index1">involutions, <a href="#text/part0009.html.page_96" class="calibre3">96</a>, <a href="#text/part0010.html.page_113" class="calibre3">113</a></p>
<p class="index1">leapfrog, <a href="#text/part0014.html.page_247" class="calibre3">247</a>, <a href="#text/part0014.html.page_265" class="calibre3">265</a></p>
<p class="index1">left-distributive, <a href="#text/part0015.html.page_293" class="calibre3">293</a></p>
<p class="index1">left-zero, <a href="#text/part0015.html.page_293" class="calibre3">293</a></p>
<p class="index1">monad laws, <a href="#text/part0014.html.page_246" class="calibre3">246</a>, <a href="#text/part0015.html.page_279" class="calibre3">279</a></p>
<p class="index1">naturality, <a href="#text/part0008.html.page_72" class="calibre3">72</a>, <a href="#text/part0008.html.page_87" class="calibre3">87</a>, <a href="#text/part0009.html.page_97" class="calibre3">97</a></p>
<p class="index1">point-free, <a href="#text/part0010.html.page_110" class="calibre3">110</a></p>
<p class="index1">right-zero, <a href="#text/part0015.html.page_293" class="calibre3">293</a></p>
<p class="index1">trigonometric, <a href="#text/part0004.html.page_ix" class="calibre3">ix</a></p>
<p class="index1">tupling, <a href="#text/part0011.html.page_152" class="calibre3">152</a>, <a href="#text/part0011.html.page_165" class="calibre3">165</a></p>
<p class="index">layout description language, <a href="#text/part0012.html.page_182" class="calibre3">182</a></p>
<p class="index">lazy evaluation, <i class="calibre1">see</i> <a href="#text/part0017.html.link17" class="calibre3">evaluation</a></p>
<p class="index">least fixed points, <a href="#text/part0013.html.page_220" class="calibre3">220</a></p>
<p class="index">least upper bounds, <a href="#text/part0013.html.page_218" class="calibre3">218</a></p>
<p class="index">left-recursion problem, <a href="#text/part0015.html.page_287" class="calibre3">287</a></p>
<p class="index">Leibniz, G., <a href="#text/part0014.html.page_243" class="calibre3">243</a></p>
<p class="index"><span class="font">length</span>, <a href="#text/part0008.html.page_69" class="calibre3">69</a>, <a href="#text/part0008.html.page_79" class="calibre3">79</a>, <a href="#text/part0011.html.page_160" class="calibre3">160</a></p>
<p class="index"><span class="font">let</span>, <i class="calibre1">see</i> <a href="#text/part0017.html.link7" class="calibre3">expressions</a></p>
<p class="index">lexicographic order, <a href="#text/part0008.html.page_76" class="calibre3">76</a>, <a href="#text/part0012.html.page_189" class="calibre3">189</a>, <a href="#text/part0013.html.page_217" class="calibre3">217</a></p>
<p class="index"><span class="font">liftM</span>, <a href="#text/part0014.html.page_264" class="calibre3">264</a></p>
<p class="index"><span class="font">lines</span>, <a href="#text/part0012.html.page_188" class="calibre3">188</a>, <a href="#text/part0012.html.page_200" class="calibre3">200</a></p>
<p class="index">Linux, <a href="#text/part0005.html.page_12" class="calibre3">12</a></p>
<p class="index">list</p>
<p class="index1">adjacency, <a href="#text/part0014.html.page_261" class="calibre3">261</a></p>
<p class="index1">comprehensions, <a href="#text/part0008.html.page_66" class="calibre3">66</a>, <a href="#text/part0009.html.page_92" class="calibre3">92</a>, <a href="#text/part0011.html.page_156" class="calibre3">156</a>, <a href="#text/part0014.html.page_244" class="calibre3">244</a>, <a href="#text/part0014.html.page_245" class="calibre3">245</a>, <a href="#text/part0014.html.page_248" class="calibre3">248</a></p>
<p class="index1">concatenation, <i class="calibre1">see</i> <a href="#text/part0017.html.link18" class="calibre3"><span class="font">(++)</span></a></p>
<p class="index1">cyclic, <a href="#text/part0013.html.page_210" class="calibre3">210</a></p>
<p class="index1">doubly-linked, <a href="#text/part0013.html.page_228" class="calibre3">228</a></p>
<p class="index1">finite, <a href="#text/part0008.html.page_64" class="calibre3">64</a></p>
<p class="index1">identity function, <a href="#text/part0010.html.page_118" class="calibre3">118</a></p>
<p class="index1">indexing, <i class="calibre1">see</i> <a href="#text/part0017.html.link19" class="calibre3"><span class="font">(!!)</span></a></p>
<p class="index1">infinite, <a href="#text/part0007.html.page_53" class="calibre3">53</a>, <a href="#text/part0008.html.page_64" class="calibre3">64</a>, <a href="#text/part0008.html.page_75" class="calibre3">75</a>, <a href="#text/part0009.html.page_108" class="calibre3">108</a>, <a href="#text/part0013.html.page_210" class="calibre3">210</a></p>
<p class="index1">notation, <a href="#text/part0005.html.page_3" class="calibre3">3</a></p>
<p class="index1">partial, <a href="#text/part0008.html.page_64" class="calibre3">64</a>, <a href="#text/part0010.html.page_115" class="calibre3">115</a>, <a href="#text/part0013.html.page_211" class="calibre3">211</a></p>
<p class="index"><span class="font">listArray</span>, <a href="#text/part0014.html.page_260" class="calibre3">260</a></p>
<p class="index">lists</p>
<p class="index1">adjacency, <a href="#text/part0014.html.page_261" class="calibre3">261</a></p>
<p class="index">literate programming, <a href="#text/part0005.html.page_8" class="calibre3">8</a></p>
<p class="index">local definitions, <a href="#text/part0005.html.page_11" class="calibre3">11</a>, <a href="#text/part0011.html.page_149" class="calibre3">149</a>, <a href="#text/part0014.html.page_256" class="calibre3">256</a></p>
<p class="index"><span class="font">log</span>, <a href="#text/part0010.html.page_141" class="calibre3">141</a></p>
<p class="index">logarithmic factors, <a href="#text/part0011.html.page_159" class="calibre3">159</a></p>
<p class="index">logarithmic time, <a href="#text/part0007.html.page_56" class="calibre3">56</a></p>
<p class="index"><span class="font">logBase</span>, <a href="#text/part0005.html.page_2" class="calibre3">2</a>, <a href="#text/part0010.html.page_141" class="calibre3">141</a></p>
<p class="index"><span class="font">lookup</span>, <a href="#text/part0014.html.page_244" class="calibre3">244</a>, <a href="#text/part0016.html.page_319" class="calibre3">319</a></p>
<p class="index">loop invariants, <a href="#text/part0014.html.page_255" class="calibre3">255</a>, <a href="#text/part0014.html.page_263" class="calibre3">263</a></p>
<p class="index">lower bounds, <a href="#text/part0011.html.page_157" class="calibre3">157</a></p>
<p class="index">lowercase, <a href="#text/part0005.html.page_5" class="calibre3">5</a></p>
<p class="index">Loyd, S., <a href="#text/part0014.html.page_267" class="calibre3">267</a></p>
<p class="index">Mac, <a href="#text/part0005.html.page_12" class="calibre3">12</a></p>
<p class="index"><span class="font">main</span>, <a href="#text/part0006.html.page_34" class="calibre3">34</a>, <a href="#text/part0013.html.page_227" class="calibre3">227</a></p>
<p class="index"><span class="font">map</span>, <a href="#text/part0005.html.page_5" class="calibre3">5</a>, <a href="#text/part0006.html.page_23" class="calibre3">23</a>, <a href="#text/part0006.html.page_31" class="calibre3">31</a>, <a href="#text/part0006.html.page_38" class="calibre3">38</a>, <a href="#text/part0008.html.page_67" class="calibre3">67</a>, <a href="#text/part0008.html.page_70" class="calibre3">70</a>, <a href="#text/part0008.html.page_80" class="calibre3">80</a>, <a href="#text/part0009.html.page_91" class="calibre3">91</a>, <a href="#text/part0010.html.page_119" class="calibre3">119</a>, <a href="#text/part0016.html.page_299" class="calibre3">299</a></p>
<p class="index"><span class="font">mapM</span>, <a href="#text/part0014.html.page_265" class="calibre3">265</a></p>
<p class="index"><span class="font">mapM_</span>, <a href="#text/part0014.html.page_265" class="calibre3">265</a></p>
<p class="index">Marlow, S., <a href="#text/part0005.html.page_20" class="calibre3">20</a></p>
<p class="index">Maslanka, C., <a href="#text/part0006.html.page_48" class="calibre3">48</a></p>
<p class="index">mathematical operators, <a href="#text/part0013.html.page_217" class="calibre3">217</a></p>
<p class="index">matrices, <a href="#text/part0009.html.page_90" class="calibre3">90</a>, <a href="#text/part0009.html.page_94" class="calibre3">94</a>, <a href="#text/part0013.html.page_234" class="calibre3">234</a></p>
<p class="index">matrix</p>
<p class="index1">addition, <a href="#text/part0009.html.page_105" class="calibre3">105</a></p>
<p class="index1">multiplication, <a href="#text/part0009.html.page_105" class="calibre3">105</a></p>
<p class="index1">transpose, <a href="#text/part0009.html.page_94" class="calibre3">94</a>, <a href="#text/part0009.html.page_106" class="calibre3">106</a></p>
<p class="index"><span class="font">maximum</span>, <a href="#text/part0010.html.page_122" class="calibre3">122</a></p>
<p class="index"><span class="font">Maybe</span>, <a href="#text/part0006.html.page_39" class="calibre3">39</a>, <a href="#text/part0014.html.page_244" class="calibre3">244</a></p>
<p class="index">McIlory, D., <a href="#text/part0005.html.page_21" class="calibre3">21</a></p>
<p class="index"><span class="font">mean</span>, <a href="#text/part0011.html.page_151" class="calibre3">151</a></p>
<p class="index">Meijer, E., <a href="#text/part0012.html.page_209" class="calibre3">209</a>, <a href="#text/part0015.html.page_297" class="calibre3">297</a></p>
<p class="index"><span class="font">merge</span>, <a href="#text/part0008.html.page_76" class="calibre3">76</a>, <a href="#text/part0013.html.page_211" class="calibre3">211</a>, <a href="#text/part0013.html.page_231" class="calibre3">231</a></p>
<p class="index">mergesort, <i class="calibre1">see</i> <a href="#text/part0017.html.link16" class="calibre3">sorting</a></p>
<p class="index"><span class="font">minimum</span>, <a href="#text/part0009.html.page_104" class="calibre3">104</a>, <a href="#text/part0009.html.page_107" class="calibre3">107</a>, <a href="#text/part0010.html.page_122" class="calibre3">122</a>, <a href="#text/part0011.html.page_157" class="calibre3">157</a>, <a href="#text/part0013.html.page_211" class="calibre3">211</a></p>
<p class="index">Miranda, <a href="#text/part0004.html.page_x" class="calibre3">x</a></p>
<p class="index"><span class="font">mkStdGen</span>, <a href="#text/part0013.html.page_223" class="calibre3">223</a></p>
<p class="index">ML, <a href="#text/part0006.html.page_29" class="calibre3">29</a>, <a href="#text/part0006.html.page_48" class="calibre3">48</a></p>
<p class="index"><span class="font">mod</span>, <a href="#text/part0005.html.page_9" class="calibre3">9</a></p>
<p class="index" id="text/part0017.html.link9">modules, <a href="#text/part0005.html.page_13" class="calibre3">13</a>, <a href="#text/part0006.html.page_25" class="calibre3">25</a>, <a href="#text/part0006.html.page_35" class="calibre3">35</a>, <a href="#text/part0016.html.page_309" class="calibre3">309</a></p>
<p class="index1">export declarations, <a href="#text/part0006.html.page_35" class="calibre3">35</a>, <a href="#text/part0012.html.page_199" class="calibre3">199</a></p>
<p class="index1">hierarchical names, <a href="#text/part0005.html.page_21" class="calibre3">21</a></p>
<p class="index1">import declarations, <a href="#text/part0005.html.page_13" class="calibre3">13</a>, <a href="#text/part0006.html.page_35" class="calibre3">35</a></p>
<p class="index"><span class="font">Monad</span>, <a href="#text/part0014.html.page_243" class="calibre3">243</a>, <a href="#text/part0014.html.page_264" class="calibre3">264</a></p>
<p class="index">monadic programming, <a href="#text/part0014.html.page_239" class="calibre3">239</a></p>
<p class="index"><span class="font">MonadPlus</span>, <a href="#text/part0015.html.page_292" class="calibre3">292</a></p>
<p class="index">monads, <a href="#text/part0014.html.page_243" class="calibre3">243</a></p>
<p class="index1">commutative, <a href="#text/part0014.html.page_264" class="calibre3">264</a></p>
<p class="index">monoids, <a href="#text/part0014.html.page_247" class="calibre3">247</a></p>
<p class="index"><span class="font">mplus</span>, <a href="#text/part0015.html.page_292" class="calibre3">292</a></p>
<p class="index">mutable structures, <a href="#text/part0014.html.page_248" class="calibre3">248</a></p>
<p class="index"><span class="font">mzero</span>, <a href="#text/part0015.html.page_292" class="calibre3">292</a></p>
<p class="index"><span class="font">Nat</span>, <a href="#text/part0007.html.page_56" class="calibre3">56</a>, <a href="#text/part0010.html.page_110" class="calibre3">110</a>, <a href="#text/part0010.html.page_132" class="calibre3">132</a></p>
<p class="index">natural transformations, <a href="#text/part0008.html.page_87" class="calibre3">87</a></p>
<p class="index"><span class="font">negate</span>, <a href="#text/part0007.html.page_50" class="calibre3">50</a></p>
<p class="index">newline character, <i class="calibre1">see </i><a href="#text/part0017.html.link20" class="calibre3">\<span class="font">n</span></a></p>
<p class="index"><span class="font">newSTRef</span>, <a href="#text/part0014.html.page_251" class="calibre3">251</a></p>
<p class="index">Newton’s method, <a href="#text/part0007.html.page_60" class="calibre3">60</a></p>
<p class="index"><span class="font">newtype</span> declarations, <a href="#text/part0015.html.page_278" class="calibre3">278</a></p>
<p class="index">non-decreasing order, <a href="#text/part0008.html.page_74" class="calibre3">74</a></p>
<p class="index"><span class="font">none</span>, <a href="#text/part0010.html.page_134" class="calibre3">134</a></p>
<p class="index">normal form, <a href="#text/part0011.html.page_146" class="calibre3">146</a></p>
<p class="index"><span class="font">not</span>, <a href="#text/part0006.html.page_30" class="calibre3">30</a></p>
<p class="index"><span class="font">notElem</span>, <a href="#text/part0009.html.page_98" class="calibre3">98</a></p>
<p class="index"><span class="font">Nothing</span>, <a href="#text/part0014.html.page_244" class="calibre3">244</a></p>
<p class="index"><span class="font">nub</span>, <a href="#text/part0009.html.page_106" class="calibre3">106</a>, <a href="#text/part0009.html.page_108" class="calibre3">108</a></p>
<p class="index"><span class="font">null</span>, <a href="#text/part0006.html.page_39" class="calibre3">39</a>, <a href="#text/part0008.html.page_68" class="calibre3">68</a></p>
<p class="index">null tuple, <i class="calibre1">see</i> <a href="#text/part0017.html.link21" class="calibre3"><span class="font">()</span></a></p>
<p class="index"><span class="font">Num</span>, <a href="#text/part0006.html.page_23" class="calibre3">23</a>, <a href="#text/part0006.html.page_31" class="calibre3">31</a>, <a href="#text/part0007.html.page_49" class="calibre3">49</a>, <a href="#text/part0007.html.page_56" class="calibre3">56</a></p>
<p class="index">Number Theory, <a href="#text/part0013.html.page_219" class="calibre3">219</a></p>
<p class="index">numbers</p>
<p class="index1">complex, <i class="calibre1">see</i> <a href="#text/part0017.html.link22" class="calibre3"><span class="font">Complex</span></a></p>
<p class="index1">floating point, <i class="calibre1">see</i> <a href="#text/part0017.html.link23" class="calibre3"><span class="font">Float</span></a>, <a href="#text/part0017.html.link24" class="calibre3"><span class="font">Double</span></a></p>
<p class="index1">floating-point, <a href="#text/part0007.html.page_60" class="calibre3">60</a></p>
<p class="index1">integer, <i class="calibre1">see</i> <a href="#text/part0017.html.link25" class="calibre3"><span class="font">Int</span></a>, <a href="#text/part0017.html.link26" class="calibre3"><span class="font">Integer</span></a></p>
<p class="index1">limited precision integers, <i class="calibre1">see</i> <a href="#text/part0017.html.link25" class="calibre3"><span class="font">Int</span></a></p>
<p class="index1">natural, <a href="#text/part0007.html.page_56" class="calibre3">56</a>, <a href="#text/part0010.html.page_110" class="calibre3">110</a></p>
<p class="index1">unlimited precision integers, <i class="calibre1">see</i> <a href="#text/part0017.html.link26" class="calibre3"><span class="font">Integer</span></a></p>
<p class="indextitle">O’Neill, M., <a href="#text/part0013.html.page_237" class="calibre3">237</a></p>
<p class="index">O’Sullivan, B., <a href="#text/part0005.html.page_21" class="calibre3">21</a></p>
<p class="index">offside rule, <a href="#text/part0006.html.page_36" class="calibre3">36</a>, <a href="#text/part0014.html.page_242" class="calibre3">242</a></p>
<p class="index"><span class="font">one</span>, <a href="#text/part0010.html.page_134" class="calibre3">134</a></p>
<p class="index">Oppen, D., <a href="#text/part0012.html.page_209" class="calibre3">209</a></p>
<p class="index"><span class="font">or</span>, <a href="#text/part0009.html.page_102" class="calibre3">102</a></p>
<p class="index"><span class="font">Ord</span>, <a href="#text/part0006.html.page_32" class="calibre3">32</a></p>
<p class="index">order of association, <a href="#text/part0005.html.page_2" class="calibre3">2</a>–4, <a href="#text/part0005.html.page_17" class="calibre3">17</a>, <a href="#text/part0006.html.page_25" class="calibre3">25</a>, <a href="#text/part0007.html.page_62" class="calibre3">62</a>, <a href="#text/part0012.html.page_196" class="calibre3">196</a></p>
<p class="index">Orwell, <a href="#text/part0004.html.page_x" class="calibre3">x</a></p>
<p class="index"><span class="font">otherwise</span>, <a href="#text/part0005.html.page_11" class="calibre3">11</a></p>
<p class="indextitle">pairs, <a href="#text/part0005.html.page_2" class="calibre3">2</a>, <a href="#text/part0008.html.page_74" class="calibre3">74</a>, <a href="#text/part0008.html.page_76" class="calibre3">76</a>, <a href="#text/part0008.html.page_82" class="calibre3">82</a>, <a href="#text/part0011.html.page_177" class="calibre3">177</a></p>
<p class="index">palindromes, <a href="#text/part0006.html.page_41" class="calibre3">41</a></p>
<p class="index">paper–rock–scissors, <a href="#text/part0013.html.page_221" class="calibre3">221</a></p>
<p class="index">paragraphs, <a href="#text/part0012.html.page_191" class="calibre3">191</a></p>
<p class="index">parentheses, <a href="#text/part0005.html.page_15" class="calibre3">15</a></p>
<p class="index">parsers, <a href="#text/part0015.html.page_276" class="calibre3">276</a></p>
<p class="index">parsing, <a href="#text/part0014.html.page_239" class="calibre3">239</a></p>
<p class="index">partial application, <a href="#text/part0008.html.page_87" class="calibre3">87</a></p>
<p class="index">partial numbers, <a href="#text/part0007.html.page_58" class="calibre3">58</a></p>
<p class="index"><span class="font">partition</span>, <a href="#text/part0016.html.page_311" class="calibre3">311</a></p>
<p class="index">Patashnik, O., <a href="#text/part0007.html.page_62" class="calibre3">62</a></p>
<p class="index">Paterson, R., <a href="#text/part0016.html.page_337" class="calibre3">337</a></p>
<p class="index" id="text/part0017.html.link1">patterns</p>
<p class="index1"><span class="font">n+k</span>, <a href="#text/part0010.html.page_111" class="calibre3">111</a></p>
<p class="index1">as patterns, <a href="#text/part0008.html.page_77" class="calibre3">77</a>, <a href="#text/part0008.html.page_83" class="calibre3">83</a></p>
<p class="index1">disjoint, <a href="#text/part0008.html.page_68" class="calibre3">68</a></p>
<p class="index1">don’t care, <a href="#text/part0008.html.page_67" class="calibre3">67</a>, <a href="#text/part0008.html.page_73" class="calibre3">73</a>, <a href="#text/part0009.html.page_103" class="calibre3">103</a>, <a href="#text/part0014.html.page_268" class="calibre3">268</a></p>
<p class="index1">exhaustive, <a href="#text/part0008.html.page_68" class="calibre3">68</a></p>
<p class="index1">irrefutable, <a href="#text/part0013.html.page_231" class="calibre3">231</a></p>
<p class="index1">matching, <a href="#text/part0007.html.page_57" class="calibre3">57</a>, <a href="#text/part0008.html.page_67" class="calibre3">67</a>, <a href="#text/part0008.html.page_68" class="calibre3">68</a>, <a href="#text/part0008.html.page_74" class="calibre3">74</a>, <a href="#text/part0010.html.page_115" class="calibre3">115</a>, <a href="#text/part0012.html.page_194" class="calibre3">194</a>, <a href="#text/part0016.html.page_332" class="calibre3">332</a></p>
<p class="index1">wildcard, <a href="#text/part0008.html.page_67" class="calibre3">67</a>, <a href="#text/part0014.html.page_268" class="calibre3">268</a></p>
<p class="index">perfect numbers, <a href="#text/part0008.html.page_65" class="calibre3">65</a></p>
<p class="index">Perlis, A., <a href="#text/part0011.html.page_145" class="calibre3">145</a></p>
<p class="index">persistent data structures, <a href="#text/part0014.html.page_254" class="calibre3">254</a></p>
<p class="index">Peyton Jones, S., <a href="#text/part0005.html.page_21" class="calibre3">21</a>, <a href="#text/part0012.html.page_209" class="calibre3">209</a></p>
<p class="index">Pierce, B., <a href="#text/part0008.html.page_87" class="calibre3">87</a></p>
<p class="index">plumbing combinators, <a href="#text/part0008.html.page_86" class="calibre3">86</a></p>
<p class="index">point-free calculations, <a href="#text/part0008.html.page_86" class="calibre3">86</a>, <a href="#text/part0016.html.page_330" class="calibre3">330</a></p>
<p class="index">point-free reasoning, <a href="#text/part0016.html.page_298" class="calibre3">298</a></p>
<p class="index">pointers, <a href="#text/part0011.html.page_146" class="calibre3">146</a></p>
<p class="index">postconditions, <a href="#text/part0014.html.page_255" class="calibre3">255</a>, <a href="#text/part0014.html.page_263" class="calibre3">263</a></p>
<p class="index">precedence, <a href="#text/part0005.html.page_14" class="calibre3">14</a>, <a href="#text/part0006.html.page_25" class="calibre3">25</a>, <a href="#text/part0006.html.page_37" class="calibre3">37</a></p>
<p class="index">preconditions, <a href="#text/part0014.html.page_255" class="calibre3">255</a>, <a href="#text/part0014.html.page_263" class="calibre3">263</a></p>
<p class="index">prefix names, <a href="#text/part0006.html.page_25" class="calibre3">25</a></p>
<p class="index">prefix operators, <a href="#text/part0007.html.page_50" class="calibre3">50</a></p>
<p class="index"><span class="font">Prelude</span>, <a href="#text/part0006.html.page_25" class="calibre3">25</a></p>
<p class="index"><span class="font">primes</span>, <a href="#text/part0011.html.page_148" class="calibre3">148</a>, <a href="#text/part0013.html.page_213" class="calibre3">213</a>, <a href="#text/part0013.html.page_219" class="calibre3">219</a>, <a href="#text/part0013.html.page_220" class="calibre3">220</a>, <a href="#text/part0013.html.page_233" class="calibre3">233</a></p>
<p class="index">printing values, <a href="#text/part0006.html.page_33" class="calibre3">33</a></p>
<p class="index">profiling tools, <a href="#text/part0011.html.page_154" class="calibre3">154</a></p>
<p class="index">program variables, <a href="#text/part0014.html.page_251" class="calibre3">251</a></p>
<p class="index">programs, <a href="#text/part0005.html.page_7" class="calibre3">7</a></p>
<p class="index">prompt symbol, <a href="#text/part0005.html.page_13" class="calibre3">13</a></p>
<p class="index">prompts, <a href="#text/part0013.html.page_229" class="calibre3">229</a>, <a href="#text/part0014.html.page_240" class="calibre3">240</a></p>
<p class="index">proof format, <a href="#text/part0004.html.page_xi" class="calibre3">xi</a>, <a href="#text/part0010.html.page_112" class="calibre3">112</a></p>
<p class="index"><span class="font">properFraction</span>, <a href="#text/part0007.html.page_56" class="calibre3">56</a></p>
<p class="index"><span class="font">putChar</span>, <a href="#text/part0014.html.page_240" class="calibre3">240</a></p>
<p class="index"><span class="font">putStrLn</span>, <a href="#text/part0005.html.page_16" class="calibre3">16</a>, <a href="#text/part0006.html.page_33" class="calibre3">33</a>, <a href="#text/part0014.html.page_239" class="calibre3">239</a>, <a href="#text/part0014.html.page_240" class="calibre3">240</a></p>
<p class="index">Pythagorean triads, <a href="#text/part0008.html.page_66" class="calibre3">66</a></p>
<p class="index">Python, <a href="#text/part0004.html.page_x" class="calibre3">x</a>, <a href="#text/part0014.html.page_239" class="calibre3">239</a>, <a href="#text/part0014.html.page_252" class="calibre3">252</a></p>
<p class="indextitle">qualified names, <a href="#text/part0016.html.page_306" class="calibre3">306</a></p>
<p class="index">quicksort, <i class="calibre1">see</i> <a href="#text/part0017.html.link16" class="calibre3">sorting</a></p>
<p class="indextitle">Rabbi, F., <a href="#text/part0011.html.page_180" class="calibre3">180</a></p>
<p class="index">Ramanujan, S., <a href="#text/part0008.html.page_78" class="calibre3">78</a></p>
<p class="index">random numbers, <a href="#text/part0013.html.page_223" class="calibre3">223</a>, <a href="#text/part0014.html.page_250" class="calibre3">250</a></p>
<p class="index"><span class="font">randomR</span>, <a href="#text/part0013.html.page_223" class="calibre3">223</a></p>
<p class="index">rank 2 polymorphic types, <a href="#text/part0014.html.page_253" class="calibre3">253</a></p>
<p class="index"><span class="font">Rational</span>, <a href="#text/part0007.html.page_49" class="calibre3">49</a>, <a href="#text/part0007.html.page_50" class="calibre3">50</a></p>
<p class="index"><span class="font">Read</span>, <a href="#text/part0006.html.page_41" class="calibre3">41</a>, <a href="#text/part0010.html.page_122" class="calibre3">122</a>, <a href="#text/part0015.html.page_277" class="calibre3">277</a></p>
<p class="index"><span class="font">read</span>, <a href="#text/part0007.html.page_52" class="calibre3">52</a>, <a href="#text/part0010.html.page_122" class="calibre3">122</a></p>
<p class="index"><span class="font">readFile</span>, <a href="#text/part0006.html.page_34" class="calibre3">34</a></p>
<p class="index">reading files, <a href="#text/part0006.html.page_34" class="calibre3">34</a></p>
<p class="index"><span class="font">ReadS</span>, <a href="#text/part0015.html.page_277" class="calibre3">277</a></p>
<p class="index"><span class="font">reads</span>, <a href="#text/part0015.html.page_277" class="calibre3">277</a></p>
<p class="index"><span class="font">readSTRef</span>, <a href="#text/part0014.html.page_251" class="calibre3">251</a></p>
<p class="index"><span class="font">Real</span>, <a href="#text/part0007.html.page_50" class="calibre3">50</a></p>
<p class="index">recursive definitions, <a href="#text/part0006.html.page_29" class="calibre3">29</a>, <a href="#text/part0008.html.page_77" class="calibre3">77</a>, <a href="#text/part0013.html.page_219" class="calibre3">219</a></p>
<p class="index">reduction, <i class="calibre1">see</i> <a href="#text/part0017.html.link17" class="calibre3">evaluation</a></p>
<p class="index">reduction steps, <a href="#text/part0011.html.page_155" class="calibre3">155</a>, <a href="#text/part0011.html.page_156" class="calibre3">156</a></p>
<p class="index">reference variables, <a href="#text/part0014.html.page_251" class="calibre3">251</a></p>
<p class="index">reflexive relation, <a href="#text/part0013.html.page_217" class="calibre3">217</a></p>
<p class="index"><span class="font">repeat</span>, <a href="#text/part0009.html.page_108" class="calibre3">108</a>, <a href="#text/part0013.html.page_212" class="calibre3">212</a></p>
<p class="index"><span class="font">return</span>, <a href="#text/part0014.html.page_241" class="calibre3">241</a></p>
<p class="index"><span class="font">reverse</span>, <a href="#text/part0006.html.page_42" class="calibre3">42</a>, <a href="#text/part0008.html.page_72" class="calibre3">72</a>, <a href="#text/part0010.html.page_113" class="calibre3">113</a>, <a href="#text/part0010.html.page_117" class="calibre3">117</a>, <a href="#text/part0010.html.page_123" class="calibre3">123</a>, <a href="#text/part0011.html.page_159" class="calibre3">159</a></p>
<p class="index">running sums, <a href="#text/part0010.html.page_125" class="calibre3">125</a></p>
<p class="index"><span class="font">runST</span>, <a href="#text/part0014.html.page_252" class="calibre3">252</a></p>
<p class="indextitle">SASL, <a href="#text/part0004.html.page_x" class="calibre3">x</a></p>
<p class="index"><span class="font">scanl</span>, <a href="#text/part0010.html.page_125" class="calibre3">125</a>, <a href="#text/part0010.html.page_127" class="calibre3">127</a></p>
<p class="index"><span class="font">scanr</span>, <a href="#text/part0010.html.page_130" class="calibre3">130</a></p>
<p class="index">scientific notation, <a href="#text/part0007.html.page_60" class="calibre3">60</a>, <a href="#text/part0010.html.page_112" class="calibre3">112</a></p>
<p class="index">scope, <a href="#text/part0005.html.page_11" class="calibre3">11</a></p>
<p class="index">scripts, <a href="#text/part0005.html.page_7" class="calibre3">7</a>, <a href="#text/part0006.html.page_25" class="calibre3">25</a>, <a href="#text/part0011.html.page_148" class="calibre3">148</a></p>
<p class="index">sections, <a href="#text/part0006.html.page_26" class="calibre3">26</a>, <a href="#text/part0007.html.page_52" class="calibre3">52</a>, <a href="#text/part0007.html.page_53" class="calibre3">53</a></p>
<p class="index">segments, <a href="#text/part0010.html.page_127" class="calibre3">127</a>, <a href="#text/part0016.html.page_316" class="calibre3">316</a></p>
<p class="index"><span class="font">select</span>, <a href="#text/part0011.html.page_175" class="calibre3">175</a></p>
<p class="index">selection sort, <i class="calibre1">see</i> <a href="#text/part0017.html.link16" class="calibre3">csorting</a></p>
<p class="index">semicolon, <a href="#text/part0006.html.page_36" class="calibre3">36</a></p>
<p class="index">separator characters, <a href="#text/part0012.html.page_200" class="calibre3">200</a></p>
<p class="index"><span class="font">seq</span>, <a href="#text/part0011.html.page_150" class="calibre3">150</a>, <a href="#text/part0011.html.page_153" class="calibre3">153</a>, <a href="#text/part0013.html.page_226" class="calibre3">226</a></p>
<p class="index"><span class="font">sequence_</span>, <a href="#text/part0014.html.page_264" class="calibre3">264</a></p>
<p class="index">set theory, <a href="#text/part0013.html.page_211" class="calibre3">211</a></p>
<p class="index">shallow embeddings, <a href="#text/part0012.html.page_187" class="calibre3">187</a>, <a href="#text/part0012.html.page_192" class="calibre3">192</a></p>
<p class="index">shared values, <a href="#text/part0011.html.page_146" class="calibre3">146</a></p>
<p class="index"><span class="font">Show</span>, <a href="#text/part0006.html.page_32" class="calibre3">32</a>, <a href="#text/part0006.html.page_40" class="calibre3">40</a>, <a href="#text/part0007.html.page_56" class="calibre3">56</a>, <a href="#text/part0013.html.page_229" class="calibre3">229</a>, <a href="#text/part0015.html.page_276" class="calibre3">276</a>, <a href="#text/part0015.html.page_291" class="calibre3">291</a></p>
<p class="index"><span class="font">ShowS</span>, <a href="#text/part0015.html.page_289" class="calibre3">289</a>, <a href="#text/part0016.html.page_311" class="calibre3">311</a></p>
<p class="index"><span class="font">showsPrec</span>, <a href="#text/part0015.html.page_290" class="calibre3">290</a>, <a href="#text/part0015.html.page_291" class="calibre3">291</a>, <a href="#text/part0016.html.page_308" class="calibre3">308</a></p>
<p class="index">side-effects, <a href="#text/part0014.html.page_243" class="calibre3">243</a></p>
<p class="index">sieve of Sundaram, <a href="#text/part0013.html.page_233" class="calibre3">233</a></p>
<p class="index"><span class="font">signum</span>, <a href="#text/part0007.html.page_50" class="calibre3">50</a></p>
<p class="index">Sijtsma, B., <a href="#text/part0013.html.page_237" class="calibre3">237</a></p>
<p class="index"><span class="font">sin</span>, <a href="#text/part0005.html.page_2" class="calibre3">2</a>, <a href="#text/part0005.html.page_14" class="calibre3">14</a></p>
<p class="index">sine function, <a href="#text/part0004.html.page_ix" class="calibre3">ix</a>, <a href="#text/part0004.html.page_xi" class="calibre3">xi</a>, <a href="#text/part0005.html.page_2" class="calibre3">2</a>, <a href="#text/part0005.html.page_14" class="calibre3">14</a></p>
<p class="index">size measures, <a href="#text/part0011.html.page_156" class="calibre3">156</a>, <a href="#text/part0012.html.page_202" class="calibre3">202</a></p>
<p class="index"><span class="font">snd</span>, <a href="#text/part0007.html.page_51" class="calibre3">51</a></p>
<p class="index"><span class="font">sort</span>, <a href="#text/part0005.html.page_14" class="calibre3">14</a>, <a href="#text/part0008.html.page_75" class="calibre3">75</a>, <a href="#text/part0011.html.page_154" class="calibre3">154</a></p>
<p class="index" id="text/part0017.html.link16">sorting, <a href="#text/part0005.html.page_5" class="calibre3">5</a>, <a href="#text/part0005.html.page_6" class="calibre3">6</a>, <a href="#text/part0009.html.page_94" class="calibre3">94</a>, <a href="#text/part0011.html.page_167" class="calibre3">167</a></p>
<p class="index1">insertion sort, <a href="#text/part0011.html.page_172" class="calibre3">172</a></p>
<p class="index1">mergesort, <a href="#text/part0008.html.page_76" class="calibre3">76</a>, <a href="#text/part0011.html.page_168" class="calibre3">168</a></p>
<p class="index1">numbers, <a href="#text/part0014.html.page_262" class="calibre3">262</a></p>
<p class="index1">quicksort, <a href="#text/part0011.html.page_169" class="calibre3">169</a>, <a href="#text/part0014.html.page_254" class="calibre3">254</a>, <a href="#text/part0014.html.page_263" class="calibre3">263</a></p>
<p class="index1">selection sort, <a href="#text/part0011.html.page_172" class="calibre3">172</a></p>
<p class="index">space character, <a href="#text/part0005.html.page_3" class="calibre3">3</a></p>
<p class="index">space efficiency, <a href="#text/part0006.html.page_29" class="calibre3">29</a>, <a href="#text/part0008.html.page_84" class="calibre3">84</a>, <a href="#text/part0011.html.page_147" class="calibre3">147</a>, <a href="#text/part0011.html.page_149" class="calibre3">149</a>, <a href="#text/part0011.html.page_154" class="calibre3">154</a>, <a href="#text/part0011.html.page_171" class="calibre3">171</a></p>
<p class="index">space leaks, <a href="#text/part0011.html.page_147" class="calibre3">147</a>, <a href="#text/part0011.html.page_151" class="calibre3">151</a>, <a href="#text/part0011.html.page_170" class="calibre3">170</a>, <a href="#text/part0011.html.page_171" class="calibre3">171</a></p>
<p class="index"><span class="font">span</span>, <a href="#text/part0008.html.page_75" class="calibre3">75</a>, <a href="#text/part0009.html.page_102" class="calibre3">102</a></p>
<p class="index">Spivey, M., <a href="#text/part0016.html.page_337" class="calibre3">337</a></p>
<p class="index"><span class="font">splitAt</span>, <a href="#text/part0008.html.page_80" class="calibre3">80</a>, <a href="#text/part0011.html.page_168" class="calibre3">168</a></p>
<p class="index"><span class="font">sqrt</span>, <a href="#text/part0007.html.page_60" class="calibre3">60</a></p>
<p class="index">stand-alone programs, <a href="#text/part0006.html.page_34" class="calibre3">34</a>, <a href="#text/part0013.html.page_227" class="calibre3">227</a></p>
<p class="index" id="text/part0017.html.link14">standard prelude, <a href="#text/part0005.html.page_13" class="calibre3">13</a>, <a href="#text/part0006.html.page_30" class="calibre3">30</a>, <a href="#text/part0006.html.page_39" class="calibre3">39</a>, <a href="#text/part0006.html.page_42" class="calibre3">42</a>, <a href="#text/part0007.html.page_51" class="calibre3">51</a>, <a href="#text/part0007.html.page_56" class="calibre3">56</a>, <a href="#text/part0008.html.page_73" class="calibre3">73</a>, <a href="#text/part0008.html.page_80" class="calibre3">80</a>, <a href="#text/part0008.html.page_86" class="calibre3">86</a>, <a href="#text/part0008.html.page_87" class="calibre3">87</a>, <a href="#text/part0010.html.page_127" class="calibre3">127</a>, <a href="#text/part0011.html.page_150" class="calibre3">150</a>, <a href="#text/part0011.html.page_161" class="calibre3">161</a>, <a href="#text/part0011.html.page_168" class="calibre3">168</a>, <a href="#text/part0013.html.page_213" class="calibre3">213</a>, <a href="#text/part0013.html.page_232" class="calibre3">232</a></p>
<p class="index"><span class="font">STArray</span>, <a href="#text/part0014.html.page_254" class="calibre3">254</a></p>
<p class="index">state monad, <a href="#text/part0014.html.page_247" class="calibre3">247</a></p>
<p class="index">state threads, <a href="#text/part0014.html.page_251" class="calibre3">251</a></p>
<p class="index">state-thread monad, <a href="#text/part0014.html.page_251" class="calibre3">251</a></p>
<p class="index">Stewart, D., <a href="#text/part0005.html.page_21" class="calibre3">21</a></p>
<p class="index">stream-based interaction, <a href="#text/part0013.html.page_226" class="calibre3">226</a></p>
<p class="index"><span class="font">STRef</span>, <a href="#text/part0014.html.page_251" class="calibre3">251</a></p>
<p class="index">strictness flags, <a href="#text/part0007.html.page_58" class="calibre3">58</a>, <a href="#text/part0012.html.page_194" class="calibre3">194</a></p>
<p class="index"><span class="font">String</span>, <a href="#text/part0005.html.page_6" class="calibre3">6</a></p>
<p class="index">strings, <a href="#text/part0005.html.page_4" class="calibre3">4</a></p>
<p class="index">subclasses, <a href="#text/part0007.html.page_50" class="calibre3">50</a></p>
<p class="index"><span class="font">subseqs</span>, <a href="#text/part0010.html.page_133" class="calibre3">133</a>, <a href="#text/part0011.html.page_146" class="calibre3">146</a>, <a href="#text/part0011.html.page_158" class="calibre3">158</a></p>
<p class="index">subsequences, <a href="#text/part0011.html.page_146" class="calibre3">146</a></p>
<p class="index"><span class="font">subtract</span>, <a href="#text/part0007.html.page_53" class="calibre3">53</a>, <a href="#text/part0007.html.page_59" class="calibre3">59</a></p>
<p class="index">Sudoku, <a href="#text/part0009.html.page_89" class="calibre3">89</a>, <a href="#text/part0014.html.page_258" class="calibre3">258</a>, <a href="#text/part0016.html.page_321" class="calibre3">321</a></p>
<p class="index"><span class="font">sum</span>, <a href="#text/part0011.html.page_150" class="calibre3">150</a></p>
<p class="index">Sundaram, S.P., <a href="#text/part0013.html.page_233" class="calibre3">233</a></p>
<p class="index">superclasses, <a href="#text/part0006.html.page_32" class="calibre3">32</a></p>
<p class="index">Swierstra, D., <a href="#text/part0012.html.page_209" class="calibre3">209</a></p>
<p class="index">syntactic categories, <a href="#text/part0015.html.page_286" class="calibre3">286</a></p>
<p class="index"><span class="font">System.Random</span>, <a href="#text/part0013.html.page_223" class="calibre3">223</a></p>
<p class="index"><span class="font">System.IO</span>, <a href="#text/part0014.html.page_242" class="calibre3">242</a></p>
<p class="indextitle"><span class="font">tail</span>, <a href="#text/part0006.html.page_38" class="calibre3">38</a>, <a href="#text/part0008.html.page_68" class="calibre3">68</a></p>
<p class="index"><span class="font">tails</span>, <a href="#text/part0010.html.page_128" class="calibre3">128</a></p>
<p class="index"><span class="font">take</span>, <a href="#text/part0005.html.page_6" class="calibre3">6</a>, <a href="#text/part0006.html.page_30" class="calibre3">30</a>, <a href="#text/part0008.html.page_79" class="calibre3">79</a>, <a href="#text/part0013.html.page_218" class="calibre3">218</a></p>
<p class="index"><span class="font">takeWhile</span>, <a href="#text/part0007.html.page_52" class="calibre3">52</a>, <a href="#text/part0009.html.page_106" class="calibre3">106</a></p>
<p class="index">taxicab numbers, <a href="#text/part0008.html.page_79" class="calibre3">79</a>, <a href="#text/part0008.html.page_88" class="calibre3">88</a></p>
<p class="index">terminator characters, <a href="#text/part0012.html.page_200" class="calibre3">200</a></p>
<p class="index">texts, <a href="#text/part0005.html.page_3" class="calibre3">3</a>, <a href="#text/part0005.html.page_5" class="calibre3">5</a>, <a href="#text/part0012.html.page_181" class="calibre3">181</a></p>
<p class="index"><span class="font">then</span>, <a href="#text/part0005.html.page_12" class="calibre3">12</a></p>
<p class="index">time efficiency, <a href="#text/part0009.html.page_92" class="calibre3">92</a>, <a href="#text/part0010.html.page_123" class="calibre3">123</a>, <a href="#text/part0010.html.page_126" class="calibre3">126</a>, <a href="#text/part0011.html.page_147" class="calibre3">147</a>, <a href="#text/part0011.html.page_154" class="calibre3">154</a>, <a href="#text/part0011.html.page_156" class="calibre3">156</a>, <a href="#text/part0012.html.page_182" class="calibre3">182</a></p>
<p class="index"><span class="font">toInteger</span>, <a href="#text/part0007.html.page_51" class="calibre3">51</a>, <a href="#text/part0011.html.page_151" class="calibre3">151</a></p>
<p class="index"><span class="font">toLower</span>, <a href="#text/part0005.html.page_5" class="calibre3">5</a>, <a href="#text/part0005.html.page_13" class="calibre3">13</a>, <a href="#text/part0006.html.page_38" class="calibre3">38</a></p>
<p class="index" id="text/part0017.html.link13">top-level definitions, <a href="#text/part0011.html.page_147" class="calibre3">147</a>, <a href="#text/part0014.html.page_256" class="calibre3">256</a></p>
<p class="index"><span class="font">toRational</span>, <a href="#text/part0007.html.page_50" class="calibre3">50</a></p>
<p class="index">toruses, <a href="#text/part0013.html.page_234" class="calibre3">234</a></p>
<p class="index"><span class="font">toUpper</span>, <a href="#text/part0006.html.page_44" class="calibre3">44</a>, <a href="#text/part0013.html.page_227" class="calibre3">227</a></p>
<p class="index">transitive relation, <a href="#text/part0013.html.page_217" class="calibre3">217</a></p>
<p class="index"><span class="font">transpose</span>, <a href="#text/part0009.html.page_106" class="calibre3">106</a></p>
<p class="index">trees, <a href="#text/part0008.html.page_71" class="calibre3">71</a>, <a href="#text/part0011.html.page_161" class="calibre3">161</a>, <a href="#text/part0011.html.page_165" class="calibre3">165</a>, <a href="#text/part0012.html.page_190" class="calibre3">190</a>, <a href="#text/part0012.html.page_194" class="calibre3">194</a></p>
<p class="index">trigonometry, <a href="#text/part0004.html.page_ix" class="calibre3">ix</a>, <a href="#text/part0005.html.page_2" class="calibre3">2</a></p>
<p class="index">tupling, <a href="#text/part0011.html.page_164" class="calibre3">164</a>, <a href="#text/part0011.html.page_170" class="calibre3">170</a></p>
<p class="index">tupling law of <span class="font">foldr</span>, <a href="#text/part0011.html.page_165" class="calibre3">165</a></p>
<p class="index">tying the recursive knot, <a href="#text/part0013.html.page_214" class="calibre3">214</a>, <a href="#text/part0013.html.page_238" class="calibre3">238</a></p>
<p class="index">type</p>
<p class="index1">annotations, <a href="#text/part0006.html.page_41" class="calibre3">41</a></p>
<p class="index1">classes, <a href="#text/part0006.html.page_25" class="calibre3">25</a>, <a href="#text/part0006.html.page_30" class="calibre3">30</a>, <a href="#text/part0006.html.page_31" class="calibre3">31</a>, <a href="#text/part0011.html.page_155" class="calibre3">155</a></p>
<p class="index1">declarations, <a href="#text/part0005.html.page_7" class="calibre3">7</a>, <a href="#text/part0005.html.page_20" class="calibre3">20</a></p>
<p class="index1">inference, <a href="#text/part0005.html.page_20" class="calibre3">20</a>, <a href="#text/part0006.html.page_22" class="calibre3">22</a></p>
<p class="index1">signatures, <a href="#text/part0005.html.page_6" class="calibre3">6</a>, <a href="#text/part0005.html.page_20" class="calibre3">20</a>, <a href="#text/part0006.html.page_30" class="calibre3">30</a>, <a href="#text/part0011.html.page_155" class="calibre3">155</a></p>
<p class="index1">synonyms, <a href="#text/part0005.html.page_5" class="calibre3">5</a>, <a href="#text/part0009.html.page_90" class="calibre3">90</a>, <a href="#text/part0012.html.page_183" class="calibre3">183</a>, <a href="#text/part0015.html.page_278" class="calibre3">278</a></p>
<p class="index1">variables, <a href="#text/part0005.html.page_7" class="calibre3">7</a>, <a href="#text/part0006.html.page_31" class="calibre3">31</a></p>
<p class="index1">well-formed, <a href="#text/part0006.html.page_22" class="calibre3">22</a></p>
<p class="index">types</p>
<p class="index1">compound, <a href="#text/part0006.html.page_30" class="calibre3">30</a></p>
<p class="index1">isomorphic, <a href="#text/part0015.html.page_278" class="calibre3">278</a></p>
<p class="index1">polymorphic, <a href="#text/part0006.html.page_31" class="calibre3">31</a>, <a href="#text/part0008.html.page_72" class="calibre3">72</a></p>
<p class="index1">primitive, <a href="#text/part0006.html.page_30" class="calibre3">30</a></p>
<p class="indextitle">UHC (Utrecht Haskell Compiler), <a href="#text/part0006.html.page_47" class="calibre3">47</a></p>
<p class="index"><span class="font">uncurry</span>, <a href="#text/part0008.html.page_86" class="calibre3">86</a>, <a href="#text/part0010.html.page_135" class="calibre3">135</a></p>
<p class="index"><span class="font">undefined</span>, <a href="#text/part0006.html.page_24" class="calibre3">24</a>, <a href="#text/part0008.html.page_64" class="calibre3">64</a></p>
<p class="index">underscore convention, <a href="#text/part0014.html.page_264" class="calibre3">264</a></p>
<p class="index"><span class="font">unlines</span>, <a href="#text/part0013.html.page_227" class="calibre3">227</a></p>
<p class="index"><span class="font">unsafeperformIO</span>, <a href="#text/part0014.html.page_242" class="calibre3">242</a></p>
<p class="index"><span class="font">until</span>, <a href="#text/part0007.html.page_52" class="calibre3">52</a>, <a href="#text/part0008.html.page_65" class="calibre3">65</a></p>
<p class="index"><span class="font">unwords</span>, <a href="#text/part0006.html.page_44" class="calibre3">44</a></p>
<p class="index"><span class="font">unzip</span>, <a href="#text/part0008.html.page_81" class="calibre3">81</a></p>
<p class="index">upper bounds, <a href="#text/part0013.html.page_218" class="calibre3">218</a></p>
<p class="indextitle">visible characters, <a href="#text/part0005.html.page_3" class="calibre3">3</a></p>
<p class="index">Visual Basic, <a href="#text/part0004.html.page_x" class="calibre3">x</a></p>
<p class="indextitle">Wadler, P., <a href="#text/part0008.html.page_87" class="calibre3">87</a>, <a href="#text/part0012.html.page_209" class="calibre3">209</a></p>
<p class="index"><span class="font">where</span> clauses, <a href="#text/part0005.html.page_11" class="calibre3">11</a>, <a href="#text/part0006.html.page_24" class="calibre3">24</a>, <a href="#text/part0006.html.page_36" class="calibre3">36</a>, <a href="#text/part0011.html.page_147" class="calibre3">147</a>, <a href="#text/part0014.html.page_242" class="calibre3">242</a></p>
<p class="index">white space, <a href="#text/part0015.html.page_283" class="calibre3">283</a></p>
<p class="index">wholemeal programming, <a href="#text/part0009.html.page_95" class="calibre3">95</a></p>
<p class="index">Wilde, O., <a href="#text/part0011.html.page_145" class="calibre3">145</a></p>
<p class="index">Windows, <a href="#text/part0005.html.page_12" class="calibre3">12</a></p>
<p class="index">WinGHCi, <a href="#text/part0005.html.page_12" class="calibre3">12</a></p>
<p class="index"><span class="font">words</span>, <a href="#text/part0005.html.page_4" class="calibre3">4</a>, <a href="#text/part0005.html.page_5" class="calibre3">5</a>, <a href="#text/part0006.html.page_38" class="calibre3">38</a>, <a href="#text/part0009.html.page_107" class="calibre3">107</a>, <a href="#text/part0012.html.page_191" class="calibre3">191</a></p>
<p class="index"><span class="font">World</span>, <a href="#text/part0014.html.page_239" class="calibre3">239</a></p>
<p class="index"><span class="font">writeFile</span>, <a href="#text/part0006.html.page_34" class="calibre3">34</a></p>
<p class="index"><span class="font">writeSTRef</span>, <a href="#text/part0014.html.page_251" class="calibre3">251</a></p>
<p class="index">writing files, <a href="#text/part0006.html.page_34" class="calibre3">34</a></p>
<p class="indextitle"><span class="font">zip</span>, <a href="#text/part0008.html.page_73" class="calibre3">73</a></p>
<p class="index"><span class="font">zipWith</span>, <a href="#text/part0008.html.page_73" class="calibre3">73</a>, <a href="#text/part0009.html.page_105" class="calibre3">105</a></p>
<p class="index"><span class="font">zipWith3</span>, <a href="#text/part0013.html.page_230" class="calibre3">230</a></p>
</div></div>
</div>

<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>
