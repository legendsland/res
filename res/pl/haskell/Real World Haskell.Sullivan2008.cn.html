<!DOCTYPE html><html><head>
<meta name="dc.identifier" content="res/67e8d5b6d4309936eb936a83f7e6972a60dc3655">


<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Real World Haskell 中文版-10211629</title>

<style>
p {
   margin-bottom: 10px;
}

.article {
  display: block;
  font-family: Helvetica Neue, NotoSansHans-Regular, AvenirNext-Regular, arial, Hiragino Sans GB, Microsoft Yahei, WenQuanYi Micro Hei, serif;
  font-size: 18px;
  line-height: 1.2;
  word-wrap: break-word;
}

.article-body {
  display: block;
  margin-bottom: 0;
}

.article-head {
  display: block;
  font-size: 2.25em;
  font-weight: 200;
  line-height: 1.2;
  page-break-before: always;
  margin: 0 0 10px;
  border-bottom: #f1f1f1 solid 1px;
  padding: 12px 0;
}

.book-toc {
  display: block;
  font-size: 16px;
  line-height: 1.6;
}

.calibre {
  color: rgba(0, 0, 0, 0.87);
  display: block;
  font-family: Microsoft Yahei, Helvetica Neue, Arial, Helvetica, sans-serif;
  font-size: 14px;
  font-smoothing: antialiased;
  line-height: 1.4285em;
  min-width: 320px;
  overflow-x: hidden;
  margin: 0 5pt;
  padding: 0;
}

.calibre1 {
  display: block;
}

.calibre2 {
  display: block;
  font-size: 2em;
  font-weight: bold;
  line-height: 1.2;
  page-break-before: always;
  text-align: center;
  margin: 0.67em 0;
}

.calibre3 {
  display: block;
  list-style-type: decimal;
  margin-bottom: 0;
  margin-right: 0;
  margin-top: 0;
  padding-bottom: 0;
  padding-right: 0;
  padding-top: 0;
}

.calibre4 {
  display: list-item;
  list-style-image: none;
  list-style-position: outside;
  list-style-type: none;
}

.calibre5 {
  background: 0 0;
  color: #4183c4;
  margin-bottom: -1px;
  outline: 0;
  padding-right: 5px;
  text-decoration: none;
  border-bottom: #fff solid 1px;
}

.calibre6 {
  display: block;
  font-size: 2.25em;
  font-weight: 400;
  line-height: 1.2;
  page-break-before: always;
  margin: 0 0 14px;
  padding: 0;
}

.calibre7 {
  color: #4183c4;
  outline: 0;
  text-decoration: none;
}

.calibre8 {
  display: block;
  font-size: 1.3em;
  font-weight: 400;
  line-height: 1.225;
  margin: 14px 0;
  border-bottom: #eee solid 1px;
  padding: 0 0 0.3em;
}

.calibre9 {
  display: block;
  line-height: 2;
}

.calibre10 {
  display: block;
  line-height: 1.2;
  list-style-type: disc;
  margin-bottom: 14px;
  margin-right: 0;
  margin-top: 14px;
  padding-bottom: 0;
  padding-right: 0;
  padding-top: 0;
}

.calibre11 {
  display: list-item;
  line-height: 2;
}

.calibre12 {
  font-weight: bold;
}

.calibre13 {
  font-style: italic;
}

.calibre14 {
  display: block;
  font-size: 1.3em;
  font-weight: 400;
  line-height: 1.225;
  page-break-before: always;
  margin: 14px 0;
  border-bottom: #eee solid 1px;
  padding: 0 0 0.3em;
}

.calibre15 {
  background-color: #f7f7f7;
  border-radius: 3px;
  display: block;
  font-family: Consolas, Monaco, And ale Mono, Ubuntu Mono, monospace;
  line-height: 1.45;
  overflow: auto;
  white-space: pre-wrap;
  margin: 14px 0;
  border: currentColor none 0;
  padding: 16px;
}

.calibre16 {
  background-color: #f7f7f7;
  border-radius: 4px;
  display: inline-block;
  font-family: Consolas, Monaco, And ale Mono, Ubuntu Mono, monospace;
  line-height: 1.3;
  white-space: pre-wrap;
  word-break: break-all;
  margin: -0.2em 0.4em;
  padding: 0.2em 0.4em;
}

.calibre17 {
  display: block;
  line-height: 1.2;
  list-style-type: decimal;
  margin-bottom: 14px;
  margin-right: 0;
  margin-top: 14px;
  padding-bottom: 0;
  padding-right: 0;
  padding-top: 0;
}

.calibre18 {
  display: block;
  line-height: 1.2;
  list-style-type: decimal;
  margin-bottom: 0;
  margin-right: 0;
  margin-top: 14px;
  padding-bottom: 0;
  padding-right: 0;
  padding-top: 0;
}

.calibre19 {
  display: block;
  font-size: 1.1em;
  font-weight: 400;
  line-height: 1.2;
  margin: 14px 0;
  padding: 0;
}

.calibre20 {
  display: block;
  font-size: 1.3em;
  font-weight: 400;
  line-height: 1.225;
  margin: 14px 0 0;
  border-bottom: #eee solid 1px;
  padding: 0 0 0.3em;
}

.calibre21 {
  border-collapse: collapse;
  border-spacing: 0;
  display: table;
  line-height: 1.2;
  table-layout: fixed;
  text-indent: 0;
  width: 100%;
  margin: 14px 0;
  padding: 0;
}

.calibre22 {
  display: table-header-group;
  vertical-align: middle;
}

.calibre23 {
  display: table-row;
  page-break-inside: avoid;
  vertical-align: inherit;
}

.calibre24 {
  display: table-cell;
  font-weight: bold;
  text-align: left;
  vertical-align: inherit;
  border: #e0e0e0 solid 1px;
  padding: 3px 12px;
}

.calibre25 {
  display: table-row-group;
  vertical-align: middle;
}

.calibre26 {
  border-collapse: collapse;
  border-spacing: 0;
  display: table;
  line-height: 1.2;
  table-layout: fixed;
  text-indent: 0;
  width: 100%;
  margin: 14px 0 0;
  padding: 0;
}

.calibre27 {
  display: table-cell;
  text-align: inherit;
  vertical-align: inherit;
  border: #e0e0e0 solid 1px;
  padding: 3px 12px;
}

.calibre28 {
  display: table-column-group;
}

.calibre29 {
  display: table-column;
}

.calibre30 {
  display: block;
  line-height: 1.2;
  list-style-type: disc;
  margin-bottom: 0;
  margin-right: 0;
  margin-top: 0;
  padding-bottom: 0;
  padding-right: 0;
  padding-top: 0;
}

.calibre31 {
  display: block;
  line-height: 1.2;
  list-style-type: circle;
  margin-bottom: 0;
  margin-right: 0;
  margin-top: 0;
  padding-bottom: 0;
  padding-right: 0;
  padding-top: 0;
}

.calibre32 {
  display: inline-block;
  height: auto;
  max-width: 100%;
  vertical-align: middle;
  width: auto;
  border: currentColor none 0;
  padding: 3px;
}

.calibre33 {
  background-color: #f7f7f7;
  border-radius: 3px;
  display: block;
  font-family: Consolas, Monaco, And ale Mono, Ubuntu Mono, monospace;
  line-height: 1.45;
  overflow: auto;
  white-space: pre-wrap;
  margin: 14px 0 0;
  border: currentColor none 0;
  padding: 16px;
}

.default {
  color: #777;
  display: block;
  line-height: 1.2;
  margin: 14px 0;
  border-left: #ddd solid 4px;
  padding: 5px 5px 5px 15px;
}

.default1 {
  color: #777;
  display: block;
  line-height: 1.2;
  margin: 0;
  border-left: #ddd solid 4px;
  padding: 5px 5px 5px 15px;
}

.root {
  display: block;
  position: relative;
}

.token {
  color: #999;
}

.token1 {
  color: #07a;
}

.token2 {
  color: #905;
}

.token3 {
  background: hsla(0, 0%, 100%, 0.5);
  color: #9a6e3a;
}

.token4 {
  color: #690;
}

.token5 {
  color: #dd4a68;
}

.token6 {
  color: #708090;
}

.tthhighlight-container {
  -moz-tab-size: 4;
  -o-tab-size: 4;
  background-color: transparent;
  border-radius: 4px;
  display: inline;
  font-family: Consolas, Monaco, And ale Mono, Ubuntu Mono, monospace;
  line-height: inherit;
  max-width: 100%;
  overflow: initial;
  tab-size: 4;
  white-space: pre-wrap;
  word-break: break-all;
  margin: 0;
  border: currentColor none 0;
  padding: 0;
}

.pcalibre:active {
  background-color: transparent;
}</style>
<style>
@page {
  margin-bottom: 5pt;
  margin-top: 5pt;
}</style>
<style>

</style>
<link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>
<body>
<div id="book-container"><div id="titlepage.xhtml"><div>

        <div>
            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="100%" height="100%" viewBox="0 0 800 1068" preserveAspectRatio="none">
                <image width="800" height="1068" xlink:href="data:image/jpg;base64,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6ADyv9n9f/r0AWKAGbB6n9P8KADYPU/p/hQA+gCv5X+z+v8A9egAoAl2D1P6f4UAGwep/T/CgBP3n+dtAEckfTB9e36H/PrxQAUAHlf7P6//AF6ADyv9n9f/AK9AFigCP95/nbQBH5X+z+v/ANegAoAl2D1P6f4UAReV/s/r/wDXoAlTofr/AEFAA6bv6j1/+v8A57UAReV/s/r/APXoAPK/2f1/+vQAeV/s/r/9egA/1X+c5z+Xp7dPzALFABQBX8r/AGf1/wDr0AHlf7P6/wD16ACOPrk/p+g/z6cUAS7B6n9P8KAIvK/2f1/+vQBYoAr+V/s/r/8AXoAl2D1P6f4UARf6r/Oc5/L09un5gFigCvQBYoAKAGbB6n9P8KAH0AFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFA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lpbadYWqLDaWFjbW9ra20CnIFraWqIkcYJOEVFGSTtB4P6tRorDLRWV9Elbrfrq33bbb7n6vRorDq0b2vorWWnlq211bbbNmtzYKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKAPDfjJ+z98I/j3ozaJ8VvAuieKbc27QWeoXNp9m1vSy/wAxbR/ENrs1XSm3ksWhnT5id248D5niPhXhzi/BPL+Icpjj4brmWsV5STT20SbtbZXV181xJwdwzxfgv7P4gymnjoPVSemvZNK/kk3bS/K2ZfwW/Zp+Cn7Pelvpnwq8B6P4emkgWG/1rBv/ABRqwHQ6p4ivS2qXJP3gJJCoIDKEIzWfDnB3DPCGEUOHspjSTv7ys56b3bulvZ8iV1vcy4b4I4Y4Qwihw/lMaV9OZr3r3e71S+Kz5UtPiV02fQ1fVH1QUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFADN49D+n+NAD6ACgAoAKAGbx6H9P8aAH0AFABQAUAM3j0P6f40APoAKACgAoAKACgAoAKACgBm8eh/T/GgB9ADN49D+n+NAD6ACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAKACgAoAZvHof0/xoAN49D+n+NABvHof0/xoAfQAUAFABQAUAFABQAzePQ/p/jQA+gBm8eh/T/GgA3j0P6f40AG8eh/T/GgA3j0P6f40APoAZvHof0/xoAN49D+n+NABvHof0/xoAfQBXl/i/D+lAEu8eh/T/GgCLzf9r9P/AK1AEn/LP/P96gBd49D+n+Nc4EVdB0B5v+1+n/1qDnD/AJa/5/vUASv0H1/oa5wH10AM2D1P6f4UAPoAKACgAoAr0AFAEu8eh/T/ABoAN49D+n+NAEVAEu8eh/T/ABoAi83/AGv0/wDrUAHm/wC1+n/1qACgCXePQ/p/jQBFQBYoAr0HQHm/7X6f/WoOcl3j0P6f40ARUAHm/wC1+n/1qALFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAUAFABQAx+g+v9DQA+gAoAKAGJ0P1/oKAB+g+v9DQAJ0P1/oKAH0AMfoPr/Q0ARUAFAEqdD9f6CgAfoPr/AENAEVABQAUAFABQAUAFABQAUAFABQAUAFABXOdAV0HOFB0BXOAV0ASp0P1/oKDnB+g+v9DXOXDd+n6oiroNQrnAK6DnCuc6AroAKAJP+Wf+f71c5zkdB0BXQAVzgFdAFig5xj9B9f6GgCKgAoAKACgAoAKDoIn6j6f1Nc9fp8v1AlroAKACgAoAKACgArnodfn+gBXQAUAFABQAUAFADX+6fw/mKCYfCvn+bGJ1P0/qK5yi0nQ/X+groOcfQAUAFABQAUAFABQAUAFABQAUAFABQB//2Q=="></image>
            </svg>
        </div>
    </div></div>
<div id="index.html"><div class="calibre">
<div id="index.html.main" class="calibre1"><div class="root"><div class="book-toc"><h1 class="calibre2">目&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;录</h1><ol class="calibre3"><li class="calibre4"><a href="#index.html" class="pcalibre calibre5">Real World Haskell 中文版</a></li><li class="calibre4"><a href="#chp-1.html" class="pcalibre calibre5">第一章：入门</a></li><li class="calibre4"><a href="#chp-2.html" class="pcalibre calibre5">第二章：类型和函数</a></li><li class="calibre4"><a href="#chp-3.html" class="pcalibre calibre5">第三章：Defining Types, Streamlining Functions</a></li><li class="calibre4"><a href="#chp-4.html" class="pcalibre calibre5">第四章：函数式编程</a></li><li class="calibre4"><a href="#chp-5.html" class="pcalibre calibre5">第五章：编写 JSON 库</a></li><li class="calibre4"><a href="#chp-6.html" class="pcalibre calibre5">第六章：类型类</a></li><li class="calibre4"><a href="#chp-7.html" class="pcalibre calibre5">第七章：I/O</a></li><li class="calibre4"><a href="#chp-8.html" class="pcalibre calibre5">第八章：高效文件处理、正则表达式、文件名匹配</a></li><li class="calibre4"><a href="#chp-9.html" class="pcalibre calibre5">第九章：I/O学习 —— 构建一个用于搜索文件系统的库</a></li><li class="calibre4"><a href="#chp-10.html" class="pcalibre calibre5">第十章：代码案例学习：解析二进制数据格式</a></li><li class="calibre4"><a href="#chp-11.html" class="pcalibre calibre5">第十一章：测试和质量保障</a></li><li class="calibre4"><a href="#chp-13.html" class="pcalibre calibre5">第十三章：数据结构</a></li><li class="calibre4"><a href="#chp-18.html" class="pcalibre calibre5">第十八章： Monad变换器</a></li><li class="calibre4"><a href="#chp-19.html" class="pcalibre calibre5">第十九章： 错误处理</a></li><li class="calibre4"><a href="#chp-20.html" class="pcalibre calibre5">第二十章：使用 Haskell 进行系统编程</a></li><li class="calibre4"><a href="#chp-21.html" class="pcalibre calibre5">第二十一章：数据库的使用</a></li><li class="calibre4"><a href="#chp-22.html" class="pcalibre calibre5">第二十二章：扩展示例 —— Web 客户端编程</a></li><li class="calibre4"><a href="#chp-27.html" class="pcalibre calibre5">第二七章：Socket 和 Syslog</a></li><li class="calibre4"><a href="#chp-28.html" class="pcalibre calibre5">第二十八章：软件事务内存 (STM)</a></li><li class="calibre4"><a href="#convention.html" class="pcalibre calibre5">翻译约定</a></li></ol></div></div></div></div></div>
<div id="chp-1.html"><div class="calibre">
<div id="chp-1.html.main" class="calibre1"><div class="root"><div class="article"><h1 class="article-head" id="chp-1.html.calibre_toc_1">第一章：入门</h1><div class="article-body"><h1 class="calibre6"><a id="chp-1.html._0" class="calibre7 pcalibre"></a>第一章：入门</h1>
<h2 class="calibre8"><a id="chp-1.html.Haskell_2" class="calibre7 pcalibre"></a>Haskell编程环境</h2>
<p class="calibre9">在本书的前面一些章节里，我们有时候会以限制性的、简单的形式来介绍一些概念。由于Haskell是一本比较深的语言，所以一次性介绍某个主题的所有特性会令人难以接受。当基础巩固后，我们就会进行更加深入的学习。</p>
<p class="calibre9">在Haskell语言的众多实现中，有两个被广泛应用，Hugs和GHC。其中Hugs是一个解析器，主要用于教学。而GHC(GlasgowHaskellCompiler)更加注重实践，它编译成本地代码，支持并行执行，并带有更好的性能分析工具和调试工具。由于这些因素，在本书中我们将采用GHC。</p>
<p class="calibre9">GHC主要有三个部分组成。</p>
<ul class="calibre10"><li class="calibre11"><strong class="calibre12">ghc</strong>是生成快速本底代码的优化编译器。</li><li class="calibre11"><strong class="calibre12">ghci</strong>是一个交互解析器和调试器。</li><li class="calibre11"><strong class="calibre12">runghc</strong>是一个以脚本形式(并不要首先编译)运行Haskell代码的程序，</li></ul>
<blockquote class="default"><p class="calibre9">Note</p></blockquote>
<blockquote class="default"><p class="calibre9">我们如何称呼GHC的各个组件</p></blockquote>
<blockquote class="default"><p class="calibre9">当我们讨论整个GHC系统时，我们称之为GHC。而如果要引用到某个特定的命令，我们会直接用其名字标识，比如<strong class="calibre12">ghc</strong>，<strong class="calibre12">ghci</strong>，<strong class="calibre12">runghc</strong>。</p></blockquote>
<p class="calibre9">在本书中，我们假定你在使用最新版6.8.2版本的GHC，这个版本是2007年发布的。大多数例子不要额外的修改也能在老的版本上运行。然而，我们<em class="calibre13">建议</em>使用最新版本。如果你是Windows或者MacOSX操作系统，你可以使用预编译的安装包快速上手。你可以从<a href="http://www.haskell.org/ghc/download.html" target="_blank" class="calibre7 pcalibre">GHC下载页面</a> 找到合适的二进制包或者安装包。</p>
<p class="calibre9">对于大多数的Linux版本，BSD提供版和其他Unix系列，你可以找到自定义的GHC二进制包。由于这些包要基于特性的环境编译，所以安装和使用显得更加容易。你可以在GHC的<a href="http://www.haskell.org/ghc/distribution_packages.html" target="_blank" class="calibre7 pcalibre">二进制发布包页面</a> 找到相关下载。</p>
<p class="calibre9">我们在[附录A]中提供了更多详细的信息介绍如何在各个流行平台上安装GHC。</p>
<h2 class="calibre14"><a id="chp-1.html.ghci_26" class="calibre7 pcalibre"></a>初识解释器ghci</h2>
<p class="calibre9"><strong class="calibre12">ghci</strong>程序是GHC的交互式解析器。它可以让用户输入Haskell表达式并对其求值，浏览模块以及调试代码。如果你熟悉Python或是Ruby，那么ghci一定程度上和python，irb很像，这两者分别是Python和Ruby的交互式解析器。</p>
<pre class="calibre15"><code class="tthhighlight-container">The ghci command has a narrow focus
We typically can not copy some code out of a haskell source file and paste it into ghci<span class="token">.</span> This does not have a significant effect on debugging pieces of code<span class="token">,</span> but it can initially be surprising <span class="token1">if</span> you are used to <span class="token">,</span> say<span class="token">,</span> the interactive Python interpreter<span class="token">.</span>

</code></pre>
<p class="calibre9">在类Unix系统中，我们在shell视窗下运行<strong class="calibre12">ghci</strong>。而在Windows系统下，你可以通过开始菜单找到它。比如，如果你在WindowsXP下安装了GHC，你应该从”所有程序”，然后”GHC”下找到<strong class="calibre12">ghci</strong>。(参考<a href="http://book.realworldhaskell.org/read/installing-ghc-and-haskell-libraries.html#install.win" target="_blank" class="calibre7 pcalibre">附录A章节Windows</a> 里的截图。)</p>
<p class="calibre9">当我们运行<strong class="calibre12">ghci</strong>时，它会首先显示一个初始banner，然后就显示提示符Prelude&gt;。下载例子展示的是Linux环境下的6.8.3版本。</p>
<pre class="calibre15"><code class="tthhighlight-container">$ ghci
GHCi<span class="token">,</span> version <span class="token2">6.8</span><span class="token2">.3</span><span class="token">:</span> http<span class="token">:</span><span class="token3">/</span><span class="token3">/</span>www<span class="token">.</span>haskell<span class="token">.</span>org<span class="token3">/</span>ghc<span class="token3">/</span>  <span class="token">:</span><span class="token3">?</span> <span class="token1">for</span> help
Loading package base <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Prelude<span class="token3">&gt;</span>

</code></pre>
<p class="calibre9">提示符Prelude标识一个很常用的库Prelude已经被加载并可以使用。同样的，当加载了其他模块或是源文件时，它们也会在出现在提示符的位子。</p>
<p class="calibre9">Tip</p>
<p class="calibre9">获取帮助信息</p>
<p class="calibre9">在ghci提示符输入 :?，则会显示详细的帮助信息。</p>
<p class="calibre9">模块Prelude有时候被称为“标准序幕”(the standardprelude)，因为它的内容是基于Haskell 98标准定义的。通常简称它为“序幕”(theprelude)。</p>
<blockquote class="default"><p class="calibre9">Note</p></blockquote>
<blockquote class="default"><p class="calibre9">关于ghci的提示符</p></blockquote>
<blockquote class="default"><p class="calibre9">提示符经常是随着模块的加载而变化。因此经常会变得很长以至在单行中没有太多可视区域用来输入。</p></blockquote>
<p class="calibre9">为了简单和一致起见，在本书中我们会用字符串 ‘ghci&gt;' 来替代ghci的默认提示符。</p>
<p class="calibre9">你可以用ghci的 :setprompt 来进行修改。</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>set prompt <span class="token4">"ghci&gt;"</span>
ghci<span class="token3">&gt;</span>

</code></pre>
<p class="calibre9">prelude模块中的类型，值和函数是默认直接可用的，在使用之前我们不需要额外的操作。然而如果需要其他模块中的一些定义，则需要使用<strong class="calibre12">ghci</strong>的**:module**方法预先加载。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>module <span class="token3">+</span> Data<span class="token">.</span>Ratio

</code></pre>
<p class="calibre9">现在我们就可以使用Data.Ratio模块中的功能了。这个模块提供了一些操作有理数的功能。<br class="calibre1"><br>
基本交互: 把ghci当作一个计算器 除了能提供测试代码片段的交互功能外，ghci也可以被当作一个桌面计算器来使用。我们可以很容易的表示基本运算，同时随着对Haskell了解的深入，也可以表示更加复杂的运算。即使是以如此简单的方式来使用这个解析器，也可以帮助我们了解更多关于Haskell是如何工作的。 基本算术运算 我们可以马上开始输入一些表达式，看看ghci会怎么处理它们。基本的算术表达式类似于像C或是Python这样的语言：用中缀表达式，即操作符在操作数之间。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token2">2</span> <span class="token3">+</span> <span class="token2">2</span>
<span class="token2">4</span>
ghci<span class="token3">&gt;</span> <span class="token2">31337</span> <span class="token3">*</span> <span class="token2">101</span>
<span class="token2">3165037</span>
ghci<span class="token3">&gt;</span> <span class="token2">7.0</span> <span class="token3">/</span> <span class="token2">2.0</span>
<span class="token2">3.5</span>

</code></pre>
<p class="calibre9">用中缀表达式是为了书写方便：我们同样可以用前缀表达式，即操作符在操作数之前。在这种情况下，我们需要用括号将操作符括起来。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token2">2</span> <span class="token3">+</span> <span class="token2">2</span>
<span class="token2">4</span>
ghci<span class="token3">&gt;</span> <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token2">2</span> <span class="token2">2</span>
<span class="token2">4</span>

</code></pre>
<p class="calibre9">上述的这些表达式暗示了一个概念，Haskell有整数和浮点数类型。整数的大小是随意的。下面例子中的(^)表示了整数的乘方。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token2">313</span> <span class="token3">^</span> <span class="token2">15</span>
<span class="token2">27112218957718876716220410905036741257</span>

</code></pre>
<h2 class="calibre14"><a id="chp-1.html.quirk_110" class="calibre7 pcalibre"></a>算术奇事(quirk),负数的表示</h2>
<p class="calibre9">在如何表示数字方面Haskell提供给我们一个特性：通常需要将负数写在括号内。当我们要表示不是最简单的表达式时，这个特性就开始发挥影响。</p>
<p class="calibre9">我们先开始表示简单的负数</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token3">-</span><span class="token2">3</span>
<span class="token3">-</span><span class="token2">3</span>

</code></pre>
<p class="calibre9">上述例子中的-是一元表达式。换句话说，我们并不是写了一个数字“-3”；而是一个数字“3”，然后作用于操作符-。-是Haskell中唯一的一元操作符，而且我们也不能将它和中缀运算符一起使用。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token2">2</span> <span class="token3">+</span> <span class="token3">-</span><span class="token2">3</span>

<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">1</span><span class="token">:</span><span class="token2">0</span><span class="token">:</span>
    precedence parsing error
        cannot mix `<span class="token">(</span><span class="token3">+</span><span class="token">)</span><span class="token4">' [infixl 6] and prefix `-'</span> <span class="token">[</span>infixl <span class="token2">6</span><span class="token">]</span> <span class="token1">in</span> the same infix expression

</code></pre>
<p class="calibre9">如果需要在一个中缀操作符附近使用一元操作符，则需要将一元操作符以及其操作数包含的括号内。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token2">2</span> <span class="token3">+</span> <span class="token">(</span><span class="token3">-</span><span class="token2">3</span><span class="token">)</span>
<span class="token3">-</span><span class="token2">1</span>
ghci<span class="token3">&gt;</span> <span class="token2">3</span> <span class="token3">+</span> <span class="token">(</span><span class="token3">-</span><span class="token">(</span><span class="token2">13</span> <span class="token3">*</span> <span class="token2">37</span><span class="token">)</span><span class="token">)</span>
<span class="token3">-</span><span class="token2">478</span>

</code></pre>
<p class="calibre9">如此可以避免解析的不确定性。当在Haskell应用(apply)一个函数时，我们先写函数名，然后随之其参数，比如f3。如果我们不用括号括起一个负数，就会有非常明显的不同的方式理解f-3：它可以是“将函数f应用(apply)与数字-3”，或者是“把变量f减去3”。</p>
<p class="calibre9"><em class="calibre13">大多数</em>情况下，我们可以省略表达式中的空格(“空”字符比如空格或制表符tab)，Haskell也同样能正确的解析。但并不是所有的情况。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token2">2</span><span class="token3">*</span><span class="token2">3</span>
<span class="token2">6</span>

</code></pre>
<p class="calibre9">下面的例子和上面有问题的负数的例子很像，然而它的错误信息并不一样。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token2">2</span><span class="token3">*</span><span class="token3">-</span><span class="token2">3</span>

<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">1</span><span class="token">:</span><span class="token2">1</span><span class="token">:</span> Not <span class="token1">in</span> scope<span class="token">:</span> `<span class="token3">*</span><span class="token3">-</span>'

</code></pre>
<p class="calibre9">这里Haskell把*-理解成单个的操作符。Haskell允许用户自定义新的操作符（这个主题我们随后会讲到），但是我们未曾定义过*-。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token2">2</span><span class="token3">*</span><span class="token">(</span><span class="token3">-</span><span class="token2">3</span><span class="token">)</span>
<span class="token3">-</span><span class="token2">6</span>

</code></pre>
<p class="calibre9">相比较其他的编程语言，这种对于负数不太一样的行为可能会很些怪异，然后它是一种合理的折中方式。Haskell允许用户在任何时候自定义新的操作符。这是一个并不深奥的语言特性，我们会在以后的章节中看到许多用户定义的操作符。语言的设计者们为了拥有这个表达式强项而接受了这个有一点累赘的负数表达语法。</p>
<h2 class="calibre14"><a id="chp-1.html._170" class="calibre7 pcalibre"></a>布尔逻辑，运算符以及值比较</h2>
<p class="calibre9">Haskell中表示布尔逻辑的值有这么两个：True和False。名字中的大写很重要。作用于布尔值得操作符类似于C语言的情况：(&amp;&amp;)表示“逻辑与”，(||)表示“逻辑或”。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> True <span class="token3">&amp;&amp;</span> False
False
ghci<span class="token3">&gt;</span> False <span class="token3">||</span> True
True

</code></pre>
<p class="calibre9">有些编程语言中会定义数字0和False同义，但是在Haskell中并没有这么定义，同样的，也Haskell也没有定义非0的值为True。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> True <span class="token3">&amp;&amp;</span> <span class="token2">1</span>

<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">1</span><span class="token">:</span><span class="token2">8</span><span class="token">:</span>
    No instance <span class="token1">for</span> <span class="token">(</span>Num Bool<span class="token">)</span>
      arising from the literal `<span class="token2">1</span>' at <span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">1</span><span class="token">:</span><span class="token2">8</span>
    Possible fix<span class="token">:</span> add an instance declaration <span class="token1">for</span> <span class="token">(</span>Num Bool<span class="token">)</span>
    In the second argument of `<span class="token">(</span><span class="token3">&amp;&amp;</span><span class="token">)</span><span class="token4">', namely `1'</span>
    In the expression<span class="token">:</span> True <span class="token3">&amp;&amp;</span> <span class="token2">1</span>
    In the definition of `it'<span class="token">:</span> it <span class="token3">=</span> True <span class="token3">&amp;&amp;</span> <span class="token2">1</span>

</code></pre>
<p class="calibre9">我们再一次的遇到了很有前瞻性的错误。简单来说，错误信息告诉我们布尔类型，Bool，不是数字类型，Num的一个成员。错误信息有些长，这是因为ghci会定位出错的具体位置，并且给出了也许能解决问题的修改提示。 错误信息详细分析如下。 “No instance for (Num Bool)” 告诉我们ghci尝试解析数字1为Bool类型但是失败。 “arising from the literal <code class="calibre16">1'” 表示是由于使用了数字1而引发了问题。 “In the definition of</code>it'” 引用了一个ghci的快捷方式。我们会在后面提到。<br class="calibre1"><br>
Tip 遇到错误信息不要胆怯 这里我们提到了很重要的一点，而且在本书的前面一些章节中我们会重复提到。如果你碰到一些你从来没遇到过的问题和错误信息，别担心(panic)。刚开始的时候，你所要的做的仅仅是找出足够的信息来帮助解决问题。随着你经验的积累，你会发现错误信息中的一部分其实很容易理解，并不会像刚开始时那么晦涩难懂。 各种错误信息都有一个目的：通过提前的一些调试，帮助我们在真正运行程序之前能书写出正确的代码。如果你曾使用过其它更加宽松(permissive)的语言，这种方式可能会有些震惊(shock).所以，拿出你的耐心来。 Haskell中大多数比较操作符和C语言以及受C语言影响的语言类似。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token2">1</span> <span class="token3">==</span> <span class="token2">1</span>
True
ghci<span class="token3">&gt;</span> <span class="token2">2</span> <span class="token3">&lt;</span> <span class="token2">3</span>
True
ghci<span class="token3">&gt;</span> <span class="token2">4</span> <span class="token3">&gt;=</span> <span class="token2">3.99</span>
True

</code></pre>
<p class="calibre9">有一个操作符和C语言的相应的不一样，“不等于”。C语言中是用!=表示的，而Haskell是用/=表示的，它看上去很像数学中的≠。</p>
<p class="calibre9">另外，类C的语言中通常用!表示逻辑非的操作，而Haskell中用函数not。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> not True
False

</code></pre>
<h2 class="calibre14"><a id="chp-1.html._218" class="calibre7 pcalibre"></a>运算符优先级以及结合性</h2>
<p class="calibre9">类似于代数或是使用中缀操作符的编程语言，Haskell也有操作符优先级的概念。我们可以使用括号将部分表达显示的组合在一起，同时操作符优先级允许省略掉一些括号。比如乘法比加法优先级高，因此以下两个表达式效果是一样的。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token2">1</span> <span class="token3">+</span> <span class="token">(</span><span class="token2">4</span> <span class="token3">*</span> <span class="token2">4</span><span class="token">)</span>
<span class="token2">17</span>
ghci<span class="token3">&gt;</span> <span class="token2">1</span> <span class="token3">+</span> <span class="token2">4</span> <span class="token3">*</span> <span class="token2">4</span>
<span class="token2">17</span>

</code></pre>
<p class="calibre9">Haskell给每个操作符一个数值型的优先级值，从1表示最低优先级，到9表示最高优先级。高优先级的操作符先于低优先级的操作符被应用(apply)。在<strong class="calibre12">ghci</strong>中我们可以用命令**:info**来查看某个操作符的优先级。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>info <span class="token">(</span><span class="token3">+</span><span class="token">)</span>
class <span class="token">(</span>Eq a<span class="token">,</span> Show a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> Num a where
  <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> a
  <span class="token">.</span><span class="token">.</span><span class="token">.</span>
    <span class="token3">--</span> Defined <span class="token1">in</span> GHC<span class="token">.</span>Num
infixl <span class="token2">6</span> <span class="token3">+</span>
ghci<span class="token3">&gt;</span> <span class="token">:</span>info <span class="token">(</span><span class="token3">*</span><span class="token">)</span>
class <span class="token">(</span>Eq a<span class="token">,</span> Show a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> Num a where
  <span class="token">.</span><span class="token">.</span><span class="token">.</span>
  <span class="token">(</span><span class="token3">*</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> a
  <span class="token">.</span><span class="token">.</span><span class="token">.</span>
    <span class="token3">--</span> Defined <span class="token1">in</span> GHC<span class="token">.</span>Num
infixl <span class="token2">7</span> <span class="token3">*</span>

</code></pre>
<p class="calibre9">这里我们需要找的信息是“infixl 6+”，表示(+)的优先级是6。（其他信息我们稍后介绍。）“infixl 7*”表示(<em class="calibre13">)的优先级为7。由于(</em>)比(+)优先级高，所以我们看到为什么1+4<em class="calibre13">4和1+(4</em>4)值相同而不是(1+4)*4。</p>
<p class="calibre9">Haskell也定义了操作符的结合性(associativity)。它决定了当一个表达式中多次出现某个操作符时是否是从左到右求值。(+)和(*)都是左结合，在上述的<strong class="calibre12">ghci</strong>输出结果中以infixl表示。一个右结合的操作符会以infixr表示。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>info <span class="token">(</span><span class="token3">^</span><span class="token">)</span>
<span class="token">(</span><span class="token3">^</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Num a<span class="token">,</span> Integral b<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> b <span class="token3">-</span><span class="token3">&gt;</span> a   <span class="token3">--</span> Defined <span class="token1">in</span> GHC<span class="token">.</span>Real
infixr <span class="token2">8</span> <span class="token3">^</span>

</code></pre>
<p class="calibre9">优先级和结合性规则的组合通常称之为固定性(<em class="calibre13">fixity</em>)规则。</p>
<h2 class="calibre14"><a id="chp-1.html._262" class="calibre7 pcalibre"></a>未定义的变量以及定义变量</h2>
<p class="calibre9">Haskell的标准库prelude定义了至少一个大家熟知的数学常量。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> pi
<span class="token2">3.141592653589793</span>

</code></pre>
<p class="calibre9">然后我们很快就会发现它对数学常量的覆盖并不是很广泛。让我们来看下Euler数，e。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> e

<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">1</span><span class="token">:</span><span class="token2">0</span><span class="token">:</span> Not <span class="token1">in</span> scope<span class="token">:</span> `e'

</code></pre>
<p class="calibre9">啊哈，看上去我们必须得自己定义。</p>
<pre class="calibre15"><code class="tthhighlight-container">不要担心错误信息
以上“not <span class="token1">in</span> the scope”的错误信息看上去有点令人畏惧的。别担心，它所要表达的只是没有用e这个名字定义过变量。

</code></pre>
<p class="calibre9">使用ghci的let构造器(contruct)，我们可以定义一个临时变量e。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> let e <span class="token3">=</span> exp <span class="token2">1</span>

</code></pre>
<p class="calibre9">这是指数函数exp的一个应用，也是如何调用一个Haskell函数的第一个例子。像Python这些语言，函数的参数是位于括号内的，但Haskell不要那样。</p>
<p class="calibre9">既然e已经定义好了，我们就可以在数学表达式中使用它。我们之前用到的乘方操作符(^)是对于整数的。如果要用浮点数作为指数，则需要操作符(**)。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">(</span>e <span class="token3">*</span><span class="token3">*</span> pi<span class="token">)</span> <span class="token3">-</span> pi
<span class="token2">19.99909997918947</span>

</code></pre>
<blockquote class="default"><p class="calibre9">Note</p></blockquote>
<blockquote class="default"><p class="calibre9">这是ghci的特殊语法</p></blockquote>
<blockquote class="default"><p class="calibre9">ghci 中 let 的语法和常规的“top level”的Haskell程序的使用不太一样。我们会在章节“初识类型”里看到常规的语法形式。</p></blockquote>
<h2 class="calibre14"><a id="chp-1.html._310" class="calibre7 pcalibre"></a>处理优先级以及结合性规则</h2>
<p class="calibre9">有时候最好显式地加入一些括号，即使Haskell允许省略。它们会帮助将来的读者，包括我们自己，更好的理解代码的意图。</p>
<p class="calibre9">更加重要的，基于操作符优先级的复杂的表达式经常引发bug。对于一个简单的、没有括号的表达式，编译器和人总是很容易的对其意图产生不同的理解。</p>
<p class="calibre9">不需要去记住所有优先级和结合性规则：在你不确定的时候，加括号是最简单的方法。</p>
<h2 class="calibre14"><a id="chp-1.html.ghci_318" class="calibre7 pcalibre"></a>ghci里的命令行编辑</h2>
<p class="calibre9">在大多数系统中，<strong class="calibre12">ghci</strong>有些命令行编辑的功能。如果你对命令行编辑还不熟悉，它将会帮你节省大量的时间。基本操作对于类Unix系统和Windows系统都很常规。按下<strong class="calibre12">向上</strong>方向键会显示你输入的上一条命令；重复输入<strong class="calibre12">向上</strong>方向键则会找到更早的一些输入。可以使用<strong class="calibre12">向左</strong>和<strong class="calibre12">向右</strong>方向键在当前行移动。在类Unix系统中(很不幸，不是Windows)，<strong class="calibre12">制表键</strong>(tab)可以完成输入了一部分的标示符。</p>
<p class="calibre9">[译者注：]制表符的完成功能其实在Windows下也是可以的。</p>
<p class="calibre9">Tip</p>
<p class="calibre9">哪里可以找到更多信息</p>
<p class="calibre9">我们只是蜻蜓点水般的介绍了下命令行编辑功能。因为命令行编辑系统可以让你更加有效的工作，你可能会觉得进一步的学习会有帮助。</p>
<p class="calibre9">在类Unix系统下，<strong class="calibre12">ghci</strong>使用功能强大并且可定制化的<a href="http://tiswww.case.edu/php/chet/readline/rltop.html#Documentation" target="_blank" class="calibre7 pcalibre">GNU readlinelibrary</a> 。在Windows系统下，<strong class="calibre12">ghci</strong>的命令行编辑功能是由<a href="http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/doskey.mspx" target="_blank" class="calibre7 pcalibre">doskeycommand</a> 提供的。</p>
<h2 class="calibre14"><a id="chp-1.html.Lists_332" class="calibre7 pcalibre"></a>列表(Lists)</h2>
<p class="calibre9">一个列表由方括号以及被逗号分隔的元素组成。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">,</span> <span class="token2">3</span><span class="token">]</span>
<span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">]</span>

</code></pre>
<blockquote class="default"><p class="calibre9">Note</p></blockquote>
<blockquote class="default"><p class="calibre9">逗号是分隔符，不是终结符</p></blockquote>
<blockquote class="default"><p class="calibre9">有些语言在表示列表时会在右中括号前多一个逗号，但是Haskell没有这样做。如果多出一个逗号(比如 [1,2,] )，则会导致编译错误。</p></blockquote>
<p class="calibre9">列表可以是任意长度。空列表表示成[]。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">[</span><span class="token">]</span>
<span class="token">[</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> <span class="token">[</span><span class="token4">"foo"</span><span class="token">,</span> <span class="token4">"bar"</span><span class="token">,</span> <span class="token4">"baz"</span><span class="token">,</span> <span class="token4">"quux"</span><span class="token">,</span> <span class="token4">"fnord"</span><span class="token">,</span> <span class="token4">"xyzzy"</span><span class="token">]</span>
<span class="token">[</span><span class="token4">"foo"</span><span class="token">,</span><span class="token4">"bar"</span><span class="token">,</span><span class="token4">"baz"</span><span class="token">,</span><span class="token4">"quux"</span><span class="token">,</span><span class="token4">"fnord"</span><span class="token">,</span><span class="token4">"xyzzy"</span><span class="token">]</span>

</code></pre>
<p class="calibre9">列表里所有的元素必须是相同类型。下面例子我们违反了这个规则：列表中前面两个是Bool类型，最后一个是字符类型。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">[</span>True<span class="token">,</span> False<span class="token">,</span> <span class="token4">"testing"</span><span class="token">]</span>

<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">1</span><span class="token">:</span><span class="token2">14</span><span class="token">:</span>
    Couldn<span class="token4">'t match expected type `Bool'</span> against inferred type `<span class="token">[</span>Char<span class="token">]</span>'
      Expected type<span class="token">:</span> Bool
      Inferred type<span class="token">:</span> <span class="token">[</span>Char<span class="token">]</span>
    In the expression<span class="token">:</span> <span class="token4">"testing"</span>
    In the expression<span class="token">:</span> <span class="token">[</span>True<span class="token">,</span> False<span class="token">,</span> <span class="token4">"testing"</span><span class="token">]</span>

</code></pre>
<p class="calibre9">这次<strong class="calibre12">ghci</strong>的错误信息也是同样的很详细。它告诉我们无法把字符串转换为布尔类型，因此无法定义这个列表表达式的类型。</p>
<p class="calibre9">如果用*列举符号(enumerationnotation)*来表示一系列元素，Haskell则会自动填充内容。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">[</span><span class="token2">1.</span><span class="token2">.10</span><span class="token">]</span>
<span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">,</span><span class="token2">4</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">6</span><span class="token">,</span><span class="token2">7</span><span class="token">,</span><span class="token2">8</span><span class="token">,</span><span class="token2">9</span><span class="token">,</span><span class="token2">10</span><span class="token">]</span>

</code></pre>
<p class="calibre9">字符..在这里表示列举(enumeration)。它只能用于那些可以被列举的类型。因此对于字符类型来说这就没意义了。比如对于["foo".."quux"]，没有任何意思，也没有通用的方式来对其进行列举。</p>
<p class="calibre9">顺便提一下，上面例子生成了一个闭区间，列表包含了两个端点的元素。</p>
<p class="calibre9">当使用列举时，我们可以通过最初两个元素之间步调的大小，来指明后续元素如何生成。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">[</span><span class="token2">1.0</span><span class="token">,</span><span class="token2">1.25</span><span class="token">.</span><span class="token2">.2</span><span class="token2">.0</span><span class="token">]</span>
<span class="token">[</span><span class="token2">1.0</span><span class="token">,</span><span class="token2">1.25</span><span class="token">,</span><span class="token2">1.5</span><span class="token">,</span><span class="token2">1.75</span><span class="token">,</span><span class="token2">2.0</span><span class="token">]</span>

ghci<span class="token3">&gt;</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">4.</span><span class="token2">.15</span><span class="token">]</span>
<span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">4</span><span class="token">,</span><span class="token2">7</span><span class="token">,</span><span class="token2">10</span><span class="token">,</span><span class="token2">13</span><span class="token">]</span>

ghci<span class="token3">&gt;</span> <span class="token">[</span><span class="token2">10</span><span class="token">,</span><span class="token2">9.</span><span class="token2">.1</span><span class="token">]</span>
<span class="token">[</span><span class="token2">10</span><span class="token">,</span><span class="token2">9</span><span class="token">,</span><span class="token2">8</span><span class="token">,</span><span class="token2">7</span><span class="token">,</span><span class="token2">6</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">4</span><span class="token">,</span><span class="token2">3</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">1</span><span class="token">]</span>

</code></pre>
<p class="calibre9">上述的第二个例子中，终点元素并未包含的列表内，是由于它不属于我们定义的系列元素。</p>
<p class="calibre9">我们可以省略列举的终点(end point)。如果类型没有自然的“上限”(upperbound)，那么会生成无穷列表。比如，如果在<strong class="calibre12">ghci</strong>终端输入[1..]，那么就会输出一个无穷的连续数列，因此你不得不强制关闭或是杀掉<strong class="calibre12">ghci</strong>进程。在后面的章节章节中我们会看在Haskell中无穷数列经常会用到。</p>
<p class="calibre9">Note</p>
<p class="calibre9">列举浮点数时要注意的</p>
<p class="calibre9">下面的例子看上并不那么直观</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">[</span><span class="token2">1.0</span><span class="token">.</span><span class="token2">.1</span><span class="token2">.8</span><span class="token">]</span>
<span class="token">[</span><span class="token2">1.0</span><span class="token">,</span><span class="token2">2.0</span><span class="token">]</span>

</code></pre>
<p class="calibre9">为了避免浮点数舍入的问题，Haskell就从 1.0 到 1.8+0.5 进行了列举。</p>
<p class="calibre9">对浮点数的列举有时候会有点特别，如果你不得不用，要注意。浮点数在任何语言里都显得有些怪异(quirky)，Haskell也不例外。</p>
<h2 class="calibre14"><a id="chp-1.html._420" class="calibre7 pcalibre"></a>列表的操作符</h2>
<p class="calibre9">有两个常见的用于列表的操作符。连接两个列表时使用(++)。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">[</span><span class="token2">3</span><span class="token">,</span><span class="token2">1</span><span class="token">,</span><span class="token2">3</span><span class="token">]</span> <span class="token3">++</span> <span class="token">[</span><span class="token2">3</span><span class="token">,</span><span class="token2">7</span><span class="token">]</span>
<span class="token">[</span><span class="token2">3</span><span class="token">,</span><span class="token2">1</span><span class="token">,</span><span class="token2">3</span><span class="token">,</span><span class="token2">3</span><span class="token">,</span><span class="token2">7</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> <span class="token">[</span><span class="token">]</span> <span class="token3">++</span> <span class="token">[</span>False<span class="token">,</span>True<span class="token">]</span> <span class="token3">++</span> <span class="token">[</span>True<span class="token">]</span>
<span class="token">[</span>False<span class="token">,</span>True<span class="token">,</span>True<span class="token">]</span>

</code></pre>
<p class="calibre9">更加基础的操作符是(:)，用于增加一个元素到列表的头部。它读成“cons”（即“construct”的简称）。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token2">1</span> <span class="token">:</span> <span class="token">[</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">]</span>
<span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> <span class="token2">1</span> <span class="token">:</span> <span class="token">[</span><span class="token">]</span>
<span class="token">[</span><span class="token2">1</span><span class="token">]</span>

</code></pre>
<p class="calibre9">你可能会尝试[1,2]:3给列表末尾增加一个元素，然而<strong class="calibre12">ghci</strong>会拒绝这样的表达式并给出错误信息，因为(:)的第一个参数必须是单个元素同时第二个必须是一个列表。</p>
<h2 class="calibre14"><a id="chp-1.html._444" class="calibre7 pcalibre"></a>字符串和字符</h2>
<p class="calibre9">如果你熟悉Perl或是C语言，你会发现Haskell里表示字符串的符号很熟悉。</p>
<p class="calibre9">双引号所包含的就表示一个文本字符串。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token4">"This is a string."</span>
<span class="token4">"This is a string."</span>

</code></pre>
<p class="calibre9">像其他语言一样，那些不显而易见的字符(hard-to-see)需要“转意”(escaping)。Haskell中需要转意的字符以及转意规则绝大大部分是和C语言中的情况一样的。比如'\n'表示换行，'\t'表示制表符。完整的详细列表可以参照<a href="http://book.realworldhaskell.org/read/characters-strings-and-escaping-rules.html" target="_blank" class="calibre7 pcalibre">附录B：字符，字符串和转意规则</a> 。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> putStrLn <span class="token4">"Here's a newline --&gt;\n&lt;-- See?"</span>
Here's a newline <span class="token3">--</span><span class="token3">&gt;</span>
<span class="token3">&lt;</span><span class="token3">--</span> See<span class="token3">?</span>

</code></pre>
<p class="calibre9">函数putStrLn用于打印一个字符串。</p>
<p class="calibre9">Haskell区分单个字符和文本字符串。单个字符用单引号包含。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token4">'a'</span>
<span class="token4">'a'</span>

</code></pre>
<p class="calibre9">事实上，文本字符串是单一字符的列表。下面例子展示了表示一个短字符串的痛苦方式，而<strong class="calibre12">ghci</strong>的显示结果却是我们很熟悉的形式。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> let a <span class="token3">=</span> <span class="token">[</span><span class="token4">'l'</span><span class="token">,</span> <span class="token4">'o'</span><span class="token">,</span> <span class="token4">'t'</span><span class="token">,</span> <span class="token4">'s'</span><span class="token">,</span> <span class="token4">' '</span><span class="token">,</span> <span class="token4">'o'</span><span class="token">,</span> <span class="token4">'f'</span><span class="token">,</span> <span class="token4">' '</span><span class="token">,</span> <span class="token4">'w'</span><span class="token">,</span> <span class="token4">'o'</span><span class="token">,</span> <span class="token4">'r'</span><span class="token">,</span> <span class="token4">'k'</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> a
<span class="token4">"lots of work"</span>
ghci<span class="token3">&gt;</span> a <span class="token3">==</span> <span class="token4">"lots of work"</span>
True

</code></pre>
<p class="calibre9">""表示空字符串，它和[]同义。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token4">""</span> <span class="token3">==</span> <span class="token">[</span><span class="token">]</span>
True

</code></pre>
<p class="calibre9">既然字符串就是单一字符的列表，那么我们就可以用列表的操作符来构造一个新的字符串。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token4">'a'</span><span class="token">:</span><span class="token4">"bc"</span>
<span class="token4">"abc"</span>
ghci<span class="token3">&gt;</span> <span class="token4">"foo"</span> <span class="token3">++</span> <span class="token4">"bar"</span>
<span class="token4">"foobar"</span>

</code></pre>
<h2 class="calibre14"><a id="chp-1.html._504" class="calibre7 pcalibre"></a>初识类型</h2>
<p class="calibre9">尽管前面的内容里提到了一些类型方面的事情，但直到目前为止，我们还没有使用ghci进行过任何类型方面的交互：即使不告诉ghci输入是什么类型，它也会很高兴地接受传给它的输入。</p>
<p class="calibre9">需要提醒的是，在Haskell里，所有类型名字都以大写字母开头，而所有变量名字都以小写字母开头。紧记这一点，你就不会弄错类型和变量。</p>
<p class="calibre9">我们探索类型世界的第一步是修改ghci，让它在返回表达式的求值结果时，打印出这个结果的类型。使用 ghci 的:set命令可以做到这一点：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>set <span class="token3">+</span>t

Prelude<span class="token3">&gt;</span> <span class="token4">'c'</span>    <span class="token3">--</span> 输入表达式
<span class="token4">'c'</span>             <span class="token3">--</span> 输出值
it <span class="token">:</span><span class="token">:</span> Char      <span class="token3">--</span> 输出值的类型

Prelude<span class="token3">&gt;</span> <span class="token4">"foo"</span>
<span class="token4">"foo"</span>
it <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Char<span class="token">]</span>

</code></pre>
<p class="calibre9">注意打印信息中那个神秘的 it ：这是一个有特殊用途的变量，ghci将最近一次求值所得的结果保存在这个变量里。（这不是Haskell语言的特性，只是 ghci 的一个辅助功能而已。）</p>
<p class="calibre9">Ghci 打印的类型信息可以分为几个部分：</p>
<ul class="calibre10"><li class="calibre11">它打印出 it</li><li class="calibre11">x::y 表示表达式 x 的类型为 y</li><li class="calibre11">第二个表达式的值的类型为 [Char] 。（类型 String 是 [Char]的一个别名，它通常用于代替 [Char] 。）</li></ul>
<p class="calibre9">以下是另一个我们已经见过的类型：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token2">7</span> <span class="token3">^</span> <span class="token2">80</span>
<span class="token2">40536215597144386832065866109016673800875222251012083746192454448001</span>
it <span class="token">:</span><span class="token">:</span> Integer

</code></pre>
<p class="calibre9">Haskell 的整数类型为 Integer 。 Integer类型值的长度只受限于系统的内存大小。</p>
<p class="calibre9">分数和整数看上去不太相同，它使用 %操作符构建，其中分子放在操作符左边，而分母放在操作符右边：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>m <span class="token3">+</span>Data<span class="token">.</span>Ratio
Prelude Data<span class="token">.</span>Ratio<span class="token3">&gt;</span> <span class="token2">11</span> <span class="token3">%</span> <span class="token2">29</span>
<span class="token2">11</span> <span class="token3">%</span> <span class="token2">29</span>
it <span class="token">:</span><span class="token">:</span> Ratio Integer

</code></pre>
<p class="calibre9">这里的 :m 是 :module 的缩写，用于载入一个给定模块。Ghci还提供了很多这类缩写，方便使用者。</p>
<p class="calibre9">为了方便起见， ghci 给很多命令都提供了缩写，这里的 :m 就是 :module的缩写，它用于载入给定的模块。</p>
<p class="calibre9">注意这个分数的类型信息：在 :: 的右边，有两个单词，分别是 Ratio 和Integer，可以将这个类型读作“由整数构成的分数”。这说明，分数的分子和分母必须都是整数类型，如果用一些别的类型值来构建分数，就会造成出错：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude Data<span class="token">.</span>Ratio<span class="token3">&gt;</span> <span class="token2">3.14</span> <span class="token3">%</span> <span class="token2">8</span>

<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">8</span><span class="token">:</span><span class="token2">1</span><span class="token">:</span>
    Ambiguous type variable `a0' <span class="token1">in</span> the constraints<span class="token">:</span>
        <span class="token">(</span>Fractional a0<span class="token">)</span>
            arising from the literal `<span class="token2">3.14</span>' at <span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">8</span><span class="token">:</span><span class="token2">1</span><span class="token3">-</span><span class="token2">4</span>
        <span class="token">(</span>Integral a0<span class="token">)</span> arising from a use of `<span class="token3">%</span>' at <span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">8</span><span class="token">:</span><span class="token2">6</span>
        <span class="token">(</span>Num a0<span class="token">)</span> arising from the literal `<span class="token2">8</span>' at <span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">8</span><span class="token">:</span><span class="token2">8</span>
    Probable fix<span class="token">:</span> add a type signature that fixes these type <span class="token5">variable</span><span class="token">(</span>s<span class="token">)</span>
    In the first argument of `<span class="token">(</span><span class="token3">%</span><span class="token">)</span><span class="token4">', namely `3.14'</span>
    In the expression<span class="token">:</span> <span class="token2">3.14</span> <span class="token3">%</span> <span class="token2">8</span>
    In an equation <span class="token1">for</span> `it'<span class="token">:</span> it <span class="token3">=</span> <span class="token2">3.14</span> <span class="token3">%</span> <span class="token2">8</span>

Prelude Data<span class="token">.</span>Ratio<span class="token3">&gt;</span> <span class="token2">1.2</span> <span class="token3">%</span> <span class="token2">3.4</span>

<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">9</span><span class="token">:</span><span class="token2">1</span><span class="token">:</span>
    Ambiguous type variable `a0' <span class="token1">in</span> the constraints<span class="token">:</span>
        <span class="token">(</span>Fractional a0<span class="token">)</span>
            arising from the literal `<span class="token2">1.2</span>' at <span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">9</span><span class="token">:</span><span class="token2">1</span><span class="token3">-</span><span class="token2">3</span>
        <span class="token">(</span>Integral a0<span class="token">)</span> arising from a use of `<span class="token3">%</span>' at <span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">9</span><span class="token">:</span><span class="token2">5</span>
    Probable fix<span class="token">:</span> add a type signature that fixes these type <span class="token5">variable</span><span class="token">(</span>s<span class="token">)</span>
    In the first argument of `<span class="token">(</span><span class="token3">%</span><span class="token">)</span><span class="token4">', namely `1.2'</span>
    In the expression<span class="token">:</span> <span class="token2">1.2</span> <span class="token3">%</span> <span class="token2">3.4</span>
    In an equation <span class="token1">for</span> `it'<span class="token">:</span> it <span class="token3">=</span> <span class="token2">1.2</span> <span class="token3">%</span> <span class="token2">3.4</span>

</code></pre>
<p class="calibre9">尽管每次都打印出值的类型很方便，但这实际上有点小题大作了。因为在一般情况下，表达式的类型并不难猜，或者我们并非对每个表达式的类型都感兴趣。所以这里用 :unset 命令取消对类型信息的打印：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude Data<span class="token">.</span>Ratio<span class="token3">&gt;</span> <span class="token">:</span>unset <span class="token3">+</span>t

Prelude Data<span class="token">.</span>Ratio<span class="token3">&gt;</span> <span class="token2">2</span>
<span class="token2">2</span>

</code></pre>
<p class="calibre9">取而代之的是，如果现在我们对某个值或者表达式的类型不清楚，那么可以用:type 命令显式地打印它的类型信息：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude Data<span class="token">.</span>Ratio<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token4">'a'</span>
<span class="token4">'a'</span> <span class="token">:</span><span class="token">:</span> Char

Prelude Data<span class="token">.</span>Ratio<span class="token3">&gt;</span> <span class="token4">"foo"</span>
<span class="token4">"foo"</span>

Prelude Data<span class="token">.</span>Ratio<span class="token3">&gt;</span> <span class="token">:</span>type it
it <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Char<span class="token">]</span>

</code></pre>
<p class="calibre9">注意 :type并不实际执行传给它的表达式，它只是对输入进行检查，然后将输入的类型信息打印出来。以下两个例子显示了其中的区别：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude Data<span class="token">.</span>Ratio<span class="token3">&gt;</span> <span class="token2">3</span> <span class="token3">+</span> <span class="token2">2</span>
<span class="token2">5</span>

Prelude Data<span class="token">.</span>Ratio<span class="token3">&gt;</span> <span class="token">:</span>type it
it <span class="token">:</span><span class="token">:</span> Integer

Prelude Data<span class="token">.</span>Ratio<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token2">3</span> <span class="token3">+</span> <span class="token2">2</span>
<span class="token2">3</span> <span class="token3">+</span> <span class="token2">2</span> <span class="token">:</span><span class="token">:</span> Num a <span class="token3">=</span><span class="token3">&gt;</span> a

</code></pre>
<p class="calibre9">在前两个表达式中，我们先求值 3+2 ，再使用 :type 命令打印 it的类型，因为这时 it 已经是 3+2 的结果 5 ，所以 :type打印这个值的类型 it::Integer 。</p>
<p class="calibre9">另一方面，最后的表达式中，我们直接将 3+2 传给 :type ，而 :type并不对输入进行求值，因此它返回表达式的类型 3+2::Numa=&gt;a 。</p>
<p class="calibre9">第六章会介绍更多类型签名的相关信息。</p>
<h2 class="calibre14"><a id="chp-1.html._630" class="calibre7 pcalibre"></a>行计数程序</h2>
<p class="calibre9">以下是一个用 Haskell写的行计数程序。如果暂时看不太懂源码也没关系，先照着代码写写程序，热热身就行了。</p>
<p class="calibre9">使用编辑器，输入以下内容，并将它保存为 WC.hs ：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch01<span class="token3">/</span>WC<span class="token">.</span>hs
<span class="token3">--</span> lines beginning with <span class="token4">"--"</span> are comments<span class="token">.</span>

main <span class="token3">=</span> interact wordCount
    where wordCount input <span class="token3">=</span> show <span class="token">(</span>length <span class="token">(</span>lines input<span class="token">)</span><span class="token">)</span> <span class="token3">++</span> <span class="token4">"\n"</span>

</code></pre>
<p class="calibre9">再创建一个 quux.txt ，包含以下内容：</p>
<pre class="calibre15"><code class="tthhighlight-container">Teignmouth<span class="token">,</span> England
Paris<span class="token">,</span> France
Ulm<span class="token">,</span> Germany
Auxerre<span class="token">,</span> France
Brunswick<span class="token">,</span> Germany
Beaumont<span class="token3">-</span>en<span class="token3">-</span>Auge<span class="token">,</span> France
Ryazan<span class="token">,</span> Russia

</code></pre>
<p class="calibre9">然后，在 shell 执行以下代码：</p>
<pre class="calibre15"><code class="tthhighlight-container">$ runghc WC <span class="token3">&lt;</span> quux<span class="token">.</span>txt
<span class="token2">7</span>

</code></pre>
<p class="calibre9">恭喜你！你刚完成了一个非常有用的行计数程序（尽管它非常简单）。后面的章节会继续介绍更多有用的知识，帮助你（读者）写出属于自己的程序。</p>
<p class="calibre9">[译注：可能会让人有点迷惑，这个程序明明是一个行计数（line count）程序，为什么却命名为 WC（word count）呢？实际上，在接下来的练习小节中，读者需要对这个程序进行修改，将它的功能从行计数改为单词计数，因此这里程序被命名为 WC.hs 。]</p>
<h2 class="calibre14"><a id="chp-1.html._670" class="calibre7 pcalibre"></a>练习</h2>
<ol class="calibre17"><li class="calibre11">在<strong class="calibre12">ghci</strong>里尝试下以下的这些表达式看看它们的类型是什么？</li></ol>
<ul class="calibre10"><li class="calibre11">5+8</li><li class="calibre11">3*5+8</li><li class="calibre11">2+4</li><li class="calibre11">(+)24</li><li class="calibre11">sqrt16</li><li class="calibre11">succ6</li><li class="calibre11">succ7</li><li class="calibre11">pred9</li><li class="calibre11">pred8</li><li class="calibre11">sin(pi/2)</li><li class="calibre11">truncatepi</li><li class="calibre11">round3.5</li><li class="calibre11">round3.4</li><li class="calibre11">floor3.7</li><li class="calibre11">ceiling3.3</li></ul>
<ol class="calibre18"><li class="calibre11">在<strong class="calibre12">ghci</strong>里输入**:?**以或许帮助信息。定义一个变量，比如letx=1,然后输入:showbindings.你看到了什么？</li><li class="calibre11">函数words计算一个字符串中的单词个数。修改例子WC.hs，使得可以计算一个文件中的单词个数。</li><li class="calibre11">再次修改WC.hs，可以输出一个文件的字符个数。</li></ol>
</div></div></div></div></div></div>
<div id="chp-2.html"><div class="calibre">
<div id="chp-2.html.main" class="calibre1"><div class="root"><div class="article"><h1 class="article-head" id="chp-2.html.calibre_toc_2">第二章：类型和函数</h1><div class="article-body"><h1 class="calibre6"><a id="chp-2.html._0" class="calibre7 pcalibre"></a>第二章：类型和函数</h1>
<h2 class="calibre8"><a id="chp-2.html._2" class="calibre7 pcalibre"></a>类型是干什么用的？</h2>
<p class="calibre9">Haskell 中的每个函数和表达式都带有各自的类型，通常称一个表达式拥有类型 T ，或者说这个表达式的类型为 T 。举个例子，布尔值 True 的类型为 Bool ，而字符串 "foo" 的类型为 String 。一个值的类型标识了它和该类型的其他值所共有的一簇属性（property），比如我们可以对数字进行相加，对列表进行拼接，诸如此类。</p>
<p class="calibre9">在对 Haskell 的类型系统进行更深入的探讨之前，不妨先来了解下，我们为什么要关心类型 —— 也即是，它们是干什么用的？</p>
<p class="calibre9">在计算机的最底层，处理的都是没有任何附加结构的字节（byte）。而类型系统在这个基础上提供了<em class="calibre13">抽象</em>：它为那些单纯的字节加上了意义，使得我们可以说“这些字节是文本”，“那些字节是机票预约数据”，等等。</p>
<p class="calibre9">通常情况下，类型系统还会在标识类型的基础上更进一步：它会阻止我们混合使用不同的类型，避免程序错误。比如说，类型系统通常不会允许将一个酒店预约数据当作汽车租凭数据来使用。</p>
<p class="calibre9">引入抽象的使得我们可以忽略底层细节。举个例子，如果程序中的某个值是一个字符串，那么我不必考虑这个字符串在内部是如何实现的，只要像操作其他字符串一样，操作这个字符串就可以了。</p>
<p class="calibre9">类型系统的一个有趣的地方是，不同的类型系统的表现并不完全相同。实际上，不同类型系统有时候处理的还是不同种类的问题。</p>
<p class="calibre9">除此之外，一门语言的类型系统，还会深切地影响这门语言的使用者思考和编写程序的方式。而 Haskell 的类型系统则允许程序员以非常抽象的层次思考，并写出简洁、高效、健壮的代码。</p>
<h2 class="calibre14"><a id="chp-2.html.Haskell__18" class="calibre7 pcalibre"></a>Haskell 的类型系统</h2>
<p class="calibre9">Haskell 中的类型有三个有趣的方面：首先，它们是强（strong）类型的；其次，它们是静态（static）的；第三，它们可以通过自动推导（automatically inferred）得出。</p>
<p class="calibre9">后面的三个小节会分别讨论这三个方面，介绍它们的长处和短处，并列举 Haskell 类型系统的概念和其他语言里相关构思之间的相似性。</p>
<h2 class="calibre14"><a id="chp-2.html._24" class="calibre7 pcalibre"></a>强类型</h2>
<p class="calibre9">Haskell 的强类型系统会拒绝执行任何无意义的表达式，保证程序不会因为这些表达式而引起错误：比如将整数当作函数来使用，或者将一个字符串传给一个只接受整数参数的函数，等等。</p>
<p class="calibre9">遵守类型规则的表达式被称为是“类型正确的”（well typed），而不遵守类型规则、会引起类型错误的表达式被称为是“类型不正确的”（ill typed）。</p>
<p class="calibre9">Haskell 强类型系统的另一个作用是，它不会自动地将值从一个类型转换到另一个类型（转换有时又称为强制或变换）。举个例子，如果将一个整数值作为参数传给了一个接受浮点数的函数，C 编译器会自动且静默（silently）地将参数从整数类型转换为浮点类型，而 Haskell 编译器则会引发一个编译错误。</p>
<p class="calibre9">要在 Haskell 中进行类型转换，必须显式地使用类型转换函数。</p>
<p class="calibre9">有些时候，强类型会让某种类型代码的编写变得困难。比如说，一种编写底层 C 代码的典型方式就是将一系列字节数组当作复杂的数据结构来操作。这种做法的效率非常高，因为它避免了对字节的复制操作。因为 Haskell 不允许这种形式的转换，所以要获得同等结构形式的数据，可能需要进行一些复制操作，这可能会对性能造成细微影响。</p>
<p class="calibre9">强类型的最大好处是可以让 bug 在代码实际运行之前浮现出来。比如说，在强类型的语言中，“不小心将整数当成了字符串来使用”这样的情况不可能出现。</p>
<p class="calibre9">[注意：这里说的“bug”指的是类型错误，和我们常说的、通常意义上的 bug 有一些区别。]</p>
<h2 class="calibre14"><a id="chp-2.html._40" class="calibre7 pcalibre"></a>静态类型</h2>
<p class="calibre9">静态类型系统指的是，编译器可以在编译期（而不是执行期）知道每个值和表达式的类型。Haskell 编译器或解释器会察觉出类型不正确的表达式，并拒绝这些表达式的执行：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> True <span class="token3">&amp;&amp;</span> <span class="token4">"False"</span>

<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">2</span><span class="token">:</span><span class="token2">9</span><span class="token">:</span>
    Couldn<span class="token4">'t match expected type `Bool'</span> with actual type `<span class="token">[</span>Char<span class="token">]</span>'
    In the second argument of `<span class="token">(</span><span class="token3">&amp;&amp;</span><span class="token">)</span><span class="token4">', namely `"False"'</span>
    In the expression<span class="token">:</span> True <span class="token3">&amp;&amp;</span> <span class="token4">"False"</span>
    In an equation <span class="token1">for</span> `it'<span class="token">:</span> it <span class="token3">=</span> True <span class="token3">&amp;&amp;</span> <span class="token4">"False"</span>

</code></pre>
<p class="calibre9">类似的类型错误在之前已经看过了：编译器发现值 "False" 的类型为 [Char] ，而 (&amp;&amp;) 操作符要求两个操作对象的类型都为 Bool ，虽然左边的操作对象 True 满足类型要求，但右边的操作对象 "False" 却不能匹配指定的类型，因此编译器以“类型不正确”为由，拒绝执行这个表达式。 静态类型有时候会让某种有用代码的编写变得困难。在 Python 这类语言里， duck typing 非常流行， 只要两个对象的行为足够相似，那么就可以在它们之间进行互换。 幸运的是， Haskell 提供的 typeclass 机制以一种安全、方便、实用的方式提供了大部分动态类型的优点。Haskell 也提供了一部分对全动态类型（truly dynamic types）编程的支持，尽管用起来没有专门支持这种功能的语言那么方便。 Haskell 对强类型和静态类型的双重支持使得程序不可能发生运行时类型错误，这也有助于捕捉那些轻微但难以发现的小错误，作为代价，在编程的时候就要付出更多的努力[译注：比如纠正类型错误和编写类型签名]。Haskell 社区有一种说法，一旦程序编译通过，那么这个程序的正确性就会比用其他语言来写要好得多。（一种更现实的说法是，Haskell 程序的小错误一般都很少。） 使用动态类型语言编写的程序，常常需要通过大量的测试来预防类型错误的发生，然而，测试通常很难做到巨细无遗：一些常见的任务，比如重构，非常容易引入一些测试没覆盖到的新类型错误。 另一方面，在 Haskell 里，编译器负责检查类型错误：编译通过的 Haskell 程序是不可能带有类型错误的。而重构 Haskell 程序通常只是移动一些代码块，编译，修复编译错误，并重复以上步骤直到编译无错为止。 要理解静态类型的好处，可以用玩拼图的例子来打比方：在 Haskell 里，如果一块拼图的形状不正确，那么它就不能被使用。另一方面，动态类型的拼图全部都是 1 x 1 大小的正方形，这些拼图无论放在那里都可以匹配，为了验证这些拼图被放到了正确的地方，必须使用测试来进行检查。<br class="calibre1"><br>
类型推导 关于类型系统，最后要说的是，Haskell 编译器可以自动推断出程序中几乎所有表达式的类型[注：有时候要提供一些信息，帮助编译器理解程序代码]。这个过程被称为类型推导（type inference）。 虽然 Haskell 允许我们显式地为任何值指定类型，但类型推导使得这种工作通常是可选的，而不是非做不可的事。<br class="calibre1"><br>
正确理解类型系统 对 Haskell 类型系统能力和好处的探索会花费好几个章节。在刚开始的时候，处理 Haskell 的类型可能会让你觉得有些麻烦。 比如说，在 Python 和 Ruby 里，你只要写下程序，然后测试一下程序的执行结果是否正确就够了，但是在 Haskell ，你还要先确保程序能通过类型检查。那么，为什么要多走这些弯路呢？ 答案是，静态、强类型检查使得 Haskell 更安全，而类型推导则让它更精炼、简洁。这样得出的的结果是，比起其他流行的静态语言，Haskell 要来得更安全，而比起其他流行的动态语言， Haskell 的表现力又更胜一筹。 这并不是吹牛，等你看完这本书之后就会了解这一点。 修复编译时的类型错误刚开始会让人觉得增加了不必要的工作量，但是，换个角度来看，这不过是提前完成了调试工作：编译器在处理程序时，会将代码中的逻辑错误一一展示出来，而不是一声不吭，任由代码在运行时出错。 更进一步来说，因为 Haskell 里值和函数的类型都可以通过自动推导得出，所以 Haskell 程序既可以获得静态类型带来的所有好处，而又不必像传统的静态类型语言那样，忙于添加各种各样的类型签名[译注：比如 C 语言的函数原型声明] —— 在其他语言里，类型系统为编译器服务；而在 Haskell 里，类型系统为你服务。唯一的要求是，你需要学习如何在类型系统提供的框架下工作。 对 Haskell 类型的运用将遍布整本书，这些技术将帮助我们编写和测试实用的代码。<br class="calibre1"><br>
一些常用的基本类型 以下是 Haskell 里最常用的一些基本类型，其中有些在之前的章节里已经看过了： Char 单个 Unicode 字符。 Bool 表示一个布尔逻辑值。这个类型只有两个值： True 和 False 。 Int 带符号的定长（fixed-width）整数。这个值的准确范围由机器决定：在 32 位机器里， Int 为 32 位宽，在 64 位机器里， Int 为 64 位宽。Haskell 保证 Int 的宽度不少于 28 位。（数值类型还可以是 8 位、16 位，等等，也可以是带符号和无符号的，以后会介绍。） Integer 不限长度的带符号整数。 Integer 并不像 Int 那么常用，因为它们需要更多的内存和更大的计算量。另一方面，对 Integer 的计算不会造成溢出，因此使用 Integer 的计算结果更可靠。 Double 用于表示浮点数。长度由机器决定，通常是 64 位。（Haskell 也有 Float 类型，但是并不推荐使用，因为编译器都是针对 Double 来进行优化的，而 Float 类型值的计算要慢得多。） 在前面的章节里，我们已经见到过 :: 符号。除了用来表示类型之外，它还可以用于进行类型签名。比如说， exp :: T 就是向 Haskell 表示， exp 的类型是 T ，而 :: T 就是表达式 exp 的类型签名。如果一个表达式没有显式地指名类型的话，那么它的类型就通过自动推导来决定：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token4">'a'</span>
<span class="token4">'a'</span> <span class="token">:</span><span class="token">:</span> Char

Prelude<span class="token3">&gt;</span> <span class="token4">'a'</span>            <span class="token3">--</span> 自动推导
<span class="token4">'a'</span>

Prelude<span class="token3">&gt;</span> <span class="token4">'a'</span> <span class="token">:</span><span class="token">:</span> Char    <span class="token3">--</span> 显式签名
<span class="token4">'a'</span>

</code></pre>
<p class="calibre9">当然了，类型签名必须正确，否则 Haskell 编译器就会产生错误：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token4">'a'</span> <span class="token">:</span><span class="token">:</span> Int     <span class="token3">--</span> 试图将一个字符值标识为 Int 类型

<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">7</span><span class="token">:</span><span class="token2">1</span><span class="token">:</span>
    Couldn<span class="token4">'t match expected type `Int'</span> with actual type `Char'
    In the expression<span class="token">:</span> <span class="token4">'a'</span> <span class="token">:</span><span class="token">:</span> Int
    In an equation <span class="token1">for</span> `it<span class="token4">': it = '</span>a' <span class="token">:</span><span class="token">:</span> Int

</code></pre>
<h2 class="calibre14"><a id="chp-2.html._82" class="calibre7 pcalibre"></a>调用函数</h2>
<p class="calibre9">要调用一个函数，先写出它的名字，后接函数的参数：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> odd <span class="token2">3</span>
True

Prelude<span class="token3">&gt;</span> odd <span class="token2">6</span>
False

</code></pre>
<p class="calibre9">注意，函数的参数不需要用括号来包围，参数和参数之间也不需要用逗号来隔开[译注：使用空格就可以了]：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> compare <span class="token2">2</span> <span class="token2">3</span>
LT

Prelude<span class="token3">&gt;</span> compare <span class="token2">3</span> <span class="token2">3</span>
EQ

Prelude<span class="token3">&gt;</span> compare <span class="token2">3</span> <span class="token2">2</span>
GT

</code></pre>
<p class="calibre9">Haskell 函数的应用方式和其他语言差不多，但是格式要来得更简单。</p>
<p class="calibre9">因为函数应用的优先级比操作符要高，因此以下两个表达式是相等的：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">(</span>compare <span class="token2">2</span> <span class="token2">3</span><span class="token">)</span> <span class="token3">==</span> LT
True

Prelude<span class="token3">&gt;</span> compare <span class="token2">2</span> <span class="token2">3</span> <span class="token3">==</span> LT
True

</code></pre>
<p class="calibre9">有时候，为了可读性考虑，添加一些额外的括号也是可以理解的，上面代码的第一个表达式就是这样一个例子。另一方面，在某些情况下，我们<em class="calibre13">必须</em>使用括号来让编译器知道，该如何处理一个复杂的表达式：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> compare <span class="token">(</span>sqrt <span class="token2">3</span><span class="token">)</span> <span class="token">(</span>sqrt <span class="token2">6</span><span class="token">)</span>
LT

</code></pre>
<p class="calibre9">这个表达式将 sqrt3 和 sqrt6 的计算结果分别传给 compare 函数。如果将括号移走， Haskell 编译器就会产生一个编译错误，因为它认为我们将四个参数传给了只需要两个参数的 compare 函数：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> compare sqrt <span class="token2">3</span> sqrt <span class="token2">6</span>

<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">17</span><span class="token">:</span><span class="token2">1</span><span class="token">:</span>
    The <span class="token1">function</span> `compare' is applied to four arguments<span class="token">,</span>
    but its type `a0 <span class="token3">-</span><span class="token3">&gt;</span> a0 <span class="token3">-</span><span class="token3">&gt;</span> Ordering' has only two
    In the expression<span class="token">:</span> compare sqrt <span class="token2">3</span> sqrt <span class="token2">6</span>
    In an equation <span class="token1">for</span> `it'<span class="token">:</span> it <span class="token3">=</span> compare sqrt <span class="token2">3</span> sqrt <span class="token2">6</span>

</code></pre>
<h2 class="calibre14"><a id="chp-2.html._143" class="calibre7 pcalibre"></a>复合数据类型：列表和元组</h2>
<p class="calibre9">复合类型通过其他类型构建得出。列表和元组是 Haskell 中最常用的复合数据类型。</p>
<p class="calibre9">在前面介绍字符串的时候，我们就已经见到过列表类型了： String 是 [Char] 的别名，而 [Char] 则表示由 Char 类型组成的列表。</p>
<p class="calibre9">head 函数取出列表的第一个元素：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> head <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">,</span> <span class="token2">3</span><span class="token">,</span> <span class="token2">4</span><span class="token">]</span>
<span class="token2">1</span>

Prelude<span class="token3">&gt;</span> head <span class="token">[</span><span class="token4">'a'</span><span class="token">,</span> <span class="token4">'b'</span><span class="token">,</span> <span class="token4">'c'</span><span class="token">]</span>
<span class="token4">'a'</span>

Prelude<span class="token3">&gt;</span> head <span class="token">[</span><span class="token">]</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> Prelude<span class="token">.</span>head<span class="token">:</span> empty list

</code></pre>
<p class="calibre9">和 head 相反， tail 取出列表里除了第一个元素之外的其他元素：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> tail <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">,</span> <span class="token2">3</span><span class="token">,</span> <span class="token2">4</span><span class="token">]</span>
<span class="token">[</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">,</span><span class="token2">4</span><span class="token">]</span>

Prelude<span class="token3">&gt;</span> tail <span class="token">[</span><span class="token2">2</span><span class="token">,</span> <span class="token2">3</span><span class="token">,</span> <span class="token2">4</span><span class="token">]</span>
<span class="token">[</span><span class="token2">3</span><span class="token">,</span><span class="token2">4</span><span class="token">]</span>

Prelude<span class="token3">&gt;</span> tail <span class="token">[</span>True<span class="token">,</span> False<span class="token">]</span>
<span class="token">[</span>False<span class="token">]</span>

Prelude<span class="token3">&gt;</span> tail <span class="token4">"list"</span>
<span class="token4">"ist"</span>

Prelude<span class="token3">&gt;</span> tail <span class="token">[</span><span class="token">]</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> Prelude<span class="token">.</span>tail<span class="token">:</span> empty list

</code></pre>
<p class="calibre9">正如前面的例子所示， head 和 tail 函数可以处理不同类型的列表。将 head 应用于 [Char] 类型的列表，结果为一个 Char 类型的值，而将它应用于 [Bool] 类型的值，结果为一个 Bool 类型的值。 head 函数并不关心它处理的是何种类型的列表。</p>
<p class="calibre9">因为列表中的值可以是任意类型，所以我们可以称列表为类型<em class="calibre13">多态</em>（polymorphic）的。当需要编写带有多态类型的代码时，需要使用<em class="calibre13">类型变量</em>。这些类型变量以小写字母开头，作为一个占位符，最终被一个具体的类型替换。</p>
<p class="calibre9">比如说， [a] 用一个方括号包围一个类型变量 a ，表示一个“类型为 a 的列表”。这也就是说“我不在乎列表是什么类型，尽管给我一个列表就是了”。</p>
<p class="calibre9">当需要一个带有具体类型的列表时，就需要用一个具体的类型去替换类型变量。比如说， [Int] 表示一个包含 Int 类型值的列表，它用 Int 类型替换了类型变量 a 。又比如， [MyPersonalType] 表示一个包含 MyPersonalType 类型值的列表，它用 MyPersonalType 替换了类型变量 a 。</p>
<p class="calibre9">这种替换还还可以递归地进行： [[Int]] 是一个包含 [Int] 类型值的列表，而 [Int] 又是一个包含 Int 类型值的列表。以下例子展示了一个包含 Bool 类型的列表的列表：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token">[</span><span class="token">[</span>True<span class="token">]</span><span class="token">,</span> <span class="token">[</span>False<span class="token">,</span> False<span class="token">]</span><span class="token">]</span>
<span class="token">[</span><span class="token">[</span>True<span class="token">]</span><span class="token">,</span> <span class="token">[</span>False<span class="token">,</span> False<span class="token">]</span><span class="token">]</span> <span class="token">:</span><span class="token">:</span> <span class="token">[</span><span class="token">[</span>Bool<span class="token">]</span><span class="token">]</span>

</code></pre>
<p class="calibre9">假设现在要用一个数据结构，分别保存一本书的出版年份 —— 一个整数，以及这本书的书名 —— 一个字符串。很明显，列表不能保存这样的信息，因为列表只能接受类型相同的值。这时，我们就需要使用元组：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">(</span><span class="token2">1964</span><span class="token">,</span> <span class="token4">"Labyrinths"</span><span class="token">)</span>
<span class="token">(</span><span class="token2">1964</span><span class="token">,</span><span class="token4">"Labyrinths"</span><span class="token">)</span>

</code></pre>
<p class="calibre9">元组和列表非常不同，它们的两个属性刚刚相反：列表可以任意长，且只能包含类型相同的值；元组的长度是固定的，但可以包含不同类型的值。</p>
<p class="calibre9">元组的两边用括号包围，元素之间用逗号分割。元组的类型信息也使用同样的格式：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token">(</span>True<span class="token">,</span> <span class="token4">"hello"</span><span class="token">)</span>
<span class="token">(</span>True<span class="token">,</span> <span class="token4">"hello"</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Bool<span class="token">,</span> <span class="token">[</span>Char<span class="token">]</span><span class="token">)</span>

Prelude<span class="token3">&gt;</span> <span class="token">(</span><span class="token2">4</span><span class="token">,</span> <span class="token">[</span><span class="token4">'a'</span><span class="token">,</span> <span class="token4">'m'</span><span class="token">]</span><span class="token">,</span> <span class="token">(</span><span class="token2">16</span><span class="token">,</span> True<span class="token">)</span><span class="token">)</span>
<span class="token">(</span><span class="token2">4</span><span class="token">,</span><span class="token4">"am"</span><span class="token">,</span><span class="token">(</span><span class="token2">16</span><span class="token">,</span>True<span class="token">)</span><span class="token">)</span>

</code></pre>
<p class="calibre9">Haskell 有一个特殊的类型 () ，这种类型只有一个值 () ，它的作用相当于包含零个元素的元组，类似于 C 语言中的 void ：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>t <span class="token">(</span><span class="token">)</span>
<span class="token">(</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> <span class="token">(</span><span class="token">)</span>

</code></pre>
<p class="calibre9">通常用元组中元素的数量作为称呼元组的前缀，比如“2-元组”用于称呼包含两个元素的元组，“5-元组”用于称呼包含五个元素的元组，诸如此类。Haskell 不能创建 1-元组，因为 Haskell 没有相应的创建 1-元组的语法（notion）。另外，在实际编程中，元组的元素太多会让代码变得混乱，因此元组通常只包含几个元素。</p>
<p class="calibre9">元组的类型由它所包含元素的数量、位置和类型决定。这意味着，如果两个元组里都包含着同样类型的元素，而这些元素的摆放位置不同，那么它们的类型就不相等，就像这样：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token">(</span>False<span class="token">,</span> <span class="token4">'a'</span><span class="token">)</span>
<span class="token">(</span>False<span class="token">,</span> <span class="token4">'a'</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Bool<span class="token">,</span> Char<span class="token">)</span>

Prelude<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token">(</span><span class="token4">'a'</span><span class="token">,</span> False<span class="token">)</span>
<span class="token">(</span><span class="token4">'a'</span><span class="token">,</span> False<span class="token">)</span> <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Char<span class="token">,</span> Bool<span class="token">)</span>

</code></pre>
<p class="calibre9">除此之外，即使两个元组之间有一部分元素的类型相同，位置也一致，但是，如果它们的元素数量不同，那么它们的类型也不相等：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token">(</span>False<span class="token">,</span> <span class="token4">'a'</span><span class="token">)</span>
<span class="token">(</span>False<span class="token">,</span> <span class="token4">'a'</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Bool<span class="token">,</span> Char<span class="token">)</span>

Prelude<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token">(</span>False<span class="token">,</span> <span class="token4">'a'</span><span class="token">,</span> <span class="token4">'b'</span><span class="token">)</span>
<span class="token">(</span>False<span class="token">,</span> <span class="token4">'a'</span><span class="token">,</span> <span class="token4">'b'</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Bool<span class="token">,</span> Char<span class="token">,</span> Char<span class="token">)</span>

</code></pre>
<p class="calibre9">只有元组中的数量、位置和类型都完全相同，这两个元组的类型才是相同的：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>t <span class="token">(</span>False<span class="token">,</span> <span class="token4">'a'</span><span class="token">)</span>
<span class="token">(</span>False<span class="token">,</span> <span class="token4">'a'</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Bool<span class="token">,</span> Char<span class="token">)</span>

Prelude<span class="token3">&gt;</span> <span class="token">:</span>t <span class="token">(</span>True<span class="token">,</span> <span class="token4">'b'</span><span class="token">)</span>
<span class="token">(</span>True<span class="token">,</span> <span class="token4">'b'</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Bool<span class="token">,</span> Char<span class="token">)</span>

</code></pre>
<p class="calibre9">元组通常用于以下两个地方：</p>
<ul class="calibre10"><li class="calibre11">如果一个函数需要返回多个值，那么可以将这些值都包装到一个元组中，然后返回元组作为函数的值。</li><li class="calibre11">当需要使用定长容器，但又没有必要使用自定义类型的时候，就可以使用元组来对值进行包装。</li></ul>
<h2 class="calibre14"><a id="chp-2.html._268" class="calibre7 pcalibre"></a>处理列表和元组的函数</h2>
<p class="calibre9">前面的内容介绍了如何构造列表和元组，现在来看看处理这两种数据结构的函数。</p>
<p class="calibre9">函数 take 和 drop 接受两个参数，一个数字 n 和一个列表 l 。</p>
<p class="calibre9">take 返回一个包含 l 前 n 个元素的列表：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> take <span class="token2">2</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">,</span> <span class="token2">3</span><span class="token">,</span> <span class="token2">4</span><span class="token">,</span> <span class="token2">5</span><span class="token">]</span>
<span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">]</span>

</code></pre>
<p class="calibre9">drop 则返回一个包含 l 丢弃了前 n 个元素之后，剩余元素的列表：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> drop <span class="token2">2</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">,</span> <span class="token2">3</span><span class="token">,</span> <span class="token2">4</span><span class="token">,</span> <span class="token2">5</span><span class="token">]</span>
<span class="token">[</span><span class="token2">3</span><span class="token">,</span><span class="token2">4</span><span class="token">,</span><span class="token2">5</span><span class="token">]</span>

</code></pre>
<p class="calibre9">函数 fst 和 snd 接受一个元组作为参数，返回该元组的第一个元素和第二个元素：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> fst <span class="token">(</span><span class="token2">1</span><span class="token">,</span> <span class="token4">'a'</span><span class="token">)</span>
<span class="token2">1</span>

Prelude<span class="token3">&gt;</span> snd <span class="token">(</span><span class="token2">1</span><span class="token">,</span> <span class="token4">'a'</span><span class="token">)</span>
<span class="token4">'a'</span>

</code></pre>
<h2 class="calibre14"><a id="chp-2.html._301" class="calibre7 pcalibre"></a>将表达式传给函数</h2>
<p class="calibre9">Haskell 的函数应用是左关联的。比如说，表达式 abcd 等同于 (((ab)c)d) 。要将一个表达式用作另一个表达式的参数，那么就必须显式地使用括号来包围它，这样编译器才会知道我们的真正意思：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> head <span class="token">(</span>drop <span class="token2">4</span> <span class="token4">"azety"</span><span class="token">)</span>
<span class="token4">'y'</span>

</code></pre>
<p class="calibre9">drop4"azety" 这个表达式被一对括号显式地包围，作为参数传入 head 函数。</p>
<p class="calibre9">如果将括号移走，那么编译器就会认为我们试图将三个参数传给 head 函数，于是它引发一个错误：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> head drop <span class="token2">4</span> <span class="token4">"azety"</span>

<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">26</span><span class="token">:</span><span class="token2">6</span><span class="token">:</span>
    Couldn<span class="token4">'t match expected type `[t1 -&gt; t2 -&gt; t0]'</span>
    with actual type `Int <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a0<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a0<span class="token">]</span>'
    In the first argument of `head<span class="token4">', namely `drop'</span>
    In the expression<span class="token">:</span> head drop <span class="token2">4</span> <span class="token4">"azety"</span>
    In an equation <span class="token1">for</span> `it'<span class="token">:</span> it <span class="token3">=</span> head drop <span class="token2">4</span> <span class="token4">"azety"</span>

</code></pre>
<h2 class="calibre14"><a id="chp-2.html._327" class="calibre7 pcalibre"></a>函数类型</h2>
<p class="calibre9">使用 :type 命令可以查看函数的类型[译注：缩写形式为 :t ]：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>type lines
lines <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>String<span class="token">]</span>

</code></pre>
<p class="calibre9">符号 -&gt; 可以读作“映射到”，或者（稍微不太精确地），读作“返回”。函数的类型签名显示， lines 函数接受单个字符串，并返回包含字符串值的列表：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> lines <span class="token4">"the quick\nbrown fox\njumps"</span>
<span class="token">[</span><span class="token4">"the quick"</span><span class="token">,</span><span class="token4">"brown fox"</span><span class="token">,</span><span class="token4">"jumps"</span><span class="token">]</span>

</code></pre>
<p class="calibre9">结果表示， lines 函数接受一个字符串作为输入，并将这个字符串按行转义符号分割成多个字符串。</p>
<p class="calibre9">从 lines 函数的这个例子可以看出：函数的类型签名对于函数自身的功能有很大的提示作用，这种属性对于函数式语言的类型来说，意义重大。</p>
<p class="calibre9">[译注： String-&gt;[String] 的实际意思是指 lines 函数定义了一个从 String 到 [String] 的函数映射，因此，这里将 -&gt; 的读法 to 翻译成“映射到”。]</p>
<h2 class="calibre14"><a id="chp-2.html._351" class="calibre7 pcalibre"></a>纯度</h2>
<p class="calibre9"><em class="calibre13">副作用</em>指的是，函数的行为受系统的全局状态所影响。</p>
<p class="calibre9">举个命令式语言的例子：假设有某个函数，它读取并返回某个全局变量，如果程序中的其他代码可以修改这个全局变量的话，那么这个函数的返回值就取决于这个全局变量在某一时刻的值。我们说这个函数带有副作用，尽管它并不亲自修改全局变量。</p>
<p class="calibre9">副作用本质上是函数的一种不可见的（invisible）输入或输出。Haskell 的函数在默认情况下都是无副作用的：函数的结果只取决于显式传入的参数。</p>
<p class="calibre9">我们将带副作用的函数称为“不纯（impure）函数”，而将不带副作用的函数称为“纯（pure）函数”。</p>
<p class="calibre9">从类型签名可以看出一个 Haskell 函数是否带有副作用 —— 不纯函数的类型签名都以 IO 开头：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>type readFile
readFile <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO String

</code></pre>
<h2 class="calibre14"><a id="chp-2.html.Haskell__369" class="calibre7 pcalibre"></a>Haskell 源码，以及简单函数的定义</h2>
<p class="calibre9">既然我们已经学会了如何应用函数，那么是时候回过头来，学习怎样去编写函数。</p>
<p class="calibre9">因为 ghci 只支持 Haskell 特性的一个非常受限的子集，因此，尽管可以在 ghci 里面定义函数，但那里并不是编写函数最适当的环境。更关键的是， ghci 里面定义函数的语法和 Haskell 源码里定义函数的语法并不相同。综上所述，我们选择将代码写在源码文件里。</p>
<p class="calibre9">Haskell 源码通常以 <em class="calibre13">.hs</em> 作为后缀。我们创建一个 add.hs 文件，并将以下定义添加到文件中：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch02<span class="token3">/</span>add<span class="token">.</span>hs
add a b <span class="token3">=</span> a <span class="token3">+</span> b

</code></pre>
<p class="calibre9">[译注：原书代码里的路径为 ch03/add.hs ，是错误的。]</p>
<p class="calibre9">= 号左边的 addab 是函数名和函数参数，而右边的 a+b 则是函数体，符号 = 表示将左边的名字（函数名和函数参数）定义为右边的表达式（函数体）。</p>
<p class="calibre9">将 add.hs 保存之后，就可以在 ghci 里通过 :load 命令（缩写为 :l ）载入它，接着就可以像使用其他函数一样，调用 add 函数了：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load add<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> add<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> add <span class="token2">1</span> <span class="token2">2</span>  <span class="token3">--</span> 包载入成功之后 ghci 的提示符会发生变化
<span class="token2">3</span>

</code></pre>
<p class="calibre9">[译注：你的当前文件夹（CWD）必须是 ch02 文件夹，否则直接载入 add.hs 会失败]</p>
<p class="calibre9">当以 1 和 2 作为参数应用 add 函数的时候，它们分别被赋值给（或者说，绑定到）函数定义中的变量 a 和 b ，因此得出的结果表达式为 1+2 ，而这个表达式的值 3 就是本次函数应用的结果。</p>
<p class="calibre9">Haskell 不使用 return 关键字来返回函数值：因为一个函数就是一个单独的表达式（expression），而不是一组陈述（statement），求值表达式所得的结果就是函数的返回值。（实际上，Haskell 有一个名为 return 的函数，但它和命令式语言里的 return 不是同一回事。）</p>
<h2 class="calibre14"><a id="chp-2.html._405" class="calibre7 pcalibre"></a>变量</h2>
<p class="calibre9">在 Haskell 里，可以使用变量来赋予表达式名字：一旦变量绑定了（也即是，关联起）某个表达式，那么这个变量的值就不会改变 —— 我们总能用这个变量来指代它所关联的表达式，并且每次都会得到同样的结果。</p>
<p class="calibre9">如果你曾经用过命令式语言，就会发现 Haskell 的变量和命令式语言的变量很不同：在命令式语言里，一个变量通常用于标识一个内存位置（或者其他类似的东西），并且在任何时候，都可以随意修改这个变量的值。因此在不同时间点上，访问这个变量得出的值可能是完全不同的。</p>
<p class="calibre9">对变量的这两种不同的处理方式产生了巨大的差别：在 Haskell 程序里面，当变量和表达式绑定之后，我们总能将变量替换成相应的表达式。但是在声明式语言里面就没有办法做这样的替换，因为变量的值可能无时不刻都处在改变当中。</p>
<p class="calibre9">举个例子，以下 Python 脚本打印出值 11 ：</p>
<pre class="calibre15"><code class="tthhighlight-container">x <span class="token3">=</span> <span class="token2">10</span>
x <span class="token3">=</span> <span class="token2">11</span>
<span class="token5">print</span><span class="token">(</span>x<span class="token">)</span>

</code></pre>
<p class="calibre9">[译注：这里将原书的代码从 printx 改为 print(x) ，确保代码在 Python 2 和 Python 3 都可以顺利执行。]</p>
<p class="calibre9">然后，试着在 Haskell 里做同样的事：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch02<span class="token3">/</span>Assign<span class="token">.</span>hs
x <span class="token3">=</span> <span class="token2">10</span>
x <span class="token3">=</span> <span class="token2">11</span>

</code></pre>
<p class="calibre9">但是 Haskell 并不允许做这样的多次赋值：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load Assign
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> Assign<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>

Assign<span class="token">.</span>hs<span class="token">:</span><span class="token2">3</span><span class="token">:</span><span class="token2">1</span><span class="token">:</span>
    Multiple declarations of `x'
    Declared at<span class="token">:</span> Assign<span class="token">.</span>hs<span class="token">:</span><span class="token2">2</span><span class="token">:</span><span class="token2">1</span>
                 Assign<span class="token">.</span>hs<span class="token">:</span><span class="token2">3</span><span class="token">:</span><span class="token2">1</span>
Failed<span class="token">,</span> modules loaded<span class="token">:</span> none<span class="token">.</span>

</code></pre>
<h2 class="calibre14"><a id="chp-2.html._447" class="calibre7 pcalibre"></a>条件求值</h2>
<p class="calibre9">和很多语言一样，Haskell 也有自己的 if 表达式。本节先说明怎么用这个表达式，然后再慢慢介绍它的详细特性。</p>
<p class="calibre9">我们通过编写一个个人版本的 drop 函数来熟悉 if 表达式。先来回顾一下 drop 的行为：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> drop <span class="token2">2</span> <span class="token4">"foobar"</span>
<span class="token4">"obar"</span>

Prelude<span class="token3">&gt;</span> drop <span class="token2">4</span> <span class="token4">"foobar"</span>
<span class="token4">"ar"</span>

Prelude<span class="token3">&gt;</span> drop <span class="token2">4</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">]</span>
<span class="token">[</span><span class="token">]</span>

Prelude<span class="token3">&gt;</span> drop <span class="token2">0</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">]</span>
<span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">]</span>

Prelude<span class="token3">&gt;</span> drop <span class="token2">7</span> <span class="token">[</span><span class="token">]</span>
<span class="token">[</span><span class="token">]</span>

Prelude<span class="token3">&gt;</span> drop <span class="token">(</span><span class="token3">-</span><span class="token2">2</span><span class="token">)</span> <span class="token4">"foo"</span>
<span class="token4">"foo"</span>

</code></pre>
<p class="calibre9">从测试代码的反馈可以看到。当 drop 函数的第一个参数小于或等于 0 时， drop 函数返回整个输入列表。否则，它就从列表左边开始移除元素，一直到移除元素的数量足够，或者输入列表被清空为止。</p>
<p class="calibre9">以下是带有同样行为的 myDrop 函数，它使用 if 表达来决定该做什么。而代码中的 null 函数则用于检查列表是否为空：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch02<span class="token3">/</span>myDrop<span class="token">.</span>hs
myDrop n xs <span class="token3">=</span> <span class="token1">if</span> n <span class="token3">&lt;=</span> <span class="token2">0</span> <span class="token3">||</span> <span class="token1">null</span> xs
              then xs
              <span class="token1">else</span> myDrop <span class="token">(</span>n <span class="token3">-</span> <span class="token2">1</span><span class="token">)</span> <span class="token">(</span>tail xs<span class="token">)</span>

</code></pre>
<p class="calibre9">在 Haskell 里，代码的缩进非常重要：它会延续（continue）一个已存在的定义，而不是新创建一个。所以，不要省略缩进！</p>
<p class="calibre9">变量 xs 展示了一个命名列表的常见模式： s 可以视为后缀，而 xs 则表示“复数个 x ”。</p>
<p class="calibre9">先保存文件，试试 myDrop 函数是否如我们所预期的那样工作：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> myDrop<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> myDrop <span class="token2">2</span> <span class="token4">"foobar"</span>
<span class="token4">"obar"</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> myDrop <span class="token2">4</span> <span class="token4">"foobar"</span>
<span class="token4">"ar"</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> myDrop <span class="token2">4</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">]</span>
<span class="token">[</span><span class="token">]</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> myDrop <span class="token2">0</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">]</span>
<span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">]</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> myDrop <span class="token2">7</span> <span class="token">[</span><span class="token">]</span>
<span class="token">[</span><span class="token">]</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> myDrop <span class="token">(</span><span class="token3">-</span><span class="token2">2</span><span class="token">)</span> <span class="token4">"foo"</span>
<span class="token4">"foo"</span>

</code></pre>
<p class="calibre9">好的，代码正如我们所想的那样运行，现在是时候回过头来，说明一下 myDrop 的函数体里都干了些什么：</p>
<p class="calibre9">if 关键字引入了一个带有三个部分的表达式：</p>
<ul class="calibre10"><li class="calibre11">跟在 if 之后的是一个 Bool 类型的表达式，它是 if 的条件部分。</li><li class="calibre11">跟在 then 关键字之后的是另一个表达式，这个表达式在条件部分的值为 True 时被执行。</li><li class="calibre11">跟在 else 关键字之后的又是另一个表达式，这个表达式在条件部分的值为 False 时被执行。</li></ul>
<p class="calibre9">我们将跟在 then 和 else 之后的表达式称为“分支”。不同分支之间的类型必须相同。[译注：这里原文还有一句“the if expression will also have this type”，这是错误的，因为条件部分的表达式只要是 Bool 类型就可以了，没有必要和分支的类型相同。]像是 ifTruethen1else"foo" 这样的表达式会产生错误，因为两个分支的类型并不相同：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token1">if</span> True then <span class="token2">1</span> <span class="token1">else</span> <span class="token4">"foo"</span>

<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">2</span><span class="token">:</span><span class="token2">14</span><span class="token">:</span>
    No instance <span class="token1">for</span> <span class="token">(</span>Num <span class="token">[</span>Char<span class="token">]</span><span class="token">)</span>
        arising from the literal `<span class="token2">1</span>'
    Possible fix<span class="token">:</span> add an instance declaration <span class="token1">for</span> <span class="token">(</span>Num <span class="token">[</span>Char<span class="token">]</span><span class="token">)</span>
    In the expression<span class="token">:</span> <span class="token2">1</span>
    In the expression<span class="token">:</span> <span class="token1">if</span> True then <span class="token2">1</span> <span class="token1">else</span> <span class="token4">"foo"</span>
    In an equation <span class="token1">for</span> `it'<span class="token">:</span> it <span class="token3">=</span> <span class="token1">if</span> True then <span class="token2">1</span> <span class="token1">else</span> <span class="token4">"foo"</span>

</code></pre>
<p class="calibre9">记住，Haskell 是一门以表达式为主导（expression-oriented）的语言。在命令式语言中，代码由陈述（statement）而不是表达式组成，因此在省略 if 语句的 else 分支的情况下，程序仍是有意义的。但是，当代码由表达式组成时，一个缺少 else 分支的 if 语句，在条件部分为 False 时，是没有办法给出一个结果的，当然这个 else 分支也不会有任何类型，因此，省略 else 分支对于 Haskell 是无意义的，编译器也不会允许这么做。</p>
<p class="calibre9">程序里还有几个新东西需要解释。其中， null 函数检查一个列表是否为空：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token1">null</span>
<span class="token1">null</span> <span class="token">:</span><span class="token">:</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Bool

Prelude<span class="token3">&gt;</span> <span class="token1">null</span> <span class="token">[</span><span class="token">]</span>
True

Prelude<span class="token3">&gt;</span> <span class="token1">null</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">,</span> <span class="token2">3</span><span class="token">]</span>
False

</code></pre>
<p class="calibre9">而 (||) 操作符对它的 Bool 类型参数执行一个逻辑或（logical or）操作：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token">(</span><span class="token3">||</span><span class="token">)</span>
<span class="token">(</span><span class="token3">||</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> Bool <span class="token3">-</span><span class="token3">&gt;</span> Bool <span class="token3">-</span><span class="token3">&gt;</span> Bool

Prelude<span class="token3">&gt;</span> True <span class="token3">||</span> False
True

Prelude<span class="token3">&gt;</span> True <span class="token3">||</span> True
True

</code></pre>
<p class="calibre9">另外需要注意的是， myDrop 函数是一个递归函数：它通过调用自身来解决问题。关于递归，书本稍后会做更详细的介绍。</p>
<p class="calibre9">最后，整个 if 表达式被分成了多行，而实际上，它也可以写成一行：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch02<span class="token3">/</span>myDropX<span class="token">.</span>hs
myDropX n xs <span class="token3">=</span> <span class="token1">if</span> n <span class="token3">&lt;=</span> <span class="token2">0</span> <span class="token3">||</span> <span class="token1">null</span> xs then xs <span class="token1">else</span> myDropX <span class="token">(</span>n <span class="token3">-</span> <span class="token2">1</span><span class="token">)</span> <span class="token">(</span>tail xs<span class="token">)</span>

</code></pre>
<p class="calibre9">[译注：原文这里的文件名称为 myDrop.hs ，为了和之前的 myDrop.hs 区别开来，这里修改文件名，让它和函数名 myDropX 保持一致。]</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load myDropX<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> myDropX<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> myDropX <span class="token2">2</span> <span class="token4">"foobar"</span>
<span class="token4">"obar"</span>

</code></pre>
<p class="calibre9">这个一行版本的 myDrop 比起之前的定义要难读得多，为了可读性考虑，一般来说，总是应该通过分行来隔开条件部分和两个分支。</p>
<p class="calibre9">作为对比，以下是一个 Python 版本的 myDrop ，它的结构和 Haskell 版本差不多：</p>
<pre class="calibre15"><code class="tthhighlight-container">def <span class="token5">myDrop</span><span class="token">(</span>n<span class="token">,</span> elts<span class="token">)</span><span class="token">:</span>
    <span class="token1">while</span> n <span class="token3">&gt;</span> <span class="token2">0</span> and elts<span class="token">:</span>
        n <span class="token3">=</span> n <span class="token3">-</span><span class="token2">1</span>
        elts <span class="token3">=</span> elts<span class="token">[</span><span class="token2">1</span><span class="token">:</span><span class="token">]</span>
    <span class="token1">return</span> elts

</code></pre>
<h2 class="calibre14"><a id="chp-2.html._604" class="calibre7 pcalibre"></a>通过示例了解求值</h2>
<p class="calibre9">前面对 myDrop 的描述关注的都是表面上的特性。我们需要更进一步，开发一个关于函数是如何被应用的心智模型：为此，我们先从一些简单的示例出发，逐步深入，直到搞清楚 myDrop2"abcd" 到底是怎样求值为止。</p>
<p class="calibre9">在前面的章节里多次谈到，可以使用一个表达式去代换一个变量。在这部分的内容里，我们也会看到这种替换能力：计算过程需要多次对表达式进行重写，并将变量替换为表达式，直到产生最终结果为止。为了帮助理解，最好准备一些纸和笔，跟着书本的说明，自己计算一次。</p>
<h2 class="calibre14"><a id="chp-2.html._610" class="calibre7 pcalibre"></a>惰性求值</h2>
<p class="calibre9">先从一个简单的、非递归例子开始，其中 mod 函数是典型的取模函数：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch02<span class="token3">/</span>isOdd<span class="token">.</span>hs
isOdd n <span class="token3">=</span> mod n <span class="token2">2</span> <span class="token3">==</span> <span class="token2">1</span>

</code></pre>
<p class="calibre9">[译注：原文的文件名为 RoundToEven.hs ，这里修改成 isOdd.hs ，和函数名 isOdd 保持一致。]</p>
<p class="calibre9">我们的第一个任务是，弄清楚 isOdd(1+2) 的结果是如何求值出的。</p>
<p class="calibre9">在使用<em class="calibre13">严格</em>求值的语言里，函数的参数总是在应用函数之前被求值。以 isOdd 为例子：子表达式 (1+2) 会首先被求值，得出结果 3 。接着，将 3 绑定到变量 n ，应用到函数 isOdd 。最后， mod32 返回 1 ，而 1==1 返回 True 。</p>
<p class="calibre9">Haskell 使用了另外一种求值方式 —— <em class="calibre13">非严格</em>求值。在这种情况下，求值 isOdd(1+2)<em class="calibre13">并不会</em>即刻使得子表达式 1+2 被求值为 3 ，相反，编译器做出了一个“承诺”，说，“当真正有需要的时候，我有办法计算出 isOdd(1+2) 的值”。</p>
<p class="calibre9">用于追踪未求值表达式的记录被称为块（chunk）。这就是事情发生的经过：编译器通过创建块来延迟表达式的求值，直到这个表达式的值真正被需要为止。如果某个表达式的值不被需要，那么从始至终，这个表达式都不会被求值。</p>
<p class="calibre9">非严格求值通常也被称为<em class="calibre13">惰性求值</em>。[注：实际上，“非严格”和“惰性”在技术上有些细微的差别，但这里不讨论这些细节。]</p>
<h2 class="calibre14"><a id="chp-2.html._632" class="calibre7 pcalibre"></a>一个更复杂的例子</h2>
<p class="calibre9">现在，将注意力放回 myDrop2"abcd" 上面，考察它的结果是如何计算出来的：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load <span class="token4">"myDrop.hs"</span>
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> myDrop<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> myDrop <span class="token2">2</span> <span class="token4">"abcd"</span>
<span class="token4">"cd"</span>

</code></pre>
<p class="calibre9">当执行表达式 myDrop2"abcd" 时，函数 myDrop 应用于值 2 和 "abcd" ，变量 n 被绑定为 2 ，而变量 xs 被绑定为 "abcd" 。将这两个变量代换到 myDrop 的条件判断部分，就得出了以下表达式：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token2">2</span> <span class="token3">&lt;=</span> <span class="token2">0</span> <span class="token3">||</span> <span class="token1">null</span> <span class="token4">"abcd"</span>
<span class="token2">2</span> <span class="token3">&lt;=</span> <span class="token2">0</span> <span class="token3">||</span> <span class="token1">null</span> <span class="token4">"abcd"</span> <span class="token">:</span><span class="token">:</span> Bool

</code></pre>
<p class="calibre9">编译器需要对表达式 2&lt;=0||null"abcd" 进行求值，从而决定 if 该执行哪一个分支。这需要对 (||) 表达式进行求值，而要求值这个表达式，又需要对它的左操作符进行求值：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token2">2</span> <span class="token3">&lt;=</span> <span class="token2">0</span>
False

</code></pre>
<p class="calibre9">将值 False 代换到 (||) 表达式当中，得出以下表达式：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type False <span class="token3">||</span> <span class="token1">null</span> <span class="token4">"abcd"</span>
False <span class="token3">||</span> <span class="token1">null</span> <span class="token4">"abcd"</span> <span class="token">:</span><span class="token">:</span> Bool

</code></pre>
<p class="calibre9">如果 (||) 左操作符的值为 True ，那么 (||) 就不需要对右操作符进行求值，因为整个 (||) 表达式的值已经由左操作符决定了。[译注：在逻辑或计算中，只要有一个变量的值为真，那么结果就为真。]另一方面，因为这里左操作符的值为 False ，那么 (||) 表达式的值由右操作符的值来决定：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token1">null</span> <span class="token4">"abcd"</span>
False

</code></pre>
<p class="calibre9">最后，将左右两个操作对象的值分别替换回 (||) 表达式，得出以下表达式：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> False <span class="token3">||</span> False
False

</code></pre>
<p class="calibre9">这个结果表明，下一步要求值的应该是 if 表达式的 else 分支，而这个分支包含一个对 myDrop 函数自身的递归调用： myDrop(2-1)(tail"abcd") 。</p>
<h2 class="calibre14"><a id="chp-2.html._688" class="calibre7 pcalibre"></a>递归</h2>
<p class="calibre9">当递归地调用 myDrop 的时候， n 被绑定为块 2-1 ，而 xs 被绑定为 tail"abcd" 。</p>
<p class="calibre9">于是再次对 myDrop 函数进行求值，这次将新的值替换到 if 的条件判断部分：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token">(</span><span class="token2">2</span> <span class="token3">-</span> <span class="token2">1</span><span class="token">)</span> <span class="token3">&lt;=</span> <span class="token2">0</span> <span class="token3">||</span> <span class="token1">null</span> <span class="token">(</span>tail <span class="token4">"abcd"</span><span class="token">)</span>
<span class="token">(</span><span class="token2">2</span> <span class="token3">-</span> <span class="token2">1</span><span class="token">)</span> <span class="token3">&lt;=</span> <span class="token2">0</span> <span class="token3">||</span> <span class="token1">null</span> <span class="token">(</span>tail <span class="token4">"abcd"</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> Bool

</code></pre>
<p class="calibre9">对 (||) 的左操作符的求值过程如下：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token">(</span><span class="token2">2</span> <span class="token3">-</span> <span class="token2">1</span><span class="token">)</span>
<span class="token">(</span><span class="token2">2</span> <span class="token3">-</span> <span class="token2">1</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> Num a <span class="token3">=</span><span class="token3">&gt;</span> a

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token2">2</span> <span class="token3">-</span> <span class="token2">1</span>
<span class="token2">1</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token2">1</span> <span class="token3">&lt;=</span> <span class="token2">0</span>
False

</code></pre>
<p class="calibre9">正如前面“惰性求值”一节所说的那样， (2-1) 只有在真正需要的时候才会被求值。同样，对右操作符 (tail"abcd") 的求值也会被延迟，直到真正有需要时才被执行：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token1">null</span> <span class="token">(</span>tail <span class="token4">"abcd"</span><span class="token">)</span>
<span class="token1">null</span> <span class="token">(</span>tail <span class="token4">"abcd"</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> Bool

<span class="token3">*</span>Main<span class="token3">&gt;</span> tail <span class="token4">"abcd"</span>
<span class="token4">"bcd"</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token1">null</span> <span class="token4">"bcd"</span>
False

</code></pre>
<p class="calibre9">因为条件判断表达式的最终结果为 False ，所以这次执行的也是 else 分支，而被执行的表达式为 myDrop(1-1)(tail"bcd") 。</p>
<h2 class="calibre14"><a id="chp-2.html._730" class="calibre7 pcalibre"></a>终止递归</h2>
<p class="calibre9">这次递归调用将 1-1 绑定到 n ，而 xs 被绑定为 tail"bcd" ：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token">(</span><span class="token2">1</span> <span class="token3">-</span> <span class="token2">1</span><span class="token">)</span> <span class="token3">&lt;=</span> <span class="token2">0</span> <span class="token3">||</span> <span class="token1">null</span> <span class="token">(</span>tail <span class="token4">"bcd"</span><span class="token">)</span>
<span class="token">(</span><span class="token2">1</span> <span class="token3">-</span> <span class="token2">1</span><span class="token">)</span> <span class="token3">&lt;=</span> <span class="token2">0</span> <span class="token3">||</span> <span class="token1">null</span> <span class="token">(</span>tail <span class="token4">"bcd"</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> Bool

</code></pre>
<p class="calibre9">再次对 (||) 操作符的右操作对象求值：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token">(</span><span class="token2">1</span> <span class="token3">-</span> <span class="token2">1</span><span class="token">)</span> <span class="token3">&lt;=</span> <span class="token2">0</span>
<span class="token">(</span><span class="token2">1</span> <span class="token3">-</span> <span class="token2">1</span><span class="token">)</span> <span class="token3">&lt;=</span> <span class="token2">0</span> <span class="token">:</span><span class="token">:</span> Bool

</code></pre>
<p class="calibre9">最终，我们得出了一个 True 值！</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> True <span class="token3">||</span> <span class="token1">null</span> <span class="token">(</span>tail <span class="token4">"bcd"</span><span class="token">)</span>
True

</code></pre>
<p class="calibre9">因为 (||) 的右操作符 null(tail"bcd") 并不影响表达式的计算结果，因此它没有被求值，而整个条件判断部分的最终值为 True 。于是 then 分支被求值：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type tail <span class="token4">"bcd"</span>
tail <span class="token4">"bcd"</span> <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Char<span class="token">]</span>

</code></pre>
<h2 class="calibre14"><a id="chp-2.html._764" class="calibre7 pcalibre"></a>从递归中返回</h2>
<p class="calibre9">请注意，在求值的最后一步，结果表达式 tail"bcd" 处于两次对 myDrop 的递归调用当中。</p>
<p class="calibre9">因此，表达式 tail"bcd" 作为结果值，被返回给对 myDrop 的第二次递归调用：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> myDrop <span class="token">(</span><span class="token2">1</span> <span class="token3">-</span> <span class="token2">1</span><span class="token">)</span> <span class="token">(</span>tail <span class="token4">"bcd"</span><span class="token">)</span> <span class="token3">==</span> tail <span class="token4">"bcd"</span>
True

</code></pre>
<p class="calibre9">接着，第二次递归调用所得的值（还是 tail"bcd" ），它被返回给第一次递归调用：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> myDrop <span class="token">(</span><span class="token2">2</span> <span class="token3">-</span> <span class="token2">1</span><span class="token">)</span> <span class="token">(</span>tail <span class="token4">"abcd"</span><span class="token">)</span> <span class="token3">==</span> tail <span class="token4">"bcd"</span>
True

</code></pre>
<p class="calibre9">然后，第一次递归调用也将 tail"bcd" 作为结果值，返回给最开始的 myDrop 调用：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> myDrop <span class="token2">2</span> <span class="token4">"abcd"</span> <span class="token3">==</span> tail <span class="token4">"bcd"</span>
True

</code></pre>
<p class="calibre9">最终计算出结果 "cd" ：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> myDrop <span class="token2">2</span> <span class="token4">"abcd"</span>
<span class="token4">"cd"</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> tail <span class="token4">"bcd"</span>
<span class="token4">"cd"</span>

</code></pre>
<p class="calibre9">注意，在从递归调用中退出并传递结果值的过程中， tail"bcd" 并不会被求值，只有当它返回到最开始的 myDrop 之后， ghci 需要打印这个值时， tail"bcd" 才会被求值。</p>
<h2 class="calibre14"><a id="chp-2.html._805" class="calibre7 pcalibre"></a>学到了什么？</h2>
<p class="calibre9">这一节介绍了三个重要的知识点：</p>
<ul class="calibre10"><li class="calibre11">可以通过代换（substitution）和重写（rewriting）去了解 Haskell 求值表达式的方式。</li><li class="calibre11">惰性求值可以延迟计算直到真正需要一个值为止，并且在求值时，也只执行可以给出（establish）值的那部分表达式。[译注：比如之前提到的， (||) 的左操作符的值为 True 时的情况。]</li><li class="calibre11">函数的返回值可能是一个块（一个被延迟计算的表达式）。</li></ul>
<h2 class="calibre14"><a id="chp-2.html.Haskell__813" class="calibre7 pcalibre"></a>Haskell 里的多态</h2>
<p class="calibre9">之前介绍列表的时候提到过，列表是类型多态的，这一节会说明更多这方面的细节。</p>
<p class="calibre9">如果想要取出一个列表的最后一个元素，那么可以使用 last 函数。 last 函数的返回值和列表中的元素的类型是相同的，但是， last 函数并不介意输入的列表是什么类型，它对于任何类型的列表都可以产生同样的效果：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> last <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">,</span> <span class="token2">3</span><span class="token">,</span> <span class="token2">4</span><span class="token">,</span> <span class="token2">5</span><span class="token">]</span>
<span class="token2">5</span>

Prelude<span class="token3">&gt;</span> last <span class="token4">"baz"</span>
<span class="token4">'z'</span>

</code></pre>
<p class="calibre9">last 的秘密就隐藏在类型签名里面：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>type last
last <span class="token">:</span><span class="token">:</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> a

</code></pre>
<p class="calibre9">这个类型签名可以读作“ last 接受一个列表，这个列表里的所有元素的类型都为 a ，并返回一个类型为 a 的元素作为返回值”，其中 a 是类型变量。</p>
<p class="calibre9">如果函数的类型签名里包含类型变量，那么就表示这个函数的某些参数可以是任意类型，我们称这些函数是多态的。</p>
<p class="calibre9">如果将一个类型为 [Char] 的列表传给 last ，那么编译器就会用 Char 代换 last 函数类型签名中的所有 a ，从而得出一个类型为 [Char]-&gt;Char 的 last 函数。而对于 [Int] 类型的列表，编译器则产生一个类型为 [Int]-&gt;Int 类型的 last 函数，诸如此类。</p>
<p class="calibre9">这种类型的多态被称为<em class="calibre13">参数</em>多态。可以用一个类比来帮助理解这个名字：就像函数的参数可以被其他实际的值绑定一样，Haskell 的类型也可以带有参数，并且这些参数也可以被其他实际的类型绑定。</p>
<p class="calibre9">当看见一个参数化类型（parameterized type）时，这表示代码并不在乎实际的类型是什么。另外，我们还可以给出一个更强的陈述：没有办法知道参数化类型的实际类型是什么，也不能操作这种类型的值；不能创建这种类型的值，也不能对这种类型的值进行探查（inspect）。</p>
<p class="calibre9">参数化类型唯一能做的事，就是作为一个完全抽象的“黑箱”而存在。稍后的内容会解释为什么这个性质对参数化类型来说至关重要。</p>
<p class="calibre9">参数多态是 Haskell 支持的多态中最明显的一个。Haskell 的参数多态直接影响了 Java 和 C# 等语言的泛型（generic）功能的设计。Java 泛型中的类型变量和 Haskell 的参数化类型非常相似。而 C++ 的模板也和参数多态相去不远。</p>
<p class="calibre9">为了弄清楚 Haskell 的多态和其他语言的多态之间的区别，以下是一些被流行语言所使用的多态形式，这些形式的多态都没有在 Haskell 里出现：</p>
<p class="calibre9">在主流的面向对象语言中，<em class="calibre13">子类</em>多态是应用得最广泛的一种。C++ 和 Java 的继承机制实现了子类多态，使得子类可以修改或扩展父类所定义的行为。Haskell 不是面向对象语言，因此它没有提供子类多态。</p>
<p class="calibre9">另一个常见的多态形式是<em class="calibre13">强制</em>多态（coercion polymorphism），它允许值在类型之间进行隐式的转换。很多语言都提供了对强制多态的某种形式的支持，其中一个例子就是：自动将整数类型值转换成浮点数类型值。既然 Haskell 坚决反对自动类型转换，那么这种多态自然也不会出现在 Haskell 里面。</p>
<p class="calibre9">关于多态还有很多东西要说，本书第六章会再次回到这个主题。</p>
<h2 class="calibre14"><a id="chp-2.html._858" class="calibre7 pcalibre"></a>对多态函数进行推理</h2>
<p class="calibre9">前面的《函数类型》小节介绍过，可以通过查看函数的类型签名来了解函数的行为。这种方法同样适用于对多态类型进行推理。</p>
<p class="calibre9">以 fst 函数为例子：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>type fst
fst <span class="token">:</span><span class="token">:</span> <span class="token">(</span>a<span class="token">,</span> b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> a

</code></pre>
<p class="calibre9">首先，函数签名包含两个类型变量 a 和 b ，表明元组可以包含不同类型的值。</p>
<p class="calibre9">其次， fst 函数的结果值的类型为 a 。前面提到过，参数多态没有办法知道输入参数的实际类型，并且它也没有足够的信息构造一个 a 类型的值，当然，它也不可以将 a 转换为 b 。因此，这个函数唯一合法的行为，就是返回元组的第一个元素。</p>
<h2 class="calibre14"><a id="chp-2.html._874" class="calibre7 pcalibre"></a>延伸阅读</h2>
<p class="calibre9">前一节所说的 fst 函数的类型推导行为背后隐藏着非常高深的数学知识，并且可以延伸出一系列复杂的多态函数。有兴趣的话，可以参考 Philip Wadler 的 Theorems for free 论文。</p>
<h2 class="calibre14"><a id="chp-2.html._878" class="calibre7 pcalibre"></a>多参数函数的类型</h2>
<p class="calibre9">截至目前为止，我们已经见到过一些函数，比如 take ，它们接受一个以上的参数：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>type take
take <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span>

</code></pre>
<p class="calibre9">通过类型签名可以看到， take 函数和一个 Int 值以及两个列表有关。类型签名中的 -&gt; 符号是右关联的： Haskell 从右到左地串联起这些箭头，使用括号可以清晰地标示这个类型签名是怎样被解释的：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch02<span class="token3">/</span>Take<span class="token">.</span>hs
take <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span><span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span><span class="token">)</span>

</code></pre>
<p class="calibre9">从这个新的类型签名可以看出， take 函数实际上只接受一个 Int 类型的参数，并返回另一个函数，这个新函数接受一个列表作为参数，并返回一个同类型的列表作为这个函数的结果。</p>
<p class="calibre9">以上的说明都是正确的，但要说清楚隐藏在这种变换背后的重要性并不容易，在《部分函数应用和柯里化》一节，我们会再次回到这个主题上。目前来说，可以简单地将类型签名中最后一个 -&gt; 右边的类型看作是函数结果的类型，而将前面的其他类型看作是函数参数的类型。</p>
<p class="calibre9">了解了这些之后，现在可以为前面定义的 myDrop 函数编写类型签名了：</p>
<pre class="calibre15"><code class="tthhighlight-container">myDrop <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span>

</code></pre>
<h2 class="calibre14"><a id="chp-2.html._907" class="calibre7 pcalibre"></a>为什么要对纯度斤斤计较？</h2>
<p class="calibre9">很少有语言像 Haskell 那样，默认使用纯函数。这个选择不仅意义深远，而且至关重要。</p>
<p class="calibre9">因为纯函数的值只取决于输入的参数，所以通常只要看看函数的名字，还有它的类型签名，就能大概知道函数是干什么用的。</p>
<p class="calibre9">以 not 函数为例子：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>type not
not <span class="token">:</span><span class="token">:</span> Bool <span class="token3">-</span><span class="token3">&gt;</span> Bool

</code></pre>
<p class="calibre9">即使抛开函数名不说，单单函数签名就极大地限制了这个函数可能有的合法行为：</p>
<ul class="calibre10"><li class="calibre11">函数要么返回 True ，要么返回 False</li><li class="calibre11">函数直接将输入参数当作返回值返回</li><li class="calibre11">函数对它的输入值求反</li></ul>
<p class="calibre9">除此之外，我们还能肯定，这个函数不会干以下这些事情：读取文件，访问网络，或者返回当前时间。</p>
<p class="calibre9">纯度减轻了理解一个函数所需的工作量。一个纯函数的行为并不取决于全局变量、数据库的内容或者网络连接状态。纯代码（pure code）从一开始就是模块化的：每个函数都是自包容的，并且都带有定义良好的接口。</p>
<p class="calibre9">将纯函数作为默认的另一个不太明显的好处是，它使得与<em class="calibre13">不纯</em>代码之间的交互变得简单。一种常见的 Haskell 风格就是，将带有副作用的代码和不带副作用的代码分开处理。在这种情况下，不纯函数需要尽可能地简单，而复杂的任务则交给纯函数去做。</p>
<p class="calibre9">软件的大部分风险，都来自于与外部世界进行交互：它需要程序去应付错误的、不完整的数据，并且处理恶意的攻击，诸如此类。Haskell 的类型系统明确地告诉我们，哪一部分的代码带有副作用，让我们可以对这部分代码添加适当的保护措施。</p>
<p class="calibre9">通过这种将不纯函数隔离、并尽可能简单化的编程风格，程序的漏洞将变得非常少。</p>
<h2 class="calibre14"><a id="chp-2.html._937" class="calibre7 pcalibre"></a>回顾</h2>
<p class="calibre9">这一章对 Haskell 的类型系统以及类型语法进行了快速的概览，了解了基本类型，并学习了如何去编写简单的函数。这章还介绍了多态、条件表达式、纯度和惰性求值。</p>
<p class="calibre9">这些知识必须被充分理解。在第三章，我们就会在这些基本知识的基础上，进一步加深对 Haskell 的理解。</p>
</div></div></div></div></div></div>
<div id="chp-3.html"><div class="calibre">
<div id="chp-3.html.main" class="calibre1"><div class="root"><div class="article"><h1 class="article-head" id="chp-3.html.calibre_toc_3">第三章：Defining Types, Streamlining Functions</h1><div class="article-body"><h1 class="calibre6"><a id="chp-3.html.Defining_Types_Streamlining_Functions_0" class="calibre7 pcalibre"></a>第三章：Defining Types, Streamlining Functions</h1>
<h2 class="calibre8"><a id="chp-3.html._2" class="calibre7 pcalibre"></a>定义新的数据类型</h2>
<p class="calibre9">尽管列表和元组都非常有用，但是，定义新的数据类型也是一种常见的需求，这种能力使得我们可以为程序中的值添加结构。</p>
<p class="calibre9">而且比起使用元组，对一簇相关的值赋予一个名字和一个独一无二的类型显得更有用一些。</p>
<p class="calibre9">定义新的数据类型也提升了代码的安全性：Haskell 不会允许我们混用两个结构相同但类型不同的值。</p>
<p class="calibre9">本章将以一个在线书店为例子，展示如何去进行类型定义。</p>
<p class="calibre9">使用 data 关键字可以定义新的数据类型：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>BookStore<span class="token">.</span>hs
data BookInfo <span class="token3">=</span> Book Int String <span class="token">[</span>String<span class="token">]</span>
                deriving <span class="token">(</span>Show<span class="token">)</span>

</code></pre>
<p class="calibre9">跟在 data 关键字之后的 BookInfo 就是新类型的名字，我们称 BookInfo 为<em class="calibre13">类型构造器</em>。类型构造器用于指代（refer）类型。正如前面提到过的，类型名字的首字母必须大写，因此，类型构造器的首字母也必须大写。</p>
<p class="calibre9">接下来的 Book 是<em class="calibre13">值构造器</em>（有时候也称为数据构造器）的名字。类型的值就是由值构造器创建的。值构造器名字的首字母也必须大写。</p>
<p class="calibre9">在 Book 之后的 Int ， String 和 [String] 是类型的<em class="calibre13">组成部分</em>。组成部分的作用，和面向对象语言的类中的域作用一致：它是一个储存值的槽。（为了方便起见，我们通常也将组成部分称为域。）</p>
<p class="calibre9">在这个例子中， Int 表示一本书的 ID ，而 String 表示书名，而 [String] 则代表作者。</p>
<p class="calibre9">BookInfo 类型包含的成分和一个 (Int,String,[String]) 类型的三元组一样，它们唯一不相同的是类型。[译注：这里指的是整个值的类型，不是成分的类型。]我们不能混用结构相同但类型不同的值。</p>
<p class="calibre9">举个例子，以下的 MagzineInfo 类型的成分和 BookInfo 一模一样，但 Haskell 会将它们作为不同的类型来区别对待，因为它们的类型构构造器和值构造器并不相同：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>BookStore<span class="token">.</span>hs
data MagzineInfo <span class="token3">=</span> Magzine Int String <span class="token">[</span>String<span class="token">]</span>
                   deriving <span class="token">(</span>Show<span class="token">)</span>

</code></pre>
<p class="calibre9">可以将值构造器看作是一个函数 —— 它创建并返回某个类型值。在这个书店的例子里，我们将 Int 、 String 和 [String] 三个类型的值应用到 Book ，从而创建一个 BookInfo 类型的值：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>BookStore<span class="token">.</span>hs
myInfo <span class="token3">=</span> Book <span class="token2">9780135072455</span> <span class="token4">"Algebra of Programming"</span>
              <span class="token">[</span><span class="token4">"Richard Bird"</span><span class="token">,</span> <span class="token4">"Oege de Moor"</span><span class="token">]</span>

</code></pre>
<p class="calibre9">定义类型的工作完成之后，可以到 ghci 里载入并测试这些新类型：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load BookStore<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> BookStore<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

</code></pre>
<p class="calibre9">再看看前面在文件里定义的 myInfo 变量：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> myInfo
Book <span class="token2">494539463</span> <span class="token4">"Algebra of Programming"</span> <span class="token">[</span><span class="token4">"Richard Bird"</span><span class="token">,</span><span class="token4">"Oege de Moor"</span><span class="token">]</span>

</code></pre>
<p class="calibre9">在 ghci 里面当然也可以创建新的 BookInfo 值：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> Book <span class="token2">0</span> <span class="token4">"The Book of Imaginary Beings"</span> <span class="token">[</span><span class="token4">"Jorge Luis Borges"</span><span class="token">]</span>
Book <span class="token2">0</span> <span class="token4">"The Book of Imaginary Beings"</span> <span class="token">[</span><span class="token4">"Jorge Luis Borges"</span><span class="token">]</span>

</code></pre>
<p class="calibre9">可以用 :type 命令来查看表达式的值：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type Book <span class="token2">1</span> <span class="token4">"Cosmicomics"</span> <span class="token">[</span><span class="token4">"Italo Calvino"</span><span class="token">]</span>
Book <span class="token2">1</span> <span class="token4">"Cosmicomics"</span> <span class="token">[</span><span class="token4">"Italo Calvino"</span><span class="token">]</span> <span class="token">:</span><span class="token">:</span> BookInfo

</code></pre>
<p class="calibre9">请记住，在 ghci 里定义变量的语法和在源码文件里定义变量的语法并不相同。在 ghci 里，变量通过 let 定义：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> let cities <span class="token3">=</span> Book <span class="token2">173</span> <span class="token4">"Use of Weapons"</span> <span class="token">[</span><span class="token4">"Iain M. Banks"</span><span class="token">]</span>

</code></pre>
<p class="calibre9">使用 :info 命令可以查看更多关于给定表达式的信息：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>info BookInfo
data BookInfo <span class="token3">=</span> Book Int String <span class="token">[</span>String<span class="token">]</span>
    <span class="token3">--</span> Defined at BookStore<span class="token">.</span>hs<span class="token">:</span><span class="token2">2</span><span class="token">:</span><span class="token2">6</span>
    instance Show BookInfo <span class="token3">--</span> Defined at BookStore<span class="token">.</span>hs<span class="token">:</span><span class="token2">3</span><span class="token">:</span><span class="token2">27</span>

</code></pre>
<p class="calibre9">使用 :type 命令，可以查看值构造器 Book 的类型签名，了解它是如何创建出 BookInfo 类型的值的：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type Book
Book <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>String<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> BookInfo

</code></pre>
<h2 class="calibre14"><a id="chp-3.html._107" class="calibre7 pcalibre"></a>类型构造器和值构造器的命名</h2>
<p class="calibre9">在前面介绍 BookInfo 类型的时候，我们专门为类型构造器和值构造器设置了不同的名字（ BookInfo 和 Book ），这样区分起来比较容易。</p>
<p class="calibre9">在 Haskell 里，类型的名字（类型构造器）和值构造器的名字是相互独立的。类型构造器只能出现在类型的定义，或者类型签名当中。而值构造器只能出现在实际的代码中。因为存在这种差别，给类型构造器和值构造器赋予一个相同的名字实际上并不会产生任何问题。</p>
<p class="calibre9">以下是这种用法的一个例子：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>BookStore<span class="token">.</span>hs
<span class="token3">--</span> 稍后就会介绍 CustomerID 的定义

data BookReview <span class="token3">=</span> BookReview BookInfo CustomerID String

</code></pre>
<p class="calibre9">以上代码定义了一个 BookReview 类型，并且它的值构造器的名字也同样是 BookReview 。</p>
<h2 class="calibre14"><a id="chp-3.html._125" class="calibre7 pcalibre"></a>类型别名</h2>
<p class="calibre9">可以使用<em class="calibre13">类型别名</em>，来为一个已存在的类型设置一个更具描述性的名字。</p>
<p class="calibre9">比如说，在前面 BookReview 类型的定义里，并没有说明 String 成分是干什么用的，通过类型别名，可以解决这个问题：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>BookStore<span class="token">.</span>hs
type CustomerID <span class="token3">=</span> Int
type ReviewBody <span class="token3">=</span> String

data BetterReview <span class="token3">=</span> BetterReview BookInfo CustomerID ReviewBody

</code></pre>
<p class="calibre9">type 关键字用于设置类型别名，其中新的类型名字放在 = 号的左边，而已有的类型名字放在 = 号的右边。这两个名字都标识同一个类型，因此，类型别名<em class="calibre13">完全是</em>为了提高可读性而存在的。</p>
<p class="calibre9">类型别名也可以用来为啰嗦的类型设置一个更短的名字：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>BookStore<span class="token">.</span>hs
type BookRecord <span class="token3">=</span> <span class="token">(</span>BookInfo<span class="token">,</span> BookReview<span class="token">)</span>

</code></pre>
<p class="calibre9">需要注意的是，类型别名只是为已有类型提供了一个新名字，创建值的工作还是由原来类型的值构造器进行。[注：如果你熟悉 C 或者 C++ ，可以将 Haskell 的类型别名看作是 typedef 。]</p>
<h2 class="calibre14"><a id="chp-3.html._152" class="calibre7 pcalibre"></a>代数数据类型</h2>
<p class="calibre9">Bool 类型是<em class="calibre13">代数数据类型</em>（algebraic data type）的最简单也是最常见的例子。一个代数类型可以有多于一个值构造器：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>Bool<span class="token">.</span>hs
data Bool <span class="token3">=</span> False <span class="token3">|</span> True

</code></pre>
<p class="calibre9">上面代码定义的 Bool 类型拥有两个值构造器，一个是 True ，另一个是 False 。每个值构造器使用 | 符号分割，读作“或者” —— 以 Bool 类型为例子，我们可以说， Bool 类型由 True 值或者 False 值构成。</p>
<p class="calibre9">当一个类型拥有一个以上的值构造器时，这些值构造器通常被称为“备选”（alternatives）或“分支”（case）。同一类型的所有备选，创建出的的值的类型都是相同的。</p>
<p class="calibre9">代数数据类型的各个值构造器都可以接受任意个数的参数。[译注：不同备选之间接受的参数个数不必相同，参数的类型也可以不一样。]以下是一个账单数据的例子：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>BookStore<span class="token">.</span>hs
type CardHolder <span class="token3">=</span> String
type CardNumber <span class="token3">=</span> String
type Address <span class="token3">=</span> <span class="token">[</span>String<span class="token">]</span>
data BillingInfo <span class="token3">=</span> CreditCard CardNumber CardHolder Address
                 <span class="token3">|</span> CashOnDelivery
                 <span class="token3">|</span> Invoice CustomerID
                   deriving <span class="token">(</span>Show<span class="token">)</span>

</code></pre>
<p class="calibre9">这个程序提供了三种付款的方式。如果使用信用卡付款，就要使用 CreditCard 作为值构造器，并输入信用卡卡号、信用卡持有人和地址作为参数。如果即时支付现金，就不用接受任何参数。最后，可以通过货到付款的方式来收款，在这种情况下，只需要填写客户的 ID 就可以了。</p>
<p class="calibre9">当使用值构造器来创建 BillingInfo 类型的值时，必须提供这个值构造器所需的参数：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load BookStore<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> BookStore<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type CreditCard
CreditCard <span class="token">:</span><span class="token">:</span> CardNumber <span class="token3">-</span><span class="token3">&gt;</span> CardHolder <span class="token3">-</span><span class="token3">&gt;</span> Address <span class="token3">-</span><span class="token3">&gt;</span> BillingInfo

<span class="token3">*</span>Main<span class="token3">&gt;</span> CreditCard <span class="token4">"2901650221064486"</span> <span class="token4">"Thomas Gradgrind"</span> <span class="token">[</span><span class="token4">"Dickens"</span><span class="token">,</span> <span class="token4">"England"</span><span class="token">]</span>
CreditCard <span class="token4">"2901650221064486"</span> <span class="token4">"Thomas Gradgrind"</span> <span class="token">[</span><span class="token4">"Dickens"</span><span class="token">,</span><span class="token4">"England"</span><span class="token">]</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type it
it <span class="token">:</span><span class="token">:</span> BillingInfo

</code></pre>
<p class="calibre9">如果输入参数的类型不对或者数量不对，那么引发一个错误：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> Invoice

<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">7</span><span class="token">:</span><span class="token2">1</span><span class="token">:</span>
    No instance <span class="token1">for</span> <span class="token">(</span>Show <span class="token">(</span>CustomerID <span class="token3">-</span><span class="token3">&gt;</span> BillingInfo<span class="token">)</span><span class="token">)</span>
        arising from a use of `print'
    Possible fix<span class="token">:</span>
        add an instance declaration <span class="token1">for</span> <span class="token">(</span>Show <span class="token">(</span>CustomerID <span class="token3">-</span><span class="token3">&gt;</span> BillingInfo<span class="token">)</span><span class="token">)</span>
    In a stmt of an interactive GHCi command<span class="token">:</span> print it

</code></pre>
<p class="calibre9">ghci 抱怨我们没有给 Invoice 值构造器足够的参数。</p>
<p class="calibre9">[译注：原文这里的代码示例有错，译文已改正。]</p>
<h2 class="calibre14"><a id="chp-3.html._218" class="calibre7 pcalibre"></a>什么情况下该用元组，而什么情况下又该用代数数据类型？</h2>
<p class="calibre9">元组和自定域代数数据类型有一些相似的地方。比如说，可以使用一个 (Int,String,[String]) 类型的元组来代替 BookInfo 类型：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> Book <span class="token2">2</span> <span class="token4">"The Wealth of Networks"</span> <span class="token">[</span><span class="token4">"Yochai Benkler"</span><span class="token">]</span>
Book <span class="token2">2</span> <span class="token4">"The Wealth of Networks"</span> <span class="token">[</span><span class="token4">"Yochai Benkler"</span><span class="token">]</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">(</span><span class="token2">2</span><span class="token">,</span> <span class="token4">"The Wealth of Networks"</span><span class="token">,</span> <span class="token">[</span><span class="token4">"Yochai Benkler"</span><span class="token">]</span><span class="token">)</span>
<span class="token">(</span><span class="token2">2</span><span class="token">,</span><span class="token4">"The Wealth of Networks"</span><span class="token">,</span><span class="token">[</span><span class="token4">"Yochai Benkler"</span><span class="token">]</span><span class="token">)</span>

</code></pre>
<p class="calibre9">代数数据类型使得我们可以在结构相同但类型不同的数据之间进行区分。然而，对于元组来说，只要元素的结构和类型都一致，那么元组的类型就是相同的：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>Distinction<span class="token">.</span>hs
a <span class="token3">=</span> <span class="token">(</span><span class="token4">"Porpoise"</span><span class="token">,</span> <span class="token4">"Grey"</span><span class="token">)</span>
b <span class="token3">=</span> <span class="token">(</span><span class="token4">"Table"</span><span class="token">,</span> <span class="token4">"Oak"</span><span class="token">)</span>

</code></pre>
<p class="calibre9">其中 a 和 b 的类型相同：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load Distinction<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> Distinction<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type a
a <span class="token">:</span><span class="token">:</span> <span class="token">(</span><span class="token">[</span>Char<span class="token">]</span><span class="token">,</span> <span class="token">[</span>Char<span class="token">]</span><span class="token">)</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type b
b <span class="token">:</span><span class="token">:</span> <span class="token">(</span><span class="token">[</span>Char<span class="token">]</span><span class="token">,</span> <span class="token">[</span>Char<span class="token">]</span><span class="token">)</span>

</code></pre>
<p class="calibre9">对于两个不同的代数数据类型来说，即使值构造器成分的结构和类型都相同，它们也是不同的类型：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>Distinction<span class="token">.</span>hs
data Cetacean <span class="token3">=</span> Cetacean String String
data Furniture <span class="token3">=</span> Furniture String String

c <span class="token3">=</span> Cetacean <span class="token4">"Porpoise"</span> <span class="token4">"Grey"</span>
d <span class="token3">=</span> Furniture <span class="token4">"Table"</span> <span class="token4">"Oak"</span>

</code></pre>
<p class="calibre9">其中 c 和 d 的类型并不相同：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load Distinction<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> Distinction<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type c
c <span class="token">:</span><span class="token">:</span> Cetacean

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type d
d <span class="token">:</span><span class="token">:</span> Furniture

</code></pre>
<p class="calibre9">以下是一个更细致的例子，它用两种不同的方式表示二维向量：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>AlgebraicVector<span class="token">.</span>hs
<span class="token3">--</span> x and y coordinates or lengths<span class="token">.</span>
data Cartesian2D <span class="token3">=</span> Cartesian2D Double Double
                   deriving <span class="token">(</span>Eq<span class="token">,</span> Show<span class="token">)</span>

<span class="token3">--</span> Angle and distance <span class="token">(</span>magnitude<span class="token">)</span><span class="token">.</span>
data Polar2D <span class="token3">=</span> Polar2D Double Double
               deriving <span class="token">(</span>Eq<span class="token">,</span> Show<span class="token">)</span>

</code></pre>
<p class="calibre9">Cartesian2D 和 Polar2D 两种类型的成分都是 Double 类型，但是，这些成分表达的是不同的<em class="calibre13">意思</em>。因为 Cartesian2D 和 Polar2D 是不同的类型，因此 Haskell 不会允许混淆使用这两种类型：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load AlgebraicVector<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> AlgebraicVector<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>
<span class="token3">*</span>Main<span class="token3">&gt;</span> Cartesian2D <span class="token">(</span>sqrt <span class="token2">2</span><span class="token">)</span> <span class="token">(</span>sqrt <span class="token2">2</span><span class="token">)</span> <span class="token3">==</span> Polar2D <span class="token">(</span>pi <span class="token3">/</span> <span class="token2">4</span><span class="token">)</span> <span class="token2">2</span>

<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">3</span><span class="token">:</span><span class="token2">34</span><span class="token">:</span>
    Couldn<span class="token4">'t match expected type `Cartesian2D'</span>
with actual type `Polar2D'
    In the <span class="token1">return</span> type of a call of `Polar2D'
In the second argument of `<span class="token">(</span><span class="token3">==</span><span class="token">)</span><span class="token4">', namely `Polar2D (pi / 4) 2'</span>
In the expression<span class="token">:</span>
    Cartesian2D <span class="token">(</span>sqrt <span class="token2">2</span><span class="token">)</span> <span class="token">(</span>sqrt <span class="token2">2</span><span class="token">)</span> <span class="token3">==</span> Polar2D <span class="token">(</span>pi <span class="token3">/</span> <span class="token2">4</span><span class="token">)</span> <span class="token2">2</span>

</code></pre>
<p class="calibre9">错误信息显示， (==) 操作符只接受类型相同的值作为它的参数，在类型签名里也可以看出这一点：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token">(</span><span class="token3">==</span><span class="token">)</span>
<span class="token">(</span><span class="token3">==</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> Eq a <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> Bool

</code></pre>
<p class="calibre9">另一方面，如果使用类型为 (Double,Double) 的元组来表示二维向量的两种表示方式，那么我们就有麻烦了：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token3">--</span> 第一个元组使用 Cartesian 表示，第二个元组使用 Polar 表示
Prelude<span class="token3">&gt;</span> <span class="token">(</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">)</span> <span class="token3">==</span> <span class="token">(</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">)</span>
True

</code></pre>
<p class="calibre9">类型系统不会察觉到，我们正错误地对比两种不同表示方式的值，因为对两个类型相同的元组进行对比是完全合法的！</p>
<p class="calibre9">关于该使用元组还是该使用代数数据类型，没有一劳永逸的办法。但是，有一个经验法则可以参考：如果程序大量使用复合数据，那么使用 data 进行类型自定义对于类型安全和可读性都有好处。而对于小规模的内部应用，那么通常使用元组就足够了。</p>
<h2 class="calibre14"><a id="chp-3.html._333" class="calibre7 pcalibre"></a>其他语言里类似代数数据类型的东西</h2>
<p class="calibre9">代数数据类型为描述数据类型提供了一种单一且强大的方式。很多其他语言，要达到相当于代数数据类型的表达能力，需要同时使用多种特性。</p>
<p class="calibre9">以下是一些 C 和 C++ 方面的例子，说明怎样在这些语言里，怎么样实现类似于代数数据类型的功能。</p>
<h4 class="calibre19"><a id="chp-3.html._339" class="calibre7 pcalibre"></a>结构</h4>
<p class="calibre9">当只有一个值构造器时，代数数据类型和元组很相似：它将一系列相关的值打包成一个复合值。这种做法相当于 C 和 C++ 里的 struct ，而代数数据类型的成分则相当于 struct 里的域。</p>
<p class="calibre9">以下是一个 C 结构，它等同于我们前面定义的 BookInfo 类型：</p>
<pre class="calibre15"><code class="tthhighlight-container">struct book_info <span class="token">{</span>
    int id<span class="token">;</span>
    char <span class="token3">*</span>name<span class="token">;</span>
    char <span class="token3">*</span><span class="token3">*</span>authors<span class="token">;</span>
<span class="token">}</span><span class="token">;</span>

</code></pre>
<p class="calibre9">目前来说， C 结构和 Haskell 的代数数据类型最大的差别是，代数数据类型的成分是匿名且按位置排序的：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span>file<span class="token">:</span> ch03<span class="token3">/</span>BookStore<span class="token">.</span>hs
data BookInfo <span class="token3">=</span> Book Int String <span class="token">[</span>String<span class="token">]</span>
                deriving <span class="token">(</span>Show<span class="token">)</span>

</code></pre>
<p class="calibre9">按位置排序指的是，对成分的访问是通过位置来实行的，而不是像 C 那样，通过名字：比如 book_info-&gt;id 。</p>
<p class="calibre9">稍后的“模式匹配”小节会介绍如何访代数数据类型里的成分。在“记录”一节会介绍定义数据的新语法，通过这种语法，可以像 C 结构那样，使用名字来访问相应的成分。</p>
<h4 class="calibre19"><a id="chp-3.html._367" class="calibre7 pcalibre"></a>枚举</h4>
<p class="calibre9">C 和 C++ 里的 enum 通常用于表示一系列符号值排列。代数数据类型里面也有相似的东西，一般称之为<em class="calibre13">枚举类型</em>。</p>
<p class="calibre9">以下是一个 enum 例子：</p>
<pre class="calibre15"><code class="tthhighlight-container">enum roygbiv <span class="token">{</span>
    red<span class="token">,</span>
    orange<span class="token">,</span>
    yellow<span class="token">,</span>
    green<span class="token">,</span>
    blue<span class="token">,</span>
    indigo<span class="token">,</span>
    violet<span class="token">,</span>
<span class="token">}</span><span class="token">;</span>

</code></pre>
<p class="calibre9">以下是等价的 Haskell 代码：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>Roygbiv<span class="token">.</span>hs
data Roygbiv <span class="token3">=</span> Red
             <span class="token3">|</span> Orange
             <span class="token3">|</span> Yellow
             <span class="token3">|</span> Green
             <span class="token3">|</span> Blue
             <span class="token3">|</span> Indigo
             <span class="token3">|</span> Violet
               deriving <span class="token">(</span>Eq<span class="token">,</span> Show<span class="token">)</span>

</code></pre>
<p class="calibre9">在 ghci 里面测试：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load Roygbiv<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> Roygbiv<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type Yellow
Yellow <span class="token">:</span><span class="token">:</span> Roygbiv

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type Red
Red <span class="token">:</span><span class="token">:</span> Roygbiv

<span class="token3">*</span>Main<span class="token3">&gt;</span> Red <span class="token3">==</span> Yellow
False

<span class="token3">*</span>Main<span class="token3">&gt;</span> Green <span class="token3">==</span> Green
True

</code></pre>
<p class="calibre9">enum 的问题是，它使用整数值去代表元素：在一些接受 enum 的场景里，可以将整数传进去，C 编译器会自动进行类型转换。同样，在使用整数的场景里，也可以将一个 enum 元素传进去。这种用法可能会造成一些令人不爽的 bug 。</p>
<p class="calibre9">另一方面，在 Haskell 里就没有这样的问题。比如说，不可能使用 Roygbiv 里的某个值来代替 Int 值[译注：因为枚举类型的每个元素都由一个唯一的值构造器生成，而不是使用整数表示。]：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> take <span class="token2">3</span> <span class="token4">"foobar"</span>
<span class="token4">"foo"</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> take Red <span class="token4">"foobar"</span>

<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">9</span><span class="token">:</span><span class="token2">6</span><span class="token">:</span>
    Couldn<span class="token4">'t match expected type `Int'</span> with actual type `Roygbiv'
    In the first argument of `take<span class="token4">', namely `Red'</span>
    In the expression<span class="token">:</span> take Red <span class="token4">"foobar"</span>
    In an equation <span class="token1">for</span> `it'<span class="token">:</span> it <span class="token3">=</span> take Red <span class="token4">"foobar"</span>

</code></pre>
<h4 class="calibre19"><a id="chp-3.html._440" class="calibre7 pcalibre"></a>联合</h4>
<p class="calibre9">如果一个代数数据类型有多个备选，那么可以将它看作是 C 或 C++ 里的 union 。</p>
<p class="calibre9">以上两者的一个主要区别是， union 并不告诉用户，当前使用的是哪一个备选， union 的使用者必须自己记录这方面的信息（通常使用一个额外的域来保存），这意味着，如果搞错了备选的信息，那么对 union 的使用就会出错。</p>
<p class="calibre9">以下是一个 union 例子：</p>
<pre class="calibre15"><code class="tthhighlight-container">enum shape_type <span class="token">{</span>
    shape_circle<span class="token">,</span>
    shape_poly<span class="token">,</span>
<span class="token">}</span><span class="token">;</span>

struct circle <span class="token">{</span>
    struct vector centre<span class="token">;</span>
    float radius<span class="token">;</span>
<span class="token">}</span><span class="token">;</span>

struct poly <span class="token">{</span>
    size_t num_vertices<span class="token">;</span>
    struct vector <span class="token3">*</span>vertices<span class="token">;</span>
<span class="token">}</span><span class="token">;</span>

struct shape
<span class="token">{</span>
    enum shape_type type<span class="token">;</span>
    union <span class="token">{</span>
    struct circle circle<span class="token">;</span>
    struct poly poly<span class="token">;</span>
    <span class="token">}</span> shape<span class="token">;</span>
<span class="token">}</span><span class="token">;</span>

</code></pre>
<p class="calibre9">在上面的代码里， shape 域的值可以是一个 circle 结构，也可以是一个 poly 结构。 shape_type 用于记录目前 shape 正在使用的结构类型。</p>
<p class="calibre9">另一方面，Haskell 版本不仅简单，而且更为安全：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>ShapeUnion<span class="token">.</span>hs
type Vector <span class="token3">=</span> <span class="token">(</span>Double<span class="token">,</span> Double<span class="token">)</span>

data Shape <span class="token3">=</span> Circle Vector Double
           <span class="token3">|</span> Poly <span class="token">[</span>Vector<span class="token">]</span>
             deriving <span class="token">(</span>Show<span class="token">)</span>

</code></pre>
<p class="calibre9">[译注：原文的代码少了 deriving(Show) 一行，在 ghci 测试时会出错。]</p>
<p class="calibre9">注意，我们不必像 C 语言那样，使用 shape_type 域来手动记录 Shape 类型的值是由 Circle 构造器生成的，还是由 Poly 构造器生成， Haskell 自己有办法弄清楚一点，它不会弄混两种不同的值。其中的原因，下一节《模式匹配》就会讲到。</p>
<p class="calibre9">[译注：原文这里将 Poly 写成了 Square 。]</p>
<h2 class="calibre14"><a id="chp-3.html._495" class="calibre7 pcalibre"></a>模式匹配</h2>
<p class="calibre9">前面的章节介绍了代数数据类型的定义方法，本节将说明怎样去处理这些类型的值。</p>
<p class="calibre9">对于某个类型的值来说，应该可以做到以下两点：</p>
<ul class="calibre10"><li class="calibre11">如果这个类型有一个以上的值构造器，那么应该可以知道，这个值是由哪个构造器创建的。</li><li class="calibre11">如果一个值构造器包含不同的成分，那么应该有办法提取这些成分。</li></ul>
<p class="calibre9">对于以上两个问题， Haskell 有一个简单且有效的解决方式，那就是<em class="calibre13">类型匹配</em>。</p>
<p class="calibre9">模式匹配允许我们查看值的内部，并将值所包含的数据绑定到变量上。以下是一个对 Bool 类型值进行模式匹配的例子，它的作用和 not 函数一样：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> myNot<span class="token">.</span>hs
myNot True <span class="token3">=</span> False
myNot False <span class="token3">=</span> True

</code></pre>
<p class="calibre9">[译注：原文的文件名为 add.hs ，这里修改成 myNot.hs ，和函数名保持一致。]</p>
<p class="calibre9">初看上去，代码似乎同时定义了两个 myNot 函数，但实际情况并不是这样 —— Haskell 允许将函数定义为<em class="calibre13">一系列等式</em>： myNot 的两个等式分别定义了函数对于输入参数在不同模式之下的行为。对于每行等式，模式定义放在函数名之后， = 符号之前。</p>
<p class="calibre9">为了理解模式匹配是如何工作的，来研究一下 myNotFalse 是如何执行的：首先调用 myNot ， Haskell 运行时检查输入参数 False 是否和第一个模式的值构造器匹配 —— 答案是不匹配，于是它继续尝试匹配第二个模式 —— 这次匹配成功了，于是第二个等式右边的值被作为结果返回。</p>
<p class="calibre9">以下是一个复杂一点的例子，这个函数计算出列表所有元素之和：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span><span class="token">:</span> ch03<span class="token3">/</span>sumList<span class="token">.</span>hs
sumList <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span> x <span class="token3">+</span> sumList xs
sumList <span class="token">[</span><span class="token">]</span>  <span class="token3">=</span> <span class="token2">0</span>

</code></pre>
<p class="calibre9">[译注：原文代码的文件名为 add.hs 这里改为 sumList.hs ，和函数名保持一致。]</p>
<p class="calibre9">需要说明的一点是，在 Haskell 里，列表 [1,2] 实际上只是 (1:(2:[])) 的一种简单的表示方式，其中 (:) 用于构造列表：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">[</span><span class="token">]</span>
<span class="token">[</span><span class="token">]</span>

Prelude<span class="token3">&gt;</span> <span class="token2">1</span><span class="token">:</span><span class="token">[</span><span class="token">]</span>
<span class="token">[</span><span class="token2">1</span><span class="token">]</span>

Prelude<span class="token3">&gt;</span> <span class="token2">1</span><span class="token">:</span><span class="token2">2</span><span class="token">:</span><span class="token">[</span><span class="token">]</span>
<span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">]</span>

</code></pre>
<p class="calibre9">因此，当需要对一个列表进行匹配时，也可以使用 (:) 操作符，只不过这次不是用来构造列表，而是用来分解列表。</p>
<p class="calibre9">作为例子，考虑求值 sumList[1,2] 时会发生什么：首先， [1,2] 尝试对第一个等式的模式 (x:xs) 进行匹配，结果是模式匹配成功，并将 x 绑定为 1 ， xs 绑定为 [2] 。</p>
<p class="calibre9">计算进行到这一步，表达式就变成了 1+(sumList[2]) ，于是递归调用 sumList ，对 [2] 进行模式匹配。</p>
<p class="calibre9">这一次也是在第一个等式匹配成功，变量 x 被绑定为 2 ，而 xs 被绑定为 [] 。表达式变为 1+(2+sumList[]) 。</p>
<p class="calibre9">再次递归调用 sumList ，输入为 [] ，这一次，第二个等式的 [] 模式匹配成功，返回 0 ，整个表达式为 1+(2+(0)) ，计算结果为 3 。</p>
<p class="calibre9">最后要说的一点是，标准函数库里已经有 sum 函数，它和我们定以的 sumList 一样，都可以用于计算表元素的和：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load sumList<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> sumList<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> sumList <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">]</span>
<span class="token2">3</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> sum <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">]</span>
<span class="token2">3</span>

</code></pre>
<h2 class="calibre14"><a id="chp-3.html._571" class="calibre7 pcalibre"></a>组成和解构</h2>
<p class="calibre9">让我们稍微慢下探索新特性的脚步，花些时间，了解构造一个值、和对这个值进行模式匹配之间的关系。</p>
<p class="calibre9">我们通过应用值构造器来构建值：表达式 Book9"CloseCalls"["JohnLong"] 应用 Book 构造器到值 9 、 "CloseCalls" 和 ["JohnLong"] 上面，从而产生一个新的 BookInfo 类型的值。</p>
<p class="calibre9">另一方面，当对 Book 构造器进行模式匹配时，我们<em class="calibre13">逆转</em>（reverse）它的构造过程：首先，检查这个值是否由 Book 构造器生成 —— 如果是的话，那么就对这个值进行探查（inspect），并取出创建这个值时，提供给构造器的各个值。</p>
<p class="calibre9">考虑一下表达式 Book9"CloseCalls"["JohnLong"] 对模式 (Bookidnameauthors) 的匹配是如何进行的：</p>
<ul class="calibre10"><li class="calibre11">因为值的构造器和模式里的构造器相同，因此匹配成功。</li><li class="calibre11">变量 id 被绑定为 9 。</li><li class="calibre11">变量 name 被绑定为 CloseCalls 。</li><li class="calibre11">变量 authors 被绑定为 ["JohnLong"] 。</li></ul>
<p class="calibre9">因为模式匹配的过程就像是逆转一个值的构造（construction）过程，因此它有时候也被称为<em class="calibre13">解构</em>（deconstruction）。</p>
<p class="calibre9">[译注：上一节的《联合》小节里提到， Haskell 有办法分辨同一类型由不同值构造器创建的值，说的就是模式匹配。</p>
<p class="calibre9">比如 Circle... 和 Poly... 两个表达式创建的都是 Shape 类型的值，但第一个表达式只有在匹配 (Circlevectordouble) 模式时才会成功，而第二个表达式只有在 (Polyvectors) 时才会成功。这就是它们不会被混淆的原因。]</p>
<h2 class="calibre14"><a id="chp-3.html._592" class="calibre7 pcalibre"></a>更进一步</h2>
<p class="calibre9">对元组进行模式匹配的语法，和构造元组的语法很相似。</p>
<p class="calibre9">以下是一个可以返回三元组中最后一个元素的函数：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>third<span class="token">.</span>hs
third <span class="token">(</span>a<span class="token">,</span> b<span class="token">,</span> c<span class="token">)</span> <span class="token3">=</span> c

</code></pre>
<p class="calibre9">[译注：原文的源码文件名为 Tuple.hs ，这里改为 third.hs ，和函数的名字保持一致。]</p>
<p class="calibre9">在 ghci 里测试这个函数：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load third<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> third<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> third <span class="token">(</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">,</span> <span class="token2">3</span><span class="token">)</span>
<span class="token2">3</span>

</code></pre>
<p class="calibre9">模式匹配的“深度”并没有限制。以下模式会同时对元组和元组里的列表进行匹配：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>complicated<span class="token">.</span>hs
complicated <span class="token">(</span>True<span class="token">,</span> a<span class="token">,</span> x<span class="token">:</span>xs<span class="token">,</span> <span class="token2">5</span><span class="token">)</span> <span class="token3">=</span> <span class="token">(</span>a<span class="token">,</span> xs<span class="token">)</span>

</code></pre>
<p class="calibre9">[译注：原文的源码文件名为 Tuple.hs ，这里改为 complicated.hs ，和函数的名字保持一致。]</p>
<p class="calibre9">在 ghci 里测试这个函数：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load complicated<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> complicated<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> complicated <span class="token">(</span>True<span class="token">,</span> <span class="token2">1</span><span class="token">,</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">,</span> <span class="token2">3</span><span class="token">]</span><span class="token">,</span> <span class="token2">5</span><span class="token">)</span>
<span class="token">(</span><span class="token2">1</span><span class="token">,</span><span class="token">[</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">]</span><span class="token">)</span>

</code></pre>
<p class="calibre9">对于出现在模式里的字面（literal）值（比如前面元组例子里的 True 和 5 ），输入里的各个值必须和这些字面值相等，匹配才有可能成功。以下代码显示，因为输入元组和模式的第一个字面值 True 不匹配，所以匹配失败了：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> complicated <span class="token">(</span>False<span class="token">,</span> <span class="token2">1</span><span class="token">,</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">,</span> <span class="token2">3</span><span class="token">]</span><span class="token">,</span> <span class="token2">5</span><span class="token">)</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> complicated<span class="token">.</span>hs<span class="token">:</span><span class="token2">2</span><span class="token">:</span><span class="token2">1</span><span class="token3">-</span><span class="token2">40</span><span class="token">:</span> Non<span class="token3">-</span>exhaustive patterns <span class="token1">in</span> <span class="token1">function</span> complicated

</code></pre>
<p class="calibre9">这个例子也显示了，如果所有给定等式的模式都匹配失败，那么返回一个运行时错误。</p>
<p class="calibre9">对代数数据类型的匹配，可以通过这个类型的值构造器来进行。拿之前我们定义的 BookInfo 类型为例子，对它的模式匹配可以使用它的 Book 构造器来进行：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>BookStore<span class="token">.</span>hs
bookID      <span class="token">(</span>Book id title authors<span class="token">)</span> <span class="token3">=</span> id
bookTitle   <span class="token">(</span>Book id title authors<span class="token">)</span> <span class="token3">=</span> title
bookAuthors <span class="token">(</span>Book id title authors<span class="token">)</span> <span class="token3">=</span> authors

</code></pre>
<p class="calibre9">在 ghci 里试试：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load BookStore<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> BookStore<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> let book <span class="token3">=</span> <span class="token">(</span>Book <span class="token2">3</span> <span class="token4">"Probability Theory"</span> <span class="token">[</span><span class="token4">"E.T.H. Jaynes"</span><span class="token">]</span><span class="token">)</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> bookID book
<span class="token2">3</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> bookTitle book
<span class="token4">"Probability Theory"</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> bookAuthors book
<span class="token">[</span><span class="token4">"E.T.H. Jaynes"</span><span class="token">]</span>

</code></pre>
<p class="calibre9">字面值的比对规则对于列表和值构造器的匹配也适用： (3:xs) 模式只匹配那些不为空，并且第一个元素为 3 的列表；而 (Book3titleauthors) 只匹配 ID 值为 3 的那本书。</p>
<h2 class="calibre14"><a id="chp-3.html._682" class="calibre7 pcalibre"></a>模式匹配中的变量名命名</h2>
<p class="calibre9">当你阅读那些进行模式匹配的函数时，经常会发现像是 (x:xs) 或是 (d:ds) 这种类型的名字。这是一个流行的命名规则，其中的 s 表示“元素的复数”。以 (x:xs) 来说，它用 x 来表示列表的第一个元素，剩余的列表元素则用 xs 表示。</p>
<h2 class="calibre14"><a id="chp-3.html._686" class="calibre7 pcalibre"></a>通配符模式匹配</h2>
<p class="calibre9">如果在匹配模式中我们不在乎某个值的类型，那么可以用下划线字符 “_” 作为符号来进行标识，它也叫做<em class="calibre13">通配符</em>。它的用法如下。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>BookStore<span class="token">.</span>hs
nicerID      <span class="token">(</span>Book id _     _      <span class="token">)</span> <span class="token3">=</span> id
nicerTitle   <span class="token">(</span>Book _  title _      <span class="token">)</span> <span class="token3">=</span> title
nicerAuthors <span class="token">(</span>Book _  _     authors<span class="token">)</span> <span class="token3">=</span> authors

</code></pre>
<p class="calibre9">于是，我们将之前介绍过的访问器函数改得更加简明了。现在能很清晰的看出各个函数究竟使用到了哪些元素。</p>
<p class="calibre9">在模式匹配里，通配符的作用和变量类似，但是它并不会绑定成一个新的变量。就像上面的例子展示的那样，在一个模式匹配里可以使用一个或多个通配符。</p>
<p class="calibre9">使用通配符还有另一个好处。如果我们在一个匹配模式中引入了一个变量，但没有在函数体中用到它的话，Haskell 编译器会发出一个警告。定义一个变量但忘了使用通常意味着存在潜在的 bug，因此这是个有用的功能。假如我们不准备使用一个变量，那就不要用变量，而是用通配符，这样编译器就不会报错。</p>
<h2 class="calibre14"><a id="chp-3.html._704" class="calibre7 pcalibre"></a>穷举匹配模式和通配符</h2>
<p class="calibre9">在给一个类型写一组匹配模式时，很重要的一点就是一定要涵盖构造器的所有可能情况。例如，如果我们需要探查一个列表，就应该写一个匹配非空构造器 (:) 的方程和一个匹配空构造器 [] 的方程。</p>
<p class="calibre9">假如我们没有涵盖所有情况会发生什么呢。下面，我们故意漏写对 [] 构造器的检查。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>BadPattern<span class="token">.</span>hs
badExample <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span> x <span class="token3">+</span> badExample xs

</code></pre>
<p class="calibre9">如果我们将其作用于一个不能匹配的值，运行时就会报错：我们的软件有 bug！</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> badExample <span class="token">[</span><span class="token">]</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> BadPattern<span class="token">.</span>hs<span class="token">:</span><span class="token2">4</span><span class="token">:</span><span class="token2">0</span><span class="token3">-</span><span class="token2">36</span><span class="token">:</span> Non<span class="token3">-</span>exhaustive patterns <span class="token1">in</span> <span class="token1">function</span> badExample

</code></pre>
<p class="calibre9">在上面的例子中，函数定义时的方程里没有一个可以匹配 [] 这个值。</p>
<p class="calibre9">如果在某些情况下，我们并不在乎某些特定的构造器，我们就可以用通配符匹配模式来定义一个默认的行为。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>BadPattern<span class="token">.</span>hs
goodExample <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span> x <span class="token3">+</span> goodExample xs
goodExample _      <span class="token3">=</span> <span class="token2">0</span>

</code></pre>
<p class="calibre9">上面例子中的通配符可以匹配 [] 构造器，因此应用这个函数不会导致程序崩溃。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> goodExample <span class="token">[</span><span class="token">]</span>
<span class="token2">0</span>
ghci<span class="token3">&gt;</span> goodExample <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">]</span>
<span class="token2">3</span>

</code></pre>
<h2 class="calibre14"><a id="chp-3.html._745" class="calibre7 pcalibre"></a>记录语法</h2>
<p class="calibre9">给一个数据类型的每个成分写访问器函数是令人感觉重复而且乏味的事情。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>BookStore<span class="token">.</span>hs
nicerID      <span class="token">(</span>Book id _     _      <span class="token">)</span> <span class="token3">=</span> id
nicerTitle   <span class="token">(</span>Book _  title _      <span class="token">)</span> <span class="token3">=</span> title
nicerAuthors <span class="token">(</span>Book _  _     authors<span class="token">)</span> <span class="token3">=</span> authors

</code></pre>
<p class="calibre9">我们把这种代码叫做“样板代码（boilerplate code）”：尽管是必需的，但是又长又烦。Haskell 程序员不喜欢样板代码。幸运的是，语言的设计者提供了避免这个问题的方法：我们在定义一种数据类型的同时，就可以定义好每个成分的访问器。（逗号的位置是一个风格问题，如果你喜欢的话，也可以把它放在每行的最后。）</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>BookStore<span class="token">.</span>hs
data Customer <span class="token3">=</span> Customer <span class="token">{</span>
      customerID      <span class="token">:</span><span class="token">:</span> CustomerID
    <span class="token">,</span> customerName    <span class="token">:</span><span class="token">:</span> String
    <span class="token">,</span> customerAddress <span class="token">:</span><span class="token">:</span> Address
    <span class="token">}</span> deriving <span class="token">(</span>Show<span class="token">)</span>

</code></pre>
<p class="calibre9">以上代码和下面这段我们更熟悉的代码的意义几乎是完全一致的。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>AltCustomer<span class="token">.</span>hs
data Customer <span class="token3">=</span> Customer Int String <span class="token">[</span>String<span class="token">]</span>
                deriving <span class="token">(</span>Show<span class="token">)</span>

customerID <span class="token">:</span><span class="token">:</span> Customer <span class="token3">-</span><span class="token3">&gt;</span> Int
customerID <span class="token">(</span>Customer id _ _<span class="token">)</span> <span class="token3">=</span> id

customerName <span class="token">:</span><span class="token">:</span> Customer <span class="token3">-</span><span class="token3">&gt;</span> String
customerName <span class="token">(</span>Customer _ name _<span class="token">)</span> <span class="token3">=</span> name

customerAddress <span class="token">:</span><span class="token">:</span> Customer <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>String<span class="token">]</span>
customerAddress <span class="token">(</span>Customer _ _ address<span class="token">)</span> <span class="token3">=</span> address

</code></pre>
<p class="calibre9">Haskell 会使用我们在定义类型的每个字段时的命名，相应生成与该命名相同的该字段的访问器函数。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type customerID
customerID <span class="token">:</span><span class="token">:</span> Customer <span class="token3">-</span><span class="token3">&gt;</span> CustomerID

</code></pre>
<p class="calibre9">我们仍然可以如往常一样使用应用语法来新建一个此类型的值。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>BookStore<span class="token">.</span>hs
customer1 <span class="token3">=</span> Customer <span class="token2">271828</span> <span class="token4">"J.R. Hacker"</span>
            <span class="token">[</span><span class="token4">"255 Syntax Ct"</span><span class="token">,</span>
             <span class="token4">"Milpitas, CA 95134"</span><span class="token">,</span>
             <span class="token4">"USA"</span><span class="token">]</span>

</code></pre>
<p class="calibre9">记录语法还新增了一种更详细的标识法来新建一个值。这种标识法通常都会提升代码的可读性。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>BookStore<span class="token">.</span>hs
customer2 <span class="token3">=</span> Customer <span class="token">{</span>
              customerID <span class="token3">=</span> <span class="token2">271828</span>
            <span class="token">,</span> customerAddress <span class="token3">=</span> <span class="token">[</span><span class="token4">"1048576 Disk Drive"</span><span class="token">,</span>
                                 <span class="token4">"Milpitas, CA 95134"</span><span class="token">,</span>
                                 <span class="token4">"USA"</span><span class="token">]</span>
            <span class="token">,</span> customerName <span class="token3">=</span> <span class="token4">"Jane Q. Citizen"</span>
            <span class="token">}</span>

</code></pre>
<p class="calibre9">如果使用这种形式，我们还可以调换字段列表的顺序。比如在上面的例子里，name 和 address 字段的顺序就被移动过，和定义类型时的顺序不一样了。</p>
<p class="calibre9">当我们使用记录语法来定义类型时，还会影响到该类型的打印格式。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> customer1
Customer <span class="token">{</span>customerID <span class="token3">=</span> <span class="token2">271828</span><span class="token">,</span> customerName <span class="token3">=</span> <span class="token4">"J.R. Hacker"</span><span class="token">,</span> customerAddress <span class="token3">=</span> <span class="token">[</span><span class="token4">"255 Syntax Ct"</span><span class="token">,</span><span class="token4">"Milpitas, CA 95134"</span><span class="token">,</span><span class="token4">"USA"</span><span class="token">]</span><span class="token">}</span>

</code></pre>
<p class="calibre9">让我们打印一个 BookInfo 类型的值来做个比较；这是没有使用记录语法时的打印格式。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> cities
Book <span class="token2">173</span> <span class="token4">"Use of Weapons"</span> <span class="token">[</span><span class="token4">"Iain M. Banks"</span><span class="token">]</span>

</code></pre>
<p class="calibre9">我们在使用记录语法的时候“免费”得到的访问器函数，实际上都是普通的 Haskell 函数。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type customerName
customerName <span class="token">:</span><span class="token">:</span> Customer <span class="token3">-</span><span class="token3">&gt;</span> String
ghci<span class="token3">&gt;</span> customerName customer1
<span class="token4">"J.R. Hacker"</span>

</code></pre>
<p class="calibre9">标准库里的 System.Time 模块就是一个使用记录语法的好例子。例如其中定义了这样一个类型：</p>
<pre class="calibre15"><code class="tthhighlight-container">data CalendarTime <span class="token3">=</span> CalendarTime <span class="token">{</span>
  ctYear                      <span class="token">:</span><span class="token">:</span> Int<span class="token">,</span>
  ctMonth                     <span class="token">:</span><span class="token">:</span> Month<span class="token">,</span>
  ctDay<span class="token">,</span> ctHour<span class="token">,</span> ctMin<span class="token">,</span> ctSec <span class="token">:</span><span class="token">:</span> Int<span class="token">,</span>
  ctPicosec                   <span class="token">:</span><span class="token">:</span> Integer<span class="token">,</span>
  ctWDay                      <span class="token">:</span><span class="token">:</span> Day<span class="token">,</span>
  ctYDay                      <span class="token">:</span><span class="token">:</span> Int<span class="token">,</span>
  ctTZName                    <span class="token">:</span><span class="token">:</span> String<span class="token">,</span>
  ctTZ                        <span class="token">:</span><span class="token">:</span> Int<span class="token">,</span>
  ctIsDST                     <span class="token">:</span><span class="token">:</span> Bool
<span class="token">}</span>

</code></pre>
<p class="calibre9">假如没有记录语法，从一个如此复杂的类型中抽取某个字段将是一件非常痛苦的事情。这种标识法使我们在使用大型结构的过程中更方便了。</p>
<h2 class="calibre14"><a id="chp-3.html._867" class="calibre7 pcalibre"></a>参数化类型</h2>
<p class="calibre9">我们曾不止一次地提到列表类型是多态的：列表中的元素可以是任何类型。我们也可以给自定义的类型添加多态性。只要在类型定义中使用类型变量就可以做到这一点。Prelude 中定义了一种叫做 Maybe 的类型：它用来表示这样一种值——既可以有值也可能空缺，比如数据库中某行的某字段就可能为空。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>Nullable<span class="token">.</span>hs
data Maybe a <span class="token3">=</span> Just a
             <span class="token3">|</span> Nothing
译注：Maybe，Just，Nothing 都是 Prelude 中已经定义好的类型
这段代码是不能在 ghci 里面执行的，它简单地展示了标准库是怎么定义 Maybe 这种类型的

</code></pre>
<p class="calibre9">这里的变量 a 不是普通的变量：它是一个类型变量。它意味着 `Maybe 类型使用另一种类型作为它的参数。从而使得 Maybe 可以作用于任何类型的值。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>Nullable<span class="token">.</span>hs
someBool <span class="token3">=</span> Just True
someString <span class="token3">=</span> Just <span class="token4">"something"</span>

</code></pre>
<p class="calibre9">和往常一样，我们可以在 <strong class="calibre12">ghci</strong> 里试着用一下这种类型。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> Just <span class="token2">1.5</span>
Just <span class="token2">1.5</span>
ghci<span class="token3">&gt;</span> Nothing
Nothing
ghci<span class="token3">&gt;</span> <span class="token">:</span>type Just <span class="token4">"invisible bike"</span>
Just <span class="token4">"invisible bike"</span> <span class="token">:</span><span class="token">:</span> Maybe <span class="token">[</span>Char<span class="token">]</span>

</code></pre>
<p class="calibre9">Maybe 是一个多态，或者称作泛型的类型。我们向 Maybe 的类型构造器传入某种类型作为参数，例如 <code class="calibre16">MaybeInt 或</code>Maybe[Bool]。 如我们所希望的那样，这些都是不同的类型（译注：可能省略了“但是都可以成功传入作为参数”）。</p>
<p class="calibre9">我们可以嵌套使用参数化的类型，但要记得使用括号标识嵌套的顺序，以便 Haskell 编译器知道如何解析这样的表达式。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>Nullable<span class="token">.</span>hs
wrapped <span class="token3">=</span> Just <span class="token">(</span>Just <span class="token4">"wrapped"</span><span class="token">)</span>

</code></pre>
<p class="calibre9">再补充说明一下，如果和其它更常见的语言做个类比，参数化类型就相当于 C++ 中的模板（template），和 Java 中的泛型（generics）。请注意这仅仅是个大概的比喻。这些语言都是在被发明之后很久再加上模板和泛型的，因此在使用时会感到有些别扭。Haskell 则是从诞生之日起就有了参数化类型，因此更简单易用。</p>
<h2 class="calibre14"><a id="chp-3.html._911" class="calibre7 pcalibre"></a>递归类型</h2>
<p class="calibre9">列表这种常见的类型就是<em class="calibre13">递归</em>的：即它用自己来定义自己。为了深入了解其中的含义，让我们自己来设计一个与列表相仿的类型。我们将用 Cons 替换 (:) 构造器，用 Nil 替换 [] 构造器。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>ListADT<span class="token">.</span>hs
data List a <span class="token3">=</span> Cons a <span class="token">(</span>List a<span class="token">)</span>
            <span class="token3">|</span> Nil
              deriving <span class="token">(</span>Show<span class="token">)</span>

</code></pre>
<p class="calibre9">Lista 在 = 符号的左右两侧都有出现，我们可以说该类型的定义引用了它自己。当我们使用 Cons 构造器创建一个值的时候，我们必须提供一个 a 的值作为参数一，以及一个 Lista 类型的值作为参数二。接下来我们看一个实例。</p>
<p class="calibre9">我们能创建的 Lista 类型的最简单的值就是 Nil。请将上面的代码保存为一个文件，然后打开 <strong class="calibre12">ghci</strong> 并加载它。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> Nil
Nil

</code></pre>
<p class="calibre9">由于 Nil 是一个 Lista 类型（译注：原文是 List 类型，可能是漏写了 a），因此我们可以将它作为 Cons 的第二个参数。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> Cons <span class="token2">0</span> Nil
Cons <span class="token2">0</span> Nil

</code></pre>
<p class="calibre9">然后 Cons0Nil 也是一个 Lista 类型，我们也可以将它作为 Cons 的第二个参数。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> Cons <span class="token2">1</span> it
Cons <span class="token2">1</span> <span class="token">(</span>Cons <span class="token2">0</span> Nil<span class="token">)</span>
ghci<span class="token3">&gt;</span> Cons <span class="token2">2</span> it
Cons <span class="token2">2</span> <span class="token">(</span>Cons <span class="token2">1</span> <span class="token">(</span>Cons <span class="token2">0</span> Nil<span class="token">)</span><span class="token">)</span>
ghci<span class="token3">&gt;</span> Cons <span class="token2">3</span> it
Cons <span class="token2">3</span> <span class="token">(</span>Cons <span class="token2">2</span> <span class="token">(</span>Cons <span class="token2">1</span> <span class="token">(</span>Cons <span class="token2">0</span> Nil<span class="token">)</span><span class="token">)</span><span class="token">)</span>

</code></pre>
<p class="calibre9">我们可以一直这样写下去，得到一个很长的 Cons 链，其中每个子链的末位元素都是一个 Nil。</p>
<p class="calibre9">Tip</p>
<p class="calibre9">List 可以被当作是 list 吗？</p>
<p class="calibre9">让我们来简单的证明一下 Lista 类型和内置的 list 类型 [a] 拥有相同的构型。让我们设计一个函数能够接受任何一个 [a] 类型的值作为输入参数，并返回 Lista 类型的一个值。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>ListADT<span class="token">.</span>hs
fromList <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span> Cons x <span class="token">(</span>fromList xs<span class="token">)</span>
fromList <span class="token">[</span><span class="token">]</span>     <span class="token3">=</span> Nil

</code></pre>
<p class="calibre9">通过查看上述实现，能清楚的看到它将每个 (:) 替换成 Cons，将每个 [] 替换成 Nil。这样就涵盖了内置 list 类型的全部构造器。因此我们可以说二者是同构的，它们有着相同的构型。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> fromList <span class="token4">"durian"</span>
Cons <span class="token4">'d'</span> <span class="token">(</span>Cons <span class="token4">'u'</span> <span class="token">(</span>Cons <span class="token4">'r'</span> <span class="token">(</span>Cons <span class="token4">'i'</span> <span class="token">(</span>Cons <span class="token4">'a'</span> <span class="token">(</span>Cons <span class="token4">'n'</span> Nil<span class="token">)</span><span class="token">)</span><span class="token">)</span><span class="token">)</span><span class="token">)</span>
ghci<span class="token3">&gt;</span> fromList <span class="token">[</span>Just True<span class="token">,</span> Nothing<span class="token">,</span> Just False<span class="token">]</span>
Cons <span class="token">(</span>Just True<span class="token">)</span> <span class="token">(</span>Cons Nothing <span class="token">(</span>Cons <span class="token">(</span>Just False<span class="token">)</span> Nil<span class="token">)</span><span class="token">)</span>

</code></pre>
<p class="calibre9">为了说明什么是递归类型，我们再来看第三个例子——定义一个二叉树类型。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>Tree<span class="token">.</span>hs
data Tree a <span class="token3">=</span> Node a <span class="token">(</span>Tree a<span class="token">)</span> <span class="token">(</span>Tree a<span class="token">)</span>
            <span class="token3">|</span> Empty
              deriving <span class="token">(</span>Show<span class="token">)</span>

</code></pre>
<p class="calibre9">二叉树是指这样一种节点：该节点有两个子节点，这两个子节点要么也是二叉树节点，要么是空节点。</p>
<p class="calibre9">这次我们将和另一种常见的语言进行比较来寻找灵感。以下是在 Java 中实现类似数据结构的类定义。</p>
<pre class="calibre15"><code class="tthhighlight-container">class <span class="token5">Tree</span><span class="token3">&lt;</span>A<span class="token3">&gt;</span>
<span class="token">{</span>
    A value<span class="token">;</span>
    Tree<span class="token3">&lt;</span>A<span class="token3">&gt;</span> left<span class="token">;</span>
    Tree<span class="token3">&lt;</span>A<span class="token3">&gt;</span> right<span class="token">;</span>

    public <span class="token5">Tree</span><span class="token">(</span>A v<span class="token">,</span> Tree<span class="token3">&lt;</span>A<span class="token3">&gt;</span> l<span class="token">,</span> Tree<span class="token3">&lt;</span>A<span class="token3">&gt;</span> r<span class="token">)</span>
    <span class="token">{</span>
    value <span class="token3">=</span> v<span class="token">;</span>
    left <span class="token3">=</span> l<span class="token">;</span>
    right <span class="token3">=</span> r<span class="token">;</span>
    <span class="token">}</span>
<span class="token">}</span>

</code></pre>
<p class="calibre9">稍有不同的是，Java 中使用特殊值 null 表示各种“没有值”, 因此我们可以使用 null 来表示一个节点没有左子节点或没有右子节点。下面这个简单的函数能够构建一个有两个叶节点的树（叶节点这个词习惯上是指没有子节点的节点）。</p>
<pre class="calibre15"><code class="tthhighlight-container">class <span class="token5">Example</span>
<span class="token">{</span>
    static Tree<span class="token3">&lt;</span>String<span class="token3">&gt;</span> <span class="token5">simpleTree</span><span class="token">(</span><span class="token">)</span>
    <span class="token">{</span>
    <span class="token1">return</span> <span class="token1">new</span> <span class="token5">Tree</span><span class="token3">&lt;</span>String<span class="token3">&gt;</span><span class="token">(</span>
            <span class="token4">"parent"</span><span class="token">,</span>
        <span class="token1">new</span> <span class="token5">Tree</span><span class="token3">&lt;</span>String<span class="token3">&gt;</span><span class="token">(</span><span class="token4">"left leaf"</span><span class="token">,</span> <span class="token1">null</span><span class="token">,</span> <span class="token1">null</span><span class="token">)</span><span class="token">,</span>
        <span class="token1">new</span> <span class="token5">Tree</span><span class="token3">&lt;</span>String<span class="token3">&gt;</span><span class="token">(</span><span class="token4">"right leaf"</span><span class="token">,</span> <span class="token1">null</span><span class="token">,</span> <span class="token1">null</span><span class="token">)</span><span class="token">)</span><span class="token">;</span>
    <span class="token">}</span>
<span class="token">}</span>

</code></pre>
<p class="calibre9">Haskell 没有与 null 对应的概念。尽管我们可以使用 Maybe 达到类似的效果，但后果是模式匹配将变得十分臃肿。因此我们决定使用一个没有参数的 Empty 构造器。在上述 Tree 类型的 Java 实现中使用到 null 的地方，在 Haskell 中都改用 Empty。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>Tree<span class="token">.</span>hs
simpleTree <span class="token3">=</span> Node <span class="token4">"parent"</span> <span class="token">(</span>Node <span class="token4">"left child"</span> Empty Empty<span class="token">)</span>
                           <span class="token">(</span>Node <span class="token4">"right child"</span> Empty Empty<span class="token">)</span>

</code></pre>
<h2 class="calibre14"><a id="chp-3.html._1034" class="calibre7 pcalibre"></a>练习</h2>
<ol class="calibre17"><li class="calibre11">请给 List 类型写一个与 fromList 作用相反的函数：传入一个 Lista 类型的值，返回一个 [a]。</li><li class="calibre11">请仿造 Java 示例，定义一种只需要一个构造器的树类型。不要使用 Empty 构造器，而是用 Maybe 表示节点的子节点。</li></ol>
<h2 class="calibre14"><a id="chp-3.html._1039" class="calibre7 pcalibre"></a>报告错误</h2>
<p class="calibre9">当我们的代码中出现严重错误时可以调用 Haskell 提供的标准函数 error::String-&gt;a。我们将希望打印出来的错误信息作为一个字符串参数传入。而该函数的类型签名看上去有些特别：它是怎么做到仅从一个字符串类型的值就生成任意类型 a 的返回值的呢？</p>
<p class="calibre9">由于它的结果是返回类型 a，因此无论我们在哪里调用它都能得到正确类型的返回值。然而，它并不像普通函数那样返回一个值，而是立即中止求值过程，并将我们提供的错误信息打印出来。</p>
<p class="calibre9">mySecond 函数返回输入列表参数的第二个元素，假如输入列表长度不够则失败。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>MySecond<span class="token">.</span>hs
mySecond <span class="token">:</span><span class="token">:</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> a

mySecond xs <span class="token3">=</span> <span class="token1">if</span> <span class="token1">null</span> <span class="token">(</span>tail xs<span class="token">)</span>
              then error <span class="token4">"list too short"</span>
              <span class="token1">else</span> head <span class="token">(</span>tail xs<span class="token">)</span>

</code></pre>
<p class="calibre9">和之前一样，我们来看看这个函数在 <strong class="calibre12">ghci</strong> 中的使用效果如何。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> mySecond <span class="token4">"xi"</span>
<span class="token4">'i'</span>
ghci<span class="token3">&gt;</span> mySecond <span class="token">[</span><span class="token2">2</span><span class="token">]</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> list too short
ghci<span class="token3">&gt;</span> head <span class="token">(</span>mySecond <span class="token">[</span><span class="token">[</span><span class="token2">9</span><span class="token">]</span><span class="token">]</span><span class="token">)</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> list too short

</code></pre>
<p class="calibre9">注意上面的第三种情况，我们试图将调用 mySecond 的结果作为参数传入另一个函数。求值过程也同样中止了，并返回到 <strong class="calibre12">ghci</strong> 提示符。这就是使用 error 的最主要的问题：它并不允许调用者根据错误是可修复的还是严重到必须中止的来区别对待。</p>
<p class="calibre9">正如我们之前所看到的，模式匹配失败也会造成类似的不可修复错误。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> mySecond <span class="token">[</span><span class="token">]</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> Prelude<span class="token">.</span>tail<span class="token">:</span> empty list

</code></pre>
<h2 class="calibre14"><a id="chp-3.html._1079" class="calibre7 pcalibre"></a>让过程更可控的方法</h2>
<p class="calibre9">我们可以使用 Maybe 类型来表示有可能出现错误的情况。</p>
<p class="calibre9">如果我们想指出某个操作可能会失败，可以使用 Nothing 构造器。反之则使用 Just 构造器将值包裹起来。</p>
<p class="calibre9">让我们看看如果返回 Maybe 类型的值而不是调用 error，这样会给 mySecond 函数带来怎样的变化。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>MySecond<span class="token">.</span>hs
safeSecond <span class="token">:</span><span class="token">:</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Maybe a

safeSecond <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> Nothing
safeSecond xs <span class="token3">=</span> <span class="token1">if</span> <span class="token1">null</span> <span class="token">(</span>tail xs<span class="token">)</span>
                then Nothing
                <span class="token1">else</span> Just <span class="token">(</span>head <span class="token">(</span>tail xs<span class="token">)</span><span class="token">)</span>

</code></pre>
<p class="calibre9">当传入的列表太短时，我们将 Nothing 返回给调用者。然后由他们来决定接下来做什么，假如调用 error 的话则会强制程序崩溃。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> safeSecond <span class="token">[</span><span class="token">]</span>
Nothing
ghci<span class="token3">&gt;</span> safeSecond <span class="token">[</span><span class="token2">1</span><span class="token">]</span>
Nothing
ghci<span class="token3">&gt;</span> safeSecond <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">]</span>
Just <span class="token2">2</span>
ghci<span class="token3">&gt;</span> safeSecond <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">]</span>
Just <span class="token2">2</span>

</code></pre>
<p class="calibre9">复习一下前面的章节，我们还可以使用模式匹配继续增强这个函数的可读性。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>MySecond<span class="token">.</span>hs
tidySecond <span class="token">:</span><span class="token">:</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Maybe a

tidySecond <span class="token">(</span>_<span class="token">:</span>x<span class="token">:</span>_<span class="token">)</span> <span class="token3">=</span> Just x
tidySecond _       <span class="token3">=</span> Nothing

</code></pre>
<pre class="calibre15"><code class="tthhighlight-container">译注：<span class="token">(</span>_<span class="token">:</span>x<span class="token">:</span>_<span class="token">)</span> 相当于 <span class="token">(</span>_<span class="token">:</span><span class="token">(</span>x<span class="token">:</span>_<span class="token">)</span><span class="token">)</span>，考虑到列表的元素只能是同一种类型
     假想第一个 _ 是 a 类型，那么这个模式匹配的是 <span class="token">(</span>a<span class="token">:</span><span class="token">(</span>a<span class="token">:</span><span class="token">[</span>a<span class="token">,</span> a<span class="token">,</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span><span class="token">]</span><span class="token">)</span><span class="token">)</span> 或 <span class="token">(</span>a<span class="token">:</span><span class="token">(</span>a<span class="token">:</span><span class="token">[</span><span class="token">]</span><span class="token">)</span><span class="token">)</span>
     即元素是 a 类型的值的一个列表，并且至少有 <span class="token2">2</span> 个元素
     那么如果第一个 _ 匹配到了 <span class="token">[</span><span class="token">]</span>，有没有可能使最终匹配到得列表只有一个元素呢？
     <span class="token">(</span><span class="token">[</span><span class="token">]</span><span class="token">:</span><span class="token">(</span>x<span class="token">:</span>_<span class="token">)</span><span class="token">)</span> 说明 a 是列表类型，那么 x 也必须是列表类型，x 至少是 <span class="token">[</span><span class="token">]</span>
     而 <span class="token">(</span><span class="token">[</span><span class="token">]</span><span class="token">:</span><span class="token">(</span><span class="token">[</span><span class="token">]</span><span class="token">:</span><span class="token">[</span><span class="token">]</span><span class="token">)</span><span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span><span class="token">[</span><span class="token">]</span><span class="token">:</span><span class="token">[</span><span class="token">[</span><span class="token">]</span><span class="token">]</span><span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span><span class="token">[</span><span class="token">]</span><span class="token">,</span> <span class="token">[</span><span class="token">]</span><span class="token">]</span>，还是 <span class="token2">2</span> 个元素

</code></pre>
<p class="calibre9">第一个模式仅仅匹配那些至少有两个元素的列表（因为它有两个列表构造器），并将列表的第二个元素的值绑定给 变量 x。如果第一个模式匹配失败了，则匹配第二个模式。<br class="calibre1"><br>
引入局部变量 在函数体内部，我们可以在任何地方使用 let 表达式引入新的局部变量。请看下面这个简单的函数，它用来检查我们是否可以向顾客出借现金。我们需要确保剩余的保证金不少于 100 元的情况下，才能出借现金，并返回减去出借金额后的余额。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>Lending<span class="token">.</span>hs
lend amount balance <span class="token3">=</span> let reserve    <span class="token3">=</span> <span class="token2">100</span>
                          newBalance <span class="token3">=</span> balance <span class="token3">-</span> amount
                      <span class="token1">in</span> <span class="token1">if</span> balance <span class="token3">&lt;</span> reserve
                         then Nothing
                         <span class="token1">else</span> Just newBalance

</code></pre>
<p class="calibre9">这段代码中使用了 let 关键字标识一个变量声明区块的开始，用 in 关键字标识这个区块的结束。每行引入了一个局部变量。变量名在 = 的左侧，右侧则是该变量所绑定的表达式。</p>
<blockquote class="default"><p class="calibre9">Note</p></blockquote>
<blockquote class="default"><p class="calibre9">特别提示</p></blockquote>
<blockquote class="default"><p class="calibre9">请特别注意我们的用词：在 let 区块中，变量名被绑定到了一个表达式而不是一个<em class="calibre13">值</em>。由于 Haskell 是一门惰性求值的语言，变量名所对应的表达式一直到被用到时才会求值。在上面的例子里，如果没有满足保证金的要求，就不会计算 newBalance 的值。</p></blockquote>
<p class="calibre9">当我们在一个 let 区块中定义一个变量时，我们称之为*<code class="calibre16">let</code> 范围内*的变量。顾名思义即是：我们将这个变量限制在这个 let 区块内。</p>
<p class="calibre9">另外，上面这个例子中对空白和缩进的使用也值得特别注意。在下一节 “The offside rule and white space in an expression” 中我们会着重讲解其中的奥妙。</p>
<p class="calibre9">在 let 区块内定义的变量，既可以在定义区内使用，也可以在紧跟着 in 关键字的表达式中使用。</p>
<p class="calibre9">一般来说，我们将代码中可以使用一个变量名的地方称作这个变量名的<em class="calibre13">作用域（scope）</em>。如果我们能使用，则说明在* 作用域<em class="calibre13">内，反之则说明</em>在作用域外* 。如果一个变量名在整个源代码的任意处都可以使用，则说明它位于<em class="calibre13">最高层</em>的作用域。</p>
<h2 class="calibre14"><a id="chp-3.html._1160" class="calibre7 pcalibre"></a>屏蔽</h2>
<p class="calibre9">我们可以在表达式中使用嵌套的 let 区块。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>NestedLets<span class="token">.</span>hs
foo <span class="token3">=</span> let a <span class="token3">=</span> <span class="token2">1</span>
      <span class="token1">in</span> let b <span class="token3">=</span> <span class="token2">2</span>
         <span class="token1">in</span> a <span class="token3">+</span> b

</code></pre>
<p class="calibre9">上面的写法是完全合法的；但是在嵌套的 let 表达式里重复使用相同的变量名并不明智。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>NestedLets<span class="token">.</span>hs
bar <span class="token3">=</span> let x <span class="token3">=</span> <span class="token2">1</span>
      <span class="token1">in</span> <span class="token">(</span><span class="token">(</span>let x <span class="token3">=</span> <span class="token4">"foo"</span> <span class="token1">in</span> x<span class="token">)</span><span class="token">,</span> x<span class="token">)</span>

</code></pre>
<p class="calibre9">如上，内部的 x 隐藏了，或称作<em class="calibre13">屏蔽（shadowing）</em>, 外部的 x。它们的变量名一样，但后者拥有完全不同的类型和值。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> bar
<span class="token">(</span><span class="token4">"foo"</span><span class="token">,</span><span class="token2">1</span><span class="token">)</span>

</code></pre>
<p class="calibre9">我们同样也可以屏蔽一个函数的参数，并导致更加奇怪的结果。你认为下面这个函数的类型是什么？</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>NestedLets<span class="token">.</span>hs
quux a <span class="token3">=</span> let a <span class="token3">=</span> <span class="token4">"foo"</span>
         <span class="token1">in</span> a <span class="token3">++</span> <span class="token4">"eek!"</span>

</code></pre>
<p class="calibre9">在函数的内部，由于 let-绑定的变量名 a 屏蔽了函数的参数，使得参数 a 没有起到任何作用，因此该参数可以是任何类型的。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type quux
quux <span class="token">:</span><span class="token">:</span> t <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>Char<span class="token">]</span>

</code></pre>
<p class="calibre9">Tip</p>
<p class="calibre9">编译器警告是你的朋友</p>
<p class="calibre9">显然屏蔽会导致混乱和恶心的 bug，因此 GHC 设置了一个有用的选项 -fwarn-name-shadowing。如果你开启了这个功能，每当屏蔽某个变量名时，GHC 就会打印出一条警告。</p>
<h2 class="calibre14"><a id="chp-3.html.where__1212" class="calibre7 pcalibre"></a>where 从句</h2>
<p class="calibre9">还有另一种方法也可以用来引入局部变量：where 从句。where 从句中的定义在其<em class="calibre13">所跟随</em>的主句中有效。下面是和 lend 函数类似的一个例子，不同之处是使用了 where 而不是 let。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>Lending<span class="token">.</span>hs
lend2 amount balance <span class="token3">=</span> <span class="token1">if</span> amount <span class="token3">&lt;</span> reserve <span class="token3">*</span> <span class="token2">0.5</span>
                       then Just newBalance
                       <span class="token1">else</span> Nothing
    where reserve    <span class="token3">=</span> <span class="token2">100</span>
          newBalance <span class="token3">=</span> balance <span class="token3">-</span> amount

</code></pre>
<p class="calibre9">尽管刚开始使用 where 从句通常会有异样的感觉，但它对于提升可读性有着巨大的帮助。它使得读者的注意力首先能集中在表达式的一些重要的细节上，而之后再补上支持性的定义。经过一段时间以后，如果再用回那些没有 where 从句的语言，你就会怀念它的存在了。</p>
<p class="calibre9">与 let 表达式一样，where 从句中的空白和缩进也十分重要。 在下一节 “The offside rule and white space in an expression” 中我们会着重讲解其中的奥妙。</p>
<h2 class="calibre14"><a id="chp-3.html._1230" class="calibre7 pcalibre"></a>局部函数与全局变量</h2>
<p class="calibre9">你可能已经注意到了，在 Haskell 的语法里，定义变量和定义函数的方式非常相似。这种相似性也存在于 let 和 where 区块里：定义局部<em class="calibre13">函数</em>就像定义局部<em class="calibre13">变量</em>那样简单。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>LocalFunction<span class="token">.</span>hs
pluralise <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>Int<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>String<span class="token">]</span>
pluralise word counts <span class="token3">=</span> map plural counts
    where plural <span class="token2">0</span> <span class="token3">=</span> <span class="token4">"no "</span> <span class="token3">++</span> word <span class="token3">++</span> <span class="token4">"s"</span>
          plural <span class="token2">1</span> <span class="token3">=</span> <span class="token4">"one "</span> <span class="token3">++</span> word
          plural n <span class="token3">=</span> show n <span class="token3">++</span> <span class="token4">" "</span> <span class="token3">++</span> word <span class="token3">++</span> <span class="token4">"s"</span>

</code></pre>
<p class="calibre9">我们定义了一个由多个等式构成的局部函数 plural。局部函数可以自由地使用其被封装在内的作用域内的任意变量：在本例中，我们使用了在外部函数 pluralise 中定义的变量 word。在 pluralise 的定义里，map 函数（我们将在下一章里再来讲解它的用法）将局部函数 plural 逐一应用于 counts 列表的每个元素。</p>
<p class="calibre9">我们也可以在代码的一开始就定义变量，语法和定义函数是一样的。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch03<span class="token3">/</span>GlobalVariable<span class="token">.</span>hs
itemName <span class="token3">=</span> <span class="token4">"Weighted Companion Cube"</span>

</code></pre>
<h2 class="calibre14"><a id="chp-3.html.The_Offside_Rule_and_Whitespace_in_an_Expression_1254" class="calibre7 pcalibre"></a>The Offside Rule and Whitespace in an Expression</h2>
<h2 class="calibre8"><a id="chp-3.html.The_Case_Expression_1256" class="calibre7 pcalibre"></a>The Case Expression</h2>
<h2 class="calibre8"><a id="chp-3.html.Common_Beginner_Mistakes_with_Patterns_1258" class="calibre7 pcalibre"></a>Common Beginner Mistakes with Patterns</h2>
<h2 class="calibre8"><a id="chp-3.html.Conditional_Evaluation_with_Guards_1260" class="calibre7 pcalibre"></a>Conditional Evaluation with Guards</h2>
<h2 class="calibre20"><a id="chp-3.html.Exercises_1262" class="calibre7 pcalibre"></a>Exercises</h2>
</div></div></div></div></div></div>
<div id="chp-4.html"><div class="calibre">
<div id="chp-4.html.main" class="calibre1"><div class="root"><div class="article"><h1 class="article-head" id="chp-4.html.calibre_toc_4">第四章：函数式编程</h1><div class="article-body"><h1 class="calibre6"><a id="chp-4.html._0" class="calibre7 pcalibre"></a>第四章：函数式编程</h1>
<h2 class="calibre8"><a id="chp-4.html._Haskell__2" class="calibre7 pcalibre"></a>使用 Haskell 思考</h2>
<p class="calibre9">初学 Haskell 的人需要迈过两个难关：</p>
<p class="calibre9">首先，我们需要将自己的编程观念从命令式语言转换到函数式语言上面来。这样做的原因并不是因为命令式语言不好，而是因为比起命令式语言，函数式语言更胜一筹。</p>
<p class="calibre9">其次，我们需要熟悉 Haskell 的标准库。和其他语言一样，函数库可以像杠杆那样，极大地提升我们解决问题的能力。因为 Haskell 是一门层次非常高的语言，而 Haskell 的标准库也趋向于处理高层次的抽象，因此对 Haskell 标准库的学习也稍微更难一些，但这些努力最终都会物有所值。</p>
<p class="calibre9">这一章会介绍一些常用的函数式编程技术，以及一些 Haskell 特性。还会在命令式语言和函数式语言之间进行对比，帮助读者了解它们之间的区别，并且在这个过程中，陆续介绍一些基本的 Haskell 标准库。</p>
<h2 class="calibre14"><a id="chp-4.html._12" class="calibre7 pcalibre"></a>一个简单的命令行程序</h2>
<p class="calibre9">在本章的大部分时间里，我们都只和无副作用的代码打交道。为了将注意力集中在实际的代码上，我们需要开发一个接口程序，连接起带副作用的代码和无副作用的代码。</p>
<p class="calibre9">这个接口程序读入一个文件，将函数应用到文件，并且将结果写到另一个文件：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>InteractWith<span class="token">.</span>hs

import System<span class="token">.</span>Environment <span class="token">(</span>getArgs<span class="token">)</span>

interactWith <span class="token1">function</span> inputFile outputFile <span class="token3">=</span> <span class="token1">do</span>
  input <span class="token3">&lt;</span><span class="token3">-</span> readFile inputFile
  writeFile outputFile <span class="token">(</span><span class="token1">function</span> input<span class="token">)</span>

main <span class="token3">=</span> mainWith myFunction
  where mainWith <span class="token1">function</span> <span class="token3">=</span> <span class="token1">do</span>
          args <span class="token3">&lt;</span><span class="token3">-</span> getArgs
          case args of
            <span class="token">[</span>input<span class="token">,</span>output<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> interactWith <span class="token1">function</span> input output
            _ <span class="token3">-</span><span class="token3">&gt;</span> putStrLn <span class="token4">"error: exactly two arguments needed"</span>

        <span class="token3">--</span> replace <span class="token4">"id"</span> with the name of our <span class="token1">function</span> below
        myFunction <span class="token3">=</span> id

</code></pre>
<p class="calibre9">这是一个简单但完整的文件处理程序。其中 do 关键字引入一个块，标识那些带有副作用的代码，比如对文件进行读和写操作。被 do 包围的 &lt;- 操作符效果等同于赋值。第七章还会介绍更多 I/O 方面的函数。</p>
<p class="calibre9">当我们需要测试其他函数的时候，我们就将程序中的 id 换成其他函数的名字。另外，这些被测试的函数的类型包含 String-&gt;String ，也即是，这些函数应该都接受并返回字符串值。</p>
<p class="calibre9">[译注： id 函数接受一个值，并原封不动地返回这个值，比如 id"hello" 返回值 "hello" ，而 id10 返回值 10 。]</p>
<p class="calibre9">[译注：这一段最后一句的原文是“ ... need to have the type String-&gt;String ... ” ，因为 Haskell 是一种带有类型多态的语言，所以将“ have the type ” 翻译成 “ 包含 xx 类型 ”，而不是 “ 必须是 xx 类型 ”。</p>
<p class="calibre9">接下来编译这个程序：</p>
<pre class="calibre15"><code class="tthhighlight-container">$ ghc <span class="token3">--</span>make InteractWith
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> InteractWith<span class="token">.</span>hs<span class="token">,</span> InteractWith<span class="token">.</span>o <span class="token">)</span>
Linking InteractWith <span class="token">.</span><span class="token">.</span><span class="token">.</span>

</code></pre>
<p class="calibre9">通过命令行运行这个程序。它接受两个文件名作为参数输入，一个用于读取，一个用于写入：</p>
<pre class="calibre15"><code class="tthhighlight-container">$ echo <span class="token4">"hello world"</span> <span class="token3">&gt;</span> hello<span class="token3">-</span><span class="token1">in</span><span class="token">.</span>txt

$ <span class="token">.</span><span class="token3">/</span>InteractWith hello<span class="token3">-</span><span class="token1">in</span><span class="token">.</span>txt hello<span class="token3">-</span>out<span class="token">.</span>txt

$ cat hello<span class="token3">-</span><span class="token1">in</span><span class="token">.</span>txt
hello world

$ cat hello<span class="token3">-</span>out<span class="token">.</span>txt
hello world

</code></pre>
<p class="calibre9">[译注：原书这里的执行过程少了写入内容到 hello-in.txt 的一步，导致执行会出错，所以这里加上 echo... 这一步。另外原书执行的是 Interact 过程，也是错误的，正确的执行文件名应该是 InteractWith 。]</p>
<h2 class="calibre14"><a id="chp-4.html._73" class="calibre7 pcalibre"></a>循环的表示</h2>
<p class="calibre9">和传统编程语言不同， Haskell 既没有 for 循环，也没有 while 循环。那么，如果有一大堆数据要处理，该用什么代替这些循环呢？这一节就会给出这个问题的几种可能的解决办法。</p>
<h2 class="calibre14"><a id="chp-4.html._77" class="calibre7 pcalibre"></a>显式递归</h2>
<p class="calibre9">通过例子进行比对，可以很直观地认识有 loop 语言和没 loop 语言之间的区别。以下是一个 C 函数，它将字符串表示的数字转换成整数：</p>
<pre class="calibre15"><code class="tthhighlight-container">int <span class="token5">as_int</span><span class="token">(</span>char <span class="token3">*</span>str<span class="token">)</span>
<span class="token">{</span>
    int acc<span class="token">;</span> <span class="token6">// accumulate the partial result</span>
    <span class="token1">for</span> <span class="token">(</span>acc <span class="token3">=</span> <span class="token2">0</span><span class="token">;</span> <span class="token5">isdigit</span><span class="token">(</span><span class="token3">*</span>str<span class="token">)</span><span class="token">;</span> str<span class="token3">++</span><span class="token">)</span><span class="token">{</span>
        acc <span class="token3">=</span> acc <span class="token3">*</span> <span class="token2">10</span> <span class="token3">+</span> <span class="token">(</span><span class="token3">*</span>str <span class="token3">-</span><span class="token4">'0'</span><span class="token">)</span><span class="token">;</span>
    <span class="token">}</span>

<span class="token1">return</span> acc<span class="token">;</span>
<span class="token">}</span>

</code></pre>
<p class="calibre9">既然 Haskell 没有 loop 的话，以上这段 C 语言代码，在 Haskell 里该怎么表达呢？</p>
<p class="calibre9">让我们先从类型签名开始写起，这不是必须的，但它对于弄清楚代码在干什么很有帮助：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>IntParse<span class="token">.</span>hs
import Data<span class="token">.</span>Char <span class="token">(</span>digitToInt<span class="token">)</span> <span class="token3">--</span> we'll need ord shortly

asInt <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> Int

</code></pre>
<p class="calibre9">C 代码在遍历字符串的过程中，渐增地计算结果。Haskell 代码同样可以做到这一点，而且，在 Haskell 里，使用函数已经足以表示 loop 计算了。[译注：在命令式语言里，很多迭代计算都是通过特殊关键字来实现的，比如 do 、 while 和 for 。]</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>IntParse<span class="token">.</span>hs
loop <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> Int

asInt xs <span class="token3">=</span> loop <span class="token2">0</span> xs

</code></pre>
<p class="calibre9">loop 的第一个参数是累积器的变量，给它赋值 0 等同于 C 语言在 for 循环开始前的初始化操作。</p>
<p class="calibre9">在研究详细的代码前，先来思考一下我们要处理的数据：输入 xs 是一个包含数字的字符串，而 String 类型不过是 [Char] 的别名，一个包含字符的列表。因此，要遍历处理字符串，最好的方法是将它看作是列表来处理：它要么就是一个空字符串；要么就是一个字符，后面跟着列表的其余部分。</p>
<p class="calibre9">以上的想法可以通过对列表的构造器进行模式匹配来表达。先从最简单的情况 —— 输入为空字符串开始：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>IntParse<span class="token">.</span>hs
loop acc <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> acc

</code></pre>
<p class="calibre9">一个空列表并不仅仅意味着“输入列表为空”，另一种可能的情况是，对一个非空字符串进行遍历之后，最终到达了列表的末尾。因此，对于空列表，我们不是抛出错误，而是将累积值返回。</p>
<p class="calibre9">另一个等式处理列表不为空的情况：先取出并处理列表的当前元素，接着处理列表的其他元素。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>IntParse<span class="token">.</span>hs
loop acc <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span> let acc' <span class="token3">=</span> acc <span class="token3">*</span> <span class="token2">10</span> <span class="token3">+</span> digitToInt x
                  <span class="token1">in</span> loop acc' xs

</code></pre>
<p class="calibre9">程序先计算出当前字符所代表的数值，将它赋值给局部变量 acc' 。然后使用 acc' 和剩余列表的元素 xs 作为参数，再次调用 loop 函数。这种调用等同于在 C 代码中再次执行一次循环。</p>
<p class="calibre9">每次递归调用 loop ，累积器的值都会被更新，并处理掉列表里的一个元素。这样一直下去，最终输入列表为空，递归调用结束。</p>
<p class="calibre9">以下是 IntParse 函数的完整定义：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>IntParse<span class="token">.</span>hs

<span class="token3">--</span> 只载入 Data<span class="token">.</span>Char 中的 digitToInt 函数
import Data<span class="token">.</span>Char <span class="token">(</span>digitToInt<span class="token">)</span>

asInt xs <span class="token3">=</span> loop <span class="token2">0</span> xs

loop <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> Int
loop acc <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> acc
loop acc <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span> let acc' <span class="token3">=</span> acc <span class="token3">*</span> <span class="token2">10</span> <span class="token3">+</span> digitToInt x
                  <span class="token1">in</span> loop acc' xs

</code></pre>
<p class="calibre9">[译注：书本原来的代码少了对 Data.Char 的引用，会造成 digitToInt 查找失败。]</p>
<p class="calibre9">在 ghci 里看看程序的表现如何：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load IntParse<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> IntParse<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> asInt <span class="token4">"33"</span>
<span class="token2">33</span>

</code></pre>
<p class="calibre9">在处理字符串表示的字符时，它运行得很好。不过，如果传给它一些不合法的输入，这个可怜的函数就没办法处理了：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> asInt <span class="token4">""</span>
<span class="token2">0</span>
<span class="token3">*</span>Main<span class="token3">&gt;</span> asInt <span class="token4">"potato"</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> Char<span class="token">.</span>digitToInt<span class="token">:</span> not a digit <span class="token4">'p'</span>

</code></pre>
<p class="calibre9">在练习一，我们会想办法解决这个问题。</p>
<p class="calibre9">loop 函数是尾递归函数的一个例子：如果输入非空，这个函数做的最后一件事，就是递归地调用自身。这个代码还展示了另一个惯用法：通过研究列表的结构，分别处理空列表和非空列表两种状况，这种方法称之为<em class="calibre13">结构递归</em>（structural recursion）。</p>
<p class="calibre9">非递归情形（列表为空）被称为“基本情形”（有时也叫终止情形）。当对函数进行递归调用时，计算最终会回到基本情形上。在数学上，这也称为“归纳情形”。</p>
<p class="calibre9">作为一项有用的技术，结构递归并不仅仅局限于列表，它也适用于其他代数数据类型，稍后就会介绍更多这方面的例子。</p>
<h2 class="calibre14"><a id="chp-4.html._192" class="calibre7 pcalibre"></a>对列表元素进行转换</h2>
<p class="calibre9">考虑以下 C 函数， square ，它对数组中的所有元素执行平方计算：</p>
<pre class="calibre15"><code class="tthhighlight-container">void <span class="token5">square</span><span class="token">(</span>double <span class="token3">*</span>out<span class="token">,</span> const double <span class="token3">*</span><span class="token1">in</span><span class="token">,</span> size_t length<span class="token">)</span>
<span class="token">{</span>
    <span class="token1">for</span> <span class="token">(</span>size_t i <span class="token3">=</span> <span class="token2">0</span><span class="token">;</span> i <span class="token3">&lt;</span> length<span class="token">;</span> i<span class="token3">++</span><span class="token">)</span> <span class="token">{</span>
        out<span class="token">[</span>i<span class="token">]</span> <span class="token3">=</span> <span class="token1">in</span><span class="token">[</span>i<span class="token">]</span> <span class="token3">*</span> <span class="token1">in</span><span class="token">[</span>i<span class="token">]</span><span class="token">;</span>
    <span class="token">}</span>
<span class="token">}</span>

</code></pre>
<p class="calibre9">这段代码展示了一个直观且常见的 loop 动作，它对输入数组中的所有元素执行同样的动作。以下是 Haskell 版本的 square 函数：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>square<span class="token">.</span>hs

square <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Double<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>Double<span class="token">]</span>

square <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span> x<span class="token3">*</span>x <span class="token">:</span> square xs
square <span class="token">[</span><span class="token">]</span>     <span class="token3">=</span> <span class="token">[</span><span class="token">]</span>

</code></pre>
<p class="calibre9">square 函数包含两个模式匹配等式。第一个模式解构一个列表，取出它的 head 部分和 tail 部分，并对第一个元素进行加倍操作，然后将计算所得的新元素放进列表里面。一直这样做下去，直到处理完整个列表为止。第二个等式确保计算会在列表为空时顺利终止。</p>
<p class="calibre9">square 产生一个和输入列表一样长的新列表，其中每个新元素的值都是原本元素的平方：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load square<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> square<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> let one_to_ten <span class="token3">=</span> <span class="token">[</span><span class="token2">1.0</span> <span class="token">.</span><span class="token">.</span> <span class="token2">10.0</span><span class="token">]</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> square one_to_ten
<span class="token">[</span><span class="token2">1.0</span><span class="token">,</span><span class="token2">4.0</span><span class="token">,</span><span class="token2">9.0</span><span class="token">,</span><span class="token2">16.0</span><span class="token">,</span><span class="token2">25.0</span><span class="token">,</span><span class="token2">36.0</span><span class="token">,</span><span class="token2">49.0</span><span class="token">,</span><span class="token2">64.0</span><span class="token">,</span><span class="token2">81.0</span><span class="token">,</span><span class="token2">100.0</span><span class="token">]</span>

</code></pre>
<p class="calibre9">以下是另一个 C 循环，它将字符串中的所有字母都设置为大写：</p>
<pre class="calibre15"><code class="tthhighlight-container">#include <span class="token3">&lt;</span>ctype<span class="token">.</span>h<span class="token3">&gt;</span>

char <span class="token3">*</span><span class="token5">uppercase</span><span class="token">(</span>const char <span class="token3">*</span><span class="token1">in</span><span class="token">)</span>
<span class="token">{</span>
    char <span class="token3">*</span>out <span class="token3">=</span> <span class="token5">strdup</span><span class="token">(</span><span class="token1">in</span><span class="token">)</span><span class="token">;</span>

    <span class="token1">if</span> <span class="token">(</span>out <span class="token3">!=</span> NULL<span class="token">)</span> <span class="token">{</span>
        <span class="token1">for</span> <span class="token">(</span>size_t i <span class="token3">=</span> <span class="token2">0</span><span class="token">;</span> out<span class="token">[</span>i<span class="token">]</span> <span class="token3">!=</span> <span class="token4">'\0'</span><span class="token">;</span> i<span class="token3">++</span><span class="token">)</span> <span class="token">{</span>
            out<span class="token">[</span>i<span class="token">]</span> <span class="token3">=</span> <span class="token5">toupper</span><span class="token">(</span>out<span class="token">[</span>i<span class="token">]</span><span class="token">)</span><span class="token">;</span>
        <span class="token">}</span>
    <span class="token">}</span>

    <span class="token1">return</span> out<span class="token">;</span>
<span class="token">}</span>

</code></pre>
<p class="calibre9">以下是相等的 Haskell 版本：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>upperCase<span class="token">.</span>hs

import Data<span class="token">.</span>Char <span class="token">(</span>toUpper<span class="token">)</span>

upperCase <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> String

upperCase <span class="token">(</span>x<span class="token">:</span> xs<span class="token">)</span> <span class="token3">=</span> toUpper x <span class="token">:</span> upperCase xs
upperCase <span class="token">[</span><span class="token">]</span>      <span class="token3">=</span> <span class="token">[</span><span class="token">]</span>

</code></pre>
<p class="calibre9">代码从 Data.Char 模块引入了 toUpper 函数，如果输入字符是一个字母的话，那么函数就将它转换成大写：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>module <span class="token3">+</span>Data<span class="token">.</span>Char

Prelude Data<span class="token">.</span>Char<span class="token3">&gt;</span> toUpper <span class="token4">'a'</span>
<span class="token4">'A'</span>

Prelude Data<span class="token">.</span>Char<span class="token3">&gt;</span> toUpper <span class="token4">'A'</span>
<span class="token4">'A'</span>

Prelude Data<span class="token">.</span>Char<span class="token3">&gt;</span> toUpper <span class="token4">'1'</span>
<span class="token4">'1'</span>

Prelude Data<span class="token">.</span>Char<span class="token3">&gt;</span> toUpper <span class="token4">'*'</span>
<span class="token4">'*'</span>

</code></pre>
<p class="calibre9">upperCase 函数和之前的 square 函数很相似：如果输入是一个空列表，那么它就停止计算，返回一个空列表。另一方面，如果输入不为空，那么它就对列表的第一个元素调用 toUpper 函数，并且递归调用自身，继续处理剩余的列表元素：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load upperCase<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> upperCase<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> upperCase <span class="token4">"The quick brown fox jumps over the lazy dog"</span>
<span class="token4">"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG"</span>

</code></pre>
<p class="calibre9">以上两个函数遵循了同一种处理列表的公共模式：基本情形处理（base case）空列表输入。而<em class="calibre13">递归情形</em>（recursive case）则处理列表非空时的情况，它对列表的头元素进行某种操作，然后递归地处理列表余下的其他元素。</p>
<h2 class="calibre14"><a id="chp-4.html._299" class="calibre7 pcalibre"></a>列表映射</h2>
<p class="calibre9">前面定义的 square 和 upperCase 函数，都生成一个和输入列表同等长度的新列表，并且每次只对列表的一个元素进行处理。因为这种用法非常常见，所以 Haskell 的 Prelude 库定义了 map 函数来更方便地执行这种操作。 map 函数接受一个函数和一个列表作为参数，将输入函数应用到输入列表的每个元素上，并构建出一个新的列表。</p>
<p class="calibre9">以下是使用 map 重写的 square 和 upperCase 函数：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>rewrite_by_map<span class="token">.</span>hs

import Data<span class="token">.</span>Char <span class="token">(</span>toUpper<span class="token">)</span>

square2 xs <span class="token3">=</span> map squareOne xs
    where squareOne x <span class="token3">=</span> x <span class="token3">*</span> x

upperCase2 xs <span class="token3">=</span> map toUpper xs

</code></pre>
<p class="calibre9">[译注：原文代码没有载入 Data.Char 中的 toUpper 函数。]</p>
<p class="calibre9">来研究一下 map 是如何实现的。通过查看它的类型签名，可以发现很多有意思的信息：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>type map
map <span class="token">:</span><span class="token">:</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>b<span class="token">]</span>

</code></pre>
<p class="calibre9">类型签名显示， map 接受两个参数：第一个参数是一个函数，这个函数接受一个 a 类型的值，并返回一个 b 类型的值[译注：这里只是说 a 和 b 类型可能不一样，但不是必须的。]。</p>
<p class="calibre9">像 map 这种接受一个函数作为参数、又或者返回一个函数作为结果的函数，被称为<em class="calibre13">高阶</em>函数。</p>
<p class="calibre9">因为 map 的抽象出现在 square 和 upperCase 函数，所以可以通过观察这两个函数，找出它们之间的共同点，然后实现自己的 map 函数：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>myMap<span class="token">.</span>hs

myMap <span class="token">:</span><span class="token">:</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>b<span class="token">]</span>

myMap f <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span> f x <span class="token">:</span> myMap f xs
myMap _ <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> <span class="token">[</span><span class="token">]</span>

</code></pre>
<p class="calibre9">[译注：在原文的代码里，第二个等式的定义为 myMap__=[] ，这并不是完全正确的，因为它可以适配于第二个参数不为列表的情况，比如 myMapf1 。因此，这里遵循标准库里 map 的定义，将第二个等式修改为 myMap_[]=[] 。]</p>
<p class="calibre9">在 ghci 测试这个 myMap 函数：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load myMap<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> myMap<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>module <span class="token3">+</span>Data<span class="token">.</span>Char

<span class="token3">*</span>Main Data<span class="token">.</span>Char<span class="token3">&gt;</span> myMap toUpper <span class="token4">"The quick brown fox"</span>
<span class="token4">"THE QUICK BROWN FOX"</span>

</code></pre>
<p class="calibre9">通过观察代码，并从中提炼出重复的抽象，是复用代码的一种良好方法。尽管对代码进行抽象并不是 Haskell 的“专利”，但高阶函数使得这种抽象变得非常容易。<br class="calibre1"><br>
筛选列表元素 另一种对列表的常见操作是，对列表元素进行筛选，只保留那些符合条件的元素。 以下函数接受一个列表作为参数，并返回这个列表里的所有奇数元素。代码的递归情形比之前的 map 函数要复杂一些，它使用守卫对元素进行条件判断，只有符合条件的元素，才会被加入进结果列表里：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>oddList<span class="token">.</span>hs

oddList <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Int<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>Int<span class="token">]</span>

oddList <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token3">|</span> odd x     <span class="token3">=</span> x <span class="token">:</span> oddList xs
               <span class="token3">|</span> otherwise <span class="token3">=</span> oddList xs
oddList <span class="token">[</span><span class="token">]</span>                 <span class="token3">=</span> <span class="token">[</span><span class="token">]</span>

</code></pre>
<p class="calibre9">[译注：这里将原文代码的 oddList_=[] 改为 oddList[]=[] ，原因和上一小节修改 map 函数的代码一样。]</p>
<p class="calibre9">测试：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load oddList<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> oddList<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> oddList <span class="token">[</span><span class="token2">1</span> <span class="token">.</span><span class="token">.</span> <span class="token2">10</span><span class="token">]</span>
<span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">3</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">7</span><span class="token">,</span><span class="token2">9</span><span class="token">]</span>

</code></pre>
<p class="calibre9">因为这种过滤模式也很常见，所以 Prelude 也定义了相应的函数 filter ：它接受一个谓词函数，并将它应用到列表里的每个元素，只有那些谓词函数求值返回 True 的元素才会被保留：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>type odd
odd <span class="token">:</span><span class="token">:</span> Integral a <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> Bool

Prelude<span class="token3">&gt;</span> odd <span class="token2">1</span>
True

Prelude<span class="token3">&gt;</span> odd <span class="token2">2</span>
False

Prelude<span class="token3">&gt;</span> <span class="token">:</span>type filter
filter <span class="token">:</span><span class="token">:</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> Bool<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span>

Prelude<span class="token3">&gt;</span> filter odd <span class="token">[</span><span class="token2">1</span> <span class="token">.</span><span class="token">.</span> <span class="token2">10</span><span class="token">]</span>
<span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">3</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">7</span><span class="token">,</span><span class="token2">9</span><span class="token">]</span>

</code></pre>
<p class="calibre9">[译注：谓词函数是指那种返回 Bool 类型值的函数。]</p>
<p class="calibre9">稍后的章节会介绍如何定义 filter 。</p>
<h2 class="calibre14"><a id="chp-4.html._409" class="calibre7 pcalibre"></a>处理收集器并得出结果</h2>
<p class="calibre9">将一个收集器（collection）简化（reduce）为一个值也是收集器的常见操作之一。</p>
<p class="calibre9">对列表的所有元素求和，就是其中的一个例子：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>mySum<span class="token">.</span>hs

mySum xs <span class="token3">=</span> helper <span class="token2">0</span> xs
    where helper acc <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span> helper <span class="token">(</span>acc <span class="token3">+</span> x<span class="token">)</span> xs
          helper acc <span class="token">[</span><span class="token">]</span>     <span class="token3">=</span> acc

</code></pre>
<p class="calibre9">helper 函数通过尾递归进行计算。 acc 是累积器参数，它记录了当前列表元素的总和。正如我们在 asInt 函数看到的那样，这种递归计算是纯函数语言里表示 loop 最自然的方式。</p>
<p class="calibre9">以下是一个稍微复杂一些的例子，它是一个 Adler-32 校验和的 JAVA 实现。Adler-32 是一个流行的校验和算法，它将两个 16 位校验和串联成一个 32 位校验和。第一个校验和是所有输入比特之和，加上一。而第二个校验和则是第一个校验和所有中间值之和。每次计算时，校验和都需要取模 65521 。（如果你不懂 JAVA ，直接跳过也没关系）：</p>
<pre class="calibre15"><code class="tthhighlight-container">public class <span class="token5">Adler32</span>
<span class="token">{</span>
    private static final int base <span class="token3">=</span> <span class="token2">65521</span><span class="token">;</span>

    public static int <span class="token5">compute</span><span class="token">(</span>byte<span class="token">[</span><span class="token">]</span> data<span class="token">,</span> int offset<span class="token">,</span> int length<span class="token">)</span>
    <span class="token">{</span>
        int a <span class="token3">=</span> <span class="token2">1</span><span class="token">,</span> b <span class="token3">=</span> <span class="token2">0</span><span class="token">;</span>

        <span class="token1">for</span> <span class="token">(</span>int i <span class="token3">=</span> offset<span class="token">;</span> i <span class="token3">&lt;</span> offset <span class="token3">+</span> length<span class="token">;</span> i<span class="token3">++</span><span class="token">)</span> <span class="token">{</span>
            a <span class="token3">=</span> <span class="token">(</span>a <span class="token3">+</span> <span class="token">(</span>data<span class="token">[</span>i<span class="token">]</span> <span class="token3">&amp;</span> oxff<span class="token">)</span><span class="token">)</span> <span class="token3">%</span> base
            b <span class="token3">=</span> <span class="token">(</span>a <span class="token3">+</span> b<span class="token">)</span> <span class="token3">%</span> base<span class="token">;</span>
        <span class="token">}</span>

        <span class="token1">return</span> <span class="token">(</span>b <span class="token3">&lt;</span><span class="token3">&lt;</span> <span class="token2">16</span><span class="token">)</span> <span class="token3">|</span> a<span class="token">;</span>
    <span class="token">}</span>
<span class="token">}</span>

</code></pre>
<p class="calibre9">尽管 Adler-32 是一个简单的校验和算法，但这个 JAVA 实现还是非常复杂，很难看清楚位操作之间的关系。</p>
<p class="calibre9">以下是 Adler-32 算法的 Haskell 实现：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>Adler32<span class="token">.</span>hs

import Data<span class="token">.</span>Char <span class="token">(</span>ord<span class="token">)</span>
import Data<span class="token">.</span>Bits <span class="token">(</span>shiftL<span class="token">,</span> <span class="token">(</span><span class="token">.</span><span class="token3">&amp;</span><span class="token">.</span><span class="token">)</span><span class="token">,</span> <span class="token">(</span><span class="token">.</span><span class="token3">|</span><span class="token">.</span><span class="token">)</span><span class="token">)</span>

base <span class="token3">=</span> <span class="token2">65521</span>

adler32 xs <span class="token3">=</span> helper <span class="token2">1</span> <span class="token2">0</span> xs
    where helper a b <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span> let a' <span class="token3">=</span> <span class="token">(</span>a <span class="token3">+</span> <span class="token">(</span>ord x <span class="token">.</span><span class="token3">&amp;</span><span class="token">.</span> <span class="token2">0xff</span><span class="token">)</span><span class="token">)</span> `mod` base
                                  b<span class="token4">' = (a'</span> <span class="token3">+</span> b<span class="token">)</span> `mod` base
                              <span class="token1">in</span> helper a<span class="token4">' b'</span> xs
          helper a b <span class="token">[</span><span class="token">]</span>     <span class="token3">=</span> <span class="token">(</span>b `shiftL` <span class="token2">16</span><span class="token">)</span> <span class="token">.</span><span class="token3">|</span><span class="token">.</span> a

</code></pre>
<p class="calibre9">在这段代码里， shiftL 函数实现逻辑左移， (.&amp;.) 实现二进制位的并操作， (.|.) 实现二进制位的或操作， ord 函数则返回给定字符对应的编码值。</p>
<p class="calibre9">helper 函数通过尾递归来进行计算，每次对它的调用，都产生新的累积变量，效果等同于 JAVA 在 for 循环里对变量的赋值更新。当列表处理完毕，递归终止时，程序计算出校验和并将它返回。</p>
<p class="calibre9">和前面抽取出 map 和 filter 函数类似，从 Adler32 函数里面，我们也可以抽取出一种通用的抽象，称之为折叠（fold）：它对一个列表中的所有元素做某种处理，并且一边处理元素，一边更新累积器，最后在处理完整个列表之后，返回累积器的值。</p>
<p class="calibre9">有两种不同类型的折叠，其中 foldl 从左边开始进行折叠，而 foldr 从右边开始进行折叠。</p>
<h2 class="calibre14"><a id="chp-4.html._476" class="calibre7 pcalibre"></a>左折叠</h2>
<p class="calibre9">以下是 foldl 函数的定义：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>foldl<span class="token">.</span>hs

foldl <span class="token">:</span><span class="token">:</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> b <span class="token3">-</span><span class="token3">&gt;</span> a<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>b<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> a

foldl step zero <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span> foldl step <span class="token">(</span>step zero x<span class="token">)</span> xs
foldl _ zero <span class="token">[</span><span class="token">]</span>        <span class="token3">=</span> zero

</code></pre>
<p class="calibre9">[译注：这个函数在载入 ghci 时会因为命名冲突而被拒绝，编写函数直接使用内置的 foldl 就可以了。]</p>
<p class="calibre9">foldl 函数接受一个步骤（step）函数，一个累积器的初始化值，以及一个列表作为参数。步骤函数每次使用累积器和列表中的一个元素作为参数，并计算出新的累积器值，这个过程称为步进（stepper）。然后，将新的累积器作为参数，再次进行同样的计算，直到整个列表处理完为止。</p>
<p class="calibre9">以下是使用 foldl 重写的 mySum 函数：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>foldlSum<span class="token">.</span>hs
foldlSum xs <span class="token3">=</span> foldl step <span class="token2">0</span> xs
    where step acc x <span class="token3">=</span> acc <span class="token3">+</span> x

</code></pre>
<p class="calibre9">因为代码里的 step 函数执行的操作不过是相加起它的两个输入参数，因此，可以直接将一个加法函数代替 step 函数，并移除多余的 where 语句：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>niceSum<span class="token">.</span>hs
niceSum <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Integer<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Integer
niceSum xs <span class="token3">=</span> foldl <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token2">0</span> xs

</code></pre>
<p class="calibre9">为了进一步看清楚 foldl 的执行模式，以下代码展示了 niceSum[1,2,3] 执行时的计算过程：</p>
<pre class="calibre15"><code class="tthhighlight-container">niceSum <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">,</span> <span class="token2">3</span><span class="token">]</span>
    <span class="token3">==</span> foldl <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token2">0</span>                   <span class="token">(</span><span class="token2">1</span><span class="token">:</span><span class="token2">2</span><span class="token">:</span><span class="token2">3</span><span class="token">:</span><span class="token">[</span><span class="token">]</span><span class="token">)</span>
    <span class="token3">==</span> foldl <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token">(</span><span class="token2">0</span> <span class="token3">+</span> <span class="token2">1</span><span class="token">)</span>             <span class="token">(</span><span class="token2">2</span><span class="token">:</span><span class="token2">3</span><span class="token">:</span><span class="token">[</span><span class="token">]</span><span class="token">)</span>
    <span class="token3">==</span> foldl <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token">(</span><span class="token">(</span><span class="token2">0</span> <span class="token3">+</span> <span class="token2">1</span><span class="token">)</span> <span class="token3">+</span> <span class="token2">2</span><span class="token">)</span>       <span class="token">(</span><span class="token2">3</span><span class="token">:</span><span class="token">[</span><span class="token">]</span><span class="token">)</span>
    <span class="token3">==</span> foldl <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token">(</span><span class="token">(</span><span class="token">(</span><span class="token2">0</span> <span class="token3">+</span> <span class="token2">1</span><span class="token">)</span> <span class="token3">+</span> <span class="token2">2</span><span class="token">)</span> <span class="token3">+</span> <span class="token2">3</span><span class="token">)</span> <span class="token">[</span><span class="token">]</span>
    <span class="token3">==</span> <span class="token">(</span><span class="token">(</span><span class="token">(</span><span class="token2">0</span> <span class="token3">+</span> <span class="token2">1</span><span class="token">)</span> <span class="token3">+</span> <span class="token2">2</span><span class="token">)</span> <span class="token3">+</span> <span class="token2">3</span><span class="token">)</span>

</code></pre>
<p class="calibre9">注意对比新的 mySum 定义比刚开始的定义节省了多少代码：新版本没有使用显式递归，因为 foldl 可以代替我们搞定了关于循环的一切。现在程序只要求我们回答两个问题：第一，累积器的初始化值是什么（foldl 的第二个参数）；第二，怎么更新累积器的值（(+) 函数）。</p>
<h2 class="calibre14"><a id="chp-4.html._fold__map__filter__526" class="calibre7 pcalibre"></a>为什么使用 fold 、 map 和 filter ？</h2>
<p class="calibre9">回顾一下之前的几个例子，可以看出，使用 fold 和 map 等高阶函数定义的函数，比起显式使用递归的函数，并不总是能节约大量代码。那么，我们为什么要使用这些函数呢？</p>
<p class="calibre9">答案是，因为它们在 Haskell 中非常通用，并且这些函数都带有正确的、可预见的行为。</p>
<p class="calibre9">这意味着，即使是一个 Haskell 新手，他/她理解起 fold 通常都要比理解显式递归要容易。一个 fold 并不产生任何意外动作，但一个显式递归函数的所做作为，通常并不是那么显而易见的。</p>
<p class="calibre9">以上观点同样适用于其他高阶函数库，包括前面介绍过的 map 和 filter 。因为这些函数都带有定义良好的行为，我们只需要学习怎样使用这些函数一次，以后每次碰到使用这些函数的代码，这些知识都可以加快我们对代码的理解。这种优势同样体现在代码的编写上：一旦我们能熟练使用高阶函数，那么写出更简洁的代码自然就不在话下。</p>
<h2 class="calibre14"><a id="chp-4.html._536" class="calibre7 pcalibre"></a>从右边开始折叠</h2>
<p class="calibre9">和 foldl 相对应的是 foldr ，它从一个列表的右边开始进行折叠。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>foldr<span class="token">.</span>hs

foldr <span class="token">:</span><span class="token">:</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> b <span class="token3">-</span><span class="token3">&gt;</span> b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> b <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> b

foldr step zero <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span> step x <span class="token">(</span>foldr step zero xs<span class="token">)</span>
foldr _ zero <span class="token">[</span><span class="token">]</span>        <span class="token3">=</span> zero

</code></pre>
<p class="calibre9">[译注：这个函数在载入 ghci 时会因为命名冲突而被拒绝，编写函数直接使用内置的 foldr 就可以了。]</p>
<p class="calibre9">可以用 foldr 改写在《左折叠》一节定义的 niceSum 函数：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>niceSumFoldr<span class="token">.</span>hs

niceSumFoldr <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Int<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Int
niceSumFoldr xs <span class="token3">=</span> foldr <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token2">0</span> xs

</code></pre>
<p class="calibre9">这个 niceSumFoldr 函数在输入为 [1,2,3] 时，产生以下计算序列：</p>
<pre class="calibre15"><code class="tthhighlight-container">niceSumFoldr <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">,</span> <span class="token2">3</span><span class="token">]</span>
    <span class="token3">==</span> foldr <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token2">0</span> <span class="token">(</span><span class="token2">1</span><span class="token">:</span><span class="token2">2</span><span class="token">:</span><span class="token2">3</span><span class="token">[</span><span class="token">]</span><span class="token">)</span>
    <span class="token3">==</span> <span class="token2">1</span> <span class="token3">+</span>           foldr <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token2">0</span> <span class="token">(</span><span class="token2">2</span><span class="token">:</span><span class="token2">3</span><span class="token">:</span><span class="token">[</span><span class="token">]</span><span class="token">)</span>
    <span class="token3">==</span> <span class="token2">1</span> <span class="token3">+</span> <span class="token">(</span><span class="token2">2</span> <span class="token3">+</span>      foldr <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token2">0</span> <span class="token">(</span><span class="token2">3</span><span class="token">:</span><span class="token">[</span><span class="token">]</span><span class="token">)</span><span class="token">)</span>
    <span class="token3">==</span> <span class="token2">1</span> <span class="token3">+</span> <span class="token">(</span><span class="token2">2</span> <span class="token3">+</span> <span class="token">(</span><span class="token2">3</span> <span class="token3">+</span> foldr <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token2">0</span> <span class="token">[</span><span class="token">]</span><span class="token">)</span><span class="token">)</span>
    <span class="token3">==</span> <span class="token2">1</span> <span class="token3">+</span> <span class="token">(</span><span class="token2">2</span> <span class="token3">+</span> <span class="token">(</span><span class="token2">3</span> <span class="token3">+</span> <span class="token2">0</span><span class="token">)</span><span class="token">)</span>

</code></pre>
<p class="calibre9">可以通过观察括号的包围方式，以及累积器初始化值摆放的位置，来区分 foldl 和 foldr ：foldl 将处初始化值放在左边，括号也是从左边开始包围。另一方面，foldr 将初始化值放在右边，而括号也是从右边开始包围。</p>
<p class="calibre9">还记得当年大明湖畔的 filter 函数吗？它可以用显式递归来定义：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>filter<span class="token">.</span>hs

filter <span class="token">:</span><span class="token">:</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> Bool<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span>
filter p <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> <span class="token">[</span><span class="token">]</span>
filter p <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span>
    <span class="token3">|</span> p x       <span class="token3">=</span> x <span class="token">:</span> filter p xs
    <span class="token3">|</span> otherwise <span class="token3">=</span> filter p xs

</code></pre>
<p class="calibre9">[译注：这个函数在载入 ghci 时会因为命名冲突而被拒绝，编写函数直接使用内置的 filter 就可以了。]</p>
<p class="calibre9">除此之外， filter 还可以通过 foldr 来定义：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>myFilter<span class="token">.</span>hs
myFilter p xs <span class="token3">=</span> foldr step <span class="token">[</span><span class="token">]</span> xs
    where step x ys <span class="token3">|</span> p x       <span class="token3">=</span> x <span class="token">:</span> ys
                    <span class="token3">|</span> otherwise <span class="token3">=</span> ys

</code></pre>
<p class="calibre9">来仔细分析一下 myFilter 函数的定义：和 foldl 一样， foldr 也接受一个函数、一个基本情形和一个列表作为参数。通过阅读 filter 函数的类型签名可以得知， myFilter 函数的输入和输出都使用同类型的列表，因此函数的基本情形，以及局部函数 step ，都必须返回这个类型的列表。</p>
<p class="calibre9">myFilter 里的 foldr 每次取出列表中的一个元素，并对他进行处理，如果这个元素经过条件判断为 True ，那么就将它放进累积的新列表里面，否则，它就略过这个元素，继续处理列表的其他剩余元素。</p>
<p class="calibre9">所有可以用 foldr 定义的函数，统称为<em class="calibre13">主递归</em>（primitive recursive）。很大一部分列表处理函数都是主递归函数。比如说， map 就可以用 foldr 定义：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>myFoldrMap<span class="token">.</span>hs

myFoldrMap <span class="token">:</span><span class="token">:</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>b<span class="token">]</span>

myFoldrMap f xs <span class="token3">=</span> foldr step <span class="token">[</span><span class="token">]</span> xs
    where step x xs <span class="token3">=</span> f x <span class="token">:</span> xs

</code></pre>
<p class="calibre9">更让人惊奇的是， foldl 甚至可以用 foldr 来表示：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>myFoldl<span class="token">.</span>hs

myFoldl <span class="token">:</span><span class="token">:</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> b <span class="token3">-</span><span class="token3">&gt;</span> a<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>b<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> a

myFoldl f z xs <span class="token3">=</span> foldr step id xs z
    where step x g a <span class="token3">=</span> g <span class="token">(</span>f a x<span class="token">)</span>

</code></pre>
<p class="calibre9">一种思考 foldr 的方式是，将它看成是对输入列表的一种<em class="calibre13">转换</em>（transform）：它的第一个参数决定了该怎么处理列表的 head 和 tail 部分；而它的第二个参数则决定了，当遇到空列表时，该用什么值来代替这个空列表。</p>
<p class="calibre9">用 foldr 定义的恒等（identity）转换，在列表为空时，返回空列表本身；如果列表不为空，那么它就将列表构造器 (:) 应用于每个 head 和 tail 对（pair）：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>identity<span class="token">.</span>hs

identity <span class="token">:</span><span class="token">:</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span>
identity xs <span class="token3">=</span> foldr <span class="token">(</span><span class="token">:</span><span class="token">)</span> <span class="token">[</span><span class="token">]</span> xs

</code></pre>
<p class="calibre9">最终产生的结果列表和原输入列表一模一样：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load identity<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> identity<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> identity <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">,</span> <span class="token2">3</span><span class="token">]</span>
<span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">]</span>

</code></pre>
<p class="calibre9">如果将 identity 函数定义中，处理空列表时返回的 [] 改为另一个列表，那么我们就得到了列表追加函数 append ：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>append<span class="token">.</span>hs
append <span class="token">:</span><span class="token">:</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span>
append xs ys <span class="token3">=</span> foldr <span class="token">(</span><span class="token">:</span><span class="token">)</span> ys xs

</code></pre>
<p class="calibre9">测试：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load append<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> append<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> append <span class="token4">"the quick "</span> <span class="token4">"fox"</span>
<span class="token4">"the quick fox"</span>

</code></pre>
<p class="calibre9">这个函数的效果等同于 (++) 操作符：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token4">"the quick "</span> <span class="token3">++</span> <span class="token4">"fox"</span>
<span class="token4">"the quick fox"</span>

</code></pre>
<p class="calibre9">append 函数依然对每个列表元素使用列表构造器，但是，当第一个输入列表为空时，它将第二个输入列表（而不是空列表元素）拼接到第一个输入列表的表尾。</p>
<p class="calibre9">通过前面这些例子对 foldr 的介绍，我们应该可以了解到， foldr 函数和《列表处理》一节所介绍的基本列表操作函数一样重要。由于 foldr 可以增量地处理和产生列表，所以它对于惰性数据处理也非常有用。</p>
<h2 class="calibre14"><a id="chp-4.html._686" class="calibre7 pcalibre"></a>左折叠、惰性和内存泄漏</h2>
<p class="calibre9">为了简化讨论，本节的例子通常都使用 foldl 来进行，这对于普通的测试是没有问题的，但是，千万不要把 foldl 用在实际使用中。</p>
<p class="calibre9">这样做是因为， Haskell 使用的是非严格求值。如果我们仔细观察 foldl(+)[1,2,3] 的执行过程，就可以会从中看出一些问题：</p>
<pre class="calibre15"><code class="tthhighlight-container">foldl <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token2">0</span> <span class="token">(</span><span class="token2">1</span><span class="token">:</span><span class="token2">2</span><span class="token">:</span><span class="token2">3</span><span class="token">:</span><span class="token">[</span><span class="token">]</span><span class="token">)</span>
          <span class="token3">==</span> foldl <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token">(</span><span class="token2">0</span> <span class="token3">+</span> <span class="token2">1</span><span class="token">)</span>             <span class="token">(</span><span class="token2">2</span><span class="token">:</span><span class="token2">3</span><span class="token">:</span><span class="token">[</span><span class="token">]</span><span class="token">)</span>
          <span class="token3">==</span> foldl <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token">(</span><span class="token">(</span><span class="token2">0</span> <span class="token3">+</span> <span class="token2">1</span><span class="token">)</span> <span class="token3">+</span> <span class="token2">2</span><span class="token">)</span>       <span class="token">(</span><span class="token2">3</span><span class="token">:</span><span class="token">[</span><span class="token">]</span><span class="token">)</span>
          <span class="token3">==</span> foldl <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token">(</span><span class="token">(</span><span class="token">(</span><span class="token2">0</span> <span class="token3">+</span> <span class="token2">1</span><span class="token">)</span> <span class="token3">+</span> <span class="token2">2</span><span class="token">)</span> <span class="token3">+</span> <span class="token2">3</span><span class="token">)</span> <span class="token">[</span><span class="token">]</span>
          <span class="token3">==</span>           <span class="token">(</span><span class="token">(</span><span class="token">(</span><span class="token2">0</span> <span class="token3">+</span> <span class="token2">1</span><span class="token">)</span> <span class="token3">+</span> <span class="token2">2</span><span class="token">)</span> <span class="token3">+</span> <span class="token2">3</span><span class="token">)</span>

</code></pre>
<p class="calibre9">除非被显式地要求，否则最后的表达式不会被求值为 6 。在表达式被求值之前，它会被保存在块里面。保存一个块比保存单独一个数字要昂贵得多，而被块保存的表达式越复杂，这个块占用的空间就越多。对于数值计算这样的廉价操作来说，块保存这种表达式所需的计算量，比直接求值这个表达式所需的计算量还多。最终，我们既浪费了时间，又浪费了金钱。</p>
<p class="calibre9">在 GHC 中，对块中表达式的求值在一个内部栈中进行。因为块中的表达式可能是无限大的，而 GHC 为栈设置了有限大的的容量，多得这个限制，我们可以在 ghci 里尝试求值一个大的块，而不必担心消耗掉全部内存。</p>
<p class="calibre9">[译注：使用栈来执行一些可能无限大的操作，是一种常见优化和保护技术。这种用法减少了操作系统显式的上下文切换，而且就算计算量超出栈可以容纳的范围，那么最坏的结果就是栈崩溃，而如果直接使用系统内存，一旦请求超出内存可以容纳的范围，可能会造成整个程序崩溃，甚至影响系统的稳定性。]</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> foldl <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token2">0</span> <span class="token">[</span><span class="token2">1.</span><span class="token2">.1000</span><span class="token">]</span>
<span class="token2">500500</span>

</code></pre>
<p class="calibre9">可以推测出，在上面的表达式被求值之前，它创建了一个保存 1000 个数字和 999 个 (+) 操作的块。单单为了表示一个数字，我们就用了非常多的内存和 CPU ！</p>
<p class="calibre9">[译注：这些块到底有多大？算算就知道了：对于每一个加法表达式，比如 x+y ，都要使用一个块来保存。而这种操作在 foldl(+)0[1..1000] 里要执行 999 次，因此一共有 999 个块被创建，这些块都保存着像 x+y 这样的表达式。]</p>
<p class="calibre9">对于一个更大的表达式 —— 尽管它并不是真的非常庞大， foldl 的执行会失败：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> foldl <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token2">0</span> <span class="token">[</span><span class="token2">1.</span><span class="token2">.1000000</span><span class="token">]</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> stack overflow

</code></pre>
<p class="calibre9">对于小的表达式来说， foldl 可以给出正确的答案，但是，因为过度的块资源占用，它运行非常缓慢。我们称这种现象为<em class="calibre13">内存泄漏</em>：代码可以正确地执行，但它占用了比实际所需多得多的内存。</p>
<p class="calibre9">对于大的表达式来说，带有内存泄漏的代码会造成运行失败，就像前面例子展示的那样。</p>
<p class="calibre9">内存泄漏是 Haskell 新手常常会遇到的问题，幸好的是，它非常容易避免。Data.List 模块定义了一个 foldl' 函数，它和 foldl 的作用类似，唯一的区别是， foldl' 并不创建块。以下的代码直观地展示了它们的区别：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> foldl  <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token2">0</span> <span class="token">[</span><span class="token2">1.</span><span class="token2">.1000000</span><span class="token">]</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> stack overflow

ghci<span class="token3">&gt;</span> <span class="token">:</span>module <span class="token3">+</span>Data<span class="token">.</span>List

ghci<span class="token3">&gt;</span> foldl' <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token2">0</span> <span class="token">[</span><span class="token2">1.</span><span class="token2">.1000000</span><span class="token">]</span>
<span class="token2">500000500000</span>

</code></pre>
<p class="calibre9">综上所述，最好不要在实际代码中使用 foldl ：即使计算不失败，它的效率也好不到那里去。更好的办法是，使用 Data.List 里面的 foldl' 来代替。 [译注：在我的电脑上，超出内存的 foldl 失败方式和书本列出的并不一样：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> foldl <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token2">0</span> <span class="token">[</span><span class="token2">1.</span><span class="token2">.1000000000</span><span class="token">]</span>
<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span> internal error<span class="token">:</span> getMBlock<span class="token">:</span> mmap<span class="token">:</span> Operation not permitted
<span class="token">(</span>GHC version <span class="token2">7.4</span><span class="token2">.2</span> <span class="token1">for</span> i386_unknown_linux<span class="token">)</span>
Please report this as a GHC bug<span class="token">:</span>  http<span class="token">:</span><span class="token3">/</span><span class="token3">/</span>www<span class="token">.</span>haskell<span class="token">.</span>org<span class="token3">/</span>ghc<span class="token3">/</span>reportabug
已放弃

</code></pre>
<p class="calibre9">从错误信息看， GHC/GHCi 处理 foldl 的方式应该已经发生了变化。</p>
<p class="calibre9">如果使用 foldl' 来执行计算，就不会出现任何问题：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>module <span class="token3">+</span>Data<span class="token">.</span>List

Prelude Data<span class="token">.</span>List<span class="token3">&gt;</span> foldl' <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token2">0</span> <span class="token">[</span><span class="token2">1.</span><span class="token2">.1000000000</span><span class="token">]</span>
<span class="token2">500000000500000000</span>

</code></pre>
<p class="calibre9">就是这样。]<br class="calibre1"><br>
延伸阅读 A tutorial on the universality and expressiveness of fold [<a href="http://www.cs.nott.ac.uk/~gmh/fold.pdf" target="_blank" class="calibre7 pcalibre">http://www.cs.nott.ac.uk/~gmh/fold.pdf</a>] 是一篇关于 fold 的优秀且深入的文章。它使用了很多例子来展示如何通过简单的系统化计算技术，将一些显式递归的函数转换成 fold 。<br class="calibre1"><br>
匿名（lambda）函数 在前面章节定义的函数中，很多函数都带有一个简单的辅助函数：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>isInAny<span class="token">.</span>hs

import Data<span class="token">.</span>List <span class="token">(</span>isInfixOf<span class="token">)</span>

isInAny needle haystack <span class="token3">=</span> any inSequence haystack
    where inSequence s <span class="token3">=</span> needle `isInfixOf` s

</code></pre>
<p class="calibre9">Haskell 允许我们编写完全匿名的函数，这样就不必再费力地为辅助函数想名字了。因为匿名函数从 lambda 演算而来，所以匿名函数通常也被称为 lambda 函数。</p>
<p class="calibre9">在 Haskell 中，匿名函数以反斜杠符号 \ 为开始，后跟函数的参数（可以包含模式），而函数体定义在 -&gt; 符号之后。其中， \ 符号读作 <em class="calibre13">lambda</em> 。</p>
<p class="calibre9">以下是前面的 isInAny 函数用 lambda 改写的版本：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>isInAny2<span class="token">.</span>hs

import Data<span class="token">.</span>List <span class="token">(</span>isInfixOf<span class="token">)</span>

isInAny2 needle haystack <span class="token3">=</span> any <span class="token">(</span>\s <span class="token3">-</span><span class="token3">&gt;</span> needle `isInfixOf` s<span class="token">)</span> haystack

</code></pre>
<p class="calibre9">定义使用括号包裹了整个匿名函数，确保 Haskell 可以知道匿名函数体在那里结束。</p>
<p class="calibre9">匿名函数各个方面的行为都和带名称的函数基本一致，但是，匿名函数的定义受到几个严格的限制，其中最重要的一点是：普通函数可以通过多条语句来定义，而 lambda 函数的定义只能有一条语句。</p>
<p class="calibre9">只能使用一条语句的局限性，限制了在 lambda 定义中可使用的模式。一个普通函数，通常要使用多条定义，来覆盖各种不同的模式：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>safeHead<span class="token">.</span>hs

safeHead <span class="token">(</span>x<span class="token">:</span>_<span class="token">)</span> <span class="token3">=</span> Just x
safeHead <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> Nothing

</code></pre>
<p class="calibre9">而 lambda 只能覆盖其中一种情形：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file ch04<span class="token3">/</span>unsafeHead<span class="token">.</span>hs
unsafeHead <span class="token3">=</span> \<span class="token">(</span>x<span class="token">:</span>_<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> x

</code></pre>
<p class="calibre9">如果一不小心，将这个函数应用到错误的模式上，它就会给我们带来麻烦：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load unsafeHead<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> unsafeHead<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type unsafeHead
unsafeHead <span class="token">:</span><span class="token">:</span> <span class="token">[</span>t<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> t

<span class="token3">*</span>Main<span class="token3">&gt;</span> unsafeHead <span class="token">[</span><span class="token2">1</span><span class="token">]</span>
<span class="token2">1</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> unsafeHead <span class="token">[</span><span class="token">]</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> unsafeHead<span class="token">.</span>hs<span class="token">:</span><span class="token2">2</span><span class="token">:</span><span class="token2">14</span><span class="token3">-</span><span class="token2">24</span><span class="token">:</span> Non<span class="token3">-</span>exhaustive patterns <span class="token1">in</span> lambda

</code></pre>
<p class="calibre9">因为这个 lambda 定义是完全合法的，它的类型也没有错误，所以它可以被顺利编译，而最终在运行期产生错误。这个故事说明，如果你要在 lambda 函数里使用模式，请千万小心，必须确保你的模式不会匹配失败。</p>
<p class="calibre9">另外需要注意的是，在前面定义的 isInAny 函数和 isInAny2 函数里，带有辅助函数的 isInAny 要比使用 lambda 的 isInAny2 要更具可读性。带有名字的辅助函数不会破坏程序的代码流（flow），而且它的名字也可以传达更多的相关信息。</p>
<p class="calibre9">相反，当在一个函数定义里面看到 lambda 时，我们必须慢下来，仔细阅读这个匿名函数的定义，弄清楚它都干了些什么。为了程序的可读性和可维护性考虑，我们在很多情况下都会避免使用 lambda 。</p>
<p class="calibre9">当然，这并不是说 lambda 函数完全没用，只是在使用它们的时候，必须小心谨慎。</p>
<p class="calibre9">很多时候，部分应用函数可以很好地代替 lambda 函数，避免不必要的函数定义，粘合起不同的函数，并产生更清晰和更可读的代码。下一节就会介绍部分应用函数。</p>
<h2 class="calibre14"><a id="chp-4.html._840" class="calibre7 pcalibre"></a>部分函数应用和柯里化</h2>
<p class="calibre9">类型签名里的 -&gt; 可能会让人感到奇怪：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>type dropWhile
dropWhile <span class="token">:</span><span class="token">:</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> Bool<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span>

</code></pre>
<p class="calibre9">初看上去，似乎 -&gt; 既用于隔开 dropWhile 函数的各个参数（比如括号里的 a 和 Bool ），又用于隔开函数参数和返回值的类型（(a-&gt;Bool)-&gt;[a] 和 [a]）。</p>
<p class="calibre9">但是，实际上 -&gt; 只有一种作用：它表示一个函数接受一个参数，并返回一个值。其中 -&gt; 符号的左边是参数的类型，右边是返回值的类型。</p>
<p class="calibre9">理解 -&gt; 的含义非常重要：在 Haskell 中，<em class="calibre13">所有函数都只接受一个参数</em>。尽管 dropWhile 看上去像是一个接受两个参数的函数，但实际上它是一个接受一个参数的函数，而这个函数的返回值是另一个函数，这个被返回的函数也只接受一个参数。</p>
<p class="calibre9">以下是一个完全合法的 Haskell 表达式：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>module <span class="token3">+</span>Data<span class="token">.</span>Char

Prelude Data<span class="token">.</span>Char<span class="token3">&gt;</span> <span class="token">:</span>type dropWhile isSpace
dropWhile isSpace <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Char<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>Char<span class="token">]</span>

</code></pre>
<p class="calibre9">表达式 dropWhile isSpace 的值是一个函数，这个函数移除一个字符串的所有前置空白。作为一个例子，可以将它应用到一个高阶函数：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude Data<span class="token">.</span>Char<span class="token3">&gt;</span> map <span class="token">(</span>dropWhile isSpace<span class="token">)</span> <span class="token">[</span><span class="token4">" a"</span><span class="token">,</span> <span class="token4">"f"</span><span class="token">,</span> <span class="token4">"    e"</span><span class="token">]</span>
<span class="token">[</span><span class="token4">"a"</span><span class="token">,</span><span class="token4">"f"</span><span class="token">,</span><span class="token4">"e"</span><span class="token">]</span>

</code></pre>
<p class="calibre9">每当我们将一个参数传给一个函数时，这个函数的类型签名最前面的一个元素就会被“移除掉”。这里用函数 zip3 来做例子，这个函数接受三个列表，并将它们压缩成一个包含三元组的列表：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>type zip3
zip3 <span class="token">:</span><span class="token">:</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>b<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>c<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span><span class="token">(</span>a<span class="token">,</span> b<span class="token">,</span> c<span class="token">)</span><span class="token">]</span>

Prelude<span class="token3">&gt;</span> zip3 <span class="token4">"foo"</span> <span class="token4">"bar"</span> <span class="token4">"quux"</span>
<span class="token">[</span><span class="token">(</span><span class="token4">'f'</span><span class="token">,</span><span class="token4">'b'</span><span class="token">,</span><span class="token4">'q'</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token4">'o'</span><span class="token">,</span><span class="token4">'a'</span><span class="token">,</span><span class="token4">'u'</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token4">'o'</span><span class="token">,</span><span class="token4">'r'</span><span class="token">,</span><span class="token4">'u'</span><span class="token">)</span><span class="token">]</span>

</code></pre>
<p class="calibre9">如果只将一个参数应用到 zip3 函数，那么它就会返回一个接受两个参数的函数。无论之后将什么参数传给这个复合函数，之前传给它的第一个参数的值都不会改变。</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>type zip3
zip3 <span class="token">:</span><span class="token">:</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>b<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>c<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span><span class="token">(</span>a<span class="token">,</span> b<span class="token">,</span> c<span class="token">)</span><span class="token">]</span>

Prelude<span class="token3">&gt;</span> <span class="token">:</span>type zip3 <span class="token4">"foo"</span>
zip3 <span class="token4">"foo"</span> <span class="token">:</span><span class="token">:</span> <span class="token">[</span>b<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>c<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span><span class="token">(</span>Char<span class="token">,</span> b<span class="token">,</span> c<span class="token">)</span><span class="token">]</span>

Prelude<span class="token3">&gt;</span> <span class="token">:</span>type zip3 <span class="token4">"foo"</span> <span class="token4">"bar"</span>
zip3 <span class="token4">"foo"</span> <span class="token4">"bar"</span> <span class="token">:</span><span class="token">:</span> <span class="token">[</span>c<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span><span class="token">(</span>Char<span class="token">,</span> Char<span class="token">,</span> c<span class="token">)</span><span class="token">]</span>

Prelude<span class="token3">&gt;</span> <span class="token">:</span>type zip3 <span class="token4">"foo"</span> <span class="token4">"bar"</span> <span class="token4">"quux"</span>
zip3 <span class="token4">"foo"</span> <span class="token4">"bar"</span> <span class="token4">"quux"</span> <span class="token">:</span><span class="token">:</span> <span class="token">[</span><span class="token">(</span>Char<span class="token">,</span> Char<span class="token">,</span> Char<span class="token">)</span><span class="token">]</span>

</code></pre>
<p class="calibre9">传入参数的数量，少于函数所能接受参数的数量，这种情况被称为函数的<em class="calibre13">部分应用</em>（partial application of the function）：函数正被它的其中几个参数所应用。</p>
<p class="calibre9">在上面的例子中， zip3"foo" 就是一个部分应用函数，它以 "foo" 作为第一个参数，部分应用了 zip3 函数；而 zip3"foo""bar" 也是另一个部分应用函数，它以 "foo" 和 "bar" 作为参数，部分应用了 zip3 函数。</p>
<p class="calibre9">只要给部分函数补充上足够的参数，它就可以被成功求值：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> let zip3foo <span class="token3">=</span> zip3 <span class="token4">"foo"</span>

Prelude<span class="token3">&gt;</span> zip3foo <span class="token4">"bar"</span> <span class="token4">"quux"</span>
<span class="token">[</span><span class="token">(</span><span class="token4">'f'</span><span class="token">,</span><span class="token4">'b'</span><span class="token">,</span><span class="token4">'q'</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token4">'o'</span><span class="token">,</span><span class="token4">'a'</span><span class="token">,</span><span class="token4">'u'</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token4">'o'</span><span class="token">,</span><span class="token4">'r'</span><span class="token">,</span><span class="token4">'u'</span><span class="token">)</span><span class="token">]</span>

Prelude<span class="token3">&gt;</span> let zip3foobar <span class="token3">=</span> zip3 <span class="token4">"foo"</span> <span class="token4">"bar"</span>

Prelude<span class="token3">&gt;</span> zip3foobar <span class="token4">"quux"</span>
<span class="token">[</span><span class="token">(</span><span class="token4">'f'</span><span class="token">,</span><span class="token4">'b'</span><span class="token">,</span><span class="token4">'q'</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token4">'o'</span><span class="token">,</span><span class="token4">'a'</span><span class="token">,</span><span class="token4">'u'</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token4">'o'</span><span class="token">,</span><span class="token4">'r'</span><span class="token">,</span><span class="token4">'u'</span><span class="token">)</span><span class="token">]</span>

Prelude<span class="token3">&gt;</span> zip3foobar <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">,</span> <span class="token2">3</span><span class="token">]</span>
<span class="token">[</span><span class="token">(</span><span class="token4">'f'</span><span class="token">,</span><span class="token4">'b'</span><span class="token">,</span><span class="token2">1</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token4">'o'</span><span class="token">,</span><span class="token4">'a'</span><span class="token">,</span><span class="token2">2</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token4">'o'</span><span class="token">,</span><span class="token4">'r'</span><span class="token">,</span><span class="token2">3</span><span class="token">)</span><span class="token">]</span>

</code></pre>
<p class="calibre9">部分函数应用（partial function application）让我们免于编写烦人的一次性函数，而且它比起之前介绍的匿名函数要来得更有用。回顾之前的 isInAny 函数，以下是一个部分应用函数改写的版本，它既不需要匿名函数，也不需要辅助函数：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>isInAny3<span class="token">.</span>hs

import Data<span class="token">.</span>List <span class="token">(</span>isInfixOf<span class="token">)</span>

isInAny3 needle haystack <span class="token3">=</span> any <span class="token">(</span>isInfixOf needle<span class="token">)</span> haystack

</code></pre>
<p class="calibre9">表达式 isInfixOfneedle 是部分应用函数，它以 needle 变量作为第一个参数，传给 isInfixOf ，并产生一个部分应用函数，这个部分应用函数的作用等同于 isInAny 定义的辅助函数，以及 isInAny2 定义的匿名函数。</p>
<p class="calibre9">部分函数应用被称为柯里化（currying），以逻辑学家 Haskell Curry 命名（Haskell 语言的命名也是来源于他的名字）。</p>
<p class="calibre9">以下是另一个使用柯里化的例子。先来回顾《左折叠》章节的 niceSum 函数：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>niceSum<span class="token">.</span>hs
niceSum <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Integer<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Integer
niceSum xs <span class="token3">=</span> foldl <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token2">0</span> xs

</code></pre>
<p class="calibre9">实际上，并不需要完全应用 foldl [译注：完全应用是指提供函数所需的全部参数]，niceSum 函数的 xs 参数，以及传给 foldl 函数的 xs 参数，这两者都可以被省略，最终得到一个更紧凑的函数，它的类型也和原本的一样：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>niceSumPartial<span class="token">.</span>hs
niceSumPartial <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Integer<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Integer
niceSumPartial <span class="token3">=</span> foldl <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token2">0</span>

</code></pre>
<p class="calibre9">测试：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load niceSumPartial<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> niceSumPartial<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> niceSumPartial <span class="token">[</span><span class="token2">1</span> <span class="token">.</span><span class="token">.</span> <span class="token2">10</span><span class="token">]</span>
<span class="token2">55</span>

</code></pre>
<h2 class="calibre14"><a id="chp-4.html._967" class="calibre7 pcalibre"></a>节</h2>
<p class="calibre9">Haskell 提供了一种方便的符号快捷方式，用于对中序函数进行部分应用：使用括号包围一个操作符，通过在括号里面提供左操作对象或者右操作对象，可以产生一个部分应用函数。这种类型的部分函数应用称之为节（section）。</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">(</span><span class="token2">1</span><span class="token3">+</span><span class="token">)</span> <span class="token2">2</span>
<span class="token2">3</span>

Prelude<span class="token3">&gt;</span> map <span class="token">(</span><span class="token3">*</span><span class="token2">3</span><span class="token">)</span> <span class="token">[</span><span class="token2">24</span><span class="token">,</span> <span class="token2">36</span><span class="token">]</span>
<span class="token">[</span><span class="token2">72</span><span class="token">,</span><span class="token2">108</span><span class="token">]</span>

Prelude<span class="token3">&gt;</span> map <span class="token">(</span><span class="token2">2</span><span class="token3">^</span><span class="token">)</span> <span class="token">[</span><span class="token2">3</span><span class="token">,</span> <span class="token2">5</span><span class="token">,</span> <span class="token2">7</span><span class="token">,</span> <span class="token2">9</span><span class="token">]</span>
<span class="token">[</span><span class="token2">8</span><span class="token">,</span><span class="token2">32</span><span class="token">,</span><span class="token2">128</span><span class="token">,</span><span class="token2">512</span><span class="token">]</span>

</code></pre>
<p class="calibre9">如果向节提供左操作对象，那么得出的部分函数就会将接收到的参数应用为右操作对对象，反之亦然。</p>
<p class="calibre9">以下两个表达式都计算 2 的 3 次方，但是第一个节接受的是左操作对象 2 ，而第二个节接受的则是右操作对象 3 。</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">(</span><span class="token2">2</span><span class="token3">^</span><span class="token">)</span> <span class="token2">3</span>
<span class="token2">8</span>

Prelude<span class="token3">&gt;</span> <span class="token">(</span><span class="token3">^</span><span class="token2">3</span><span class="token">)</span> <span class="token2">2</span>
<span class="token2">8</span>

</code></pre>
<p class="calibre9">之前提到过，通过使用反括号来包围一个函数，可以将这个函数用作中序操作符。这种用法可以让节使用函数：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token">(</span>`elem` <span class="token">[</span><span class="token4">'a'</span> <span class="token">.</span><span class="token">.</span> <span class="token4">'z'</span><span class="token">]</span><span class="token">)</span>
<span class="token">(</span>`elem` <span class="token">[</span><span class="token4">'a'</span> <span class="token">.</span><span class="token">.</span> <span class="token4">'z'</span><span class="token">]</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> Char <span class="token3">-</span><span class="token3">&gt;</span> Bool

</code></pre>
<p class="calibre9">上面的定义将 ['a'..'z'] 传给 elem 作为第二个参数，表达式返回的函数可以用于检查一个给定字符值是否属于小写字母：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">(</span>`elem` <span class="token">[</span><span class="token4">'a'</span> <span class="token">.</span><span class="token">.</span> <span class="token4">'z'</span><span class="token">]</span><span class="token">)</span> <span class="token4">'f'</span>
True

Prelude<span class="token3">&gt;</span> <span class="token">(</span>`elem` <span class="token">[</span><span class="token4">'a'</span> <span class="token">.</span><span class="token">.</span> <span class="token4">'z'</span><span class="token">]</span><span class="token">)</span> <span class="token4">'1'</span>
False

</code></pre>
<p class="calibre9">还可以将这个节用作 all 函数的输入，这样就得到了一个检查给定字符串是否整个字符串都由小写字母组成的函数：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> all <span class="token">(</span>`elem` <span class="token">[</span><span class="token4">'a'</span> <span class="token">.</span><span class="token">.</span> <span class="token4">'z'</span><span class="token">]</span><span class="token">)</span> <span class="token4">"Haskell"</span>
False

Prelude<span class="token3">&gt;</span> all <span class="token">(</span>`elem` <span class="token">[</span><span class="token4">'a'</span> <span class="token">.</span><span class="token">.</span> <span class="token4">'z'</span><span class="token">]</span><span class="token">)</span> <span class="token4">"haskell"</span>
True

</code></pre>
<p class="calibre9">通过这种用法，可以再一次提升 isInAny3 函数的可读性：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>isInAny4<span class="token">.</span>hs

import Data<span class="token">.</span>List <span class="token">(</span>isInfixOf<span class="token">)</span>

isInAny4 needle haystack <span class="token3">=</span> any <span class="token">(</span>needle `isInfixOf`<span class="token">)</span> haystack

</code></pre>
<p class="calibre9">[译注：根据前面部分函数部分提到的技术，这个 isInAny4 的定义还可以进一步精简，去除 haystack 参数：</p>
<pre class="calibre15"><code class="tthhighlight-container">import Data<span class="token">.</span>List <span class="token">(</span>isInfixOf<span class="token">)</span>
isInAny4Partial needle <span class="token3">=</span> any <span class="token">(</span>needle `isInfixOf`<span class="token">)</span>

</code></pre>
<p class="calibre9">]</p>
<h2 class="calibre14"><a id="chp-4.html.As_1047" class="calibre7 pcalibre"></a>As-模式</h2>
<p class="calibre9">Data.List 模块里定义的 tails 函数是 tail 的推广，它返回一个列表的所有“尾巴”：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>m <span class="token3">+</span>Data<span class="token">.</span>List

Prelude Data<span class="token">.</span>List<span class="token3">&gt;</span> tail <span class="token4">"foobar"</span>
<span class="token4">"oobar"</span>

Prelude Data<span class="token">.</span>List<span class="token3">&gt;</span> tail <span class="token">(</span>tail <span class="token4">"foobar"</span><span class="token">)</span>
<span class="token4">"obar"</span>

Prelude Data<span class="token">.</span>List<span class="token3">&gt;</span> tails <span class="token4">"foobar"</span>
<span class="token">[</span><span class="token4">"foobar"</span><span class="token">,</span><span class="token4">"oobar"</span><span class="token">,</span><span class="token4">"obar"</span><span class="token">,</span><span class="token4">"bar"</span><span class="token">,</span><span class="token4">"ar"</span><span class="token">,</span><span class="token4">"r"</span><span class="token">,</span><span class="token4">""</span><span class="token">]</span>

</code></pre>
<p class="calibre9">tails 返回一个包含字符串的列表，这个列表保存了输入字符串的所有后缀，以及一个额外的空列表（放在结果列表的最后）。tails 的返回值总是带有额外的空列表，即使它的输入为空时：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude Data<span class="token">.</span>List<span class="token3">&gt;</span> tails <span class="token4">""</span>
<span class="token">[</span><span class="token4">""</span><span class="token">]</span>

</code></pre>
<p class="calibre9">如果想要一个行为和 tails 类似，但是并不包含空列表后缀的函数，可以自己写一个：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>suffixes<span class="token">.</span>hs

suffixes <span class="token">:</span><span class="token">:</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span><span class="token">[</span>a<span class="token">]</span><span class="token">]</span>
suffixes xs@<span class="token">(</span>_<span class="token">:</span>xs<span class="token4">') = xs : suffixes xs'</span>
suffixes <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> <span class="token">[</span><span class="token">]</span>

</code></pre>
<p class="calibre9">[译注：在稍后的章节就会看到，有简单得多的方法来完成这个目标，这个例子主要用于展示 as-模式的作用。]</p>
<p class="calibre9">源码里面用到了新引入的 @ 符号，模式 xs@(<em class="calibre13">:xs') 被称为 as-模式，它的意思是：如果输入值能匹配 @ 符号右边的模式（这里是 (</em>:xs') ），那么就将这个值绑定到 @ 符号左边的变量中（这里是 xs ）。</p>
<p class="calibre9">在这个例子里，如果输入值能够匹配模式 (_:xs') ，那么这个输入值这就被绑定为 xs ，它的 tail 部分被绑定为 xs' ，而它的 head 部分因为使用通配符 _ 进行匹配，所以这部分没有被绑定到任何变量。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main Data<span class="token">.</span>List<span class="token3">&gt;</span> tails <span class="token4">"foo"</span>
<span class="token">[</span><span class="token4">"foo"</span><span class="token">,</span><span class="token4">"oo"</span><span class="token">,</span><span class="token4">"o"</span><span class="token">,</span><span class="token4">""</span><span class="token">]</span>

<span class="token3">*</span>Main Data<span class="token">.</span>List<span class="token3">&gt;</span> suffixes <span class="token4">"foo"</span>
<span class="token">[</span><span class="token4">"foo"</span><span class="token">,</span><span class="token4">"oo"</span><span class="token">,</span><span class="token4">"o"</span><span class="token">]</span>

</code></pre>
<p class="calibre9">As-模式可以提升代码的可读性，作为对比，以下是一个没有使用 as-模式的 suffixes 定义：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> noAsPattern<span class="token">.</span>hs

noAsPattern <span class="token">:</span><span class="token">:</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span><span class="token">[</span>a<span class="token">]</span><span class="token">]</span>
noAsPattern <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span> <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token">:</span> noAsPattern xs
noAsPattern <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> <span class="token">[</span><span class="token">]</span>

</code></pre>
<p class="calibre9">可以看到，使用 as-模式的定义同时完成了模式匹配和变量绑定两项工作。而不使用 as-模式的定义，则需要在对列表进行结构之后，在函数体里又重新对列表进行组合。</p>
<p class="calibre9">除了增强可读性之外， as-模式还有其他作用：它可以对输入数据进行共享，而不是复制它。在 noAsPattern 函数的定义中，当 (x:xs) 匹配时，在函数体里需要复制一个 (x:xs) 的副本。这个动作会引起内存分配。虽然这个分配动作可能很廉价，但它并不是免费的。相反，当使用 suffixes 函数时，我们通过变量 xs 重用匹配了 as-模式的输入值，因此就避免了内存分配。</p>
<h2 class="calibre14"><a id="chp-4.html._1114" class="calibre7 pcalibre"></a>通过组合函数来进行代码复用</h2>
<p class="calibre9">前面的 suffixes 函数实际上有一种更简单的实现方式。</p>
<p class="calibre9">回忆前面在《使用列表》一节里介绍的 init 函数，它可以返回一个列表中除了最后一个元素之外的其他元素。而组合使用 init 和 tails ，可以给出一个 suffixes 函数的更简单实现：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>suffixes<span class="token">.</span>hs

import Data<span class="token">.</span>List <span class="token">(</span>tails<span class="token">)</span>

suffixes2 xs <span class="token3">=</span> init <span class="token">(</span>tails xs<span class="token">)</span>

</code></pre>
<p class="calibre9">suffixes2 和 suffixes 函数的行为完全一样，但 suffixes2 的定义只需一行：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load suffixes2<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> suffixes2<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> suffixes2 <span class="token4">"foobar"</span>
<span class="token">[</span><span class="token4">"foobar"</span><span class="token">,</span><span class="token4">"oobar"</span><span class="token">,</span><span class="token4">"obar"</span><span class="token">,</span><span class="token4">"bar"</span><span class="token">,</span><span class="token4">"ar"</span><span class="token">,</span><span class="token4">"r"</span><span class="token">]</span>

</code></pre>
<p class="calibre9">如果仔细地观察，就会发现这里隐含着一个模式：我们先应用一个函数，然后又将这个函数得出的结果应用到另一个函数。可以将这个模式定义为一个函数：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>compose<span class="token">.</span>hs

compose <span class="token">:</span><span class="token">:</span> <span class="token">(</span>b <span class="token3">-</span><span class="token3">&gt;</span> c<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> c
compose f g x <span class="token3">=</span> f <span class="token">(</span>g x<span class="token">)</span>

</code></pre>
<p class="calibre9">compose 函数可以用于粘合两个函数：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load compose<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> compose<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>m <span class="token3">+</span>Data<span class="token">.</span>List

<span class="token3">*</span>Main Data<span class="token">.</span>List<span class="token3">&gt;</span> let suffixes3 xs <span class="token3">=</span> compose init tails xs

</code></pre>
<p class="calibre9">通过柯里化，可以丢掉 xs 函数：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main Data<span class="token">.</span>List<span class="token3">&gt;</span> let suffixes4 <span class="token3">=</span> compose init tails

</code></pre>
<p class="calibre9">更棒的是，其实我们并不需要自己编写 compose 函数，因为 Haskell 已经内置在了 Prelude 里面，使用 (.) 操作符就可以组合起两个函数：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main Data<span class="token">.</span>List<span class="token3">&gt;</span> let suffixes5 <span class="token3">=</span> init <span class="token">.</span> tails

</code></pre>
<p class="calibre9">(.) 操作符并不是什么特殊语法，它只是一个普通的操作符：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main Data<span class="token">.</span>List<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token">(</span><span class="token">.</span><span class="token">)</span>
<span class="token">(</span><span class="token">.</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> <span class="token">(</span>b <span class="token3">-</span><span class="token3">&gt;</span> c<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> c

<span class="token3">*</span>Main Data<span class="token">.</span>List<span class="token3">&gt;</span> <span class="token">:</span>type suffixes5
suffixes5 <span class="token">:</span><span class="token">:</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span><span class="token">[</span>a<span class="token">]</span><span class="token">]</span>

<span class="token3">*</span>Main Data<span class="token">.</span>List<span class="token3">&gt;</span> suffixes5 <span class="token4">"foobar"</span>
<span class="token">[</span><span class="token4">"foobar"</span><span class="token">,</span><span class="token4">"oobar"</span><span class="token">,</span><span class="token4">"obar"</span><span class="token">,</span><span class="token4">"bar"</span><span class="token">,</span><span class="token4">"ar"</span><span class="token">,</span><span class="token4">"r"</span><span class="token">]</span>

</code></pre>
<p class="calibre9">在任何时候，都可以通过使用 (.) 来组合函数，并产生新函数。组合链的长度并没有限制，只要 (.) 符号右边函数的输出值类型适用于 (.) 符号左边函数的输入值类型就可以了。</p>
<p class="calibre9">也即是，对于 f.g 来说， g 的输出值必须是 f 能接受的类型，这样的组合就是合法的， (.) 的类型签名也显示了这一点。</p>
<p class="calibre9">作为例子，再来解决一个非常常见的问题：计算字符串中以大写字母开头的单词的个数：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>module <span class="token3">+</span>Data<span class="token">.</span>Char

Prelude Data<span class="token">.</span>Char<span class="token3">&gt;</span> let capCount <span class="token3">=</span> length <span class="token">.</span> filter <span class="token">(</span>isUpper <span class="token">.</span> head<span class="token">)</span> <span class="token">.</span> words

Prelude Data<span class="token">.</span>Char<span class="token3">&gt;</span> capCount <span class="token4">"Hello there, Mon!"</span>
<span class="token2">2</span>

</code></pre>
<p class="calibre9">来逐步分析 capCount 函数的组合过程。因为 (.) 操作符是右关联的，因此我们从组合链的最右边开始研究：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude Data<span class="token">.</span>Char<span class="token3">&gt;</span> <span class="token">:</span>type words
words <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>String<span class="token">]</span>

</code></pre>
<p class="calibre9">words 返回一个 [String] 类型值，因此 (.) 的左边的函数必须能接受这个参数。</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude Data<span class="token">.</span>Char<span class="token3">&gt;</span> <span class="token">:</span>type isUpper <span class="token">.</span> head
isUpper <span class="token">.</span> head <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Char<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Bool

</code></pre>
<p class="calibre9">上面的组合函数在输入字符串以大写字母开头时返回 True ，因此 filter(isUpper.head) 表达式会返回所有以大写字母开头的字符串：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude Data<span class="token">.</span>Char<span class="token3">&gt;</span> <span class="token">:</span>type filter <span class="token">(</span>isUpper <span class="token">.</span> head<span class="token">)</span>
filter <span class="token">(</span>isUpper <span class="token">.</span> head<span class="token">)</span> <span class="token">:</span><span class="token">:</span> <span class="token">[</span><span class="token">[</span>Char<span class="token">]</span><span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span><span class="token">[</span>Char<span class="token">]</span><span class="token">]</span>

</code></pre>
<p class="calibre9">因为这个表达式返回一个列表，而 length 函数用于统计列表的长度，所以 length.filter(isUpper.head) 就计算出了所有以大写字母开头的字符串的个数。</p>
<p class="calibre9">以下是另一个例子，它从 libpcap —— 一个流行的网络包过滤库中提取 C 文件头中给定格式的宏名字。这些头文件带有很多以下格式的宏：</p>
<pre class="calibre15"><code class="tthhighlight-container">#define DLT_EN10MB      <span class="token2">1</span>       <span class="token6">/* Ethernet (10Mb) */</span>
#define DLT_EN3MB       <span class="token2">2</span>       <span class="token6">/* Experimental Ethernet (3Mb) */</span>
#define DLT_AX25        <span class="token2">3</span>       <span class="token6">/* Amateur Radio AX.25 */</span>

</code></pre>
<p class="calibre9">我们的目标是提取出所有像 DLT_AX25 和 DLT_EN3MB 这种名字。以下是程序的定义，它将整个文件看作是一个字符串，先使用 lines 对文件进行按行分割，再将 foldrstep[] 应用到各行当中，其中 step 辅助函数用于过滤和提取符合格式的宏名字：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>dlts<span class="token">.</span>hs

import Data<span class="token">.</span>List <span class="token">(</span>isPrefixOf<span class="token">)</span>

dlts <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>String<span class="token">]</span>

dlts <span class="token3">=</span> foldr step <span class="token">[</span><span class="token">]</span> <span class="token">.</span> lines
  where step l ds
          <span class="token3">|</span> <span class="token4">"#define DLT_"</span> `isPrefixOf` l <span class="token3">=</span> secondWord l <span class="token">:</span> ds
          <span class="token3">|</span> otherwise                     <span class="token3">=</span> ds
        secondWord <span class="token3">=</span> head <span class="token">.</span> tail <span class="token">.</span> words

</code></pre>
<p class="calibre9">程序通过守卫表达式来过滤输入：如果输入字符串符合给定格式，就将它加入到结果列表里；否则，就略过这个字符串，继续处理剩余的输入字符串。</p>
<p class="calibre9">至于 secondWord 函数，它先取出一个列表的 tail 部分，得出一个新列表。再取出新列表的 head 部分，等同于取出一个列表的第二个元素。</p>
<p class="calibre9">[译注：书本的这个程序弱爆了，以下是 dlts 的一个更直观的版本，它使用 filter 来过滤输入，只保留符合格式的输入，而不是使用复杂且难看的显式递归和守卫来进行过滤：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>dlts2<span class="token">.</span>hs

import Data<span class="token">.</span>List <span class="token">(</span>isPrefixOf<span class="token">)</span>

dlts2 <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>String<span class="token">]</span>
dlts2 <span class="token3">=</span> map <span class="token">(</span>head <span class="token">.</span> tail <span class="token">.</span> words<span class="token">)</span> <span class="token">.</span> filter <span class="token">(</span><span class="token4">"#define DLT_"</span> `isPrefixOf`<span class="token">)</span> <span class="token">.</span> lines

</code></pre>
<p class="calibre9">]</p>
<h2 class="calibre14"><a id="chp-4.html._1276" class="calibre7 pcalibre"></a>编写可读代码的提示</h2>
<p class="calibre9">目前为止，我们知道 Haskell 有两个非常诱人的特性：尾递归和匿名函数。但是，这两个特性通常并不被使用。</p>
<p class="calibre9">对列表的处理操作一般可以通过组合库函数比如 map 、 take 和 filter 来进行。当然，熟悉这些库函数需要一定的时间，不过掌握这些函数之后，就可以使用它们写出更快更好更少 bug 的代码。</p>
<p class="calibre9">库函数比尾递归更好的原因很简单：尾递归和命令式语言里的 loop 有同样的问题 —— 它们太通用（general）了。在一个尾递归里，你可以同时执行过滤（filtering）、映射（mapping）和其他别的动作。这强迫代码的阅读者（可能是你自己）必须弄懂整个递归函数的定义，才能理解这个函数到底做了些什么。与此相反，map 和其他很多列表函数，都只专注于做<em class="calibre13">一件</em>事。通过这些函数，我们可以很快理解某段代码到底做了什么，以及整个程序想表达什么意思，而不是将时间浪费在关注细节方面。</p>
<p class="calibre9">折叠（fold）操作处于（完全通用化的）尾递归和（只做一件事的）列表处理函数之间的中间地带。折叠也很值得我们花时间去好好理解，它的作用跟组合起 map 和 filter 函数差不多，但比起显式递归来说，折叠的行为要来得更有规律，而且更可控。一般来说，可以通过组合函数来解决的问题，就不要使用折叠。另一方面，如果问题用组合函数没办法解决，那么使用折叠要比使用显式递归要好。</p>
<p class="calibre9">另一方面，匿名函数通常会对代码的可读性造成影响。一般来说，匿名函数都可以用 let 或者 where 定义的局部函数来代替。而且带名字的局部函数可以达到一箭双雕的效果：它使得代码更具可读性，且函数名本身也达到了文档化的作用。</p>
<h2 class="calibre14"><a id="chp-4.html._1288" class="calibre7 pcalibre"></a>内存泄漏和严格求值</h2>
<p class="calibre9">前面介绍的 foldl 函数并不是 Haskell 代码里唯一会造成内存泄漏的地方。</p>
<p class="calibre9">在这一节，我们使用 foldl 来展示非严格求值在什么情况下会造成问题，以及如何去解决这些问题。</p>
<h2 class="calibre14"><a id="chp-4.html._seq__1294" class="calibre7 pcalibre"></a>通过 seq 函数避免内存泄漏</h2>
<p class="calibre9">我们称非惰性求值的表达式为<em class="calibre13">严格的</em>（strict）。 foldl' 就是左折叠的严格版本，它使用特殊的 seq 函数来绕过 Haskell 默认的非严格求值：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch04<span class="token3">/</span>strictFoldl<span class="token">.</span>hs

foldl' _ zero <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> zero
foldl' step zero <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span> 
    let <span class="token1">new</span> <span class="token3">=</span> step zero x
    <span class="token1">in</span> <span class="token1">new</span> `seq` foldl' step <span class="token1">new</span> <span class="token5">xs</span>

</code></pre>
<p class="calibre9">seq 函数的类型签名和之前看过的函数都有些不同，昭示了它的特殊身份：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type seq
seq <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> t <span class="token3">-</span><span class="token3">&gt;</span> t

</code></pre>
<p class="calibre9">[译注：在 7.4.2 版本的 GHCi 里， seq 函数的类型签名不再使用 t ，而是像其他函数一样，使用 a 和 b 。</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>type seq
seq <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> b <span class="token3">-</span><span class="token3">&gt;</span> b

</code></pre>
<p class="calibre9">]</p>
<p class="calibre9">实际上， seq 函数的行为并没有那么神秘：它强迫（force）求值传入的第一个参数，然后返回它的第二个参数。</p>
<p class="calibre9">比如说，对于以下表达式：</p>
<pre class="calibre15"><code class="tthhighlight-container">foldl' <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token2">1</span> <span class="token">(</span><span class="token2">2</span><span class="token">:</span><span class="token">[</span><span class="token">]</span><span class="token">)</span>

</code></pre>
<p class="calibre9">它展开为：</p>
<pre class="calibre15"><code class="tthhighlight-container">let <span class="token1">new</span> <span class="token3">=</span> <span class="token2">1</span> <span class="token3">+</span> <span class="token2">2</span>
<span class="token1">in</span> <span class="token1">new</span> `seq` foldl' <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token1">new</span> <span class="token">[</span><span class="token">]</span>

</code></pre>
<p class="calibre9">它强迫 new 求值为 3 ，然后返回它的第二个参数：</p>
<pre class="calibre15"><code class="tthhighlight-container">foldl' <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token2">3</span> <span class="token">[</span><span class="token">]</span>

</code></pre>
<p class="calibre9">最终得到结果 3 。</p>
<p class="calibre9">因为 seq 的存在，这个创建过程没有用到任何块。</p>
<h2 class="calibre14"><a id="chp-4.html.seq__1354" class="calibre7 pcalibre"></a>seq 的用法</h2>
<p class="calibre9">本节介绍一些更有效地使用 seq 的指导规则。</p>
<p class="calibre9">要正确地产生 seq 的作用，表达式中被求值的第一个必须是 seq ：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> 错误：因为表达式中第一个被求值的是 someFunc 而不是 seq
<span class="token3">--</span> 所以 seq 的调用被隐藏了在 someFunc 调用之下
hiddenInside x y <span class="token3">=</span> someFunc <span class="token">(</span>x `seq` y<span class="token">)</span>

<span class="token3">--</span> 错误：原因和上面一样
hiddenByLet x y z <span class="token3">=</span> let a <span class="token3">=</span> x `seq` someFunc y
                    <span class="token1">in</span> anotherFunc a z

<span class="token3">--</span> 正确： seq 被第一个求值，并且 x 被强迫求值
onTheOutside x y <span class="token3">=</span> x `seq` someFunc y

</code></pre>
<p class="calibre9">为了严格求值多个值，可以连接起 seq 调用：</p>
<pre class="calibre15"><code class="tthhighlight-container">chained x y z <span class="token3">=</span> x `seq` y `seq` someFunc z

</code></pre>
<p class="calibre9">一个常见错误是，将 seq 用在没有关联的连个表达式上面：</p>
<pre class="calibre15"><code class="tthhighlight-container">badExpression step zero <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span>
    seq <span class="token">(</span>step zero x<span class="token">)</span>
            <span class="token">(</span>badExpression step <span class="token">(</span>step zero x<span class="token">)</span> xs<span class="token">)</span>

</code></pre>
<p class="calibre9">stepzerox 分别出现在 seq 的第一个参数和 badExpression 的表达式内， seq 只会对第一个 stepzerox 求值，而它的结果并不会影响 badExpression 表达式内的 stepzerox 。正确的用法应该是用一个 let 结果保存起 stepzerox 表达式，然后将它分别传给 seq 和 badExpression ，做法可以参考前面的 foldl' 的定义。</p>
<p class="calibre9">seq 在遇到像数字这样的值时，它会对值进行求值，但是，一旦 seq 碰到构造器，比如 (:) 或者 (,) ，那么 seq 的求值就会停止。举个例子，如果将 (1+2):[] 传给 seq 作为它的第一个参数，那么 seq 不会对这个表达式进行求值；相反，如果将 1 传给 seq 作为第一个参数，那么它会被求值为 1 。</p>
<p class="calibre9">[译注：</p>
<p class="calibre9">原文说，对于 (1+2):[] 这样的表达式， seq 在求值 (1+2) 之后，碰到 : ，然后停止求值。但是根据原文网站上的评论者测试， seq 并不会对 (1+2) 求值，而是在碰到 (1+2):[] 时就直接停止求值。</p>
<p class="calibre9">这一表现可能的原因如下：虽然 : 是中序操作符，但它实际上只是函数 (:) ，而 Haskell 的函数总是前序的，因此 (1+2):[] 实际上应该表示为 (:)(1+2)[] ，所以原文说“seq 在碰到构造器时就会停止求值”这一描述并没有出错，只是给的例子出了问题。</p>
<p class="calibre9">因为以上原因，这里对原文进行了修改。</p>
<p class="calibre9">]</p>
<p class="calibre9">如果有需要的话，也可以绕过这些限制：</p>
<pre class="calibre15"><code class="tthhighlight-container">strictPair <span class="token">(</span>a<span class="token">,</span>b<span class="token">)</span> <span class="token3">=</span> a `seq` b `seq` <span class="token">(</span>a<span class="token">,</span>b<span class="token">)</span>

strictList <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span> x `seq` x <span class="token">:</span> strictList xs
strictList <span class="token">[</span><span class="token">]</span>     <span class="token3">=</span> <span class="token">[</span><span class="token">]</span>

</code></pre>
<p class="calibre9">seq 的使用并不是无成本的，知道这一点很重要：它需要在运行时检查输入值是否已经被求值。必须谨慎使用 seq 。比如说，上面定义的 strictPair ，尽管它能顺利对元组进行强制求值，但它在求值元组所需的计算量上，加上了一次模式匹配、两次 seq 调用和一次构造新元组的计算量。如果我们检测这个函数的性能的话，就会发现它降低了程序的处理速度。</p>
<p class="calibre9">即使不考虑性能的问题， seq 也不是处理内存泄漏的万能药。可以进行非严格求值，但并不意味着非用它不可。对 seq 的不小心使用可能对内存泄漏并没有帮助，在更糟糕的情况下，它还会造成新的内存泄漏。</p>
<p class="calibre9">第二十五章会介绍关于性能和优化的内容，到时会说明跟多 seq 的用法和细节。</p>
</div></div></div></div></div></div>
<div id="chp-5.html"><div class="calibre">
<div id="chp-5.html.main" class="calibre1"><div class="root"><div class="article"><h1 class="article-head" id="chp-5.html.calibre_toc_5">第五章：编写 JSON 库</h1><div class="article-body"><h1 class="calibre6"><a id="chp-5.html._JSON__0" class="calibre7 pcalibre"></a>第五章：编写 JSON 库</h1>
<h2 class="calibre8"><a id="chp-5.html.JSON__2" class="calibre7 pcalibre"></a>JSON 简介</h2>
<p class="calibre9">在这一章，我们将开发一个小而完整的 Haskell 库，这个库用于处理和序列化 JSON 数据。</p>
<p class="calibre9">JSON （JavaScript 对象符号）是一种小型、表示简单、便于存储和发送的语言。它通常用于从 web 服务向基于浏览器的 JavaScript 程序传送数据。JSON 的格式由 <a href="#chp-5.html." class="calibre7 pcalibre">www.json.org</a> 描述，而细节由 <a href="http://www.ietf.org/rfc/rfc4627.txt" target="_blank" class="calibre7 pcalibre">RFC 4627</a> [<a href="http://www.ietf.org/rfc/rfc4627.txt" target="_blank" class="calibre7 pcalibre">http://www.ietf.org/rfc/rfc4627.txt</a>] 补充。</p>
<p class="calibre9">JSON 支持四种基本类型值：字符串、数字、布尔值和一个特殊值， null 。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token4">"a string"</span>

<span class="token2">12345</span>

<span class="token2">true</span>

<span class="token1">null</span>

</code></pre>
<p class="calibre9">JSON 还提供了两种复合类型：<em class="calibre13">数组</em>是值的有序序列，而<em class="calibre13">对象</em>则是“名字/值”对的无序收集器（unordered collection of name/value pairs）。其中对象的名字必须是字符串，而对象和数组的值则可以是任何 JSON 类型。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token">[</span><span class="token3">-</span><span class="token2">3.14</span><span class="token">,</span> <span class="token2">true</span><span class="token">,</span> <span class="token1">null</span><span class="token">,</span> <span class="token4">"a string"</span><span class="token">]</span>

<span class="token">{</span><span class="token4">"numbers"</span><span class="token">:</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">,</span><span class="token2">4</span><span class="token">,</span><span class="token2">5</span><span class="token">]</span><span class="token">,</span> <span class="token4">"useful"</span><span class="token">:</span> <span class="token2">false</span><span class="token">}</span>

</code></pre>
<h2 class="calibre14"><a id="chp-5.html._Haskell__JSON__30" class="calibre7 pcalibre"></a>在 Haskell 中表示 JSON 数据</h2>
<p class="calibre9">要在 Haskell 中处理 JSON 数据，可以用一个代数数据类型来表示 JSON 的各个数据类型：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>SimpleJSON<span class="token">.</span>hs
data JValue <span class="token3">=</span> JString String
            <span class="token3">|</span> JNumber Double
            <span class="token3">|</span> JBool Bool
            <span class="token3">|</span> JNull
            <span class="token3">|</span> JObject <span class="token">[</span><span class="token">(</span>String<span class="token">,</span> JValue<span class="token">)</span><span class="token">]</span>
            <span class="token3">|</span> JArray <span class="token">[</span>JValue<span class="token">]</span>
              deriving <span class="token">(</span>Eq<span class="token">,</span> Ord<span class="token">,</span> Show<span class="token">)</span>

</code></pre>
<p class="calibre9">[译注：这里的 JObject[(String,JValue)] 不能改为 JObject[(JString,JValue)] ，因为值构造器里面声明的是类构造器，不能是值构造器。</p>
<p class="calibre9">另外，严格来说， JObject 并不是完全无序的，因为它的定义使用了列表来包围，在书本的后面会介绍 Map 类型，它可以创建一个无序的键-值对结构。]</p>
<p class="calibre9">对于每个 JSON 类型，代码都定义了一个单独的值构造器。部分构造器带有参数，比如说，如果你要创建一个 JSON 字符串，那么就要给 JString 值构造器传入一个 String 类型值作为参数。</p>
<p class="calibre9">将这些定义载入到 ghci 试试看：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load SimpleJSON
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> SimpleJSON<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> JString <span class="token4">"the quick brown fox"</span>
JString <span class="token4">"the quick brown fox"</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> JNumber <span class="token2">3.14</span>
JNumber <span class="token2">3.14</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> JBool True
JBool True

<span class="token3">*</span>Main<span class="token3">&gt;</span> JNull
JNull

<span class="token3">*</span>Main<span class="token3">&gt;</span> JObject <span class="token">[</span><span class="token">(</span><span class="token4">"language"</span><span class="token">,</span> JString <span class="token4">"Haskell"</span><span class="token">)</span><span class="token">,</span> <span class="token">(</span><span class="token4">"complier"</span><span class="token">,</span> JString <span class="token4">"GHC"</span><span class="token">)</span><span class="token">]</span>
JObject <span class="token">[</span><span class="token">(</span><span class="token4">"language"</span><span class="token">,</span>JString <span class="token4">"Haskell"</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token4">"complier"</span><span class="token">,</span>JString <span class="token4">"GHC"</span><span class="token">)</span><span class="token">]</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> JArray <span class="token">[</span>JString <span class="token4">"Haskell"</span><span class="token">,</span> JString <span class="token4">"Clojure"</span><span class="token">,</span> JString <span class="token4">"Python"</span><span class="token">]</span>
JArray <span class="token">[</span>JString <span class="token4">"Haskell"</span><span class="token">,</span>JString <span class="token4">"Clojure"</span><span class="token">,</span>JString <span class="token4">"Python"</span><span class="token">]</span>

</code></pre>
<p class="calibre9">前面代码中的构造器将一个 Haskell 值转换为一个 JValue 。反过来，同样可以通过模式匹配，从 JValue 中取出 Haskell 值。</p>
<p class="calibre9">以下函数试图从一个 JString 值中取出一个 Haskell 字符串：如果 JValue 真的包含一个字符串，那么程序返回一个用 Just 构造器包裹的字符串；否则，它返回一个 Nothing 。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>SimpleJSON<span class="token">.</span>hs
getString <span class="token">:</span><span class="token">:</span> JValue <span class="token3">-</span><span class="token3">&gt;</span> Maybe String
getString <span class="token">(</span>JString s<span class="token">)</span> <span class="token3">=</span> Just s
getString _           <span class="token3">=</span> Nothing

</code></pre>
<p class="calibre9">保存修改过的源码文件，然后使用 :reload 命令重新载入 SimpleJSON.hs 文件（:reload 会自动记忆最近一次载入的文件）：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>reload
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> SimpleJSON<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> getString <span class="token">(</span>JString <span class="token4">"hello"</span><span class="token">)</span>
Just <span class="token4">"hello"</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> getString <span class="token">(</span>JNumber <span class="token2">3</span><span class="token">)</span>
Nothing

</code></pre>
<p class="calibre9">再加上一些其他函数，初步完成一些基本功能：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>SimpleJSON<span class="token">.</span>hs
getInt <span class="token">(</span>JNumber n<span class="token">)</span> <span class="token3">=</span> Just <span class="token">(</span>truncate n<span class="token">)</span>
getInt _           <span class="token3">=</span> Nothing

getBool <span class="token">(</span>JBool b<span class="token">)</span> <span class="token3">=</span> Just b
getBool _         <span class="token3">=</span> Nothing

getObject <span class="token">(</span>JObject o<span class="token">)</span> <span class="token3">=</span> Just o
getObject _           <span class="token3">=</span> Nothing

getArray <span class="token">(</span>JArray a<span class="token">)</span> <span class="token3">=</span> Just a
getArray _          <span class="token3">=</span> Nothing

isNull v            <span class="token3">=</span> v <span class="token3">==</span> JNull

</code></pre>
<p class="calibre9">truncate 函数返回浮点数或者有理数的整数部分：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> truncate <span class="token2">5.8</span>
<span class="token2">5</span>

Prelude<span class="token3">&gt;</span> <span class="token">:</span>module <span class="token3">+</span>Data<span class="token">.</span>Ratio

Prelude Data<span class="token">.</span>Ratio<span class="token3">&gt;</span> truncate <span class="token">(</span><span class="token2">22</span> <span class="token3">%</span> <span class="token2">7</span><span class="token">)</span>
<span class="token2">3</span>

</code></pre>
<p class="calibre9">Haskell 模块 一个 Haskell 文件可以包含一个模块定义，模块可以决定模块中的哪些名字可以被外部访问。 模块的定义必须放在其它定义之前：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>SimpleJSON<span class="token">.</span>hs
module SimpleJSON
    <span class="token">(</span>
        <span class="token5">JValue</span><span class="token">(</span><span class="token">.</span><span class="token">.</span><span class="token">)</span>
    <span class="token">,</span>   getString
    <span class="token">,</span>   getInt
    <span class="token">,</span>   getDouble
    <span class="token">,</span>   getBool
    <span class="token">,</span>   getObject
    <span class="token">,</span>   getArray
    <span class="token">,</span>   isNull
    <span class="token">)</span> where

</code></pre>
<p class="calibre9">单词 module 是保留字，跟在它之后的是模块的名字：模块名字必须以大写字母开头，并且它必须和包含这个模块的文件的基础名（不包含后缀的文件名）一致。比如上面定义的模块就以 SimpleJSON 命名，因为包含它的文件名为 SimpleJSON.hs 。</p>
<p class="calibre9">在模块名之后，用括号包围的是<em class="calibre13">导出</em>列表（list of exports）。 where 关键字之后的内容为模块的体。</p>
<p class="calibre9">导出列表决定模块中的哪些名字对于外部模块是可见的，使得私有代码可以隐藏在模块的内部。跟在 JValue 之后的 (..) 符号表示导出 JValue 类型以及它的所有值构造器。</p>
<p class="calibre9">事实上，模块甚至可以只导出类型的名字（类构造器），而不导出这个类型的值构造器。这种能力非常重要：它允许模块对用户隐藏类型的细节，将一个类型变得<em class="calibre13">抽象</em>。如果用户看不见类型的值构造器，他就没办法对类型的值进行模式匹配，也不能使用值构造器显式创建这种类型的值[译注：只能通过相应的 API 来创建这种类型的值]。本章稍后会说明，在什么情况下，我们需要将一个类型变得抽象。</p>
<p class="calibre9">如果省略掉模块定义中的导出部分，那么所有名字都会被导出：</p>
<pre class="calibre15"><code class="tthhighlight-container">module ExportEverything where

</code></pre>
<p class="calibre9">如果不想导出模块中的任何名字（通常不会这么用），那么可以将导出列表留空，仅保留一对括号：</p>
<pre class="calibre15"><code class="tthhighlight-container">module ExportNothing <span class="token">(</span><span class="token">)</span> where

</code></pre>
<h2 class="calibre14"><a id="chp-5.html._Haskell__178" class="calibre7 pcalibre"></a>编译 Haskell 代码</h2>
<p class="calibre9">除了 ghci 之外， GHC 还包括一个生成本地码（native code）的编译器： ghc 。如果你熟悉 gcc 或者 cl （微软 Visual Studio 使用的 C++ 编译器组件）之类的编译器，那么你对 ghc 应该不会感到陌生。</p>
<p class="calibre9">编译一个 Haskell 源码文件可以通过 ghc 命令来完成：</p>
<pre class="calibre15"><code class="tthhighlight-container">$ ghc <span class="token3">-</span>c SimpleJSON<span class="token">.</span>hs

$ ls
SimpleJSON<span class="token">.</span>hi  SimpleJSON<span class="token">.</span>hs  SimpleJSON<span class="token">.</span>o

</code></pre>
<p class="calibre9">-c 表示让 ghc 只生成目标代码。如果省略 -c 选项，那么 ghc 就会试图生成一个完整的可执行文件，这会失败，因为目前的 SimpleJSON.hs 还没有定义 main 函数，而 GHC 在执行一个独立程序时会调用这个 main 函数。</p>
<p class="calibre9">在编译完成之后，会生成两个新文件。其中 SimpleJSON.hi 是<em class="calibre13">接口文件</em>（interface file）， ghc 以机器可读的格式，将模块中导出名字的信息保存在这个文件。而 SimpleJSON.o 则是<em class="calibre13">目标文件</em>（object file），它包含了已生成的机器码。</p>
<h2 class="calibre14"><a id="chp-5.html._196" class="calibre7 pcalibre"></a>载入模块和生成可执行文件</h2>
<p class="calibre9">既然已经成功编译了 SimpleJSON 库，是时候写个小程序来执行它了。打开编辑器，将以下内容保存为 Main.hs ：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Main<span class="token">.</span>hs

module Main <span class="token">(</span>main<span class="token">)</span> where

import SimpleJSON

main <span class="token3">=</span> print <span class="token">(</span>JObject <span class="token">[</span><span class="token">(</span><span class="token4">"foo"</span><span class="token">,</span> JNumber <span class="token2">1</span><span class="token">)</span><span class="token">,</span> <span class="token">(</span><span class="token4">"bar"</span><span class="token">,</span> JBool False<span class="token">)</span><span class="token">]</span><span class="token">)</span>

</code></pre>
<p class="calibre9">[译注：原文说，可以不导出 main 函数，但是实际中测试这种做法并不能通过编译。]</p>
<p class="calibre9">放在模块定义之后的 import 表示载入所有 SimpleJSON 模块导出的名字，使得它们在 Main 模块中可用。</p>
<p class="calibre9">所有 import 指令（directive）都必须出现在模块的开头，并且位于其他模块代码之前。不可以随意摆放 import 。</p>
<p class="calibre9">Main.hs 的名字和 main 函数的命名是有特别含义的，要创建一个可执行文件， ghc 需要一个命名为 Main 的模块，并且这个模块里面还要有一个 main 函数，而 main 函数在程序执行时会被调用。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghc <span class="token3">-</span>o simple Main<span class="token">.</span>hs

</code></pre>
<p class="calibre9">这次编译没有使用 -c 选项，因此 ghc 会尝试生成一个可执行程序，这个过程被称为<em class="calibre13">链接</em>（linking）。ghc 可以在一条命令中同时完成编译和链接的任务。</p>
<p class="calibre9">-o 选项用于指定可执行程序的名字。在 Windows 平台下，它会生成一个 .exe 后缀的文件，而 UNIX 平台的文件则没有后缀。</p>
<p class="calibre9">ghc 会自动找到所需的文件，进行编译和链接，然后产生可执行文件，我们唯一要做的就是提供 Main.hs 文件。</p>
<p class="calibre9">[译注：在原文中说到，编译时必须手动列出所有相关文件，但是在新版 GHC 中，编译时提供 Main.hs 就可以了，编译器会自动找到、编译和链接相关代码。因此，本段内容做了相应的修改。]</p>
<p class="calibre9">一旦编译完成，就可以运行编译所得的可执行文件了：</p>
<pre class="calibre15"><code class="tthhighlight-container">$ <span class="token">.</span><span class="token3">/</span>simple
JObject <span class="token">[</span><span class="token">(</span><span class="token4">"foo"</span><span class="token">,</span>JNumber <span class="token2">1.0</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token4">"bar"</span><span class="token">,</span>JBool False<span class="token">)</span><span class="token">]</span>

</code></pre>
<h2 class="calibre14"><a id="chp-5.html._JSON__240" class="calibre7 pcalibre"></a>打印 JSON 数据</h2>
<p class="calibre9">SimpleJSON 模块已经有了 JSON 类型的表示了，那么下一步要做的就是将 Haskell 值翻译（render）成 JSON 数据。</p>
<p class="calibre9">有好几种方法可以将 Haskell 值翻译成 JSON 数据，最直接的一种是编写翻译函数，以 JSON 格式来打印 Haskell 值。稍后会介绍完成这个任务的其他更有趣方法。</p>
<pre class="calibre15"><code class="tthhighlight-container">module PutJSON where

import Data<span class="token">.</span>List <span class="token">(</span>intercalate<span class="token">)</span>
import SimpleJSON

renderJValue <span class="token">:</span><span class="token">:</span> JValue <span class="token3">-</span><span class="token3">&gt;</span> String

renderJValue <span class="token">(</span>JString s<span class="token">)</span>   <span class="token3">=</span> show s
renderJValue <span class="token">(</span>JNumber n<span class="token">)</span>   <span class="token3">=</span> show n
renderJValue <span class="token">(</span>JBool True<span class="token">)</span>  <span class="token3">=</span> <span class="token4">"true"</span>
renderJValue <span class="token">(</span>JBool False<span class="token">)</span> <span class="token3">=</span> <span class="token4">"false"</span>
renderJValue JNull         <span class="token3">=</span> <span class="token4">"null"</span>

renderJValue <span class="token">(</span>JObject o<span class="token">)</span> <span class="token3">=</span> <span class="token4">"{"</span> <span class="token3">++</span> pairs o <span class="token3">++</span> <span class="token4">"}"</span>
  where pairs <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> <span class="token4">""</span>
    pairs ps <span class="token3">=</span> intercalate <span class="token4">", "</span> <span class="token">(</span>map renderPair ps<span class="token">)</span>
    renderPair <span class="token">(</span>k<span class="token">,</span>v<span class="token">)</span>   <span class="token3">=</span> show k <span class="token3">++</span> <span class="token4">": "</span> <span class="token3">++</span> renderJValue v

renderJValue <span class="token">(</span>JArray a<span class="token">)</span> <span class="token3">=</span> <span class="token4">"["</span> <span class="token3">++</span> values a <span class="token3">++</span> <span class="token4">"]"</span>
  where values <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> <span class="token4">""</span>
    values vs <span class="token3">=</span> intercalate <span class="token4">", "</span> <span class="token">(</span>map renderJValue vs<span class="token">)</span>

</code></pre>
<p class="calibre9">分割纯代码和带有 IO 的代码是一种良好的 Haskell 风格。这里我们用 putJValue 来进行打印操作，这样就不会影响 renderJValue 的纯洁性：</p>
<pre class="calibre15"><code class="tthhighlight-container">putJValue <span class="token">:</span><span class="token">:</span> JValue <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
putJValue v <span class="token3">=</span> putStrLn <span class="token">(</span>renderJValue v<span class="token">)</span>

</code></pre>
<p class="calibre9">现在打印 JSON 值变得容易得多了：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude SimpleJSON<span class="token3">&gt;</span> <span class="token">:</span>load PutJSON
<span class="token">[</span><span class="token2">2</span> of <span class="token2">2</span><span class="token">]</span> Compiling PutJSON          <span class="token">(</span> PutJSON<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> PutJSON<span class="token">,</span> SimpleJSON<span class="token">.</span>

<span class="token3">*</span>PutJSON<span class="token3">&gt;</span> putJValue <span class="token">(</span>JString <span class="token4">"a"</span><span class="token">)</span>
<span class="token4">"a"</span>

<span class="token3">*</span>PutJSON<span class="token3">&gt;</span> putJValue <span class="token">(</span>JBool True<span class="token">)</span>
<span class="token2">true</span>

</code></pre>
<p class="calibre9">除了风格上的考虑之外，将翻译代码和实际打印代码分开，也有助于提升灵活性。比如说，如果想在数据写出之前进行压缩，那么只需要修改 putJValue 就可以了，不必改动整个 renderJValue 函数。</p>
<p class="calibre9">将纯代码和不纯代码分离的理念非常强大，并且在 Haskell 代码中无处不在。现有的一些 Haskell 压缩模块，它们都拥有简单的接口：压缩函数接受一个未压缩的字符串，并返回一个压缩后的字符串。通过组合使用不同的函数，可以在打印 JSON 值之前，对数据进行各种不同的处理。</p>
<h2 class="calibre14"><a id="chp-5.html._298" class="calibre7 pcalibre"></a>类型推导是一把双刃剑</h2>
<p class="calibre9">Haskell 编译器的类型推导能力非常强大也非常有价值。在刚开始的时候，我们通常会倾向于尽可能地省略所有类型签名，让类型推导去决定所有函数的类型定义。</p>
<p class="calibre9">但是，这种做法是有缺陷的，它通常是 Haskell 新手引发类型错误的主要来源。</p>
<p class="calibre9">如果我们省略显式的类型信息时，那么编译器就必须猜测我们的意图：它会推导出合乎逻辑且相容的（consistent）类型，但是，这些类型可能并不是我们想要的。一旦程序员和编译器之间的想法产生了分歧，那么寻找 bug 的工作就会变得更困难。</p>
<p class="calibre9">作为例子，假设有一个函数，它预计会返回 String 类型的值，但是没有显式地为它编写类型签名：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Trouble<span class="token">.</span>hs

import Data<span class="token">.</span>Char <span class="token">(</span>toUpper<span class="token">)</span>

upcaseFirst <span class="token">(</span>c<span class="token">:</span>cs<span class="token">)</span> <span class="token3">=</span> toUpper c  <span class="token3">--</span> 这里忘记了 <span class="token4">":cs"</span>

</code></pre>
<p class="calibre9">这个函数试图将输入单词的第一个字母设置为大写，但是它在设置之后，忘记了重新拼接字符串的后续部分 xs 。在我们的预想中，这个函数的类型应该是 String-&gt;String ，但编译器推导出的类型却是 String-&gt;Char 。</p>
<p class="calibre9">现在，有另一个函数调用这个 upcaseFirst 函数：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Trouble<span class="token">.</span>hs

camelCase <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> String
camelCase xs <span class="token3">=</span> concat <span class="token">(</span>map upcaseFirst <span class="token">(</span>words xs<span class="token">)</span><span class="token">)</span>

</code></pre>
<p class="calibre9">这段代码在载入 ghci 时会发生错误：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load Trouble<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> Trouble<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>

Trouble<span class="token">.</span>hs<span class="token">:</span><span class="token2">8</span><span class="token">:</span><span class="token2">28</span><span class="token">:</span>
    Couldn<span class="token4">'t match expected type `[Char]'</span> with actual type `Char'
    Expected type<span class="token">:</span> <span class="token">[</span>Char<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>Char<span class="token">]</span>
        Actual type<span class="token">:</span> <span class="token">[</span>Char<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Char
    In the first argument of `map<span class="token4">', namely `upcaseFirst'</span>
    In the first argument of `concat<span class="token4">', namely            `(map upcaseFirst (words xs))'</span>
Failed<span class="token">,</span> modules loaded<span class="token">:</span> none<span class="token">.</span>

</code></pre>
<p class="calibre9">请注意，如果不是 upcaseFirst 被其他函数所调用的话，它的错误可能并不会被发现！相反，如果我们之前为 upcaseFirst 编写了类型签名的话，那么 upcaseFirst 的类型错误就会立即被捕捉到，并且可以即刻定位出错误发生的位置。 为函数编写类型签名，既可以移除我们实际想要的类型和编译器推导出的类型之间的分歧，也可以作为函数的一种文档，帮助阅读和理解函数的行为。 这并不是说要巨细无遗地为所有函数都编写类型签名。不过，为所有顶层（top-level）函数添加类型签名通常是一种不错的做法。在刚开始的时候最好尽可能地为函数添加类型签名，然后随着对类型系统了解的加深，逐步放松要求。<br class="calibre1"><br>
更通用的转换方式 在前面构造 SimpleJSON 库时，我们的目标主要是按照 JSON 的格式，将 Haskell 数据转换为 JSON 值。而这些转换所得值的输出可能并不是那么适合人去阅读。有一些被称为美观打印器（pretty printer）的库，它们的输出既适合机器读入，也适合人类阅读。我们这就来编写一个美观打印器，学习库设计和函数式编程的相关技术。 这个美观打印器库命名为 Prettify ，它被包含在 Prettify.hs 文件里。为了让 Prettify 适用于实际需求，我们先编写一个新的 JSON 转换器，它使用 Prettify 提供的 API 。等完成这个 JSON 转换器之后，再转过头来补充 Prettify 模块的细节。 和前面的 SimpleJSON 模块不同，Prettify 模块将数据转换为一种称为 Doc 类型的抽象数据，而不是字符串：抽象类型允许我们随意选择不同的实现，最大化灵活性和效率，而且在更改实现时，不会影响到用户。 新的 JSON 转换模块被命名为 PrettyJSON.hs ，转换的工作依然由 renderJValue 函数进行，它的定义和之前一样简单直观：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>PrettyJSON<span class="token">.</span>hs
renderJValue <span class="token">:</span><span class="token">:</span> JValue <span class="token3">-</span><span class="token3">&gt;</span> Doc
renderJValue <span class="token">(</span>JBool True<span class="token">)</span>  <span class="token3">=</span> text <span class="token4">"true"</span>
renderJValue <span class="token">(</span>JBool False<span class="token">)</span> <span class="token3">=</span> text <span class="token4">"false"</span>
renderJValue JNull         <span class="token3">=</span> text <span class="token4">"null"</span>
renderJValue <span class="token">(</span>JNumber num<span class="token">)</span> <span class="token3">=</span> double num
renderJValue <span class="token">(</span>JString str<span class="token">)</span> <span class="token3">=</span> string str

</code></pre>
<p class="calibre9">其中 text 、 double 和 string 都由 Prettify 模块提供。</p>
<h2 class="calibre14"><a id="chp-5.html.Haskell__359" class="calibre7 pcalibre"></a>Haskell 开发诀窍</h2>
<p class="calibre9">在刚开始进行 Haskell 开发的时候，通常需要面对大量崭新、不熟悉的概念，要一次性完成程序的编写，并顺利通过编译器检查，难度非常的高。</p>
<p class="calibre9">在每次完成一个功能点时，花几分钟停下来，对程序进行编译，是非常有益的：因为 Haskell 是强类型语言，如果程序能成功通过编译，那么说明程序和我们预想中的目标相去不远。</p>
<p class="calibre9">编写函数和类型的占位符（placeholder）版本，对于快速原型开发非常有效。举个例子，前文断言， string 、 text 和 double 函数都由 Prettify 模块提供，如果 Prettify 模块里不定义这些函数，或者不定义 Doc 类型，那么对程序的编译就会失败，我们的“早编译，常编译”战术就没有办法施展。通过编写占位符代码，可以避免这些问题：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>PrettyStub<span class="token">.</span>hs
import SimpleJSON

data Doc <span class="token3">=</span> ToBeDefined
         deriving <span class="token">(</span>Show<span class="token">)</span>

 string <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> Doc
 string str <span class="token3">=</span> undefined

 text <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> Doc
 text str <span class="token3">=</span> undefined

 double <span class="token">:</span><span class="token">:</span> Double <span class="token3">-</span><span class="token3">&gt;</span> Doc
 double num <span class="token3">=</span> undefined

</code></pre>
<p class="calibre9">特殊值 undefined 的类型为 a ，因此它可以让代码顺利通过类型检查。因为它只是一个占位符，没有什么实际作用，所以对它进行求值只会产生错误：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type undefined
undefined <span class="token">:</span><span class="token">:</span> a

<span class="token3">*</span>Main<span class="token3">&gt;</span> undefined
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> Prelude<span class="token">.</span>undefined

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>load PrettyStub<span class="token">.</span>hs
<span class="token">[</span><span class="token2">2</span> of <span class="token2">2</span><span class="token">]</span> Compiling Main             <span class="token">(</span> PrettyStub<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">,</span> SimpleJSON<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type double
double <span class="token">:</span><span class="token">:</span> Double <span class="token3">-</span><span class="token3">&gt;</span> Doc

<span class="token3">*</span>Main<span class="token3">&gt;</span> double <span class="token2">3.14</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> Prelude<span class="token">.</span>undefined

</code></pre>
<p class="calibre9">尽管程序里还没有任何实际可执行的代码，但是编译器的类型检查器可以保证程序中类型的正确性，这为接下来的进一步开发奠定了良好基础。</p>
<p class="calibre9">[译注：原文中 PrettyStub.hs 和 Prettify.hs 混合使用，给读者阅读带来了很大麻烦。为了避免混淆，下文统一在 Prettify.hs中书写代码，并列出编译通过所需要的占位符代码。随着文章进行，读者只要不断将占位符版本替换为可用版本即可。]</p>
<h2 class="calibre14"><a id="chp-5.html._410" class="calibre7 pcalibre"></a>美观打印字符串</h2>
<p class="calibre9">当需要美观地打印字符串时，我们需要遵守 JSON 的转义规则。字符串，顾名思义，仅仅是一串被包含在引号中的字符而已。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Prettify<span class="token">.</span>hs
string <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> Doc
string <span class="token3">=</span> enclose <span class="token4">'"'</span> <span class="token4">'"'</span> <span class="token">.</span> hcat <span class="token">.</span> map oneChar

enclose <span class="token">:</span><span class="token">:</span> Char <span class="token3">-</span><span class="token3">&gt;</span> Char <span class="token3">-</span><span class="token3">&gt;</span> Doc <span class="token3">-</span><span class="token3">&gt;</span> Doc
enclose left right x <span class="token3">=</span> undefined

hcat <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Doc<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Doc
hcat xs <span class="token3">=</span> undefined

oneChar <span class="token">:</span><span class="token">:</span> Char <span class="token3">-</span><span class="token3">&gt;</span> Doc
oneChar c <span class="token3">=</span> undefined

</code></pre>
<p class="calibre9">enclose 函数把一个 Doc 值用起始字符和终止字符包起来。(&lt;&gt;) 函数将两个 Doc 值拼接起来。也就是说，它是 Doc 中的 ++ 函数。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Prettify<span class="token">.</span>hs
enclose <span class="token">:</span><span class="token">:</span> Char <span class="token3">-</span><span class="token3">&gt;</span> Char <span class="token3">-</span><span class="token3">&gt;</span> Doc <span class="token3">-</span><span class="token3">&gt;</span> Doc
enclose left right x <span class="token3">=</span> char left <span class="token3">&lt;</span><span class="token3">&gt;</span> x <span class="token3">&lt;</span><span class="token3">&gt;</span> char right

<span class="token">(</span><span class="token3">&lt;</span><span class="token3">&gt;</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> Doc <span class="token3">-</span><span class="token3">&gt;</span> Doc <span class="token3">-</span><span class="token3">&gt;</span> Doc
a <span class="token3">&lt;</span><span class="token3">&gt;</span> b <span class="token3">=</span> undefined

char <span class="token">:</span><span class="token">:</span> Char <span class="token3">-</span><span class="token3">&gt;</span> Doc
char c <span class="token3">=</span> undefined

</code></pre>
<p class="calibre9">hcat 函数将多个 Doc 值拼接成一个，类似列表中的 concat 函数。</p>
<p class="calibre9">string 函数将 oneChar 函数应用于字符串的每一个字符，然后把拼接起来的结果放入引号中。 oneChar 函数将一个单独的字符进行转义（escape）或转换（render）。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Prettify<span class="token">.</span>hs
oneChar <span class="token">:</span><span class="token">:</span> Char <span class="token3">-</span><span class="token3">&gt;</span> Doc
oneChar c <span class="token3">=</span> case lookup c simpleEscapes of
              Just r <span class="token3">-</span><span class="token3">&gt;</span> text r
              Nothing <span class="token3">|</span> mustEscape c <span class="token3">-</span><span class="token3">&gt;</span> hexEscape c
                      <span class="token3">|</span> otherwise    <span class="token3">-</span><span class="token3">&gt;</span> char c
    where mustEscape c <span class="token3">=</span> c <span class="token3">&lt;</span> <span class="token4">' '</span> <span class="token3">||</span> c <span class="token3">==</span> <span class="token4">'\x7f'</span> <span class="token3">||</span> c <span class="token3">&gt;</span> <span class="token4">'\xff'</span>

simpleEscapes <span class="token">:</span><span class="token">:</span> <span class="token">[</span><span class="token">(</span>Char<span class="token">,</span> String<span class="token">)</span><span class="token">]</span>
simpleEscapes <span class="token3">=</span> zipWith ch <span class="token4">"\b\n\f\r\t\\\"/"</span> <span class="token4">"bnfrt\\\"/"</span>
    where ch a b <span class="token3">=</span> <span class="token">(</span>a<span class="token">,</span> <span class="token">[</span><span class="token4">'\\'</span><span class="token">,</span>b<span class="token">]</span><span class="token">)</span>

hexEscape <span class="token">:</span><span class="token">:</span> Char <span class="token3">-</span><span class="token3">&gt;</span> Doc
hexEscape c <span class="token3">=</span> undefined

</code></pre>
<p class="calibre9">simpleEscapes 是一个序对组成的列表。我们把由序对组成的列表称为<em class="calibre13">关联列表（association list）</em>，或简称为<em class="calibre13">alist</em>。我们的 alist 将字符和其对应的转义形式关联起来。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>l Prettify<span class="token">.</span>hs
ghci<span class="token3">&gt;</span> take <span class="token2">4</span> simpleEscapes
<span class="token">[</span><span class="token">(</span><span class="token4">'\b'</span><span class="token">,</span><span class="token4">"\\b"</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token4">'\n'</span><span class="token">,</span><span class="token4">"\\n"</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token4">'\f'</span><span class="token">,</span><span class="token4">"\\f"</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token4">'\r'</span><span class="token">,</span><span class="token4">"\\r"</span><span class="token">)</span><span class="token">]</span>

</code></pre>
<p class="calibre9">case 表达式试图确定一个字符是否存在于 alist 当中。如果存在，我们就返回它对应的转义形式，否则我们就要用更复杂的方法来转义它。当两种转义都不需要时我们返回字符本身。保守地说，我们返回的非转义字符只包含可打印的 ASCII 字符。</p>
<p class="calibre9">上文提到的复杂的转义是指将一个 Unicode 字符转为一个 “<em class="calibre13">\u</em>” 加上四个表示它编码16进制数字。</p>
<p class="calibre9">[译注：smallHex 函数为 hexEscape 函数的一部分，只处理较为简单的一种情况。]</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Prettify<span class="token">.</span>hs
import Numeric <span class="token">(</span>showHex<span class="token">)</span>

smallHex <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> Doc
smallHex x  <span class="token3">=</span> text <span class="token4">"\\u"</span>
           <span class="token3">&lt;</span><span class="token3">&gt;</span> text <span class="token">(</span>replicate <span class="token">(</span><span class="token2">4</span> <span class="token3">-</span> length h<span class="token">)</span> <span class="token4">'0'</span><span class="token">)</span>
           <span class="token3">&lt;</span><span class="token3">&gt;</span> text h
    where h <span class="token3">=</span> showHex x <span class="token4">""</span>

</code></pre>
<p class="calibre9">showHex 函数来自于 Numeric 库（需要在 Prettify.hs 开头载入)，它返回一个数字的16进制表示。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> showHex <span class="token2">114111</span> <span class="token4">""</span>
<span class="token4">"1bdbf"</span>

</code></pre>
<p class="calibre9">replicate 函数由 Prelude 提供，它创建一个长度确定的重复列表。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> replicate <span class="token2">5</span> <span class="token4">"foo"</span>
<span class="token">[</span><span class="token4">"foo"</span><span class="token">,</span><span class="token4">"foo"</span><span class="token">,</span><span class="token4">"foo"</span><span class="token">,</span><span class="token4">"foo"</span><span class="token">,</span><span class="token4">"foo"</span><span class="token">]</span>

</code></pre>
<p class="calibre9">有一点需要注意： smallHex 提供的4位数字编码仅能够表示 0xffff 范围之内的 Unicode 字符。而合法的 Unicode 字符范围可达 0x10ffff 。为了使用 JSON 字符串表示这部分字符，我们需要遵循一些复杂的规则将它们一分为二。这使得我们有机会对 Haskell 数字进行一些位操作(bit-level manipulation)。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Prettify<span class="token">.</span>hs
import Data<span class="token">.</span>Bits <span class="token">(</span>shiftR<span class="token">,</span> <span class="token">(</span><span class="token">.</span><span class="token3">&amp;</span><span class="token">.</span><span class="token">)</span><span class="token">)</span>

astral <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> Doc
astral n <span class="token3">=</span> smallHex <span class="token">(</span>a <span class="token3">+</span> <span class="token2">0xd800</span><span class="token">)</span> <span class="token3">&lt;</span><span class="token3">&gt;</span> smallHex <span class="token">(</span>b <span class="token3">+</span> <span class="token2">0xdc00</span><span class="token">)</span>
    where a <span class="token3">=</span> <span class="token">(</span>n `shiftR` <span class="token2">10</span><span class="token">)</span> <span class="token">.</span><span class="token3">&amp;</span><span class="token">.</span> <span class="token2">0x3ff</span>
          b <span class="token3">=</span> n <span class="token">.</span><span class="token3">&amp;</span><span class="token">.</span> <span class="token2">0x3ff</span>

</code></pre>
<p class="calibre9">shiftR 函数来自 Data.Bits 模块，它把一个数字右移一位。同样来自于 Data.Bits 模块的 (.&amp;.) 函数将两个数字进行按位与操作。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token2">0x10000</span> `shiftR` <span class="token2">4</span>   <span class="token">:</span><span class="token">:</span> Int
<span class="token2">4096</span>
ghci<span class="token3">&gt;</span> <span class="token2">7</span> <span class="token">.</span><span class="token3">&amp;</span><span class="token">.</span> <span class="token2">2</span>   <span class="token">:</span><span class="token">:</span> Int
<span class="token2">2</span>

</code></pre>
<p class="calibre9">有了 smallHex 和 astral ，我们可以如下定义 hexEscape ：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Prettify<span class="token">.</span>hs
import Data<span class="token">.</span>Char <span class="token">(</span>ord<span class="token">)</span>

hexEscape <span class="token">:</span><span class="token">:</span> Char <span class="token3">-</span><span class="token3">&gt;</span> Doc
hexEscape c <span class="token3">|</span> d <span class="token3">&lt;</span> <span class="token2">0x10000</span> <span class="token3">=</span> smallHex d
            <span class="token3">|</span> otherwise   <span class="token3">=</span> astral <span class="token">(</span>d <span class="token3">-</span> <span class="token2">0x10000</span><span class="token">)</span>
    where d <span class="token3">=</span> ord c

</code></pre>
<h2 class="calibre14"><a id="chp-5.html._546" class="calibre7 pcalibre"></a>数组和对象</h2>
<p class="calibre9">跟字符串比起来，美观打印数组和对象就简单多了。我们已经知道它们两个看起来很像：以起始字符开头，中间是用逗号隔开的一系列值，以终止字符结束。我们写个函数来体现它们的共同特点：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>PrettyJSON<span class="token">.</span>hs
series <span class="token">:</span><span class="token">:</span> Char <span class="token3">-</span><span class="token3">&gt;</span> Char <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> Doc<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Doc
series open close f <span class="token3">=</span> enclose open close
                    <span class="token">.</span> fsep <span class="token">.</span> punctuate <span class="token">(</span>char <span class="token4">','</span><span class="token">)</span> <span class="token">.</span> map f

</code></pre>
<p class="calibre9">首先我们来解释这个函数的类型。它的参数是一个起始字符和一个终止字符 ，然后是一个知道怎样打印未知类型 a 的函数，接着是一个包含 a 类型数据的列表，最后返回一个 Doc 类型的值。</p>
<p class="calibre9">尽管函数的类型签名有4个参数，我们在函数定义中只列出了3个。这跟我们把 myLengthxs=lengthxs 简化成 myLength=length 是一个道理。</p>
<p class="calibre9">我们已经有了把 Doc 包在起始字符和终止字符之间的 enclose 函数。fsep 会在 Prettify 模块中定义。它将多个 Doc 值拼接成一个，并且在需要的时候换行。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Prettify<span class="token">.</span>hs
fsep <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Doc<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Doc
fsep xs <span class="token3">=</span> undefined

</code></pre>
<p class="calibre9">punctuate 函数也会在 Prettify 中定义。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Prettify<span class="token">.</span>hs
punctuate <span class="token">:</span><span class="token">:</span> Doc <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>Doc<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>Doc<span class="token">]</span>
punctuate p <span class="token">[</span><span class="token">]</span>     <span class="token3">=</span> <span class="token">[</span><span class="token">]</span>
punctuate p <span class="token">[</span>d<span class="token">]</span>    <span class="token3">=</span> <span class="token">[</span>d<span class="token">]</span>
punctuate p <span class="token">(</span>d<span class="token">:</span>ds<span class="token">)</span> <span class="token3">=</span> <span class="token">(</span>d <span class="token3">&lt;</span><span class="token3">&gt;</span> p<span class="token">)</span> <span class="token">:</span> punctuate p ds

</code></pre>
<p class="calibre9">有了 series，美观打印数组就非常直观了。我们在 renderJValue 的定义的最后加上下面一行。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>PrettyJSON<span class="token">.</span>hs
renderJValue <span class="token">(</span>JArray ary<span class="token">)</span> <span class="token3">=</span> series <span class="token4">'['</span> <span class="token4">']'</span> renderJValue ary

</code></pre>
<p class="calibre9">美观打印对象稍微麻烦一点：对于每个元素，我们还要额外处理名字和值。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>PrettyJSON<span class="token">.</span>hs
renderJValue <span class="token">(</span>JObject obj<span class="token">)</span> <span class="token3">=</span> series <span class="token4">'{'</span> <span class="token4">'}'</span> field obj
    where field <span class="token">(</span>name<span class="token">,</span>val<span class="token">)</span> <span class="token3">=</span> string name
                          <span class="token3">&lt;</span><span class="token3">&gt;</span> text <span class="token4">": "</span>
                          <span class="token3">&lt;</span><span class="token3">&gt;</span> renderJValue val

</code></pre>
<h2 class="calibre14"><a id="chp-5.html._601" class="calibre7 pcalibre"></a>书写模块头</h2>
<p class="calibre9">PrettyJSON.hs 文件写得差不多了，我们现在回到文件顶部书写模块声明。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>PrettyJSON<span class="token">.</span>hs
module PrettyJSON
    <span class="token">(</span>
      renderJValue
    <span class="token">)</span> where

import SimpleJSON <span class="token">(</span><span class="token5">JValue</span><span class="token">(</span><span class="token">.</span><span class="token">.</span><span class="token">)</span><span class="token">)</span>
import Prettify <span class="token">(</span>Doc<span class="token">,</span> <span class="token">(</span><span class="token3">&lt;</span><span class="token3">&gt;</span><span class="token">)</span><span class="token">,</span> char<span class="token">,</span> double<span class="token">,</span> fsep<span class="token">,</span> hcat<span class="token">,</span> punctuate<span class="token">,</span> text<span class="token">,</span> compact<span class="token">,</span> pretty<span class="token">)</span>

</code></pre>
<p class="calibre9">[译注：compact 和 pretty 函数会在稍后介绍。]</p>
<p class="calibre9">我们只从这个模块导出了一个函数，renderJValue，也就是我们的 JSON 转换函数。其它的函数只是为了支持 renderJValue，因此没必要对其它模块可见。</p>
<p class="calibre9">关于载入部分，Numeric 和 Data.Bits 模块是 GHC 内置的。我们已经写好了 SimpleJSON 模块，Prettify 模块的框架也搭好了。可以看出载入标准模块和我们自己写的模块没什么区别。[译注：原文在 PrettyJSON.hs 头部载入了 Numeric 和 Data.Bits 模块。但事实上并无必要，因此在译文中删除。此处作者的说明部分未作改动。]</p>
<p class="calibre9">在每个 import 命令中，我们都列出了想要引入我们的模块的命名空间的名字。这并非强制：如果省略这些名字，我们就可以使用一个模块导出的所有名字。然而，通常来讲显式地载入更好。</p>
<ul class="calibre10"><li class="calibre11">一个显式列表清楚地表明了我们从哪里载入了哪个名字。如果读者碰到了不熟悉的函数，这便于他们查看文档。</li><li class="calibre11">有时候库的维护者会删除或者重命名函数。一个函数很可能在我们写完模块很久之后才从第三方库中消失并导致编译错误。显式列表提醒我们消失的名字是从哪儿载入的，有助于我们更快找到问题。</li><li class="calibre11">另外一种情况是库的维护者在模块中加入的函数与我们代码中现有的函数名字一样。如果不用显式列表，这个函数就会在我们的模块中出现两次。当我们用这个函数的时候，GHC 就会报告歧义错误。</li></ul>
<p class="calibre9">通常情况下使用显式列表更好，但这并不是硬性规定。有的时候，我们需要一个模块中的很多名字，一一列举会非常麻烦。有的时候，有些模块已经被广泛使用，有经验的 Hashell 程序员会知道哪个名字来自那些模块。</p>
<h2 class="calibre14"><a id="chp-5.html._631" class="calibre7 pcalibre"></a>完成美观打印库</h2>
<p class="calibre9">在 Prettify 模块中，我们用代数数据类型来表示 Doc 类型。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Prettify<span class="token">.</span>hs
data Doc <span class="token3">=</span> Empty
         <span class="token3">|</span> Char Char
         <span class="token3">|</span> Text String
         <span class="token3">|</span> Line
         <span class="token3">|</span> Concat Doc Doc
         <span class="token3">|</span> Union Doc Doc
           deriving <span class="token">(</span>Show<span class="token">,</span>Eq<span class="token">)</span>

</code></pre>
<p class="calibre9">可以看出 Doc 类型其实是一棵树。Concat 和 Union 构造器以两个 Doc 值构造一个内部节点，Empty 和其它简单的构造器构造叶子。</p>
<p class="calibre9">在模块头中，我们导出了这个类型的名字，但是不包含任何它的构造器：这样可以保证使用这个类型的模块无法创建 Doc 值和对其进行模式匹配。</p>
<p class="calibre9">如果想创建 Doc，Prettify 模块的用户可以调用我们提供的函数。下面是一些简单的构造函数。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Prettify<span class="token">.</span>hs
empty <span class="token">:</span><span class="token">:</span> Doc
empty <span class="token3">=</span> Empty

char <span class="token">:</span><span class="token">:</span> Char <span class="token3">-</span><span class="token3">&gt;</span> Doc
char c <span class="token3">=</span> Char c

text <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> Doc
text <span class="token4">""</span> <span class="token3">=</span> Empty
text s  <span class="token3">=</span> Text s

double <span class="token">:</span><span class="token">:</span> Double <span class="token3">-</span><span class="token3">&gt;</span> Doc
double d <span class="token3">=</span> text <span class="token">(</span>show d<span class="token">)</span>

</code></pre>
<p class="calibre9">Line 构造器表示一个换行。line 函数创建一个<em class="calibre13">硬</em>换行，它总是出现在美观打印器的输出中。有时候我们想要一个<em class="calibre13">软</em>换行，只有在行太宽，一个窗口或一页放不下的时候才用。稍后我们就会介绍这个softline 函数。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Prettify<span class="token">.</span>hs
line <span class="token">:</span><span class="token">:</span> Doc
line <span class="token3">=</span> Line

</code></pre>
<p class="calibre9">下面是 (&lt;&gt;) 函数的实现。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Prettify<span class="token">.</span>hs
<span class="token">(</span><span class="token3">&lt;</span><span class="token3">&gt;</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> Doc <span class="token3">-</span><span class="token3">&gt;</span> Doc <span class="token3">-</span><span class="token3">&gt;</span> Doc
Empty <span class="token3">&lt;</span><span class="token3">&gt;</span> y <span class="token3">=</span> y
x <span class="token3">&lt;</span><span class="token3">&gt;</span> Empty <span class="token3">=</span> x
x <span class="token3">&lt;</span><span class="token3">&gt;</span> y <span class="token3">=</span> x `Concat` y

</code></pre>
<p class="calibre9">我们使用 Empty 进行模式匹配。将一个 Empty 拼接在一个 Doc 值的左侧或右侧都不会有效果。这样可以帮助我们的树减少一些无意义信息。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> text <span class="token4">"foo"</span> <span class="token3">&lt;</span><span class="token3">&gt;</span> text <span class="token4">"bar"</span>
Concat <span class="token">(</span>Text <span class="token4">"foo"</span><span class="token">)</span> <span class="token">(</span>Text <span class="token4">"bar"</span><span class="token">)</span>
ghci<span class="token3">&gt;</span> text <span class="token4">"foo"</span> <span class="token3">&lt;</span><span class="token3">&gt;</span> empty
Text <span class="token4">"foo"</span>
ghci<span class="token3">&gt;</span> empty <span class="token3">&lt;</span><span class="token3">&gt;</span> text <span class="token4">"bar"</span>
Text <span class="token4">"bar"</span>

</code></pre>
<p class="calibre9">Note</p>
<p class="calibre9">A mathematical moment(to be added)</p>
<p class="calibre9">我们的 hcat 和 fsep 函数将 Doc 列表拼接成一个 Doc 值。在之前的一道题目里（fix link），我们提到了可以用 foldr 来定义列表拼接。[译注：这个例子只是为了回顾，本章代码并没有用到。]</p>
<pre class="calibre15"><code class="tthhighlight-container">concat <span class="token">:</span><span class="token">:</span> <span class="token">[</span><span class="token">[</span>a<span class="token">]</span><span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span>
concat <span class="token3">=</span> foldr <span class="token">(</span><span class="token3">++</span><span class="token">)</span> <span class="token">[</span><span class="token">]</span>

</code></pre>
<p class="calibre9">因为 (&lt;&gt;) 类比于 (++)，empty 类比于 []，我们可以用同样的方法来定义 hcat 和 fsep 函数。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Prettify<span class="token">.</span>hs
hcat <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Doc<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Doc
hcat <span class="token3">=</span> fold <span class="token">(</span><span class="token3">&lt;</span><span class="token3">&gt;</span><span class="token">)</span>

fold <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Doc <span class="token3">-</span><span class="token3">&gt;</span> Doc <span class="token3">-</span><span class="token3">&gt;</span> Doc<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>Doc<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Doc
fold f <span class="token3">=</span> foldr f empty

</code></pre>
<p class="calibre9">fsep 的定义依赖于其它几个函数。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Prettify<span class="token">.</span>hs
fsep <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Doc<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Doc
fsep <span class="token3">=</span> fold <span class="token">(</span><span class="token3">&lt;</span><span class="token3">/</span><span class="token3">&gt;</span><span class="token">)</span>

<span class="token">(</span><span class="token3">&lt;</span><span class="token3">/</span><span class="token3">&gt;</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> Doc <span class="token3">-</span><span class="token3">&gt;</span> Doc <span class="token3">-</span><span class="token3">&gt;</span> Doc
x <span class="token3">&lt;</span><span class="token3">/</span><span class="token3">&gt;</span> y <span class="token3">=</span> x <span class="token3">&lt;</span><span class="token3">&gt;</span> softline <span class="token3">&lt;</span><span class="token3">&gt;</span> y

softline <span class="token">:</span><span class="token">:</span> Doc
softline <span class="token3">=</span> group line

group <span class="token">:</span><span class="token">:</span> Doc <span class="token3">-</span><span class="token3">&gt;</span> Doc
group x <span class="token3">=</span> undefined

</code></pre>
<p class="calibre9">稍微来解释一下。如果当前行变得太长，softline 函数就插入一个新行，否则就插入一个空格。Doc 并没有包含“怎样才算太长”的信息，这该怎么实现呢？答案是每次碰到这种情况，我们使用 Union 构造器来用两种不同的方式保存文档。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Prettify<span class="token">.</span>hs
group <span class="token">:</span><span class="token">:</span> Doc <span class="token3">-</span><span class="token3">&gt;</span> Doc
group x <span class="token3">=</span> flatten x `Union` x

flatten <span class="token">:</span><span class="token">:</span> Doc <span class="token3">-</span><span class="token3">&gt;</span> Doc
flatten <span class="token3">=</span> undefined

</code></pre>
<p class="calibre9">flatten 函数将 Line 替换为一个空格，把两行变成一行。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Prettify<span class="token">.</span>hs
flatten <span class="token">:</span><span class="token">:</span> Doc <span class="token3">-</span><span class="token3">&gt;</span> Doc
flatten <span class="token">(</span>x `Concat` y<span class="token">)</span> <span class="token3">=</span> flatten x `Concat` flatten y
flatten Line           <span class="token3">=</span> Char <span class="token4">' '</span>
flatten <span class="token">(</span>x `Union` _<span class="token">)</span>  <span class="token3">=</span> flatten x
flatten other          <span class="token3">=</span> other

</code></pre>
<p class="calibre9">我们只在 Union 左侧的元素上调用 flatten： Union 左侧元素的长度总是大于等于右侧元素的长度。下面的转换函数会用到这一性质。</p>
<h2 class="calibre14"><a id="chp-5.html._770" class="calibre7 pcalibre"></a>紧凑转换</h2>
<p class="calibre9">我们经常希望一段数据占用的字符数越少越好。例如，如果我们想通过网络传输 JSON 数据，就没必要把它弄得很漂亮：另外一端的软件并不关心它漂不漂亮，而使布局变漂亮的空格会增加额外开销。</p>
<p class="calibre9">在这种情况下，我们提供一个最基本的紧凑转换函数。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Prettify<span class="token">.</span>hs
compact <span class="token">:</span><span class="token">:</span> Doc <span class="token3">-</span><span class="token3">&gt;</span> String
compact x <span class="token3">=</span> transform <span class="token">[</span>x<span class="token">]</span>
    where transform <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> <span class="token4">""</span>
          transform <span class="token">(</span>d<span class="token">:</span>ds<span class="token">)</span> <span class="token3">=</span>
                case d of
                    Empty        <span class="token3">-</span><span class="token3">&gt;</span> transform ds
                    Char c       <span class="token3">-</span><span class="token3">&gt;</span> c <span class="token">:</span> transform ds
                    Text s       <span class="token3">-</span><span class="token3">&gt;</span> s <span class="token3">++</span> transform ds
                    Line         <span class="token3">-</span><span class="token3">&gt;</span> <span class="token4">'\n'</span> <span class="token">:</span> transform ds
                    a `Concat` b <span class="token3">-</span><span class="token3">&gt;</span> transform <span class="token">(</span>a<span class="token">:</span>b<span class="token">:</span>ds<span class="token">)</span>
                    _ `Union` b  <span class="token3">-</span><span class="token3">&gt;</span> transform <span class="token">(</span>b<span class="token">:</span>ds<span class="token">)</span>

</code></pre>
<p class="calibre9">compact 函数把它的参数放进一个列表里，然后再对它应用 transform 辅助函数。transform 函数把参数当做栈来处理，列表的第一个元素即为栈顶。</p>
<p class="calibre9">transform 函数的 (d:ds) 模式将栈分为头 d 和剩余部分 ds。在 case 表达式里，前几个分支在 ds 上递归，每次处理一个栈顶的元素。最后两个分支在 ds 前面加了东西：Concat 分支把两个元素都加到栈里，Union 分支忽略左侧元素（我们对它调用了 flatten ），只把右侧元素加进栈里。</p>
<p class="calibre9">现在我们终于可以在 <strong class="calibre12">ghci</strong> 里试试 compact 函数了。[译注：这里要对 PrettyJSON.hs 里 importPrettify 部分作一下修改才能使 PrettyJSON.hs 编译。包括去掉还未实现的 pretty 函数，增加缺少的 string, series 函数等。一个可以编译的版本如下。]</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>PrettyJSON<span class="token">.</span>hs
import Prettify <span class="token">(</span>Doc<span class="token">,</span> <span class="token">(</span><span class="token3">&lt;</span><span class="token3">&gt;</span><span class="token">)</span><span class="token">,</span> string<span class="token">,</span> series<span class="token">,</span> char<span class="token">,</span> double<span class="token">,</span> fsep<span class="token">,</span> hcat<span class="token">,</span> punctuate<span class="token">,</span> text<span class="token">,</span> compact<span class="token">)</span>

</code></pre>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> let value <span class="token3">=</span> renderJValue <span class="token">(</span>JObject <span class="token">[</span><span class="token">(</span><span class="token4">"f"</span><span class="token">,</span> JNumber <span class="token2">1</span><span class="token">)</span><span class="token">,</span> <span class="token">(</span><span class="token4">"q"</span><span class="token">,</span> JBool True<span class="token">)</span><span class="token">]</span><span class="token">)</span>
ghci<span class="token3">&gt;</span> <span class="token">:</span>type value
value <span class="token">:</span><span class="token">:</span> Doc
ghci<span class="token3">&gt;</span> putStrLn <span class="token">(</span>compact value<span class="token">)</span>
<span class="token">{</span><span class="token4">"f"</span><span class="token">:</span> <span class="token2">1.0</span><span class="token">,</span>
<span class="token4">"q"</span><span class="token">:</span> <span class="token2">true</span>
<span class="token">}</span>

</code></pre>
<p class="calibre9">为了更好地理解代码，我们来分析一个更简单的例子。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> char <span class="token4">'f'</span> <span class="token3">&lt;</span><span class="token3">&gt;</span> text <span class="token4">"oo"</span>
Concat <span class="token">(</span>Char <span class="token4">'f'</span><span class="token">)</span> <span class="token">(</span>Text <span class="token4">"oo"</span><span class="token">)</span>
ghci<span class="token3">&gt;</span> compact <span class="token">(</span>char <span class="token4">'f'</span> <span class="token3">&lt;</span><span class="token3">&gt;</span> text <span class="token4">"oo"</span><span class="token">)</span>
<span class="token4">"foo"</span>

</code></pre>
<p class="calibre9">当我们调用 compact 时，它把参数转成一个列表并应用 transform。</p>
<ul class="calibre10"><li class="calibre11"></li></ul>
<p class="calibre9">transform 函数的参数是一个单元素列表，匹配 (d:ds) 模式。因此 d 是 Concat(Char'f')(Text"oo")，ds 是个空列表，[]。</p>
<p class="calibre9">因为 d 的构造器是 Concat，case 表达式匹配到了 Concat 分支。我们把 Char'f' 和 Text"oo" 放进栈里，并递归调用 transform。</p>
<ul class="calibre10"><li class="calibre11"></li><li class="calibre11"><p class="calibre9">这次 transform 的参数是一个二元素列表，匹配 (d:ds) 模式。变量 d 被绑定到 Char'f'，ds 被绑定到 [Text"oo"]。case 表达式匹配到 Char 分支。因此我们用 (:) 构造一个列表，它的头是 'f'，剩余部分是对 transform 进行递归调用的结果。</p></li><li class="calibre11"></li><li class="calibre11"><p class="calibre9">这次递归调用的参数是一个单元素列表，变量 d 被绑定到 Text"oo"，ds 被绑定到 []。case 表达式匹配到 Text 分支。我们用 (++) 拼接 "oo" 和下次递归调用的结果。</p></li><li class="calibre11"></li><li class="calibre11"><p class="calibre9">最后一次调用，transform 的参数是一个空列表，因此返回一个空字符串。</p></li><li class="calibre11"><p class="calibre9">结果是 "oo"++""。</p></li><li class="calibre11"><p class="calibre9">结果是 'f':"oo"++""。</p></li></ul>
<h2 class="calibre14"><a id="chp-5.html._846" class="calibre7 pcalibre"></a>真正的美观打印</h2>
<p class="calibre9">我们的 compact 方便了机器之间的交流，人阅读起来却非常困难。我们写一个 pretty 函数来产生可读性较强的输出。跟 compact 相比，[<code class="calibre16">](#)pretty</code>多了一个参数：每行的最大宽度(有几列)。(假设我们使用等宽字体。)</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Prettify<span class="token">.</span>hs
pretty <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> Doc <span class="token3">-</span><span class="token3">&gt;</span> String
pretty <span class="token3">=</span> undefined

</code></pre>
<p class="calibre9">更准确地说，这个 Int 参数控制了 pretty 遇到 softline 时的行为。只有碰到 softline 时，pretty 才能选择继续当前行还是新开一行。别的地方，我们必须严格遵守已有的打印规则。</p>
<p class="calibre9">下面是这个函数的核心部分。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Prettify<span class="token">.</span>hs
pretty <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> Doc <span class="token3">-</span><span class="token3">&gt;</span> String
pretty width x <span class="token3">=</span> best <span class="token2">0</span> <span class="token">[</span>x<span class="token">]</span>
    where best col <span class="token">(</span>d<span class="token">:</span>ds<span class="token">)</span> <span class="token3">=</span>
        case d of
            Empty        <span class="token3">-</span><span class="token3">&gt;</span> best col ds
            Char c       <span class="token3">-</span><span class="token3">&gt;</span> c <span class="token">:</span>  best <span class="token">(</span>col <span class="token3">+</span> <span class="token2">1</span><span class="token">)</span> ds
            Text s       <span class="token3">-</span><span class="token3">&gt;</span> s <span class="token3">++</span> best <span class="token">(</span>col <span class="token3">+</span> length s<span class="token">)</span> ds
            Line         <span class="token3">-</span><span class="token3">&gt;</span> <span class="token4">'\n'</span> <span class="token">:</span> best <span class="token2">0</span> ds
            a `Concat` b <span class="token3">-</span><span class="token3">&gt;</span> best col <span class="token">(</span>a<span class="token">:</span>b<span class="token">:</span>ds<span class="token">)</span>
            a `Union` b  <span class="token3">-</span><span class="token3">&gt;</span> nicest col <span class="token">(</span>best col <span class="token">(</span>a<span class="token">:</span>ds<span class="token">)</span><span class="token">)</span>
                                       <span class="token">(</span>best col <span class="token">(</span>b<span class="token">:</span>ds<span class="token">)</span><span class="token">)</span>
      best _ _ <span class="token3">=</span> <span class="token4">""</span>

      nicest col a b <span class="token3">|</span> <span class="token">(</span>width <span class="token3">-</span> least<span class="token">)</span> `fits` a <span class="token3">=</span> a
                     <span class="token3">|</span> otherwise                <span class="token3">=</span> b
                     where least <span class="token3">=</span> min width col

fits <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> Bool
fits <span class="token3">=</span> undefined

</code></pre>
<p class="calibre9">辅助函数 best 接受两个参数：当前行已经走过的列数和剩余需要处理的 Doc 列表。一般情况下，best 会简单地消耗输入更新 col。即使 Concat 这种情况也显而易见：我们把拼接好的两个元素放进栈里，保持 col 不变。</p>
<p class="calibre9">有趣的是涉及到 Union 构造器的情况。回想一下，我们将 flatten 应用到了左侧元素，右侧不变。并且，flatten 把换行替换成了空格。因此，我们的任务是看看两种布局中，哪一种（如果有的话）能满足我们的 width 限制。</p>
<p class="calibre9">我们还需要一个小的辅助函数来确定某一行已经被转换的 Doc 值是否能放进给定的宽度中。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Prettify<span class="token">.</span>hs
fits <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> Bool
w `fits` _ <span class="token3">|</span> w <span class="token3">&lt;</span> <span class="token2">0</span> <span class="token3">=</span> False
w `fits` <span class="token4">""</span>        <span class="token3">=</span> True
w `fits` <span class="token">(</span><span class="token4">'\n'</span><span class="token">:</span>_<span class="token">)</span>  <span class="token3">=</span> True
w `fits` <span class="token">(</span>c<span class="token">:</span>cs<span class="token">)</span>    <span class="token3">=</span> <span class="token">(</span>w <span class="token3">-</span> <span class="token2">1</span><span class="token">)</span> `fits` cs

</code></pre>
<h2 class="calibre14"><a id="chp-5.html._901" class="calibre7 pcalibre"></a>理解美观打印器</h2>
<p class="calibre9">为了理解这段代码是如何工作的，我们首先来考虑一个简单的 Doc 值。[译注：PrettyJSON.hs 并未载入 empty 和 &lt;/&gt;。需要读者自行载入。]</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> empty <span class="token3">&lt;</span><span class="token3">/</span><span class="token3">&gt;</span> char <span class="token4">'a'</span>
Concat <span class="token">(</span>Union <span class="token">(</span>Char <span class="token4">' '</span><span class="token">)</span> Line<span class="token">)</span> <span class="token">(</span>Char <span class="token4">'a'</span><span class="token">)</span>

</code></pre>
<p class="calibre9">我们会将 pretty2 应用到这个值上。第一次应用 best 时，col 的值是0。它匹配到了 Concat 分支，于是把 Union(Char'')Line 和 Char'a' 放进栈里，继续递归。在递归调用时，它匹配到了 Union 分支。</p>
<p class="calibre9">这个时候，我们忽略 Haskell 通常的求值顺序。这使得在不影响结果的情况下，我们的解释最容易被理解。现在我们有两个子表达式：best0[Char'',Char'a'] 和 best0[Line,Char'a']。第一个被求值成 "a"，第二个被求值成 "\na"。我们把这些值替换进函数得到 nicest0"a""\na"。</p>
<p class="calibre9">为了弄清 nicest 的结果是什么，我们再做点替换。width 和 col 的值分别是0和2，所以 least 是0，width-least 是2。我们在 <strong class="calibre12">ghci</strong> 里试试 2<code class="calibre16">fits</code>"a" 的结果是什么。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token2">2</span> `fits` <span class="token4">" a"</span>
True

</code></pre>
<p class="calibre9">由于求值结果为 True，nicest 的结果是 "a"。</p>
<p class="calibre9">如果我们将 pretty 函数应用到之前的 JSON 上，我们可以看到随着我们给它的宽度不同，它产生了不同的结果。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> putStrLn <span class="token">(</span>pretty <span class="token2">10</span> value<span class="token">)</span>
<span class="token">{</span><span class="token4">"f"</span><span class="token">:</span> <span class="token2">1.0</span><span class="token">,</span>
<span class="token4">"q"</span><span class="token">:</span> <span class="token2">true</span>
<span class="token">}</span>
ghci<span class="token3">&gt;</span> putStrLn <span class="token">(</span>pretty <span class="token2">20</span> value<span class="token">)</span>
<span class="token">{</span><span class="token4">"f"</span><span class="token">:</span> <span class="token2">1.0</span><span class="token">,</span> <span class="token4">"q"</span><span class="token">:</span> <span class="token2">true</span>
<span class="token">}</span>
ghci<span class="token3">&gt;</span> putStrLn <span class="token">(</span>pretty <span class="token2">30</span> value<span class="token">)</span>
<span class="token">{</span><span class="token4">"f"</span><span class="token">:</span> <span class="token2">1.0</span><span class="token">,</span> <span class="token4">"q"</span><span class="token">:</span> <span class="token2">true</span> <span class="token">}</span>

</code></pre>
<h2 class="calibre14"><a id="chp-5.html._940" class="calibre7 pcalibre"></a>练习</h2>
<p class="calibre9">我们现有的美观打印器已经可以满足一定的空间限制要求，我们还可以对它做更多改进。</p>
<ol class="calibre17"><li class="calibre11"></li></ol>
<p class="calibre9">用下面的类型签名写一个函数 fill。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Prettify<span class="token">.</span>hs
fill <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> Doc <span class="token3">-</span><span class="token3">&gt;</span> Doc

</code></pre>
<p class="calibre9">它应该给文档添加空格直到指定宽度。如果宽度已经超过指定值，则不加。</p>
<ol class="calibre17"><li class="calibre11"></li></ol>
<p class="calibre9">我们的美观打印器并未考虑嵌套（nesting）这种情况。当左括号（无论是小括号，中括号，还是大括号）出现时，之后的行应该缩进，直到对应的右括号出现为止。</p>
<p class="calibre9">实现这个功能，缩进量应该可控。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Prettify<span class="token">.</span>hs
nest <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> Doc <span class="token3">-</span><span class="token3">&gt;</span> Doc

</code></pre>
<h2 class="calibre14"><a id="chp-5.html._966" class="calibre7 pcalibre"></a>创建包</h2>
<p class="calibre9">Cabal 是 Haskell 社区用来构建，安装和发布软件的一套标准工具。Cabal 将软件组织为<em class="calibre13">包（package）</em>。一个包有且只能有一个库，但可以有多个可执行程序。</p>
<h2 class="calibre14"><a id="chp-5.html._970" class="calibre7 pcalibre"></a>为包添加描述</h2>
<p class="calibre9">Cabal 要求你给每个包添加描述。这些描述放在一个以 .cabal 结尾的文件当中。这个文件需要放在你项目的顶层目录里。它的格式很简单，下面我们就来介绍它。</p>
<p class="calibre9">每个 Cabal 包都需要有个名字。通常来说，包的名字和 .cabal 文件的名字相同。如果我们的包叫做 mypretty ，那我们的文件就是 mypretty.cabal 。通常，包含 .cabal文件的目录名字和包名字相同，如 mypretty 。</p>
<p class="calibre9">放在包描述开头的是一些全局属性，它们适用于包里所有的库和可执行程序。</p>
<pre class="calibre15"><code class="tthhighlight-container">Name<span class="token">:</span>          mypretty
Version<span class="token">:</span>       <span class="token2">0.1</span>

<span class="token3">--</span> This is a comment<span class="token">.</span>  It stretches to the end of the line<span class="token">.</span>

</code></pre>
<p class="calibre9">包的名字必须独一无二。如果你创建安装的包和你系统里已经存在的某个包名字相同，GHC 会搞不清楚用哪个。</p>
<p class="calibre9">全局属性中的很多信息都是给人而不是 Cabal 自己来读的。</p>
<pre class="calibre15"><code class="tthhighlight-container">Synopsis<span class="token">:</span>      My pretty printing library<span class="token">,</span> with JSON support
Description<span class="token">:</span>
    A simple pretty printing library that illustrates how to
    develop a Haskell library<span class="token">.</span>
Author<span class="token">:</span>        Real World Haskell
Maintainer<span class="token">:</span>    somebody@realworldhaskell<span class="token">.</span>org

</code></pre>
<p class="calibre9">如 Description 所示，一个字段可以有多行，只要缩进即可。</p>
<p class="calibre9">许可协议也被放在全局属性中。大部分 Haskell 包使用 BSD 协议，Cabal 称之为 BSD3。（当然，你可以随意选择合适的协议。）我们可以在 License-File 这个非强制字段中加入许可协议文件，这个文件包含了我们的包所使用的协议的全部协议条款。</p>
<p class="calibre9">Cabal 所支持的功能会不断变化，因此，指定我们期望兼容的 Cabal 版本是非常明智的。我们增加的功能可以被 Cabal 1.2及以上的版本支持。</p>
<pre class="calibre15"><code class="tthhighlight-container">Cabal<span class="token3">-</span>Version<span class="token">:</span> <span class="token3">&gt;=</span> <span class="token2">1.2</span>

</code></pre>
<p class="calibre9">我们使用 <em class="calibre13">library</em> 区域来描述包中单独的库。缩进的使用非常重要：处于一个区域中的内容必须缩进。</p>
<pre class="calibre15"><code class="tthhighlight-container">library
    Exposed<span class="token3">-</span>Modules<span class="token">:</span> Prettify
                     PrettyJSON
                     SimpleJSON
    Build<span class="token3">-</span>Depends<span class="token">:</span>   base <span class="token3">&gt;=</span> <span class="token2">2.0</span>

</code></pre>
<p class="calibre9">Exposed-Modules 列出了本包中用户可用的模块。可选字段字段 Other-Modules 列出了<em class="calibre13">内部模块</em>。这些内部模块用来支持这个库的功能，然而对用户不可见。</p>
<p class="calibre9">Build-Depends 包含了构建我们库所需要的包，它们之间用逗号分开。对于每一个包，我们可以选择性地说明这个库可以与之工作的版本号范围。base 包包含了很多 Haskell 的核心模块，如Prelude，因此实际上它总是被需要的。</p>
<p class="calibre9">Note</p>
<p class="calibre9">处理依赖关系</p>
<p class="calibre9">我们并不需要猜测或者调查我们依赖于哪些包。如果我们在构建包的时候没有包含 Build-Depends 字段，编译会失败，并返回一条有用的错误信息。我们可以试试把 base 注释掉会发生什么。</p>
<pre class="calibre15"><code class="tthhighlight-container">$ runghc Setup build
Preprocessing library mypretty<span class="token3">-</span><span class="token2">0.1</span><span class="token">.</span><span class="token">.</span><span class="token">.</span>
Building mypretty<span class="token3">-</span><span class="token2">0.1</span><span class="token">.</span><span class="token">.</span><span class="token">.</span>

PrettyJSON<span class="token">.</span>hs<span class="token">:</span><span class="token2">8</span><span class="token">:</span><span class="token2">7</span><span class="token">:</span>
    Could not find module `Data<span class="token">.</span>Bits'<span class="token">:</span>
        it is a member of package base<span class="token">,</span> which is hidden

</code></pre>
<p class="calibre9">错误信息清楚地表明我们需要增加 base 包，尽管它已经被安装了。强制我们显式地列出所有包有一个实际好处：cabal-install 这个命令行工具会自动下载，构建并安装一个包和所有它依赖的包。 [译注，在运行 runghc Setup build 之前，Cabal 会首先要求你运行 configure。具体方法见下文。]<br class="calibre1"><br>
GHC 的包管理器 GHC 内置了一个简单的包管理器用来记录安装了哪些包以及它们的版本号。我们可以使用 ghc-pkg 命令来查看包数据库。 我们说数据库，是因为 GHC 区分所有用户都能使用的系统包（system-wide packages）和只有当前用户才能使用的用户包（per-user packages）。 用户数据库（per-user database）使我们没有管理员权限也可以安装包。 ghc-pkg 命令为不同的任务提供了不同的子命令。大多数时间，我们只用到两个。 ghc-pkg list 命令列出已安装的包。当我们想要卸载一个包时，ghc-pkg unregister 告诉 GHC 我们不再用这个包了。 （我们需要手动删除已安装的文件。）<br class="calibre1"><br>
配置，构建和安装 除了 .cabal 文件，每个包还必须包含一个 setup 文件。 这使得 Cabal 可以在需要的时候自定义构建过程。一个最简单的配置文件如下所示。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch05<span class="token3">/</span>Setup<span class="token">.</span>hs
#<span class="token3">!</span><span class="token3">/</span>usr<span class="token3">/</span>bin<span class="token3">/</span>env runhaskell
import Distribution<span class="token">.</span>Simple
main <span class="token3">=</span> defaultMain

</code></pre>
<p class="calibre9">我们把这个文件保存为 Setup.hs。</p>
<p class="calibre9">有了 .cabal 和 Setup.hs 文件之后，我们只有三步之遥。</p>
<p class="calibre9">我们用一个简单的命令告诉 Cabal 如何构建一个包以及往哪里安装这个包。</p>
<p class="calibre9">[译注：运行此命令时，Cabal 提示我没有指定 build-type。于是我按照提示在 .cabal 文件里加了 build-type:Simple 字段。]</p>
<pre class="calibre15"><code class="tthhighlight-container">$ runghc Setup configure

</code></pre>
<p class="calibre9">这个命令保证了我们的包可用，并且保存设置让后续的 Cabal 命令使用。</p>
<p class="calibre9">如果我们不给 configure 提供任何参数，Cabal 会把我们的包安装在系统包数据库里。如果想安装在指定目录下和用户包数据库内，我们需要提供更多的信息。</p>
<pre class="calibre15"><code class="tthhighlight-container">$ runghc Setup configure <span class="token3">--</span>prefix<span class="token3">=</span>$HOME <span class="token3">--</span>user

</code></pre>
<p class="calibre9">完成之后，我们来构建这个包。</p>
<pre class="calibre15"><code class="tthhighlight-container">$ runghc Setup build

</code></pre>
<p class="calibre9">成功之后，我们就可以安装包了。我们不需要告诉 Cabal 装在哪儿，它会使用我们在第一步里提供的信息。它会把包装在我们指定的目录下然后更新 GHC 的用户包数据库。</p>
<pre class="calibre15"><code class="tthhighlight-container">$ runghc Setup install

</code></pre>
<h2 class="calibre14"><a id="chp-5.html._1089" class="calibre7 pcalibre"></a>实用链接和扩展阅读</h2>
<p class="calibre9">GHC 内置了一个美观打印库，Text.PrettyPrint.HughesPJ。它提供的 API 和我们的例子相同并且有更丰富有用的美观打印函数。与自己实现相比，我们更推荐使用它。</p>
<p class="calibre9">John Hughes 在 <a href="#chp-5.html." class="calibre7 pcalibre">[Hughes95]</a> 中介绍了 HughesPJ 美观打印器的设计。这个库后来被 Simon Peyton Jones 改进，也因此得名。Hughes 的论文很长，但他对怎样设计 Haskell 库的讨论非常值得一读。</p>
<p class="calibre9">本章介绍的美观打印库基于 Philip Wadler 在 <a href="#chp-5.html." class="calibre7 pcalibre">[Wadler98]</a> 中描述的一个更简单的系统。Daan Leijen 扩展了这个库，扩展之后的版本可以从 Hackage 里下载： wl-pprint。如果你用 <strong class="calibre12">cabal</strong> 命令行工具，一个命令即可完成下载，构建和安装： <strong class="calibre12">cabal install wl-pprint</strong>。</p>
<table class="calibre21"><thead class="calibre22"><tr class="calibre23"><th class="calibre24"><a href="#chp-5.html." class="calibre7 pcalibre">[Hughes95]</a></th><th class="calibre24">John Hughes. “<a href="http://citeseer.ist.psu.edu/hughes95design.html" target="_blank" class="calibre7 pcalibre">The design of a pretty-printing library</a> [<a href="http://citeseer.ist.psu.edu/hughes95design.html" target="_blank" class="calibre7 pcalibre">http://citeseer.ist.psu.edu/hughes95design.html</a>]”.May, 1995. First International Spring School on Advanced Functional Programming Techniques. Bastad, Sweden. .</th></tr></thead><tbody class="calibre25"></tbody></table>
<table class="calibre26"><thead class="calibre22"><tr class="calibre23"><th class="calibre24"><a href="#chp-5.html." class="calibre7 pcalibre">[Wadler98]</a></th><th class="calibre24">Philip Wadler. “<a href="http://citeseer.ist.psu.edu/wadler98prettier.html" target="_blank" class="calibre7 pcalibre">A prettier printer</a> [<a href="http://citeseer.ist.psu.edu/wadler98prettier.html" target="_blank" class="calibre7 pcalibre">http://citeseer.ist.psu.edu/wadler98prettier.html</a>]”. March 1998.</th></tr></thead><tbody class="calibre25"></tbody></table>
</div></div></div></div></div></div>
<div id="chp-6.html"><div class="calibre">
<div id="chp-6.html.main" class="calibre1"><div class="root"><div class="article"><h1 class="article-head" id="chp-6.html.calibre_toc_6">第六章：类型类</h1><div class="article-body"><h1 class="calibre6"><a id="chp-6.html._0" class="calibre7 pcalibre"></a>第六章：类型类</h1>
<p class="calibre9">类型类（typeclass）是 Haskell 最强大的功能之一：它用于定义通用接口，为各种不同的类型提供一组公共特性集。</p>
<p class="calibre9">类型类是某些基本语言特性的核心，比如相等性测试和数值操作符。</p>
<p class="calibre9">在讨论如何使用类型类之前，先来看看它能做什么。</p>
<h2 class="calibre14"><a id="chp-6.html._8" class="calibre7 pcalibre"></a>类型类的作用</h2>
<p class="calibre9">假设这样一个场景：我们想对 Color 类型的值进行对比，但 Haskell 的语言设计者却没有实现 == 操作。</p>
<p class="calibre9">要解决这个问题，必须亲自实现一个相等性测试函数：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch06<span class="token3">/</span>colorEq<span class="token">.</span>hs

data Color <span class="token3">=</span> Red <span class="token3">|</span> Green <span class="token3">|</span> Blue

colorEq <span class="token">:</span><span class="token">:</span> Color <span class="token3">-</span><span class="token3">&gt;</span> Color <span class="token3">-</span><span class="token3">&gt;</span> Bool
colorEq Red   Red   <span class="token3">=</span> True
colorEq Green Green <span class="token3">=</span> True
colorEq Blue  Blue  <span class="token3">=</span> True
colorEq _     _     <span class="token3">=</span> False

</code></pre>
<p class="calibre9">在 ghci 里测试：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load colorEq<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> colorEq<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> colorEq Green Green
True

<span class="token3">*</span>Main<span class="token3">&gt;</span> colorEq Blue Red
False

</code></pre>
<p class="calibre9">过了一会，程序又添加了一个新类型 —— 职位：它对公司中的各个员工进行分类。</p>
<p class="calibre9">在执行像是工资计算这类任务是，又需要用到相等性测试，所以又需要再次为职位类型定义相等性测试函数：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch06<span class="token3">/</span>roleEq<span class="token">.</span>hs

data Role <span class="token3">=</span> Boss <span class="token3">|</span> Manager <span class="token3">|</span> Employee

roleEq <span class="token">:</span><span class="token">:</span> Role <span class="token3">-</span><span class="token3">&gt;</span> Role <span class="token3">-</span><span class="token3">&gt;</span> Bool
roleEq Employee Employee <span class="token3">=</span> True
roleEq Manager  Manager  <span class="token3">=</span> True
roleEq Boss     Boss     <span class="token3">=</span> True
roleEq _        _        <span class="token3">=</span> False

</code></pre>
<p class="calibre9">测试：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load roleEq<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> roleEq<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> roleEq Boss Boss
True

<span class="token3">*</span>Main<span class="token3">&gt;</span> roleEq Boss Employee
False

</code></pre>
<p class="calibre9">colorEq 和 roleEq 的定义揭示了一个问题：对于每个不同的类型，我们都需要为它们专门定义一个对比函数。</p>
<p class="calibre9">这种做法非常低效，而且烦人。如果同一个对比函数（比如 == ）可以用于对比任何类型的值，这样就会方便得多。</p>
<p class="calibre9">另一方面，一般来说，如果定义了相等测试函数（比如 == ），那么不等测试函数（比如 /= ）的值就可以直接对相等测试函数取反（使用 not ）来计算得出。因此，如果可以通过相等测试函数来定义不等测试函数，那么会更方便。</p>
<p class="calibre9">通用函数还可以让代码变得更通用：如果同一段代码可以用于不同类型的输入值，那么程序的代码量将大大减少。</p>
<p class="calibre9">还有很重要的一点是，如果在之后添加通用函数对新类型的支持，那么原来的代码应该不需要进行修改。</p>
<p class="calibre9">Haskell 的类型类可以满足以上提到的所有要求。</p>
<h2 class="calibre14"><a id="chp-6.html._86" class="calibre7 pcalibre"></a>什么是类型类？</h2>
<p class="calibre9">类型类定义了一系列函数，这些函数对于不同类型的值使用不同的函数实现。它和其他语言的接口和多态方法有些类似。</p>
<p class="calibre9">[译注：这里原文是将“面向对象编程中的对象”和 Haskell 的类型类进行类比，但实际上这种类比并不太恰当，类比成接口和多态方法更适合一点。]</p>
<p class="calibre9">我们定义一个类型类来解决前面提到的相等性测试问题：</p>
<pre class="calibre15"><code class="tthhighlight-container">class <span class="token5">BasicEq</span> a where
    isEqual <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> Bool

</code></pre>
<p class="calibre9">类型类使用 class 关键字来定义，跟在 class 之后的 BasicEq 是这个类型类的名字，之后的 a 是这个类型类的实例类型（instance type）。</p>
<p class="calibre9">BasicEq 使用类型变量 a 来表示实例类型，说明它并不将这个类型类限定于某个类型：任何一个类型，只要它实现了这个类型类中定义的函数，那么它就是这个类型类的实例类型。</p>
<p class="calibre9">实例类型所使用的名字可以随意选择，但是它和类型类中定义函数签名时所使用的名字应该保持一致。比如说，我们使用 a 来表示实例类型，那么函数签名中也必须使用 a 来代表这个实例类型。</p>
<p class="calibre9">BasicEq 类型类只定义了 isEqual 一个函数 —— 它接受两个参数作为输入，并且这两个参数都指向同一种实例类型：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load BasicEq_1<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> BasicEq_1<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type isEqual
isEqual <span class="token">:</span><span class="token">:</span> BasicEq a <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> Bool

</code></pre>
<p class="calibre9">作为演示，以下代码将 Bool 类型作为 BasicEq 的实例类型，实现了 isEqual 函数：</p>
<pre class="calibre15"><code class="tthhighlight-container">instance BasicEq Bool where
    isEqual True  True  <span class="token3">=</span> True
    isEqual False False <span class="token3">=</span> True
    isEqual _     _     <span class="token3">=</span> False

</code></pre>
<p class="calibre9">在 ghci 里验证这个程序：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> isEqual True True
True

<span class="token3">*</span>Main<span class="token3">&gt;</span> isEqual False True
False

</code></pre>
<p class="calibre9">如果试图将不是 BasicEq 实例类型的值作为输入调用 isEqual 函数，那么就会引发错误：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> isEqual <span class="token4">"hello"</span> <span class="token4">"moto"</span>

<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">5</span><span class="token">:</span><span class="token2">1</span><span class="token">:</span>
    No instance <span class="token1">for</span> <span class="token">(</span>BasicEq <span class="token">[</span>Char<span class="token">]</span><span class="token">)</span>
          arising from a use of `isEqual'
    Possible fix<span class="token">:</span> add an instance declaration <span class="token1">for</span> <span class="token">(</span>BasicEq <span class="token">[</span>Char<span class="token">]</span><span class="token">)</span>
    In the expression<span class="token">:</span> isEqual <span class="token4">"hello"</span> <span class="token4">"moto"</span>
    In an equation <span class="token1">for</span> `it'<span class="token">:</span> it <span class="token3">=</span> isEqual <span class="token4">"hello"</span> <span class="token4">"moto"</span>

</code></pre>
<p class="calibre9">错误信息提醒我们， [Char] 并不是 BasicEq 的实例类型。</p>
<p class="calibre9">稍后的一节会介绍更多关于类型类实例的定义方式，这里先继续前面的例子。这一次，除了 isEqual 之外，我们还想定义不等测试函数 isNotEqual ：</p>
<pre class="calibre15"><code class="tthhighlight-container">class <span class="token5">BasicEq</span> a where
    isEqual    <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> Bool
    isNotEqual <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> Bool

</code></pre>
<p class="calibre9">同时定义 isEqual 和 isNotEqual 两个函数产生了一些不必要的工作：从逻辑上讲，对于任何类型，只要知道 isEqual 或 isNotEqual 的任意一个，就可以计算出另外一个。因此，一种更省事的办法是，为 isEqual 和 isNotEqual 两个函数提供默认值，这样 BasicEq 的实例类型只要实现这两个函数中的一个，就可以顺利使用这两个函数：</p>
<pre class="calibre15"><code class="tthhighlight-container">class <span class="token5">BasicEq</span> a where
    isEqual <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> Bool
    isEqual x y <span class="token3">=</span> not <span class="token">(</span>isNotEqual x y<span class="token">)</span>

    isNotEqual <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> Bool
    isNotEqual x y <span class="token3">=</span> not <span class="token">(</span>isEqual x y<span class="token">)</span>

</code></pre>
<p class="calibre9">以下是将 Bool 作为 BasicEq 实例类型的例子：</p>
<pre class="calibre15"><code class="tthhighlight-container">instance BasicEq Bool where
    isEqual False False <span class="token3">=</span> True
    isEqual True  True  <span class="token3">=</span> True
    isEqual _     _     <span class="token3">=</span> False

</code></pre>
<p class="calibre9">我们只要定义 isEqual 函数，就可以“免费”得到 isNotEqual ：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load BasicEq_3<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> BasicEq_3<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> isEqual True True
True

<span class="token3">*</span>Main<span class="token3">&gt;</span> isEqual False False
True

<span class="token3">*</span>Main<span class="token3">&gt;</span> isNotEqual False True
True

</code></pre>
<p class="calibre9">当然，如果闲着没事，你仍然可以自己亲手定义这两个函数。但是，你至少要定义两个函数中的一个，否则两个默认的函数就会互相调用，直到程序崩溃。</p>
<h2 class="calibre14"><a id="chp-6.html._206" class="calibre7 pcalibre"></a>定义类型类实例</h2>
<p class="calibre9">定义一个类型为某个类型类的实例，指的就是，为某个类型实现给定类型类所声明的全部函数。</p>
<p class="calibre9">比如在前面， BasicEq 类型类定义了两个函数 isEqual 和 isNotEqual ：</p>
<pre class="calibre15"><code class="tthhighlight-container">class <span class="token5">BasicEq</span> a where
    isEqual <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> Bool
    isEqual x y <span class="token3">=</span> not <span class="token">(</span>isNotEqual x y<span class="token">)</span>

    isNotEqual <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> Bool
    isNotEqual x y <span class="token3">=</span> not <span class="token">(</span>isEqual x y<span class="token">)</span>

</code></pre>
<p class="calibre9">在前一节，我们成功将 Bool 类型实现为 BasicEq 的实例类型，要使 Color 类型也成为 BasicEq 类型类的实例，就需要另外为 Color 类型实现 isEqual 和 isNotEqual ：</p>
<pre class="calibre15"><code class="tthhighlight-container">instance BasicEq Color where
    isEqual Red Red <span class="token3">=</span> True
    isEqual Blue Blue <span class="token3">=</span> True
    isEqual Green Green <span class="token3">=</span> True
    isEqual _ _ <span class="token3">=</span> True

</code></pre>
<p class="calibre9">注意，这里的函数定义和之前的 colorEq 函数定义实际上没有什么不同，唯一的区别是，它使得 isEqual 不仅可以对 Bool 类型进行对比测试，还可以对 Color 类型进行对比测试。</p>
<p class="calibre9">更一般地说，只要为相应的类型实现 BasicEq 类型类中的定义，那么 isEqual 就可以用于对比<em class="calibre13">任何</em>我们想对比的类型。</p>
<p class="calibre9">不过在实际中，通常并不使用 BasicEq 类型类，而是使用 Haskell Report 中定义的 Eq 类型类：它定义了 == 和 /= 操作符，这两个操作符才是 Haskell 中最常用的测试函数。</p>
<p class="calibre9">以下是 Eq 类型类的定义：</p>
<pre class="calibre15"><code class="tthhighlight-container">class  <span class="token5">Eq</span> a  where
    <span class="token">(</span><span class="token3">==</span><span class="token">)</span><span class="token">,</span> <span class="token">(</span><span class="token3">/</span><span class="token3">=</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> Bool

<span class="token3">--</span> Minimal complete definition<span class="token">:</span>
<span class="token3">--</span>     <span class="token">(</span><span class="token3">==</span><span class="token">)</span> or <span class="token">(</span><span class="token3">/</span><span class="token3">=</span><span class="token">)</span>
x <span class="token3">/</span><span class="token3">=</span> y     <span class="token3">=</span>  not <span class="token">(</span>x <span class="token3">==</span> y<span class="token">)</span>
x <span class="token3">==</span> y     <span class="token3">=</span>  not <span class="token">(</span>x <span class="token3">/</span><span class="token3">=</span> y<span class="token">)</span>

</code></pre>
<p class="calibre9">稍后会介绍更多使用 Eq 类型类的信息。</p>
<h2 class="calibre14"><a id="chp-6.html._254" class="calibre7 pcalibre"></a>几个重要的内置类型类</h2>
<p class="calibre9">前面两节分别介绍了类型类的定义，以及如何让某个类型成为给定类型类的实例类型。</p>
<p class="calibre9">正本节会介绍几个 Prelude 库中包含的类型类。如本章开始时所说的，类型类是 Haskell 语言某些特性的奠基石，本节就会介绍几个这方面的例子。</p>
<p class="calibre9">更多信息可以参考 Haskell 的函数参考，那里一般都给出了类型类的详细介绍，并且说明，要成为这个类型类的实例，需要实现那些函数。</p>
<h2 class="calibre14"><a id="chp-6.html.Show_262" class="calibre7 pcalibre"></a>Show</h2>
<p class="calibre9">Show 类型类用于将值转换为字符串，它最重要的函数是 show 。</p>
<p class="calibre9">show 函数使用单个参数接收输入数据，并返回一个表示该输入数据的字符串：</p>
<pre class="calibre15"><code class="tthhighlight-container">Main<span class="token3">&gt;</span> <span class="token">:</span>type show
show <span class="token">:</span><span class="token">:</span> Show a <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> String

</code></pre>
<p class="calibre9">以下是一些 show 函数调用的例子：</p>
<pre class="calibre15"><code class="tthhighlight-container">Main<span class="token3">&gt;</span> show <span class="token2">1</span>
<span class="token4">"1"</span>

Main<span class="token3">&gt;</span> show <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">,</span> <span class="token2">3</span><span class="token">]</span>
<span class="token4">"[1,2,3]"</span>

Main<span class="token3">&gt;</span> show <span class="token">(</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">)</span>
<span class="token4">"(1,2)"</span>

</code></pre>
<p class="calibre9">Ghci 输出一个值，实际上就是对这个值调用 putStrLn 和 show ：</p>
<pre class="calibre15"><code class="tthhighlight-container">Main<span class="token3">&gt;</span> <span class="token2">1</span>
<span class="token2">1</span>

Main<span class="token3">&gt;</span> show <span class="token2">1</span>
<span class="token4">"1"</span>

Main<span class="token3">&gt;</span> putStrLn <span class="token">(</span>show <span class="token2">1</span><span class="token">)</span>
<span class="token2">1</span>

</code></pre>
<p class="calibre9">因此，如果你定义了一种新的数据类型，并且希望通过 ghci 来显示它，那么你就应该将这个类型实现为 Show 类型类的实例，否则 ghci 就会向你抱怨，说它不知道该怎样用字符串的形式表示这种数据类型：</p>
<pre class="calibre15"><code class="tthhighlight-container">Main<span class="token3">&gt;</span> data Color <span class="token3">=</span> Red <span class="token3">|</span> Green <span class="token3">|</span> Blue<span class="token">;</span>

Main<span class="token3">&gt;</span> show Red

<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">10</span><span class="token">:</span><span class="token2">1</span><span class="token">:</span>
    No instance <span class="token1">for</span> <span class="token">(</span>Show Color<span class="token">)</span>
        arising from a use of `show'
    Possible fix<span class="token">:</span> add an instance declaration <span class="token1">for</span> <span class="token">(</span>Show Color<span class="token">)</span>
    In the expression<span class="token">:</span> show Red
    In an equation <span class="token1">for</span> `it'<span class="token">:</span> it <span class="token3">=</span> show Red

Prelude<span class="token3">&gt;</span> Red

<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">5</span><span class="token">:</span><span class="token2">1</span><span class="token">:</span>
    No instance <span class="token1">for</span> <span class="token">(</span>Show Color<span class="token">)</span>
        arising from a use of `print'
    Possible fix<span class="token">:</span> add an instance declaration <span class="token1">for</span> <span class="token">(</span>Show Color<span class="token">)</span>
    In a stmt of an interactive GHCi command<span class="token">:</span> print it

</code></pre>
<p class="calibre9">通过实现 Color 类型的 show 函数，让 Color 类型成为 Show 的类型实例，可以解决以上问题：</p>
<pre class="calibre15"><code class="tthhighlight-container">instance Show Color where
    show Red   <span class="token3">=</span> <span class="token4">"Red"</span>
    show Green <span class="token3">=</span> <span class="token4">"Green"</span>
    show Blue  <span class="token3">=</span> <span class="token4">"Blue"</span>

</code></pre>
<p class="calibre9">当然， show 函数的打印值并不是非要和类型构造器一样不可，比如 Red 值并不是非要表示为 "Red" 不可，以下是另一种实例化 Show 类型类的方式：</p>
<pre class="calibre15"><code class="tthhighlight-container">instance Show Color where
    show Red   <span class="token3">=</span> <span class="token4">"Color 1: Red"</span>
    show Green <span class="token3">=</span> <span class="token4">"Color 2: Green"</span>
    show Blue  <span class="token3">=</span> <span class="token4">"Color 3: Blue"</span>

</code></pre>
<h2 class="calibre14"><a id="chp-6.html.Read_346" class="calibre7 pcalibre"></a>Read</h2>
<p class="calibre9">Read 和 Show 类型类的作用正好相反，它将字符串转换为值。</p>
<p class="calibre9">Read 最有用的函数是 read ：它接受一个字符串作为参数，对这个字符串进行处理，并返回一个值，这个值的类型为 Read 实例类型的成员（所有实例类型中的一种）。</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>type read
read <span class="token">:</span><span class="token">:</span> Read a <span class="token3">=</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> a

</code></pre>
<p class="calibre9">以下代码展示了 read 的用法：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> read <span class="token4">"3"</span>

<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">5</span><span class="token">:</span><span class="token2">1</span><span class="token">:</span>
    Ambiguous type variable `a0' <span class="token1">in</span> the constraint<span class="token">:</span>
          <span class="token">(</span>Read a0<span class="token">)</span> arising from a use of `read'
    Probable fix<span class="token">:</span> add a type signature that fixes these type <span class="token5">variable</span><span class="token">(</span>s<span class="token">)</span>
    In the expression<span class="token">:</span> read <span class="token4">"3"</span>
    In an equation <span class="token1">for</span> `it'<span class="token">:</span> it <span class="token3">=</span> read <span class="token4">"3"</span>

Prelude<span class="token3">&gt;</span> <span class="token">(</span>read <span class="token4">"3"</span><span class="token">)</span><span class="token">:</span><span class="token">:</span>Int
<span class="token2">3</span>

Prelude<span class="token3">&gt;</span> <span class="token">:</span>type it
it <span class="token">:</span><span class="token">:</span> Int

Prelude<span class="token3">&gt;</span> <span class="token">(</span>read <span class="token4">"3"</span><span class="token">)</span><span class="token">:</span><span class="token">:</span>Double
<span class="token2">3.0</span>

Prelude<span class="token3">&gt;</span> <span class="token">:</span>type it
it <span class="token">:</span><span class="token">:</span> Double

</code></pre>
<p class="calibre9">注意在第一次调用 read 的时候，我们并没有显式地给定类型签名，这时对 read"3" 的求值会引发错误。这是因为有非常多的类型都是 Read 的实例，而编译器在 read 函数读入 "3" 之后，不知道应该将这个值转换成什么类型，于是编译器就会向我们发牢骚。</p>
<p class="calibre9">因此，为了让 read 函数返回正确类型的值，必须给它指示正确的类型。</p>
<h2 class="calibre14"><a id="chp-6.html._Read__Show__388" class="calibre7 pcalibre"></a>使用 Read 和 Show 进行序列化</h2>
<p class="calibre9">很多时候，程序需要将内存中的数据保存为文件，又或者，反过来，需要将文件中的数据转换为内存中的数据实体。这种转换过程称为<em class="calibre13">序列化</em>和<em class="calibre13">反序列化</em> .</p>
<p class="calibre9">通过将类型实现为 Read 和 Show 的实例类型， read 和 show 两个函数可以成为非常好的序列化工具。</p>
<p class="calibre9">作为例子，以下代码将一个内存中的列表序列化到文件中：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> let years <span class="token3">=</span> <span class="token">[</span><span class="token2">1999</span><span class="token">,</span> <span class="token2">2010</span><span class="token">,</span> <span class="token2">2012</span><span class="token">]</span>

Prelude<span class="token3">&gt;</span> show years
<span class="token4">"[1999,2010,2012]"</span>

Prelude<span class="token3">&gt;</span> writeFile <span class="token4">"years.txt"</span> <span class="token">(</span>show years<span class="token">)</span>

</code></pre>
<p class="calibre9">writeFile 将给定内容写入到文件当中，它接受两个参数，第一个参数是文件路径，第二个参数是写入到文件的字符串内容。</p>
<p class="calibre9">观察文件 years.txt 可以看到， (showyears) 所产生的文本被成功保存到了文件当中：</p>
<pre class="calibre15"><code class="tthhighlight-container">$ cat years<span class="token">.</span>txt
<span class="token">[</span><span class="token2">1999</span><span class="token">,</span><span class="token2">2010</span><span class="token">,</span><span class="token2">2012</span><span class="token">]</span>

</code></pre>
<p class="calibre9">使用以下代码可以对 years.txt 进行反序列化操作：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> input <span class="token3">&lt;</span><span class="token3">-</span> readFile <span class="token4">"years.txt"</span>

Prelude<span class="token3">&gt;</span> input                  <span class="token3">--</span> 读入的字符串
<span class="token4">"[1999,2010,2012]"</span>

Prelude<span class="token3">&gt;</span> <span class="token">(</span>read input<span class="token">)</span><span class="token">:</span><span class="token">:</span><span class="token">[</span>Int<span class="token">]</span>    <span class="token3">--</span> 将字符串转换成列表
<span class="token">[</span><span class="token2">1999</span><span class="token">,</span><span class="token2">2010</span><span class="token">,</span><span class="token2">2012</span><span class="token">]</span>

</code></pre>
<p class="calibre9">readFile 读入给定的 years.txt ，并将它的内存传给 input 变量，最后，通过使用 read ，我们成功将字符串反序列化成一个列表。</p>
<h2 class="calibre14"><a id="chp-6.html._431" class="calibre7 pcalibre"></a>数字类型</h2>
<p class="calibre9">Haskell 有一集非常强大的数字类型：从速度飞快的 32 位或 64 位整数，到任意精度的有理数，包罗万有。</p>
<p class="calibre9">除此之外，Haskell 还有一系列通用算术操作符，这些操作符可以用于几乎所有数字类型。而对数字类型的这种强有力的支持就是建立在类型类的基础上的。</p>
<p class="calibre9">作为一个额外的好处（side benefit），用户可以定义自己的数字类型，并且获得和内置数字类型完全平等的权利。</p>
<p class="calibre9">以下表格显示了 Haskell 中最常用的一些数字类型：</p>
<p class="calibre9"><strong class="calibre12">表格 6.1 ： 部分数字类型</strong></p>
<table class="calibre21"><thead class="calibre22"><tr class="calibre23"><th class="calibre24">类型</th><th class="calibre24">介绍</th></tr></thead><tbody class="calibre25"><tr class="calibre23"><td class="calibre27">Double</td><td class="calibre27">双精度浮点数。表示浮点数的常见选择。</td></tr><tr class="calibre23"><td class="calibre27">Float</td><td class="calibre27">单精度浮点数。通常在对接 C 程序时使用。</td></tr><tr class="calibre23"><td class="calibre27">Int</td><td class="calibre27">固定精度带符号整数；最小范围在 -2^29 至 2^29-1 。相当常用。</td></tr><tr class="calibre23"><td class="calibre27">Int8</td><td class="calibre27">8 位带符号整数</td></tr><tr class="calibre23"><td class="calibre27">Int16</td><td class="calibre27">16 位带符号整数</td></tr><tr class="calibre23"><td class="calibre27">Int32</td><td class="calibre27">32 位带符号整数</td></tr><tr class="calibre23"><td class="calibre27">Int64</td><td class="calibre27">64 位带符号整数</td></tr><tr class="calibre23"><td class="calibre27">Integer</td><td class="calibre27">任意精度带符号整数；范围由机器的内存限制。相当常用。</td></tr><tr class="calibre23"><td class="calibre27">Rational</td><td class="calibre27">任意精度有理数。保存为两个整数之比（ratio）。</td></tr><tr class="calibre23"><td class="calibre27">Word</td><td class="calibre27">固定精度无符号整数。占用的内存大小和 Int 相同</td></tr><tr class="calibre23"><td class="calibre27">Word8</td><td class="calibre27">8 位无符号整数</td></tr><tr class="calibre23"><td class="calibre27">Word16</td><td class="calibre27">16 位无符号整数</td></tr><tr class="calibre23"><td class="calibre27">Word32</td><td class="calibre27">32 位无符号整数</td></tr><tr class="calibre23"><td class="calibre27">Word64</td><td class="calibre27">64 位无符号整数</td></tr></tbody></table>
<p class="calibre9">大部分算术操作都可以用于任意数字类型，少数的一部分函数，比如 asin ，只能用于浮点数类型。</p>
<p class="calibre9">以下表格列举了操作各种数字类型的常见函数和操作符：</p>
<p class="calibre9"><strong class="calibre12">表格 6.2 ： 部分数字函数和</strong></p>
<table class="calibre21"><thead class="calibre22"><tr class="calibre23"><th class="calibre24">项</th><th class="calibre24">类型</th><th class="calibre24">模块</th><th class="calibre24">描述</th></tr></thead><tbody class="calibre25"><tr class="calibre23"><td class="calibre27">(+)</td><td class="calibre27">Num a =&gt; a -&gt; a -&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">加法</td></tr><tr class="calibre23"><td class="calibre27">(-)</td><td class="calibre27">Num a =&gt; a -&gt; a -&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">减法</td></tr><tr class="calibre23"><td class="calibre27">(*)</td><td class="calibre27">Num a =&gt; a -&gt; a -&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">乘法</td></tr><tr class="calibre23"><td class="calibre27">(/)</td><td class="calibre27">Fractional a =&gt; a -&gt; a -&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">份数除法</td></tr><tr class="calibre23"><td class="calibre27">(**)</td><td class="calibre27">Floating a =&gt; a -&gt; a -&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">乘幂</td></tr><tr class="calibre23"><td class="calibre27">(^)</td><td class="calibre27">(Num a, Integral b) =&gt; a -&gt; b -&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">计算某个数的非负整数次方</td></tr><tr class="calibre23"><td class="calibre27">(^^)</td><td class="calibre27">(Fractional a, Integral b) =&gt; a -&gt; b -&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">分数的任意整数次方</td></tr><tr class="calibre23"><td class="calibre27">(%)</td><td class="calibre27">Integral a =&gt; a -&gt; a -&gt; Ratio a</td><td class="calibre27">Data.Ratio</td><td class="calibre27">构成比率</td></tr><tr class="calibre23"><td class="calibre27">(.&amp;.)</td><td class="calibre27">Bits a =&gt; a -&gt; a -&gt; a</td><td class="calibre27">Data.Bits</td><td class="calibre27">二进制并操作</td></tr><tr class="calibre23"><td class="calibre27">(.</td><td class="calibre27">.)</td><td class="calibre27">Bits a =&gt; a -&gt; a -&gt; a</td><td class="calibre27">Data.Bits</td></tr><tr class="calibre23"><td class="calibre27">abs</td><td class="calibre27">Num a =&gt; a -&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">绝对值操作</td></tr><tr class="calibre23"><td class="calibre27">approxRational</td><td class="calibre27">RealFrac a =&gt; a -&gt; a -&gt; Rational</td><td class="calibre27">Data.Ratio</td><td class="calibre27">通过分数的分子和分母计算出近似有理数</td></tr><tr class="calibre23"><td class="calibre27">cos</td><td class="calibre27">Floating a =&gt; a -&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">余弦函数。另外还有 acos 、 cosh 和 acosh ，类型和 cos 一样。</td></tr><tr class="calibre23"><td class="calibre27">div</td><td class="calibre27">Integral a =&gt; a -&gt; a -&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">整数除法，总是截断小数位。</td></tr><tr class="calibre23"><td class="calibre27">fromInteger</td><td class="calibre27">Num a =&gt; Integer -&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">将一个 Integer 值转换为任意数字类型。</td></tr><tr class="calibre23"><td class="calibre27">fromIntegral</td><td class="calibre27">(Integral a, Num b) =&gt; a -&gt; b</td><td class="calibre27">Prelude</td><td class="calibre27">一个更通用的转换函数，将任意 Integral 值转为任意数字类型。</td></tr><tr class="calibre23"><td class="calibre27">fromRational</td><td class="calibre27">Fractional a =&gt; Rational -&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">将一个有理数转换为分数。可能会有精度损失。</td></tr><tr class="calibre23"><td class="calibre27">log</td><td class="calibre27">Floating a =&gt; a -&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">自然对数算法。</td></tr><tr class="calibre23"><td class="calibre27">logBase</td><td class="calibre27">Floating a =&gt; a -&gt; a -&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">计算指定底数对数。</td></tr><tr class="calibre23"><td class="calibre27">maxBound</td><td class="calibre27">Bounded a =&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">有限长度数字类型的最大值。</td></tr><tr class="calibre23"><td class="calibre27">minBound</td><td class="calibre27">Bounded a =&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">有限长度数字类型的最小值。</td></tr><tr class="calibre23"><td class="calibre27">mod</td><td class="calibre27">Integral a =&gt; a -&gt; a -&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">整数取模。</td></tr><tr class="calibre23"><td class="calibre27">pi</td><td class="calibre27">Floating a =&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">圆周率常量。</td></tr><tr class="calibre23"><td class="calibre27">quot</td><td class="calibre27">Integral a =&gt; a -&gt; a -&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">整数除法；商数的分数部分截断为 0 。</td></tr><tr class="calibre23"><td class="calibre27">recip</td><td class="calibre27">Fractional a =&gt; a -&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">分数的倒数。</td></tr><tr class="calibre23"><td class="calibre27">rem</td><td class="calibre27">Integral a =&gt; a -&gt; a -&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">整数除法的余数。</td></tr><tr class="calibre23"><td class="calibre27">round</td><td class="calibre27">(RealFrac a, Integral b) =&gt; a -&gt; b</td><td class="calibre27">Prelude</td><td class="calibre27">四舍五入到最近的整数。</td></tr><tr class="calibre23"><td class="calibre27">shift</td><td class="calibre27">Bits a =&gt; a -&gt; Int -&gt; a</td><td class="calibre27">Bits</td><td class="calibre27">输入为正整数，就进行左移。如果为负数，进行右移。</td></tr><tr class="calibre23"><td class="calibre27">sin</td><td class="calibre27">Floating a =&gt; a -&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">正弦函数。还提供了 asin 、 sinh 和 asinh ，和 sin 类型一样。</td></tr><tr class="calibre23"><td class="calibre27">sqrt</td><td class="calibre27">Floating a =&gt; a -&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">平方根</td></tr><tr class="calibre23"><td class="calibre27">tan</td><td class="calibre27">Floating a =&gt; a -&gt; a</td><td class="calibre27">Prelude</td><td class="calibre27">正切函数。还提供了 atan 、 tanh 和 atanh ，和 tan 类型一样。</td></tr><tr class="calibre23"><td class="calibre27">toInteger</td><td class="calibre27">Integral a =&gt; a -&gt; Integer</td><td class="calibre27">Prelude</td><td class="calibre27">将任意 Integral 值转换为 Integer</td></tr><tr class="calibre23"><td class="calibre27">toRational</td><td class="calibre27">Real a =&gt; a -&gt; Rational</td><td class="calibre27">Prelude</td><td class="calibre27">从实数到有理数的有损转换</td></tr><tr class="calibre23"><td class="calibre27">truncate</td><td class="calibre27">(RealFrac a, Integral b) =&gt; a -&gt; b</td><td class="calibre27">Prelude</td><td class="calibre27">向下取整</td></tr><tr class="calibre23"><td class="calibre27">xor</td><td class="calibre27">Bits a =&gt; a -&gt; a -&gt; a</td><td class="calibre27">Data.Bits</td><td class="calibre27">二进制异或操作</td></tr></tbody></table>
<p class="calibre9">数字类型及其对应的类型类列举在下表：</p>
<p class="calibre9"><strong class="calibre12">表格 6.3 ： 数字类型的类型类实例</strong></p>
<table class="calibre21"><thead class="calibre22"><tr class="calibre23"><th class="calibre24">类型</th><th class="calibre24">Bits</th><th class="calibre24">Bounded</th><th class="calibre24">Floating</th><th class="calibre24">Fractional</th><th class="calibre24">Integral</th><th class="calibre24">Num</th><th class="calibre24">Real</th><th class="calibre24">RealFrac</th></tr></thead><tbody class="calibre25"><tr class="calibre23"><td class="calibre27">Double</td><td class="calibre27"></td><td class="calibre27"></td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27"></td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27">X</td></tr><tr class="calibre23"><td class="calibre27">Float</td><td class="calibre27"></td><td class="calibre27"></td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27"></td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27">X</td></tr><tr class="calibre23"><td class="calibre27">Int</td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27"></td><td class="calibre27"></td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27"></td></tr><tr class="calibre23"><td class="calibre27">Int16</td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27"></td><td class="calibre27"></td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27"></td></tr><tr class="calibre23"><td class="calibre27">Int32</td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27"></td><td class="calibre27"></td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27"></td></tr><tr class="calibre23"><td class="calibre27">Int64</td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27"></td><td class="calibre27"></td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27"></td></tr><tr class="calibre23"><td class="calibre27">Integer</td><td class="calibre27">X</td><td class="calibre27"></td><td class="calibre27"></td><td class="calibre27"></td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27"></td></tr><tr class="calibre23"><td class="calibre27">Rational or any Ratio</td><td class="calibre27"></td><td class="calibre27"></td><td class="calibre27"></td><td class="calibre27">X</td><td class="calibre27"></td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27">X</td></tr><tr class="calibre23"><td class="calibre27">Word</td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27"></td><td class="calibre27"></td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27"></td></tr><tr class="calibre23"><td class="calibre27">Word16</td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27"></td><td class="calibre27"></td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27"></td></tr><tr class="calibre23"><td class="calibre27">Word32</td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27"></td><td class="calibre27"></td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27"></td></tr><tr class="calibre23"><td class="calibre27">Word64</td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27"></td><td class="calibre27"></td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27">X</td><td class="calibre27"></td></tr></tbody></table>
<p class="calibre9">表格 6.2 列举了一些数字类型之间进行转换的函数，以下表格是一个汇总：</p>
<p class="calibre9"><strong class="calibre12">表格 6.4 ： 数字类型之间的转换</strong></p>
<table border="1" class="calibre21"><colgroup class="calibre28"><col width="15%" class="calibre29"><col width="29%" class="calibre29"><col width="15%" class="calibre29"><col width="16%" class="calibre29"><col width="24%" class="calibre29"></colgroup><tbody valign="top" class="calibre25"><tr class="calibre23"><td rowspan="2" class="calibre27">源类型</td><td colspan="4" class="calibre27">目标类型</td></tr><tr class="calibre23"><td class="calibre27">Double, Float</td><td class="calibre27">Int, Word</td><td class="calibre27">Integer</td><td class="calibre27">Rational</td></tr><tr class="calibre23"><td class="calibre27">Double, FloatInt, WordIntegerRational</td><td class="calibre27">fromRational . toRationalfromIntegralfromIntegralfromRational</td><td class="calibre27">truncate *fromIntegralfromIntegraltruncate *</td><td class="calibre27">truncate *fromIntegralN/Atruncate *</td><td class="calibre27">toRationalfromIntegralfromIntegralN/A</td></tr></tbody></table>
<ul class="calibre10"><li class="calibre11">除了 truncate 之外，还可以使用 round 、 ceiling 或者 float 。</li></ul>
<p class="calibre9">第十三章会说明，怎样用自定义数据类型来扩展数字类型。</p>
<h2 class="calibre14"><a id="chp-6.html._533" class="calibre7 pcalibre"></a>相等性，有序和对比</h2>
<p class="calibre9">除了前面介绍的通用算术符号之外，相等测试、不等测试、大于和小于等对比操作也是非常常见的。</p>
<p class="calibre9">其中， Eq 类型类定义了 == 和 /= 操作，而 &gt;= 和 &lt;= 等对比操作，则由 Ord 类型类定义。</p>
<p class="calibre9">需要将对比操作和相等性测试分开用两个类型类来定义的原因是，对于某些类型，它们只对相等性测试和不等测试有兴趣，比如 Handle 类型，而部分有序操作（particular ordering， 大于、小于等）对它来说是没有意义的。</p>
<p class="calibre9">所有 Ord 实例都可以使用 Data.List.sort 来排序。</p>
<p class="calibre9">几乎所有 Haskell 内置类型都是 Eq 类型类的实例，而 Ord 实例的类型也不在少数。</p>
<h2 class="calibre14"><a id="chp-6.html._545" class="calibre7 pcalibre"></a>自动派生</h2>
<p class="calibre9">对于简单的数据类型， Haskell 编译器可以自动将类型派生（derivation）为 Read 、 Show 、 Bounded 、 Enum 、 Eq 和 Ord 的实例。</p>
<p class="calibre9">以下代码将 Color 类型派生为 Read 、 Show 、 Eq 和 Ord 的实例：</p>
<pre class="calibre15"><code class="tthhighlight-container">data Color <span class="token3">=</span> Red <span class="token3">|</span> Green <span class="token3">|</span> Blue
    deriving <span class="token">(</span>Read<span class="token">,</span> Show<span class="token">,</span> Eq<span class="token">,</span> Ord<span class="token">)</span>

</code></pre>
<p class="calibre9">测试：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> show Red
<span class="token4">"Red"</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">(</span>read <span class="token4">"Red"</span><span class="token">)</span><span class="token">:</span><span class="token">:</span>Color
Red

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">(</span>read <span class="token4">"[Red, Red, Blue]"</span><span class="token">)</span><span class="token">:</span><span class="token">:</span><span class="token">[</span>Color<span class="token">]</span>
<span class="token">[</span>Red<span class="token">,</span>Red<span class="token">,</span>Blue<span class="token">]</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> Red <span class="token3">==</span> Red
True

<span class="token3">*</span>Main<span class="token3">&gt;</span> Data<span class="token">.</span>List<span class="token">.</span>sort <span class="token">[</span>Blue<span class="token">,</span> Green<span class="token">,</span> Blue<span class="token">,</span> Red<span class="token">]</span>
<span class="token">[</span>Red<span class="token">,</span>Green<span class="token">,</span>Blue<span class="token">,</span>Blue<span class="token">]</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> Red <span class="token3">&lt;</span> Blue
True

</code></pre>
<p class="calibre9">注意 Color 类型的排序位置由定义类型时值构造器的排序决定。</p>
<p class="calibre9">自动派生并不总是可用的。比如说，如果定义类型 dataMyType=MyType(Int-&gt;Bool) ，那么编译器就没办法派生 MyType 为 Show 的实例，因为它不知道该怎么将 MyType 函数的输出转换成字符串，这会造成编译错误。</p>
<p class="calibre9">除此之外，当使用自动推导将某个类型设置为给定类型类的实例时，定义这个类型时所使用的其他类型，也必须是给定类型类的实例（通过自动推导或手动添加的都可以）。</p>
<p class="calibre9">举个例子，以下代码不能使用自动推导：</p>
<pre class="calibre15"><code class="tthhighlight-container">data Book <span class="token3">=</span> Book

data BookInfo <span class="token3">=</span> BookInfo Book
                deriving <span class="token">(</span>Show<span class="token">)</span>

</code></pre>
<p class="calibre9">Ghci 会给出提示，说明 Book 类型也必须是 Show 的实例， BookInfo 才能对 Show 进行自动推导：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load cant_ad<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> cant_ad<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>

ad<span class="token">.</span>hs<span class="token">:</span><span class="token2">4</span><span class="token">:</span><span class="token2">27</span><span class="token">:</span>
    No instance <span class="token1">for</span> <span class="token">(</span>Show Book<span class="token">)</span>
          arising from the <span class="token4">'deriving'</span> clause of a data type declaration
    Possible fix<span class="token">:</span>
        add an instance declaration <span class="token1">for</span> <span class="token">(</span>Show Book<span class="token">)</span>
        or use a standalone <span class="token4">'deriving instance'</span> declaration<span class="token">,</span>
        so you can specify the instance context yourself
    When deriving the instance <span class="token1">for</span> <span class="token">(</span>Show BookInfo<span class="token">)</span>
Failed<span class="token">,</span> modules loaded<span class="token">:</span> none<span class="token">.</span>

</code></pre>
<p class="calibre9">相反，以下代码可以使用自动推导，因为它对 Book 类型也使用了自动推导，使得 Book 类型变成了 Show 的实例：</p>
<pre class="calibre15"><code class="tthhighlight-container">data Book <span class="token3">=</span> Book
            deriving <span class="token">(</span>Show<span class="token">)</span>

data BookInfo <span class="token3">=</span> BookInfo Book
                deriving <span class="token">(</span>Show<span class="token">)</span>

</code></pre>
<p class="calibre9">使用 :info 命令在 ghci 中确认两种类型都是 Show 的实例：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>load ad<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> ad<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>info Book
data Book <span class="token3">=</span> Book    <span class="token3">--</span> Defined at ad<span class="token">.</span>hs<span class="token">:</span><span class="token2">1</span><span class="token">:</span><span class="token2">6</span>
instance Show Book <span class="token3">--</span> Defined at ad<span class="token">.</span>hs<span class="token">:</span><span class="token2">2</span><span class="token">:</span><span class="token2">23</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>info BookInfo
data BookInfo <span class="token3">=</span> BookInfo Book   <span class="token3">--</span> Defined at ad<span class="token">.</span>hs<span class="token">:</span><span class="token2">4</span><span class="token">:</span><span class="token2">6</span>
instance Show BookInfo <span class="token3">--</span> Defined at ad<span class="token">.</span>hs<span class="token">:</span><span class="token2">5</span><span class="token">:</span><span class="token2">27</span>

</code></pre>
<h2 class="calibre14"><a id="chp-6.html._JSON__642" class="calibre7 pcalibre"></a>类型类实战：让 JSON 更好用</h2>
<p class="calibre9">我们在 <a href="#chp-6.html." class="calibre7 pcalibre"><em class="calibre13">在 Haskell 中表示 JSON 数据</em></a> 一节介绍的 JValue 用起来还不够简便。这里是一段由搜索引擎返回的实际 JSON 数据。删除重整之后：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token">{</span>
    <span class="token4">"query"</span><span class="token">:</span> <span class="token4">"awkward squad haskell"</span><span class="token">,</span>
    <span class="token4">"estimatedCount"</span><span class="token">:</span> <span class="token2">3920</span><span class="token">,</span>
    <span class="token4">"moreResults"</span><span class="token">:</span> <span class="token2">true</span><span class="token">,</span>
    <span class="token4">"results"</span><span class="token">:</span>
    <span class="token">[</span><span class="token">{</span>
        <span class="token4">"title"</span><span class="token">:</span> <span class="token4">"Simon Peyton Jones: papers"</span><span class="token">,</span>
        <span class="token4">"snippet"</span><span class="token">:</span> <span class="token4">"Tackling the awkward squad: monadic input/output ..."</span><span class="token">,</span>
        <span class="token4">"url"</span><span class="token">:</span> <span class="token4">"http://research.microsoft.com/~simonpj/papers/marktoberdorf/"</span><span class="token">,</span>
    <span class="token">}</span><span class="token">,</span>
    <span class="token">{</span>
        <span class="token4">"title"</span><span class="token">:</span> <span class="token4">"Haskell for C Programmers | Lambda the Ultimate"</span><span class="token">,</span>
        <span class="token4">"snippet"</span><span class="token">:</span> <span class="token4">"... the best job of all the tutorials I've read ..."</span><span class="token">,</span>
        <span class="token4">"url"</span><span class="token">:</span> <span class="token4">"http://lambda-the-ultimate.org/node/724"</span><span class="token">,</span>
    <span class="token">}</span><span class="token">]</span>
<span class="token">}</span>

</code></pre>
<p class="calibre9">进一步简化之，并用 Haskell 表示：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch06<span class="token3">/</span>SimpleResult<span class="token">.</span>hs
import SimpleJSON

result <span class="token">:</span><span class="token">:</span> JValue
result <span class="token3">=</span> JObject <span class="token">[</span>
    <span class="token">(</span><span class="token4">"query"</span><span class="token">,</span> JString <span class="token4">"awkward squad haskell"</span><span class="token">)</span><span class="token">,</span>
    <span class="token">(</span><span class="token4">"estimatedCount"</span><span class="token">,</span> JNumber <span class="token2">3920</span><span class="token">)</span><span class="token">,</span>
    <span class="token">(</span><span class="token4">"moreResults"</span><span class="token">,</span> JBool True<span class="token">)</span><span class="token">,</span>
    <span class="token">(</span><span class="token4">"results"</span><span class="token">,</span> JArray <span class="token">[</span>
        JObject <span class="token">[</span>
        <span class="token">(</span><span class="token4">"title"</span><span class="token">,</span> JString <span class="token4">"Simon Peyton Jones: papers"</span><span class="token">)</span><span class="token">,</span>
        <span class="token">(</span><span class="token4">"snippet"</span><span class="token">,</span> JString <span class="token4">"Tackling the awkward ..."</span><span class="token">)</span><span class="token">,</span>
        <span class="token">(</span><span class="token4">"url"</span><span class="token">,</span> JString <span class="token4">"http://.../marktoberdorf/"</span><span class="token">)</span>
        <span class="token">]</span><span class="token">]</span><span class="token">)</span>
    <span class="token">]</span>

</code></pre>
<p class="calibre9">由于 Haskell 不原生支持包含不同类型值的列表，我们不能直接表示包含不同类型值的 JSON 对象。我们需要把每个值都用 JValue 构造器包装起来。但这样我们的灵活性就受到了限制：如果我们想把数字 3920 转换成字符串 "3,920"，我们就必须把 JNumber 构造器换成 JString 构造器。</p>
<p class="calibre9">Haskell 的类型类提供了一个诱人的解决方案：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch06<span class="token3">/</span>JSONClass<span class="token">.</span>hs
type JSONError <span class="token3">=</span> String

class <span class="token5">JSON</span> a where
    toJValue <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> JValue
    fromJValue <span class="token">:</span><span class="token">:</span> JValue <span class="token3">-</span><span class="token3">&gt;</span> Either JSONError a

instance JSON JValue where
    toJValue <span class="token3">=</span> id
    fromJValue <span class="token3">=</span> Right

</code></pre>
<p class="calibre9">现在，我们无需再用 JNumber 等构造器去包装值了，直接使用 toJValue 函数即可。如果我们更改值的类型，编译器会自动选择相应的 toJValue 实现。</p>
<p class="calibre9">我们也提供了 fromJValue 函数，它把 JValue 值转换成我们希望的类型。</p>
<h2 class="calibre14"><a id="chp-6.html._709" class="calibre7 pcalibre"></a>让错误信息更有用</h2>
<p class="calibre9">fromJValue 函数的返回类型为 Either。跟 Maybe 一样，这个类型是预定义的。我们经常用它来表示可能会失败的计算。</p>
<p class="calibre9">虽然 Maybe 也用作这个目的，但它在错误发生时没有给我们足够有用的信息：我们只得到一个 Nothing。Either 类型的结构相同，但它在错误发生时会调用 Left 构造器，并且还接受一个参数。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch06<span class="token3">/</span>DataEither<span class="token">.</span>hs
data Maybe a <span class="token3">=</span> Nothing
             <span class="token3">|</span> Just a
               deriving <span class="token">(</span>Eq<span class="token">,</span> Ord<span class="token">,</span> Read<span class="token">,</span> Show<span class="token">)</span>

data Either a b <span class="token3">=</span> Left a
                <span class="token3">|</span> Right b
                  deriving <span class="token">(</span>Eq<span class="token">,</span> Ord<span class="token">,</span> Read<span class="token">,</span> Show<span class="token">)</span>

</code></pre>
<p class="calibre9">我们经常使用 String 作为 a 参数的类型，以便在出错时提供有用的描述。为了说明在实际中怎么使用 Either 类型，我们来看一个简单实例。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch06<span class="token3">/</span>JSONClass<span class="token">.</span>hs
instance JSON Bool where
    toJValue <span class="token3">=</span> JBool
    fromJValue <span class="token">(</span>JBool b<span class="token">)</span> <span class="token3">=</span> Right b
    fromJValue _ <span class="token3">=</span> Left <span class="token4">"not a JSON boolean"</span>

</code></pre>
<p class="calibre9">[译注：读者若想在 <strong class="calibre12">ghci</strong> 中尝试 fromJValue，需要为其提供类型标注，例如 (fromJValue(toJValueTrue))::EitherJSONErrorBool。]</p>
<h2 class="calibre14"><a id="chp-6.html._740" class="calibre7 pcalibre"></a>使用类型别名创建实例</h2>
<p class="calibre9">Haskell 98标准不允许我们用下面的形式声明实例，尽管它看起来没什么问题：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch06<span class="token3">/</span>JSONClass<span class="token">.</span>hs
instance JSON String where
    toJValue               <span class="token3">=</span> JString

    fromJValue <span class="token">(</span>JString s<span class="token">)</span> <span class="token3">=</span> Right s
    fromJValue _           <span class="token3">=</span> Left <span class="token4">"not a JSON string"</span>

</code></pre>
<p class="calibre9">String 是 [Char] 的别名，因此它的类型是 [a]，并用 Char 替换了类型变量 a。根据 Haskell 98的规则，我们在声明实例的时候不能用具体类型替代类型变量。也就是说，我们可以给 [a] 声明实例，但给 [Char] 不行。</p>
<p class="calibre9">尽管 GHC 默认遵守 Haskell 98标准，但是我们可以在文件顶部添加特殊格式的注释来解除这个限制。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch06<span class="token3">/</span>JSONClass<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span># LANGUAGE TypeSynonymInstances #<span class="token3">-</span><span class="token">}</span>

</code></pre>
<p class="calibre9">这条注释是一条编译器指令，称为<em class="calibre13">编译选项（pragma）</em>，它告诉编译器允许这项语言扩展。上面的代码因为<code class="calibre16">TypeSynonymInstances</code> 这项语言扩展而合法。我们在本章（本书）还会碰到更多的语言扩展。</p>
<p class="calibre9">[译注：作者举的这个例子实际上牵涉到了两个问题。第一，Haskell 98不允许类型别名，这个问题可以通过上述方法解决。第二，Haskell 98不允许 [Char] 这种形式的类型，这个问题需要通过增加另外一条编译选项 {-#LANGUAGEFlexibleInstances#-} 来解决。]</p>
<h2 class="calibre14"><a id="chp-6.html._768" class="calibre7 pcalibre"></a>生活在开放世界</h2>
<p class="calibre9">Haskell 的设计允许我们任意创建类型类实例。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch06<span class="token3">/</span>JSONClass<span class="token">.</span>hs
doubleToJValue <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Double <span class="token3">-</span><span class="token3">&gt;</span> a<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> JValue <span class="token3">-</span><span class="token3">&gt;</span> Either JSONError a
doubleToJValue f <span class="token">(</span>JNumber v<span class="token">)</span> <span class="token3">=</span> Right <span class="token">(</span>f v<span class="token">)</span>
doubleToJValue _ _ <span class="token3">=</span> Left <span class="token4">"not a JSON number"</span>

instance JSON Int where
    toJValue <span class="token3">=</span> JNumber <span class="token">.</span> realToFrac
    fromJValue <span class="token3">=</span> doubleToJValue round

instance JSON Integer where
    toJValue <span class="token3">=</span> JNumber <span class="token">.</span> realToFrac
    fromJValue <span class="token3">=</span> doubleToJValue round

instance JSON Double where
    toJValue <span class="token3">=</span> JNumber
    fromJValue <span class="token3">=</span> doubleToJValue id

</code></pre>
<p class="calibre9">我们可以在任意地方创建新实例，而不仅限于在定义了类型类的模块中。类型类系统的这个特性被称为<em class="calibre13">开放世界假设</em>（open world assumption）。如果有方法表示“这个类型类只存在这些实例”，那我们将得到一个<em class="calibre13">封闭的</em>世界。</p>
<p class="calibre9">我们希望把列表转为 JSON 数组。现在先不用关心实现细节，暂时用 undefined 替代函数内容即可。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch06<span class="token3">/</span>BrokenClass<span class="token">.</span>hs
instance <span class="token">(</span>JSON a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> JSON <span class="token">[</span>a<span class="token">]</span> where
    toJValue <span class="token3">=</span> undefined
    fromJValue <span class="token3">=</span> undefined

</code></pre>
<p class="calibre9">我们也希望能将键/值对列表转为 JSON 对象。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch06<span class="token3">/</span>BrokenClass<span class="token">.</span>hs
instance <span class="token">(</span>JSON a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> JSON <span class="token">[</span><span class="token">(</span>String<span class="token">,</span> a<span class="token">)</span><span class="token">]</span> where
    toJValue <span class="token3">=</span> undefined
    fromJValue <span class="token3">=</span> undefined

</code></pre>
<h2 class="calibre14"><a id="chp-6.html.Overlapping_instances_814" class="calibre7 pcalibre"></a>什么时候重叠实例（Overlapping instances）会出问题？</h2>
<p class="calibre9">如果我们把这些定义放进文件中并在 <strong class="calibre12">ghci</strong> 里载入，初看起来没什么问题。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>JSONClass<span class="token3">&gt;</span> <span class="token">:</span>l BrokenClass<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">2</span><span class="token">]</span> Compiling JSONClass        <span class="token">(</span> JSONClass<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
<span class="token">[</span><span class="token2">2</span> of <span class="token2">2</span><span class="token">]</span> Compiling BrokenClass      <span class="token">(</span> BrokenClass<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> JSONClass<span class="token">,</span> BrokenClass

</code></pre>
<p class="calibre9">然而，当我们使用序对列表实例时，麻烦来了。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>BrokenClass<span class="token3">&gt;</span> toJValue <span class="token">[</span><span class="token">(</span><span class="token4">"foo"</span><span class="token">,</span><span class="token4">"bar"</span><span class="token">)</span><span class="token">]</span>

<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">10</span><span class="token">:</span><span class="token2">1</span><span class="token">:</span>
    Overlapping instances <span class="token1">for</span> JSON <span class="token">[</span><span class="token">(</span><span class="token">[</span>Char<span class="token">]</span><span class="token">,</span> <span class="token">[</span>Char<span class="token">]</span><span class="token">)</span><span class="token">]</span>
        arising from a use of ‘toJValue’
    Matching instances<span class="token">:</span>
        instance JSON a <span class="token3">=</span><span class="token3">&gt;</span> JSON <span class="token">[</span><span class="token">(</span>String<span class="token">,</span> a<span class="token">)</span><span class="token">]</span>
            <span class="token3">--</span> Defined at BrokenClass<span class="token">.</span>hs<span class="token">:</span><span class="token2">13</span><span class="token">:</span><span class="token2">10</span>
        instance JSON a <span class="token3">=</span><span class="token3">&gt;</span> JSON <span class="token">[</span>a<span class="token">]</span> <span class="token3">--</span> Defined at BrokenClass<span class="token">.</span>hs<span class="token">:</span><span class="token2">8</span><span class="token">:</span><span class="token2">10</span>
    In the expression<span class="token">:</span> toJValue <span class="token">[</span><span class="token">(</span><span class="token4">"foo"</span><span class="token">,</span> <span class="token4">"bar"</span><span class="token">)</span><span class="token">]</span>
    In an equation <span class="token1">for</span> ‘it’<span class="token">:</span> it <span class="token3">=</span> toJValue <span class="token">[</span><span class="token">(</span><span class="token4">"foo"</span><span class="token">,</span> <span class="token4">"bar"</span><span class="token">)</span><span class="token">]</span>

</code></pre>
<p class="calibre9">重叠实例问题是由 Haskell 的开放世界假设造成的。 这里有一个更简单的例子来说明发生了什么。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch06<span class="token3">/</span>Overlap<span class="token">.</span>hs
class <span class="token5">Borked</span> a where
    bork <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> String

instance Borked Int where
    bork <span class="token3">=</span> show

instance Borked <span class="token">(</span>Int<span class="token">,</span> Int<span class="token">)</span> where
    bork <span class="token">(</span>a<span class="token">,</span> b<span class="token">)</span> <span class="token3">=</span> bork a <span class="token3">++</span> <span class="token4">", "</span> <span class="token3">++</span> bork b

instance <span class="token">(</span>Borked a<span class="token">,</span> Borked b<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> Borked <span class="token">(</span>a<span class="token">,</span> b<span class="token">)</span> where
    bork <span class="token">(</span>a<span class="token">,</span> b<span class="token">)</span> <span class="token3">=</span> <span class="token4">"&gt;&gt;"</span> <span class="token3">++</span> bork a <span class="token3">++</span> <span class="token4">" "</span> <span class="token3">++</span> bork b <span class="token3">++</span> <span class="token4">"&lt;&lt;"</span>

</code></pre>
<p class="calibre9">对于序对，我们有两个 Borked 类型类实例：一个是 Int 序对，另一个是任意类型的序对，只要这个类型是 Borked 类型类的实例。</p>
<p class="calibre9">假设我们想把 bork 应用于 Int 序对。编译器必须选择一个实例来用。由于这两个实例都能用，所以看上去它好像只要选那个更相关（specific）的实例就可以了。</p>
<p class="calibre9">但是，GHC 默认是保守的。它坚持只能有一个可用实例。这样，当我们试图使用 bork 时，它就会报错。</p>
<p class="calibre9">Note</p>
<p class="calibre9">重叠实例什么时候会出问题？</p>
<p class="calibre9">之前我们提到，我们可以把某个类型类的实例分散在几个模块中。GHC 并不会在意重叠实例的存在。相反，只有当我们使用受影响的类型类的函数，GHC 被迫要选择使用哪个实例时，它才会报错。</p>
<h2 class="calibre14"><a id="chp-6.html._871" class="calibre7 pcalibre"></a>取消类型类的一些限制</h2>
<p class="calibre9">通常，我们不能给多态类型（polymorphic type）的特化版本（specialized version）写类型类实例。[Char] 类型就是多态类型 [a] 特化成 Char 的结果。因此我们禁止声明 [Char] 为某个类型类的实例。这非常不方便，因为字符串在代码中无处不在。</p>
<p class="calibre9">FlexibleInstances 语言扩展取消了这个限制，它允许我们写这样的实例。</p>
<p class="calibre9">GHC 支持另外一个有用的语言扩展，OverlappingInstances，它解决了重叠实例带来的问题。如果存在重叠实例，编译器会选择最相关的（specific）那一个。</p>
<p class="calibre9">我们经常把这个扩展和 TypeSynonymInstances 放在一起使用。下面是一个例子。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch06<span class="token3">/</span>SimpleClass<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span># LANGUAGE TypeSynonymInstances<span class="token">,</span> OverlappingInstances #<span class="token3">-</span><span class="token">}</span>

import Data<span class="token">.</span>List

class <span class="token5">Foo</span> a where
    foo <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> String

instance Foo a <span class="token3">=</span><span class="token3">&gt;</span> Foo <span class="token">[</span>a<span class="token">]</span> where
    foo <span class="token3">=</span> concat <span class="token">.</span> intersperse <span class="token4">", "</span> <span class="token">.</span> map foo

instance Foo Char where
    foo c <span class="token3">=</span> <span class="token">[</span>c<span class="token">]</span>

instance Foo String where
    foo <span class="token3">=</span> id

</code></pre>
<p class="calibre9">如果我们对 String 应用 foo，编译器会选择 String 的特定实现。即使 [a] 和 Char 都是 Foo 的实例，但由于 String 实例更相关，因此 GHC 选择了它。</p>
<p class="calibre9">即使开了 OverlappingInstances 扩展，如果 GHC 发现了多个同样相（equally specific）关的实例，它仍然会拒绝代码。</p>
<blockquote class="default"><p class="calibre9">何时使用 OverlappingInstances 扩展（to be added）</p></blockquote>
<h2 class="calibre14"><a id="chp-6.html._show__907" class="calibre7 pcalibre"></a>字符串的 show 是如何工作的？</h2>
<p class="calibre9">OverlappingInstances 和 TypeSynonymInstances 语言扩展是 GHC 特有的，Haskell 98 并不支持。然而，Haskell 98 中的 Show 类型类在转化 Char 列表和 Int 列表时却用了不同的方法。它用了一个聪明但简单的小技巧。</p>
<p class="calibre9">Show 类型类定义了转换单个值的 show 方法和转换列表的 showList 方法。showList 默认使用中括号和逗号转换列表。</p>
<p class="calibre9">[a] 的 Show 实例使用 showList 实现。Char 的 Show 实例提供了一个特殊的 showList 实现，它使用双引号，并转义非 ASCII 打印字符。</p>
<p class="calibre9">结果是，如果有人想对 [Char] 应用 show，编译器会选择 showList 的实现，并使用双引号正确转换这个字符串。</p>
<p class="calibre9">这样，换个角度看问题，我们就能避免 OverlappingInstances 扩展了。</p>
<h2 class="calibre14"><a id="chp-6.html.Identity_919" class="calibre7 pcalibre"></a>如何给类型定义新身份（Identity）</h2>
<p class="calibre9">除了熟悉的 data 关键字外，Haskell 还允许我们用 newtype 关键字来创建新类型。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch06<span class="token3">/</span>Newtype<span class="token">.</span>hs
data DataInt <span class="token3">=</span> D Int
    deriving <span class="token">(</span>Eq<span class="token">,</span> Ord<span class="token">,</span> Show<span class="token">)</span>

newtype NewtypeInt <span class="token3">=</span> N Int
    deriving <span class="token">(</span>Eq<span class="token">,</span> Ord<span class="token">,</span> Show<span class="token">)</span>

</code></pre>
<p class="calibre9">newtype 声明的作用是重命名现有类型，并给它一个新身份。可以看出，它的用法和使用 data 关键字进行类型声明看起来很相似。</p>
<p class="calibre9">Note</p>
<p class="calibre9">type 和 newtype 关键字</p>
<p class="calibre9">尽管名字类似，type 和 newtype 关键字的作用却完全不同。type 关键字给了我们另一种指代某个类型的方法，类似于给朋友起的绰号。我们和编译器都知道 [Char] 和 String 指的是同一个类型。</p>
<p class="calibre9">相反，newtype 关键字的存在是为了隐藏类型的本性。考虑这个 UniqueID 类型。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch06<span class="token3">/</span>Newtype<span class="token">.</span>hs
newtype UniqueID <span class="token3">=</span> UniqueID Int
    deriving <span class="token">(</span>Eq<span class="token">)</span>

</code></pre>
<p class="calibre9">编译器会把 UniqueID 当成和 Int 不同的类型。作为 UniqueID 的用户，我们只知道它是一个唯一标识符；我们并不知道它是用 Int 来实现的。</p>
<p class="calibre9">在声明 newtype 时，我们必须决定暴露被重命名类型的哪些类型类实例。这里，我们让 NewtypeInt 提供 Int 类型的 Eq， Ord 和 Show 实例。这样，我们就可以比较和打印 NewtypeInt 类型的值了。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> N <span class="token2">1</span> <span class="token3">&lt;</span> N <span class="token2">2</span>
True

</code></pre>
<p class="calibre9">由于我们没有暴露 Int 的 Num 或 Integral 实例，NewtypeInt 类型的值并不是数字。例如，我们不能做加法。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> N <span class="token2">313</span> <span class="token3">+</span> N <span class="token2">37</span>

<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">9</span><span class="token">:</span><span class="token2">7</span><span class="token">:</span>
    No instance <span class="token1">for</span> <span class="token">(</span>Num NewtypeInt<span class="token">)</span> arising from a use of ‘<span class="token3">+</span>’
    In the expression<span class="token">:</span> N <span class="token2">313</span> <span class="token3">+</span> N <span class="token2">37</span>
    In an equation <span class="token1">for</span> ‘it’<span class="token">:</span> it <span class="token3">=</span> N <span class="token2">313</span> <span class="token3">+</span> N <span class="token2">37</span>

</code></pre>
<p class="calibre9">跟用 data 关键字一样，我们可以用 newtype 的值构造器创建新值，或者对现有值进行模式匹配。 如果 newtype 没用自动派生来暴露对应类型的类型类实现的话，我们可以自己写一个新实例或者干脆不实现那个类型类。 data 和 newtype 的区别 newtype 关键字给现有类型一个不同的身份，相比起 data，它使用时的限制更多。具体来讲，newtype 只能有一个值构造器， 并且这个构造器只能有一个字段。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch06<span class="token3">/</span>NewtypeDiff<span class="token">.</span>hs
<span class="token3">--</span> 可以：任意数量的构造器和字段
data TwoFields <span class="token3">=</span> TwoFields Int Int

<span class="token3">--</span> 可以：一个字段
newtype Okay <span class="token3">=</span> ExactlyOne Int

<span class="token3">--</span> 可以：使用类型变量
newtype Param a b <span class="token3">=</span> Param <span class="token">(</span>Either a b<span class="token">)</span>

<span class="token3">--</span> 可以：使用记录语法
newtype Record <span class="token3">=</span> Record <span class="token">{</span>
        getInt <span class="token">:</span><span class="token">:</span> Int
    <span class="token">}</span>

<span class="token3">--</span> 不可以：没有字段
newtype TooFew <span class="token3">=</span> TooFew

<span class="token3">--</span> 不可以：多于一个字段
newtype TooManyFields <span class="token3">=</span> Fields Int Int

<span class="token3">--</span> 不可以：多于一个构造器
newtype TooManyCtors <span class="token3">=</span> Bad Int
                     <span class="token3">|</span> Worse Int

</code></pre>
<p class="calibre9">除此之外，data 和 newtype 还有一个重要区别。由 data 关键字创建的类型在运行时有一个簿记开销，如记录某个值是用哪个构造器创建的。而 newtype 只有一个构造器，所以不需要这个额外开销。这使得它在运行时更省时间和空间。</p>
<p class="calibre9">由于 newtype 的构造器只在编译时使用，运行时甚至不存在，用 newtype 定义的类型和用 data 定义的类型在匹配 undefined 时会有不同的行为。</p>
<p class="calibre9">为了理解它们的不同点，我们首先回顾一下普通数据类型的行为。我们已经非常熟悉，在运行时对 undefined 求值会导致崩溃。</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> undefined
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> Prelude<span class="token">.</span>undefined

</code></pre>
<p class="calibre9">我们把 undefined 放进 D 构造器创建一个 DataInt，然后对它进行模式匹配。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> case <span class="token">(</span>D undefined<span class="token">)</span> of D _ <span class="token3">-</span><span class="token3">&gt;</span> <span class="token2">1</span>
<span class="token2">1</span>

</code></pre>
<p class="calibre9">由于我们的模式匹配只匹配构造器而不管里面的值，undefined 未被求值，因而不会抛出异常。</p>
<p class="calibre9">下面的例子没有使用 D 构造器，因而模式匹配时 undefined 被求值，异常抛出。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> case undefined of D _ <span class="token3">-</span><span class="token3">&gt;</span> <span class="token2">1</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> Prelude<span class="token">.</span>undefined

</code></pre>
<p class="calibre9">当我们用 N 构造器创建 NewtypeInt 值时，它的行为与使用 DataInt 类型的 D 构造器相同：没有异常。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> case <span class="token">(</span>N undefined<span class="token">)</span> of N _ <span class="token3">-</span><span class="token3">&gt;</span> <span class="token2">1</span>
<span class="token2">1</span>

</code></pre>
<p class="calibre9">但当我们把表达式中的 N 去掉，并对 undefined 进行模式匹配时，关键的不同点来了。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> case undefined of N _ <span class="token3">-</span><span class="token3">&gt;</span> <span class="token2">1</span>
<span class="token2">1</span>

</code></pre>
<p class="calibre9">没有崩溃！由于运行时不存在构造器，匹配 N_ 实际上就是在匹配通配符 _：由于通配符总可以被匹配，所以表达式是不需要被求值的。</p>
<h2 class="calibre14"><a id="chp-6.html._1048" class="calibre7 pcalibre"></a>命名类型的三种方式</h2>
<p class="calibre9">这里简要回顾一下 haskell 引入新类型名的三种方式。</p>
<ul class="calibre10"><li class="calibre11">data 关键字定义一个真正的代数数据类型。</li><li class="calibre11">type 关键字给现有类型定义别名。类型和别名可以通用。</li><li class="calibre11">newtype 关键字给现有类型定义一个不同的身份（distinct identity）。原类型和新类型不能通用。</li></ul>
<h2 class="calibre14"><a id="chp-6.html.JSON_typeclasses_without_overlapping_instances_1056" class="calibre7 pcalibre"></a>JSON typeclasses without overlapping instances</h2>
<h2 class="calibre8"><a id="chp-6.html.monomorphism_restriction_1058" class="calibre7 pcalibre"></a>可怕的单一同态限定（monomorphism restriction）</h2>
<p class="calibre9">Haskell 98 有一个微妙的特性可能会在某些意想不到的情况下“咬”到我们。下面这个简单的函数展示了这个问题。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch06<span class="token3">/</span>Monomorphism<span class="token">.</span>hs
myShow <span class="token3">=</span> show

</code></pre>
<p class="calibre9">如果我们试图把它载入 <strong class="calibre12">ghci</strong>，会产生一个奇怪的错误：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>l Monomorphism<span class="token">.</span>hs

<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> Monomorphism<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>

Monomorphism<span class="token">.</span>hs<span class="token">:</span><span class="token2">2</span><span class="token">:</span><span class="token2">10</span><span class="token">:</span>
    No instance <span class="token1">for</span> <span class="token">(</span>Show a0<span class="token">)</span> arising from a use of ‘show’
    The type variable ‘a0’ is ambiguous
    Relevant bindings include
        myShow <span class="token">:</span><span class="token">:</span> a0 <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token">(</span>bound at Monomorphism<span class="token">.</span>hs<span class="token">:</span><span class="token2">2</span><span class="token">:</span><span class="token2">1</span><span class="token">)</span>
    Note<span class="token">:</span> there are several potential instances<span class="token">:</span>
        instance Show a <span class="token3">=</span><span class="token3">&gt;</span> Show <span class="token">(</span>Maybe a<span class="token">)</span> <span class="token3">--</span> Defined <span class="token1">in</span> ‘GHC<span class="token">.</span>Show’
        instance Show Ordering <span class="token3">--</span> Defined <span class="token1">in</span> ‘GHC<span class="token">.</span>Show’
        instance Show Integer <span class="token3">--</span> Defined <span class="token1">in</span> ‘GHC<span class="token">.</span>Show’
        <span class="token">.</span><span class="token">.</span><span class="token">.</span>plus <span class="token2">22</span> others
    In the expression<span class="token">:</span> show
    In an equation <span class="token1">for</span> ‘myShow’<span class="token">:</span> myShow <span class="token3">=</span> show
    Failed<span class="token">,</span> modules loaded<span class="token">:</span> none<span class="token">.</span>

</code></pre>
<p class="calibre9">[译注：译者得到的输出和原文有出入，这里提供的是使用最新版本 GHC 得到的输出。] 错误信息中提到的 “monomorphism” 是 Haskell 98 的一部分。 单一同态是多态（polymorphism）的反义词：它表明某个表达式只有一种类型。 Haskell 有时会强制使某些声明不像我们预想的那么多态。 我们在这里提单一同态是因为尽管它和类型类没有直接关系，但类型类给它提供了产生的环境。 Note 在实际代码中可能很久都不会碰到单一同态，因此我们觉得你没必要记住这部分的细节， 只要在心里知道有这么回事就可以了，除非 GHC 真的报告了跟上面类似的错误。 如果真的发生了，记得在这儿曾读过这个错误，然后回过头来看就行了。 我们不会试图去解释单一同态限制。Haskell 社区一致同意它并不经常出现；它解释起来很棘手（tricky)； 它几乎没什么实际用处；它唯一的作用就是坑人。举个例子来说明它为什么棘手：尽管上面的例子违反了这个限制， 下面的两个编译起来却毫无问题。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch06<span class="token3">/</span>Monomorphism<span class="token">.</span>hs
myShow2 value <span class="token3">=</span> show value

myShow3 <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Show a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> String
myShow3 <span class="token3">=</span> show

</code></pre>
<p class="calibre9">上面的定义表明，如果 GHC 报告单一同态限制错误，我们有三个简单的方法来处理。</p>
<ul class="calibre10"><li class="calibre11">显式声明函数参数，而不是隐性。</li><li class="calibre11">显式定义类型签名，而不是依靠编译器去推导。</li><li class="calibre11">不改代码，编译模块的时候用上 NoMonomorphismRestriction 语言扩展。它取消了单一同态限制。</li></ul>
<p class="calibre9">没人喜欢单一同态限制，因此几乎可以肯定的是下一个版本的 Haskell 会去掉它。但这并不是说加上 NoMonomorphismRestriction 就可以一劳永逸：有些编译器（包括一些老版本的 GHC）识别不了这个扩展，但用另外两种方法就可以解决问题。如果这种可移植性对你不是问题，那么请务必打开这个扩展。</p>
<h2 class="calibre14"><a id="chp-6.html._1108" class="calibre7 pcalibre"></a>结论</h2>
<p class="calibre9">在这章，你学到了类型类有什么用以及怎么用它们。我们讨论了如何定义自己的类型类，然后又讨论了一些 Haskell 库里定义的类型类。最后，我们展示了怎么让 Haskell 编译器给你的类型自动派生出某些类型类实例。</p>
</div></div></div></div></div></div>
<div id="chp-7.html"><div class="calibre">
<div id="chp-7.html.main" class="calibre1"><div class="root"><div class="article"><h1 class="article-head" id="chp-7.html.calibre_toc_7">第七章：I/O</h1><div class="article-body"><h1 class="calibre6"><a id="chp-7.html.IO_0" class="calibre7 pcalibre"></a>第七章：I/O</h1>
<p class="calibre9">就算不是全部，绝大多数的程序员显然还是致力于从外界收集数据，处理这些数据，然后把结果传回外界。也就是说，关键就是输入输出。</p>
<p class="calibre9">Haskell的I/O系统是很强大和富有表现力的。它易于使用，也很有必要去理解。Haskell严格地把纯代码从那些会让外部世界发生事情的代码中分隔开。就是说，它给纯代码提供了完全的副作用隔离。除了帮助程序员推断他们自己代码的正确性，它还使编译器可以自动采取优化和并行化成为可能。</p>
<p class="calibre9">我们将用简单标准的I/O来开始这一章。然后我们要讨论下一些更强大的选项，以及提供更多I/O是怎么适应纯的，惰性的，函数式的Haskell世界的细节。</p>
<h2 class="calibre14"><a id="chp-7.html.HaskellIO_8" class="calibre7 pcalibre"></a>Haskell经典I/O</h2>
<p class="calibre9">让我们开始使用Haskell的I/O吧。先来看一个程序，它看起来很像在C或者Perl等其他语言的I/O。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch07<span class="token3">/</span>basicio<span class="token">.</span>hs
main <span class="token3">=</span> <span class="token1">do</span>
    putStrLn <span class="token4">"Greetings!  What is your name?"</span>
    inpStr <span class="token3">&lt;</span><span class="token3">-</span> getLine
    putStrLn $ <span class="token4">"Welcome to Haskell, "</span> <span class="token3">++</span> inpStr <span class="token3">++</span> <span class="token4">"!"</span>

</code></pre>
<p class="calibre9">你可以编译这个程序，变成一个单独的可执行文件，然后用 <strong class="calibre12">runghc</strong> 运行它，或者从 <strong class="calibre12">ghci</strong> 调用 main 。这里有一个使用<strong class="calibre12">runghc</strong>的例子：</p>
<pre class="calibre15"><code class="tthhighlight-container">$ runghc basicio<span class="token">.</span>hs
Greetings<span class="token3">!</span>  What is your name<span class="token3">?</span>
John
Welcome to Haskell<span class="token">,</span> John<span class="token3">!</span>

</code></pre>
<p class="calibre9">这相单简单，结果很明显。你可以看到 putStrLn 输出一个 string ，后面跟了一个换行符。 getLine 从标准输入读取一行。 &lt;- 语法对于你可能比较新。简单来看，它绑定一个I/O动作的结果到一个名字。我们用简单的列表串联运算符 ++ 来联合输入字符串和我们自己的文本。</p>
<p class="calibre9">让我们来看一下 putStrLn 和 getLine 的类型。你可以在库参考手册里看到这些信息，或者直接问 ghci ：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type putStrLn
putStrLn <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
ghci<span class="token3">&gt;</span> <span class="token">:</span>type getLine
getLine <span class="token">:</span><span class="token">:</span> IO String

</code></pre>
<p class="calibre9">注意，这些类型在他们的返回值里面都有IO。现在关键的是，你要从这里知道他们可能有副作用，或者他们用相同的参数调用可能返回不同的值，或者两者都有。 putStrLn 的类型看起来像一个函数，它接受一个 String 类型的参数，并返回 IO() 类型的值。可是 IO() 是什么呢？</p>
<p class="calibre9">IOsomething 类型的所有东西都是一个IO动作，你可以保存它但是什么都不会发生。我可以说 writefoo=putStrLn"foo" 并且现在什么都不发生。但是如果我过一会在另一个I/O动作中间使用 writefoo ， writefoo 动作将会在它的父动作被执行的时候执行 – I/O动作可以粘合在一起来形成更大的I/O动作。 () 是一个空的元组（读作“unit”），表明从 putStrLn 没有返回值。这和Java或C里面的 void 类似。</p>
<p class="calibre9">Tip</p>
<p class="calibre9">I/O动作可以被创建，赋值和传递到任何地方，但是它们只能在另一个I/O动作里面被执行。</p>
<p class="calibre9">我们在 <strong class="calibre12">ghci</strong> 下看下这句代码：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> let writefoo <span class="token3">=</span> putStrLn <span class="token4">"foo"</span>
ghci<span class="token3">&gt;</span> writefoo
foo

</code></pre>
<p class="calibre9">在这个例子中，输出 foo 不是 putStrLn 的返回值，而是它的副作用，把 foo 写到终端上。</p>
<p class="calibre9">还有另一件事要注意， 实际上是 <strong class="calibre12">ghci</strong> 执行的 writefoo 。意思是，如果给 <strong class="calibre12">ghci</strong> 一个I/O动作，它将会在那个地方帮你执行它。</p>
<p class="calibre9">Note</p>
<p class="calibre9">什么是I/O动作？* 类型是 IOt* 是Haskell的头等值，并且和Haskell的类型系统无缝结合。* 在运行（perform）的时候产生作用，而不是在估值（evaluate）的时候。* 任何表达式都会产生一个动作作为它的值，但是这个动作直到在另一个I/O动作里面被执行的时候才会运行。* 运行（执行）一个 IOt 类型的动作可能运行I/O，并且最终交付一个类型 t 的结果。</p>
<p class="calibre9">getLine 的类型可能看起来比较陌生。它看起来像一个值，而不像一个函数。但实际上，有一种看它的方法： getLine 保存了一个I/O动作。当这个动作运行了你会得到一个 String 。 &lt;- 运算符是用来从运行I/O动作中抽出结果，并且保存到一个变量中。</p>
<p class="calibre9">main 自己就是一个I/O动作，类型是 IO() 。你可以在其他I/O动作中只是运行I/O动作。Haskell程序中的所有I/O动作都是由从 main 的顶部开始驱动的， main 是每一个Haskell程序开始执行的地方。然后，要说的是给Haskell中副作用提供隔离的机制是：你在I/O动作中运行I/O，并且在那儿调用纯的（非I/O）函数。大部分Haskell代码是纯的，I/O动作运行I/O并且调用存代码。</p>
<p class="calibre9">do 是用来定义一串动作的方便方法。你马上就会看到，还有其他方法可以用来定义。当你用这种方式来使用 do 的时候，缩进很重要，确保你的动作正确地对齐了。</p>
<p class="calibre9">只有当你有多余一个动作需要运行的时候才要用到 do 。 do 代码块的值是最后一个动作执行的结果。想要看 do 语法的完整介绍，可以看 <a href="#chp-7.html." class="calibre7 pcalibre"><code class="calibre16">do代码块提取</code>_</a> .</p>
<p class="calibre9">我们来考虑一个在I/O动作中调用存代码的一个例子：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch07<span class="token3">/</span>callingpure<span class="token">.</span>hs
name2reply <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> String
name2reply name <span class="token3">=</span>
    <span class="token4">"Pleased to meet you, "</span> <span class="token3">++</span> name <span class="token3">++</span> <span class="token4">".\n"</span> <span class="token3">++</span>
    <span class="token4">"Your name contains "</span> <span class="token3">++</span> charcount <span class="token3">++</span> <span class="token4">" characters."</span>
    where charcount <span class="token3">=</span> show <span class="token">(</span>length name<span class="token">)</span>

main <span class="token">:</span><span class="token">:</span> IO <span class="token">(</span><span class="token">)</span>
main <span class="token3">=</span> <span class="token1">do</span>
       putStrLn <span class="token4">"Greetings once again.  What is your name?"</span>
       inpStr <span class="token3">&lt;</span><span class="token3">-</span> getLine
       let outStr <span class="token3">=</span> name2reply inpStr
       putStrLn outStr

</code></pre>
<p class="calibre9">注意例子中的 name2replay 函数。这是一个Haskell的一个常规函数，它遵守所有我们告诉过你的规则：给它相同的输入，它总是返回相同的结果，没有副作用，并且以惰性方式运行。它用了其他Haskell函数： (++) ， show 和 length 。</p>
<p class="calibre9">往下看到 main ，我们绑定 name2replayinpStr 的结果到 outStr 。当你在用 do 代码块的时候，你用 &lt;- 去得到I/O动作的结果，用 let 得到存代码的结果。 当你在 do 代码块中使用 let 声明的时候，不要在后面放上 in 。</p>
<p class="calibre9">你可以看到这里是怎么从键盘读取这人的名字的。然后，数据被传到一个纯函数，接着它的结果被打印出来。实际上， main 的最后两行可以被替换成 putStrLn(name2replyinpStr) 。所以， main 有副作用（比如它在终端上显示东西）， name2replay 没有副作用，也不能有副作用。因为 name2replay 是一个纯函数，不是一个动作。</p>
<p class="calibre9">我们在 <strong class="calibre12">ghci</strong> 上检查一下：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>load callingpure<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> callingpure<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>
ghci<span class="token3">&gt;</span> name2reply <span class="token4">"John"</span>
<span class="token4">"Pleased to meet you, John.\nYour name contains 4 characters."</span>
ghci<span class="token3">&gt;</span> putStrLn <span class="token">(</span>name2reply <span class="token4">"John"</span><span class="token">)</span>
Pleased to meet you<span class="token">,</span> John<span class="token">.</span>
Your name contains <span class="token2">4</span> characters<span class="token">.</span>

</code></pre>
<p class="calibre9">字符串里面的 \n 是换行符， 它让终端在输出中开始新的一行。在 <strong class="calibre12">ghci</strong> 直接调用 name2replay"John" 会字面上显示 \n ，因为使用 show 来显示返回值。但是使用 putStrLn 来发送到终端的话，终端会把 \n 解释成开始新的一行。</p>
<p class="calibre9">如果你就在 <strong class="calibre12">ghci</strong> 提示符那打上 main ，你觉得会发生什么？来试一下吧。</p>
<p class="calibre9">看完这几个例子程序之后，你可能会好奇Haskell是不是真正的命令式语言呢，而不是纯的，惰性的，函数式的。这些例子里的一些看起来是按照顺序的一连串的操作。这里面还有很多东西，我们会在这一章的 <a href="#chp-7.html." class="calibre7 pcalibre"><code class="calibre16">Haskell是不是真正的命令式的呢？</code>_</a> 和 <a href="#chp-7.html." class="calibre7 pcalibre">惰性I/O</a> 章节来讨论这个问题。</p>
<h2 class="calibre14"><a id="chp-7.html.Pure_vs_IO_121" class="calibre7 pcalibre"></a>Pure vs. I/O</h2>
<p class="calibre9">这里有一个比较的表格，用来帮助理解存代码和I/O之间的区别。 当我们说起存代码的时候，我们是在说Haskell函数在输入相同的时候总是返回相同结果，并且没有副作用。在Haskell里面只有I/O动作的执行违反这些规则。</p>
<p class="calibre9"><strong class="calibre12">表格7.1. Pure vs. Impure</strong></p>
<table class="calibre21"><thead class="calibre22"><tr class="calibre23"><th class="calibre24">Pure</th><th class="calibre24">Impure</th></tr></thead><tbody class="calibre25"><tr class="calibre23"><td class="calibre27">输入相同时总是产生相同结果</td><td class="calibre27">相同的参数可能产生不同的结果</td></tr><tr class="calibre23"><td class="calibre27">从不会有副作用</td><td class="calibre27">可能有副作用</td></tr><tr class="calibre23"><td class="calibre27">从不修改状态</td><td class="calibre27">可能修改程序、系统或者世界的全局状态</td></tr></tbody></table>
<h2 class="calibre14"><a id="chp-7.html._133" class="calibre7 pcalibre"></a>为什么纯不纯很重要？</h2>
<p class="calibre9">在这一节中，我们已经讨论了Haskell是怎么在存代码和I/O动作之间做了很明确的区分。很多语言没有这种区分。在C或者Java这样的语言中，编译器不能保证一个函数对于同样的参数总是返回同样的结果，或者保证函数没有副作用。要知道一个函数有没有副作用只有一个办法，就是去读它的文档，并且希望文档说的准确。</p>
<p class="calibre9">程序中的很多错误都是由意料之外的副作用造成的。函数在某些情况下对于相同参数可能返回不同的结果，还有更多错误是由于误解了这些情况而造成的。 多线程和其他形式的并行化变得越来越普遍， 管理全局副作用变得越来越困难。</p>
<p class="calibre9">Haskell隔离副作用到I/O动作中的方法提供了一个明确的界限。你总是可以知道系统中的那一部分可能修改状态哪一部分不会。你总是可以确定程序中纯的部分不会有意想不到的结果。这样就帮助你思考程序，也帮助编译器思考程序。比如最新版本的 <strong class="calibre12">ghc</strong> 可以自动给你代码纯的部分提供一定程度的并行化 – 一个计算的神圣目标。</p>
<p class="calibre9">对于这个主题，你可以在 _惰性I/O副作用 一节看更多的讨论。</p>
<h2 class="calibre14"><a id="chp-7.html.Handle_143" class="calibre7 pcalibre"></a>使用文件和句柄（Handle）</h2>
<p class="calibre9">到目前为止，我们已经看了在计算机的终端里怎么和用户交互。当然，你经常会需要去操作某个特定文件，这个也很简单。</p>
<p class="calibre9">Haskell位I/O定义了一些基本函数，其中很多和你在其他语言里面见到的类似。 <a href="http://System.IO" target="_blank" class="calibre7 pcalibre">System.IO</a> 的参考手册为这些函数提供了很好的概要。你会用到这里面某个我们在这里没有提及的某个函数。</p>
<p class="calibre9">通常开始的时候你会用到 openFile ，这个函数给你一个文件句柄，这个句柄用来对这个文件做特定的操作。Haskell提供了像 hPutStrLn 这样的函数，它用起来和 putStrLn 很像，但是多一个参数（句柄），指定操作哪个文件。当操作完成之后，需要用 hClose 来关闭这个句柄 。这些函数都是定义在 <a href="http://System.IO" target="_blank" class="calibre7 pcalibre">System.IO</a> 中的，所以当你操作文件的时候你要引入这个模块。几乎每一个非“h”的函数都有一个对应的“h”函数，比如，print 打印到显示器，有一个对应的 hPrint 打印到文件。</p>
<p class="calibre9">我们用一种命令式的方式来开始读写文件。这有点像一个其他语言中 while 循环，这在Haskell中不是最好的方法。接着我们会看几个更加Haskell风格的例子。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch07<span class="token3">/</span>toupper<span class="token3">-</span>imp<span class="token">.</span>hs
import System<span class="token">.</span>IO
import Data<span class="token">.</span><span class="token5">Char</span><span class="token">(</span>toUpper<span class="token">)</span>

main <span class="token">:</span><span class="token">:</span> IO <span class="token">(</span><span class="token">)</span>
main <span class="token3">=</span> <span class="token1">do</span>
    inh <span class="token3">&lt;</span><span class="token3">-</span> openFile <span class="token4">"input.txt"</span> ReadMode
    outh <span class="token3">&lt;</span><span class="token3">-</span> openFile <span class="token4">"output.txt"</span> WriteMode
    mainloop inh outh
    hClose inh
    hClose outh

mainloop <span class="token">:</span><span class="token">:</span> Handle <span class="token3">-</span><span class="token3">&gt;</span> Handle <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
mainloop inh outh <span class="token3">=</span>
    <span class="token1">do</span> ineof <span class="token3">&lt;</span><span class="token3">-</span> hIsEOF inh
        <span class="token1">if</span> ineof
        then <span class="token1">return</span> <span class="token">(</span><span class="token">)</span>
        <span class="token1">else</span> <span class="token1">do</span> inpStr <span class="token3">&lt;</span><span class="token3">-</span> hGetLine inh
                hPutStrLn outh <span class="token">(</span>map toUpper inpStr<span class="token">)</span>
                mainloop inh outh

</code></pre>
<p class="calibre9">像每一个Haskell程序一样，程序在 main 那里开始执行。两个文件被打开： input.txt 被打开用来读，还有一个 output.txt 被打开用来写。然后我们调用 mainloop 来处理这个文件。</p>
<p class="calibre9">mainloop 开始的时候检查看看我们是否在输入文件的结尾（EOF）。如果不是，我们从输入文件读取一行，把这一行转成大写，再把它写到输出文件。然后我们递归调用 mainloop 继续处理这个文件。</p>
<p class="calibre9">注意那个 return 调用。这个和C或者Python中的 return 不一样。在那些语言中， return 用来立即退出当前函数的执行，并且给调用者返回一个值。在Haskell中， return 是和 &lt;- 相反。也就是说， return 接受一个纯的值，把它包装进IO。因为每个I/O动作必须返回某个 IO 类型，如果你的结果来自纯的计算，你必须用 return 把它包装进IO。举一个例子，如果 7 是一个 Int ，然后 return7 会创建一个动作，里面保存了一个 IOInt 类型的值。在执行的时候，这个动作将会产生结果 7 。关于 return 的更多细节，可以参见 <a href="#chp-7.html." class="calibre7 pcalibre">Return的本色</a> 一节。</p>
<p class="calibre9">我们来尝试运行这个程序。我们已经有一个像这样的名字叫 input.txt 的文件：</p>
<pre class="calibre15"><code class="tthhighlight-container">This is ch08<span class="token3">/</span>input<span class="token">.</span>txt

Test Input
I like Haskell
Haskell is great
I<span class="token3">/</span>O is fun

<span class="token2">123456789</span>

</code></pre>
<p class="calibre9">现在，你可以执行 runghctoupper-imp.hs，你会在你的目录里找到 output.txt 。它看起来应该是这样：</p>
<pre class="calibre15"><code class="tthhighlight-container">THIS IS CH08<span class="token3">/</span>INPUT<span class="token">.</span>TXT

TEST INPUT
I LIKE HASKELL
HASKELL IS GREAT
I<span class="token3">/</span>O IS FUN

<span class="token2">123456789</span>

</code></pre>
<h2 class="calibre14"><a id="chp-7.html._openFile__211" class="calibre7 pcalibre"></a>关于 openFile 的更多信息</h2>
<p class="calibre9">我们用 <strong class="calibre12">ghci</strong> 来检查 openFifle 的类型：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>module System<span class="token">.</span>IO
ghci<span class="token3">&gt;</span> <span class="token">:</span>type openFile
openFile <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IOMode <span class="token3">-</span><span class="token3">&gt;</span> IO Handle

</code></pre>
<p class="calibre9">FilePath 就是 String 的另一个名字。它在I/O函数的类型中使用，用来阐明那个参数是用来表示文件名的，而不是其他通常的数据。</p>
<p class="calibre9">IOMode 指定文件是怎么被管理的， IOMode 的可能值在表格7.2中列出来了。</p>
<p class="calibre9"><strong class="calibre12">表格7.2. IOMode 可能值</strong></p>
<table class="calibre21"><thead class="calibre22"><tr class="calibre23"><th class="calibre24">IOMode</th><th class="calibre24">可读</th><th class="calibre24">可写</th><th class="calibre24">开始位置</th><th class="calibre24">备注</th></tr></thead><tbody class="calibre25"><tr class="calibre23"><td class="calibre27">ReadMode</td><td class="calibre27">是</td><td class="calibre27">否</td><td class="calibre27">文件开头</td><td class="calibre27">文件必须存在</td></tr><tr class="calibre23"><td class="calibre27">WriteMode</td><td class="calibre27">否</td><td class="calibre27">是</td><td class="calibre27">文件开头</td><td class="calibre27">如果存在，文件会被截断（完全清空）</td></tr><tr class="calibre23"><td class="calibre27">ReadWriteMode</td><td class="calibre27">是</td><td class="calibre27">是</td><td class="calibre27">文件开头</td><td class="calibre27">如果不存在会新建文件，如果存在不会损害原来的数据</td></tr><tr class="calibre23"><td class="calibre27">AppendMode</td><td class="calibre27">否</td><td class="calibre27">是</td><td class="calibre27">文件结尾</td><td class="calibre27">如果不存在会新建文件，如果存在不会损害原来的数据</td></tr></tbody></table>
<p class="calibre9">我们在这一章里大多数是操作文本文件，二进制文件同样可以在Haskell里使用。如果你在操作一个二进制文件，你要用 openBinaryFile 替代 openFile 。你当做二进制文件打开，而不是当做文本文件打开的话，像Windows这样的操作系统会用不同的方式来处理文件。在Linux这类操作系统中， openFile 和 openBinaryFile 执行相同的操作。不过为了移植性，当你处理二进制数据的时候总是用 openBinaryFile 还是明智的。</p>
<h2 class="calibre14"><a id="chp-7.html._237" class="calibre7 pcalibre"></a>关闭句柄</h2>
<p class="calibre9">你已经看到 hClose 用来关闭文件句柄 。我们花点时间思考下为什么这个很重要。</p>
<p class="calibre9">就和你将在 <a href="#chp-7.html." class="calibre7 pcalibre">缓冲区（Buffering）</a> 一节看到的一样，Haskell为文件维护内部缓冲区，这提供了一个重要的性能提升。然而，也就是说，直到你在一个打开来写的文件上调用 hClose ，你的数据不会被清理出操作系统。</p>
<p class="calibre9">确保 hClose 的另一个理由是，打开的文件会占用系统资源。如果你的程序运行很长一段时间，并且打开了很多文件，但是没有关闭他们，你的程序很有可能因为资源耗尽而崩溃。所有这些Haskell和其他语言没有什么不同。</p>
<p class="calibre9">当一个程序退出的时候，Haskell通常会小心地关闭所以还打开着的文件。然而在一些情况下Haskell可能不会帮你做这些。所以再一次强调，最好任何时候由你负责调用 hClose 。</p>
<p class="calibre9">Haskell给你提供了一些工具，不管出现什么错误，用来简单地确保这些工作。你可以阅读在 <a href="#chp-7.html." class="calibre7 pcalibre">扩展例子：函数式I/O和临时文件</a> 一节的 finally 和 <a href="#chp-7.html." class="calibre7 pcalibre"><code class="calibre16">获取-使用-回收 周期</code>_</a> 一节的 bracket 。</p>
<h2 class="calibre14"><a id="chp-7.html.Seek_and_Tell_249" class="calibre7 pcalibre"></a>Seek and Tell</h2>
<p class="calibre9">当从一个对应硬盘上某个文件句柄上读写的时候，操作系统维护了一个当前硬盘位置的内部记录。每次你做另一次读的时候，操作系统返回下一个从当前位置开始的数据块，并且增加这个位置，反映出你正在读的数据。</p>
<p class="calibre9">你可以用 hTell 来找出你文件中的当前位置。当文件刚新建的时候，文件是空的，这个位置为0。在你写入5个字节之后，位置会变成5，诸如此类。 hTell 接受一个 Handle 并返回一个带有位置的 IOInteger 。</p>
<p class="calibre9">hTell 的伙伴是 hSeek 。 hSeek 让你可以改变文件位置，它有3个参数：一个 Handle ， 一个 seekMode ，还有一个位置。</p>
<p class="calibre9">SeekMode 可以是三个不同值中的一个，这个值指定怎么去解析这个给的位置。 AbsoluteSeek 表示这个位置是在文件中的精确位置，这个和 hTell 给你的是同样的信息。 RelativeSeek 表示从当前位置开始寻找，一个正数要求在文件中向前推进，一个负数要求向后倒退。最后， SeekFromEnd 会寻找文件结尾之前特定数目的字节。 hSeekhandleSeekFromEnd0 把你带到文件结尾。举一个 hSeek 的例子，参考 <a href="#chp-7.html." class="calibre7 pcalibre">扩展例子：函数式I/O和临时文件</a> 一节。</p>
<p class="calibre9">不是所有句柄都是可以定位的。一个句柄通常对应于一个文件，但是它也可以对应其他东西，比如网络连接，磁带机或者终端。你可以用 hIsSeekable 去看给定的句柄是不是可定位的。</p>
<h2 class="calibre14"><a id="chp-7.html._261" class="calibre7 pcalibre"></a>标准输入，输出和错误</h2>
<p class="calibre9">先前我们指出对于每一个非“h”函数通常有一个对应的“h”函数用在句柄上的。实际上，非“h”的函数就是他们的“h”函数的一个快捷方式。</p>
<p class="calibre9">在 <a href="http://System.IO" target="_blank" class="calibre7 pcalibre">System.IO</a> 里有3个预定义的句柄，这些句柄总是可用的。他们是 stdin ，对应标准输入； stdout ，对应标准输出；和 stderr 对应标准错误。标准输入一般对应键盘，标准输出对应显示器，标准错误一般输出到显示器。</p>
<p class="calibre9">像 getLine 的这些函数可以简单地这样定义：</p>
<pre class="calibre15"><code class="tthhighlight-container">getLine <span class="token3">=</span> hGetLine stdin
putStrLn <span class="token3">=</span> hPutStrLn stdout
print <span class="token3">=</span> hPrint stdout

</code></pre>
<p class="calibre9">Tip</p>
<p class="calibre9">我们这里使用了局部应用。如果不明白，可以参考 <a href="#chp-7.html." class="calibre7 pcalibre"><code class="calibre16">局部函数应用和柯里化</code>_</a></p>
<p class="calibre9">之前我们告诉你这3个标准文件句柄一般对应什么。那是因为一些操作系统可以让你重定向这个文件句柄到不同的地方-文件，设备，甚至是其他程序。这个功能在POSIX（Linux，BSD，Mac）操作系统Shell编程中广泛使用，在Windows中也能使用。</p>
<p class="calibre9">使用标准输入输出经常是很有用的，这让你和终端前的用户交互。它也能让你操作输入输出文件，或者甚至让你的代码和其他程序组合在一起。</p>
<p class="calibre9">举一个例子，我们可以像这样在前面提供标准输入给 callingpure.hs ：</p>
<pre class="calibre15"><code class="tthhighlight-container">$ echo John<span class="token3">|</span>runghc callingpure<span class="token">.</span>hs
Greetings once again<span class="token">.</span>  What is your name<span class="token3">?</span>
Pleased to meet you<span class="token">,</span> John<span class="token">.</span>
Your name contains <span class="token2">4</span> characters<span class="token">.</span>

</code></pre>
<p class="calibre9">当 callingpure.hs 运行的时候，它不用等待键盘的输入，而是从 echo 程序接收 John 。注意输出也没有把 John 这个词放在一个分开的行，这和用键盘运行程序一样。终端一般回显所有你输入的东西给你，但这是一个技术上的输入，不会包含在输出流中。</p>
<h2 class="calibre14"><a id="chp-7.html._296" class="calibre7 pcalibre"></a>删除和重命名文件</h2>
<p class="calibre9">这一章到目前为止，我们已经讨论了文件的内容。现在让我们说一点文件自己的东西。System.Directory 提供了两个你可能觉得有用的函数。 removeFile 接受一个参数，一个文件名，然后删除那个文件。 renameFile 接受两个文件名：第一个是老的文件名，第二个是新的文件名。如果新的文件名在另外一个目录中，你也可以把它想象成移动文件。在调用 renameFile 之前老的文件必须存在。如果新的文件已经存在了，它在重命名之前会被删除掉。</p>
<p class="calibre9">像很多其他接受文件名的函数一样，如果老的文件名不存在， renameFile 会引发一个异常。更多关于异常处理的信息你可以在 <a href="#chp-7.html." class="calibre7 pcalibre"><code class="calibre16">第十九章，错误处理</code>_</a> 中找到。</p>
<p class="calibre9">在 System.Directory 中有很多其他函数，用来创建和删除目录，查找目录中文件列表，和测试文件是否存在。它们在 <a href="#chp-7.html." class="calibre7 pcalibre"><code class="calibre16">目录和文件信息</code>_</a> 一节中讨论。</p>
<h2 class="calibre14"><a id="chp-7.html._304" class="calibre7 pcalibre"></a>临时文件</h2>
<p class="calibre9">程序员频繁需要用到临时文件。临时文件可能用来存储大量需要计算的数据，其他程序要使用的数据，或者很多其他的用法。</p>
<p class="calibre9">当你想一个办法来手动打开同名的多个文件，安全地做到这一点的细节在各个平台上都不相同。Haskell提供了一个方便的函数叫做 openTempFile （还有一个对应的 openBinaryTempFile ）来为你处理这个难点。</p>
<p class="calibre9">openTempFile 接受两个参数：创建文件所在的目录，和一个命名文件的“模板”。这个目录可以简单是“.”，表示当前目录。或者你可以用 System.Directory.getTemporaryDirectory 去找指定机器上存放临时文件最好的地方。这个模板用做文件名的基础，它会添加一些随机的字符来保证文件名是唯一的，从实际上保证被操作的文件具有独一无二的文件名。</p>
<p class="calibre9">openTempFile 返回类型是 IO(FilePath,Handle) 。元组的第一部分是创建的文件的名字，第二部分是用 ReadWriteMode 打开那个文件的一个句柄 。当你处理完这个文件，你要 hClose 它并且调用 removeFile 删除它。看下面的例子中一个样本函数的使用。</p>
<h2 class="calibre14"><a id="chp-7.html.IO_314" class="calibre7 pcalibre"></a>扩展例子：函数式I/O和临时文件</h2>
<p class="calibre9">这里有一个大一点的例子，它把很多这一章的还有前面几章的概念放在一起，还包含了一些没有介绍过的概念。看一下这个程序，看你是否能知道它是干什么的，是怎么做的。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch07<span class="token3">/</span>tempfile<span class="token">.</span>hs
import System<span class="token">.</span>IO
import System<span class="token">.</span><span class="token5">Directory</span><span class="token">(</span>getTemporaryDirectory<span class="token">,</span> removeFile<span class="token">)</span>
import System<span class="token">.</span>IO<span class="token">.</span><span class="token5">Error</span><span class="token">(</span><span class="token1">catch</span><span class="token">)</span>
import Control<span class="token">.</span><span class="token5">Exception</span><span class="token">(</span><span class="token1">finally</span><span class="token">)</span>

<span class="token3">--</span> The main entry point<span class="token">.</span>  Work with a temp file <span class="token1">in</span> myAction<span class="token">.</span>
main <span class="token">:</span><span class="token">:</span> IO <span class="token">(</span><span class="token">)</span>
main <span class="token3">=</span> withTempFile <span class="token4">"mytemp.txt"</span> myAction

<span class="token">{</span><span class="token3">-</span> The guts of the program<span class="token">.</span>  Called with the path and handle of a temporary
file<span class="token">.</span>  When this <span class="token1">function</span> exits<span class="token">,</span> that file will be closed and deleted
because myAction was called from withTempFile<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
myAction <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> Handle <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
myAction tempname temph <span class="token3">=</span>
    <span class="token1">do</span> <span class="token3">--</span> Start by displaying a greeting on the terminal
        putStrLn <span class="token4">"Welcome to tempfile.hs"</span>
        putStrLn $ <span class="token4">"I have a temporary file at "</span> <span class="token3">++</span> tempname

        <span class="token3">--</span> Let's see what the initial position is
        pos <span class="token3">&lt;</span><span class="token3">-</span> hTell temph
        putStrLn $ <span class="token4">"My initial position is "</span> <span class="token3">++</span> show pos

        <span class="token3">--</span> Now<span class="token">,</span> write some data to the temporary file
        let tempdata <span class="token3">=</span> show <span class="token">[</span><span class="token2">1.</span><span class="token2">.10</span><span class="token">]</span>
        putStrLn $ <span class="token4">"Writing one line containing "</span> <span class="token3">++</span>
            show <span class="token">(</span>length tempdata<span class="token">)</span> <span class="token3">++</span> <span class="token4">" bytes: "</span> <span class="token3">++</span>
               tempdata
        hPutStrLn temph tempdata

        <span class="token3">--</span> Get our <span class="token1">new</span> <span class="token5">position<span class="token">.</span></span>  This doesn't actually modify pos
        <span class="token3">--</span> <span class="token1">in</span> memory<span class="token">,</span> but makes the name <span class="token4">"pos"</span> correspond to a different
        <span class="token3">--</span> value <span class="token1">for</span> the remainder of the <span class="token4">"do"</span> block<span class="token">.</span>
        pos <span class="token3">&lt;</span><span class="token3">-</span> hTell temph
        putStrLn $ <span class="token4">"After writing, my new position is "</span> <span class="token3">++</span> show pos

        <span class="token3">--</span> Seek to the beginning of the file and display it
        putStrLn $ <span class="token4">"The file content is: "</span>
        hSeek temph AbsoluteSeek <span class="token2">0</span>

        <span class="token3">--</span> hGetContents performs a lazy read of the entire file
        c <span class="token3">&lt;</span><span class="token3">-</span> hGetContents temph

        <span class="token3">--</span> Copy the file byte<span class="token3">-</span><span class="token1">for</span><span class="token3">-</span>byte to stdout<span class="token">,</span> followed by \n
        putStrLn c

        <span class="token3">--</span> Let's also display it as a Haskell literal
        putStrLn $ <span class="token4">"Which could be expressed as this Haskell literal:"</span>
        print c

<span class="token">{</span><span class="token3">-</span> This <span class="token1">function</span> takes two parameters<span class="token">:</span> a filename pattern and another
<span class="token1">function</span><span class="token">.</span>  It will create a temporary file<span class="token">,</span> and pass the name and Handle
of that file to the given <span class="token1">function</span><span class="token">.</span>

The temporary file is created with openTempFile<span class="token">.</span>  The directory is the one
indicated by getTemporaryDirectory<span class="token">,</span> or<span class="token">,</span> <span class="token1">if</span> the system has no notion of
a temporary directory<span class="token">,</span> <span class="token4">"."</span> is used<span class="token">.</span>  The given pattern is passed to
openTempFile<span class="token">.</span>

After the given <span class="token1">function</span> terminates<span class="token">,</span> even <span class="token1">if</span> it terminates due to an
exception<span class="token">,</span> the Handle is closed and the file is deleted<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
withTempFile <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>FilePath <span class="token3">-</span><span class="token3">&gt;</span> Handle <span class="token3">-</span><span class="token3">&gt;</span> IO a<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> IO a
withTempFile pattern func <span class="token3">=</span>
    <span class="token1">do</span> <span class="token3">--</span> The library ref says that getTemporaryDirectory may raise on
       <span class="token3">--</span> exception on systems that have no notion of a temporary directory<span class="token">.</span>
       <span class="token3">--</span> So<span class="token">,</span> we run getTemporaryDirectory under <span class="token1">catch</span><span class="token">.</span>  <span class="token1">catch</span> takes
       <span class="token3">--</span> two functions<span class="token">:</span> one to run<span class="token">,</span> and a different one to run <span class="token1">if</span> the
       <span class="token3">--</span> first raised an exception<span class="token">.</span>  If getTemporaryDirectory raised an
       <span class="token3">--</span> exception<span class="token">,</span> just use <span class="token4">"."</span> <span class="token">(</span>the current working directory<span class="token">)</span><span class="token">.</span>
       tempdir <span class="token3">&lt;</span><span class="token3">-</span> <span class="token1">catch</span> <span class="token">(</span><span class="token5">getTemporaryDirectory</span><span class="token">)</span> <span class="token">(</span>\_ <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> <span class="token4">"."</span><span class="token">)</span>
       <span class="token">(</span>tempfile<span class="token">,</span> temph<span class="token">)</span> <span class="token3">&lt;</span><span class="token3">-</span> openTempFile tempdir pattern

       <span class="token3">--</span> Call <span class="token">(</span>func tempfile temph<span class="token">)</span> to perform the action on the temporary
       <span class="token3">--</span> file<span class="token">.</span>  <span class="token1">finally</span> takes two actions<span class="token">.</span>  The first is the action to run<span class="token">.</span>
       <span class="token3">--</span> The second is an action to run after the first<span class="token">,</span> regardless of
       <span class="token3">--</span> whether the first action raised an exception<span class="token">.</span>  This way<span class="token">,</span> we ensure
       <span class="token3">--</span> the temporary file is always deleted<span class="token">.</span>  The <span class="token1">return</span> value from <span class="token1">finally</span>
       <span class="token3">--</span> is the first action's <span class="token1">return</span> value<span class="token">.</span>
       <span class="token1">finally</span> <span class="token">(</span>func tempfile temph<span class="token">)</span>
               <span class="token">(</span><span class="token1">do</span> hClose temph
                   removeFile tempfile<span class="token">)</span>

</code></pre>
<p class="calibre9">让我们从结尾开始看这个程序。 writeTempFile 函数证明Haskell当I/O被引入的时候没有忘记它的函数式特性。这个函数接受一个 String 和另外一个函数，传给 withTempFile 的函数使用这个名字和一个临时文件的句柄调用。当函数退出时，这个临时文件被关闭和删除。所以甚至在处理I/O时，我们仍然可以发现为了方便传递函数作为参数的习惯。Lisp程序员可能看到我们的 withTempFile 函数有点类似Lisp的 with-open-file 函数。</p>
<p class="calibre9">为了让程序能够更好地处理错误，我们需要为它添加一些异常处理代码。你一般需要临时文件在处理完成之后被删除，就算有错误发生。所以我们要确保删除发生。关于异常处理的更多信息，请看 <a href="#chp-7.html." class="calibre7 pcalibre"><code class="calibre16">第十九章：错误处理</code>_</a> 。</p>
<p class="calibre9">让我们回到这个程序的开头， main 被简单定义成 withTempFile"mytemp.txt"myAction 。然后, myAction 将会被调用，使用名字和这个临时文件的句柄作为参数。</p>
<p class="calibre9">myAction 显示一些信息到终端，写一些数据到文件，寻找文件的开头，并且使用 hGetContents 把数据读取回来。然后把文件的内容按字节地，通过 printc 当做Haskell字面量显示出来。这和 putStrLn(showc) 一样。</p>
<p class="calibre9">我们看一下输出：</p>
<pre class="calibre15"><code class="tthhighlight-container">$ runhaskell tempfile<span class="token">.</span>hs
Welcome to tempfile<span class="token">.</span>hs
I have a temporary file at <span class="token3">/</span>tmp<span class="token3">/</span>mytemp8572<span class="token">.</span>txt
My initial position is <span class="token2">0</span>
Writing one line containing <span class="token2">22</span> bytes<span class="token">:</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">,</span><span class="token2">4</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">6</span><span class="token">,</span><span class="token2">7</span><span class="token">,</span><span class="token2">8</span><span class="token">,</span><span class="token2">9</span><span class="token">,</span><span class="token2">10</span><span class="token">]</span>
After writing<span class="token">,</span> my <span class="token1">new</span> <span class="token5">position</span> is <span class="token2">23</span>
The file content is<span class="token">:</span>
<span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">,</span><span class="token2">4</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">6</span><span class="token">,</span><span class="token2">7</span><span class="token">,</span><span class="token2">8</span><span class="token">,</span><span class="token2">9</span><span class="token">,</span><span class="token2">10</span><span class="token">]</span>

Which could be expressed as this Haskell literal<span class="token">:</span>
<span class="token4">"[1,2,3,4,5,6,7,8,9,10]\n"</span>

</code></pre>
<p class="calibre9">每次你运行这个程序，你的临时文件的名字应该有点细微的差别，因为它包含了一个随机生成的部分。看一下这个输出，你可能会问一些问题？</p>
<ol class="calibre17"><li class="calibre11">为什么写入一行22个字节之后你的位置是23？</li><li class="calibre11">为什么文件内容显示之后有一个空行？</li><li class="calibre11">为什么Haskell字面量显示的最后有一个 \n ？</li></ol>
<p class="calibre9">你可能能猜到这三个问题的答案都是相关的。看看你能不能在一会内答出这些题。如果你需要帮助，这里有解释：</p>
<ol class="calibre17"><li class="calibre11">是因为我们用 hPutStrLn 替代 hPutStr 来写这个数据。 hPutStrLn 总是在结束一行的时候在结尾处写上一个 \n ，而这个没有出现在 tempdata 。</li><li class="calibre11">我们用 putStrLnc 来显示文件内容 c 。因为数据原来使用 hPutStrLn 来写的，c 结尾处有一个换行符，并且 putStrLn 又添加了第二个换行符，结果就是多了一个空行。</li><li class="calibre11">这个 \n 是来自原始的 hPutStrLn 的换行符。</li></ol>
<p class="calibre9">最后一个注意事项，字节数目可能在一些操作系统上不一样。比如Windows，使用连个字节序列 \r\n 作为行结束标记，所以在Windows平台你可能会看到不同。</p>
<h2 class="calibre14"><a id="chp-7.html.IO_442" class="calibre7 pcalibre"></a>惰性I/O</h2>
<p class="calibre9">这一章到目前为止，你已经看了一些相当传统的I/O例子。单独请求和处理每一行或者每一块数据。</p>
<p class="calibre9">Haskell还为你准备了另一种方法。因为Haskell是一种惰性语言，意思是任何给定的数据片只有在它的值必须要知道的情况下才会被计算。有一些新奇的方法来处理I/O。</p>
<h2 class="calibre14"><a id="chp-7.html.hGetContents_448" class="calibre7 pcalibre"></a>hGetContents</h2>
<p class="calibre9">一种新奇的处理I/O的办法是 hGetContents 函数，这个函数类型是 Handle-&gt;IOString 。这个返回的 String 表示 Handle 所给文件里的所有数据。</p>
<p class="calibre9">在一个严格求值（strictly-evaluated）的语言中，使用这样的函数不是一件好事情。读取一个2KB文件的所有内容可能没事，但是如果你尝试去读取一个500GB文件的所有内容，你很可能因为缺少内存去存储这些数据而崩溃。在这些语言中，传统上你会采用循环去处理文件的全部数据的机制。</p>
<p class="calibre9">但是 hGetContents 不一样。它返回的 String 是惰性估值的。在你调用 hGetContents 的时刻，实际上没有读任何东西。数据只从句柄读取， 作为处理的一个元素（字符）列表。 String 的元素一直都用不到，Haskell的垃圾收集器会自动释放那块内存。所有这些都是完全透明地发生的。因为函数的返回值是一个如假包换的纯 String ，所以它可以被传递给非 I/O 的纯代码。让我们快速看一个例子。回到 <a href="#chp-7.html." class="calibre7 pcalibre"><code class="calibre16">操作文件和句柄</code>_</a> 一节，你看到一个命令式的程序，它把整个文件内容转换成大写。它的命令式算法和你在其他语言看到的很类似。接下来展示的是一个利用了惰性求值实现的更简单的算法。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch07<span class="token3">/</span>toupper<span class="token3">-</span>lazy1<span class="token">.</span>hs
import System<span class="token">.</span>IO
import Data<span class="token">.</span><span class="token5">Char</span><span class="token">(</span>toUpper<span class="token">)</span>

main <span class="token">:</span><span class="token">:</span> IO <span class="token">(</span><span class="token">)</span>
main <span class="token3">=</span> <span class="token1">do</span>
       inh <span class="token3">&lt;</span><span class="token3">-</span> openFile <span class="token4">"input.txt"</span> ReadMode
       outh <span class="token3">&lt;</span><span class="token3">-</span> openFile <span class="token4">"output.txt"</span> WriteMode
       inpStr <span class="token3">&lt;</span><span class="token3">-</span> hGetContents inh
       let result <span class="token3">=</span> processData inpStr
       hPutStr outh result
       hClose inh
       hClose outh

processData <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> String
processData <span class="token3">=</span> map toUpper

</code></pre>
<p class="calibre9">注意到 hGetContents 为我们处理所有的读取工作。看一下 processData ，它是一个纯函数，因为它没有副作用，并且每次调用的时候总是返回相同的结果。它不需要知道，也没办法告诉它，它的输入是惰性从文件读取的。不管是20个字符的字面量还是硬盘上500GB的数据它都可以很好的工作。</p>
<p class="calibre9">你可以用 <strong class="calibre12">ghci</strong> 验证一下：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>load toupper<span class="token3">-</span>lazy1<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> toupper<span class="token3">-</span>lazy1<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>
ghci<span class="token3">&gt;</span> processData <span class="token4">"Hello, there!  How are you?"</span>
<span class="token4">"HELLO, THERE!  HOW ARE YOU?"</span>
ghci<span class="token3">&gt;</span> <span class="token">:</span>type processData
processData <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> String
ghci<span class="token3">&gt;</span> <span class="token">:</span>type processData <span class="token4">"Hello!"</span>
processData <span class="token4">"Hello!"</span> <span class="token">:</span><span class="token">:</span> String

</code></pre>
<p class="calibre9">Warning</p>
<p class="calibre9">如果我们尝试去抓住上面例子中的 inpStr ，在超过它被使用的地方（ processData 调用那），内存中将没有它了。这是因为编译器会强制保存 inpStr 的值在内存里，为了以后的使用。这里我们知道 inpStr 讲不会被重用，它一被使用完就会被释放内存。只要记住：最后一次使用后释放内存。</p>
<p class="calibre9">这个程序为了清楚地表明使用了存代码，显得有点啰嗦。这里有更加简洁的版本，新版本在下一个例子里：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch07<span class="token3">/</span>toupper<span class="token3">-</span>lazy2<span class="token">.</span>hs
import System<span class="token">.</span>IO
import Data<span class="token">.</span><span class="token5">Char</span><span class="token">(</span>toUpper<span class="token">)</span>

main <span class="token3">=</span> <span class="token1">do</span>
       inh <span class="token3">&lt;</span><span class="token3">-</span> openFile <span class="token4">"input.txt"</span> ReadMode
       outh <span class="token3">&lt;</span><span class="token3">-</span> openFile <span class="token4">"output.txt"</span> WriteMode
       inpStr <span class="token3">&lt;</span><span class="token3">-</span> hGetContents inh
       hPutStr outh <span class="token">(</span>map toUpper inpStr<span class="token">)</span>
       hClose inh
       hClose outh

</code></pre>
<p class="calibre9">你在使用 hGetContents 的时候不要求去使用输入文件的所有数据。任何时候Haskell系统能决定整个 hGgetContents 返回的字符串能否被垃圾收集掉，意思就是它不会再被使用，文件会自动被关闭。同样的原理适用于从文件读取的数据。当给定的数据片不会再被使用的任何时候，Haskell会释放它保存的那块内存。严格意义上来讲，我们在这个例子中根本不必要去调用 hClose 。但是，养成习惯去调用还是个好的实践。以后对程序的修改可能让 hClose 的调用变得重要。</p>
<p class="calibre9">Warning</p>
<p class="calibre9">当使用 hGetContents 的时候，记住，就算你可能在剩下的程序里面不再显式引用句柄 ，你绝不能关闭句柄 ，直到在你结束对结果的使用后， 这点很重要。提早关闭会造成丢失文件数据的部分或全部。因为Haskell是惰性的，一般地可以假定，你只有在包含输入的计算被算出结果输出之后，你才能使用这个输入。</p>
<h2 class="calibre14"><a id="chp-7.html.readFilewriteFile_520" class="calibre7 pcalibre"></a>readFile和writeFile</h2>
<p class="calibre9">Haskell程序员经常使用 hGetContents 作为一个过滤器。他们从一个文件读取，在数据上做一些事情，然后把结果写到其他地方。这很常见，有很多种快捷方式可以做。 readFile 和 writeFile 是把文件当做字符串处理的快捷方式。他们处理所有细节，包括打开文件，关闭文件，读取文件和写入文件。 readFile 在内部使用 hGetContents 。</p>
<p class="calibre9">你能猜到这些函数的Haskell类型吗？我们用 <strong class="calibre12">ghci</strong> 检查一下：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type readFile
readFile <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO String
ghci<span class="token3">&gt;</span> <span class="token">:</span>type writeFile
writeFile <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>

</code></pre>
<p class="calibre9">现在有一个例子程序使用了 readFile 和 writeFile ：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch07<span class="token3">/</span>toupper<span class="token3">-</span>lazy3<span class="token">.</span>hs
import Data<span class="token">.</span><span class="token5">Char</span><span class="token">(</span>toUpper<span class="token">)</span>

main <span class="token3">=</span> <span class="token1">do</span>
       inpStr <span class="token3">&lt;</span><span class="token3">-</span> readFile <span class="token4">"input.txt"</span>
       writeFile <span class="token4">"output.txt"</span> <span class="token">(</span>map toUpper inpStr<span class="token">)</span>

</code></pre>
<p class="calibre9">看一下，这个程序的内部只有两行。 readFile 返回一个惰性 String ，我们保存在 inpStr 。然后我们拿到它，处理它，然后把它传给 writeFile 函数去写入。</p>
<p class="calibre9">readFile 和 writeFile 都不提供一个句柄给你操作，所以没有东西要去 hClose 。 readFile 在内部使用 hGetContents ，底下的句柄在返回的 String 被垃圾回收或者所有输入都被消费之后就会被关闭。 writeFile 会在供应给它的 String 全部被写入之后关闭它底下的句柄。</p>
<h2 class="calibre14"><a id="chp-7.html._550" class="calibre7 pcalibre"></a>一言以蔽惰性输出</h2>
<p class="calibre9">到现在为止，你应该理解了Haskell的惰性输入怎么工作的。但是在输入的时候惰性是怎么样的呢？</p>
<p class="calibre9">据你所知，Haskell中的所有东西都是在需要的时候才被求值的。因为像 writeFile 和 putStr 这样的函数写传递给它们的整个 String ， 所以这整个 String 必须被求值。所以保证 putStr 的参数会被完全求值。</p>
<p class="calibre9">但是输入的惰性是什么意思呢？ 在上面的例子中，对 putStr 或者 writeFile 的调用会强制一次性把整个输入字符串载入到内存中吗，直接全部写出？</p>
<p class="calibre9">答案是否定的。 putStr （以及所有类似的输出函数）在它变得可用时才写出数据。他们也不需要保存已经写的数据，所以只要程序中没有其他地方需要它，这块内存就可以立即释放。在某种意义上，你可以把这个在 readFile 和 writeFile 之间的 String 想成一个连接它们两个的管道。数据从一头进去，通过某种方式传递，然后从另外一头流出。</p>
<p class="calibre9">你可以自己验证这个，通过给 toupper-lazy3.hs 产生一个大的 input.txt 。处理它可能时间要花一点时间，但是在处理它的时候你应该能看到一个常量的并且低的内存使用。</p>
<h2 class="calibre14"><a id="chp-7.html.interact_562" class="calibre7 pcalibre"></a>interact</h2>
<p class="calibre9">你学习了 readFile 和 writeFile 处理读文件，做个转换，然后写到不同文件的普通情形。还有一个比他还普遍的情形：从标准输入读取，做一个转换，然后把结果写到标准输出。对于这种情形，有一个函数叫做 interact 。 interact 函数的类型是 (String-&gt;String)-&gt;IO() 。也就是说，它接受一个参数：一个类型为 String-&gt;String 的函数。 getContents 的结果传递给这个函数，也就是，惰性读取标准输入。这个函数的结果会发送到标准输出。</p>
<p class="calibre9">我们可以使用 interact 来转换我们的例子程序去操作标准输入和标准输出。这里有一种方式：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch07<span class="token3">/</span>toupper<span class="token3">-</span>lazy4<span class="token">.</span>hs
import Data<span class="token">.</span><span class="token5">Char</span><span class="token">(</span>toUpper<span class="token">)</span>

main <span class="token3">=</span> interact <span class="token">(</span>map toUpper<span class="token">)</span>

</code></pre>
<p class="calibre9">来看一下，一行就完成了我们的变换。要实现上一个例子同样的效果，你可以像这样来运行这个例子：</p>
<pre class="calibre15"><code class="tthhighlight-container">$ runghc toupper<span class="token3">-</span>lazy4<span class="token">.</span>hs <span class="token3">&lt;</span> input<span class="token">.</span>txt <span class="token3">&gt;</span> output<span class="token">.</span>txt

</code></pre>
<p class="calibre9">或者，如果你想看输出打印在屏幕上的话，你可以打下面的命令：</p>
<pre class="calibre15"><code class="tthhighlight-container">$ runghc toupper<span class="token3">-</span>lazy4<span class="token">.</span>hs <span class="token3">&lt;</span> input<span class="token">.</span>txt

</code></pre>
<p class="calibre9">如果你想看看Haskell是否真的一接收到数据块就立即写出的话，运行 runghctoupper-lazy4.hs ，不要其他的命令行参数。你可以看到每一个你输入的字符都会立马回显，但是都变成大写了。缓冲区可能改变这种行为，更多关于缓冲区的看这一章后面的 <a href="#chp-7.html." class="calibre7 pcalibre"><code class="calibre16">缓冲区</code>_</a> 一节。如果你看到你输入的没一行都立马回显，或者甚至一段时间什么都没有，那就是缓冲区造成的。</p>
<p class="calibre9">你也可以用 interactive 写一个简单的交互程序。让我们从一个简单的例子开始：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch07<span class="token3">/</span>toupper<span class="token3">-</span>lazy5<span class="token">.</span>hs
import Data<span class="token">.</span><span class="token5">Char</span><span class="token">(</span>toUpper<span class="token">)</span>

main <span class="token3">=</span> interact <span class="token">(</span>map toUpper <span class="token">.</span> <span class="token">(</span><span class="token3">++</span><span class="token">)</span> <span class="token4">"Your data, in uppercase, is:\n\n"</span><span class="token">)</span>

</code></pre>
<p class="calibre9">Tip</p>
<p class="calibre9">如果 . 运算符不明白的话，你可以参考 <a href="#chp-7.html." class="calibre7 pcalibre"><code class="calibre16">使用组合来重用代码</code>_</a> 一节。</p>
<p class="calibre9">这里我们在输出的开头添加了一个字符串。你可以发现这个问题吗？</p>
<p class="calibre9">因为我们在 (++) 的结果上调用 map ，这个头自己也会显示成大写。我们可以这样来解决：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch07<span class="token3">/</span>toupper<span class="token3">-</span>lazy6<span class="token">.</span>hs
import Data<span class="token">.</span><span class="token5">Char</span><span class="token">(</span>toUpper<span class="token">)</span>

main <span class="token3">=</span> interact <span class="token">(</span><span class="token">(</span><span class="token3">++</span><span class="token">)</span> <span class="token4">"Your data, in uppercase, is:\n\n"</span> <span class="token">.</span>
                 map toUpper<span class="token">)</span>

</code></pre>
<p class="calibre9">现在把头移出了 map 。</p>
<h2 class="calibre14"><a id="chp-7.html.interact__621" class="calibre7 pcalibre"></a>interact 过滤器</h2>
<p class="calibre9">interact 另一个通常的用法是过滤器。比如说你要写一个程序，这个程序读一个文件，并且输出所有包含字符“a”的行。你可能会这样用 interact 来实现：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch07<span class="token3">/</span>filter<span class="token">.</span>hs
main <span class="token3">=</span> interact <span class="token">(</span>unlines <span class="token">.</span> filter <span class="token">(</span>elem <span class="token4">'a'</span><span class="token">)</span> <span class="token">.</span> lines<span class="token">)</span>

</code></pre>
<p class="calibre9">这里引入了三个你还不熟悉的函数。让我们在 <strong class="calibre12">ghci</strong> 里检查它们的类型：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type lines
lines <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>String<span class="token">]</span>
ghci<span class="token3">&gt;</span> <span class="token">:</span>type unlines
unlines <span class="token">:</span><span class="token">:</span> <span class="token">[</span>String<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> String
ghci<span class="token3">&gt;</span> <span class="token">:</span>type elem
elem <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Eq a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Bool

</code></pre>
<p class="calibre9">你只是看它们的类型，你能猜到它们是干什么的吗？如果不能，你可以在 <a href="#chp-7.html." class="calibre7 pcalibre"><code class="calibre16">热身：快捷文本行分割</code>_</a> 一节和 <a href="#chp-7.html." class="calibre7 pcalibre"><code class="calibre16">特殊字符串处理函数</code>_</a> 一节找到解释。你会频繁看到 lines 和 unlines 和I/O一起使用。最后， elem 接受一个元素和一个列表，如果元素在列中中出现则返回 True 。</p>
<p class="calibre9">试着用我们的标准输入例子来运行：</p>
<pre class="calibre15"><code class="tthhighlight-container">$ runghc filter<span class="token">.</span>hs <span class="token3">&lt;</span> input<span class="token">.</span>txt
I like Haskell
Haskell is great

</code></pre>
<p class="calibre9">果然，你得到包含“a”的两行。惰性过滤器是使用Haskell强大的方式。你想想看，一个过滤器，就像标准Unix程序 <strong class="calibre12">Grep</strong> ，听起来很像一个函数。它接受一些输入，应用一些计算，然后生成一个意料之中的输出。</p>
<h2 class="calibre14"><a id="chp-7.html.The_IO_Monad_656" class="calibre7 pcalibre"></a>The IO Monad</h2>
<p class="calibre9">这个时候你已经看了若干Haskell中I/O的例子。让我们花点时间回想一下，并且思考下I/O是怎么和更广阔的Haskell语言相关联的。</p>
<p class="calibre9">因为Haskell是一个纯的语言，如果你给特定的函数一个指定的参数，每次你给它那个参数这个函数将会返回相同的结果。此外，这个函数不会改变程序的总体状态的任何东西。</p>
<p class="calibre9">你可能想知道I/O是怎么融合到整体中去的呢？当然如果你想从键盘输入中读取一行，去读输入的那个函数肯定不可能每次都返回相同的结果。是不是？此外，I/O都是和改变状态相关的。I/O可以点亮终端上的一个像素，可以让打印机的纸开始出来，或者甚至是让一个包裹从仓库运送到另一个大洲。I/O不只是改变一个程序的状态。你可以把I/O想成可以改变世界的状态。</p>
<h2 class="calibre14"><a id="chp-7.html.Actions_664" class="calibre7 pcalibre"></a>动作（Actions）</h2>
<p class="calibre9">大多数语言在纯函数和非纯函数之间没有明确的区分。Haskell的函数有数学上的意思：它们是纯粹的计算过程，并且这些计算不会被外部所影响。此外，这些计算可以在任何时候、按需地执行。</p>
<p class="calibre9">显然，我们需要其他一些工具来使用I/O。Haskell里的这个工具叫做动作（Actions）。动作类似于函数，它们在定义的时候不做任何事情，而在它们被调用时执行一些任务。I/O动作被定义在 IO Monad。Monad是一种强大的将函数链在一起的方法，在 <a href="#chp-7.html." class="calibre7 pcalibre"><code class="calibre16">第十四章：Monad</code>_</a> 会讲到。为了理解I/O你不是一定要理解Monad，只要理解操作的返回类型都带有 IO 就行了。我们来看一些类型：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type putStrLn
putStrLn <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
ghci<span class="token3">&gt;</span> <span class="token">:</span>type getLine
getLine <span class="token">:</span><span class="token">:</span> IO String

</code></pre>
<p class="calibre9">putStrLn 的类型就像其他函数一样，接受一个参数，返回一个 IO() 。这个 IO() 就是一个操作。如果你想你可以在纯代码中保存和传递操作，虽然我们不经常这么干。一个操作在它被调用前不做任何事情。我们看一个这样的例子：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch07<span class="token3">/</span>actions<span class="token">.</span>hs
str2action <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
str2action input <span class="token3">=</span> putStrLn <span class="token">(</span><span class="token4">"Data: "</span> <span class="token3">++</span> input<span class="token">)</span>

list2actions <span class="token">:</span><span class="token">:</span> <span class="token">[</span>String<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>IO <span class="token">(</span><span class="token">)</span><span class="token">]</span>
list2actions <span class="token3">=</span> map str2action

numbers <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Int<span class="token">]</span>
numbers <span class="token3">=</span> <span class="token">[</span><span class="token2">1.</span><span class="token2">.10</span><span class="token">]</span>

strings <span class="token">:</span><span class="token">:</span> <span class="token">[</span>String<span class="token">]</span>
strings <span class="token3">=</span> map show numbers

actions <span class="token">:</span><span class="token">:</span> <span class="token">[</span>IO <span class="token">(</span><span class="token">)</span><span class="token">]</span>
actions <span class="token3">=</span> list2actions strings

printitall <span class="token">:</span><span class="token">:</span> IO <span class="token">(</span><span class="token">)</span>
printitall <span class="token3">=</span> runall actions

<span class="token3">--</span> Take a list of actions<span class="token">,</span> and execute each of them <span class="token1">in</span> turn<span class="token">.</span>
runall <span class="token">:</span><span class="token">:</span> <span class="token">[</span>IO <span class="token">(</span><span class="token">)</span><span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
runall <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> <span class="token1">return</span> <span class="token">(</span><span class="token">)</span>
runall <span class="token">(</span>firstelem<span class="token">:</span>remainingelems<span class="token">)</span> <span class="token3">=</span>
    <span class="token1">do</span> firstelem
       runall remainingelems

main <span class="token3">=</span> <span class="token1">do</span> str2action <span class="token4">"Start of the program"</span>
          printitall
          str2action <span class="token4">"Done!"</span>

</code></pre>
<p class="calibre9">str2action 这个函数接受一个参数并返回 IO() ，就像你在 main 结尾看到的那样，你可以直接在另一个操作里使用这个函数，它会立刻打印出一行。或者你可以保存（不是执行）纯代码中的操作。你可以在 list2actions 里看到保存的例子，我们在 str2action 用 map ，返回一个操作的列表，就和操作其他纯数据一样。所有东西都通过 printall 显示出来， 而 printall 是用纯代码写的。</p>
<p class="calibre9">虽然我们定义了 printall ，但是直到它的操作在其他地方被求值的时候才会执行。现在注意，我们是怎么在 main 里把 str2action 当做一个I/O操作使用，并且执行了它。但是先前我们在I/O Monad外面使用它，只是把结果收集进一个列表。</p>
<p class="calibre9">你可以这样来思考： do 代码块中的每一个声明，除了 let ，都要产生一个I/O操作，这个操作在将来被执行。</p>
<p class="calibre9">对 printall 的调用最后会执行所有这些操作。实际上，因为Haskell是惰性的，所以这些操作直到这里才会被生成。</p>
<p class="calibre9">当你运行这个程序时，你的输出看起来像这样：</p>
<pre class="calibre15"><code class="tthhighlight-container">Data<span class="token">:</span> Start of the program
Data<span class="token">:</span> <span class="token2">1</span>
Data<span class="token">:</span> <span class="token2">2</span>
Data<span class="token">:</span> <span class="token2">3</span>
Data<span class="token">:</span> <span class="token2">4</span>
Data<span class="token">:</span> <span class="token2">5</span>
Data<span class="token">:</span> <span class="token2">6</span>
Data<span class="token">:</span> <span class="token2">7</span>
Data<span class="token">:</span> <span class="token2">8</span>
Data<span class="token">:</span> <span class="token2">9</span>
Data<span class="token">:</span> <span class="token2">10</span>
Data<span class="token">:</span> Done<span class="token3">!</span>

</code></pre>
<p class="calibre9">我们实际上可以写的更紧凑。来看看这个例子的修改：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch07<span class="token3">/</span>actions2<span class="token">.</span>hs
str2message <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> String
str2message input <span class="token3">=</span> <span class="token4">"Data: "</span> <span class="token3">++</span> input

str2action <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
str2action <span class="token3">=</span> putStrLn <span class="token">.</span> str2message

numbers <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Int<span class="token">]</span>
numbers <span class="token3">=</span> <span class="token">[</span><span class="token2">1.</span><span class="token2">.10</span><span class="token">]</span>

main <span class="token3">=</span> <span class="token1">do</span> str2action <span class="token4">"Start of the program"</span>
          mapM_ <span class="token">(</span>str2action <span class="token">.</span> show<span class="token">)</span> numbers
          str2action <span class="token4">"Done!"</span>

</code></pre>
<p class="calibre9">注意在 str2action 里对标准函数组合运算符的使用。在 main 里面，有一个对 mapM_ 的调用，这个函数和 map 类似，接受一个函数和一个列表。提供给 mapM_ 的函数是一个I/O操作，这个操作对列表中的每一项都执行。 mapM_ 扔掉了函数的结果，但是如果你想要 I/O的结果，你可以用 mapM 返回一个I/O结果的列表。来看一下它们的类型：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type mapM
mapM <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Monad m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> m b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> m <span class="token">[</span>b<span class="token">]</span>
ghci<span class="token3">&gt;</span> <span class="token">:</span>type mapM_
mapM_ <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Monad m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> m b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> m <span class="token">(</span><span class="token">)</span>

</code></pre>
<p class="calibre9">Tip</p>
<p class="calibre9">这些函数其实可以做I/O更多的事情，所有的Monad都可以使用他们。到现在为止，你看到“M”就把它想成“IO”。还有，那些以下划线结尾的函数一般不管它们的返回值。</p>
<p class="calibre9">为什么我们有了 map 还要有一个 mapM ，因为 map 是返回一个列表的纯函数，它实际上不直接执行也不能执行操作。 maoM 是一个 IO Monda里面的可以执行操作的实用程序。</p>
<p class="calibre9">现在回到 main ， mapM_ 在 numbers.show 每个元素上应用 (str2action.show) ， number.show 把每个数字转换成一个 String ， str2action 把每个 String 转换成一个操作。 mapM_ 把这些单独的操作组合成一个打的操作，然后打印出这些行。</p>
<h2 class="calibre14"><a id="chp-7.html._776" class="calibre7 pcalibre"></a>串联化</h2>
<p class="calibre9">do 代码块实际上是把操作连接在一起的快捷记号。有两个运算符可以用来代替 do 代码块： &gt;&gt; 和 &gt;&gt;= 。在 <strong class="calibre12">ghci</strong> 看一下它们的类型：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token">(</span><span class="token3">&gt;</span><span class="token3">&gt;</span><span class="token">)</span>
<span class="token">(</span><span class="token3">&gt;</span><span class="token3">&gt;</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Monad m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> m a <span class="token3">-</span><span class="token3">&gt;</span> m b <span class="token3">-</span><span class="token3">&gt;</span> m b
ghci<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token">(</span><span class="token3">&gt;</span><span class="token3">&gt;=</span><span class="token">)</span>
<span class="token">(</span><span class="token3">&gt;</span><span class="token3">&gt;=</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Monad m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> m a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> m b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> m b

</code></pre>
<blockquote class="default"><blockquote class="default1"><p class="calibre9">运算符把两个操作串联在一起：第一个操作先运行，然后是第二个。运算符的计算的结果是第二个操作的结果，第一个操作的结果被丢弃了。这和在 do 代码块中只有一行是类似的。你可能会写 putStrLn"line1"&gt;&gt;putStrLn"line2" 来测试这一点。它会打印出两行，把第一个 putStrLn 的结果丢掉了，值提供第二个操作的结果。</p></blockquote></blockquote>
<blockquote class="default"><blockquote class="default1"><p class="calibre9">= 运算符运行一个操作，然后把它的结果传递给一个返回操作的函数。那样第二个操作可以同样运行，而且整个表达式的结果就是第二个操作的结果。例如，你写 getLine&gt;&gt;=putStrLn ，这会从键盘读取一行，然后显示出来。</p></blockquote></blockquote>
<p class="calibre9">让我们重写例子中的一个，不用 do 代码快。还记得这一章开头的这个例子吗？</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch07<span class="token3">/</span>basicio<span class="token">.</span>hs
main <span class="token3">=</span> <span class="token1">do</span>
       putStrLn <span class="token4">"Greetings!  What is your name?"</span>
       inpStr <span class="token3">&lt;</span><span class="token3">-</span> getLine
       putStrLn $ <span class="token4">"Welcome to Haskell, "</span> <span class="token3">++</span> inpStr <span class="token3">++</span> <span class="token4">"!"</span>

</code></pre>
<p class="calibre9">我们不用 do 代码块来重写它：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch07<span class="token3">/</span>basicio<span class="token3">-</span>nodo<span class="token">.</span>hs
main <span class="token3">=</span>
    putStrLn <span class="token4">"Greetings!  What is your name?"</span> <span class="token3">&gt;</span><span class="token3">&gt;</span>
    getLine <span class="token3">&gt;</span><span class="token3">&gt;=</span>
    <span class="token">(</span>\inpStr <span class="token3">-</span><span class="token3">&gt;</span> putStrLn $ <span class="token4">"Welcome to Haskell, "</span> <span class="token3">++</span> inpStr <span class="token3">++</span> <span class="token4">"!"</span><span class="token">)</span>

</code></pre>
<p class="calibre9">你定义 do 代码块的时候，Haskell编译器内部会把它翻译成像这样。</p>
<p class="calibre9">Tip</p>
<p class="calibre9">忘记了怎么使用 \ (lambda表达式)了吗？参见 <a href="#chp-7.html." class="calibre7 pcalibre"><code class="calibre16">匿名（lambda）函数</code>_</a> 一节。</p>
<h2 class="calibre14"><a id="chp-7.html.Return_820" class="calibre7 pcalibre"></a>Return的本色</h2>
<p class="calibre9">在这一章的前面，我们提到 return 很可能不是它看起来的那样。很多语言有一个关键字叫做 return ，它取消函数的执行并立即给调用者一个返回值。</p>
<p class="calibre9">Haskell的 return 函数很不一样。在Haskell中， return 用来在Monad里面包装数据。当说I/O的时候， return 用来拿到纯数据并把它带入IO Monad。</p>
<p class="calibre9">为什么我们需要那样做？还记得结果依赖I/O的所有东西都必须在一个IO Monad里面吗？所以如果我们在写一个执行I/O的函数，然后一个纯的计算，我们需要用 return 来让这个纯的计算能给函数返回一个合适的值。否则，会发生一个类型错误。这儿有一个例子：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch07<span class="token3">/</span>return1<span class="token">.</span>hs
import Data<span class="token">.</span><span class="token5">Char</span><span class="token">(</span>toUpper<span class="token">)</span>

isGreen <span class="token">:</span><span class="token">:</span> IO Bool
isGreen <span class="token3">=</span>
    <span class="token1">do</span> putStrLn <span class="token4">"Is green your favorite color?"</span>
       inpStr <span class="token3">&lt;</span><span class="token3">-</span> getLine
       <span class="token1">return</span> <span class="token">(</span><span class="token">(</span>toUpper <span class="token">.</span> head $ inpStr<span class="token">)</span> <span class="token3">==</span> <span class="token4">'Y'</span><span class="token">)</span>

</code></pre>
<p class="calibre9">我们有一个纯的计算产生一个 Bool ，这个计算传给了 return ， return 把它放进了 IO Monad。因为它是 do 代码块的最后一个值，所以它变成 isGreen 的返回值，而不是因为我们用了 return 函数。</p>
<p class="calibre9">这有一个相同程序但是把纯计算移到一个单独的函数里的版本。这帮助纯代码保持分离，并且让意图更清晰。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch07<span class="token3">/</span>return2<span class="token">.</span>hs
import Data<span class="token">.</span><span class="token5">Char</span><span class="token">(</span>toUpper<span class="token">)</span>

isYes <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> Bool
isYes inpStr <span class="token3">=</span> <span class="token">(</span>toUpper <span class="token">.</span> head $ inpStr<span class="token">)</span> <span class="token3">==</span> <span class="token4">'Y'</span>

isGreen <span class="token">:</span><span class="token">:</span> IO Bool
isGreen <span class="token3">=</span>
    <span class="token1">do</span> putStrLn <span class="token4">"Is green your favorite color?"</span>
       inpStr <span class="token3">&lt;</span><span class="token3">-</span> getLine
       <span class="token1">return</span> <span class="token">(</span>isYes inpStr<span class="token">)</span>

</code></pre>
<p class="calibre9">最后，有一个人为的例子，这个例子显示了 return 确实没有在 do 代码块的结尾出现。在实践中，通常是这样的，但是不一定需要这样。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch07<span class="token3">/</span>return3<span class="token">.</span>hs
returnTest <span class="token">:</span><span class="token">:</span> IO <span class="token">(</span><span class="token">)</span>
returnTest <span class="token3">=</span>
    <span class="token1">do</span> one <span class="token3">&lt;</span><span class="token3">-</span> <span class="token1">return</span> <span class="token2">1</span>
       let two <span class="token3">=</span> <span class="token2">2</span>
       putStrLn $ show <span class="token">(</span>one <span class="token3">+</span> two<span class="token">)</span>

</code></pre>
<p class="calibre9">注意，我们用了 &lt;- 和 return 的组合，但是 let 是和简单字面量组合的。这是因为我们需要都是纯的值才能去相加它们， &lt;- 把东西从Monad里面拿出来，实际上就是 return 的反作用。在 <strong class="calibre12">ghci</strong> 运行一下，你会看到和预期一样显示3。</p>
<h2 class="calibre14"><a id="chp-7.html.Haskell__873" class="calibre7 pcalibre"></a>Haskell 实际上是命令式的吗？</h2>
<p class="calibre9">这些 do 代码块可能开起来很像一个命令式语言？毕竟大部分时间你给了一些命令按顺序运行。</p>
<p class="calibre9">但是Haskell在它的核心上是一个惰性语言。时常在需要给I/O串联操作的时候，是由一些工具完成的，这些工具就是Haskell的一部分。Haskell通过 I/O Monad实现了出色的I/O和语言剩余部分的分离。</p>
<h2 class="calibre14"><a id="chp-7.html.IO_879" class="calibre7 pcalibre"></a>惰性I/O的副作用</h2>
<p class="calibre9">本章前面你看到了 hGetContents ，我们解释说它返回的 String 可以在纯代码中使用。</p>
<p class="calibre9">关于副作用我们需要得到一些更具体的东西。当我们说Haskell没有副作用，这到底意味着什么？</p>
<p class="calibre9">在一定程度上，副作用总是可能的。一个写的不好的循环，就算写成纯代码形式的，也会造成系统内存耗尽和机器崩溃，或者导致数据交换到硬盘上。</p>
<p class="calibre9">当我们说没有副作用的时候，我们意思是，Haskell中的存代码不能运行那些能触发副作用的命令。纯函数不能修改全局变量，请求I/O，或者运行一条关闭系统的命令。</p>
<p class="calibre9">当你有从 hGetContents 拿到一个 String ，你把它传给一个纯函数，这个函数不知道这个 String 是由硬盘文件上来的。这个函数表现地还是和原来一样，但是处理那个 String 的时候可能造成环境发出I/O命令。纯函数是不会发出I/O命令的，它们作为处理正在运行的纯函数的一个结果，就和交换内存到磁盘的例子一样。</p>
<p class="calibre9">有时候，你在I/O发生时需要更多的控制。可能你正在从用户那里交互地读取数据，或者通过管道从另一个程序读取数据，你需要直接和用户交流。在这些时候， hGetContents 可能就不合适了。</p>
<h2 class="calibre14"><a id="chp-7.html.Buffering_893" class="calibre7 pcalibre"></a>缓冲区（Buffering）</h2>
<p class="calibre9">I/O子系统是现代计算机中最慢的部分之一。完成一次写磁盘的时间是一次写内存的几千倍。在网络上的写入还要慢成百上千倍。就算你的操作没有直接和磁盘通信，可能数据被缓存了，I/O还是需要一个系统调用，这个也会减慢速度。</p>
<p class="calibre9">由于这个原因，现代操作系统和编程语言都提供了工具来帮助程序当涉及到I/O的时候更好地运行。操作系统一般采用缓存（Cache），把频繁使用的数据片段保存在内存中，这样就能更快的访问了。</p>
<p class="calibre9">编程语言通常采用缓冲区。就是说，它们可能从操作系统请求一大块数据，就算底层代码是一次一个字节地处理数据的。通过这样，它们可以实现显著的性能提升，因为每次向操作系统的I/O请求带来一次处理开销。缓冲区允许我们去读相同数量的数据可以用少得多的I/O请求。</p>
<h2 class="calibre14"><a id="chp-7.html._901" class="calibre7 pcalibre"></a>缓冲区模式</h2>
<p class="calibre9">Haskell中有3种不同的缓冲区模式，它们定义成 BufferMode 类型： NoBuffering ， LineBuffering 和 BlockBuffering 。</p>
<p class="calibre9">NoBuffering 就和它听起来那样-没有缓冲区。通过像 hGetLine 这样的函数读取的数据是从操作系统一次一个字符读取的。写入的数据会立即写入，也是一次一个字符地写入。因此， NoBuffering 通常性能很差，不适用于一般目的的使用。</p>
<p class="calibre9">LineBuffering 当换行符输出的时候会让输出缓冲区写入，或者当缓冲区太大的时候。在输入上，它通常试图去读取块上所有可用的字符，直到它首次遇到换行符。当从终端读取的时候，每次按下回车之后它会立即返回数据。这个模式经常是默认模式。</p>
<p class="calibre9">BlockBuffering 让Haskell在可能的时候以一个固定的块大小读取或者写入数据。这在批处理大量数据的时候是性能做好的，就算数据是以行存储的也是一样。然而，这个对于交互程序不能用，因为它会阻塞输入直到一整块数据被读取。 BlockBuffering 接受一个 Maybe 类型的参数： 如果是 Nothing ， 它会使用一个自定的缓冲区大小，或者你可以使用一个像 Just4096 的设定，设置缓冲区大小为4096个字节。</p>
<p class="calibre9">默认的缓冲区模式依赖于操作系统和Haskell的实现。你可以通过调用 hGetBuffering 查看系统的当前缓冲区模式。当前的模式可以通过 hSetBuffering 来设置，它接受一个 Handle 和 BufferMode 。例如，你可以写 hSetBufferingstdin(BlockBufferingNothing) 。</p>
<h2 class="calibre14"><a id="chp-7.html._913" class="calibre7 pcalibre"></a>刷新缓冲区</h2>
<p class="calibre9">对于任何类型的缓冲区，你可能有时候需要强制Haskell去写出所有保存在缓冲区里的数据。有些时候这个会自动发生：比如，对 hClose 的调用。有时候你可能需要调用 hFlush 作为代替， hFlush 会强制所有等待的数据立即写入。这在句柄是一个网络套接字的时候，你想数据被立即传输，或者你想让磁盘的数据给其他程序使用，而其他程序也正在并发地读那些数据的时候都是有用的。</p>
<h2 class="calibre14"><a id="chp-7.html._917" class="calibre7 pcalibre"></a>读取命令行参数</h2>
<p class="calibre9">很多命令行程序喜欢通过命令行来传递参数。 System.Environment.getArgs 返回 IO[String] 列出每个参数。这和C语言的 argv 一样，从 argv[1] 开始。程序的名字（C语言的 argv[0] ）用 System.Environment.getProgName 可以得到。</p>
<p class="calibre9">System.Console.GetOpt 模块提供了一些解析命令行选项的工具。如果你有一个程序，它有很复杂的选项，你会觉得它很有用。你可以在 <a href="#chp-7.html." class="calibre7 pcalibre"><code class="calibre16">命令行解析</code>_</a> 一节看到一个例子和使用方法。</p>
<h2 class="calibre14"><a id="chp-7.html._923" class="calibre7 pcalibre"></a>环境变量</h2>
<p class="calibre9">如果你需要阅读环境变量，你可以使用 System.Environment 里面两个函数中的一个： getEnv 或者 getEnvironment 。 getEnv 查找指定的变量，如果不存在会抛出异常。 getEnvironment 用一个 [(String,String))] 返回整个环境，然后你可以用 lookup 这样的函数来找你想要的环境条目。</p>
<p class="calibre9">在Haskell设置环境变量没有采用跨平台的方式来定义。如果你在像Linux这样的POSIX平台上，你可以使用 System.Posix.Env 模块中的 putEnv 或者 setEnv 。环境设置在Windows下面没有定义。</p>
</div></div></div></div></div></div>
<div id="chp-8.html"><div class="calibre">
<div id="chp-8.html.main" class="calibre1"><div class="root"><div class="article"><h1 class="article-head" id="chp-8.html.calibre_toc_8">第八章：高效文件处理、正则表达式、文件名匹配</h1><div class="article-body"><h1 class="calibre6"><a id="chp-8.html._0" class="calibre7 pcalibre"></a>第八章：高效文件处理、正则表达式、文件名匹配</h1>
<h2 class="calibre8"><a id="chp-8.html._2" class="calibre7 pcalibre"></a>高效文件处理</h2>
<p class="calibre9">下面是个简单的基准测试，读取一个由数字构成的文本文件，并打印它们的和。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>SumFile<span class="token">.</span>hs
main <span class="token3">=</span> <span class="token1">do</span>
    contents <span class="token3">&lt;</span><span class="token3">-</span> getContents
    print <span class="token">(</span>sumFile contents<span class="token">)</span>
  where sumFile <span class="token3">=</span> sum <span class="token">.</span> map read <span class="token">.</span> words

</code></pre>
<p class="calibre9">尽管读写文件时，默认使用 String 类型，但它并不高效，所以这样简单的程序效率会很糟糕。</p>
<p class="calibre9">一个 String 代表一个元素类型为 Char 的列表；列表的每个元素被单独分配内存，并有一定的写入开销。对那些要读取文本及二进制数据的程序来说，这些因素会影响内存消耗和执行效率。在这个简单的测试中，即使是 Python 那样的解释型语言的表现也会大大好于使用 String 的 Haskell 代码。</p>
<p class="calibre9">bytestring 库是 String 类型的一个快速、经济的替代品。在保持 Haskell 代码的表现力和简洁的同时，使用 bytestring 编写的代码在内存占用和执行效率经常可以达到或超过 C 代码。</p>
<p class="calibre9">这个库提供两个模块。每个都定义了与 String 类型上函数对应的替代物。</p>
<blockquote class="default"></blockquote>
<blockquote class="default"><ul class="calibre30"><li class="calibre11">Data.ByteString 定义了一个名为 ByteString 的严格类型，其将一个字符串或二进制数据或文本用一个数组表示。</li><li class="calibre11">Data.ByteString.Lazy 模块定义了一个惰性类型，同样命名为 ByteString 。其将字符串数据表示为一个由 块 组成的列表，每个块是大小为 64KB 的数组。</li></ul></blockquote>
<p class="calibre9">这两种 ByteString 适用于不同的场景。对于大体积的文件流(几百 MB 至几 TB)，最好使用惰性的 ByteString 。其块的大小被调整得对现代 CPU 的 L1 缓存特别友好，并且在流中已经被处理过块可以被垃圾收集器快速丢弃。</p>
<p class="calibre9">对于不在意内存占用而且需要随机访问的数据，最好使用严格的 ByteString 类型。</p>
<h2 class="calibre14"><a id="chp-8.html._IO__32" class="calibre7 pcalibre"></a>二进制 I/O 和有限载入</h2>
<p class="calibre9">让我们来开发一个小函数以说明 ByteString API 的一些用法。我们将检测一个文件是否是 ELF object 文件：这种文件类型几乎被所有现代类 Unix 系统作为可执行文件。</p>
<p class="calibre9">这个简单的问题可以通过查看文件头部的四个字节解决，看他们是否匹配某个特定的字节序列。表示某种文件类型的字节序列通常被称为 魔法数 。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>ElfMagic<span class="token">.</span>hs
import qualified Data<span class="token">.</span>ByteString<span class="token">.</span>Lazy as L

hasElfMagic <span class="token">:</span><span class="token">:</span> L<span class="token">.</span>ByteString <span class="token3">-</span><span class="token3">&gt;</span> Bool
hasElfMagic content <span class="token3">=</span> L<span class="token">.</span>take <span class="token2">4</span> content <span class="token3">==</span> elfMagic
    where elfMagic <span class="token3">=</span> L<span class="token">.</span>pack <span class="token">[</span><span class="token2">0x7f</span><span class="token">,</span> <span class="token2">0x45</span><span class="token">,</span> <span class="token2">0x4c</span><span class="token">,</span> <span class="token2">0x46</span><span class="token">]</span>

</code></pre>
<p class="calibre9">我们使用 Haskell 的 有限载入 语法载入 ByteString 模块， 像上面 importqualified 那句那样。这样可以把一个模块关联到另一个我们选定的名字。</p>
<p class="calibre9">例如，使用到惰性 ByteString 模块的 take 函数时，要写成 L.take ，因为我们将这个模块载入到了 L 这个名字下。若没有明确指明使用哪个版本的函数，如此处的 take ，编译器会报错。</p>
<p class="calibre9">我们将一直使用有限载入语法使用 ByteString 模块，因为其中提供的很多函数与 Prelude 模块中的函数重名。</p>
<p class="calibre9">Note</p>
<p class="calibre9">有限载入使得可以方便地切换两种 ByteString 类型。只需要在代码的头部改变 import 声明；剩余的代码可能无需任何修改。你可以方便地比较两种类型，以观察哪种类型更符合你程序的需要。</p>
<p class="calibre9">无论是否使用有限载入，始终可以使用模块的全名来识别某些混淆。例如， Data.ByteString.Lazy.length 和 L.length 表示相同的函数， Prelude.sum 和 sum 也是如此。</p>
<p class="calibre9">ByteString 模块为二进制 I/O 而设计。Haskell 中表达字节的类型是 Word8 ；如果需要按名字引用它，需要将其从 Data.Word 模块载入。</p>
<p class="calibre9">L.pack 函数接受一个由 Word8 组成的列表，并将其装入一个惰性 ByteString （ L.unpack 函数的作用恰好相反。）。 hasElfMagic 函数简单地将一个 ByteString 的前四字节与一个魔法数相比较。</p>
<p class="calibre9">我们使用了典型的 Haskell 风格编写 hasElfMagic 函数，其并不执行 I/O。这里是如何在真正的文件上使用它。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>ElfMagic<span class="token">.</span>hs
isElfFile <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO Bool
isElfFile path <span class="token3">=</span> <span class="token1">do</span>
  content <span class="token3">&lt;</span><span class="token3">-</span> L<span class="token">.</span>readFile path
  <span class="token1">return</span> <span class="token">(</span>hasElfMagic content<span class="token">)</span>

</code></pre>
<p class="calibre9">L.readFile 函数是 readFile 的惰性 ByteString 等价物。它是惰性执行的，将文件读取为数据是需要的。它也很高效，立即读取 64KB 大小的块。对我们的任务而言，惰性 ByteString 是一个好选择，我们可以安全的将这个函数应用在任意大小的文件上。</p>
<h2 class="calibre14"><a id="chp-8.html._IO_77" class="calibre7 pcalibre"></a>文本 I/O</h2>
<p class="calibre9">方便起见， bytestring 库提供两个具有有限文本 I/O 功能的模块， Data.ByteString.Char8 和 Data.ByteSring.Lazy.Char8 。它们将每个字符串的元素暴露为 Char 而非 Word8 。</p>
<p class="calibre9">Warning</p>
<p class="calibre9">这些模块中的函数适用于单字节大小的 Char 值，所以他们仅适用于 ASCII 及某些欧洲字符集。大于 255 的值将被截断。</p>
<p class="calibre9">这两个面向字符的 bytestring 模块提供了用于文本处理的函数。以下文件包含了一家知名互联网公司在 2008 年中期每个月的股价。</p>
<p class="calibre9">如何在这一系列记录中找到最高收盘价呢？收盘价位于以逗号分隔的第四列。以下函数从单行数据中获取收盘价。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>HighestClose<span class="token">.</span>hs
import qualified Data<span class="token">.</span>ByteString<span class="token">.</span>Lazy<span class="token">.</span>Char8 as L

closing <span class="token3">=</span> readPrice <span class="token">.</span> <span class="token">(</span><span class="token3">!</span><span class="token3">!</span><span class="token2">4</span><span class="token">)</span> <span class="token">.</span> L<span class="token">.</span>split <span class="token4">','</span>

</code></pre>
<p class="calibre9">这个函数使用 point-free 风格编写，我们要从右向左阅读。 L.split 函数将一个惰性 ByteString 按某个分隔符切分为一个由 ByteString 组成的列表。 (!!) 操作符检索列表中的第 k 个元素。 readPrice 函数将一个表示小数的字符串转换为一个数。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">-</span> file<span class="token">:</span> ch08<span class="token3">/</span>HighestClose<span class="token">.</span>hs
readPrice <span class="token">:</span><span class="token">:</span> L<span class="token">.</span>ByteString <span class="token3">-</span><span class="token3">&gt;</span> Maybe Int
readPrice str <span class="token3">=</span>
    case L<span class="token">.</span>readInt str of
      Nothing             <span class="token3">-</span><span class="token3">&gt;</span> Nothing
      Just <span class="token">(</span>dollars<span class="token">,</span>rest<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span>
        case L<span class="token">.</span>readInt <span class="token">(</span>L<span class="token">.</span>tail rest<span class="token">)</span> of
          Nothing           <span class="token3">-</span><span class="token3">&gt;</span> Nothing
          Just <span class="token">(</span>cents<span class="token">,</span>more<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span>
            Just <span class="token">(</span>dollars <span class="token3">*</span> <span class="token2">100</span> <span class="token3">+</span> cents<span class="token">)</span>

</code></pre>
<p class="calibre9">我们使用 L.readInt 函数来解析一个整数。当发现数字时，它会将一个整数和字符串的剩余部分一起返回。 L.readInt 在解析失败时返回 Nothing ，这导致我们的函数稍有些复杂。</p>
<p class="calibre9">查找最高收盘价的函数很容易编写。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>HighestClose<span class="token">.</span>hs
highestClose <span class="token3">=</span> maximum <span class="token">.</span> <span class="token">(</span>Nothing<span class="token">:</span><span class="token">)</span> <span class="token">.</span> map closing <span class="token">.</span> L<span class="token">.</span>lines

highestCloseFrom path <span class="token3">=</span> <span class="token1">do</span>
    contents <span class="token3">&lt;</span><span class="token3">-</span> L<span class="token">.</span>readFile path
    print <span class="token">(</span>highestClose contents<span class="token">)</span>

</code></pre>
<p class="calibre9">不能对空列表使用 maximum 函数，所以我们耍了点小把戏。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> maximum <span class="token">[</span><span class="token2">3</span><span class="token">,</span><span class="token2">6</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">9</span><span class="token">]</span>
<span class="token2">9</span>
ghci<span class="token3">&gt;</span> maximum <span class="token">[</span><span class="token">]</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> Prelude<span class="token">.</span>maximum<span class="token">:</span> empty list

</code></pre>
<p class="calibre9">我们想在没有股票数据时也不抛出异常，所以用 (Nothing:) 这个表达式来确保输入到 maximum 函数的由 MaybeInt 值构成的列表总是非空。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> maximum <span class="token">[</span>Nothing<span class="token">,</span> Just <span class="token2">1</span><span class="token">]</span>
Just <span class="token2">1</span>
ghci<span class="token3">&gt;</span> maximum <span class="token">[</span>Nothing<span class="token">]</span>
Nothing

</code></pre>
<p class="calibre9">我们的函数工作正常吗？</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>load HighestClose
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> HighestClose<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>
ghci<span class="token3">&gt;</span> highestCloseFrom <span class="token4">"prices.csv"</span>
Loading package array<span class="token3">-</span><span class="token2">0.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package bytestring<span class="token3">-</span><span class="token2">0.9</span><span class="token2">.0</span><span class="token2">.1</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Just <span class="token2">2741</span>

</code></pre>
<p class="calibre9">因为我们把逻辑和 I/O 分离开了，所以即使不创建一个空文件也可以测试无数据的情况。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> highestClose L<span class="token">.</span>empty
Nothing

</code></pre>
<h2 class="calibre14"><a id="chp-8.html._168" class="calibre7 pcalibre"></a>匹配文件名</h2>
<p class="calibre9">很多面向操作系统的编程语言提供了检测某个文件名是否匹配给定模式的库函数，或者返回一个匹配给定模式的文件列表。在其他语言中，这个函数通常叫做 fmatch 。尽管 Haskell 标准库提供了很多有用的系统编程设施，但是并没有提供这类用于匹配文件名的函数。所以我们可以自己开发一个。</p>
<p class="calibre9">我们需要处理的模式种类通常称为 glob 模式（我们将使用这个术语），通配符模式，或称 shell 风格模式。它们仅是一些简单规则。你可能已经了解了，但是这里将做一个简要的回顾。</p>
<p class="calibre9">Note</p>
<ul class="calibre10"><li class="calibre11">对某个模式的匹配从字符串头部开始，在字符串尾部结束。</li><li class="calibre11">多数文本字符匹配自身。例如，文本 foo 作为模式匹配其自身 foo ，且在一个输入字符串中仅匹配 foo 。</li><li class="calibre11"><ul class="calibre31"><li class="calibre11">(星号) 意味着 “匹配所有”; 其将匹配所有文本，包括空字符串。 例如, 模式 foo* 将匹配任意以 foo 开头的字符串，比如 foo 自身， foobar ， 或 foo.c 。 模式 quux*.c 将匹配任何以 quux 开头且以 .c 结束的字符串，如 quuxbaz.c 。</li></ul></li><li class="calibre11">? (问号) 匹配任意单个字符。模式 pic??.jpg 将匹配类似 picaa.jpg 或 pic01.jpg 的文件名。</li><li class="calibre11">[ (左方括号) 将开始定义一个字符类，以 ] 结束。其意思是 “匹配在这个字符类中的任意字符”。 [! 开启一个否定的字符类，其意为 “匹配不在这个字符类中的任意字符”。</li></ul>
<p class="calibre9">用 - (破折号) 连接的两个字符，是一种表示范围的速记方法，表示：“匹配这个围内的任意字符”。</p>
<p class="calibre9">字符类有一个附加的条件；其不可为空。在 [ 或 [! 后的字符是这个字符类的一部分，所以我们可以编写包含 ] 的字符类，如 []aeiou] 。模式 pic[0-9].[pP][nN][gG] 将匹配由字符串 pic 开始，跟随单个数字，最后是字符串 .png 的任意大小写形式。</p>
<p class="calibre9">尽管 Haskell 的标准库没有提供匹配 glob 模式的方法，但它提供了一个良好的正则表达式库。Glob 模式仅是一个从正则表达式中切分出来的略有不同的子集。很容易将 glob 模式转换为正则表达式，但在此之前，我们首先要了解怎样在 Haskell 中使用正则表达式。</p>
<h2 class="calibre14"><a id="chp-8.html.Haskell__188" class="calibre7 pcalibre"></a>Haskell 中的正则表达式</h2>
<p class="calibre9">在这一节，我们将假设读者已经熟悉 Python、Perl 或 Java 等其他语言中的正则表达式。</p>
<p class="calibre9">为了简洁，此后我们将 “regular expression” 简写为 regexp。</p>
<p class="calibre9">我们将以与其他语言对比的方式介绍 Haskell 如何处理 regexp，而非从头讲解何为 regexp。Haskell 的正则表达式库比其他语言具备更加强大的表现力，所以我们有很多可以聊的。</p>
<p class="calibre9">在我们对 regexp 库的探索开始时，只需使用 Text.Regex.Posix 工作。一般通过在 ghci 进行交互是探索一个模块最方便的办法。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>module <span class="token3">+</span>Text<span class="token">.</span>Regex<span class="token">.</span>Posix

</code></pre>
<p class="calibre9">可能正则表达式匹配函数是我们平时需要使用的唯一的函数，其以中缀预算符 (=~) (从 Perl 中借鉴) 表示。要克服的第一个障碍是 Haskell 的 regexp 库重度使用了多态。其结果就是， (=~) 的类型签名非常难懂，所以我们在此对其不做解释。 =~ 操作符的参数和返回值都使用了类型类。第一个参数 (=~ 左侧) 是要被匹配的文本；第二个参数 (=~ 右侧) 是准备匹配的正则表达式。对每个参数我们都可以使用 String 或者 ByteString 。 结果的多种类型 =~ 操作符的返回类型是多态的，所以 Haskell 编译器需要一通过一些途径知道我们想获得哪种类型的结果。实际编码中，可以通过我们如何使用匹配结果推导出它的类型。但是当我们通过 ghci 进行探索时，缺少类型推导的线索。如果不指明匹配结果的类型，ghci 将因其无法获得足够信息对匹配结果进行类型推导而报错。 当 ghci 无法推断目标的类型时，我们要告诉它想要哪种类型。若想知道正则匹配是否通过时，需要将结果类型指定为 Bool 型。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token4">"my left foot"</span> <span class="token3">=</span><span class="token3">~</span> <span class="token4">"foo"</span> <span class="token">:</span><span class="token">:</span> Bool
Loading package array<span class="token3">-</span><span class="token2">0.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package containers<span class="token3">-</span><span class="token2">0.1</span><span class="token2">.0</span><span class="token2">.1</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package bytestring<span class="token3">-</span><span class="token2">0.9</span><span class="token2">.0</span><span class="token2">.1</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package mtl<span class="token3">-</span><span class="token2">1.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package regex<span class="token3">-</span>base<span class="token3">-</span><span class="token2">0.93</span><span class="token2">.1</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package regex<span class="token3">-</span>posix<span class="token3">-</span><span class="token2">0.93</span><span class="token2">.1</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
True
ghci<span class="token3">&gt;</span> <span class="token4">"your right hand"</span> <span class="token3">=</span><span class="token3">~</span> <span class="token4">"bar"</span> <span class="token">:</span><span class="token">:</span> Bool
False
ghci<span class="token3">&gt;</span> <span class="token4">"your right hand"</span> <span class="token3">=</span><span class="token3">~</span> <span class="token4">"(hand|foot)"</span> <span class="token">:</span><span class="token">:</span> Bool
True

</code></pre>
<p class="calibre9">在 regexp 库内部，有一种类型类名为 RegexContext ，其描述了目标类型的行为。基础库定义了很多这个类型类的实例。 Bool 型是这种类型类的一个实例，所以我们取回了一个可用的结果. 另一个实例是 Int ，可以描述正则表达式匹配了多少次。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token4">"a star called henry"</span> <span class="token3">=</span><span class="token3">~</span> <span class="token4">"planet"</span> <span class="token">:</span><span class="token">:</span> Int
<span class="token2">0</span>
ghci<span class="token3">&gt;</span> <span class="token4">"honorificabilitudinitatibus"</span> <span class="token3">=</span><span class="token3">~</span> <span class="token4">"[aeiou]"</span> <span class="token">:</span><span class="token">:</span> Int
<span class="token2">13</span>

</code></pre>
<p class="calibre9">如果指定结果类型为 String ，将得到第一个匹配的子串，或者表示无匹配的空字符串。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token4">"I, B. Ionsonii, uurit a lift'd batch"</span> <span class="token3">=</span><span class="token3">~</span> <span class="token4">"(uu|ii)"</span> <span class="token">:</span><span class="token">:</span> String
<span class="token4">"ii"</span>
ghci<span class="token3">&gt;</span> <span class="token4">"hi ludi, F. Baconis nati, tuiti orbi"</span> <span class="token3">=</span><span class="token3">~</span> <span class="token4">"Shakespeare"</span> <span class="token">:</span><span class="token">:</span> String
<span class="token4">""</span>

</code></pre>
<p class="calibre9">另一个合法的返回值类型是 [[Srtring]] ，将返回由所有匹配的的字符串组成的列表。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token4">"I, B. Ionsonii, uurit a lift'd batch"</span> <span class="token3">=</span><span class="token3">~</span> <span class="token4">"(uu|ii)"</span> <span class="token">:</span><span class="token">:</span> <span class="token">[</span><span class="token">[</span>String<span class="token">]</span><span class="token">]</span>
<span class="token">[</span><span class="token">[</span><span class="token4">"ii"</span><span class="token">,</span><span class="token4">"ii"</span><span class="token">]</span><span class="token">,</span><span class="token">[</span><span class="token4">"uu"</span><span class="token">,</span><span class="token4">"uu"</span><span class="token">]</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> <span class="token4">"hi ludi, F. Baconis nati, tuiti orbi"</span> <span class="token3">=</span><span class="token3">~</span> <span class="token4">"Shakespeare"</span> <span class="token">:</span><span class="token">:</span> <span class="token">[</span><span class="token">[</span>String<span class="token">]</span><span class="token">]</span>
<span class="token">[</span><span class="token">]</span>

</code></pre>
<p class="calibre9">Warning</p>
<p class="calibre9">注意 String 类型的结果</p>
<p class="calibre9">指定结果为普通的字符串时，要当心。因为 (=~) 在表示 “无匹配” 时会返回空字符串，很明显这导致了难以处理可以匹配空字符串的正则表达式。这情况出现时，就需要使用另一种不同的结果类型，比如 [[String]]。</p>
<p class="calibre9">以上是一些 “简单”的结果类型，不过还没说完。在继续讲解之前，我们先来定义一个在之后的例子中共同使用的模式串。可以在 ghci 中将这个模式串定义为一个变量，以便节省一些输入操作。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> let pat <span class="token3">=</span> <span class="token4">"(foo[a-z]*bar|quux)"</span>

</code></pre>
<p class="calibre9">当模式匹配了字符串时，可以获取很多关于上下文的信息。如果指定 (String,String,String) 类型的元组作为结果类型，可以获取字符串中首次匹配之前的部分，首次匹配的子串，和首次匹配之后的部分。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token4">"before foodiebar after"</span> <span class="token3">=</span><span class="token3">~</span> pat <span class="token">:</span><span class="token">:</span> <span class="token">(</span>String<span class="token">,</span>String<span class="token">,</span>String<span class="token">)</span>
<span class="token">(</span><span class="token4">"before "</span><span class="token">,</span><span class="token4">"foodiebar"</span><span class="token">,</span><span class="token4">" after"</span><span class="token">)</span>

</code></pre>
<p class="calibre9">若匹配失败，整个字符串会作为 “首次匹配之前” 的部分返回，元组的其他两个元素将为空字符串。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token4">"no match here"</span> <span class="token3">=</span><span class="token3">~</span> pat <span class="token">:</span><span class="token">:</span> <span class="token">(</span>String<span class="token">,</span>String<span class="token">,</span>String<span class="token">)</span>
<span class="token">(</span><span class="token4">"no match here"</span><span class="token">,</span><span class="token4">""</span><span class="token">,</span><span class="token4">""</span><span class="token">)</span>

</code></pre>
<p class="calibre9">使用四元组作为返回结果时，元组的第四个元素是一个包含了模式中所有分组的列表。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token4">"before foodiebar after"</span> <span class="token3">=</span><span class="token3">~</span> pat <span class="token">:</span><span class="token">:</span> <span class="token">(</span>String<span class="token">,</span>String<span class="token">,</span>String<span class="token">,</span><span class="token">[</span>String<span class="token">]</span><span class="token">)</span>
<span class="token">(</span><span class="token4">"before "</span><span class="token">,</span><span class="token4">"foodiebar"</span><span class="token">,</span><span class="token4">" after"</span><span class="token">,</span><span class="token">[</span><span class="token4">"foodiebar"</span><span class="token">]</span><span class="token">)</span>

</code></pre>
<p class="calibre9">也可以获得关于匹配结果的数字信息。二元组类型的结果可以表示首次匹配在字符串中的偏移，以及匹配结果的长度。如果使用由这种二元组构成的列表作为结果类型，我们将得到所有字符串中所有匹配的此类信息。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token4">"before foodiebar after"</span> <span class="token3">=</span><span class="token3">~</span> pat <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Int<span class="token">,</span>Int<span class="token">)</span>
<span class="token">(</span><span class="token2">7</span><span class="token">,</span><span class="token2">9</span><span class="token">)</span>
ghci<span class="token3">&gt;</span> getAllMatches  <span class="token">(</span><span class="token4">"i foobarbar a quux"</span> <span class="token3">=</span><span class="token3">~</span> pat<span class="token">)</span> <span class="token">:</span><span class="token">:</span> <span class="token">[</span><span class="token">(</span>Int<span class="token">,</span>Int<span class="token">)</span><span class="token">]</span>
<span class="token">[</span><span class="token">(</span><span class="token2">2</span><span class="token">,</span><span class="token2">9</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token2">14</span><span class="token">,</span><span class="token2">4</span><span class="token">)</span><span class="token">]</span>

</code></pre>
<p class="calibre9">二元组的首个元素（表示偏移的那个），其值为 -1 时，表示匹配失败。当指定返回值为列表时，空表表示失败。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token4">"eleemosynary"</span> <span class="token3">=</span><span class="token3">~</span> pat <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Int<span class="token">,</span>Int<span class="token">)</span>
<span class="token">(</span><span class="token3">-</span><span class="token2">1</span><span class="token">,</span><span class="token2">0</span><span class="token">)</span>
ghci<span class="token3">&gt;</span> <span class="token4">"mondegreen"</span> <span class="token3">=</span><span class="token3">~</span> pat <span class="token">:</span><span class="token">:</span> <span class="token">[</span><span class="token">(</span>Int<span class="token">,</span>Int<span class="token">)</span><span class="token">]</span>
<span class="token">[</span><span class="token">]</span>

</code></pre>
<p class="calibre9">以上并非 RegexContext 类型类的内置实例的完整清单。完整的清单可以在 Text.Regex.Base.Context 模块的文档中找到。</p>
<p class="calibre9">使函数具有多态返回值的能力对于一个静态类型语言来说是个不同寻常的特性。</p>
<h2 class="calibre14"><a id="chp-8.html._310" class="calibre7 pcalibre"></a>进一步了解正则表达式</h2>
<h2 class="calibre8"><a id="chp-8.html._312" class="calibre7 pcalibre"></a>不同类型字符串的混合与匹配</h2>
<p class="calibre9">之前提到过， =~ 操作符的输入和返回值都使用了类型类。我们可以在正则表达式和要匹配的文本中使用 String 或者严格的 ByteString 类型。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>module <span class="token3">+</span>Data<span class="token">.</span>ByteString<span class="token">.</span>Char8
ghci<span class="token3">&gt;</span> <span class="token">:</span>type pack <span class="token4">"foo"</span>
pack <span class="token4">"foo"</span> <span class="token">:</span><span class="token">:</span> ByteString

</code></pre>
<p class="calibre9">我们可以尝试不同的 String 和 ByteString 组合。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> pack <span class="token4">"foo"</span> <span class="token3">=</span><span class="token3">~</span> <span class="token4">"bar"</span> <span class="token">:</span><span class="token">:</span> Bool
False
ghci<span class="token3">&gt;</span> <span class="token4">"foo"</span> <span class="token3">=</span><span class="token3">~</span> pack <span class="token4">"bar"</span> <span class="token">:</span><span class="token">:</span> Int
<span class="token2">0</span>
ghci<span class="token3">&gt;</span> getAllMatches <span class="token">(</span>pack <span class="token4">"foo"</span> <span class="token3">=</span><span class="token3">~</span> pack <span class="token4">"o"</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> <span class="token">[</span><span class="token">(</span>Int<span class="token">,</span> Int<span class="token">)</span><span class="token">]</span>
<span class="token">[</span><span class="token">(</span><span class="token2">1</span><span class="token">,</span><span class="token2">1</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token2">2</span><span class="token">,</span><span class="token2">1</span><span class="token">)</span><span class="token">]</span>

</code></pre>
<p class="calibre9">不过，我们需要注意，文本匹配的结果必须于被匹配的字符串类型一致。让我们实践一下，看这是什么意思。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> pack <span class="token4">"good food"</span> <span class="token3">=</span><span class="token3">~</span> <span class="token4">".ood"</span> <span class="token">:</span><span class="token">:</span> <span class="token">[</span><span class="token">[</span>ByteString<span class="token">]</span><span class="token">]</span>
<span class="token">[</span><span class="token">[</span><span class="token4">"good"</span><span class="token">]</span><span class="token">,</span><span class="token">[</span><span class="token4">"food"</span><span class="token">]</span><span class="token">]</span>

</code></pre>
<p class="calibre9">上面的例子中，我们使用 pack 将一个 String 转换为 ByteString 。这种情况可以通过类型检查，因为 ByteString 也是一种合法的结果类型。但是如果输入字符串类型为 String 类型，在尝试获得 ByteString 类型结果时将会失败。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token4">"good food"</span> <span class="token3">=</span><span class="token3">~</span> <span class="token4">".ood"</span> <span class="token">:</span><span class="token">:</span> <span class="token">[</span><span class="token">[</span>ByteString<span class="token">]</span><span class="token">]</span>

<span class="token3">&lt;</span>interactive<span class="token3">&gt;</span><span class="token">:</span><span class="token2">55</span><span class="token">:</span><span class="token2">13</span><span class="token">:</span>
    No instance <span class="token1">for</span> <span class="token">(</span>RegexContext Regex <span class="token">[</span>Char<span class="token">]</span> <span class="token">[</span><span class="token">[</span>ByteString<span class="token">]</span><span class="token">]</span><span class="token">)</span>
      arising from a use of ‘<span class="token3">=</span><span class="token3">~</span>’
    In the expression<span class="token">:</span> <span class="token4">"good food"</span> <span class="token3">=</span><span class="token3">~</span> <span class="token4">".ood"</span> <span class="token">:</span><span class="token">:</span> <span class="token">[</span><span class="token">[</span>ByteString<span class="token">]</span><span class="token">]</span>
    In an equation <span class="token1">for</span> ‘it’<span class="token">:</span>
        it <span class="token3">=</span> <span class="token4">"good food"</span> <span class="token3">=</span><span class="token3">~</span> <span class="token4">".ood"</span> <span class="token">:</span><span class="token">:</span> <span class="token">[</span><span class="token">[</span>ByteString<span class="token">]</span><span class="token">]</span>

</code></pre>
<p class="calibre9">将结果类型指定为与被匹配字符串相同的 String 类型就可以轻松地解决这个问题。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token4">"good food"</span> <span class="token3">=</span><span class="token3">~</span> <span class="token4">".ood"</span> <span class="token">:</span><span class="token">:</span> <span class="token">[</span><span class="token">[</span>String<span class="token">]</span><span class="token">]</span>
<span class="token">[</span><span class="token">[</span><span class="token4">"good"</span><span class="token">]</span><span class="token">,</span><span class="token">[</span><span class="token4">"food"</span><span class="token">]</span><span class="token">]</span>

</code></pre>
<p class="calibre9">对于正则表达式不存在这个限制。正则表达式可以是 String 或 ByteString ，而不必在意输入或结果是何种类型。</p>
<h2 class="calibre14"><a id="chp-8.html._363" class="calibre7 pcalibre"></a>你要知道的其他一些事情</h2>
<p class="calibre9">查阅 Haskell 的库文档，会发现很多和正则表达式有关的模块。 Text.Regex.Base 下的模块定义了供其他所有正则表达式库使用的通用 API 。可以同时安装许多不同实现的正则表达式模块。写作本书时， GHC 自带一个实现， Text.Regex.Posix 。正如其名字，这个模块提供了 POSIX 语义的正则表达式实现。</p>
<p class="calibre9">Note</p>
<p class="calibre9">Perl 风格和 POSIX 风格的正则表达式</p>
<p class="calibre9">如果你此前用过其他语言，如 Perl，Python，或 Java，并且使用过其中的正则表达式， 你应该知道 Text.Regex.Posix 模块处理的 POSIX 风格的正则表达式与 Perl 风格的正则表达式有一些显著的不同。</p>
<p class="calibre9">当有多个匹配结果候选时，Perl 的正则表达式引擎表现为左侧最小匹配，而 POSIX 引擎会选择贪婪匹配（最长匹配）。当使用正则表达式 (foo|fo*) 匹配字符串 foooooo 时，Perl 风格引擎将返回 foo (最左的匹配)，而 POSIX 引擎将返回的结果将包含整个字符串 (贪婪匹配)。</p>
<p class="calibre9">POSIX 正则表达式比 Perl 风格的正则表达式缺少一些格式语法。它们也缺少一些 Perl 风格正则表达式的功能，比如零宽度断言和对贪婪匹配的控制。</p>
<p class="calibre9">Hackage 上也有其他 Haskell 正则表达式包可供下载。其中一些比内置的 POSIX 引擎拥有更好的执行效率 (如 regex-tdfa); 另外一些提供了大多数程序员熟悉的 Perl 风格正则匹配 (如 regex-pcre)。它们都按照我们这节提到的 API 编写。</p>
<h2 class="calibre14"><a id="chp-8.html._glob__379" class="calibre7 pcalibre"></a>将 glob 模式翻译为正则表达式</h2>
<p class="calibre9">我们已经看到了用正则表达式匹配文本的多种方法，现在让我们将注意力回到 glob 模式。我们要编写一个函数，接收一个 glob 模式作为输入，返回其对应的正则表达式。glob 模式和正则表达式都以文本字符串表示，所以这个函数的类型应该已经清楚了。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>GlobRegex<span class="token">.</span>hs
module GlobRegex
    <span class="token">(</span>
      globToRegex
    <span class="token">,</span> matchesGlob
    <span class="token">)</span> where

import Text<span class="token">.</span>Regex<span class="token">.</span>Posix <span class="token">(</span><span class="token">(</span><span class="token3">=</span><span class="token3">~</span><span class="token">)</span><span class="token">)</span>

globToRegex <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> String

</code></pre>
<p class="calibre9">我们生成的正则表达式必须被锚定，所以它要对一个字符串从头到尾完整匹配。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>GlobRegex<span class="token">.</span>hs
globToRegex cs <span class="token3">=</span> <span class="token4">'^'</span> <span class="token">:</span> globToRegex' cs <span class="token3">++</span> <span class="token4">"$"</span>

</code></pre>
<p class="calibre9">回想一下， String 仅是 [Char] 的同义词，一个由字符组成的数组。 : 操作符将一个值加入某个列表头部，此处是将字符 ^ 加入 globToRegex' 函数返回的列表头部。</p>
<p class="calibre9">Note</p>
<p class="calibre9">在定义之前使用一个值</p>
<p class="calibre9">Haskell 在使用某个值或函数时，并不需要其在之前的源码中被声明。在某个值首次被使用之后才定义它是很平常的。Haskell 编译器并不关心这个层面上的顺序。这使我们可以用最符合逻辑的方式灵活地组织代码，而不是为使编译器作者更轻松而遵守某种顺序。</p>
<p class="calibre9">Haskell 模块的作者们经常利用这种灵活性，将“更重要的”代码放在源码文件更靠前的位置，将繁琐的实现放在后面。这也是我们实现 globToRegex' 函数及其辅助函数的方法。</p>
<p class="calibre9">globToRegex' 将使用正则表达式做大部分的翻译工作。我们将使用 Haskell 的模式匹配特性轻松地穷举出需要处理的每一种情况</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>GlobRegex<span class="token">.</span>hs

globToRegex' <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> String
globToRegex' <span class="token4">""</span> <span class="token3">=</span> <span class="token4">""</span>

globToRegex<span class="token4">' ('</span><span class="token3">*</span><span class="token4">':cs) = ".*" ++ globToRegex'</span> cs

globToRegex<span class="token4">' ('</span><span class="token3">?</span><span class="token4">':cs) = '</span><span class="token">.</span><span class="token4">' : globToRegex'</span> cs

globToRegex<span class="token4">' ('</span><span class="token">[</span><span class="token4">':'</span><span class="token3">!</span>'<span class="token">:</span>c<span class="token">:</span>cs<span class="token">)</span> <span class="token3">=</span> <span class="token4">"[^"</span> <span class="token3">++</span> c <span class="token">:</span> charClass cs
globToRegex<span class="token4">' ('</span><span class="token">[</span><span class="token4">':c:cs)     = '</span><span class="token">[</span>'  <span class="token">:</span>  c <span class="token">:</span> charClass cs
globToRegex<span class="token4">' ('</span><span class="token">[</span>'<span class="token">:</span>_<span class="token">)</span>        <span class="token3">=</span> error <span class="token4">"unterminated character class"</span>

globToRegex<span class="token4">' (c:cs) = escape c ++ globToRegex'</span> cs

</code></pre>
<p class="calibre9">我们的第一条规则是，如果触及 glob 模式的尾部（也就是说当输入为空字符串时），我们返回 $ ，正则表达式中表示“匹配行尾”的符号。我们按照这样一系列规则将模式串由 glob 语法转化为正则表达式语法。最后一条规则匹配所有字符，首先将可转义字符进行转义。</p>
<p class="calibre9">escape 函数确保正则表达式引擎不会将普通字符串解释为构成正则表达式语法的字符。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>GlobRegex<span class="token">.</span>hs
escape <span class="token">:</span><span class="token">:</span> Char <span class="token3">-</span><span class="token3">&gt;</span> String
escape c <span class="token3">|</span> c `elem` regexChars <span class="token3">=</span> <span class="token4">'\\'</span> <span class="token">:</span> <span class="token">[</span>c<span class="token">]</span>
         <span class="token3">|</span> otherwise <span class="token3">=</span> <span class="token">[</span>c<span class="token">]</span>
    where regexChars <span class="token3">=</span> <span class="token4">"\\+()^$.{}]|"</span>

</code></pre>
<p class="calibre9">charClass 辅助函数仅检查一个字符类是否正确地结束。这个并不改变其输入，直到遇到一个 ] 字符，其将控制流交还给 globToRegex'</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>GlobRegex<span class="token">.</span>hs
charClass <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> String
charClass <span class="token">(</span><span class="token4">']'</span><span class="token">:</span>cs<span class="token">)</span> <span class="token3">=</span> <span class="token4">']'</span> <span class="token">:</span> globToRegex' cs
charClass <span class="token">(</span>c<span class="token">:</span>cs<span class="token">)</span>   <span class="token3">=</span> c <span class="token">:</span> charClass cs
charClass <span class="token">[</span><span class="token">]</span>       <span class="token3">=</span> error <span class="token4">"unterminated character class"</span>

</code></pre>
<p class="calibre9">现在我们已经完成了 globToRegex 函数及其辅助函数的定义，让我们在 ghci 中装载并且实验一下。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>load GlobRegex<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling GlobRegex        <span class="token">(</span> GlobRegex<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> GlobRegex<span class="token">.</span>
ghci<span class="token3">&gt;</span> <span class="token">:</span>module <span class="token3">+</span>Text<span class="token">.</span>Regex<span class="token">.</span>Posix
ghci<span class="token3">&gt;</span> globToRegex <span class="token4">"f??.c"</span>
Loading package array<span class="token3">-</span><span class="token2">0.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package containers<span class="token3">-</span><span class="token2">0.1</span><span class="token2">.0</span><span class="token2">.1</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package bytestring<span class="token3">-</span><span class="token2">0.9</span><span class="token2">.0</span><span class="token2">.1</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package mtl<span class="token3">-</span><span class="token2">1.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package regex<span class="token3">-</span>base<span class="token3">-</span><span class="token2">0.93</span><span class="token2">.1</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package regex<span class="token3">-</span>posix<span class="token3">-</span><span class="token2">0.93</span><span class="token2">.1</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
<span class="token4">"^f..\\.c$"</span>

</code></pre>
<p class="calibre9">果然，看上去像是一个合理的正则表达式。可以使用她来匹配某个字符串码？</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token4">"foo.c"</span> <span class="token3">=</span><span class="token3">~</span> globToRegex <span class="token4">"f??.c"</span> <span class="token">:</span><span class="token">:</span> Bool
True
ghci<span class="token3">&gt;</span> <span class="token4">"test.c"</span> <span class="token3">=</span><span class="token3">~</span> globToRegex <span class="token4">"t[ea]s*"</span> <span class="token">:</span><span class="token">:</span> Bool
True
ghci<span class="token3">&gt;</span> <span class="token4">"taste.txt"</span> <span class="token3">=</span><span class="token3">~</span> globToRegex <span class="token4">"t[ea]s*"</span> <span class="token">:</span><span class="token">:</span> Bool
True

</code></pre>
<p class="calibre9">奏效了！现在让我们在 ghci 里玩耍一下。我们可以临时定义一个 fnmatch 函数，并且试用它。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> let fnmatch pat name  <span class="token3">=</span>  name <span class="token3">=</span><span class="token3">~</span> globToRegex pat <span class="token">:</span><span class="token">:</span> Bool
ghci<span class="token3">&gt;</span> <span class="token">:</span>type fnmatch
fnmatch <span class="token">:</span><span class="token">:</span> <span class="token">(</span>RegexLike Regex source1<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> source1 <span class="token3">-</span><span class="token3">&gt;</span> Bool
ghci<span class="token3">&gt;</span> fnmatch <span class="token4">"d*"</span> <span class="token4">"myname"</span>
False

</code></pre>
<p class="calibre9">但是 fnmatch 没有真正的 “Haskell 味道”。目前为止，最常见的 Haskell 风格是赋予函数具有描述性的，“驼峰式” 命名。将单词连接为驼峰状，首字母小写后面每个单词的首字母大写。例如，“file name matches” 这几个词将转换为 fileNameMatch 这个名字。 “驼峰式” 这种说法来自与大写字母形成的“驼峰”。在我们的库中，将使用 matchesGlob 这个函数名。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>GlobRegex<span class="token">.</span>hs
matchesGlob <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> Bool
name `matchesGlob` pat <span class="token3">=</span> name <span class="token3">=</span><span class="token3">~</span> globToRegex pat

</code></pre>
<p class="calibre9">你可能注意到目前为止我们使用的都是短变量名。从经验来看，描述性的名字在更长的函数定义中更有用，它们有助于可读性。对一个仅有两行的函数来说，长变量名价值较小。</p>
<h2 class="calibre14"><a id="chp-8.html._509" class="calibre7 pcalibre"></a>练习</h2>
<ol class="calibre17"><li class="calibre11">使用 ghci 探索当你向 globToRegex 传入一个畸形的模式时会发生什么，如 “[” 。编写一个小函数调用 globToRegex ，向其传入一个畸形的模式。发生了什么？</li><li class="calibre11">Unix 的文件系统的文件名通常是对大小写敏感的（如：”G” 和 “g” 不同），Windows 文件系统则不是。为 globToRegex 和 matchesGlob 函数添加一个参数，以控制它们是否大小写敏感。</li></ol>
<h2 class="calibre14"><a id="chp-8.html._514" class="calibre7 pcalibre"></a>重要的题外话：编写惰性函数</h2>
<p class="calibre9">在命令式语言中， globToRegex 通常是个被我们写成循环的函数。举个例子，Python 标准库中的 fnmatch 模块包括了一个名叫 translate 的函数与我们的 globToRegex 函数做了完全相同的工作。它就被写成一个循环。</p>
<p class="calibre9">如果你了解过函数式编程语言比如 Scheme 或 ML ，可能有个概念已经深入你的脑海，“模拟一个循环的方法是使用尾递归”。</p>
<p class="calibre9">观察 globToRegex' ，可以发现其不是一个尾递归函数。至于原因，重新检查一下它的最后一组规则（它的其他规则也类似）。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>GlobRegex<span class="token">.</span>hs
globToRegex<span class="token4">' (c:cs) = escape c ++ globToRegex'</span> cs

</code></pre>
<p class="calibre9">其递归地执行自身，并以递归执行的结果作为 (++) 函数的参数。因为递归执行并不是这个函数的最后一个操作，所以 globToRegex' 不是尾递归函数。</p>
<p class="calibre9">为何我们的函数没有定义成尾递归的？答案是 Haskell 的非严格求值策略。在我们开始讨论它之前，先快速的了解一下为什么，传统编程语言中，这类递归定义是我们要避免的。这里有一个简化的 (++) 操作符定义。它是递归的，但不是尾递归的。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>append<span class="token">.</span>hs
<span class="token">(</span><span class="token3">++</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span>

<span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token3">++</span> ys <span class="token3">=</span> x <span class="token">:</span> <span class="token">(</span>xs <span class="token3">++</span> ys<span class="token">)</span>
<span class="token">[</span><span class="token">]</span>     <span class="token3">++</span> ys <span class="token3">=</span> ys

</code></pre>
<p class="calibre9">在严格求值语言中，如果我们执行 “foo” ++ “bar”，将马上构建并返回整个列表。非严格求值将这项工作延后很久执行，知道其结果在某处被用到。</p>
<p class="calibre9">如果我们需要 “foo” ++ “bar” 这个表达式结果中的一个元素，函数定义中的第一个模式被匹配，返回表达式 x : (xs ++ ys)。因为 (:) 构造器是非严格的，xs ++ ys 的求值被延迟到当我们需要生成更多结果中的元素时。当生成了结果中的更多元素，我们不再需要 x ，垃圾收集器可以将其回收。因为我们按需要计算结果中的元素，且不保留已经计算出的结果，编译器可以用常数空间对我们的代码求值。</p>
<h2 class="calibre14"><a id="chp-8.html._545" class="calibre7 pcalibre"></a>利用我们的模式匹配器</h2>
<p class="calibre9">有一个函数可以匹配 glob 模式很好，但我们希望可以在实际中使用它。在类 Unix 系统中，glob 函数返回一个由匹配给定 glob 模式串的文件和目录组成的列表。让我们用 Haskell 构造一个类似的函数。按 Haskell 的描述性命名规范，我们将这个函数称为 namesMatching 。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>Glob<span class="token">.</span>hs
module Glob <span class="token">(</span>namesMatching<span class="token">)</span> where

</code></pre>
<p class="calibre9">我们将 namesMatching 指定为我们的 Glob 模块中唯一对用户可见的名字。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>Glob<span class="token">.</span>hs
import System<span class="token">.</span>Directory <span class="token">(</span>doesDirectoryExist<span class="token">,</span> doesFileExist<span class="token">,</span>
                      getCurrentDirectory<span class="token">,</span> getDirectoryContents<span class="token">)</span>

</code></pre>
<p class="calibre9">System.FilePath 抽象了操作系统路径名称的惯例。(&lt;/&gt;) 函数将两个部分组合为一个路径。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>m <span class="token3">+</span>System<span class="token">.</span>FilePath
ghci<span class="token3">&gt;</span> <span class="token4">"foo"</span> <span class="token3">&lt;</span><span class="token3">/</span><span class="token3">&gt;</span> <span class="token4">"bar"</span>
Loading package filepath<span class="token3">-</span><span class="token2">1.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
<span class="token4">"foo/bar"</span>

</code></pre>
<p class="calibre9">The name of the dropTrailingPathSeparator function is perfectly descriptive. No commentsdropTrailingPathSeparator 函数的名字完美地描述了其作用。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> dropTrailingPathSeparator <span class="token4">"foo/"</span>
<span class="token4">"foo"</span>

</code></pre>
<p class="calibre9">splitFileName 函数以路径中的最后一个斜线将路径分割为两部分。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> splitFileName <span class="token4">"foo/bar/Quux.hs"</span>
<span class="token">(</span><span class="token4">"foo/bar/"</span><span class="token">,</span><span class="token4">"Quux.hs"</span><span class="token">)</span>
ghci<span class="token3">&gt;</span> splitFileName <span class="token4">"zippity"</span>
<span class="token">(</span><span class="token4">""</span><span class="token">,</span><span class="token4">"zippity"</span><span class="token">)</span>

</code></pre>
<p class="calibre9">配合 Systems.FilePath 和 Systems.Directory 两个模块，我们可以编写一个在类 Unix 和 Windows 系统上都可以运行的可移植的 namesMatching 函数。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>Glob<span class="token">.</span>hs
import System<span class="token">.</span>FilePath <span class="token">(</span>dropTrailingPathSeparator<span class="token">,</span> splitFileName<span class="token">,</span> <span class="token">(</span><span class="token3">&lt;</span><span class="token3">/</span><span class="token3">&gt;</span><span class="token">)</span><span class="token">)</span>

</code></pre>
<p class="calibre9">在这个模块中，我们将模拟一个 “for” 循环；首次尝试在 Haskell 中处理异常；当然还会用到我们刚写的 matchesGlob 函数。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>Glob<span class="token">.</span>hs
import Control<span class="token">.</span>Exception <span class="token">(</span>handle<span class="token">,</span> SomeException<span class="token">)</span>
import Control<span class="token">.</span>Monad <span class="token">(</span>forM<span class="token">)</span>
import GlobRegex <span class="token">(</span>matchesGlob<span class="token">)</span>

</code></pre>
<p class="calibre9">目录和文件存在于各种带有副作用的活动的“真实世界”，我们的 glob 模式处理函数的返回值类型中将必须带有 IO 。</p>
<p class="calibre9">如果的输入字符串中不包含模式字符，我们简单的在文件系统中检查输入的名字是否已经建立。（注意，此处使用 Haskell 的 guard 语法可以编写精细整齐的定义。“if” 语句也可以做到，但是在美学上不能令人满意。 ）</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>Glob<span class="token">.</span>hs
isPattern <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> Bool
isPattern <span class="token3">=</span> any <span class="token">(</span>`elem` <span class="token4">"[?*"</span><span class="token">)</span>

namesMatching pat
  <span class="token3">|</span> not <span class="token">(</span>isPattern pat<span class="token">)</span> <span class="token3">=</span> <span class="token1">do</span>
    exists <span class="token3">&lt;</span><span class="token3">-</span> doesNameExist pat
    <span class="token1">return</span> <span class="token">(</span><span class="token1">if</span> exists then <span class="token">[</span>pat<span class="token">]</span> <span class="token1">else</span> <span class="token">[</span><span class="token">]</span><span class="token">)</span>

</code></pre>
<p class="calibre9">doesNameExist 是一个我们将要简要定义的函数的名字。</p>
<p class="calibre9">如果字符串是一个 glob 模式呢？继续定义我们的函数。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>Glob<span class="token">.</span>hs
  <span class="token3">|</span> otherwise <span class="token3">=</span> <span class="token1">do</span>
    case splitFileName pat of
      <span class="token">(</span><span class="token4">""</span><span class="token">,</span> baseName<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">do</span>
          curDir <span class="token3">&lt;</span><span class="token3">-</span> getCurrentDirectory
          listMatches curDir baseName
      <span class="token">(</span>dirName<span class="token">,</span> baseName<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">do</span>
          dirs <span class="token3">&lt;</span><span class="token3">-</span> <span class="token1">if</span> isPattern dirName
                  then namesMatching <span class="token">(</span>dropTrailingPathSeparator dirName<span class="token">)</span>
                  <span class="token1">else</span> <span class="token1">return</span> <span class="token">[</span>dirName<span class="token">]</span>
          let listDir <span class="token3">=</span> <span class="token1">if</span> isPattern baseName
                        then listMatches
                        <span class="token1">else</span> listPlain
          pathNames <span class="token3">&lt;</span><span class="token3">-</span> forM dirs $ \dir <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">do</span>
                           baseNames <span class="token3">&lt;</span><span class="token3">-</span> listDir dir baseName
                           <span class="token1">return</span> <span class="token">(</span>map <span class="token">(</span>dir <span class="token3">&lt;</span><span class="token3">/</span><span class="token3">&gt;</span><span class="token">)</span> baseNames<span class="token">)</span>
          <span class="token1">return</span> <span class="token">(</span>concat pathNames<span class="token">)</span>

</code></pre>
<p class="calibre9">我们使用 splitFileName 将字符串分割为目录名和文件名。如果第一个元素为空，说明我们正在当前目录寻找符合模式的文件。否则，我们必须检查目录名，观察其是否包含模式。若不含模式，我们建立一个只由目录名一个元素组成的列表。如果含有模式，我们列出所有匹配的目录。</p>
<p class="calibre9">Note</p>
<p class="calibre9">注意事项</p>
<p class="calibre9">System.FilePath 模块稍有点诡异。上面的情况就是一个例子。 splitFileName 函数在其返回值的目录名部分的结尾保留了一个斜线。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>module <span class="token3">+</span>System<span class="token">.</span>FilePath
ghci<span class="token3">&gt;</span> splitFileName <span class="token4">"foo/bar"</span>
Loading package filepath<span class="token3">-</span><span class="token2">1.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
<span class="token">(</span><span class="token4">"foo/"</span><span class="token">,</span><span class="token4">"bar"</span><span class="token">)</span>

</code></pre>
<p class="calibre9">If we didn't remember (or know enough) to remove that slash, we'd recurse endlessly in namesMatching, because of the following behaviour of splitFileName. 1 comment 如果忘记（或不够了解）要去掉这个斜线，我们将在 namesMatching 函数中进行无止尽的递归匹配，看看后面演示的 splitFileName 的行为你就会明白。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> splitFileName <span class="token4">"foo/"</span>
<span class="token">(</span><span class="token4">"foo/"</span><span class="token">,</span><span class="token4">""</span><span class="token">)</span>

</code></pre>
<p class="calibre9">你或许能够想想想象是什么促使我们加入这份注意事项。</p>
<p class="calibre9">最终，我们将每个目录中的匹配收集起来，得到一个由列表组成的列表，然后将它们连接为一个单独的由文件名组成的列表。</p>
<p class="calibre9">上面那个函数中出现的陌生的 forM 函数，其行为有些像 “for” 循环：它将其第二个参数（一个动作）映射到其第一个参数（一个列表），并返回由其结果组成的列表。</p>
<p class="calibre9">我们还剩余一些零散的目标需要完成。首先是上面用到过的 doesNameExist 函数的定义。 System.Directory 函数无法检查一个名字是否已经在文件系统中建立。它强制我们明确要检查的是一个文件还是目录。这个 API 设计的很丑陋，所以我们必须在一个函数中完成两次检验。出于效率考虑，我们首先检查文件名，因为文件比目录更常见。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>Glob<span class="token">.</span>hs
doesNameExist <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO Bool

doesNameExist name <span class="token3">=</span> <span class="token1">do</span>
    fileExists <span class="token3">&lt;</span><span class="token3">-</span> doesFileExist name
    <span class="token1">if</span> fileExists
      then <span class="token1">return</span> True
      <span class="token1">else</span> doesDirectoryExist name

</code></pre>
<p class="calibre9">还有两个函数需要定义，返回值都是由某个目录下的名字组成的列表。 listMatches 函数返回由某目录下全部匹配给定 glob 模式的文件名组成的列表。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>Glob<span class="token">.</span>hs
listMatches <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">[</span>String<span class="token">]</span>
listMatches dirName pat <span class="token3">=</span> <span class="token1">do</span>
    dirName' <span class="token3">&lt;</span><span class="token3">-</span> <span class="token1">if</span> <span class="token1">null</span> dirName
                then getCurrentDirectory
                <span class="token1">else</span> <span class="token1">return</span> dirName
    handle <span class="token">(</span>const <span class="token">(</span><span class="token1">return</span> <span class="token">[</span><span class="token">]</span><span class="token">)</span><span class="token">:</span><span class="token">:</span><span class="token">(</span>SomeException<span class="token3">-</span><span class="token3">&gt;</span>IO <span class="token">[</span>String<span class="token">]</span><span class="token">)</span><span class="token">)</span>
           $ <span class="token1">do</span> names <span class="token3">&lt;</span><span class="token3">-</span> getDirectoryContents dirName'
                let names' <span class="token3">=</span> <span class="token1">if</span> isHidden pat
                             then filter isHidden names
                             <span class="token1">else</span> filter <span class="token">(</span>not <span class="token">.</span> isHidden<span class="token">)</span> names
                <span class="token1">return</span> <span class="token">(</span>filter <span class="token">(</span>`matchesGlob` pat<span class="token">)</span> names'<span class="token">)</span>

isHidden <span class="token">(</span><span class="token4">'.'</span><span class="token">:</span>_<span class="token">)</span> <span class="token3">=</span> True
isHidden _       <span class="token3">=</span> False

</code></pre>
<p class="calibre9">listPlain 接收的函数名若存在，则返回由这个文件名组成的单元素列表，否则返回空列表。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>Glob<span class="token">.</span>hs
listPlain <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">[</span>String<span class="token">]</span>
listPlain dirName baseName <span class="token3">=</span> <span class="token1">do</span>
    exists <span class="token3">&lt;</span><span class="token3">-</span> <span class="token1">if</span> <span class="token1">null</span> baseName
              then doesDirectoryExist dirName
              <span class="token1">else</span> doesNameExist <span class="token">(</span>dirName <span class="token3">&lt;</span><span class="token3">/</span><span class="token3">&gt;</span> baseName<span class="token">)</span>
    <span class="token1">return</span> <span class="token">(</span><span class="token1">if</span> exists then <span class="token">[</span>baseName<span class="token">]</span> <span class="token1">else</span> <span class="token">[</span><span class="token">]</span><span class="token">)</span>

</code></pre>
<p class="calibre9">仔细观察 listMatches 函数的定义，将发现一个名为 handle 的函数。之前，我们从 Control.Exception 模块中将其载入。正如其暗示的那样，这个函数让我们初次体验了 Haskell 中的异常处理。把它扔进 ghci 中看我们会发现什么。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>module <span class="token3">+</span>Control<span class="token">.</span>Exception
ghci<span class="token3">&gt;</span> <span class="token">:</span>type handle
handle <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Exception <span class="token3">-</span><span class="token3">&gt;</span> IO a<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> IO a <span class="token3">-</span><span class="token3">&gt;</span> IO a

</code></pre>
<p class="calibre9">可以看出 handle 接受两个参数。首先是一个函数，其接受一个异常值，且有副作用（其返回值类型带有 IO 标签）；这是一个异常处理器。第二个参数是可能会抛出异常的代码。 关于异常处理器，异常处理器的类型限制其必须返回与抛出异常的代码相同的类型。所以它只能选择或是抛出一个异常，或像在我们的例子中返回一个由字符串组成的列表。 const 函数接受两个参数；无论第二个参数是什么，其始终返回第一个参数。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type const
const <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> b <span class="token3">-</span><span class="token3">&gt;</span> a
ghci<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token1">return</span> <span class="token">[</span><span class="token">]</span>
<span class="token1">return</span> <span class="token">[</span><span class="token">]</span> <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Monad m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> m <span class="token">[</span>a<span class="token">]</span>
ghci<span class="token3">&gt;</span> <span class="token">:</span>type handle <span class="token">(</span>const <span class="token">(</span><span class="token1">return</span> <span class="token">[</span><span class="token">]</span><span class="token">)</span><span class="token">)</span>
handle <span class="token">(</span>const <span class="token">(</span><span class="token1">return</span> <span class="token">[</span><span class="token">]</span><span class="token">)</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> IO <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">[</span>a<span class="token">]</span>

</code></pre>
<p class="calibre9">我们使用 const 编写异常处理器忽略任何向其传入的异常。取而代之，当我们捕获异常时，返回一个空列表。</p>
<p class="calibre9">本章不会再展开任何异常处理相关的话题。然而还有更多可说，我们将在第 19 章异常处理时重新探讨这个主题。</p>
<h2 class="calibre14"><a id="chp-8.html._750" class="calibre7 pcalibre"></a>练习</h2>
<ol class="calibre17"><li class="calibre11">尽管我们已经编写了一个可移植 namesMatching 函数，这个函数使用了我们的大小写敏感的 globToRegex 函数。尝试在不改变其类型签名的前提下，使 namesMatching 在 Unix 下大小写敏感，在 Windows 下大小写不敏感。</li></ol>
<p class="calibre9">提示：查阅一下 System.FilePath 的文档，其中有一个变量可以告诉我们程序是运行在类 Unix 系统上还是在 Windows 系统上。</p>
<ol class="calibre17"><li class="calibre11">如果你在使用类 Unix 系统，查阅 System.Posix.Files 模块的文档，看是否能找到一个 doesNameExist 的替代品。</li><li class="calibre11"><ul class="calibre31"><li class="calibre11">通配符，仅匹配一个单独目录中的名字。很多 shell 可以提供扩展通配符语法， ** ，其将在所有目录中进行递归匹配。举个例子，**.c 意为 “在当前目录及其任意深度的子目录下匹配一个 .c 结尾的文件名”。实现 ** 通配符匹配。</li></ul></li></ol>
<h2 class="calibre14"><a id="chp-8.html._API__759" class="calibre7 pcalibre"></a>通过 API 设计进行错误处理</h2>
<p class="calibre9">向 globToRegex 传入一个畸形的正则表达式未必会是一场灾难。用户的表达式可能会有输入错误，这时我们更希望得到有意义的报错信息。</p>
<p class="calibre9">当这类问题出现时，调用 error 函数会有很激烈的反应（其结果在 Q: 1 这个练习中探索过。）。 error 函数会抛出一个异常。纯函数式的 Haskell 代码无法处理异常，所以控制流会突破我们的纯函数代码直接交给处于距离最近一层 IO 中并且安装有合适的异常处理器的调用者。如果没有安装异常处理器， Haskell 运行时的默认动作是终结我们的程序（如果是在 ghci 中，则会打出一条令人不快的错误信息。）</p>
<p class="calibre9">所以，调用 error 有点像是拉下了战斗机的座椅弹射手柄。我们从一个无法优雅处理的灾难性场景中逃离，而等我们着地时会撒出很多燃烧着的残骸。</p>
<p class="calibre9">我们已经确定了 error 是为灾难情场景准备的，但我们仍旧在 globToRegex 中使用它。畸形的输入将被拒绝，但不会导致大问题。处理这种情况有更好的方式吗？</p>
<p class="calibre9">Haskell 的类型系统和库来救你了！我们可以使用内置的 Either 类型，在 globToRegex 函数的类型签名中描述失败的可能性。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>GlobRegexEither<span class="token">.</span>hs
type GlobError <span class="token3">=</span> String

globToRegex <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> Either GlobError String

</code></pre>
<p class="calibre9">globToRegex 的返回值将为两种情况之一，或者为 Left"出错信息" 或者为 Right"一个合法正则表达式" 。这种返回值类型，强制我们的调用者处理可能出现的错误。（你会发现这是 Haskell 代码中 Either 类型最广泛的用途。）</p>
<h2 class="calibre14"><a id="chp-8.html._781" class="calibre7 pcalibre"></a>练习</h2>
<ol class="calibre17"><li class="calibre11">编写一个使用上面那种类型签名的 globToRegex 版本。</li><li class="calibre11">改变 namesMatching 的类型签名，使其可以处理畸形的正则表达式，并使用它重写 globToRegex 函数。</li></ol>
<p class="calibre9">Tip</p>
<p class="calibre9">你会发现牵扯到的工作量大得惊人。别怕，我们将在后面的章节介绍更多简单老练的处理错误的方式。</p>
<h2 class="calibre14"><a id="chp-8.html._790" class="calibre7 pcalibre"></a>让我们的代码工作</h2>
<p class="calibre9">namesMatching 函数本身并不是很令人兴奋，但它是一个很有用的构建模块。将它与稍多点的函数组合在一起，就会让我们做出有趣的东西。</p>
<p class="calibre9">这里有个例子。定义一个 renameWith 函数，并不简单的重命名一个文件，取而代之，对文件名执行一个函数，并将返回值作为新的文件名。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>Useful<span class="token">.</span>hs
import System<span class="token">.</span>FilePath <span class="token">(</span>replaceExtension<span class="token">)</span>
import System<span class="token">.</span>Directory <span class="token">(</span>doesFileExist<span class="token">,</span> renameDirectory<span class="token">,</span> renameFile<span class="token">)</span>
import Glob <span class="token">(</span>namesMatching<span class="token">)</span>

renameWith <span class="token">:</span><span class="token">:</span> <span class="token">(</span>FilePath <span class="token3">-</span><span class="token3">&gt;</span> FilePath<span class="token">)</span>
           <span class="token3">-</span><span class="token3">&gt;</span> FilePath
           <span class="token3">-</span><span class="token3">&gt;</span> IO FilePath

renameWith f path <span class="token3">=</span> <span class="token1">do</span>
    let path' <span class="token3">=</span> f path
    rename path path'
    <span class="token1">return</span> path'

</code></pre>
<p class="calibre9">我们再一次通过一个辅助函数使用 System.Directory 中难看的文件/目录函数</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>Useful<span class="token">.</span>hs
rename <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>

rename old <span class="token1">new</span> <span class="token3">=</span> <span class="token1">do</span>
    isFile <span class="token3">&lt;</span><span class="token3">-</span> doesFileExist old
    let f <span class="token3">=</span> <span class="token1">if</span> isFile then renameFile <span class="token1">else</span> renameDirectory
    f old <span class="token1">new</span>

</code></pre>
<p class="calibre9">System.FilePath 模块提供了很多有用的函数用于操作文件名。这些函数洽好漏过了我们的 renameWith 和 namesMatching 函数，所以我们可以通过将他们组合起来的方式来快速的创建新函数。例如，这个简洁的函数修改了 C++ 源码文件的后缀名。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch08<span class="token3">/</span>Useful<span class="token">.</span>hs
cc2cpp <span class="token3">=</span>
  mapM <span class="token">(</span>renameWith <span class="token">(</span>flip replaceExtension <span class="token4">".cpp"</span><span class="token">)</span><span class="token">)</span> <span class="token3">=</span><span class="token3">&lt;</span><span class="token3">&lt;</span> namesMatching <span class="token4">"*.cc"</span>

</code></pre>
<p class="calibre9">cc2cpp 函数使用了几个我们已经见过多次的函数。 flip 函数接受另一个函数作为参数，交换其参数的顺序（可以在 ghci 中调查 replaceExtension 的类型以了解详情）。 =&lt;&lt; 函数将其右侧动作的结果喂给其左侧的动作。</p>
<h2 class="calibre14"><a id="chp-8.html._837" class="calibre7 pcalibre"></a>练习</h2>
<ol class="calibre18"><li class="calibre11">Glob 模式解释起来很简单，用 Haskell 可以很容易的直接写出其匹配器，正则表达式则不然。试一下编写正则匹配。</li></ol>
</div></div></div></div></div></div>
<div id="chp-9.html"><div class="calibre">
<div id="chp-9.html.main" class="calibre1"><div class="root"><div class="article"><h1 class="article-head" id="chp-9.html.calibre_toc_9">第九章：I/O学习 —— 构建一个用于搜索文件系统的库</h1><div class="article-body"><h1 class="calibre6"><a id="chp-9.html.IO___0" class="calibre7 pcalibre"></a>第九章：I/O学习 —— 构建一个用于搜索文件系统的库</h1>
<p class="calibre9">自从电脑有了分层文件系统以来，“我知道有这个文件，但不知道它放在哪”这个问题就一直困扰着人们。1974年发布的Unix第五个版本引入的 find 命令，到今天仍在使用。查找文件的艺术已经走过了很长一段路：伴随现代操作系统一起不断发展的文件索引和搜索功能。</p>
<p class="calibre9">给程序员的工具箱里添加类似 find 这样的功能依旧非常有价值，在本章，我们将通过编写一个Haskell库给我们的 find 命令添加更多功能，我们将通过一些有着不同的健壮度的方法来完成这个库。</p>
<h2 class="calibre14"><a id="chp-9.html.find_6" class="calibre7 pcalibre"></a>find命令</h2>
<p class="calibre9">如果你不曾用过类Unix的系统，或者你不是个重度shell用户，那么你很可能从未听说过 find ，通过给定的一组目录，它递归搜索每个目录并且打印出每个匹配表达式的实体名称。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>RecursiveContents<span class="token">.</span>hs
module RecursiveContents <span class="token">(</span>getRecursiveContents<span class="token">)</span> where
import Control<span class="token">.</span>Monad <span class="token">(</span>forM<span class="token">)</span>
import System<span class="token">.</span>Directory <span class="token">(</span>doesDirectoryExist<span class="token">,</span> getDirectoryContents<span class="token">)</span>
import System<span class="token">.</span>FilePath <span class="token">(</span><span class="token">(</span><span class="token3">&lt;</span><span class="token3">/</span><span class="token3">&gt;</span><span class="token">)</span><span class="token">)</span>
getRecursiveContents <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">[</span>FilePath<span class="token">]</span>
getRecursiveContents topdir <span class="token3">=</span> <span class="token1">do</span>
    names <span class="token3">&lt;</span><span class="token3">-</span> getDirectoryContents topdir
let properNames <span class="token3">=</span> filter <span class="token">(</span>`notElem` <span class="token">[</span><span class="token4">"."</span><span class="token">,</span> <span class="token4">".."</span><span class="token">]</span><span class="token">)</span> names
    paths <span class="token3">&lt;</span><span class="token3">-</span> forM properNames $ \name <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">do</span>
let path <span class="token3">=</span> topdir <span class="token3">&lt;</span><span class="token3">/</span><span class="token3">&gt;</span> name
    isDirectory <span class="token3">&lt;</span><span class="token3">-</span> doesDirectoryExist path
    <span class="token1">if</span> isDirectory
        then getRecursiveContents path
    <span class="token1">else</span> <span class="token1">return</span> <span class="token">[</span>path<span class="token">]</span>
<span class="token1">return</span> <span class="token">(</span>concat paths<span class="token">)</span>

</code></pre>
<p class="calibre9">单个表达式可以识别像“符合这个全局模式的名称”，“实体是一个文件”，“当前最后一个被修改的文件”以及其他诸如此类的表达式，通过and或or算子就可以把他们装配起来构成更加复杂的表达式</p>
<h2 class="calibre14"><a id="chp-9.html._32" class="calibre7 pcalibre"></a>简单的开始：递归遍历目录</h2>
<p class="calibre9">在投入设计我们的库之前，先解决一些规模稍小的问题，我们第一个问题就是递归地列出一个目录下面的所有内容和它的子目录</p>
<p class="calibre9">filter 表达式确保一个目录的列表不含特定的目录名（比如代表当前目录的 . 和上一级目录的 .. ），如果忘记过滤这些，随后的查找将陷入无限循环。</p>
<p class="calibre9">我们在之前的章节里完成了 forM 函数，它是参数颠倒后的 mapM 函数。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>m <span class="token3">+</span>Control<span class="token">.</span>Monad
ghci<span class="token3">&gt;</span> <span class="token">:</span>type mapM
mapM <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Monad m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> m b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> m <span class="token">[</span>b<span class="token">]</span>
ghci<span class="token3">&gt;</span> <span class="token">:</span>type forM
forM <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Monad m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> m b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> m <span class="token">[</span>b<span class="token">]</span>

</code></pre>
<p class="calibre9">循环体将检查当前实体是否为目录，如果是，则递归调用 getrecuresivacontents 函数列出这个目录（的内容），如果否，则返回只含有当前实体名称一个元素的列表，不要忘记 return 函数在 Haskell 中有特殊的含义，他通过monad的类型构造器包装了一个值。</p>
<p class="calibre9">另一个值得注意的地方是变量 isDirectory 的使用，在命令式语言如 Python 中，我们通常用 ifos.path.isdir(path) 来表示，然而， doesDirectoryExist 函数是一个动作，它的返回类型是 IOBool 而非 Bool ，由于 if 表达式需要一个操作值为 bool 的表达式作为条件，我们使用 &lt;- 来从io包装器上得到这个动作的的 bool 返回值，这样我们就能在 if 中使用这个干净的无包装的 bool 。</p>
<p class="calibre9">循环体中每一次迭代生成的结果都是名称列表，因此 forM 的结果是 IO[[FilePath]] ，我们通过 concat 将它转换为一个元素列表(从以列表为元素的列表转换为不含列表元素的列表)</p>
<h2 class="calibre14"><a id="chp-9.html._55" class="calibre7 pcalibre"></a>再次认识匿名和命名函数</h2>
<p class="calibre9">在 <a href="http://book.realworldhaskell.org/read/functional-programming.html#fp.anonymous" target="_blank" class="calibre7 pcalibre">Anonymous (lambda) functions</a> [<a href="http://book.realworldhaskell.org/read/functional-programming.html#fp.anonymous" target="_blank" class="calibre7 pcalibre">http://book.realworldhaskell.org/read/functional-programming.html#fp.anonymous</a>] 这部分，我们列举了一系列不使用匿名函数的原因，然而在这里，我们将使用它作为函数体，这是匿名函数在 Haskell 中最常见的用途之一。</p>
<p class="calibre9">我们已经在 froM 和 mapM 上看到使用函数作为参数的方式，许多循环体是程序中只出现一次的代码块。既然我们喜欢在循环中使用一个再也不会出现的循环体，那么为什么要给他们命名？</p>
<p class="calibre9">显而易见，有时候我们需要在不同的循环中嵌入相同的代码，这时候我们不应该使用匿名函数，把他们剪贴和复制进去，而是给这些匿名函数命名来调用，这样显得有意义一点</p>
<h2 class="calibre14"><a id="chp-9.html._mapM__forM_63" class="calibre7 pcalibre"></a>为什么提供 mapM 和 forM</h2>
<p class="calibre9">存在两个相同的函数看起来是有点奇怪，但接受参数的顺序之间的差异使他们适用于不同的情况。</p>
<p class="calibre9">我们来考察下之前的例子，使用匿名函数作为循环体，如果我们使用 mapM 而非 forM ，我们将不得不把变量 properNames 放置到函数体的后边，而为了让代码正确解析，我们就必须将整个匿名函数用括号包起来，或者用一个不必要的命名函数将它取代，自己尝试下，拷贝上边的代码，用 mapM 代替 forM ，观察代码可读性上有什么变化</p>
<p class="calibre9">相反，如果循环体是一个命名函数，而且我们要循环的列表是通过一个复杂表达式计算的，我们就找到了 mapM 的应用场景</p>
<p class="calibre9">这里需要遵守的代码风格是无论通过 mapM 和 forM 都让你写出干净的代码，如果循环体或者循环中的表达式都很短，那么用哪个都无所谓，如果循环体很短，但数据很长，使用 mapM ，如果相反，则用 forM ，如果都很长，使用 let 或者 where 让其中一个变短，通过这样一些实践，不同情况下那个实现最好就变得显而易见</p>
<h2 class="calibre14"><a id="chp-9.html._73" class="calibre7 pcalibre"></a>一个本地查找函数</h2>
<p class="calibre9">我们可以使用 getRecursiveContents 函数作为一个内置的简单文件查找器的基础</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>SimpleFinder<span class="token">.</span>hs
import RecursiveContents <span class="token">(</span>getRecursiveContents<span class="token">)</span>
simpleFind <span class="token">:</span><span class="token">:</span> <span class="token">(</span>FilePath <span class="token3">-</span><span class="token3">&gt;</span> Bool<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">[</span>FilePath<span class="token">]</span>
simpleFind p path <span class="token3">=</span> <span class="token1">do</span>
    names <span class="token3">&lt;</span><span class="token3">-</span> getRecursiveContents path
    <span class="token1">return</span> <span class="token">(</span>filter p names<span class="token">)</span>

</code></pre>
<p class="calibre9">上文的函数通过我们在过滤器中的谓词来匹配 getRecursiveContents 函数返回的名字，每个通过谓词判断的名称都是文件全路径，因此如何完成一个像“查找所有扩展名以 .c 结尾的文件”的功能？</p>
<p class="calibre9">System.FilePath 模块包含了许多有价值的函数来帮助我们操作文件名，在这个例子中，我们使用 takeExtension ：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>m <span class="token3">+</span>System<span class="token">.</span>FilePath
ghci<span class="token3">&gt;</span> <span class="token">:</span>type takeExtension
takeExtension <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> String
ghci<span class="token3">&gt;</span> takeExtension <span class="token4">"foo/bar.c"</span>
Loading package filepath<span class="token3">-</span><span class="token2">1.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
<span class="token4">".c"</span>
ghci<span class="token3">&gt;</span> takeExtension <span class="token4">"quux"</span>
<span class="token4">""</span>

</code></pre>
<p class="calibre9">下面的代码给我们一个包括获得路径，获得扩展名，然后和.c进行比较的简单功能的函数实现，</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>load SimpleFinder
<span class="token">[</span><span class="token2">1</span> of <span class="token2">2</span><span class="token">]</span> Compiling RecursiveContents <span class="token">(</span> RecursiveContents<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
<span class="token">[</span><span class="token2">2</span> of <span class="token2">2</span><span class="token">]</span> Compiling Main             <span class="token">(</span> SimpleFinder<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> RecursiveContents<span class="token">,</span> Main<span class="token">.</span>
ghci<span class="token3">&gt;</span> <span class="token">:</span>type simpleFind <span class="token">(</span>\p <span class="token3">-</span><span class="token3">&gt;</span> takeExtension p <span class="token3">==</span> <span class="token4">".c"</span><span class="token">)</span>
simpleFind <span class="token">(</span>\p <span class="token3">-</span><span class="token3">&gt;</span> takeExtension p <span class="token3">==</span> <span class="token4">".c"</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">[</span>FilePath<span class="token">]</span>

</code></pre>
<p class="calibre9">simpleFind 在工作中有一些非常刺眼的问题，第一个就是谓词并不能准确而完全的表达，他只关注文件夹中的实体名称，而无法做到辨认这是个文件还是个目录此类的事情，——而我们使用 simpleFind 的尝试就是想列举所文件和有和文件一样拥有 .c 扩展名的文件夹</p>
<p class="calibre9">第二个问题是在 simpleFind 中我们无法控制它遍历文件系统的方式，这是显而易见的，想想在分布式版本控制系统中控制下的树状结构中查找一个源文件的问题吧，所有被控制的目录都含有一个 .svn 的私有文件夹，每一个包含了许多我们毫不感兴趣的子文件夹和文件，简单的过滤所有包含 .svn 的路径远比仅仅在读取时避免遍历这些文件夹更加有效。例如，一个分布式源码树包含了45000个文件，30000个分布在1200个不同的.svn文件夹中，避免遍历这1200个文件夹比过滤他们包含的30000个文件代价更低。</p>
<p class="calibre9">最后。 simpleFind 是严格的，因为它包含一系列IO元操作执行构成的动作，如果我们有一百万个文件要遍历，我们需要等待很长一段时间才能得到一个包含一百万个名字的巨大的返回值，这对用户体验和资源消耗都是噩梦，我们更需要一个只有当他们获得结果的时才展示的结果流。</p>
<p class="calibre9">在接下来的环节里，我们将解决每个遇到的问题</p>
<h2 class="calibre14"><a id="chp-9.html._123" class="calibre7 pcalibre"></a>谓词在保持纯粹的同时支持从贫类型到富类型</h2>
<p class="calibre9">我们的谓词只关注文件名，这将一系列有趣的操作排除在外，试想下，假如我们希望列出比某个给定值更大的文件呢？</p>
<p class="calibre9">面对这个问题的第一反应是查找 IO :我们的谓词是 FilePath-&gt;Bool 类型，为什么不把它变成 FilePath-&gt;IOBool 类型？这将使我们所有的IO操作都成为谓词的一部分，但这在显而易见的好处之外引入一个潜在的问题，使用这样一个谓词存在各种可能的后果，比如一个有 IOa 类型返回的函数将有能力生成任何它想产生的结果。</p>
<p class="calibre9">让我们在类型系统中寻找以写出拥有更多谓词，更少bug的代码，我们通过避免污染IO来坚持断言的纯粹，这将确保他们不会产生任何不纯的结果，同时我们给他们提供更多信息，这样他们就可以在不必诱发潜在的危险的情况下获得需要的表达式</p>
<p class="calibre9">Haskell 的 System.Directory 模块提供了一个尽管受限但仍然有用的关于文件元数据的集合</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>m <span class="token3">+</span>System<span class="token">.</span>Directory

</code></pre>
<p class="calibre9">我们可以通过 doesFileExist 和 doesDirectoryExist 来判断目录实体是目录还是文件，但暂时还没有更多方式来查找这些年里出现的纷繁复杂的其他文件类型，比如管道，硬链接和软连接。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type doesFileExist
doesFileExist <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO Bool
ghci<span class="token3">&gt;</span> doesFileExist <span class="token4">"."</span>
Loading package old<span class="token3">-</span>locale<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package old<span class="token3">-</span>time<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package directory<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
False
ghci<span class="token3">&gt;</span> <span class="token">:</span>type doesDirectoryExist
doesDirectoryExist <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO Bool
ghci<span class="token3">&gt;</span> doesDirectoryExist <span class="token4">"."</span>
True

</code></pre>
<p class="calibre9">getPermissions 函数让我们确定当前对于文件或目录的操作是否是合法：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type getPermissions
getPermissions <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO Permissions
ghci<span class="token3">&gt;</span> <span class="token">:</span>info Permissions
data Permissions
  <span class="token3">=</span> Permissions <span class="token">{</span>readable <span class="token">:</span><span class="token">:</span> Bool<span class="token">,</span>
                 writable <span class="token">:</span><span class="token">:</span> Bool<span class="token">,</span>
                 executable <span class="token">:</span><span class="token">:</span> Bool<span class="token">,</span>
                 searchable <span class="token">:</span><span class="token">:</span> Bool<span class="token">}</span>
      <span class="token3">--</span> Defined <span class="token1">in</span> System<span class="token">.</span>Directory
instance Eq Permissions <span class="token3">--</span> Defined <span class="token1">in</span> System<span class="token">.</span>Directory
instance Ord Permissions <span class="token3">--</span> Defined <span class="token1">in</span> System<span class="token">.</span>Directory
instance Read Permissions <span class="token3">--</span> Defined <span class="token1">in</span> System<span class="token">.</span>Directory
instance Show Permissions <span class="token3">--</span> Defined <span class="token1">in</span> System<span class="token">.</span>Directory
ghci<span class="token3">&gt;</span> getPermissions <span class="token4">"."</span>
Permissions <span class="token">{</span>readable <span class="token3">=</span> True<span class="token">,</span> writable <span class="token3">=</span> True<span class="token">,</span> executable <span class="token3">=</span> False<span class="token">,</span> searchable <span class="token3">=</span> True<span class="token">}</span>
ghci<span class="token3">&gt;</span> <span class="token">:</span>type searchable
searchable <span class="token">:</span><span class="token">:</span> Permissions <span class="token3">-</span><span class="token3">&gt;</span> Bool
ghci<span class="token3">&gt;</span> searchable it
True

</code></pre>
<p class="calibre9">如果你无法回忆起 ghci 中变量 it 的特殊用法，回到第一章复习一下，如果我们的权限能够列出它的内容，那么这个目录就应该是可被搜索的，而文件则永远是不可搜索的</p>
<p class="calibre9">最后， getModificationTime 告诉我们实体上次被修改的时间：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type getModificationTime
getModificationTime <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO System<span class="token">.</span>Time<span class="token">.</span>ClockTime
ghci<span class="token3">&gt;</span> getModificationTime <span class="token4">"."</span>
Mon Aug <span class="token2">18</span> <span class="token2">12</span><span class="token">:</span><span class="token2">08</span><span class="token">:</span><span class="token2">24</span> CDT <span class="token2">2008</span>

</code></pre>
<p class="calibre9">如果我们像标准的Haskell代码一样对可移植性要求严格，这些函数就是我们手头所有的一切(我们同样可以通过黑客手段来获得文件大小)，这些已经足够让我们明白所感兴趣领域中的原则，而非让我们浪费宝贵的时间对着一个例子冥思苦想，如果你需要写满足更多需求的代码， System.Posix 和 System.Win32 模块提供关于当代两种计算平台的更多文件元数据的细节。 Hackage 中同样有一个 unix-compat 包，提供windows下的类unix的api 。</p>
<p class="calibre9">新的富类型谓词需要关注的数据段到底有几个？自从我们可以通过 Permissions 来判断实体是文件还是目录之后，我们就不再需要获得 doesFileExist 和 doesDirectoryExist 的结果，因此一个谓词需要关注的输入有四个。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>BetterPredicate<span class="token">.</span>hs
import Control<span class="token">.</span>Monad <span class="token">(</span>filterM<span class="token">)</span>
import System<span class="token">.</span>Directory <span class="token">(</span><span class="token5">Permissions</span><span class="token">(</span><span class="token">.</span><span class="token">.</span><span class="token">)</span><span class="token">,</span> getModificationTime<span class="token">,</span> getPermissions<span class="token">)</span>
import System<span class="token">.</span>Time <span class="token">(</span><span class="token5">ClockTime</span><span class="token">(</span><span class="token">.</span><span class="token">.</span><span class="token">)</span><span class="token">)</span>
import System<span class="token">.</span>FilePath <span class="token">(</span>takeExtension<span class="token">)</span>
import Control<span class="token">.</span>Exception <span class="token">(</span>bracket<span class="token">,</span> handle<span class="token">)</span>
import System<span class="token">.</span>IO <span class="token">(</span><span class="token5">IOMode</span><span class="token">(</span><span class="token">.</span><span class="token">.</span><span class="token">)</span><span class="token">,</span> hClose<span class="token">,</span> hFileSize<span class="token">,</span> openFile<span class="token">)</span>

<span class="token3">--</span> the <span class="token1">function</span> we wrote earlier
import RecursiveContents <span class="token">(</span>getRecursiveContents<span class="token">)</span>

type Predicate <span class="token3">=</span>  FilePath      <span class="token3">--</span> path to directory entry
               <span class="token3">-</span><span class="token3">&gt;</span> Permissions   <span class="token3">--</span> permissions
               <span class="token3">-</span><span class="token3">&gt;</span> Maybe Integer <span class="token3">--</span> file size <span class="token">(</span>Nothing <span class="token1">if</span> not file<span class="token">)</span>
               <span class="token3">-</span><span class="token3">&gt;</span> ClockTime     <span class="token3">--</span> last modified
               <span class="token3">-</span><span class="token3">&gt;</span> Bool

</code></pre>
<p class="calibre9">这一谓词类型只是一个有四个参数的函数的同义词，他将给我们节省一些键盘工作和屏幕空间。</p>
<p class="calibre9">注意这一返回值是 Bool 而非 IOBool ，谓词需要保证纯粹，而且不能表现IO，在拥有这种类型以后，我们的查找函数仍然显得非常空白。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>BetterPredicate<span class="token">.</span>hs
<span class="token3">--</span> soon to be defined
getFileSize <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span>Maybe Integer<span class="token">)</span>

betterFind <span class="token">:</span><span class="token">:</span> Predicate <span class="token3">-</span><span class="token3">&gt;</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">[</span>FilePath<span class="token">]</span>

betterFind p path <span class="token3">=</span> getRecursiveContents path <span class="token3">&gt;</span><span class="token3">&gt;=</span> filterM check
    where check name <span class="token3">=</span> <span class="token1">do</span>
            perms <span class="token3">&lt;</span><span class="token3">-</span> getPermissions name
            size <span class="token3">&lt;</span><span class="token3">-</span> getFileSize name
            modified <span class="token3">&lt;</span><span class="token3">-</span> getModificationTime name
            <span class="token1">return</span> <span class="token">(</span>p name perms size modified<span class="token">)</span>

</code></pre>
<p class="calibre9">先来阅读代码，由于随后将讨论 getFileSize 的某些细节，因此现在暂时先跳过它。</p>
<p class="calibre9">我们无法使用 filter 来调用我们的谓词，因为 p 的纯粹代表他不能作为IO收集元数据的方式</p>
<p class="calibre9">这让我们将目光转移到一个并不熟悉的函数 filterM 上，它的动作就像普通的 filter 函数，但在这种情况下，它在 IOmonad 操作中使用它的谓词，进而通过谓词表现IO：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>m <span class="token3">+</span>Control<span class="token">.</span>Monad
ghci<span class="token3">&gt;</span> <span class="token">:</span>type filterM
filterM <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Monad m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> m Bool<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> m <span class="token">[</span>a<span class="token">]</span>

</code></pre>
<p class="calibre9">check 谓词是纯谓词 p 的IO功能包装器，他执行了所有IO发生在 p 上的可能引起负面效果的任务，因此我们可以使 p 对负面效果免疫，在收集完元数据后， check 调用 p ，通过 return 语句包装 p 的IO返回结果</p>
<h2 class="calibre14"><a id="chp-9.html._251" class="calibre7 pcalibre"></a>安全的获得一个文件的大小</h2>
<p class="calibre9">即使 System.Directory 不允许我们获得一个文件的大小，我们仍可以使用 <a href="http://System.IO" target="_blank" class="calibre7 pcalibre">System.IO</a> 的类似接口完成这项任务，它包含了一个名为 hFileSize 的函数，这一函数返回打开文件的字节数，下面是他的简单调用实例：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>BetterPredicate<span class="token">.</span>hs
simpleFileSize <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO Integer

simpleFileSize path <span class="token3">=</span> <span class="token1">do</span>
  h <span class="token3">&lt;</span><span class="token3">-</span> openFile path ReadMode
  size <span class="token3">&lt;</span><span class="token3">-</span> hFileSize h
  hClose h
  <span class="token1">return</span> size

</code></pre>
<p class="calibre9">当这个函数工作时，他还不能完全为我们所用，在 betterFind 中，我们在目录下的任何实体上调用 getFileSize ，如果实体不是一个文件或者大小被 Just 包装起来，他应当返回一个空值，而当实体不是文件或者没有被打开时（可能是由于权限不够），这个函数会抛出一个异常然后返回一个未包装的大小。</p>
<p class="calibre9">下文是安全的用法：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>BetterPredicate<span class="token">.</span>hs
saferFileSize <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span>Maybe Integer<span class="token">)</span>

saferFileSize path <span class="token3">=</span> handle <span class="token">(</span>\_ <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> Nothing<span class="token">)</span> $ <span class="token1">do</span>
  h <span class="token3">&lt;</span><span class="token3">-</span> openFile path ReadMode
  size <span class="token3">&lt;</span><span class="token3">-</span> hFileSize h
  hClose h
  <span class="token1">return</span> <span class="token">(</span>Just size<span class="token">)</span>

</code></pre>
<p class="calibre9">函数体几乎完全一致，除了 handle 语句。</p>
<p class="calibre9">我们的异常捕捉在忽略通过的异常的同时返回一个空值，函数体唯一的变化就是允许通过 Just 包装文件大小</p>
<p class="calibre9">saferFileSize 函数现在有正确的类型签名，并且不会抛出任何异常，但他扔未能完全的正常工作，存在 openFile 会成功的目录实体，但 hFileSize 会抛出异常，这将和被称作命名管道的状况一起发生，这样的异常会被捕捉，但却从未发起调用 hClose 。</p>
<p class="calibre9">当发现不再使用文件句柄，Haskell会自动关闭它，但这只有在运行垃圾回收时才会执行，如果无法断言，则延迟到下一次垃圾回收。</p>
<p class="calibre9">文件句柄是稀缺资源，稀缺性是通过操作系统强制保证的，在linux中，一个进程只能同时拥有1024个文件句柄。</p>
<p class="calibre9">不难想象这种场景，程序调用了一个使用 saferFileSize 的 betterFind 函数，在足够的垃圾文件句柄被关闭之前，由于 betterFind 造成文件句柄数耗尽导致了程序崩溃</p>
<p class="calibre9">这是bug危害性的一方面：通过合并起来的不同的部分使得bug不易被排查，只有在 betterFind 访问足够多的非文件达到进程打开文件句柄数上限的时候才会被触发，随后在积累的垃圾文件句柄被关闭之前返回一个尝试打开另一个文件的调用。</p>
<p class="calibre9">任何程序内由无法获得数据造成的后续错误都会让事情变得更糟，直到垃圾回收为止。修正这样一个bug需要程序结构本身支持，文件系统内容，如何关闭当前正在运行的程序以触发垃圾回收</p>
<p class="calibre9">这种问题在开发中很容易被检查出来，然而当他在上线之后出现（这些恶心的问题一向如此），就变得非常难以发觉</p>
<p class="calibre9">幸运的是，我们可以很容易避开这种错误，同时又能缩短我们的函数。</p>
<h2 class="calibre14"><a id="chp-9.html._303" class="calibre7 pcalibre"></a>请求-使用-释放循环</h2>
<p class="calibre9">每当 openFile 成功之后我们就必须保证调用 hClose ， Control.Exception 模块提供了 bracket 函数来支持这个想法：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type bracket
bracket <span class="token">:</span><span class="token">:</span> IO a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> IO b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> IO c<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> IO c

</code></pre>
<p class="calibre9">bracket 函数需要三个动作作为参数，第一个动作需要一个资源，第二个动作释放这个资源，第三个动作在这两个中执行，当资源被请求，我们称他为操作动作，当请求动作成功，释放动作随后总是被调用，这保证了这个资源一直能够被释放，对通过的每个请求资源文件的操作，使用和释放动作都是必要的。</p>
<p class="calibre9">如果一个异常发生在使用过程中， bracket 调用释放动作并抛出异常，如果使用动作成功， bracket 调用释放动作，同时返回使用动作返回的值。</p>
<p class="calibre9">我们现在可以写一个完全安全的函数了，他将不会抛出异常，也不会积累可能在我们程序其他地方制造失败的垃圾文件句柄数。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>BetterPredicate<span class="token">.</span>hs
getFileSize path <span class="token3">=</span> handle <span class="token">(</span>\_ <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> Nothing<span class="token">)</span> $
  bracket <span class="token">(</span>openFile path ReadMode<span class="token">)</span> hClose $ \h <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">do</span>
    size <span class="token3">&lt;</span><span class="token3">-</span> hFileSize h
    <span class="token1">return</span> <span class="token">(</span>Just size<span class="token">)</span>

</code></pre>
<p class="calibre9">仔细观察 bracket 的参数，首先打开文件，并且返回文件句柄，第二步关闭句柄，第三步在句柄上调用 hFileSize 并用 just 包装结果返回</p>
<p class="calibre9">为了这个函数的正常工作，我们需要使用 bracket 和 handle ，前者保证我们不会积累垃圾文件句柄数，后者保证我们免于异常。</p>
<h4 class="calibre19"><a id="chp-9.html._332" class="calibre7 pcalibre"></a>练习</h4>
<ol class="calibre17"><li class="calibre11">调用 bracket 和 handle 的顺序重要吗，为什么</li></ol>
<h2 class="calibre14"><a id="chp-9.html._336" class="calibre7 pcalibre"></a>为谓词而开发的领域特定语言</h2>
<p class="calibre9">深入谓词写作的内部，我们的谓词将检查大于128kb的C++源文件：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>BetterPredicate<span class="token">.</span>hs
myTest path _ <span class="token">(</span>Just size<span class="token">)</span> _ <span class="token3">=</span>
    takeExtension path <span class="token3">==</span> <span class="token4">".cpp"</span> <span class="token3">&amp;&amp;</span> size <span class="token3">&gt;</span> <span class="token2">131072</span>
myTest _ _ _ _ <span class="token3">=</span> False

</code></pre>
<p class="calibre9">这并不是令人感到愉快的工作，断言需要四个参数，并且总是忽略其中的两个，同时需要定义两个等式，写一些更有意义的谓词代码，我们可以做的更好。</p>
<p class="calibre9">有些时候，这种库被用作嵌入式领域特定语言，我们通过编写代码的过程中通过编程语言的本地特性来优雅的解决一些特定问题</p>
<p class="calibre9">第一步是写一个返回当前函数的一个参数的函数，这个从参数中抽取路径并传给谓词：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>BetterPredicate<span class="token">.</span>hs
pathP path _ _ _ <span class="token3">=</span> path

</code></pre>
<p class="calibre9">如果我们不能提供类型签名， Haskell 将给这个函数提供一个通用类型，这在随后会导致一个难以理解的错误信息，因此给 pathP 一个类型：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>BetterPredicate<span class="token">.</span>hs
type InfoP a <span class="token3">=</span>  FilePath        <span class="token3">--</span> path to directory entry
             <span class="token3">-</span><span class="token3">&gt;</span> Permissions     <span class="token3">--</span> permissions
             <span class="token3">-</span><span class="token3">&gt;</span> Maybe Integer   <span class="token3">--</span> file size <span class="token">(</span>Nothing <span class="token1">if</span> not file<span class="token">)</span>
             <span class="token3">-</span><span class="token3">&gt;</span> ClockTime       <span class="token3">--</span> last modified
             <span class="token3">-</span><span class="token3">&gt;</span> a

pathP <span class="token">:</span><span class="token">:</span> InfoP FilePath

</code></pre>
<p class="calibre9">我们已经创建了一个可以用做缩写的类型，相似的结构函数，我们的类型代词接受一个类型参数，如此我们可以分辨不同的结果类型：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>BetterPredicate<span class="token">.</span>hs
sizeP <span class="token">:</span><span class="token">:</span> InfoP Integer
sizeP _ _ <span class="token">(</span>Just size<span class="token">)</span> _ <span class="token3">=</span> size
sizeP _ _ Nothing     _ <span class="token3">=</span> <span class="token3">-</span><span class="token2">1</span>

</code></pre>
<p class="calibre9">我们在这里做了些小动作，对那些我们无法打开的文件或者不是文件的东西我们返回的实体大小是 -1 。</p>
<p class="calibre9">事实上，浏览中可以看出我们在本章开始处定义谓词类型的和 InfoPBool 一样，因此我们可以合法的放弃谓词类型。</p>
<p class="calibre9">pathP 和 sizeP 的用法？通过一些线索，我们发现可以在一个谓词中使用它们（每个名称中的前缀p代表断言），从这开始事情就变得有趣起来：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>BetterPredicate<span class="token">.</span>hs
equalP <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Eq a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> InfoP a <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> InfoP Bool
equalP f k <span class="token3">=</span> \w x y z <span class="token3">-</span><span class="token3">&gt;</span> f w x y z <span class="token3">==</span> k

</code></pre>
<p class="calibre9">equalP 的类型签名值得注意，他接受一个 InfoPa ，同时兼容 pathP 和 sizeP ，他接受一个 a ，并返回一个被认为是谓词同义词的 InfoPBool ，换言之， equalP 构造了一个谓词。</p>
<p class="calibre9">equalP 函数通过返回一个匿名函数工作，谓词接受参数之后将他们转成 f ，并将结果和 f 进行比对。</p>
<p class="calibre9">equalP 的相等强调了这一事实，我们认为它需要两个参数，在 Haskell 柯里化处理了所有函数的情况下，通过这种方式写 equalP 并无必要，我们可以避免匿名函数，同时通过柯里化来写出表现相同的函数：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>BetterPredicate<span class="token">.</span>hs
equalP' <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Eq a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> InfoP a <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> InfoP Bool
equalP' f k w x y z <span class="token3">=</span> f w x y z <span class="token3">==</span> k

</code></pre>
<p class="calibre9">在继续我们的探险之前，先把写好的模块加载到 ghci 里去：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>load BetterPredicate
<span class="token">[</span><span class="token2">1</span> of <span class="token2">2</span><span class="token">]</span> Compiling RecursiveContents <span class="token">(</span> RecursiveContents<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
<span class="token">[</span><span class="token2">2</span> of <span class="token2">2</span><span class="token">]</span> Compiling Main             <span class="token">(</span> BetterPredicate<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> RecursiveContents<span class="token">,</span> Main<span class="token">.</span>

</code></pre>
<p class="calibre9">让我们来看看函数中的简单谓词能否正常工作：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type betterFind <span class="token">(</span>sizeP `equalP` <span class="token2">1024</span><span class="token">)</span>
betterFind <span class="token">(</span>sizeP `equalP` <span class="token2">1024</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">[</span>FilePath<span class="token">]</span>

</code></pre>
<p class="calibre9">注意我们并没有直接调用 betterFind ，我们只是确定我们的表达式进行了类型检查，现在我们需要更多的方法来列出大小为特定值的所有文件，之前的成功给了我们继续下去的勇气。</p>
<h2 class="calibre14"><a id="chp-9.html.lifting_430" class="calibre7 pcalibre"></a>多用提升（lifting）少用模板</h2>
<p class="calibre9">除了 equalP ，我们还将能够编写其他二进制函数，我们更希望不去写他们每个的具体实现，因为这看起来只是重复工作：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>BetterPredicate<span class="token">.</span>hs
liftP <span class="token">:</span><span class="token">:</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> b <span class="token3">-</span><span class="token3">&gt;</span> c<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> InfoP a <span class="token3">-</span><span class="token3">&gt;</span> b <span class="token3">-</span><span class="token3">&gt;</span> InfoP c
liftP q f k w x y z <span class="token3">=</span> f w x y z `q` k

greaterP<span class="token">,</span> lesserP <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Ord a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> InfoP a <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> InfoP Bool
greaterP <span class="token3">=</span> liftP <span class="token">(</span><span class="token3">&gt;</span><span class="token">)</span>
lesserP <span class="token3">=</span> liftP <span class="token">(</span><span class="token3">&lt;</span><span class="token">)</span>

</code></pre>
<p class="calibre9">为了完成这个，让我们使用 Haskell 的抽象功能，定义 equalP 代替直接调用 == ，我们就可以把二进制函数作为参数传入我们想调用的函数。</p>
<p class="calibre9">函数动作，比如 &gt; ，以及将它转换成另一个函数操作另一种上下文，在这里是 greaterP ，通过提升（lifting）将它引入到上下文，这解释了当前函数名称中lifting出现的原因，提升让我们复用代码并降低模板的使用，在本书的后半部分的内容中，我们将大量使用这一技术</p>
<p class="calibre9">当我们提升一个函数，我们通常将它转换到原始类型和一个新版本——提升和未提升两个版本</p>
<p class="calibre9">在这里，将 q 作为 liftP 的第一个参数是经过深思熟虑的，这使得我们可能写一个对 greaterP 和 lesserP 都有意义的定义，实践中发现，相较其他语言，Haskell 中参数的最佳适配成为api设计中最重要的一部分。语言内部要求参数转换，在Haskell中放错一个参数的位置就将失去程序的所有意义。</p>
<p class="calibre9">我们可以通过组合字（combinators）恢复一些意义，比如，直到2007年 forM 才加入 Control.Monad 模块，在此之前，人们用的是 flipmapM 。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>m <span class="token3">+</span>Control<span class="token">.</span>Monad
ghci<span class="token3">&gt;</span> <span class="token">:</span>t mapM
mapM <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Monad m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> m b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> m <span class="token">[</span>b<span class="token">]</span>
ghci<span class="token3">&gt;</span> <span class="token">:</span>t forM
forM <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Monad m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> m b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> m <span class="token">[</span>b<span class="token">]</span>
ghci<span class="token3">&gt;</span> <span class="token">:</span>t flip mapM
flip mapM <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Monad m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> m b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> m <span class="token">[</span>b<span class="token">]</span>

</code></pre>
<h2 class="calibre14"><a id="chp-9.html._466" class="calibre7 pcalibre"></a>谓词组合</h2>
<p class="calibre9">如果我们希望组合谓词，我们可以循着手边最明显的路径来开始</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>BetterPredicate<span class="token">.</span>hs
simpleAndP <span class="token">:</span><span class="token">:</span> InfoP Bool <span class="token3">-</span><span class="token3">&gt;</span> InfoP Bool <span class="token3">-</span><span class="token3">&gt;</span> InfoP Bool
simpleAndP f g w x y z <span class="token3">=</span> f w x y z <span class="token3">&amp;&amp;</span> g w x y z

</code></pre>
<p class="calibre9">现在我们知道了提升，他成为通过提升存在的布尔操作来削减代码量的更自然的选择。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>BetterPredicate<span class="token">.</span>hs
liftP2 <span class="token">:</span><span class="token">:</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> b <span class="token3">-</span><span class="token3">&gt;</span> c<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> InfoP a <span class="token3">-</span><span class="token3">&gt;</span> InfoP b <span class="token3">-</span><span class="token3">&gt;</span> InfoP c
liftP2 q f g w x y z <span class="token3">=</span> f w x y z `q` g w x y z

andP <span class="token3">=</span> liftP2 <span class="token">(</span><span class="token3">&amp;&amp;</span><span class="token">)</span>
orP <span class="token3">=</span> liftP2 <span class="token">(</span><span class="token3">||</span><span class="token">)</span>

</code></pre>
<p class="calibre9">注意 liftP2 非常像我们之前的 liftP ，事实上，这更加通用，因为我们可以用 liftP 代替 liftP2 ：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>BetterPredicate<span class="token">.</span>hs
constP <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> InfoP a
constP k _ _ _ _ <span class="token3">=</span> k

liftP' q f k w x y z <span class="token3">=</span> f w x y z `q` constP k w x y z

</code></pre>
<p class="calibre9">Note</p>
<p class="calibre9">组合子</p>
<p class="calibre9">在Haskell中，我们更希望函数的传入参数和返回值都是函数，就像组合子一样</p>
<p class="calibre9">回到之前定义的 myTest 函数，现在我们可以使用一些帮助函数了。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>BetterPredicate<span class="token">.</span>hs
myTest path _ <span class="token">(</span>Just size<span class="token">)</span> _ <span class="token3">=</span>
    takeExtension path <span class="token3">==</span> <span class="token4">".cpp"</span> <span class="token3">&amp;&amp;</span> size <span class="token3">&gt;</span> <span class="token2">131072</span>
myTest _ _ _ _ <span class="token3">=</span> False

</code></pre>
<p class="calibre9">在加入组合字以后这个函数会变成什么样子：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>BetterPredicate<span class="token">.</span>hs
liftPath <span class="token">:</span><span class="token">:</span> <span class="token">(</span>FilePath <span class="token3">-</span><span class="token3">&gt;</span> a<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> InfoP a
liftPath f w _ _ _ <span class="token3">=</span> f w

myTest2 <span class="token3">=</span> <span class="token">(</span>liftPath takeExtension `equalP` <span class="token4">".cpp"</span><span class="token">)</span> `andP`
          <span class="token">(</span>sizeP `greaterP` <span class="token2">131072</span><span class="token">)</span>

</code></pre>
<p class="calibre9">由于操作文件名是如此平常的行为，我们加入了最终组合字 liftPath 。</p>
<h2 class="calibre14"><a id="chp-9.html._530" class="calibre7 pcalibre"></a>定义并使用新算符</h2>
<p class="calibre9">可以通过特定领域语言定义新的操作：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>BetterPredicate<span class="token">.</span>hs
<span class="token">(</span><span class="token3">==</span><span class="token3">?</span><span class="token">)</span> <span class="token3">=</span> equalP
<span class="token">(</span><span class="token3">&amp;&amp;</span><span class="token3">?</span><span class="token">)</span> <span class="token3">=</span> andP
<span class="token">(</span><span class="token3">&gt;</span><span class="token3">?</span><span class="token">)</span> <span class="token3">=</span> greaterP

myTest3 <span class="token3">=</span> <span class="token">(</span>liftPath takeExtension <span class="token3">==</span><span class="token3">?</span> <span class="token4">".cpp"</span><span class="token">)</span> <span class="token3">&amp;&amp;</span><span class="token3">?</span> <span class="token">(</span>sizeP <span class="token3">&gt;</span><span class="token3">?</span> <span class="token2">131072</span><span class="token">)</span>

</code></pre>
<p class="calibre9">这个括号在定义中是必要的，因为并未告诉Haskell有关之前和相关的操作，领域语言的操作如果没有边界（fixities）声明将会被以 infixl9 之类的东西对待，计算从左到右，如果跳过这个括号，表达式将被解析成具有可怕错误的 (((liftPathtakeExtension)==?".cpp")&amp;&amp;?sizeP)&gt;?131072 。</p>
<p class="calibre9">可以给操作添加边界声明，第一步是找出未提升的操作的，这样就可以模仿他们了：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>info <span class="token3">==</span>
class <span class="token5">Eq</span> a where
  <span class="token">(</span><span class="token3">==</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> Bool
  <span class="token">.</span><span class="token">.</span><span class="token">.</span>
      <span class="token3">--</span> Defined <span class="token1">in</span> GHC<span class="token">.</span>Base
infix <span class="token2">4</span> <span class="token3">==</span>
ghci<span class="token3">&gt;</span> <span class="token">:</span>info <span class="token3">&amp;&amp;</span>
<span class="token">(</span><span class="token3">&amp;&amp;</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> Bool <span class="token3">-</span><span class="token3">&gt;</span> Bool <span class="token3">-</span><span class="token3">&gt;</span> Bool        <span class="token3">--</span> Defined <span class="token1">in</span> GHC<span class="token">.</span>Base
infixr <span class="token2">3</span> <span class="token3">&amp;&amp;</span>
ghci<span class="token3">&gt;</span> <span class="token">:</span>info <span class="token3">&gt;</span>
class <span class="token">(</span>Eq a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> Ord a where
  <span class="token">.</span><span class="token">.</span><span class="token">.</span>
  <span class="token">(</span><span class="token3">&gt;</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> Bool
  <span class="token">.</span><span class="token">.</span><span class="token">.</span>
    <span class="token3">--</span> Defined <span class="token1">in</span> GHC<span class="token">.</span>Base
infix <span class="token2">4</span> <span class="token3">&gt;</span>

</code></pre>
<p class="calibre9">学会这些就可以写一个不用括号的表达式，却和 myTest3 的解析结果一致的表达式了</p>
<h2 class="calibre14"><a id="chp-9.html._570" class="calibre7 pcalibre"></a>控制遍历</h2>
<p class="calibre9">遍历文件系统时，我们喜欢在需要遍历的文件夹上有更多的控制权，简便方法之一是可以在函数中允许给定文件夹的部分子文件夹通过，然后返回另一个列表，这个列表可以移除元素，也可以要求和原始列表不同，或两者皆有，最简单的控制函数就是id，原样返回未修改的列表。</p>
<p class="calibre9">为了应付多种情况，我们正在尝试改变部分表达，为了替代精心刻画的函数类型 InfoP ，我们将使用一个普通代数数据类型来表达相同的含义</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>ControlledVisit<span class="token">.</span>hs
data Info <span class="token3">=</span> Info <span class="token">{</span>
      infoPath <span class="token">:</span><span class="token">:</span> FilePath
    <span class="token">,</span> infoPerms <span class="token">:</span><span class="token">:</span> Maybe Permissions
    <span class="token">,</span> infoSize <span class="token">:</span><span class="token">:</span> Maybe Integer
    <span class="token">,</span> infoModTime <span class="token">:</span><span class="token">:</span> Maybe ClockTime
    <span class="token">}</span> deriving <span class="token">(</span>Eq<span class="token">,</span> Ord<span class="token">,</span> Show<span class="token">)</span>

getInfo <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO Info

</code></pre>
<p class="calibre9">记录语法给我们自由控制函数的权限，如 infoPath ， traverse 函数中的这种类型是简单地，正如我们之前期望的那样，如果需要一个文件或者目录的信息，就调用 getInfo 函数：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>ControlledVisit<span class="token">.</span>hs
traverse <span class="token">:</span><span class="token">:</span> <span class="token">(</span><span class="token">[</span>Info<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>Info<span class="token">]</span><span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">[</span>Info<span class="token">]</span>

</code></pre>
<p class="calibre9">traverse 的定义很短，但很有分量：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>ControlledVisit<span class="token">.</span>hs
traverse order path <span class="token3">=</span> <span class="token1">do</span>
    names <span class="token3">&lt;</span><span class="token3">-</span> getUsefulContents path
    contents <span class="token3">&lt;</span><span class="token3">-</span> mapM getInfo <span class="token">(</span>path <span class="token">:</span> map <span class="token">(</span>path <span class="token3">&lt;</span><span class="token3">/</span><span class="token3">&gt;</span><span class="token">)</span> names<span class="token">)</span>
    liftM concat $ forM <span class="token">(</span>order contents<span class="token">)</span> $ \info <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">do</span>
      <span class="token1">if</span> isDirectory info <span class="token3">&amp;&amp;</span> infoPath info <span class="token3">/</span><span class="token3">=</span> path
        then traverse order <span class="token">(</span>infoPath info<span class="token">)</span>
        <span class="token1">else</span> <span class="token1">return</span> <span class="token">[</span>info<span class="token">]</span>

getUsefulContents <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">[</span>String<span class="token">]</span>
getUsefulContents path <span class="token3">=</span> <span class="token1">do</span>
    names <span class="token3">&lt;</span><span class="token3">-</span> getDirectoryContents path
    <span class="token1">return</span> <span class="token">(</span>filter <span class="token">(</span>`notElem` <span class="token">[</span><span class="token4">"."</span><span class="token">,</span> <span class="token4">".."</span><span class="token">]</span><span class="token">)</span> names<span class="token">)</span>

isDirectory <span class="token">:</span><span class="token">:</span> Info <span class="token3">-</span><span class="token3">&gt;</span> Bool
isDirectory <span class="token3">=</span> maybe False searchable <span class="token">.</span> infoPerms

</code></pre>
<p class="calibre9">现在不再引入新技术，这就是我们遇到的最深奥的函数定义，一行行的深入他，解释它每行为何是这样，不过开始部分的那几行没什么神秘的，它们只是之前看到代码的拷贝。</p>
<p class="calibre9">观察变量 contents 的时候情况变得有趣起来，从左到右仔细阅读，已经知道 names 是目录实体的列表，同时确定当前目录的所有元素都在这个列表中，这时通过 mapM 将 getInfo 附加到结果返回的路径上。</p>
<p class="calibre9">接下来的这一行更深奥，继续从左往右看，我们看到本行的最后一个元素以一个匿名函数的定义开始，并持续到这一段的结尾，给定一个Info值，函数或者递归访问一个目录（有额外的方法保证我们不在访问这个路径），或者返回当前值作为列表唯一元素的列表（来匹配递归的返回类型）。</p>
<p class="calibre9">函数通过 forM 获得 order 返回 info 列表中的每个元素， forM 是使用者提供的递归控制函数。</p>
<p class="calibre9">本行的新上下文中使用提升技术， liftM 函数需要一个规则函数， concat ，并且提升到 IO 的monad操作，换言之，他需要 forM 通过 IO monad 操作的的返回值，并将 concat 附加其上（获得一个 [Info] 类型的返回值，这也是我们所需要的）并将结果值返回给 IO monad 。</p>
<p class="calibre9">最后不要忘记定义 getInfo 函数：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>ControlledVisit<span class="token">.</span>hs
maybeIO <span class="token">:</span><span class="token">:</span> IO a <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span>Maybe a<span class="token">)</span>
maybeIO act <span class="token3">=</span> handle <span class="token">(</span>\_ <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> Nothing<span class="token">)</span> <span class="token">(</span>Just `liftM` act<span class="token">)</span>

getInfo path <span class="token3">=</span> <span class="token1">do</span>
  perms <span class="token3">&lt;</span><span class="token3">-</span> maybeIO <span class="token">(</span>getPermissions path<span class="token">)</span>
  size <span class="token3">&lt;</span><span class="token3">-</span> maybeIO <span class="token">(</span>bracket <span class="token">(</span>openFile path ReadMode<span class="token">)</span> hClose hFileSize<span class="token">)</span>
  modified <span class="token3">&lt;</span><span class="token3">-</span> maybeIO <span class="token">(</span>getModificationTime path<span class="token">)</span>
  <span class="token1">return</span> <span class="token">(</span>Info path perms size modified<span class="token">)</span>

</code></pre>
<p class="calibre9">在此唯一值得记录的事情是一个有用的组合字， maybeIO ，将一个可能抛出异常的 IO 操作转换成用 Maybe 包装的结果</p>
<h2 class="calibre14"><a id="chp-9.html._646" class="calibre7 pcalibre"></a>练习</h2>
<ol class="calibre17"><li class="calibre11">在以代数顺序遍历一个目录树时如何确定需要通过的内容。</li><li class="calibre11">使用 id 作为控制函数， traverseid 扮演一个前序递归树，在子目录之前他返回一个父目录，写一个控制函数让 traverse 表现为一个后序遍历，返回子目录在父目录之前。</li><li class="calibre11">使得《谓词组合》一节里面的断言和组合字可以处理新的 info 类型。</li><li class="calibre11">给 traverse 写一个包装器，让你通过谓词控制递归，并通过谓词过滤返回结果</li></ol>
<h2 class="calibre14"><a id="chp-9.html._653" class="calibre7 pcalibre"></a>代码深度，可读性和学习过程</h2>
<p class="calibre9">traverse 这样深度的代码在Haskell中并不多见，在这种表达方式中里学习的收获是巨大的，同时也并不需要大量的练习才能以这种方式流利的阅读和写作代码：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>ControlledVisit<span class="token">.</span>hs
traverseVerbose order path <span class="token3">=</span> <span class="token1">do</span>
    names <span class="token3">&lt;</span><span class="token3">-</span> getDirectoryContents path
    let usefulNames <span class="token3">=</span> filter <span class="token">(</span>`notElem` <span class="token">[</span><span class="token4">"."</span><span class="token">,</span> <span class="token4">".."</span><span class="token">]</span><span class="token">)</span> names
    contents <span class="token3">&lt;</span><span class="token3">-</span> mapM getEntryName <span class="token">(</span><span class="token4">""</span> <span class="token">:</span> usefulNames<span class="token">)</span>
    recursiveContents <span class="token3">&lt;</span><span class="token3">-</span> mapM recurse <span class="token">(</span>order contents<span class="token">)</span>
    <span class="token1">return</span> <span class="token">(</span>concat recursiveContents<span class="token">)</span>
  where getEntryName name <span class="token3">=</span> getInfo <span class="token">(</span>path <span class="token3">&lt;</span><span class="token3">/</span><span class="token3">&gt;</span> name<span class="token">)</span>
        isDirectory info <span class="token3">=</span> case infoPerms info of
                             Nothing <span class="token3">-</span><span class="token3">&gt;</span> False
                             Just perms <span class="token3">-</span><span class="token3">&gt;</span> searchable perms
        recurse info <span class="token3">=</span> <span class="token1">do</span>
            <span class="token1">if</span> isDirectory info <span class="token3">&amp;&amp;</span> infoPath info <span class="token3">/</span><span class="token3">=</span> path
                then traverseVerbose order <span class="token">(</span>infoPath info<span class="token">)</span>
                <span class="token1">else</span> <span class="token1">return</span> <span class="token">[</span>info<span class="token">]</span>

</code></pre>
<p class="calibre9">作为对比，这里有一个不那么复杂的代码，这也许适合一个对Haskell了解不那么深入的程序员</p>
<p class="calibre9">这里所做的一切都是创建一个新的替代，通过部分应用（partial application）和函数组合（function composition）替代liberally，在 where 块中我们已经定义了一些本地函数，在 maybe 组合子中，使用了 case 表达式，为了替代 liftM ，我们手动将 concat 提升。</p>
<p class="calibre9">并不是说深度是一个不好的特征， traverse 函数的每一行原始代码都很短，我们引入一个本地变量和本地函数来保证代码干净且足够短，命名注意可读性，同时使用函数组合管道，最长的管道只含有三个元素。</p>
<p class="calibre9">编写可维护的Haskell代码核心是找到深度和可读性的折中，能否做到这点取决于你的实践层次：</p>
<ul class="calibre10"><li class="calibre11">成为Haskell程序员之前，Andrew并不知道使用标准库的方式，为此付出的代价则是写了一大堆不必要的重复代码。</li><li class="calibre11">Zack是一个有数月编程经验的，并且精通通过( . )组合长管道的技巧。每当代码需要改动，就需要重构一个管道，他无法更深入的理解已经存在的管道的意义，而这些管道也太脆弱而无法修正。</li><li class="calibre11">Monica有相当时间的编程经验，他对Haskell库和编写整洁的代码非常熟悉，但他避免使用高深度的风格，她的代码可维护，同时她还找到了一种简单地方法来面对快速的需求变更</li></ul>
<h2 class="calibre14"><a id="chp-9.html._688" class="calibre7 pcalibre"></a>观察迭代函数的另一种方法</h2>
<p class="calibre9">相比原始的 betterFind 函数，迭代函数给我们更多控制权的同时仍存在一个问题，我们可以避免递归目录，但我们不能过滤其他文件名直到我们获得整个名称树，如果递归含有100000个文件的目录的同时只关注其中三个，在获得这三个需要的文件名之前需要给出一个含有10000个元素的表。</p>
<p class="calibre9">一个可能的方法是提供一个过滤器作为递归的新参数，我们将它应用到生成的名单中，这将允许我们获得一个只包含我们需要元素的列表</p>
<p class="calibre9">然而，这个方法也存在缺点，假如说我们知道需要比三个多很多的实体组，并且这些实体组是这10000个我们需要遍历实体中的前几个，这种情况下就不需要访问剩下的实体，这并不是个故弄玄虚的问题，举个栗子，邮箱文件夹中存放了包含许多邮件信息的文件夹——就像一个有大量文件的目录，那么代表邮箱的目录含有数千个文件就很正常。</p>
<p class="calibre9">从另一个角度看，我们尝试定位之前两个遍历函数的弱点：我们如何看待文件系统遍历阶级目录下的一个文件夹？</p>
<p class="calibre9">相似的文件夹， foldr 和 foldl' ，干净的生成遍历并计算出一个结果，很难把这个想法从列表扩展到目录树，但我们仍乐于在 fold 中加入一个控制元素，我们将这个控制表达为一个代数数据类型：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>FoldDir<span class="token">.</span>hs
data Iterate seed <span class="token3">=</span> Done     <span class="token">{</span> unwrap <span class="token">:</span><span class="token">:</span> seed <span class="token">}</span>
                  <span class="token3">|</span> Skip     <span class="token">{</span> unwrap <span class="token">:</span><span class="token">:</span> seed <span class="token">}</span>
                  <span class="token3">|</span> Continue <span class="token">{</span> unwrap <span class="token">:</span><span class="token">:</span> seed <span class="token">}</span>
                    deriving <span class="token">(</span>Show<span class="token">)</span>

type Iterator seed <span class="token3">=</span> seed <span class="token3">-</span><span class="token3">&gt;</span> Info <span class="token3">-</span><span class="token3">&gt;</span> Iterate seed

</code></pre>
<p class="calibre9">Iterator 类型给函数一个便于使用的别名，它需要一个种子和一个 info 值来表达这个目录实体，并返回一个新种子和一个我们 fold 函数的说明，这个说明通过 Iterate 类型的构造器来表达：</p>
<ul class="calibre10"><li class="calibre11">如果这个构造器已经完成，遍历将立即释放，被 Done 包裹的值将作为结果返回。</li><li class="calibre11">如果这个说明被跳过，并且当前 info 代表一个目录，遍历将不在递归寻找这个目录。</li><li class="calibre11">其他，这个便利仍将继续，使用包裹值作为下一个调用 fold 函数的参数。</li></ul>
<p class="calibre9">目录逻辑上是左序的，因为我们开始从我们第一个遇到的实体开始 fold 操作，而每步中的种子是之前一步的结果。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>FoldDir<span class="token">.</span>hs
foldTree <span class="token">:</span><span class="token">:</span> Iterator a <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO a

foldTree iter initSeed path <span class="token3">=</span> <span class="token1">do</span>
    endSeed <span class="token3">&lt;</span><span class="token3">-</span> fold initSeed path
    <span class="token1">return</span> <span class="token">(</span>unwrap endSeed<span class="token">)</span>
  where
    fold seed subpath <span class="token3">=</span> getUsefulContents subpath <span class="token3">&gt;</span><span class="token3">&gt;=</span> walk seed

    walk seed <span class="token">(</span>name<span class="token">:</span>names<span class="token">)</span> <span class="token3">=</span> <span class="token1">do</span>
      let path' <span class="token3">=</span> path <span class="token3">&lt;</span><span class="token3">/</span><span class="token3">&gt;</span> name
      info <span class="token3">&lt;</span><span class="token3">-</span> getInfo path'
      case iter seed info of
        done@<span class="token">(</span>Done _<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> done
        Skip seed<span class="token4">'    -&gt; walk seed'</span> names
        Continue seed'
          <span class="token3">|</span> isDirectory info <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">do</span>
              next <span class="token3">&lt;</span><span class="token3">-</span> fold seed<span class="token4">' path'</span>
              case next of
                done@<span class="token">(</span>Done _<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> done
                seed<span class="token4">''</span>        <span class="token3">-</span><span class="token3">&gt;</span> walk <span class="token">(</span>unwrap seed<span class="token4">''</span><span class="token">)</span> names
          <span class="token3">|</span> otherwise <span class="token3">-</span><span class="token3">&gt;</span> walk seed' names
    walk seed _ <span class="token3">=</span> <span class="token1">return</span> <span class="token">(</span>Continue seed<span class="token">)</span>

</code></pre>
<p class="calibre9">这部分代码中有意思的部分很少，开始是通过 scoping 避免通过额外的参数，最高层 foldTree 函数只是 fold 的包装器，用来揭开 fold 的最后结果的生成器。</p>
<p class="calibre9">由于 fold 是本地函数，我们不需要通过 foldTree 的 iter 变量来进入他，可以从外部进入，相似的， walk 也可以在外部看到 path 。</p>
<p class="calibre9">另一个需要指出的点是 walk 是一个尾递归，在我们最初的函数中用来替代一个匿名函数调用。通过外部控制，可以在任何需要的时候停止，这使得当 iterator 返回 Done 的时候就可以退出。</p>
<p class="calibre9">即使 fold 调用 walk ， walk 调用 fold 这样的递归来遍历子目录，每个函数返回一个用 Iterate 包装起来的种子，当 fold 被调用，并且返回， walk 检查返回并观察需要继续还是退出，通过这种方式，一个 Done 的返回直接终止两个函数中的所有递归调用。</p>
<p class="calibre9">实践中一个 iterator 像什么，下面是一个观察三个位图文件（至多）的同时并不逆向递归元数据目录的复杂例子：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>FoldDir<span class="token">.</span>hs
atMostThreePictures <span class="token">:</span><span class="token">:</span> Iterator <span class="token">[</span>FilePath<span class="token">]</span>

atMostThreePictures paths info
    <span class="token3">|</span> length paths <span class="token3">==</span> <span class="token2">3</span>
      <span class="token3">=</span> Done paths
    <span class="token3">|</span> isDirectory info <span class="token3">&amp;&amp;</span> takeFileName path <span class="token3">==</span> <span class="token4">".svn"</span>
      <span class="token3">=</span> Skip paths
    <span class="token3">|</span> extension `elem` <span class="token">[</span><span class="token4">".jpg"</span><span class="token">,</span> <span class="token4">".png"</span><span class="token">]</span>
      <span class="token3">=</span> Continue <span class="token">(</span>path <span class="token">:</span> paths<span class="token">)</span>
    <span class="token3">|</span> otherwise
      <span class="token3">=</span> Continue paths
  where extension <span class="token3">=</span> map toLower <span class="token">(</span>takeExtension path<span class="token">)</span>
        path <span class="token3">=</span> infoPath info

</code></pre>
<p class="calibre9">为了使用这个需要调用 foldTreeatMostThreePictures[] ，它给我们一个 IO[FilePath] 类型的返回值。</p>
<p class="calibre9">当然， iterators 并不需要如此复杂，下面是个对目录进行计数的代码：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>FoldDir<span class="token">.</span>hs
countDirectories count info <span class="token3">=</span>
    Continue <span class="token">(</span><span class="token1">if</span> isDirectory info
              then count <span class="token3">+</span> <span class="token2">1</span>
              <span class="token1">else</span> count<span class="token">)</span>

</code></pre>
<p class="calibre9">传递给 foldTree 的初始种子（seed）为数字零。</p>
<h2 class="calibre14"><a id="chp-9.html._789" class="calibre7 pcalibre"></a>练习</h2>
<ol class="calibre17"><li class="calibre11">修正 foldTree 来允许调用改变遍历目录实体的顺序。</li><li class="calibre11">foldTree 函数展示了前序遍历，将它修正为允许调用方决定便利顺序。</li><li class="calibre11">写一个组合子的库允许 foldTree 接收不同类型的 iterators ，你能写出更简洁的 iterators 吗？</li></ol>
<h2 class="calibre14"><a id="chp-9.html._795" class="calibre7 pcalibre"></a>代码指南</h2>
<p class="calibre9">有许多好的Haskell程序员的习惯来自经验，我们有一些通用的经验给你，这样你可以更快的写出易于阅读的代码。</p>
<p class="calibre9">正如已经提到的，Haskell中永远使用空格，而不是tab 。</p>
<p class="calibre9">如果你发现代码里有个片段聪明到炸裂，停下来，然后思考下如果你离开代码一个月是否还能懂这段代码。</p>
<p class="calibre9">常规命名类型和变量一般是骆驼法，例如 myVariableName ，这种风格在Haskell中也同样流行，不要去想你的其他命名习惯，如果你遵循一个不标准的惯例，那么你的代码将会对其他人的眼睛造成折磨。</p>
<p class="calibre9">即使你已经用了Haskell一段时间，在你写小函数之前花费几分钟的时间查阅库函数，如果标准库并没有提供你需要的函数，你可能需要组合出一个新的函数来获得你想要的结果。</p>
<p class="calibre9">组合函数的长管道难以阅读，长意味着包含三个以上元素的序列，如果你有这样一个管道，使用 let 或者 where 语句块将它分解成若干个小部分，给每个管道元素一个有意义的名字，然后再将他们回填到代码，如果你想不出一个有意义的名字，问下自己 能不能解释这段代码的功能，如果不能，简化你的代码。</p>
<p class="calibre9">即使在编辑器中很容易格式化长于八十列的代码，宽度仍然是个重要问题，宽行在80行之外的内容通常会被截断，这非常伤害可读性，每一行不超过八十个字符，这样你就可以写入单独的一行，这帮助你保持每一行代码不那么复杂，从而更容易被人读懂。</p>
<h2 class="calibre14"><a id="chp-9.html._811" class="calibre7 pcalibre"></a>常用布局风格</h2>
<p class="calibre9">只要你的代码遵守布局规范，那么他并不会给人一团乱麻的感觉，因此也不会造成误解，也就是说，有些布局风格是常用的。</p>
<p class="calibre9">in 关键字通常正对着 let 关键字，如下所示：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>Style<span class="token">.</span>hs
tidyLet <span class="token3">=</span> let foo <span class="token3">=</span> undefinedwei's
              bar <span class="token3">=</span> foo <span class="token3">*</span> <span class="token2">2</span>
          <span class="token1">in</span> undefined

</code></pre>
<p class="calibre9">单独列出 in 或者让 in 在一系列等式之后跟着的写法都是正确的，但下面这种写法则会显得很奇怪：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>Style<span class="token">.</span>hs
weirdLet <span class="token3">=</span> let foo <span class="token3">=</span> undefined
               bar <span class="token3">=</span> foo <span class="token3">*</span> <span class="token2">2</span>
    <span class="token1">in</span> undefined

strangeLet <span class="token3">=</span> let foo <span class="token3">=</span> undefined
                 bar <span class="token3">=</span> foo <span class="token3">*</span> <span class="token2">2</span> <span class="token1">in</span>
    undefined

</code></pre>
<p class="calibre9">与此相反，让 do 在行尾跟着而非在行首单独列出：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>Style<span class="token">.</span>hs
commonDo <span class="token3">=</span> <span class="token1">do</span>
  something <span class="token3">&lt;</span><span class="token3">-</span> undefined
  <span class="token1">return</span> <span class="token">(</span><span class="token">)</span>

<span class="token3">--</span> not seen very often
rareDo <span class="token3">=</span>
  <span class="token1">do</span> something <span class="token3">&lt;</span><span class="token3">-</span> undefined
     <span class="token1">return</span> <span class="token">(</span><span class="token">)</span>

</code></pre>
<p class="calibre9">括号和分号即使合法也很少用到，他们的使用并不存在问题，只是让代码看起来奇怪，同时让Haskell写成的代码不必遵守排版规则。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>Style<span class="token">.</span>hs
unusualPunctuation <span class="token3">=</span>
    <span class="token">[</span> <span class="token">(</span>x<span class="token">,</span>y<span class="token">)</span> <span class="token3">|</span> x <span class="token3">&lt;</span><span class="token3">-</span> <span class="token">[</span><span class="token2">1.</span><span class="token">.</span>a<span class="token">]</span><span class="token">,</span> y <span class="token3">&lt;</span><span class="token3">-</span> <span class="token">[</span><span class="token2">1.</span><span class="token">.</span>b<span class="token">]</span> <span class="token">]</span> where <span class="token">{</span>
                                           b <span class="token3">=</span> <span class="token2">7</span><span class="token">;</span>
 a <span class="token3">=</span> <span class="token2">6</span> <span class="token">}</span>

preferredLayout <span class="token3">=</span> <span class="token">[</span> <span class="token">(</span>x<span class="token">,</span>y<span class="token">)</span> <span class="token3">|</span> x <span class="token3">&lt;</span><span class="token3">-</span> <span class="token">[</span><span class="token2">1.</span><span class="token">.</span>a<span class="token">]</span><span class="token">,</span> y <span class="token3">&lt;</span><span class="token3">-</span> <span class="token">[</span><span class="token2">1.</span><span class="token">.</span>b<span class="token">]</span> <span class="token">]</span>
    where b <span class="token3">=</span> <span class="token2">7</span>
          a <span class="token3">=</span> <span class="token2">6</span>

</code></pre>
<p class="calibre9">如果等式的右侧另起一行，通常在和他本行内，相关变量名或者函数定义的下方之前留出一些空格。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>Style<span class="token">.</span>hs
normalIndent <span class="token3">=</span>
    undefined

strangeIndent <span class="token3">=</span>
                           undefined

</code></pre>
<p class="calibre9">空格缩进的数量有多种选择，有时候在一个文件中，二，三，四格缩进都很正常，一个缩进也合法，但不常用，而且容易被误读。</p>
<p class="calibre9">写 where 语句的缩进时，最好让它分辨起来比较容易：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch09<span class="token3">/</span>Style<span class="token">.</span>hs
goodWhere <span class="token3">=</span> take <span class="token2">5</span> lambdas
    where lambdas <span class="token3">=</span> <span class="token">[</span><span class="token">]</span>

alsoGood <span class="token3">=</span>
    take <span class="token2">5</span> lambdas
  where
    lambdas <span class="token3">=</span> <span class="token">[</span><span class="token">]</span>

badWhere <span class="token3">=</span>           <span class="token3">--</span> legal<span class="token">,</span> but ugly and hard to read
    take <span class="token2">5</span> lambdas
    where
    lambdas <span class="token3">=</span> <span class="token">[</span><span class="token">]</span>

</code></pre>
<h2 class="calibre14"><a id="chp-9.html._902" class="calibre7 pcalibre"></a>练习</h2>
<p class="calibre9">即使本章内容指导你们完成文件查找代码，但这并不意味着真正的系统编程，因为haskell移植的 IO 库并不暴露足够的消息给我们写有趣和复杂的查询。</p>
<ol class="calibre18"><li class="calibre11">把本章代码移植到你使用平台的 api 上， System.Posix 或者 System.Win32 。</li><li class="calibre11">加入查找文件所有者的功能，将这个属性对谓词可见。</li></ol>
</div></div></div></div></div></div>
<div id="chp-10.html"><div class="calibre">
<div id="chp-10.html.main" class="calibre1"><div class="root"><div class="article"><h1 class="article-head" id="chp-10.html.calibre_toc_10">第十章：代码案例学习：解析二进制数据格式</h1><div class="article-body"><h1 class="calibre6"><a id="chp-10.html._0" class="calibre7 pcalibre"></a>第十章：代码案例学习：解析二进制数据格式</h1>
<p class="calibre9">本章将会讨论一个常见任务：解析（parsing）二进制文件。选这个任务有两个目的。第一个确实是想谈谈解析过程，但更重要的目标是谈谈程序组织、重构和消除样板代码（boilerplate code：通常指不重要，但没它又不行的代码）。我们将会展示如何清理冗余代码，并为第十四章讨论 Monad 做点准备。</p>
<p class="calibre9">我们将要用到的文件格式来自于 netpbm 库，它包含一组用来处理位图图像的程序及文件格式，它古老而令人尊敬。这种文件格式不但被广泛使用，而且还非常简单，虽然解析过程也不是完全没有挑战。对我们而言最重要的是，netpbm 文件没有经过压缩。</p>
<h2 class="calibre14"><a id="chp-10.html._6" class="calibre7 pcalibre"></a>灰度文件</h2>
<p class="calibre9">netpbm 的灰度文件格式名为 PGM（”portable grey map”）。事实上它不是一个格式，而是两个：纯文本（又名P2）格式使用 ASCII 编码，而更常用的原始（P5）格式则采用二进制表示。</p>
<p class="calibre9">每种文件格式都包含头信息，头信息以一个“魔法”字符串开始，指出文件格式。纯文本格式是 P2，原始格式是 P5。魔法字符串之后是空格，然后是三个数字：宽度、高度、图像的最大灰度值。这些数字用十进制 ASCII 数字表示，并用空格隔开。</p>
<p class="calibre9">最大灰度值之后便是图像数据了。在原始文件中，这是一串二进制值。纯文本文件中，这些值是用空格隔开的十进制 ASCII 数字。</p>
<p class="calibre9">原始文件可包含多个图像，一个接一个，每个都有自己的头信息。纯文本文件只包含一个图像。</p>
<h2 class="calibre14"><a id="chp-10.html._PGM__16" class="calibre7 pcalibre"></a>解析原始 PGM 文件</h2>
<p class="calibre9">首先我们来给原始 PGM 文件写解析函数。PGM 解析函数是一个纯函数。它不管获取数据，只管解析。这是一种常见的 Haskell 编程方法。通过把数据的获取和处理分开，我们可以很方便地控制从哪里获取数据。</p>
<p class="calibre9">我们用 ByteString 类型来存储灰度数据，因为它比较节省空间。由于 PGM 文件以 ASCII 字符串开头，文件内容又是二进制数据，我们同时载入两种形式的 ByteString 模块。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>PNM<span class="token">.</span>hs
import qualified Data<span class="token">.</span>ByteString<span class="token">.</span>Lazy<span class="token">.</span>Char8 as L8
import qualified Data<span class="token">.</span>ByteString<span class="token">.</span>Lazy as L
import Data<span class="token">.</span>Char <span class="token">(</span>isSpace<span class="token">)</span>

</code></pre>
<p class="calibre9">我们并不关心 ByteString 类型是惰性的还是严格的，因此我们随便选了惰性的版本。</p>
<p class="calibre9">我们用一个直白的数据类型来表示 PGM 图像。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>PNM<span class="token">.</span>hs
data Greymap <span class="token3">=</span> Greymap <span class="token">{</span>
      greyWidth <span class="token">:</span><span class="token">:</span> Int
    <span class="token">,</span> greyHeight <span class="token">:</span><span class="token">:</span> Int
    <span class="token">,</span> greyMax <span class="token">:</span><span class="token">:</span> Int
    <span class="token">,</span> greyData <span class="token">:</span><span class="token">:</span> L<span class="token">.</span>ByteString
    <span class="token">}</span> deriving <span class="token">(</span>Eq<span class="token">)</span>

</code></pre>
<p class="calibre9">通常来说，Haskell 的 Show 实例会生成数据的字符串表示，我们还可以用 read 读回来。然而，对于一个位图图像文件来说，这可能会生成一个非常大的字符串，比如当你对一张照片调用 show 的时候。基于这个原因，我们不准备让编译器自动为我们派生 Show 实例；我们会自己实现，并刻意简化它。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>PNM<span class="token">.</span>hs
instance Show Greymap where
    show <span class="token">(</span>Greymap w h m _<span class="token">)</span> <span class="token3">=</span> <span class="token4">"Greymap "</span> <span class="token3">++</span> show w <span class="token3">++</span> <span class="token4">"x"</span> <span class="token3">++</span> show h <span class="token3">+</span> <span class="token4">" "</span> <span class="token3">++</span> show m

</code></pre>
<p class="calibre9">我们的 Show 实例故意没打印位图数据，也就没必要写 Read 实例了，因为我们无法从 show 的结果重构 Greymap。</p>
<p class="calibre9">解析函数的类型显而易见。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>PNM<span class="token">.</span>hs
parseP5 <span class="token">:</span><span class="token">:</span> L<span class="token">.</span>ByteString <span class="token3">-</span><span class="token3">&gt;</span> Maybe <span class="token">(</span>Greymap<span class="token">,</span> L<span class="token">.</span>ByteString<span class="token">)</span>

</code></pre>
<p class="calibre9">这个函数以一个 ByteString 为参数，如果解析成功的话，它返回一个被解析的 Greymap 值以及解析之后剩下的字符串，剩下的字符串以后会用到。</p>
<p class="calibre9">解析函数必须一点一点处理输入数据。首先，我们必须确认我们正在处理的是原始 PGM 文件；然后，我们处理头信息中的数字；最后我们处理位图数据。下面是是一种比较初级的实现方法，我们会在它的基础上不断改进。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>PNM<span class="token">.</span>hs
matchHeader <span class="token">:</span><span class="token">:</span> L<span class="token">.</span>ByteString <span class="token3">-</span><span class="token3">&gt;</span> L<span class="token">.</span>ByteString <span class="token3">-</span><span class="token3">&gt;</span> Maybe L<span class="token">.</span>ByteString

<span class="token3">--</span> <span class="token4">"nat"</span> here is short <span class="token1">for</span> <span class="token4">"natural number"</span>
getNat <span class="token">:</span><span class="token">:</span> L<span class="token">.</span>ByteString <span class="token3">-</span><span class="token3">&gt;</span> Maybe <span class="token">(</span>Int<span class="token">,</span> L<span class="token">.</span>ByteString<span class="token">)</span>

getBytes <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> L<span class="token">.</span>ByteString
         <span class="token3">-</span><span class="token3">&gt;</span> Maybe <span class="token">(</span>L<span class="token">.</span>ByteString<span class="token">,</span> L<span class="token">.</span>ByteString<span class="token">)</span>

parseP5 s <span class="token3">=</span>
  case matchHeader <span class="token">(</span>L8<span class="token">.</span>pack <span class="token4">"P5"</span><span class="token">)</span> s of
    Nothing <span class="token3">-</span><span class="token3">&gt;</span> Nothing
    Just s1 <span class="token3">-</span><span class="token3">&gt;</span>
      case getNat s1 of
        Nothing <span class="token3">-</span><span class="token3">&gt;</span> Nothing
        Just <span class="token">(</span>width<span class="token">,</span> s2<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span>
          case getNat <span class="token">(</span>L8<span class="token">.</span>dropWhile isSpace s2<span class="token">)</span> of
            Nothing <span class="token3">-</span><span class="token3">&gt;</span> Nothing
            Just <span class="token">(</span>height<span class="token">,</span> s3<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span>
              case getNat <span class="token">(</span>L8<span class="token">.</span>dropWhile isSpace s3<span class="token">)</span> of
                Nothing <span class="token3">-</span><span class="token3">&gt;</span> Nothing
                Just <span class="token">(</span>maxGrey<span class="token">,</span> s4<span class="token">)</span>
                  <span class="token3">|</span> maxGrey <span class="token3">&gt;</span> <span class="token2">255</span> <span class="token3">-</span><span class="token3">&gt;</span> Nothing
                  <span class="token3">|</span> otherwise <span class="token3">-</span><span class="token3">&gt;</span>
                      case getBytes <span class="token2">1</span> s4 of
                        Nothing <span class="token3">-</span><span class="token3">&gt;</span> Nothing
                        Just <span class="token">(</span>_<span class="token">,</span> s5<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span>
                          case getBytes <span class="token">(</span>width <span class="token3">*</span> height<span class="token">)</span> s5 of
                            Nothing <span class="token3">-</span><span class="token3">&gt;</span> Nothing
                            Just <span class="token">(</span>bitmap<span class="token">,</span> s6<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span>
                              Just <span class="token">(</span>Greymap width height maxGrey bitmap<span class="token">,</span> s6<span class="token">)</span>

</code></pre>
<p class="calibre9">这段代码非常直白，它把所有的解析放在了一个长长的梯形 case 表达式中。每个函数在处理完它所需要的部分后会把剩余的 ByteString 返回。我们再把这部分传给下个函数。像这样我们将结果依次解构，如果解析失败就返回 Nothing，否则便又向最终结迈近了一步。下面是我们在解析过程中用到的函数的定义。它们的类型被注释掉了因为已经写过了。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>PNM<span class="token">.</span>hs
<span class="token3">--</span> L<span class="token">.</span>ByteString <span class="token3">-</span><span class="token3">&gt;</span> L<span class="token">.</span>ByteString <span class="token3">-</span><span class="token3">&gt;</span> Maybe L<span class="token">.</span>ByteString
matchHeader prefix str
    <span class="token3">|</span> prefix `L8<span class="token">.</span>isPrefixOf` str
        <span class="token3">=</span> Just <span class="token">(</span>L8<span class="token">.</span>dropWhile isSpace <span class="token">(</span>L<span class="token">.</span>drop <span class="token">(</span>L<span class="token">.</span>length prefix<span class="token">)</span> str<span class="token">)</span><span class="token">)</span>
    <span class="token3">|</span> otherwise
        <span class="token3">=</span> Nothing

<span class="token3">--</span> L<span class="token">.</span>ByteString <span class="token3">-</span><span class="token3">&gt;</span> Maybe <span class="token">(</span>Int<span class="token">,</span> L<span class="token">.</span>ByteString<span class="token">)</span>
getNat s <span class="token3">=</span> case L8<span class="token">.</span>readInt s of
             Nothing <span class="token3">-</span><span class="token3">&gt;</span> Nothing
             Just <span class="token">(</span>num<span class="token">,</span>rest<span class="token">)</span>
                 <span class="token3">|</span> num <span class="token3">&lt;=</span> <span class="token2">0</span>    <span class="token3">-</span><span class="token3">&gt;</span> Nothing
                 <span class="token3">|</span> otherwise   <span class="token3">-</span><span class="token3">&gt;</span> Just <span class="token">(</span>num<span class="token">,</span> L8<span class="token">.</span>dropWhile isSpace rest<span class="token">)</span>

<span class="token3">--</span> Int <span class="token3">-</span><span class="token3">&gt;</span> L<span class="token">.</span>ByteString <span class="token3">-</span><span class="token3">&gt;</span> Maybe <span class="token">(</span>L<span class="token">.</span>ByteString<span class="token">,</span> L<span class="token">.</span>ByteString<span class="token">)</span>
getBytes n str <span class="token3">=</span> let count           <span class="token3">=</span> fromIntegral n
                     both@<span class="token">(</span>prefix<span class="token">,</span>_<span class="token">)</span> <span class="token3">=</span> L<span class="token">.</span>splitAt count str
                 <span class="token1">in</span> <span class="token1">if</span> L<span class="token">.</span>length prefix <span class="token3">&lt;</span> count
                    then Nothing
                    <span class="token1">else</span> Just both

</code></pre>
<h2 class="calibre14"><a id="chp-10.html._130" class="calibre7 pcalibre"></a>消除样板代码</h2>
<p class="calibre9">parseP5 函数虽然能用，但它的代码风格却并不令人满意。它不断挪向屏幕右侧，非常明显，再来个稍微复杂点的函数它就要横跨屏幕了。我们不断构建和解构 Maybe 值，只在 Just 匹配特定值的时候才继续。所有这些相似的 case 表达式就是“样板代码”，它掩盖了我们真正要做的事情。总而言之，这段代码需要抽象重构。</p>
<p class="calibre9">退一步看，我们能观察到两种模式。第一，很多我们用到的函数都有相似的类型，它们最后一个参数都是 ByteString，返回值类型都是 Maybe。第二，parseP5 函数不断解构 Maybe 值，然后要么失败退出，要么把展开之后的值传给下个函数。</p>
<p class="calibre9">我们很容易就能写个函数来体现第二种模式。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>PNM<span class="token">.</span>hs
<span class="token">(</span><span class="token3">&gt;</span><span class="token3">&gt;</span><span class="token3">?</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> Maybe a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> Maybe b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> Maybe b
Nothing <span class="token3">&gt;</span><span class="token3">&gt;</span><span class="token3">?</span> _ <span class="token3">=</span> Nothing
Just v  <span class="token3">&gt;</span><span class="token3">&gt;</span><span class="token3">?</span> f <span class="token3">=</span> f v

</code></pre>
<p class="calibre9">(&gt;&gt;?) 函数非常简单：它接受一个值作为左侧参数，一个函数 f 作为右侧参数。如果值不为 Nothing，它就把函数 f 应用在 Just 构造器中的值上。我们把这个函数定义为操作符这样它就能把别的函数串联在一起了。最后，我们没给 (&gt;&gt;?) 定义结合度，因此它默认为 infixl9 （左结合，优先级最高的操作符）。换言之，a&gt;&gt;?b&gt;&gt;?c 会从左向右求值，就像 (a&gt;&gt;?b)&gt;&gt;?c) 一样。</p>
<p class="calibre9">有了这个串联函数，我们来重写一下解析函数。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>PNM<span class="token">.</span>hs
parseP5_take2 <span class="token">:</span><span class="token">:</span> L<span class="token">.</span>ByteString <span class="token3">-</span><span class="token3">&gt;</span> Maybe <span class="token">(</span>Greymap<span class="token">,</span> L<span class="token">.</span>ByteString<span class="token">)</span>
parseP5_take2 s <span class="token3">=</span>
    matchHeader <span class="token">(</span>L8<span class="token">.</span>pack <span class="token4">"P5"</span><span class="token">)</span> s      <span class="token3">&gt;</span><span class="token3">&gt;</span><span class="token3">?</span>
    \s <span class="token3">-</span><span class="token3">&gt;</span> skipSpace <span class="token">(</span><span class="token">(</span><span class="token">)</span><span class="token">,</span> s<span class="token">)</span>           <span class="token3">&gt;</span><span class="token3">&gt;</span><span class="token3">?</span>
    <span class="token">(</span>getNat <span class="token">.</span> snd<span class="token">)</span>                    <span class="token3">&gt;</span><span class="token3">&gt;</span><span class="token3">?</span>
    skipSpace                         <span class="token3">&gt;</span><span class="token3">&gt;</span><span class="token3">?</span>
    \<span class="token">(</span>width<span class="token">,</span> s<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span>   getNat s         <span class="token3">&gt;</span><span class="token3">&gt;</span><span class="token3">?</span>
    skipSpace                         <span class="token3">&gt;</span><span class="token3">&gt;</span><span class="token3">?</span>
    \<span class="token">(</span>height<span class="token">,</span> s<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span>  getNat s         <span class="token3">&gt;</span><span class="token3">&gt;</span><span class="token3">?</span>
    \<span class="token">(</span>maxGrey<span class="token">,</span> s<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> getBytes <span class="token2">1</span> s     <span class="token3">&gt;</span><span class="token3">&gt;</span><span class="token3">?</span>
    <span class="token">(</span>getBytes <span class="token">(</span>width <span class="token3">*</span> height<span class="token">)</span> <span class="token">.</span> snd<span class="token">)</span> <span class="token3">&gt;</span><span class="token3">&gt;</span><span class="token3">?</span>
    \<span class="token">(</span>bitmap<span class="token">,</span> s<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> Just <span class="token">(</span>Greymap width height maxGrey bitmap<span class="token">,</span> s<span class="token">)</span>

skipSpace <span class="token">:</span><span class="token">:</span> <span class="token">(</span>a<span class="token">,</span> L<span class="token">.</span>ByteString<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> Maybe <span class="token">(</span>a<span class="token">,</span> L<span class="token">.</span>ByteString<span class="token">)</span>
skipSpace <span class="token">(</span>a<span class="token">,</span> s<span class="token">)</span> <span class="token3">=</span> Just <span class="token">(</span>a<span class="token">,</span> L8<span class="token">.</span>dropWhile isSpace s<span class="token">)</span>

</code></pre>
<p class="calibre9">理解这个函数的关键在于理解其中的链。每个 (&gt;&gt;?) 的左侧都是一个 Maybe 值，右侧都是一个返回 Maybe 值的函数。这样，Maybe 值就可以不断传给后续 (&gt;&gt;?) 表达式。</p>
<p class="calibre9">我们新增了 skipSpace 函数用来提高可读性。通过这些改进，我们已将代码长度减半。通过移除样板 case 代码，代码变得更容易理解。</p>
<p class="calibre9">尽管在<a href="#chp-10.html." class="calibre7 pcalibre"><em class="calibre13">匿名（lambda）函数</em></a>中我们已经警告过不要过度使用匿名函数，在上面的函数链中我们还是用了一些。因为这些函数太小了，给它们命名并不能提高可读性。</p>
<h2 class="calibre14"><a id="chp-10.html._176" class="calibre7 pcalibre"></a>隐式状态</h2>
<p class="calibre9">到这里还没完。我们的代码显式地用序对传递结果，其中一个元素代表解析结果的中间值，另一个代表剩余的 ByteString 值。如果我们想扩展代码，比方说记录已经处理过的字节数，以便在解析失败时报告出错位置，那我们已经有8个地方要改了，就为了把序对改成三元组。</p>
<p class="calibre9">这使得本来就没多少的代码还很难修改。问题在于用模式匹配从序对中取值：我们假设了我们总是会用序对，并且把这种假设编进了代码。尽管模式匹配非常好用，但如果不慎重，我们还是会误入歧途。</p>
<p class="calibre9">让我们解决新代码带来的不便。首先，我们来修改解析状态的类型。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>Parse<span class="token">.</span>hs
data ParseState <span class="token3">=</span> ParseState <span class="token">{</span>
      string <span class="token">:</span><span class="token">:</span> L<span class="token">.</span>ByteString
    <span class="token">,</span> offset <span class="token">:</span><span class="token">:</span> Int64           <span class="token3">--</span> imported from Data<span class="token">.</span>Int
    <span class="token">}</span> deriving <span class="token">(</span>Show<span class="token">)</span>

</code></pre>
<p class="calibre9">我们转向了代数数据类型，现在我们既可以记录当前剩余的字符串，也可以记录相对于原字符串的偏移值了。更重要的改变是用了记录语法：现在可以避免使用模式匹配来获取状态信息了，可以用 string 和 offset 访问函数。</p>
<p class="calibre9">我们给解析状态起了名字。给东西起名字方便我们推理。例如，我们现在可以这么看解析函数：它处理一个解析状态，产生新解析状态和一些别的信息。我们可以用 Haskell 类型直接表示。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>Parse<span class="token">.</span>hs
simpleParse <span class="token">:</span><span class="token">:</span> ParseState <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>a<span class="token">,</span> ParseState<span class="token">)</span>
simpleParse <span class="token3">=</span> undefined

</code></pre>
<p class="calibre9">为了给用户更多帮助，我们可以在解析失败时报告一条错误信息。只需对解析器的类型稍作修改即可。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>Parse<span class="token">.</span>hs
betterParse <span class="token">:</span><span class="token">:</span> ParseState <span class="token3">-</span><span class="token3">&gt;</span> Either String <span class="token">(</span>a<span class="token">,</span> ParseState<span class="token">)</span>
betterParse <span class="token3">=</span> undefined

</code></pre>
<p class="calibre9">为了防患于未然，我们最好不要将解析器的实现暴露给用户。早些时候我们显式地用序对来表示状态，当我们想扩展解析器的功能时，我们马上就遇到了麻烦。为了防止这种现象再次发生，我们用一个 newtype 声明来隐藏解析器的细节。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span>file<span class="token">:</span> ch10<span class="token3">/</span>Parse<span class="token">.</span>hs
newtype Parse a <span class="token3">=</span> Parse <span class="token">{</span>
    runParse <span class="token">:</span><span class="token">:</span> ParseState <span class="token3">-</span><span class="token3">&gt;</span> Either String <span class="token">(</span>a<span class="token">,</span> ParseState<span class="token">)</span>
    <span class="token">}</span>

</code></pre>
<p class="calibre9">别忘了 newtype 只是函数在编译时的一层包装，它没有运行时开销。我们想用这个函数时，我们用 runParser 访问器。</p>
<p class="calibre9">如果我们的模块不导出 Parse 值构造器，我们就能确保没人会不小心创建一个解析器，或者通过模式匹配来观察其内部构造。</p>
<h2 class="calibre14"><a id="chp-10.html.identity__227" class="calibre7 pcalibre"></a>identity 解析器</h2>
<p class="calibre9">我们来定义一个简单的 <em class="calibre13">identity</em> 解析器。它把输入值转为解析结果。从这个意义上讲，它有点像 id 函数。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>Parse<span class="token">.</span>hs
identity <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> Parse a
identity a <span class="token3">=</span> Parse <span class="token">(</span>\s <span class="token3">-</span><span class="token3">&gt;</span> Right <span class="token">(</span>a<span class="token">,</span> s<span class="token">)</span><span class="token">)</span>

</code></pre>
<p class="calibre9">这个函数没动解析状态，只把它的参数当成了解析结果。我们把函数体包装成 Parse 类型以通过类型检查。我们该怎么用它去解析呢？</p>
<p class="calibre9">首先我们得把 Parse 包装去掉从而得到里面的函数。这通过 runParse 函数实现。然后得创建一个 ParseState，然后对其调用解析函数。最后，我们把解析结果和最终的 ParseState 分开。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>Parse<span class="token">.</span>hs
parse <span class="token">:</span><span class="token">:</span> Parse a <span class="token3">-</span><span class="token3">&gt;</span> L<span class="token">.</span>ByteString <span class="token3">-</span><span class="token3">&gt;</span> Either String a
parse parser initState
    <span class="token3">=</span> case runParse parser <span class="token">(</span>ParseState initState <span class="token2">0</span><span class="token">)</span> of
        Left err          <span class="token3">-</span><span class="token3">&gt;</span> Left err
        Right <span class="token">(</span>result<span class="token">,</span> _<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> Right result

</code></pre>
<p class="calibre9">由于 identity 解析器和 parse 函数都没有检查解析状态，我们都不用传入字符串就可以试验我们的代码。</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>r
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> Parse<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>
<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>type parse <span class="token">(</span>identity <span class="token2">1</span><span class="token">)</span> undefined
parse <span class="token">(</span>identity <span class="token2">1</span><span class="token">)</span> undefined <span class="token">:</span><span class="token">:</span> Num a <span class="token3">=</span><span class="token3">&gt;</span> Either String a
<span class="token3">*</span>Main<span class="token3">&gt;</span> parse <span class="token">(</span>identity <span class="token2">1</span><span class="token">)</span> undefined
Right <span class="token2">1</span>
<span class="token3">*</span>Main<span class="token3">&gt;</span> parse <span class="token">(</span>identity <span class="token4">"foo"</span><span class="token">)</span> undefined
Right <span class="token4">"foo"</span>

</code></pre>
<p class="calibre9">一个不检查输入的解析器可能有点奇怪，但很快我们就可以看到它的用处。同时，我们更加确信我们的类型是正确的，基本了解了代码是如何工作的。</p>
<h2 class="calibre14"><a id="chp-10.html._269" class="calibre7 pcalibre"></a>记录语法、更新以及模式匹配</h2>
<p class="calibre9">记录语法的用处不仅仅在于访问函数：我们可以用它来复制或部分改变已有值。就像下面这样：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>Parse<span class="token">.</span>hs
modifyOffset <span class="token">:</span><span class="token">:</span> ParseState <span class="token3">-</span><span class="token3">&gt;</span> Int64 <span class="token3">-</span><span class="token3">&gt;</span> ParseState
modifyOffset initState newOffset <span class="token3">=</span>
    initState <span class="token">{</span> offset <span class="token3">=</span> newOffset <span class="token">}</span>

</code></pre>
<p class="calibre9">这会创建一个跟 initState 完全一样的 ParseState 值，除了 offset 字段会替换成 newOffset 指定的值。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> let before <span class="token3">=</span> ParseState <span class="token">(</span>L8<span class="token">.</span>pack <span class="token4">"foo"</span><span class="token">)</span> <span class="token2">0</span>
<span class="token3">*</span>Main<span class="token3">&gt;</span> let after <span class="token3">=</span> modifyOffset before <span class="token2">3</span>
<span class="token3">*</span>Main<span class="token3">&gt;</span> before
ParseState <span class="token">{</span>string <span class="token3">=</span> <span class="token4">"foo"</span><span class="token">,</span> offset <span class="token3">=</span> <span class="token2">0</span><span class="token">}</span>
<span class="token3">*</span>Main<span class="token3">&gt;</span> after
ParseState <span class="token">{</span>string <span class="token3">=</span> <span class="token4">"foo"</span><span class="token">,</span> offset <span class="token3">=</span> <span class="token2">3</span><span class="token">}</span>

</code></pre>
<p class="calibre9">在大括号里我们可以给任意多的字段赋值，用逗号分开即可。</p>
<h2 class="calibre14"><a id="chp-10.html._295" class="calibre7 pcalibre"></a>一个更有趣的解析器</h2>
<p class="calibre9">现在来写个解析器做一些有意义的事情。我们并不好高骛远：我们只想解析单个字节而已。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>Parse<span class="token">.</span>hs
<span class="token3">--</span> import the Word8 type from Data<span class="token">.</span>Word
parseByte <span class="token">:</span><span class="token">:</span> Parse Word8
parseByte <span class="token3">=</span>
    getState <span class="token3">==</span><span class="token3">&gt;</span> \initState <span class="token3">-</span><span class="token3">&gt;</span>
    case L<span class="token">.</span>uncons <span class="token">(</span>string initState<span class="token">)</span> of
      Nothing <span class="token3">-</span><span class="token3">&gt;</span>
          bail <span class="token4">"no more input"</span>
      Just <span class="token">(</span>byte<span class="token">,</span>remainder<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span>
          putState newState <span class="token3">==</span><span class="token3">&gt;</span> \_ <span class="token3">-</span><span class="token3">&gt;</span>
          identity byte
        where newState <span class="token3">=</span> initState <span class="token">{</span> string <span class="token3">=</span> remainder<span class="token">,</span>
                                     offset <span class="token3">=</span> newOffset <span class="token">}</span>
              newOffset <span class="token3">=</span> offset initState <span class="token3">+</span> <span class="token2">1</span>

</code></pre>
<p class="calibre9">定义中有几个新函数。</p>
<p class="calibre9">L8.uncons 函数取出 ByteString 中的第一个元素。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> L8<span class="token">.</span>uncons <span class="token">(</span>L8<span class="token">.</span>pack <span class="token4">"foo"</span><span class="token">)</span>
Just <span class="token">(</span><span class="token4">'f'</span><span class="token">,</span>Chunk <span class="token4">"oo"</span> Empty<span class="token">)</span>
ghci<span class="token3">&gt;</span> L8<span class="token">.</span>uncons L8<span class="token">.</span>empty
Nothing

</code></pre>
<p class="calibre9">getState 函数得到当前解析状态，putState 函数更新解析状态。bail 函数终止解析并报告错误。(==&gt;) 函数把解析器串联起来。我们马上就会详细介绍这些函数。</p>
<p class="calibre9">Note</p>
<p class="calibre9">Hanging lambdas</p>
<h2 class="calibre14"><a id="chp-10.html._335" class="calibre7 pcalibre"></a>获取和修改解析状态</h2>
<p class="calibre9">parseByte 函数并不接受解析状态作为参数。相反，它必须调用 getState 来得到解析状态的副本，然后调用 putState 将当前状态更新为新状态。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>Parse<span class="token">.</span>hs
getState <span class="token">:</span><span class="token">:</span> Parse ParseState
getState <span class="token3">=</span> Parse <span class="token">(</span>\s <span class="token3">-</span><span class="token3">&gt;</span> Right <span class="token">(</span>s<span class="token">,</span> s<span class="token">)</span><span class="token">)</span>

putState <span class="token">:</span><span class="token">:</span> ParseState <span class="token3">-</span><span class="token3">&gt;</span> Parse <span class="token">(</span><span class="token">)</span>
putState s <span class="token3">=</span> Parse <span class="token">(</span>\_ <span class="token3">-</span><span class="token3">&gt;</span> Right <span class="token">(</span><span class="token">(</span><span class="token">)</span><span class="token">,</span> s<span class="token">)</span><span class="token">)</span>

</code></pre>
<p class="calibre9">阅读这些函数的时候，记得序对左元素为 Parse 结果，右元素为当前 ParseState。这样理解起来会比较容易。</p>
<p class="calibre9">getState 将当前解析状态展开，这样调用者就能访问里面的字符串。putState 将当前解析状态替换为一个新状态。(==&gt;) 链中的下一个函数将会使用这个状态。</p>
<p class="calibre9">这些函数将显式的状态处理移到了需要它们的函数的函数体内。很多函数并不关心当前状态是什么，因而它们也不会调用 getState 或 putState。跟之前需要手动传递元组的解析器相比，现在的代码更加紧凑。在之后的代码中就能看到效果。</p>
<p class="calibre9">我们将解析状态的细节打包放入 ParseState 类型中，然后我们通过访问器而不是模式匹配来访问它。隐式地传递解析状态给我们带来另外的好处。如果想增加解析状态的信息，我们只需修改 ParseState 定义，以及需要新信息的函数体即可。跟之前通过模式匹配暴露状态的解析器相比，现在的代码更加模块化：只有需要新信息的代码会受到影响。</p>
<h2 class="calibre14"><a id="chp-10.html._357" class="calibre7 pcalibre"></a>报告解析错误</h2>
<p class="calibre9">在定义 Parse 的时候我们已经考虑了出错的情况。(==&gt;) 组合子不断检查解析错误并在错误发生时终止解析。但我们还没来得及介绍用来报告解析错误的 bail 函数。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>Parse<span class="token">.</span>hs
bail <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> Parse a
bail err <span class="token3">=</span> Parse $ \s <span class="token3">-</span><span class="token3">&gt;</span> Left $
           <span class="token4">"byte offset "</span> <span class="token3">++</span> show <span class="token">(</span>offset s<span class="token">)</span> <span class="token3">++</span> <span class="token4">": "</span> <span class="token3">++</span> err

</code></pre>
<p class="calibre9">调用 bail 之后，(==&gt;) 会模式匹配包装了错误信息的 Left 构造器，并且不会调用下一个解析器。这使得错误信息可以沿着调用链返回。</p>
<h2 class="calibre14"><a id="chp-10.html._371" class="calibre7 pcalibre"></a>把解析器串联起来</h2>
<p class="calibre9">(==&gt;) 函数的功能和之前介绍的 (&gt;&gt;?) 函数功能类似：它可以作为“胶水”把函数串联起来。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>Parse<span class="token">.</span>hs
<span class="token">(</span><span class="token3">==</span><span class="token3">&gt;</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> Parse a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> Parse b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> Parse b

firstParser <span class="token3">==</span><span class="token3">&gt;</span> secondParser  <span class="token3">=</span>  Parse chainedParser
  where chainedParser initState   <span class="token3">=</span>
          case runParse firstParser initState of
            Left errMessage <span class="token3">-</span><span class="token3">&gt;</span>
                Left errMessage
            Right <span class="token">(</span>firstResult<span class="token">,</span> newState<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span>
                runParse <span class="token">(</span>secondParser firstResult<span class="token">)</span> newState

</code></pre>
<p class="calibre9">(==&gt;) 函数体很有趣，还稍微有点复杂。回想一下，Parse 类型表示一个被包装的函数。既然 (==&gt;) 函数把两个 Parse 串联起来并产生第三个，它也必须返回一个被包装的函数。</p>
<p class="calibre9">这个函数做的并不多：它仅仅创建了一个<em class="calibre13">闭包</em>（closure）用来记忆 firstParser 和 secondParser 的值。</p>
<p class="calibre9">Note</p>
<p class="calibre9">闭包是一个函数和它所在的<em class="calibre13">环境</em>，也就是它可以访问的变量。闭包在 Haskell 中很常见。例如，(+5) 就是一个闭包。实现的时候必须将 5 记录为 (+) 操作符的第二个参数，这样得到的函数才能把 5 加给它的参数。</p>
<p class="calibre9">在应用 parse 之前，这个闭包不会被展开应用。应用的时候，它会求值 firstParser 并检查它的结果。如果解析失败，闭包也会失败。否则，它会把解析结果及 newState 传给 secondParser。</p>
<p class="calibre9">这是非常具有想象力、非常微妙的想法：我们实际上用了一个隐藏的参数将 ParseState 在 Parse 链之间传递。（我们在之后几章还会碰到这样的代码，所以现在不懂也没有关系。）</p>
<h2 class="calibre14"><a id="chp-10.html.Functor__401" class="calibre7 pcalibre"></a>Functor 简介</h2>
<p class="calibre9">现在我们对 map 函数已经有了一个比较详细的了解，它把函数应用在列表的每一个元素上，并返回一个可能包含另一种类型元素的列表。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> map <span class="token">(</span><span class="token3">+</span><span class="token2">1</span><span class="token">)</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">]</span>
<span class="token">[</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">,</span><span class="token2">4</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> map show <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">]</span>
<span class="token">[</span><span class="token4">"1"</span><span class="token">,</span><span class="token4">"2"</span><span class="token">,</span><span class="token4">"3"</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> <span class="token">:</span>type map show
map show <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Show a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>String<span class="token">]</span>

</code></pre>
<p class="calibre9">map 函数这种行为在别的实例中可能有用。例如，考虑一棵二叉树。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>TreeMap<span class="token">.</span>hs
data Tree a <span class="token3">=</span> Node <span class="token">(</span>Tree a<span class="token">)</span> <span class="token">(</span>Tree a<span class="token">)</span>
            <span class="token3">|</span> Leaf a
              deriving <span class="token">(</span>Show<span class="token">)</span>

</code></pre>
<p class="calibre9">如果想把一个字符串树转成一个包含这些字符串长度的树，我们可以写个函数来实现：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>TreeMap<span class="token">.</span>hs
treeLengths <span class="token">(</span>Leaf s<span class="token">)</span> <span class="token3">=</span> Leaf <span class="token">(</span>length s<span class="token">)</span>
treeLengths <span class="token">(</span>Node l r<span class="token">)</span> <span class="token3">=</span> Node <span class="token">(</span>treeLengths l<span class="token">)</span> <span class="token">(</span>treeLengths r<span class="token">)</span>

</code></pre>
<p class="calibre9">我们试着寻找一些可能转成通用函数的模式，下面就是一个可能的模式。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>TreeMap<span class="token">.</span>hs
treeMap <span class="token">:</span><span class="token">:</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> Tree a <span class="token3">-</span><span class="token3">&gt;</span> Tree b
treeMap f <span class="token">(</span>Leaf a<span class="token">)</span>   <span class="token3">=</span> Leaf <span class="token">(</span>f a<span class="token">)</span>
treeMap f <span class="token">(</span>Node l r<span class="token">)</span> <span class="token3">=</span> Node <span class="token">(</span>treeMap f l<span class="token">)</span> <span class="token">(</span>treeMap f r<span class="token">)</span>

</code></pre>
<p class="calibre9">正如我们希望的那样，treeLengths 和 treeMaplength 返回相同的结果。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> let tree <span class="token3">=</span> Node <span class="token">(</span>Leaf <span class="token4">"foo"</span><span class="token">)</span> <span class="token">(</span>Node <span class="token">(</span>Leaf <span class="token4">"x"</span><span class="token">)</span> <span class="token">(</span>Leaf <span class="token4">"quux"</span><span class="token">)</span><span class="token">)</span>
ghci<span class="token3">&gt;</span> treeLengths tree
Node <span class="token">(</span>Leaf <span class="token2">3</span><span class="token">)</span> <span class="token">(</span>Node <span class="token">(</span>Leaf <span class="token2">1</span><span class="token">)</span> <span class="token">(</span>Leaf <span class="token2">4</span><span class="token">)</span><span class="token">)</span>
ghci<span class="token3">&gt;</span> treeMap length tree
Node <span class="token">(</span>Leaf <span class="token2">3</span><span class="token">)</span> <span class="token">(</span>Node <span class="token">(</span>Leaf <span class="token2">1</span><span class="token">)</span> <span class="token">(</span>Leaf <span class="token2">4</span><span class="token">)</span><span class="token">)</span>
ghci<span class="token3">&gt;</span> treeMap <span class="token">(</span>odd <span class="token">.</span> length<span class="token">)</span> tree
Node <span class="token">(</span>Leaf True<span class="token">)</span> <span class="token">(</span>Node <span class="token">(</span>Leaf True<span class="token">)</span> <span class="token">(</span>Leaf False<span class="token">)</span><span class="token">)</span>

</code></pre>
<p class="calibre9">Haskell 提供了一个众所周知的类型类来进一步一般化 treeMap。这个类型类叫做 Functor，它只定义了一个函数 fmap。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>TreeMap<span class="token">.</span>hs
class <span class="token5">Functor</span> f where
    fmap <span class="token">:</span><span class="token">:</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> f a <span class="token3">-</span><span class="token3">&gt;</span> f b

</code></pre>
<p class="calibre9">我们可以把 fmap 当做某种提升函数，就像我们在 Avoiding boilerplate with lifting(fix link) 一节中介绍的那样。它接受一个参数为普通值 a-&gt;b 的函数并把它提升为一个参数为容器 fa-&gt;fb 的函数。其中 f 是容器的类型。</p>
<p class="calibre9">举个例子，如果我们用 Tree 替换类型变量 f，fmap 的类型就会跟 treeMap 的类型相同。事实上我们可以用 treeMap 作为 fmap 对 Tree 的实现。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>TreeMap<span class="token">.</span>hs
instance Functor Tree where
    fmap <span class="token3">=</span> treeMap

</code></pre>
<p class="calibre9">我们可以用 map 作为 fmap 对列表的实现。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>TreeMap<span class="token">.</span>hs
instance Functor <span class="token">[</span><span class="token">]</span> where
    fmap <span class="token3">=</span> map

</code></pre>
<p class="calibre9">现在我们可以把 fmap 用于不同类型的容器上了。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> fmap length <span class="token">[</span><span class="token4">"foo"</span><span class="token">,</span><span class="token4">"quux"</span><span class="token">]</span>
<span class="token">[</span><span class="token2">3</span><span class="token">,</span><span class="token2">4</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> fmap length <span class="token">(</span>Node <span class="token">(</span>Leaf <span class="token4">"Livingstone"</span><span class="token">)</span> <span class="token">(</span>Leaf <span class="token4">"I presume"</span><span class="token">)</span><span class="token">)</span>
Node <span class="token">(</span>Leaf <span class="token2">11</span><span class="token">)</span> <span class="token">(</span>Leaf <span class="token2">9</span><span class="token">)</span>

</code></pre>
<p class="calibre9">Prelude 定义了一些常见类型的 Functor 实例，如列表和 Maybe。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>TreeMap<span class="token">.</span>hs
instance Functor Maybe where
    fmap _ Nothing  <span class="token3">=</span> Nothing
    fmap f <span class="token">(</span>Just x<span class="token">)</span> <span class="token3">=</span> Just <span class="token">(</span>f x<span class="token">)</span>

</code></pre>
<p class="calibre9">Maybe 的这个实例很清楚地表明了 fmap 要做什么。对于类型的每一个构造器，它都必须给出对应的行为。例如，如果值被包装在 Just 里，fmap 实现把函数应用在展开之后的值上，然后再用 Just 重新包装起来。</p>
<p class="calibre9">Functor 的定义限制了我们能用 fmap 做什么。例如，如果一个类型有且仅有一个类型参数，我们才能给它实现 Functor 实例。</p>
<p class="calibre9">举个例子，我们不能给 Eitherab 或者 (a,b) 写 fmap 实现，因为它们有两个类型参数。我们也不能给 Bool 或者 Int 写，因为它们没有类型参数。</p>
<p class="calibre9">另外，我们不能给类型定义添加任何约束。这是什么意思呢？为了搞清楚，我们来看一个正常的 data 定义和它的 Functor 实例。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>ValidFunctor<span class="token">.</span>hs
data Foo a <span class="token3">=</span> Foo a

instance Functor Foo where
    fmap f <span class="token">(</span>Foo a<span class="token">)</span> <span class="token3">=</span> Foo <span class="token">(</span>f a<span class="token">)</span>

</code></pre>
<p class="calibre9">当我们定义新类型时，我们可以在 data 关键字之后加一个类型约束。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>ValidFunctor<span class="token">.</span>hs
data Eq a <span class="token3">=</span><span class="token3">&gt;</span> Bar a <span class="token3">=</span> Bar a

instance Functor Bar where
    fmap f <span class="token">(</span>Bar a<span class="token">)</span> <span class="token3">=</span> Bar <span class="token">(</span>f a<span class="token">)</span>

</code></pre>
<p class="calibre9">这意味着只有当 a 是 Eq 类型类的成员时，它才能被放进 Foo。然而，这个约束却让我们无法给 Bar 写 Functor 实例。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>l ValidFunctor<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> ValidFunctor<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>

ValidFunctor<span class="token">.</span>hs<span class="token">:</span><span class="token2">8</span><span class="token">:</span><span class="token2">6</span><span class="token">:</span>
    Illegal datatype context <span class="token">(</span>use DatatypeContexts<span class="token">)</span><span class="token">:</span> Eq a <span class="token3">=</span><span class="token3">&gt;</span>
Failed<span class="token">,</span> modules loaded<span class="token">:</span> none<span class="token">.</span>

</code></pre>
<h2 class="calibre14"><a id="chp-10.html._546" class="calibre7 pcalibre"></a>给类型定义加约束不好</h2>
<p class="calibre9">给类型定义加约束从来就不是什么好主意。它的实质效果是强迫你给每一个用到这种类型值的函数加类型约束。假设我们现在有一个栈数据结构，我们想通过访问它来看看它的元素是否按顺序排列。下面是数据类型的一个简单实现。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>TypeConstraint<span class="token">.</span>hs
data <span class="token">(</span>Ord a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> OrdStack a <span class="token3">=</span> Bottom
                           <span class="token3">|</span> Item a <span class="token">(</span>OrdStack a<span class="token">)</span>
                             deriving <span class="token">(</span>Show<span class="token">)</span>

</code></pre>
<p class="calibre9">如果我们想写一个函数来看看它是不是升序的（即每个元素都比它下面的元素大），很显然，我们需要 Ord 约束来进行两两比较。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>TypeConstraint<span class="token">.</span>hs
isIncreasing <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Ord a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> OrdStack a <span class="token3">-</span><span class="token3">&gt;</span> Bool
isIncreasing <span class="token">(</span>Item a rest@<span class="token">(</span>Item b _<span class="token">)</span><span class="token">)</span>
    <span class="token3">|</span> a <span class="token3">&lt;</span> b     <span class="token3">=</span> isIncreasing rest
    <span class="token3">|</span> otherwise <span class="token3">=</span> False
isIncreasing _  <span class="token3">=</span> True

</code></pre>
<p class="calibre9">然而，由于我们在类型声明上加了类型约束，它最后也影响到了某些不需要它的地方：我们需要给 push 加上 Ord 约束，但事实上它并不关心栈里元素的顺序。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>TypeConstraint<span class="token">.</span>hs
push <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Ord a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> OrdStack a <span class="token3">-</span><span class="token3">&gt;</span> OrdStack a
push a s <span class="token3">=</span> Item a s

</code></pre>
<p class="calibre9">如果你把 Ord 约束删掉，push 定义便无法通过类型检查。</p>
<p class="calibre9">正是由于这个原因，我们之前给 Bar 写 Functor 实例没有成功：它要求 fmap 的类型签名加上 Eq 约束。</p>
<p class="calibre9">我们现在已经尝试性地确定了 Haskell 里给类型签名加类型约束并不是一个好的特性，那有什么好的替代吗？答案很简单：不要在类型定义上加类型约束，在需要它们的函数上加。</p>
<p class="calibre9">在这个例子中，我们可以删掉 OrdStack 和 push 上的 Ord。isIncreasing 还需要，否则便无法调用 (&lt;)。现在我们只在需要的地方加类型约束了。这还有一个更深远的好处：类型签名更准确地表示了每个函数的真正需求。</p>
<p class="calibre9">大多数 Haskell 容器遵循这个模式。Data.Map 模块里的 Map 类型要求它的键是排序的，但类型本身却没有这个约束。这个约束是通过 insert 这样的函数来表达的，因为这里需要它，在 size 上却没有，因为在这里顺序无关紧要。</p>
<h2 class="calibre14"><a id="chp-10.html.fmap__589" class="calibre7 pcalibre"></a>fmap 的中缀使用</h2>
<p class="calibre9">你经常会看到 fmap 作为操作符使用：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">(</span><span class="token2">1</span><span class="token3">+</span><span class="token">)</span> `fmap` <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">]</span> <span class="token3">++</span> <span class="token">[</span><span class="token2">4</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">6</span><span class="token">]</span>
<span class="token">[</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">,</span><span class="token2">4</span><span class="token">,</span><span class="token2">4</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">6</span><span class="token">]</span>

</code></pre>
<p class="calibre9">也许你感到奇怪，原始的 map 却几乎从不这样使用。</p>
<p class="calibre9">我们这样使用 fmap 一个可能的原因是可以省略第二个参数的括号。括号越少读代码也就越容易。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> fmap <span class="token">(</span><span class="token2">1</span><span class="token3">+</span><span class="token">)</span> <span class="token">(</span><span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">]</span> <span class="token3">++</span> <span class="token">[</span><span class="token2">4</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">6</span><span class="token">]</span><span class="token">)</span>
<span class="token">[</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">,</span><span class="token2">4</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">6</span><span class="token">,</span><span class="token2">7</span><span class="token">]</span>

</code></pre>
<p class="calibre9">如果你真的想把 fmap 当做操作符用，Control.Applicative 模块包含了作为 fmap 别名的 (&lt;$&gt;) 操作符。</p>
<p class="calibre9">当我们返回之前写的代码时，我们会发现这对解析很有用。</p>
<h2 class="calibre14"><a id="chp-10.html._613" class="calibre7 pcalibre"></a>灵活实例</h2>
<p class="calibre9">你可能想给 EitherIntb 类型实现 Functor 实例，因为它只有一个类型参数。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>EitherInt<span class="token">.</span>hs
instance Functor <span class="token">(</span>Either Int<span class="token">)</span> where
    fmap _ <span class="token">(</span>Left n<span class="token">)</span> <span class="token3">=</span> Left n
    fmap f <span class="token">(</span>Right r<span class="token">)</span> <span class="token3">=</span> Right <span class="token">(</span>f r<span class="token">)</span>

</code></pre>
<p class="calibre9">然而，Haskell 98 类型系统不能保证检查这种实例的约束会终结。非终结的约束检查会导致编译器进入死循环，所以这种形式的实例是被禁止的。</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>l EitherInt<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> EitherInt<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>

EitherInt<span class="token">.</span>hs<span class="token">:</span><span class="token2">2</span><span class="token">:</span><span class="token2">10</span><span class="token">:</span>
    Illegal instance declaration <span class="token1">for</span> ‘Functor <span class="token">(</span>Either Int<span class="token">)</span>’
      <span class="token">(</span>All instance types must be of the form <span class="token">(</span>T a1 <span class="token">.</span><span class="token">.</span><span class="token">.</span> an<span class="token">)</span>
       where a1 <span class="token">.</span><span class="token">.</span><span class="token">.</span> an are <span class="token3">*</span>distinct type variables<span class="token3">*</span><span class="token">,</span>
       and each type variable appears at most once <span class="token1">in</span> the instance head<span class="token">.</span>
       Use FlexibleInstances <span class="token1">if</span> you want to disable this<span class="token">.</span><span class="token">)</span>
    In the instance declaration <span class="token1">for</span> ‘Functor <span class="token">(</span>Either Int<span class="token">)</span>’
Failed<span class="token">,</span> modules loaded<span class="token">:</span> none<span class="token">.</span>

</code></pre>
<p class="calibre9">GHC 的类型系统比 Haskell 98 标准更强大。出于可移植性的考虑，默认情况下，它是运行在兼容 Haskell 98 的模式下的。 我们可以通过一个编译命令允许更灵活的实例。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>EitherIntFlexible<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span># LANGUAGE FlexibleInstances #<span class="token3">-</span><span class="token">}</span>

instance Functor <span class="token">(</span>Either Int<span class="token">)</span> where
    fmap _ <span class="token">(</span>Left n<span class="token">)</span>  <span class="token3">=</span> Left n
    fmap f <span class="token">(</span>Right r<span class="token">)</span> <span class="token3">=</span> Right <span class="token">(</span>f r<span class="token">)</span>

</code></pre>
<p class="calibre9">这个命令内嵌于 LANGUAGE 编译选项。</p>
<p class="calibre9">有了 Functor 实例，我们来试试 EitherInt 的 fmap 函数。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>load EitherIntFlexible
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> EitherIntFlexible<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>
ghci<span class="token3">&gt;</span> fmap <span class="token">(</span><span class="token3">==</span> <span class="token4">"cheeseburger"</span><span class="token">)</span> <span class="token">(</span>Left <span class="token2">1</span> <span class="token">:</span><span class="token">:</span> Either Int String<span class="token">)</span>
Left <span class="token2">1</span>
ghci<span class="token3">&gt;</span> fmap <span class="token">(</span><span class="token3">==</span> <span class="token4">"cheeseburger"</span><span class="token">)</span> <span class="token">(</span>Right <span class="token4">"fries"</span> <span class="token">:</span><span class="token">:</span> Either Int String<span class="token">)</span>
Right False

</code></pre>
<h2 class="calibre14"><a id="chp-10.html._Functor__667" class="calibre7 pcalibre"></a>更多关于 Functor 的思考</h2>
<p class="calibre9">对于 Functor 如何工作，我们做了一些隐式的假设。把它们说清楚并当成规则去遵守非常有用，因为这会让我们把 Functor 当成统一的、行为规范的对象。规则只有两个，并且非常简单。</p>
<p class="calibre9">第一条规则是 Functor 必须保持<em class="calibre13">身份</em>（preserve identity）。也就是说，应用 fmapid 应该返回相同的值。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> fmap id <span class="token">(</span>Node <span class="token">(</span>Leaf <span class="token4">"a"</span><span class="token">)</span> <span class="token">(</span>Leaf <span class="token4">"b"</span><span class="token">)</span><span class="token">)</span>
Node <span class="token">(</span>Leaf <span class="token4">"a"</span><span class="token">)</span> <span class="token">(</span>Leaf <span class="token4">"b"</span><span class="token">)</span>

</code></pre>
<p class="calibre9">第二条规则是 Functor 必须是<em class="calibre13">可组合的</em>。也就是说，把两个 fmap 组合使用效果应该和把函数组合起来再用 fmap 相同。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">(</span>fmap even <span class="token">.</span> fmap length<span class="token">)</span> <span class="token">(</span>Just <span class="token4">"twelve"</span><span class="token">)</span>
Just True
ghci<span class="token3">&gt;</span> fmap <span class="token">(</span>even <span class="token">.</span> length<span class="token">)</span> <span class="token">(</span>Just <span class="token4">"twelve"</span><span class="token">)</span>
Just True

</code></pre>
<p class="calibre9">另一种看待这两条规则的方式是 Functor 必须保持<em class="calibre13">结构</em>（shape）。集合的结构不应该受到 Functor 的影响，只有对应的值会改变。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> fmap odd <span class="token">(</span>Just <span class="token2">1</span><span class="token">)</span>
Just True
ghci<span class="token3">&gt;</span> fmap odd Nothing
Nothing

</code></pre>
<p class="calibre9">如果你要写 Functor 实例，最好把这些规则记在脑子里，并且最好测试一下，因为编译器不会检查我们提到的规则。另一方面，如果你只是用 Functor，这些规则又如此自然，根本没必要记住。它们只是把一些“照我说的做”的直觉概念形式化了。下面是期望行为的伪代码表示。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>FunctorLaws<span class="token">.</span>hs
fmap id       <span class="token3">==</span>  id
fmap <span class="token">(</span>f <span class="token">.</span> g<span class="token">)</span>  <span class="token3">==</span>  fmap f <span class="token">.</span> fmap g

</code></pre>
<h2 class="calibre14"><a id="chp-10.html._Parse__Functor__708" class="calibre7 pcalibre"></a>给 Parse 写一个 Functor 实例</h2>
<p class="calibre9">对于到目前为止我们研究过的类型而言，fmap 的期望行为非常明显。然而由于 Parse 的复杂度，对于它而言 fmap 的期望行为并没有这么明显。一个合理的猜测是我们要 fmap 的函数应该应用到当前解析的结果上，并保持解析状态不变。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>Parse<span class="token">.</span>hs
instance Functor Parse where
    fmap f parser <span class="token3">=</span> parser <span class="token3">==</span><span class="token3">&gt;</span> \result <span class="token3">-</span><span class="token3">&gt;</span>
                    identity <span class="token">(</span>f result<span class="token">)</span>

</code></pre>
<p class="calibre9">定义很容易理解，我们来快速做几个实验看看我们是否遵守了 Functor 规则。</p>
<p class="calibre9">首先我们检查身份是否被保持。我们在一次应该失败的解析上试试：从空字符串中解析字节（别忘了 (&lt;$&gt;) 就是 fmap）。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> parse parseByte L<span class="token">.</span>empty
Left <span class="token4">"byte offset 0: no more input"</span>
ghci<span class="token3">&gt;</span> parse <span class="token">(</span>id <span class="token3">&lt;</span>$<span class="token3">&gt;</span> parseByte<span class="token">)</span> L<span class="token">.</span>empty
Left <span class="token4">"byte offset 0: no more input"</span>

</code></pre>
<p class="calibre9">不错。再来试试应该成功的解析。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> let input <span class="token3">=</span> L8<span class="token">.</span>pack <span class="token4">"foo"</span>
ghci<span class="token3">&gt;</span> L<span class="token">.</span>head input
<span class="token2">102</span>
ghci<span class="token3">&gt;</span> parse parseByte input
Right <span class="token2">102</span>
ghci<span class="token3">&gt;</span> parse <span class="token">(</span>id <span class="token3">&lt;</span>$<span class="token3">&gt;</span> parseByte<span class="token">)</span> input
Right <span class="token2">102</span>

</code></pre>
<p class="calibre9">通过观察上面的结果，可以看到我们的 Functor 实例同样遵守了第二条规则，也就是保持结构。失败被保持为失败，成功被保持为成功。</p>
<p class="calibre9">最后，我们确保可组合性被保持了。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> parse <span class="token">(</span><span class="token">(</span>chr <span class="token">.</span> fromIntegral<span class="token">)</span> <span class="token3">&lt;</span>$<span class="token3">&gt;</span> parseByte<span class="token">)</span> input
Right <span class="token4">'f'</span>
ghci<span class="token3">&gt;</span> parse <span class="token">(</span>chr <span class="token3">&lt;</span>$<span class="token3">&gt;</span> fromIntegral <span class="token3">&lt;</span>$<span class="token3">&gt;</span> parseByte<span class="token">)</span> input
Right <span class="token4">'f'</span>

</code></pre>
<p class="calibre9">通过这个简单的观察，我们的 Functor 实例看起来行为规范。</p>
<h2 class="calibre14"><a id="chp-10.html._Functor__759" class="calibre7 pcalibre"></a>利用 Functor 解析</h2>
<p class="calibre9">我们讨论 Functor 是有目的的：它让我们写出简洁、表达能力强的代码。回想早先引入的 parseByte 函数。在重构 PGM 解析器使之使用新的解析架构的过程中，我们经常想用 ASCII 字符而不是 Word8 值。</p>
<p class="calibre9">尽管可以写一个类似于 parseByte 的 parseChar 函数，我们现在可以利用 Parse 的 Functor 属性来避免重复代码。我们的 functor 接受一个解析结果并将一个函数应用于它，因此我们需要的是一个把 Word8 转成 Char 的函数。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>Parse<span class="token">.</span>hs
w2c <span class="token">:</span><span class="token">:</span> Word8 <span class="token3">-</span><span class="token3">&gt;</span> Char
w2c <span class="token3">=</span> chr <span class="token">.</span> fromIntegral

<span class="token3">--</span> import Control<span class="token">.</span>Applicative
parseChar <span class="token">:</span><span class="token">:</span> Parse Char
parseChar <span class="token3">=</span> w2c <span class="token3">&lt;</span>$<span class="token3">&gt;</span> parseByte

</code></pre>
<p class="calibre9">我们也可以利用 Functor 来写一个短小的“窥视”函数。如果我们在输入字符串的末尾，它会返回 Nothing。否则，它返回下一个字符，但不作处理（也就是说，它观察但不打扰当前的解析状态）。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>Parse<span class="token">.</span>hs
peekByte <span class="token">:</span><span class="token">:</span> Parse <span class="token">(</span>Maybe Word8<span class="token">)</span>
peekByte <span class="token3">=</span> <span class="token">(</span>fmap fst <span class="token">.</span> L<span class="token">.</span>uncons <span class="token">.</span> string<span class="token">)</span> <span class="token3">&lt;</span>$<span class="token3">&gt;</span> getState

</code></pre>
<p class="calibre9">定义 parseChar 时用到的提升把戏同样也可以用于定义 peekChar。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>Parse<span class="token">.</span>hs
peekChar <span class="token">:</span><span class="token">:</span> Parse <span class="token">(</span>Maybe Char<span class="token">)</span>
peekChar <span class="token3">=</span> fmap w2c <span class="token3">&lt;</span>$<span class="token3">&gt;</span> peekByte

</code></pre>
<p class="calibre9">注意到 peekByte 和 peekChar 分别两次调用了 fmap，其中一次还是 (&lt;$&gt;)。这么做的原因是 Parse(Maybea) 类型是嵌在 Functor 中的 Functor。我们必须提升函数两次使它能进入内部 Functor。</p>
<p class="calibre9">最后，我们会写一个通用组合子，它是 Parse 中的 takeWhile：它在谓词为 True 是处理输入。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>Parse<span class="token">.</span>hs
parseWhile <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Word8 <span class="token3">-</span><span class="token3">&gt;</span> Bool<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> Parse <span class="token">[</span>Word8<span class="token">]</span>
parseWhile p <span class="token3">=</span> <span class="token">(</span>fmap p <span class="token3">&lt;</span>$<span class="token3">&gt;</span> peekByte<span class="token">)</span> <span class="token3">==</span><span class="token3">&gt;</span> \mp <span class="token3">-</span><span class="token3">&gt;</span>
               <span class="token1">if</span> mp <span class="token3">==</span> Just True
               then parseByte <span class="token3">==</span><span class="token3">&gt;</span> \b <span class="token3">-</span><span class="token3">&gt;</span>
                    <span class="token">(</span>b<span class="token">:</span><span class="token">)</span> <span class="token3">&lt;</span>$<span class="token3">&gt;</span> parseWhile p
               <span class="token1">else</span> identity <span class="token">[</span><span class="token">]</span>

</code></pre>
<p class="calibre9">再次说明，我们在好几个地方都用到了 Functor（doubled up, when necessary）用以化简函数。下面是相同函数不用 Functor 的版本。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>Parse<span class="token">.</span>hs
parseWhileVerbose p <span class="token3">=</span>
    peekByte <span class="token3">==</span><span class="token3">&gt;</span> \mc <span class="token3">-</span><span class="token3">&gt;</span>
    case mc of
      Nothing <span class="token3">-</span><span class="token3">&gt;</span> identity <span class="token">[</span><span class="token">]</span>
      Just c <span class="token3">|</span> p c <span class="token3">-</span><span class="token3">&gt;</span>
                 parseByte <span class="token3">==</span><span class="token3">&gt;</span> \b <span class="token3">-</span><span class="token3">&gt;</span>
                 parseWhileVerbose p <span class="token3">==</span><span class="token3">&gt;</span> \bs <span class="token3">-</span><span class="token3">&gt;</span>
                 identity <span class="token">(</span>b<span class="token">:</span>bs<span class="token">)</span>
             <span class="token3">|</span> otherwise <span class="token3">-</span><span class="token3">&gt;</span>
                 identity <span class="token">[</span><span class="token">]</span>

</code></pre>
<p class="calibre9">当你对 Functor 不熟悉的时候，冗余的定义应该会更好读。但是，由于 Haskell 中 Functor 非常常见，你很快就会更习惯（包括读和写）简洁的表达。</p>
<h2 class="calibre14"><a id="chp-10.html._PGM__828" class="calibre7 pcalibre"></a>重构 PGM 解析器</h2>
<p class="calibre9">有了新的解析代码，原始 PGM 解析函数现在变成了这个样子：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>Parse<span class="token">.</span>hs
parseRawPGM <span class="token3">=</span>
    parseWhileWith w2c notWhite <span class="token3">==</span><span class="token3">&gt;</span> \header <span class="token3">-</span><span class="token3">&gt;</span> skipSpaces <span class="token3">==</span><span class="token3">&gt;</span><span class="token3">&amp;</span>
    assert <span class="token">(</span>header <span class="token3">==</span> <span class="token4">"P5"</span><span class="token">)</span> <span class="token4">"invalid raw header"</span> <span class="token3">==</span><span class="token3">&gt;</span><span class="token3">&amp;</span>
    parseNat <span class="token3">==</span><span class="token3">&gt;</span> \width <span class="token3">-</span><span class="token3">&gt;</span> skipSpaces <span class="token3">==</span><span class="token3">&gt;</span><span class="token3">&amp;</span>
    parseNat <span class="token3">==</span><span class="token3">&gt;</span> \height <span class="token3">-</span><span class="token3">&gt;</span> skipSpaces <span class="token3">==</span><span class="token3">&gt;</span><span class="token3">&amp;</span>
    parseNat <span class="token3">==</span><span class="token3">&gt;</span> \maxGrey <span class="token3">-</span><span class="token3">&gt;</span>
    parseByte <span class="token3">==</span><span class="token3">&gt;</span><span class="token3">&amp;</span>
    parseBytes <span class="token">(</span>width <span class="token3">*</span> height<span class="token">)</span> <span class="token3">==</span><span class="token3">&gt;</span> \bitmap <span class="token3">-</span><span class="token3">&gt;</span>
    identity <span class="token">(</span>Greymap width height maxGrey bitmap<span class="token">)</span>
  where notWhite <span class="token3">=</span> <span class="token">(</span>`notElem` <span class="token4">" \r\n\t"</span><span class="token">)</span>

</code></pre>
<p class="calibre9">下面是定义中用到的辅助函数，其中一些模式现在应该已经非常熟悉了：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch10<span class="token3">/</span>Parse<span class="token">.</span>hs
parseWhileWith <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Word8 <span class="token3">-</span><span class="token3">&gt;</span> a<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> Bool<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> Parse <span class="token">[</span>a<span class="token">]</span>
parseWhileWith f p <span class="token3">=</span> fmap f <span class="token3">&lt;</span>$<span class="token3">&gt;</span> parseWhile <span class="token">(</span>p <span class="token">.</span> f<span class="token">)</span>

parseNat <span class="token">:</span><span class="token">:</span> Parse Int
parseNat <span class="token3">=</span> parseWhileWith w2c isDigit <span class="token3">==</span><span class="token3">&gt;</span> \digits <span class="token3">-</span><span class="token3">&gt;</span>
           <span class="token1">if</span> <span class="token1">null</span> digits
           then bail <span class="token4">"no more input"</span>
           <span class="token1">else</span> let n <span class="token3">=</span> read digits
                <span class="token1">in</span> <span class="token1">if</span> n <span class="token3">&lt;</span> <span class="token2">0</span>
                   then bail <span class="token4">"integer overflow"</span>
                   <span class="token1">else</span> identity n

<span class="token">(</span><span class="token3">==</span><span class="token3">&gt;</span><span class="token3">&amp;</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> Parse a <span class="token3">-</span><span class="token3">&gt;</span> Parse b <span class="token3">-</span><span class="token3">&gt;</span> Parse b
p <span class="token3">==</span><span class="token3">&gt;</span><span class="token3">&amp;</span> f <span class="token3">=</span> p <span class="token3">==</span><span class="token3">&gt;</span> \_ <span class="token3">-</span><span class="token3">&gt;</span> f

skipSpaces <span class="token">:</span><span class="token">:</span> Parse <span class="token">(</span><span class="token">)</span>
skipSpaces <span class="token3">=</span> parseWhileWith w2c isSpace <span class="token3">==</span><span class="token3">&gt;</span><span class="token3">&amp;</span> identity <span class="token">(</span><span class="token">)</span>

assert <span class="token">:</span><span class="token">:</span> Bool <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> Parse <span class="token">(</span><span class="token">)</span>
assert True  _   <span class="token3">=</span> identity <span class="token">(</span><span class="token">)</span>
assert False err <span class="token3">=</span> bail err

</code></pre>
<p class="calibre9">类似于 (==&gt;)，(==&gt;&amp;) 组合子将解析器串联起来。但右侧忽略左侧的结果。assert 使得我们可以检查性质，然后当性质为 False 时终止解析并报告错误信息。</p>
<h2 class="calibre14"><a id="chp-10.html._877" class="calibre7 pcalibre"></a>未来方向</h2>
<p class="calibre9">本章的主题是抽象。我们发现在函数链中传递显式状态并不理想，因此我们把这个细节抽象出来。在写解析器的时候发现要重复用到一些代码，我们把它们抽象成函数。我们引入了 Functor，它提供了一种映射到参数化类型的通用方法。</p>
<p class="calibre9">关于解析，我们在第16章会讨论一个使用广泛并且灵活的解析库 Parsec。在第14章中，我们会再次讨论抽象，我们会发现用 Monad 可以进一步化简这章的代码。</p>
<p class="calibre9">Hackage 数据库中存在不少包可以用来高效解析以 ByteString 表示的二进制数据。在写作时，最流行的是 binary，它易用且高效。</p>
<h2 class="calibre14"><a id="chp-10.html._885" class="calibre7 pcalibre"></a>练习</h2>
<ol class="calibre17"><li class="calibre11"></li></ol>
<p class="calibre9">给“纯文本” PGM 文件写解析器。</p>
<ol class="calibre17"><li class="calibre11"></li></ol>
<p class="calibre9">在对“原始” PGM 文件的描述中，我们省略了一个细节。如果头信息中的“最大灰度”值小于256，那每个像素都会用单个字节表示。然而，它的最大范围可达65535，这种情况下每个像素会以大端序的形式（最高有效位字节在前）用两个字节来表示。</p>
<p class="calibre9">重写原始 PGM 解析器使它能够处理单字节和双字节形式。</p>
<ol class="calibre17"><li class="calibre11"></li></ol>
<p class="calibre9">重写解析器使得它能够区分“原始”和“纯文本” PGM 文件，并解析对应的文件类型。</p>
</div></div></div></div></div></div>
<div id="chp-11.html"><div class="calibre">
<div id="chp-11.html.main" class="calibre1"><div class="root"><div class="article"><h1 class="article-head" id="chp-11.html.calibre_toc_11">第十一章：测试和质量保障</h1><div class="article-body"><h1 class="calibre6"><a id="chp-11.html._0" class="calibre7 pcalibre"></a>第十一章：测试和质量保障</h1>
<p class="calibre9">构建真实系统意味着我们要关心系统的质量控制，健壮性和正确性。有了正确的质量保障机制，良好编写的代码才能像一架精确的机器一样，所有模块都完成它们预期的任务，并且不会有模棱两可的边界情况。最后我们得到的将是不言自明，正确无疑的代码——这样的代码往往能激发自信。</p>
<p class="calibre9">Haskell 有几个工具用来构建这样精确的系统。最明显的一个，也是语言本身就内置的，是具有强大表达力的类型系统。它使得一些复杂的不变量（invariants）得到了静态保证——绝无可能写出违反这些约束条件的代码。另外，纯度和多态也促进了模块化，易重构，易测试的代码风格。这种类型的代码通常不会出错。</p>
<p class="calibre9">测试在保证代码的正确性上起到了关键作用。Haskell 主要的测试机制是传统的单元测试（通过 HUnit 库）和由它衍生而来的更强机制：使用 Haskell 开源测试框架 QuickCheck 进行的基于类型的“性质”测试。基于性质的测试是一种层次较高的方法，它抽象出一些函数应该普遍满足的不变量，真正的测试数据由测试库为程序员产生。通过这种方法，我们可以用成百上千的测试来检验代码，从而发现一些用其他方法无法发现的微妙的边角情形(corner cases)，而这对于手写来说是不可能的。</p>
<p class="calibre9">在这章里，我们将会学习如何使用 QuickCheck 来建立不变量，然后重新审视之前章节开发的美观打印器，并用 QuickCheck 对它进行测试。我们也会学习如何用 GHC 的内置代码覆盖工具 HPC 来指导测试过程。</p>
<h2 class="calibre14"><a id="chp-11.html.QuickCheck__10" class="calibre7 pcalibre"></a>QuickCheck: 基于类型的测试</h2>
<p class="calibre9">为了大概了解基于性质的测试是如何工作的，我们从一个简单的情形开始：你写了一个排序算法，需要测试它的行为。</p>
<p class="calibre9">首先我们载入 QuickCheck 库和其它依赖模块：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>QC<span class="token3">-</span>basics<span class="token">.</span>hs
import Test<span class="token">.</span>QuickCheck
import Data<span class="token">.</span>List

</code></pre>
<p class="calibre9">然后是我们想要测试的函数——一个自定义的排序过程:</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>QC<span class="token3">-</span>basics<span class="token">.</span>hs
qsort <span class="token">:</span><span class="token">:</span> Ord a <span class="token3">=</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span>
qsort <span class="token">[</span><span class="token">]</span>     <span class="token3">=</span> <span class="token">[</span><span class="token">]</span>
qsort <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span> qsort lhs <span class="token3">++</span> <span class="token">[</span>x<span class="token">]</span> <span class="token3">++</span> qsort rhs
    where lhs <span class="token3">=</span> filter  <span class="token">(</span><span class="token3">&lt;</span> x<span class="token">)</span> xs
          rhs <span class="token3">=</span> filter <span class="token">(</span><span class="token3">&gt;=</span> x<span class="token">)</span> xs

</code></pre>
<p class="calibre9">这是一个经典的 Haskell 排序实现：它可能不够高效（因为不是原地排序），但它至少展示了函数式编程的优雅。现在，我们来检查这个函数是否符合一个好排序算法应该符合的基本规则。很多纯函数式代码都有的一个很有用的不变量是<em class="calibre13">幂等</em>（idempotency）——应用一个函数两次和一次效果应该相同。对于我们的排序过程，一个稳定的排序算法，这当然应该满足，否则就真的出大错了！这个不变量可以简单地表示为如下性质：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>QC<span class="token3">-</span>basics<span class="token">.</span>hs
prop_idempotent xs <span class="token3">=</span> qsort <span class="token">(</span>qsort xs<span class="token">)</span> <span class="token3">==</span> qsort xs

</code></pre>
<p class="calibre9">依照 QuickCheck 的惯例，我们给测试性质加上 prop_ 前缀以和普通代码区分。幂等性质可以简单地用一个 Haskell 函数表示：对于任何已排序输入，再次应用 qsort 结果必须相同。我们可以手动写几个例子来确保没什么问题：</p>
<p class="calibre9">[译注，运行之前需要确保自己安装了 QuickCheck 包，译者使用的版本是2.8.1。]</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> prop_idempotent <span class="token">[</span><span class="token">]</span>
True
ghci<span class="token3">&gt;</span> prop_idempotent <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">1</span><span class="token">,</span><span class="token2">1</span><span class="token">,</span><span class="token2">1</span><span class="token">]</span>
True
ghci<span class="token3">&gt;</span> prop_idempotent <span class="token">[</span><span class="token2">1.</span><span class="token2">.100</span><span class="token">]</span>
True
ghci<span class="token3">&gt;</span> prop_idempotent <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">0</span><span class="token">,</span><span class="token2">9</span><span class="token">]</span>
True

</code></pre>
<p class="calibre9">看起来不错。但是，用手写输入数据非常无趣，并且违反了一个高效函数式程序员的道德法则：让机器干活！为了使这个过程自动化，QuickCheck 内置了一组数据生成器用来生成 Haskell 所有的基本数据类型。QuickCheck 使用 Arbitrary 类型类来给（伪）随机数据生成过程提供了一个统一接口，类型系统会具体决定使用哪个生成器。QuickCheck 通常会把数据生成过程隐藏起来，但我们可以手动运行生成器来看看 QuickCheck 生成的数据呈什么分布。例如，随机生成一组布尔值：</p>
<p class="calibre9">[译注：本例子根据最新版本的 QuickCheck 库做了改动。]</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude Test<span class="token">.</span>QuickCheck<span class="token">.</span>Gen Test<span class="token">.</span>QuickCheck<span class="token">.</span>Arbitrary<span class="token3">&gt;</span> sample' arbitrary <span class="token">:</span><span class="token">:</span> IO <span class="token">[</span>Bool<span class="token">]</span>
<span class="token">[</span>False<span class="token">,</span>False<span class="token">,</span>False<span class="token">,</span>True<span class="token">,</span>False<span class="token">,</span>False<span class="token">,</span>True<span class="token">,</span>True<span class="token">,</span>True<span class="token">,</span>True<span class="token">,</span>True<span class="token">]</span>

</code></pre>
<p class="calibre9">QuickCheck 用这种方法产生测试数据，然后通过 quickCheck 函数把数据传给我们要测试的性质。性质本身的类型决定了它使用哪个数据生成器。quickCheck 确保对于所有产生的测试数据，性质仍然成立。由于幂等测试对于列表元素类型是多态的，我们需要选择一个特定的类型来产生测试数据，我们把它作为一个类型约束写在性质上。运行测试的时候，只需调用 quickCheck 函数，并指定我们性质函数的类型即可（否则的话，列表值将会是没什么意思的 () 类型）：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main Test<span class="token">.</span>QuickCheck<span class="token3">&gt;</span> <span class="token">:</span>type quickCheck
quickCheck <span class="token">:</span><span class="token">:</span> Testable prop <span class="token3">=</span><span class="token3">&gt;</span> prop <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
<span class="token3">*</span>Main Test<span class="token">.</span>QuickCheck<span class="token3">&gt;</span> quickCheck <span class="token">(</span>prop_idempotent <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Integer<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Bool<span class="token">)</span>
<span class="token3">++</span><span class="token3">+</span> OK<span class="token">,</span> passed <span class="token2">100</span> tests<span class="token">.</span>

</code></pre>
<p class="calibre9">对于产生的100个不同列表，我们的性质都成立——太棒了！编写测试的时候，查看为每个测试生成的实际数据常常会很有用。我们可以把 quickCheck 替换为它的兄弟函数 verboseCheck 来查看每个测试的（完整）输出。现在，来看看我们的函数还可能满足什么更复杂的性质。</p>
<h2 class="calibre14"><a id="chp-11.html._81" class="calibre7 pcalibre"></a>性质测试</h2>
<p class="calibre9">好的库通常都会包含一组彼此正交而又关联的基本函数。我们可以使用 QuickCheck 来指定我们代码中函数之间的关系，从而通过一组通过有用性质相互关联的函数来提供一个好的库接口。从这个角度来说，QuickCheck 扮演了 API “lint” 工具的角色：它确保我们的库 API 能说的通。</p>
<p class="calibre9">列表排序函数的一些有趣性质把它和其它列表操作关联起来。例如：已排序列表的第一个元素应该是输入列表的最小元素。我们可以使用 List 库的 minimum 函数来指出这个性质：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>QC<span class="token3">-</span>basics<span class="token">.</span>hs
import Data<span class="token">.</span>List
prop_minimum xs         <span class="token3">=</span> head <span class="token">(</span>qsort xs<span class="token">)</span> <span class="token3">==</span> minimum xs

</code></pre>
<p class="calibre9">测试的时候出错了：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main Test<span class="token">.</span>QuickCheck<span class="token3">&gt;</span> quickCheck <span class="token">(</span>prop_minimum <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Integer<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Bool<span class="token">)</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Failed<span class="token3">!</span> Exception<span class="token">:</span> <span class="token4">'Prelude.head: empty list'</span> <span class="token">(</span>after <span class="token2">1</span> test<span class="token">)</span><span class="token">:</span>
<span class="token">[</span><span class="token">]</span>

</code></pre>
<p class="calibre9">当对一个空列表排序时性质不满足了：对于空列表而言，head 和 minimum 没有定义，正如它们的定义所示：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>minimum<span class="token">.</span>hs
head       <span class="token">:</span><span class="token">:</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> a
head <span class="token">(</span>x<span class="token">:</span>_<span class="token">)</span> <span class="token3">=</span> x
head <span class="token">[</span><span class="token">]</span>    <span class="token3">=</span> error <span class="token4">"Prelude.head: empty list"</span>

minimum    <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Ord a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> a
minimum <span class="token">[</span><span class="token">]</span> <span class="token3">=</span>  error <span class="token4">"Prelude.minimum: empty list"</span>
minimum xs <span class="token3">=</span>  foldl1 min xs

</code></pre>
<p class="calibre9">因此这个性质只在非空列表上满足。幸运的是，QuickCheck 内置了一套完整的性质编写语言，使我们可以更精确地表述我们的不变量，排除那些我们不予考虑的值。对于空列表这个例子，我们可以这么说：<em class="calibre13">如果</em>列表非空，<em class="calibre13">那么</em>被排序列表的第一个元素是最小值。这是通过 (==&gt;) 函数来实现的，它在测试性质之前将无效数据排除在外：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>QC<span class="token3">-</span>basics<span class="token">.</span>hs
prop_minimum' xs         <span class="token3">=</span> not <span class="token">(</span><span class="token1">null</span> xs<span class="token">)</span> <span class="token3">==</span><span class="token3">&gt;</span> head <span class="token">(</span>qsort xs<span class="token">)</span> <span class="token3">==</span> minimum xs

</code></pre>
<p class="calibre9">结果非常清楚。通过把空列表排除在外，我们可以确定指定性质是成立的。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main Test<span class="token">.</span>QuickCheck<span class="token3">&gt;</span> quickCheck <span class="token">(</span>prop_minimum' <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Integer<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Property<span class="token">)</span>
<span class="token3">++</span><span class="token3">+</span> OK<span class="token">,</span> passed <span class="token2">100</span> tests<span class="token">.</span>

</code></pre>
<p class="calibre9">注意到我们把性质的类型从 Bool 改成了更一般的 Property 类型（property 函数会在测试之前过滤出非空列表，而不仅是简单地返回一个布尔常量了）。</p>
<p class="calibre9">再加上其它一些应该满足的不变量，我们就可以完成排序函数的基本性质集了：输出应该有序（每个元素应该小于等于它的后继元素）；输出是输入的排列（我们通过列表差异函数 (\) 来检测）；被排序列表的最后一个元素应该是最大值；对于两个不同列表的最小值，如果我们把两个列表拼接并排序，这个值应该是第一个元素。这些性质可以表述如下：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>QC<span class="token3">-</span>basics<span class="token">.</span>hs
prop_ordered xs <span class="token3">=</span> ordered <span class="token">(</span>qsort xs<span class="token">)</span>
    where ordered <span class="token">[</span><span class="token">]</span>       <span class="token3">=</span> True
          ordered <span class="token">[</span>x<span class="token">]</span>      <span class="token3">=</span> True
          ordered <span class="token">(</span>x<span class="token">:</span>y<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span> x <span class="token3">&lt;=</span> y <span class="token3">&amp;&amp;</span> ordered <span class="token">(</span>y<span class="token">:</span>xs<span class="token">)</span>

prop_permutation xs <span class="token3">=</span> permutation xs <span class="token">(</span>qsort xs<span class="token">)</span>
    where permutation xs ys <span class="token3">=</span> <span class="token1">null</span> <span class="token">(</span>xs \\ ys<span class="token">)</span> <span class="token3">&amp;&amp;</span> <span class="token1">null</span> <span class="token">(</span>ys \\ xs<span class="token">)</span>

prop_maximum xs         <span class="token3">=</span>
    not <span class="token">(</span><span class="token1">null</span> xs<span class="token">)</span> <span class="token3">==</span><span class="token3">&gt;</span>
        last <span class="token">(</span>qsort xs<span class="token">)</span> <span class="token3">==</span> maximum xs

prop_append xs ys       <span class="token3">=</span>
    not <span class="token">(</span><span class="token1">null</span> xs<span class="token">)</span> <span class="token3">==</span><span class="token3">&gt;</span>
    not <span class="token">(</span><span class="token1">null</span> ys<span class="token">)</span> <span class="token3">==</span><span class="token3">&gt;</span>
        head <span class="token">(</span>qsort <span class="token">(</span>xs <span class="token3">++</span> ys<span class="token">)</span><span class="token">)</span> <span class="token3">==</span> min <span class="token">(</span>minimum xs<span class="token">)</span> <span class="token">(</span>minimum ys<span class="token">)</span>

</code></pre>
<h2 class="calibre14"><a id="chp-11.html._156" class="calibre7 pcalibre"></a>利用模型进行测试</h2>
<p class="calibre9">另一种增加代码可信度的技术是利用模型实现进行测试。我们可以把我们的列表排序函数跟标准列表库中的排序实现进行对比。如果它们行为相同，我们会有更多信心我们的代码的正确的。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>QC<span class="token3">-</span>basics<span class="token">.</span>hs
prop_sort_model xs      <span class="token3">=</span> sort xs <span class="token3">==</span> qsort xs

</code></pre>
<p class="calibre9">这种基于模型的测试非常强大。开发人员经常会有一些正确但低效的参考实现或原型。他们可以保留这部分代码来确保优化之后的生产代码仍具有相同行为。通过构建大量这样的测试并定期运行（例如每次提交），我们可以很容易地确保代码仍然正确。大型的 Haskell 项目通常包含了跟项目本身大小可比的性质测试集，每次代码改变都会进行成千上万项不变量测试，保证了代码行为跟预期一致。</p>
<h2 class="calibre14"><a id="chp-11.html._168" class="calibre7 pcalibre"></a>测试案例学习：美观打印器</h2>
<p class="calibre9">测试单个函数的自然性质是开发大型 Haskell 系统的基石。我们现在来看一个更复杂的案例：为第五章开发的美观打印器编写测试集。</p>
<h2 class="calibre14"><a id="chp-11.html._172" class="calibre7 pcalibre"></a>生成测试数据</h2>
<p class="calibre9">美观打印器是围绕 Doc 而建的，它是一个代数数据类型，表示格式良好的文档。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>Prettify2<span class="token">.</span>hs

data Doc <span class="token3">=</span> Empty
         <span class="token3">|</span> Char Char
         <span class="token3">|</span> Text String
         <span class="token3">|</span> Line
         <span class="token3">|</span> Concat Doc Doc
         <span class="token3">|</span> Union Doc Doc
         deriving <span class="token">(</span>Show<span class="token">,</span>Eq<span class="token">)</span>

</code></pre>
<p class="calibre9">这个库本身是由一组函数构成的，这些函数负责构建和变换 Doc 类型的值，最后再把它们转换成字符串。</p>
<p class="calibre9">QuickCheck 鼓励这样一种测试方式：开发人员指定一些不变量，它们对于任何代码接受的输入都成立。为了测试美观打印库，我们首先需要一个输入数据源。我们可以利用 QuickCheck 通过 Arbitrary 类型类提供的一套用来生成随机数据的组合子集。Arbitrary 类型类提供了 arbitrary 函数来给每种类型生成数据，我们可以利用它来给自定义数据类型写数据生成器。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>Arbitrary<span class="token">.</span>hs
import Test<span class="token">.</span>QuickCheck<span class="token">.</span>Arbitrary
import Test<span class="token">.</span>QuickCheck<span class="token">.</span>Gen
class <span class="token5">Arbitrary</span> a where
    arbitrary   <span class="token">:</span><span class="token">:</span> Gen a

</code></pre>
<p class="calibre9">有一点需要注意，函数的类型签名表明生成器运行在 Gen 环境中。它是一个简单的状态传递 monad，用来隐藏贯穿于代码中的随机数字生成器的状态。稍后的章节会更加细致地研究 monads，现在只要知道，由于 Gen 被定义为一个 monad，我们可以使用 do 语法来定义新生成器来访问隐式的随机数字源。Arbitrary 类型类提供了一组可以生成随机值的函数，我们可以把它们组合起来构建出我们所关心的类型的数据结构，以便给我们的自定义类型写生成器。一些关键函数的类型如下：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>Arbitrary<span class="token">.</span>hs
    elements <span class="token">:</span><span class="token">:</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Gen a
    choose   <span class="token">:</span><span class="token">:</span> Random a <span class="token3">=</span><span class="token3">&gt;</span> <span class="token">(</span>a<span class="token">,</span> a<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> Gen a
    oneof    <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Gen a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Gen a

</code></pre>
<p class="calibre9">elements 函数接受一个列表，返回这个列表的随机值生成器。我们稍后再用 choose 和 oneof。有了 elements，我们就可以开始给一些简单的数据类型写生成器了。例如，如果我们给三元逻辑定义了一个新数据类型：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>Arbitrary<span class="token">.</span>hs
data Ternary
    <span class="token3">=</span> Yes
    <span class="token3">|</span> No
    <span class="token3">|</span> Unknown
    deriving <span class="token">(</span>Eq<span class="token">,</span>Show<span class="token">)</span>

</code></pre>
<p class="calibre9">我们可以给 Ternary 类型实现 Arbitrary 实例：只要实现 arbitrary 即可，它从所有可能的 Ternary 类型值中随机选出一些来：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>Arbitrary<span class="token">.</span>hs
instance Arbitrary Ternary where
    arbitrary     <span class="token3">=</span> elements <span class="token">[</span>Yes<span class="token">,</span> No<span class="token">,</span> Unknown<span class="token">]</span>

</code></pre>
<p class="calibre9">另一种生成数据的方案是生成 Haskell 基本类型数据，然后把它们映射成我们感兴趣的类型。在写 Ternary 实例的时候，我们可以用 choose 生成0到2的整数值，然后把它们映射为 Ternary 值。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>Arbitrary2<span class="token">.</span>hs
instance Arbitrary Ternary where
    arbitrary     <span class="token3">=</span> <span class="token1">do</span>
        n <span class="token3">&lt;</span><span class="token3">-</span> choose <span class="token">(</span><span class="token2">0</span><span class="token">,</span> <span class="token2">2</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> Gen Int
        <span class="token1">return</span> $ case n of
                      <span class="token2">0</span> <span class="token3">-</span><span class="token3">&gt;</span> Yes
                      <span class="token2">1</span> <span class="token3">-</span><span class="token3">&gt;</span> No
                      _ <span class="token3">-</span><span class="token3">&gt;</span> Unknown

</code></pre>
<p class="calibre9">对于简单的<em class="calibre13">和</em>类型，这种方法非常奏效，因为整数可以很好地映射到数据类型的构造器上。对于<em class="calibre13">积</em>类型(如结构体和元组)，我们首先得把积的不同部分分别生成（对于嵌套类型递归地生成），然后再把他们组合起来。例如，生成随机序对：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>Arbitrary<span class="token">.</span>hs
instance <span class="token">(</span>Arbitrary a<span class="token">,</span> Arbitrary b<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> Arbitrary <span class="token">(</span>a<span class="token">,</span> b<span class="token">)</span> where
    arbitrary <span class="token3">=</span> <span class="token1">do</span>
        x <span class="token3">&lt;</span><span class="token3">-</span> arbitrary
        y <span class="token3">&lt;</span><span class="token3">-</span> arbitrary
        <span class="token1">return</span> <span class="token">(</span>x<span class="token">,</span> y<span class="token">)</span>

</code></pre>
<p class="calibre9">现在我们写个生成器来生成 Doc 类型所有不同的变种。我们把问题分解，首先先随机生成一个构造器，然后根据结果再随机生成参数。最复杂的是 union 和 concatenation 这两种情形。</p>
<p class="calibre9">[译注，作者在此处解释并实现了 Char 的 Arbitrary 实例。但由于最新 QuickCheck 已经包含此实例，故此处略去相关内容。]</p>
<p class="calibre9">现在我们可以开始给 Doc 写实例了。只要枚举构造器，再把参数填进去即可。我们用一个随机整数来表示生成哪种形式的 Doc，然后再根据结果分派。生成 concat 和 union 的 Doc 值时，我们只需要递归调用 arbitrary 即可，类型推导会决定使用哪个 Arbitrary 实例：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>QC<span class="token">.</span>hs
instance Arbitrary Doc where
    arbitrary <span class="token3">=</span> <span class="token1">do</span>
        n <span class="token3">&lt;</span><span class="token3">-</span> choose <span class="token">(</span><span class="token2">1</span><span class="token">,</span><span class="token2">6</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> Gen Int
        case n of
             <span class="token2">1</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> Empty

             <span class="token2">2</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">do</span> x <span class="token3">&lt;</span><span class="token3">-</span> arbitrary
                     <span class="token1">return</span> <span class="token">(</span>Char x<span class="token">)</span>

             <span class="token2">3</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">do</span> x <span class="token3">&lt;</span><span class="token3">-</span> arbitrary
                     <span class="token1">return</span> <span class="token">(</span>Text x<span class="token">)</span>

             <span class="token2">4</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> Line

             <span class="token2">5</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">do</span> x <span class="token3">&lt;</span><span class="token3">-</span> arbitrary
                     y <span class="token3">&lt;</span><span class="token3">-</span> arbitrary
                     <span class="token1">return</span> <span class="token">(</span>Concat x y<span class="token">)</span>

             <span class="token2">6</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">do</span> x <span class="token3">&lt;</span><span class="token3">-</span> arbitrary
                     y <span class="token3">&lt;</span><span class="token3">-</span> arbitrary
                     <span class="token1">return</span> <span class="token">(</span>Union x y<span class="token">)</span>

</code></pre>
<p class="calibre9">看起来很直观。我们可以用 oneof 函数来化简它。我们之前见到过 oneof 的类型，它从列表中选择一个生成器（我们也可以用 monadic 组合子 liftM 来避免命名中间结果）：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>QC<span class="token">.</span>hs
instance Arbitrary Doc where
    arbitrary <span class="token3">=</span>
        oneof <span class="token">[</span> <span class="token1">return</span> Empty
              <span class="token">,</span> liftM  Char   arbitrary
              <span class="token">,</span> liftM  Text   arbitrary
              <span class="token">,</span> <span class="token1">return</span> Line
              <span class="token">,</span> liftM2 Concat arbitrary arbitrary
              <span class="token">,</span> liftM2 Union  arbitrary arbitrary <span class="token">]</span>

</code></pre>
<p class="calibre9">后者更简洁。我们可以试着生成一些随机文档，确保没什么问题。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>QC Test<span class="token">.</span>QuickCheck<span class="token3">&gt;</span> sample' <span class="token">(</span>arbitrary<span class="token">:</span><span class="token">:</span>Gen Doc<span class="token">)</span>
<span class="token">[</span>Text <span class="token4">""</span><span class="token">,</span>Concat <span class="token">(</span>Char <span class="token4">'\157'</span><span class="token">)</span> Line<span class="token">,</span>Char <span class="token4">'\NAK'</span><span class="token">,</span>Concat <span class="token">(</span>Text <span class="token4">"A\b"</span><span class="token">)</span> Empty<span class="token">,</span>
Union Empty <span class="token">(</span>Text <span class="token4">"4\146~\210"</span><span class="token">)</span><span class="token">,</span>Line<span class="token">,</span>Union Line Line<span class="token">,</span>
Concat Empty <span class="token">(</span>Text <span class="token4">"|m  \DC4-\DLE*3\DC3\186"</span><span class="token">)</span><span class="token">,</span>Char <span class="token4">'-'</span><span class="token">,</span>
Union <span class="token">(</span>Union Line <span class="token">(</span>Text <span class="token4">"T\141\167\&amp;3\233\163\&amp;5\STX\164\145zI"</span><span class="token">)</span><span class="token">)</span> <span class="token">(</span>Char <span class="token4">'~'</span><span class="token">)</span><span class="token">,</span>Line<span class="token">]</span>

</code></pre>
<p class="calibre9">从输出的结果里，我们既看到了简单，基本的文档，也看到了相对复杂的嵌套文档。每次测试时我们都会随机生成成百上千的随机文档，他们应该可以很好地覆盖各种情形。现在我们可以开始给我们的文档函数写一些通用性质了。</p>
<h2 class="calibre14"><a id="chp-11.html._319" class="calibre7 pcalibre"></a>测试文档构建</h2>
<p class="calibre9">文档有两个基本函数：一个是空文档常量 Empty，另一个是拼接函数。它们的类型是：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>Prettify2<span class="token">.</span>hs
empty <span class="token">:</span><span class="token">:</span> Doc
<span class="token">(</span><span class="token3">&lt;</span><span class="token3">&gt;</span><span class="token">)</span>  <span class="token">:</span><span class="token">:</span> Doc <span class="token3">-</span><span class="token3">&gt;</span> Doc <span class="token3">-</span><span class="token3">&gt;</span> Doc

</code></pre>
<p class="calibre9">两个函数合起来有一个不错的性质：将空列表拼接在（无论是左拼接还是右拼接）另一个列表上，这个列表保持不变。我们可以将这个不变量表述为如下性质：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>QC<span class="token">.</span>hs
prop_empty_id x <span class="token3">=</span>
    empty <span class="token3">&lt;</span><span class="token3">&gt;</span> x <span class="token3">==</span> x
  <span class="token3">&amp;&amp;</span>
    x <span class="token3">&lt;</span><span class="token3">&gt;</span> empty <span class="token3">==</span> x

</code></pre>
<p class="calibre9">运行测试，确保性质成立：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>QC Test<span class="token">.</span>QuickCheck<span class="token3">&gt;</span> quickCheck prop_empty_id
<span class="token3">++</span><span class="token3">+</span> OK<span class="token">,</span> passed <span class="token2">100</span> tests<span class="token">.</span>

</code></pre>
<p class="calibre9">可以把 quickCheck 替换成 verboseCheck 来看看实际测试时用的是哪些文档。从输出可以看到，简单和复杂的情形都覆盖到了。如果需要的话，我们还可以进一步优化数据生成器来控制不同类型数据的比例。</p>
<p class="calibre9">其它 API 函数也很简单，可以用性质来完全描述它们的行为。这样做使得我们可以对函数的行为维护一个外部的，可检查的描述以确保之后的修改不会破坏这些基本不变量：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>QC<span class="token">.</span>hs

prop_char c   <span class="token3">=</span> char c   <span class="token3">==</span> Char c

prop_text s   <span class="token3">=</span> text s   <span class="token3">==</span> <span class="token1">if</span> <span class="token1">null</span> s then Empty <span class="token1">else</span> Text s

prop_line     <span class="token3">=</span> line     <span class="token3">==</span> Line

prop_double d <span class="token3">=</span> double d <span class="token3">==</span> text <span class="token">(</span>show d<span class="token">)</span>

</code></pre>
<p class="calibre9">这些性质足以测试基本的文档结构了。测试库的剩余部分还要更多工作。</p>
<h2 class="calibre14"><a id="chp-11.html._368" class="calibre7 pcalibre"></a>以列表为模型</h2>
<p class="calibre9">高阶函数是可复用编程的基本胶水，我们的美观打印库也不例外——我们自定义了 fold 函数，用来在内部实现文档拼接和在文档块之间加分隔符。fold 函数接受一个文档列表，并借助一个合并方程（combining function）把它们粘合在一起。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>Prettify2<span class="token">.</span>hs
fold <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Doc <span class="token3">-</span><span class="token3">&gt;</span> Doc <span class="token3">-</span><span class="token3">&gt;</span> Doc<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>Doc<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Doc
fold f <span class="token3">=</span> foldr f empty

</code></pre>
<p class="calibre9">我们可以很容易地给某个特定 fold 实例写测试。例如，横向拼接（Horizontal concatenation）就可以简单地利用列表中的参考实现来测试。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>QC<span class="token">.</span>hs

prop_hcat xs <span class="token3">=</span> hcat xs <span class="token3">==</span> glue xs
    where
        glue <span class="token">[</span><span class="token">]</span>     <span class="token3">=</span> empty
        glue <span class="token">(</span>d<span class="token">:</span>ds<span class="token">)</span> <span class="token3">=</span> d <span class="token3">&lt;</span><span class="token3">&gt;</span> glue ds

</code></pre>
<p class="calibre9">punctuate 也类似，插入标点类似于列表的 interspersion 操作（intersperse 这个函数来自于 Data.List，它把一个元素插在列表元素之间）：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>QC<span class="token">.</span>hs

prop_punctuate s xs <span class="token3">=</span> punctuate s xs <span class="token3">==</span> intersperse s xs

</code></pre>
<p class="calibre9">看起来不错，运行起来却出了问题：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>QC Test<span class="token">.</span>QuickCheck<span class="token3">&gt;</span> quickCheck prop_punctuate
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Failed<span class="token3">!</span> Falsifiable <span class="token">(</span>after <span class="token2">5</span> tests and <span class="token2">1</span> shrink<span class="token">)</span><span class="token">:</span>
Empty
<span class="token">[</span>Text <span class="token4">""</span><span class="token">,</span>Text <span class="token4">"E"</span><span class="token">]</span>

</code></pre>
<p class="calibre9">美观打印库优化了冗余的空文档，然而模型实现却没有，所以我们得让模型匹配实际情况。首先，我们可以把分隔符插入文档，然后再用一个循环去掉当中的 Empty 文档，就像这样：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>QC<span class="token">.</span>hs
prop_punctuate' s xs <span class="token3">=</span> punctuate s xs <span class="token3">==</span> combine <span class="token">(</span>intersperse s xs<span class="token">)</span>
    where
        combine <span class="token">[</span><span class="token">]</span>           <span class="token3">=</span> <span class="token">[</span><span class="token">]</span>
        combine <span class="token">[</span>x<span class="token">]</span>          <span class="token3">=</span> <span class="token">[</span>x<span class="token">]</span>

        combine <span class="token">(</span>x<span class="token">:</span>Empty<span class="token">:</span>ys<span class="token">)</span> <span class="token3">=</span> x <span class="token">:</span> combine ys
        combine <span class="token">(</span>Empty<span class="token">:</span>y<span class="token">:</span>ys<span class="token">)</span> <span class="token3">=</span> y <span class="token">:</span> combine ys
        combine <span class="token">(</span>x<span class="token">:</span>y<span class="token">:</span>ys<span class="token">)</span>     <span class="token3">=</span> x `Concat` y <span class="token">:</span> combine ys

</code></pre>
<p class="calibre9">在 <strong class="calibre12">ghci</strong> 里运行，确保结果是正确的。测试框架发现代码中的错误让人感到欣慰——因为这正是我们追求的。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>QC Test<span class="token">.</span>QuickCheck<span class="token3">&gt;</span> quickCheck prop_punctuate'
<span class="token3">++</span><span class="token3">+</span> OK<span class="token">,</span> passed <span class="token2">100</span> tests<span class="token">.</span>

</code></pre>
<h2 class="calibre14"><a id="chp-11.html._433" class="calibre7 pcalibre"></a>完成测试框架</h2>
<p class="calibre9">[译注：为了匹配最新版本的 QuickCheck，本节在原文基础上做了较大改动。读者可自行参考原文，对比阅读。]</p>
<p class="calibre9">我们可以把这些测试单独放在一个文件中，然后用 QuickCheck 的驱动函数运行它们。这样的函数有很多，包括一些复杂的并行驱动函数。我们在这里使用 quickCheckWithResult 函数。我们只需提供一些测试参数，然后列出我们想要测试的函数即可：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>Run<span class="token">.</span>hs
module Main where
import QC
import Test<span class="token">.</span>QuickCheck

anal <span class="token">:</span><span class="token">:</span> Args
anal <span class="token3">=</span> Args
    <span class="token">{</span> replay <span class="token3">=</span> Nothing
    <span class="token">,</span> maxSuccess <span class="token3">=</span> <span class="token2">1000</span>
    <span class="token">,</span> maxDiscardRatio <span class="token3">=</span> <span class="token2">1</span>
    <span class="token">,</span> maxSize <span class="token3">=</span> <span class="token2">1000</span>
    <span class="token">,</span> chatty <span class="token3">=</span> True
    <span class="token">}</span>

minimal <span class="token">:</span><span class="token">:</span> Args
minimal <span class="token3">=</span> Args
    <span class="token">{</span> replay <span class="token3">=</span> Nothing
    <span class="token">,</span> maxSuccess <span class="token3">=</span> <span class="token2">200</span>
    <span class="token">,</span> maxDiscardRatio <span class="token3">=</span> <span class="token2">1</span>
    <span class="token">,</span> maxSize <span class="token3">=</span> <span class="token2">200</span>
    <span class="token">,</span> chatty <span class="token3">=</span> True
    <span class="token">}</span>

runTests <span class="token">:</span><span class="token">:</span> Args <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
runTests args <span class="token3">=</span> <span class="token1">do</span>
    f prop_empty_id <span class="token4">"empty_id ok?"</span>
    f prop_char <span class="token4">"char ok?"</span>
    f prop_text <span class="token4">"text ok?"</span>
    f prop_line <span class="token4">"line ok?"</span>
    f prop_double <span class="token4">"double ok?"</span>
    f prop_hcat <span class="token4">"hcat ok?"</span>
    f prop_punctuate' <span class="token4">"punctuate ok?"</span>
    where
        f prop str <span class="token3">=</span> <span class="token1">do</span>
            putStrLn str
            quickCheckWithResult args prop
            <span class="token1">return</span> <span class="token">(</span><span class="token">)</span>

main <span class="token">:</span><span class="token">:</span> IO <span class="token">(</span><span class="token">)</span>
main <span class="token3">=</span> <span class="token1">do</span>
    putStrLn <span class="token4">"Choose test depth"</span>
    putStrLn <span class="token4">"1. Anal"</span>
    putStrLn <span class="token4">"2. Minimal"</span>
    depth <span class="token3">&lt;</span><span class="token3">-</span> readLn
    <span class="token1">if</span> depth <span class="token3">==</span> <span class="token2">1</span>
        then runTests anal
    <span class="token1">else</span> runTests minimal

</code></pre>
<p class="calibre9">[译注：此代码出处为原文下Charlie Harvey的评论。]</p>
<p class="calibre9">我们把这些代码放在一个单独的脚本中，声明的实例和性质也有自己单独的文件，它们库的源文件完全分开。这在库项目中非常常见，通常在这些项目中测试都会和库本身分开，测试通过模块系统载入库。</p>
<p class="calibre9">这时候可以编译并运行测试脚本了：</p>
<pre class="calibre15"><code class="tthhighlight-container">$ ghc <span class="token3">--</span>make Run<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">3</span><span class="token">]</span> Compiling Prettify2        <span class="token">(</span> Prettify2<span class="token">.</span>hs<span class="token">,</span> Prettify2<span class="token">.</span>o <span class="token">)</span>
<span class="token">[</span><span class="token2">2</span> of <span class="token2">3</span><span class="token">]</span> Compiling QC               <span class="token">(</span> QC<span class="token">.</span>hs<span class="token">,</span> QC<span class="token">.</span>o <span class="token">)</span>
<span class="token">[</span><span class="token2">3</span> of <span class="token2">3</span><span class="token">]</span> Compiling Main             <span class="token">(</span> Run<span class="token">.</span>hs<span class="token">,</span> Run<span class="token">.</span>o <span class="token">)</span>
Linking Run <span class="token">.</span><span class="token">.</span><span class="token">.</span>
$ <span class="token">.</span><span class="token3">/</span>Run
Choose test depth
<span class="token2">1.</span> Anal
<span class="token2">2.</span> Minimal
<span class="token2">2</span>
empty_id ok<span class="token3">?</span>
<span class="token3">++</span><span class="token3">+</span> OK<span class="token">,</span> passed <span class="token2">200</span> tests<span class="token">.</span>
char ok<span class="token3">?</span>
<span class="token3">++</span><span class="token3">+</span> OK<span class="token">,</span> passed <span class="token2">200</span> tests<span class="token">.</span>
text ok<span class="token3">?</span>
<span class="token3">++</span><span class="token3">+</span> OK<span class="token">,</span> passed <span class="token2">200</span> tests<span class="token">.</span>
line ok<span class="token3">?</span>
<span class="token3">++</span><span class="token3">+</span> OK<span class="token">,</span> passed <span class="token2">1</span> tests<span class="token">.</span>
double ok<span class="token3">?</span>
<span class="token3">++</span><span class="token3">+</span> OK<span class="token">,</span> passed <span class="token2">200</span> tests<span class="token">.</span>
hcat ok<span class="token3">?</span>
<span class="token3">++</span><span class="token3">+</span> OK<span class="token">,</span> passed <span class="token2">200</span> tests<span class="token">.</span>
punctuate ok<span class="token3">?</span>
<span class="token3">++</span><span class="token3">+</span> OK<span class="token">,</span> passed <span class="token2">200</span> tests<span class="token">.</span>

</code></pre>
<p class="calibre9">一共产生了1201个测试，很不错。增加测试深度很容易，但为了了解代码究竟被测试的怎样，我们应该使用内置的代码覆盖率工具 HPC，它可以精确地告诉我们发生了什么。</p>
<h2 class="calibre14"><a id="chp-11.html._HPC__526" class="calibre7 pcalibre"></a>用 HPC 衡量测试覆盖率</h2>
<p class="calibre9">HPC(Haskell Program Coverage) 是一个编译器扩展，用来观察程序运行时哪一部分的代码被真正执行了。这在测试时非常有用，它让我们精确地观察哪些函数，分支以及表达式被求值了。我们可以轻易得到被测试代码的百分比。HPC 的内置工具可以产生关于程序覆盖率的图表，方便我们找到测试集的缺陷。</p>
<p class="calibre9">在编译测试代码时，我们只需在命令行加上 -fhpc 选项，即可得到测试覆盖率数据。</p>
<pre class="calibre15"><code class="tthhighlight-container">$ ghc <span class="token3">-</span>fhpc Run<span class="token">.</span>hs <span class="token3">--</span>make

</code></pre>
<p class="calibre9">正常运行测试：</p>
<pre class="calibre15"><code class="tthhighlight-container">$ <span class="token">.</span><span class="token3">/</span>Run

</code></pre>
<p class="calibre9">测试运行时，程序运行的细节被写入当前目录下的 .tix 和 .mix 文件。之后，命令行工具 hpc 用这些文件来展示各种统计数据，解释发生了什么。最基本的交互是通过文字。首先，我们可以在 hpc 命令中加上 report 选项来得到一个测试覆盖率的摘要。我们会把测试程序排除在外（使用 --exclude 选项），这样就能把注意力集中在美观打印库上了。在命令行中输入以下命令：</p>
<pre class="calibre15"><code class="tthhighlight-container">$ hpc report Run <span class="token3">--</span>exclude<span class="token3">=</span>Main <span class="token3">--</span>exclude<span class="token3">=</span>QC
 <span class="token2">93</span><span class="token3">%</span> expressions used <span class="token">(</span><span class="token2">30</span><span class="token3">/</span><span class="token2">32</span><span class="token">)</span>
<span class="token2">100</span><span class="token3">%</span> boolean coverage <span class="token">(</span><span class="token2">0</span><span class="token3">/</span><span class="token2">0</span><span class="token">)</span>
    <span class="token2">100</span><span class="token3">%</span> guards <span class="token">(</span><span class="token2">0</span><span class="token3">/</span><span class="token2">0</span><span class="token">)</span>
    <span class="token2">100</span><span class="token3">%</span> <span class="token4">'if'</span> conditions <span class="token">(</span><span class="token2">0</span><span class="token3">/</span><span class="token2">0</span><span class="token">)</span>
    <span class="token2">100</span><span class="token3">%</span> qualifiers <span class="token">(</span><span class="token2">0</span><span class="token3">/</span><span class="token2">0</span><span class="token">)</span>
<span class="token2">100</span><span class="token3">%</span> alternatives used <span class="token">(</span><span class="token2">8</span><span class="token3">/</span><span class="token2">8</span><span class="token">)</span>
<span class="token2">100</span><span class="token3">%</span> local declarations used <span class="token">(</span><span class="token2">0</span><span class="token3">/</span><span class="token2">0</span><span class="token">)</span>
 <span class="token2">66</span><span class="token3">%</span> top<span class="token3">-</span>level declarations used <span class="token">(</span><span class="token2">10</span><span class="token3">/</span><span class="token2">15</span><span class="token">)</span>

</code></pre>
<p class="calibre9">[译注：报告结果可能因人而异。]</p>
<p class="calibre9">在最后一行我们看到，测试时有66%的顶层定义被求值。对于第一次尝试来说，已经是很不错的结果了。随着被测试函数的增加，这个数字还会提升。对于快速了解结果来说文字版本的结果还不错，但为了真正了解发生了什么，最好还是看看被标记后的结果（marked up output）。用 markup 选项可以生成：</p>
<pre class="calibre15"><code class="tthhighlight-container">$hpc markup Run <span class="token3">--</span>exclude<span class="token3">=</span>Main <span class="token3">--</span>exclude<span class="token3">=</span>QC

</code></pre>
<p class="calibre9">它会对每一个 Haskell 源文件产生一个 html 文件，再加上一些索引文件。在浏览器中打开 hpc_index.html，我们可以看到一些非常漂亮的代码覆盖率图表：</p>
<p class="calibre9"></p>
<p class="calibre9">还不错。打开 Prettify2.hs.html 可以看到程序的源代码，其中未被测试的代码用黄色粗体标记，被执行的代码用粗体标记。</p>
<p class="calibre9"></p>
<p class="calibre9">我们没测 Monoid 实例，还有一些复杂函数也没测。HPC 不会说谎。我们来给 Monoid 类型类实例加个测试，这个类型类支持拼接元素和返回空元素：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch11<span class="token3">/</span>QC<span class="token">.</span>hs
prop_mempty_id x <span class="token3">=</span>
    mempty `mappend` x <span class="token3">==</span> x
  <span class="token3">&amp;&amp;</span>
    x `mappend` mempty <span class="token3">==</span> <span class="token">(</span>x <span class="token">:</span><span class="token">:</span> Doc<span class="token">)</span>

</code></pre>
<p class="calibre9">在 <strong class="calibre12">ghci</strong> 里检查确保正确：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>QC Test<span class="token">.</span>QuickCheck<span class="token3">&gt;</span> quickCheck prop_mempty_id
<span class="token3">++</span><span class="token3">+</span> OK<span class="token">,</span> passed <span class="token2">100</span> tests<span class="token">.</span>

</code></pre>
<p class="calibre9">我们现在可以重新编译并运行测试了。确保旧的 .tix 被删除，否则当 HPC 试图合并两次测试数据时会报错：</p>
<pre class="calibre15"><code class="tthhighlight-container">$ ghc <span class="token3">-</span>fhpc Run<span class="token">.</span>hs <span class="token3">--</span>make <span class="token3">-</span>fforce<span class="token3">-</span>recomp
<span class="token">[</span><span class="token2">1</span> of <span class="token2">3</span><span class="token">]</span> Compiling Prettify2        <span class="token">(</span> Prettify2<span class="token">.</span>hs<span class="token">,</span> Prettify2<span class="token">.</span>o <span class="token">)</span>
<span class="token">[</span><span class="token2">2</span> of <span class="token2">3</span><span class="token">]</span> Compiling QC               <span class="token">(</span> QC<span class="token">.</span>hs<span class="token">,</span> QC<span class="token">.</span>o <span class="token">)</span>
<span class="token">[</span><span class="token2">3</span> of <span class="token2">3</span><span class="token">]</span> Compiling Main             <span class="token">(</span> Run<span class="token">.</span>hs<span class="token">,</span> Run<span class="token">.</span>o <span class="token">)</span>
Linking Run <span class="token">.</span><span class="token">.</span><span class="token">.</span>
$ <span class="token">.</span><span class="token3">/</span>Run
<span class="token1">in</span> module <span class="token4">'Main'</span>
Hpc failure<span class="token">:</span> module mismatch with <span class="token">.</span>tix<span class="token3">/</span><span class="token">.</span>mix file hash number
<span class="token">(</span>perhaps remove Run<span class="token">.</span>tix file<span class="token3">?</span><span class="token">)</span>
$rm Run<span class="token">.</span>tix
$<span class="token">.</span><span class="token3">/</span>Run
Choose test depth
<span class="token2">1.</span> Anal
<span class="token2">2.</span> Minimal
<span class="token2">2</span>
empty_id ok<span class="token3">?</span>
<span class="token3">++</span><span class="token3">+</span> OK<span class="token">,</span> passed <span class="token2">200</span> tests<span class="token">.</span>
char ok<span class="token3">?</span>
<span class="token3">++</span><span class="token3">+</span> OK<span class="token">,</span> passed <span class="token2">200</span> tests<span class="token">.</span>
text ok<span class="token3">?</span>
<span class="token3">++</span><span class="token3">+</span> OK<span class="token">,</span> passed <span class="token2">200</span> tests<span class="token">.</span>
line ok<span class="token3">?</span>
<span class="token3">++</span><span class="token3">+</span> OK<span class="token">,</span> passed <span class="token2">1</span> tests<span class="token">.</span>
double ok<span class="token3">?</span>
<span class="token3">++</span><span class="token3">+</span> OK<span class="token">,</span> passed <span class="token2">200</span> tests<span class="token">.</span>
hcat ok<span class="token3">?</span>
<span class="token3">++</span><span class="token3">+</span> OK<span class="token">,</span> passed <span class="token2">200</span> tests<span class="token">.</span>
punctuate ok<span class="token3">?</span>
<span class="token3">++</span><span class="token3">+</span> OK<span class="token">,</span> passed <span class="token2">200</span> tests<span class="token">.</span>
prop_mempty_id ok<span class="token3">?</span>
<span class="token3">++</span><span class="token3">+</span> OK<span class="token">,</span> passed <span class="token2">200</span> tests<span class="token">.</span>

</code></pre>
<p class="calibre9">测试用例又多了两百个，我们的代码覆盖率也提高到了80%：</p>
<p class="calibre9"></p>
<p class="calibre9">HPC 确保我们在测试时诚实，因为任何没有被覆盖到的代码都会被标记出来。特别地，它确保程序员考虑到各种错误情形，状况不明朗的复杂分支，以及各式各样的代码。有了 QuickCheck 这样全面的测试生成系统，测试变得非常有意义，也成了 Haskell 开发的核心。</p>
</div></div></div></div></div></div>
<div id="chp-13.html"><div class="calibre">
<div id="chp-13.html.main" class="calibre1"><div class="root"><div class="article"><h1 class="article-head" id="chp-13.html.calibre_toc_12">第十三章：数据结构</h1><div class="article-body"><h1 class="calibre6"><a id="chp-13.html._0" class="calibre7 pcalibre"></a>第十三章：数据结构</h1>
<h2 class="calibre8"><a id="chp-13.html._2" class="calibre7 pcalibre"></a>关联列表</h2>
<p class="calibre9">我们常常会跟一些以键为索引的无序数据打交道。</p>
<p class="calibre9">举个例子，UNIX 管理猿可能需要这么一个列表，它包含系统中所有用户的 UID ，以及和这个 UID 相对应的用户名。这个列表根据 UID 而不是数据的位置来查找相应的用户名。换句话来说， UID 就是这个数据集的键。</p>
<p class="calibre9">Haskell 里有几种不同的方法来处理这种结构的数据，最常用的两个是关联列表（association list）和 Data.Map 模块提供的 Map 类型。</p>
<p class="calibre9">关联列表非常简单，易于使用。由于关联列表由 Haskell 列表构成，因此所有列表操作函数都可以用于处理关联列表。</p>
<p class="calibre9">另一方面， Map 类型在处理大数据集时，性能比关联列表要好。</p>
<p class="calibre9">本章将同时介绍这两种数据结构。</p>
<p class="calibre9">关联列表就是包含一个或多个 (key,value) 元组的列表， key 和 value 可以是任意类型。一个处理 UID 和用户名映射的关联列表的类型可能是 [(Integer,String)] 。</p>
<p class="calibre9">[注：关联列表的 key 必须是 Eq 类型的成员。]</p>
<p class="calibre9">关联列表的构建方式和普通列表一样。Haskell 提供了一个 Data.List.lookup 函数，用于在关联列表中查找数据。这个函数的类型签名为 Eqa=&gt;a-&gt;[(a,b)]-&gt;Maybeb 。它的使用方式如下：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> let al <span class="token3">=</span> <span class="token">[</span><span class="token">(</span><span class="token2">1</span><span class="token">,</span> <span class="token4">"one"</span><span class="token">)</span><span class="token">,</span> <span class="token">(</span><span class="token2">2</span><span class="token">,</span> <span class="token4">"two"</span><span class="token">)</span><span class="token">,</span> <span class="token">(</span><span class="token2">3</span><span class="token">,</span> <span class="token4">"three"</span><span class="token">)</span><span class="token">,</span> <span class="token">(</span><span class="token2">4</span><span class="token">,</span> <span class="token4">"four"</span><span class="token">)</span><span class="token">]</span>

Prelude<span class="token3">&gt;</span> lookup <span class="token2">1</span> al
Just <span class="token4">"one"</span>

Prelude<span class="token3">&gt;</span> lookup <span class="token2">5</span> al
Nothing

</code></pre>
<p class="calibre9">lookup 函数的定义如下：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>lookup<span class="token">.</span>hs
myLookup <span class="token">:</span><span class="token">:</span> Eq a <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span><span class="token">(</span>a<span class="token">,</span> b<span class="token">)</span><span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Maybe b
myLookup _ <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> Nothing
myLookup key <span class="token">(</span><span class="token">(</span>thiskey<span class="token">,</span> thisval<span class="token">)</span><span class="token">:</span>rest<span class="token">)</span> <span class="token3">=</span>
    <span class="token1">if</span> key <span class="token3">==</span> thiskey
       then Just thisval
       <span class="token1">else</span> myLookup key rest

</code></pre>
<p class="calibre9">lookup 在输入列表为空时返回 Nothing 。如果输入列表不为空，那么它检查当前列表元素的 key 是否就是我们要找的 key ，如果是的话就返回和这个 key 对应的 value ，否则就继续递归处理剩余的列表元素。</p>
<p class="calibre9">再来看一个稍微复杂点的例子。在 Unix/Linux 系统中，有一个 /etc/passwd 文件，这个文件保存了用户名称， UID，用户的 HOME 目录位置，以及其他一些数据。文件以行分割每个用户的资料，每个数据域用冒号隔开：</p>
<pre class="calibre15"><code class="tthhighlight-container">root<span class="token">:</span>x<span class="token">:</span><span class="token2">0</span><span class="token">:</span><span class="token2">0</span><span class="token">:</span>root<span class="token">:</span><span class="token3">/</span>root<span class="token">:</span><span class="token3">/</span>bin<span class="token3">/</span>bash
daemon<span class="token">:</span>x<span class="token">:</span><span class="token2">1</span><span class="token">:</span><span class="token2">1</span><span class="token">:</span>daemon<span class="token">:</span><span class="token3">/</span>usr<span class="token3">/</span>sbin<span class="token">:</span><span class="token3">/</span>bin<span class="token3">/</span>sh
bin<span class="token">:</span>x<span class="token">:</span><span class="token2">2</span><span class="token">:</span><span class="token2">2</span><span class="token">:</span>bin<span class="token">:</span><span class="token3">/</span>bin<span class="token">:</span><span class="token3">/</span>bin<span class="token3">/</span>sh
sys<span class="token">:</span>x<span class="token">:</span><span class="token2">3</span><span class="token">:</span><span class="token2">3</span><span class="token">:</span>sys<span class="token">:</span><span class="token3">/</span>dev<span class="token">:</span><span class="token3">/</span>bin<span class="token3">/</span>sh
sync<span class="token">:</span>x<span class="token">:</span><span class="token2">4</span><span class="token">:</span><span class="token2">65534</span><span class="token">:</span>sync<span class="token">:</span><span class="token3">/</span>bin<span class="token">:</span><span class="token3">/</span>bin<span class="token3">/</span>sync
games<span class="token">:</span>x<span class="token">:</span><span class="token2">5</span><span class="token">:</span><span class="token2">60</span><span class="token">:</span>games<span class="token">:</span><span class="token3">/</span>usr<span class="token3">/</span>games<span class="token">:</span><span class="token3">/</span>bin<span class="token3">/</span>sh
man<span class="token">:</span>x<span class="token">:</span><span class="token2">6</span><span class="token">:</span><span class="token2">12</span><span class="token">:</span>man<span class="token">:</span><span class="token3">/</span>var<span class="token3">/</span>cache<span class="token3">/</span>man<span class="token">:</span><span class="token3">/</span>bin<span class="token3">/</span>sh
lp<span class="token">:</span>x<span class="token">:</span><span class="token2">7</span><span class="token">:</span><span class="token2">7</span><span class="token">:</span>lp<span class="token">:</span><span class="token3">/</span>var<span class="token3">/</span>spool<span class="token3">/</span>lpd<span class="token">:</span><span class="token3">/</span>bin<span class="token3">/</span>sh
mail<span class="token">:</span>x<span class="token">:</span><span class="token2">8</span><span class="token">:</span><span class="token2">8</span><span class="token">:</span>mail<span class="token">:</span><span class="token3">/</span>var<span class="token3">/</span>mail<span class="token">:</span><span class="token3">/</span>bin<span class="token3">/</span>sh
news<span class="token">:</span>x<span class="token">:</span><span class="token2">9</span><span class="token">:</span><span class="token2">9</span><span class="token">:</span>news<span class="token">:</span><span class="token3">/</span>var<span class="token3">/</span>spool<span class="token3">/</span>news<span class="token">:</span><span class="token3">/</span>bin<span class="token3">/</span>sh
jgoerzen<span class="token">:</span>x<span class="token">:</span><span class="token2">1000</span><span class="token">:</span><span class="token2">1000</span><span class="token">:</span>John Goerzen<span class="token">,</span><span class="token">,</span><span class="token">,</span><span class="token">:</span><span class="token3">/</span>home<span class="token3">/</span>jgoerzen<span class="token">:</span><span class="token3">/</span>bin<span class="token3">/</span>bash

</code></pre>
<p class="calibre9">以下程序读入并处理 /etc/passwd 文件，它创建一个关联列表，使得我们可以根据给定 UID ，获取相应的用户名：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>passwd<span class="token3">-</span>al<span class="token">.</span>hs
import Data<span class="token">.</span>List
import System<span class="token">.</span>IO
import Control<span class="token">.</span><span class="token5">Monad</span><span class="token">(</span>when<span class="token">)</span>
import System<span class="token">.</span>Exit
import System<span class="token">.</span><span class="token5">Environment</span><span class="token">(</span>getArgs<span class="token">)</span>

main <span class="token3">=</span> <span class="token1">do</span>
    <span class="token3">--</span> Load the command<span class="token3">-</span>line arguments
    args <span class="token3">&lt;</span><span class="token3">-</span> getArgs

    <span class="token3">--</span> If we don't have the right amount of args<span class="token">,</span> give an error and abort
    when <span class="token">(</span>length args <span class="token3">/</span><span class="token3">=</span> <span class="token2">2</span><span class="token">)</span> $ <span class="token1">do</span>
        putStrLn <span class="token4">"Syntax: passwd-al filename uid"</span>
        exitFailure

    <span class="token3">--</span> Read the file lazily
    content <span class="token3">&lt;</span><span class="token3">-</span> readFile <span class="token">(</span>args <span class="token3">!</span><span class="token3">!</span> <span class="token2">0</span><span class="token">)</span>

    <span class="token3">--</span> Compute the username <span class="token1">in</span> pure code
    let username <span class="token3">=</span> findByUID content <span class="token">(</span>read <span class="token">(</span>args <span class="token3">!</span><span class="token3">!</span> <span class="token2">1</span><span class="token">)</span><span class="token">)</span>

    <span class="token3">--</span> Display the result
    case username of
         Just x <span class="token3">-</span><span class="token3">&gt;</span> putStrLn x
         Nothing <span class="token3">-</span><span class="token3">&gt;</span> putStrLn <span class="token4">"Could not find that UID"</span>

<span class="token3">--</span> Given the entire input and a UID<span class="token">,</span> see <span class="token1">if</span> we can find a username<span class="token">.</span>
findByUID <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> Integer <span class="token3">-</span><span class="token3">&gt;</span> Maybe String
findByUID content uid <span class="token3">=</span>
    let al <span class="token3">=</span> map parseline <span class="token">.</span> lines $ content
        <span class="token1">in</span> lookup uid al

<span class="token3">--</span> Convert a colon<span class="token3">-</span>separated line into fields
parseline <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>Integer<span class="token">,</span> String<span class="token">)</span>
parseline input <span class="token3">=</span> 
    let fields <span class="token3">=</span> split <span class="token4">':'</span> input
        <span class="token1">in</span> <span class="token">(</span>read <span class="token">(</span>fields <span class="token3">!</span><span class="token3">!</span> <span class="token2">2</span><span class="token">)</span><span class="token">,</span> fields <span class="token3">!</span><span class="token3">!</span> <span class="token2">0</span><span class="token">)</span>

<span class="token3">--</span> Takes a delimiter and a list<span class="token">.</span> 
<span class="token3">--</span> Break up the list based on the delimiter<span class="token">.</span>
split <span class="token">:</span><span class="token">:</span> Eq a <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span><span class="token">[</span>a<span class="token">]</span><span class="token">]</span>

<span class="token3">--</span> If the input is empty<span class="token">,</span> the result is a list of empty lists<span class="token">.</span>
split _ <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> <span class="token">[</span><span class="token">[</span><span class="token">]</span><span class="token">]</span>
split delimiter str <span class="token3">=</span>
    let <span class="token3">--</span> Find the part of the list before delimiter and put it <span class="token1">in</span> <span class="token4">"before"</span><span class="token">.</span>
        <span class="token3">--</span> The result of the list<span class="token">,</span> including the leading delimiter<span class="token">,</span> goes <span class="token1">in</span> <span class="token4">"remainder"</span><span class="token">.</span>
        <span class="token">(</span>before<span class="token">,</span> remainder<span class="token">)</span> <span class="token3">=</span> span <span class="token">(</span><span class="token3">/</span><span class="token3">=</span> delimiter<span class="token">)</span> str
        <span class="token1">in</span> before <span class="token">:</span> case remainder of
                         <span class="token">[</span><span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span><span class="token">]</span>
                         x <span class="token3">-</span><span class="token3">&gt;</span> <span class="token3">--</span> If there is more data to process<span class="token">,</span>
                              <span class="token3">--</span> call split recursively to process it
                              split delimiter <span class="token">(</span>tail x<span class="token">)</span>

</code></pre>
<p class="calibre9">findByUID 是整个程序的核心，它逐行读入并处理输入，使用 lookup 从处理结果中查找给定 UID ：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> findByUID <span class="token4">"root:x:0:0:root:/root:/bin/bash"</span> <span class="token2">0</span>
Just <span class="token4">"root"</span>

</code></pre>
<p class="calibre9">parseline 读入并处理一个字符串，返回一个包含 UID 和用户名的元组：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> parseline <span class="token4">"root:x:0:0:root:/root:/bin/bash"</span>
<span class="token">(</span><span class="token2">0</span><span class="token">,</span><span class="token4">"root"</span><span class="token">)</span>

</code></pre>
<p class="calibre9">split 函数根据给定分隔符 delimiter 将一个文本行分割为列表：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> split <span class="token4">':'</span> <span class="token4">"root:x:0:0:root:/root:/bin/bash"</span>
<span class="token">[</span><span class="token4">"root"</span><span class="token">,</span><span class="token4">"x"</span><span class="token">,</span><span class="token4">"0"</span><span class="token">,</span><span class="token4">"0"</span><span class="token">,</span><span class="token4">"root"</span><span class="token">,</span><span class="token4">"/root"</span><span class="token">,</span><span class="token4">"/bin/bash"</span><span class="token">]</span>

</code></pre>
<p class="calibre9">以下是在本机执行 passwd-al.hs 处理 /etc/passwd 的结果：</p>
<pre class="calibre15"><code class="tthhighlight-container">$ runghc passwd<span class="token3">-</span>al<span class="token">.</span>hs <span class="token3">/</span>etc<span class="token3">/</span>passwd <span class="token2">0</span>
root

$ runghc passwd<span class="token3">-</span>al<span class="token">.</span>hs <span class="token3">/</span>etc<span class="token3">/</span>passwd <span class="token2">10086</span>
Could not find that UID

</code></pre>
<h2 class="calibre14"><a id="chp-13.html.Map__160" class="calibre7 pcalibre"></a>Map 类型</h2>
<p class="calibre9">Data.Map 模块提供的 Map 类型的行为和关联列表类似，但 Map 类型的性能更好。</p>
<p class="calibre9">Map 和其他语言提供的哈希表类似。不同的是， Map 的内部由平衡二叉树实现，在 Haskell 这种使用不可变数据的语言中，它是一个比哈希表更高效的表示。这是一个非常明显的例子，说明纯函数式语言是如何深入地影响我们编写程序的方式：对于一个给定的任务，我们总是选择合适的算法和数据结构，使得解决方案尽可能地简单和有效，但这些（纯函数式的）选择通常不同于命令式语言处理同样问题时的选择。</p>
<p class="calibre9">因为 Data.Map 模块的一些函数和 Prelude 模块的函数重名，我们通过 importqualifiedData.MapasMap 的方式引入模块，并使用 <a href="http://Map.name" target="_blank" class="calibre7 pcalibre">Map.name</a> 的方式引用模块中的名字。</p>
<p class="calibre9">先来看看如何用几种不同的方式构建 Map ：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>buildmap<span class="token">.</span>hs
import qualified Data<span class="token">.</span>Map as Map

<span class="token3">--</span> Functions to generate a Map that represents an association list
<span class="token3">--</span> as a map

al <span class="token3">=</span> <span class="token">[</span><span class="token">(</span><span class="token2">1</span><span class="token">,</span> <span class="token4">"one"</span><span class="token">)</span><span class="token">,</span> <span class="token">(</span><span class="token2">2</span><span class="token">,</span> <span class="token4">"two"</span><span class="token">)</span><span class="token">,</span> <span class="token">(</span><span class="token2">3</span><span class="token">,</span> <span class="token4">"three"</span><span class="token">)</span><span class="token">,</span> <span class="token">(</span><span class="token2">4</span><span class="token">,</span> <span class="token4">"four"</span><span class="token">)</span><span class="token">]</span>

<span class="token3">--</span> Create a map representation of <span class="token4">'al'</span> by converting the association 
<span class="token3">--</span> list using Map<span class="token">.</span>fromList
mapFromAL <span class="token3">=</span>
    Map<span class="token">.</span>fromList al

<span class="token3">--</span> Create a map representation of <span class="token4">'al'</span> by doing a fold
mapFold <span class="token3">=</span> 
    foldl <span class="token">(</span>\map <span class="token">(</span>k<span class="token">,</span> v<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> Map<span class="token">.</span>insert k v map<span class="token">)</span> Map<span class="token">.</span>empty al

<span class="token3">--</span> Manually create a map with the elements of <span class="token4">'al'</span> <span class="token1">in</span> it
mapManual <span class="token3">=</span>
    Map<span class="token">.</span>insert <span class="token2">2</span> <span class="token4">"two"</span> <span class="token">.</span>
    Map<span class="token">.</span>insert <span class="token2">4</span> <span class="token4">"four"</span> <span class="token">.</span>
    Map<span class="token">.</span>insert <span class="token2">1</span> <span class="token4">"one"</span> <span class="token">.</span>
    Map<span class="token">.</span>insert <span class="token2">3</span> <span class="token4">"three"</span> $ Map<span class="token">.</span>empty

</code></pre>
<p class="calibre9">Map.insert 函数处理数据的方式非常『 Haskell 化』：它返回经过函数应用的输入数据的副本。这种处理数据的方式在操作多个 Map 时非常有用，它意味着你可以像前面代码中 mapFold 那样使用 fold 来构建一个 Map ，又或者像 mapManual 那样，串连起多个 Map.insert 调用。</p>
<p class="calibre9">[译注：这里说『 Haskell 化』实际上就是『函数式化』，对于函数式语言来说，最常见的函数处理方式是接受一个输入，然后返回一个输出，输出是另一个独立的值，且原输入不会被修改。]</p>
<p class="calibre9">现在，到 ghci 中验证一下是否所有定义都如我们所预期的那样工作：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>l buildmap<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> buildmap<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> al
Loading package array<span class="token3">-</span><span class="token2">0.4</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package deepseq<span class="token3">-</span><span class="token2">1.3</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package containers<span class="token3">-</span><span class="token2">0.4</span><span class="token2">.2</span><span class="token2">.1</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
<span class="token">[</span><span class="token">(</span><span class="token2">1</span><span class="token">,</span><span class="token4">"one"</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token2">2</span><span class="token">,</span><span class="token4">"two"</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token2">3</span><span class="token">,</span><span class="token4">"three"</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token2">4</span><span class="token">,</span><span class="token4">"four"</span><span class="token">)</span><span class="token">]</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> mapFromAL
fromList <span class="token">[</span><span class="token">(</span><span class="token2">1</span><span class="token">,</span><span class="token4">"one"</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token2">2</span><span class="token">,</span><span class="token4">"two"</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token2">3</span><span class="token">,</span><span class="token4">"three"</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token2">4</span><span class="token">,</span><span class="token4">"four"</span><span class="token">)</span><span class="token">]</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> mapFold
fromList <span class="token">[</span><span class="token">(</span><span class="token2">1</span><span class="token">,</span><span class="token4">"one"</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token2">2</span><span class="token">,</span><span class="token4">"two"</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token2">3</span><span class="token">,</span><span class="token4">"three"</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token2">4</span><span class="token">,</span><span class="token4">"four"</span><span class="token">)</span><span class="token">]</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> mapManual
fromList <span class="token">[</span><span class="token">(</span><span class="token2">1</span><span class="token">,</span><span class="token4">"one"</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token2">2</span><span class="token">,</span><span class="token4">"two"</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token2">3</span><span class="token">,</span><span class="token4">"three"</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token2">4</span><span class="token">,</span><span class="token4">"four"</span><span class="token">)</span><span class="token">]</span>

</code></pre>
<p class="calibre9">注意， Map 并不保证它的输出排列和原本的输入排列一致，对比 mapManual 的输入和输出可以看出这一点。</p>
<p class="calibre9">Map 的操作方式和关联列表类似。 Data.Map 模块提供了一组函数，用于增删 Map 元素，对 Map 进行过滤、修改和 fold ，以及在 Map 和关联列表之间进行转换。 Data.Map 模块本身的文档非常优秀，因此我们在这里不会详细讲解每个函数，而是在本章的后续内容中，通过例子来介绍这些概念。</p>
<h2 class="calibre14"><a id="chp-13.html._229" class="calibre7 pcalibre"></a>函数也是数据</h2>
<p class="calibre9">Haskell 语言的威力部分在于它可以让我们方便地创建并操作函数。</p>
<p class="calibre9">以下示例展示了怎样将函数保存到记录的域中：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>funcrecs<span class="token">.</span>hs

<span class="token3">--</span> Our usual CustomColor type to play with
data CustomColor <span class="token3">=</span>
    CustomColor <span class="token">{</span>red <span class="token">:</span><span class="token">:</span> Int<span class="token">,</span>
                 green <span class="token">:</span><span class="token">:</span> Int<span class="token">,</span>
                 blue <span class="token">:</span><span class="token">:</span> Int<span class="token">}</span>
    deriving <span class="token">(</span>Eq<span class="token">,</span> Show<span class="token">,</span> Read<span class="token">)</span>

<span class="token3">--</span> A <span class="token1">new</span> <span class="token5">type</span> that stores a name and a <span class="token1">function</span><span class="token">.</span>
<span class="token3">--</span> The <span class="token1">function</span> takes an Int<span class="token">,</span> applies some computation to it<span class="token">,</span>
<span class="token3">--</span> and returns an Int along with a CustomColor
data FuncRec <span class="token3">=</span>
    FuncRec <span class="token">{</span>name <span class="token">:</span><span class="token">:</span> String<span class="token">,</span>
             colorCalc <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>CustomColor<span class="token">,</span> Int<span class="token">)</span><span class="token">}</span>

plus5func color x <span class="token3">=</span> <span class="token">(</span>color<span class="token">,</span> x <span class="token3">+</span> <span class="token2">5</span><span class="token">)</span>

purple <span class="token3">=</span> CustomColor <span class="token2">255</span> <span class="token2">0</span> <span class="token2">255</span>

plus5 <span class="token3">=</span> FuncRec <span class="token">{</span>name <span class="token3">=</span> <span class="token4">"plus5"</span><span class="token">,</span> colorCalc <span class="token3">=</span> plus5func purple<span class="token">}</span>
always0 <span class="token3">=</span> FuncRec <span class="token">{</span>name <span class="token3">=</span> <span class="token4">"always0"</span><span class="token">,</span> colorCalc <span class="token3">=</span> \_ <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>purple<span class="token">,</span> <span class="token2">0</span><span class="token">)</span><span class="token">}</span>

</code></pre>
<p class="calibre9">注意 colorCalc 域的类型：它是一个函数，接受一个 Int 类型值作为参数，并返回一个 (CustomColor,Int) 元组。</p>
<p class="calibre9">我们创建了两个 FuncRec 记录： plus5 和 always0 ，这两个记录的 colorCalc 域都总是返回紫色（purple）。 FuncRec 自身并没有域去保存所使用的颜色，颜色的值被保存在函数当中 —— 我们称这种用法为<em class="calibre13">闭包</em>。</p>
<p class="calibre9">以下是示例代码：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>l funcrecs<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> funcrecs<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>t plus5
plus5 <span class="token">:</span><span class="token">:</span> FuncRec

<span class="token3">*</span>Main<span class="token3">&gt;</span> name plus5
<span class="token4">"plus5"</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>t colorCalc plus5
colorCalc plus5 <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>CustomColor<span class="token">,</span> Int<span class="token">)</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">(</span>colorCalc plus5<span class="token">)</span> <span class="token2">7</span>
<span class="token">(</span>CustomColor <span class="token">{</span>red <span class="token3">=</span> <span class="token2">255</span><span class="token">,</span> green <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> blue <span class="token3">=</span> <span class="token2">255</span><span class="token">}</span><span class="token">,</span><span class="token2">12</span><span class="token">)</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>t colorCalc always0
colorCalc always0 <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>CustomColor<span class="token">,</span> Int<span class="token">)</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">(</span>colorCalc always0<span class="token">)</span> <span class="token2">7</span>
<span class="token">(</span>CustomColor <span class="token">{</span>red <span class="token3">=</span> <span class="token2">255</span><span class="token">,</span> green <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> blue <span class="token3">=</span> <span class="token2">255</span><span class="token">}</span><span class="token">,</span><span class="token2">0</span><span class="token">)</span>

</code></pre>
<p class="calibre9">上面的程序工作得很好，但我们还想做一些更有趣的事，比如说，在多个域中使用同一段数据。可以使用一个类型构造函数来做到这一点：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>funcrecs2<span class="token">.</span>hs
data FuncRec <span class="token3">=</span>
    FuncRec <span class="token">{</span>name <span class="token">:</span><span class="token">:</span> String<span class="token">,</span>
             calc <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> Int<span class="token">,</span>
             namedCalc <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>String<span class="token">,</span> Int<span class="token">)</span><span class="token">}</span>

mkFuncRec <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>Int <span class="token3">-</span><span class="token3">&gt;</span> Int<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> FuncRec
mkFuncRec name calcfunc <span class="token3">=</span>
    FuncRec <span class="token">{</span>name <span class="token3">=</span> name<span class="token">,</span>
             calc <span class="token3">=</span> calcfunc<span class="token">,</span>
             namedCalc <span class="token3">=</span> \x <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>name<span class="token">,</span> calcfunc x<span class="token">)</span><span class="token">}</span>

plus5 <span class="token3">=</span> mkFuncRec <span class="token4">"plus5"</span> <span class="token">(</span><span class="token3">+</span> <span class="token2">5</span><span class="token">)</span>
always0 <span class="token3">=</span> mkFuncRec <span class="token4">"always0"</span> <span class="token">(</span>\_ <span class="token3">-</span><span class="token3">&gt;</span> <span class="token2">0</span><span class="token">)</span>

</code></pre>
<p class="calibre9">mkFuncRecs 函数接受一个字符串和一个函数作为参数，返回一个新的 FuncRec 记录。以下是对 mkFuncRecs 函数的测试：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>l funcrecs2<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> funcrecs2<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>t plus5
plus5 <span class="token">:</span><span class="token">:</span> FuncRec

<span class="token3">*</span>Main<span class="token3">&gt;</span> name plus5
<span class="token4">"plus5"</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">(</span>calc plus5<span class="token">)</span> <span class="token2">5</span>
<span class="token2">10</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">(</span>namedCalc plus5<span class="token">)</span> <span class="token2">5</span>
<span class="token">(</span><span class="token4">"plus5"</span><span class="token">,</span><span class="token2">10</span><span class="token">)</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> let plus5a <span class="token3">=</span> plus5 <span class="token">{</span>name <span class="token3">=</span> <span class="token4">"PLUS5A"</span><span class="token">}</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> name plus5a
<span class="token4">"PLUS5A"</span>

<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">(</span>namedCalc plus5a<span class="token">)</span> <span class="token2">5</span>
<span class="token">(</span><span class="token4">"plus5"</span><span class="token">,</span><span class="token2">10</span><span class="token">)</span>

</code></pre>
<p class="calibre9">注意 plus5a 的创建过程：我们改变了 plus5 的 name 域，但没有修改它的 namedCalc 域。这就是为什么调用 name 会返回新名字，而 namedCalc 依然返回原本使用 mkFuncRecs 创建时设置的名字 —— 除非我们显式地修改域，否则它们不会被改变。</p>
<h2 class="calibre14"><a id="chp-13.html._etcpassword_343" class="calibre7 pcalibre"></a>扩展示例： /etc/password</h2>
<p class="calibre9">以下是一个扩展示例，它展示了几种不同的数据结构的用法，根据 /etc/passwd 文件的格式，程序处理并保存它的实体（entry）：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>passwdmap<span class="token">.</span>hs
import Data<span class="token">.</span>List
import qualified Data<span class="token">.</span>Map as Map
import System<span class="token">.</span>IO
import Text<span class="token">.</span><span class="token5">Printf</span><span class="token">(</span>printf<span class="token">)</span>
import System<span class="token">.</span><span class="token5">Environment</span><span class="token">(</span>getArgs<span class="token">)</span>
import System<span class="token">.</span>Exit
import Control<span class="token">.</span><span class="token5">Monad</span><span class="token">(</span>when<span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> The primary piece of data this program will store<span class="token">.</span>
   It represents the fields <span class="token1">in</span> a POSIX <span class="token3">/</span>etc<span class="token3">/</span>passwd file <span class="token3">-</span><span class="token">}</span>
data PasswdEntry <span class="token3">=</span> PasswdEntry <span class="token">{</span>
    userName <span class="token">:</span><span class="token">:</span> String<span class="token">,</span>
    password <span class="token">:</span><span class="token">:</span> String<span class="token">,</span>
    uid <span class="token">:</span><span class="token">:</span> Integer<span class="token">,</span>
    gid <span class="token">:</span><span class="token">:</span> Integer<span class="token">,</span>
    gecos <span class="token">:</span><span class="token">:</span> String<span class="token">,</span>
    homeDir <span class="token">:</span><span class="token">:</span> String<span class="token">,</span>
    shell <span class="token">:</span><span class="token">:</span> String<span class="token">}</span>
    deriving <span class="token">(</span>Eq<span class="token">,</span> Ord<span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Define how we get data to a <span class="token4">'PasswdEntry'</span><span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
instance Show PasswdEntry where
    show pe <span class="token3">=</span> printf <span class="token4">"%s:%s:%d:%d:%s:%s:%s"</span> 
                <span class="token">(</span>userName pe<span class="token">)</span> <span class="token">(</span>password pe<span class="token">)</span> <span class="token">(</span>uid pe<span class="token">)</span> <span class="token">(</span>gid pe<span class="token">)</span>
                <span class="token">(</span>gecos pe<span class="token">)</span> <span class="token">(</span>homeDir pe<span class="token">)</span> <span class="token">(</span>shell pe<span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Converting data back out of a <span class="token4">'PasswdEntry'</span><span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
instance Read PasswdEntry where
    readsPrec _ value <span class="token3">=</span>
        case split <span class="token4">':'</span> value of
             <span class="token">[</span>f1<span class="token">,</span> f2<span class="token">,</span> f3<span class="token">,</span> f4<span class="token">,</span> f5<span class="token">,</span> f6<span class="token">,</span> f7<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span>
                 <span class="token3">--</span> Generate a <span class="token4">'PasswdEntry'</span> the shorthand way<span class="token">:</span>
                 <span class="token3">--</span> using the positional fields<span class="token">.</span>  We use <span class="token4">'read'</span> to convert
                 <span class="token3">--</span> the numeric fields to Integers<span class="token">.</span>
                 <span class="token">[</span><span class="token">(</span>PasswdEntry f1 f2 <span class="token">(</span>read f3<span class="token">)</span> <span class="token">(</span>read f4<span class="token">)</span> f5 f6 f7<span class="token">,</span> <span class="token">[</span><span class="token">]</span><span class="token">)</span><span class="token">]</span>
             x <span class="token3">-</span><span class="token3">&gt;</span> error $ <span class="token4">"Invalid number of fields in input: "</span> <span class="token3">++</span> show x
        where 
        <span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Takes a delimiter and a list<span class="token">.</span>  Break up the list based on the
        <span class="token3">-</span>  delimiter<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
        split <span class="token">:</span><span class="token">:</span> Eq a <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span><span class="token">[</span>a<span class="token">]</span><span class="token">]</span>

        <span class="token3">--</span> If the input is empty<span class="token">,</span> the result is a list of empty lists<span class="token">.</span>
        split _ <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> <span class="token">[</span><span class="token">[</span><span class="token">]</span><span class="token">]</span>
        split delim str <span class="token3">=</span>
            let <span class="token3">--</span> Find the part of the list before delim and put it <span class="token1">in</span>
                <span class="token3">--</span> <span class="token4">"before"</span><span class="token">.</span>  The rest of the list<span class="token">,</span> including the leading 
                <span class="token3">--</span> delim<span class="token">,</span> goes <span class="token1">in</span> <span class="token4">"remainder"</span><span class="token">.</span>
                <span class="token">(</span>before<span class="token">,</span> remainder<span class="token">)</span> <span class="token3">=</span> span <span class="token">(</span><span class="token3">/</span><span class="token3">=</span> delim<span class="token">)</span> str
                <span class="token1">in</span>
                before <span class="token">:</span> case remainder of
                              <span class="token">[</span><span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span><span class="token">]</span>
                              x <span class="token3">-</span><span class="token3">&gt;</span> <span class="token3">--</span> If there is more data to process<span class="token">,</span>
                                   <span class="token3">--</span> call split recursively to process it
                                   split delim <span class="token">(</span>tail x<span class="token">)</span>

<span class="token3">--</span> Convenience aliases<span class="token">;</span> we'll have two maps<span class="token">:</span> one from UID to entries
<span class="token3">--</span> and the other from username to entries
type UIDMap <span class="token3">=</span> Map<span class="token">.</span>Map Integer PasswdEntry
type UserMap <span class="token3">=</span> Map<span class="token">.</span>Map String PasswdEntry

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Converts input data to maps<span class="token">.</span>  Returns UID and User maps<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
inputToMaps <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>UIDMap<span class="token">,</span> UserMap<span class="token">)</span>
inputToMaps inp <span class="token3">=</span>
    <span class="token">(</span>uidmap<span class="token">,</span> usermap<span class="token">)</span>
    where
    <span class="token3">--</span> fromList converts a <span class="token">[</span><span class="token">(</span>key<span class="token">,</span> value<span class="token">)</span><span class="token">]</span> list into a Map
    uidmap <span class="token3">=</span> Map<span class="token">.</span>fromList <span class="token">.</span> map <span class="token">(</span>\pe <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>uid pe<span class="token">,</span> pe<span class="token">)</span><span class="token">)</span> $ entries
    usermap <span class="token3">=</span> Map<span class="token">.</span>fromList <span class="token">.</span> 
              map <span class="token">(</span>\pe <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>userName pe<span class="token">,</span> pe<span class="token">)</span><span class="token">)</span> $ entries
    <span class="token3">--</span> Convert the input String to <span class="token">[</span>PasswdEntry<span class="token">]</span>
    entries <span class="token3">=</span> map read <span class="token">(</span>lines inp<span class="token">)</span>

main <span class="token3">=</span> <span class="token1">do</span>
    <span class="token3">--</span> Load the command<span class="token3">-</span>line arguments
    args <span class="token3">&lt;</span><span class="token3">-</span> getArgs

    <span class="token3">--</span> If we don't have the right number of args<span class="token">,</span>
    <span class="token3">--</span> give an error and abort

    when <span class="token">(</span>length args <span class="token3">/</span><span class="token3">=</span> <span class="token2">1</span><span class="token">)</span> $ <span class="token1">do</span>
        putStrLn <span class="token4">"Syntax: passwdmap filename"</span>
        exitFailure

    <span class="token3">--</span> Read the file lazily
    content <span class="token3">&lt;</span><span class="token3">-</span> readFile <span class="token">(</span>head args<span class="token">)</span>
    let maps <span class="token3">=</span> inputToMaps content
    mainMenu maps

mainMenu maps@<span class="token">(</span>uidmap<span class="token">,</span> usermap<span class="token">)</span> <span class="token3">=</span> <span class="token1">do</span>
    putStr optionText
    hFlush stdout
    sel <span class="token3">&lt;</span><span class="token3">-</span> getLine
    <span class="token3">--</span> See what they want to <span class="token1">do</span><span class="token">.</span>  For every option except <span class="token2">4</span><span class="token">,</span>
    <span class="token3">--</span> <span class="token1">return</span> them to the main menu afterwards by calling
    <span class="token3">--</span> mainMenu recursively
    case sel of
         <span class="token4">"1"</span> <span class="token3">-</span><span class="token3">&gt;</span> lookupUserName <span class="token3">&gt;</span><span class="token3">&gt;</span> mainMenu maps
         <span class="token4">"2"</span> <span class="token3">-</span><span class="token3">&gt;</span> lookupUID <span class="token3">&gt;</span><span class="token3">&gt;</span> mainMenu maps
         <span class="token4">"3"</span> <span class="token3">-</span><span class="token3">&gt;</span> displayFile <span class="token3">&gt;</span><span class="token3">&gt;</span> mainMenu maps
         <span class="token4">"4"</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> <span class="token">(</span><span class="token">)</span>
         _ <span class="token3">-</span><span class="token3">&gt;</span> putStrLn <span class="token4">"Invalid selection"</span> <span class="token3">&gt;</span><span class="token3">&gt;</span> mainMenu maps

    where 
    lookupUserName <span class="token3">=</span> <span class="token1">do</span>
        putStrLn <span class="token4">"Username: "</span>
        username <span class="token3">&lt;</span><span class="token3">-</span> getLine
        case Map<span class="token">.</span>lookup username usermap of
             Nothing <span class="token3">-</span><span class="token3">&gt;</span> putStrLn <span class="token4">"Not found."</span>
             Just x <span class="token3">-</span><span class="token3">&gt;</span> print x
    lookupUID <span class="token3">=</span> <span class="token1">do</span>
        putStrLn <span class="token4">"UID: "</span>
        uidstring <span class="token3">&lt;</span><span class="token3">-</span> getLine
        case Map<span class="token">.</span>lookup <span class="token">(</span>read uidstring<span class="token">)</span> uidmap of
             Nothing <span class="token3">-</span><span class="token3">&gt;</span> putStrLn <span class="token4">"Not found."</span>
             Just x <span class="token3">-</span><span class="token3">&gt;</span> print x
    displayFile <span class="token3">=</span> 
        putStr <span class="token">.</span> unlines <span class="token">.</span> map <span class="token">(</span>show <span class="token">.</span> snd<span class="token">)</span> <span class="token">.</span> Map<span class="token">.</span>toList $ uidmap
    optionText <span class="token3">=</span> 
          <span class="token4">"\npasswdmap options:\n\
           \\n\
           \1   Look up a user name\n\
           \2   Look up a UID\n\
           \3   Display entire file\n\
           \4   Quit\n\n\
           \Your selection: "</span>

</code></pre>
<p class="calibre9">示例程序维持两个 Map ：一个从用户名映射到 PasswdEntry ，另一个从 UID 映射到 PasswdEntry 。有数据库使用经验的人可以将它们看作是两个不同数据域的索引。</p>
<p class="calibre9">根据 /etc/passwd 文件的格式， PasswdEntry 的 Show 和 Read 实例分别用于显示（display）和处理（parse）工作。</p>
<h2 class="calibre14"><a id="chp-13.html.Numeric_Types_481" class="calibre7 pcalibre"></a>扩展示例：数字类型（Numeric Types）</h2>
<p class="calibre9">我们已经讲过 Haskell 的类型系统有多强大，表达能力有多强。我们已经讲过很多利用这种能力的方法。现在我们来举一个实际的例子看看。</p>
<p class="calibre9">在 <a href="#chp-13.html." class="calibre7 pcalibre"><em class="calibre13">数字类型</em></a> 一节中，我们展示了 Haskell 的数字类型类。现在，我们来定义一些类，然后用数字类型类把它们和 Haskell 的基本数学结合起来，看看能得到什么。</p>
<p class="calibre9">我们先来想想我们想用这些新类型在 <strong class="calibre12">ghci</strong> 里干什么。首先，一个不错的选择是把数学表达式转成字符串，并确保它显示了正确的优先级。我们可以写一个 prettyShow 函数来实现。稍后我们就告诉你怎么写，先来看看怎么用它。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>l num<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> num<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>
ghci<span class="token3">&gt;</span> <span class="token2">5</span> <span class="token3">+</span> <span class="token2">1</span> <span class="token3">*</span> <span class="token2">3</span>
<span class="token2">8</span>
ghci<span class="token3">&gt;</span> prettyShow $ <span class="token2">5</span> <span class="token3">+</span> <span class="token2">1</span> <span class="token3">*</span> <span class="token2">3</span>
<span class="token4">"5+(1*3)"</span>
ghci<span class="token3">&gt;</span> prettyShow $ <span class="token2">5</span> <span class="token3">*</span> <span class="token2">1</span> <span class="token3">+</span> <span class="token2">3</span>
<span class="token4">"(5*1)+3"</span>

</code></pre>
<p class="calibre9">看起来不错，但还不够聪明。我们可以很容易地把 1* 从表达式里拿掉。写个函数来简化怎么样？</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> prettyShow $ simplify $ <span class="token2">5</span> <span class="token3">+</span> <span class="token2">1</span> <span class="token3">*</span> <span class="token2">3</span>
<span class="token4">"5+3"</span>

</code></pre>
<p class="calibre9">把数学表达式转成逆波兰表达式（RPN）怎么样？RPN 是一种后缀表示法，它不要求括号，常见于 HP 计算器。RPN 是一种基于栈的表达式。我们把数字放进栈里，当碰到操作符时，栈顶的数字出栈，结果再被放回栈里。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> rpnShow $ <span class="token2">5</span> <span class="token3">+</span> <span class="token2">1</span> <span class="token3">*</span> <span class="token2">3</span>
<span class="token4">"5 1 3 * +"</span>
ghci<span class="token3">&gt;</span> rpnShow $ simplify $ <span class="token2">5</span> <span class="token3">+</span> <span class="token2">1</span> <span class="token3">*</span> <span class="token2">3</span>
<span class="token4">"5 3 +"</span>

</code></pre>
<p class="calibre9">能表示含有未知符号的简单表达式也很不错。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> prettyShow $ <span class="token2">5</span> <span class="token3">+</span> <span class="token">(</span>Symbol <span class="token4">"x"</span><span class="token">)</span> <span class="token3">*</span> <span class="token2">3</span>
<span class="token4">"5+(x*3)"</span>

</code></pre>
<p class="calibre9">跟数字打交道时，单位常常很重要。例如，当你看见数字5时，它是5米，5英尺，还是5字节？当然，当你用5米除以2秒时，系统应该推出来正确的单位。而且，它应该阻止你用2秒加上5米。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token2">5</span> <span class="token3">/</span> <span class="token2">2</span>
<span class="token2">2.5</span>
ghci<span class="token3">&gt;</span> <span class="token">(</span>units <span class="token2">5</span> <span class="token4">"m"</span><span class="token">)</span> <span class="token3">/</span> <span class="token">(</span>units <span class="token2">2</span> <span class="token4">"s"</span><span class="token">)</span>
<span class="token2">2.5</span>_m<span class="token3">/</span>s
ghci<span class="token3">&gt;</span> <span class="token">(</span>units <span class="token2">5</span> <span class="token4">"m"</span><span class="token">)</span> <span class="token3">+</span> <span class="token">(</span>units <span class="token2">2</span> <span class="token4">"s"</span><span class="token">)</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> Mis<span class="token3">-</span>matched units <span class="token1">in</span> add
ghci<span class="token3">&gt;</span> <span class="token">(</span>units <span class="token2">5</span> <span class="token4">"m"</span><span class="token">)</span> <span class="token3">+</span> <span class="token">(</span>units <span class="token2">2</span> <span class="token4">"m"</span><span class="token">)</span>
<span class="token2">7</span>_m
ghci<span class="token3">&gt;</span> <span class="token">(</span>units <span class="token2">5</span> <span class="token4">"m"</span><span class="token">)</span> <span class="token3">/</span> <span class="token2">2</span>
<span class="token2">2.5</span>_m
ghci<span class="token3">&gt;</span> <span class="token2">10</span> <span class="token3">*</span> <span class="token">(</span>units <span class="token2">5</span> <span class="token4">"m"</span><span class="token">)</span> <span class="token3">/</span> <span class="token">(</span>units <span class="token2">2</span> <span class="token4">"s"</span><span class="token">)</span>
<span class="token2">25.0</span>_m<span class="token3">/</span>s

</code></pre>
<p class="calibre9">如果我们定义的表达式或函数对所有数字都合法，那我们就应该能计算出结果，或者把表达式转成字符串。例如，如果我们定义 test 的类型为 Numa=&gt;a，并令 test=2*5+3，那我们应该可以：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> test
<span class="token2">13</span>
ghci<span class="token3">&gt;</span> rpnShow test
<span class="token4">"2 5 * 3 +"</span>
ghci<span class="token3">&gt;</span> prettyShow test
<span class="token4">"(2*5)+3"</span>
ghci<span class="token3">&gt;</span> test <span class="token3">+</span> <span class="token2">5</span>
<span class="token2">18</span>
ghci<span class="token3">&gt;</span> prettyShow <span class="token">(</span>test <span class="token3">+</span> <span class="token2">5</span><span class="token">)</span>
<span class="token4">"((2*5)+3)+5"</span>
ghci<span class="token3">&gt;</span> rpnShow <span class="token">(</span>test <span class="token3">+</span> <span class="token2">5</span><span class="token">)</span>
<span class="token4">"2 5 * 3 + 5 +"</span>

</code></pre>
<p class="calibre9">既然我们能处理单位，那我们也应该能处理一些基本的三角函数，其中很多操作都是关于角的。让我们确保角度和弧度都能被处理。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> sin <span class="token">(</span>pi <span class="token3">/</span> <span class="token2">2</span><span class="token">)</span>
<span class="token2">1.0</span>
ghci<span class="token3">&gt;</span> sin <span class="token">(</span>units <span class="token">(</span>pi <span class="token3">/</span> <span class="token2">2</span><span class="token">)</span> <span class="token4">"rad"</span><span class="token">)</span>
<span class="token2">1.0</span>_1<span class="token">.</span><span class="token2">0</span>
ghci<span class="token3">&gt;</span> sin <span class="token">(</span>units <span class="token2">90</span> <span class="token4">"deg"</span><span class="token">)</span>
<span class="token2">1.0</span>_1<span class="token">.</span><span class="token2">0</span>
ghci<span class="token3">&gt;</span> <span class="token">(</span>units <span class="token2">50</span> <span class="token4">"m"</span><span class="token">)</span> <span class="token3">*</span> sin <span class="token">(</span>units <span class="token2">90</span> <span class="token4">"deg"</span><span class="token">)</span>
<span class="token2">50.0</span>_m

</code></pre>
<p class="calibre9">最后，我们应该能把这些都放在一起，把不同类型的表达式混合使用。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">(</span><span class="token">(</span>units <span class="token2">50</span> <span class="token4">"m"</span><span class="token">)</span> <span class="token3">*</span> sin <span class="token">(</span>units <span class="token2">90</span> <span class="token4">"deg"</span><span class="token">)</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> Units <span class="token">(</span>SymbolicManip Double<span class="token">)</span>
<span class="token2">50.0</span><span class="token3">*</span><span class="token5">sin</span><span class="token">(</span><span class="token">(</span><span class="token">(</span><span class="token2">2.0</span><span class="token3">*</span>pi<span class="token">)</span><span class="token3">*</span><span class="token2">90.0</span><span class="token">)</span><span class="token3">/</span><span class="token2">360.0</span><span class="token">)</span>_m
ghci<span class="token3">&gt;</span> prettyShow $ dropUnits $ <span class="token">(</span>units <span class="token2">50</span> <span class="token4">"m"</span><span class="token">)</span> <span class="token3">*</span> sin <span class="token">(</span>units <span class="token2">90</span> <span class="token4">"deg"</span><span class="token">)</span>
<span class="token4">"50.0*sin(((2.0*pi)*90.0)/360.0)"</span>
ghci<span class="token3">&gt;</span> rpnShow $ dropUnits $ <span class="token">(</span>units <span class="token2">50</span> <span class="token4">"m"</span><span class="token">)</span> <span class="token3">*</span> sin <span class="token">(</span>units <span class="token2">90</span> <span class="token4">"deg"</span><span class="token">)</span>
<span class="token4">"50.0 2.0 pi * 90.0 * 360.0 / sin *"</span>
ghci<span class="token3">&gt;</span> <span class="token">(</span>units <span class="token">(</span>Symbol <span class="token4">"x"</span><span class="token">)</span> <span class="token4">"m"</span><span class="token">)</span> <span class="token3">*</span> sin <span class="token">(</span>units <span class="token2">90</span> <span class="token4">"deg"</span><span class="token">)</span>
x<span class="token3">*</span><span class="token5">sin</span><span class="token">(</span><span class="token">(</span><span class="token">(</span><span class="token2">2.0</span><span class="token3">*</span>pi<span class="token">)</span><span class="token3">*</span><span class="token2">90.0</span><span class="token">)</span><span class="token3">/</span><span class="token2">360.0</span><span class="token">)</span>_m

</code></pre>
<p class="calibre9">你刚才看到的一切都可以用 Haskell 的类型和类型类实现。实际上，你看到的正是我们马上要实现的 num.hs。</p>
<h2 class="calibre14"><a id="chp-13.html._594" class="calibre7 pcalibre"></a>第一步</h2>
<p class="calibre9">我们想想怎么实现上面提到的功能。首先，用 <strong class="calibre12">ghci</strong> 查看一下可知，(+) 的类型是 Numa=&gt;a-&gt;a-&gt;a。如果我们想给加号实现一些自定义行为，我们就必须定义一个新类型并声明它为 Num 的实例。这个类型得用符号的形式来存储表达式。我们可以从加法操作开始。我们需要存储操作符本身、左侧以及右侧内容。左侧和右侧内容本身又可以是表达式。</p>
<p class="calibre9">我们可以把表达式想象成一棵树。让我们从一些简单类型开始。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>numsimple<span class="token">.</span>hs
<span class="token3">--</span> 我们支持的操作符
data Op <span class="token3">=</span> Plus <span class="token3">|</span> Minus <span class="token3">|</span> Mul <span class="token3">|</span> Div <span class="token3">|</span> Pow
        deriving <span class="token">(</span>Eq<span class="token">,</span> Show<span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> 核心符号操作类型（core symbolic manipulation type） <span class="token3">-</span><span class="token">}</span>
data SymbolicManip a <span class="token3">=</span>
          Number a           <span class="token3">--</span> Simple number<span class="token">,</span> such as <span class="token2">5</span>
        <span class="token3">|</span> Arith Op <span class="token">(</span>SymbolicManip a<span class="token">)</span> <span class="token">(</span>SymbolicManip a<span class="token">)</span>
          deriving <span class="token">(</span>Eq<span class="token">,</span> Show<span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> SymbolicManip 是 Num 的实例。定义 SymbolicManip 实现 Num 的函数。如<span class="token">(</span><span class="token3">+</span><span class="token">)</span>等。 <span class="token3">-</span><span class="token">}</span>
instance Num a <span class="token3">=</span><span class="token3">&gt;</span> Num <span class="token">(</span>SymbolicManip a<span class="token">)</span> where
    a <span class="token3">+</span> b <span class="token3">=</span> Arith Plus a b
    a <span class="token3">-</span> b <span class="token3">=</span> Arith Minus a b
    a <span class="token3">*</span> b <span class="token3">=</span> Arith Mul a b
    negate a <span class="token3">=</span> Arith Mul <span class="token">(</span>Number <span class="token">(</span><span class="token3">-</span><span class="token2">1</span><span class="token">)</span><span class="token">)</span> a
    abs a <span class="token3">=</span> error <span class="token4">"abs is unimplemented"</span>
    signum _ <span class="token3">=</span> error <span class="token4">"signum is unimplemented"</span>
    fromInteger i <span class="token3">=</span> Number <span class="token">(</span>fromInteger i<span class="token">)</span>

</code></pre>
<p class="calibre9">首先我们定义了 Op 类型。这个类型表示我们要支持的操作。接着，我们定义了 SymbolicManipa，由于 Numa 约束的存在，a 可替换为任何 Num 实例。我们可以有 SymbolicManipInt 这样的具体类型。</p>
<p class="calibre9">SymbolicManip 类型可以是数字，也可以是数学运算。Arith 构造器是递归的，这在 Haskell 里完全合法。Arith 用一个 Op 和两个 SymbolicManip 创建了一个 SymbolicManip。我们来看一个例子：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> <span class="token">:</span>l numsimple<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> numsimple<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>
<span class="token3">*</span>Main<span class="token3">&gt;</span> Number <span class="token2">5</span>
Number <span class="token2">5</span>
<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>t Number <span class="token2">5</span>
Number <span class="token2">5</span> <span class="token">:</span><span class="token">:</span> Num a <span class="token3">=</span><span class="token3">&gt;</span> SymbolicManip a
<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">:</span>t Number <span class="token">(</span><span class="token2">5</span><span class="token">:</span><span class="token">:</span>Int<span class="token">)</span>
Number <span class="token">(</span><span class="token2">5</span><span class="token">:</span><span class="token">:</span>Int<span class="token">)</span> <span class="token">:</span><span class="token">:</span> SymbolicManip Int
<span class="token3">*</span>Main<span class="token3">&gt;</span> Number <span class="token2">5</span> <span class="token3">*</span> Number <span class="token2">10</span>
Arith Mul <span class="token">(</span>Number <span class="token2">5</span><span class="token">)</span> <span class="token">(</span>Number <span class="token2">10</span><span class="token">)</span>
<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">(</span><span class="token2">5</span> <span class="token3">*</span> <span class="token2">10</span><span class="token">)</span><span class="token">:</span><span class="token">:</span>SymbolicManip Int
Arith Mul <span class="token">(</span>Number <span class="token2">5</span><span class="token">)</span> <span class="token">(</span>Number <span class="token2">10</span><span class="token">)</span>
<span class="token3">*</span>Main<span class="token3">&gt;</span> <span class="token">(</span><span class="token2">5</span> <span class="token3">*</span> <span class="token2">10</span> <span class="token3">+</span> <span class="token2">2</span><span class="token">)</span><span class="token">:</span><span class="token">:</span>SymbolicManip Int
Arith Plus <span class="token">(</span>Arith Mul <span class="token">(</span>Number <span class="token2">5</span><span class="token">)</span> <span class="token">(</span>Number <span class="token2">10</span><span class="token">)</span><span class="token">)</span> <span class="token">(</span>Number <span class="token2">2</span><span class="token">)</span>

</code></pre>
<p class="calibre9">可以看到，我们已经可以表示一些简单的表达式了。注意观察 Haskell 是如何把 5*10+2 “转换”成 SymbolicManip 值的，它甚至还正确处理了求值顺序。事实上，这并不是真正意义上的转换，因为 SymbolicManip 已经是一等数字（first-class number）了。就算 Integer 类型的数字字面量（numeric literals）在内部也是被包装在 fromInteger 里的，所以 5 作为一个 SymbolicManipInt 和作为一个 Int 同样有效。</p>
<p class="calibre9">从这儿开始，我们的任务就简单了：扩展 SymbolicManip，使它能表示所有我们想要的操作；把它声明为其它数字类型类的实例；为 SymbolicManip 实现我们自己的 Show 实例，使这棵树在显示时更友好。</p>
<h2 class="calibre14"><a id="chp-13.html._651" class="calibre7 pcalibre"></a>完整代码</h2>
<p class="calibre9">这里是完整的 num.hs，我们在本节开始的 <strong class="calibre12">ghci</strong> 例子中用到了它。我们来一点一点分析这段代码。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>num<span class="token">.</span>hs
import Data<span class="token">.</span>List

<span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span>
<span class="token3">--</span> Symbolic<span class="token3">/</span>units manipulation
<span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span>

<span class="token3">--</span> The <span class="token4">"operators"</span> that we're going to support
data Op <span class="token3">=</span> Plus <span class="token3">|</span> Minus <span class="token3">|</span> Mul <span class="token3">|</span> Div <span class="token3">|</span> Pow
        deriving <span class="token">(</span>Eq<span class="token">,</span> Show<span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> The core symbolic manipulation type<span class="token">.</span>  It can be a simple number<span class="token">,</span>
a symbol<span class="token">,</span> a binary arithmetic operation <span class="token">(</span>such as <span class="token3">+</span><span class="token">)</span><span class="token">,</span> or a unary
arithmetic operation <span class="token">(</span>such as cos<span class="token">)</span>

Notice the types of BinaryArith and UnaryArith<span class="token">:</span> it's a recursive
type<span class="token">.</span>  So<span class="token">,</span> we could represent a <span class="token">(</span><span class="token3">+</span><span class="token">)</span> over two SymbolicManips<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
data SymbolicManip a <span class="token3">=</span>
        Number a           <span class="token3">--</span> Simple number<span class="token">,</span> such as <span class="token2">5</span>
      <span class="token3">|</span> Symbol String      <span class="token3">--</span> A symbol<span class="token">,</span> such as x
      <span class="token3">|</span> BinaryArith Op <span class="token">(</span>SymbolicManip a<span class="token">)</span> <span class="token">(</span>SymbolicManip a<span class="token">)</span>
      <span class="token3">|</span> UnaryArith String <span class="token">(</span>SymbolicManip a<span class="token">)</span>
        deriving <span class="token">(</span>Eq<span class="token">)</span>

</code></pre>
<p class="calibre9">我们在这段代码中定义了 Op，和之前我们用到的一样。我们也定义了 SymbolicManip，它和我们之前用到的类似。在这个版本中，我们开始支持一元数学操作（unary arithmetic operations）（也就是接受一个参数的操作），例如 abs 和 cos。接下来我们来定义自己的 Num 实例。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>num<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span> SymbolicManip will be an instance of Num<span class="token">.</span>  Define how the Num
operations are handled over a SymbolicManip<span class="token">.</span>  This will implement things
like <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token1">for</span> SymbolicManip<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
instance Num a <span class="token3">=</span><span class="token3">&gt;</span> Num <span class="token">(</span>SymbolicManip a<span class="token">)</span> where
    a <span class="token3">+</span> b <span class="token3">=</span> BinaryArith Plus a b
    a <span class="token3">-</span> b <span class="token3">=</span> BinaryArith Minus a b
    a <span class="token3">*</span> b <span class="token3">=</span> BinaryArith Mul a b
    negate a <span class="token3">=</span> BinaryArith Mul <span class="token">(</span>Number <span class="token">(</span><span class="token3">-</span><span class="token2">1</span><span class="token">)</span><span class="token">)</span> a
    abs a <span class="token3">=</span> UnaryArith <span class="token4">"abs"</span> a
    signum _ <span class="token3">=</span> error <span class="token4">"signum is unimplemented"</span>
    fromInteger i <span class="token3">=</span> Number <span class="token">(</span>fromInteger i<span class="token">)</span>

</code></pre>
<p class="calibre9">非常直观，和之前的代码很像。注意之前我们不支持 abs，但现在可以了，因为有了 UnaryArith。接下来，我们再定义几个实例。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>num<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span> 定义 SymbolicManip 为 Fractional 实例 <span class="token3">-</span><span class="token">}</span>
instance <span class="token">(</span>Fractional a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> Fractional <span class="token">(</span>SymbolicManip a<span class="token">)</span> where
    a <span class="token3">/</span> b <span class="token3">=</span> BinaryArith Div a b
    recip a <span class="token3">=</span> BinaryArith Div <span class="token">(</span>Number <span class="token2">1</span><span class="token">)</span> a
    fromRational r <span class="token3">=</span> Number <span class="token">(</span>fromRational r<span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> 定义 SymbolicManip 为 Floating 实例 <span class="token3">-</span><span class="token">}</span>
instance <span class="token">(</span>Floating a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> Floating <span class="token">(</span>SymbolicManip a<span class="token">)</span> where
    pi <span class="token3">=</span> Symbol <span class="token4">"pi"</span>
    exp a <span class="token3">=</span> UnaryArith <span class="token4">"exp"</span> a
    log a <span class="token3">=</span> UnaryArith <span class="token4">"log"</span> a
    sqrt a <span class="token3">=</span> UnaryArith <span class="token4">"sqrt"</span> a
    a <span class="token3">*</span><span class="token3">*</span> b <span class="token3">=</span> BinaryArith Pow a b
    sin a <span class="token3">=</span> UnaryArith <span class="token4">"sin"</span> a
    cos a <span class="token3">=</span> UnaryArith <span class="token4">"cos"</span> a
    tan a <span class="token3">=</span> UnaryArith <span class="token4">"tan"</span> a
    asin a <span class="token3">=</span> UnaryArith <span class="token4">"asin"</span> a
    acos a <span class="token3">=</span> UnaryArith <span class="token4">"acos"</span> a
    atan a <span class="token3">=</span> UnaryArith <span class="token4">"atan"</span> a
    sinh a <span class="token3">=</span> UnaryArith <span class="token4">"sinh"</span> a
    cosh a <span class="token3">=</span> UnaryArith <span class="token4">"cosh"</span> a
    tanh a <span class="token3">=</span> UnaryArith <span class="token4">"tanh"</span> a
    asinh a <span class="token3">=</span> UnaryArith <span class="token4">"asinh"</span> a
    acosh a <span class="token3">=</span> UnaryArith <span class="token4">"acosh"</span> a
    atanh a <span class="token3">=</span> UnaryArith <span class="token4">"atanh"</span> a

</code></pre>
<p class="calibre9">这段代码直观地定义了 Fractional 和 Floating 实例。接下来，我们把表达式转换字符串。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>num<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span> 使用常规代数表示法，把 SymbolicManip 转换为字符串 <span class="token3">-</span><span class="token">}</span>
prettyShow <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Show a<span class="token">,</span> Num a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> SymbolicManip a <span class="token3">-</span><span class="token3">&gt;</span> String

<span class="token3">--</span> 显示字符或符号
prettyShow <span class="token">(</span>Number x<span class="token">)</span> <span class="token3">=</span> show x
prettyShow <span class="token">(</span>Symbol x<span class="token">)</span> <span class="token3">=</span> x

prettyShow <span class="token">(</span>BinaryArith op a b<span class="token">)</span> <span class="token3">=</span>
    let pa <span class="token3">=</span> simpleParen a
        pb <span class="token3">=</span> simpleParen b
        pop <span class="token3">=</span> op2str op
        <span class="token1">in</span> pa <span class="token3">++</span> pop <span class="token3">++</span> pb
prettyShow <span class="token">(</span>UnaryArith opstr a<span class="token">)</span> <span class="token3">=</span>
    opstr <span class="token3">++</span> <span class="token4">"("</span> <span class="token3">++</span> show a <span class="token3">++</span> <span class="token4">")"</span>

op2str <span class="token">:</span><span class="token">:</span> Op <span class="token3">-</span><span class="token3">&gt;</span> String
op2str Plus <span class="token3">=</span> <span class="token4">"+"</span>
op2str Minus <span class="token3">=</span> <span class="token4">"-"</span>
op2str Mul <span class="token3">=</span> <span class="token4">"*"</span>
op2str Div <span class="token3">=</span> <span class="token4">"/"</span>
op2str Pow <span class="token3">=</span> <span class="token4">"**"</span>

<span class="token">{</span><span class="token3">-</span> 在需要的地方添加括号。这个函数比较保守，有时候不需要也会加。
Haskell 在构建 SymbolicManip 的时候已经处理好优先级了。<span class="token3">-</span><span class="token">}</span>
simpleParen <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Show a<span class="token">,</span> Num a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> SymbolicManip a <span class="token3">-</span><span class="token3">&gt;</span> String
simpleParen <span class="token">(</span>Number x<span class="token">)</span> <span class="token3">=</span> prettyShow <span class="token">(</span>Number x<span class="token">)</span>
simpleParen <span class="token">(</span>Symbol x<span class="token">)</span> <span class="token3">=</span> prettyShow <span class="token">(</span>Symbol x<span class="token">)</span>
simpleParen x@<span class="token">(</span>BinaryArith _ _ _<span class="token">)</span> <span class="token3">=</span> <span class="token4">"("</span> <span class="token3">++</span> prettyShow x <span class="token3">++</span> <span class="token4">")"</span>
simpleParen x@<span class="token">(</span>UnaryArith _ _<span class="token">)</span> <span class="token3">=</span> prettyShow x

<span class="token">{</span><span class="token3">-</span> 调用 prettyShow 函数显示 SymbolicManip 值 <span class="token3">-</span><span class="token">}</span>
instance <span class="token">(</span>Show a<span class="token">,</span> Num a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> Show <span class="token">(</span>SymbolicManip a<span class="token">)</span> where
    show a <span class="token3">=</span> prettyShow a

</code></pre>
<p class="calibre9">首先我们定义了 prettyShow 函数。它把一个表达式转换成常规表达形式。算法相当简单：数字和符号不做处理；二元操作是转换后两侧的内容加上中间的操作符；当然我们也处理了一元操作。op2str 把 Op 转为 String。在 simpleParen 里，我们加括号的算法非常保守，以确保优先级在结果里清楚显示。最后，我们声明 SymbolicManip 为 Show 的实例然后用 prettyShow 来实现。现在，我们来设计一个算法把表达式转为 RPN 形式的字符串。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>num<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span> Show a SymbolicManip using RPN<span class="token">.</span>  HP calculator users may
find this familiar<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
rpnShow <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Show a<span class="token">,</span> Num a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> SymbolicManip a <span class="token3">-</span><span class="token3">&gt;</span> String
rpnShow i <span class="token3">=</span>
    let toList <span class="token">(</span>Number x<span class="token">)</span> <span class="token3">=</span> <span class="token">[</span>show x<span class="token">]</span>
        toList <span class="token">(</span>Symbol x<span class="token">)</span> <span class="token3">=</span> <span class="token">[</span>x<span class="token">]</span>
        toList <span class="token">(</span>BinaryArith op a b<span class="token">)</span> <span class="token3">=</span> toList a <span class="token3">++</span> toList b <span class="token3">++</span>
            <span class="token">[</span>op2str op<span class="token">]</span>
        toList <span class="token">(</span>UnaryArith op a<span class="token">)</span> <span class="token3">=</span> toList a <span class="token3">++</span> <span class="token">[</span>op<span class="token">]</span>
        join <span class="token">:</span><span class="token">:</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span><span class="token">[</span>a<span class="token">]</span><span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span>
        join delim l <span class="token3">=</span> concat <span class="token">(</span>intersperse delim l<span class="token">)</span>
    <span class="token1">in</span> join <span class="token4">" "</span> <span class="token">(</span>toList i<span class="token">)</span>

</code></pre>
<p class="calibre9">RPN 爱好者会发现，跟上面的算法相比，这个算法是多么简洁。尤其是，我们根本不用关心要从哪里加括号，因为 RPN 天生只能沿着一个方向求值。接下来，我们写个函数来实现一些基本的表达式化简。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>num<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span> Perform some basic algebraic simplifications on a SymbolicManip<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
simplify <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Eq a<span class="token">,</span> Num a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> SymbolicManip a <span class="token3">-</span><span class="token3">&gt;</span> SymbolicManip a
simplify <span class="token">(</span>BinaryArith op ia ib<span class="token">)</span> <span class="token3">=</span>
    let sa <span class="token3">=</span> simplify ia
        sb <span class="token3">=</span> simplify ib
        <span class="token1">in</span>
        case <span class="token">(</span>op<span class="token">,</span> sa<span class="token">,</span> sb<span class="token">)</span> of
                <span class="token">(</span>Mul<span class="token">,</span> Number <span class="token2">1</span><span class="token">,</span> b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> b
                <span class="token">(</span>Mul<span class="token">,</span> a<span class="token">,</span> Number <span class="token2">1</span><span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> a
                <span class="token">(</span>Mul<span class="token">,</span> Number <span class="token2">0</span><span class="token">,</span> b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> Number <span class="token2">0</span>
                <span class="token">(</span>Mul<span class="token">,</span> a<span class="token">,</span> Number <span class="token2">0</span><span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> Number <span class="token2">0</span>
                <span class="token">(</span>Div<span class="token">,</span> a<span class="token">,</span> Number <span class="token2">1</span><span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> a
                <span class="token">(</span>Plus<span class="token">,</span> a<span class="token">,</span> Number <span class="token2">0</span><span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> a
                <span class="token">(</span>Plus<span class="token">,</span> Number <span class="token2">0</span><span class="token">,</span> b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> b
                <span class="token">(</span>Minus<span class="token">,</span> a<span class="token">,</span> Number <span class="token2">0</span><span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> a
                _ <span class="token3">-</span><span class="token3">&gt;</span> BinaryArith op sa sb
simplify <span class="token">(</span>UnaryArith op a<span class="token">)</span> <span class="token3">=</span> UnaryArith op <span class="token">(</span>simplify a<span class="token">)</span>
simplify x <span class="token3">=</span> x

</code></pre>
<p class="calibre9">这个函数相当简单。我们很轻易地就能化简某些二元数学运算——例如，用1乘以任何值。我们首先得到操作符两侧操作数被化简之后的版本（在这儿用到了递归）然后再化简结果。对于一元操作符我们能做的不多，所以我们仅仅简化它们作用于的表达式。</p>
<p class="calibre9">从现在开始，我们会增加对计量单位的支持。增加之后我们就能表示“5米”这种数量了。跟之前一样，我们先来定义一个类型：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>num<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span> 新数据类型：Units。Units 类型包含一个数字和一个 SymbolicManip，也就是计量单位。
计量单位符号可以是 <span class="token">(</span>Symbol <span class="token4">"m"</span><span class="token">)</span> 这个样子。 <span class="token3">-</span><span class="token">}</span>
data Units a <span class="token3">=</span> Units a <span class="token">(</span>SymbolicManip a<span class="token">)</span>
             deriving <span class="token">(</span>Eq<span class="token">)</span>

</code></pre>
<p class="calibre9">一个 Units 值包含一个数字和一个符号。符号本身是 SymbolicManip 类型。接下来，将 Units 声明为 Num 实例。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>num<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span> 为 Units 实现 Num 实例。我们不知道如何转换任意单位，因此当不同单位的数字相加时，我们报告错误。
对于乘法，我们生成对应的新单位。 <span class="token3">-</span><span class="token">}</span>
instance <span class="token">(</span>Eq a<span class="token">,</span> Num a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> Num <span class="token">(</span>Units a<span class="token">)</span> where
    <span class="token">(</span>Units xa ua<span class="token">)</span> <span class="token3">+</span> <span class="token">(</span>Units xb ub<span class="token">)</span>
        <span class="token3">|</span> ua <span class="token3">==</span> ub <span class="token3">=</span> Units <span class="token">(</span>xa <span class="token3">+</span> xb<span class="token">)</span> ua
        <span class="token3">|</span> otherwise <span class="token3">=</span> error <span class="token4">"Mis-matched units in add or subtract"</span>
    <span class="token">(</span>Units xa ua<span class="token">)</span> <span class="token3">-</span> <span class="token">(</span>Units xb ub<span class="token">)</span> <span class="token3">=</span> <span class="token">(</span>Units xa ua<span class="token">)</span> <span class="token3">+</span> <span class="token">(</span>Units <span class="token">(</span>xb <span class="token3">*</span> <span class="token">(</span><span class="token3">-</span><span class="token2">1</span><span class="token">)</span><span class="token">)</span> ub<span class="token">)</span>
    <span class="token">(</span>Units xa ua<span class="token">)</span> <span class="token3">*</span> <span class="token">(</span>Units xb ub<span class="token">)</span> <span class="token3">=</span> Units <span class="token">(</span>xa <span class="token3">*</span> xb<span class="token">)</span> <span class="token">(</span>ua <span class="token3">*</span> ub<span class="token">)</span>
    negate <span class="token">(</span>Units xa ua<span class="token">)</span> <span class="token3">=</span> Units <span class="token">(</span>negate xa<span class="token">)</span> ua
    abs <span class="token">(</span>Units xa ua<span class="token">)</span> <span class="token3">=</span> Units <span class="token">(</span>abs xa<span class="token">)</span> ua
    signum <span class="token">(</span>Units xa _<span class="token">)</span> <span class="token3">=</span> Units <span class="token">(</span>signum xa<span class="token">)</span> <span class="token">(</span>Number <span class="token2">1</span><span class="token">)</span>
    fromInteger i <span class="token3">=</span> Units <span class="token">(</span>fromInteger i<span class="token">)</span> <span class="token">(</span>Number <span class="token2">1</span><span class="token">)</span>

</code></pre>
<p class="calibre9">现在，我们应该清楚为什么要用 SymbolicManip 而不是 String 来存储计量单位了。做乘法时，计量单位也会发生改变。例如，5米乘以2米会得到10平方米。我们要求加法运算的单位必须匹配，并用加法实现了减法。我们再来看几个 Units 的类型类实例。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>num<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span> Make Units an instance of Fractional <span class="token3">-</span><span class="token">}</span>
instance <span class="token">(</span>Eq a<span class="token">,</span> Fractional a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> Fractional <span class="token">(</span>Units a<span class="token">)</span> where
    <span class="token">(</span>Units xa ua<span class="token">)</span> <span class="token3">/</span> <span class="token">(</span>Units xb ub<span class="token">)</span> <span class="token3">=</span> Units <span class="token">(</span>xa <span class="token3">/</span> xb<span class="token">)</span> <span class="token">(</span>ua <span class="token3">/</span> ub<span class="token">)</span>
    recip a <span class="token3">=</span> <span class="token2">1</span> <span class="token3">/</span> a
    fromRational r <span class="token3">=</span> Units <span class="token">(</span>fromRational r<span class="token">)</span> <span class="token">(</span>Number <span class="token2">1</span><span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> Floating implementation <span class="token1">for</span> Units<span class="token">.</span>

Use some intelligence <span class="token1">for</span> angle calculations<span class="token">:</span> support deg and rad
<span class="token3">-</span><span class="token">}</span>
instance <span class="token">(</span>Eq a<span class="token">,</span> Floating a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> Floating <span class="token">(</span>Units a<span class="token">)</span> where
    pi <span class="token3">=</span> <span class="token">(</span>Units pi <span class="token">(</span>Number <span class="token2">1</span><span class="token">)</span><span class="token">)</span>
    exp _ <span class="token3">=</span> error <span class="token4">"exp not yet implemented in Units"</span>
    log _ <span class="token3">=</span> error <span class="token4">"log not yet implemented in Units"</span>
    <span class="token">(</span>Units xa ua<span class="token">)</span> <span class="token3">*</span><span class="token3">*</span> <span class="token">(</span>Units xb ub<span class="token">)</span>
        <span class="token3">|</span> ub <span class="token3">==</span> Number <span class="token2">1</span> <span class="token3">=</span> Units <span class="token">(</span>xa <span class="token3">*</span><span class="token3">*</span> xb<span class="token">)</span> <span class="token">(</span>ua <span class="token3">*</span><span class="token3">*</span> Number xb<span class="token">)</span>
        <span class="token3">|</span> otherwise <span class="token3">=</span> error <span class="token4">"units for RHS of ** not supported"</span>
    sqrt <span class="token">(</span>Units xa ua<span class="token">)</span> <span class="token3">=</span> Units <span class="token">(</span>sqrt xa<span class="token">)</span> <span class="token">(</span>sqrt ua<span class="token">)</span>
    sin <span class="token">(</span>Units xa ua<span class="token">)</span>
        <span class="token3">|</span> ua <span class="token3">==</span> Symbol <span class="token4">"rad"</span> <span class="token3">=</span> Units <span class="token">(</span>sin xa<span class="token">)</span> <span class="token">(</span>Number <span class="token2">1</span><span class="token">)</span>
        <span class="token3">|</span> ua <span class="token3">==</span> Symbol <span class="token4">"deg"</span> <span class="token3">=</span> Units <span class="token">(</span>sin <span class="token">(</span>deg2rad xa<span class="token">)</span><span class="token">)</span> <span class="token">(</span>Number <span class="token2">1</span><span class="token">)</span>
        <span class="token3">|</span> otherwise <span class="token3">=</span> error <span class="token4">"Units for sin must be deg or rad"</span>
    cos <span class="token">(</span>Units xa ua<span class="token">)</span>
        <span class="token3">|</span> ua <span class="token3">==</span> Symbol <span class="token4">"rad"</span> <span class="token3">=</span> Units <span class="token">(</span>cos xa<span class="token">)</span> <span class="token">(</span>Number <span class="token2">1</span><span class="token">)</span>
        <span class="token3">|</span> ua <span class="token3">==</span> Symbol <span class="token4">"deg"</span> <span class="token3">=</span> Units <span class="token">(</span>cos <span class="token">(</span>deg2rad xa<span class="token">)</span><span class="token">)</span> <span class="token">(</span>Number <span class="token2">1</span><span class="token">)</span>
        <span class="token3">|</span> otherwise <span class="token3">=</span> error <span class="token4">"Units for cos must be deg or rad"</span>
    tan <span class="token">(</span>Units xa ua<span class="token">)</span>
        <span class="token3">|</span> ua <span class="token3">==</span> Symbol <span class="token4">"rad"</span> <span class="token3">=</span> Units <span class="token">(</span>tan xa<span class="token">)</span> <span class="token">(</span>Number <span class="token2">1</span><span class="token">)</span>
        <span class="token3">|</span> ua <span class="token3">==</span> Symbol <span class="token4">"deg"</span> <span class="token3">=</span> Units <span class="token">(</span>tan <span class="token">(</span>deg2rad xa<span class="token">)</span><span class="token">)</span> <span class="token">(</span>Number <span class="token2">1</span><span class="token">)</span>
        <span class="token3">|</span> otherwise <span class="token3">=</span> error <span class="token4">"Units for tan must be deg or rad"</span>
    asin <span class="token">(</span>Units xa ua<span class="token">)</span>
        <span class="token3">|</span> ua <span class="token3">==</span> Number <span class="token2">1</span> <span class="token3">=</span> Units <span class="token">(</span>rad2deg $ asin xa<span class="token">)</span> <span class="token">(</span>Symbol <span class="token4">"deg"</span><span class="token">)</span>
        <span class="token3">|</span> otherwise <span class="token3">=</span> error <span class="token4">"Units for asin must be empty"</span>
    acos <span class="token">(</span>Units xa ua<span class="token">)</span>
        <span class="token3">|</span> ua <span class="token3">==</span> Number <span class="token2">1</span> <span class="token3">=</span> Units <span class="token">(</span>rad2deg $ acos xa<span class="token">)</span> <span class="token">(</span>Symbol <span class="token4">"deg"</span><span class="token">)</span>
        <span class="token3">|</span> otherwise <span class="token3">=</span> error <span class="token4">"Units for acos must be empty"</span>
    atan <span class="token">(</span>Units xa ua<span class="token">)</span>
        <span class="token3">|</span> ua <span class="token3">==</span> Number <span class="token2">1</span> <span class="token3">=</span> Units <span class="token">(</span>rad2deg $ atan xa<span class="token">)</span> <span class="token">(</span>Symbol <span class="token4">"deg"</span><span class="token">)</span>
        <span class="token3">|</span> otherwise <span class="token3">=</span> error <span class="token4">"Units for atan must be empty"</span>
    sinh <span class="token3">=</span> error <span class="token4">"sinh not yet implemented in Units"</span>
    cosh <span class="token3">=</span> error <span class="token4">"cosh not yet implemented in Units"</span>
    tanh <span class="token3">=</span> error <span class="token4">"tanh not yet implemented in Units"</span>
    asinh <span class="token3">=</span> error <span class="token4">"asinh not yet implemented in Units"</span>
    acosh <span class="token3">=</span> error <span class="token4">"acosh not yet implemented in Units"</span>
    atanh <span class="token3">=</span> error <span class="token4">"atanh not yet implemented in Units"</span>

</code></pre>
<p class="calibre9">虽然没有实现所有函数，但大部分都定义了。现在我们来定义几个跟单位打交道的工具函数。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>num<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span> A simple <span class="token1">function</span> that takes a number and a String and returns an
appropriate Units type to represent the number and its unit of measure <span class="token3">-</span><span class="token">}</span>
units <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Num z<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> z <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> Units z
units a b <span class="token3">=</span> Units a <span class="token">(</span>Symbol b<span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> Extract the number only out of a Units type <span class="token3">-</span><span class="token">}</span>
dropUnits <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Num z<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> Units z <span class="token3">-</span><span class="token3">&gt;</span> z
dropUnits <span class="token">(</span>Units x _<span class="token">)</span> <span class="token3">=</span> x

<span class="token">{</span><span class="token3">-</span> Utilities <span class="token1">for</span> the Unit implementation <span class="token3">-</span><span class="token">}</span>
deg2rad x <span class="token3">=</span> <span class="token2">2</span> <span class="token3">*</span> pi <span class="token3">*</span> x <span class="token3">/</span> <span class="token2">360</span>
rad2deg x <span class="token3">=</span> <span class="token2">360</span> <span class="token3">*</span> x <span class="token3">/</span> <span class="token">(</span><span class="token2">2</span> <span class="token3">*</span> pi<span class="token">)</span>

</code></pre>
<p class="calibre9">首先我们定义了 units，使表达式更简洁。units5"m" 肯定要比 Units5(Symbol"m") 省事。我们还定义了 dropUnits，它把单位去掉只返回 Num。最后，我们定义了两个函数，用来在角度和弧度之间转换。接下来，我们给 Units 定义 Show 实例。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>num<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span> Showing units<span class="token">:</span> we show the numeric component<span class="token">,</span> an underscore<span class="token">,</span>
then the prettyShow version of the simplified units <span class="token3">-</span><span class="token">}</span>
instance <span class="token">(</span>Eq a<span class="token">,</span> Show a<span class="token">,</span> Num a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> Show <span class="token">(</span>Units a<span class="token">)</span> where
    show <span class="token">(</span>Units xa ua<span class="token">)</span> <span class="token3">=</span> show xa <span class="token3">++</span> <span class="token4">"_"</span> <span class="token3">++</span> prettyShow <span class="token">(</span>simplify ua<span class="token">)</span>

</code></pre>
<p class="calibre9">很简单。最后我们定义 test 变量用来测试。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>num<span class="token">.</span>hs
test <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Num a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> a
test <span class="token3">=</span> <span class="token2">2</span> <span class="token3">*</span> <span class="token2">5</span> <span class="token3">+</span> <span class="token2">3</span>

</code></pre>
<p class="calibre9">回头看看这些代码，我们已经完成了既定目标：给 SymbolicManip 实现更多实例；我们引入了新类型 Units，它包含一个数字和一个单位；我们实现了几个 show 函数，以便用不同的方式来转换 SymbolicManip 和 Units。</p>
<p class="calibre9">这个例子还给了我们另外一点启发。所有语言——即使那些包含对象和重载的——都有从某种角度看很独特的地方。在 Haskell 里，这个“特殊”的部分很小。我们刚刚开发了一种新的表示法用来表示像数字一样基本的东西，而且很容易就实现了。我们的新类型是一等类型，编译器在编译时就知道使用它哪个函数。Haskell 把代码复用和互换（interchangeability）发挥到了极致。写通用代码很容易，而且很方便就能把它们用于多种不同类型的东西上。同样容易的是创建新类型并使它们自动成为系统的一等功能（first-class features）。</p>
<p class="calibre9">还记得本节开头的 <strong class="calibre12">ghci</strong> 例子吗？ 我们已经实现了它的全部功能。你可以自己试试，看看它们是怎么工作的。</p>
<h2 class="calibre14"><a id="chp-13.html._945" class="calibre7 pcalibre"></a>练习</h2>
<ol class="calibre17"><li class="calibre11">扩展 prettyShow 函数，去掉不必要的括号。</li></ol>
<h2 class="calibre14"><a id="chp-13.html._949" class="calibre7 pcalibre"></a>把函数当成数据来用</h2>
<p class="calibre9">在命令式语言当中，拼接两个列表很容易。下面的 C 语言结构维护了指向列表头尾的指针：</p>
<pre class="calibre15"><code class="tthhighlight-container">struct list <span class="token">{</span>
    struct node <span class="token3">*</span>head<span class="token">,</span> <span class="token3">*</span>tail<span class="token">;</span>
<span class="token">}</span><span class="token">;</span>

</code></pre>
<p class="calibre9">当我们想把列表 B 拼接到列表 A 的尾部时，我们将 A 的最后一个节点指向 B 的 head 节点，再把 A 的 tail 指针指向 B 的 tail 节点。</p>
<p class="calibre9">很显然，在 Haskell 里，如果我们想保持“纯”的话，这种方法是有局限性的。由于纯数据是不可变的，我们无法原地修改列表。Haskell 的 (++) 操作符通过生成一个新列表来拼接列表。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>Append<span class="token">.</span>hs
<span class="token">(</span><span class="token3">++</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span>
<span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token3">++</span> ys <span class="token3">=</span> x <span class="token">:</span> xs <span class="token3">++</span> ys
_      <span class="token3">++</span> ys <span class="token3">=</span> ys

</code></pre>
<p class="calibre9">从代码里可以看出，创建新列表的开销取决于第一个列表的长度。</p>
<p class="calibre9">我们经常需要通过重复拼接列表来创建一个大列表。例如，在生成网页内容时我们可能想生成一个 String。每当有新内容添加到网页中时，我们会很自然地想到把它拼接到已有 String 的末尾。</p>
<p class="calibre9">如果每一次拼接的开销都正比与初始列表的长度，每一次拼接都把初始列表加的更长，那么我们将会陷入一个很糟糕的情况：所有拼接的总开销将会正比于最终列表长度的平方。</p>
<p class="calibre9">为了更好地理解，我们来研究一下。(++) 操作符是右结合的。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>info <span class="token">(</span><span class="token3">++</span><span class="token">)</span>
<span class="token">(</span><span class="token3">++</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span>   <span class="token3">--</span> Defined <span class="token1">in</span> GHC<span class="token">.</span>Base
infixr <span class="token2">5</span> <span class="token3">++</span>

</code></pre>
<p class="calibre9">这意味着 Haskell 在求值表达式 "a"++"b"++"c" 时会从右向左进行，就像加了括号一样："a"++("b"++"c")。这对于提高性能非常有好处，因为它会让左侧操作数始终保持最短。</p>
<p class="calibre9">当我们重复向列表末尾拼接时，我们破坏了这种结合性。假设我们有一个列表 "a" 然后想把 "b" 拼接上去，我们把结果存储在一个新列表里。稍后如果我们想把 "c" 拼接上去时，这时的左操作数已经变成了 "ab"。在这种情况下，每次拼接都让左操作数变得更长。</p>
<p class="calibre9">与此同时，命令式语言的程序员却在偷笑，因为他们重复拼接的开销只取决于操作的次数。他们的性能是线性的，我们的是平方的。</p>
<p class="calibre9">当像重复拼接列表这种常见任务都暴露出如此严重的性能问题时，我们有必要从另一个角度来看看问题了。</p>
<p class="calibre9">表达式 ("a"++) 是一个 <a href="#chp-13.html." class="calibre7 pcalibre"><em class="calibre13">节</em></a> (section)，一个部分应用的函数。它的类型是什么呢？</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token">(</span><span class="token4">"a"</span> <span class="token3">++</span><span class="token">)</span>
<span class="token">(</span><span class="token4">"a"</span> <span class="token3">++</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Char<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>Char<span class="token">]</span>

</code></pre>
<p class="calibre9">由于这是一个函数，我们可以用 (.) 操作符把它和另一个节组合起来，例如 ("b"++)。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type <span class="token">(</span><span class="token4">"a"</span> <span class="token3">++</span><span class="token">)</span> <span class="token">.</span> <span class="token">(</span><span class="token4">"b"</span> <span class="token3">++</span><span class="token">)</span>
<span class="token">(</span><span class="token4">"a"</span> <span class="token3">++</span><span class="token">)</span> <span class="token">.</span> <span class="token">(</span><span class="token4">"b"</span> <span class="token3">++</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Char<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>Char<span class="token">]</span>

</code></pre>
<p class="calibre9">新函数的类型和之前相同。当我们停止组合函数，并向我们创造的函数提供一个 String 会发生什么呢？</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> let f <span class="token3">=</span> <span class="token">(</span><span class="token4">"a"</span> <span class="token3">++</span><span class="token">)</span> <span class="token">.</span> <span class="token">(</span><span class="token4">"b"</span> <span class="token3">++</span><span class="token">)</span>
ghci<span class="token3">&gt;</span> f <span class="token">[</span><span class="token">]</span>
<span class="token4">"ab"</span>

</code></pre>
<p class="calibre9">我们实现了字符串拼接！我们利用这些部分应用的函数来存储数据，并且只要提供一个空列表就可以把数据提取出来。每一个 (++) 和 (.) 部分应用都代表了一次拼接，但它们并没有真正完成拼接。</p>
<p class="calibre9">这个方法有两点非常有趣。第一点是部分应用的开销是固定的，这样多次部分应用的开销就是线性的。第二点是当我们提供一个 [] 值来从部分应用链中提取最终列表时，求值会从右至左进行。这使得 (++) 的左操作数尽可能小，使得所有拼接的总开销是线性而不是平方。</p>
<p class="calibre9">通过使用这种并不太熟悉的数据表示方式，我们避免了一个性能泥潭，并且对“把函数当成数据来用”有了新的认识。顺便说一下，这个技巧并不新鲜，它通常被称为<em class="calibre13">差异列表</em>（difference list）。</p>
<p class="calibre9">还有一点没讲。尽管从理论上看差异列表非常吸引人，但如果在实际中把 (++)、(.) 和部分应用都暴露在外的话，它并不会非常好用。我们需要把它转成一种更好用的形式。</p>
<h2 class="calibre14"><a id="chp-13.html._1028" class="calibre7 pcalibre"></a>把差异列表转成库</h2>
<p class="calibre9">第一步是用 newtype 声明把底层的类型隐藏起来。我们会创建一个 DList 类型。类似于普通列表，它是一个参数化类型。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>DList<span class="token">.</span>hs
newtype DList a <span class="token3">=</span> DL <span class="token">{</span>
    unDL <span class="token">:</span><span class="token">:</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span>
    <span class="token">}</span>

</code></pre>
<p class="calibre9">unDL 是我们的析构函数，它把 DL 构造器删除掉。我们最后导出模块函数时会忽略掉构造函数和析构函数，这样我们的用户就没必要知道 DList 类型的实现细节。他们只用我们导出的函数即可。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>DList<span class="token">.</span>hs
append <span class="token">:</span><span class="token">:</span> DList a <span class="token3">-</span><span class="token3">&gt;</span> DList a <span class="token3">-</span><span class="token3">&gt;</span> DList a
append xs ys <span class="token3">=</span> DL <span class="token">(</span>unDL xs <span class="token">.</span> unDL ys<span class="token">)</span>

</code></pre>
<p class="calibre9">我们的 append 函数看起来可能有点复杂，但其实它仅仅是围绕着 (.) 操作符做了一些簿记工作，(.) 的用法和我们之前展示的完全一样。生成函数的时候，我们必须首先用 unDL 函数把它们从 DL 构造器中取出来。然后我们在把得到的结果重新用 DL 包装起来，确保它的类型正确。</p>
<p class="calibre9">下面是相同函数的另一种写法，这种方法通过模式识别取出 xs 和 ys。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>DList<span class="token">.</span>hs
append' <span class="token">:</span><span class="token">:</span> DList a <span class="token3">-</span><span class="token3">&gt;</span> DList a <span class="token3">-</span><span class="token3">&gt;</span> DList a
append' <span class="token">(</span>DL xs<span class="token">)</span> <span class="token">(</span>DL ys<span class="token">)</span> <span class="token3">=</span> DL <span class="token">(</span>xs <span class="token">.</span> ys<span class="token">)</span>

</code></pre>
<p class="calibre9">我们需要在 DList 类型和普通列表之间来回转换。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>DList<span class="token">.</span>hs
fromList <span class="token">:</span><span class="token">:</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> DList a
fromList xs <span class="token3">=</span> DL <span class="token">(</span>xs <span class="token3">++</span><span class="token">)</span>

toList <span class="token">:</span><span class="token">:</span> DList a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span>
toList <span class="token">(</span>DL xs<span class="token">)</span> <span class="token3">=</span> xs <span class="token">[</span><span class="token">]</span>

</code></pre>
<p class="calibre9">再次声明，跟这些函数最原始的版本相比，我们在这里做的只是一些簿记工作。</p>
<p class="calibre9">如果我们想把 DList 作为普通列表的替代品，我们还需要提供一些常用的列表操作。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>DList<span class="token">.</span>hs
empty <span class="token">:</span><span class="token">:</span> DList a
empty <span class="token3">=</span> DL id

<span class="token3">--</span> equivalent of the list type's <span class="token">(</span><span class="token">:</span><span class="token">)</span> operator
cons <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> DList a <span class="token3">-</span><span class="token3">&gt;</span> DList a
cons x <span class="token">(</span>DL xs<span class="token">)</span> <span class="token3">=</span> DL <span class="token">(</span><span class="token">(</span>x<span class="token">:</span><span class="token">)</span> <span class="token">.</span> xs<span class="token">)</span>
infixr `cons`

dfoldr <span class="token">:</span><span class="token">:</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> b <span class="token3">-</span><span class="token3">&gt;</span> b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> b <span class="token3">-</span><span class="token3">&gt;</span> DList a <span class="token3">-</span><span class="token3">&gt;</span> b
dfoldr f z xs <span class="token3">=</span> foldr f z <span class="token">(</span>toList xs<span class="token">)</span>

</code></pre>
<p class="calibre9">尽管 DList 使得拼接很廉价，但并不是所有的列表操作都容易实现。列表的 head 函数具有常数开销，而对应的 DList 实现却需要将整个 DList 转为普通列表，因此它比普通列表的实现昂贵得多：它的开销正比于构造 DList 所需的拼接次数。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>DList<span class="token">.</span>hs
safeHead <span class="token">:</span><span class="token">:</span> DList a <span class="token3">-</span><span class="token3">&gt;</span> Maybe a
safeHead xs <span class="token3">=</span> case toList xs of
                <span class="token">(</span>y<span class="token">:</span>_<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> Just y
                _ <span class="token3">-</span><span class="token3">&gt;</span> Nothing

</code></pre>
<p class="calibre9">为了实现对应的 map 函数，我们可以把 DList 类型声明为一个 Functor（函子）。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>DList<span class="token">.</span>hs
dmap <span class="token">:</span><span class="token">:</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> DList a <span class="token3">-</span><span class="token3">&gt;</span> DList b
dmap f <span class="token3">=</span> dfoldr go empty
    where go x xs <span class="token3">=</span> cons <span class="token">(</span>f x<span class="token">)</span> xs

instance Functor DList where
    fmap <span class="token3">=</span> dmap

</code></pre>
<p class="calibre9">当我们实现了足够多的列表操作时，我们回到源文件顶部增加一个模块头。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>DList<span class="token">.</span>hs
module DList
    <span class="token">(</span>
    DList
    <span class="token">,</span> fromList
    <span class="token">,</span> toList
    <span class="token">,</span> empty
    <span class="token">,</span> append
    <span class="token">,</span> cons
    <span class="token">,</span> dfoldr
    <span class="token">)</span> where

</code></pre>
<h2 class="calibre14"><a id="chp-13.html.monoids_1132" class="calibre7 pcalibre"></a>列表、差异列表和幺半群（monoids）</h2>
<p class="calibre9">在抽象代数中，有一类简单的抽象结构被称为<em class="calibre13">幺半群</em>。许多数学结构都是幺半群，因为成为幺半群的要求非常低。一个结构只要满足两个性质便可称为幺半群：</p>
<ul class="calibre10"><li class="calibre11">一个满足结合律的二元操作符。我们称之为 (<em class="calibre13">)：表达式 a</em>(b<em class="calibre13">c) 和 (a</em>b)*c 结果必须相同。</li><li class="calibre11">一个单位元素。我们称之为 e，它必须遵守两条法则：a<em class="calibre13">e==a 和 e</em>a==a。</li></ul>
<p class="calibre9">幺半群并不要求这个二元操作符做什么，它只要求这个二元操作符必须存在。因此很多数学结构都是幺半群。如果我们把加号作为二元操作符，0作为单位元素，那么整数就是一个幺半群。把乘号作为二元操作符，1作为单位元素，整数就形成了另一个幺半群。</p>
<p class="calibre9">Haskell 中幺半群无所不在。Data.Monoid 模块定义了 Monoid 类型类。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>Monoid<span class="token">.</span>hs
class <span class="token5">Monoid</span> a where
    mempty  <span class="token">:</span><span class="token">:</span> a                <span class="token3">--</span> the identity
    mappend <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> a      <span class="token3">--</span> associative binary operator

</code></pre>
<p class="calibre9">如果我们把 (++) 当做二元操作符，[] 当做单位元素，列表就形成了一个幺半群。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>Monoid<span class="token">.</span>hs
instance Monoid <span class="token">[</span>a<span class="token">]</span> where
    mempty  <span class="token3">=</span> <span class="token">[</span><span class="token">]</span>
    mappend <span class="token3">=</span> <span class="token">(</span><span class="token3">++</span><span class="token">)</span>

</code></pre>
<p class="calibre9">由于列表和 DLists 关系如此紧密，DList 类型也必须是一个幺半群。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>DList<span class="token">.</span>hs
instance Monoid <span class="token">(</span>DList a<span class="token">)</span> where
    mempty <span class="token3">=</span> empty
    mappend <span class="token3">=</span> append

</code></pre>
<p class="calibre9">在 <strong class="calibre12">ghci</strong> 里试试 Monoid 类型类的函数。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token4">"foo"</span> `mappend` <span class="token4">"bar"</span>
<span class="token4">"foobar"</span>
ghci<span class="token3">&gt;</span> toList <span class="token">(</span>fromList <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">]</span> `mappend` fromList <span class="token">[</span><span class="token2">3</span><span class="token">,</span><span class="token2">4</span><span class="token">]</span><span class="token">)</span>
<span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">,</span><span class="token2">4</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> mempty `mappend` <span class="token">[</span><span class="token2">1</span><span class="token">]</span>
<span class="token">[</span><span class="token2">1</span><span class="token">]</span>

</code></pre>
<p class="calibre9">Note</p>
<p class="calibre9">尽管从数学的角度看，整数可以以两种不同的方式作为幺半群，但在 Haskell 里，我们却不能给 Int 写两个不同的 Monoid 实例：编译器会报告重复实例错误。</p>
<p class="calibre9">如果我们真的需要在同一个类型上实现多个 Monoid 实例，我们可以用 newtype 创建不同的类型来达到目的。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch13<span class="token3">/</span>Monoid<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span># LANGUAGE GeneralizedNewtypeDeriving #<span class="token3">-</span><span class="token">}</span>

newtype AInt <span class="token3">=</span> A <span class="token">{</span> unA <span class="token">:</span><span class="token">:</span> Int <span class="token">}</span>
    deriving <span class="token">(</span>Show<span class="token">,</span> Eq<span class="token">,</span> Num<span class="token">)</span>

<span class="token3">--</span> monoid under addition
instance Monoid AInt where
    mempty <span class="token3">=</span> <span class="token2">0</span>
    mappend <span class="token3">=</span> <span class="token">(</span><span class="token3">+</span><span class="token">)</span>

newtype MInt <span class="token3">=</span> M <span class="token">{</span> unM <span class="token">:</span><span class="token">:</span> Int <span class="token">}</span>
    deriving <span class="token">(</span>Show<span class="token">,</span> Eq<span class="token">,</span> Num<span class="token">)</span>

<span class="token3">--</span> monoid under multiplication
instance Monoid MInt where
    mempty <span class="token3">=</span> <span class="token2">1</span>
    mappend <span class="token3">=</span> <span class="token">(</span><span class="token3">*</span><span class="token">)</span>

</code></pre>
<p class="calibre9">这样，根据使用类型的不同，我们就能得到不同的行为。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token2">2</span> `mappend` <span class="token2">5</span> <span class="token">:</span><span class="token">:</span> MInt
M <span class="token">{</span>unM <span class="token3">=</span> <span class="token2">10</span><span class="token">}</span>
ghci<span class="token3">&gt;</span> <span class="token2">2</span> `mappend` <span class="token2">5</span> <span class="token">:</span><span class="token">:</span> AInt
A <span class="token">{</span>unA <span class="token3">=</span> <span class="token2">7</span><span class="token">}</span>

</code></pre>
<p class="calibre9">在这一节（The writer monad and lists）中，我们还会继续讨论差异列表和它的幺半群性质。</p>
<p class="calibre9">Note</p>
<p class="calibre9">跟 functor 规则一样，Haskell 没法替我们检查幺半群的规则。如果我们定义了一个 Monoid 实例，我们可以很容易地写一些 QuickCheck 性质来得到一个较高的统计推断，确保代码遵守了幺半群规则。</p>
<h2 class="calibre14"><a id="chp-13.html._1227" class="calibre7 pcalibre"></a>通用序列</h2>
<p class="calibre9">不论是 Haskell 内置的列表，还是我们前面定义的 DList ，这些数据结构在不同的地方都有自己的性能短板。为此， Data.Sequence 模块定义了 Seq 容器类型，对于大多数操作，这种类型能都提供良好的效率保证。</p>
<p class="calibre9">为了避免命名冲突， Data.Sequence 模块通常以 qualified 的方式引入：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude<span class="token3">&gt;</span> import qualified Data<span class="token">.</span>Sequence as Seq
Prelude Seq<span class="token3">&gt;</span>

</code></pre>
<p class="calibre9">empty 函数用于创建一个空 Seq ， singleton 用于创建只包含单个元素的 Seq ：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude Seq<span class="token3">&gt;</span> Seq<span class="token">.</span>empty
fromList <span class="token">[</span><span class="token">]</span>

Prelude Seq<span class="token3">&gt;</span> Seq<span class="token">.</span>singleton <span class="token2">1</span>
fromList <span class="token">[</span><span class="token2">1</span><span class="token">]</span>

</code></pre>
<p class="calibre9">还可以使用 fromList 函数，通过列表创建出相应的 Seq ：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude Seq<span class="token3">&gt;</span> let a <span class="token3">=</span> Seq<span class="token">.</span>fromList <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">,</span> <span class="token2">3</span><span class="token">]</span>

Prelude Seq<span class="token3">&gt;</span> a
fromList <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">]</span>

</code></pre>
<p class="calibre9">Data.Sequence 模块还提供了几种操作符形式的构造函数。但是，在使用 qualified 形式载入模块的情况下调用它们会非常难看：</p>
<p class="calibre9">[译注：操作符形式指的是那种放在两个操作对象之间的函数，比如 2*2 中的 * 函数。]</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude Seq<span class="token3">&gt;</span> <span class="token2">1</span> Seq<span class="token">.</span><span class="token3">&lt;</span><span class="token3">|</span> Seq<span class="token">.</span>singleton <span class="token2">2</span>
fromList <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">]</span>

</code></pre>
<p class="calibre9">可以通过直接载入这几个函数来改善可读性：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude Seq<span class="token3">&gt;</span> import Data<span class="token">.</span><span class="token5">Sequence</span><span class="token">(</span><span class="token">(</span><span class="token3">&gt;</span><span class="token3">&lt;</span><span class="token">)</span><span class="token">,</span> <span class="token">(</span><span class="token3">&lt;</span><span class="token3">|</span><span class="token">)</span><span class="token">,</span> <span class="token">(</span><span class="token3">|</span><span class="token3">&gt;</span><span class="token">)</span><span class="token">)</span>

</code></pre>
<p class="calibre9">现在好多了：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude Seq Data<span class="token">.</span>Sequence<span class="token3">&gt;</span> Seq<span class="token">.</span>singleton <span class="token2">1</span> <span class="token3">|</span><span class="token3">&gt;</span> <span class="token2">2</span>
fromList <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">]</span>

</code></pre>
<p class="calibre9">一个帮助记忆 (&lt;|) 和 (|&gt;) 函数的方法是，函数的『箭头』总是指向被添加的元素： (&lt;|) 函数要添加的元素在左边，而 (|&gt;) 函数要添加的元素在右边：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude Seq Data<span class="token">.</span>Sequence<span class="token3">&gt;</span> <span class="token2">1</span> <span class="token3">&lt;</span><span class="token3">|</span> Seq<span class="token">.</span>singleton <span class="token2">2</span>
fromList <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">]</span>

Prelude Seq Data<span class="token">.</span>Sequence<span class="token3">&gt;</span> Seq<span class="token">.</span>singleton <span class="token2">1</span> <span class="token3">|</span><span class="token3">&gt;</span> <span class="token2">2</span>
fromList <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">]</span>

</code></pre>
<p class="calibre9">不管是从左边添加元素，还是从右边添加元素，添加操作都可以在常数时间内完成。对两个 Seq 进行追加（append）操作同样非常廉价，复杂度等同于两个 Seq 中较短的那个 Seq 的长度的对数。</p>
<p class="calibre9">追加操作由 (&gt;&lt;) 函数完成：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude Seq Data<span class="token">.</span>Sequence<span class="token3">&gt;</span> let left <span class="token3">=</span> Seq<span class="token">.</span>fromList <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">3</span><span class="token">,</span> <span class="token2">3</span><span class="token">]</span>

Prelude Seq Data<span class="token">.</span>Sequence<span class="token3">&gt;</span> let right <span class="token3">=</span> Seq<span class="token">.</span>fromList <span class="token">[</span><span class="token2">7</span><span class="token">,</span> <span class="token2">1</span><span class="token">]</span>

Prelude Seq Data<span class="token">.</span>Sequence<span class="token3">&gt;</span> left <span class="token3">&gt;</span><span class="token3">&lt;</span> right
fromList <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">3</span><span class="token">,</span><span class="token2">3</span><span class="token">,</span><span class="token2">7</span><span class="token">,</span><span class="token2">1</span><span class="token">]</span>

</code></pre>
<p class="calibre9">反过来，如果我们想将 Seq 转换回列表，那么就需要 Data.Foldable 模块的帮助：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude Seq Data<span class="token">.</span>Sequence<span class="token3">&gt;</span> import qualified Data<span class="token">.</span>Foldable as Foldable
Prelude Seq Data<span class="token">.</span>Sequence Foldable<span class="token3">&gt;</span>

</code></pre>
<p class="calibre9">这个模块定义了一个类型， Foldable ，而 Seq 实现了这个类型：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude Seq Data<span class="token">.</span>Sequence Foldable<span class="token3">&gt;</span> Foldable<span class="token">.</span>toList <span class="token">(</span>Seq<span class="token">.</span>fromList <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">,</span> <span class="token2">3</span><span class="token">]</span><span class="token">)</span>
<span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">]</span>

</code></pre>
<p class="calibre9">Data.Foldable 中的 fold 函数可以用于对 Seq 进行 fold 操作：</p>
<pre class="calibre15"><code class="tthhighlight-container">Prelude Seq Data<span class="token">.</span>Sequence Foldable<span class="token3">&gt;</span> Foldable<span class="token">.</span>foldl' <span class="token">(</span><span class="token3">+</span><span class="token">)</span> <span class="token2">0</span> <span class="token">(</span>Seq<span class="token">.</span>fromList <span class="token">[</span><span class="token2">1</span><span class="token">,</span> <span class="token2">2</span><span class="token">,</span> <span class="token2">3</span><span class="token">]</span><span class="token">)</span>
<span class="token2">6</span>

</code></pre>
<p class="calibre9">Data.Sequence 模块还提供了大量有用的函数，这些函数都和 Haskell 列表的函数类似。模块的文档也非常齐全，还提供了函数的时间复杂度信息。</p>
<p class="calibre9">最后的疑问是，既然 Seq 的效率这么好，那为什么它不是 Haskell 默认的序列类型呢？答案是，列表类型更简单，消耗更低，对于大多数应用程序来说，列表已经足够满足需求了。除此之外，列表可以很好地处理惰性环境，而 Seq 在这方面做得还不够好。</p>
</div></div></div></div></div></div>
<div id="chp-18.html"><div class="calibre">
<div id="chp-18.html.main" class="calibre1"><div class="root"><div class="article"><h1 class="article-head" id="chp-18.html.calibre_toc_13">第十八章： Monad变换器</h1><div class="article-body"><h1 class="calibre6"><a id="chp-18.html._Monad_0" class="calibre7 pcalibre"></a>第十八章： Monad变换器</h1>
<h2 class="calibre8"><a id="chp-18.html.__2" class="calibre7 pcalibre"></a>动机： 避免样板代码</h2>
<p class="calibre9">Monad提供了一种强大途径以构建带效果的计算。虽然各个标准monad皆专一于其特定的任务，但在实际代码中，我们常常想同时使用多种效果。</p>
<p class="calibre9">比如，回忆在第十章中开发的 Parse 类型。在介绍monad之时，我们提到这个类型其实是乔装过的 State monad。事实上我们的monad比标准的 State monad 更加复杂：它同时也使用了 Either 类型来表达解析过程中可能的失败。在这个例子中，我们想在解析失败的时候就立刻停止这个过程，而不是以错误的状态继续执行解析。这个monad同时包含了带状态计算的效果和提早退出计算的效果。</p>
<p class="calibre9">普通的 State monad不允许我们提早退出，因为其只负责状态的携带。其使用的是 fail 函数的默认实现：直接调用 error 抛出异常 － 这一异常无法在纯函数式的代码中捕获。因此，尽管 State monad似乎允许错误，但是这一能力并没有什么用。（再次强调：请尽量避免使用 fail 函数！）</p>
<p class="calibre9">理想情况下，我们希望能使用标准的 State monad，并为其加上实用的错误处理能力以代替手动地大量定制各种monad。虽然在 mtl 库中的标准monad不可合并使用，但使用库中提供了一系列的 <em class="calibre13">monad变换器</em> 可以达到相同的效果。</p>
<p class="calibre9">Monad变换器和常规的monad很类似，但它们并不是独立的实体。相反，monad变换器通过修改其以为基础的monad的行为来工作。 大部分 mtl 库中的monad都有对应的变换器。习惯上变换器以其等价的monad名为基础，加以 T 结尾。 例如，与 State 等价的变换器版本称作 StateT ； 它修改下层monad以增加可变状态。此外，若将 WriterT monad变换器叠加于其他（或许不支持数据输出的）monad之上，在被monad修改后的的monad中，输出数据将成为可能。</p>
<p class="calibre9">[注：mtl 意为monad变换器函数库(Monad Transformer Library)]</p>
<p class="calibre9">[译注：Monad变换器需要依附在一已有monad上来构成新的monad，在接下来的行文中将使用“下层monad”来称呼monad变换器所依附的那个monad]</p>
<h2 class="calibre14"><a id="chp-18.html.Monad_18" class="calibre7 pcalibre"></a>简单的Monad变换器实例</h2>
<p class="calibre9">在介绍monad变换器之前，先看看以下函数，其中使用的都是之前接触过的技术。这个函数递归地访问目录树，并返回一个列表，列表中包含树的每层的实体个数：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>CountEntries<span class="token">.</span>hs
module CountEntries
  <span class="token">(</span> listDirectory
  <span class="token">,</span> countEntriesTrad
  <span class="token">)</span> where

import System<span class="token">.</span>Directory <span class="token">(</span>doesDirectoryExist<span class="token">,</span> getDirectoryContents<span class="token">)</span>
import System<span class="token">.</span>FilePath <span class="token">(</span><span class="token">(</span><span class="token3">&lt;</span><span class="token3">/</span><span class="token3">&gt;</span><span class="token">)</span><span class="token">)</span>
import Control<span class="token">.</span>Monad <span class="token">(</span>forM<span class="token">,</span> liftM<span class="token">)</span>

listDirectory <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">[</span>String<span class="token">]</span>
listDirectory <span class="token3">=</span> liftM <span class="token">(</span>filter notDots<span class="token">)</span> <span class="token">.</span> getDirectoryContents
  where notDots p <span class="token3">=</span> p <span class="token3">/</span><span class="token3">=</span> <span class="token4">"."</span> <span class="token3">&amp;&amp;</span> p <span class="token3">/</span><span class="token3">=</span> <span class="token4">".."</span>

countEntriesTrad <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">[</span><span class="token">(</span>FilePath<span class="token">,</span> Int<span class="token">)</span><span class="token">]</span>
countEntriesTrad path <span class="token3">=</span> <span class="token1">do</span>
    contents <span class="token3">&lt;</span><span class="token3">-</span> listDirectory path
    rest <span class="token3">&lt;</span><span class="token3">-</span> forM contents $ \name <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">do</span>
        let newName <span class="token3">=</span> path <span class="token3">&lt;</span><span class="token3">/</span><span class="token3">&gt;</span> name
        isDir <span class="token3">&lt;</span><span class="token3">-</span> doesDirectoryExist newName
        <span class="token1">if</span> isDir
          then countEntriesTrad newName
          <span class="token1">else</span> <span class="token1">return</span> <span class="token">[</span><span class="token">]</span>
    <span class="token1">return</span> $ <span class="token">(</span>path<span class="token">,</span> length contents<span class="token">)</span> <span class="token">:</span> concat rest

</code></pre>
<p class="calibre9">现在看看如何使用 Writer monad 实现相同的目标。由于这个monad允许随时记下数值，所以并不需要我们显示地去构建结果。</p>
<p class="calibre9">为了遍历目录，这个函数必须在 IO monad中执行，因此我们无法直接使用 Writer monad。但我们可以用 WriterT 将记录信息的能力赋予 IO 。一种简单的理解方法是首先理解涉及的类型。</p>
<p class="calibre9">通常 Writer monad有两个类型参数，因此写作 Writerwa 更为恰当。其中参数 w 用以指明我们想要记录的数值的类型。而另一类型参数 a 是monad类型类所要求的。因此 Writer[(FilePath，Int)]a 是个记录一列目录名和目录大小的writer monad。</p>
<p class="calibre9">WriterT 变换器有着类似的结构。但其增加了另外一个类型参数 m ：这便是下层monad，也是我们想为其增加功能的monad。 WriterT 的完整类型签名是 Writerwma。</p>
<p class="calibre9">由于所需的目录遍历操作需要访问 IO monad，因此我们将writer功能累加在 IO monad之上。通过将monad变换器与原有monad结合，我们得到了类型签名： WriterT[(FilePath，Int)]IOa 这个monad变换器和monad的组合自身也是一个monad：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>CountEntriesT<span class="token">.</span>hs
module CountEntriesT
  <span class="token">(</span> listDirectory
  <span class="token">,</span> countEntries
  <span class="token">)</span> where

import CountEntries <span class="token">(</span>listDirectory<span class="token">)</span>
import System<span class="token">.</span>Directory <span class="token">(</span>doesDirectoryExist<span class="token">)</span>
import System<span class="token">.</span>FilePath <span class="token">(</span><span class="token">(</span><span class="token3">&lt;</span><span class="token3">/</span><span class="token3">&gt;</span><span class="token">)</span><span class="token">)</span>
import Control<span class="token">.</span>Monad <span class="token">(</span>forM_<span class="token">,</span> when<span class="token">)</span>
import Control<span class="token">.</span>Monad<span class="token">.</span>Trans <span class="token">(</span>liftIO<span class="token">)</span>
import Control<span class="token">.</span>Monad<span class="token">.</span>Writer <span class="token">(</span>WriterT<span class="token">,</span> tell<span class="token">)</span>

countEntries <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> WriterT <span class="token">[</span><span class="token">(</span>FilePath<span class="token">,</span> Int<span class="token">)</span><span class="token">]</span> IO <span class="token">(</span><span class="token">)</span>
countEntries path <span class="token3">=</span> <span class="token1">do</span>
    contents <span class="token3">&lt;</span><span class="token3">-</span> liftIO <span class="token">.</span> listDirectory $ path
    tell <span class="token">[</span><span class="token">(</span>path<span class="token">,</span> length contents<span class="token">)</span><span class="token">]</span>
    forM_ contents $ \name <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">do</span>
        let newName <span class="token3">=</span> path <span class="token3">&lt;</span><span class="token3">/</span><span class="token3">&gt;</span> name
        isDir <span class="token3">&lt;</span><span class="token3">-</span> liftIO <span class="token">.</span> doesDirectoryExist $ newName
        when isDir $ countEntries newName

</code></pre>
<p class="calibre9">代码与其先前的版本区别不大，需要时 liftIO 可以将 IO monad暴露出来；同时， tell 可以用以记下对目录的访问。</p>
<p class="calibre9">为了执行这一代码，需要选择一个 WriterT 的执行函数：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type runWriterT
runWriterT <span class="token">:</span><span class="token">:</span> WriterT w m a <span class="token3">-</span><span class="token3">&gt;</span> m <span class="token">(</span>a<span class="token">,</span> w<span class="token">)</span>
ghci<span class="token3">&gt;</span> <span class="token">:</span>type execWriterT
execWriterT <span class="token">:</span><span class="token">:</span> Monad m <span class="token3">=</span><span class="token3">&gt;</span> WriterT w m a <span class="token3">-</span><span class="token3">&gt;</span> m w

</code></pre>
<p class="calibre9">这些函数都可以用以执行动作，移除 WriterT 的包装，并将结果交给其下层monad。其中 runWriterT 函数同时返回动作结果以及在执行过程获得的记录。而 execWriterT 丢弃动作的结果，只将记录返回。</p>
<p class="calibre9">因为没有 IOT 这样的monad变换器，所以此处我们在 IO 之上使用 WriterT 。一旦要用 IO monad和其他的一个或多个monad变换器结合， IO 一定在monad栈的最底下。</p>
<p class="calibre9">[译注：“monad栈”由monad和一个或多个monad变换器叠加而成，形成一个栈的结构。若在monad栈中需要 IO monad，由于没有对应的monad变换器（ IOT ），所以 IO monad只能位于整个monad栈的最底下。此外， IO 是一个很特殊的monad，它的 IOT 版本是无法实现的。]</p>
<h2 class="calibre14"><a id="chp-18.html.MonadMonad_103" class="calibre7 pcalibre"></a>Monad和Monad变换器中的模式</h2>
<p class="calibre9">在 mtl 库中的大部分monad与monad变换器遵从一些关于命名和类型类的模式。</p>
<p class="calibre9">为说明这些规则，我们将注意力聚焦在一个简单的monad上： reader monad。 reader monad的具体API位于 MonadReader 中。大部分 mtl 中的monad都有一个名称相对的类型类。例如 MonadWriter 定义了writer monad的API，以此类推。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>Reader<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span># LANGUAGE FunctionalDependencies #<span class="token3">-</span><span class="token">}</span>
class <span class="token5">Monad</span> m <span class="token3">=</span><span class="token3">&gt;</span> MonadReader r m <span class="token3">|</span> m <span class="token3">-</span><span class="token3">&gt;</span> r where
    ask <span class="token">:</span><span class="token">:</span> m r
    local <span class="token">:</span><span class="token">:</span> <span class="token">(</span>r <span class="token3">-</span><span class="token3">&gt;</span> r<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> m a <span class="token3">-</span><span class="token3">&gt;</span> m a

</code></pre>
<p class="calibre9">其中类型变量 r 表示reader monad所附带的不变状态， Readerr monad是个 MonadReader 的实例，同时 ReaderTrm monad变换器也是一个。这个模式同样也在其他的 mtl monad中重复着： 通常有个具体的monad，和其对应的monad变换器，而它们都是相应命令的类型类的实例。这个类型类定义了功能相同的monad的API。</p>
<p class="calibre9">回到我们reader monad的例子中，我们之前尚未讨论过 local 函数。通过一个类型为 r-&gt;r 的函数，它可临时修改当前的环境，并在这一临时环境中执行其动作。举个具体的例子：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>LocalReader<span class="token">.</span>hs
import Control<span class="token">.</span>Monad<span class="token">.</span>Reader

myName step <span class="token3">=</span> <span class="token1">do</span>
    name <span class="token3">&lt;</span><span class="token3">-</span> ask
    <span class="token1">return</span> <span class="token">(</span>step <span class="token3">++</span> <span class="token4">", I am "</span> <span class="token3">++</span> name<span class="token">)</span>

localExample <span class="token">:</span><span class="token">:</span> Reader String <span class="token">(</span>String<span class="token">,</span> String<span class="token">,</span> String<span class="token">)</span>
localExample <span class="token3">=</span> <span class="token1">do</span>
    a <span class="token3">&lt;</span><span class="token3">-</span> myName <span class="token4">"First"</span>
    b <span class="token3">&lt;</span><span class="token3">-</span> local <span class="token">(</span><span class="token3">++</span><span class="token4">"dy"</span><span class="token">)</span> <span class="token">(</span>myName <span class="token4">"Second"</span><span class="token">)</span>
    c <span class="token3">&lt;</span><span class="token3">-</span> myName <span class="token4">"Third"</span>
    <span class="token1">return</span> <span class="token">(</span>a<span class="token">,</span>b<span class="token">,</span>c<span class="token">)</span>

</code></pre>
<p class="calibre9">若在 ghci 中执行 localExample ，可以观察到对环境修改的效果被限制在了一个地方：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> runReader localExample <span class="token4">"Fred"</span>
Loading package mtl<span class="token3">-</span><span class="token2">1.1</span><span class="token2">.0</span><span class="token2">.1</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
<span class="token">(</span><span class="token4">"First, I am Fred"</span><span class="token">,</span><span class="token4">"Second, I am Freddy"</span><span class="token">,</span><span class="token4">"Third, I am Fred"</span><span class="token">)</span>

</code></pre>
<p class="calibre9">当下层monad m 是一个 MonadIO 的实例时， mtl 提供了关于 ReaderTrm 和其他类型类的实例，这里是其中的一些：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>Reader<span class="token">.</span>hs
instance <span class="token">(</span>Monad m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> Functor <span class="token">(</span>ReaderT r m<span class="token">)</span> where
    <span class="token">.</span><span class="token">.</span><span class="token">.</span>

instance <span class="token">(</span>MonadIO m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> MonadIO <span class="token">(</span>ReaderT r m<span class="token">)</span> where
    <span class="token">.</span><span class="token">.</span><span class="token">.</span>

instance <span class="token">(</span>MonadPlus m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> MonadPlus <span class="token">(</span>ReaderT r m<span class="token">)</span> where
    <span class="token">.</span><span class="token">.</span><span class="token">.</span>

</code></pre>
<p class="calibre9">再次说明：为方便使用，大部分的 mtl monad变换器都定义了诸如此类的实例。</p>
<h2 class="calibre14"><a id="chp-18.html.Monad_165" class="calibre7 pcalibre"></a>叠加多个Monad变换器</h2>
<p class="calibre9">之前提到过，在常规monad上叠加monad变换器可得到另一个monad。由于混合的结果也是个monad，我们可以凭此为基础再叠加上一层monad变换器。事实上，这么做十分常见。但在什么情况下才需要创建这样的monad呢？</p>
<ul class="calibre10"><li class="calibre11">若代码想和外界打交道，便需要 IO 作为这个monad栈的基础。否则普通的monad便可以满足需求。</li><li class="calibre11">加上一层 ReaderT ，以添加访问只读配置信息的能力。</li><li class="calibre11">叠加上 StateT ，就可以添加可修改的全局状态。</li><li class="calibre11">若想得到记录事件的能力，可以添加一层 WriterT 。</li></ul>
<p class="calibre9">这个做法的强大之处在于：我们可以指定所需的计算效果，以量身定制monad栈。</p>
<p class="calibre9">举个多重叠加的moand变换器的例子，这里是之前开发的 countEntries 函数。我们想限制其递归的深度，并记录下它在执行过程中所到达的最大深度：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>UglyStack<span class="token">.</span>hs
import System<span class="token">.</span>Directory
import System<span class="token">.</span>FilePath
import System<span class="token">.</span>Monad<span class="token">.</span>Reader
import System<span class="token">.</span>Monad<span class="token">.</span>State

data AppConfig <span class="token3">=</span> AppConfig
  <span class="token">{</span> cfgMaxDepth <span class="token">:</span><span class="token">:</span> Int
  <span class="token">}</span> deriving <span class="token">(</span>Show<span class="token">)</span>

data AppState <span class="token3">=</span> AppState
  <span class="token">{</span> stDeepestReached <span class="token">:</span><span class="token">:</span> Int
  <span class="token">}</span> deriving <span class="token">(</span>Show<span class="token">)</span>

</code></pre>
<p class="calibre9">此处使用 ReaderT 来记录配置数据，数据的内容表示最大允许的递归深度。同时也使用了 StateT 来记录在实际遍历过程中所达到的最大深度。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>UglyStack<span class="token">.</span>hs
type App <span class="token3">=</span> ReaderT AppConfig <span class="token">(</span>StateT AppState IO<span class="token">)</span>

</code></pre>
<p class="calibre9">我们的变换器以 IO 为基础，依次叠加 StateT 与 ReaderT 。在此例中，栈顶是 ReaderT 还是 WriterT 并不重要，但是 IO 必须作为最下层monad。</p>
<p class="calibre9">仅仅几个monad变换器的叠加，也会使类型签名迅速变得复杂起来。故此处以 type 关键字定义类型别名，以简化类型的书写。</p>
<h2 class="calibre14"><a id="chp-18.html._207" class="calibre7 pcalibre"></a>缺失的类型参数呢？</h2>
<p class="calibre9">或许你已注意到，此处的类型别名并没有我们为monad类型所常添加的类型参数 a：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>UglyStack<span class="token">.</span>hs
type App2 a <span class="token3">=</span> ReaderT AppConfig <span class="token">(</span>StateT AppState IO<span class="token">)</span> a

</code></pre>
<p class="calibre9">在常规的类型签名用例下， App 和 App2 不会遇到问题。但如果想以此类型为基础构建其他类型，两者的区别就显现出来了。</p>
<p class="calibre9">例如我们想另加一层monad变换器，编译器会允许 WriterT[String]Appa 但拒绝 WriterT[String]App2a 。</p>
<p class="calibre9">其中的理由是：Haskell不允许对类型别名的部分应用。 App 不需要类型参数，故没有问题。另一方面，因为 App2 需要一个类型参数，若想基于 App2 构造其他的类型，则必须为这个类型参数提供一个类型。</p>
<p class="calibre9">这一限制仅适用于类型别名，当构建monad栈时，通常的做法是用 newtype 来封装（接下来的部分就会看到这类例子）。 因此实际应用中很少出现这种问题。</p>
<p class="calibre9">[译注：类似于函数的部分应用，“类型别名的部分应用”指的是在应用类型别名时，给出的参数数量少于定义中的参数数量。在以上例子中， App 是一个完整的应用，因为在其定义 typeApp=... 中，没有类型参数；而 App2 却是个部分应用，因为在其定义 typeApp2a=... 中，还需要一个类型参数 a 。]</p>
<p class="calibre9">我们monad栈的执行函数很简单：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>UglyStack<span class="token">.</span>hs
runApp <span class="token">:</span><span class="token">:</span> App a <span class="token3">-</span><span class="token3">&gt;</span> Int <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span>a<span class="token">,</span> AppState<span class="token">)</span>
runApp k maxDepth <span class="token3">=</span>
    let config <span class="token3">=</span> AppConfig maxDepth
        state <span class="token3">=</span> AppState <span class="token2">0</span>
    <span class="token1">in</span> runStateT <span class="token">(</span>runReaderT k config<span class="token">)</span> state

</code></pre>
<p class="calibre9">对 runReaderT 的应用移除了 ReaderT 变换器的包装，之后 runStateT 移除了 StateT 的包装，最后的结果便留在 IO monad中。</p>
<p class="calibre9">和先前的版本相比，我们的修改并未使代码复杂太多，但现在函数却能记录目前的路径，和达到的最大深度：</p>
<pre class="calibre15"><code class="tthhighlight-container">constrainedCount <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> App <span class="token">[</span><span class="token">(</span>FilePath<span class="token">,</span> Int<span class="token">)</span><span class="token">]</span>
constrainedCount curDepth path <span class="token3">=</span> <span class="token1">do</span>
    contents <span class="token3">&lt;</span><span class="token3">-</span> liftIO <span class="token">.</span> listDirectory $ path
    cfg <span class="token3">&lt;</span><span class="token3">-</span> ask
    rest <span class="token3">&lt;</span><span class="token3">-</span> forM contents $ \name <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">do</span>
        let newPath <span class="token3">=</span> path <span class="token3">&lt;</span><span class="token3">/</span><span class="token3">&gt;</span> name
        isDir <span class="token3">&lt;</span><span class="token3">-</span> liftIO $ doesDirectoryExist newPath
        <span class="token1">if</span> isDir <span class="token3">&amp;&amp;</span> curDepth <span class="token3">&lt;</span> cfgMaxDepth cfg
          then <span class="token1">do</span>
            let newDepth <span class="token3">=</span> curDepth <span class="token3">+</span> <span class="token2">1</span>
            st <span class="token3">&lt;</span><span class="token3">-</span> get
            when <span class="token">(</span>stDeepestReached st <span class="token3">&lt;</span> newDepth<span class="token">)</span> $
              put st <span class="token">{</span>stDeepestReached <span class="token3">=</span> newDepth<span class="token">}</span>
            constrainedCount newDepth newPath
          <span class="token1">else</span> <span class="token1">return</span> <span class="token">[</span><span class="token">]</span>
    <span class="token1">return</span> $ <span class="token">(</span>path<span class="token">,</span> length contents<span class="token">)</span> <span class="token">:</span> concat rest

</code></pre>
<p class="calibre9">在这个例子中如此运用monad变换器确实有些小题大做，因为这仅仅是个简单函数，其并没有因此得到太多的好处。但是这个方法的实用性在于，可以将其 <em class="calibre13">轻易扩展以解决更加复杂的问题</em> 。</p>
<p class="calibre9">大部分指令式的应用可以使用和这里的 App monad类似的方法，在monad栈中编写。在实际的程序中，或许需要携带更复杂的配置数据，但依旧可以使用 ReaderT 以保持其只读，并只在需要时暴露配置；或许有更多可变状态需要管理，但依旧可以使用 StateT 封装它们。</p>
<h2 class="calibre14"><a id="chp-18.html._267" class="calibre7 pcalibre"></a>隐藏细节</h2>
<p class="calibre9">使用常规的 newtype 技术，便可将细节与接口分离开：</p>
<pre class="calibre15"><code class="tthhighlight-container">newtype MyApp a <span class="token3">=</span> MyA
  <span class="token">{</span> runA <span class="token">:</span><span class="token">:</span> ReaderT AppConfig <span class="token">(</span>StateT AppState IO<span class="token">)</span> a
  <span class="token">}</span> deriving <span class="token">(</span>Monad<span class="token">,</span> MonadIO<span class="token">,</span> MonadReader AppConfig<span class="token">,</span>
              MonadState AppState<span class="token">)</span>

runMyApp <span class="token">:</span><span class="token">:</span> MyApp a <span class="token3">-</span><span class="token3">&gt;</span> Int <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span>a<span class="token">,</span> AppState<span class="token">)</span>
runMyApp k maxDepth <span class="token3">=</span>
    let config <span class="token3">=</span> AppConfig maxDepth
        state <span class="token3">=</span> AppState <span class="token2">0</span>
    <span class="token1">in</span> runStateT <span class="token">(</span>runReaderT <span class="token">(</span>runA k<span class="token">)</span> config<span class="token">)</span> state

</code></pre>
<p class="calibre9">若只导出 MyApp 类构造器和 runMyApp 执行函数，客户端的代码就无法知晓这个monad的内部结构是否是monad栈了。</p>
<p class="calibre9">此处，庞大的 deriving 子句需要 GeneralizedNewtypeDeriving 语言编译选项。编译器可以为我们生成这些实例，这看似十分神奇，究竟是如何做到的呢？</p>
<p class="calibre9">早先，我们提到 mtl 库为每个monad变换器都提供了一系列实例。例如 IO monad实现了 MonadIO ，若下层monad是 MonadIO 的实例，那么 mtl 也将为其对应的 StateT 构建一个 MonadIO 的实例，类似的事情也发生在 ReaderT 上。</p>
<p class="calibre9">因此，这其中并无太多神奇之处：位于monad栈顶层的monad变换器，已是所有我们声明的 deriving 子句中的类型类的实例，我们做的只不过是重新派生这些实例。这是 mtl 精心设计的一系列类型类和实例完美配合的结果。除了基于 newtype 声明的常规的自动推导以外并没有发生什么。</p>
<p class="calibre9">[译注：注意到此处 newtypeMyAppa 只是乔装过的 ReaderTAppConfig(StateTAppStateIO)a 。因此我们可以列出 MyAppa 这个monad栈的全貌（自顶向下）：</p>
<ul class="calibre10"><li class="calibre11">ReaderTAppConfig （monad变换器）</li><li class="calibre11">StateTAppState （monad变换器）</li><li class="calibre11">IO （monad）</li></ul>
<p class="calibre9">注意这个monad栈和 deriving 子句中类型类的相似度。这些实例都可以自动派生： MonadIO 实例自底层派生上来， MonadStateT 从中间一层派生，而 MonadReader 实例来自顶层。所以虽然 newtypeMyAppa 引入了一个全新的类型，其实例是可以通过内部结构自动推导的。]</p>
<h2 class="calibre14"><a id="chp-18.html._301" class="calibre7 pcalibre"></a>练习</h2>
<ol class="calibre17"><li class="calibre11">修改 App 类型别名以交换 ReaderT 和 StateT 的位置，这一变换对执行函数 runApp 会带来什么影响？</li><li class="calibre11">为 App monad栈添加 WriterT 变换器。 相应地修改 runApp 。</li><li class="calibre11">重写 contrainedCount 函数，在为 App 新添加的 WriterT 中记录结果。</li></ol>
<p class="calibre9">[译注：第一题中的 StateT 原为 WriterT ，鉴于 App 定义中并无 WriterT ，此处应该指的是 StateT ]</p>
<h2 class="calibre14"><a id="chp-18.html.Monad_309" class="calibre7 pcalibre"></a>深入Monad栈中</h2>
<p class="calibre9">至今，我们了解了对monad变换器的简单运用。对 mtl 库的便利组合拼接使我们免于了解monad栈构造的细节。我们确实已掌握了足以帮助我们简化大量常见编程任务的monad变换器相关知识。</p>
<p class="calibre9">但有时，为了实现一些实用的功能，还是我们需要了解 mtl 库并不便利的一面。这些任务可能是将定制的monad置于monad栈底，也可能是将定制的monad变换器置于monad变换器栈中的某处。为了解其中潜在的难度，我们讨论以下例子。</p>
<p class="calibre9">假设我们有个定制的monad变换器 CustomT ：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>CustomT<span class="token">.</span>hs
newtype CustomT m a <span class="token3">=</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span>

</code></pre>
<p class="calibre9">在 mtl 提供的框架中，每个位于栈上的monad变换器都将其下层monad的API暴露出来。这是通过提供大量的类型类实例来实现的。遵从这一模式的规则，我们也可以实现一系列的样板实例：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>CustomT<span class="token">.</span>hs
instance MonadReader r m <span class="token3">=</span><span class="token3">&gt;</span> MonadReader r <span class="token">(</span>CustomT m<span class="token">)</span> where
    <span class="token">.</span><span class="token">.</span><span class="token">.</span>

instance MonadIO m <span class="token3">=</span><span class="token3">&gt;</span> MonadIO <span class="token">(</span>CustomT m<span class="token">)</span> where
    <span class="token">.</span><span class="token">.</span><span class="token">.</span>

</code></pre>
<p class="calibre9">若下层monad是 MonadReader 的实例，则 CustomT 也可作为 MonadReader 的实例： 实例化的方法是将所有相关的API调用转接给其下层实例的相应函数。经过实例化之后，上层的代码就可以将monad栈作为一个整体，当作 MonadReader 的实例，而不再需要了解或关心到底是其中的哪一层提供了具体的实现。</p>
<p class="calibre9">不同于这种依赖类型类实例的方法，我们也可以显式指定想要使用的API。 MonadTrans 类型类定义了一个实用的函数 lift ：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>m <span class="token3">+</span>Control<span class="token">.</span>Monad<span class="token">.</span>Trans
ghci<span class="token3">&gt;</span> <span class="token">:</span>info MonadTrans
class <span class="token5">MonadTrans</span> t where lift <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Monad m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> m a <span class="token3">-</span><span class="token3">&gt;</span> t m a
      <span class="token3">--</span> Defined <span class="token1">in</span> Control<span class="token">.</span>Monad<span class="token">.</span>Trans

</code></pre>
<p class="calibre9">这个函数接受来自monad栈中，当前栈下一层的monad动作，并将这个动作变成，或者说是 <em class="calibre13">抬举</em> 到现在的monad变换器中。每个monad变换器都是 MonadTrans 的实例。</p>
<p class="calibre9">lift 这个名字是基于此函数与 fmap 和 liftM 目的上的相似度的。这些函数都可以从类型系统的下一层中把东西提升到我们目前工作的这一层。它们的区别是：</p>
<p class="calibre9">fmap将纯函数提升到functor层次liftM将纯函数提升到monad层次lift将一monad动作，从monad栈中的下一层提升到本层</p>
<p class="calibre9">[译注：实际上 liftM 间接调用了 fmap ，两个函数在效果上是完全一样的。译者认为，当操作对象是monad（所有的monad都是functor）的时候，使用其中的哪一个只是思考方法上的不同。]</p>
<p class="calibre9">现在重新考虑我们在早些时候定义的 App monad栈 (之前我们将其包装在 newtype 中)：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>UglyStack<span class="token">.</span>hs
type App <span class="token3">=</span> ReaderT AppConfig <span class="token">(</span>StateT AppState IO<span class="token">)</span>

</code></pre>
<p class="calibre9">若想访问 StateT 所携带的 AppState ，通常需要依赖 mtl 的类型类实例来为我们处理组合工作：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>UglyStack<span class="token">.</span>hs
implicitGet <span class="token">:</span><span class="token">:</span> App AppState
implicitGet <span class="token3">=</span> get

</code></pre>
<p class="calibre9">通过将 get 函数从 StateT 中抬举进 ReaderT ， lift 函数也可以实现同样的效果：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>UglyStack<span class="token">.</span>hs
explicitGet <span class="token">:</span><span class="token">:</span> App AppState
explicitGet <span class="token3">=</span> lift get

</code></pre>
<p class="calibre9">显然当 mtl 可以为我们完成这一工作时，代码会变得更清晰。但是 mtl 并不总能完成这类工作。</p>
<h2 class="calibre14"><a id="chp-18.html._382" class="calibre7 pcalibre"></a>何时需要显式的抬举？</h2>
<p class="calibre9">我们必须使用 lift 的一个例子是：当在一个monad栈中，同一个类型类的实例出现了多次时：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>StackStack<span class="token">.</span>hs
type Foo <span class="token3">=</span> StateT Int <span class="token">(</span>State String<span class="token">)</span>

</code></pre>
<p class="calibre9">若此时我们试着使用 MonadState 类型类中的 put 动作，得到的实例将是 StateTInt ，因为这个实例在monad栈顶。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>StackStack<span class="token">.</span>hs
outerPut <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> Foo <span class="token">(</span><span class="token">)</span>
outerPut <span class="token3">=</span> put

</code></pre>
<p class="calibre9">在这个情况下，唯一能访问下层 State monad的 put 函数的方法是使用 lift ：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>StackStack<span class="token">.</span>hs
innerPut <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> Foo <span class="token">(</span><span class="token">)</span>
innerPut <span class="token3">=</span> lift <span class="token">.</span> put

</code></pre>
<p class="calibre9">有时我们需要访问多于一层以下的monad，这时我们必须组合 lift 调用。每个函数组合中的 lift 将我们带到更深的一层。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>StackStack<span class="token">.</span>hs
type Bar <span class="token3">=</span> ReaderT Bool Foo

barPut <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> Bar <span class="token">(</span><span class="token">)</span>
barPut <span class="token3">=</span> lift <span class="token">.</span> lift <span class="token">.</span> put

</code></pre>
<p class="calibre9">正如以上代码所示，当需要用 lift 的时候，一个好习惯是定义并使用包裹函数来为我们完成抬举工作。因为这种在代码各处显式使用lift的方法使代码变得混乱。另一个显式lift的缺点在于，其硬编码了monad栈的层次细节，这将使日后对monad栈的修改变得复杂。</p>
<h2 class="calibre14"><a id="chp-18.html.Monad_423" class="calibre7 pcalibre"></a>构建以理解Monad变换器</h2>
<p class="calibre9">为了深入理解monad变换器通常是如何运作的，在本节我们将自己构建一个monad变换器，期间一并讨论其中的组织结构。我们的目标简单而实用： MaybeT 。但是 mtl 库意外地并没有提供它。</p>
<p class="calibre9">[译注：如果想使用现成的 MaybeT ，现在你可以在 Hackage 上的 transformers 库中找到它。]</p>
<p class="calibre9">这个monad变换器修改monad的方法是：将下层monad ma 的类型参数包装在 Maybe 中，以得到类型 m(Maybea) 。正如 Maybe monad一样，若在 MaybeT monad变换器中调用 fail ，则计算将提早结束执行。</p>
<p class="calibre9">为使 m(Maybea) 成为 Monad 的实例，其必须有个独特的类型。这里我们通过 newtype 声明来实现：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>MaybeT<span class="token">.</span>hs
newtype MaybeT m a <span class="token3">=</span> MaybeT
  <span class="token">{</span> runMaybeT <span class="token">:</span><span class="token">:</span> m <span class="token">(</span>Maybe a<span class="token">)</span> <span class="token">}</span>

</code></pre>
<p class="calibre9">现在需要定义三个标准的monad函数。其中最复杂的是 (&gt;&gt;=) ，它的实现也阐明了我们实际上在做什么。在开始研究其操作之前，不妨先看看其类型：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>MaybeT<span class="token">.</span>hs
bindMT <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Monad m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> MaybeT m a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> MaybeT m b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> MaybeT m b

</code></pre>
<p class="calibre9">为理解其类型签名，回顾之前在十五章中对“多参数类型类”讨论。此处我们想使 <em class="calibre13">部分类型</em>MaybeTm 成为 Monad 的实例。这个部分类型拥有通常的单一类型参数 a ，这样便能满足 Monad 类型类的要求。</p>
<p class="calibre9">[译注： MaybeT 的完整定义是 MaybeTma ，因此 MaybeTm 只是部分应用。]</p>
<p class="calibre9">理解以下 (&gt;&gt;=) 实现的关键在于： do 代码块里的代码是在 <em class="calibre13">下层</em> monad中执行的，无论这个下层monad是什么。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>MaybeT<span class="token">.</span>hs
x `bindMT` f <span class="token3">=</span> MaybeT $ <span class="token1">do</span>
    unwrapped <span class="token3">&lt;</span><span class="token3">-</span> runMaybeT x
    case unwrapped of
      Nothing <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> Nothing
      Just y <span class="token3">-</span><span class="token3">&gt;</span> runMaybeT <span class="token">(</span>f y<span class="token">)</span>

</code></pre>
<p class="calibre9">我们的 runMaybeT 函数解开了在 x 中包含的结果。进而，注意到 &lt;- 符号是 (&gt;&gt;=) 的语法糖：monad变换器必须使用其下层monad的 (&gt;&gt;=) 。而最后一部分对 unwrapped 的结构分析（ case 表达式），决定了我们是要短路当前计算，还是将计算继续下去。最后，观察表达式的最外层。为了将下层monad再次藏起来，这里必须用 MaybeT 构造器包装结果。</p>
<p class="calibre9">刚才展示的 do 标记看起来更容易阅读，但是其将我们依赖下层monad的 (&gt;&gt;=) 函数的事实也藏了起来。下面提供一个更符合语言习惯的 MaybeT 的 (&gt;&gt;=) 实现：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>MaybeT<span class="token">.</span>hs
x `altBindMT` f <span class="token3">=</span>
    MaybeT $ runMaybeT x <span class="token3">&gt;</span><span class="token3">&gt;=</span> maybe <span class="token">(</span><span class="token1">return</span> Nothing<span class="token">)</span> <span class="token">(</span>runMaybeT <span class="token">.</span> f<span class="token">)</span>

</code></pre>
<p class="calibre9">现在我们了解了 (&gt;&gt;=) 在干些什么。关于 return 和 fail 无需太多解释， Monad 实例也不言自明：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>MaybeT<span class="token">.</span>hs
returnMT <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Monad m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> MaybeT m a
returnMT a <span class="token3">=</span> MaybeT $ <span class="token1">return</span> <span class="token">(</span>Just a<span class="token">)</span>

failMT <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Monad m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> t <span class="token3">-</span><span class="token3">&gt;</span> MaybeT m a
failMT _ <span class="token3">=</span> MaybeT $ <span class="token1">return</span> Nothing

instance <span class="token">(</span>Monad m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> Monad <span class="token">(</span>MaybeT m<span class="token">)</span> where
  <span class="token1">return</span> <span class="token3">=</span> returnMT
  <span class="token">(</span><span class="token3">&gt;</span><span class="token3">&gt;=</span><span class="token">)</span> <span class="token3">=</span> bindMT
  fail <span class="token3">=</span> failM

</code></pre>
<h2 class="calibre14"><a id="chp-18.html.Monad_492" class="calibre7 pcalibre"></a>建立Monad变换器</h2>
<p class="calibre9">为将我们的类型变成monad变换器，必须提供 MonadTrans 的实例，以使用户可以访问下层monad：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>MaybeT<span class="token">.</span>hs
instance MonadTrans MaybeT where
    lift m <span class="token3">=</span> MaybeT <span class="token">(</span>Just `liftM` m<span class="token">)</span>

</code></pre>
<p class="calibre9">下层monad以类型 a 开始：我们“注入” Just 构造器以使其变成需要的类型： Maybea 。进而我们通过 MaybeT 藏起下层monad。</p>
<h2 class="calibre14"><a id="chp-18.html._505" class="calibre7 pcalibre"></a>更多的类型类实例</h2>
<p class="calibre9">在定义好 MonadTrans 的实例后，便可用其来定义其他大量的 mtl 类型类实例了：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>MaybeT<span class="token">.</span>hs
instance <span class="token">(</span>MonadIO m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> MonadIO <span class="token">(</span>MaybeT m<span class="token">)</span> where
  liftIO m <span class="token3">=</span> lift <span class="token">(</span>liftIO m<span class="token">)</span>

instance <span class="token">(</span>MonadState s m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> MonadState s <span class="token">(</span>MaybeT m<span class="token">)</span> where
  get <span class="token3">=</span> lift get
  put k <span class="token3">=</span> lift <span class="token">(</span>put k<span class="token">)</span>

<span class="token3">--</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> 对 MonadReader，MonadWriter等的实例定义同理 <span class="token">.</span><span class="token">.</span><span class="token">.</span>

</code></pre>
<p class="calibre9">由于一些 mtl 类型类使用了函数式依赖，有些实例的声明需要GHC大大放宽其原有的类型检查规则。(若我们忘记了其中任意的 LANGUAGE 指令，编译器会在其错误信息中提供建议。)</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>MaybeT<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span># LANGUAGE FlexibleInstances<span class="token">,</span> MultiParamTypeClasses<span class="token">,</span>
             UndecidableInstances #<span class="token3">-</span><span class="token">}</span>

</code></pre>
<p class="calibre9">是花些时间来写这些样板实例呢，还是显式地使用 lift 呢？这取决于这个monad变换器的用途。 如果我们只在几种有限的情况下使用它，那么只提供 MonadTrans 实例就够了。在这种情况下，也无妨提供一些依然有意义的实例，比如 MonadIO。另一方面，若我们需要在大量的情况下使用这一monad变换器，那么花些时间来完成这些实例或许也不错。</p>
<h2 class="calibre14"><a id="chp-18.html.MonadParse_533" class="calibre7 pcalibre"></a>以Monad栈替代Parse类型</h2>
<p class="calibre9">现在我们已开发了一个支持提早退出的monad变换器，可以用其来辅助开发了。例如，此处若想处理解析一半失败的情况，便可以用这一以我们的需求定制的monad变换器来替代我们在第十章“隐式状态”一节开发的 Parse 类型。</p>
<h2 class="calibre14"><a id="chp-18.html._537" class="calibre7 pcalibre"></a>练习</h2>
<ol class="calibre17"><li class="calibre11">我们的Parse monad还不是之前版本的完美替代。因为其用的是 Maybe 而不是 Either 来代表结果。因此在失败时暂时无法提供任何有用的信息。</li></ol>
<blockquote class="default"><p class="calibre9">构建一个 EitherTs （其中 s 是某个类型）来表示结果，并用其实现更适合的 Parse monad以在解析失败时汇报具体错误信息。</p></blockquote>
<p class="calibre9">或许在你探索Haskell库的途中，在 Control.Monad.Error 遇到过一个 Either 类型的 Monad 实例。我们建议不要参照它来完成你的实现，因为它的设计太局限了：虽然其将 EitherString 变成一个monad，但实际上把 Either 的第一个类型参数限定为 String 并非必要。</p>
<p class="calibre9">提示: 若你按照这条建议来做，你的定义中或许需要使用 FlexibleInstances 语言扩展。</p>
<h2 class="calibre14"><a id="chp-18.html._547" class="calibre7 pcalibre"></a>注意变换器堆叠顺序</h2>
<p class="calibre9">从早先使用 ReaderT 和 StateT 的例子中，你或许会认为叠加monad变换器的顺序并不重要。事实并非如此，考虑在 State 上叠加 StateT 的情况，或许会助于你更清晰地意识到：堆叠的顺序确实产生了结果上的区别：类型 StateTInt(StateString) 和类型 StateTString(StateInt) 或许携带的信息相同，但它们却无法互换使用。叠加的顺序决定了我们是否要用 lift 来取得状态中的某个部分。</p>
<p class="calibre9">下面的例子更加显著地阐明了顺序的重要性。假设有个可能失败的计算，而我们想记录下在什么情况下其会失败：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>MTComposition<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span># LANGUAGE FlexibleContexts #<span class="token3">-</span><span class="token">}</span>
import Control<span class="token">.</span>Monad<span class="token">.</span>Writer
import MaybeT

problem <span class="token">:</span><span class="token">:</span> MonadWriter <span class="token">[</span>String<span class="token">]</span> m <span class="token3">=</span><span class="token3">&gt;</span> m <span class="token">(</span><span class="token">)</span>
problem <span class="token3">=</span> <span class="token1">do</span>
  tell <span class="token">[</span><span class="token4">"this is where i fail"</span><span class="token">]</span>
  fail <span class="token4">"oops"</span>

</code></pre>
<p class="calibre9">那么这两个monad栈中的哪一个会带给我们需要的信息呢？</p>
<pre class="calibre15"><code class="tthhighlight-container">type A <span class="token3">=</span> WriterT <span class="token">[</span>String<span class="token">]</span> Maybe

type B <span class="token3">=</span> MaybeT <span class="token">(</span>Writer <span class="token">[</span>String<span class="token">]</span><span class="token">)</span>

a <span class="token">:</span><span class="token">:</span> A <span class="token">(</span><span class="token">)</span>
a <span class="token3">=</span> problem

b <span class="token">:</span><span class="token">:</span> B <span class="token">(</span><span class="token">)</span>
b <span class="token3">=</span> problem

</code></pre>
<p class="calibre9">我们在 ghci 中试试看：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> runWriterT a
Loading package mtl<span class="token3">-</span><span class="token2">1.1</span><span class="token2">.0</span><span class="token2">.1</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Nothing
ghci<span class="token3">&gt;</span> runWriter $ runMaybeT b
<span class="token">(</span>Nothing<span class="token">,</span><span class="token">[</span><span class="token4">"this is where i fail"</span><span class="token">]</span><span class="token">)</span>

</code></pre>
<p class="calibre9">看看执行函数的类型签名，其实结果并不意外：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>t runWriterT
runWriterT <span class="token">:</span><span class="token">:</span> WriterT w m a <span class="token3">-</span><span class="token3">&gt;</span> m <span class="token">(</span>a<span class="token">,</span> w<span class="token">)</span>
ghci<span class="token3">&gt;</span> <span class="token">:</span>t runWriter <span class="token">.</span> runMaybeT
runWriter <span class="token">.</span> runMaybeT <span class="token">:</span><span class="token">:</span> MaybeT <span class="token">(</span>Writer w<span class="token">)</span> a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>Maybe a<span class="token">,</span> w<span class="token">)</span>

</code></pre>
<p class="calibre9">在 Maybe 上叠加 WriterT 的策略使 Maybe 成为下层monad，因此 runWriterT 必须给我们以 Maybe 为类型的结果。在测试样例中，我们只会在不出现任何失败的情况下才能获得日志！</p>
<p class="calibre9">叠加monad变换器类似于组合函数：如果我们改变函数应用的顺序，那么我们并不会对得到不同的结果感到意外。同样的道理也适用于对monad变换器的叠加。</p>
<h2 class="calibre14"><a id="chp-18.html.MonadMonad_606" class="calibre7 pcalibre"></a>纵观Monad与Monad变换器</h2>
<p class="calibre9">本节，让我们暂别细节，讨论一下用monad和monad变换器编程的优缺点。</p>
<h2 class="calibre14"><a id="chp-18.html._610" class="calibre7 pcalibre"></a>对纯代码的干涉</h2>
<p class="calibre9">在实际编程中，使用monad的最恼人之处或许在于其阻碍了我们使用纯代码。很多实用的纯函数需要一个monad版的类似函数，而其monad版只是加上一个占位参数 m 供monad类型构造器填充：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>t filter
filter <span class="token">:</span><span class="token">:</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> Bool<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span>
ghci<span class="token3">&gt;</span> <span class="token">:</span>i filterM
filterM <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Monad m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> m Bool<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> m <span class="token">[</span>a<span class="token">]</span>
      <span class="token3">--</span> Defined <span class="token1">in</span> Control<span class="token">.</span>Monad

</code></pre>
<p class="calibre9">然而，这种覆盖是有限的：标准库中并不总能提供纯函数的monad版本。</p>
<p class="calibre9">其中有一部分历史原因：Eugenio Moggi于1988年引入了使用monad编程的思想。而当时Haskell 1.0标准尚在开发中。现今版本的 Prelude 中的大部分函数可以追溯到于1990发布的Haskell 1.0。在1991年，Philip Wadler开始为更多的函数式编程听众作文，阐述monad的潜力。从那时起，monad开始用于实践。</p>
<p class="calibre9">直到1996年Haskell 1.3标准发布之时，monad才得到了支持。但是在那时，语言的设计者已经受制于维护向前兼容性: 它们无法改变 Prelude 中的函数签名，因为那会破坏现有的代码。</p>
<p class="calibre9">从那以后，Haskell社区学会了很多合适的抽象。因此我们可以写出不受这一纯函数／monad函数分裂影响的代码。你可以在 Data.Traversable 和 Data.Foldable 中找到这些思想的精华。</p>
<p class="calibre9">尽管它们极具吸引力，由于版面的限制。我们不会在本书中涵盖相关内容。但如果你能轻易理解本章内容，自行理解它们也不会有问题。</p>
<p class="calibre9">在理想世界里，我们是否会与过去断绝，并让 Prelude 包含 Traversable 和 Foldable 类型呢？或许不会，因为学习Haskell本身对新手来说已经是个相当刺激的历程了。在我们已经了解functor和monad之后， Foldable 和 Traversable 的抽象是十分容易理解的。但是对学习者来说这意味着摆在他们面前的是更多纯粹的抽象。若以教授语言为目的， map 操作的最好是列表，而不是functor。</p>
<p class="calibre9">[译注：实际上，自GHC 7.10开始， Foldable 和 Traversable 已经进入了 Prelude 。一些函数的类型签名会变得更加抽象（以GHC 7.10.1为例）：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">-</span><span class="token2">7.10</span><span class="token2">.1</span><span class="token3">&gt;</span> <span class="token">:</span>t mapM
mapM <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Monad m<span class="token">,</span> Traversable t<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> m b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> t a <span class="token3">-</span><span class="token3">&gt;</span> m <span class="token">(</span>t b<span class="token">)</span>
ghci<span class="token3">-</span><span class="token2">7.10</span><span class="token2">.1</span><span class="token3">&gt;</span> <span class="token">:</span>t foldl
foldl <span class="token">:</span><span class="token">:</span> Foldable t <span class="token3">=</span><span class="token3">&gt;</span> <span class="token">(</span>b <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> b <span class="token3">-</span><span class="token3">&gt;</span> t a <span class="token3">-</span><span class="token3">&gt;</span> b

</code></pre>
<p class="calibre9">这并不是一个对初学者友好的改动，但由于新的函数只是旧有函数的推广形式，使用旧的函数签名依旧可以通过类型检查：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">-</span><span class="token2">7.10</span><span class="token2">.1</span><span class="token3">&gt;</span> <span class="token">:</span>t <span class="token">(</span>mapM <span class="token">:</span><span class="token">:</span> Monad m <span class="token3">=</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> m b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> m <span class="token">[</span>b<span class="token">]</span><span class="token">)</span>
<span class="token">(</span>mapM <span class="token">:</span><span class="token">:</span> Monad m <span class="token3">=</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> m b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> m <span class="token">[</span>b<span class="token">]</span><span class="token">)</span>
  <span class="token">:</span><span class="token">:</span> Monad m <span class="token3">=</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> m b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> m <span class="token">[</span>b<span class="token">]</span>
ghci<span class="token3">-</span><span class="token2">7.10</span><span class="token2">.1</span><span class="token3">&gt;</span> <span class="token">:</span>t <span class="token">(</span>foldl <span class="token">:</span><span class="token">:</span> <span class="token">(</span>b <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> b <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> b<span class="token">)</span>
<span class="token">(</span>foldl <span class="token">:</span><span class="token">:</span> <span class="token">(</span>b <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> b <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> b<span class="token">)</span>
  <span class="token">:</span><span class="token">:</span> <span class="token">(</span>b <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> b<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> b <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> b

</code></pre>
<p class="calibre9">若在学习过程中遇到障碍，不妨暂且以旧的类型签名来理解它们。]</p>
<h2 class="calibre14"><a id="chp-18.html._659" class="calibre7 pcalibre"></a>对次序的过度限定</h2>
<p class="calibre9">我们使用monad的一个基本原因是：其允许我们指定效果发生的次序。再看看我们早先写的一小段代码：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch18<span class="token3">/</span>MTComposition<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span># LANGUAGE FlexibleContexts #<span class="token3">-</span><span class="token">}</span>
import Control<span class="token">.</span>Monad<span class="token">.</span>Writer
import MaybeT

problem <span class="token">:</span><span class="token">:</span> MonadWriter <span class="token">[</span>String<span class="token">]</span> m <span class="token3">=</span><span class="token3">&gt;</span> m <span class="token">(</span><span class="token">)</span>
problem <span class="token3">=</span> <span class="token1">do</span>
  tell <span class="token">[</span><span class="token4">"this is where i fail"</span><span class="token">]</span>
  fail <span class="token4">"oops"</span>

</code></pre>
<p class="calibre9">因为我们在monad中执行， tell 的效果可以保证发生在 fail 之前。这里的问题在于，这个次序并不必要，但是我们却得到了这样的次序保证。编译器无法任意安排monad式代码的次序，即便这么做能使代码效率更高。</p>
<p class="calibre9">[译注：解释一下这里的“次序并不必要”。回顾之前对叠加次序问题的讨论：</p>
<pre class="calibre15"><code class="tthhighlight-container">type A <span class="token3">=</span> WriterT <span class="token">[</span>String<span class="token">]</span> Maybe

type B <span class="token3">=</span> MaybeT <span class="token">(</span>Writer <span class="token">[</span>String<span class="token">]</span><span class="token">)</span>

a <span class="token">:</span><span class="token">:</span> A <span class="token">(</span><span class="token">)</span>
a <span class="token3">=</span> problem
<span class="token3">--</span> runWriterT a <span class="token3">==</span> Nothing

b <span class="token">:</span><span class="token">:</span> B <span class="token">(</span><span class="token">)</span>
b <span class="token3">=</span> problem
<span class="token3">--</span> runWriter <span class="token">(</span>runMaybeT b<span class="token">)</span> <span class="token3">==</span> <span class="token">(</span>Nothing<span class="token">,</span> <span class="token">[</span><span class="token4">"this is where i fail"</span><span class="token">]</span><span class="token">)</span>

</code></pre>
<p class="calibre9">下面把注意力集中于 a ： 注意到 runWriterTa==Nothing ， tell 的结果并不需要，因为接下来的 fail 取消了计算，将之前的结果抛弃了。利用这个事实，可以得知让 fail 先执行效率更高。同时注意对 fail 和 tell 的实际处理来自monad栈的不同层，所以在一定限制下调换某些操作的顺序会不影响结果。但是由于这个monad栈本身也要是个monad，使这种本来可以进行的交换变得不可能了。]</p>
<h2 class="calibre14"><a id="chp-18.html._697" class="calibre7 pcalibre"></a>运行时开销</h2>
<p class="calibre9">最后，当我们使用monad和monad变换器时，需要付出一些效率的代价。 例如 State monad携带状态并将其放在一个闭包中。在Haskell的实现中，闭包的开销或许廉价但绝非免费。</p>
<p class="calibre9">Monad变换器把其自身的开销附加在了其下层monad之上。每次我们使用 (&gt;&gt;=) 时，MaybeT变换器便需要包装和解包。而由 ReaderT ， StateT 和 MaybeT 依次叠加组成的monad栈，在每次使用 (&gt;&gt;=) 时，更是有一系列的簿记工作需要完成。</p>
<p class="calibre9">一个足够聪明的编译器或许可以将这些开销部分，甚至于全部消除。但是那种深度的复杂工作尚未广泛适用。</p>
<p class="calibre9">但是依旧有些相对简单技术可以避免其中的一些开销，版面的限制只允许我们在此做简单描述。例如，在continuation monad中，对 (&gt;&gt;=) 频繁的包装和解包可以避免，仅留下执行效果的开销。所幸的是使用这种方法所要考虑的大部分复杂问题，已经在函数库中得到了处理。</p>
<p class="calibre9">这一部分的工作在本书写作时尚在积极的开发中。如果你想让你对monad变换器的使用更加高效，我们推荐在Hackage中寻找相关的库或是在邮件列表或IRC上寻求指引。</p>
<h2 class="calibre14"><a id="chp-18.html._709" class="calibre7 pcalibre"></a>缺乏灵活性的接口</h2>
<p class="calibre9">若我们只把 mtl 当作黑盒，那么所有的组件将很好地合作。但是若我们开始开发自己的monad和monad变换器，并想让它们于 mtl 提供的组件配合，这种缺陷便显现出来了。</p>
<p class="calibre9">例如，我们开发一个新的monad变换器 FooT ，并想沿用 mtl 中的模式。我们就必须实现一个类型类 MonadFoo 。若我们想让其更好地和 mtl 配合，那么便需要提供大量的实例来支持 mtl 中的类型类。</p>
<p class="calibre9">除此之外，还需要为每个 mtl 中的变换器提供 MonadFoo 的实例。大部分的实例实现几乎是完全一样的，写起来也十分乏味。若我们想在 mtl 中集成更多的monad变换器，那么我们需要处理的各类活动部件将达到引入的monad变换器数量的 <em class="calibre13">平方级别</em> ！</p>
<p class="calibre9">公平地看来，这个问题会只影响到少数人。大部分 mtl 的用户并不需要开发新的monad。</p>
<p class="calibre9">造成这一 mtl 设计缺陷的原因在于，它是第一个monad变换器的函数库。想像其设计者投入这个未知的领域，完成了大量的工作以使这个强大的函数库对于大部分用户来说做到简便易用。</p>
<p class="calibre9">一个新的关于monad和变换器的函数库 monadLib ，修正了 mtl 中大量的设计缺陷。若在未来你成为了一个monad变换器的中坚骇客，这值得你一试。</p>
<p class="calibre9">平方级别的实例定义实际上是使用monad变换器带来的问题。除此之外另有其他的手段来组合利用monad。虽然那些手段可以避免这类问题，但是它们对最终用户而言仍不及monad变换器便利。幸运的是，并没有太多基础而泛用的monad变换器需要去定义实现。</p>
<h2 class="calibre14"><a id="chp-18.html._725" class="calibre7 pcalibre"></a>综述</h2>
<p class="calibre9">Monad在任何意义下都不是处理效果和类型的终极途径。它只是在我们探索至今，处理这类问题最为实用的技术。语言的研究者们一直致力于找到可以扬长避短的替代系统。</p>
<p class="calibre9">尽管在使用它们时我们必须做出妥协，monad和monad变换器依旧提供了一定程度上的灵活度和控制，而这在指令式语言中并无先例。 仅仅几个声明，我们就可以给分号般基础的东西赋予崭新的意义。</p>
<p class="calibre9">[译注：此处的分号应该指的是 do 标记中使用的分号。]</p>
</div></div></div></div></div></div>
<div id="chp-19.html"><div class="calibre">
<div id="chp-19.html.main" class="calibre1"><div class="root"><div class="article"><h1 class="article-head" id="chp-19.html.calibre_toc_14">第十九章： 错误处理</h1><div class="article-body"><h1 class="calibre6"><a id="chp-19.html.__0" class="calibre7 pcalibre"></a>第十九章： 错误处理</h1>
<p class="calibre9">无论使用哪门语言，错误处理都是程序员最重要–也是最容易忽视–的话题之一。在Haskell中，你会发现有两类主流的错误处理：“纯”的错误处理和异常。</p>
<p class="calibre9">当我们说“纯”的错误处理，我们是指算法不依赖任何IO Monad。我们通常会利用Haskell富于表现力的数据类型系统来实现这一类错误处理。Haskell也支持异常。由于惰性求值复杂性，Haskell中任何地方都可能抛出异常，但是只会在IO monad中被捕获。在这一章中，这两类错误处理我们都会考虑。</p>
<h2 class="calibre14"><a id="chp-19.html._6" class="calibre7 pcalibre"></a>使用数据类型进行错误处理</h2>
<p class="calibre9">让我们从一个非常简单的函数来开始我们关于错误处理的讨论。假设我们希望对一系列的数字执行除法运算。分子是常数，但是分母是变化的。可能我们会写出这样一个函数：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>divby1<span class="token">.</span>hs
divBy <span class="token">:</span><span class="token">:</span> Integral a <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span>
divBy numerator <span class="token3">=</span> map <span class="token">(</span>numerator `div`<span class="token">)</span>

</code></pre>
<p class="calibre9">非常简单，对吧？我们可以在 ghci 中执行这些代码：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> divBy <span class="token2">50</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">8</span><span class="token">,</span><span class="token2">10</span><span class="token">]</span>
<span class="token">[</span><span class="token2">50</span><span class="token">,</span><span class="token2">25</span><span class="token">,</span><span class="token2">10</span><span class="token">,</span><span class="token2">6</span><span class="token">,</span><span class="token2">5</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> take <span class="token2">5</span> <span class="token">(</span>divBy <span class="token2">100</span> <span class="token">[</span><span class="token2">1.</span><span class="token">.</span><span class="token">]</span><span class="token">)</span>
<span class="token">[</span><span class="token2">100</span><span class="token">,</span><span class="token2">50</span><span class="token">,</span><span class="token2">33</span><span class="token">,</span><span class="token2">25</span><span class="token">,</span><span class="token2">20</span><span class="token">]</span>

</code></pre>
<p class="calibre9">这个行为跟我们预期的是一致的：50 / 1 得到50，50 / 2 得到25，等等。甚至对于无穷的链表 [1..] 它也是可以工作的。如果有个0溜进去我们的链表中了，会发生什么事呢？</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> divBy <span class="token2">50</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">0</span><span class="token">,</span><span class="token2">8</span><span class="token">,</span><span class="token2">10</span><span class="token">]</span>
<span class="token">[</span><span class="token2">50</span><span class="token">,</span><span class="token2">25</span><span class="token">,</span><span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> divide by zero

</code></pre>
<p class="calibre9">是不是很有意思？ ghci 开始显示输出，然后当它遇到零时发生了一个异常停止了。这是惰性求值的作用–它只按需求值。</p>
<p class="calibre9">在这一章里接下来我们会看到，缺乏一个明确的异常处理时，这个异常会使程序崩溃。这当然不是我们想要的，所以让我们思考一下更好的方式来表征这个纯函数中的错误。</p>
<h2 class="calibre14"><a id="chp-19.html.Maybe_39" class="calibre7 pcalibre"></a>使用Maybe</h2>
<p class="calibre9">可以立刻想到的一个表示失败的简单的方法是使用 Maybe 。如果输入链表中任何地方包含了零，相对于仅仅返回一个链表并在失败的时候抛出异常，我们可以返回 Nothing ，或者如果没有出现零我们可以返回结果的 Just。下面是这个算法的实现：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>divby2<span class="token">.</span>hs
divBy <span class="token">:</span><span class="token">:</span> Integral a <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Maybe <span class="token">[</span>a<span class="token">]</span>
divBy _ <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> Just <span class="token">[</span><span class="token">]</span>
divBy _ <span class="token">(</span><span class="token2">0</span><span class="token">:</span>_<span class="token">)</span> <span class="token3">=</span> Nothing
divBy numerator <span class="token">(</span>denom<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span>
    case divBy numerator xs of
      Nothing <span class="token3">-</span><span class="token3">&gt;</span> Nothing
      Just results <span class="token3">-</span><span class="token3">&gt;</span> Just <span class="token">(</span><span class="token">(</span>numerator `div` denom<span class="token">)</span> <span class="token">:</span> results<span class="token">)</span>

</code></pre>
<p class="calibre9">如果你在 ghci 中尝试它，你会发现它可以工作：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> divBy <span class="token2">50</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">8</span><span class="token">,</span><span class="token2">10</span><span class="token">]</span>
Just <span class="token">[</span><span class="token2">50</span><span class="token">,</span><span class="token2">25</span><span class="token">,</span><span class="token2">10</span><span class="token">,</span><span class="token2">6</span><span class="token">,</span><span class="token2">5</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> divBy <span class="token2">50</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">0</span><span class="token">,</span><span class="token2">8</span><span class="token">,</span><span class="token2">10</span><span class="token">]</span>
Nothing

</code></pre>
<p class="calibre9">调用 divBy 的函数现在可以使用 case 语句来观察调用成功与否，就像 divBy 调用自己时所做的那样。</p>
<p class="calibre9">Tip</p>
<p class="calibre9">你大概注意到，上面可以使用一个monadic的实现，像这样子：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>divby2m<span class="token">.</span>hs
divBy <span class="token">:</span><span class="token">:</span> Integral a <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Maybe <span class="token">[</span>a<span class="token">]</span>
divBy numerator denominators <span class="token3">=</span> 
    mapM <span class="token">(</span>numerator `safeDiv`<span class="token">)</span> denominators
    where safeDiv _ <span class="token2">0</span> <span class="token3">=</span> Nothing
          safeDiv x y <span class="token3">=</span> x `div` y

</code></pre>
<p class="calibre9">出于简单考虑，在这章中我们会避免使用monadic实现，但是会指出有这种做法。</p>
<p class="calibre9">[译注:Tip中那段代码编译不过]</p>
<h4 class="calibre19"><a id="chp-19.html._85" class="calibre7 pcalibre"></a>丢失和保存惰性</h4>
<p class="calibre9">使用 Maybe 很方便，但是有代价。 divBy 将不能够再处理无限的链表输入。由于结果是一个 Maybe[a] ，必须要检查整个输入链表，我们才能确认不会因为存在零而返回 Nothing 。你可以尝试在之前的例子中验证这一点：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> divBy <span class="token2">100</span> <span class="token">[</span><span class="token2">1.</span><span class="token">.</span><span class="token">]</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> stack overflow

</code></pre>
<p class="calibre9">这里观察到，你没有看到部分的输出；你没得到任何输出。注意到在 divBy 的每一步中(除了输入链表为空或者链表开头是零的情况)，每个子序列元素的结果必须先于当前元素的结果得到。因此这个算法无法处理无穷链表，并且对于大的有限链表，它的空间效率也不高。</p>
<p class="calibre9">之前已经说过， Maybe 通常是一个好的选择。在这个特殊例子中，只有当我们去执行整个输入的时候我们才知道是否有问题。有时候我们可以提交发现问题，例如，在 ghci 中 tail[] 会生成一个异常。我们可以很容易写一个可以处理无穷情况的 tail ：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>safetail<span class="token">.</span>hs
safeTail <span class="token">:</span><span class="token">:</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Maybe <span class="token">[</span>a<span class="token">]</span>
safeTail <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> Nothing
safeTail <span class="token">(</span>_<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span> Just xs

</code></pre>
<p class="calibre9">如果输入为空，简单的返回一个 Nothing ，其它情况返回结果的 Just 。由于在知道是否发生错误之前，我们只需要确认链表非空，在这里使用 Maybe 不会破坏惰性。我们可以在 ghci 中测试并观察跟普通的 tail 有何不同：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> tail <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">,</span><span class="token2">4</span><span class="token">,</span><span class="token2">5</span><span class="token">]</span>
<span class="token">[</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">,</span><span class="token2">4</span><span class="token">,</span><span class="token2">5</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> safeTail <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">,</span><span class="token2">4</span><span class="token">,</span><span class="token2">5</span><span class="token">]</span>
Just <span class="token">[</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">,</span><span class="token2">4</span><span class="token">,</span><span class="token2">5</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> tail <span class="token">[</span><span class="token">]</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> Prelude<span class="token">.</span>tail<span class="token">:</span> empty list
ghci<span class="token3">&gt;</span> safeTail <span class="token">[</span><span class="token">]</span>
Nothing

</code></pre>
<p class="calibre9">这里我们可以看到，我们的 safeTail 执行结果符合预期。但是对于无穷链表呢？我们不想打印无穷的结果的数字，所以我们用 take5(tail[1..]) 以及一个类似的saftTail构建测试：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> take <span class="token2">5</span> <span class="token">(</span>tail <span class="token">[</span><span class="token2">1.</span><span class="token">.</span><span class="token">]</span><span class="token">)</span>
<span class="token">[</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">,</span><span class="token2">4</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">6</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> case safeTail <span class="token">[</span><span class="token2">1.</span><span class="token">.</span><span class="token">]</span> of <span class="token">{</span>Nothing <span class="token3">-</span><span class="token3">&gt;</span> Nothing<span class="token">;</span> Just x <span class="token3">-</span><span class="token3">&gt;</span> Just <span class="token">(</span>take <span class="token2">5</span> x<span class="token">)</span><span class="token">}</span>
Just <span class="token">[</span><span class="token2">2</span><span class="token">,</span><span class="token2">3</span><span class="token">,</span><span class="token2">4</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">6</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> take <span class="token2">5</span> <span class="token">(</span>tail <span class="token">[</span><span class="token">]</span><span class="token">)</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> Prelude<span class="token">.</span>tail<span class="token">:</span> empty list
ghci<span class="token3">&gt;</span> case safeTail <span class="token">[</span><span class="token">]</span> of <span class="token">{</span>Nothing <span class="token3">-</span><span class="token3">&gt;</span> Nothing<span class="token">;</span> Just x <span class="token3">-</span><span class="token3">&gt;</span> Just <span class="token">(</span>take <span class="token2">5</span> x<span class="token">)</span><span class="token">}</span>
Nothing

</code></pre>
<p class="calibre9">这里你可以看到 tail 和 safeTail 都可以处理无穷链表。注意我们可以更好地处理空的输入链表；而不是抛出异常，我们决定这种情况返回 Nothing 。我们可以获得错误处理能力却不会失去惰性。</p>
<p class="calibre9">但是我们如何将它应用到我们的 divBy 的例子中呢？让我们思考下现在的情况：失败是单个坏的输入的属性，而不是输入链表自身。那么将失败作为单个输出元素的属性，而不是整个输出链表怎么样？也就是说，不是一个类型为 a-&gt;[a]-&gt;Maybe[a] 的函数，取而代之我们使用 a-&gt;[a]-&gt;[Maybea] 。这样做的好处是可以保留惰性，并且调用者可以确定是在链表中的哪里出了问题–或者甚至是过滤掉有问题的结果，如果需要的话。这里是一个实现：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>divby3<span class="token">.</span>hs
divBy <span class="token">:</span><span class="token">:</span> Integral a <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>Maybe a<span class="token">]</span>
divBy numerator denominators <span class="token3">=</span>
    map worker denominators
    where worker <span class="token2">0</span> <span class="token3">=</span> Nothing
          worker x <span class="token3">=</span> Just <span class="token">(</span>numerator `div` x<span class="token">)</span>

</code></pre>
<p class="calibre9">看下这个函数，我们再次回到使用 map ，这无论对简洁和惰性都是件好事。我们可以在 ghci 中测试它，并观察对于有限和无限链表它都可以正常工作：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> divBy <span class="token2">50</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">8</span><span class="token">,</span><span class="token2">10</span><span class="token">]</span>
<span class="token">[</span>Just <span class="token2">50</span><span class="token">,</span>Just <span class="token2">25</span><span class="token">,</span>Just <span class="token2">10</span><span class="token">,</span>Just <span class="token2">6</span><span class="token">,</span>Just <span class="token2">5</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> divBy <span class="token2">50</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">0</span><span class="token">,</span><span class="token2">8</span><span class="token">,</span><span class="token2">10</span><span class="token">]</span>
<span class="token">[</span>Just <span class="token2">50</span><span class="token">,</span>Just <span class="token2">25</span><span class="token">,</span>Nothing<span class="token">,</span>Just <span class="token2">6</span><span class="token">,</span>Just <span class="token2">5</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> take <span class="token2">5</span> <span class="token">(</span>divBy <span class="token2">100</span> <span class="token">[</span><span class="token2">1.</span><span class="token">.</span><span class="token">]</span><span class="token">)</span>
<span class="token">[</span>Just <span class="token2">100</span><span class="token">,</span>Just <span class="token2">50</span><span class="token">,</span>Just <span class="token2">33</span><span class="token">,</span>Just <span class="token2">25</span><span class="token">,</span>Just <span class="token2">20</span><span class="token">]</span>

</code></pre>
<p class="calibre9">我们希望通过这个讨论你可以明白这点，不符合规范的（正如 safeTail 中的情况）输入和包含坏的数据的输入( divBy 中的情况)是有区别的。这两种情况通常需要对结果采用不同的处理。</p>
<h4 class="calibre19"><a id="chp-19.html.Maybe_Monad_163" class="calibre7 pcalibre"></a>Maybe Monad的用法</h4>
<p class="calibre9">回到 <em class="calibre13">使用Maybe</em> 这一节，我们有一个叫做 divby2.hs 的示例程序。这个例子没有保存惰性，而是返回一个类型为 Maybe[a] 的值。用monadic风格也可以表达同样的算法。更多信息和monad相关背景，参考 <a href="http://rwh.readthedocs.org/en/latest/chp/14.html" target="_blank" class="calibre7 pcalibre">第14章Monads</a> [<a href="http://rwh.readthedocs.org/en/latest/chp/14.html" target="_blank" class="calibre7 pcalibre">http://rwh.readthedocs.org/en/latest/chp/14.html</a>] 。这是我们新的monadic风格的算法：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>divby4<span class="token">.</span>hs
divBy <span class="token">:</span><span class="token">:</span> Integral a <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Maybe <span class="token">[</span>a<span class="token">]</span>
divBy _ <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> <span class="token1">return</span> <span class="token">[</span><span class="token">]</span>
divBy _ <span class="token">(</span><span class="token2">0</span><span class="token">:</span>_<span class="token">)</span> <span class="token3">=</span> fail <span class="token4">"division by zero in divBy"</span>
divBy numerator <span class="token">(</span>denom<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span>
    <span class="token1">do</span> next <span class="token3">&lt;</span><span class="token3">-</span> divBy numerator xs
       <span class="token1">return</span> <span class="token">(</span><span class="token">(</span>numerator `div` denom<span class="token">)</span> <span class="token">:</span> next<span class="token">)</span>

</code></pre>
<p class="calibre9">Maybe monad使得这个算法的表示看上去更好。对于 Maybe monad， return 就跟 Just 一样，并且 fail_=Nothing ，因此我们看到任何的错误说明的字段串。我们可以用我们在 divby2.hs 中使用过的测试来测试这个算法：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> divBy <span class="token2">50</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">8</span><span class="token">,</span><span class="token2">10</span><span class="token">]</span>
Just <span class="token">[</span><span class="token2">50</span><span class="token">,</span><span class="token2">25</span><span class="token">,</span><span class="token2">10</span><span class="token">,</span><span class="token2">6</span><span class="token">,</span><span class="token2">5</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> divBy <span class="token2">50</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">0</span><span class="token">,</span><span class="token2">8</span><span class="token">,</span><span class="token2">10</span><span class="token">]</span>
Nothing
ghci<span class="token3">&gt;</span> divBy <span class="token2">100</span> <span class="token">[</span><span class="token2">1.</span><span class="token">.</span><span class="token">]</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> stack overflow

</code></pre>
<p class="calibre9">我们写的代码实际上并不限于 Maybe monad。只要简单地改变类型，我们可以让它对于任何monad都能工作。让我们试一下：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>divby5<span class="token">.</span>hs
divBy <span class="token">:</span><span class="token">:</span> Integral a <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Maybe <span class="token">[</span>a<span class="token">]</span>
divBy <span class="token3">=</span> divByGeneric

divByGeneric <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Monad m<span class="token">,</span> Integral a<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> m <span class="token">[</span>a<span class="token">]</span>
divByGeneric _ <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> <span class="token1">return</span> <span class="token">[</span><span class="token">]</span>
divByGeneric _ <span class="token">(</span><span class="token2">0</span><span class="token">:</span>_<span class="token">)</span> <span class="token3">=</span> fail <span class="token4">"division by zero in divByGeneric"</span>
divByGeneric numerator <span class="token">(</span>denom<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span>
    <span class="token1">do</span> next <span class="token3">&lt;</span><span class="token3">-</span> divByGeneric numerator xs
       <span class="token1">return</span> <span class="token">(</span><span class="token">(</span>numerator `div` denom<span class="token">)</span> <span class="token">:</span> next<span class="token">)</span>

</code></pre>
<p class="calibre9">函数 divByGeneric 包含的代码 divBy 之前所做的一样；我们只是给它一个更通用的类型。事实上，如果不给出类型，这个类型是由 ghci 自动推导的。我们还为特定的类型定义了一个更方便的函数 divBy 。</p>
<p class="calibre9">让我们在 ghci 中运行一下。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>l divby5<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> divby5<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>
ghci<span class="token3">&gt;</span> divBy <span class="token2">50</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">8</span><span class="token">,</span><span class="token2">10</span><span class="token">]</span>
Just <span class="token">[</span><span class="token2">50</span><span class="token">,</span><span class="token2">25</span><span class="token">,</span><span class="token2">10</span><span class="token">,</span><span class="token2">6</span><span class="token">,</span><span class="token2">5</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> <span class="token">(</span>divByGeneric <span class="token2">50</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">8</span><span class="token">,</span><span class="token2">10</span><span class="token">]</span><span class="token">)</span><span class="token">:</span><span class="token">:</span><span class="token">(</span>Integral a <span class="token3">=</span><span class="token3">&gt;</span> Maybe <span class="token">[</span>a<span class="token">]</span><span class="token">)</span>
Just <span class="token">[</span><span class="token2">50</span><span class="token">,</span><span class="token2">25</span><span class="token">,</span><span class="token2">10</span><span class="token">,</span><span class="token2">6</span><span class="token">,</span><span class="token2">5</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> divByGeneric <span class="token2">50</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">8</span><span class="token">,</span><span class="token2">10</span><span class="token">]</span>
<span class="token">[</span><span class="token2">50</span><span class="token">,</span><span class="token2">25</span><span class="token">,</span><span class="token2">10</span><span class="token">,</span><span class="token2">6</span><span class="token">,</span><span class="token2">5</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> divByGeneric <span class="token2">50</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">0</span><span class="token">,</span><span class="token2">8</span><span class="token">,</span><span class="token2">10</span><span class="token">]</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> user error <span class="token">(</span>division by zero <span class="token1">in</span> divByGeneric<span class="token">)</span>

</code></pre>
<p class="calibre9">前两个例子产生的输出都跟我们之前看到的一样。由于 divByGeneric 没有指定返回的类型，我们要么指定一个，要么让解释器从环境中推导得到。如果我们不指定返回类型， ghic 推荐得到 IO monad。在第三和第四个例子中你可以看出来。在第四个例子中你可以看到， IO monad将 fail 转化成了一个异常。</p>
<p class="calibre9">mtl 包中的 Control.Monad.Error 模块也将 EitherString 变成了一个monad。如果你使用 Either ，你可以得到保存了错误信息的纯的结果，像这样子：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>m <span class="token3">+</span>Control<span class="token">.</span>Monad<span class="token">.</span>Error
ghci<span class="token3">&gt;</span> <span class="token">(</span>divByGeneric <span class="token2">50</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">8</span><span class="token">,</span><span class="token2">10</span><span class="token">]</span><span class="token">)</span><span class="token">:</span><span class="token">:</span><span class="token">(</span>Integral a <span class="token3">=</span><span class="token3">&gt;</span> Either String <span class="token">[</span>a<span class="token">]</span><span class="token">)</span>
Loading package mtl<span class="token3">-</span><span class="token2">1.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Right <span class="token">[</span><span class="token2">50</span><span class="token">,</span><span class="token2">25</span><span class="token">,</span><span class="token2">10</span><span class="token">,</span><span class="token2">6</span><span class="token">,</span><span class="token2">5</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> <span class="token">(</span>divByGeneric <span class="token2">50</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">0</span><span class="token">,</span><span class="token2">8</span><span class="token">,</span><span class="token2">10</span><span class="token">]</span><span class="token">)</span><span class="token">:</span><span class="token">:</span><span class="token">(</span>Integral a <span class="token3">=</span><span class="token3">&gt;</span> Either String <span class="token">[</span>a<span class="token">]</span><span class="token">)</span>
Left <span class="token4">"division by zero in divByGeneric"</span>

</code></pre>
<p class="calibre9">这让我们进入到下一个话题的讨论：使用 Either 返回错误信息。</p>
<h2 class="calibre14"><a id="chp-19.html.Either_241" class="calibre7 pcalibre"></a>使用Either</h2>
<p class="calibre9">Either 类型跟 Maybe 类型类似，除了一处关键的不同：对于错误或者成功（“ Right 类型”），它都可以携带数据。尽管语言没有强加任何限制，按照惯例，一个返回 Either 的函数使用 Left 返回值来表示一个错误， Right 来表示成功。如果你觉得这样有助于记忆，你可以认为 Right 表式正确结果。我们可以改一下前面小节中关于 Maybe 时使用的 divby2.hs 的例子，让 Either 可以工作：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>divby6<span class="token">.</span>hs
divBy <span class="token">:</span><span class="token">:</span> Integral a <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Either String <span class="token">[</span>a<span class="token">]</span>
divBy _ <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> Right <span class="token">[</span><span class="token">]</span>
divBy _ <span class="token">(</span><span class="token2">0</span><span class="token">:</span>_<span class="token">)</span> <span class="token3">=</span> Left <span class="token4">"divBy: division by 0"</span>
divBy numerator <span class="token">(</span>denom<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span>
    case divBy numerator xs of
      Left x <span class="token3">-</span><span class="token3">&gt;</span> Left x
      Right results <span class="token3">-</span><span class="token3">&gt;</span> Right <span class="token">(</span><span class="token">(</span>numerator `div` denom<span class="token">)</span> <span class="token">:</span> results<span class="token">)</span>

</code></pre>
<p class="calibre9">这份代码跟 Maybe 的代码几乎是完全一样的；我们只是把每个 Just 用 Right 替换。Left 对应于 Nothing ，但是现在它可以携带一条信息。让我们在 ghci 里面运行一下：</p>
<blockquote class="default"><p class="calibre9">ghci&gt; divBy 50 [1,2,5,8,10]Right [50,25,10,6,5]ghci&gt; divBy 50 [1,2,0,8,10]Left “divBy: division by 0”</p></blockquote>
<h4 class="calibre19"><a id="chp-19.html._261" class="calibre7 pcalibre"></a>为错误定制数据类型</h4>
<p class="calibre9">尽管用 String 类型来表示错误的原因对今后很有好处，自定义的错误类型通常会更有帮助。使用自定义的错误类型我们可以知道到底是出了什么问题，并且获知是什么动作引发的这个问题。例如，让我们假设，由于某些原因，不仅仅是除0，我们还不想除以10或者20。我们可以像这样子自定义一个错误类型：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>divby7<span class="token">.</span>hs
data DivByError a <span class="token3">=</span> DivBy0
                 <span class="token3">|</span> ForbiddenDenominator a
                   deriving <span class="token">(</span>Eq<span class="token">,</span> Read<span class="token">,</span> Show<span class="token">)</span>

divBy <span class="token">:</span><span class="token">:</span> Integral a <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Either <span class="token">(</span>DivByError a<span class="token">)</span> <span class="token">[</span>a<span class="token">]</span>
divBy _ <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> Right <span class="token">[</span><span class="token">]</span>
divBy _ <span class="token">(</span><span class="token2">0</span><span class="token">:</span>_<span class="token">)</span> <span class="token3">=</span> Left DivBy0
divBy _ <span class="token">(</span><span class="token2">10</span><span class="token">:</span>_<span class="token">)</span> <span class="token3">=</span> Left <span class="token">(</span>ForbiddenDenominator <span class="token2">10</span><span class="token">)</span>
divBy _ <span class="token">(</span><span class="token2">20</span><span class="token">:</span>_<span class="token">)</span> <span class="token3">=</span> Left <span class="token">(</span>ForbiddenDenominator <span class="token2">20</span><span class="token">)</span>
divBy numerator <span class="token">(</span>denom<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span>
    case divBy numerator xs of
      Left x <span class="token3">-</span><span class="token3">&gt;</span> Left x
      Right results <span class="token3">-</span><span class="token3">&gt;</span> Right <span class="token">(</span><span class="token">(</span>numerator `div` denom<span class="token">)</span> <span class="token">:</span> results<span class="token">)</span>

</code></pre>
<p class="calibre9">现在，在出现错误时，可以通过 Left 数据检查导致错误的准确原因。或者，可以简单的只是通过 show 打印出来。下面是这个函数的应用：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> divBy <span class="token2">50</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">8</span><span class="token">]</span>
Right <span class="token">[</span><span class="token2">50</span><span class="token">,</span><span class="token2">25</span><span class="token">,</span><span class="token2">10</span><span class="token">,</span><span class="token2">6</span><span class="token">]</span>
ghci<span class="token3">&gt;</span> divBy <span class="token2">50</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">5</span><span class="token">,</span><span class="token2">8</span><span class="token">,</span><span class="token2">10</span><span class="token">]</span>
Left <span class="token">(</span>ForbiddenDenominator <span class="token2">10</span><span class="token">)</span>
ghci<span class="token3">&gt;</span> divBy <span class="token2">50</span> <span class="token">[</span><span class="token2">1</span><span class="token">,</span><span class="token2">2</span><span class="token">,</span><span class="token2">0</span><span class="token">,</span><span class="token2">8</span><span class="token">,</span><span class="token2">10</span><span class="token">]</span>
Left DivBy0

</code></pre>
<p class="calibre9">Warning</p>
<p class="calibre9">所有这些 Either 的例子都跟我们之前的 Maybe 一样，都会遇到失去惰性的问题。我们将在这一章的最后用一个练习题来解决这个问题。</p>
<h4 class="calibre19"><a id="chp-19.html.MonadicEither_299" class="calibre7 pcalibre"></a>Monadic地使用Either</h4>
<p class="calibre9">回到 <em class="calibre13">Maybe Monad的用法</em> 这一节，我们向你展示了如何在一个monad中使用 Maybe 。 Either 也可以在monad中使用，但是可能会复杂一点。原因是 fail 是硬编码的只接受 String 作为失败代码，因此我们必须有一种方法将这样的字符串映射成我们的 Left 使用的类型。正如你前面所见， Control.Monad.Error 为 EitherStringa 提供了内置的支持，它没有涉及到将参数映射到 fail 。这里我们可以将我们的例子修改为monadic风格使得 Either 可以工作：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>divby8<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span># LANGUAGE FlexibleContexts #<span class="token3">-</span><span class="token">}</span>

import Control<span class="token">.</span>Monad<span class="token">.</span>Error

data Show a <span class="token3">=</span><span class="token3">&gt;</span> 
    DivByError a <span class="token3">=</span> DivBy0
                  <span class="token3">|</span> ForbiddenDenominator a
                  <span class="token3">|</span> OtherDivByError String
                    deriving <span class="token">(</span>Eq<span class="token">,</span> Read<span class="token">,</span> Show<span class="token">)</span>

instance Error <span class="token">(</span>DivByError a<span class="token">)</span> where
    strMsg x <span class="token3">=</span> OtherDivByError x

divBy <span class="token">:</span><span class="token">:</span> Integral a <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Either <span class="token">(</span>DivByError a<span class="token">)</span> <span class="token">[</span>a<span class="token">]</span>
divBy <span class="token3">=</span> divByGeneric

divByGeneric <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Integral a<span class="token">,</span> MonadError <span class="token">(</span>DivByError a<span class="token">)</span> m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span>
                 a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> m <span class="token">[</span>a<span class="token">]</span>
divByGeneric _ <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> <span class="token1">return</span> <span class="token">[</span><span class="token">]</span>
divByGeneric _ <span class="token">(</span><span class="token2">0</span><span class="token">:</span>_<span class="token">)</span> <span class="token3">=</span> throwError DivBy0
divByGeneric _ <span class="token">(</span><span class="token2">10</span><span class="token">:</span>_<span class="token">)</span> <span class="token3">=</span> throwError <span class="token">(</span>ForbiddenDenominator <span class="token2">10</span><span class="token">)</span>
divByGeneric _ <span class="token">(</span><span class="token2">20</span><span class="token">:</span>_<span class="token">)</span> <span class="token3">=</span> throwError <span class="token">(</span>ForbiddenDenominator <span class="token2">20</span><span class="token">)</span>
divByGeneric numerator <span class="token">(</span>denom<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span>
    <span class="token1">do</span> next <span class="token3">&lt;</span><span class="token3">-</span> divByGeneric numerator xs
       <span class="token1">return</span> <span class="token">(</span><span class="token">(</span>numerator `div` denom<span class="token">)</span> <span class="token">:</span> next<span class="token">)</span>

</code></pre>
<p class="calibre9">这里，我们需要打开 FlexibleContexts 语言扩展以提供 divByGeneric 的类型签名。 divBy 函数跟之前的工作方式完全一致。对于 divByGeneric ，我们将 divByError 做为 Error 类型类的成员，通过定义调用 fail 时的行为（ strMsg 函数）。我们还将 Right 转化成 return ，将 Left 转化成 throwError 进行泛化。</p>
<h2 class="calibre14"><a id="chp-19.html._335" class="calibre7 pcalibre"></a>异常</h2>
<p class="calibre9">许多语言中都有异常处理，包括Haskell。异常很有用，因为当发生故障时，它提供了一种简单的处理方法，即使故障离发生的地方沿着函数调用链走了几层。有了异常，不需要检查每个函数调用的返回值是否发生了错误，不需要注意去生成表示错误的返回值，像C程序员必须这么做。在Haskell中，由于有 monad以及 Either 和 Maybe 类型，你通常可以在纯的代码中达到同样的效果而不需要使用异常和异常处理。</p>
<p class="calibre9">有些问题–尤其是涉及到IO调用–需要处理异常。在Haskell中，异常可能会在程序的任何地方抛出。然而，由于计算顺序是不确定的，异常只可以在 IO monad中捕获。Haskell异常处理不涉及像Python或者Java中那样的特殊语法。捕获和处理异常的技术是–真令人惊讶–函数。</p>
<h2 class="calibre14"><a id="chp-19.html._341" class="calibre7 pcalibre"></a>异常第一步</h2>
<p class="calibre9">在 Control.Exception 模块中，定义了各种跟异常相关的函数和类型。 Exception 类型是在那里定义的；所有的异常的类型都是 Exception 。还有用于捕获和处理异常的函数。让我们先看一看 try ，它的类型是 IOa-&gt;IO(EitherExceptiona) 。它将异常处理包装在 IO 中。如果有异常抛出，它会返回一个 Left 值表示异常；否则，返回原始结果到 Right 值。让我们在 ghci 中运行一下。我们首先触发一个未处理的异常，然后尝试捕获它。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>m Control<span class="token">.</span>Exception
ghci<span class="token3">&gt;</span> let x <span class="token3">=</span> <span class="token2">5</span> `div` <span class="token2">0</span>
ghci<span class="token3">&gt;</span> let y <span class="token3">=</span> <span class="token2">5</span> `div` <span class="token2">1</span>
ghci<span class="token3">&gt;</span> print x
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> divide by zero
ghci<span class="token3">&gt;</span> print y
<span class="token2">5</span>
ghci<span class="token3">&gt;</span> <span class="token1">try</span> <span class="token">(</span>print x<span class="token">)</span>
Left divide by zero
ghci<span class="token3">&gt;</span> <span class="token1">try</span> <span class="token">(</span>print y<span class="token">)</span>
<span class="token2">5</span>
Right <span class="token">(</span><span class="token">)</span>

</code></pre>
<p class="calibre9">注意到在 let 语句中没有抛出异常。这是意料之中的，是因为惰性求值；除以零只有到打印 x 的值的时候才需要计算。还有，注意 try(printy) 有两行输出。第一行是由 print 产生的，它在终端上显示5。第二个是由 ghci 生成的，这个表示 printy 的返回值为 () 并且没有抛出异常。</p>
<h2 class="calibre14"><a id="chp-19.html._363" class="calibre7 pcalibre"></a>惰性和异常处理</h2>
<p class="calibre9">既然你知道了 try 是如何工作的，让我们试下另一个实验。让我们假设我们想捕获 try 的结果用于后续的计算，这样我们可以处理除的结果。我们大概会这么做：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> result <span class="token3">&lt;</span><span class="token3">-</span> <span class="token1">try</span> <span class="token">(</span><span class="token1">return</span> x<span class="token">)</span>
Right <span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> divide by zero

</code></pre>
<p class="calibre9">这里发生了什么？让我们拆成一步一步看，先试下另一个例子：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> let z <span class="token3">=</span> undefined
ghci<span class="token3">&gt;</span> <span class="token1">try</span> <span class="token">(</span>print z<span class="token">)</span>
Left Prelude<span class="token">.</span>undefined
ghci<span class="token3">&gt;</span> result <span class="token3">&lt;</span><span class="token3">-</span> <span class="token1">try</span> <span class="token">(</span><span class="token1">return</span> z<span class="token">)</span>
Right <span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> Prelude<span class="token">.</span>undefined

</code></pre>
<p class="calibre9">跟之前一样，将 undefined 赋值给 z 没什么问题。问题的关键，以及前面的迷惑，都在于惰性求值。准确地说，是在于 return ，它没有强制它的参数的执行；它只是将它包装了一下。这样， try(returnundefined) 的结果应该是 Rightundefined 。现在， ghci 想要将这个结果显示在终端上。它将运行到打印”Right”，但是 undefined 无法打印（或者说除以零的结果无法打印）。因此你看到了异常信息，它是来源于 ghci 的，而不是你的程序。</p>
<p class="calibre9">这是一个关键点。让我们想想为什么之前的例子可以工作，而这个不可以。之前，我们把 printx 放在了 try 里面。打印一些东西的值，固然是需要执行它的，因此，异常在正确的地方被检测到了。但是，仅仅是使用 return 并不会强制计算的执行。为了解决这个问题， Control.Exception 模块中定义了一个 evaluate 函数。它的行为跟 return 类似，但是会让参数立即执行。让我们试一下：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> let z <span class="token3">=</span> undefined
ghci<span class="token3">&gt;</span> result <span class="token3">&lt;</span><span class="token3">-</span> <span class="token1">try</span> <span class="token">(</span>evaluate z<span class="token">)</span>
Left Prelude<span class="token">.</span>undefined
ghci<span class="token3">&gt;</span> result <span class="token3">&lt;</span><span class="token3">-</span> <span class="token1">try</span> <span class="token">(</span>evaluate x<span class="token">)</span>
Left divide by zero

</code></pre>
<p class="calibre9">看，这就是我们想要的答案。无论对于 undefiined 还是除以零的例子，都可以正常工作。</p>
<p class="calibre9">Tip</p>
<p class="calibre9">记住：任何时候你想捕获纯的代码中抛出的异常，在你的异常处理函数中使用 evaluate 而不是 return 。</p>
<h2 class="calibre14"><a id="chp-19.html.handle_403" class="calibre7 pcalibre"></a>使用handle</h2>
<p class="calibre9">通常，你可能希望如果一块代码中没有任何异常发生，就执行某个动作，否则执行不同的动作。对于像这种场合，有一个叫做 handle 的函数。这个函数的类型是 (Exception-&gt;IOa)-&gt;IOa-&gt;IOa 。即是说，它需要两个参数：前一个是一个函数，当执行后一个动作发生异常的时候它会被调用。下面是我们使用的一种方式：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>m Control<span class="token">.</span>Exception
ghci<span class="token3">&gt;</span> let x <span class="token3">=</span> <span class="token2">5</span> `div` <span class="token2">0</span>
ghci<span class="token3">&gt;</span> let y <span class="token3">=</span> <span class="token2">5</span> `div` <span class="token2">1</span>
ghci<span class="token3">&gt;</span> handle <span class="token">(</span>\_ <span class="token3">-</span><span class="token3">&gt;</span> putStrLn <span class="token4">"Error calculating result"</span><span class="token">)</span> <span class="token">(</span>print x<span class="token">)</span>
Error calculating result
ghci<span class="token3">&gt;</span> handle <span class="token">(</span>\_ <span class="token3">-</span><span class="token3">&gt;</span> putStrLn <span class="token4">"Error calculating result"</span><span class="token">)</span> <span class="token">(</span>print y<span class="token">)</span>
<span class="token2">5</span>

</code></pre>
<p class="calibre9">像这样，如果计算中没有错误发生，我们可以打印一条好的信息。这当然要比除以零出错时程序崩溃要好。</p>
<h2 class="calibre14"><a id="chp-19.html._420" class="calibre7 pcalibre"></a>选择性地处理异常</h2>
<p class="calibre9">上面的例子的一个问题是，对于任何异常它都是打印 “Error calculating result”。可能会有些其它不是除零的异常。例如，显示输出时可能会发生错误，或者纯的代码中可能抛出一些其它的异常。</p>
<p class="calibre9">handleJust 函数就是处理这种情况的。它让你指定一个测试来决定是否对给定的异常感兴趣。让我们看一下：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>hj1<span class="token">.</span>hs
import Control<span class="token">.</span>Exception

catchIt <span class="token">:</span><span class="token">:</span> Exception <span class="token3">-</span><span class="token3">&gt;</span> Maybe <span class="token">(</span><span class="token">)</span>
catchIt <span class="token">(</span>ArithException DivideByZero<span class="token">)</span> <span class="token3">=</span> Just <span class="token">(</span><span class="token">)</span>
catchIt _ <span class="token3">=</span> Nothing

handler <span class="token">:</span><span class="token">:</span> <span class="token">(</span><span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
handler _ <span class="token3">=</span> putStrLn <span class="token4">"Caught error: divide by zero"</span>

safePrint <span class="token">:</span><span class="token">:</span> Integer <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
safePrint x <span class="token3">=</span> handleJust catchIt handler <span class="token">(</span>print x<span class="token">)</span>

</code></pre>
<p class="calibre9">cacheIt 定义了一个函数，这个函数会决定我们对给定的异常是否感兴趣。如果是，它会返回 Just ，否则返回 Nothing 。还有， Just 中附带的值会被传到我们的处理函数中。现在我们可以很好地使用 safePrint 了：</p>
<blockquote class="default"><p class="calibre9">ghci&gt; :l hj1.hs[1 of 1] Compiling Main ( hj1.hs, interpreted )Ok, modules loaded: Main.ghci&gt; let x = 5 div 0ghci&gt; let y = 5 div 1ghci&gt; safePrint xCaught error: divide by zeroghci&gt; safePrint y5</p></blockquote>
<p class="calibre9">Control.Exception 模块还提供了一些可以在 handleJust 中使用的函数，以便于我们将异常的范围缩小到我们所关心的类别。例如，有个函数 arithExceptions 类型是 Exception-&gt;MaybeArithException 可以挑选出任意的 ArithException 异常，但是会忽略掉其它。我们可以像这样使用它：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>hj2<span class="token">.</span>hs
import Control<span class="token">.</span>Exception

handler <span class="token">:</span><span class="token">:</span> ArithException <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
handler e <span class="token3">=</span> putStrLn $ <span class="token4">"Caught arithmetic error: "</span> <span class="token3">++</span> show e

safePrint <span class="token">:</span><span class="token">:</span> Integer <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
safePrint x <span class="token3">=</span> handleJust arithExceptions handler <span class="token">(</span>print x<span class="token">)</span>

</code></pre>
<p class="calibre9">用这种方式，我们可以捕获所有 ArithException 类型的异常，但是仍然让其它的异常通过，不捕获也不修改。我们可以看到它是这样工作的：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>l hj2<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> hj2<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>
ghci<span class="token3">&gt;</span> let x <span class="token3">=</span> <span class="token2">5</span> `div` <span class="token2">0</span>
ghci<span class="token3">&gt;</span> let y <span class="token3">=</span> <span class="token2">5</span> `div` <span class="token2">1</span>
ghci<span class="token3">&gt;</span> safePrint x
Caught arithmetic error<span class="token">:</span> divide by zero
ghci<span class="token3">&gt;</span> safePrint y
<span class="token2">5</span>

</code></pre>
<p class="calibre9">其中特别感兴趣的是，你大概注意到了 ioErrors 测试，这是跟一大类的I/O相关的异常。</p>
<h2 class="calibre14"><a id="chp-19.html.IO_477" class="calibre7 pcalibre"></a>I/O异常</h2>
<p class="calibre9">大概在任何程序中异常最大的来源就是I/O。在处理外部世界的时候所有事情都可能出错：磁盘满了，网络断了，或者你期望文件里面有数据而文件却是空的。在Haskell中，I/O异常就跟其它的异常一样可以用 Exception 数据类型来表示。另一方面，由于有这么多类型的I/O异常，有一个特殊的模块– System.IO.Error 专门用于处理它们。</p>
<p class="calibre9">System.IO.Error 定义了两个函数： catch 和 try ，跟 Control.Exception 中的类似，它们都是用于处理异常的。然而，不像 Control.Exception 中的函数，这些函数只会捕获I/O错误，而不处理其它类型异常。在Haskell中，所有I/O错误有一个共同类型 IOError ，它的定义跟 IOException 是一样的。</p>
<p class="calibre9">Tip</p>
<p class="calibre9">当心你使用的哪个名字因为 System.IO.Error 和 Control.Exception 定义了同样名字的函数，如果你将它们都导入你的程序，你将收到一个错误信息说引用的函数有歧义。你可以通过 qualified 引用其中一个或者另一个，或者将其中一个或者另一个的符号隐藏。</p>
<p class="calibre9">注意 Prelude 导出的是 System.IO.Error 中的 catch ，而不是 ControlException 中提供的。记住，前者只捕获I/O错误，而后者捕获所有的异常。换句话说， 你要的几乎总是 Control.Exception 中的那个 catch ，而不是默认的那个。</p>
<p class="calibre9">让我们看一下对我们有益的一个在I/O系统中使用异常的方法。在 <a href="http://rwh.readthedocs.org/en/latest/chp/7.html#handle" target="_blank" class="calibre7 pcalibre">使用文件和句柄</a> [<a href="http://rwh.readthedocs.org/en/latest/chp/7.html#handle" target="_blank" class="calibre7 pcalibre">http://rwh.readthedocs.org/en/latest/chp/7.html#handle</a>] 这一节里，我们展示了一个使用命令式风格从文件中一行一行的读取的程序。尽管我们后面也示范过更简洁的，更”Haskelly”的方式解决那个问题，让我们在这里重新审视这个例子。在 mainloop 函数中，在读一行之前，我们必须明确地测试我们的输入文件是否结束。这次，我们可以检查尝试读一行是否会导致一个EOF错误，像这样子：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>toupper<span class="token3">-</span>impch20<span class="token">.</span>hs
import System<span class="token">.</span>IO
import System<span class="token">.</span>IO<span class="token">.</span>Error
import Data<span class="token">.</span><span class="token5">Char</span><span class="token">(</span>toUpper<span class="token">)</span>

main <span class="token">:</span><span class="token">:</span> IO <span class="token">(</span><span class="token">)</span>
main <span class="token3">=</span> <span class="token1">do</span> 
       inh <span class="token3">&lt;</span><span class="token3">-</span> openFile <span class="token4">"input.txt"</span> ReadMode
       outh <span class="token3">&lt;</span><span class="token3">-</span> openFile <span class="token4">"output.txt"</span> WriteMode
       mainloop inh outh
       hClose inh
       hClose outh

mainloop <span class="token">:</span><span class="token">:</span> Handle <span class="token3">-</span><span class="token3">&gt;</span> Handle <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
mainloop inh outh <span class="token3">=</span> 
    <span class="token1">do</span> input <span class="token3">&lt;</span><span class="token3">-</span> <span class="token1">try</span> <span class="token">(</span>hGetLine inh<span class="token">)</span>
       case input of
         Left e <span class="token3">-</span><span class="token3">&gt;</span> 
             <span class="token1">if</span> isEOFError e
                then <span class="token1">return</span> <span class="token">(</span><span class="token">)</span>
                <span class="token1">else</span> ioError e
         Right inpStr <span class="token3">-</span><span class="token3">&gt;</span>
             <span class="token1">do</span> hPutStrLn outh <span class="token">(</span>map toUpper inpStr<span class="token">)</span>
                mainloop inh outh

</code></pre>
<p class="calibre9">这里，我们使用 System.IO.Error 中的 try 来检测是否 hGetLine 抛出一个 IOError 。如果是，我们使用 isEOFError （在 System.IO.Error 中定义）来看是否抛出异常表明我们到达了文件末尾。如果是的，我们退出循环。如果是其它的异常，我们调用 ioError 重新抛出它。</p>
<p class="calibre9">有许多的这种测试和方法可以从 System.IO.Error 中定义的 IOError 中提取信息。我们推荐你在需要的时候去查一下库的参考页。</p>
<h2 class="calibre14"><a id="chp-19.html._523" class="calibre7 pcalibre"></a>抛出异常</h2>
<p class="calibre9">到现在为止，我们已经详细地讨论了异常处理。还有另外一个困惑：抛出异常。到目前为止这一章我们所接触到的例子中，都是由Haskell为你抛出异常的。然后你也可以自己抛出任何异常。我们会告诉你怎么做。</p>
<p class="calibre9">你将会注意到这些函数大部分似乎返回一个类型为 a 或者 IOa 的值。这意味着这个函数似乎可以返回任意类型的值。事实上，由于这些函数会抛出异常，一般情况下它们决不“返回”任何东西。这些返回值让你可以在各种各样的上下文中使用这些函数，不同的上下文需要不同的类型。</p>
<p class="calibre9">让我们使用函数 Control.Exception 来开始我们的抛出异常的教程。最通用的函数是 throw ，它的类型是 Exception-&gt;a 。这个函数可以抛出任何的 Exception ，并且可以用于纯的上下文中。还有一个类型为 Exception-&gt;IOa 的函数 throwIO 在 IO monad中抛出异常。这两个函数都需要一个 Exception 用于抛出。你可以手工制作一个 Exception ，或者重用之前创建的 Exception 。</p>
<p class="calibre9">还有一个函数 ioError ，它在 Control.Exception 和 System.IO.Error 中定义都是相同的，它的类型是 IOError-&gt;IOa 。当你想生成任意的I/O相关的异常的时候可以使用它。</p>
<h2 class="calibre14"><a id="chp-19.html._533" class="calibre7 pcalibre"></a>动态异常</h2>
<p class="calibre9">这需要使用两个很不常用的Haskell模块: Data.Dynamic 和 Data.Typeable 。我们不会讲太多关于这些模块，但是告诉你当你需要制作自己的动态异常类型时，可以使用这些工具。</p>
<p class="calibre9">在 <a href="#chp-19.html." class="calibre7 pcalibre">第二十一章使用数据库http://book.realworldhaskell.org/read/using-databases.html</a> 中，你会看到HDBC数据库库使用动态异常来表示SQL数据库返回给应用的错误。数据库引擎返回的错误通常有三个组件：一个表示错误码的整数，一个状态，以及一条人类可读的错误消息。在这一章中我们会创建我们自己的HDBC SqlError 实现。让我们从错误自身的数据结构表示开始：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>dynexc<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span># LANGUAGE DeriveDataTypeable #<span class="token3">-</span><span class="token">}</span>

import Data<span class="token">.</span>Dynamic
import Control<span class="token">.</span>Exception

data SqlError <span class="token3">=</span> SqlError <span class="token">{</span>seState <span class="token">:</span><span class="token">:</span> String<span class="token">,</span>
                          seNativeError <span class="token">:</span><span class="token">:</span> Int<span class="token">,</span>
                          seErrorMsg <span class="token">:</span><span class="token">:</span> String<span class="token">}</span>
                deriving <span class="token">(</span>Eq<span class="token">,</span> Show<span class="token">,</span> Read<span class="token">,</span> Typeable<span class="token">)</span>

</code></pre>
<p class="calibre9">通过继承 Typeable 类型类，我们使这个类型可用于动态的类型编程。为了让GHC自动生成一个 Typeable 实例，我们要开启 DeriveDataTypeable 语言扩展。</p>
<p class="calibre9">现在，让我们定义一个 catchSql 和一个 handleSql 用于捕猎一个 SqlError 异常。注意常规的 catch 和 handle 函数无法捕猎我们的 SqlError ，因为它不是 Exception 类型的。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>dynexc<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Execute the given IO action<span class="token">.</span>

If it raises a <span class="token4">'SqlError'</span><span class="token">,</span> then execute the supplied 
handler and <span class="token1">return</span> its <span class="token1">return</span> value<span class="token">.</span>  Otherwise<span class="token">,</span> proceed
as normal<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
catchSql <span class="token">:</span><span class="token">:</span> IO a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>SqlError <span class="token3">-</span><span class="token3">&gt;</span> IO a<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> IO a
catchSql <span class="token3">=</span> catchDyn

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Like <span class="token4">'catchSql'</span><span class="token">,</span> with the order of arguments reversed<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
handleSql <span class="token">:</span><span class="token">:</span> <span class="token">(</span>SqlError <span class="token3">-</span><span class="token3">&gt;</span> IO a<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> IO a <span class="token3">-</span><span class="token3">&gt;</span> IO a
handleSql <span class="token3">=</span> flip catchSql

</code></pre>
<p class="calibre9">[译注：原文中文件名是dynexc.hs，但是跟前面的冲突了，所以这里重命名为dynexc1.hs]</p>
<p class="calibre9">这些函数仅仅是在 catchDyn 外面包了很薄的一层，类型是 Typeableexception=&gt;IOa-&gt;(exception-&gt;IOa)-&gt;IOa 。这里我们简单地限定了它的类型使得它只捕猎SQL异常。</p>
<p class="calibre9">正常地，当一个异常抛出，但是没有在任何地方被捕获，程序会崩溃并显示异常到标准错误输出。然而，对于动态异常，系统不会知道该如何显示它，因此你将仅仅会看到一个的”unknown exception”消息，这可能没太大帮助。我们可以提供一个辅助函数，这样应用可以写成，比如说 main=handleSqlError$do... ，使抛出的异常可以显示。下面是如何写 handleSqlError ：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>dynexc<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Catches <span class="token4">'SqlError'</span>s<span class="token">,</span> and re<span class="token3">-</span>raises them as IO errors with fail<span class="token">.</span>
Useful <span class="token1">if</span> you don't care to <span class="token1">catch</span> SQL errors<span class="token">,</span> but want to see a sane
error message <span class="token1">if</span> one happens<span class="token">.</span>  One would often use this as a 
high<span class="token3">-</span>level wrapper around SQL calls<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
handleSqlError <span class="token">:</span><span class="token">:</span> IO a <span class="token3">-</span><span class="token3">&gt;</span> IO a
handleSqlError action <span class="token3">=</span>
    catchSql action handler
    where handler e <span class="token3">=</span> fail <span class="token">(</span><span class="token4">"SQL error: "</span> <span class="token3">++</span> show e<span class="token">)</span>

</code></pre>
<p class="calibre9">[译注：原文中是dynexc.hs，这里重命名过文件]</p>
<p class="calibre9">最后，让我们给出一个如何抛出 SqlError 异常的例子。下面的函数做的就是这件事：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>dynexc<span class="token">.</span>hs
throwSqlError <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> Int <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> a
throwSqlError state nativeerror errormsg <span class="token3">=</span>
    throwDyn <span class="token">(</span>SqlError state nativeerror errormsg<span class="token">)</span>

throwSqlErrorIO <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> Int <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> IO a
throwSqlErrorIO state nativeerror errormsg <span class="token3">=</span>
    evaluate <span class="token">(</span>throwSqlError state nativeerror errormsg<span class="token">)</span>

</code></pre>
<p class="calibre9">Tip</p>
<p class="calibre9">提醒一下， evaluate 跟 return 类似但是会立即计算它的参数。</p>
<p class="calibre9">这样我们的动态异常的支持就完成了。代码很多，你大概不需要这么多代码，但是我们想要给你一个动态异常自身的例子以及和它相关的工具。事实上，这里的例子几乎就反映在HDBC库中。让我们在 ghci 中试一下：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>l dynexc<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> dynexc<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>
ghci<span class="token3">&gt;</span> throwSqlErrorIO <span class="token4">"state"</span> <span class="token2">5</span> <span class="token4">"error message"</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> <span class="token">(</span>unknown<span class="token">)</span>
ghci<span class="token3">&gt;</span> handleSqlError $ throwSqlErrorIO <span class="token4">"state"</span> <span class="token2">5</span> <span class="token4">"error message"</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> user error <span class="token">(</span>SQL error<span class="token">:</span> SqlError <span class="token">{</span>seState <span class="token3">=</span> <span class="token4">"state"</span><span class="token">,</span> seNativeError <span class="token3">=</span> <span class="token2">5</span><span class="token">,</span> seErrorMsg <span class="token3">=</span> <span class="token4">"error message"</span><span class="token">}</span><span class="token">)</span>
ghci<span class="token3">&gt;</span> handleSqlError $ fail <span class="token4">"other error"</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> user error <span class="token">(</span>other error<span class="token">)</span>

</code></pre>
<p class="calibre9">这里你可以看出， ghci 自己并不知道如何显示SQL错误。但是，你可以看到 handleSqlError 帮助做了这些，不过没有捕获其它的错误。最后让我们试一个自定义的handler：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> handleSql <span class="token">(</span>fail <span class="token">.</span> seErrorMsg<span class="token">)</span> <span class="token">(</span>throwSqlErrorIO <span class="token4">"state"</span> <span class="token2">5</span> <span class="token4">"my error"</span><span class="token">)</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> user error <span class="token">(</span>my error<span class="token">)</span>

</code></pre>
<p class="calibre9">这里，我们自定义了一个错误处理抛出一个新的异常，构成 SqlError 中的 seErrorMsg 域。你可以看到它是按预想中那样工作的。</p>
<h2 class="calibre14"><a id="chp-19.html._637" class="calibre7 pcalibre"></a>练习</h2>
<ol class="calibre17"><li class="calibre11">将 Either 修改成 Maybe 例子中的那种风格，使它保存惰性。</li></ol>
<h2 class="calibre14"><a id="chp-19.html.monad_641" class="calibre7 pcalibre"></a>monad中的错误处理</h2>
<p class="calibre9">因为我们必须捕获 IO monad中的异常，如果我们在一个monad中或者在monad的转化栈中使用它们，我们将跳出到 IO monad。这几乎肯定不是我们想要的。</p>
<p class="calibre9">在 <a href="http://rwh.readthedocs.org/en/latest/chp/18.html#id9" target="_blank" class="calibre7 pcalibre">构建以理解Monad变换器</a> [<a href="http://rwh.readthedocs.org/en/latest/chp/18.html#id9" target="_blank" class="calibre7 pcalibre">http://rwh.readthedocs.org/en/latest/chp/18.html#id9</a>] 中我们定义了一个 MaybeT 的变换，但是它更像是一个有助于理解的东西，而不是编程的工具。幸运的是，已经有一个专门的–也更有用的–monad变换： ErrorT ，它是定义在 Control.Monad.Error 模块中的。</p>
<p class="calibre9">ErrorT 变换器使我们可以向monad中添加异常，但是它使用了特殊的方法，跟 Control.Exception 模块中提供的不一样。它提供给我们一些有趣的能力。</p>
<ul class="calibre10"><li class="calibre11">如果我们继续用 ErrorT 接口，在这个monad中我们可以抛出和捕获异常。</li><li class="calibre11">根据其它monad变换器的命名规范，这个执行函数的名字是 runErrorT 。当它遇到 runErrorT 之后，未被捕获的 ErrorT 异常将停止向上传递。我们不会被踢到 IO monad中。</li><li class="calibre11">我们可以控制我们的异常的类型。</li></ul>
<p class="calibre9">Warning</p>
<p class="calibre9">不要把ErrorT跟普通异常混淆如果我们在 ErrorT 内面使用 Control.Exception 中的 throw 函数，我们仍然会弹出到 IO monad。</p>
<p class="calibre9">正如其它的 mtl monad一样， ErrorT 提供的接口是由一个类型类定义的。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>MonadError<span class="token">.</span>hs
class <span class="token">(</span>Monad m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> MonadError e m <span class="token3">|</span> m <span class="token3">-</span><span class="token3">&gt;</span> e where
    throwError <span class="token">:</span><span class="token">:</span> e             <span class="token3">--</span> error to <span class="token1">throw</span>
               <span class="token3">-</span><span class="token3">&gt;</span> m a

    catchError <span class="token">:</span><span class="token">:</span> m a           <span class="token3">--</span> action to execute
               <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>e <span class="token3">-</span><span class="token3">&gt;</span> m a<span class="token">)</span>    <span class="token3">--</span> error handler
               <span class="token3">-</span><span class="token3">&gt;</span> m a

</code></pre>
<p class="calibre9">类型变量 e 代表我们想要使用的错误类型。不管我们的错误类型是什么，我们必须将它做成 Error 类型类的实例。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>MonadError<span class="token">.</span>hs
class <span class="token5">Error</span> a where
    <span class="token3">--</span> create an exception with no message
    noMsg  <span class="token">:</span><span class="token">:</span> a

    <span class="token3">--</span> create an exception with a message
    strMsg <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> a

</code></pre>
<p class="calibre9">ErrorT 实现 fail 时会用到 strMsg 函数。它将 strMsg 作为一个异常抛出，将自己接收到的字符串参数传递给这个异常。对于 noMsg ，它是用于提供 MonadPlus 类型类中的 mzero 的实现。</p>
<p class="calibre9">为了支持 strMsg 和 noMsg 函数，我们的 ParseError 类型会有一个 Chatty 构造器。这个将用作构造器如果，比如说，有人在我们的monad中调用 fail 。</p>
<p class="calibre9">我们需要知道的最后一块是关于执行函数 runErrorT 的类型。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>t runErrorT
runErrorT <span class="token">:</span><span class="token">:</span> ErrorT e m a <span class="token3">-</span><span class="token3">&gt;</span> m <span class="token">(</span>Either e a<span class="token">)</span>

</code></pre>
<h2 class="calibre14"><a id="chp-19.html._696" class="calibre7 pcalibre"></a>一个小的解析构架</h2>
<p class="calibre9">为了说明 ErrorT 的使用，让我们开发一个类似于Parsec的解析库的基本的骨架。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>ParseInt<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span># LANGUAGE GeneralizedNewtypeDeriving #<span class="token3">-</span><span class="token">}</span>

import Control<span class="token">.</span>Monad<span class="token">.</span>Error
import Control<span class="token">.</span>Monad<span class="token">.</span>State
import qualified Data<span class="token">.</span>ByteString<span class="token">.</span>Char8 as B

data ParseError <span class="token3">=</span> NumericOverflow
            <span class="token3">|</span> EndOfInput
            <span class="token3">|</span> Chatty String
              deriving <span class="token">(</span>Eq<span class="token">,</span> Ord<span class="token">,</span> Show<span class="token">)</span>

instance Error ParseError where
    noMsg  <span class="token3">=</span> Chatty <span class="token4">"oh noes!"</span>
    strMsg <span class="token3">=</span> Chatty

</code></pre>
<p class="calibre9">对于我们解析器的状态，我们会创建一个非常小的monad变换器栈。一个 State monad包含了需要解析的 ByteString ，在栈的顶部是 ErrorT 用于提供错误处理。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>ParseInt<span class="token">.</span>hs
newtype Parser a <span class="token3">=</span> P <span class="token">{</span>
      runP <span class="token">:</span><span class="token">:</span> ErrorT ParseError <span class="token">(</span>State B<span class="token">.</span>ByteString<span class="token">)</span> a
    <span class="token">}</span> deriving <span class="token">(</span>Monad<span class="token">,</span> MonadError ParseError<span class="token">)</span>

</code></pre>
<p class="calibre9">和平常一样，我们将我们的monad栈包装在一个 newtype 中。这样做没有任意性能损耗，但是增加了类型安全。我们故意避免继承 MonadStateB.ByteString 的实例。这意味着 Parser monad用户将不能够使用 get 或者 put 去查询或者修改解析器的状态。这样的结果是，我们强制自己去做一些手动提升的事情来获取在我们栈中的 State monad。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>ParseInt<span class="token">.</span>hs
liftP <span class="token">:</span><span class="token">:</span> State B<span class="token">.</span>ByteString a <span class="token3">-</span><span class="token3">&gt;</span> Parser a
liftP m <span class="token3">=</span> P <span class="token">(</span>lift m<span class="token">)</span>

satisfy <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Char <span class="token3">-</span><span class="token3">&gt;</span> Bool<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> Parser Char
satisfy p <span class="token3">=</span> <span class="token1">do</span>
  s <span class="token3">&lt;</span><span class="token3">-</span> liftP get
  case B<span class="token">.</span>uncons s of
    Nothing         <span class="token3">-</span><span class="token3">&gt;</span> throwError EndOfInput
    Just <span class="token">(</span>c<span class="token">,</span> s'<span class="token">)</span>
        <span class="token3">|</span> p c       <span class="token3">-</span><span class="token3">&gt;</span> liftP <span class="token">(</span>put s'<span class="token">)</span> <span class="token3">&gt;</span><span class="token3">&gt;</span> <span class="token1">return</span> c
        <span class="token3">|</span> otherwise <span class="token3">-</span><span class="token3">&gt;</span> throwError <span class="token">(</span>Chatty <span class="token4">"satisfy failed"</span><span class="token">)</span>

</code></pre>
<p class="calibre9">catchError 函数对于我们的任何非常有用，远胜于简单的错误处理。例如，我们可以很轻松地解除一个异常，将它变成更友好的形式。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>ParseInt<span class="token">.</span>hs
optional <span class="token">:</span><span class="token">:</span> Parser a <span class="token3">-</span><span class="token3">&gt;</span> Parser <span class="token">(</span>Maybe a<span class="token">)</span>
optional p <span class="token3">=</span> <span class="token">(</span>Just `liftM` p<span class="token">)</span> `catchError` \_ <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> Nothing

</code></pre>
<p class="calibre9">我们的执行函数仅仅是将各层连接起来，将结果重新组织成更整洁的形式。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch19<span class="token3">/</span>ParseInt<span class="token">.</span>hs
runParser <span class="token">:</span><span class="token">:</span> Parser a <span class="token3">-</span><span class="token3">&gt;</span> B<span class="token">.</span>ByteString
          <span class="token3">-</span><span class="token3">&gt;</span> Either ParseError <span class="token">(</span>a<span class="token">,</span> B<span class="token">.</span>ByteString<span class="token">)</span>
runParser p bs <span class="token3">=</span> case runState <span class="token">(</span>runErrorT <span class="token">(</span>runP p<span class="token">)</span><span class="token">)</span> bs of
                   <span class="token">(</span>Left err<span class="token">,</span> _<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> Left err
                   <span class="token">(</span>Right r<span class="token">,</span> bs<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> Right <span class="token">(</span>r<span class="token">,</span> bs<span class="token">)</span>

</code></pre>
<p class="calibre9">如果我们将它加载到 ghci 中，我们可以对它进行了一些测试。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>m <span class="token3">+</span>Data<span class="token">.</span>Char
ghci<span class="token3">&gt;</span> let p <span class="token3">=</span> satisfy isDigit
Loading package array<span class="token3">-</span><span class="token2">0.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package bytestring<span class="token3">-</span><span class="token2">0.9</span><span class="token2">.0</span><span class="token2">.1</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package mtl<span class="token3">-</span><span class="token2">1.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
ghci<span class="token3">&gt;</span> runParser p <span class="token">(</span>B<span class="token">.</span>pack <span class="token4">"x"</span><span class="token">)</span>
Left <span class="token">(</span>Chatty <span class="token4">"satisfy failed"</span><span class="token">)</span>
ghci<span class="token3">&gt;</span> runParser p <span class="token">(</span>B<span class="token">.</span>pack <span class="token4">"9abc"</span><span class="token">)</span>
Right <span class="token">(</span><span class="token4">'9'</span><span class="token">,</span><span class="token4">"abc"</span><span class="token">)</span>
ghci<span class="token3">&gt;</span> runParser <span class="token">(</span>optional p<span class="token">)</span> <span class="token">(</span>B<span class="token">.</span>pack <span class="token4">"x"</span><span class="token">)</span>
Right <span class="token">(</span>Nothing<span class="token">,</span><span class="token4">"x"</span><span class="token">)</span>
ghci<span class="token3">&gt;</span> runParser <span class="token">(</span>optional p<span class="token">)</span> <span class="token">(</span>B<span class="token">.</span>pack <span class="token4">"9a"</span><span class="token">)</span>
Right <span class="token">(</span>Just <span class="token4">'9'</span><span class="token">,</span><span class="token4">"a"</span><span class="token">)</span>

</code></pre>
<h2 class="calibre14"><a id="chp-19.html._787" class="calibre7 pcalibre"></a>级习</h2>
<ol class="calibre17"><li class="calibre11">写一个 many 解析器，类型是 Parsera-&gt;Parser[a] 。它应该执行解析直到失败。</li><li class="calibre11">使用 many 写一个 int 解析器，类型是 ParserInt 。它应该既能接受负数也能接受正数。</li><li class="calibre11">修改你们 int 解析器，如果在解析时检测到了一个数值溢出，抛出一个 NumericOverflow 异常。</li></ol>
<p class="calibre9">注</p>
<table class="calibre21"><thead class="calibre22"><tr class="calibre23"><th class="calibre24">[38]</th><th class="calibre24">这里我们使用的是整数的除法，因此 50 / 8 显示是 6 而不是 6.25 。在这个例子中我们没有使用浮点算术是因为对一个 Double 除以零会返回一个特殊的 Infinity 而不是一个错误。</th></tr></thead><tbody class="calibre25"></tbody></table>
<table class="calibre21"><thead class="calibre22"><tr class="calibre23"><th class="calibre24">[39]</th><th class="calibre24">关于 Maybe 的介绍，参考<code class="calibre16">&lt;让过程更可控的方法 [http://rwh.readthedocs.org/en/latest/chp/3.html#id21](http://rwh.readthedocs.org/en/latest/chp/3.html#id21)&gt;</code>_</th></tr></thead><tbody class="calibre25"></tbody></table>
<table class="calibre21"><thead class="calibre22"><tr class="calibre23"><th class="calibre24">[40]</th><th class="calibre24">更多关于 Either 的信息，参考<code class="calibre16">&lt;通过 API 设计进行错误处理 [http://rwh.readthedocs.org/en/latest/chp/8.html#api](http://rwh.readthedocs.org/en/latest/chp/8.html#api)&gt;</code>_</th></tr></thead><tbody class="calibre25"></tbody></table>
<table class="calibre21"><thead class="calibre22"><tr class="calibre23"><th class="calibre24">[41]</th><th class="calibre24">在一些其它语言中，抛出异常是叫做 raising 。</th></tr></thead><tbody class="calibre25"></tbody></table>
<table class="calibre26"><thead class="calibre22"><tr class="calibre23"><th class="calibre24">[42]</th><th class="calibre24">可以手动继承 Typeable 实例，但是那样很麻烦。</th></tr></thead><tbody class="calibre25"></tbody></table>
</div></div></div></div></div></div>
<div id="chp-20.html"><div class="calibre">
<div id="chp-20.html.main" class="calibre1"><div class="root"><div class="article"><h1 class="article-head" id="chp-20.html.calibre_toc_15">第二十章：使用 Haskell 进行系统编程</h1><div class="article-body"><h1 class="calibre6"><a id="chp-20.html._Haskell__0" class="calibre7 pcalibre"></a>第二十章：使用 Haskell 进行系统编程</h1>
<p class="calibre9">目前为止，我们讨论的大多数是高阶概念。 Haskell 也可以用于底层系统编程。完全可以使用 Haskell 编写使用操作系统底层接口的程序。</p>
<p class="calibre9">本章中，我们将尝试一些很有野心的东西：编写一种类似 Perl 实际上是合法的 Haskell 的“语言”，完全使用 Haskell 实现，用于简化编写 shell 脚本。我们将实现管道，简单命令调用，和一些简单的工具用于执行由 grep 和 sed 处理的任务。</p>
<p class="calibre9">有些模块是依赖操作系统的。本章中，我们将尽可能使用不依赖特殊操作系统的通用模块。不过，本章将有很多内容着眼于 POSIX 环境。 POSIX 是一种类 Unix 标准， 如 Linux ，FreeBSD ，MacOS X ，或 Solaris 。Windows 默认情况下不支持 POSIX ，但是 Cygwin 环境为 Windows 提供了 POSIX 兼容层。</p>
<h2 class="calibre14"><a id="chp-20.html._8" class="calibre7 pcalibre"></a>调用外部程序</h2>
<p class="calibre9">Haskell 可以调用外部命令。为了这么做，我们建议使用 System.Cmd 模块中的 rawSystem 。其用特定的参数调用特定的程序，并将返回程序的退出状态码。你可以在 ghci 中练习一下。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>module System<span class="token">.</span>Cmd
ghci<span class="token3">&gt;</span> rawSystem <span class="token4">"ls"</span> <span class="token">[</span><span class="token4">"-l"</span><span class="token">,</span> <span class="token4">"/usr"</span><span class="token">]</span>
Loading package old<span class="token3">-</span>locale<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package old<span class="token3">-</span>time<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package filepath<span class="token3">-</span><span class="token2">1.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package directory<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package unix<span class="token3">-</span><span class="token2">2.3</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package process<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
total <span class="token2">124</span>
drwxr<span class="token3">-</span>xr<span class="token3">-</span>x   <span class="token2">2</span> root root  <span class="token2">49152</span> <span class="token2">2008</span><span class="token3">-</span><span class="token2">08</span><span class="token3">-</span><span class="token2">18</span> <span class="token2">11</span><span class="token">:</span><span class="token2">04</span> bin
drwxr<span class="token3">-</span>xr<span class="token3">-</span>x   <span class="token2">2</span> root root   <span class="token2">4096</span> <span class="token2">2008</span><span class="token3">-</span><span class="token2">03</span><span class="token3">-</span><span class="token2">09</span> <span class="token2">05</span><span class="token">:</span><span class="token2">53</span> games
drwxr<span class="token3">-</span>sr<span class="token3">-</span>x  <span class="token2">10</span> jimb guile  <span class="token2">4096</span> <span class="token2">2006</span><span class="token3">-</span><span class="token2">02</span><span class="token3">-</span><span class="token2">04</span> <span class="token2">09</span><span class="token">:</span><span class="token2">13</span> guile
drwxr<span class="token3">-</span>xr<span class="token3">-</span>x  <span class="token2">47</span> root root   <span class="token2">8192</span> <span class="token2">2008</span><span class="token3">-</span><span class="token2">08</span><span class="token3">-</span><span class="token2">08</span> <span class="token2">08</span><span class="token">:</span><span class="token2">18</span> include
drwxr<span class="token3">-</span>xr<span class="token3">-</span>x <span class="token2">107</span> root root  <span class="token2">32768</span> <span class="token2">2008</span><span class="token3">-</span><span class="token2">08</span><span class="token3">-</span><span class="token2">18</span> <span class="token2">11</span><span class="token">:</span><span class="token2">04</span> lib
lrwxrwxrwx   <span class="token2">1</span> root root      <span class="token2">3</span> <span class="token2">2007</span><span class="token3">-</span><span class="token2">09</span><span class="token3">-</span><span class="token2">24</span> <span class="token2">16</span><span class="token">:</span><span class="token2">55</span> lib64 <span class="token3">-</span><span class="token3">&gt;</span> lib
drwxrwsr<span class="token3">-</span>x  <span class="token2">17</span> root staff  <span class="token2">4096</span> <span class="token2">2008</span><span class="token3">-</span><span class="token2">06</span><span class="token3">-</span><span class="token2">24</span> <span class="token2">17</span><span class="token">:</span><span class="token2">35</span> local
drwxr<span class="token3">-</span>xr<span class="token3">-</span>x   <span class="token2">2</span> root root   <span class="token2">8192</span> <span class="token2">2008</span><span class="token3">-</span><span class="token2">08</span><span class="token3">-</span><span class="token2">18</span> <span class="token2">11</span><span class="token">:</span><span class="token2">03</span> sbin
drwxr<span class="token3">-</span>xr<span class="token3">-</span>x <span class="token2">181</span> root root   <span class="token2">8192</span> <span class="token2">2008</span><span class="token3">-</span><span class="token2">08</span><span class="token3">-</span><span class="token2">12</span> <span class="token2">10</span><span class="token">:</span><span class="token2">11</span> share
drwxrwsr<span class="token3">-</span>x   <span class="token2">2</span> root src    <span class="token2">4096</span> <span class="token2">2007</span><span class="token3">-</span><span class="token2">04</span><span class="token3">-</span><span class="token2">10</span> <span class="token2">16</span><span class="token">:</span><span class="token2">28</span> src
drwxr<span class="token3">-</span>xr<span class="token3">-</span>x   <span class="token2">3</span> root root   <span class="token2">4096</span> <span class="token2">2008</span><span class="token3">-</span><span class="token2">07</span><span class="token3">-</span><span class="token2">04</span> <span class="token2">19</span><span class="token">:</span><span class="token2">03</span> X11R6
ExitSuccess

</code></pre>
<p class="calibre9">此处，我们相当于执行了 shell 命令 ls-l/usr 。 rawSystem 并不从字符串解析输入参数或是扩展通配符 <a href="#chp-20.html." class="calibre7 pcalibre">[43]</a> 。取而代之，其接受一个包含所有参数的列表。如果不想提供参数，可以像这样简单地输入一个空列表。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> rawSystem <span class="token4">"ls"</span> <span class="token">[</span><span class="token">]</span>
calendartime<span class="token">.</span>ghci  modtime<span class="token">.</span>ghci    rp<span class="token">.</span>ghci    RunProcessSimple<span class="token">.</span>hs
cmd<span class="token">.</span>ghci       posixtime<span class="token">.</span>hs    rps<span class="token">.</span>ghci   timediff<span class="token">.</span>ghci
dir<span class="token">.</span>ghci       rawSystem<span class="token">.</span>ghci  RunProcess<span class="token">.</span>hs  time<span class="token">.</span>ghci
ExitSuccess

</code></pre>
<h2 class="calibre14"><a id="chp-20.html._48" class="calibre7 pcalibre"></a>目录和文件信息</h2>
<p class="calibre9">System.Directory 模块包含了相当多可以从文件系统获取信息的函数。你可以获取某目录包含的文件列表，重命名或删除文件，复制文件，改变当前工作路径，或者建立新目录。 System.Directory 是可移植的，在可以跑 GHC 的平台都可以使用。</p>
<p class="calibre9"><a href="http://hackage.haskell.org/package/directory-1.0.0.0/docs/System-Directory.html" target="_blank" class="calibre7 pcalibre">System.Directory 的库文档</a> [<a href="http://hackage.haskell.org/package/directory-1.0.0.0/docs/System-Directory.html" target="_blank" class="calibre7 pcalibre">http://hackage.haskell.org/package/directory-1.0.0.0/docs/System-Directory.html</a>] 中含有一份详尽的函数列表。让我们通过 ghci 来对其中一些进行演示。这些函数大多数简单的等价于其对应的 C 语言库函数或 shell 命令。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>module System<span class="token">.</span>Directory
ghci<span class="token3">&gt;</span> setCurrentDirectory <span class="token4">"/etc"</span>
Loading package old<span class="token3">-</span>locale<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package old<span class="token3">-</span>time<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package filepath<span class="token3">-</span><span class="token2">1.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package directory<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
ghci<span class="token3">&gt;</span> getCurrentDirectory
<span class="token4">"/etc"</span>
ghci<span class="token3">&gt;</span> setCurrentDirectory <span class="token4">".."</span>
ghci<span class="token3">&gt;</span> getCurrentDirectory
<span class="token4">"/"</span>

</code></pre>
<p class="calibre9">此处我们看到了改变工作目录和获取当前工作目录的命令。它们类似 POSIX shell 中的 cd 和 pwd 命令。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> getDirectoryContents <span class="token4">"/"</span>
<span class="token">[</span><span class="token4">"."</span><span class="token">,</span><span class="token4">".."</span><span class="token">,</span><span class="token4">"lost+found"</span><span class="token">,</span><span class="token4">"boot"</span><span class="token">,</span><span class="token4">"etc"</span><span class="token">,</span><span class="token4">"media"</span><span class="token">,</span><span class="token4">"initrd.img"</span><span class="token">,</span><span class="token4">"var"</span><span class="token">,</span><span class="token4">"usr"</span><span class="token">,</span><span class="token4">"bin"</span><span class="token">,</span><span class="token4">"dev"</span><span class="token">,</span><span class="token4">"home"</span><span class="token">,</span><span class="token4">"lib"</span><span class="token">,</span><span class="token4">"mnt"</span><span class="token">,</span><span class="token4">"proc"</span><span class="token">,</span><span class="token4">"root"</span><span class="token">,</span><span class="token4">"sbin"</span><span class="token">,</span><span class="token4">"tmp"</span><span class="token">,</span><span class="token4">"sys"</span><span class="token">,</span><span class="token4">"lib64"</span><span class="token">,</span><span class="token4">"srv"</span><span class="token">,</span><span class="token4">"opt"</span><span class="token">,</span><span class="token4">"initrd"</span><span class="token">,</span><span class="token4">"vmlinuz"</span><span class="token">,</span><span class="token4">".rnd"</span><span class="token">,</span><span class="token4">"www"</span><span class="token">,</span><span class="token4">"ultra60"</span><span class="token">,</span><span class="token4">"emul"</span><span class="token">,</span><span class="token4">".fonts.cache-1"</span><span class="token">,</span><span class="token4">"selinux"</span><span class="token">,</span><span class="token4">"razor-agent.log"</span><span class="token">,</span><span class="token4">".svn"</span><span class="token">,</span><span class="token4">"initrd.img.old"</span><span class="token">,</span><span class="token4">"vmlinuz.old"</span><span class="token">,</span><span class="token4">"ugid-survey.bulkdata"</span><span class="token">,</span><span class="token4">"ugid-survey.brief"</span><span class="token">]</span>

</code></pre>
<p class="calibre9">getDirectoryContents 返回一个列表，包含给定目录的所有内容。注意，在 POSIX 系统中，这个列表通常包含特殊值 ”.” 和 ”..” 。通常在处理目录内容时，你可能会希望将他们过滤出去，像这样：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> getDirectoryContents <span class="token4">"/"</span> <span class="token3">&gt;</span><span class="token3">&gt;=</span> <span class="token1">return</span> <span class="token">.</span> filter <span class="token">(</span>`notElem` <span class="token">[</span><span class="token4">"."</span><span class="token">,</span> <span class="token4">".."</span><span class="token">]</span><span class="token">)</span>
<span class="token">[</span><span class="token4">"lost+found"</span><span class="token">,</span><span class="token4">"boot"</span><span class="token">,</span><span class="token4">"etc"</span><span class="token">,</span><span class="token4">"media"</span><span class="token">,</span><span class="token4">"initrd.img"</span><span class="token">,</span><span class="token4">"var"</span><span class="token">,</span><span class="token4">"usr"</span><span class="token">,</span><span class="token4">"bin"</span><span class="token">,</span><span class="token4">"dev"</span><span class="token">,</span><span class="token4">"home"</span><span class="token">,</span><span class="token4">"lib"</span><span class="token">,</span><span class="token4">"mnt"</span><span class="token">,</span><span class="token4">"proc"</span><span class="token">,</span><span class="token4">"root"</span><span class="token">,</span><span class="token4">"sbin"</span><span class="token">,</span><span class="token4">"tmp"</span><span class="token">,</span><span class="token4">"sys"</span><span class="token">,</span><span class="token4">"lib64"</span><span class="token">,</span><span class="token4">"srv"</span><span class="token">,</span><span class="token4">"opt"</span><span class="token">,</span><span class="token4">"initrd"</span><span class="token">,</span><span class="token4">"vmlinuz"</span><span class="token">,</span><span class="token4">".rnd"</span><span class="token">,</span><span class="token4">"www"</span><span class="token">,</span><span class="token4">"ultra60"</span><span class="token">,</span><span class="token4">"emul"</span><span class="token">,</span><span class="token4">".fonts.cache-1"</span><span class="token">,</span><span class="token4">"selinux"</span><span class="token">,</span><span class="token4">"razor-agent.log"</span><span class="token">,</span><span class="token4">".svn"</span><span class="token">,</span><span class="token4">"initrd.img.old"</span><span class="token">,</span><span class="token4">"vmlinuz.old"</span><span class="token">,</span><span class="token4">"ugid-survey.bulkdata"</span><span class="token">,</span><span class="token4">"ugid-survey.brief"</span><span class="token">]</span>

</code></pre>
<p class="calibre9">Tip</p>
<p class="calibre9">更细致的讨论如何过滤 getDirectoryContents 函数的结果，请参考 <a href="#chp-20.html." class="calibre7 pcalibre"><em class="calibre13">第八章：高效文件处理、正则表达式、文件名匹配</em></a></p>
<p class="calibre9">filter(<code class="calibre16">notElem</code>[".",".."]) 这段代码是否有点莫名其妙？也可以写作 filter(c-&gt;not$elemc[".",".."]) 。反引号让我们更有效的将第二个参数传给 notElem ；在 “中序函数” 一节中有关于反引号更详细的信息。</p>
<p class="calibre9">也可以向系统查询某些路径的位置。这将向底层操作系统发起查询相关信息。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> getHomeDirectory
<span class="token4">"/home/bos"</span>
ghci<span class="token3">&gt;</span> getAppUserDataDirectory <span class="token4">"myApp"</span>
<span class="token4">"/home/bos/.myApp"</span>
ghci<span class="token3">&gt;</span> getUserDocumentsDirectory
<span class="token4">"/home/bos"</span>

</code></pre>
<h2 class="calibre14"><a id="chp-20.html._103" class="calibre7 pcalibre"></a>终止程序</h2>
<p class="calibre9">开发者经常编写独立的程序以完成特定任务。这些独立的部分可能会被组合起来完成更大的任务。一段 shell 脚本或者其他程序将会执行它们。发起调用的脚本需要获知被调用程序是否执行成功。 Haskell 自动为异常退出的程序分配一个 “不成功” 的状态码。</p>
<p class="calibre9">不过，你需要对状态码进行更细粒度的控制。可能你需要对不同类型的错误返回不同的代码。 System.Exit 模块提供一个途径可以在程序退出时返回特定的状态码。通过调用 exitWithExitSuccess 表示程序执行成功（POSIX 系统中的 0）。或者可以调用 exitWith(ExitFailure5) ，表示将在程序退出时向系统返回 5 作为状态码。</p>
<h2 class="calibre14"><a id="chp-20.html._109" class="calibre7 pcalibre"></a>日期和时间</h2>
<p class="calibre9">从文件时间戳到商业事务的很多事情都涉及到日期和时间。 除了从系统获取日期时间信息之外，Haskell 提供了很多关于时间日期的操作方法。</p>
<h2 class="calibre14"><a id="chp-20.html.ClockTime__CalendarTime_113" class="calibre7 pcalibre"></a>ClockTime 和 CalendarTime</h2>
<p class="calibre9">在 Haskell 中，日期和时间主要由 System.Time 模块处理。它定义了两个类型： ClockTime 和 CalendarTime 。</p>
<p class="calibre9">ClockTime 是传统 POSIX 中时间戳的 Haskell 版本。 ClockTime 表示一个相对于 UTC 1970 年 1 月 1 日 零点的时间。负值的 ClockTime 表示在其之前的秒数，正值表示在其之后的秒数。</p>
<p class="calibre9">ClockTime 便于计算。因为它遵循协调世界时（Coordinated Universal Time，UTC），其不必调整本地时区、夏令时或其他时间处理中的特例。每天是精确的 (60 * 60 * 24) 或 86,400 秒 <a href="#chp-20.html." class="calibre7 pcalibre">[44]</a>，这易于计算时间间隔。举个例子，你可以简单的记录某个程序开始执行的时间和其结束的时间，相减即可确定程序的执行时间。如果需要的话，还可以除以 3600，这样就可以按小时显示。</p>
<p class="calibre9">使用 ClockTime 的典型场景：</p>
<blockquote class="default"></blockquote>
<blockquote class="default"><ul class="calibre30"><li class="calibre11">经过了多长时间？</li><li class="calibre11">相对此刻 14 天前是什么时间？</li><li class="calibre11">文件的最后修改时间是何时？</li><li class="calibre11">当下的精确时间是何时？</li></ul></blockquote>
<p class="calibre9">ClockTime 善于处理这些问题，因为它们使用无法混淆的精确时间。但是， ClockTime 不善于处理下列问题：</p>
<blockquote class="default"></blockquote>
<blockquote class="default"><ul class="calibre30"><li class="calibre11">今天是周一吗？</li><li class="calibre11">明年 5 月 1 日是周几？</li><li class="calibre11">在我的时区当前是什么时间，考虑夏令时。</li></ul></blockquote>
<p class="calibre9">CalendarTime 按人类的方式存储时间：年，月，日，小时，分，秒，时区，夏令时信息。很容易的转换为便于显示的字符串，或者以上问题的答案。</p>
<p class="calibre9">你可以任意转换 ClockTime 和 CalendarTime 。Haskell 将 ClockTime 可以按本地时区转换为 CalendarTime ，或者按 CalendarTime 格式表示的 UTC 时间。</p>
<h4 class="calibre19"><a id="chp-20.html._ClockTime_142" class="calibre7 pcalibre"></a>使用 ClockTime</h4>
<p class="calibre9">ClockTime 在 System.Time 中这样定义：</p>
<pre class="calibre15"><code class="tthhighlight-container">data ClockTime <span class="token3">=</span> TOD Integer Integer

</code></pre>
<p class="calibre9">第一个 Integer 表示从 Unix 纪元开始经过的秒数。第二个 Integer 表示附加的皮秒数。因为 Haskell 中的 ClockTime 使用无边界的 Integer 类型，所以其能够表示的数据范围仅受计算资源限制。</p>
<p class="calibre9">让我们看看使用 ClockTime 的一些方法。首先是按系统时钟获取当前时间的 getClockTime 函数。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>module System<span class="token">.</span>Time
ghci<span class="token3">&gt;</span> getClockTime
Loading package old<span class="token3">-</span>locale<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package old<span class="token3">-</span>time<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Mon Aug <span class="token2">18</span> <span class="token2">12</span><span class="token">:</span><span class="token2">10</span><span class="token">:</span><span class="token2">38</span> CDT <span class="token2">2008</span>

</code></pre>
<p class="calibre9">如果一秒钟再次运行 getClockTime ，它将返回一个更新后的时间。这条命令会输出一个便于观察的字符串，补全了周相关的信息。这是由于 ClockTime 的 Show 实例。让我们从更底层看一下 ClockTime ：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> TOD <span class="token2">1000</span> <span class="token2">0</span>
Wed Dec <span class="token2">31</span> <span class="token2">18</span><span class="token">:</span><span class="token2">16</span><span class="token">:</span><span class="token2">40</span> CST <span class="token2">1969</span>
ghci<span class="token3">&gt;</span> getClockTime <span class="token3">&gt;</span><span class="token3">&gt;=</span> <span class="token">(</span>\<span class="token">(</span>TOD sec _<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> sec<span class="token">)</span>
<span class="token2">1219079438</span>

</code></pre>
<p class="calibre9">这里我们先构建一个 ClockTime ，表示 UTC 时间 1970 年 1 月 1 日午夜后 1000 秒这个时间点。在你的时区这个时间相当于 1969 年 12 月 31 日晚。</p>
<p class="calibre9">第二个例子演示如何从 getClockTime 返值中将秒数取出来。我们可以像这样操作它：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> getClockTime <span class="token3">&gt;</span><span class="token3">&gt;=</span> <span class="token">(</span>\<span class="token">(</span>TOD sec _<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> <span class="token">(</span>TOD <span class="token">(</span>sec <span class="token3">+</span> <span class="token2">86400</span><span class="token">)</span> <span class="token2">0</span><span class="token">)</span><span class="token">)</span>
Tue Aug <span class="token2">19</span> <span class="token2">12</span><span class="token">:</span><span class="token2">10</span><span class="token">:</span><span class="token2">38</span> CDT <span class="token2">2008</span>

</code></pre>
<p class="calibre9">这将显精确示你的时区 24 小时后的时间，因为 24 小时等于 86,400 秒。</p>
<h4 class="calibre19"><a id="chp-20.html._CalendarTime_186" class="calibre7 pcalibre"></a>使用 CalendarTime</h4>
<p class="calibre9">正如其名字暗示的， CalendarTime 按日历上的方式表示时间。它包括年、月、日等信息。 CalendarTime 和其相关类型定义如下：</p>
<pre class="calibre15"><code class="tthhighlight-container">data CalendarTime <span class="token3">=</span> CalendarTime
   <span class="token">{</span>ctYear <span class="token">:</span><span class="token">:</span> Int<span class="token">,</span>         <span class="token3">--</span> Year <span class="token">(</span>post<span class="token3">-</span>Gregorian<span class="token">)</span>
    ctMonth <span class="token">:</span><span class="token">:</span> Month<span class="token">,</span>
    ctDay <span class="token">:</span><span class="token">:</span> Int<span class="token">,</span>          <span class="token3">--</span> Day of the month <span class="token">(</span><span class="token2">1</span> to <span class="token2">31</span><span class="token">)</span>
    ctHour <span class="token">:</span><span class="token">:</span> Int<span class="token">,</span>         <span class="token3">--</span> Hour of the day <span class="token">(</span><span class="token2">0</span> to <span class="token2">23</span><span class="token">)</span>
    ctMin <span class="token">:</span><span class="token">:</span> Int<span class="token">,</span>          <span class="token3">--</span> Minutes <span class="token">(</span><span class="token2">0</span> to <span class="token2">59</span><span class="token">)</span>
    ctSec <span class="token">:</span><span class="token">:</span> Int<span class="token">,</span>          <span class="token3">--</span> Seconds <span class="token">(</span><span class="token2">0</span> to <span class="token2">61</span><span class="token">,</span> allowing <span class="token1">for</span> leap seconds<span class="token">)</span>
    ctPicosec <span class="token">:</span><span class="token">:</span> Integer<span class="token">,</span>  <span class="token3">--</span> Picoseconds
    ctWDay <span class="token">:</span><span class="token">:</span> Day<span class="token">,</span>         <span class="token3">--</span> Day of the week
    ctYDay <span class="token">:</span><span class="token">:</span> Int<span class="token">,</span>         <span class="token3">--</span> Day of the year <span class="token">(</span><span class="token2">0</span> to <span class="token2">364</span> or <span class="token2">365</span><span class="token">)</span>
    ctTZName <span class="token">:</span><span class="token">:</span> String<span class="token">,</span>    <span class="token3">--</span> Name of timezone
    ctTZ <span class="token">:</span><span class="token">:</span> Int<span class="token">,</span>           <span class="token3">--</span> Variation from UTC <span class="token1">in</span> seconds
    ctIsDST <span class="token">:</span><span class="token">:</span> Bool        <span class="token3">--</span> True <span class="token1">if</span> Daylight Saving Time <span class="token1">in</span> effect
   <span class="token">}</span>

data Month <span class="token3">=</span> January <span class="token3">|</span> February <span class="token3">|</span> March <span class="token3">|</span> April <span class="token3">|</span> May <span class="token3">|</span> June
             <span class="token3">|</span> July <span class="token3">|</span> August <span class="token3">|</span> September <span class="token3">|</span> October <span class="token3">|</span> November <span class="token3">|</span> December

data Day <span class="token3">=</span> Sunday <span class="token3">|</span> Monday <span class="token3">|</span> Tuesday <span class="token3">|</span> Wednesday
           <span class="token3">|</span> Thursday <span class="token3">|</span> Friday <span class="token3">|</span> Saturday

</code></pre>
<p class="calibre9">关于以上结构有些事情需要强调：</p>
<blockquote class="default"></blockquote>
<blockquote class="default"><ul class="calibre30"><li class="calibre11">ctWDay, ctYDay, ctTZName 是被创建 CalendarTime 的库函数生成的，但是并不参与计算。如果你手工创建一个 CalendarTime ，不必向其中填写准确的值，除非你的计算依赖于它们。</li><li class="calibre11">这三个类型都是 Eq, Ord, Read, Show 类型类的成员。另外， Month 和 Day 都被声明为 Enum 和 Bounded 类型类的成员。更多的信息请参考 “重要的类型类” 这一章节。</li></ul></blockquote>
<p class="calibre9">有几种不同的途径可以生成 CalendarTime 。可以像这样将 ClockTime 转换为 CalendarTime ：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>module System<span class="token">.</span>Time
ghci<span class="token3">&gt;</span> now <span class="token3">&lt;</span><span class="token3">-</span> getClockTime
Loading package old<span class="token3">-</span>locale<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package old<span class="token3">-</span>time<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Mon Aug <span class="token2">18</span> <span class="token2">12</span><span class="token">:</span><span class="token2">10</span><span class="token">:</span><span class="token2">35</span> CDT <span class="token2">2008</span>
ghci<span class="token3">&gt;</span> nowCal <span class="token3">&lt;</span><span class="token3">-</span> toCalendarTime now
CalendarTime <span class="token">{</span>ctYear <span class="token3">=</span> <span class="token2">2008</span><span class="token">,</span> ctMonth <span class="token3">=</span> August<span class="token">,</span> ctDay <span class="token3">=</span> <span class="token2">18</span><span class="token">,</span> ctHour <span class="token3">=</span> <span class="token2">12</span><span class="token">,</span> ctMin <span class="token3">=</span> <span class="token2">10</span><span class="token">,</span> ctSec <span class="token3">=</span> <span class="token2">35</span><span class="token">,</span> ctPicosec <span class="token3">=</span> <span class="token2">804267000000</span><span class="token">,</span> ctWDay <span class="token3">=</span> Monday<span class="token">,</span> ctYDay <span class="token3">=</span> <span class="token2">230</span><span class="token">,</span> ctTZName <span class="token3">=</span> <span class="token4">"CDT"</span><span class="token">,</span> ctTZ <span class="token3">=</span> <span class="token3">-</span><span class="token2">18000</span><span class="token">,</span> ctIsDST <span class="token3">=</span> True<span class="token">}</span>
ghci<span class="token3">&gt;</span> let nowUTC <span class="token3">=</span> toUTCTime now
ghci<span class="token3">&gt;</span> nowCal
CalendarTime <span class="token">{</span>ctYear <span class="token3">=</span> <span class="token2">2008</span><span class="token">,</span> ctMonth <span class="token3">=</span> August<span class="token">,</span> ctDay <span class="token3">=</span> <span class="token2">18</span><span class="token">,</span> ctHour <span class="token3">=</span> <span class="token2">12</span><span class="token">,</span> ctMin <span class="token3">=</span> <span class="token2">10</span><span class="token">,</span> ctSec <span class="token3">=</span> <span class="token2">35</span><span class="token">,</span> ctPicosec <span class="token3">=</span> <span class="token2">804267000000</span><span class="token">,</span> ctWDay <span class="token3">=</span> Monday<span class="token">,</span> ctYDay <span class="token3">=</span> <span class="token2">230</span><span class="token">,</span> ctTZName <span class="token3">=</span> <span class="token4">"CDT"</span><span class="token">,</span> ctTZ <span class="token3">=</span> <span class="token3">-</span><span class="token2">18000</span><span class="token">,</span> ctIsDST <span class="token3">=</span> True<span class="token">}</span>
ghci<span class="token3">&gt;</span> nowUTC
CalendarTime <span class="token">{</span>ctYear <span class="token3">=</span> <span class="token2">2008</span><span class="token">,</span> ctMonth <span class="token3">=</span> August<span class="token">,</span> ctDay <span class="token3">=</span> <span class="token2">18</span><span class="token">,</span> ctHour <span class="token3">=</span> <span class="token2">17</span><span class="token">,</span> ctMin <span class="token3">=</span> <span class="token2">10</span><span class="token">,</span> ctSec <span class="token3">=</span> <span class="token2">35</span><span class="token">,</span> ctPicosec <span class="token3">=</span> <span class="token2">804267000000</span><span class="token">,</span> ctWDay <span class="token3">=</span> Monday<span class="token">,</span> ctYDay <span class="token3">=</span> <span class="token2">230</span><span class="token">,</span> ctTZName <span class="token3">=</span> <span class="token4">"UTC"</span><span class="token">,</span> ctTZ <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> ctIsDST <span class="token3">=</span> False<span class="token">}</span>

</code></pre>
<p class="calibre9">用 getClockTime 从系统获得当前的 ClockTime 。接下来， toCalendarTime 按本地时间区将 ClockTime 转换为 CalendarTime 。 toUTCtime 执行类似的转换，但其结果将以 UTC 时区表示。</p>
<p class="calibre9">注意， toCalendarTime 是一个 IO 函数，但是 toUTCTime 不是。原因是 toCalendarTime 依赖本地时区返回不同的结果，但是针对相同的 ClockTime ， toUTCTime 将始终返回相同的结果。</p>
<p class="calibre9">很容易改变一个 CalendarTime 的值</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> nowCal <span class="token">{</span>ctYear <span class="token3">=</span> <span class="token2">1960</span><span class="token">}</span>
CalendarTime <span class="token">{</span>ctYear <span class="token3">=</span> <span class="token2">1960</span><span class="token">,</span> ctMonth <span class="token3">=</span> August<span class="token">,</span> ctDay <span class="token3">=</span> <span class="token2">18</span><span class="token">,</span> ctHour <span class="token3">=</span> <span class="token2">12</span><span class="token">,</span> ctMin <span class="token3">=</span> <span class="token2">10</span><span class="token">,</span> ctSec <span class="token3">=</span> <span class="token2">35</span><span class="token">,</span> ctPicosec <span class="token3">=</span> <span class="token2">804267000000</span><span class="token">,</span> ctWDay <span class="token3">=</span> Monday<span class="token">,</span> ctYDay <span class="token3">=</span> <span class="token2">230</span><span class="token">,</span> ctTZName <span class="token3">=</span> <span class="token4">"CDT"</span><span class="token">,</span> ctTZ <span class="token3">=</span> <span class="token3">-</span><span class="token2">18000</span><span class="token">,</span> ctIsDST <span class="token3">=</span> True<span class="token">}</span>
ghci<span class="token3">&gt;</span> <span class="token">(</span>\<span class="token">(</span>TOD sec _<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> sec<span class="token">)</span> <span class="token">(</span>toClockTime nowCal<span class="token">)</span>
<span class="token2">1219079435</span>
ghci<span class="token3">&gt;</span> <span class="token">(</span>\<span class="token">(</span>TOD sec _<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> sec<span class="token">)</span> <span class="token">(</span>toClockTime <span class="token">(</span>nowCal <span class="token">{</span>ctYear <span class="token3">=</span> <span class="token2">1960</span><span class="token">}</span><span class="token">)</span><span class="token">)</span>
<span class="token3">-</span><span class="token2">295685365</span>

</code></pre>
<p class="calibre9">此处，先将之前的 CalendarTime 年份修改为 1960 。然后用 toClockTime 将其初始值转换为一个 ClockTime ，接着转换新值，以便观察其差别。注意新值在转换为 ClockTime 后显示了一个负的秒数。这是意料中的， ClockTime 表示的是 UTC 时间 1970 年 1 月 1 日午夜之后的秒数。</p>
<p class="calibre9">也可以像这样手工创建 CalendarTime ：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> let newCT <span class="token3">=</span> CalendarTime <span class="token2">2010</span> January <span class="token2">15</span> <span class="token2">12</span> <span class="token2">30</span> <span class="token2">0</span> <span class="token2">0</span> Sunday <span class="token2">0</span> <span class="token4">"UTC"</span> <span class="token2">0</span> False
ghci<span class="token3">&gt;</span> newCT
CalendarTime <span class="token">{</span>ctYear <span class="token3">=</span> <span class="token2">2010</span><span class="token">,</span> ctMonth <span class="token3">=</span> January<span class="token">,</span> ctDay <span class="token3">=</span> <span class="token2">15</span><span class="token">,</span> ctHour <span class="token3">=</span> <span class="token2">12</span><span class="token">,</span> ctMin <span class="token3">=</span> <span class="token2">30</span><span class="token">,</span> ctSec <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> ctPicosec <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> ctWDay <span class="token3">=</span> Sunday<span class="token">,</span> ctYDay <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> ctTZName <span class="token3">=</span> <span class="token4">"UTC"</span><span class="token">,</span> ctTZ <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> ctIsDST <span class="token3">=</span> False<span class="token">}</span>
ghci<span class="token3">&gt;</span> <span class="token">(</span>\<span class="token">(</span>TOD sec _<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> sec<span class="token">)</span> <span class="token">(</span>toClockTime newCT<span class="token">)</span>
<span class="token2">1263558600</span>

</code></pre>
<p class="calibre9">注意，尽管 2010 年 1 月 15 日并不是一个周日 – 并且也不是一年中的第 0 天 – 系统可以很好的处理这些情况。实际上，如果将其转换为 ClockTime 后再转回 CalendarTime ，你将发现这些域已经被正确的处理了。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> toUTCTime <span class="token">.</span> toClockTime $ newCT
CalendarTime <span class="token">{</span>ctYear <span class="token3">=</span> <span class="token2">2010</span><span class="token">,</span> ctMonth <span class="token3">=</span> January<span class="token">,</span> ctDay <span class="token3">=</span> <span class="token2">15</span><span class="token">,</span> ctHour <span class="token3">=</span> <span class="token2">12</span><span class="token">,</span> ctMin <span class="token3">=</span> <span class="token2">30</span><span class="token">,</span> ctSec <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> ctPicosec <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> ctWDay <span class="token3">=</span> Friday<span class="token">,</span> ctYDay <span class="token3">=</span> <span class="token2">14</span><span class="token">,</span> ctTZName <span class="token3">=</span> <span class="token4">"UTC"</span><span class="token">,</span> ctTZ <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> ctIsDST <span class="token3">=</span> False<span class="token">}</span>

</code></pre>
<h4 class="calibre19"><a id="chp-20.html.ClockTime__TimeDiff_276" class="calibre7 pcalibre"></a>ClockTime 的 TimeDiff</h4>
<p class="calibre9">以对人类友好的方式难于处理 ClockTime 值之间的差异， System.Time 模块包括了一个 TimeDiff 类型。 TimeDiff 用于方便的处理这些差异。其定义如下：</p>
<pre class="calibre15"><code class="tthhighlight-container">data TimeDiff <span class="token3">=</span> TimeDiff
   <span class="token">{</span>tdYear <span class="token">:</span><span class="token">:</span> Int<span class="token">,</span>
    tdMonth <span class="token">:</span><span class="token">:</span> Int<span class="token">,</span>
    tdDay <span class="token">:</span><span class="token">:</span> Int<span class="token">,</span>
    tdHour <span class="token">:</span><span class="token">:</span> Int<span class="token">,</span>
    tdMin <span class="token">:</span><span class="token">:</span> Int<span class="token">,</span>
    tdSec <span class="token">:</span><span class="token">:</span> Int<span class="token">,</span>
    tdPicosec <span class="token">:</span><span class="token">:</span> Integer<span class="token">}</span>

</code></pre>
<p class="calibre9">diffClockTimes 和 addToClockTime 两个函数接收一个 ClockTime 和一个 TimeDiff 并在内部将 ClockTime 转换为一个 UTC 时区的 CalendarTime ，在其上执行 TimeDiff ，最后将结果转换回一个 ClockTime 。</p>
<p class="calibre9">看看它怎样工作：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>module System<span class="token">.</span>Time
ghci<span class="token3">&gt;</span> let feb5 <span class="token3">=</span> toClockTime $ CalendarTime <span class="token2">2008</span> February <span class="token2">5</span> <span class="token2">0</span> <span class="token2">0</span> <span class="token2">0</span> <span class="token2">0</span> Sunday <span class="token2">0</span> <span class="token4">"UTC"</span> <span class="token2">0</span> False
Loading package old<span class="token3">-</span>locale<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package old<span class="token3">-</span>time<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
ghci<span class="token3">&gt;</span> feb5
Mon Feb  <span class="token2">4</span> <span class="token2">18</span><span class="token">:</span><span class="token2">00</span><span class="token">:</span><span class="token2">00</span> CST <span class="token2">2008</span>
ghci<span class="token3">&gt;</span> addToClockTime <span class="token">(</span>TimeDiff <span class="token2">0</span> <span class="token2">1</span> <span class="token2">0</span> <span class="token2">0</span> <span class="token2">0</span> <span class="token2">0</span> <span class="token2">0</span><span class="token">)</span> feb5
Tue Mar  <span class="token2">4</span> <span class="token2">18</span><span class="token">:</span><span class="token2">00</span><span class="token">:</span><span class="token2">00</span> CST <span class="token2">2008</span>
ghci<span class="token3">&gt;</span> toUTCTime $ addToClockTime <span class="token">(</span>TimeDiff <span class="token2">0</span> <span class="token2">1</span> <span class="token2">0</span> <span class="token2">0</span> <span class="token2">0</span> <span class="token2">0</span> <span class="token2">0</span><span class="token">)</span> feb5
CalendarTime <span class="token">{</span>ctYear <span class="token3">=</span> <span class="token2">2008</span><span class="token">,</span> ctMonth <span class="token3">=</span> March<span class="token">,</span> ctDay <span class="token3">=</span> <span class="token2">5</span><span class="token">,</span> ctHour <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> ctMin <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> ctSec <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> ctPicosec <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> ctWDay <span class="token3">=</span> Wednesday<span class="token">,</span> ctYDay <span class="token3">=</span> <span class="token2">64</span><span class="token">,</span> ctTZName <span class="token3">=</span> <span class="token4">"UTC"</span><span class="token">,</span> ctTZ <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> ctIsDST <span class="token3">=</span> False<span class="token">}</span>
ghci<span class="token3">&gt;</span> let jan30 <span class="token3">=</span> toClockTime $ CalendarTime <span class="token2">2009</span> January <span class="token2">30</span> <span class="token2">0</span> <span class="token2">0</span> <span class="token2">0</span> <span class="token2">0</span> Sunday <span class="token2">0</span> <span class="token4">"UTC"</span> <span class="token2">0</span> False
ghci<span class="token3">&gt;</span> jan30
Thu Jan <span class="token2">29</span> <span class="token2">18</span><span class="token">:</span><span class="token2">00</span><span class="token">:</span><span class="token2">00</span> CST <span class="token2">2009</span>
ghci<span class="token3">&gt;</span> addToClockTime <span class="token">(</span>TimeDiff <span class="token2">0</span> <span class="token2">1</span> <span class="token2">0</span> <span class="token2">0</span> <span class="token2">0</span> <span class="token2">0</span> <span class="token2">0</span><span class="token">)</span> jan30
Sun Mar  <span class="token2">1</span> <span class="token2">18</span><span class="token">:</span><span class="token2">00</span><span class="token">:</span><span class="token2">00</span> CST <span class="token2">2009</span>
ghci<span class="token3">&gt;</span> toUTCTime $ addToClockTime <span class="token">(</span>TimeDiff <span class="token2">0</span> <span class="token2">1</span> <span class="token2">0</span> <span class="token2">0</span> <span class="token2">0</span> <span class="token2">0</span> <span class="token2">0</span><span class="token">)</span> jan30
CalendarTime <span class="token">{</span>ctYear <span class="token3">=</span> <span class="token2">2009</span><span class="token">,</span> ctMonth <span class="token3">=</span> March<span class="token">,</span> ctDay <span class="token3">=</span> <span class="token2">2</span><span class="token">,</span> ctHour <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> ctMin <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> ctSec <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> ctPicosec <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> ctWDay <span class="token3">=</span> Monday<span class="token">,</span> ctYDay <span class="token3">=</span> <span class="token2">60</span><span class="token">,</span> ctTZName <span class="token3">=</span> <span class="token4">"UTC"</span><span class="token">,</span> ctTZ <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> ctIsDST <span class="token3">=</span> False<span class="token">}</span>
ghci<span class="token3">&gt;</span> diffClockTimes jan30 feb5
TimeDiff <span class="token">{</span>tdYear <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> tdMonth <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> tdDay <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> tdHour <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> tdMin <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> tdSec <span class="token3">=</span> <span class="token2">31104000</span><span class="token">,</span> tdPicosec <span class="token3">=</span> <span class="token2">0</span><span class="token">}</span>
ghci<span class="token3">&gt;</span> normalizeTimeDiff $ diffClockTimes jan30 feb5
TimeDiff <span class="token">{</span>tdYear <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> tdMonth <span class="token3">=</span> <span class="token2">12</span><span class="token">,</span> tdDay <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> tdHour <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> tdMin <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> tdSec <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> tdPicosec <span class="token3">=</span> <span class="token2">0</span><span class="token">}</span>

</code></pre>
<p class="calibre9">首先我们生成一个 ClockTime 表示 UTC 时间 2008 年 2 月 5 日。注意，若你的时区不是 UTC，按你本地时区的格式，当其被显示的时候可能是 2 月 4 日晚。</p>
<p class="calibre9">其次，我们用 addToClockTime 在其上加一个月。2008 是闰年，但系统可以正确的处理，然后我们得到了一个月后的相同日期。使用 toUTCTime ，我们可以看到以 UTC 时间表示的结果。</p>
<p class="calibre9">第二个实验，设定一个表示 UTC 时间 2009 年 1 月 30 日午夜的时间。2009 年不是闰年，所以我们可能很好奇其加上一个月是什么结果。因为 2009 年没有 2 月 29 日和 2 月 30 日，所以我们得到了 3 月 2 日。</p>
<p class="calibre9">最后，我们可以看到 diffClockTimes 怎样通过两个 ClockTime 值得到一个 TimeDiff ， 尽管其只包含秒和皮秒。 normalizeTimeDiff 函数接受一个 TimeDiff 将其重新按照人类的习惯格式化。</p>
<h2 class="calibre14"><a id="chp-20.html._329" class="calibre7 pcalibre"></a>文件修改日期</h2>
<p class="calibre9">很多程序需要找出某些文件的最后修改日期。 ls 和图形化的文件管理器是典型的需要显示文件最后变更时间的程序。 System.Directory 模块包含一个跨平台的 getModificationTime 函数。其接受一个文件名，返回一个表示文件最后变更日期的 ClockTime 。例如：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>module System<span class="token">.</span>Directory
ghci<span class="token3">&gt;</span> getModificationTime <span class="token4">"/etc/passwd"</span>
Loading package old<span class="token3">-</span>locale<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package old<span class="token3">-</span>time<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package filepath<span class="token3">-</span><span class="token2">1.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package directory<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Fri Aug <span class="token2">15</span> <span class="token2">08</span><span class="token">:</span><span class="token2">29</span><span class="token">:</span><span class="token2">48</span> CDT <span class="token2">2008</span>

</code></pre>
<p class="calibre9">POSIX 平台不仅维护变更时间 (被称为 mtime)， 还有最后读或写访问时间 (atime)以及最后状态变更时间 (ctime)。这是 POSIX 平台独有的，所以跨平台的 System.Directory 模块无法访问它。取而代之，需要使用 System.Posix.Files 模块中的函数。下面有一个例子：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch20<span class="token3">/</span>posixtime<span class="token">.</span>hs
<span class="token3">--</span> posixtime<span class="token">.</span>hs

import System<span class="token">.</span>Posix<span class="token">.</span>Files
import System<span class="token">.</span>Time
import System<span class="token">.</span>Posix<span class="token">.</span>Types

<span class="token3">--</span> <span class="token3">|</span> Given a path<span class="token">,</span> returns <span class="token">(</span>atime<span class="token">,</span> mtime<span class="token">,</span> ctime<span class="token">)</span>
getTimes <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span>ClockTime<span class="token">,</span> ClockTime<span class="token">,</span> ClockTime<span class="token">)</span>
getTimes fp <span class="token3">=</span>
    <span class="token1">do</span> stat <span class="token3">&lt;</span><span class="token3">-</span> getFileStatus fp
       <span class="token1">return</span> <span class="token">(</span>toct <span class="token">(</span>accessTime stat<span class="token">)</span><span class="token">,</span>
               toct <span class="token">(</span>modificationTime stat<span class="token">)</span><span class="token">,</span>
               toct <span class="token">(</span>statusChangeTime stat<span class="token">)</span><span class="token">)</span>

<span class="token3">--</span> <span class="token3">|</span> Convert an EpochTime to a ClockTime
toct <span class="token">:</span><span class="token">:</span> EpochTime <span class="token3">-</span><span class="token3">&gt;</span> ClockTime
toct et <span class="token3">=</span>
    TOD <span class="token">(</span>truncate <span class="token">(</span>toRational et<span class="token">)</span><span class="token">)</span> <span class="token2">0</span>

</code></pre>
<p class="calibre9">注意对 getFileStatus 的调用。 这个调用直接映射到 C 语言的 stat() 函数。其返回一个包含了大量不同种类信息的值，包括文件类型、权限、属主、组、和我们感性去的三种时间值。 System.Posix.Files 提供了 accessTime 等多个函数，可以将我们感兴趣的时间从 getFileStatus 返回的 FileStatus 类型中提取出来。</p>
<blockquote class="default"><p class="calibre9">accessTime 等函数返回一个POSIX 平台特有的类型，称为 EpochTime ， 可以通过 toct 函数转换 ClockTime 。 System.Posix.Files 模块同样提供了 setFileTimes 函数，以设置文件的 atime 和 mtime 。 <a href="#chp-20.html." class="calibre7 pcalibre">[45]</a></p></blockquote>
<h2 class="calibre14"><a id="chp-20.html.__373" class="calibre7 pcalibre"></a>延伸的例子: 管道</h2>
<p class="calibre9">我们已经了解了如何调用外部程序。有时候需要更多的控制。比如获得程序的标准输出、提供输入，甚至将不同的外部程序串起来调用。管道有助于实现所有这些需求。管道经常用在 shell 脚本中。 在 shell 中设置一个管道，会调用多个程序。第一个程序的输入会做为第二个程序的输入。其输出又会作为第三个的输入，以此类推。最后一个程序通常将输出打印到终端，或者写入文件。下面是一个 POSIX shell 的例子，演示如何使用管道：</p>
<pre class="calibre15"><code class="tthhighlight-container">$ ls <span class="token3">/</span>etc <span class="token3">|</span> grep <span class="token4">'m.*ap'</span> <span class="token3">|</span> tr a<span class="token3">-</span>z A<span class="token3">-</span>Z
IDMAPD<span class="token">.</span>CONF
MAILCAP
MAILCAP<span class="token">.</span>ORDER
MEDIAPRM
TERMCAP

</code></pre>
<p class="calibre9">这条命令运行了三个程序，使用管道在它们之间传输数据。它以 ls/etc 开始，输出是 /etc 目录下全部文件和目录的列表。 ls 的输出被作为 grep 的输入。我们想 grep 输入一条正则使其只输出以 ‘m' 开头并且在某处包含 “ap” 的行。最后，其结果被传入 tr 。我们给 tr 设置一个选项，使其将所有字符转换为大写。 tr 的输出没有特殊的去处，所以直接在屏幕显示。</p>
<p class="calibre9">这种情况下，程序之间的管道线路由 shell 设置。我们可以使用 Haskell 中的 POSIX 工具实现同的事情。</p>
<p class="calibre9">在讲解如何实现之前，要提醒你一下， System.Posix 模块提供的是很低阶的 Unix 系统接口。无论使用何种编程语言，这些接口都可以相互组合，组合的结果也可以相互组合。这些低阶接口的完整性质可以用一整本书来讨论，这章中我们只会简单介绍。</p>
<h2 class="calibre14"><a id="chp-20.html._393" class="calibre7 pcalibre"></a>使用管道做重定向</h2>
<p class="calibre9">POSIX 定义了一个函数用于创建管道。这个函数返回两个文件描述符（FD），与 Haskell 中的句柄概念类似。一个 FD 用于读端，另一个用于写端。任何从写端写入的东西，都可以从读端读取。这些数据就是“通过管道推送”的。在 Haskell 中，你可以通过 createPipe 使用这个接口。</p>
<p class="calibre9">在外部程序之间传递数据之前，要做的第一步是建立一个管道。同时还要将一个程序的输出重定向到管道，并将管道做为另一个程序的输入。 Haskell 的 dupTo 函数就是做这个的。其接收一个 FD 并将其拷贝为另一个 FD 号。 POSIX 的标准输入、标准输出和标准错误的 FD 分别被预定义为 0, 1, 2 。将管道的某一端设置为这些 FD 号，我们就可以有效的重定向程序的输入和输出。</p>
<p class="calibre9">不过还有问题需要解决。我们不能简单的只是在某个调用比如 rawSystem 之前使用 dupTo ，因为这回混淆我们的 Haskell 主程序的输入和输出。此外， rawSystem 会一直阻塞直到被调用的程序执行完毕，这让我们无法启动并行执行的进程。 为了解决这个问题，可以使用 forkProcess 。这是一个很特殊的函数。它实际上生成了一份当前进程的拷贝，并使这两份进程同时运行。 Haskell 的 forkProcess 函数接收一个函数，使其在新进程（称为子进程）中运行。我们让这个函数调用 dupTo 。之后，其调用 executeFile 调用真正希望执行的命令。这同样也是一个特殊的函数：如果一切顺利，他将不会返回。这是因为 executeFile 使用一个不同的程序替换了当前执行的进程。最后，初始的 Haskell 进程调用 getProcessStatus 以等待子进程结束，并获得其状态码。</p>
<p class="calibre9">在 POSIX 系统中，无论何时你执行一条命令，不关是在命令上上敲 ls 还是在 Haskell 中使用 rawSystem ，其内部机理都是调用 forkProcess , executeFile , 和 getProcessStatusa (或是它们对应的 C 函数)。为了使用管道，我们复制了系统启动程序的进程，并且加入了一些调用和重定向管道的步骤。</p>
<p class="calibre9">还有另外一些辅助步骤需要注意。当调用 forkProcess 时，“几乎”和程序有关的一切都被复制 <a href="#chp-20.html." class="calibre7 pcalibre">[46]</a> 。包括所有已经打开的文件描述符（句柄）。程序通过检查管道是否传来文件结束符判断数据接收是否结束。写端进程关闭管道时，读端程序将收到文件结束符。然而，如果同一个写端文件描述符在多个进程中同时存在，则文件结束符要在所有进程中都被关闭才会发送文件结束符。因此，我们必须在子进程中追踪打开了哪些文件描述符，以便关闭它们。同样，也必须尽早在主进程中关闭子进程的写管道。</p>
<p class="calibre9">下面是一个用 Haskell 编写的管道系统的初始实现：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch20<span class="token3">/</span>RunProcessSimple<span class="token">.</span>hs

<span class="token">{</span><span class="token3">-</span># OPTIONS_GHC <span class="token3">-</span>XDatatypeContexts #<span class="token3">-</span><span class="token">}</span>
<span class="token">{</span><span class="token3">-</span># OPTIONS_GHC <span class="token3">-</span>XTypeSynonymInstances #<span class="token3">-</span><span class="token">}</span>
<span class="token">{</span><span class="token3">-</span># OPTIONS_GHC <span class="token3">-</span>XFlexibleInstances #<span class="token3">-</span><span class="token">}</span>

module RunProcessSimple where

<span class="token3">--</span>import System<span class="token">.</span>Process
import Control<span class="token">.</span>Concurrent
import Control<span class="token">.</span>Concurrent<span class="token">.</span>MVar
import System<span class="token">.</span>IO
import System<span class="token">.</span>Exit
import Text<span class="token">.</span>Regex<span class="token">.</span>Posix
import System<span class="token">.</span>Posix<span class="token">.</span>Process
import System<span class="token">.</span>Posix<span class="token">.</span>IO
import System<span class="token">.</span>Posix<span class="token">.</span>Types
import Control<span class="token">.</span>Exception

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> The type <span class="token1">for</span> running external commands<span class="token">.</span>  The first part
of the tuple is the program name<span class="token">.</span>  The list represents the
command<span class="token3">-</span>line parameters to pass to the command<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
type SysCommand <span class="token3">=</span> <span class="token">(</span>String<span class="token">,</span> <span class="token">[</span>String<span class="token">]</span><span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> The result of running any command <span class="token3">-</span><span class="token">}</span>
data CommandResult <span class="token3">=</span> CommandResult <span class="token">{</span>
    cmdOutput <span class="token">:</span><span class="token">:</span> IO String<span class="token">,</span>              <span class="token3">--</span> <span class="token3">^</span> IO action that yields the output
    getExitStatus <span class="token">:</span><span class="token">:</span> IO ProcessStatus    <span class="token3">--</span> <span class="token3">^</span> IO action that yields exit result
    <span class="token">}</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> The type <span class="token1">for</span> handling global lists of FDs to always close <span class="token1">in</span> the clients
<span class="token3">-</span><span class="token">}</span>
type CloseFDs <span class="token3">=</span> MVar <span class="token">[</span>Fd<span class="token">]</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Class <span class="token5">representing</span> anything that is a runnable command <span class="token3">-</span><span class="token">}</span>
class <span class="token5">CommandLike</span> a where
    <span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Given the command and a String representing input<span class="token">,</span>
         invokes the command<span class="token">.</span>  Returns a String
         representing the output of the command<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
    invoke <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> CloseFDs <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> IO CommandResult

<span class="token3">--</span> Support <span class="token1">for</span> running system commands
instance CommandLike SysCommand where
    invoke <span class="token">(</span>cmd<span class="token">,</span> args<span class="token">)</span> closefds input <span class="token3">=</span>
        <span class="token1">do</span> <span class="token3">--</span> Create two pipes<span class="token">:</span> one to handle stdin and the other
           <span class="token3">--</span> to handle stdout<span class="token">.</span>  We <span class="token1">do</span> not redirect stderr <span class="token1">in</span> this program<span class="token">.</span>
           <span class="token">(</span>stdinread<span class="token">,</span> stdinwrite<span class="token">)</span> <span class="token3">&lt;</span><span class="token3">-</span> createPipe
           <span class="token">(</span>stdoutread<span class="token">,</span> stdoutwrite<span class="token">)</span> <span class="token3">&lt;</span><span class="token3">-</span> createPipe

           <span class="token3">--</span> We add the parent FDs to this list because we always need
           <span class="token3">--</span> to close them <span class="token1">in</span> the clients<span class="token">.</span>
           addCloseFDs closefds <span class="token">[</span>stdinwrite<span class="token">,</span> stdoutread<span class="token">]</span>

           <span class="token3">--</span> Now<span class="token">,</span> grab the closed FDs list and fork the child<span class="token">.</span>
           childPID <span class="token3">&lt;</span><span class="token3">-</span> withMVar closefds <span class="token">(</span>\fds <span class="token3">-</span><span class="token3">&gt;</span>
                          forkProcess <span class="token">(</span>child fds stdinread stdoutwrite<span class="token">)</span><span class="token">)</span>

           <span class="token3">--</span> Now<span class="token">,</span> on the parent<span class="token">,</span> close the client<span class="token3">-</span>side FDs<span class="token">.</span>
           closeFd stdinread
           closeFd stdoutwrite

           <span class="token3">--</span> Write the input to the command<span class="token">.</span>
           stdinhdl <span class="token3">&lt;</span><span class="token3">-</span> fdToHandle stdinwrite
           forkIO $ <span class="token1">do</span> hPutStr stdinhdl input
                       hClose stdinhdl

           <span class="token3">--</span> Prepare to receive output from the command
           stdouthdl <span class="token3">&lt;</span><span class="token3">-</span> fdToHandle stdoutread

           <span class="token3">--</span> Set up the <span class="token1">function</span> to call when ready to wait <span class="token1">for</span> the
           <span class="token3">--</span> child to exit<span class="token">.</span>
           let waitfunc <span class="token3">=</span>
                <span class="token1">do</span> status <span class="token3">&lt;</span><span class="token3">-</span> getProcessStatus True False childPID
                   case status of
                       Nothing <span class="token3">-</span><span class="token3">&gt;</span> fail $ <span class="token4">"Error: Nothing from getProcessStatus"</span>
                       Just ps <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">do</span> removeCloseFDs closefds
                                          <span class="token">[</span>stdinwrite<span class="token">,</span> stdoutread<span class="token">]</span>
                                     <span class="token1">return</span> ps
           <span class="token1">return</span> $ CommandResult <span class="token">{</span>cmdOutput <span class="token3">=</span> hGetContents stdouthdl<span class="token">,</span>
                                   getExitStatus <span class="token3">=</span> waitfunc<span class="token">}</span>

        <span class="token3">--</span> Define what happens <span class="token1">in</span> the child process
        where child closefds stdinread stdoutwrite <span class="token3">=</span>
                <span class="token1">do</span> <span class="token3">--</span> Copy our pipes over the regular stdin<span class="token3">/</span>stdout FDs
                   dupTo stdinread stdInput
                   dupTo stdoutwrite stdOutput

                   <span class="token3">--</span> Now close the original pipe FDs
                   closeFd stdinread
                   closeFd stdoutwrite

                   <span class="token3">--</span> Close all the open FDs we inherited from the parent
                   mapM_ <span class="token">(</span>\fd <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">catch</span> <span class="token">(</span><span class="token5">closeFd</span> fd<span class="token">)</span> <span class="token">(</span>\<span class="token">(</span>SomeException e<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> <span class="token">(</span><span class="token">)</span><span class="token">)</span><span class="token">)</span> closefds

                   <span class="token3">--</span> Start the program
                   executeFile cmd True args Nothing

<span class="token3">--</span> Add FDs to the list of FDs that must be closed post<span class="token3">-</span>fork <span class="token1">in</span> a child
addCloseFDs <span class="token">:</span><span class="token">:</span> CloseFDs <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>Fd<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
addCloseFDs closefds newfds <span class="token3">=</span>
    modifyMVar_ closefds <span class="token">(</span>\oldfds <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> $ oldfds <span class="token3">++</span> newfds<span class="token">)</span>

<span class="token3">--</span> Remove FDs from the list
removeCloseFDs <span class="token">:</span><span class="token">:</span> CloseFDs <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>Fd<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
removeCloseFDs closefds removethem <span class="token3">=</span>
    modifyMVar_ closefds <span class="token">(</span>\fdlist <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> $ procfdlist fdlist removethem<span class="token">)</span>

    where
    procfdlist fdlist <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> fdlist
    procfdlist fdlist <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span> procfdlist <span class="token">(</span>removefd fdlist x<span class="token">)</span> xs

    <span class="token3">--</span> We want to remove only the first occurance ot any given fd
    removefd <span class="token">[</span><span class="token">]</span> _ <span class="token3">=</span> <span class="token">[</span><span class="token">]</span>
    removefd <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> fd
        <span class="token3">|</span> fd <span class="token3">==</span> x <span class="token3">=</span> xs
        <span class="token3">|</span> otherwise <span class="token3">=</span> x <span class="token">:</span> removefd xs fd

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Type representing a pipe<span class="token">.</span>  A <span class="token4">'PipeCommand'</span> consists of a source
and destination part<span class="token">,</span> both of which must be instances of
<span class="token4">'CommandLike'</span><span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
data <span class="token">(</span>CommandLike src<span class="token">,</span> CommandLike dest<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span>
     PipeCommand src dest <span class="token3">=</span> PipeCommand src dest

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> A convenient <span class="token1">function</span> <span class="token1">for</span> creating a <span class="token4">'PipeCommand'</span><span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
<span class="token">(</span><span class="token3">-</span><span class="token3">|</span><span class="token3">-</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> <span class="token">(</span>CommandLike a<span class="token">,</span> CommandLike b<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> b <span class="token3">-</span><span class="token3">&gt;</span> PipeCommand a b
<span class="token">(</span><span class="token3">-</span><span class="token3">|</span><span class="token3">-</span><span class="token">)</span> <span class="token3">=</span> PipeCommand

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Make <span class="token4">'PipeCommand'</span> runnable as a command <span class="token3">-</span><span class="token">}</span>
instance <span class="token">(</span>CommandLike a<span class="token">,</span> CommandLike b<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span>
         CommandLike <span class="token">(</span>PipeCommand a b<span class="token">)</span> where
    invoke <span class="token">(</span>PipeCommand src dest<span class="token">)</span> closefds input <span class="token3">=</span>
        <span class="token1">do</span> res1 <span class="token3">&lt;</span><span class="token3">-</span> invoke src closefds input
           output1 <span class="token3">&lt;</span><span class="token3">-</span> cmdOutput res1
           res2 <span class="token3">&lt;</span><span class="token3">-</span> invoke dest closefds output1
           <span class="token1">return</span> $ CommandResult <span class="token">(</span>cmdOutput res2<span class="token">)</span> <span class="token">(</span>getEC res1 res2<span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Given two <span class="token4">'CommandResult'</span> items<span class="token">,</span> evaluate the exit codes <span class="token1">for</span>
both and then <span class="token1">return</span> a <span class="token4">"combined"</span> exit code<span class="token">.</span>  This will be ExitSuccess
<span class="token1">if</span> both exited successfully<span class="token">.</span>  Otherwise<span class="token">,</span> it will reflect the first
error encountered<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
getEC <span class="token">:</span><span class="token">:</span> CommandResult <span class="token3">-</span><span class="token3">&gt;</span> CommandResult <span class="token3">-</span><span class="token3">&gt;</span> IO ProcessStatus
getEC src dest <span class="token3">=</span>
    <span class="token1">do</span> sec <span class="token3">&lt;</span><span class="token3">-</span> getExitStatus src
       dec <span class="token3">&lt;</span><span class="token3">-</span> getExitStatus dest
       case sec of
            Exited ExitSuccess <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> dec
            x <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> x

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Execute a <span class="token4">'CommandLike'</span><span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
runIO <span class="token">:</span><span class="token">:</span> CommandLike a <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
runIO cmd <span class="token3">=</span>
    <span class="token1">do</span> <span class="token3">--</span> Initialize our closefds list
       closefds <span class="token3">&lt;</span><span class="token3">-</span> newMVar <span class="token">[</span><span class="token">]</span>

       <span class="token3">--</span> Invoke the command
       res <span class="token3">&lt;</span><span class="token3">-</span> invoke cmd closefds <span class="token">[</span><span class="token">]</span>

       <span class="token3">--</span> Process its output
       output <span class="token3">&lt;</span><span class="token3">-</span> cmdOutput res
       putStr output

       <span class="token3">--</span> Wait <span class="token1">for</span> termination and get exit status
       ec <span class="token3">&lt;</span><span class="token3">-</span> getExitStatus res
       case ec of
            Exited ExitSuccess <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> <span class="token">(</span><span class="token">)</span>
            x <span class="token3">-</span><span class="token3">&gt;</span> fail $ <span class="token4">"Exited: "</span> <span class="token3">++</span> show x

</code></pre>
<p class="calibre9">在研究这个函数的运作原理之前，让我们先来在 ghci 里面尝试运行它一下：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> runIO $ <span class="token">(</span><span class="token4">"pwd"</span><span class="token">,</span> <span class="token">[</span><span class="token">]</span><span class="token">:</span><span class="token">:</span><span class="token">[</span>String<span class="token">]</span><span class="token">)</span>
<span class="token3">/</span>Users<span class="token3">/</span>Blade<span class="token3">/</span>sandbox

ghci<span class="token3">&gt;</span> runIO $ <span class="token">(</span><span class="token4">"ls"</span><span class="token">,</span> <span class="token">[</span><span class="token4">"/usr"</span><span class="token">]</span><span class="token">)</span>
NX
X11
X11R6
bin
include
lib
libexec
local
sbin
share
standalone

ghci<span class="token3">&gt;</span> runIO $ <span class="token">(</span><span class="token4">"ls"</span><span class="token">,</span> <span class="token">[</span><span class="token4">"/usr"</span><span class="token">]</span><span class="token">)</span> <span class="token3">-</span><span class="token3">|</span><span class="token3">-</span> <span class="token">(</span><span class="token4">"grep"</span><span class="token">,</span> <span class="token">[</span><span class="token4">"^l"</span><span class="token">]</span><span class="token">)</span>
lib
libexec
local

ghci<span class="token3">&gt;</span> runIO $ <span class="token">(</span><span class="token4">"ls"</span><span class="token">,</span> <span class="token">[</span><span class="token4">"/etc"</span><span class="token">]</span><span class="token">)</span> <span class="token3">-</span><span class="token3">|</span><span class="token3">-</span> <span class="token">(</span><span class="token4">"grep"</span><span class="token">,</span> <span class="token">[</span><span class="token4">"m.*ap"</span><span class="token">]</span><span class="token">)</span> <span class="token3">-</span><span class="token3">|</span><span class="token3">-</span> <span class="token">(</span><span class="token4">"tr"</span><span class="token">,</span> <span class="token">[</span><span class="token4">"a-z"</span><span class="token">,</span> <span class="token4">"A-Z"</span><span class="token">]</span><span class="token">)</span>
COM<span class="token">.</span>APPLE<span class="token">.</span>SCREENSHARING<span class="token">.</span>AGENT<span class="token">.</span>LAUNCHD

</code></pre>
<p class="calibre9">我们从一个简单的命令 pwd 开始，它会打印当前工作目录。我们将 [] 做为参数列表，因为 pwd 不需要任何参数。由于使用了类型类， Haskell 无法自动推导出 [] 的类型，所以我们说明其类型为字符串组成的列表。</p>
<p class="calibre9">下面是一个更复杂些的例子。我们执行了 ls ，将其输出传入 grep 。最后我们通过管道，调用了一个与本节开始处 shell 内置管道的例子中相同的命令。不像 shell 中那样舒服，但是相对于 shell 我们的程序始终相对简单。</p>
<p class="calibre9">让我们读一下程序。起始处的 OPTIONS_GHC 语句，作用与 ghc 或 ghci 开始时传入 -fglasgow-exts 参数相同。我们使用了一个 GHC 扩展，以允许使用 (String,[String]) 类型作为一个类型类的实例 <a href="#chp-20.html." class="calibre7 pcalibre">[47]</a> 。将此类声明加入源码文件，就不用在每次调用这个模块的时候都要记得手工打开编译器开关。</p>
<p class="calibre9">在载入了所需模块之后，定义了一些类型。首先，定义 typeSysCommand=(String,[String]) 作为一个别名。这是系统将接收并执行的命令的类型。例子中的每条领命都要用到这个类型的数据。 CommandResult 命令用于表示给定命令的执行结果， CloseFDs 用于表示必须在新的子进程中关闭的文件描述符列表。</p>
<p class="calibre9">接着，定义一个类称为 CommandLike 。这个类用来跑 “东西” ，这个“东西” 可以是独立的程序，可以是两个程序之间的管道，未来也可以跑纯 Haskell 函数。任何一个类型想为这个类的成员，只需实现一个函数 – invoke 。这将允许以 runIO 启动一个独立命令或者一个管道。这在定义管道时也很有用，因为我们可以拥有某个管道的读写两端的完整调用栈。</p>
<p class="calibre9">我们的管道基础设施将使用字符串在进程间传递数据。我们将通过 hGetContents 获得 Haskell 在延迟读取方面的优势，并使用 forkIO 在后台写入。这种设计工作得不错，尽管传输速度不像将两个进程的管道读写端直接连接起来那样快 <a href="#chp-20.html." class="calibre7 pcalibre">[48]</a> 。但这让实现很简单。我们仅需要小心，不要做任何会让整个字符串被缓冲的操作，把接下来的工作完全交给 Haskell 的延迟特性。</p>
<p class="calibre9">接下来，为 SysCommand 定义一个 CommandLike 实例。我们创建两个管道：一个用来作为新进程的标准输入，另一个用于其标准输出。将产生两个读端两个写端，四个文件描述符。我们将要在子进程中关闭的文件描述符加入列表。这包括子进程标准输入的写端，和子进程标准输出的读端。接着，我们 fork 出子进程。然后可以在父进程中关闭相关的子进程文件描述符。 fork 之前不能这样做，因为那时子进程还不可用。获取 stdinwrite 的句柄，并通过 forkIO 启动一个现成向其写入数据。接着定义 waitfunc , 其中定义了调用这在准备好等待子进程结束时要执行的动作。同时，子进程使用 dupTo ，关闭其不需要的文件描述符。并执行命令。</p>
<p class="calibre9">然后定义一些工具函数用来管理文件描述符。此后，定义一些工具用于建立管道。首先，定义一个新类型 PipeCommand ，其有源和目的两个属性。源和目的都必须是 CommandLike 的成员。为了方便，我们还定义了 -|- 操作符。然后使 PipeCommand 成为 CommandLike 的实例。它调用第一个命令并获得输出，将其传入第二个命令。之后返回第二个命令的输出，并调用 getExitStatus 函数等待命令执行结束并检查整组命令执行之后的状态码。</p>
<p class="calibre9">最后以定义 runIO 结束。这个函数建立了需要在子进程中关闭的 FDS 列表，执行程序，显示输出，并检查其退出状态。</p>
<h2 class="calibre14"><a id="chp-20.html._624" class="calibre7 pcalibre"></a>更好的管道</h2>
<p class="calibre9">上个例子中解决了一个类似 shell 的管道系统的基本需求。但是为它加上下面这些特点之后就更好了：</p>
<blockquote class="default"></blockquote>
<blockquote class="default"><ul class="calibre30"><li class="calibre11">支持更多的 shell 语法。</li><li class="calibre11">使管道同时支持外部程序和正规 Haskell 函数，并使二者可以自由的混合使用。</li><li class="calibre11">以易于 Haskell 程序利用的方式返回标准输出和退出状态码。</li></ul></blockquote>
<p class="calibre9">幸运的是，支持这些功能的代码片段已经差不多就位了。只需要为 CommandLike 多加入几个实例，以及一些类似 runIO 的函数。下面是修订后实现了以上功能的例子代码：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch20<span class="token3">/</span>RunProcess<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span># OPTIONS_GHC <span class="token3">-</span>XDatatypeContexts #<span class="token3">-</span><span class="token">}</span>
<span class="token">{</span><span class="token3">-</span># OPTIONS_GHC <span class="token3">-</span>XTypeSynonymInstances #<span class="token3">-</span><span class="token">}</span>
<span class="token">{</span><span class="token3">-</span># OPTIONS_GHC <span class="token3">-</span>XFlexibleInstances #<span class="token3">-</span><span class="token">}</span>

module RunProcess where

import System<span class="token">.</span>Process
import Control<span class="token">.</span>Concurrent
import Control<span class="token">.</span>Concurrent<span class="token">.</span>MVar
import Control<span class="token">.</span>Exception
import System<span class="token">.</span>Posix<span class="token">.</span>Directory
import System<span class="token">.</span><span class="token5">Directory</span><span class="token">(</span>setCurrentDirectory<span class="token">)</span>
import System<span class="token">.</span>IO
import System<span class="token">.</span>Exit
import Text<span class="token">.</span>Regex
import System<span class="token">.</span>Posix<span class="token">.</span>Process
import System<span class="token">.</span>Posix<span class="token">.</span>IO
import System<span class="token">.</span>Posix<span class="token">.</span>Types
import Data<span class="token">.</span>List
import System<span class="token">.</span>Posix<span class="token">.</span><span class="token5">Env</span><span class="token">(</span>getEnv<span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> The type <span class="token1">for</span> running external commands<span class="token">.</span>  The first part
of the tuple is the program name<span class="token">.</span>  The list represents the
command<span class="token3">-</span>line parameters to pass to the command<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
type SysCommand <span class="token3">=</span> <span class="token">(</span>String<span class="token">,</span> <span class="token">[</span>String<span class="token">]</span><span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> The result of running any command <span class="token3">-</span><span class="token">}</span>
data CommandResult <span class="token3">=</span> CommandResult <span class="token">{</span>
    cmdOutput <span class="token">:</span><span class="token">:</span> IO String<span class="token">,</span>              <span class="token3">--</span> <span class="token3">^</span> IO action that yields the output
    getExitStatus <span class="token">:</span><span class="token">:</span> IO ProcessStatus    <span class="token3">--</span> <span class="token3">^</span> IO action that yields exit result
    <span class="token">}</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> The type <span class="token1">for</span> handling global lists of FDs to always close <span class="token1">in</span> the clients
<span class="token3">-</span><span class="token">}</span>
type CloseFDs <span class="token3">=</span> MVar <span class="token">[</span>Fd<span class="token">]</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Class <span class="token5">representing</span> anything that is a runnable command <span class="token3">-</span><span class="token">}</span>
class <span class="token5">CommandLike</span> a where
    <span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Given the command and a String representing input<span class="token">,</span>
         invokes the command<span class="token">.</span>  Returns a String
         representing the output of the command<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
    invoke <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> CloseFDs <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> IO CommandResult

<span class="token3">--</span> Support <span class="token1">for</span> running system commands
instance CommandLike SysCommand where
    invoke <span class="token">(</span>cmd<span class="token">,</span> args<span class="token">)</span> closefds input <span class="token3">=</span>
        <span class="token1">do</span> <span class="token3">--</span> Create two pipes<span class="token">:</span> one to handle stdin and the other
           <span class="token3">--</span> to handle stdout<span class="token">.</span>  We <span class="token1">do</span> not redirect stderr <span class="token1">in</span> this program<span class="token">.</span>
           <span class="token">(</span>stdinread<span class="token">,</span> stdinwrite<span class="token">)</span> <span class="token3">&lt;</span><span class="token3">-</span> createPipe
           <span class="token">(</span>stdoutread<span class="token">,</span> stdoutwrite<span class="token">)</span> <span class="token3">&lt;</span><span class="token3">-</span> createPipe

           <span class="token3">--</span> We add the parent FDs to this list because we always need
           <span class="token3">--</span> to close them <span class="token1">in</span> the clients<span class="token">.</span>
           addCloseFDs closefds <span class="token">[</span>stdinwrite<span class="token">,</span> stdoutread<span class="token">]</span>

           <span class="token3">--</span> Now<span class="token">,</span> grab the closed FDs list and fork the child<span class="token">.</span>
           childPID <span class="token3">&lt;</span><span class="token3">-</span> withMVar closefds <span class="token">(</span>\fds <span class="token3">-</span><span class="token3">&gt;</span>
                          forkProcess <span class="token">(</span>child fds stdinread stdoutwrite<span class="token">)</span><span class="token">)</span>

           <span class="token3">--</span> Now<span class="token">,</span> on the parent<span class="token">,</span> close the client<span class="token3">-</span>side FDs<span class="token">.</span>
           closeFd stdinread
           closeFd stdoutwrite

           <span class="token3">--</span> Write the input to the command<span class="token">.</span>
           stdinhdl <span class="token3">&lt;</span><span class="token3">-</span> fdToHandle stdinwrite
           forkIO $ <span class="token1">do</span> hPutStr stdinhdl input
                       hClose stdinhdl

           <span class="token3">--</span> Prepare to receive output from the command
           stdouthdl <span class="token3">&lt;</span><span class="token3">-</span> fdToHandle stdoutread

           <span class="token3">--</span> Set up the <span class="token1">function</span> to call when ready to wait <span class="token1">for</span> the
           <span class="token3">--</span> child to exit<span class="token">.</span>
           let waitfunc <span class="token3">=</span>
                <span class="token1">do</span> status <span class="token3">&lt;</span><span class="token3">-</span> getProcessStatus True False childPID
                   case status of
                       Nothing <span class="token3">-</span><span class="token3">&gt;</span> fail $ <span class="token4">"Error: Nothing from getProcessStatus"</span>
                       Just ps <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">do</span> removeCloseFDs closefds
                                          <span class="token">[</span>stdinwrite<span class="token">,</span> stdoutread<span class="token">]</span>
                                     <span class="token1">return</span> ps
           <span class="token1">return</span> $ CommandResult <span class="token">{</span>cmdOutput <span class="token3">=</span> hGetContents stdouthdl<span class="token">,</span>
                                   getExitStatus <span class="token3">=</span> waitfunc<span class="token">}</span>

        <span class="token3">--</span> Define what happens <span class="token1">in</span> the child process
        where child closefds stdinread stdoutwrite <span class="token3">=</span>
                <span class="token1">do</span> <span class="token3">--</span> Copy our pipes over the regular stdin<span class="token3">/</span>stdout FDs
                   dupTo stdinread stdInput
                   dupTo stdoutwrite stdOutput

                   <span class="token3">--</span> Now close the original pipe FDs
                   closeFd stdinread
                   closeFd stdoutwrite

                   <span class="token3">--</span> Close all the open FDs we inherited from the parent
                   mapM_ <span class="token">(</span>\fd <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">catch</span> <span class="token">(</span><span class="token5">closeFd</span> fd<span class="token">)</span> <span class="token">(</span>\<span class="token">(</span>SomeException e<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> <span class="token">(</span><span class="token">)</span><span class="token">)</span><span class="token">)</span> closefds

                   <span class="token3">--</span> Start the program
                   executeFile cmd True args Nothing

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> An instance of <span class="token4">'CommandLike'</span> <span class="token1">for</span> an external command<span class="token">.</span>  The String is
passed to a shell <span class="token1">for</span> evaluation and invocation<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
instance CommandLike String where
    invoke cmd closefds input <span class="token3">=</span>
        <span class="token1">do</span> <span class="token3">--</span> Use the shell given by the environment variable SHELL<span class="token">,</span>
           <span class="token3">--</span> <span class="token1">if</span> any<span class="token">.</span>  Otherwise<span class="token">,</span> use <span class="token3">/</span>bin<span class="token3">/</span>sh
           esh <span class="token3">&lt;</span><span class="token3">-</span> getEnv <span class="token4">"SHELL"</span>
           let sh <span class="token3">=</span> case esh of
                       Nothing <span class="token3">-</span><span class="token3">&gt;</span> <span class="token4">"/bin/sh"</span>
                       Just x <span class="token3">-</span><span class="token3">&gt;</span> x
           invoke <span class="token">(</span>sh<span class="token">,</span> <span class="token">[</span><span class="token4">"-c"</span><span class="token">,</span> cmd<span class="token">]</span><span class="token">)</span> closefds input

<span class="token3">--</span> Add FDs to the list of FDs that must be closed post<span class="token3">-</span>fork <span class="token1">in</span> a child
addCloseFDs <span class="token">:</span><span class="token">:</span> CloseFDs <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>Fd<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
addCloseFDs closefds newfds <span class="token3">=</span>
    modifyMVar_ closefds <span class="token">(</span>\oldfds <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> $ oldfds <span class="token3">++</span> newfds<span class="token">)</span>

<span class="token3">--</span> Remove FDs from the list
removeCloseFDs <span class="token">:</span><span class="token">:</span> CloseFDs <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>Fd<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
removeCloseFDs closefds removethem <span class="token3">=</span>
    modifyMVar_ closefds <span class="token">(</span>\fdlist <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> $ procfdlist fdlist removethem<span class="token">)</span>

    where
    procfdlist fdlist <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> fdlist
    procfdlist fdlist <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> <span class="token3">=</span> procfdlist <span class="token">(</span>removefd fdlist x<span class="token">)</span> xs

    <span class="token3">--</span> We want to remove only the first occurance ot any given fd
    removefd <span class="token">[</span><span class="token">]</span> _ <span class="token3">=</span> <span class="token">[</span><span class="token">]</span>
    removefd <span class="token">(</span>x<span class="token">:</span>xs<span class="token">)</span> fd
        <span class="token3">|</span> fd <span class="token3">==</span> x <span class="token3">=</span> xs
        <span class="token3">|</span> otherwise <span class="token3">=</span> x <span class="token">:</span> removefd xs fd

<span class="token3">--</span> Support <span class="token1">for</span> running Haskell commands
instance CommandLike <span class="token">(</span>String <span class="token3">-</span><span class="token3">&gt;</span> IO String<span class="token">)</span> where
    invoke func _ input <span class="token3">=</span>
       <span class="token1">return</span> $ CommandResult <span class="token">(</span>func input<span class="token">)</span> <span class="token">(</span><span class="token1">return</span> <span class="token">(</span>Exited ExitSuccess<span class="token">)</span><span class="token">)</span>

<span class="token3">--</span> Support pure Haskell functions by wrapping them <span class="token1">in</span> IO
instance CommandLike <span class="token">(</span>String <span class="token3">-</span><span class="token3">&gt;</span> String<span class="token">)</span> where
    invoke func <span class="token3">=</span> invoke iofunc
        where iofunc <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> IO String
              iofunc <span class="token3">=</span> <span class="token1">return</span> <span class="token">.</span> func

<span class="token3">--</span> It's also useful to operate on lines<span class="token">.</span>  Define support <span class="token1">for</span> line<span class="token3">-</span>based
<span class="token3">--</span> functions both within and without the IO monad<span class="token">.</span>

instance CommandLike <span class="token">(</span><span class="token">[</span>String<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">[</span>String<span class="token">]</span><span class="token">)</span> where
    invoke func _ input <span class="token3">=</span>
           <span class="token1">return</span> $ CommandResult linedfunc <span class="token">(</span><span class="token1">return</span> <span class="token">(</span>Exited ExitSuccess<span class="token">)</span><span class="token">)</span>
       where linedfunc <span class="token3">=</span> func <span class="token">(</span>lines input<span class="token">)</span> <span class="token3">&gt;</span><span class="token3">&gt;=</span> <span class="token">(</span><span class="token1">return</span> <span class="token">.</span> unlines<span class="token">)</span>

instance CommandLike <span class="token">(</span><span class="token">[</span>String<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>String<span class="token">]</span><span class="token">)</span> where
    invoke func <span class="token3">=</span> invoke <span class="token">(</span>unlines <span class="token">.</span> func <span class="token">.</span> lines<span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Type representing a pipe<span class="token">.</span>  A <span class="token4">'PipeCommand'</span> consists of a source
and destination part<span class="token">,</span> both of which must be instances of
<span class="token4">'CommandLike'</span><span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
data <span class="token">(</span>CommandLike src<span class="token">,</span> CommandLike dest<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span>
     PipeCommand src dest <span class="token3">=</span> PipeCommand src dest

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> A convenient <span class="token1">function</span> <span class="token1">for</span> creating a <span class="token4">'PipeCommand'</span><span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
<span class="token">(</span><span class="token3">-</span><span class="token3">|</span><span class="token3">-</span><span class="token">)</span> <span class="token">:</span><span class="token">:</span> <span class="token">(</span>CommandLike a<span class="token">,</span> CommandLike b<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> b <span class="token3">-</span><span class="token3">&gt;</span> PipeCommand a b
<span class="token">(</span><span class="token3">-</span><span class="token3">|</span><span class="token3">-</span><span class="token">)</span> <span class="token3">=</span> PipeCommand

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Make <span class="token4">'PipeCommand'</span> runnable as a command <span class="token3">-</span><span class="token">}</span>
instance <span class="token">(</span>CommandLike a<span class="token">,</span> CommandLike b<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span>
         CommandLike <span class="token">(</span>PipeCommand a b<span class="token">)</span> where
    invoke <span class="token">(</span>PipeCommand src dest<span class="token">)</span> closefds input <span class="token3">=</span>
        <span class="token1">do</span> res1 <span class="token3">&lt;</span><span class="token3">-</span> invoke src closefds input
           output1 <span class="token3">&lt;</span><span class="token3">-</span> cmdOutput res1
           res2 <span class="token3">&lt;</span><span class="token3">-</span> invoke dest closefds output1
           <span class="token1">return</span> $ CommandResult <span class="token">(</span>cmdOutput res2<span class="token">)</span> <span class="token">(</span>getEC res1 res2<span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Given two <span class="token4">'CommandResult'</span> items<span class="token">,</span> evaluate the exit codes <span class="token1">for</span>
both and then <span class="token1">return</span> a <span class="token4">"combined"</span> exit code<span class="token">.</span>  This will be ExitSuccess
<span class="token1">if</span> both exited successfully<span class="token">.</span>  Otherwise<span class="token">,</span> it will reflect the first
error encountered<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
getEC <span class="token">:</span><span class="token">:</span> CommandResult <span class="token3">-</span><span class="token3">&gt;</span> CommandResult <span class="token3">-</span><span class="token3">&gt;</span> IO ProcessStatus
getEC src dest <span class="token3">=</span>
    <span class="token1">do</span> sec <span class="token3">&lt;</span><span class="token3">-</span> getExitStatus src
       dec <span class="token3">&lt;</span><span class="token3">-</span> getExitStatus dest
       case sec of
            Exited ExitSuccess <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> dec
            x <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> x

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Different ways to get data from <span class="token4">'run'</span><span class="token">.</span>

 <span class="token3">*</span> IO <span class="token">(</span><span class="token">)</span> runs<span class="token">,</span> throws an exception on error<span class="token">,</span> and sends stdout to stdout

 <span class="token3">*</span> IO String runs<span class="token">,</span> throws an exception on error<span class="token">,</span> reads stdout into
   a buffer<span class="token">,</span> and returns it as a string<span class="token">.</span>

 <span class="token3">*</span> IO <span class="token">[</span>String<span class="token">]</span> is same as IO String<span class="token">,</span> but returns the results as lines

 <span class="token3">*</span> IO ProcessStatus runs and returns a ProcessStatus with the exit
   information<span class="token">.</span>  stdout is sent to stdout<span class="token">.</span>  Exceptions are not thrown<span class="token">.</span>

 <span class="token3">*</span> IO <span class="token">(</span>String<span class="token">,</span> ProcessStatus<span class="token">)</span> is like IO ProcessStatus<span class="token">,</span> but also
   includes a description of the last command <span class="token1">in</span> the pipe to have
   an error <span class="token">(</span>or the last command<span class="token">,</span> <span class="token1">if</span> there was no error<span class="token">)</span>

 <span class="token3">*</span> IO Int returns the exit code from a program directly<span class="token">.</span>  If a signal
   caused the command to be reaped<span class="token">,</span> returns <span class="token2">128</span> <span class="token3">+</span> SIGNUM<span class="token">.</span>

 <span class="token3">*</span> IO Bool returns True <span class="token1">if</span> the program exited normally <span class="token">(</span>exit code <span class="token2">0</span><span class="token">,</span>
   not stopped by a signal<span class="token">)</span> and False otherwise<span class="token">.</span>

<span class="token3">-</span><span class="token">}</span>
class <span class="token5">RunResult</span> a where
    <span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Runs a command <span class="token">(</span>or pipe of commands<span class="token">)</span><span class="token">,</span> with results presented
       <span class="token1">in</span> any number of different ways<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
    run <span class="token">:</span><span class="token">:</span> <span class="token">(</span>CommandLike b<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> b <span class="token3">-</span><span class="token3">&gt;</span> a

<span class="token3">--</span> <span class="token3">|</span> Utility <span class="token1">function</span> <span class="token1">for</span> use by <span class="token4">'RunResult'</span> instances
setUpCommand <span class="token">:</span><span class="token">:</span> CommandLike a <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> IO CommandResult
setUpCommand cmd <span class="token3">=</span>
    <span class="token1">do</span> <span class="token3">--</span> Initialize our closefds list
       closefds <span class="token3">&lt;</span><span class="token3">-</span> newMVar <span class="token">[</span><span class="token">]</span>

       <span class="token3">--</span> Invoke the command
       invoke cmd closefds <span class="token">[</span><span class="token">]</span>

instance RunResult <span class="token">(</span>IO <span class="token">(</span><span class="token">)</span><span class="token">)</span> where
    run cmd <span class="token3">=</span> run cmd <span class="token3">&gt;</span><span class="token3">&gt;=</span> checkResult

instance RunResult <span class="token">(</span>IO ProcessStatus<span class="token">)</span> where
    run cmd <span class="token3">=</span>
        <span class="token1">do</span> res <span class="token3">&lt;</span><span class="token3">-</span> setUpCommand cmd

           <span class="token3">--</span> Process its output
           output <span class="token3">&lt;</span><span class="token3">-</span> cmdOutput res
           putStr output

           getExitStatus res

instance RunResult <span class="token">(</span>IO Int<span class="token">)</span> where
    run cmd <span class="token3">=</span> <span class="token1">do</span> rc <span class="token3">&lt;</span><span class="token3">-</span> run cmd
                 case rc of
                   Exited <span class="token">(</span>ExitSuccess<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> <span class="token2">0</span>
                   Exited <span class="token">(</span>ExitFailure x<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> x
                   <span class="token">(</span>Terminated x _<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> <span class="token">(</span><span class="token2">128</span> <span class="token3">+</span> <span class="token">(</span>fromIntegral x<span class="token">)</span><span class="token">)</span>
                   Stopped x <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> <span class="token">(</span><span class="token2">128</span> <span class="token3">+</span> <span class="token">(</span>fromIntegral x<span class="token">)</span><span class="token">)</span>

instance RunResult <span class="token">(</span>IO Bool<span class="token">)</span> where
    run cmd <span class="token3">=</span> <span class="token1">do</span> rc <span class="token3">&lt;</span><span class="token3">-</span> run cmd
                 <span class="token1">return</span> <span class="token">(</span><span class="token">(</span>rc<span class="token">:</span><span class="token">:</span>Int<span class="token">)</span> <span class="token3">==</span> <span class="token2">0</span><span class="token">)</span>

instance RunResult <span class="token">(</span>IO <span class="token">[</span>String<span class="token">]</span><span class="token">)</span> where
    run cmd <span class="token3">=</span> <span class="token1">do</span> r <span class="token3">&lt;</span><span class="token3">-</span> run cmd
                 <span class="token1">return</span> <span class="token">(</span>lines r<span class="token">)</span>

instance RunResult <span class="token">(</span>IO String<span class="token">)</span> where
    run cmd <span class="token3">=</span>
        <span class="token1">do</span> res <span class="token3">&lt;</span><span class="token3">-</span> setUpCommand cmd

           output <span class="token3">&lt;</span><span class="token3">-</span> cmdOutput res

           <span class="token3">--</span> Force output to be buffered
           evaluate <span class="token">(</span>length output<span class="token">)</span>

           ec <span class="token3">&lt;</span><span class="token3">-</span> getExitStatus res
           checkResult ec
           <span class="token1">return</span> output

checkResult <span class="token">:</span><span class="token">:</span> ProcessStatus <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
checkResult ps <span class="token3">=</span>
    case ps of
         Exited <span class="token">(</span>ExitSuccess<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> <span class="token">(</span><span class="token">)</span>
         x <span class="token3">-</span><span class="token3">&gt;</span> fail <span class="token">(</span>show x<span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> A convenience <span class="token1">function</span><span class="token">.</span>  Refers only to the version of <span class="token4">'run'</span>
that returns @IO <span class="token">(</span><span class="token">)</span>@<span class="token">.</span>  This prevents you from having to cast to it
all the time when you <span class="token1">do</span> not care about the result of <span class="token4">'run'</span><span class="token">.</span>
<span class="token3">-</span><span class="token">}</span>
runIO <span class="token">:</span><span class="token">:</span> CommandLike a <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
runIO <span class="token3">=</span> run

<span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span>
<span class="token3">--</span> Utility Functions
<span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span><span class="token3">--</span>
cd <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
cd <span class="token3">=</span> setCurrentDirectory

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Takes a string and sends it on as standard output<span class="token">.</span>
The input to this <span class="token1">function</span> is never read<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
echo <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> String
echo inp _ <span class="token3">=</span> inp

<span class="token3">--</span> <span class="token3">|</span> Search <span class="token1">for</span> the regexp <span class="token1">in</span> the lines<span class="token">.</span>  Return those that match<span class="token">.</span>
grep <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>String<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>String<span class="token">]</span>
grep pat <span class="token3">=</span> filter <span class="token">(</span>ismatch regex<span class="token">)</span>
    where regex <span class="token3">=</span> mkRegex pat
          ismatch r inp <span class="token3">=</span> case matchRegex r inp of
                            Nothing <span class="token3">-</span><span class="token3">&gt;</span> False
                            Just _ <span class="token3">-</span><span class="token3">&gt;</span> True

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Creates the given directory<span class="token">.</span>  A value of <span class="token2">0</span>o755 <span class="token1">for</span> mode would be typical<span class="token">.</span>
An alias <span class="token1">for</span> System<span class="token">.</span>Posix<span class="token">.</span>Directory<span class="token">.</span>createDirectory<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
mkdir <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> FileMode <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
mkdir <span class="token3">=</span> createDirectory

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Remove duplicate lines from a file <span class="token">(</span>like Unix uniq<span class="token">)</span><span class="token">.</span>
Takes a String representing a file or output and plugs it through
lines and then nub to uniqify on a line basis<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
uniq <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> String
uniq <span class="token3">=</span> unlines <span class="token">.</span> nub <span class="token">.</span> lines

<span class="token3">--</span> <span class="token3">|</span> Count number of lines<span class="token">.</span>  wc <span class="token3">-</span>l
wcL<span class="token">,</span> wcW <span class="token">:</span><span class="token">:</span> <span class="token">[</span>String<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>String<span class="token">]</span>
wcL inp <span class="token3">=</span> <span class="token">[</span>show <span class="token">(</span>genericLength inp <span class="token">:</span><span class="token">:</span> Integer<span class="token">)</span><span class="token">]</span>

<span class="token3">--</span> <span class="token3">|</span> Count number of words <span class="token1">in</span> a file <span class="token">(</span>like wc <span class="token3">-</span>w<span class="token">)</span>
wcW inp <span class="token3">=</span> <span class="token">[</span>show <span class="token">(</span><span class="token">(</span>genericLength $ words $ unlines inp<span class="token">)</span> <span class="token">:</span><span class="token">:</span> Integer<span class="token">)</span><span class="token">]</span>

sortLines <span class="token">:</span><span class="token">:</span> <span class="token">[</span>String<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>String<span class="token">]</span>
sortLines <span class="token3">=</span> sort

<span class="token3">--</span> <span class="token3">|</span> Count the lines <span class="token1">in</span> the input
countLines <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> IO String
countLines <span class="token3">=</span> <span class="token1">return</span> <span class="token">.</span> <span class="token">(</span><span class="token3">++</span><span class="token">)</span> <span class="token4">"\n"</span> <span class="token">.</span> show <span class="token">.</span> length <span class="token">.</span> lines

</code></pre>
<p class="calibre9">主要改变是：</p>
<blockquote class="default"></blockquote>
<blockquote class="default"><ul class="calibre30"><li class="calibre11">String 的 CommandLike 实例，以便在 shell 中对字符串进行求值和调用。</li><li class="calibre11">String-&gt;IOString 的实例，以及其它几种相关类型的实现。这样就可以像处理命令一样处理 Haskell 函数。</li><li class="calibre11">RunResult 类型类，定义了一个 run 函数，其可以用多种不同方式返回命令的相关信息。</li><li class="calibre11">一些工具函数，提供了用 Haskell 实现的类 Unix shell 命令。</li></ul></blockquote>
<p class="calibre9">现在来试试这些新特性。首先确定一下之前例子中的命令是否还能工作。然后，使用新的类 shell 语法运行一下。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>load RunProcess<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling RunProcess       <span class="token">(</span> RunProcess<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> RunProcess<span class="token">.</span>

ghci<span class="token3">&gt;</span> runIO $ <span class="token">(</span><span class="token4">"ls"</span><span class="token">,</span> <span class="token">[</span><span class="token4">"/etc"</span><span class="token">]</span><span class="token">)</span> <span class="token3">-</span><span class="token3">|</span><span class="token3">-</span> <span class="token">(</span><span class="token4">"grep"</span><span class="token">,</span> <span class="token">[</span><span class="token4">"m.*ap"</span><span class="token">]</span><span class="token">)</span> <span class="token3">-</span><span class="token3">|</span><span class="token3">-</span> <span class="token">(</span><span class="token4">"tr"</span><span class="token">,</span> <span class="token">[</span><span class="token4">"a-z"</span><span class="token">,</span> <span class="token4">"A-Z"</span><span class="token">]</span><span class="token">)</span>
Loading package array<span class="token3">-</span><span class="token2">0.5</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package deepseq<span class="token3">-</span><span class="token2">1.3</span><span class="token2">.0</span><span class="token2">.2</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package bytestring<span class="token3">-</span><span class="token2">0.10</span><span class="token2">.4</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package containers<span class="token3">-</span><span class="token2">0.5</span><span class="token2">.5</span><span class="token2">.1</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package filepath<span class="token3">-</span><span class="token2">1.3</span><span class="token2">.0</span><span class="token2">.2</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package old<span class="token3">-</span>locale<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.6</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package time<span class="token3">-</span><span class="token2">1.4</span><span class="token2">.2</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package unix<span class="token3">-</span><span class="token2">2.7</span><span class="token2">.0</span><span class="token2">.1</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package directory<span class="token3">-</span><span class="token2">1.2</span><span class="token2">.1</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package process<span class="token3">-</span><span class="token2">1.2</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package transformers<span class="token3">-</span><span class="token2">0.3</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package mtl<span class="token3">-</span><span class="token2">2.1</span><span class="token2">.3</span><span class="token2">.1</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package regex<span class="token3">-</span>base<span class="token3">-</span><span class="token2">0.93</span><span class="token2">.2</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package regex<span class="token3">-</span>posix<span class="token3">-</span><span class="token2">0.95</span><span class="token2">.2</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package regex<span class="token3">-</span>compat<span class="token3">-</span><span class="token2">0.95</span><span class="token2">.1</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
COM<span class="token">.</span>APPLE<span class="token">.</span>SCREENSHARING<span class="token">.</span>AGENT<span class="token">.</span>LAUNCHD

ghci<span class="token3">&gt;</span> runIO $ <span class="token4">"ls /etc"</span> <span class="token3">-</span><span class="token3">|</span><span class="token3">-</span> <span class="token4">"grep 'm.*ap'"</span> <span class="token3">-</span><span class="token3">|</span><span class="token3">-</span> <span class="token4">"tr a-z A-Z"</span>
COM<span class="token">.</span>APPLE<span class="token">.</span>SCREENSHARING<span class="token">.</span>AGENT<span class="token">.</span>LAUNCHD

</code></pre>
<p class="calibre9">输入起来容易多了。试试使用 Haskell 实现的 grep 来试一下其它的新特性：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> runIO $ <span class="token4">"ls /usr/local/bin"</span> <span class="token3">-</span><span class="token3">|</span><span class="token3">-</span> grep <span class="token4">"m.*ap"</span> <span class="token3">-</span><span class="token3">|</span><span class="token3">-</span> <span class="token4">"tr a-z A-Z"</span>
DUMPCAP
MERGECAP
NMAP

ghci<span class="token3">&gt;</span> run $ <span class="token4">"ls /usr/local/bin"</span> <span class="token3">-</span><span class="token3">|</span><span class="token3">-</span> grep <span class="token4">"m.*ap"</span> <span class="token3">-</span><span class="token3">|</span><span class="token3">-</span> <span class="token4">"tr a-z A-Z"</span> <span class="token">:</span><span class="token">:</span> IO String
<span class="token4">"DUMPCAP\nMERGECAP\nNMAP\n"</span>

ghci<span class="token3">&gt;</span> run $ <span class="token4">"ls /usr/local/bin"</span> <span class="token3">-</span><span class="token3">|</span><span class="token3">-</span> grep <span class="token4">"m.*ap"</span> <span class="token3">-</span><span class="token3">|</span><span class="token3">-</span> <span class="token4">"tr a-z A-Z"</span> <span class="token">:</span><span class="token">:</span> IO <span class="token">[</span>String<span class="token">]</span>
<span class="token">[</span><span class="token4">"DUMPCAP"</span><span class="token">,</span><span class="token4">"MERGECAP"</span><span class="token">,</span><span class="token4">"NMAP"</span><span class="token">]</span>

ghci<span class="token3">&gt;</span> run $ <span class="token4">"ls /usr"</span> <span class="token">:</span><span class="token">:</span> IO String
<span class="token4">"X11\nX11R6\nbin\ninclude\nlib\nlibexec\nlocal\nsbin\nshare\nstandalone\ntexbin\n"</span>

ghci<span class="token3">&gt;</span> run $ <span class="token4">"ls /usr"</span> <span class="token">:</span><span class="token">:</span> IO Int
X11
X11R6
bin
include
lib
libexec
local
sbin
share
standalone
texbin
<span class="token2">0</span>

ghci<span class="token3">&gt;</span> runIO $ echo <span class="token4">"Line1\nHi, test\n"</span> <span class="token3">-</span><span class="token3">|</span><span class="token3">-</span> <span class="token4">"tr a-z A-Z"</span> <span class="token3">-</span><span class="token3">|</span><span class="token3">-</span> sortLines
HI<span class="token">,</span> TEST
LINE1

</code></pre>
<h2 class="calibre14"><a id="chp-20.html._1036" class="calibre7 pcalibre"></a>关于管道，最后说几句</h2>
<p class="calibre9">我们开发了一个精巧的系统。前面时醒过， POSIX 有时会很复杂。另外要强调一下：要始终注意确保先将这些函数返回的字符串求值，然后再尝试获取子进程的退出状态码。子进程经常要等待写出其所有输出之后才能退出，如果搞错了获取输出和退出状态码的顺序，你的程序会挂住。</p>
<p class="calibre9">本章中，我们从零开始开发了一个精简版的 HSH 。如果你希望使程序具有这样类 shell 的功能，我们推荐使用 HSH 而非上面开发的例子，因为 HSH 的实现更加优化。HSH 还有一个数量庞大的工具函数集和更多功能，但其背后的代码也更加庞大和复杂。其实例子中很多工具函数的代码我们是直接从 HSH 抄过来的。可以从 <a href="http://software.complete.org" target="_blank" class="calibre7 pcalibre">http://software.complete.org</a>/hsh访问 HSH 的源码。</p>
<p class="calibre9">注</p>
<table class="calibre21"><thead class="calibre22"><tr class="calibre23"><th class="calibre24"><a href="#chp-20.html." class="calibre7 pcalibre">[43]</a></th><th class="calibre24">也有一个 system 函数，接受单个字符串为参数，并将其传入 shell 解析。我们推荐使用 rawSystem ，因为某些字符在 shell 中具有特殊含义，可能会导致安全隐患或者意外的行为。</th></tr></thead><tbody class="calibre25"></tbody></table>
<table class="calibre21"><thead class="calibre22"><tr class="calibre23"><th class="calibre24"><a href="#chp-20.html." class="calibre7 pcalibre">[44]</a></th><th class="calibre24">可能有人会注意到 UTC 定义了不规则的闰秒。在 Haskell 使用的 POSIX 标准中，规定了在其表示的时间中，每天必须都是精确的 86,400 秒，所以在执行日常计算时无需担心闰秒。精确的处理闰秒依赖于系统而且复杂，不过通常其可以被解释为一个“长秒”。这个问题大体上只是在执行精确的亚秒级计算时才需要关心。</th></tr></thead><tbody class="calibre25"></tbody></table>
<table class="calibre21"><thead class="calibre22"><tr class="calibre23"><th class="calibre24"><a href="#chp-20.html." class="calibre7 pcalibre">[45]</a></th><th class="calibre24">POSIX 系统上通常无法设置 ctime 。</th></tr></thead><tbody class="calibre25"></tbody></table>
<table class="calibre21"><thead class="calibre22"><tr class="calibre23"><th class="calibre24"><a href="#chp-20.html." class="calibre7 pcalibre">[46]</a></th><th class="calibre24">线程是一个主要例外，其不会被复制，所以说“几乎”。</th></tr></thead><tbody class="calibre25"></tbody></table>
<table class="calibre21"><thead class="calibre22"><tr class="calibre23"><th class="calibre24"><a href="#chp-20.html." class="calibre7 pcalibre">[47]</a></th><th class="calibre24">Haskell 社区对这个扩展支持得很好。 Hugs 用户可以通过 hugs-98+o 使用。</th></tr></thead><tbody class="calibre25"></tbody></table>
<table class="calibre26"><thead class="calibre22"><tr class="calibre23"><th class="calibre24"><a href="#chp-20.html." class="calibre7 pcalibre">[48]</a></th><th class="calibre24">Haskell 的 HSH 库提供了与此相近的 API ，使用了更高效（也更复杂）的机构将外部进程使用管道直接连接起来，没有要传给 Haskell 处理的数据。shell 采用了相同的方法，而且这样可以降低处理管道的 CPU 负载。</th></tr></thead><tbody class="calibre25"></tbody></table>
</div></div></div></div></div></div>
<div id="chp-21.html"><div class="calibre">
<div id="chp-21.html.main" class="calibre1"><div class="root"><div class="article"><h1 class="article-head" id="chp-21.html.calibre_toc_16">第二十一章：数据库的使用</h1><div class="article-body"><h1 class="calibre6"><a id="chp-21.html._0" class="calibre7 pcalibre"></a>第二十一章：数据库的使用</h1>
<p class="calibre9">网上论坛、播客抓取器（podcatchers）甚至备份程序通常都会使用数据库进行持久化储存。基于 SQL 的数据库非常常见：这种数据库具有速度快、伸缩性好、可以通过网络进行操作等优点，它们通常会负责处理加锁和事务，有些数据库甚至还提供了故障恢复（failover）功能以提高应用程序的冗余性（redundancy）。市面上的数据库有很多不同的种类：既有 Oracle 这样大型的商业数据库，也有 PostgreSQL 、 MySQL 这样的开源引擎，甚至还有 Sqlite 这样的可嵌入引擎。</p>
<p class="calibre9">因为数据库是如此的重要，所以 Haskell 也必须对数据库进行支持。本章将介绍其中一个与数据库进行互动的 Haskell 框架，并使用这个框架去构建一个播客下载器（podcast downloader），本书的 23 章还会对这个博客下载器做进一步的扩展。</p>
<h2 class="calibre14"><a id="chp-21.html.HDBC__6" class="calibre7 pcalibre"></a>HDBC 简介</h2>
<p class="calibre9">数据库引擎位于数据库栈（stack）的最底层，引擎负责将数据实际地储存到硬盘里面，常见的数据库引擎有 PostgreSQL 、 MySQL 和 Oracle 。</p>
<p class="calibre9">大多数现代化的数据库引擎都支持 SQL ，也即是结构化查询语言（Structured Query Language），并将这种语言用作读取和写入关系式数据库的标准方式。不过本书并不会提供 SQL 或者关系式数据库管理方面的教程<a href="#chp-21.html." class="calibre7 pcalibre">[49]</a>。</p>
<table class="calibre21"><thead class="calibre22"><tr class="calibre23"><th class="calibre24"><a href="#chp-21.html." class="calibre7 pcalibre">[49]</a></th><th class="calibre24">O'Reilly 出版的《Learning SQL and SQL in a Nutshell》对于没有 SQL 经验的读者来说可能会有所帮助。</th></tr></thead><tbody class="calibre25"></tbody></table>
<p class="calibre9">在拥有了支持 SQL 的数据库引擎之后，用户还需要寻找一种方法与引擎进行通信。虽然每个数据库都有自己的独有协议，但是因为各个数据库处理的 SQL 几乎都是相同的，所以通过为不同的协议提供不同的驱动，以此来创建一个通用的接口是完全可以做到的。</p>
<p class="calibre9">Haskell 有几种不同的数据库框架可用，其中某些框架在其他框架的基础上提供了更高层次的抽象，而本章将对 HDBC —— 也即是 Haskell DataBase Connectivity 系统进行介绍。通过 HDBC ，用户可以在只需进行少量修改甚至无需进行修改的情况下，访问储存在任意 SQL 数据库里面的数据<a href="#chp-21.html." class="calibre7 pcalibre">[50]</a>。即使你并不需要更换底层的数据引擎，由多个驱动构成的 HDBC 系统也使得你在单个接口上面有更多选择可用。</p>
<table class="calibre21"><thead class="calibre22"><tr class="calibre23"><th class="calibre24"><a href="#chp-21.html." class="calibre7 pcalibre">[50]</a></th><th class="calibre24">假设你只能使用标准的 SQL 。</th></tr></thead><tbody class="calibre25"></tbody></table>
<p class="calibre9">HSQL 是 Haskell 的另一个数据库抽象库，它与 HDBC 具有相似的构想。除此之外，Haskell 还有一个名为 HaskellDB 的高层次框架，这个框架可以运行在 HDBC 或是 HSQL 之上，它被设计于用来为程序员隔离处理 SQL 时的相关细节。因为 HaskellDB 的设计无法处理一些非常常见的数据库访问模式，所以它并未被广泛引用。最后，Takusen 是一个使用左折叠（left fold）方式从数据库里面读取数据的框架。</p>
<h2 class="calibre14"><a id="chp-21.html._HDBC__24" class="calibre7 pcalibre"></a>安装 HDBC 和驱动</h2>
<p class="calibre9">为了使用 HDBC 去连给定的数据库，用户至少需要用到两个包：一个包是 HDBC 的通用接口，而另一个包则是针对给定数据库的驱动。HDBC 包和所有其他驱动都可以通过 <a href="http://hackage.haskell.org/" target="_blank" class="calibre7 pcalibre">Hackage</a> [<a href="http://hackage.haskell.org/" target="_blank" class="calibre7 pcalibre">http://hackage.haskell.org/</a>]<a href="#chp-21.html." class="calibre7 pcalibre">[51]</a>获得，本章将使用 1.1.3 版本的 HDBC 作为示例。</p>
<table class="calibre21"><thead class="calibre22"><tr class="calibre23"><th class="calibre24"><a href="#chp-21.html." class="calibre7 pcalibre">[51]</a></th><th class="calibre24">想要了解更多关于安装 Haskell 软件的相关信息，请阅读本书的《安装 Haskell 软件》一节。</th></tr></thead><tbody class="calibre25"></tbody></table>
<p class="calibre9">除了 HDBC 包之外，用户还需要准备数据库后端和数据库驱动。本章会使用 Sqlite 3 作为数据库后端，这个数据库是一个嵌入式数据库，因此它不需要独立的服务器，并且也非常容易设置。很多操作系统本身就内置了 Sqlite 3 ，如果你的系统里面没有提供这一数据库，那么你可以到 <a href="http://www.sqlite.org/" target="_blank" class="calibre7 pcalibre">http://www.sqlite.org/</a> 里面进行下载。HDBC 的主页上面列出了指向已有 HDBC 后端驱动的链接，针对 Sqlite 3 的驱动也可以通过 Hackage 下载到。</p>
<p class="calibre9">如果读者打算使用 HDBC 去处理其他数据库，那么可以在 <a href="http://software.complete.org/hdbc/wiki/KnownDrivers" target="_blank" class="calibre7 pcalibre">http://software.complete.org/hdbc/wiki/KnownDrivers</a> 查看 HDBC 已有的驱动：上面展示的 ODBC 绑定（binding）基本上可以让你在任何平台（Windows、POSIX等等）上面连接任何数据库；针对 PostgreSQL 的绑定也是存在的；而 MySQL 同样可以通过 ODBC 绑定进行支持，具体的信息可以在 <a href="http://software.complete.org/static/hdbc-odbc/doc/HDBC-odbc/" target="_blank" class="calibre7 pcalibre">HDBC-ODBC API 文档</a> [<a href="http://software.complete.org/static/hdbc-odbc/doc/HDBC-odbc/" target="_blank" class="calibre7 pcalibre">http://software.complete.org/static/hdbc-odbc/doc/HDBC-odbc/</a>]里面找到。</p>
<h2 class="calibre14"><a id="chp-21.html._35" class="calibre7 pcalibre"></a>连接数据库</h2>
<p class="calibre9">连接至数据库需要用到数据库后端驱动提供的连接函数。每个数据库都有自己独特的连接方法。用户通常只会在初始化连接的时候直接调用从后端驱动模块载入的函数。</p>
<p class="calibre9">数据库连接函数会返回一个数据库连接，不同驱动的数据库连接类型可能并不相同，但它们总是 IConnection 类型类的一个实例，并且所有数据库操作函数都能够与这种类型的实例进行协作。</p>
<p class="calibre9">在完成了与数据库的通信指挥，用户只要调用 disconnect 函数就可以断开与数据库的连接。以下代码展示了怎样去连接一个 Sqlite 数据库：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>module Database<span class="token">.</span>HDBC Database<span class="token">.</span>HDBC<span class="token">.</span>Sqlite3

ghci<span class="token3">&gt;</span> conn <span class="token3">&lt;</span><span class="token3">-</span> connectSqlite3 <span class="token4">"test1.db"</span>
Loading package array<span class="token3">-</span><span class="token2">0.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package containers<span class="token3">-</span><span class="token2">0.1</span><span class="token2">.0</span><span class="token2">.1</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package bytestring<span class="token3">-</span><span class="token2">0.9</span><span class="token2">.0</span><span class="token2">.1</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package old<span class="token3">-</span>locale<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package old<span class="token3">-</span>time<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package mtl<span class="token3">-</span><span class="token2">1.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package HDBC<span class="token3">-</span><span class="token2">1.1</span><span class="token2">.5</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package HDBC<span class="token3">-</span>sqlite3<span class="token3">-</span><span class="token2">1.1</span><span class="token2">.4</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>

ghci<span class="token3">&gt;</span> <span class="token">:</span>type conn
conn <span class="token">:</span><span class="token">:</span> Connection

ghci<span class="token3">&gt;</span> disconnect conn

</code></pre>
<h2 class="calibre14"><a id="chp-21.html._63" class="calibre7 pcalibre"></a>事务</h2>
<p class="calibre9">大部分现代化 SQL 数据库都具有事务的概念。事务可以确保一项修改的所有组成部分都会被实现，又或者全部都不实现。更进一步来说，事务可以避免访问相同数据库的多个进程看见正在进行的修改动作所产生的不完整数据。</p>
<p class="calibre9">大多数数据库都要求用户通过显式的提交操作来将所有修改储存到硬盘上面，又或者在“自动提交”模式下运行：这种模式在每一条语句的后面都会进行一次隐式的提交。“自动提交”模式可能会给不熟悉事务数据库的程序员带来一些方便，但它对于那些真正想要执行多条语句事务的人来说却是一个阻碍。</p>
<p class="calibre9">HDBC 有意地不对自动提交模式进行支持。当用户在修改数据库的数据之后，它必须显式地将修改提交到硬盘上面。有两种方法可以在 HDBC 里面做到这件事：第一种方法就是在准备好将数据写入到硬盘的时候，调用 commit 函数；而另一种方法则是将修改数据的代码包裹到 withTransaction 函数里面。withTransaction 会在被包裹的函数成功执行之后自动执行提交操作。</p>
<p class="calibre9">在将数据写入到数据库里面的时候，可能会出现问题。也许是因为数据库出错了，又或者数据库发现正在提交的数据出现了问题。在这种情况下，用户可以“回滚”事务进行的修改：回滚动作会撤销最近一次提交或是最近一次回滚之后发生的所有修改。在 HDBC 里面，你可以通过 rollback 函数来进行回滚。如果你使用 withTransaction 函数来包裹事务，那么函数将在事务发生异常时自动进行回滚。</p>
<p class="calibre9">要记住，回滚操作只会撤销掉最近一次 commit 函数、 rollback 函数或者 withTransaction 函数引发的修改。数据库并不会像版本控制系统那样记录全部历史信息。本章稍后将展示一些 commit 函数的使用示例。</p>
<h2 class="calibre14"><a id="chp-21.html._75" class="calibre7 pcalibre"></a>简单的查询示例</h2>
<p class="calibre9">最简单的 SQL 查询语句都是一些不返回任何数据的语句，这些查询可以用于创建表、插入数据、删除数据、又或者设置数据库的参数。</p>
<p class="calibre9">run 函数是向数据库发送查询的最基本的函数，这个函数接受三个参数，它们分别是一个 IConnection 实例、一个表示查询的 String 以及一个由列表组成的参数。以下代码展示了如何使用这个函数去将一些数据储存到数据库里面。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>module Database<span class="token">.</span>HDBC Database<span class="token">.</span>HDBC<span class="token">.</span>Sqlite3

ghci<span class="token3">&gt;</span> conn <span class="token3">&lt;</span><span class="token3">-</span> connectSqlite3 <span class="token4">"test1.db"</span>
Loading package array<span class="token3">-</span><span class="token2">0.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package containers<span class="token3">-</span><span class="token2">0.1</span><span class="token2">.0</span><span class="token2">.1</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package bytestring<span class="token3">-</span><span class="token2">0.9</span><span class="token2">.0</span><span class="token2">.1</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package old<span class="token3">-</span>locale<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package old<span class="token3">-</span>time<span class="token3">-</span><span class="token2">1.0</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package mtl<span class="token3">-</span><span class="token2">1.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package HDBC<span class="token3">-</span><span class="token2">1.1</span><span class="token2">.5</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package HDBC<span class="token3">-</span>sqlite3<span class="token3">-</span><span class="token2">1.1</span><span class="token2">.4</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>

ghci<span class="token3">&gt;</span> run conn <span class="token4">"CREATE TABLE test (id INTEGER NOT NULL, desc VARCHAR(80))"</span> <span class="token">[</span><span class="token">]</span>
<span class="token2">0</span>

ghci<span class="token3">&gt;</span> run conn <span class="token4">"INSERT INTO test (id) VALUES (0)"</span> <span class="token">[</span><span class="token">]</span>
<span class="token2">1</span>

ghci<span class="token3">&gt;</span> commit conn

ghci<span class="token3">&gt;</span> disconnect conn

</code></pre>
<p class="calibre9">在连接到数据库之后，程序首先创建了一个名为 test 的表，接着向表里面插入了一个行。最后，程序将修改提交到数据库，并断开与数据库的连接。记住，如果程序不调用 commit 函数，那么修改将不会被写入到数据库里面。</p>
<p class="calibre9">run 函数返回因为查询语句而被修改的行数量。在上面展示的代码里面，第一个查询只是创建一个表，它并没有修改任何行；而第二个查询则向表里面插入了一个行，因此 run 函数返回了数字 1 。</p>
<h2 class="calibre14"><a id="chp-21.html.SqlValue_110" class="calibre7 pcalibre"></a>SqlValue</h2>
<p class="calibre9">在继续讨论后续内容之前，我们需要先了解一种由 HDBC 引入的数据类型：SqlValue 。因为 Haskell 和 SQL 都是强类型系统，所以 HDBC 会尝试尽可能地保留类型信息。与此同时，Haskell 和 SQL 类型并不是一一对应的。更进一步来说，日期和字符串里面的特殊字符这样的东西，在每个数据库里面的表示方法都是不相同的。</p>
<p class="calibre9">SqlValue 类型具有 SqlString 、 SqlBool 、 SqlNull 、 SqlInteger 等多个构造器，用户可以通过使用这些构造器，在传给数据库的参数列表里面表示各式各样不同类型的数据，并且仍然能够将这些数据储存到一个列表里面。除此之外，SqlValue 还提供了 toSql 和 fromSql 这样的常用函数。如果你非常关心数据的精确表示的话，那么你还是可以在有需要的时候，手动地构造 SqlValue 数据。</p>
<h2 class="calibre14"><a id="chp-21.html._116" class="calibre7 pcalibre"></a>查询参数</h2>
<p class="calibre9">HDBC 和其他数据库一样，都支持可替换的查询参数。使用可替换参数主要有几个好处：它可以预防 SQL 注射攻击、避免因为输入里面包含特殊字符而导致的问题、提升重复执行相似查询时的性能、并通过查询语句实现简单且可移植的数据插入操作。</p>
<p class="calibre9">假设我们想要将上千个行插入到新的表 test 里面，那么我们可能会执行像 INSERTINTOtestVALUES(0,'zero') 和 INSERTINTOtestVALUES(1,'one') 这样的查询上千次，这使得数据库必须独立地分析每条 SQL 语句。但如果我们将被插入的两个值替换为占位符，那么服务器只需要对 SQL 查询进行一次分析，然后就可以通过重复地执行这个查询来处理不同的数据了。</p>
<p class="calibre9">使用可替换参数的第二个原因和特殊字符有关。因为 SQL 使用单引号表示域（field）的末尾，所以如果我们想要插入字符串 "Idon'tlike1" ，那么大多数 SQL 数据库都会要求我们把这个字符串写成 Idon''tlike1' ，并且不同的特殊字符（比如反斜杠符号）在不同的数据库里面也会需要不同的转移规则。但是只要使用 HDBC ，它就会帮你自动完成所有转义动作，以下展示的代码就是一个例子：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> conn <span class="token3">&lt;</span><span class="token3">-</span> connectSqlite3 <span class="token4">"test1.db"</span>

ghci<span class="token3">&gt;</span> run conn <span class="token4">"INSERT INTO test VALUES (?, ?)"</span> <span class="token">[</span>toSql <span class="token2">0</span><span class="token">,</span> toSql <span class="token4">"zero"</span><span class="token">]</span>
<span class="token2">1</span>

ghci<span class="token3">&gt;</span> commit conn

ghci<span class="token3">&gt;</span> disconnect conn

</code></pre>
<p class="calibre9">在这个示例里面，INSERT 查询包含的问号是一个占位符，而跟在占位符后面的就是要传递给占位符的各个参数。因为 run 函数的第三个参数接受的是 SqlValue 组成的列表，所以我们使用了 toSql 去将列表中的值转换为 SqlValue 。HDBC 会根据目前使用的数据库，自动地将 String"zero" 转换为正确的表示方式。</p>
<p class="calibre9">在插入大量数据的时候，可替换参数实际上并不会带来任何性能上的提升。因此，我们需要对创建 SQL 查询的过程做进一步的控制，具体的方法在接下来的一节里面就会进行讨论。</p>
<p class="calibre9">Note</p>
<p class="calibre9">使用可替换参数</p>
<p class="calibre9">当服务器期望在查询语句的指定部分看见一个值的时候，用户才能使用可替换参数：比如在执行 SELECT 语句的 WHERE 子句时就可以使用可替换参数；又或者在执行 INSERT 语句的时候就可以把要插入的值设置为可替换参数；但执行 run"SELECT*from?"[toSql"tablename"] 是无法运行的。这是因为表的名字并非一个值，所以大多数数据库都不允许这种语法。因为在实际中很少人会使用这种方式去替换一个不是值的事物，所以这并不会带来什么大的问题。</p>
<h2 class="calibre14"><a id="chp-21.html._146" class="calibre7 pcalibre"></a>预备语句</h2>
<p class="calibre9">HDBC 定义了一个 prepare 函数，它可以预先准备好一个 SQL 查询，但是并不将查询语句跟具体的参数绑定。prepare 函数返回一个 Statement 值来表示已编译的查询。</p>
<p class="calibre9">在拥有了 Statement 值之后，用户就可以对它调用一次或多次 execute 函数。在对一个会返回数据的查询执行 execute 函数之后，用户可以使用任意的获取函数去取得查询所得的数据。诸如 run 和 quickQuery' 这样的函数都会在内部使用查询语句和 execute 函数；为了让用户可以更快捷妥当地执行常见的任务，像是 run 和 quickQuery' 这样的函数都会在内部使用 Statement 值和 execute 函数。当用户需要对查询的具体执行过程有更多的控制时，就可以考虑使用 Statement 而不是 run 函数。</p>
<p class="calibre9">以下代码展示了如何通过 Statement 值，在只使用一条查询的情况下插入多个值：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> conn <span class="token3">&lt;</span><span class="token3">-</span> connectSqlite3 <span class="token4">"test1.db"</span>

ghci<span class="token3">&gt;</span> stmt <span class="token3">&lt;</span><span class="token3">-</span> prepare conn <span class="token4">"INSERT INTO test VALUES (?, ?)"</span>

ghci<span class="token3">&gt;</span> execute stmt <span class="token">[</span>toSql <span class="token2">1</span><span class="token">,</span> toSql <span class="token4">"one"</span><span class="token">]</span>
<span class="token2">1</span>

ghci<span class="token3">&gt;</span> execute stmt <span class="token">[</span>toSql <span class="token2">2</span><span class="token">,</span> toSql <span class="token4">"two"</span><span class="token">]</span>
<span class="token2">1</span>

ghci<span class="token3">&gt;</span> execute stmt <span class="token">[</span>toSql <span class="token2">3</span><span class="token">,</span> toSql <span class="token4">"three"</span><span class="token">]</span>
<span class="token2">1</span>

ghci<span class="token3">&gt;</span> execute stmt <span class="token">[</span>toSql <span class="token2">4</span><span class="token">,</span> SqlNull<span class="token">]</span>
<span class="token2">1</span>

ghci<span class="token3">&gt;</span> commit conn

ghci<span class="token3">&gt;</span> disconnect conn

</code></pre>
<p class="calibre9">在这段代码里面，我们创建了一个预备语句并使用 stmt 函数去调用它。我们一共执行了那个语句四次，每次都向它传递了不同的参数，这些参数会被用于替换原有查询字符串中的问号。在代码的最后，我们提交了修改并断开数据库。</p>
<p class="calibre9">为了方便地重复执行同一个预备语句，HDBC 还提供了 executeMany 函数，这个函数接受一个由多个数据行组成的列表作为参数，而列表中的数据行就是需要调用预备语句的数据行。正如以下代码所示：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> conn <span class="token3">&lt;</span><span class="token3">-</span> connectSqlite3 <span class="token4">"test1.db"</span>

ghci<span class="token3">&gt;</span> stmt <span class="token3">&lt;</span><span class="token3">-</span> prepare conn <span class="token4">"INSERT INTO test VALUES (?, ?)"</span>

ghci<span class="token3">&gt;</span> executeMany stmt <span class="token">[</span><span class="token">[</span>toSql <span class="token2">5</span><span class="token">,</span> toSql <span class="token4">"five's nice"</span><span class="token">]</span><span class="token">,</span> <span class="token">[</span>toSql <span class="token2">6</span><span class="token">,</span> SqlNull<span class="token">]</span><span class="token">]</span>

ghci<span class="token3">&gt;</span> commit conn

ghci<span class="token3">&gt;</span> disconnect conn

</code></pre>
<p class="calibre9">Note</p>
<p class="calibre9">更高效的查询执行方法</p>
<p class="calibre9">在服务器上面，大多数数据库都会对 executeMany 函数进行优化，使得查询字符串只会被编译一次而不是多次。<a href="#chp-21.html." class="calibre7 pcalibre">[52]</a>在一次插入大量数据的时候，这种优化可以带来极为有效的性能提升。有些数据库还可以将这种优化应用到执行查询语句上面，并并非所有数据库都能做到这一点。</p>
<table class="calibre21"><thead class="calibre22"><tr class="calibre23"><th class="calibre24"><a href="#chp-21.html." class="calibre7 pcalibre">[52]</a></th><th class="calibre24">对于不支持这一优化的数据库，HDBC 会通过模拟这一行为来为用户提供一致的 API ，以便执行重复的查询。</th></tr></thead><tbody class="calibre25"></tbody></table>
<h2 class="calibre14"><a id="chp-21.html._203" class="calibre7 pcalibre"></a>读取结果</h2>
<p class="calibre9">本章在前面已经介绍过如何通过查询语句，将数据插入到数据库；在接下来的内容中，我们将学习从数据库里面获取数据的方法。quickQuery' 函数的类型和 run 函数非常相似，只不过 quickQuery' 函数返回的是一个由查询结果组成的列表而不是被改动的行数量。quickQuery' 函数通常与 SELECT 语句一起使用，正如以下代码所示：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> conn <span class="token3">&lt;</span><span class="token3">-</span> connectSqlite3 <span class="token4">"test1.db"</span>

ghci<span class="token3">&gt;</span> quickQuery' conn <span class="token4">"SELECT * from test where id &lt; 2"</span> <span class="token">[</span><span class="token">]</span>
<span class="token">[</span><span class="token">[</span>SqlString <span class="token4">"0"</span><span class="token">,</span>SqlNull<span class="token">]</span><span class="token">,</span><span class="token">[</span>SqlString <span class="token4">"0"</span><span class="token">,</span>SqlString <span class="token4">"zero"</span><span class="token">]</span><span class="token">,</span><span class="token">[</span>SqlString <span class="token4">"1"</span><span class="token">,</span>SqlString <span class="token4">"one"</span><span class="token">]</span><span class="token">]</span>

ghci<span class="token3">&gt;</span> disconnect conn

</code></pre>
<p class="calibre9">正如之前展示过的一样，quickQuery' 函数能够接受可替换参数。上面的代码没有使用任何可替换参数，所以在调用 quickQuery' 的时候，我们没有在函数调用的末尾给定任何的可替换值。quickQuery' 返回一个由行组成的列表，其中每个行都会被表示为 [SqlValue] ，而行里面的值会根据数据库返回时的顺序进行排列。在有需要的时候，用户可以使用 fromSql 可以将这些值转换为普通的 Haskell 类型。</p>
<p class="calibre9">因为 quickQuery' 的输出有一些难读，我们可以对上面的示例进行一些扩展，将它的结果格式化得更美观一些。以下代码展示了对结果进行格式化的具体方法：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch21<span class="token3">/</span>query<span class="token">.</span>hs
import Database<span class="token">.</span>HDBC<span class="token">.</span>Sqlite3 <span class="token">(</span>connectSqlite3<span class="token">)</span>
import Database<span class="token">.</span>HDBC

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> 定义一个函数，它接受一个表示要获取的最大 id 值作为参数。
函数会从 test 数据库里面获取所有匹配的行，并以一种美观的方式将它们打印到屏幕上面。 <span class="token3">-</span><span class="token">}</span>
query <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
query maxId <span class="token3">=</span>
    <span class="token1">do</span> <span class="token3">--</span> 连接数据库
        conn <span class="token3">&lt;</span><span class="token3">-</span> connectSqlite3 <span class="token4">"test1.db"</span>

        <span class="token3">--</span> 执行查询并将结果储存在 r 里面
        r <span class="token3">&lt;</span><span class="token3">-</span> quickQuery' conn
            <span class="token4">"SELECT id, desc from test where id &lt;= ? ORDER BY id, desc"</span>
            <span class="token">[</span>toSql maxId<span class="token">]</span>

        <span class="token3">--</span> 将每个行转换为 String
        let stringRows <span class="token3">=</span> map convRow r

        <span class="token3">--</span> 打印行
        mapM_ putStrLn stringRows

        <span class="token3">--</span> 断开与服务器之间的连接
        disconnect conn

    where convRow <span class="token">:</span><span class="token">:</span> <span class="token">[</span>SqlValue<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> String
        convRow <span class="token">[</span>sqlId<span class="token">,</span> sqlDesc<span class="token">]</span> <span class="token3">=</span>
            show intid <span class="token3">++</span> <span class="token4">": "</span> <span class="token3">++</span> desc
            where intid <span class="token3">=</span> <span class="token">(</span>fromSql sqlId<span class="token">)</span><span class="token">:</span><span class="token">:</span>Integer
                desc <span class="token3">=</span> case fromSql sqlDesc of
                            Just x <span class="token3">-</span><span class="token3">&gt;</span> x
                            Nothing <span class="token3">-</span><span class="token3">&gt;</span> <span class="token4">"NULL"</span>
        convRow x <span class="token3">=</span> fail $ <span class="token4">"Unexpected result: "</span> <span class="token3">++</span> show x

</code></pre>
<p class="calibre9">这个程序所做的工作和本书之前展示过的 <strong class="calibre12">ghci</strong> 示例差不多，唯一的区别就是新添加了一个 convRow 函数。这个函数接受来自数据库行的数据，并将它转换为一个易于打印的 String 值。</p>
<p class="calibre9">注意，这个程序会直接通过 fromSql 取出 intid 值，但是在处理 fromSqlsqlDesc 的时候却使用了 MaybeString 。不知道你是否还记得，我们在定义表的时候，曾经将表的第一列设置为不准包含 NULL 值，但是第二列却没有进行这样的设置。所以，程序不需要担心第一列是否会包含 NULL 值，只要对第二行进行处理就可以了。虽然我们也可以使用 fromSql 去将第二行的值直接转换为 String ，但是这样一来的话，程序只要遇到 NULL 值就会出现异常。因此，我们需要把 SQL 的 NULL 转换为字符串 "NULL" 。虽然这个值在打印的时候可能会与字符串 'NULL' 出现混淆，但对于这个例子来说，这样的问题还是可以接受的。让我们尝试在 <strong class="calibre12">ghci</strong> 里面调用这个函数：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>load query<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> query<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>

ghci<span class="token3">&gt;</span> query <span class="token2">2</span>
<span class="token2">0</span><span class="token">:</span> NULL
<span class="token2">0</span><span class="token">:</span> zero
<span class="token2">1</span><span class="token">:</span> one
<span class="token2">2</span><span class="token">:</span> two

</code></pre>
<h2 class="calibre14"><a id="chp-21.html._275" class="calibre7 pcalibre"></a>使用语句进行数据读取操作</h2>
<p class="calibre9">正如前面的《预备语句》一节所说，用户可以使用预备语句进行读取操作，并且在一些环境下，使用不同的方法从这些语句里面读取出数据将是一件非常有用的事情。像 run 、 quickQuery' 这样的常用函数实际上都是使用语句去完成任务的。</p>
<p class="calibre9">为了创建一个执行读取操作的预备语句，用户只需要像之前执行写入操作那样使用 prepare 函数来创建预备语句，然后使用 execute 去执行那个预备语句就可以了。在语句被执行之后，用户就可以使用各种不同的函数去读取语句中的数据。fetchAllRows' 函数和 quickQuery' 函数一样，都返回 [[SqlValue]] 类型的值。除此之外，还有一个名为 sFetchAllRows' 的函数，它在返回每个列的数据之前，会先将它们转换为 MaybeString 。最后，fetchAllRowsAL' 函数对于每个列返回一个 (String,SqlValue) 二元组，其中 String 类型的值是数据库返回的列名。本章接下来的《数据库元数据》一节还会介绍其他获取列名的方法。</p>
<p class="calibre9">通过 fetchRow 函数，用户可以每次只读取一个行上面的数据，这个函数会返回 IO(Maybe[SqlValue]) 类型的值：当所有行都已经被读取了之后，函数返回 Nothing ；如果还有尚未读取的行，那么函数返回一个行。</p>
<h2 class="calibre14"><a id="chp-21.html._283" class="calibre7 pcalibre"></a>惰性读取</h2>
<p class="calibre9">前面的《惰性I/O》一节曾经介绍过如何对文件进行惰性 I/O 操作，同样的方法也可以用于读取数据库中的数据，并且在处理可能会返回大量数据的查询时，这种特性将是非常有用的。通过惰性地读取数据，用户可以继续使用 fetchAllRows 这样的方便的函数，不必再在行数据到达时手动地读取数据。通过以谨慎的方式使用数据，用户可以避免将所有结构都缓存到内存里面。</p>
<p class="calibre9">不过要注意的是，针对数据库的惰性读取比针对文件的惰性读取要负责得多。用户在以惰性的方式读取完整个文件之后，文件就会被关闭，不会留下什么麻烦的事情。另一方面，当用户以惰性的方式从数据库读取完数据之后，数据库的连接仍然处于打开状态，以便用户继续执行其他操作。有些数据库甚至支持同时发送多个查询，所以 HDBC 是无法在用户完成一次惰性读取之后就关闭连接的。</p>
<p class="calibre9">在使用惰性读取的时候，有一点是非常重要的：在尝试关闭连接或者执行一个新的查询之前，一定要先将整个数据集读取完。我们推荐你使用严格（strict）函数又或者以一行接一行的方式进行处理，从而尽量避免惰性读取带来的复杂的交互行为。</p>
<p class="calibre9">Tip</p>
<p class="calibre9">如果你是刚开始使用 HDBC ，又或者对惰性读取的概念并不熟悉，但是又需要读取大量数据，那么可以考虑通过反复调用 fetchRow 来获取数据。这是因为惰性读取虽然是一种非常强大而且有用的工具，但是正确地使用它并不是那么容易的。</p>
<p class="calibre9">要对数据库进行惰性读取，只需要使用不带单引号版本的数据库函数就可以了。比如 fetchAllRows 就是 fetchAllRows' 的惰性读取版本。惰性函数的类型和对应的严格版本函数的类型一样。以下代码展示了一个惰性读取示例：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> conn <span class="token3">&lt;</span><span class="token3">-</span> connectSqlite3 <span class="token4">"test1.db"</span>

ghci<span class="token3">&gt;</span> stmt <span class="token3">&lt;</span><span class="token3">-</span> prepare conn <span class="token4">"SELECT * from test where id &lt; 2"</span>

ghci<span class="token3">&gt;</span> execute stmt <span class="token">[</span><span class="token">]</span>
<span class="token2">0</span>

ghci<span class="token3">&gt;</span> results <span class="token3">&lt;</span><span class="token3">-</span> fetchAllRowsAL stmt
<span class="token">[</span><span class="token">[</span><span class="token">(</span><span class="token4">"id"</span><span class="token">,</span>SqlString <span class="token4">"0"</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token4">"desc"</span><span class="token">,</span>SqlNull<span class="token">)</span><span class="token">]</span><span class="token">,</span><span class="token">[</span><span class="token">(</span><span class="token4">"id"</span><span class="token">,</span>SqlString <span class="token4">"0"</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token4">"desc"</span><span class="token">,</span>SqlString <span class="token4">"zero"</span><span class="token">)</span><span class="token">]</span><span class="token">,</span><span class="token">[</span><span class="token">(</span><span class="token4">"id"</span><span class="token">,</span>SqlString <span class="token4">"1"</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token4">"desc"</span><span class="token">,</span>SqlString <span class="token4">"one"</span><span class="token">)</span><span class="token">]</span><span class="token">]</span>

ghci<span class="token3">&gt;</span> mapM_ print results
<span class="token">[</span><span class="token">(</span><span class="token4">"id"</span><span class="token">,</span>SqlString <span class="token4">"0"</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token4">"desc"</span><span class="token">,</span>SqlNull<span class="token">)</span><span class="token">]</span>
<span class="token">[</span><span class="token">(</span><span class="token4">"id"</span><span class="token">,</span>SqlString <span class="token4">"0"</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token4">"desc"</span><span class="token">,</span>SqlString <span class="token4">"zero"</span><span class="token">)</span><span class="token">]</span>
<span class="token">[</span><span class="token">(</span><span class="token4">"id"</span><span class="token">,</span>SqlString <span class="token4">"1"</span><span class="token">)</span><span class="token">,</span><span class="token">(</span><span class="token4">"desc"</span><span class="token">,</span>SqlString <span class="token4">"one"</span><span class="token">)</span><span class="token">]</span>

ghci<span class="token3">&gt;</span> disconnect conn

</code></pre>
<p class="calibre9">虽然使用 fetchAllRowsAL' 函数也可以达到取出所有行的效果，但是如果需要读取的数据集非常大，那么 fetchAllRowsAL' 函数可能就会消耗非常多的内容。通过以惰性的方式读取数据，我们同样可以读取非常大的数据集，但是只需要使用常数数量的内存。惰性版本的数据库读取函数会把结果放到一个块里面进行求值；而严格版的数据库读取函数则会直接获取所有结果，把它们储存到内存里面，接着打印。</p>
<h2 class="calibre14"><a id="chp-21.html._319" class="calibre7 pcalibre"></a>数据库元数据</h2>
<p class="calibre9">在一些情况下，能够知道一些关于数据库自身的信息是非常有用的。比如说，一个程序可能会想要看看数据库里面目前已有的表，然后自动创建缺失的表或者对数据库的模式（schema）进行更新。而在另外一些情况下，程序可能会需要根据正在使用的数据库后端对自己的行为进行修改。</p>
<p class="calibre9">通过使用 getTables 函数，我们可以取得数据库目前已定义的所有列表；而 describeTable 函数则可以告诉我们给定表的各个列的定义信息。</p>
<p class="calibre9">调用 dbServerVer 和 proxiedClientName 可以帮助我们了解正在运行的数据库服务器，而 dbTransactionSupport 函数则可以让我们了解到数据库是否支持事务。以下代码展示了这三个函数的调用示例：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> conn <span class="token3">&lt;</span><span class="token3">-</span> connectSqlite3 <span class="token4">"test1.db"</span>

ghci<span class="token3">&gt;</span> getTables conn
<span class="token">[</span><span class="token4">"test"</span><span class="token">]</span>

ghci<span class="token3">&gt;</span> proxiedClientName conn
<span class="token4">"sqlite3"</span>

ghci<span class="token3">&gt;</span> dbServerVer conn
<span class="token4">"3.5.9"</span>

ghci<span class="token3">&gt;</span> dbTransactionSupport conn
True

ghci<span class="token3">&gt;</span> disconnect conn

</code></pre>
<p class="calibre9">describeResult 函数返回一组 [(String,SqlColDesc)] 类型的二元组，二元组的第一个项是列的名字，第二个项则是与列相关的信息：列的类型、大小以及这个列能够为 NULL 等等。完整的描述可以参考 HDBC 的 API 手册。</p>
<p class="calibre9">需要注意一点是，某些数据库并不能提供所有这些元数据。在这种情况下，程序将引发一个异常。比如 Sqlite3 就不支持前面提到的 describeResult 和 describeTable 。</p>
<h2 class="calibre14"><a id="chp-21.html._350" class="calibre7 pcalibre"></a>错误处理</h2>
<p class="calibre9">HDBC 在错误出现时会引发异常，异常的类型为 SqlError 。这些异常会传递来自底层 SQL 引擎的信息，比如数据库的状态、错误信息、数据库的数字错误代号等等。</p>
<p class="calibre9">因为 <strong class="calibre12">ghci</strong> 并不清楚应该如何向用户展示一个 SqlError ，所以这个异常将导致程序停止，并打印一条没有什么用的信息。就像这样：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> conn <span class="token3">&lt;</span><span class="token3">-</span> connectSqlite3 <span class="token4">"test1.db"</span>

ghci<span class="token3">&gt;</span> quickQuery' conn <span class="token4">"SELECT * from test2"</span> <span class="token">[</span><span class="token">]</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> <span class="token">(</span>unknown<span class="token">)</span>

ghci<span class="token3">&gt;</span> disconnect conn

</code></pre>
<p class="calibre9">上面的这段代码因为使用了 SELECT 去获取一个不存在的表，所以引发了错误，但 <strong class="calibre12">ghci</strong> 返回的的错误信息并没有说清楚这一点。通过使用 handleSqlError 辅助函数，我们可以捕捉 SqlError 并将它重新抛出为 IOError 。这种格式的错误可以被 <strong class="calibre12">ghci</strong> 打印，但是这种格式会使得用户比较难于通过编程的方式来获取错误信息的指定部分。以下是一个使用 handleSqlError 处理异常的例子：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> conn <span class="token3">&lt;</span><span class="token3">-</span> connectSqlite3 <span class="token4">"test1.db"</span>

ghci<span class="token3">&gt;</span> handleSqlError $ quickQuery' conn <span class="token4">"SELECT * from test2"</span> <span class="token">[</span><span class="token">]</span>
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> user error <span class="token">(</span>SQL error<span class="token">:</span> SqlError <span class="token">{</span>seState <span class="token3">=</span> <span class="token4">""</span><span class="token">,</span> seNativeError <span class="token3">=</span> <span class="token2">1</span><span class="token">,</span> seErrorMsg <span class="token3">=</span> <span class="token4">"prepare 20: SELECT * from test2: no such table: test2"</span><span class="token">}</span><span class="token">)</span>

ghci<span class="token3">&gt;</span> disconnect conn

</code></pre>
<p class="calibre9">这个新的错误提示具有更多信息，它甚至包含了一条说明 test2 表并不存在的消息，这比之前的错误提示有用得多了。作为一种标准实践（standard practice），很多 HDBC 程序员都将 main=handleSqlError$do 放到程序的开头，确保所有未被捕获的 SqlError 都会以更有效的方式被打印。</p>
<p class="calibre9">除了 handleSqlError 之外，HDBC 还提供了 catchSql 和 handleSql 这两个函数，它们类似于标准的 catch 函数和 handle 函数，主要的区别在于 catchSql 和 handleSql 只会中断 HDBC 错误。想要了解更多关于错误处理的信息，可以参考本书第 19 章《错误处理》一章。</p>
</div></div></div></div></div></div>
<div id="chp-22.html"><div class="calibre">
<div id="chp-22.html.main" class="calibre1"><div class="root"><div class="article"><h1 class="article-head" id="chp-22.html.calibre_toc_17">第二十二章：扩展示例 —— Web 客户端编程</h1><div class="article-body"><h1 class="calibre6"><a id="chp-22.html.__Web__0" class="calibre7 pcalibre"></a>第二十二章：扩展示例 —— Web 客户端编程</h1>
<p class="calibre9">到目前为止，我们已经了解过如何与数据库进行交互、如何进行语法分析（parse）以及如何处理错误。接下来，让我们更进一步，通过引入一个 web 客户端库来将这些知识结合在一起。</p>
<p class="calibre9">在这一章，我们将要构建一个实际的程序：一个播客下载器（podcast downloader），或者叫“播客抓取器”（podcatcher）。这个博客抓取器的概念非常简单，它接受一系列 URL 作为输入，通过下载这些 URL 来得到一些 RSS 格式的 XML 文件，然后在这些 XML 文件里面找到下载音频文件所需的 URL 。</p>
<p class="calibre9">播客抓取器常常会让用户通过将 RSS URL 添加到配置文件里面的方法来订阅播客，之后用户就可以定期地进行更新操作：播客抓取器会下载 RSS 文档，对它们进行检查以寻找音频文件的下载链接，并为用户下载所有目前尚未存在的音频文件。</p>
<p class="calibre9">Tip</p>
<p class="calibre9">用户通常将 RSS 文件称之为“广播”（podcast）或是“广播源”（podcast feed），而每个单独的音频文件则是播客的其中一集（episode）。</p>
<p class="calibre9">为了实现具有类似功能的播客抓取器，我们需要以下几样东西：</p>
<ul class="calibre10"><li class="calibre11">一个用于下载文件的 HTTP 客户端库；</li><li class="calibre11">一个 XML 分析器；</li><li class="calibre11">一种能够记录我们感兴趣的广播，并将这些记录永久地储存起来的方法；</li><li class="calibre11">一种能够永久地记录已下载广播分集（episodes）的方法。</li></ul>
<p class="calibre9">这个列表的后两样可以通过使用 HDBC 设置的数据库来完成，而前两样则可以通过本章介绍的其他库模块来完成。</p>
<p class="calibre9">Tip</p>
<p class="calibre9">本章的代码是专为本书而写的，但这些代码实际上是基于 hpodder —— 一个使用 Haskell 编写的播客抓取器来编写的。hpodder 拥有的特性比本书展示的播客抓取器要多得多，因此本书不太可能详细地对它进行介绍。如果读者对 hpodder 感兴趣的话，可以在 <a href="http://software.complete.org/hpodder" target="_blank" class="calibre7 pcalibre">http://software.complete.org/hpodder</a> 找到 hpodder 的源代码。</p>
<p class="calibre9">本章的所有代码都是以自成一体的方式来编写的，每段代码都是一个独立的 Haskell 模块，读者可以通过 <strong class="calibre12">ghci</strong> 独立地运行这些模块。本章的最后会写出一段代码，将这些模块全部结合起来，构成一个完整的程序。我们首先要做的就是写出构建博客抓取器需要用到的基本类型。</p>
<h2 class="calibre14"><a id="chp-22.html._27" class="calibre7 pcalibre"></a>基本类型</h2>
<p class="calibre9">为了构建播客抓取器，我们首先需要思考抓取器需要引入（important）的基本信息有那些。一般来说，抓取器关心的都是记录用户感兴趣的博客的信息，以及那些记录了用户已经看过和处理过的分集的信息。在有需要的时候改变这些信息并不困难，但是因为我们在整个抓取器里面都要用到这些信息，所以我们最好还是先定义它们：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch22<span class="token3">/</span>PodTypes<span class="token">.</span>hs
module PodTypes where

data Podcast <span class="token3">=</span>
    Podcast <span class="token">{</span>castId <span class="token">:</span><span class="token">:</span> Integer<span class="token">,</span> <span class="token3">--</span> <span class="token3">^</span> 这个播客的数字 ID
             castURL <span class="token">:</span><span class="token">:</span> String  <span class="token3">--</span> <span class="token3">^</span> 这个播客的源 URL
            <span class="token">}</span>
    deriving <span class="token">(</span>Eq<span class="token">,</span> Show<span class="token">,</span> Read<span class="token">)</span>

data Episode <span class="token3">=</span>
    Episode <span class="token">{</span>epId <span class="token">:</span><span class="token">:</span> Integer<span class="token">,</span>     <span class="token3">--</span> <span class="token3">^</span> 这个分集的数字 ID
             epCast <span class="token">:</span><span class="token">:</span> Podcast<span class="token">,</span>   <span class="token3">--</span> <span class="token3">^</span> 这个分集所属播客的 ID
             epURL <span class="token">:</span><span class="token">:</span> String<span class="token">,</span>     <span class="token3">--</span> <span class="token3">^</span> 下载这一集所使用的 URL
             epDone <span class="token">:</span><span class="token">:</span> Bool       <span class="token3">--</span> <span class="token3">^</span> 记录用户是否已经看过这一集
            <span class="token">}</span>
    deriving <span class="token">(</span>Eq<span class="token">,</span> Show<span class="token">,</span> Read<span class="token">)</span>

</code></pre>
<p class="calibre9">这些信息将被储存到数据库里面。通过为每个播客和博客的每一集都创建一个独一无二的 ID ，程序可以更容易找到分集所属的播客，也可以更容易地从一个特定的播客或者分集里面载入信息，并且更好地应对将来可能会出现的“博客 URL 改变”这类情况。</p>
<h2 class="calibre14"><a id="chp-22.html._53" class="calibre7 pcalibre"></a>数据库</h2>
<p class="calibre9">接下来，我们需要编写代码，以便将信息永久地储存到数据库里面。我们最感兴趣的，就是通过数据库，将 PodTypes.hs 文件定义的 Haskell 结构中的数据储存到硬盘里面。并在用户首次运行程序的时候，创建储存数据所需的数据库表。</p>
<p class="calibre9">我们将使用 21 章介绍过的 HDBC 与 Sqlite 数据库进行交互。Sqlite 非常轻量，并且是自包含的（self-contained），因此它对于这个小项目来说简直是再合适不过了。HDBC 和 Sqlite 的安装方法可以在 21 章的《安装 HDBC 和驱动》一节看到。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch22<span class="token3">/</span>PodDB<span class="token">.</span>hs
module PodDB where

import Database<span class="token">.</span>HDBC
import Database<span class="token">.</span>HDBC<span class="token">.</span>Sqlite3
import PodTypes
import Control<span class="token">.</span><span class="token5">Monad</span><span class="token">(</span>when<span class="token">)</span>
import Data<span class="token">.</span><span class="token5">List</span><span class="token">(</span>sort<span class="token">)</span>

<span class="token3">--</span> <span class="token3">|</span> Initialize DB and <span class="token1">return</span> database Connection
connect <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> IO Connection
connect fp <span class="token3">=</span>
    <span class="token1">do</span> dbh <span class="token3">&lt;</span><span class="token3">-</span> connectSqlite3 fp
       prepDB dbh
       <span class="token1">return</span> dbh

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> 对数据库进行设置，做好储存数据的准备。

这个程序会创建两个表，并要求数据库引擎为我们检查某些数据的一致性：

<span class="token3">*</span> castid 和 epid 都是独一无二的主键（unique primary keys），它们的值不能重复
<span class="token3">*</span> castURL 的值也应该是独一无二的
<span class="token3">*</span> 在记录分集的表里面，对于一个给定的播客（epcast<span class="token">)</span>，每个给定的 URL 或者分集 ID 只能出现一次
<span class="token3">-</span><span class="token">}</span>
prepDB <span class="token">:</span><span class="token">:</span> IConnection conn <span class="token3">=</span><span class="token3">&gt;</span> conn <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
prepDB dbh <span class="token3">=</span>
    <span class="token1">do</span> tables <span class="token3">&lt;</span><span class="token3">-</span> getTables dbh
        when <span class="token">(</span>not <span class="token">(</span><span class="token4">"podcasts"</span> `elem` tables<span class="token">)</span><span class="token">)</span> $
            <span class="token1">do</span> run dbh <span class="token4">"CREATE TABLE podcasts (\
                        \castid INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\
                        \castURL TEXT NOT NULL UNIQUE)"</span> <span class="token">[</span><span class="token">]</span>
               <span class="token1">return</span> <span class="token">(</span><span class="token">)</span>
        when <span class="token">(</span>not <span class="token">(</span><span class="token4">"episodes"</span> `elem` tables<span class="token">)</span><span class="token">)</span> $
            <span class="token1">do</span> run dbh <span class="token4">"CREATE TABLE episodes (\
                        \epid INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\
                        \epcastid INTEGER NOT NULL,\
                        \epurl TEXT NOT NULL,\
                        \epdone INTEGER NOT NULL,\
                        \UNIQUE(epcastid, epurl),\
                        \UNIQUE(epcastid, epid))"</span> <span class="token">[</span><span class="token">]</span>
               <span class="token1">return</span> <span class="token">(</span><span class="token">)</span>
        commit dbh

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> 将一个新的播客添加到数据库里面。
在创建播客时忽略播客的 castid ，并返回一个包含了 castid 的新对象。

尝试添加一个已经存在的播客将引发一个错误。 <span class="token3">-</span><span class="token">}</span>
addPodcast <span class="token">:</span><span class="token">:</span> IConnection conn <span class="token3">=</span><span class="token3">&gt;</span> conn <span class="token3">-</span><span class="token3">&gt;</span> Podcast <span class="token3">-</span><span class="token3">&gt;</span> IO Podcast
addPodcast dbh podcast <span class="token3">=</span>
    handleSql errorHandler $
        <span class="token1">do</span> <span class="token3">--</span> Insert the castURL into the table<span class="token">.</span>  The database
           <span class="token3">--</span> will automatically assign a cast ID<span class="token">.</span>
           run dbh <span class="token4">"INSERT INTO podcasts (castURL) VALUES (?)"</span>
               <span class="token">[</span>toSql <span class="token">(</span>castURL podcast<span class="token">)</span><span class="token">]</span>
           <span class="token3">--</span> Find out the castID <span class="token1">for</span> the URL we just added<span class="token">.</span>
           r <span class="token3">&lt;</span><span class="token3">-</span> quickQuery' dbh <span class="token4">"SELECT castid FROM podcasts WHERE castURL = ?"</span>
                <span class="token">[</span>toSql <span class="token">(</span>castURL podcast<span class="token">)</span><span class="token">]</span>
           case r of
             <span class="token">[</span><span class="token">[</span>x<span class="token">]</span><span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> $ podcast <span class="token">{</span>castId <span class="token3">=</span> fromSql x<span class="token">}</span>
             y <span class="token3">-</span><span class="token3">&gt;</span> fail $ <span class="token4">"addPodcast: unexpected result: "</span> <span class="token3">++</span> show y
    where errorHandler e <span class="token3">=</span>
              <span class="token1">do</span> fail $ <span class="token4">"Error adding podcast; does this URL already exist?\n"</span>
                     <span class="token3">++</span> show e

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> 将一个新的分集添加到数据库里面。

因为这一操作是自动执行而非用户请求执行的，我们将简单地忽略创建重复分集的请求。
这样的话，在对播客源进行处理的时候，我们就可以把遇到的所有 URL 到传给这个函数，
而不必先检查这个 URL 是否已经存在于数据库当中。

这个函数在创建新的分集时同样不会考虑如何创建新的 ID ，
因此它也没有必要去考虑如何去获取这个 ID 。 <span class="token3">-</span><span class="token">}</span>
addEpisode <span class="token">:</span><span class="token">:</span> IConnection conn <span class="token3">=</span><span class="token3">&gt;</span> conn <span class="token3">-</span><span class="token3">&gt;</span> Episode <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
addEpisode dbh ep <span class="token3">=</span>
    run dbh <span class="token4">"INSERT OR IGNORE INTO episodes (epCastId, epURL, epDone) \
            \VALUES (?, ?, ?)"</span>
            <span class="token">[</span>toSql <span class="token">(</span>castId <span class="token">.</span> epCast $ ep<span class="token">)</span><span class="token">,</span> toSql <span class="token">(</span>epURL ep<span class="token">)</span><span class="token">,</span>
             toSql <span class="token">(</span>epDone ep<span class="token">)</span><span class="token">]</span>
    <span class="token3">&gt;</span><span class="token3">&gt;</span> <span class="token1">return</span> <span class="token">(</span><span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> 对一个已经存在的播客进行修改。
根据 ID 来查找指定的播客，并根据传入的 Podcast 结构对数据库记录进行修改。 <span class="token3">-</span><span class="token">}</span>
updatePodcast <span class="token">:</span><span class="token">:</span> IConnection conn <span class="token3">=</span><span class="token3">&gt;</span> conn <span class="token3">-</span><span class="token3">&gt;</span> Podcast <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
updatePodcast dbh podcast <span class="token3">=</span>
    run dbh <span class="token4">"UPDATE podcasts SET castURL = ? WHERE castId = ?"</span>
            <span class="token">[</span>toSql <span class="token">(</span>castURL podcast<span class="token">)</span><span class="token">,</span> toSql <span class="token">(</span>castId podcast<span class="token">)</span><span class="token">]</span>
    <span class="token3">&gt;</span><span class="token3">&gt;</span> <span class="token1">return</span> <span class="token">(</span><span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> 对一个已经存在的分集进行修改。
根据 ID 来查找指定的分集，并根据传入的 episode 结构对数据库记录进行修改。 <span class="token3">-</span><span class="token">}</span>
updateEpisode <span class="token">:</span><span class="token">:</span> IConnection conn <span class="token3">=</span><span class="token3">&gt;</span> conn <span class="token3">-</span><span class="token3">&gt;</span> Episode <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
updateEpisode dbh episode <span class="token3">=</span>
    run dbh <span class="token4">"UPDATE episodes SET epCastId = ?, epURL = ?, epDone = ? \
            \WHERE epId = ?"</span>
            <span class="token">[</span>toSql <span class="token">(</span>castId <span class="token">.</span> epCast $ episode<span class="token">)</span><span class="token">,</span>
             toSql <span class="token">(</span>epURL episode<span class="token">)</span><span class="token">,</span>
             toSql <span class="token">(</span>epDone episode<span class="token">)</span><span class="token">,</span>
             toSql <span class="token">(</span>epId episode<span class="token">)</span><span class="token">]</span>
    <span class="token3">&gt;</span><span class="token3">&gt;</span> <span class="token1">return</span> <span class="token">(</span><span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> 移除一个播客。 这个操作在执行之前会先移除这个播客已有的所有分集。 <span class="token3">-</span><span class="token">}</span>
removePodcast <span class="token">:</span><span class="token">:</span> IConnection conn <span class="token3">=</span><span class="token3">&gt;</span> conn <span class="token3">-</span><span class="token3">&gt;</span> Podcast <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
removePodcast dbh podcast <span class="token3">=</span>
    <span class="token1">do</span> run dbh <span class="token4">"DELETE FROM episodes WHERE epcastid = ?"</span>
         <span class="token">[</span>toSql <span class="token">(</span>castId podcast<span class="token">)</span><span class="token">]</span>
       run dbh <span class="token4">"DELETE FROM podcasts WHERE castid = ?"</span>
         <span class="token">[</span>toSql <span class="token">(</span>castId podcast<span class="token">)</span><span class="token">]</span>
       <span class="token1">return</span> <span class="token">(</span><span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> 获取一个包含所有播客的列表。 <span class="token3">-</span><span class="token">}</span>
getPodcasts <span class="token">:</span><span class="token">:</span> IConnection conn <span class="token3">=</span><span class="token3">&gt;</span> conn <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">[</span>Podcast<span class="token">]</span>
getPodcasts dbh <span class="token3">=</span>
    <span class="token1">do</span> res <span class="token3">&lt;</span><span class="token3">-</span> quickQuery' dbh
              <span class="token4">"SELECT castid, casturl FROM podcasts ORDER BY castid"</span> <span class="token">[</span><span class="token">]</span>
       <span class="token1">return</span> <span class="token">(</span>map convPodcastRow res<span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> 获取特定的广播。
函数在成功执行时返回 Just Podcast ；在 ID 不匹配时返回 Nothing 。 <span class="token3">-</span><span class="token">}</span>
getPodcast <span class="token">:</span><span class="token">:</span> IConnection conn <span class="token3">=</span><span class="token3">&gt;</span> conn <span class="token3">-</span><span class="token3">&gt;</span> Integer <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span>Maybe Podcast<span class="token">)</span>
getPodcast dbh wantedId <span class="token3">=</span>
    <span class="token1">do</span> res <span class="token3">&lt;</span><span class="token3">-</span> quickQuery' dbh
              <span class="token4">"SELECT castid, casturl FROM podcasts WHERE castid = ?"</span>
              <span class="token">[</span>toSql wantedId<span class="token">]</span>
       case res of
         <span class="token">[</span>x<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> <span class="token">(</span>Just <span class="token">(</span>convPodcastRow x<span class="token">)</span><span class="token">)</span>
         <span class="token">[</span><span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> Nothing
         x <span class="token3">-</span><span class="token3">&gt;</span> fail $ <span class="token4">"Really bad error; more than one podcast with ID"</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> 将 SELECT 语句的执行结果转换为 Podcast 记录 <span class="token3">-</span><span class="token">}</span>
convPodcastRow <span class="token">:</span><span class="token">:</span> <span class="token">[</span>SqlValue<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Podcast
convPodcastRow <span class="token">[</span>svId<span class="token">,</span> svURL<span class="token">]</span> <span class="token3">=</span>
    Podcast <span class="token">{</span>castId <span class="token3">=</span> fromSql svId<span class="token">,</span>
             castURL <span class="token3">=</span> fromSql svURL<span class="token">}</span>
convPodcastRow x <span class="token3">=</span> error $ <span class="token4">"Can't convert podcast row "</span> <span class="token3">++</span> show x

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> 获取特定播客的所有分集。 <span class="token3">-</span><span class="token">}</span>
getPodcastEpisodes <span class="token">:</span><span class="token">:</span> IConnection conn <span class="token3">=</span><span class="token3">&gt;</span> conn <span class="token3">-</span><span class="token3">&gt;</span> Podcast <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">[</span>Episode<span class="token">]</span>
getPodcastEpisodes dbh pc <span class="token3">=</span>
    <span class="token1">do</span> r <span class="token3">&lt;</span><span class="token3">-</span> quickQuery' dbh
            <span class="token4">"SELECT epId, epURL, epDone FROM episodes WHERE epCastId = ?"</span>
            <span class="token">[</span>toSql <span class="token">(</span>castId pc<span class="token">)</span><span class="token">]</span>
       <span class="token1">return</span> <span class="token">(</span>map convEpisodeRow r<span class="token">)</span>
    where convEpisodeRow <span class="token">[</span>svId<span class="token">,</span> svURL<span class="token">,</span> svDone<span class="token">]</span> <span class="token3">=</span>
              Episode <span class="token">{</span>epId <span class="token3">=</span> fromSql svId<span class="token">,</span> epURL <span class="token3">=</span> fromSql svURL<span class="token">,</span>
                       epDone <span class="token3">=</span> fromSql svDone<span class="token">,</span> epCast <span class="token3">=</span> pc<span class="token">}</span>

</code></pre>
<p class="calibre9">PodDB 模块定义了连接数据库的函数、创建所需数据库表的函数、将数据添加到数据库里面的函数、查询数据库的函数以及从数据库里面移除数据的函数。以下代码展示了一个与数据库进行交互的 <strong class="calibre12">ghci</strong> 会话，这个会话将在当前目录里面创建一个名为 poddbtest.db 的数据库文件，并将广播和分集添加到这个文件里面。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>load PodDB<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">2</span><span class="token">]</span> Compiling PodTypes         <span class="token">(</span> PodTypes<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
<span class="token">[</span><span class="token2">2</span> of <span class="token2">2</span><span class="token">]</span> Compiling PodDB            <span class="token">(</span> PodDB<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> PodDB<span class="token">,</span> PodTypes<span class="token">.</span>

ghci<span class="token3">&gt;</span> dbh <span class="token3">&lt;</span><span class="token3">-</span> connect <span class="token4">"poddbtest.db"</span>

ghci<span class="token3">&gt;</span> <span class="token">:</span>type dbh
dbh <span class="token">:</span><span class="token">:</span> Connection

ghci<span class="token3">&gt;</span> getTables dbh
<span class="token">[</span><span class="token4">"episodes"</span><span class="token">,</span><span class="token4">"podcasts"</span><span class="token">,</span><span class="token4">"sqlite_sequence"</span><span class="token">]</span>

ghci<span class="token3">&gt;</span> let url <span class="token3">=</span> <span class="token4">"http://feeds.thisamericanlife.org/talpodcast"</span>

ghci<span class="token3">&gt;</span> pc <span class="token3">&lt;</span><span class="token3">-</span> addPodcast dbh <span class="token">(</span>Podcast <span class="token">{</span>castId<span class="token3">=</span><span class="token2">0</span><span class="token">,</span> castURL<span class="token3">=</span>url<span class="token">}</span><span class="token">)</span>
Podcast <span class="token">{</span>castId <span class="token3">=</span> <span class="token2">1</span><span class="token">,</span> castURL <span class="token3">=</span> <span class="token4">"http://feeds.thisamericanlife.org/talpodcast"</span><span class="token">}</span>

ghci<span class="token3">&gt;</span> getPodcasts dbh
<span class="token">[</span>Podcast <span class="token">{</span>castId <span class="token3">=</span> <span class="token2">1</span><span class="token">,</span> castURL <span class="token3">=</span> <span class="token4">"http://feeds.thisamericanlife.org/talpodcast"</span><span class="token">}</span><span class="token">]</span>

ghci<span class="token3">&gt;</span> addEpisode dbh <span class="token">(</span>Episode <span class="token">{</span>epId <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> epCast <span class="token3">=</span> pc<span class="token">,</span> epURL <span class="token3">=</span> <span class="token4">"http://www.example.com/foo.mp3"</span><span class="token">,</span> epDone <span class="token3">=</span> False<span class="token">}</span><span class="token">)</span>

ghci<span class="token3">&gt;</span> getPodcastEpisodes dbh pc
<span class="token">[</span>Episode <span class="token">{</span>epId <span class="token3">=</span> <span class="token2">1</span><span class="token">,</span> epCast <span class="token3">=</span> Podcast <span class="token">{</span>castId <span class="token3">=</span> <span class="token2">1</span><span class="token">,</span> castURL <span class="token3">=</span> <span class="token4">"http://feeds.thisamericanlife.org/talpodcast"</span><span class="token">}</span><span class="token">,</span> epURL <span class="token3">=</span> <span class="token4">"http://www.example.com/foo.mp3"</span><span class="token">,</span> epDone <span class="token3">=</span> False<span class="token">}</span><span class="token">]</span>

ghci<span class="token3">&gt;</span> commit dbh

ghci<span class="token3">&gt;</span> disconnect dbh

</code></pre>
<h2 class="calibre14"><a id="chp-22.html._243" class="calibre7 pcalibre"></a>分析器</h2>
<p class="calibre9">在实现了抓取器的数据库部分之后，我们接下来就需要实现抓取器中负责对广播源进行语法分析的部分，这个部分要分析的是一些包含着多种信息的 XML 文件，例子如下：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">&lt;</span><span class="token3">?</span>xml version<span class="token3">=</span><span class="token4">"1.0"</span> encoding<span class="token3">=</span><span class="token4">"UTF-8"</span><span class="token3">?</span><span class="token3">&gt;</span>
<span class="token3">&lt;</span>rss xmlns<span class="token">:</span>itunes<span class="token3">=</span><span class="token4">"http://www.itunes.com/DTDs/Podcast-1.0.dtd"</span> version<span class="token3">=</span><span class="token4">"2.0"</span><span class="token3">&gt;</span>
<span class="token3">&lt;</span>channel<span class="token3">&gt;</span>
<span class="token3">&lt;</span>title<span class="token3">&gt;</span>Haskell Radio<span class="token3">&lt;</span><span class="token3">/</span>title<span class="token3">&gt;</span>
<span class="token3">&lt;</span>link<span class="token3">&gt;</span>http<span class="token">:</span><span class="token3">/</span><span class="token3">/</span>www<span class="token">.</span>example<span class="token">.</span>com<span class="token3">/</span>radio<span class="token3">/</span><span class="token3">&lt;</span><span class="token3">/</span>link<span class="token3">&gt;</span>
<span class="token3">&lt;</span>description<span class="token3">&gt;</span>Description of this podcast<span class="token3">&lt;</span><span class="token3">/</span>description<span class="token3">&gt;</span>
<span class="token3">&lt;</span>item<span class="token3">&gt;</span>
<span class="token3">&lt;</span>title<span class="token3">&gt;</span>Episode <span class="token2">2</span><span class="token">:</span> Lambdas<span class="token3">&lt;</span><span class="token3">/</span>title<span class="token3">&gt;</span>
<span class="token3">&lt;</span>link<span class="token3">&gt;</span>http<span class="token">:</span><span class="token3">/</span><span class="token3">/</span>www<span class="token">.</span>example<span class="token">.</span>com<span class="token3">/</span>radio<span class="token3">/</span>lambdas<span class="token3">&lt;</span><span class="token3">/</span>link<span class="token3">&gt;</span>
<span class="token3">&lt;</span>enclosure url<span class="token3">=</span><span class="token4">"http://www.example.com/radio/lambdas.mp3"</span>
type<span class="token3">=</span><span class="token4">"audio/mpeg"</span> length<span class="token3">=</span><span class="token4">"10485760"</span><span class="token3">/</span><span class="token3">&gt;</span>
<span class="token3">&lt;</span><span class="token3">/</span>item<span class="token3">&gt;</span>
<span class="token3">&lt;</span>item<span class="token3">&gt;</span>
<span class="token3">&lt;</span>title<span class="token3">&gt;</span>Episode <span class="token2">1</span><span class="token">:</span> Parsec<span class="token3">&lt;</span><span class="token3">/</span>title<span class="token3">&gt;</span>
<span class="token3">&lt;</span>link<span class="token3">&gt;</span>http<span class="token">:</span><span class="token3">/</span><span class="token3">/</span>www<span class="token">.</span>example<span class="token">.</span>com<span class="token3">/</span>radio<span class="token3">/</span>parsec<span class="token3">&lt;</span><span class="token3">/</span>link<span class="token3">&gt;</span>
<span class="token3">&lt;</span>enclosure url<span class="token3">=</span><span class="token4">"http://www.example.com/radio/parsec.mp3"</span>
type<span class="token3">=</span><span class="token4">"audio/mpeg"</span> length<span class="token3">=</span><span class="token4">"10485150"</span><span class="token3">/</span><span class="token3">&gt;</span>
<span class="token3">&lt;</span><span class="token3">/</span>item<span class="token3">&gt;</span>
<span class="token3">&lt;</span><span class="token3">/</span>channel<span class="token3">&gt;</span>
<span class="token3">&lt;</span><span class="token3">/</span>rss<span class="token3">&gt;</span>

</code></pre>
<p class="calibre9">在这些文件里面，我们最关心的是两样东西：广播的标题以及它们的附件（enclosure） URL 。我们将使用 <a href="http://www.cs.york.ac.uk/fp/HaXml/" target="_blank" class="calibre7 pcalibre">HaXml 工具包</a> [<a href="http://www.cs.york.ac.uk/fp/HaXml/" target="_blank" class="calibre7 pcalibre">http://www.cs.york.ac.uk/fp/HaXml/</a>]来对 XML 文件进行分析，以下代码就是这个工具包的源码：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch22<span class="token3">/</span>PodParser<span class="token">.</span>hs
module PodParser where

import PodTypes
import Text<span class="token">.</span>XML<span class="token">.</span>HaXml
import Text<span class="token">.</span>XML<span class="token">.</span>HaXml<span class="token">.</span>Parse
import Text<span class="token">.</span>XML<span class="token">.</span>HaXml<span class="token">.</span>Html<span class="token">.</span><span class="token5">Generate</span><span class="token">(</span>showattr<span class="token">)</span>
import Data<span class="token">.</span>Char
import Data<span class="token">.</span>List

data PodItem <span class="token3">=</span> PodItem <span class="token">{</span>itemtitle <span class="token">:</span><span class="token">:</span> String<span class="token">,</span>
                  enclosureurl <span class="token">:</span><span class="token">:</span> String
                  <span class="token">}</span>
          deriving <span class="token">(</span>Eq<span class="token">,</span> Show<span class="token">,</span> Read<span class="token">)</span>

data Feed <span class="token3">=</span> Feed <span class="token">{</span>channeltitle <span class="token">:</span><span class="token">:</span> String<span class="token">,</span>
                  items <span class="token">:</span><span class="token">:</span> <span class="token">[</span>PodItem<span class="token">]</span><span class="token">}</span>
            deriving <span class="token">(</span>Eq<span class="token">,</span> Show<span class="token">,</span> Read<span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> 根据给定的广播和 PodItem ，产生一个分集。 <span class="token3">-</span><span class="token">}</span>
item2ep <span class="token">:</span><span class="token">:</span> Podcast <span class="token3">-</span><span class="token3">&gt;</span> PodItem <span class="token3">-</span><span class="token3">&gt;</span> Episode
item2ep pc item <span class="token3">=</span>
    Episode <span class="token">{</span>epId <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span>
             epCast <span class="token3">=</span> pc<span class="token">,</span>
             epURL <span class="token3">=</span> enclosureurl item<span class="token">,</span>
             epDone <span class="token3">=</span> False<span class="token">}</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> 从给定的字符串里面分析出数据，给定的名字在有需要的时候会被用在错误消息里面。 <span class="token3">-</span><span class="token">}</span>
parse <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> Feed
parse content name <span class="token3">=</span>
    Feed <span class="token">{</span>channeltitle <span class="token3">=</span> getTitle doc<span class="token">,</span>
          items <span class="token3">=</span> getEnclosures doc<span class="token">}</span>

    where parseResult <span class="token3">=</span> xmlParse name <span class="token">(</span>stripUnicodeBOM content<span class="token">)</span>
          doc <span class="token3">=</span> getContent parseResult

          getContent <span class="token">:</span><span class="token">:</span> Document <span class="token3">-</span><span class="token3">&gt;</span> Content
          getContent <span class="token">(</span>Document _ _ e _<span class="token">)</span> <span class="token3">=</span> CElem e

          <span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Some Unicode documents begin with a binary sequence<span class="token">;</span>
          strip it off before processing<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>
          stripUnicodeBOM <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> String
          stripUnicodeBOM <span class="token">(</span><span class="token4">'\xef'</span><span class="token">:</span><span class="token4">'\xbb'</span><span class="token">:</span><span class="token4">'\xbf'</span><span class="token">:</span>x<span class="token">)</span> <span class="token3">=</span> x
          stripUnicodeBOM x <span class="token3">=</span> x

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> 从文档里面提取出频道部分（channel part）

注意 HaXml 会将 CFilter 定义为：

<span class="token3">&gt;</span> type CFilter <span class="token3">=</span> Content <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>Content<span class="token">]</span>
<span class="token3">-</span><span class="token">}</span>
channel <span class="token">:</span><span class="token">:</span> CFilter
channel <span class="token3">=</span> tag <span class="token4">"rss"</span> <span class="token3">/</span><span class="token3">&gt;</span> tag <span class="token4">"channel"</span>

getTitle <span class="token">:</span><span class="token">:</span> Content <span class="token3">-</span><span class="token3">&gt;</span> String
getTitle doc <span class="token3">=</span>
    contentToStringDefault <span class="token4">"Untitled Podcast"</span>
        <span class="token">(</span>channel <span class="token3">/</span><span class="token3">&gt;</span> tag <span class="token4">"title"</span> <span class="token3">/</span><span class="token3">&gt;</span> txt $ doc<span class="token">)</span>

getEnclosures <span class="token">:</span><span class="token">:</span> Content <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>PodItem<span class="token">]</span>
getEnclosures doc <span class="token3">=</span>
    concatMap procPodItem $ getPodItems doc
    where procPodItem <span class="token">:</span><span class="token">:</span> Content <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>PodItem<span class="token">]</span>
          procPodItem item <span class="token3">=</span> concatMap <span class="token">(</span>procEnclosure title<span class="token">)</span> enclosure
              where title <span class="token3">=</span> contentToStringDefault <span class="token4">"Untitled Episode"</span>
                               <span class="token">(</span>keep <span class="token3">/</span><span class="token3">&gt;</span> tag <span class="token4">"title"</span> <span class="token3">/</span><span class="token3">&gt;</span> txt $ item<span class="token">)</span>
                    enclosure <span class="token3">=</span> <span class="token">(</span>keep <span class="token3">/</span><span class="token3">&gt;</span> tag <span class="token4">"enclosure"</span><span class="token">)</span> item

          getPodItems <span class="token">:</span><span class="token">:</span> CFilter
          getPodItems <span class="token3">=</span> channel <span class="token3">/</span><span class="token3">&gt;</span> tag <span class="token4">"item"</span>

          procEnclosure <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> Content <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>PodItem<span class="token">]</span>
          procEnclosure title enclosure <span class="token3">=</span>
              map makePodItem <span class="token">(</span>showattr <span class="token4">"url"</span> enclosure<span class="token">)</span>
              where makePodItem <span class="token">:</span><span class="token">:</span> Content <span class="token3">-</span><span class="token3">&gt;</span> PodItem
                    makePodItem x <span class="token3">=</span> PodItem <span class="token">{</span>itemtitle <span class="token3">=</span> title<span class="token">,</span>
                                       enclosureurl <span class="token3">=</span> contentToString <span class="token">[</span>x<span class="token">]</span><span class="token">}</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> 将 <span class="token">[</span>Content<span class="token">]</span> 转换为可打印的字符串，
如果传入的 <span class="token">[</span>Content<span class="token">]</span> 为 <span class="token">[</span><span class="token">]</span> ，那么向用户说明此次匹配未成功。 <span class="token3">-</span><span class="token">}</span>
contentToStringDefault <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>Content<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> String
contentToStringDefault msg <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> msg
contentToStringDefault _ x <span class="token3">=</span> contentToString x

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> 将 <span class="token">[</span>Content<span class="token">]</span> 转换为可打印的字符串，并且小心地对它进行反解码（unescape）。

一个没有反解码实现的实现可以简单地定义为：

<span class="token3">&gt;</span> contentToString <span class="token3">=</span> concatMap <span class="token">(</span>show <span class="token">.</span> content<span class="token">)</span>

因为 HaXml 的反解码操作只能对 Elements 使用，
我们必须保证每个 Content 都被包裹为 Element ，
然后使用 txt 函数去将 Element 内部的数据提取出来。 <span class="token3">-</span><span class="token">}</span>
contentToString <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Content<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> String
contentToString <span class="token3">=</span>
    concatMap procContent
    where procContent x <span class="token3">=</span>
              verbatim $ keep <span class="token3">/</span><span class="token3">&gt;</span> txt $ CElem <span class="token">(</span>unesc <span class="token">(</span>fakeElem x<span class="token">)</span><span class="token">)</span>

          fakeElem <span class="token">:</span><span class="token">:</span> Content <span class="token3">-</span><span class="token3">&gt;</span> Element
          fakeElem x <span class="token3">=</span> Elem <span class="token4">"fake"</span> <span class="token">[</span><span class="token">]</span> <span class="token">[</span>x<span class="token">]</span>

          unesc <span class="token">:</span><span class="token">:</span> Element <span class="token3">-</span><span class="token3">&gt;</span> Element
          unesc <span class="token3">=</span> xmlUnEscape stdXmlEscaper

</code></pre>
<p class="calibre9">让我们好好看看这段代码。它首先定义了两种类型：PodItem 和 Feed 。程序会将 XML 文件转换为 Feed ，而每个 Feed 可以包含多个 PodItem 。此外，程序还提供了一个函数，它可以将 PodItem 转换为 PodTypes.hs 文件中定义的 Episode 。</p>
<p class="calibre9">接下来，程序开始定义与语法分析有关的函数。parse 函数接受两个参数，一个是 String 表示的 XML 文本，另一个则是用于展示错误信息的 String 表示的名字，这个函数也会返回一个 Feed 。</p>
<p class="calibre9">HaXml 被设计成一个将数据从一种类型转换为另一种类型的“过滤器”，它是一个简单直接的转换操作，可以将 XML 转换为 XML 、将 XML 转换为 Haskell 数据、或者将 Haskell 数据转换为 XML 。HaXml 拥有一种名为 CFilter 的数据类型，它的定义如下：</p>
<pre class="calibre15"><code class="tthhighlight-container">type CFilter <span class="token3">=</span> Content <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>Content<span class="token">]</span>

</code></pre>
<p class="calibre9">一个 CFilter 接受一个 XML 文档片段（fragments），然后返回 0 个或多个片段。CFilter 可能会被要求找出指定标签（tag）的所有子标签、所有具有指定名字的标签、XML 文档某一部分包含的文本，又或者其他几样东西（a number of other things）。操作符 (/&gt;) 可以将多个 CFilter 函数组合在一起。抓取器想要的是那些包围在  标签里面的数据，所以我们首先要做的就是找出这些数据。以下是实现这一操作的一个简单的 CFilter ：</p>
<pre class="calibre15"><code class="tthhighlight-container">channel <span class="token3">=</span> tag <span class="token4">"rss"</span> <span class="token3">/</span><span class="token3">&gt;</span> tag <span class="token4">"channel"</span>

</code></pre>
<p class="calibre9">当我们将一个文档传递给 channel 函数时，函数会从文档的顶层（top level）查找名为 rss 的标签。并在发现这些标签之后，寻找 channel 标签。</p>
<p class="calibre9">余下的程序也会遵循这一基本方法进行。txt 函数会从标签中提取出文本，然后通过使用 CFilter 函数，程序可以取得文档的任意部分。</p>
<h2 class="calibre14"><a id="chp-22.html._403" class="calibre7 pcalibre"></a>下载</h2>
<p class="calibre9">构建抓取器的下一个步骤是完成用于下载数据的模块。抓取器需要下载两种不同类型的数据：它们分别是广播的内容以及每个分集的音频。对于前者，程序需要对数据进行语法分析并更新数据库；而对于后者，程序则需要将数据写入到文件里面并储存到硬盘上。</p>
<p class="calibre9">抓取器将通过 HTTP 服务器进行下载，所以我们需要使用一个 Haskell HTTP 库。为了下载广播源，抓取器需要下载文档、对文档进行语法分析并更新数据库。对于分集音频，程序会下载文件、将它写入到硬盘并在数据库里面将该分集标记为“已下载”。以下是执行这一工作的代码：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch22<span class="token3">/</span>PodDownload<span class="token">.</span>hs
module PodDownload where
import PodTypes
import PodDB
import PodParser
import Network<span class="token">.</span>HTTP
import System<span class="token">.</span>IO
import Database<span class="token">.</span>HDBC
import Data<span class="token">.</span>Maybe
import Network<span class="token">.</span>URI

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> 下载 URL 。
函数在发生错误时返回 <span class="token">(</span>Left errorMessage<span class="token">)</span> ；
下载成功时返回 <span class="token">(</span>Right doc<span class="token">)</span> 。 <span class="token3">-</span><span class="token">}</span>
downloadURL <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span>Either String String<span class="token">)</span>
downloadURL url <span class="token3">=</span>
    <span class="token1">do</span> resp <span class="token3">&lt;</span><span class="token3">-</span> simpleHTTP request
       case resp of
         Left x <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> $ Left <span class="token">(</span><span class="token4">"Error connecting: "</span> <span class="token3">++</span> show x<span class="token">)</span>
         Right r <span class="token3">-</span><span class="token3">&gt;</span>
             case rspCode r of
               <span class="token">(</span><span class="token2">2</span><span class="token">,</span>_<span class="token">,</span>_<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> $ Right <span class="token">(</span>rspBody r<span class="token">)</span>
               <span class="token">(</span><span class="token2">3</span><span class="token">,</span>_<span class="token">,</span>_<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token3">--</span> A HTTP redirect
                 case findHeader HdrLocation r of
                   Nothing <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> $ Left <span class="token">(</span>show r<span class="token">)</span>
                   Just url <span class="token3">-</span><span class="token3">&gt;</span> downloadURL url
               _ <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> $ Left <span class="token">(</span>show r<span class="token">)</span>
    where request <span class="token3">=</span> Request <span class="token">{</span>rqURI <span class="token3">=</span> uri<span class="token">,</span>
                             rqMethod <span class="token3">=</span> GET<span class="token">,</span>
                             rqHeaders <span class="token3">=</span> <span class="token">[</span><span class="token">]</span><span class="token">,</span>
                             rqBody <span class="token3">=</span> <span class="token4">""</span><span class="token">}</span>
          uri <span class="token3">=</span> fromJust $ parseURI url

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> 对数据库中的广播源进行更新。 <span class="token3">-</span><span class="token">}</span>
updatePodcastFromFeed <span class="token">:</span><span class="token">:</span> IConnection conn <span class="token3">=</span><span class="token3">&gt;</span> conn <span class="token3">-</span><span class="token3">&gt;</span> Podcast <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
updatePodcastFromFeed dbh pc <span class="token3">=</span>
    <span class="token1">do</span> resp <span class="token3">&lt;</span><span class="token3">-</span> downloadURL <span class="token">(</span>castURL pc<span class="token">)</span>
       case resp of
         Left x <span class="token3">-</span><span class="token3">&gt;</span> putStrLn x
         Right doc <span class="token3">-</span><span class="token3">&gt;</span> updateDB doc

    where updateDB doc <span class="token3">=</span>
              <span class="token1">do</span> mapM_ <span class="token">(</span>addEpisode dbh<span class="token">)</span> episodes
                 commit dbh
              where feed <span class="token3">=</span> parse doc <span class="token">(</span>castURL pc<span class="token">)</span>
                    episodes <span class="token3">=</span> map <span class="token">(</span>item2ep pc<span class="token">)</span> <span class="token">(</span>items feed<span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> 下载一个分集，并以 String 表示的形式，将储存该分集的文件名返回给调用者。
函数在发生错误时返回一个 Nothing 。 <span class="token3">-</span><span class="token">}</span>
getEpisode <span class="token">:</span><span class="token">:</span> IConnection conn <span class="token3">=</span><span class="token3">&gt;</span> conn <span class="token3">-</span><span class="token3">&gt;</span> Episode <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span>Maybe String<span class="token">)</span>
getEpisode dbh ep <span class="token3">=</span>
    <span class="token1">do</span> resp <span class="token3">&lt;</span><span class="token3">-</span> downloadURL <span class="token">(</span>epURL ep<span class="token">)</span>
       case resp of
         Left x <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">do</span> putStrLn x
                      <span class="token1">return</span> Nothing
         Right doc <span class="token3">-</span><span class="token3">&gt;</span>
             <span class="token1">do</span> file <span class="token3">&lt;</span><span class="token3">-</span> openBinaryFile filename WriteMode
                hPutStr file doc
                hClose file
                updateEpisode dbh <span class="token">(</span>ep <span class="token">{</span>epDone <span class="token3">=</span> True<span class="token">}</span><span class="token">)</span>
                commit dbh
                <span class="token1">return</span> <span class="token">(</span>Just filename<span class="token">)</span>
          <span class="token3">--</span> This <span class="token1">function</span> ought to apply an extension based on the filetype
    where filename <span class="token3">=</span> <span class="token4">"pod."</span> <span class="token3">++</span> <span class="token">(</span>show <span class="token">.</span> castId <span class="token">.</span> epCast $ ep<span class="token">)</span> <span class="token3">++</span> <span class="token4">"."</span> <span class="token3">++</span>
                     <span class="token">(</span>show <span class="token">(</span>epId ep<span class="token">)</span><span class="token">)</span> <span class="token3">++</span> <span class="token4">".mp3"</span>

</code></pre>
<p class="calibre9">这个函数定义了三个函数：</p>
<ul class="calibre10"><li class="calibre11">downloadURL 函数对 URL 进行下载，并以 String 形式返回它；</li><li class="calibre11">updatePodcastFromFeed 函数对 XML 源文件进行下载，对文件进行分析，并更新数据库；</li><li class="calibre11">getEpisode 下载一个给定的分集，并在数据库里面将该分集标记为“已下载”。</li></ul>
<p class="calibre9">Warning</p>
<p class="calibre9">这里使用的 HTTP 库并不会以惰性的方式读取 HTTP 结果，因此在下载诸如广播这样的大文件的时候，这个库可能会消耗掉大量的内容。其他一些 HTTP 库并没有这一限制。我们之所以在这里使用这个有缺陷的库，是因为它稳定、易于安装并且也易于使用。对于正式的 HTTP 需要，我们推荐使用 mini-http 库，这个库可以从 Hackage 里面获得。</p>
<h2 class="calibre14"><a id="chp-22.html._488" class="calibre7 pcalibre"></a>主程序</h2>
<p class="calibre9">最后，我们需要编写一个程序来将上面展示的各个部分结合在一起。以下是这个主模块（main module）：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch22<span class="token3">/</span>PodMain<span class="token">.</span>hs
module Main where

import PodDownload
import PodDB
import PodTypes
import System<span class="token">.</span>Environment
import Database<span class="token">.</span>HDBC
import Network<span class="token">.</span><span class="token5">Socket</span><span class="token">(</span>withSocketsDo<span class="token">)</span>

main <span class="token3">=</span> withSocketsDo $ handleSqlError $
    <span class="token1">do</span> args <span class="token3">&lt;</span><span class="token3">-</span> getArgs
       dbh <span class="token3">&lt;</span><span class="token3">-</span> connect <span class="token4">"pod.db"</span>
       case args of
         <span class="token">[</span><span class="token4">"add"</span><span class="token">,</span> url<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> add dbh url
         <span class="token">[</span><span class="token4">"update"</span><span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> update dbh
         <span class="token">[</span><span class="token4">"download"</span><span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> download dbh
         <span class="token">[</span><span class="token4">"fetch"</span><span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">do</span> update dbh
                         download dbh
         _ <span class="token3">-</span><span class="token3">&gt;</span> syntaxError
    disconnect dbh

add dbh url <span class="token3">=</span>
    <span class="token1">do</span> addPodcast dbh pc
       commit dbh
    where pc <span class="token3">=</span> Podcast <span class="token">{</span>castId <span class="token3">=</span> <span class="token2">0</span><span class="token">,</span> castURL <span class="token3">=</span> url<span class="token">}</span>

update dbh <span class="token3">=</span>
    <span class="token1">do</span> pclist <span class="token3">&lt;</span><span class="token3">-</span> getPodcasts dbh
       mapM_ procPodcast pclist
    where procPodcast pc <span class="token3">=</span>
              <span class="token1">do</span> putStrLn $ <span class="token4">"Updating from "</span> <span class="token3">++</span> <span class="token">(</span>castURL pc<span class="token">)</span>
                 updatePodcastFromFeed dbh pc

download dbh <span class="token3">=</span>
    <span class="token1">do</span> pclist <span class="token3">&lt;</span><span class="token3">-</span> getPodcasts dbh
       mapM_ procPodcast pclist
    where procPodcast pc <span class="token3">=</span>
              <span class="token1">do</span> putStrLn $ <span class="token4">"Considering "</span> <span class="token3">++</span> <span class="token">(</span>castURL pc<span class="token">)</span>
                 episodelist <span class="token3">&lt;</span><span class="token3">-</span> getPodcastEpisodes dbh pc
                 let dleps <span class="token3">=</span> filter <span class="token">(</span>\ep <span class="token3">-</span><span class="token3">&gt;</span> epDone ep <span class="token3">==</span> False<span class="token">)</span>
                             episodelist
                 mapM_ procEpisode dleps
          procEpisode ep <span class="token3">=</span>
              <span class="token1">do</span> putStrLn $ <span class="token4">"Downloading "</span> <span class="token3">++</span> <span class="token">(</span>epURL ep<span class="token">)</span>
                 getEpisode dbh ep

syntaxError <span class="token3">=</span> putStrLn
  <span class="token4">"Usage: pod command [args]\n\
  \\n\
  \pod add url      Adds a new podcast with the given URL\n\
  \pod download     Downloads all pending episodes\n\
  \pod fetch        Updates, then downloads\n\
  \pod update       Downloads podcast feeds, looks for new episodes\n"</span>

</code></pre>
<p class="calibre9">这个程序使用了一个非常简单的命令行解释器，并且这个解释器还包含了一个用于展示命令行语法错误的函数，以及一些用于处理不同命令行参数的小函数。</p>
<p class="calibre9">通过以下命令，可以对这个程序进行编译：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghc <span class="token3">--</span>make <span class="token3">-</span>O2 <span class="token3">-</span>o pod <span class="token3">-</span>package HTTP <span class="token3">-</span>package HaXml <span class="token3">-</span>package network \
    <span class="token3">-</span>package HDBC <span class="token3">-</span>package HDBC<span class="token3">-</span>sqlite3 PodMain<span class="token">.</span>hs

</code></pre>
<p class="calibre9">你也可以通过《创建包》一节介绍的方法，使用 Cabal 文件来构建这个项目：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> ch23<span class="token3">/</span>pod<span class="token">.</span>cabal
Name<span class="token">:</span> pod
Version<span class="token">:</span> <span class="token2">1.0</span><span class="token2">.0</span>
Build<span class="token3">-</span>type<span class="token">:</span> Simple
Build<span class="token3">-</span>Depends<span class="token">:</span> HTTP<span class="token">,</span> HaXml<span class="token">,</span> network<span class="token">,</span> HDBC<span class="token">,</span> HDBC<span class="token3">-</span>sqlite3<span class="token">,</span> base

Executable<span class="token">:</span> pod
Main<span class="token3">-</span>Is<span class="token">:</span> PodMain<span class="token">.</span>hs
GHC<span class="token3">-</span>Options<span class="token">:</span> <span class="token3">-</span>O2

</code></pre>
<p class="calibre9">除此之外，我们还需要一个简单的 Setup.hs 文件：</p>
<pre class="calibre15"><code class="tthhighlight-container">import Distribution<span class="token">.</span>Simple
main <span class="token3">=</span> defaultMain

</code></pre>
<p class="calibre9">如果你是使用 Cabal 进行构建的话，那么只要运行以下代码即可：</p>
<pre class="calibre15"><code class="tthhighlight-container">runghc Setup<span class="token">.</span>hs configure
runghc Setup<span class="token">.</span>hs build

</code></pre>
<p class="calibre9">程序的输出将被放到一个名为 dist 的文件及里面。要将程序安装到系统里面的话，可以运行 runrunghcSetup.hsinstall 。</p>
</div></div></div></div></div></div>
<div id="chp-27.html"><div class="calibre">
<div id="chp-27.html.main" class="calibre1"><div class="root"><div class="article"><h1 class="article-head" id="chp-27.html.calibre_toc_18">第二七章：Socket 和 Syslog</h1><div class="article-body"><h1 class="calibre6"><a id="chp-27.html.Socket__Syslog_0" class="calibre7 pcalibre"></a>第二七章：Socket 和 Syslog</h1>
<h2 class="calibre8"><a id="chp-27.html._2" class="calibre7 pcalibre"></a>基本网络</h2>
<p class="calibre9">本书的前几张，我们讨论了在网络上进行操作的服务。其中两个例子是数据库客户端/服务器和 web 服务。当需要设计新的协议，或者使用没有现成 Haskell 库的协议通信时，将需要使用 Haskell 库函数提供的底层网络工具。</p>
<p class="calibre9">本章中，我们将讨论这些底层工具。网络通讯是个大题目，可以用一整本书来讨论。本章中，我们将展示如何使用 Haskell 应用你已经掌握的底层网络知识。</p>
<p class="calibre9">Haskell 的网络函数几乎始终与常见的 C 函数调用相符。像其他在 C 上层的语言一样，你将发现其接口很眼熟。</p>
<h2 class="calibre14"><a id="chp-27.html._UDP__10" class="calibre7 pcalibre"></a>使用 UDP 通信</h2>
<p class="calibre9">UDP 将数据拆散为数据包。其不保证数据到达目的地，也不确保同一个数据包到达的次数。其用校验和的方式确保到达的数据包没有损坏。 UDP 适合用在对性能和延迟敏感的应用中，此类场景中系统的整体性能比单个数据包更重要。也可以用在 TCP 表现性能不高的场景，比如发送互不相关的短消息。适合使用 UDP 的系统的例子包括音频和视频会议、时间同步、网络文件系统、以及日志系统。</p>
<h2 class="calibre14"><a id="chp-27.html.UDP_syslog_14" class="calibre7 pcalibre"></a>UDP 客户端例子：syslog</h2>
<p class="calibre9">传统 Unix syslog 服务允许程序通过网络向某个负责记录的中央服务器发送日志信息。某些程序对性能非常敏感，而且可能会生成大量日志消息。这样的程序，将日志的开销最小化比确保每条日志被记录更重要。此外，在日志服务器无法访问时，使程序依旧可以操作或许是一种可取的设计。因此，UDP 是一种 syslog 支持的日志传输协议。这种协议比较简单，这里有一个 Haskell 实现的客户端：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch27<span class="token3">/</span>syslogclient<span class="token">.</span>hs
import Data<span class="token">.</span>Bits
import Network<span class="token">.</span>Socket
import Network<span class="token">.</span>BSD
import Data<span class="token">.</span>List
import SyslogTypes

data SyslogHandle <span class="token3">=</span>
    SyslogHandle <span class="token">{</span>slSocket <span class="token">:</span><span class="token">:</span> Socket<span class="token">,</span>
                  slProgram <span class="token">:</span><span class="token">:</span> String<span class="token">,</span>
                  slAddress <span class="token">:</span><span class="token">:</span> SockAddr<span class="token">}</span>

openlog <span class="token">:</span><span class="token">:</span> HostName             <span class="token3">--</span> <span class="token3">^</span> Remote hostname<span class="token">,</span> or localhost
        <span class="token3">-</span><span class="token3">&gt;</span> String               <span class="token3">--</span> <span class="token3">^</span> Port number or name<span class="token">;</span> <span class="token2">514</span> is default
        <span class="token3">-</span><span class="token3">&gt;</span> String               <span class="token3">--</span> <span class="token3">^</span> Name to log under
        <span class="token3">-</span><span class="token3">&gt;</span> IO SyslogHandle      <span class="token3">--</span> <span class="token3">^</span> Handle to use <span class="token1">for</span> logging
openlog hostname port progname <span class="token3">=</span>
    <span class="token1">do</span> <span class="token3">--</span> Look up the hostname and port<span class="token">.</span>  Either raises an exception
       <span class="token3">--</span> or returns a nonempty list<span class="token">.</span>  First element <span class="token1">in</span> that list
       <span class="token3">--</span> is supposed to be the best option<span class="token">.</span>
       addrinfos <span class="token3">&lt;</span><span class="token3">-</span> getAddrInfo Nothing <span class="token">(</span>Just hostname<span class="token">)</span> <span class="token">(</span>Just port<span class="token">)</span>
       let serveraddr <span class="token3">=</span> head addrinfos

       <span class="token3">--</span> Establish a socket <span class="token1">for</span> communication
       sock <span class="token3">&lt;</span><span class="token3">-</span> socket <span class="token">(</span>addrFamily serveraddr<span class="token">)</span> Datagram defaultProtocol

       <span class="token3">--</span> Save off the socket<span class="token">,</span> program name<span class="token">,</span> and server address <span class="token1">in</span> a handle
       <span class="token1">return</span> $ SyslogHandle sock progname <span class="token">(</span>addrAddress serveraddr<span class="token">)</span>

syslog <span class="token">:</span><span class="token">:</span> SyslogHandle <span class="token3">-</span><span class="token3">&gt;</span> Facility <span class="token3">-</span><span class="token3">&gt;</span> Priority <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
syslog syslogh fac pri msg <span class="token3">=</span>
    sendstr sendmsg
    where code <span class="token3">=</span> makeCode fac pri
          sendmsg <span class="token3">=</span> <span class="token4">"&lt;"</span> <span class="token3">++</span> show code <span class="token3">++</span> <span class="token4">"&gt;"</span> <span class="token3">++</span> <span class="token">(</span>slProgram syslogh<span class="token">)</span> <span class="token3">++</span>
                    <span class="token4">": "</span> <span class="token3">++</span> msg

          <span class="token3">--</span> Send until everything is done
          sendstr <span class="token">:</span><span class="token">:</span> String <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
          sendstr <span class="token">[</span><span class="token">]</span> <span class="token3">=</span> <span class="token1">return</span> <span class="token">(</span><span class="token">)</span>
          sendstr omsg <span class="token3">=</span> <span class="token1">do</span> sent <span class="token3">&lt;</span><span class="token3">-</span> sendTo <span class="token">(</span>slSocket syslogh<span class="token">)</span> omsg
                                    <span class="token">(</span>slAddress syslogh<span class="token">)</span>
                            sendstr <span class="token">(</span>genericDrop sent omsg<span class="token">)</span>

closelog <span class="token">:</span><span class="token">:</span> SyslogHandle <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
closelog syslogh <span class="token3">=</span> sClose <span class="token">(</span>slSocket syslogh<span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Convert a facility and a priority into a syslog code <span class="token3">-</span><span class="token">}</span>
makeCode <span class="token">:</span><span class="token">:</span> Facility <span class="token3">-</span><span class="token3">&gt;</span> Priority <span class="token3">-</span><span class="token3">&gt;</span> Int
makeCode fac pri <span class="token3">=</span>
    let faccode <span class="token3">=</span> codeOfFac fac
        pricode <span class="token3">=</span> fromEnum pri
        <span class="token1">in</span>
          <span class="token">(</span>faccode `shiftL` <span class="token2">3</span><span class="token">)</span> <span class="token">.</span><span class="token3">|</span><span class="token">.</span> pricode

</code></pre>
<p class="calibre9">这段程序需要 SyslogTypes.hs ，代码如下：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch27<span class="token3">/</span>SyslogTypes<span class="token">.</span>hs
module SyslogTypes where
<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Priorities define how important a log message is<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>

data Priority <span class="token3">=</span>
            DEBUG                   <span class="token3">--</span> <span class="token3">^</span> Debug messages
          <span class="token3">|</span> INFO                    <span class="token3">--</span> <span class="token3">^</span> Information
          <span class="token3">|</span> NOTICE                  <span class="token3">--</span> <span class="token3">^</span> Normal runtime conditions
          <span class="token3">|</span> WARNING                 <span class="token3">--</span> <span class="token3">^</span> General Warnings
          <span class="token3">|</span> ERROR                   <span class="token3">--</span> <span class="token3">^</span> General Errors
          <span class="token3">|</span> CRITICAL                <span class="token3">--</span> <span class="token3">^</span> Severe situations
          <span class="token3">|</span> ALERT                   <span class="token3">--</span> <span class="token3">^</span> Take immediate action
          <span class="token3">|</span> EMERGENCY               <span class="token3">--</span> <span class="token3">^</span> System is unusable
                    deriving <span class="token">(</span>Eq<span class="token">,</span> Ord<span class="token">,</span> Show<span class="token">,</span> Read<span class="token">,</span> Enum<span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Facilities are used by the system to determine where messages
are sent<span class="token">.</span> <span class="token3">-</span><span class="token">}</span>

data Facility <span class="token3">=</span>
              KERN                      <span class="token3">--</span> <span class="token3">^</span> Kernel messages
              <span class="token3">|</span> USER                    <span class="token3">--</span> <span class="token3">^</span> General userland messages
              <span class="token3">|</span> MAIL                    <span class="token3">--</span> <span class="token3">^</span> E<span class="token3">-</span>Mail system
              <span class="token3">|</span> DAEMON                  <span class="token3">--</span> <span class="token3">^</span> Daemon <span class="token">(</span>server process<span class="token">)</span> messages
              <span class="token3">|</span> AUTH                    <span class="token3">--</span> <span class="token3">^</span> Authentication or security messages
              <span class="token3">|</span> SYSLOG                  <span class="token3">--</span> <span class="token3">^</span> Internal syslog messages
              <span class="token3">|</span> LPR                     <span class="token3">--</span> <span class="token3">^</span> Printer messages
              <span class="token3">|</span> NEWS                    <span class="token3">--</span> <span class="token3">^</span> Usenet news
              <span class="token3">|</span> UUCP                    <span class="token3">--</span> <span class="token3">^</span> UUCP messages
              <span class="token3">|</span> CRON                    <span class="token3">--</span> <span class="token3">^</span> Cron messages
              <span class="token3">|</span> AUTHPRIV                <span class="token3">--</span> <span class="token3">^</span> Private authentication messages
              <span class="token3">|</span> FTP                     <span class="token3">--</span> <span class="token3">^</span> FTP messages
              <span class="token3">|</span> LOCAL0
              <span class="token3">|</span> LOCAL1
              <span class="token3">|</span> LOCAL2
              <span class="token3">|</span> LOCAL3
              <span class="token3">|</span> LOCAL4
              <span class="token3">|</span> LOCAL5
              <span class="token3">|</span> LOCAL6
              <span class="token3">|</span> LOCAL7
                deriving <span class="token">(</span>Eq<span class="token">,</span> Show<span class="token">,</span> Read<span class="token">)</span>

facToCode <span class="token3">=</span> <span class="token">[</span>
                       <span class="token">(</span>KERN<span class="token">,</span> <span class="token2">0</span><span class="token">)</span><span class="token">,</span>
                       <span class="token">(</span>USER<span class="token">,</span> <span class="token2">1</span><span class="token">)</span><span class="token">,</span>
                       <span class="token">(</span>MAIL<span class="token">,</span> <span class="token2">2</span><span class="token">)</span><span class="token">,</span>
                       <span class="token">(</span>DAEMON<span class="token">,</span> <span class="token2">3</span><span class="token">)</span><span class="token">,</span>
                       <span class="token">(</span>AUTH<span class="token">,</span> <span class="token2">4</span><span class="token">)</span><span class="token">,</span>
                       <span class="token">(</span>SYSLOG<span class="token">,</span> <span class="token2">5</span><span class="token">)</span><span class="token">,</span>
                       <span class="token">(</span>LPR<span class="token">,</span> <span class="token2">6</span><span class="token">)</span><span class="token">,</span>
                       <span class="token">(</span>NEWS<span class="token">,</span> <span class="token2">7</span><span class="token">)</span><span class="token">,</span>
                       <span class="token">(</span>UUCP<span class="token">,</span> <span class="token2">8</span><span class="token">)</span><span class="token">,</span>
                       <span class="token">(</span>CRON<span class="token">,</span> <span class="token2">9</span><span class="token">)</span><span class="token">,</span>
                       <span class="token">(</span>AUTHPRIV<span class="token">,</span> <span class="token2">10</span><span class="token">)</span><span class="token">,</span>
                       <span class="token">(</span>FTP<span class="token">,</span> <span class="token2">11</span><span class="token">)</span><span class="token">,</span>
                       <span class="token">(</span>LOCAL0<span class="token">,</span> <span class="token2">16</span><span class="token">)</span><span class="token">,</span>
                       <span class="token">(</span>LOCAL1<span class="token">,</span> <span class="token2">17</span><span class="token">)</span><span class="token">,</span>
                       <span class="token">(</span>LOCAL2<span class="token">,</span> <span class="token2">18</span><span class="token">)</span><span class="token">,</span>
                       <span class="token">(</span>LOCAL3<span class="token">,</span> <span class="token2">19</span><span class="token">)</span><span class="token">,</span>
                       <span class="token">(</span>LOCAL4<span class="token">,</span> <span class="token2">20</span><span class="token">)</span><span class="token">,</span>
                       <span class="token">(</span>LOCAL5<span class="token">,</span> <span class="token2">21</span><span class="token">)</span><span class="token">,</span>
                       <span class="token">(</span>LOCAL6<span class="token">,</span> <span class="token2">22</span><span class="token">)</span><span class="token">,</span>
                       <span class="token">(</span>LOCAL7<span class="token">,</span> <span class="token2">23</span><span class="token">)</span>
           <span class="token">]</span>

codeToFac <span class="token3">=</span> map <span class="token">(</span>\<span class="token">(</span>x<span class="token">,</span> y<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>y<span class="token">,</span> x<span class="token">)</span><span class="token">)</span> facToCode

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> We can't use enum here because the numbering is discontiguous <span class="token3">-</span><span class="token">}</span>
codeOfFac <span class="token">:</span><span class="token">:</span> Facility <span class="token3">-</span><span class="token3">&gt;</span> Int
codeOfFac f <span class="token3">=</span> case lookup f facToCode of
                Just x <span class="token3">-</span><span class="token3">&gt;</span> x
                _ <span class="token3">-</span><span class="token3">&gt;</span> error $ <span class="token4">"Internal error in codeOfFac"</span>

facOfCode <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> Facility
facOfCode f <span class="token3">=</span> case lookup f codeToFac of
                Just x <span class="token3">-</span><span class="token3">&gt;</span> x
                _ <span class="token3">-</span><span class="token3">&gt;</span> error $ <span class="token4">"Invalid code in facOfCode"</span>

</code></pre>
<p class="calibre9">可以用 ghci 向本地的 syslog 服务器发送消息。服务器可以使用本章实现的例子，也可以使用其它的在 Linux 或者 POSIX 系统中的 syslog 服务器。注意，这些服务器默认禁用了 UDP 端口，你需要启用 UDP 以使 syslog 接收 UDP 消息。</p>
<p class="calibre9">可以使用下面这样的命令向本地 syslog 服务器发送一条消息：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>load syslogclient<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">2</span><span class="token">]</span> Compiling SyslogTypes      <span class="token">(</span> SyslogTypes<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
<span class="token">[</span><span class="token2">2</span> of <span class="token2">2</span><span class="token">]</span> Compiling Main             <span class="token">(</span> syslogclient<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> SyslogTypes<span class="token">,</span> Main<span class="token">.</span>
ghci<span class="token3">&gt;</span> h <span class="token3">&lt;</span><span class="token3">-</span> openlog <span class="token4">"localhost"</span> <span class="token4">"514"</span> <span class="token4">"testprog"</span>
Loading package parsec<span class="token3">-</span><span class="token2">2.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package network<span class="token3">-</span><span class="token2">2.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
ghci<span class="token3">&gt;</span> syslog h USER INFO <span class="token4">"This is my message"</span>
ghci<span class="token3">&gt;</span> closelog h

</code></pre>
<h2 class="calibre14"><a id="chp-27.html.UDP_Syslog__174" class="calibre7 pcalibre"></a>UDP Syslog 服务器</h2>
<p class="calibre9">UDP 服务器会在服务器上绑定某个端口。其接收直接发到这个端口的包，并处理它们。UDP 是无状态的，面向包的协议，程序员通常使用 recvFrom 这个调用接收消息和发送机信息，在发送响应时会用到发送机信息。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch27<span class="token3">/</span>syslogserver<span class="token">.</span>hs
import Data<span class="token">.</span>Bits
import Network<span class="token">.</span>Socket
import Network<span class="token">.</span>BSD
import Data<span class="token">.</span>List

type HandlerFunc <span class="token3">=</span> SockAddr <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>

serveLog <span class="token">:</span><span class="token">:</span> String              <span class="token3">--</span> <span class="token3">^</span> Port number or name<span class="token">;</span> <span class="token2">514</span> is default
         <span class="token3">-</span><span class="token3">&gt;</span> HandlerFunc         <span class="token3">--</span> <span class="token3">^</span> Function to handle incoming messages
         <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
serveLog port handlerfunc <span class="token3">=</span> withSocketsDo $
    <span class="token1">do</span> <span class="token3">--</span> Look up the port<span class="token">.</span>  Either raises an exception or returns
       <span class="token3">--</span> a nonempty list<span class="token">.</span>
       addrinfos <span class="token3">&lt;</span><span class="token3">-</span> getAddrInfo
                    <span class="token">(</span>Just <span class="token">(</span>defaultHints <span class="token">{</span>addrFlags <span class="token3">=</span> <span class="token">[</span>AI_PASSIVE<span class="token">]</span><span class="token">}</span><span class="token">)</span><span class="token">)</span>
                    Nothing <span class="token">(</span>Just port<span class="token">)</span>
       let serveraddr <span class="token3">=</span> head addrinfos

       <span class="token3">--</span> Create a socket
       sock <span class="token3">&lt;</span><span class="token3">-</span> socket <span class="token">(</span>addrFamily serveraddr<span class="token">)</span> Datagram defaultProtocol

       <span class="token3">--</span> Bind it to the address we're listening to
       bindSocket sock <span class="token">(</span>addrAddress serveraddr<span class="token">)</span>

       <span class="token3">--</span> Loop forever processing incoming data<span class="token">.</span>  Ctrl<span class="token3">-</span>C to abort<span class="token">.</span>
       procMessages sock
    where procMessages sock <span class="token3">=</span>
              <span class="token1">do</span> <span class="token3">--</span> Receive one UDP packet<span class="token">,</span> maximum length <span class="token2">1024</span> bytes<span class="token">,</span>
                 <span class="token3">--</span> and save its content into msg and its source
                 <span class="token3">--</span> IP and port into addr
                 <span class="token">(</span>msg<span class="token">,</span> _<span class="token">,</span> addr<span class="token">)</span> <span class="token3">&lt;</span><span class="token3">-</span> recvFrom sock <span class="token2">1024</span>
                 <span class="token3">--</span> Handle it
                 handlerfunc addr msg
                 <span class="token3">--</span> And process more messages
                 procMessages sock

<span class="token3">--</span> A simple handler that prints incoming packets
plainHandler <span class="token">:</span><span class="token">:</span> HandlerFunc
plainHandler addr msg <span class="token3">=</span>
    putStrLn $ <span class="token4">"From "</span> <span class="token3">++</span> show addr <span class="token3">++</span> <span class="token4">": "</span> <span class="token3">++</span> msg

</code></pre>
<p class="calibre9">这段程序可以在 ghci 中执行。执行 serveLog"1514"plainHandler 将建立一个监听 1514 端口的 UDP 服务器。其使用 plainHandler 将每条收到的 UDP 包打印出来。按下 Ctrl-C 可以终止这个程序。</p>
<p class="calibre9">Note</p>
<p class="calibre9">处理错误。执行时收到了 bind:permissiondenied 消息？要确保端口值比 1024 大。某些操作系统不允许 root 之外的用户使用小于 1024 的端口。</p>
<h2 class="calibre14"><a id="chp-27.html._TCP__229" class="calibre7 pcalibre"></a>使用 TCP 通信</h2>
<p class="calibre9">TCP 被设计为确保互联网上的数据尽可能可靠地传输。 TCP 是数据流传输。虽然流在传输时会被操作系统拆散为一个个单独的包，但是应用程序并不需要关心包的边界。TCP 负责确保如果流被传送到应用程序，它就是完整的、无改动、仅传输一次且保证顺序。显然，如果线缆被破坏会导致流量无法送达，任何协议都无法克服这类限制。</p>
<p class="calibre9">与 UDP 相比，这带来一些折衷。首先，在 TCP 会话开始必须传递一些包以建立连接。其次，对于每个短会话，UDP 将有性能优势。另外，TCP 会努力确保数据到达。如果会话的一端尝试向远端发送数据，但是没有收到响应，它将周期性的尝试重新传输数据直至放弃。这使得 TCP 面对丢包时比较健壮可靠。可是，它同样意味着 TCP 不是实时传输协议（如实况音频或视频传输）的最佳选择。</p>
<h2 class="calibre14"><a id="chp-27.html._TCP__235" class="calibre7 pcalibre"></a>处理多个 TCP 流</h2>
<p class="calibre9">TCP 的连接是有状态的。这意味着每个客户机和服务器之间都有一条专用的逻辑“频道”，而不是像 UDP 一样只是处理一次性的数据包。这简化了客户端开发者的工作。服务器端程序几乎总是需要同时处理多条 TCP 连接。如何做到这一点呢？</p>
<p class="calibre9">在服务器端，首先需要创建一个 socket 并绑定到某个端口，就像 UDP 一样。但这回不是重复监听从任意地址发来的数据，取而代之，你的主循环将围绕 accept 调用编写。每当有一个客户机连接，服务器操作系统为其分配一个新的 socket 。所以我们的主 socket 只用来监听进来的连接，但从不发送数据。我们也获得了多个子 socket 可以同时使用，每个子 socket 从属于一个逻辑上的 TCP 会话。</p>
<p class="calibre9">在 Haskell 中，通常使用 forkIO 创建一个单独的轻量级线程以处理与子 socket 的通信。对此， Haskell 拥有一个高效的内部实现，执行得非常好。</p>
<h2 class="calibre14"><a id="chp-27.html.TCP_Syslog__243" class="calibre7 pcalibre"></a>TCP Syslog 服务器</h2>
<p class="calibre9">让我们使用 TCP 的实现来替换 UDP 的 syslog 服务器。假设一条消息并不是定义为单独的包，而是以一个尾部的字符 ‘n' 结束。任意客户端可以使用 TCP 连接向服务器发送 0 或多条消息。我们可以像下面这样实现：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch27<span class="token3">/</span>syslogtcpserver<span class="token">.</span>hs
import Data<span class="token">.</span>Bits
import Network<span class="token">.</span>Socket
import Network<span class="token">.</span>BSD
import Data<span class="token">.</span>List
import Control<span class="token">.</span>Concurrent
import Control<span class="token">.</span>Concurrent<span class="token">.</span>MVar
import System<span class="token">.</span>IO

type HandlerFunc <span class="token3">=</span> SockAddr <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>

serveLog <span class="token">:</span><span class="token">:</span> String              <span class="token3">--</span> <span class="token3">^</span> Port number or name<span class="token">;</span> <span class="token2">514</span> is default
         <span class="token3">-</span><span class="token3">&gt;</span> HandlerFunc         <span class="token3">--</span> <span class="token3">^</span> Function to handle incoming messages
         <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
serveLog port handlerfunc <span class="token3">=</span> withSocketsDo $
    <span class="token1">do</span> <span class="token3">--</span> Look up the port<span class="token">.</span>  Either raises an exception or returns
       <span class="token3">--</span> a nonempty list<span class="token">.</span>
       addrinfos <span class="token3">&lt;</span><span class="token3">-</span> getAddrInfo
                    <span class="token">(</span>Just <span class="token">(</span>defaultHints <span class="token">{</span>addrFlags <span class="token3">=</span> <span class="token">[</span>AI_PASSIVE<span class="token">]</span><span class="token">}</span><span class="token">)</span><span class="token">)</span>
                    Nothing <span class="token">(</span>Just port<span class="token">)</span>
       let serveraddr <span class="token3">=</span> head addrinfos

       <span class="token3">--</span> Create a socket
       sock <span class="token3">&lt;</span><span class="token3">-</span> socket <span class="token">(</span>addrFamily serveraddr<span class="token">)</span> Stream defaultProtocol

       <span class="token3">--</span> Bind it to the address we're listening to
       bindSocket sock <span class="token">(</span>addrAddress serveraddr<span class="token">)</span>

       <span class="token3">--</span> Start listening <span class="token1">for</span> connection requests<span class="token">.</span>  Maximum queue size
       <span class="token3">--</span> of <span class="token2">5</span> connection requests waiting to be accepted<span class="token">.</span>
       listen sock <span class="token2">5</span>

       <span class="token3">--</span> Create a lock to use <span class="token1">for</span> synchronizing access to the handler
       lock <span class="token3">&lt;</span><span class="token3">-</span> newMVar <span class="token">(</span><span class="token">)</span>

       <span class="token3">--</span> Loop forever waiting <span class="token1">for</span> connections<span class="token">.</span>  Ctrl<span class="token3">-</span>C to abort<span class="token">.</span>
       procRequests lock sock

    where
          <span class="token3">--</span> <span class="token3">|</span> Process incoming connection requests
          procRequests <span class="token">:</span><span class="token">:</span> MVar <span class="token">(</span><span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> Socket <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
          procRequests lock mastersock <span class="token3">=</span>
              <span class="token1">do</span> <span class="token">(</span>connsock<span class="token">,</span> clientaddr<span class="token">)</span> <span class="token3">&lt;</span><span class="token3">-</span> accept mastersock
                 handle lock clientaddr
                    <span class="token4">"syslogtcpserver.hs: client connnected"</span>
                 forkIO $ procMessages lock connsock clientaddr
                 procRequests lock mastersock

          <span class="token3">--</span> <span class="token3">|</span> Process incoming messages
          procMessages <span class="token">:</span><span class="token">:</span> MVar <span class="token">(</span><span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> Socket <span class="token3">-</span><span class="token3">&gt;</span> SockAddr <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
          procMessages lock connsock clientaddr <span class="token3">=</span>
              <span class="token1">do</span> connhdl <span class="token3">&lt;</span><span class="token3">-</span> socketToHandle connsock ReadMode
                 hSetBuffering connhdl LineBuffering
                 messages <span class="token3">&lt;</span><span class="token3">-</span> hGetContents connhdl
                 mapM_ <span class="token">(</span>handle lock clientaddr<span class="token">)</span> <span class="token">(</span>lines messages<span class="token">)</span>
                 hClose connhdl
                 handle lock clientaddr
                    <span class="token4">"syslogtcpserver.hs: client disconnected"</span>

          <span class="token3">--</span> Lock the handler before passing data to it<span class="token">.</span>
          handle <span class="token">:</span><span class="token">:</span> MVar <span class="token">(</span><span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> HandlerFunc
          <span class="token3">--</span> This type is the same as
          <span class="token3">--</span> handle <span class="token">:</span><span class="token">:</span> MVar <span class="token">(</span><span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> SockAddr <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
          handle lock clientaddr msg <span class="token3">=</span>
              withMVar lock
                 <span class="token">(</span>\a <span class="token3">-</span><span class="token3">&gt;</span> handlerfunc clientaddr msg <span class="token3">&gt;</span><span class="token3">&gt;</span> <span class="token1">return</span> a<span class="token">)</span>

<span class="token3">--</span> A simple handler that prints incoming packets
plainHandler <span class="token">:</span><span class="token">:</span> HandlerFunc
plainHandler addr msg <span class="token3">=</span>
    putStrLn $ <span class="token4">"From "</span> <span class="token3">++</span> show addr <span class="token3">++</span> <span class="token4">": "</span> <span class="token3">++</span> msg

</code></pre>
<p class="calibre9">SyslogTypes 的实现，见 <a href="#chp-27.html." class="calibre7 pcalibre"><em class="calibre13">UDP 客户端例子：syslog</em></a> 。</p>
<p class="calibre9">让我们读一下源码。主循环是 procRequests ，这是一个死循环，用于等待来自客户端的新连接。 accept 调用将一直阻塞，直到一个客户端来连接。当有客户端连接，我们获得一个新 socket 和客户机地址。我们向处理函数发送一条关于新连接的消息，接着使用 forkIO 建立一个线程处理来自客户机的数据。这条线程执行 procMessages 。</p>
<p class="calibre9">处理 TCP 数据时，为了方便，通常将 socket 转换为 Haskell 句柄。我们也同样处理，并明确设置了缓冲 – 一个 TCP 通信的要点。接着，设置惰性读取 socket 句柄。对每个传入的行，我们都将其传给 handle 。当没有更多数据时 – 远端已经关闭了 socket – 我们输出一条会话结束的消息。</p>
<p class="calibre9">因为可能同时收到多条消息，我们需要确保没有将多条消息同时写入一个处理函数。那将导致混乱的输出。我们使用了一个简单的锁以序列化对处理函数的访问，并且编写了一个简单的 handle 函数处理它。</p>
<p class="calibre9">你可以使用下面我们将展示的客户机代码测试，或者直接使用 telnet 程序来连接这个服务器。你向其发送的每一行输入都将被服务器原样返回。我们来试一下：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>load syslogtcpserver<span class="token">.</span>hs
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> syslogtcpserver<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>
ghci<span class="token3">&gt;</span> serveLog <span class="token4">"10514"</span> plainHandler
Loading package parsec<span class="token3">-</span><span class="token2">2.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package network<span class="token3">-</span><span class="token2">2.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>

</code></pre>
<p class="calibre9">此处，服务器从 10514 端口监听新连接。在有某个客户机过来连接之前，它什么事儿都不做。我们可以使用 telnet 来连接这个服务器：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">~</span>$ telnet localhost <span class="token2">10514</span>
Trying <span class="token2">127.0</span><span class="token2">.0</span><span class="token2">.1</span><span class="token">.</span><span class="token">.</span><span class="token">.</span>
Connected to localhost<span class="token">.</span>
Escape character is <span class="token4">'^]'</span><span class="token">.</span>
Test message
<span class="token3">^</span><span class="token">]</span>
telnet<span class="token3">&gt;</span> quit
Connection closed<span class="token">.</span>

</code></pre>
<p class="calibre9">于此同时，在我们运行 TCP 服务器的终端上，你将看到如下输出：</p>
<pre class="calibre15"><code class="tthhighlight-container">From <span class="token2">127.0</span><span class="token2">.0</span><span class="token2">.1</span><span class="token">:</span><span class="token2">38790</span><span class="token">:</span> syslogtcpserver<span class="token">.</span>hs<span class="token">:</span> client connnected
From <span class="token2">127.0</span><span class="token2">.0</span><span class="token2">.1</span><span class="token">:</span><span class="token2">38790</span><span class="token">:</span> Test message
From <span class="token2">127.0</span><span class="token2">.0</span><span class="token2">.1</span><span class="token">:</span><span class="token2">38790</span><span class="token">:</span> syslogtcpserver<span class="token">.</span>hs<span class="token">:</span> client disconnected

</code></pre>
<p class="calibre9">其显示一个客户端从本机 (127.0.0.1) 的 38790 端口连上了主机。连接之后，它发送了一条消息，然后断开。当你扮演一个 TCP 客户端时，操作系统将分配一个未被使用的端口给你。通常这个端口在你每次运行程序时都不一样。</p>
<h2 class="calibre14"><a id="chp-27.html.TCP_Syslog__365" class="calibre7 pcalibre"></a>TCP Syslog 客户端</h2>
<p class="calibre9">现在，为我们的 TCP syslog 协议编写一个客户端。这个客户端与 UDP 客户端类似，但是有一些变化。首先，因为 TCP 是流式协议，我们可以使用句柄传输数据而不需要使用底层的 socket 操作。其次，不在需要在 SyslogHandle 中保存目的地址，因为我们将使用 connect 建立 TCP 连接。最后，我们需要一个途径，以区分不同的消息。UDP 中，这很容易，因为每条消息都是不相关的逻辑包。TCP 中，我们将仅使用换行符 ‘n' 来作为消息结尾的标识，尽管这意味着不能在单条消息中发送多行信息。这是代码：</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch27<span class="token3">/</span>syslogtcpclient<span class="token">.</span>hs
import Data<span class="token">.</span>Bits
import Network<span class="token">.</span>Socket
import Network<span class="token">.</span>BSD
import Data<span class="token">.</span>List
import SyslogTypes
import System<span class="token">.</span>IO

data SyslogHandle <span class="token3">=</span>
    SyslogHandle <span class="token">{</span>slHandle <span class="token">:</span><span class="token">:</span> Handle<span class="token">,</span>
                  slProgram <span class="token">:</span><span class="token">:</span> String<span class="token">}</span>

openlog <span class="token">:</span><span class="token">:</span> HostName             <span class="token3">--</span> <span class="token3">^</span> Remote hostname<span class="token">,</span> or localhost
        <span class="token3">-</span><span class="token3">&gt;</span> String               <span class="token3">--</span> <span class="token3">^</span> Port number or name<span class="token">;</span> <span class="token2">514</span> is default
        <span class="token3">-</span><span class="token3">&gt;</span> String               <span class="token3">--</span> <span class="token3">^</span> Name to log under
        <span class="token3">-</span><span class="token3">&gt;</span> IO SyslogHandle      <span class="token3">--</span> <span class="token3">^</span> Handle to use <span class="token1">for</span> logging
openlog hostname port progname <span class="token3">=</span>
    <span class="token1">do</span> <span class="token3">--</span> Look up the hostname and port<span class="token">.</span>  Either raises an exception
       <span class="token3">--</span> or returns a nonempty list<span class="token">.</span>  First element <span class="token1">in</span> that list
       <span class="token3">--</span> is supposed to be the best option<span class="token">.</span>
       addrinfos <span class="token3">&lt;</span><span class="token3">-</span> getAddrInfo Nothing <span class="token">(</span>Just hostname<span class="token">)</span> <span class="token">(</span>Just port<span class="token">)</span>
       let serveraddr <span class="token3">=</span> head addrinfos

       <span class="token3">--</span> Establish a socket <span class="token1">for</span> communication
       sock <span class="token3">&lt;</span><span class="token3">-</span> socket <span class="token">(</span>addrFamily serveraddr<span class="token">)</span> Stream defaultProtocol

       <span class="token3">--</span> Mark the socket <span class="token1">for</span> keep<span class="token3">-</span>alive handling since it may be idle
       <span class="token3">--</span> <span class="token1">for</span> long periods of time
       setSocketOption sock KeepAlive <span class="token2">1</span>

       <span class="token3">--</span> Connect to server
       connect sock <span class="token">(</span>addrAddress serveraddr<span class="token">)</span>

       <span class="token3">--</span> Make a Handle out of it <span class="token1">for</span> convenience
       h <span class="token3">&lt;</span><span class="token3">-</span> socketToHandle sock WriteMode

       <span class="token3">--</span> We're going to set buffering to BlockBuffering and then
       <span class="token3">--</span> explicitly call hFlush after each message<span class="token">,</span> below<span class="token">,</span> so that
       <span class="token3">--</span> messages get logged immediately
       hSetBuffering h <span class="token">(</span>BlockBuffering Nothing<span class="token">)</span>

       <span class="token3">--</span> Save off the socket<span class="token">,</span> program name<span class="token">,</span> and server address <span class="token1">in</span> a handle
       <span class="token1">return</span> $ SyslogHandle h progname

syslog <span class="token">:</span><span class="token">:</span> SyslogHandle <span class="token3">-</span><span class="token3">&gt;</span> Facility <span class="token3">-</span><span class="token3">&gt;</span> Priority <span class="token3">-</span><span class="token3">&gt;</span> String <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
syslog syslogh fac pri msg <span class="token3">=</span>
    <span class="token1">do</span> hPutStrLn <span class="token">(</span>slHandle syslogh<span class="token">)</span> sendmsg
       <span class="token3">--</span> Make sure that we send data immediately
       hFlush <span class="token">(</span>slHandle syslogh<span class="token">)</span>
    where code <span class="token3">=</span> makeCode fac pri
          sendmsg <span class="token3">=</span> <span class="token4">"&lt;"</span> <span class="token3">++</span> show code <span class="token3">++</span> <span class="token4">"&gt;"</span> <span class="token3">++</span> <span class="token">(</span>slProgram syslogh<span class="token">)</span> <span class="token3">++</span>
                    <span class="token4">": "</span> <span class="token3">++</span> msg

closelog <span class="token">:</span><span class="token">:</span> SyslogHandle <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
closelog syslogh <span class="token3">=</span> hClose <span class="token">(</span>slHandle syslogh<span class="token">)</span>

<span class="token">{</span><span class="token3">-</span> <span class="token3">|</span> Convert a facility and a priority into a syslog code <span class="token3">-</span><span class="token">}</span>
makeCode <span class="token">:</span><span class="token">:</span> Facility <span class="token3">-</span><span class="token3">&gt;</span> Priority <span class="token3">-</span><span class="token3">&gt;</span> Int
makeCode fac pri <span class="token3">=</span>
    let faccode <span class="token3">=</span> codeOfFac fac
        pricode <span class="token3">=</span> fromEnum pri
        <span class="token1">in</span>
          <span class="token">(</span>faccode `shiftL` <span class="token2">3</span><span class="token">)</span> <span class="token">.</span><span class="token3">|</span><span class="token">.</span> pricode

</code></pre>
<p class="calibre9">可以在 ghci 中试着运行它。如果还没有关闭之前的 TCP 服务器，你的会话看上去可能会像是这样：</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>load syslogtcpclient<span class="token">.</span>hs
Loading package base <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
<span class="token">[</span><span class="token2">1</span> of <span class="token2">2</span><span class="token">]</span> Compiling SyslogTypes      <span class="token">(</span> SyslogTypes<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
<span class="token">[</span><span class="token2">2</span> of <span class="token2">2</span><span class="token">]</span> Compiling Main             <span class="token">(</span> syslogtcpclient<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">,</span> SyslogTypes<span class="token">.</span>
ghci<span class="token3">&gt;</span> openlog <span class="token4">"localhost"</span> <span class="token4">"10514"</span> <span class="token4">"tcptest"</span>
Loading package parsec<span class="token3">-</span><span class="token2">2.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package network<span class="token3">-</span><span class="token2">2.1</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
ghci<span class="token3">&gt;</span> sl <span class="token3">&lt;</span><span class="token3">-</span> openlog <span class="token4">"localhost"</span> <span class="token4">"10514"</span> <span class="token4">"tcptest"</span>
ghci<span class="token3">&gt;</span> syslog sl USER INFO <span class="token4">"This is my TCP message"</span>
ghci<span class="token3">&gt;</span> syslog sl USER INFO <span class="token4">"This is my TCP message again"</span>
ghci<span class="token3">&gt;</span> closelog sl

</code></pre>
<p class="calibre9">结束时，服务器上将看到这样的输出：</p>
<pre class="calibre15"><code class="tthhighlight-container">From <span class="token2">127.0</span><span class="token2">.0</span><span class="token2">.1</span><span class="token">:</span><span class="token2">46319</span><span class="token">:</span> syslogtcpserver<span class="token">.</span>hs<span class="token">:</span> client connnected
From <span class="token2">127.0</span><span class="token2">.0</span><span class="token2">.1</span><span class="token">:</span><span class="token2">46319</span><span class="token">:</span> <span class="token3">&lt;</span><span class="token2">9</span><span class="token3">&gt;</span>tcptest<span class="token">:</span> This is my TCP message
From <span class="token2">127.0</span><span class="token2">.0</span><span class="token2">.1</span><span class="token">:</span><span class="token2">46319</span><span class="token">:</span> <span class="token3">&lt;</span><span class="token2">9</span><span class="token3">&gt;</span>tcptest<span class="token">:</span> This is my TCP message again
From <span class="token2">127.0</span><span class="token2">.0</span><span class="token2">.1</span><span class="token">:</span><span class="token2">46319</span><span class="token">:</span> syslogtcpserver<span class="token">.</span>hs<span class="token">:</span> client disconnected

</code></pre>
<p class="calibre9">&lt;9&gt; 是优先级和设施代码，和之前 UDP 例子中的意思一样。</p>
</div></div></div></div></div></div>
<div id="chp-28.html"><div class="calibre">
<div id="chp-28.html.main" class="calibre1"><div class="root"><div class="article"><h1 class="article-head" id="chp-28.html.calibre_toc_19">第二十八章：软件事务内存 (STM)</h1><div class="article-body"><h1 class="calibre6"><a id="chp-28.html._STM_0" class="calibre7 pcalibre"></a>第二十八章：软件事务内存 (STM)</h1>
<p class="calibre9">在并发编程的传统线程模型中，线程之间的数据共享需要通过锁来保持一致性(consistentBalance)，当数据产生变化时，还需要使用条件变量(condition variable)对各个线程进行通知。</p>
<p class="calibre9">某种程度上，Haskell 的 MVar 机制对上面提到的工具进行了改进，但是，它仍然带有和这些工具一样的缺陷：</p>
<ul class="calibre10"><li class="calibre11">因为忘记使用锁而导致条件竞争(race condition)</li><li class="calibre11">因为不正确的加锁顺序而导致死锁(deadblock)</li><li class="calibre11">因为未被捕捉的异常而造成程序崩溃(corruption)</li><li class="calibre11">因为错误地忽略了通知，造成线程无法正常唤醒(lost wakeup)</li></ul>
<p class="calibre9">这些问题即使在很小的并发程序里也会经常发生，而在更加庞大的代码库或是高负载的情况下，这些问题会引发更加糟糕的难题。</p>
<p class="calibre9">比如说，对一个只有几个大范围锁的程序进行编程并不难，只是一旦这个程序在高负载的环境下运行，锁之间的相互竞争就会变得非常严重。另一方面，如果采用细粒度(fineo-grained)的锁机制，保持软件正常工作将会变得非常困难。除此之外，就算在负载不高的情况下, 加锁带来的额外的簿记工作(book-keeping)也会对性能产生影响。</p>
<h2 class="calibre14"><a id="chp-28.html._15" class="calibre7 pcalibre"></a>基础知识</h2>
<p class="calibre9">软件事务内存(Software transactional memory)提供了一些简单但强大的工具。通过这些工具我们可以解决前面提到的大多数问题。通过 atomically 组合器(combinator), 我们可以在一个事务内执行一批操作。当这一组操作开始执行的时候，其他线程是觉察不到这些操作所产生的任何修改，直到所有操作完成。同样的，当前线程也无法察觉其他线程的所产生的修改。这些性质表明的操作的隔离性(isolated)。</p>
<p class="calibre9">当从一个事务退出的时候，只会发生以下情况中的一种:</p>
<ul class="calibre10"><li class="calibre11">如果没有其他线程修改了同样的数据，当前线程产生的修改将会对所有其他线程可见。</li><li class="calibre11">否则，当前线程的所产生的改动会被丢弃，然后这组操作会被重新执行。</li></ul>
<blockquote class="default"><p class="calibre9">atomically 这种全有或全无(all-or-nothing)的天性被称之为原子性(atomic)， atomically 也因为得名。如果你使用过支持事务的数据库，你会觉得STM使用起来非常熟悉。</p></blockquote>
<h2 class="calibre14"><a id="chp-28.html._26" class="calibre7 pcalibre"></a>一些简单的例子</h2>
<p class="calibre9">在多玩家角色扮演的游戏里， 一个玩家的角色会有许多属性，比如健康，财产以及金钱。让我们从基于游戏人物属性的一些简单的函数和类型开始去了解STM的精彩内容。随着学习的深入，我们也会不断地改进我们的代码。</p>
<p class="calibre9">STM的API位于 stm 包，模块 Control.Concurrent.STM 。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>GameInventory<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span># LANGUAGE GeneralizedNewtypeDeriving #<span class="token3">-</span><span class="token">}</span>

import Control<span class="token">.</span>Concurrent<span class="token">.</span>STM
import Control<span class="token">.</span>Monad

data Item <span class="token3">=</span> Scroll
          <span class="token3">|</span> Wand
          <span class="token3">|</span> Banjo
            deriving <span class="token">(</span>Eq<span class="token">,</span> Ord<span class="token">,</span> Show<span class="token">)</span>

newtype Gold <span class="token3">=</span> Gold Int
    deriving <span class="token">(</span>Eq<span class="token">,</span> Ord<span class="token">,</span> Show<span class="token">,</span> Num<span class="token">)</span>

newtype HitPoint <span class="token3">=</span> HitPoint Int
    deriving <span class="token">(</span>Eq<span class="token">,</span> Ord<span class="token">,</span> Show<span class="token">,</span> Num<span class="token">)</span>

type Inventory <span class="token3">=</span> TVar <span class="token">[</span>Item<span class="token">]</span>
type Health <span class="token3">=</span> TVar HitPoint
type Balance <span class="token3">=</span> TVar Gold

data Player <span class="token3">=</span> Player <span class="token">{</span>
      balance <span class="token">:</span><span class="token">:</span> Balance<span class="token">,</span>
      health <span class="token">:</span><span class="token">:</span> Health<span class="token">,</span>
      inventory <span class="token">:</span><span class="token">:</span> Inventory
<span class="token">}</span>

</code></pre>
<p class="calibre9">参数化类型 TVar 是一个可变量，可以在 atomically 块中读取或者修改。为了简单起见，我们把玩家的背包(Inventory)定义为物品的列表。同时注意到，我们用到了 newtype ，这样不会混淆财富和健康属性。</p>
<p class="calibre9">当需要在两个账户(Balance)之间转账，我们所要的做的就只是调整下各自的 Tvar 。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>GameInventory<span class="token">.</span>hs
basicTransfer qty fromBal toBal <span class="token3">=</span> <span class="token1">do</span>
  fromQty <span class="token3">&lt;</span><span class="token3">-</span> readTVar fromBal
  toQty   <span class="token3">&lt;</span><span class="token3">-</span> readTVar toBal
  writeTVar fromBal <span class="token">(</span>fromQty <span class="token3">-</span> qty<span class="token">)</span>
  writeTVar toBal   <span class="token">(</span>toQty <span class="token3">+</span> qty<span class="token">)</span>

</code></pre>
<p class="calibre9">让我们写个简单的测试函数</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>GameInventory<span class="token">.</span>hs
transferTest <span class="token3">=</span> <span class="token1">do</span>
  alice <span class="token3">&lt;</span><span class="token3">-</span> newTVar <span class="token">(</span><span class="token2">12</span> <span class="token">:</span><span class="token">:</span> Gold<span class="token">)</span>
  bob   <span class="token3">&lt;</span><span class="token3">-</span> newTVar <span class="token2">4</span>
  basicTransfer <span class="token2">3</span> alice bob
  liftM2 <span class="token">(</span><span class="token">,</span><span class="token">)</span> <span class="token">(</span>readTVar alice<span class="token">)</span> <span class="token">(</span>readTVar bob<span class="token">)</span>

</code></pre>
<p class="calibre9">如果我们在ghci里执行下这个函数，应该有如下的结果</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>load GameInventory
<span class="token">[</span><span class="token2">1</span> of <span class="token2">1</span><span class="token">]</span> Compiling Main             <span class="token">(</span> GameInventory<span class="token">.</span>hs<span class="token">,</span> interpreted <span class="token">)</span>
Ok<span class="token">,</span> modules loaded<span class="token">:</span> Main<span class="token">.</span>
ghci<span class="token3">&gt;</span> atomically transferTest
Loading package array<span class="token3">-</span><span class="token2">0.4</span><span class="token2">.0</span><span class="token2">.0</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
Loading package stm<span class="token3">-</span><span class="token2">2.3</span> <span class="token">.</span><span class="token">.</span><span class="token">.</span> linking <span class="token">.</span><span class="token">.</span><span class="token">.</span> done<span class="token">.</span>
<span class="token">(</span>Gold <span class="token2">9</span><span class="token">,</span>Gold <span class="token2">7</span><span class="token">)</span>

</code></pre>
<p class="calibre9">原子性和隔离性保证了当其他线程同时看到 bob 的账户和 alice 的账户被修改了。</p>
<p class="calibre9">即使在并发程序里，我们也努力保持代码尽量的纯函数化。这使得我们的代码更加容易推导和测试。由于数据并没有事务性，这也让底层的STM做更少的事。以下的纯函数实现了从我们来表示玩家背包的数列里移除一个物品。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>GameInventory<span class="token">.</span>hs
removeInv <span class="token">:</span><span class="token">:</span> Eq a <span class="token3">=</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Maybe <span class="token">[</span>a<span class="token">]</span>
removeInv x xs <span class="token3">=</span>
    case takeWhile <span class="token">(</span><span class="token3">/</span><span class="token3">=</span> x<span class="token">)</span> xs of
      <span class="token">(</span>_<span class="token">:</span>ys<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> Just ys
      <span class="token">[</span><span class="token">]</span>     <span class="token3">-</span><span class="token3">&gt;</span> Nothing

</code></pre>
<p class="calibre9">这里返回值用了 Maybe 类型，它可以用来表示物品是否在玩家的背包里。</p>
<p class="calibre9">下面这个事务性的函数实现了把一个物品给另外一个玩家。这个函数有一点点复杂因为需要判断给予者是否有这个物品。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>GameInventory<span class="token">.</span>hs
maybeGiveItem item fromInv toInv <span class="token3">=</span> <span class="token1">do</span>
  fromList <span class="token3">&lt;</span><span class="token3">-</span> readTVar fromInv
  case removeInv item fromList of
    Nothing      <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> False
    Just newList <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">do</span>
      writeTVar fromInv newList
      destItems <span class="token3">&lt;</span><span class="token3">-</span> readTVar toInv
      writeTVar toInv <span class="token">(</span>item <span class="token">:</span> destItems<span class="token">)</span>
      <span class="token1">return</span> True

</code></pre>
<h2 class="calibre14"><a id="chp-28.html.STM_133" class="calibre7 pcalibre"></a>STM的安全性</h2>
<p class="calibre9">既然我们提供了有原子性和隔离型的事务，那么保证我们不能有意或是无意的从 atomically 执行块从脱离显得格外重要。借由 STM monad，Haskell的类型系统保证了我们这种行为。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type atomically
atomically <span class="token">:</span><span class="token">:</span> STM a <span class="token3">-</span><span class="token3">&gt;</span> IO a

</code></pre>
<p class="calibre9">atomically 接受一个 STM monad的动作， 然后执行并让我们可以从 IO monad里拿到这个结果。 STM monad是所有事务相关代码执行的地方。比如这些操作 TVar 值的函数都在 STM monad里被执行。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type newTVar
newTVar <span class="token">:</span><span class="token">:</span> a <span class="token3">-</span><span class="token3">&gt;</span> STM <span class="token">(</span>TVar a<span class="token">)</span>
ghci<span class="token3">&gt;</span> <span class="token">:</span>type readTVar
readTVar <span class="token">:</span><span class="token">:</span> TVar a <span class="token3">-</span><span class="token3">&gt;</span> STM a
ghci<span class="token3">&gt;</span> <span class="token">:</span>type writeTVar
writeTVar <span class="token">:</span><span class="token">:</span> TVar a <span class="token3">-</span><span class="token3">&gt;</span> a <span class="token3">-</span><span class="token3">&gt;</span> STM <span class="token">(</span><span class="token">)</span>

</code></pre>
<p class="calibre9">我们之前定义的事务性函数也有这个特性</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>GameInventory<span class="token">.</span>hs
basicTransfer <span class="token">:</span><span class="token">:</span> Gold <span class="token3">-</span><span class="token3">&gt;</span> Balance <span class="token3">-</span><span class="token3">&gt;</span> Balance <span class="token3">-</span><span class="token3">&gt;</span> STM <span class="token">(</span><span class="token">)</span>
maybeGiveItem <span class="token">:</span><span class="token">:</span> Item <span class="token3">-</span><span class="token3">&gt;</span> Inventory <span class="token3">-</span><span class="token3">&gt;</span> Inventory <span class="token3">-</span><span class="token3">&gt;</span> STM Bool

</code></pre>
<p class="calibre9">在 STM monad里是不允许执行I/O操作或者是修改非事务性的可变状态，比如 MVar 的值。这就使得我们可以避免那些违背事务完整的操作。</p>
<h2 class="calibre14"><a id="chp-28.html._166" class="calibre7 pcalibre"></a>重试一个事务</h2>
<p class="calibre9">maybeGiveItem 这个函数看上去稍微有点怪异。只有当角色有这个物品时才会将它给另外一个角色，这看上去还算合理，然后返回一个 Bool 值使调用这个函数的代码变得复杂。下面这个函数调用了 maybeGiveItem, 它必须根据 maybeGiveItem 的返回结果来决定如何继续执行。</p>
<pre class="calibre15"><code class="tthhighlight-container">maybeSellItem <span class="token">:</span><span class="token">:</span> Item <span class="token3">-</span><span class="token3">&gt;</span> Gold <span class="token3">-</span><span class="token3">&gt;</span> Player <span class="token3">-</span><span class="token3">&gt;</span> Player <span class="token3">-</span><span class="token3">&gt;</span> STM Bool
maybeSellItem item price buyer seller <span class="token3">=</span> <span class="token1">do</span>
  given <span class="token3">&lt;</span><span class="token3">-</span> maybeGiveItem item <span class="token">(</span>inventory seller<span class="token">)</span> <span class="token">(</span>inventory buyer<span class="token">)</span>
  <span class="token1">if</span> given
    then <span class="token1">do</span>
      basicTransfer price <span class="token">(</span>balance buyer<span class="token">)</span> <span class="token">(</span>balance seller<span class="token">)</span>
      <span class="token1">return</span> True
    <span class="token1">else</span> <span class="token1">return</span> False

</code></pre>
<p class="calibre9">我们不仅要检查物品是否给到了另一个玩家，而且还得把是否成功这个信号传递给调用者。这就意味了复杂性被延续到了更外层。</p>
<p class="calibre9">下面我们来看看如何用更加优雅的方式处理事务无法成功进行的情况。 STM API 提供了一个 retry 函数，它可以立即中断一个 无法成功进行的 atomically 执行块。正如这个函数名本身所指明的意思，当它发生时，执行块会被重新执行，所有在这之前的操作都不会被记录。我们使用 retry 重新实现了 maybeGiveItem 。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>GameInventory<span class="token">.</span>hs
giveItem <span class="token">:</span><span class="token">:</span> Item <span class="token3">-</span><span class="token3">&gt;</span> Inventory <span class="token3">-</span><span class="token3">&gt;</span> Inventory <span class="token3">-</span><span class="token3">&gt;</span> STM <span class="token">(</span><span class="token">)</span>

giveItem item fromInv toInv <span class="token3">=</span> <span class="token1">do</span>
    fromList <span class="token3">&lt;</span><span class="token3">-</span> readTVar fromInv
    case removeInv item fromList of
        Nothing <span class="token3">-</span><span class="token3">&gt;</span> retry
        Just newList <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">do</span>
            writeTVar fromInv newList
            readTVar toInv <span class="token3">&gt;</span><span class="token3">&gt;=</span> writeTVar toInv <span class="token">.</span> <span class="token">(</span>item <span class="token">:</span><span class="token">)</span>

</code></pre>
<p class="calibre9">我们之前实现的 basicTransfer 有一个缺陷：没有检查发送者的账户是否有足够的资金。我们可以使用 retry 来纠正这个问题并保持方法签名不变。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>GameInventory<span class="token">.</span>hs
transfer <span class="token">:</span><span class="token">:</span> Gold <span class="token3">-</span><span class="token3">&gt;</span> Balance <span class="token3">-</span><span class="token3">&gt;</span> Balance <span class="token3">-</span><span class="token3">&gt;</span> STM <span class="token">(</span><span class="token">)</span>

transfer qty fromBal toBal <span class="token3">=</span> <span class="token1">do</span>
  fromQty <span class="token3">&lt;</span><span class="token3">-</span> readTVar fromBal
  when <span class="token">(</span>qty <span class="token3">&gt;</span> fromQty<span class="token">)</span> $
    retry
  writeTVar fromBal <span class="token">(</span>fromQty <span class="token3">-</span> qty<span class="token">)</span>
  readTVar toBal <span class="token3">&gt;</span><span class="token3">&gt;=</span> writeTVar toBal <span class="token">.</span> <span class="token">(</span>qty <span class="token3">+</span><span class="token">)</span>

</code></pre>
<p class="calibre9">使用 retry 后，销售物品的函数就显得简单很多。</p>
<pre class="calibre15"><code class="tthhighlight-container">sellItem <span class="token">:</span><span class="token">:</span> Item <span class="token3">-</span><span class="token3">&gt;</span> Gold <span class="token3">-</span><span class="token3">&gt;</span> Player <span class="token3">-</span><span class="token3">&gt;</span> Player <span class="token3">-</span><span class="token3">&gt;</span> STM <span class="token">(</span><span class="token">)</span>
sellItem item price buyer seller <span class="token3">=</span> <span class="token1">do</span>
  giveItem item <span class="token">(</span>inventory seller<span class="token">)</span> <span class="token">(</span>inventory buyer<span class="token">)</span>
  transfer price <span class="token">(</span>balance buyer<span class="token">)</span> <span class="token">(</span>balance seller<span class="token">)</span>

</code></pre>
<p class="calibre9">这个实现和之前的稍微有点不同。如果有必要会会阻塞以至卖家有东西可卖并且买家有足够的余额支付，而不是在发现卖家没这个物品可销售时马上返回 False 。</p>
<h2 class="calibre14"><a id="chp-28.html.retry__227" class="calibre7 pcalibre"></a>retry 时到底发生了什么?</h2>
<p class="calibre9">retry 不仅仅使得代码更加简洁：它似乎有魔力般的内部实现。当我们调用 retry 的时候，它并不是马上重启事务，而是会先阻塞线程，一直到那些在 retry 之前被访问过的变量被其他线程修改。</p>
<p class="calibre9">比如，如果我们调用 transfer 而发现余额不足， retry 会自发的等待，直到账户余额的变动，然后会重新启动事务。 同样的，对于函数 giveItem ， 如果卖家没有那个物品，线程就会阻塞直到他有了那个物品。</p>
<h2 class="calibre14"><a id="chp-28.html._233" class="calibre7 pcalibre"></a>选择替代方案</h2>
<p class="calibre9">有时候我们并不总是希望重启 atomically 操作即使调用了 retry 或者由于其他线程的同步修改而导致的失败。比如函数 sellItem 会不断地重试，只要没有满足其条件：要有物品并且余额足够。然而我们可能更希望只重试一次。</p>
<p class="calibre9">orElse 组合器允许我们在主操作失败的情况下，执行一个”备用”操作。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type orElse
orElse <span class="token">:</span><span class="token">:</span> STM a <span class="token3">-</span><span class="token3">&gt;</span> STM a <span class="token3">-</span><span class="token3">&gt;</span> STM a

</code></pre>
<p class="calibre9">我们对 sellItem 做了一点修改：如果 sellItem 失败， 则 orElse 执行 returnFalse 的动作从而使这个sale函数立即返回。</p>
<pre class="calibre15"><code class="tthhighlight-container">trySellItem <span class="token">:</span><span class="token">:</span> Item <span class="token3">-</span><span class="token3">&gt;</span> Gold <span class="token3">-</span><span class="token3">&gt;</span> Player <span class="token3">-</span><span class="token3">&gt;</span> Player <span class="token3">-</span><span class="token3">&gt;</span> STM Bool
trySellItem item price buyer seller <span class="token3">=</span>
   sellItem item price buyer seller <span class="token3">&gt;</span><span class="token3">&gt;</span> <span class="token1">return</span> True
  `orElse`
   <span class="token1">return</span> False

</code></pre>
<h2 class="calibre14"><a id="chp-28.html._256" class="calibre7 pcalibre"></a>在事务中使用高阶代码</h2>
<p class="calibre9">假设我们想做稍微有挑战的事情，从一系列的物品中，选取第一个卖家拥有的并且买家能承担费用的物品进行购买，如果没有这样的物品则什么都不做。显然我们可以很直观的给出实现。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>GameInventory<span class="token">.</span>hs
crummyList <span class="token">:</span><span class="token">:</span> <span class="token">[</span><span class="token">(</span>Item<span class="token">,</span> Gold<span class="token">)</span><span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Player <span class="token3">-</span><span class="token3">&gt;</span> Player
             <span class="token3">-</span><span class="token3">&gt;</span> STM <span class="token">(</span>Maybe <span class="token">(</span>Item<span class="token">,</span> Gold<span class="token">)</span><span class="token">)</span>
crummyList list buyer seller <span class="token3">=</span> go list
    where go <span class="token">[</span><span class="token">]</span>                         <span class="token3">=</span> <span class="token1">return</span> Nothing
          go <span class="token">(</span>this@<span class="token">(</span>item<span class="token">,</span>price<span class="token">)</span> <span class="token">:</span> rest<span class="token">)</span> <span class="token3">=</span> <span class="token1">do</span>
              sellItem item price buyer seller
              <span class="token1">return</span> <span class="token">(</span>Just this<span class="token">)</span>
           `orElse`
              go rest

</code></pre>
<p class="calibre9">在这个实现里，我们有碰到了一个熟悉的问题：把我们的需求和如果实现混淆在一个。再深入一点观察，则会发现两个可重复使用的模式。</p>
<p class="calibre9">第一个就是让事务失败而不是重试。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>GameInventory<span class="token">.</span>hs
maybeSTM <span class="token">:</span><span class="token">:</span> STM a <span class="token3">-</span><span class="token3">&gt;</span> STM <span class="token">(</span>Maybe a<span class="token">)</span>
maybeSTM m <span class="token3">=</span> <span class="token">(</span>Just `liftM` m<span class="token">)</span> `orElse` <span class="token1">return</span> Nothing

</code></pre>
<p class="calibre9">第二个，我们要对一系列的对象执行否一个操作，直到有一个成功为止。如果全部都失败，则执行 retry 操作。由于 STM 是 MonadPlus 类型类的一个实例，所以显得很方便。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>STMPlus<span class="token">.</span>hs
instance MonadPlus STM where
  mzero <span class="token3">=</span> retry
  mplus <span class="token3">=</span> orElse

</code></pre>
<p class="calibre9">Control.Monad 模块定义了一个 msum 函数，而它就是我们所需要的。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>STMPlus<span class="token">.</span>hs
msum <span class="token">:</span><span class="token">:</span> MonadPlus m <span class="token3">=</span><span class="token3">&gt;</span> <span class="token">[</span>m a<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> m a
msum <span class="token3">=</span>  foldr mplus mzero

</code></pre>
<p class="calibre9">有了这些重要的工具，我们就可以写出更加简洁的实现了。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>GameInventory<span class="token">.</span>hs
shoppingList <span class="token">:</span><span class="token">:</span> <span class="token">[</span><span class="token">(</span>Item<span class="token">,</span> Gold<span class="token">)</span><span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Player <span class="token3">-</span><span class="token3">&gt;</span> Player
             <span class="token3">-</span><span class="token3">&gt;</span> STM <span class="token">(</span>Maybe <span class="token">(</span>Item<span class="token">,</span> Gold<span class="token">)</span><span class="token">)</span>
shoppingList list buyer seller <span class="token3">=</span> maybeSTM <span class="token">.</span> msum $ map sellOne list
    where sellOne this@<span class="token">(</span>item<span class="token">,</span>price<span class="token">)</span> <span class="token3">=</span> <span class="token1">do</span>
            sellItem item price buyer seller
            <span class="token1">return</span> this

</code></pre>
<p class="calibre9">既然 STM 是 MonadPlus 类型类的实例，我们可以改进 maybeSTM ，这样就可以适用于任何 MonadPlus 的实例。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>GameInventory<span class="token">.</span>hs
maybeM <span class="token">:</span><span class="token">:</span> MonadPlus m <span class="token3">=</span><span class="token3">&gt;</span> m a <span class="token3">-</span><span class="token3">&gt;</span> m <span class="token">(</span>Maybe a<span class="token">)</span>
maybeM m <span class="token3">=</span> <span class="token">(</span>Just `liftM` m<span class="token">)</span> `mplus` <span class="token1">return</span> Nothing

</code></pre>
<p class="calibre9">这个函数会在很多不同情况下显得非常有用。</p>
<h2 class="calibre14"><a id="chp-28.html.IO__STM_328" class="calibre7 pcalibre"></a>I/O 和 STM</h2>
<p class="calibre9">STM monad 禁止任意的I/O操作，因为I/O操作会破坏原子性和隔离性。当然I/O的操作还是需要的，只是我们需要非常的谨慎。</p>
<p class="calibre9">大多数时候，我们会执行I/O操作是由于我们在 atomically 块中产生的一个结果。在这些情况下，正确的做法通常是 atomically 返回一些数据，在I/O monad里的调用者则根据这些数据知道如何继续下一步动作。我们甚至可以返回需要被操作的动作 (action)， 因为他们是第一类值(First Class vaules)。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>STMIO<span class="token">.</span>hs
someAction <span class="token">:</span><span class="token">:</span> IO a

stmTransaction <span class="token">:</span><span class="token">:</span> STM <span class="token">(</span>IO a<span class="token">)</span>
stmTransaction <span class="token3">=</span> <span class="token1">return</span> someAction

doSomething <span class="token">:</span><span class="token">:</span> IO a
doSomething <span class="token3">=</span> join <span class="token">(</span>atomically stmTransaction<span class="token">)</span>

</code></pre>
<p class="calibre9">我们偶尔也需要在 STM 里进行I/O操作。比如从一个肯定存在的文件里读取一些非可变数据，这样的操作并不会违背 STM 保证原子性和隔离性的原则。在这些情况，我们可以使用 unsafeIOToSTM 来执行一个 IO 操作。这个函数位于偏底层的一个模块 GHC.Conc ，所以要谨慎使用。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>m <span class="token3">+</span>GHC<span class="token">.</span>Conc
ghci<span class="token3">&gt;</span> <span class="token">:</span>type unsafeIOToSTM
unsafeIOToSTM <span class="token">:</span><span class="token">:</span> IO a <span class="token3">-</span><span class="token3">&gt;</span> STM a

</code></pre>
<p class="calibre9">我们所执行的这个 IO 动作绝对不能打开另外一个 atomically 事务。如果一个线程尝试嵌套的事务，系统就会抛出异常。</p>
<p class="calibre9">由于类型系统无法帮助我们确保 IO 代码没有执行一些敏感动作，最安全的做法就是我们尽量的限制使用 unsafeIOToSTM 。下面的例子展示了在 atomically 中执行 IO 的典型错误。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>STMIO<span class="token">.</span>hs
launchTorpedoes <span class="token">:</span><span class="token">:</span> IO <span class="token">(</span><span class="token">)</span>

notActuallyAtomic <span class="token3">=</span> <span class="token1">do</span>
  doStuff
  unsafeIOToSTM launchTorpedoes
  mightRetry

</code></pre>
<p class="calibre9">如果 mightRetry 会引发事务的重启，那么 launchTorpedoes 会被调用多次。事实上，我们无法预见它会被调用多少次， 因为重试是由运行时系统所处理的。解决方案就是在事务中不要有这种类型的non-idempotent I/O操作。</p>
<h2 class="calibre14"><a id="chp-28.html._372" class="calibre7 pcalibre"></a>线程之间的通讯</h2>
<p class="calibre9">正如基础类型 TVar 那样， stm 包也提供了两个更有用的类型用于线程之间的通讯， TMVar 和 TChan 。 TMVar 是STM世界的 MVar ， 它可以保存一个 Maybe 类型的值， 即 Just 值或者 Nothing 。 TChan 则是 STM 世界里的 Chan ，它实现了一个有类型的先进先出(FIFO)通道。</p>
<p class="calibre9">[译者注：为何说 TMVar 是STM世界的 MVar 而不是 TVar ？是因为从实践意义上理解的。 MVar 的特性是要么有值要么为空的一个容器，所以当线程去读这个容器时，要么读到值继续执行，要么读不到值就等待。 而 TVar 并没有这样的特性，所以引入了 TMVar 。 它的实现是这样的， newtypeTMVara=TMVar(TVar(Maybea)) ， 正是由于它包含了一个 Maybe 类型的值，这样就有了”要么有值要么为空”这样的特性，也就是 MVar 所拥有的特性。]</p>
<h2 class="calibre14"><a id="chp-28.html._378" class="calibre7 pcalibre"></a>并发网络链接检查器</h2>
<p class="calibre9">作为一个使用 STM 的实际例子， 我们将开发一个检查HTML文件里不正确链接的程序，这里不正确的链接是指那些链接指向了一个错误的网页或是无法访问到其指向的服务器。用并发的方式解决这个问题非常得合适：如果我们尝试和已经下线的服务器(dead server)通讯，需要有两分钟的超时时间。如果使用多线程，即使有一两个线程由于和响应很慢或者下线的服务器通讯而停住(stuck)，我们还是可以继续进行一些有用的事情。</p>
<p class="calibre9">我们不能简单直观的给每一个URL新建一个线程，因为由于（也是我们预想的）大多数链接是正确的，那么这样做就会导致CPU或是网络连接超负荷。因此，我们只会创建固定数量的线程，这些线程会从一个队列里拿URL做检查。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>Check<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span># LANGUAGE FlexibleContexts<span class="token">,</span> GeneralizedNewtypeDeriving<span class="token">,</span>
             PatternGuards #<span class="token3">-</span><span class="token">}</span>

import Control<span class="token">.</span>Concurrent <span class="token">(</span>forkIO<span class="token">)</span>
import Control<span class="token">.</span>Concurrent<span class="token">.</span>STM
import Control<span class="token">.</span>Exception <span class="token">(</span><span class="token1">catch</span><span class="token">,</span> <span class="token1">finally</span><span class="token">)</span>
import Control<span class="token">.</span>Monad<span class="token">.</span>Error
import Control<span class="token">.</span>Monad<span class="token">.</span>State
import Data<span class="token">.</span>Char <span class="token">(</span>isControl<span class="token">)</span>
import Data<span class="token">.</span>List <span class="token">(</span>nub<span class="token">)</span>
import Network<span class="token">.</span>URI
import Prelude hiding <span class="token">(</span><span class="token1">catch</span><span class="token">)</span>
import System<span class="token">.</span>Console<span class="token">.</span>GetOpt
import System<span class="token">.</span>Environment <span class="token">(</span>getArgs<span class="token">)</span>
import System<span class="token">.</span>Exit <span class="token">(</span><span class="token5">ExitCode</span><span class="token">(</span><span class="token">.</span><span class="token">.</span><span class="token">)</span><span class="token">,</span> exitWith<span class="token">)</span>
import System<span class="token">.</span>IO <span class="token">(</span>hFlush<span class="token">,</span> hPutStrLn<span class="token">,</span> stderr<span class="token">,</span> stdout<span class="token">)</span>
import Text<span class="token">.</span>Printf <span class="token">(</span>printf<span class="token">)</span>
import qualified Data<span class="token">.</span>ByteString<span class="token">.</span>Lazy<span class="token">.</span>Char8 as B
import qualified Data<span class="token">.</span>Set as S

<span class="token3">--</span> 这里需要HTTP包<span class="token">,</span> 它并不是GHC自带的<span class="token">.</span>
import Network<span class="token">.</span>HTTP

type URL <span class="token3">=</span> B<span class="token">.</span>ByteString

data Task <span class="token3">=</span> Check URL <span class="token3">|</span> Done

</code></pre>
<p class="calibre9">main 函数显示了这个程序的主体脚手架(scaffolding)。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>Check<span class="token">.</span>hs
main <span class="token">:</span><span class="token">:</span> IO <span class="token">(</span><span class="token">)</span>
main <span class="token3">=</span> <span class="token1">do</span>
    <span class="token">(</span>files<span class="token">,</span>k<span class="token">)</span> <span class="token3">&lt;</span><span class="token3">-</span> parseArgs
    let n <span class="token3">=</span> length files

    <span class="token3">--</span> count of broken links
    badCount <span class="token3">&lt;</span><span class="token3">-</span> newTVarIO <span class="token">(</span><span class="token2">0</span> <span class="token">:</span><span class="token">:</span> Int<span class="token">)</span>

    <span class="token3">--</span> <span class="token1">for</span> reporting broken links
    badLinks <span class="token3">&lt;</span><span class="token3">-</span> newTChanIO

    <span class="token3">--</span> <span class="token1">for</span> sending jobs to workers
    jobs <span class="token3">&lt;</span><span class="token3">-</span> newTChanIO

    <span class="token3">--</span> the number of workers currently running
    workers <span class="token3">&lt;</span><span class="token3">-</span> newTVarIO k

    <span class="token3">--</span> one thread reports bad links to stdout
    forkIO $ writeBadLinks badLinks

    <span class="token3">--</span> start worker threads
    forkTimes k workers <span class="token">(</span>worker badLinks jobs badCount<span class="token">)</span>

    <span class="token3">--</span> read links from files<span class="token">,</span> and enqueue them as jobs
    stats <span class="token3">&lt;</span><span class="token3">-</span> execJob <span class="token">(</span>mapM_ checkURLs files<span class="token">)</span>
                     <span class="token">(</span>JobState S<span class="token">.</span>empty <span class="token2">0</span> jobs<span class="token">)</span>

    <span class="token3">--</span> enqueue <span class="token4">"please finish"</span> messages
    atomically $ replicateM_ k <span class="token">(</span>writeTChan jobs Done<span class="token">)</span>

    waitFor workers

    broken <span class="token3">&lt;</span><span class="token3">-</span> atomically $ readTVar badCount

    printf fmt broken
               <span class="token">(</span>linksFound stats<span class="token">)</span>
               <span class="token">(</span>S<span class="token">.</span>size <span class="token">(</span>linksSeen stats<span class="token">)</span><span class="token">)</span>
               n
  where
    fmt   <span class="token3">=</span> <span class="token4">"Found %d broken links. "</span> <span class="token3">++</span>
            <span class="token4">"Checked %d links (%d unique) in %d files.\n"</span>

</code></pre>
<p class="calibre9">当我们处于 IO monad时，可以使用 newTVarIO 函数新建一个 TVar 值。同样的，也有类似的函数可以新建 TMVar 和 TChan 值。</p>
<p class="calibre9">在程序用了 printf 函数打印出最后的结果。和C语言里类似函数 printf 不同的是Haskell这个版本会在运行时检查参数的个数以及其类型。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>m <span class="token3">+</span>Text<span class="token">.</span>Printf
ghci<span class="token3">&gt;</span> printf <span class="token4">"%d and %d\n"</span> <span class="token">(</span><span class="token2">3</span><span class="token">:</span><span class="token">:</span>Int<span class="token">)</span>
<span class="token2">3</span> and <span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> Printf<span class="token">.</span>printf<span class="token">:</span> argument list ended prematurely
ghci<span class="token3">&gt;</span> printf <span class="token4">"%s and %d\n"</span> <span class="token4">"foo"</span> <span class="token">(</span><span class="token2">3</span><span class="token">:</span><span class="token">:</span>Int<span class="token">)</span>
foo and <span class="token2">3</span>

</code></pre>
<p class="calibre9">在 <strong class="calibre12">ghci</strong> 里试试 printf"%d"True ,看看会得到什么结果。</p>
<p class="calibre9">支持 main 函数的是几个短小的函数。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>Check<span class="token">.</span>hs
modifyTVar_ <span class="token">:</span><span class="token">:</span> TVar a <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">(</span>a <span class="token3">-</span><span class="token3">&gt;</span> a<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> STM <span class="token">(</span><span class="token">)</span>
modifyTVar_ tv f <span class="token3">=</span> readTVar tv <span class="token3">&gt;</span><span class="token3">&gt;=</span> writeTVar tv <span class="token">.</span> f

forkTimes <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> TVar Int <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
forkTimes k alive act <span class="token3">=</span>
  replicateM_ k <span class="token">.</span> forkIO $
    act
    `<span class="token1">finally</span>`
    <span class="token">(</span>atomically $ modifyTVar_ alive <span class="token">(</span>subtract <span class="token2">1</span><span class="token">)</span><span class="token">)</span>

</code></pre>
<p class="calibre9">forkTimes 函数新建特定数量的相同的工作线程，每当一个线程推出时，则”活动”线程的计数器相应的减一。我们使用 finally 组合器确保无论线程是如何终止的，都会减少”活动”线程的数量。</p>
<p class="calibre9">下一步， writeBadLinks 会把每个失效或者死亡(dead)的链接打印到 stdout 。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>Check<span class="token">.</span>hs
writeBadLinks <span class="token">:</span><span class="token">:</span> TChan String <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
writeBadLinks c <span class="token3">=</span>
  forever $
    atomically <span class="token">(</span>readTChan c<span class="token">)</span> <span class="token3">&gt;</span><span class="token3">&gt;=</span> putStrLn <span class="token3">&gt;</span><span class="token3">&gt;</span> hFlush stdout

</code></pre>
<p class="calibre9">上面我们使用了 forever 组合器使一个操作永远的执行。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>m <span class="token3">+</span>Control<span class="token">.</span>Monad
ghci<span class="token3">&gt;</span> <span class="token">:</span>type forever
forever <span class="token">:</span><span class="token">:</span> <span class="token">(</span>Monad m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> m a <span class="token3">-</span><span class="token3">&gt;</span> m <span class="token">(</span><span class="token">)</span>

</code></pre>
<p class="calibre9">waitFor 函数使用了 check ， 当它的参数是 False 时会调用 retry 。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>Check<span class="token">.</span>hs
waitFor <span class="token">:</span><span class="token">:</span> TVar Int <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
waitFor alive <span class="token3">=</span> atomically $ <span class="token1">do</span>
  count <span class="token3">&lt;</span><span class="token3">-</span> readTVar alive
  check <span class="token">(</span>count <span class="token3">==</span> <span class="token2">0</span><span class="token">)</span>

</code></pre>
<h2 class="calibre14"><a id="chp-28.html._527" class="calibre7 pcalibre"></a>检查一个链接</h2>
<p class="calibre9">这个原生的函数实现了如何检查一个链接的状态。 代码和 [第二十二章 Chapter 22, Extended Example: Web Client Programming] 里的 podcatcher 相似但有一点不同。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>Check<span class="token">.</span>hs
getStatus <span class="token">:</span><span class="token">:</span> URI <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span>Either String Int<span class="token">)</span>
getStatus <span class="token3">=</span> chase <span class="token">(</span><span class="token2">5</span> <span class="token">:</span><span class="token">:</span> Int<span class="token">)</span>
  where
    chase <span class="token2">0</span> _ <span class="token3">=</span> bail <span class="token4">"too many redirects"</span>
    chase n u <span class="token3">=</span> <span class="token1">do</span>
      resp <span class="token3">&lt;</span><span class="token3">-</span> getHead u
      case resp of
        Left err <span class="token3">-</span><span class="token3">&gt;</span> bail <span class="token">(</span>show err<span class="token">)</span>
        Right r <span class="token3">-</span><span class="token3">&gt;</span>
          case rspCode r of
            <span class="token">(</span><span class="token2">3</span><span class="token">,</span>_<span class="token">,</span>_<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span>
               case findHeader HdrLocation r of
                 Nothing <span class="token3">-</span><span class="token3">&gt;</span> bail <span class="token">(</span>show r<span class="token">)</span>
                 Just u' <span class="token3">-</span><span class="token3">&gt;</span>
                   case parseURI u' of
                     Nothing <span class="token3">-</span><span class="token3">&gt;</span> bail <span class="token4">"bad URL"</span>
                     Just url <span class="token3">-</span><span class="token3">&gt;</span> chase <span class="token">(</span>n<span class="token3">-</span><span class="token2">1</span><span class="token">)</span> url
            <span class="token">(</span>a<span class="token">,</span>b<span class="token">,</span>c<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> <span class="token">.</span> Right $ a <span class="token3">*</span> <span class="token2">100</span> <span class="token3">+</span> b <span class="token3">*</span> <span class="token2">10</span> <span class="token3">+</span> c

    bail <span class="token3">=</span> <span class="token1">return</span> <span class="token">.</span> Left

getHead <span class="token">:</span><span class="token">:</span> URI <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span>Result Response<span class="token">)</span>
getHead uri <span class="token3">=</span> simpleHTTP Request <span class="token">{</span> rqURI <span class="token3">=</span> uri<span class="token">,</span>
                                   rqMethod <span class="token3">=</span> HEAD<span class="token">,</span>
                                   rqHeaders <span class="token3">=</span> <span class="token">[</span><span class="token">]</span><span class="token">,</span>
                                   rqBody <span class="token3">=</span> <span class="token4">""</span> <span class="token">}</span>

</code></pre>
<p class="calibre9">为了避免无尽的重定向相应，我们只允许固定次数的重定向请求。我们通过查看HTTP标准HEAD信息来确认链接的有效性， 比起一个完整的GET请求，这样做可以减少网络流量。</p>
<p class="calibre9">这个代码是典型的”marching off the left of the screen”风格。正如之前我们提到的，需要谨慎使用这样的风格。下面我们用 ErrorT monad transformer 和几个通用一点的方法进行了重新实现，它看上去简洁了很多。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>Check<span class="token">.</span>hs
getStatusE <span class="token3">=</span> runErrorT <span class="token">.</span> chase <span class="token">(</span><span class="token2">5</span> <span class="token">:</span><span class="token">:</span> Int<span class="token">)</span>
  where
    chase <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> URI <span class="token3">-</span><span class="token3">&gt;</span> ErrorT String IO Int
    chase <span class="token2">0</span> _ <span class="token3">=</span> throwError <span class="token4">"too many redirects"</span>
    chase n u <span class="token3">=</span> <span class="token1">do</span>
      r <span class="token3">&lt;</span><span class="token3">-</span> embedEither show <span class="token3">=</span><span class="token3">&lt;</span><span class="token3">&lt;</span> liftIO <span class="token">(</span>getHead u<span class="token">)</span>
      case rspCode r of
        <span class="token">(</span><span class="token2">3</span><span class="token">,</span>_<span class="token">,</span>_<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">do</span>
            u'  <span class="token3">&lt;</span><span class="token3">-</span> embedMaybe <span class="token">(</span>show r<span class="token">)</span>  $ findHeader HdrLocation r
            url <span class="token3">&lt;</span><span class="token3">-</span> embedMaybe <span class="token4">"bad URL"</span> $ parseURI u'
            chase <span class="token">(</span>n<span class="token3">-</span><span class="token2">1</span><span class="token">)</span> url
        <span class="token">(</span>a<span class="token">,</span>b<span class="token">,</span>c<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> $ a<span class="token3">*</span><span class="token2">100</span> <span class="token3">+</span> b<span class="token3">*</span><span class="token2">10</span> <span class="token3">+</span> c

<span class="token3">--</span> Some handy embedding functions<span class="token">.</span>
embedEither <span class="token">:</span><span class="token">:</span> <span class="token">(</span>MonadError e m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> <span class="token">(</span>s <span class="token3">-</span><span class="token3">&gt;</span> e<span class="token">)</span> <span class="token3">-</span><span class="token3">&gt;</span> Either s a <span class="token3">-</span><span class="token3">&gt;</span> m a
embedEither f <span class="token3">=</span> either <span class="token">(</span>throwError <span class="token">.</span> f<span class="token">)</span> <span class="token1">return</span>

embedMaybe <span class="token">:</span><span class="token">:</span> <span class="token">(</span>MonadError e m<span class="token">)</span> <span class="token3">=</span><span class="token3">&gt;</span> e <span class="token3">-</span><span class="token3">&gt;</span> Maybe a <span class="token3">-</span><span class="token3">&gt;</span> m a
embedMaybe err <span class="token3">=</span> maybe <span class="token">(</span>throwError err<span class="token">)</span> <span class="token1">return</span>

</code></pre>
<h2 class="calibre14"><a id="chp-28.html._590" class="calibre7 pcalibre"></a>工作者线程</h2>
<p class="calibre9">每个工作者线程(Worker Thread)从一个共享队列里拿一个任务，这个任务要么检查链接有效性，要么让线程推出。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>Check<span class="token">.</span>hs
worker <span class="token">:</span><span class="token">:</span> TChan String <span class="token3">-</span><span class="token3">&gt;</span> TChan Task <span class="token3">-</span><span class="token3">&gt;</span> TVar Int <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
worker badLinks jobQueue badCount <span class="token3">=</span> loop
  where
    <span class="token3">--</span> Consume jobs until we are told to exit<span class="token">.</span>
    loop <span class="token3">=</span> <span class="token1">do</span>
        job <span class="token3">&lt;</span><span class="token3">-</span> atomically $ readTChan jobQueue
        case job of
            Done  <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> <span class="token">(</span><span class="token">)</span>
            Check x <span class="token3">-</span><span class="token3">&gt;</span> checkOne <span class="token">(</span>B<span class="token">.</span>unpack x<span class="token">)</span> <span class="token3">&gt;</span><span class="token3">&gt;</span> loop

    <span class="token3">--</span> Check a single link<span class="token">.</span>
    checkOne url <span class="token3">=</span> case parseURI url of
        Just uri <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">do</span>
            code <span class="token3">&lt;</span><span class="token3">-</span> getStatus uri `<span class="token1">catch</span>` <span class="token">(</span><span class="token1">return</span> <span class="token">.</span> Left <span class="token">.</span> show<span class="token">)</span>
            case code of
                Right <span class="token2">200</span> <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> <span class="token">(</span><span class="token">)</span>
                Right n   <span class="token3">-</span><span class="token3">&gt;</span> report <span class="token">(</span>show n<span class="token">)</span>
                Left err  <span class="token3">-</span><span class="token3">&gt;</span> report err
        _ <span class="token3">-</span><span class="token3">&gt;</span> report <span class="token4">"invalid URL"</span>

        where report s <span class="token3">=</span> atomically $ <span class="token1">do</span>
                           modifyTVar_ badCount <span class="token">(</span><span class="token3">+</span><span class="token2">1</span><span class="token">)</span>
                           writeTChan badLinks <span class="token">(</span>url <span class="token3">++</span> <span class="token4">" "</span> <span class="token3">++</span> s<span class="token">)</span>

</code></pre>
<h2 class="calibre14"><a id="chp-28.html._622" class="calibre7 pcalibre"></a>查找链接</h2>
<p class="calibre9">我们构造了基于 IO monad 的 状态 monad transformer栈用于查找链接。这个状态会记录我们已经找到过的链接(避免重复)、链接的数量以及一个队列，我们会把需要做检查的链接放到这个队列里。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>Check<span class="token">.</span>hs
data JobState <span class="token3">=</span> JobState <span class="token">{</span> linksSeen <span class="token">:</span><span class="token">:</span> S<span class="token">.</span>Set URL<span class="token">,</span>
                           linksFound <span class="token">:</span><span class="token">:</span> Int<span class="token">,</span>
                           linkQueue <span class="token">:</span><span class="token">:</span> TChan Task <span class="token">}</span>

newtype Job a <span class="token3">=</span> Job <span class="token">{</span> runJob <span class="token">:</span><span class="token">:</span> StateT JobState IO a <span class="token">}</span>
    deriving <span class="token">(</span>Monad<span class="token">,</span> MonadState JobState<span class="token">,</span> MonadIO<span class="token">)</span>

execJob <span class="token">:</span><span class="token">:</span> Job a <span class="token3">-</span><span class="token3">&gt;</span> JobState <span class="token3">-</span><span class="token3">&gt;</span> IO JobState
execJob <span class="token3">=</span> execStateT <span class="token">.</span> runJob

</code></pre>
<p class="calibre9">严格来说，对于对立运行的小型程序，我们并不需要用到 newtype ，然后我们还是将它作为一个好的编码实践的例子放在这里。(毕竟也只多了几行代码)</p>
<p class="calibre9">main 函数实现了对每个输入文件调用一次 checkURLs 方法，所以 checkURLs 的参数就是单个文件。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>Check<span class="token">.</span>hs
checkURLs <span class="token">:</span><span class="token">:</span> FilePath <span class="token3">-</span><span class="token3">&gt;</span> Job <span class="token">(</span><span class="token">)</span>
checkURLs f <span class="token3">=</span> <span class="token1">do</span>
    src <span class="token3">&lt;</span><span class="token3">-</span> liftIO $ B<span class="token">.</span>readFile f
    let urls <span class="token3">=</span> extractLinks src
    filterM seenURI urls <span class="token3">&gt;</span><span class="token3">&gt;=</span> sendJobs
    updateStats <span class="token">(</span>length urls<span class="token">)</span>

updateStats <span class="token">:</span><span class="token">:</span> Int <span class="token3">-</span><span class="token3">&gt;</span> Job <span class="token">(</span><span class="token">)</span>
updateStats a <span class="token3">=</span> modify $ \s <span class="token3">-</span><span class="token3">&gt;</span>
    s <span class="token">{</span> linksFound <span class="token3">=</span> linksFound s <span class="token3">+</span> a <span class="token">}</span>

<span class="token3">--</span> <span class="token3">|</span> Add a link to the set we have seen<span class="token">.</span>
insertURI <span class="token">:</span><span class="token">:</span> URL <span class="token3">-</span><span class="token3">&gt;</span> Job <span class="token">(</span><span class="token">)</span>
insertURI c <span class="token3">=</span> modify $ \s <span class="token3">-</span><span class="token3">&gt;</span>
    s <span class="token">{</span> linksSeen <span class="token3">=</span> S<span class="token">.</span>insert c <span class="token">(</span>linksSeen s<span class="token">)</span> <span class="token">}</span>

<span class="token3">--</span> <span class="token3">|</span> If we have seen a link<span class="token">,</span> <span class="token1">return</span> False<span class="token">.</span>  Otherwise<span class="token">,</span> record that we
<span class="token3">--</span> have seen it<span class="token">,</span> and <span class="token1">return</span> True<span class="token">.</span>
seenURI <span class="token">:</span><span class="token">:</span> URL <span class="token3">-</span><span class="token3">&gt;</span> Job Bool
seenURI url <span class="token3">=</span> <span class="token1">do</span>
    seen <span class="token3">&lt;</span><span class="token3">-</span> <span class="token">(</span>not <span class="token">.</span> S<span class="token">.</span>member url<span class="token">)</span> `liftM` gets linksSeen
    insertURI url
    <span class="token1">return</span> seen

sendJobs <span class="token">:</span><span class="token">:</span> <span class="token">[</span>URL<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> Job <span class="token">(</span><span class="token">)</span>
sendJobs js <span class="token3">=</span> <span class="token1">do</span>
    c <span class="token3">&lt;</span><span class="token3">-</span> gets linkQueue
    liftIO <span class="token">.</span> atomically $ mapM_ <span class="token">(</span>writeTChan c <span class="token">.</span> Check<span class="token">)</span> js

</code></pre>
<p class="calibre9">extractLinks 函数并没有尝试去准确的去解析一个HTMP或是文本文件，而只是匹配那些看上去像URL的字符串。我们认为这样做就够了。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>Check<span class="token">.</span>hs
extractLinks <span class="token">:</span><span class="token">:</span> B<span class="token">.</span>ByteString <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>URL<span class="token">]</span>
extractLinks <span class="token3">=</span> concatMap uris <span class="token">.</span> B<span class="token">.</span>lines
  where uris s      <span class="token3">=</span> filter looksOkay <span class="token">(</span>B<span class="token">.</span>splitWith isDelim s<span class="token">)</span>
        isDelim c   <span class="token3">=</span> isControl c <span class="token3">||</span> c `elem` <span class="token4">" &lt;&gt;\"{}|\\^[]`"</span>
        looksOkay s <span class="token3">=</span> http `B<span class="token">.</span>isPrefixOf` s
        http        <span class="token3">=</span> B<span class="token">.</span>pack <span class="token4">"http:"</span>

</code></pre>
<h2 class="calibre14"><a id="chp-28.html._690" class="calibre7 pcalibre"></a>命令行的实现</h2>
<p class="calibre9">我们使用了 System.Console.GetOpt 模块来解析命令行参数。这个模块提供了很多解析命令行参数的很有用的方法，不过使用起来稍微有点繁琐。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>Check<span class="token">.</span>hs
data Flag <span class="token3">=</span> Help <span class="token3">|</span> N Int
            deriving Eq

parseArgs <span class="token">:</span><span class="token">:</span> IO <span class="token">(</span><span class="token">[</span>String<span class="token">]</span><span class="token">,</span> Int<span class="token">)</span>
parseArgs <span class="token3">=</span> <span class="token1">do</span>
    argv <span class="token3">&lt;</span><span class="token3">-</span> getArgs
    case parse argv of
        <span class="token">(</span><span class="token">[</span><span class="token">]</span><span class="token">,</span> files<span class="token">,</span> <span class="token">[</span><span class="token">]</span><span class="token">)</span>                     <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> <span class="token">(</span>nub files<span class="token">,</span> <span class="token2">16</span><span class="token">)</span>
        <span class="token">(</span>opts<span class="token">,</span> files<span class="token">,</span> <span class="token">[</span><span class="token">]</span><span class="token">)</span>
            <span class="token3">|</span> Help `elem` opts              <span class="token3">-</span><span class="token3">&gt;</span> help
            <span class="token3">|</span> <span class="token">[</span>N n<span class="token">]</span> <span class="token3">&lt;</span><span class="token3">-</span> filter <span class="token">(</span><span class="token3">/</span><span class="token3">=</span>Help<span class="token">)</span> opts <span class="token3">-</span><span class="token3">&gt;</span> <span class="token1">return</span> <span class="token">(</span>nub files<span class="token">,</span> n<span class="token">)</span>
        <span class="token">(</span>_<span class="token">,</span>_<span class="token">,</span>errs<span class="token">)</span>                          <span class="token3">-</span><span class="token3">&gt;</span> die errs
  where
    parse argv <span class="token3">=</span> getOpt Permute options argv
    header     <span class="token3">=</span> <span class="token4">"Usage: urlcheck [-h] [-n n] [file ...]"</span>
    info       <span class="token3">=</span> usageInfo header options
    dump       <span class="token3">=</span> hPutStrLn stderr
    die errs   <span class="token3">=</span> dump <span class="token">(</span>concat errs <span class="token3">++</span> info<span class="token">)</span> <span class="token3">&gt;</span><span class="token3">&gt;</span> exitWith <span class="token">(</span>ExitFailure <span class="token2">1</span><span class="token">)</span>
    help       <span class="token3">=</span> dump info                  <span class="token3">&gt;</span><span class="token3">&gt;</span> exitWith ExitSuccess

</code></pre>
<p class="calibre9">getOpt 函数接受三个参数</p>
<blockquote class="default"></blockquote>
<blockquote class="default"><ul class="calibre30"><li class="calibre11">参数顺序的定义。 它定义了选项(Option)是否可以和其他参数混淆使用(就是我们上面用到的 Permute )或者是选项必须出现在参数之前。</li><li class="calibre11">选项的定义。 每个选项有这四个部分组成： 简称，全称，选项的描述(比如是否接受参数) 以及用户说明。</li><li class="calibre11">参数和选项数组，类似于 getArgs 的返回值。</li></ul></blockquote>
<p class="calibre9">这个函数返回一个三元组，包括用户输入的选项，参数以及错误信息(如果有的话)。</p>
<p class="calibre9">我们使用 Flag 代数类型(Algebraic Data Type)表示程序所能接收的选项。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>Check<span class="token">.</span>hs
options <span class="token">:</span><span class="token">:</span> <span class="token">[</span>OptDescr Flag<span class="token">]</span>
options <span class="token3">=</span> <span class="token">[</span> Option <span class="token">[</span><span class="token4">'h'</span><span class="token">]</span> <span class="token">[</span><span class="token4">"help"</span><span class="token">]</span> <span class="token">(</span>NoArg Help<span class="token">)</span>
                   <span class="token4">"Show this help message"</span><span class="token">,</span>
            Option <span class="token">[</span><span class="token4">'n'</span><span class="token">]</span> <span class="token">[</span><span class="token">]</span>       <span class="token">(</span>ReqArg <span class="token">(</span>\s <span class="token3">-</span><span class="token3">&gt;</span> N <span class="token">(</span>read s<span class="token">)</span><span class="token">)</span> <span class="token4">"N"</span><span class="token">)</span>
                   <span class="token4">"Number of concurrent connections (default 16)"</span> <span class="token">]</span>

</code></pre>
<p class="calibre9">options 列表保存了每个程序能接收选项的描述。每个描述必须要生成一个 Flag 值。参考上面例子中是如何使用 NoArg 和 ReqArg 。 GetOpt 模块的 ArgDescr 类型有很多构造函数(Constructors)。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>GetOpt<span class="token">.</span>hs
data ArgDescr a <span class="token3">=</span> NoArg a
                <span class="token3">|</span> ReqArg <span class="token">(</span>String <span class="token3">-</span><span class="token3">&gt;</span> a<span class="token">)</span> String
                <span class="token3">|</span> OptArg <span class="token">(</span>Maybe String <span class="token3">-</span><span class="token3">&gt;</span> a<span class="token">)</span> String

</code></pre>
<ul class="calibre10"><li class="calibre11">NoArg 接受一个参数用来表示这个选项。在我们这个例子中，如果用户在调用程序时输入 -h 或者 --help , 我们就用 Help 值表示。</li><li class="calibre11">ReqArg 的第一个函数作为参数，这个函数把用户输入的参数转化成相应的值；第二个参数是用来说明的。 这里我们是将字符串转换为数值(integer)，然后再给类型 Flag 的构造函数 N 。</li><li class="calibre11">OptArg 和 ReqArg 很相似，但它允许选项没有对应的参数。</li></ul>
<h2 class="calibre14"><a id="chp-28.html._Pattern_guards_754" class="calibre7 pcalibre"></a>模式守卫 (Pattern guards)</h2>
<p class="calibre9">函数 parseArgs 的定义里其实潜在了一个语言扩展(Language Extension), Pattern guards。用它可以写出更加简要的guard expressions. 它通过语言扩展 PatternGuards 来使用。</p>
<p class="calibre9">一个Pattern Guard有三个组成部分： 一个模式(Pattern)， 一个 &lt;- 符号以及一个表达式。表达式会被解释然后和模式相匹配。 如果成功，在模式中定义的变量会被赋值。我们可以在一个guard里同时使用pattern guards和普通的 Bool guard expressions。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>PatternGuard<span class="token">.</span>hs
<span class="token">{</span><span class="token3">-</span># LANGUAGE PatternGuards #<span class="token3">-</span><span class="token">}</span>

testme x xs <span class="token3">|</span> Just y <span class="token3">&lt;</span><span class="token3">-</span> lookup x xs<span class="token">,</span> y <span class="token3">&gt;</span> <span class="token2">3</span> <span class="token3">=</span> y
            <span class="token3">|</span> otherwise                    <span class="token3">=</span> <span class="token2">0</span>

</code></pre>
<p class="calibre9">在上面的例子中，当关键字 x 存在于alist xs 并且大于等于3，则返回它所对应的值。下面的定义实现了同样的功能。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>PatternGuard<span class="token">.</span>hs
testme_noguards x xs <span class="token3">=</span> case lookup x xs of
                         Just y <span class="token3">|</span> y <span class="token3">&gt;</span> <span class="token2">3</span> <span class="token3">-</span><span class="token3">&gt;</span> y
                         _              <span class="token3">-</span><span class="token3">&gt;</span> <span class="token2">0</span>

</code></pre>
<p class="calibre9">Pattern guards 使得我们可以把一系列的guards和 case 表达式组合到单个guard，从而写出更加简洁并容易理解的guards。</p>
<h2 class="calibre14"><a id="chp-28.html.STM_781" class="calibre7 pcalibre"></a>STM的实践意义</h2>
<p class="calibre9">至此我们还并未提及STM所提供的特别优越的地方。比如它在做组合(<em class="calibre13">composes</em>)方面就表现的很好：当需要向一个事务中增加逻辑时，只需要用到常见的函数 (&gt;&gt;=) 和 (&gt;&gt;) 。</p>
<p class="calibre9">组合的概念在构建模块化软件是显得格外重要。如果我们把俩段都没有问题的代码组合在一起，也应该是能很好工作的。常规的线程编程技术无法实现组合，然而由于STM提供了一些很关键的前提，从而使在线程编程时使用组合变得可能。</p>
<p class="calibre9">STM monad防止了我们意外的非事务性的I/O。我们不再需要关心锁的顺序，因为代码里根本没有锁机制。我们可以忘记丢失唤醒，因为不再有条件变量了。如果有异常发生，我们则可以用函数 catchSTM 捕捉到，或者是往上级传递。 最后，我们可以用 retry 和 orElse 以更加漂亮的方式组织代码。</p>
<p class="calibre9">采用STM机制的代码不会死锁，但是导致饥饿还是有可能的。一个长事务导致另外一个事务不停的 retry 。为了解决这样的问题，需要尽量的短事务并保持数据一致性。</p>
<h2 class="calibre14"><a id="chp-28.html._791" class="calibre7 pcalibre"></a>合理的放弃控制权</h2>
<p class="calibre9">无论是同步管理还是内存管理，经常会遇到保留控制权的情况：一些软件需要对延时或是内存使用记录有很强的保证，因此就必须花很多时间和精力去管理和调试显式的代码。然后对于软件的大多数实际情况，垃圾回收(Garbage Collection)和STM已经做的足够好了。</p>
<p class="calibre9">STM并不是一颗完美的灵丹妙药。当我们选择垃圾回收而不是显式的内存管理， 我们是放弃了控制权从而获得更加安全的代码。 同样的，当使用STM时，我们放弃了底层的细节，从而希望代码可读性更好，更加容易理解。</p>
<h2 class="calibre14"><a id="chp-28.html._797" class="calibre7 pcalibre"></a>使用不变量</h2>
<p class="calibre9">STM并不能消除某些类型的bug。比如，我们在一个 atomically 事务中从某个账号中取钱，然后返回到 IO monad，然后在另一个 atomically 事务中把钱存到另一个账号，那么代码就会产生不一致性，因为会在某个特定时刻，这部分钱不会出现的任意一个账号里。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>GameInventory<span class="token">.</span>hs
bogusTransfer qty fromBal toBal <span class="token3">=</span> <span class="token1">do</span>
  fromQty <span class="token3">&lt;</span><span class="token3">-</span> atomically $ readTVar fromBal
  <span class="token3">--</span> window of inconsistency
  toQty   <span class="token3">&lt;</span><span class="token3">-</span> atomically $ readTVar toBal
  atomically $ writeTVar fromBal <span class="token">(</span>fromQty <span class="token3">-</span> qty<span class="token">)</span>
  <span class="token3">--</span> window of inconsistency
  atomically $ writeTVar toBal   <span class="token">(</span>toQty <span class="token3">+</span> qty<span class="token">)</span>

bogusSale <span class="token">:</span><span class="token">:</span> Item <span class="token3">-</span><span class="token3">&gt;</span> Gold <span class="token3">-</span><span class="token3">&gt;</span> Player <span class="token3">-</span><span class="token3">&gt;</span> Player <span class="token3">-</span><span class="token3">&gt;</span> IO <span class="token">(</span><span class="token">)</span>
bogusSale item price buyer seller <span class="token3">=</span> <span class="token1">do</span>
  atomically $ giveItem item <span class="token">(</span>inventory seller<span class="token">)</span> <span class="token">(</span>inventory buyer<span class="token">)</span>
  bogusTransfer price <span class="token">(</span>balance buyer<span class="token">)</span> <span class="token">(</span>balance seller<span class="token">)</span>

</code></pre>
<p class="calibre9">在同步程序中，这类问题显然很难而且不容易重现。比如上述例子中的不一致性问题通常只存在一段很短的时间内。在开发阶段通常不会出现这类问题，而往往只有在负载很高的产品环境才有可能发生。</p>
<p class="calibre9">我们可以用函数 alwaysSucceeds 定义一个不变量，它是永远为真的一个数据属性。</p>
<pre class="calibre15"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> <span class="token">:</span>type alwaysSucceeds
alwaysSucceeds <span class="token">:</span><span class="token">:</span> STM a <span class="token3">-</span><span class="token3">&gt;</span> STM <span class="token">(</span><span class="token">)</span>

</code></pre>
<p class="calibre9">当创建一个不变量时，它马上会被检查。如果要失败，那么这个不变量会抛出异常。更有意思的是，不变量会在经后每个事务完成时自动被检查。如果在任何一个点上失败，事务就会推出，不变量抛出的异常也会被传递下去。这就意味着当不变量的条件被违反时，我们就可以马上得到反馈。</p>
<p class="calibre9">比如，下面两个函数给本章开始时定义的游戏世界增加玩家</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>GameInventory<span class="token">.</span>hs
newPlayer <span class="token">:</span><span class="token">:</span> Gold <span class="token3">-</span><span class="token3">&gt;</span> HitPoint <span class="token3">-</span><span class="token3">&gt;</span> <span class="token">[</span>Item<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> STM Player
newPlayer balance health inventory <span class="token3">=</span>
    Player `liftM` newTVar balance
              `ap` newTVar health
              `ap` newTVar inventory

populateWorld <span class="token">:</span><span class="token">:</span> STM <span class="token">[</span>Player<span class="token">]</span>
populateWorld <span class="token3">=</span> sequence <span class="token">[</span> newPlayer <span class="token2">20</span> <span class="token2">20</span> <span class="token">[</span>Wand<span class="token">,</span> Banjo<span class="token">]</span><span class="token">,</span>
                           newPlayer <span class="token2">10</span> <span class="token2">12</span> <span class="token">[</span>Scroll<span class="token">]</span> <span class="token">]</span>

</code></pre>
<p class="calibre9">下面的函数则返回了一个不变量，通过它我们可以保证整个游戏世界资金总是平衡的：即任何时候的资金总量和游戏建立时的总量是一样的。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>GameInventory<span class="token">.</span>hs
consistentBalance <span class="token">:</span><span class="token">:</span> <span class="token">[</span>Player<span class="token">]</span> <span class="token3">-</span><span class="token3">&gt;</span> STM <span class="token">(</span>STM <span class="token">(</span><span class="token">)</span><span class="token">)</span>
consistentBalance players <span class="token3">=</span> <span class="token1">do</span>
    initialTotal <span class="token3">&lt;</span><span class="token3">-</span> totalBalance
    <span class="token1">return</span> $ <span class="token1">do</span>
      curTotal <span class="token3">&lt;</span><span class="token3">-</span> totalBalance
      when <span class="token">(</span>curTotal <span class="token3">/</span><span class="token3">=</span> initialTotal<span class="token">)</span> $
        error <span class="token4">"inconsistent global balance"</span>
  where totalBalance   <span class="token3">=</span> foldM addBalance <span class="token2">0</span> players
        addBalance a b <span class="token3">=</span> <span class="token">(</span>a<span class="token3">+</span><span class="token">)</span> `liftM` readTVar <span class="token">(</span>balance b<span class="token">)</span>

</code></pre>
<p class="calibre9">下面我们写个函数来试验下。</p>
<pre class="calibre15"><code class="tthhighlight-container"><span class="token3">--</span> file<span class="token">:</span> ch28<span class="token3">/</span>GameInventory<span class="token">.</span>hs
tryBogusSale <span class="token3">=</span> <span class="token1">do</span>
  players@<span class="token">(</span>alice<span class="token">:</span>bob<span class="token">:</span>_<span class="token">)</span> <span class="token3">&lt;</span><span class="token3">-</span> atomically populateWorld
  atomically $ alwaysSucceeds <span class="token3">=</span><span class="token3">&lt;</span><span class="token3">&lt;</span> consistentBalance players
  bogusSale Wand <span class="token2">5</span> alice bob

</code></pre>
<p class="calibre9">由于在函数 bogusTransfer 中不正确地使用了 atomically 而会导致不一致性， 当我们在 <strong class="calibre12">ghci</strong> 里运行这个方法时则会检测到这个不一致性。</p>
<pre class="calibre33"><code class="tthhighlight-container">ghci<span class="token3">&gt;</span> tryBogusSale
<span class="token3">*</span><span class="token3">*</span><span class="token3">*</span> Exception<span class="token">:</span> inconsistent global balance

</code></pre>
</div></div></div></div></div></div>
<div id="convention.html"><div class="calibre">
<div id="convention.html.main" class="calibre1"><div class="root"><div class="article"><h1 class="article-head" id="convention.html.calibre_toc_20">翻译约定</h1><div class="article-body"><h1 class="calibre6"><a id="convention.html._0" class="calibre7 pcalibre"></a>翻译约定</h1>
<h2 class="calibre8"><a id="convention.html._2" class="calibre7 pcalibre"></a>第二章</h2>
<p class="calibre9">强类型 strong type</p>
<p class="calibre9">静态类型 static type</p>
<p class="calibre9">自动推导 automatically infer</p>
<p class="calibre9">类型正确 well type</p>
<p class="calibre9">类型不正确 ill type</p>
<p class="calibre9">类型推导 type inference</p>
<p class="calibre9">列表 list</p>
<p class="calibre9">元组 tuple</p>
<p class="calibre9">表达式 expression</p>
<p class="calibre9">陈述 statement</p>
<p class="calibre9">分支 branche</p>
<p class="calibre9">严格求值 strict evaluation</p>
<p class="calibre9">非严格求值 non-strict evaluation</p>
<p class="calibre9">惰性求值 lazy evaluation</p>
<p class="calibre9">块 chunk</p>
<p class="calibre9">代换 substitution</p>
<h2 class="calibre14"><a id="convention.html._36" class="calibre7 pcalibre"></a>第三章</h2>
<p class="calibre9">类构造器 type constructor</p>
<p class="calibre9">值构造器 value constructor</p>
<p class="calibre9">类型别名 type synonym</p>
<p class="calibre9">代数数据类型 algebraic data type</p>
<p class="calibre9">备选 alternative</p>
<p class="calibre9">分支 case</p>
<p class="calibre9">复合数据/复合值 compound value</p>
<p class="calibre9">枚举类型 enumeration type</p>
<p class="calibre9">解构 deconstruction</p>
<p class="calibre9">字面 literal</p>
<p class="calibre9">结构递归 structural recursion</p>
<p class="calibre9">递归情形 recursive case</p>
<p class="calibre9">基本情形 base case</p>
<p class="calibre9">高阶 high-order</p>
<p class="calibre9">公式化 boilerplate</p>
<p class="calibre9">样板代码 boilerplate code</p>
<p class="calibre9">访问器函数 accessor function</p>
<h2 class="calibre14"><a id="convention.html._72" class="calibre7 pcalibre"></a>第四章</h2>
<p class="calibre9">折叠 fold</p>
<p class="calibre9">收集器 collection</p>
<p class="calibre9">主递归 primitive recursive</p>
<p class="calibre9">部分应用 paritial application</p>
<p class="calibre9">部分函数应用 paritial function application</p>
<p class="calibre9">柯里化 currying</p>
<p class="calibre9">组合函数 composition</p>
<p class="calibre9">内存泄漏 space leak</p>
<p class="calibre9">严格 strict</p>
<p class="calibre9">非严格 non-strict</p>
<h2 class="calibre14"><a id="convention.html._94" class="calibre7 pcalibre"></a>第五章</h2>
<p class="calibre9">导出 export</p>
<p class="calibre9">本地码 navie code</p>
<p class="calibre9">目标代码 object code</p>
<p class="calibre9">指令 directive</p>
<p class="calibre9">顶层 top-level</p>
<h2 class="calibre14"><a id="convention.html._106" class="calibre7 pcalibre"></a>第六章</h2>
<p class="calibre9">通用函数 generic function</p>
<p class="calibre9">部分有序 particular ordering</p>
<p class="calibre9">编译选项 pragma</p>
<p class="calibre9">重叠实例 overlapping instances</p>
<p class="calibre9">身份 identity</p>
<p class="calibre9">单一同态 monomorphism</p>
<h2 class="calibre14"><a id="convention.html._120" class="calibre7 pcalibre"></a>第十八章</h2>
<p class="calibre9">monad变换器 monad transformer</p>
<p class="calibre9">monad栈 monad transformer stack / monad stack</p>
<p class="calibre9">下层monad underlying monad</p>
<p class="calibre9">派生 derive / deriving</p>
<p class="calibre9">类型类 typeclass</p>
<p class="calibre9">抬举 lift</p>
<h2 class="calibre14"><a id="convention.html._134" class="calibre7 pcalibre"></a>第八章</h2>
<p class="calibre9">字符类 character class</p>
<p class="calibre9">多态 polymorphism</p>
<h2 class="calibre14"><a id="convention.html._140" class="calibre7 pcalibre"></a>第十九章</h2>
<p class="calibre9">错误处理 error handling</p>
<p class="calibre9">惰性求值 lazy evaluation</p>
<h2 class="calibre14"><a id="convention.html._146" class="calibre7 pcalibre"></a>第二十八章</h2>
<p class="calibre9">软件事务内存 Software transactional memory</p>
<p class="calibre9">一致性 consistent</p>
<p class="calibre9">条件变量 condition variable</p>
<p class="calibre9">条件竞争 race condition</p>
<p class="calibre9">死锁 deadlock</p>
<p class="calibre9">程序崩溃 corruption</p>
<p class="calibre9">细粒度 fineo-grained</p>
<p class="calibre9">簿记 book-keeping</p>
</div></div></div></div></div></div>
</div>

<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>
